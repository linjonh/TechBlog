---
layout: post
title: "游戏中帧同步的实现"
date: 2024-12-30 22:42:36 +0800
description: "简介帧同步是一种前后端数据同步的方式，一般应用于对实时性要求很高的网络游戏，常见于dota类和RTS"
keywords: "游戏帧同步例子代码"
categories: ['游戏开发']
tags: ['网络游戏', '游戏', '手游', '帧同步']
artid: "51363790"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51363790
    alt: "游戏中帧同步的实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51363790
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51363790
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     游戏中帧同步的实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3 id="简介">
     简介
    </h3>
    <p>
     帧同步是一种前后端数据同步的方式，一般应用于对实时性要求很高的网络游戏，常见于dota类和RTS类游戏，如端游中的dota，dota2，梦三国等；手游中的王者荣耀，自由之战等。
    </p>
    <h3 id="过程">
     过程
    </h3>
    <p>
     帧同步的过程可以简述为：
    </p>
    <ol>
     <li>
      各客户端实时上传操作指令集;
     </li>
     <li>
      服务端保存这些操作指令集，并在下一帧将其广播给所有客户端;
     </li>
     <li>
      客户端收到指令集后分别按帧序执行指令集中的操作。
     </li>
    </ol>
    <h3 id="示例">
     示例
    </h3>
    <p>
     目前我们正在做的是一款格斗手游，下面是我们项目中使用的同步算法主要伪代码：
    </p>
    <h4 id="1-各客户端实时上传操作指令集">
     1 各客户端实时上传操作指令集
    </h4>
    <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">op_fun</span><span class="hljs-params">()</span>:</span>
    net.send_lock_step_data(cmd)</code></pre>
    <h4 id="2-服务端保存指令集并在下一帧广播指令集">
     2 服务端保存指令集，并在下一帧广播指令集
    </h4>
    <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_lockstep_data</span><span class="hljs-params">(self, cmd)</span>:</span>
    <span class="hljs-string">"""保存操作指令"""</span>

    role_ctrl_data = self.lockstep_data.setdefault(<span class="hljs-string">'c'</span>, {})
    ctrl_data = role_ctrl_data.setdefault(self.uid, {})
    ctrl_data.update(cmd)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_lockstep</span><span class="hljs-params">(self, tid)</span>:</span>
    <span class="hljs-string">"""定时器响应函数，广播操作指令"""</span>

    self.lockstep_frame_index += <span class="hljs-number">1</span>  <span class="hljs-comment"># 帧序增加，开始帧同步时初始为0</span>
    self.broad(self.lockstep_data)
    self.lockstep_data = {<!-- --><span class="hljs-string">'i'</span>: self.lockstep_frame_index, <span class="hljs-string">'t'</span>: time.time()}  <span class="hljs-comment"># 更新数据，为下一帧做准备</span></code></pre>
    <h4 id="3-客户端处理收到的帧数据">
     3 客户端处理收到的帧数据
    </h4>
    <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_lock_step_data</span><span class="hljs-params">(self, data)</span>:</span>
    self.lockstep_datas.append(data)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span><span class="hljs-params">(self)</span>:</span>
    frame = self.lockstep_datas[<span class="hljs-number">0</span>][<span class="hljs-string">'i'</span>]
    <span class="hljs-keyword">if</span> frame == self.lockstep_frame:
        ls_data = self.lockstep_datas.pop(<span class="hljs-number">0</span>)
        ctrl_datas = ls_data.get(<span class="hljs-string">'c'</span>)
        <span class="hljs-keyword">if</span> ctrl_datas:
            uid_list = ctrl_datas.keys()
            uid_list.sort()
            <span class="hljs-keyword">for</span> uid <span class="hljs-keyword">in</span> uid_list:
                self.process_lockstep_ctrl_data(uid, ctrl_datas[uid])  <span class="hljs-comment"># 将操作指令给指定玩家</span>
        self.lockstep_frame += <span class="hljs-number">1</span></code></pre>
    <p>
     <strong>
      另外，帧同步还有一点比较重要，要保证各个客户端随机种子相同，各个实体排序也必须一样。
     </strong>
    </p>
    <h3 id="小结">
     小结
    </h3>
    <p>
     我们用的是乐观帧同步，服务端不会每帧等待每个客户端数据，防止其他客服端被开始；
     <br/>
     使用帧同步的好处是各个客户端可以保证数据的高度一致性，带来的问题是调试相当麻烦，需要添加很多的log，来判断具体是那一帧开始不同步，才能进一步的找出为什么不同步。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f787566656e6730393931:2f61727469636c652f64657461696c732f3531333633373930" class_="artid" style="display:none">
 </p>
</div>


