---
layout: post
title: "回顾一下Qt的多线程技术以及实际开发常用场景"
date: 2025-03-11 20:10:41 +0800
description: "在 Qt 中，多线程编程是一项重要的技术，它允许程序同时执行多个任务，从而提高程序的性能和响应能力。下面将详细介绍 Qt 中的多线程编程，包括相关类、使用方法以及实际运用场景例子。"
keywords: "回顾一下Qt的多线程技术以及实际开发常用场景"
categories: ['未分类']
tags: ['数据库', 'Qt', 'Lucene']
artid: "146187984"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146187984
    alt: "回顾一下Qt的多线程技术以及实际开发常用场景"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146187984
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146187984
cover: https://bing.ee123.net/img/rand?artid=146187984
image: https://bing.ee123.net/img/rand?artid=146187984
img: https://bing.ee123.net/img/rand?artid=146187984
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     回顾一下Qt的多线程技术以及实际开发常用场景
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Qt 中，多线程编程是一项重要的技术，它允许程序同时执行多个任务，从而提高程序的性能和响应能力。下面将详细介绍 Qt 中的多线程编程，包括相关类、使用方法以及实际运用场景例子。
    </p>
    <h4>
     1. Qt 中多线程编程的相关类
    </h4>
    <h5>
     <code>
      QThread
     </code>
    </h5>
    <p>
     <code>
      QThread
     </code>
     是 Qt 中用于创建和管理线程的核心类。通过继承
     <code>
      QThread
     </code>
     并重写其
     <code>
      run()
     </code>
     方法，可以在新线程中执行自定义的任务。以下是一个简单的示例：
    </p>
    <p>
    </p>
    <pre><code>#include &lt;QThread&gt;
#include &lt;QDebug&gt;

class MyThread : public QThread
{
    Q_OBJECT
public:
    explicit MyThread(QObject *parent = nullptr) : QThread(parent) {}

protected:
    void run() override {
        for (int i = 0; i &lt; 5; ++i) {
            qDebug() &lt;&lt; "Thread ID:" &lt;&lt; QThread::currentThreadId() &lt;&lt; "Count:" &lt;&lt; i;
            QThread::sleep(1);
        }
    }
};
</code></pre>
    <p>
    </p>
    <p>
     在上述代码中，
     <code>
      MyThread
     </code>
     类继承自
     <code>
      QThread
     </code>
     ，并重写了
     <code>
      run()
     </code>
     方法。在
     <code>
      run()
     </code>
     方法中，线程会每隔 1 秒输出一次当前线程的 ID 和计数。
    </p>
    <h5>
     <code>
      QRunnable
     </code>
     和
     <code>
      QThreadPool
     </code>
    </h5>
    <p>
    </p>
    <p>
     <code>
      QRunnable
     </code>
     是一个抽象基类，用于表示可以在线程池中运行的任务。
     <code>
      QThreadPool
     </code>
     是 Qt 提供的线程池类，它可以管理和复用线程，减少线程创建和销毁的开销。以下是一个使用
     <code>
      QRunnable
     </code>
     和
     <code>
      QThreadPool
     </code>
     的示例：
    </p>
    <p>
    </p>
    <pre><code>#include &lt;QRunnable&gt;
#include &lt;QThreadPool&gt;
#include &lt;QDebug&gt;

class MyRunnable : public QRunnable
{
public:
    void run() override {
        for (int i = 0; i &lt; 3; ++i) {
            qDebug() &lt;&lt; "Thread ID:" &lt;&lt; QThread::currentThreadId() &lt;&lt; "Count:" &lt;&lt; i;
            QThread::sleep(1);
        }
    }
};

// 使用示例
void useThreadPool() {
    QThreadPool pool;
    MyRunnable *runnable = new MyRunnable();
    runnable-&gt;setAutoDelete(true); // 任务执行完后自动删除
    pool.start(runnable);
    pool.waitForDone(); // 等待所有任务完成
}
</code></pre>
    <p>
    </p>
    <p>
     在上述代码中，
     <code>
      MyRunnable
     </code>
     类继承自
     <code>
      QRunnable
     </code>
     ，并重写了
     <code>
      run()
     </code>
     方法。
     <code>
      QThreadPool
     </code>
     会自动分配线程来执行
     <code>
      MyRunnable
     </code>
     任务。
    </p>
    <h4>
     2. 线程间通信
    </h4>
    <p>
    </p>
    <p>
     在多线程编程中，线程间通信是非常重要的。Qt 提供了信号和槽机制来实现线程间的安全通信。以下是一个示例：
    </p>
    <p>
    </p>
    <pre><code>#include &lt;QThread&gt;
#include &lt;QObject&gt;
#include &lt;QDebug&gt;

// 工作线程类
class Worker : public QObject
{
    Q_OBJECT
public:
    explicit Worker(QObject *parent = nullptr) : QObject(parent) {}

signals:
    void resultReady(const QString &amp;result);

public slots:
    void doWork() {
        QString result = "Work done";
        emit resultReady(result);
    }
};

// 主线程类
class Controller : public QObject
{
    Q_OBJECT
public:
    explicit Controller(QObject *parent = nullptr) : QObject(parent) {
        worker = new Worker();
        thread = new QThread();
        worker-&gt;moveToThread(thread);

        connect(thread, &amp;QThread::started, worker, &amp;Worker::doWork);
        connect(worker, &amp;Worker::resultReady, this, &amp;Controller::handleResults);
        connect(worker, &amp;Worker::resultReady, thread, &amp;QThread::quit);
        connect(worker, &amp;Worker::resultReady, worker, &amp;Worker::deleteLater);
        connect(thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);

        thread-&gt;start();
    }

public slots:
    void handleResults(const QString &amp;result) {
        qDebug() &lt;&lt; "Received result:" &lt;&lt; result;
    }

private:
    Worker *worker;
    QThread *thread;
};
</code></pre>
    <p>
    </p>
    <p>
     在上述代码中，
     <code>
      Worker
     </code>
     类在新线程中执行任务，并通过信号
     <code>
      resultReady
     </code>
     向主线程发送结果。
     <code>
      Controller
     </code>
     类负责管理线程和接收结果。
    </p>
    <h4>
     3. 实际运用场景例子
    </h4>
    <h5>
     网络请求
    </h5>
    <p>
    </p>
    <p>
     在开发网络应用程序时，网络请求可能会阻塞主线程，导致界面卡顿。使用多线程可以将网络请求放在新线程中执行，避免阻塞主线程。以下是一个简单的示例：
    </p>
    <p>
    </p>
    <pre><code>#include &lt;QThread&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QDebug&gt;

class NetworkWorker : public QObject
{
    Q_OBJECT
public:
    explicit NetworkWorker(QObject *parent = nullptr) : QObject(parent) {
        manager = new QNetworkAccessManager(this);
        connect(manager, &amp;QNetworkAccessManager::finished, this, &amp;NetworkWorker::handleNetworkReply);
    }

signals:
    void networkDataReceived(const QByteArray &amp;data);

public slots:
    void performNetworkRequest(const QUrl &amp;url) {
        QNetworkRequest request(url);
        manager-&gt;get(request);
    }

private slots:
    void handleNetworkReply(QNetworkReply *reply) {
        if (reply-&gt;error() == QNetworkReply::NoError) {
            QByteArray data = reply-&gt;readAll();
            emit networkDataReceived(data);
        } else {
            qDebug() &lt;&lt; "Network error:" &lt;&lt; reply-&gt;errorString();
        }
        reply-&gt;deleteLater();
    }

private:
    QNetworkAccessManager *manager;
};

// 使用示例
void performNetworkTask() {
    NetworkWorker *worker = new NetworkWorker();
    QThread *thread = new QThread();
    worker-&gt;moveToThread(thread);

    connect(thread, &amp;QThread::started, [worker]() {
        worker-&gt;performNetworkRequest(QUrl("https://www.example.com"));
    });
    connect(worker, &amp;NetworkWorker::networkDataReceived, [](const QByteArray &amp;data) {
        qDebug() &lt;&lt; "Received data:" &lt;&lt; data;
    });
    connect(worker, &amp;NetworkWorker::networkDataReceived, thread, &amp;QThread::quit);
    connect(worker, &amp;NetworkWorker::networkDataReceived, worker, &amp;NetworkWorker::deleteLater);
    connect(thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);

    thread-&gt;start();
}
</code></pre>
    <p>
    </p>
    <p>
     在上述代码中，
     <code>
      NetworkWorker
     </code>
     类在新线程中执行网络请求，并通过信号
     <code>
      networkDataReceived
     </code>
     将请求结果发送给主线程。
    </p>
    <h5>
     大数据处理
    </h5>
    <p>
    </p>
    <p>
     在处理大量数据时，如文件读写、图像处理等，可能会消耗大量的时间。使用多线程可以将数据处理任务分配到多个线程中并行执行，提高处理效率。以下是一个简单的文件读取示例：
    </p>
    <p>
    </p>
    <pre><code>#include &lt;QThread&gt;
#include &lt;QFile&gt;
#include &lt;QTextStream&gt;
#include &lt;QDebug&gt;

class FileReader : public QObject
{
    Q_OBJECT
public:
    explicit FileReader(QObject *parent = nullptr) : QObject(parent) {}

signals:
    void fileReadFinished(const QString &amp;content);

public slots:
    void readFile(const QString &amp;fileName) {
        QFile file(fileName);
        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QTextStream in(&amp;file);
            QString content = in.readAll();
            file.close();
            emit fileReadFinished(content);
        } else {
            qDebug() &lt;&lt; "Failed to open file:" &lt;&lt; fileName;
        }
    }
};

// 使用示例
void performFileReadTask() {
    FileReader *reader = new FileReader();
    QThread *thread = new QThread();
    reader-&gt;moveToThread(thread);

    connect(thread, &amp;QThread::started, [reader]() {
        reader-&gt;readFile("test.txt");
    });
    connect(reader, &amp;FileReader::fileReadFinished, [](const QString &amp;content) {
        qDebug() &lt;&lt; "File content:" &lt;&lt; content;
    });
    connect(reader, &amp;FileReader::fileReadFinished, thread, &amp;QThread::quit);
    connect(reader, &amp;FileReader::fileReadFinished, reader, &amp;FileReader::deleteLater);
    connect(thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);

    thread-&gt;start();
}
</code></pre>
    <p>
    </p>
    <p>
     在上述代码中，
     <code>
      FileReader
     </code>
     类在新线程中读取文件内容，并通过信号
     <code>
      fileReadFinished
     </code>
     将文件内容发送给主线程。
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f68786a5f3638362f:61727469636c652f64657461696c732f313436313837393834" class_="artid" style="display:none">
 </p>
</div>


