---
layout: post
title: "实时读取另一个串口发来的返回数据"
date: 2025-03-06 18:42:50 +0800
description: "txtBack->append(QStringLiteral(\">> 未知响应码: 0x%1\").arg(resultCode, 2, 16, QLatin1Char('0')));txtBack->append(QStringLiteral(\">> 未知响应码: 0x%1\").arg(resultCode, 2, 16, QLatin1Char('0')));\"是\" : \"否\"));txtBack->append(QStringLiteral(\"使能状态: %1\").arg(enableStatus?"
keywords: "实时读取另一个串口发来的返回数据"
categories: ['未分类']
tags: ['开发语言', 'Kotlin', 'Android']
artid: "146077474"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077474
    alt: "实时读取另一个串口发来的返回数据"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077474
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077474
cover: https://bing.ee123.net/img/rand?artid=146077474
image: https://bing.ee123.net/img/rand?artid=146077474
img: https://bing.ee123.net/img/rand?artid=146077474
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     实时读取另一个串口发来的返回数据
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      在您提供的代码基础上，我们可以直接在 `StepperDriver` 类中实现解析回零状态和电机状态标志位的功能，并将解析结果展示在 `txtBack` 中。以下是具体的实现方案：
     </p>
     <p>
      ---
     </p>
     <p>
      ### **1. 修改 `StepperDriver` 类**
     </p>
     <p>
      #### **1.1 添加状态解析方法**
      <br/>
      在 `StepperDriver` 类中，我们已经有了 `readZeroReturnStatus` 和 `readMotorStatusFlags` 方法，这些方法已经实现了状态解析功能。我们需要确保它们的解析结果能够正确显示在 `txtBack` 中。
     </p>
     <p>
      #### **1.2 修改 `readZeroReturnStatus` 方法**
      <br/>
      确保 `readZeroReturnStatus` 方法将解析结果追加到 `txtBack` 中：
     </p>
     <p>
      ```cpp
      <br/>
      bool StepperDriver::readZeroReturnStatus(char slaveAddress, QTextEdit *txtBack)
      <br/>
      {
      <!-- -->
      <br/>
      // 构建查询指令
      <br/>
      QByteArray command;
      <br/>
      command.append(slaveAddress);
      <br/>
      command.append(0x3B);
      <br/>
      command.append(0x6B);
     </p>
     <p>
      // 显示发送指令
      <br/>
      txtBack-&gt;append(QStringLiteral("[发送] 零点回归状态查询指令: ")
      <br/>
      + command.toHex(' ').toUpper());
     </p>
     <p>
      // 发送指令
      <br/>
      serialPort-&gt;write(command);
      <br/>
      if (!serialPort-&gt;waitForBytesWritten(1000)) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：指令发送超时");
      <br/>
      return false;
      <br/>
      }
     </p>
     <p>
      // 等待并读取响应
      <br/>
      QByteArray response;
      <br/>
      while (serialPort-&gt;waitForReadyRead(500)) {
      <!-- -->
      <br/>
      response += serialPort-&gt;readAll();
      <br/>
      if (response.length() &gt;= 4) break; // 最小响应长度4字节
      <br/>
      }
     </p>
     <p>
      // 显示原始响应
      <br/>
      txtBack-&gt;append(QStringLiteral("[接收] 原始响应数据: ")
      <br/>
      + response.toHex(' ').toUpper());
     </p>
     <p>
      // 基础响应验证
      <br/>
      if (response.size() &lt; 4) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：响应数据长度不足");
      <br/>
      return false;
      <br/>
      }
     </p>
     <p>
      // 地址和功能码验证
      <br/>
      if (static_cast&lt;quint8&gt;(response[0]) != static_cast&lt;quint8&gt;(slaveAddress) ||
      <br/>
      static_cast&lt;quint8&gt;(response[1]) != 0x3B) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：响应头验证失败");
      <br/>
      return false;
      <br/>
      }
     </p>
     <p>
      // 解析状态字节（第3字节）
      <br/>
      const quint8 statusByte = static_cast&lt;quint8&gt;(response[2]);
      <br/>
      txtBack-&gt;append(QStringLiteral("零点回归状态字节: 0x%1")
      <br/>
      .arg(statusByte, 2, 16, QLatin1Char('0')));
     </p>
     <p>
      // 标志位解析
      <br/>
      const bool encoderReady = (statusByte &amp; 0x01);
      <br/>
      const bool calibrationReady = (statusByte &amp; 0x02);
      <br/>
      const bool zeroingActive = (statusByte &amp; 0x04);
      <br/>
      const bool zeroingFailed = (statusByte &amp; 0x08);
     </p>
     <p>
      txtBack-&gt;append(QStringLiteral("编码器就绪: %1").arg(encoderReady ? "是" : "否"));
      <br/>
      txtBack-&gt;append(QStringLiteral("校准表就绪: %1").arg(calibrationReady ? "是" : "否"));
      <br/>
      txtBack-&gt;append(QStringLiteral("正在归零: %1").arg(zeroingActive ? "是" : "否"));
      <br/>
      txtBack-&gt;append(QStringLiteral("归零失败: %1").arg(zeroingFailed ? "是" : "否"));
     </p>
     <p>
      // 校验结果状态（第4字节）
      <br/>
      const quint8 resultCode = static_cast&lt;quint8&gt;(response[3]);
      <br/>
      switch (resultCode) {
      <!-- -->
      <br/>
      case 0x02:
      <br/>
      txtBack-&gt;append("&gt;&gt; 操作成功：零点回归状态读取成功");
      <br/>
      return true;
      <br/>
      case 0xE2:
      <br/>
      txtBack-&gt;append("&gt;&gt; 操作失败：条件不满足");
      <br/>
      return false;
      <br/>
      case 0xEE:
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：无效指令");
      <br/>
      return false;
      <br/>
      default:
      <br/>
      txtBack-&gt;append(QStringLiteral("&gt;&gt; 未知响应码: 0x%1").arg(resultCode, 2, 16, QLatin1Char('0')));
      <br/>
      return false;
      <br/>
      }
      <br/>
      }
      <br/>
      ```
     </p>
     <p>
      #### **1.3 修改 `readMotorStatusFlags` 方法**
      <br/>
      确保 `readMotorStatusFlags` 方法将解析结果追加到 `txtBack` 中：
     </p>
     <p>
      ```cpp
      <br/>
      bool StepperDriver::readMotorStatusFlags(char slaveAddress, QTextEdit *txtBack)
      <br/>
      {
      <!-- -->
      <br/>
      // 构建查询指令
      <br/>
      QByteArray command;
      <br/>
      command.append(slaveAddress);
      <br/>
      command.append(0x3A);
      <br/>
      command.append(0x6B);
     </p>
     <p>
      // 显示发送指令
      <br/>
      txtBack-&gt;append(QStringLiteral("[发送] 电机状态标志查询指令: ")
      <br/>
      + command.toHex(' ').toUpper());
     </p>
     <p>
      // 发送指令
      <br/>
      serialPort-&gt;write(command);
      <br/>
      if (!serialPort-&gt;waitForBytesWritten(1000)) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：指令发送超时");
      <br/>
      return false;
      <br/>
      }
     </p>
     <p>
      // 等待并读取响应
      <br/>
      QByteArray response;
      <br/>
      while (serialPort-&gt;waitForReadyRead(500)) {
      <!-- -->
      <br/>
      response += serialPort-&gt;readAll();
      <br/>
      if (response.length() &gt;= 4) break; // 最小响应长度4字节
      <br/>
      }
     </p>
     <p>
      // 显示原始响应
      <br/>
      txtBack-&gt;append(QStringLiteral("[接收] 原始响应数据: ")
      <br/>
      + response.toHex(' ').toUpper());
     </p>
     <p>
      // 基础响应验证
      <br/>
      if (response.size() &lt; 4) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：响应数据长度不足");
      <br/>
      return false;
      <br/>
      }
     </p>
     <p>
      // 地址和功能码验证
      <br/>
      if (static_cast&lt;quint8&gt;(response[0]) != static_cast&lt;quint8&gt;(slaveAddress) ||
      <br/>
      static_cast&lt;quint8&gt;(response[1]) != 0x3A) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：响应头验证失败");
      <br/>
      return false;
      <br/>
      }
     </p>
     <p>
      // 解析状态字节（第3字节）
      <br/>
      const quint8 statusByte = static_cast&lt;quint8&gt;(response[2]);
      <br/>
      txtBack-&gt;append(QStringLiteral("电机状态标志字节: 0x%1")
      <br/>
      .arg(statusByte, 2, 16, QLatin1Char('0')));
     </p>
     <p>
      // 标志位解析
      <br/>
      const bool enableStatus = (statusByte &amp; 0x01);     // bit0: 使能状态
      <br/>
      const bool positionReached = (statusByte &amp; 0x02);  // bit1: 位置到达
      <br/>
      const bool stallDetected = (statusByte &amp; 0x04);    // bit2: 堵转检测
      <br/>
      const bool stallProtection = (statusByte &amp; 0x08);  // bit3: 堵转保护
     </p>
     <p>
      txtBack-&gt;append(QStringLiteral("使能状态: %1").arg(enableStatus ? "有效" : "无效"));
      <br/>
      txtBack-&gt;append(QStringLiteral("位置到达: %1").arg(positionReached ? "是" : "否"));
      <br/>
      txtBack-&gt;append(QStringLiteral("堵转检测: %1").arg(stallDetected ? "触发" : "正常"));
      <br/>
      txtBack-&gt;append(QStringLiteral("堵转保护: %1").arg(stallProtection ? "激活" : "关闭"));
     </p>
     <p>
      // 校验结果状态（第4字节）
      <br/>
      const quint8 resultCode = static_cast&lt;quint8&gt;(response[3]);
      <br/>
      switch (resultCode) {
      <!-- -->
      <br/>
      case 0x02:
      <br/>
      txtBack-&gt;append("&gt;&gt; 操作成功：状态标志读取成功");
      <br/>
      return true;
      <br/>
      case 0xE2:
      <br/>
      txtBack-&gt;append("&gt;&gt; 操作失败：设备未就绪");
      <br/>
      return false;
      <br/>
      case 0xEE:
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：无效状态查询指令");
      <br/>
      return false;
      <br/>
      default:
      <br/>
      txtBack-&gt;append(QStringLiteral("&gt;&gt; 未知响应码: 0x%1").arg(resultCode, 2, 16, QLatin1Char('0')));
      <br/>
      return false;
      <br/>
      }
      <br/>
      }
      <br/>
      ```
     </p>
     <p>
      ---
     </p>
     <p>
      ### **2. 测试功能**
     </p>
     <p>
      #### **2.1 发送读状态命令**
      <br/>
      在程序中调用 `readZeroReturnStatus` 和 `readMotorStatusFlags` 方法，例如：
     </p>
     <p>
      ```cpp
      <br/>
      // 读取回零状态
      <br/>
      stepperDriver-&gt;readZeroReturnStatus(0x01, ui-&gt;txtBack);
     </p>
     <p>
      // 读取电机状态
      <br/>
      stepperDriver-&gt;readMotorStatusFlags(0x01, ui-&gt;txtBack);
      <br/>
      ```
     </p>
     <p>
      #### **2.2 预期结果**
      <br/>
      假设设备返回以下数据包：
      <br/>
      - 回零状态：`01 3B 03 6B`
      <br/>
      - 电机状态：`01 3A 05 6B`
     </p>
     <p>
      则 `txtBack` 中显示：
      <br/>
      ```
      <br/>
      [发送] 零点回归状态查询指令: 01 3B 6B
      <br/>
      [接收] 原始响应数据: 01 3B 03 6B
      <br/>
      零点回归状态字节: 0x03
      <br/>
      编码器就绪: 是
      <br/>
      校准表就绪: 是
      <br/>
      正在归零: 否
      <br/>
      归零失败: 否
      <br/>
      &gt;&gt; 操作成功：零点回归状态读取成功
     </p>
     <p>
      [发送] 电机状态标志查询指令: 01 3A 6B
      <br/>
      [接收] 原始响应数据: 01 3A 05 6B
      <br/>
      电机状态标志字节: 0x05
      <br/>
      使能状态: 有效
      <br/>
      位置到达: 否
      <br/>
      堵转检测: 是
      <br/>
      堵转保护: 否
      <br/>
      &gt;&gt; 操作成功：状态标志读取成功
      <br/>
      ```
     </p>
     <p>
      ---
     </p>
     <p>
      ### **3. 扩展功能**
     </p>
     <p>
      #### **3.1 添加时间戳**
      <br/>
      在显示状态信息时，添加时间戳：
     </p>
     <p>
      ```cpp
      <br/>
      QString timestamp = QDateTime::currentDateTime().toString("hh:mm:ss");
      <br/>
      txtBack-&gt;append(QString("[%1] ").arg(timestamp) + message);
      <br/>
      ```
     </p>
     <p>
      #### **3.2 支持错误命令返回**
      <br/>
      在解析逻辑中添加对错误命令返回的处理：
     </p>
     <p>
      ```cpp
      <br/>
      if (static_cast&lt;quint8&gt;(response[2]) == 0xEE) {
      <!-- -->
      <br/>
      txtBack-&gt;append("&gt;&gt; 错误：无效命令");
      <br/>
      return false;
      <br/>
      }
      <br/>
      ```
     </p>
     <p>
      ---
     </p>
     <p>
      ### **4. 完整代码示例**
     </p>
     <p>
      #### **StepperDriver.h**
      <br/>
      ```cpp
      <br/>
      class StepperDriver : public QObject
      <br/>
      {
      <!-- -->
      <br/>
      Q_OBJECT
      <br/>
      public:
      <br/>
      explicit StepperDriver(QObject *parent = nullptr);
      <br/>
      QSerialPort *getSerialPort() const;
      <br/>
      void on_btnOpenPort_clicked();
      <br/>
      bool sendCommand(const QByteArray &amp;command, const QString &amp;desc, QString successMsg, QTextEdit *txtBack);
      <br/>
      bool enableMotor(char slaveAddress, char enableStatus, QTextEdit *txtBack);
      <br/>
      bool setPositionControl(char slaveAddress, char direction, uint16_t speed, char acceleration,
      <br/>
      uint32_t pulseCount, char mode, char multiSync, QTextEdit *txtBack);
      <br/>
      bool emergencyStop(char slaveAddress, char multiSync, QTextEdit *txtBack);
      <br/>
      bool readZeroReturnStatus(char slaveAddress, QTextEdit *txtBack);
      <br/>
      bool forceAbortZeroReturn(char slaveAddress, QTextEdit *txtBack);
      <br/>
      bool triggerZeroReturn(char slaveAddress, char zeroReturnMode, char multiSync, QTextEdit *txtBack);
      <br/>
      bool readMotorCurrentPosition(char slaveAddress, QTextEdit *txtBack);
      <br/>
      bool readMotorStatusFlags(char slaveAddress, QTextEdit *txtBack);
     </p>
     <p>
      private:
      <br/>
      QSerialPort *serialPort;
      <br/>
      };
      <br/>
      ```
     </p>
     <p>
      #### **MainWindow.cpp**
      <br/>
      ```cpp
      <br/>
      void MainWindow::on_btnReadZeroReturnStatus_clicked()
      <br/>
      {
      <!-- -->
      <br/>
      stepperDriver-&gt;readZeroReturnStatus(0x01, ui-&gt;txtBack);
      <br/>
      }
     </p>
     <p>
      void MainWindow::on_btnReadMotorStatus_clicked()
      <br/>
      {
      <!-- -->
      <br/>
      stepperDriver-&gt;readMotorStatusFlags(0x01, ui-&gt;txtBack);
      <br/>
      }
      <br/>
      ```
     </p>
     <p>
      ---
     </p>
     <p>
      通过以上修改，您的程序可以解析并显示回零状态和电机状态标志位的内容。如果仍有问题，请提供具体的错误信息或日志，以便进一步分析。
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f59793436383534352f:61727469636c652f64657461696c732f313436303737343734" class_="artid" style="display:none">
 </p>
</div>


