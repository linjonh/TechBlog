---
layout: post
title: "C-STL算法函数-应用及其操作实现"
date: 2025-03-16 00:00:00 +0800
description: "C++ STL算法函数 —— 应用及其操作实现"
keywords: "C++ STL算法函数 —— 应用及其操作实现"
categories: ['算法', 'C']
tags: ['算法', '数据结构', 'C']
artid: "146191023"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146191023
    alt: "C-STL算法函数-应用及其操作实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146191023
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146191023
cover: https://bing.ee123.net/img/rand?artid=146191023
image: https://bing.ee123.net/img/rand?artid=146191023
img: https://bing.ee123.net/img/rand?artid=146191023
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ STL算法函数 —— 应用及其操作实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <strong>
      一、STL算法函数分类概述
     </strong>
    </h2>
    <p>
     STL算法库提供了大量实用函数，按功能可分为以下五类：
    </p>
    <hr/>
    <h3>
     <strong>
      1. 不修改序列的操作
     </strong>
    </h3>
    <p>
     <strong>
      定义
     </strong>
     ：这些算法不会改变容器中的元素，仅对数据进行查询或统计。
     <br/>
     <strong>
      典型函数
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         find(first, last, value)
        </code>
       </td>
       <td>
        在区间
        <code>
         [first, last)
        </code>
        内顺序查找值为
        <code>
         value
        </code>
        的元素。
       </td>
       <td>
        <code>
         find(a.begin(), a.end(), 5)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         count(first, last, value)
        </code>
       </td>
       <td>
        统计区间内值为
        <code>
         value
        </code>
        的元素个数。
       </td>
       <td>
        <code>
         count(a.begin(), a.end(), 3)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         all_of(first, last, pred)
        </code>
       </td>
       <td>
        检查区间内所有元素是否满足谓词
        <code>
         pred
        </code>
        。
       </td>
       <td>
        <code>
         all_of(a.begin(), a.end(), is_positive)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         accumulate(first, last, init)
        </code>
       </td>
       <td>
        对区间内元素进行累加，初始值为
        <code>
         init
        </code>
        。
       </td>
       <td>
        <code>
         accumulate(a.begin(), a.end(), 0)
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        搜索操作
       </strong>
       ：如
       <code>
        find
       </code>
       、
       <code>
        search
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        批量操作
       </strong>
       ：如
       <code>
        for_each
       </code>
       （对每个元素执行操作）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        折叠操作
       </strong>
       ：如
       <code>
        accumulate
       </code>
       （将元素通过运算折叠为一个值）。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      2. 修改序列的操作
     </strong>
    </h3>
    <p>
     <strong>
      定义
     </strong>
     ：这些算法会直接修改容器中的元素或顺序。
     <strong>
      有复制操作、交换操作、生成操作、移除操作、顺序变更操作、采样操作。
     </strong>
     <br/>
     <strong>
      典型函数
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         copy(src_begin, src_end, dest)
        </code>
       </td>
       <td>
        复制源区间元素到目标位置。
       </td>
       <td>
        <code>
         copy(a.begin(), a.end(), b.begin())
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         swap(a, b)
        </code>
       </td>
       <td>
        交换两个元素的值。
       </td>
       <td>
        <code>
         swap(a[0], a[1])
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         remove(first, last, value)
        </code>
       </td>
       <td>
        移除区间内所有值为
        <code>
         value
        </code>
        的元素（需配合
        <code>
         erase
        </code>
        使用）。
       </td>
       <td>
        <code>
         a.erase(remove(a.begin(), a.end(), 5), a.end())
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         reverse(first, last)
        </code>
       </td>
       <td>
        翻转区间内元素的顺序。
       </td>
       <td>
        <code>
         reverse(a.begin(), a.end())
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        复制操作
       </strong>
       ：如
       <code>
        copy
       </code>
       、
       <code>
        copy_n
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        移除操作
       </strong>
       ：如
       <code>
        remove
       </code>
       、
       <code>
        remove_if
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        顺序变更操作
       </strong>
       ：如
       <code>
        reverse
       </code>
       、
       <code>
        rotate
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      3. 排序和相关操作
     </strong>
    </h3>
    <p>
     <strong>
      定义
     </strong>
     ：涉及排序、划分、堆操作等与元素顺序相关的算法。
     <strong>
      有划分操作、排序操作、二分搜索操作（在已划分范围上）、集合操作（在已排序范围上）、归并操作（在已排序范围上）、堆操作、最大/最小操作、字典序比较操作、排列操作。
     </strong>
     <br/>
     <strong>
      典型函数
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         sort(first, last, cmp)
        </code>
       </td>
       <td>
        对区间进行排序（默认升序）。
       </td>
       <td>
        <code>
         sort(a.begin(), a.end())
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         binary_search(first, last, value)
        </code>
       </td>
       <td>
        在已排序区间内进行二分查找。
       </td>
       <td>
        <code>
         binary_search(a.begin(), a.end(), 10)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         nth_element(first, nth, last)
        </code>
       </td>
       <td>
        将第
        <code>
         n
        </code>
        大的元素放到正确位置，左侧均小于它，右侧均大于它。
       </td>
       <td>
        <code>
         nth_element(a.begin(), a.begin()+3, a.end())
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         make_heap(first, last)
        </code>
       </td>
       <td>
        将区间转换为堆结构。
       </td>
       <td>
        <code>
         make_heap(a.begin(), a.end())
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        划分操作
       </strong>
       ：如
       <code>
        partition
       </code>
       （按条件划分元素）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        集合操作
       </strong>
       ：如
       <code>
        set_union
       </code>
       （求并集，需已排序）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排列操作
       </strong>
       ：如
       <code>
        next_permutation
       </code>
       （生成下一个排列）。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      4. 数值运算
     </strong>
    </h3>
    <p>
     <strong>
      定义
     </strong>
     ：与数学计算相关的算法，需包含
     <code>
      &lt;numeric&gt;
     </code>
     头文件。
     <br/>
     <strong>
      典型函数
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         iota(first, last, start)
        </code>
       </td>
       <td>
        用连续递增的值填充区间，从
        <code>
         start
        </code>
        开始。
       </td>
       <td>
        <code>
         iota(a.begin(), a.end(), 1)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         inner_product(a_begin, a_end, b_begin, init)
        </code>
       </td>
       <td>
        计算两个序列的内积（点积）。
       </td>
       <td>
        <code>
         inner_product(a.begin(), a.end(), b.begin(), 0)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         partial_sum(first, last, dest)
        </code>
       </td>
       <td>
        计算前缀和并写入目标位置。
       </td>
       <td>
        <code>
         partial_sum(a.begin(), a.end(), b.begin())
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       此类算法通常用于数学计算，如求和、乘积、差值等。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      5. 在未初始化内存上的操作
     </strong>
    </h3>
    <p>
     <strong>
      定义
     </strong>
     ：直接在未初始化的内存区域构造对象，需包含
     <code>
      &lt;memory&gt;
     </code>
     头文件。
     <br/>
     <strong>
      典型函数
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         uninitialized_copy(src_begin, src_end, dest)
        </code>
       </td>
       <td>
        将源区间复制到未初始化的内存。
       </td>
       <td>
        <code>
         uninitialized_copy(a.begin(), a.end(), raw_mem)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         uninitialized_fill(first, last, value)
        </code>
       </td>
       <td>
        在未初始化内存区间填充
        <code>
         value
        </code>
        。
       </td>
       <td>
        <code>
         uninitialized_fill(a.begin(), a.end(), 0)
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       这些函数用于低级内存管理，常见于自定义容器实现或性能优化场景。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     STL算法分类清晰，覆盖了从数据查询、修改到数学运算和内存管理的广泛需求。在算法竞赛中，合理使用这些函数可以大幅简化代码并提高效率。例如：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        快速查找
       </strong>
       ：使用
       <code>
        lower_bound
       </code>
       和
       <code>
        binary_search
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        高效排序
       </strong>
       ：结合
       <code>
        sort
       </code>
       和
       <code>
        nth_element
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        灵活修改
       </strong>
       ：通过
       <code>
        copy
       </code>
       和
       <code>
        reverse
       </code>
       调整数据顺序。
      </p>
     </li>
    </ul>
    <h2>
    </h2>
    <h2>
     二、算法函数
    </h2>
    <p>
     <strong>
      下面简要介绍一些在算法竞赛中常用的函数：
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数
       </th>
       <th>
        功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         unique(first, last)
        </strong>
       </td>
       <td>
        去除容器中相邻的重复元素，所以一般需要先排序，然后用
        <code>
         unique
        </code>
        去重。返回值为指向去重后最后一个不同元素的迭代器。注意原容器大小不变，末尾的重复元素可以用
        <code>
         erase()
        </code>
        删除。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         nth_element(a.begin(), a.begin() + mid, a.end(), cmp)
        </strong>
       </td>
       <td>
        按指定范围进行分类，找出序列中第
        <code>
         n
        </code>
        大的元素，使其左边均为小于它的数，右边均为大于它的数。该函数一般用于求第
        <code>
         k
        </code>
        小的数。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         binary_search(a.begin(), a.end(), value)
        </strong>
       </td>
       <td>
        在已经排序的序列上做二分查找，需要先用
        <code>
         sort()
        </code>
        排序。
        <code>
         value
        </code>
        为需要查找的值，如果找到，返回
        <code>
         true
        </code>
        ，否则返回
        <code>
         false
        </code>
        。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         lower_bound(a.begin(), a.end(), x)
        </strong>
       </td>
       <td>
        在一个有序序列中进行二分查找，返回指向第一个
        <strong>
         大于或等于
        </strong>
        <code>
         x
        </code>
        的元素的位置。如果不存在这样的元素，则返回尾迭代器。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         upper_bound(a.begin(), a.end(), x)
        </strong>
       </td>
       <td>
        在一个有序序列中进行二分查找，返回指向第一个
        <strong>
         大于
        </strong>
        <code>
         x
        </code>
        的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         next_permutation(a.begin(), a.end())
        </strong>
       </td>
       <td>
        将当前排列更改为全排列中的下一个排列。如果当前排列已经是全排列中的最后一个排列，该函数返回
        <code>
         false
        </code>
        ，并将排列更改为全排列中的第一个排列。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         prev_permutation()
        </strong>
       </td>
       <td>
        将当前排列更改为全排列中的上一个排列，用法与
        <code>
         next_permutation()
        </code>
        相同。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         max(), min()
        </strong>
       </td>
       <td>
        查找最大、最小值。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         swap()
        </strong>
       </td>
       <td>
        交换两个元素的值。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         find(a.begin(), a.end(), value)
        </strong>
       </td>
       <td>
        顺序查找，
        <code>
         value
        </code>
        为需要查找的值。如果找到，返回指向该元素的迭代器；否则返回尾迭代器。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         reverse(a.begin(), a.end())
        </strong>
       </td>
       <td>
        翻转数组、字符串。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         sort(a.begin(), a.end(), cmp)
        </strong>
       </td>
       <td>
        排序，
        <code>
         cmp
        </code>
        为自定义的比较函数。如果没有提供
        <code>
         cmp
        </code>
        ，默认按升序排序。
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     详细说明：
    </h3>
    <h4>
     1.
     <code>
      unique(first, last)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：去除相邻的重复元素，通常需要先对容器进行排序。返回的迭代器指向去重后的最后一个元素，原容器的大小不变，末尾的重复元素可以通过
     <code>
      erase()
     </code>
     删除。
    </p>
    <p>
     <code>
      std::unique
     </code>
     函数的作用是
     <span style="color:#fe2c24">
      <strong>
       去除相邻的重复元素，但它并不会改变容器的大小。它只是将不重复的元素移动到容器的前面，并返回一个指向去重后最后一个元素的迭代器。
      </strong>
     </span>
     <strong>
      去重后的元素范围是从
      <code>
       begin()
      </code>
      到
      <code>
       unique()
      </code>
      返回的迭代器之间的部分，而剩下的部分（从返回的迭代器到
      <code>
       end()
      </code>
      ）仍然包含原来的元素，这些元素是未定义的（通常是重复元素的残留）。
     </strong>
    </p>
    <h4>
     为什么会有重复元素？
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         std::unique
        </code>
        只去除相邻的重复元素
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果容器中有多个相同的元素，但它们不相邻，
         <code>
          std::unique
         </code>
         不会去除它们。
        </p>
       </li>
       <li>
        <p>
         例如，
         <code>
          {1, 2, 2, 3, 2, 4}
         </code>
         ，
         <code>
          std::unique
         </code>
         只会将相邻的
         <code>
          2
         </code>
         去除，结果是
         <code>
          {1, 2, 3, 2, 4}
         </code>
         ，后面的
         <code>
          2
         </code>
         仍然存在。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         std::unique
        </code>
        不会改变容器的大小
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         它只是将不重复的元素移动到容器的前面，并返回一个指向去重后最后一个元素的迭代器。
        </p>
       </li>
       <li>
        <p>
         剩下的部分（从返回的迭代器到
         <code>
          end()
         </code>
         ）仍然包含原来的元素，这些元素是未定义的（通常是重复元素的残留）。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     为什么需要
     <code>
      erase
     </code>
     ？
    </h4>
    <ul>
     <li>
      <p>
       为了真正删除这些残留的重复元素，我们需要使用
       <code>
        erase
       </code>
       函数，将去重后的范围之后的元素删除。
      </p>
     </li>
     <li>
      <p>
       如果不使用
       <code>
        erase
       </code>
       ，容器的大小不会改变，末尾的残留元素仍然存在。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 2, 3, 2, 4, 4, 5};

    // 先排序，确保相同的元素相邻
    std::sort(vec.begin(), vec.end());

    // 使用 unique 去除相邻的重复元素
    auto last = std::unique(vec.begin(), vec.end());

    // 使用 erase 删除末尾的残留元素
    vec.erase(last, vec.end());

    // 输出去重后的结果
    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }

    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：1 2 3 4 5
    </p>
    <hr/>
    <h4>
     2.
     <code>
      nth_element(a.begin(), a.begin() + mid, a.end(), cmp)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：在序列中找到第
     <code>
      n
     </code>
     大的元素，并将其放置在正确的位置，使得左边的元素都小于它，右边的元素都大于它。常用于快速找到第
     <code>
      k
     </code>
     小的元素。
    </p>
    <p>
     在
     <code>
      std::nth_element
     </code>
     函数中，
     <code>
      cmp
     </code>
     参数是一个可选的比较函数，用于定义元素的排序规则。如果不提供
     <code>
      cmp
     </code>
     参数，
     <code>
      std::nth_element
     </code>
     会使用默认的比较规则，即
     <strong>
      升序排序
     </strong>
     （从小到大）。
    </p>
    <p>
     <strong>
      默认行为
     </strong>
    </p>
    <ul>
     <li>
      <p>
       如果不提供
       <code>
        cmp
       </code>
       ，
       <code>
        std::nth_element
       </code>
       会使用
       <code>
        operator&lt;
       </code>
       来比较元素。
      </p>
     </li>
     <li>
      <p>
       这意味着它会将序列划分为：左边的元素都小于第
       <code>
        n
       </code>
       个元素，右边的元素都大于或等于第
       <code>
        n
       </code>
       个元素。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      代码示例（默认）：
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {5, 3, 1, 4, 2};
    int mid = 2; // 找第3小的元素

    // 使用默认的比较规则（升序）
    std::nth_element(vec.begin(), vec.begin() + mid, vec.end());

    std::cout &lt;&lt; "第3小的元素是: " &lt;&lt; vec[mid] &lt;&lt; std::endl;

    // 输出整个向量
    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }

    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：第3小的元素是: 3
    </p>
    <p>
     <strong>
      代码示例（自定义比较函数）：
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool cmp(int a, int b) {
    return a &gt; b; // 降序排序
}

int main() {
    std::vector&lt;int&gt; vec = {5, 3, 1, 4, 2};
    int mid = 2; // 找第3大的元素

    // 使用自定义的比较规则（降序）
    std::nth_element(vec.begin(), vec.begin() + mid, vec.end(), cmp);

    std::cout &lt;&lt; "第3大的元素是: " &lt;&lt; vec[mid] &lt;&lt; std::endl;

    // 输出整个向量
    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }

    return 0;
}</code></pre>
    <hr/>
    <h4>
     3.
     <code>
      binary_search(a.begin(), a.end(), value)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：在已排序的序列中进行二分查找，查找值为
     <code>
      value
     </code>
     。如果找到，返回
     <code>
      true
     </code>
     ，否则返回
     <code>
      false
     </code>
     。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    bool found = std::binary_search(vec.begin(), vec.end(), 3);

    std::cout &lt;&lt; (found ? "找到" : "未找到") &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：找到
    </p>
    <hr/>
    <h4>
     4.
     <code>
      lower_bound(a.begin(), a.end(), x)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：在有序序列中查找第一个
     <strong>
      大于或等于
     </strong>
     <code>
      x
     </code>
     的元素的位置。如果不存在这样的元素，返回尾迭代器。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 4, 4, 5};
    auto it = std::lower_bound(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout &lt;&lt; "第一个大于或等于3的元素是: " &lt;&lt; *it &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "未找到" &lt;&lt; std::endl;
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：第一个大于或等于3的元素是: 4
    </p>
    <hr/>
    <h4>
     5.
     <code>
      upper_bound(a.begin(), a.end(), x)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：在有序序列中查找第一个
     <strong>
      大于
     </strong>
     <code>
      x
     </code>
     的元素的位置。如果不存在这样的元素，返回尾迭代器。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 4, 4, 5};
    auto it = std::upper_bound(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout &lt;&lt; "第一个大于3的元素是: " &lt;&lt; *it &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "未找到" &lt;&lt; std::endl;
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：第一个大于3的元素是: 4
    </p>
    <hr/>
    <h4>
     6.
     <code>
      next_permutation(a.begin(), a.end())
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：
     <strong>
      将当前排列更改为全排列中的下一个排列。如果当前排列已经是最后一个排列，则返回
      <code>
       false
      </code>
      ，并将排列重置为第一个排列。
     </strong>
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3};
    do {
        for (int i : vec) {
            std::cout &lt;&lt; i &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    } while (std::next_permutation(vec.begin(), vec.end()));
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：
    </p>
    <pre>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1</pre>
    <hr/>
    <h4>
     7.
     <code>
      prev_permutation()
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：
     <strong>
      将当前排列更改为全排列中的上一个排列。用法与
      <code>
       next_permutation()
      </code>
      类似。
     </strong>
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {3, 2, 1};
    do {
        for (int i : vec) {
            std::cout &lt;&lt; i &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    } while (std::prev_permutation(vec.begin(), vec.end()));
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：
    </p>
    <pre>3 2 1
3 1 2
2 3 1
2 1 3
1 3 2
1 2 3</pre>
    <hr/>
    <h4>
     8.
     <code>
      max(), min()
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：用于查找序列中的最大值和最小值。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main() {
    int a = 5, b = 3;
    std::cout &lt;&lt; "最大值: " &lt;&lt; std::max(a, b) &lt;&lt; std::endl;
    std::cout &lt;&lt; "最小值: " &lt;&lt; std::min(a, b) &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：
    </p>
    <pre>最大值: 5
最小值: 3</pre>
    <hr/>
    <h4>
     9.
     <code>
      swap()
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：交换两个元素的值。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main() {
    int a = 5, b = 3;
    std::swap(a, b);
    std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：a: 3, b: 5
    </p>
    <hr/>
    <h4>
     10.
     <code>
      find(a.begin(), a.end(), value)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：
     <strong>
      在序列中顺序查找值为
      <code>
       value
      </code>
      的元素。如果找到，返回指向该元素的迭代器；否则返回尾迭代器。
     </strong>
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout &lt;&lt; "找到: " &lt;&lt; *it &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "未找到" &lt;&lt; std::endl;
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：找到: 3
    </p>
    <hr/>
    <h4>
     11.
     <code>
      reverse(a.begin(), a.end())
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：翻转数组或字符串。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    std::reverse(vec.begin(), vec.end());

    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：5 4 3 2 1
    </p>
    <hr/>
    <h4>
     12.
     <code>
      sort(a.begin(), a.end(), cmp)
     </code>
    </h4>
    <p>
     <strong>
      功能
     </strong>
     ：对序列进行排序，
     <code>
      cmp
     </code>
     为自定义的比较函数。如果没有提供
     <code>
      cmp
     </code>
     ，默认按升序排序。
    </p>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool cmp(int a, int b) {
    return a &gt; b; // 降序排序
}

int main() {
    std::vector&lt;int&gt; vec = {5, 3, 1, 4, 2};
    std::sort(vec.begin(), vec.end(), cmp);

    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：5 4 3 2 1
    </p>
    <p>
    </p>
    <h2 style="background-color:transparent">
     三、两种相关例子说明
    </h2>
    <blockquote>
     <p>
      <strong>
       注意：最重要的一点是迭代器是左闭右开区间，即最左边能取到，但是最右边取不到，换成数组也是一样的。
      </strong>
     </p>
    </blockquote>
    <h3>
     <strong>
      1. 使用
      <code>
       vector
      </code>
      定义数列的代码
     </strong>
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;  // 包含标准库的所有头文件
using namespace std;      // 使用标准命名空间

vector&lt;int&gt; a {23, 5, 36, 4, 8, 7, 5, 23};  // 初始化一个 vector，包含元素 23, 5, 36, 4, 8, 7, 5, 23

void out() {  // 定义一个输出函数，用于打印 vector 的内容
    for (int i = 0; i &lt; a.size(); i++)  // 遍历 vector
        cout &lt;&lt; a[i] &lt;&lt; " ";  // 输出每个元素
    cout &lt;&lt; endl;  // 换行
}

int main() {
    auto it = find(a.begin(), a.end(), 5);  // 在 vector 中查找值为 5 的元素
    if (it != a.end()) cout &lt;&lt; "yes" &lt;&lt; endl;  // 如果找到，输出 "yes"
    else cout &lt;&lt; "no" &lt;&lt; endl;  // 如果没找到，输出 "no"

    nth_element(a.begin(), a.begin() + 4, a.end());  // 将第 5 小的元素放到正确位置
    out();  // 输出当前 vector 内容
    cout &lt;&lt; "第 5 小:" &lt;&lt; a[4] &lt;&lt; endl;  // 输出第 5 小的元素

    sort(a.begin(), a.end());  // 对 vector 进行升序排序
    out();  // 输出排序后的 vector

    auto last = unique(a.begin(), a.end());  // 去除相邻重复元素，返回去重后的尾迭代器
    out();  // 输出去重后的 vector

    a.erase(last, a.end());  // 删除末尾的重复元素
    out();  // 输出最终去重后的 vector

    it = lower_bound(a.begin(), a.end(), 11);  // 查找第一个大于或等于 11 的元素
    if (it != a.end()) cout &lt;&lt; *it &lt;&lt; endl;  // 如果找到，输出该元素

    it = upper_bound(a.begin(), a.end(), 5);  // 查找第一个大于 5 的元素
    if (it != a.end()) cout &lt;&lt; *it &lt;&lt; endl;  // 如果找到，输出该元素

    return 0;  // 主函数结束
}</code></pre>
    <hr/>
    <h3>
     <strong>
      2. 使用数组定义数列的代码
     </strong>
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;  // 包含标准库的所有头文件
using namespace std;      // 使用标准命名空间

int a[] = {23, 5, 36, 4, 8, 7, 5, 23};  // 初始化一个数组，包含元素 23, 5, 36, 4, 8, 7, 5, 23
int n = 8;  // 数组的长度

void out() {  // 定义一个输出函数，用于打印数组的内容
    for (int i = 0; i &lt; n; i++)  // 遍历数组
        cout &lt;&lt; a[i] &lt;&lt; " ";  // 输出每个元素
    cout &lt;&lt; endl;  // 换行
}

int main() {
    int k = find(a, a + n, 5) - a;  // 在数组中查找值为 5 的元素，返回其索引
    if (k != n) cout &lt;&lt; "yes" &lt;&lt; endl;  // 如果找到，输出 "yes"
    else cout &lt;&lt; "no" &lt;&lt; endl;  // 如果没找到，输出 "no"

    nth_element(a, a + 4, a + n);  // 将第 5 小的元素放到正确位置
    out();  // 输出当前数组内容
    cout &lt;&lt; "第 5 小:" &lt;&lt; a[4] &lt;&lt; endl;  // 输出第 5 小的元素

    sort(a, a + n);  // 对数组进行升序排序
    out();  // 输出排序后的数组

    n = unique(a, a + n) - a;  // 去除相邻重复元素，并更新数组长度
    out();  // 输出去重后的数组

    k = lower_bound(a, a + n, 11) - a;  // 查找第一个大于或等于 11 的元素
    if (k != n) cout &lt;&lt; a[k] &lt;&lt; endl;  // 如果找到，输出该元素

    k = upper_bound(a, a + n, 5) - a;  // 查找第一个大于 5 的元素
    if (k != n) cout &lt;&lt; a[k] &lt;&lt; endl;  // 如果找到，输出该元素

    if (binary_search(a, a + n, 23)) cout &lt;&lt; "yes1" &lt;&lt; endl;  // 在数组中二分查找值为 23 的元素
    else cout &lt;&lt; "no1" &lt;&lt; endl;  // 如果没找到，输出 "no1"

    reverse(a, a + n);  // 反转数组
    out();  // 输出反转后的数组

    int b[] = {2, 5, 7, 4, 5};  // 初始化另一个数组
    do {  // 使用 do-while 循环生成排列
        for (int i = 1; i &lt; 4; i++) cout &lt;&lt; b[i] &lt;&lt; " ";  // 输出数组的部分元素
        cout &lt;&lt; " ";  // 输出空格
    } while (next_permutation(b + 1, b + 4));  // 生成从第 2 个元素到第 4 个元素的全排列

    return 0;  // 主函数结束
}</code></pre>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         vector
        </code>
        版本
       </strong>
       ：使用 STL 容器
       <code>
        vector
       </code>
       ，支持动态大小调整，操作更灵活。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数组版本
       </strong>
       ：使用静态数组，操作更底层，适合固定大小的场景。
      </p>
     </li>
     <li>
      <p>
       两段代码的功能基本相同，包括查找、排序、去重、二分查找、排列生成等操作。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436313931303233" class_="artid" style="display:none">
 </p>
</div>


