---
layout: post
title: "32.C二叉树进阶1二叉搜索树"
date: 2025-03-04 23:58:27 +0800
description: "C++二叉搜索树的学习"
keywords: "32.C++二叉树进阶1（二叉搜索树）"
categories: ['数据结构与算法', 'C']
tags: ['面试', '数据结构', '开发语言', '二叉树', '二叉搜索树', 'C']
artid: "146027468"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146027468
    alt: "32.C二叉树进阶1二叉搜索树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146027468
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146027468
cover: https://bing.ee123.net/img/rand?artid=146027468
image: https://bing.ee123.net/img/rand?artid=146027468
img: https://bing.ee123.net/img/rand?artid=146027468
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     32.C++二叉树进阶1（二叉搜索树）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      ⭐上篇文章：
      <a href="https://blog.csdn.net/yzcllzx/article/details/145912188?spm=1001.2014.3001.5501" title="31.C++多态4（静态多态，动态多态，虚函数表的存储位置）-CSDN博客">
       31.C++多态4（静态多态，动态多态，虚函数表的存储位置）-CSDN博客
      </a>
     </p>
     <p>
      ⭐本篇代码：
      <a href="https://gitee.com/yzc-YZC/c-learning-of-yzc/tree/master/c++%E5%AD%A6%E4%B9%A0/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E9%98%B6-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow" title="c++学习/18.二叉树进阶-二叉搜索树 · 橘子真甜/c++-learning-of-yzc - 码云 - 开源中国 (gitee.com)">
       c++学习/18.二叉树进阶-二叉搜索树 · 橘子真甜/c++-learning-of-yzc - 码云 - 开源中国 (gitee.com)
      </a>
     </p>
     <p>
      ⭐标⭐是比较重要的部分
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" name="%E4%B8%80.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">
     一. 二叉搜索树的概念
    </h2>
    <p>
     二叉搜索树也称二叉排序树，它有可能是一颗空树。二叉搜索树性质如下：
    </p>
    <blockquote>
     <p>
      1 若它有左子树，那么它的左子树所有节点的值小于根节点
     </p>
     <p>
      2 如它有右子树，那么它的右子树所有节点的值小于根节点
     </p>
     <p>
      3 它的左右子树也是二叉搜索树
     </p>
    </blockquote>
    <p>
     二叉树的代码框架如下：
    </p>
    <pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;vector&gt;

//二叉树节点
template&lt;class K&gt;
struct BSTreeNode
{
	K _key;
	BSTreeNode* _left;
	BSTreeNode* _right;

	BSTreeNode(const K&amp; key)
		:_key(key), _left(nullptr), _right(nullptr)
	{};
};


//二叉树
template&lt;class K&gt;
class BSTree
{
	typedef BSTreeNode&lt;K&gt; Node;
public:
	bool Insert()
	{}

	bool find()
	{}

	bool Delete)
	{}

	//二叉树不允许修改数据
private:
	Node* _root;	//根节点
};
</code></pre>
    <h2 id="%E4%BA%8C.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0" name="%E4%BA%8C.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0">
     二. 二叉搜索树的插入
    </h2>
    <blockquote>
     <p>
      假设我们插入的节点为key
     </p>
     <p>
      若一棵树为空，则直接插入即可
     </p>
     <p>
      若不为空：
     </p>
     <p>
      按照二叉搜索树的性质，插入该节点即可。
     </p>
     <p>
      如果某一个节点和key值相同，则直接不插入
     </p>
     <p>
      若某一个节点比key值大，则应该将key插入到该节点的左子树中
     </p>
     <p>
      若某一个节点比key值小，则应该将key插入到该节点的右子树中
     </p>
     <p>
      然后在其左右子树中进行判断，直到子树节点为空，然后插入即可
     </p>
    </blockquote>
    <p>
     流程图如下：
    </p>
    <p>
     <img alt="" height="545" src="https://i-blog.csdnimg.cn/direct/36d70b5aa27448959b2c78673a627abd.png" width="1200"/>
    </p>
    <p>
     插入函数的代码如下：
    </p>
    <pre><code class="language-cpp">	bool Insert(const K&amp; key)
	{
		//根节点为空
		if (!root)
		{
			_root = new Node(key);
			return true;
		}

		//不为空，根据性质插入数据
		Node* cur = _root;
		Node* parent = cur;			//最后cur为空，需要一个节点保存其父节点用于连接
		while (cur)
		{
			if (key &gt; cur-&gt;_key)	//比当前值大，找其右子树
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (key &lt; cur-&gt;_key)	//比当前树小，找其左子树
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
				return false;	//有相同节点，插入失败
		}

		//此时cur为空，cur即为插入的数据
		cur = new Node(key);
		if (cur-&gt;_key &gt; parent-&gt;_key)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}
		return true;
	}</code></pre>
    <h2 id="%C2%A0%E4%B8%89.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" name="%C2%A0%E4%B8%89.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE">
     三. 二叉搜索树的查找
    </h2>
    <p>
     二叉搜索树的查找过程和插入过程非常相似。比如在插入的过程中，如果发现值相同，返回true即可，如果为空，则说明没有这个节点，返回false
    </p>
    <pre><code class="language-cpp">	bool find(const K&amp; key)
	{
		if (!_root)
			return false;

		Node* cur = _root;
		while (cur)
		{
			if (key &gt; cur-&gt;_key)
				cur = cur-&gt;_right;
			else if (key &lt; cur-&gt;_key)
				cur = cur-&gt;_left;
			else 
				return true;
		}
		//cur为空，没有key这个节点
		return false;
	}
</code></pre>
    <h2 id="%C2%A0%E5%9B%9B.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4" name="%C2%A0%E5%9B%9B.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4">
     四. 二叉树的删除
    </h2>
    <blockquote>
     <p>
      二叉树的删除比较麻烦。可以分为下面四个情况。
     </p>
     <p>
      1 该节点无左右子节点：
     </p>
     <p>
      2 该节点只有左子树：
     </p>
     <p>
      3 该节点只有右子树
     </p>
     <p>
      4 该节点有左右子树
     </p>
    </blockquote>
    <p>
     实际情况1与情况2或者3是重合的，所以只需考虑三者情况
    </p>
    <p>
    </p>
    <h3 id="4.1%C2%A0%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%BA%E7%A9%BA" name="4.1%C2%A0%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%BA%E7%A9%BA">
     4.1 删除节点右子树为空
    </h3>
    <p>
     下面这流程图我们要删除节点9
    </p>
    <p>
     <img alt="" height="496" src="https://i-blog.csdnimg.cn/direct/d6fb52cd06f24afb8ade9f9aed2e989f.png" width="880"/>
    </p>
    <p>
     若删除节点是父亲左孩子，父亲的左指向删除节点的左孩子
    </p>
    <p>
     若删除节点是父亲的右孩子，父亲的右指向删除节点的左孩子
    </p>
    <p>
     如果一个节点左右都为空，也满足这种情况
    </p>
    <h3 id="4.2%C2%A0%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%BA%E7%A9%BA%C2%A0" name="4.2%C2%A0%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%BA%E7%A9%BA%C2%A0">
     4.2 删除节点左子树为空
    </h3>
    <p>
     与上面情况类似
    </p>
    <p>
     若删除节点是父亲左孩子，父亲的左指向删除节点的右孩子
    </p>
    <p>
     若删除节点是父亲的右孩子，父亲的右指向删除节点的右孩子
    </p>
    <h3 id="4.3%20%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%9D%87%E4%B8%8D%E4%B8%BA%E7%A9%BA" name="4.3%20%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%9D%87%E4%B8%8D%E4%B8%BA%E7%A9%BA">
     4.3 左右孩子均不为空
    </h3>
    <p>
     此时需要找到一个节点来替代这个节点，
     <strong>
      在二叉搜索树中，根据其左子树节点比根节点小，右子树节点比根节点大的性质。
     </strong>
     <strong>
      如果一给节点左右不为空，只需找出其左子树最大，或者右子树最小来替代这个节点即可。
     </strong>
    </p>
    <p>
     流程图如下：
    </p>
    <p>
     <img alt="" height="677" src="https://i-blog.csdnimg.cn/direct/87f445999e7847588ab540fddb5182b9.png" width="1100"/>
    </p>
    <h3 id="4.4%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E4%BB%A3%E7%A0%81%C2%A0" name="4.4%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E4%BB%A3%E7%A0%81%C2%A0">
     4.4 删除节点代码
    </h3>
    <pre><code class="language-cpp">//删除
	bool Erase(const K&amp; key)
	{
		//1.该节点只有一个孩子
		//2.该节点没有孩子
		//3.该节点有三个孩子
		Node* cur = _root;
		Node* parent = cur;
		while (cur)
		{
			if (cur-&gt;_key &lt; key)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_key &gt; key)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else//找到了，开始删除
			{
				if (cur-&gt;_left == nullptr)
				{
					//当cur为根的时候要特判
					if (cur == _root)
					{
						_root = cur-&gt;_right;
					}

					if (cur == parent-&gt;_left)
					{
						parent-&gt;_left = cur-&gt;_right;
					}
					else
					{
						parent-&gt;_right = cur-&gt;_right;
					}
					delete cur;
					cur = nullptr;
				}
				else if (cur-&gt;_right == nullptr)
				{
					if (cur == _root)
					{
						_root = cur-&gt;_left;
					}

					if (cur == parent-&gt;_left)
					{
						parent-&gt;_left = cur-&gt;_left;
					}
					else
					{
						parent-&gt;_right = cur-&gt;_left;
					}
					delete cur;
					cur = nullptr;
				}
				else//两边都不为空
				{
					//找到左边最大，右边最小与当前值交互即可
					Node* rightmin = cur-&gt;_right;
					Node* rightminparent = cur;
					
					while (rightmin-&gt;_left)
					{
						rightminparent = rightmin;
						rightmin = rightmin-&gt;_left;
					}
					cur-&gt;_key = rightmin-&gt;_key;

					//如果cur的右孩子是最小的，直接让cur指向右孩子的右孩子即可
					if (rightmin == cur-&gt;_right)
					{
						cur-&gt;_right = rightmin-&gt;_right;
					}
					else
					{
						rightminparent-&gt;_left = rightmin-&gt;_right;
					}

					delete rightmin;
					rightmin = nullptr;
				}
				return true;
			}
		}
		return false;
	}</code></pre>
    <h2 id="%E4%BA%94.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0" name="%E4%BA%94.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0">
     五. 二叉搜索树的遍历
    </h2>
    <p>
     根据二叉搜索树的性质，如果我们以中序遍历(左根右)，那我们的遍历的时候先是最小的，然后依次遍历更大的。
     <strong>
      那么最终的排序顺序是有序的！
     </strong>
    </p>
    <p>
     <strong>
      中序遍历代码如下：
     </strong>
    </p>
    <pre><code class="language-cpp">	
	void _InOrder(const Node* root)
	{
		if (!root)
			return;
		//中序遍历
		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_key &lt;&lt; " ";
		_InOrder(root-&gt;_right);
	}</code></pre>
    <h2 id="%E5%85%AD.%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%B5%8B%E8%AF%95" name="%E5%85%AD.%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%B5%8B%E8%AF%95">
     六.代码与测试
    </h2>
    <p>
     bstree.h
    </p>
    <pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

template&lt;class K&gt;
struct BSTreeNode
{
	BSTreeNode* _left;
	BSTreeNode* _right;
	K _key;
	//构造函数
	BSTreeNode(const K&amp; key)
		:_left(nullptr)
		, _right(nullptr)
		, _key(key)
	{}
};

template&lt;class K&gt;
class BSTree
{
	typedef BSTreeNode&lt;K&gt; Node;
public:
	//插入
	bool Insert(const K&amp; key)
	{
		//第一次插入
		if (!_root)
		{
			_root = new Node(key);
			return  true;
		}

		Node* cur = _root;
		Node* parent = cur;
		while (cur)
		{
			if (cur-&gt;_key &lt; key)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_key &gt; key)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(key);
		if (parent-&gt;_key &gt; key)
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}
		return true;
	}

	//查找
	bool find(const K&amp; key)
	{
		if (!_root)
			return false;

		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_key &lt; key)
			{
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_key &gt; key)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return true;
			}
		}
		return false;
	}

	//删除
	bool Erase(const K&amp; key)
	{
		//1.该节点只有一个孩子
		//2.该节点没有孩子
		//3.该节点有三个孩子
		Node* cur = _root;
		Node* parent = cur;
		while (cur)
		{
			if (cur-&gt;_key &lt; key)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_key &gt; key)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else//找到了，开始删除
			{
				if (cur-&gt;_left == nullptr)
				{
					//当cur为根的时候要特判
					if (cur == _root)
					{
						_root = cur-&gt;_right;
					}

					if (cur == parent-&gt;_left)
					{
						parent-&gt;_left = cur-&gt;_right;
					}
					else
					{
						parent-&gt;_right = cur-&gt;_right;
					}
					delete cur;
					cur = nullptr;
				}
				else if (cur-&gt;_right == nullptr)
				{
					if (cur == _root)
					{
						_root = cur-&gt;_left;
					}

					if (cur == parent-&gt;_left)
					{
						parent-&gt;_left = cur-&gt;_left;
					}
					else
					{
						parent-&gt;_right = cur-&gt;_left;
					}
					delete cur;
					cur = nullptr;
				}
				else//两边都不为空
				{
					//找到左边最大，右边最小与当前值交互即可
					Node* rightmin = cur-&gt;_right;
					Node* rightminparent = cur;
					
					while (rightmin-&gt;_left)
					{
						rightminparent = rightmin;
						rightmin = rightmin-&gt;_left;
					}
					cur-&gt;_key = rightmin-&gt;_key;

					//如果cur的右孩子是最小的，直接让cur指向右孩子的右孩子即可
					if (rightmin == cur-&gt;_right)
					{
						cur-&gt;_right = rightmin-&gt;_right;
					}
					else
					{
						rightminparent-&gt;_left = rightmin-&gt;_right;
					}

					delete rightmin;
					rightmin = nullptr;
				}
				return true;
			}
		}
		return false;
	}

	//二叉搜索树不允许修改，修改后会导致二叉树失效
	//中序遍历
	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}

private:
	Node* _root = nullptr;
	
	void _InOrder(const Node* root)
	{
		if (!root)
			return;
		//中序遍历
		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_key &lt;&lt; " ";
		_InOrder(root-&gt;_right);
	}
};</code></pre>
    <p>
     test.cpp
    </p>
    <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"bstree.h"

void test1()
{
	BSTree&lt;int&gt; tree;

	vector&lt;int&gt; arr;
	for (int i = 0; i &lt; 10; i++)
	{
		int t = rand() % 10000;
		arr.push_back(t);
		tree.Insert(t);
	}

	tree.InOrder();
	for (int i = 0; i &lt;= 9; i++)
	{
		cout &lt;&lt; "删除" &lt;&lt; arr[i] &lt;&lt; "后:";
		tree.Erase(arr[i]);
		tree.InOrder();
	}
}

int main()
{
	srand((unsigned int)time(0));
	test1();
}</code></pre>
    <p>
     <img alt="" height="794" src="https://i-blog.csdnimg.cn/direct/83cfaf78de134c659dd71d9d87dc2c0a.png" width="1438"/>
    </p>
    <p>
     可以看到，排序的顺序是有序的
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f797a636c6c7a782f:61727469636c652f64657461696c732f313436303237343638" class_="artid" style="display:none">
 </p>
</div>


