---
layout: post
title: "Ubuntu-下-nginx-1.24.0-源码分析-conf_ctx"
date: 2025-03-08 17:21:26 +0800
description: "/ 其他字段...// 其他字段...# 工作进程数# 全局错误日志层级 2：HTTP 块（http）作用server {listen 80;# 监听端口# 域名# 站点根目录层级 4：路径（location）作用# 反向代理到后端服务# 代理缓冲区大小继承关系。"
keywords: "Ubuntu 下 nginx-1.24.0 源码分析 - conf_ctx"
categories: ['未分类']
tags: ['数据库', 'Ubuntu', 'Nginx']
artid: "146118481"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146118481
    alt: "Ubuntu-下-nginx-1.24.0-源码分析-conf_ctx"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146118481
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146118481
cover: https://bing.ee123.net/img/rand?artid=146118481
image: https://bing.ee123.net/img/rand?artid=146118481
img: https://bing.ee123.net/img/rand?artid=146118481
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Ubuntu 下 nginx-1.24.0 源码分析 - conf_ctx
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_cycle_s
      </code>
     </span>
     结构体的
     <span style="color:#be191c">
      <code>
       conf_ctx
      </code>
     </span>
     字段定义如下
    </h4>
    <pre><code class="hljs">typedef struct ngx_cycle_s  ngx_cycle_t;

struct ngx_cycle_s {
    // 其他字段...
    void                    ****conf_ctx;
    // 其他字段...
};</code></pre>
    <h4>
     这是一个四级指针
    </h4>
    <h4 id="conf_ctx的作用和意义">
     <span style="color:#be191c">
      conf_ctx
     </span>
     的作用和意义
    </h4>
    <ol>
     <li>
      <h4>
       <strong>
        模块配置统一管理
       </strong>
       ：
       <span style="color:#be191c">
        <code>
         conf_ctx
        </code>
       </span>
       是一个存储所有模块配置上下文的容器，它是Nginx配置系统的核心组成部分。
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        配置层次结构
       </strong>
       ：它实现了Nginx多层次配置的管理能力，使得不同模块可以在不同配置层次（如main、server、location）中有各自的配置。
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        模块间解耦
       </strong>
       ：通过这种设计，各个模块可以独立管理自己的配置，不需要了解其他模块的实现细节。
      </h4>
     </li>
    </ol>
    <hr/>
    <h4 id="1. 四级指针的设计原因">
     四级指针的设计原因
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       conf_ctx
      </code>
     </span>
     是一个
     <span style="color:#be191c">
      四级
     </span>
     指针
     <code>
      void ****
     </code>
     ，这种设计看似复杂，但非常巧妙：
    </h4>
    <ul>
     <li>
      <h4>
       第一层：模块类型（核心模块、事件模块、HTTP 模块等）。
      </h4>
     </li>
     <li>
      <h4>
       第二层：模块实例（如 HTTP 模块下的各个子模块）。
      </h4>
     </li>
     <li>
      <h4>
       第三层：配置层级（main、server、location）。
      </h4>
     </li>
     <li>
      <h4>
       第四层：具体配置结构体。
      </h4>
     </li>
    </ul>
    <h4>
     这样设计的好处是可以在运行时动态构建配置，并且能够处理模块的动态加载和卸载。
    </h4>
    <hr/>
    <h4>
     假设我们有以下 Nginx 配置片段：
    </h4>
    <pre><code class="hljs">http {
    # HTTP 主配置（main 级）
    server {
        # 虚拟主机配置（server 级）
        location /api {
            # 路径配置（location 级）
            proxy_pass http://backend;
        }
    }
}</code></pre>
    <h4>
     <code>
      conf_ctx
     </code>
     的四层指针结构可以拆解为以下层级：
    </h4>
    <h4>
     <strong>
      第一层：模块类型（
      <code>
       void ***
      </code>
      ）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        含义
       </strong>
       ：指向不同模块类型的配置数组。Nginx 模块分为核心模块（
       <code>
        NGX_CORE_MODULE
       </code>
       ）、事件模块（
       <code>
        NGX_EVENT_MODULE
       </code>
       ）、HTTP 模块（
       <code>
        NGX_HTTP_MODULE
       </code>
       ）等。
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">conf_ctx[NGX_CORE_MODULE]   // 核心模块配置数组
conf_ctx[NGX_HTTP_MODULE]   // HTTP 模块配置数组</code></pre>
    <h4>
     <strong>
      第二层：模块实例（
      <code>
       void **
      </code>
      ）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        含义
       </strong>
       ：指向某个模块类型的子模块配置数组。例如，HTTP 模块下可能包含核心 HTTP 模块、代理模块（
       <code>
        ngx_http_proxy_module
       </code>
       ）、FastCGI 模块等。
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">// 假设 HTTP 模块类型下有两个子模块：
conf_ctx[NGX_HTTP_MODULE][0] = ngx_http_core_module 的配置
conf_ctx[NGX_HTTP_MODULE][1] = ngx_http_proxy_module 的配置</code></pre>
    <h4>
    </h4>
    <h4>
     <strong>
      第三层：配置层级（
      <code>
       void *
      </code>
      ）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        含义
       </strong>
       ：指向某个模块在特定配置层级（main、server、location）的配置结构。例如，HTTP 模块的配置可能分为全局（main）、虚拟主机（server）、路径（location）三级。
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">// 以 ngx_http_core_module 为例：
conf_ctx[NGX_HTTP_MODULE][0][NGX_HTTP_MAIN_CONF]   // HTTP 全局配置
conf_ctx[NGX_HTTP_MODULE][0][NGX_HTTP_SRV_CONF]    // 虚拟主机配置
conf_ctx[NGX_HTTP_MODULE][0][NGX_HTTP_LOC_CONF]    // 路径配置</code></pre>
    <h4>
     <strong>
      第四层：具体配置结构体
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        含义
       </strong>
       ：实际存储模块配置的结构体指针。例如，HTTP 核心模块的 main 级配置结构体是
       <code>
        ngx_http_core_main_conf_t
       </code>
       。
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">// 获取 HTTP 核心模块的 main 级配置：
ngx_http_core_main_conf_t *cmcf = 
    (ngx_http_core_main_conf_t *) conf_ctx[NGX_HTTP_MODULE][0][NGX_HTTP_MAIN_CONF];</code></pre>
    <h4>
     <strong>
      完整示例：访问
      <code>
       proxy_pass
      </code>
      配置
     </strong>
    </h4>
    <h4>
     假设我们要在
     <code>
      location /api
     </code>
     中获取
     <code>
      proxy_pass
     </code>
     的配置值：
    </h4>
    <ol>
     <li>
      <h4>
       <strong>
        定位模块类型
       </strong>
       ：
       <code>
        NGX_HTTP_MODULE
       </code>
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        定位子模块
       </strong>
       ：
       <code>
        ngx_http_proxy_module
       </code>
       （假设索引为 2）
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        定位配置层级
       </strong>
       ：
       <code>
        NGX_HTTP_LOC_CONF
       </code>
      </h4>
     </li>
     <li>
      <strong>
       获取配置结构体
      </strong>
      ：
      <pre><code class="hljs">ngx_http_proxy_loc_conf_t *plcf = 
    (ngx_http_proxy_loc_conf_t *) 
        conf_ctx[NGX_HTTP_MODULE][2][NGX_HTTP_LOC_CONF];
// 访问配置值
printf("proxy_pass: %s\n", plcf-&gt;upstream.url);</code></pre>
      <hr/>
      <h4>
       Nginx 的配置确实分为
       <strong>
        4 个核心层级
       </strong>
       ，这种设计是为了实现配置的灵活性、模块化和细粒度控制。以下是具体层级及其设计意义：
      </h4>
     </li>
    </ol>
    <h4>
     <strong>
      层级 1：全局（main）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        作用
       </strong>
       ：定义全局性配置，影响所有模块和进程。
      </h4>
     </li>
     <li>
      <h4>
       例：
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">worker_processes  4;       # 工作进程数
error_log  /var/log/nginx/error.log;  # 全局错误日志</code></pre>
    <h4>
     <strong>
      层级 2：HTTP 块（http）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        作用
       </strong>
       ：配置 HTTP 协议相关的全局参数。
      </h4>
     </li>
     <li>
      <h4>
       例：
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">http {
    include       mime.types;        # MIME 类型映射
    default_type  application/octet-stream;
    sendfile        on;              # 零拷贝文件传输
}</code></pre>
    <h4>
     <strong>
      层级 3：虚拟主机（server）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        作用
       </strong>
       ：定义独立的虚拟主机（基于域名或 IP 的站点）。
      </h4>
     </li>
     <li>
      <h4>
       例：
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">server {
    listen       80;                 # 监听端口
    server_name  example.com;        # 域名
    root   /var/www/example.com;     # 站点根目录
}</code></pre>
    <h4>
     <strong>
      层级 4：路径（location）
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        作用
       </strong>
       ：针对特定 URL 路径定义处理规则。
      </h4>
     </li>
     <li>
      <h4>
       例：
      </h4>
     </li>
    </ul>
    <pre><code class="hljs">location /api {
    proxy_pass  http://backend;      # 反向代理到后端服务
    proxy_buffer_size  4k;           # 代理缓冲区大小
}</code></pre>
    <hr/>
    <h4>
     <strong>
      继承关系
     </strong>
     ：下层配置继承上层的默认值，同时可以覆盖
    </h4>
    <pre><code class="hljs">http {                # 全局 HTTP 配置
    proxy_buffer_size  8k;
    server {
        proxy_buffer_size  16k;      # 覆盖 HTTP 层的值
        location /api {
            proxy_buffer_size  4k;   # 覆盖 server 层的值
        }
    }
}</code></pre>
    <h4>
     <strong>
      模块化与解耦
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       <strong>
        模块化设计
       </strong>
       ：每个层级对应不同的功能模块（如核心模块、HTTP 模块、代理模块）。
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        示例
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <h4>
         <code>
          main
         </code>
         层级处理进程管理。
        </h4>
       </li>
       <li>
        <h4>
         <code>
          http
         </code>
         层级处理协议解析。
        </h4>
       </li>
       <li>
        <h4>
         <code>
          server
         </code>
         层级处理虚拟主机。
        </h4>
       </li>
       <li>
        <h4>
         <code>
          location
         </code>
         层级处理具体请求路由。
        </h4>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      动态扩展
     </strong>
     ：通过层级嵌套，轻松添加新功能（如
     <code>
      upstream
     </code>
     块用于负载均衡）
    </h4>
    <pre><code class="hljs">http {
    upstream backend {
        server 192.168.1.101;
        server 192.168.1.102;
    }
    server {
        location /api {
            proxy_pass http://backend;  # 引用 upstream
        }
    }
}</code></pre>
    <hr/>
    <h4>
    </h4>
    <h4>
     <strong>
      典型配置示例
     </strong>
    </h4>
    <pre><code class="hljs"># 全局层级（main）
worker_processes  2;

events {
    worker_connections  1024;
}

# HTTP 块层级
http {
    include       mime.types;
    default_type  application/octet-stream;

    # 虚拟主机层级（server）
    server {
        listen       80;
        server_name  example.com;

        # 路径层级（location）
        location / {
            root   /var/www/html;
            index  index.html;
        }

        location /api {
            proxy_pass  http://backend;
            proxy_set_header Host $host;
        }
    }

    # 上游服务器层级（upstream）
    upstream backend {
        server 127.0.0.1:8080;
        server 127.0.0.1:8081;
    }
}</code></pre>
    <ol>
     <li>
      <h4>
       <strong>
        清晰的职责划分
       </strong>
       ：每个层级专注特定功能，降低配置复杂度。
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        灵活的覆盖机制
       </strong>
       ：允许在更具体的层级覆盖全局配置。
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        高性能路由
       </strong>
       ：通过层级化匹配算法（如哈希表、红黑树）实现快速请求分发。
      </h4>
     </li>
     <li>
      <h4>
       <strong>
        易于维护
       </strong>
       ：层级结构使配置文件更易阅读和修改。
      </h4>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <h4>
     Nginx 的四层配置结构（main → http → server → location）是其高性能和灵活性的核心设计之一。通过层级化、模块化的配置管理，Nginx 能够高效处理从全局设置到具体请求路由的复杂需求，同时保持配置的简洁和可维护性。
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34313831323334362f:61727469636c652f64657461696c732f313436313138343831" class_="artid" style="display:none">
 </p>
</div>


