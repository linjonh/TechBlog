---
layout: post
title: "Docker自写"
date: 2025-08-30T21:29:52+0800
description: "Docker程序是跑在操作系统上的，而操作系统上又装了各种不同版本的依赖库和配置程序依赖环境，环境不同，程序就可能跑不起来，如果我们能将环境和程序一起打包docker就是可以将程序和环境一起打包并运行的工具软件。"
keywords: "Docker(自写)"
categories: ['未分类']
tags: ['运维', '容器', 'Docker']
artid: "151025145"
arturl: "https://blog.csdn.net/2301_80355452/article/details/151025145"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151025145
    alt: "Docker自写"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151025145
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151025145
cover: https://bing.ee123.net/img/rand?artid=151025145
image: https://bing.ee123.net/img/rand?artid=151025145
img: https://bing.ee123.net/img/rand?artid=151025145
---



# Docker(自写)

Docker

程序是跑在操作系统上的，而操作系统上又装了各种不同版本的依赖库和配置

![](https://i-blog.csdnimg.cn/direct/4880c9d16e9c416cb792a2f36b3b5aff.png)

程序依赖环境，环境不同，程序就可能跑不起来，如果我们能将环境和程序一起打包

docker就是可以将程序和环境一起打包并运行的工具软件

### 基础镜像

![](https://i-blog.csdnimg.cn/direct/8c51352eeefd4e29a5ef4c701d809826.png)

### DockerFile

有了基础镜像还不够，我们经常还需要安装一些依赖

![](https://i-blog.csdnimg.cn/direct/95e51b642c944945a777314f8bf8e5a3.png)

将要做的事情以命令行一行一行列出来，就像一份todo list

### 容器镜像

当执行docker build的时候，docker软件就会按dockerfile的说明，一行行构建环境加应用程序，最终将这个环境加程序打包成一个类似“压缩包”的东西，就是容器镜像Container Image,只要将容器镜像传到任意一台服务器上，对这个“压缩包”进行“解压缩”就能同时运行环境和程序

### Registry

怎么将容器镜像传到那么多服务器呢

![](https://i-blog.csdnimg.cn/direct/03fc57caa40e4df684d331c8f4f9dcca.png)

可以用docker registry负责管理镜像推拉能力的服务

![](https://i-blog.csdnimg.cn/direct/221171b5d15b459f8306350d1aabd132.png)

### 容器是什么

在目的服务器用docker pull拿到容器镜像

执行docker run命令将这个类似压缩包的容器进行“解压缩”，获得一个独立的环境和应用程序并运行起来，这就是所谓的容器，可以在一个操作系统中，跑多个container，且都是互相独立

### docker和虚拟机关系

![](https://i-blog.csdnimg.cn/direct/29cc1195517e4a9791676e74c7c6b391.png)

### docker的架构原理

典型的cs架构，

![](https://i-blog.csdnimg.cn/direct/c5ccac8dab6e43f6adb64783a5526ab0.png)

docker解析我们输入的command命令，然后调用docker daemon守护进程提供的restful API，守护进程收到命令后，会根据命令创建和管理各个容器

docker daemon内部分为docker server 和Engine

docker server本质上是个HTTP服务器，负责对外提供操作容器和镜像的API接口，接收到API请求后，会分发任务给Engine层，Engine层创建job，由job层实际执行各种工作，不同的docker命令执行不同的类型的job 任务

### docker build

如果执行的是docker build命令，job则会根据dockerfile指令像剥洋葱皮似的一层层构建容器镜像文件

### docker pull/push

job则会跟外部的docker registry交互，将镜像创建或下载

### docker run

job就会基于镜像文件调用containierd组件，驱使runC组件创建和运行容器

### docker compose是什么

docker容器本身只是一个特殊进程，但如果要部署多个容器，且对容器的顺序有一定要求。比如一个博客系统，当然是先启动数据库再启动身份验证服务，最后才能启动博客web服务。按理说挨个执行docker run 命令当然是没有问题的，可以通过一个yaml文件写清除要部署的容器有哪些，部署顺序是怎么样的，以及这些容器占用cpu和内存等信息，然后通过docker-compose up命令开始解析yaml文件，将容器门一键按顺序部署，就完成一整套服务的部署

### docker swarm是什么

docker解决的一个容器的部署

docker compose 解决的是多个容器组成的一整套服务的部署

docker swarm 是解决一整套服务再多台服务器上的集群部署问题，比如某应用在a服务器坏了，就将该服务在b服务器上重写部署一套，实现迁移，还能根据需要对引用做扩缩容

### docker 和k8s

k8s会在多台node的服务器上调度pod进行部署和扩缩容，每个pod内部可以含有多个container,每个container本质上就是一个服务进程



