---
layout: post
title: "ArduPilot开源代码之AP_OSD"
date: 2025-03-09 18:28:40 +0800
description: "最多支持两种OSD实例切换，不支持同一时刻，两种OSD同时使用。基于为了让Ardupilot代码支持模拟+数字OSD同时显示更新，需定制固件。目前，前面提及的补丁尚未合入，且存在一个模拟越来越少使用的问题，要合入可能也存在一定的苦难。ArduPilot开源飞控之lida2003-H743-5inch套机配置ArduPilot开源飞控之lida2003-H743-5inch配置调整orArduPilot飞控AOCODARC-H7DUAL固件编译Ardupilot开源飞控工程项目编译回顾。"
keywords: "ArduPilot开源代码之AP_OSD"
categories: ['Ardupilot']
tags: ['开源', 'Git', 'Ardupilot']
artid: "146136377"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146136377
    alt: "ArduPilot开源代码之AP_OSD"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146136377
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146136377
cover: https://bing.ee123.net/img/rand?artid=146136377
image: https://bing.ee123.net/img/rand?artid=146136377
img: https://bing.ee123.net/img/rand?artid=146136377
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ArduPilot开源代码之AP_OSD
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="1__2">
     </a>
     1. 源由
    </h2>
    <p>
     因为自己有两个摄像头：模拟+数字；而数字OpenIPC地面端Jetson-fpv还不太成熟，所以暂时还想使用模拟的飞，等稳定了切换成数字。
    </p>
    <p>
     问题是数字录像还是要的，以便更好的了解OpenIPC作为数字图传的效果。
    </p>
    <ul>
     <li>
      <a href="https://discuss.ardupilot.org/t/is-it-possible-for-two-osd-resolution-working-at-the-same-time/125505" rel="nofollow">
       Is it possible for two OSD resolution working at the same time?
      </a>
     </li>
     <li>
      <a href="https://discuss.ardupilot.org/t/how-to-setup-two-vtx-one-for-analog-camera-another-for-digital-camera/125151" rel="nofollow">
       How to setup two VTX (one for analog camera, another for digital camera)
      </a>
     </li>
    </ul>
    <p>
     从代码和咨询的角度看，似乎Ardupilot并不支持同时两个OSD在不同分辨率的情况下工作。
    </p>
    <p>
     所以，还是需要从代码入手，DIY玩的就是“心跳”，对吧。
    </p>
    <h2>
     <a id="2__16">
     </a>
     2. 简介
    </h2>
    <p>
     最多支持两种
     <code>
      OSD
     </code>
     实例切换，不支持同一时刻，两种OSD同时使用。
    </p>
    <pre><code class="prism language-C">#define OSD_MAX_INSTANCES 2
</code></pre>
    <p>
     基于
     <a href="https://blog.csdn.net/lida2003/article/details/146178089">
      <code>
       AP_OSD_Backend
      </code>
     </a>
     支持以下四种OSD类型：
    </p>
    <ul>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/146188230">
       OSD_MAX7456: AP_OSD_MAX7456
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/146187783">
       OSD_SITL: AP_OSD_SITL
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/146183819">
       OSD_MSP: AP_OSD_MSP
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/146181307">
       OSD_MSP_DISPLAYPORT: AP_OSD_MSP_DisplayPort
      </a>
     </li>
    </ul>
    <h2>
     <a id="3__31">
     </a>
     3. 补丁
    </h2>
    <p>
     但是通过
     <a href="https://github.com/ArduPilot/ardupilot/pull/29149">
      AP_OSD: add two osd resolution concurrently support #29149
     </a>
     已经打破该困局，支持同一时刻，两种尺寸的OSD的同时显示：
    </p>
    <ul>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/145815090">
       Git Repo下如何制作一个patch文件
      </a>
     </li>
    </ul>
    <p>
     <code>
      patch
     </code>
     分享/更好的差异化比较，减少宝贵Review时间浪费，也是对代码熟悉程度的体现。
    </p>
    <p>
     另外，也可以作为系统集成的差异化补丁，快速实现本地集成、编译、测试、验证等。
    </p>
    <h2>
     <a id="4__41">
     </a>
     4. 框架设计
    </h2>
    <p>
     接下来，我们来看下该模块的设计。
    </p>
    <h3>
     <a id="41__AP_OSDinit_45">
     </a>
     4.1 启动代码 (AP_OSD::init)
    </h3>
    <p>
     这里不做过多解释，详见：启动代码流程-
     <a href="https://blog.csdn.net/lida2003/article/details/130634007">
      ArduPilot飞控启动&amp;运行过程简介
     </a>
    </p>
    <pre><code class="prism language-C">Copter::init_ardupilot
 └──&gt; osd.init();
</code></pre>
    <ol>
     <li>
      根据配置内容直接对实例类型进行赋值
     </li>
     <li>
      然后针对对应的四种类型OSD进行初始化
     </li>
     <li>
      创建
      <code>
       osd_thread
      </code>
      任务，依据优先级执行例程
     </li>
    </ol>
    <pre><code class="prism language-C">AP_OSD::init
 ├──&gt; const AP_OSD::osd_types types[OSD_MAX_INSTANCES] = {
 │      osd_types(osd_type.get()),
 │      osd_types(osd_type2.get())
 │  };
 ├──&gt; for &lt;instance &lt; OSD_MAX_INSTANCES&gt;
 │   ├──&gt; init_backend(types[instance], instance)
 │   └──&gt; _backend_count++;
 └──&gt; &lt;_backend_count &gt; 0&gt;
     └──&gt; hal.scheduler-&gt;thread_create(FUNCTOR_BIND_MEMBER(&amp;AP_OSD::osd_thread, void), "OSD", 1280, AP_HAL::Scheduler::PRIORITY_IO, 1);
</code></pre>
    <h3>
     <a id="42__AP_OSDosd_thread_71">
     </a>
     4.2 任务代码 (AP_OSD::osd_thread)
    </h3>
    <ol>
     <li>
      例程会首先执行
      <code>
       osd_thread_run_once
      </code>
     </li>
     <li>
      然后每隔100ms唤醒对2个OSD实例进行更新
     </li>
     <li>
      若
      <code>
       disable
      </code>
      OSD，则无需更新状态
     </li>
     <li>
      对OSD Overlay进行刷新
     </li>
    </ol>
    <pre><code class="prism language-C">
 ├──&gt; for &lt;instance &lt; OSD_MAX_INSTANCES&gt;
 │   └──&gt; _backends[instance]-&gt;osd_thread_run_once()
 └──&gt; &lt;loop&gt;
     ├──&gt; hal.scheduler-&gt;delay(100)
     ├──&gt; &lt;!_disable&gt;
     │   ├──&gt; update_stats();
     │   └──&gt; update_current_screen();
     └──&gt; update_osd()
</code></pre>
    <h3>
     <a id="43__AP_OSDinit_backend_90">
     </a>
     4.3 实例初始化 (AP_OSD::init_backend)
    </h3>
    <p>
     每种实例需要对软硬件进行除此环境设定，这里采用类似
     <code>
      probe
     </code>
     的方式执行。
    </p>
    <ul>
     <li>
      若，probe失败，则该OSD实例为空指针
     </li>
     <li>
      若，该实例与第一个默认OSD实例冲突，则第二个实例不进行初始化
     </li>
    </ul>
    <pre><code class="prism language-C">AP_OSD::init_backend
 ├──&gt; &lt;instance &gt; 0 &amp;&amp; _backends[0] &amp;&amp; !_backends[0]-&gt;is_compatible_with_backend_type(type)&gt;
 │   └──&gt; return false; // 第二种类型OSD与默认第一类OSD不兼容
 ├──&gt; &lt;switch&gt;
 │   ├──&gt; &lt;OSD_NONE&gt; break
 │   ├──&gt; &lt;OSD_TXONLY&gt; break
 │   ├──&gt; &lt;OSD_MAX7456&gt; &lt;HAL_WITH_SPI_OSD&gt; &lt;HAL_WITH_OSD_BITMAP&gt;
 │   │   ├──&gt; AP_HAL::OwnPtr&lt;AP_HAL::Device&gt; spi_dev = std::move(hal.spi-&gt;get_device("osd"));
 │   │   ├──&gt; _backends[instance] = AP_OSD_MAX7456::probe(*this, std::move(spi_dev))
 │   │   └──&gt;  break
 │   ├──&gt; &lt;WITH_SITL_OSD&gt; 
 │   │   ├──&gt; _backends[instance] = AP_OSD_SITL::probe(*this)
 │   │   └──&gt;  break
 │   ├──&gt; &lt;OSD_MSP&gt; 
 │   │   ├──&gt; _backends[instance] = AP_OSD_MSP::probe(*this);
 │   │   └──&gt;  break
 │   └──&gt; &lt;OSD_MSP_DISPLAYPORT&gt; &lt;HAL_WITH_MSP_DISPLAYPORT&gt;
 │       ├──&gt; _backends[instance] = AP_OSD_MSP_DisplayPort::probe(*this)
 │       └──&gt;  break
 ├──&gt; &lt;OSD_ENABLED &amp;&amp; _backends[instance] != nullptr&gt;
 │   ├──&gt; _backends[instance]-&gt;init_symbol_set(AP_OSD_AbstractScreen::symbols_lookup_table, AP_OSD_NUM_SYMBOLS)
 │   └──&gt; return true;
 └──&gt; return false;
</code></pre>
    <h2>
     <a id="5__123">
     </a>
     5. 重要例程
    </h2>
    <h3>
     <a id="51_AP_OSDupdate_stats_125">
     </a>
     5.1 AP_OSD::update_stats
    </h3>
    <p>
     对系统内部的参数进行定期更新
    </p>
    <ul>
     <li>
      地速
     </li>
     <li>
      位置
     </li>
     <li>
      高度
     </li>
     <li>
      空速
     </li>
     <li>
      飞行距离
     </li>
     <li>
      最大地面速度
     </li>
     <li>
      最大高度
     </li>
     <li>
      最大直线与HOME的距离
     </li>
     <li>
      最大电流
     </li>
     <li>
      最小电压
     </li>
     <li>
      最小RSSI
     </li>
     <li>
      最大空速
     </li>
     <li>
      最大ESC温度
     </li>
    </ul>
    <pre><code class="prism language-C">AP_OSD::update_stats
 ├──&gt; WITH_SEMAPHORE(_sem);
 ├──&gt; uint32_t now = AP_HAL::millis();
 ├──&gt; &lt;!AP_Notify::flags.armed&gt; //没有启动，则无需更新状态
 │   ├──&gt; _stats.last_update_ms = now;
 │   └──&gt; return;
 │
 ├──&gt; [更新delta_ms]
 │   ├──&gt; uint32_t delta_ms = now - _stats.last_update_ms;
 │   ├──&gt; _stats.last_update_ms = now;
 │   │
 │   ├──&gt; Vector2f v;
 │   ├──&gt; Location loc {};
 │   ├──&gt; Location home_loc;
 │   ├──&gt; bool home_is_set;
 │   ├──&gt; bool have_airspeed_estimate;
 │   ├──&gt; float alt;
 │   ├──&gt; float aspd_mps = 0.0f;
 │   └──&gt; [获取地速、HOME以及当前位置、高度、空速]
 │       ├──&gt; AP_AHRS &amp;ahrs = AP::ahrs();
 │       ├──&gt; WITH_SEMAPHORE(ahrs.get_semaphore()); // minimize semaphore scope
 │       ├──&gt; v = ahrs.groundspeed_vector();
 │       ├──&gt; home_is_set = ahrs.get_location(loc) &amp;&amp; ahrs.home_is_set();
 │       ├──&gt; &lt;home_is_set&gt;
 │       │   └──&gt;home_loc = ahrs.get_home();
 │       ├──&gt; ahrs.get_relative_position_D_home(alt);
 │       └──&gt; have_airspeed_estimate = ahrs.airspeed_estimate(aspd_mps);
 │
 ├──&gt; [飞行距离更新]
 │   ├──&gt; float speed = v.length();
 │   ├──&gt; &lt;speed &lt; 0.178&gt;
 │   │   └──&gt; speed = 0.0;
 │   ├──&gt; float dist_m = (speed * delta_ms)*0.001;
 │   └──&gt; _stats.last_distance_m += dist_m;
 │
 ├──&gt; [最大地面速度更新]
 │   └──&gt; _stats.max_speed_mps = fmaxf(_stats.max_speed_mps,speed);
 │
 ├──&gt; [最大距离HOME位置更新]&lt;home_is_set&gt;
 │   ├──&gt; float distance = home_loc.get_distance(loc);
 │   └──&gt; _stats.max_dist_m = fmaxf(_stats.max_dist_m, distance);
 │
 ├──&gt; [最大高度更新]
 │   ├──&gt; alt = -alt;
 │   └──&gt; _stats.max_alt_m = fmaxf(_stats.max_alt_m, alt);
 │
 ├──&gt; &lt;AP_BATTERY_ENABLED&gt;
 │   ├──&gt; [最大电流更新]
 │   │   ├──&gt; AP_BattMonitor &amp;battery = AP::battery();
 │   │   ├──&gt; float amps;
 │   │   └──&gt; &lt;battery.current_amps(amps)&gt;  _stats.max_current_a = fmaxf(_stats.max_current_a, amps)
 │   └──&gt; [最小电压更新]
 │       ├──&gt; float voltage = battery.voltage();
 │       └──&gt; &lt;voltage &gt; 0&gt; _stats.min_voltage_v = fminf(_stats.min_voltage_v, voltage)
 │
 ├──&gt; &lt;AP_RSSI_ENABLED&gt;
 │   └──&gt; [最小RSSI更新]
 │       ├──&gt; AP_RSSI *ap_rssi = AP_RSSI::get_singleton();
 │       └──&gt; &lt;ap_rssi&gt; _stats.min_rssi = fminf(_stats.min_rssi, ap_rssi-&gt;read_receiver_rssi());
 │
 ├──&gt; [最大空速更新]
 │   └──&gt; &lt;have_airspeed_estimate&gt; _stats.max_airspeed_mps = fmaxf(_stats.max_airspeed_mps, aspd_mps);
 │
 └──&gt; &lt;HAL_WITH_ESC_TELEM&gt;
     └──&gt; [最大ESC温度更新]
         ├──&gt; AP_ESC_Telem&amp; telem = AP::esc_telem();
         ├──&gt; int16_t highest_temperature = 0;
         ├──&gt; telem.get_highest_temperature(highest_temperature);
         └──&gt; _stats.max_esc_temp = MAX(_stats.max_esc_temp, highest_temperature);
</code></pre>
    <h3>
     <a id="52_AP_OSDupdate_current_screen_215">
     </a>
     5.2 AP_OSD::update_current_screen
    </h3>
    <p>
     默认配置情况下:
    </p>
    <ul>
     <li>
      <code>
       arm_scr = 0
      </code>
     </li>
     <li>
      <code>
       disarm_scr = 0
      </code>
     </li>
     <li>
      <code>
       failsafe_scr = 0
      </code>
     </li>
     <li>
      <code>
       rc_channel = 0
      </code>
     </li>
    </ul>
    <pre><code>    // @Param: _CHAN
    // @DisplayName: Screen switch transmitter channel
    // @Description: This sets the channel used to switch different OSD screens.
    // @Values: 0:Disable,5:Chan5,6:Chan6,7:Chan7,8:Chan8,9:Chan9,10:Chan10,11:Chan11,12:Chan12,13:Chan13,14:Chan14,15:Chan15,16:Chan16
    // @User: Standard
    AP_GROUPINFO("_CHAN", 2, AP_OSD, rc_channel, 0),
    
    // @Param: _ARM_SCR
    // @DisplayName: Arm screen
    // @Description: Screen to be shown on Arm event. Zero to disable the feature.
    // @Range: 0 4
    // @User: Standard
    AP_GROUPINFO("_ARM_SCR", 17, AP_OSD, arm_scr, 0),

    // @Param: _DSARM_SCR
    // @DisplayName: Disarm screen
    // @Description: Screen to be shown on disarm event. Zero to disable the feature.
    // @Range: 0 4
    // @User: Standard
    AP_GROUPINFO("_DSARM_SCR", 18, AP_OSD, disarm_scr, 0),

    // @Param: _FS_SCR
    // @DisplayName: Failsafe screen
    // @Description: Screen to be shown on failsafe event. Zero to disable the feature.
    // @Range: 0 4
    // @User: Standard
    AP_GROUPINFO("_FS_SCR", 19, AP_OSD, failsafe_scr, 0),
</code></pre>
    <p>
     所以，默认情况以下代码不执行。
    </p>
    <pre><code class="prism language-C">AP_OSD::update_current_screen
 ├──&gt; [Switch on ARM/DISARM event]
 │   ├──&gt; &lt;AP_Notify::flags.armed&gt;
 │   │   ├──&gt; &lt;!was_armed &amp;&amp; arm_scr &gt; 0 
 │   │   │   │    &amp;&amp; arm_scr &lt;= AP_OSD_NUM_DISPLAY_SCREENS 
 │   │   │   │    &amp;&amp; get_screen(arm_scr-1).enabled&gt;
 │   │   │   └──&gt; current_screen = arm_scr-1;
 │   │   └──&gt; was_armed = true;
 │   └──&gt; &lt;was_armed&gt;
 │       ├──&gt; &lt;disarm_scr &gt; 0&gt;
 │       │   │    &amp;&amp; disarm_scr &lt;= AP_OSD_NUM_DISPLAY_SCREENS 
 │       │   │    &amp;&amp; get_screen(disarm_scr-1).enabled&gt;
 │       │   └──&gt; current_screen = disarm_scr-1;
 │       └──&gt; was_armed = false;
 │
 ├──&gt; [Switch on failsafe event]
 │   ├──&gt; &lt;AP_Notify::flags.failsafe_radio 
 │   │     || AP_Notify::flags.failsafe_battery&gt;
 │   │   ├──&gt; &lt;!was_failsafe &amp;&amp; failsafe_scr &gt; 0 
 │   │   │   │    &amp;&amp; failsafe_scr &lt;= AP_OSD_NUM_DISPLAY_SCREENS 
 │   │   │   │    &amp;&amp; get_screen(failsafe_scr-1).enabled&gt;
 │   │   │   ├──&gt; pre_fs_screen = current_screen;
 │   │   │   └──&gt; current_screen = failsafe_scr-1;
 │   │   └──&gt; was_failsafe = true;
 │   └──&gt; &lt;was_failsafe&gt;
 │       ├──&gt; &lt;get_screen(pre_fs_screen).enabled&gt;
 │       │   └──&gt; current_screen = pre_fs_screen;
 │       └──&gt; was_failsafe = false;
 │
 ├──&gt; &lt;rc_channel == 0&gt; return
 │
 └──&gt; &lt;AP_RC_CHANNEL_ENABLED&gt;
     ├──&gt; RC_Channel *channel = RC_Channels::rc_channel(rc_channel-1);
     ├──&gt; &lt;channel == nullptr&gt; return;
     ├──&gt; int16_t channel_value = channel-&gt;get_radio_in();
     ├──&gt; [switch (sw_method)] 
     │   ├──&gt; &lt;default/TOGGLE&gt; //switch to next screen if channel value was changed
     │   │   ├──&gt; &lt;previous_channel_value == 0&gt;
     │   │   │   └──&gt; previous_channel_value = channel_value; //do not switch to the next screen just after initialization
     │   │   └──&gt; &lt;abs(channel_value-previous_channel_value) &gt; 200&gt;
     │   │       ├──&gt; switch_debouncer) {
     │   │       │   ├──&gt; next_screen();
     │   │       │   └──&gt; previous_channel_value = channel_value;
     │   │       └──&gt; &lt;else&gt;
     │   │           ├──&gt; switch_debouncer = true;
     │   │           └──&gt; return;
     │   │
     │   ├──&gt; &lt;PWM_RANGE&gt; //select screen based on pwm ranges specified
     │   │   └──&gt; &lt;for (int i=0; i&lt;AP_OSD_NUM_SCREENS; i++&gt;
     │   │       └──&gt; &lt;get_screen(i).enabled 
     │   │           │ &amp;&amp; get_screen(i).channel_min &lt;= channel_value 
     │   │           │ &amp;&amp; get_screen(i).channel_max &gt; channel_value&gt;
     │   │           ├──&gt; &lt;previous_pwm_screen == i&gt;
     │   │           │   └──&gt; break;
     │   │           └──&gt; &lt;else&gt;
     │   │               └──&gt; current_screen = previous_pwm_screen = i;
     │   │
     │   └──&gt; &lt;AUTO_SWITCH&gt; //switch to next screen after low to high transition and every 1s while channel value is high
     │       ├──&gt; &lt;channel_value &gt; channel-&gt;get_radio_trim()&gt;
     │       │   ├──&gt; &lt;switch_debouncer&gt;
     │       │   │   ├──&gt; uint32_t now = AP_HAL::millis();
     │       │   │   └──&gt; &lt;now - last_switch_ms &gt; 1000&gt;
     │       │   │       ├──&gt; next_screen();
     │       │   │       └──&gt; last_switch_ms = now;
     │       │   └──&gt; &lt;else&gt;
     │       │       ├──&gt; switch_debouncer = true;
     │       │       └──&gt; return;
     │       └──&gt; &lt;else&gt;
     │           └──&gt;last_switch_ms = 0;
     └──&gt; switch_debouncer = false;
</code></pre>
    <h3>
     <a id="53_AP_OSDupdate_osd_331">
     </a>
     5.3 AP_OSD::update_osd
    </h3>
    <p>
     默认初始化时，
     <code>
      current_screen = 0
     </code>
     。
    </p>
    <p>
     所以，从这里可以看出，始终更行
     <code>
      current_screen
     </code>
     对应的OSD。
    </p>
    <pre><code class="prism language-C">AP_OSD::update_osd
 └──&gt; for &lt;instance &lt; _backend_count&gt;
     ├──&gt; _backends[instance]-&gt;clear()
     ├──&gt; &lt;!_disable&gt;
     │   ├──&gt; get_screen(current_screen).set_backend(_backends[instance])
     │   └──&gt; &lt;_backends[instance]-&gt;get_backend_type() != OSD_MSP&gt; get_screen(current_screen).draw()
     └──&gt; _backends[instance]-&gt;flush()
</code></pre>
    <p>
     <strong>
      注：应用层面OSD更新在
      <code>
       get_screen(current_screen).draw()
      </code>
      中实现，这里不再展开，后续将在其他章节介绍。
     </strong>
    </p>
    <h2>
     <a id="6__349">
     </a>
     6. 总结
    </h2>
    <p>
     为了让Ardupilot代码支持模拟+数字OSD同时显示更新，需定制固件。
    </p>
    <p>
     目前，前面提及的补丁尚未合入，且存在一个模拟越来越少使用的问题，要合入可能也存在一定的苦难。
    </p>
    <p>
     不过，对于我们的测试样机：
    </p>
    <ul>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/137013375">
       ArduPilot开源飞控之lida2003-H743-5inch套机配置
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/145585224">
       ArduPilot开源飞控之lida2003-H743-5inch配置调整
      </a>
     </li>
    </ul>
    <p>
     这里已经整理了代码：
    </p>
    <ul>
     <li>
      <a href="https://github.com/SnapDragonfly/ardupilot/commit/72b8368f391be9e1dfac0a6979c7afb8383b7747">
       AP_OSD: add two osd resolution concurrently support
      </a>
     </li>
     <li>
      <a href="https://github.com/SnapDragonfly/ardupilot/commit/c4e157ab6c4c87206f9788838db60569fa788056">
       hwdef: enable two osd resolution concurrently feature for Aocoda-RC H743 target
      </a>
     </li>
    </ul>
    <pre><code class="prism language-bash">$ <span class="token function">git</span> clone git@github.com:SnapDragonfly/ardupilot.git
or
$ <span class="token function">git</span> clone https://github.com/SnapDragonfly/ardupilot.git
$ <span class="token builtin class-name">cd</span> ardupilot
$ <span class="token function">git</span> checkout Copter-4.5-lida2003
</code></pre>
    <p>
     然后进行编译：
    </p>
    <ul>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/127707633">
       ArduPilot飞控AOCODARC-H7DUAL固件编译
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/lida2003/article/details/138851743">
       Ardupilot开源飞控工程项目编译回顾
      </a>
     </li>
    </ul>
    <h2>
     <a id="7__381">
     </a>
     7. 参考资料
    </h2>
    <p>
     【1】
     <a href="https://blog.csdn.net/lida2003/article/details/130224625">
      ArduPilot开源飞控系统之简单介绍
     </a>
     <br/>
     【2】
     <a href="https://blog.csdn.net/lida2003/article/details/130696076">
      ArduPilot之开源代码Task介绍
     </a>
     <br/>
     【3】
     <a href="https://blog.csdn.net/lida2003/article/details/130634007">
      ArduPilot飞控启动&amp;运行过程简介
     </a>
     <br/>
     【4】
     <a href="https://blog.csdn.net/lida2003/article/details/130437984">
      ArduPilot之开源代码Library&amp;Sketches设计
     </a>
     <br/>
     【5】
     <a href="https://blog.csdn.net/lida2003/article/details/130438349">
      ArduPilot之开源代码Sensor Drivers设计
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6c696461323030332f:61727469636c652f64657461696c732f313436313336333737" class_="artid" style="display:none">
 </p>
</div>


