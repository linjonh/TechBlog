---
layout: post
title: "力扣-Hot-100-刷题记录-LRU-缓存"
date: 2025-03-11 14:44:00 +0800
description: "是力扣 Hot 100 中的一道经典题目，题目要求如下：请你设计并实现一个满足缓存约束的数据结构。实现LRUCachecapacitykey-1keyvaluekey-valuecapacity函数get和put必须以O(1)的平均时间复杂度运行。输入：输出：解释：// 缓存是 {1=1}// 缓存是 {1=1, 2=2}// 返回 1// 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}// 返回 -1 (未找到)"
keywords: "力扣 Hot 100 刷题记录 - LRU 缓存"
categories: ['未分类']
tags: ['缓存', '算法', 'Leetcode']
artid: "146178816"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146178816
    alt: "力扣-Hot-100-刷题记录-LRU-缓存"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146178816
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146178816
cover: https://bing.ee123.net/img/rand?artid=146178816
image: https://bing.ee123.net/img/rand?artid=146178816
img: https://bing.ee123.net/img/rand?artid=146178816
---

# 力扣 Hot 100 刷题记录 - LRU 缓存

## 力扣 Hot 100 刷题记录 - LRU 缓存

### 题目描述

[LRU 缓存](https://leetcode.cn/problems/lru-cache/) 是力扣 Hot 100 中的一道经典题目，题目要求如下：

请你设计并实现一个满足 **LRU (最近最少使用)** 缓存约束的数据结构。

实现 `LRUCache` 类：

  * `LRUCache(int capacity)`：以正整数作为容量 `capacity` 初始化 LRU 缓存。
  * `int get(int key)`：如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1`。
  * `void put(int key, int value)`：如果关键字 `key` 已经存在，则变更其数据值 `value`；如果不存在，则插入该组 `key-value`。如果插入操作导致关键字数量超过 `capacity`，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例 1：**  
输入：  
[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]  
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]  
输出：  
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释：  
LRUCache lRUCache = new LRUCache(2);  
lRUCache.put(1, 1); // 缓存是 {1=1}  
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}  
lRUCache.get(1); // 返回 1  
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}  
lRUCache.get(2); // 返回 -1 (未找到)  
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}  
lRUCache.get(1); // 返回 -1 (未找到)  
lRUCache.get(3); // 返回 3  
lRUCache.get(4); // 返回 4

* * *

### 解题思路

这道题的核心是实现一个 LRU 缓存机制，要求 `get` 和 `put` 操作的时间复杂度为 `O(1)`。为了实现这一目标，我们需要结合以下数据结构：

  1. **哈希表** ：

     * 用于快速查找键值对，时间复杂度为 `O(1)`。
  2. **双向链表** ：

     * 用于维护键值对的访问顺序，最近使用的节点放在链表头部，最久未使用的节点放在链表尾部。
     * 双向链表的插入和删除操作时间复杂度为 `O(1)`。

* * *

### C++ 代码实现

    
    
    class LRUCache {
    private:
        struct Node {
            int key;
            int value;
            Node* prev;
            Node* next;
            Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
        };
    
        int capacity;
        unordered_map<int, Node*> cache; // 哈希表，存储键值对
        Node* head; // 双向链表的虚拟头节点
        Node* tail; // 双向链表的虚拟尾节点
    
        // 将节点移动到链表头部
        void moveToHead(Node* node) {
            removeNode(node);
            addToHead(node);
        }
    
        // 移除节点
        void removeNode(Node* node) {
            node->prev->next = node->next;
            node->next->prev = node->prev;
        }
    
        // 将节点添加到链表头部
        void addToHead(Node* node) {
            node->next = head->next;
            node->prev = head;
            head->next->prev = node;
            head->next = node;
        }
    
        // 移除链表尾部节点
        Node* removeTail() {
            Node* node = tail->prev;
            removeNode(node);
            return node;
        }
    
    public:
        LRUCache(int capacity) : capacity(capacity) {
            head = new Node(-1, -1); // 初始化虚拟头节点
            tail = new Node(-1, -1); // 初始化虚拟尾节点
            head->next = tail;
            tail->prev = head;
        }
    
        int get(int key) {
            if (cache.find(key) == cache.end()) {
                return -1; // 键不存在
            }
            Node* node = cache[key];
            moveToHead(node); // 将节点移动到链表头部
            return node->value;
        }
    
        void put(int key, int value) {
            if (cache.find(key) != cache.end()) {
                // 如果键已存在，更新值并移动到链表头部
                Node* node = cache[key];
                node->value = value;
                moveToHead(node);
            } else {
                // 如果键不存在，创建新节点并添加到链表头部
                Node* node = new Node(key, value);
                cache[key] = node;
                addToHead(node);
    
                // 如果超出容量，移除链表尾部节点
                if (cache.size() > capacity) {
                    Node* removed = removeTail();
                    cache.erase(removed->key);
                    delete removed;
                }
            }
        }
    };
    



