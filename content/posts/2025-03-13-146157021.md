---
layout: post
title: "音视频入门基础RTP专题18FFmpeg源码中,获取RTP的音频信息的实现上"
date: 2025-03-13 21:00:00 +0800
description: "FFmpeg源码中，获取RTP的音频信息的实现（上）"
keywords: "音视频入门基础：RTP专题（18）——FFmpeg源码中，获取RTP的音频信息的实现（上）"
categories: ['音视频技术', 'Ffmpeg']
tags: ['音视频', 'Ffmpeg']
artid: "146157021"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146157021
    alt: "音视频入门基础RTP专题18FFmpeg源码中,获取RTP的音频信息的实现上"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146157021
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146157021
cover: https://bing.ee123.net/img/rand?artid=146157021
image: https://bing.ee123.net/img/rand?artid=146157021
img: https://bing.ee123.net/img/rand?artid=146157021
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     音视频入门基础：RTP专题（18）——FFmpeg源码中，获取RTP的音频信息的实现（上）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     由于本文篇幅较长，分为上、下两篇。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     一、引言
    </h2>
    <p>
     通过FFmpeg命令可以获取到SDP描述的RTP流的的音频压缩编码格式、音频压缩编码格式的profile、音频采样率、通道数信息：
    </p>
    <pre><code class="language-bash">ffmpeg -protocol_whitelist "file,rtp,udp" -i XXX.sdp</code></pre>
    <p>
     <img alt="" height="508" src="https://i-blog.csdnimg.cn/direct/86ccd6f878714dec9c56d49ce0fe1c5a.png" width="1331"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     而由《
     <a class="link-info" href="https://blog.csdn.net/u014552102/article/details/146106451?sharetype=blogdetail&amp;sharerId=146106451&amp;sharerefer=PC&amp;sharesource=u014552102&amp;spm=1011.2480.3001.8118" title="音视频入门基础：RTP专题（17）——音频的SDP媒体描述">
      音视频入门基础：RTP专题（17）——音频的SDP媒体描述
     </a>
     》可以知道，SDP协议中，a=rtpmap属性和a=fmtp属性中的config参数都会重复包含音频压缩编码格式、音频采样率、通道数音频这些信息。所以FFmpeg到底获取的是哪个地方的音频信息呢，本文为大家揭开谜底。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     二、音频压缩编码格式
    </h2>
    <p>
     FFmpeg获取SDP描述的RTP流的音频压缩编码格式，是从SDP的a=rtpmap属性获取的。比如SDP中某一行的内容为：
    </p>
    <pre><code class="language-bash">a=rtpmap:97 MPEG4-GENERIC/48000/2</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     FFmpeg识别到上述“a=rtpmap”这个&lt;type&gt;后，会把后面的字符串“MPEG4-GENERIC”提取出来，检测是否存在相应的音视频压缩编码格式。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     具体可以参考：《
     <a href="https://blog.csdn.net/u014552102/article/details/145226011" title="音视频入门基础：RTP专题（5）——FFmpeg源码中，解析SDP的实现">
      音视频入门基础：RTP专题（5）——FFmpeg源码中，解析SDP的实现
     </a>
     》。
    </p>
    <p>
     当识别到上述“a=rtpmap”这个&lt;type&gt;后，sdp_parse_line函数中会调用sdp_parse_rtpmap函数：
    </p>
    <pre><code class="language-cpp">else if (av_strstart(p, "rtpmap:", &amp;p) &amp;&amp; s-&gt;nb_streams &gt; 0) {
            /* NOTE: rtpmap is only supported AFTER the 'm=' tag */
            get_word(buf1, sizeof(buf1), &amp;p);
            payload_type = atoi(buf1);
            rtsp_st = rt-&gt;rtsp_streams[rt-&gt;nb_rtsp_streams - 1];
            if (rtsp_st-&gt;stream_index &gt;= 0) {
                st = s-&gt;streams[rtsp_st-&gt;stream_index];
                sdp_parse_rtpmap(s, st, rtsp_st, payload_type, p);
            }
            s1-&gt;seen_rtpmap = 1;
            if (s1-&gt;seen_fmtp) {
                parse_fmtp(s, rt, payload_type, s1-&gt;delayed_fmtp);
            }
        } </code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     sdp_parse_rtpmap函数中又会调用ff_rtp_handler_find_by_name函数：
    </p>
    <pre><code class="language-cpp">/* parse the rtpmap description: &lt;codec_name&gt;/&lt;clock_rate&gt;[/&lt;other params&gt;] */
static int sdp_parse_rtpmap(AVFormatContext *s,
                            AVStream *st, RTSPStream *rtsp_st,
                            int payload_type, const char *p)
{
//...
    if (par-&gt;codec_id == AV_CODEC_ID_NONE) {
            const RTPDynamicProtocolHandler *handler =
            ff_rtp_handler_find_by_name(buf, par-&gt;codec_type);
    //...
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     ff_rtp_handler_find_by_name函数定义如下，可以看到其内部调用了rtp_handler_iterate函数：
    </p>
    <pre><code class="language-cpp">const RTPDynamicProtocolHandler *ff_rtp_handler_find_by_name(const char *name,
                                                       enum AVMediaType codec_type)
{
    void *i = 0;
    const RTPDynamicProtocolHandler *handler;
    while (handler = rtp_handler_iterate(&amp;i)) {
        if (handler-&gt;enc_name &amp;&amp;
            !av_strcasecmp(name, handler-&gt;enc_name) &amp;&amp;
            codec_type == handler-&gt;codec_type)
            return handler;
    }
    return NULL;
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     rtp_handler_iterate函数定义如下，可以看到该函数内部遍历了全局数组rtp_dynamic_protocol_handler_list：
    </p>
    <pre><code class="language-cpp">static const RTPDynamicProtocolHandler *rtp_handler_iterate(void **opaque)
{
    uintptr_t i = (uintptr_t)*opaque;
    const RTPDynamicProtocolHandler *r = rtp_dynamic_protocol_handler_list[i];

    if (r)
        *opaque = (void*)(i + 1);

    return r;
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     rtp_dynamic_protocol_handler_list数组定义如下：
    </p>
    <pre><code class="language-cpp">static const RTPDynamicProtocolHandler *const rtp_dynamic_protocol_handler_list[] = {
    /* rtp */
    &amp;ff_ac3_dynamic_handler,
    &amp;ff_amr_nb_dynamic_handler,
    &amp;ff_amr_wb_dynamic_handler,
    &amp;ff_dv_dynamic_handler,
    &amp;ff_g726_16_dynamic_handler,
    &amp;ff_g726_24_dynamic_handler,
    &amp;ff_g726_32_dynamic_handler,
    &amp;ff_g726_40_dynamic_handler,
    &amp;ff_g726le_16_dynamic_handler,
    &amp;ff_g726le_24_dynamic_handler,
    &amp;ff_g726le_32_dynamic_handler,
    &amp;ff_g726le_40_dynamic_handler,
    &amp;ff_h261_dynamic_handler,
    &amp;ff_h263_1998_dynamic_handler,
    &amp;ff_h263_2000_dynamic_handler,
    &amp;ff_h263_rfc2190_dynamic_handler,
    &amp;ff_h264_dynamic_handler,
    &amp;ff_hevc_dynamic_handler,
    &amp;ff_ilbc_dynamic_handler,
    &amp;ff_jpeg_dynamic_handler,
    &amp;ff_mp4a_latm_dynamic_handler,
    &amp;ff_mp4v_es_dynamic_handler,
    &amp;ff_mpeg_audio_dynamic_handler,
    &amp;ff_mpeg_audio_robust_dynamic_handler,
    &amp;ff_mpeg_video_dynamic_handler,
    &amp;ff_mpeg4_generic_dynamic_handler,
    &amp;ff_mpegts_dynamic_handler,
    &amp;ff_ms_rtp_asf_pfa_handler,
    &amp;ff_ms_rtp_asf_pfv_handler,
    &amp;ff_qcelp_dynamic_handler,
    &amp;ff_qdm2_dynamic_handler,
    &amp;ff_qt_rtp_aud_handler,
    &amp;ff_qt_rtp_vid_handler,
    &amp;ff_quicktime_rtp_aud_handler,
    &amp;ff_quicktime_rtp_vid_handler,
    &amp;ff_rfc4175_rtp_handler,
    &amp;ff_svq3_dynamic_handler,
    &amp;ff_theora_dynamic_handler,
    &amp;ff_vc2hq_dynamic_handler,
    &amp;ff_vorbis_dynamic_handler,
    &amp;ff_vp8_dynamic_handler,
    &amp;ff_vp9_dynamic_handler,
    &amp;gsm_dynamic_handler,
    &amp;l24_dynamic_handler,
    &amp;opus_dynamic_handler,
    &amp;realmedia_mp3_dynamic_handler,
    &amp;speex_dynamic_handler,
    &amp;t140_dynamic_handler,
    /* rdt */
    &amp;ff_rdt_video_handler,
    &amp;ff_rdt_audio_handler,
    &amp;ff_rdt_live_video_handler,
    &amp;ff_rdt_live_audio_handler,
    NULL,
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     rtp_dynamic_protocol_handler_list数组中的每个元素都把SDP协议中的&lt;encoding name&gt;和具体的音视频压缩编码格式对应起来，比如“MPEG4-GENERIC”对应AAC：
    </p>
    <pre><code class="language-cpp">const RTPDynamicProtocolHandler ff_mpeg4_generic_dynamic_handler = {
    .enc_name           = "mpeg4-generic",
    .codec_type         = AVMEDIA_TYPE_AUDIO,
    .codec_id           = AV_CODEC_ID_AAC,
    .priv_data_size     = sizeof(PayloadContext),
    .parse_sdp_a_line   = parse_sdp_line,
    .close              = close_context,
    .parse_packet       = aac_parse_packet,
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     X-MP3-draft-00"对应MP3ADU：
    </p>
    <pre><code class="language-cpp">static const RTPDynamicProtocolHandler realmedia_mp3_dynamic_handler = {
    .enc_name   = "X-MP3-draft-00",
    .codec_type = AVMEDIA_TYPE_AUDIO,
    .codec_id   = AV_CODEC_ID_MP3ADU,
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     所以sdp_parse_rtpmap函数中执行语句：ff_rtp_handler_find_by_name(buf, par-&gt;codec_type)后，会通过遍历全局数组rtp_dynamic_protocol_handler_list，找到SDP协议中的&lt;encoding name&gt;对应的音视频压缩编码格式（比如“MPEG4-GENERIC”对应的是AAC），将其赋值给st-&gt;codecpar-&gt;codec_id（即AVCodecParameters的codec_id）：
    </p>
    <pre><code class="language-cpp">/* parse the rtpmap description: &lt;codec_name&gt;/&lt;clock_rate&gt;[/&lt;other params&gt;] */
static int sdp_parse_rtpmap(AVFormatContext *s,
                            AVStream *st, RTSPStream *rtsp_st,
                            int payload_type, const char *p)
{
//...
    if (par-&gt;codec_id == AV_CODEC_ID_NONE) {
            const RTPDynamicProtocolHandler *handler =
            ff_rtp_handler_find_by_name(buf, par-&gt;codec_type);
    //...
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在sdp_parse_line函数外部，通过avcodec_parameters_to_context函数将AVCodecParameters的codec_id赋值给AVCodecContext的codec_id：
    </p>
    <pre><code class="language-cpp">int avcodec_parameters_to_context(AVCodecContext *codec,
                                  const AVCodecParameters *par)
{
//...
    codec-&gt;codec_id   = par-&gt;codec_id;
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在dump_stream_format函数中，通过avcodec_string函数中的语句：codec_name = avcodec_get_name(enc-&gt;codec_id) 拿到AVCodecContext的codec_id对应的音频压缩编码格式名称。最后再在dump_stream_format函数中将音频压缩编码格式打印出来：
    </p>
    <pre><code class="language-cpp">void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
{
//...
    codec_name = avcodec_get_name(enc-&gt;codec_id);
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     所以FFmpeg获取SDP描述的RTP流的音频压缩编码格式，是从SDP的“a=rtpmap”这一行获取的：
    </p>
    <p>
     <img alt="" height="484" src="https://i-blog.csdnimg.cn/direct/236c6781c2724e54b8a6f539bc8dd420.png" width="1332"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     三、音频压缩编码格式的profile
    </h2>
    <p>
     音频压缩编码格式还有附带的profile（规格）。比如音频压缩编码格式为AAC，根据《ISO14496-3-2009.pdf》第124页，还有AAC Main、AAC LC、AAC SSR、AAC LTP这几种规格：
    </p>
    <p>
     <img alt="" height="331" src="https://i-blog.csdnimg.cn/direct/d81b1d692887467ab118186003573fc8.png" width="1071"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     FFmpeg获取SDP描述的RTP流的音频压缩编码格式的profile，获取的是a=fmtp属性中的config参数中的信息，即AudioSpecificConfig中的audioObjectType。由《
     <a href="https://blog.csdn.net/u014552102/article/details/143202232?spm=1001.2014.3001.5502" title="音视频入门基础：AAC专题（11）——AudioSpecificConfig简介">
      音视频入门基础：AAC专题（11）——AudioSpecificConfig简介
     </a>
     》可以知道，Audio Specific Config中存在一个占5位或11位的audioObjectType属性，表示音频对象类型：
    </p>
    <p>
     0: Null
     <br/>
     1: AAC Main
     <br/>
     2: AAC LC (Low Complexity)
     <br/>
     3: AAC SSR (Scalable Sample Rate)
     <br/>
     4: AAC LTP (Long Term Prediction)
     <br/>
     5: SBR (Spectral Band Replication)
     <br/>
     6: AAC Scalable
     <br/>
     7: TwinVQ
     <br/>
     8: CELP (Code Excited Linear Prediction)
     <br/>
     9: HXVC (Harmonic Vector eXcitation Coding)
     <br/>
     10: Reserved
     <br/>
     11: Reserved
     <br/>
     12: TTSI (Text-To-Speech Interface)
     <br/>
     13: Main Synthesis
     <br/>
     14: Wavetable Synthesis
     <br/>
     15: General MIDI
     <br/>
     16: Algorithmic Synthesis and Audio Effects
     <br/>
     17: ER (Error Resilient) AAC LC
     <br/>
     18: Reserved
     <br/>
     19: ER AAC LTP
     <br/>
     20: ER AAC Scalable
     <br/>
     21: ER TwinVQ
     <br/>
     22: ER BSAC (Bit-Sliced Arithmetic Coding)
     <br/>
     23: ER AAC LD (Low Delay)
     <br/>
     24: ER CELP
     <br/>
     25: ER HVXC
     <br/>
     26: ER HILN (Harmonic and Individual Lines plus Noise)
     <br/>
     27: ER Parametric
     <br/>
     28: SSC (SinuSoidal Coding)
     <br/>
     29: PS (Parametric Stereo)
     <br/>
     30: MPEG Surround
     <br/>
     31: (Escape value)
     <br/>
     32: Layer-1
     <br/>
     33: Layer-2
     <br/>
     34: Layer-3
     <br/>
     35: DST (Direct Stream Transfer)
     <br/>
     36: ALS (Audio Lossless)
     <br/>
     37: SLS (Scalable LosslesS)
     <br/>
     38: SLS non-core
     <br/>
     39: ER AAC ELD (Enhanced Low Delay)
     <br/>
     40: SMR (Symbolic Music Representation) Simple
     <br/>
     41: SMR Main
     <br/>
     42: USAC (Unified Speech and Audio Coding) (no SBR)
     <br/>
     43: SAOC (Spatial Audio Object Coding)
     <br/>
     44: LD MPEG Surround
     <br/>
     45: USAC
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     由《
     <a href="https://blog.csdn.net/u014552102/article/details/143277399?sharetype=blogdetail&amp;sharerId=143277399&amp;sharerefer=PC&amp;sharesource=u014552102&amp;spm=1011.2480.3001.8118" title="音视频入门基础：AAC专题（12）——FFmpeg源码中，解码AudioSpecificConfig的实现">
      音视频入门基础：AAC专题（12）——FFmpeg源码中，解码AudioSpecificConfig的实现
     </a>
     》可以知道，
    </p>
    <p>
     FFmpeg源码中使用decode_audio_specific_config_gb函数来读取AudioSpecificConfig的信息。decode_audio_specific_config_gb函数中会调用ff_mpeg4audio_get_config_gb函数，而ff_mpeg4audio_get_config_gb函数中，通过语句：c-&gt;object_type = get_object_type(gb) 获取AudioSpecificConfig的audioObjectType属性。执行decode_audio_specific_config_gb函数后，m4ac指向的变量会得到从AudioSpecificConfig中解码出来的属性：
    </p>
    <pre><code class="language-cpp">static inline int get_object_type(GetBitContext *gb)
{
    int object_type = get_bits(gb, 5);
    if (object_type == AOT_ESCAPE)
        object_type = 32 + get_bits(gb, 6);
    return object_type;
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在decode_audio_specific_config_gb函数外部，通过aac_decode_frame_int函数将上一步得到的audioObjectType属性赋值给AVCodecContext的profile：
    </p>
    <pre><code class="language-cpp">static int aac_decode_frame_int(AVCodecContext *avctx, AVFrame *frame,
                                int *got_frame_ptr, GetBitContext *gb,
                                const AVPacket *avpkt)
{
//...
    // The AV_PROFILE_AAC_* defines are all object_type - 1
    // This may lead to an undefined profile being signaled
    ac-&gt;avctx-&gt;profile = ac-&gt;oc[1].m4ac.object_type - 1;
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在dump_stream_format函数中，通过avcodec_string函数中的语句：profile = avcodec_profile_name(enc-&gt;codec_id, enc-&gt;profile)拿到上一步中得到的AVCodecContext的profile。最后再在dump_stream_format函数中将profile打印出来：
    </p>
    <pre><code class="language-cpp">void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
{
//...
    profile = avcodec_profile_name(enc-&gt;codec_id, enc-&gt;profile);
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     所以FFmpeg获取SDP描述的RTP流的的音频压缩编码格式的profile，获取的是a=fmtp属性中的config参数中的信息，即AudioSpecificConfig中的audioObjectType：
    </p>
    <p>
     <img alt="" height="498" src="https://i-blog.csdnimg.cn/direct/555e957a025340df97f48cec4f8cf3e5.png" width="1336"/>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031343535323130322f:61727469636c652f64657461696c732f313436313537303231" class_="artid" style="display:none">
 </p>
</div>


