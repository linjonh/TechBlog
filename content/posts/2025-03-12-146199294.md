---
layout: post
title: "C-WPF-基础知识学习二"
date: 2025-03-12 10:59:37 +0800
description: "样式是一种用于集中设置 UI 元素属性的机制，可以将一组属性应用到多个元素上，实现统一的外观风格。命令是一种抽象的操作，它定义了操作的执行逻辑和是否可以执行的判断逻辑。WPF 提供了丰富的动画系统，允许对 UI 元素的属性进行动态变化，从而创建出各种生动的效果。是一个动态集合，当集合中的元素发生添加、删除或修改操作时，会自动通知绑定的 UI 元素进行更新。可以将资源字典定义在单独的。用于定义触发条件，当鼠标悬停在按钮上时，改变按钮的背景色。通过这种方式，可以实现资源的共享和复用，提高代码的可维护性。"
keywords: "C# WPF 基础知识学习（二）"
categories: ['未分类']
tags: ['计算机视觉', '开发语言', '学习', '人工智能', 'Wpf', 'C']
artid: "146199294"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146199294
    alt: "C-WPF-基础知识学习二"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146199294
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146199294
cover: https://bing.ee123.net/img/rand?artid=146199294
image: https://bing.ee123.net/img/rand?artid=146199294
img: https://bing.ee123.net/img/rand?artid=146199294
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# WPF 基础知识学习（二）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     四、数据绑定
    </h3>
    <h4>
     （一）数据绑定基础
    </h4>
    <ol>
     <li>
      <strong>
       绑定源和目标
      </strong>
      ：数据绑定建立了 UI 元素（绑定目标）属性与数据源（绑定源）之间的联系。例如，将一个
      <code>
       TextBox
      </code>
      的
      <code>
       Text
      </code>
      属性绑定到一个对象的某个属性上。绑定源可以是对象的属性、集合、XML 数据等，绑定目标通常是 UI 元素的依赖属性。
     </li>
     <li>
      <strong>
       绑定模式
      </strong>
      ：WPF 支持三种绑定模式：
      <ul>
       <li>
        <strong>
         OneWay
        </strong>
        ：数据从绑定源流向绑定目标。当绑定源属性值发生变化时，绑定目标属性会自动更新，但绑定目标的变化不会影响绑定源。例如，将一个只读的文本框绑定到一个数据模型中的属性，用于显示数据。
       </li>
      </ul>
     </li>
    </ol>
    <pre><code class="language-XML">&lt;TextBox Text="{Binding MyReadOnlyProperty, Mode=OneWay}"/&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       TwoWay
      </strong>
      ：数据在绑定源和绑定目标之间双向流动。当绑定源属性值变化时，绑定目标更新；当绑定目标属性值变化时，绑定源也会相应更新。常用于需要用户输入并更新数据模型的场景，如编辑文本框。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBox Text="{Binding MyEditableProperty, Mode=TwoWay}"/&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       OneTime
      </strong>
      ：数据在初始化时从绑定源流向绑定目标，之后绑定源的变化不会再影响绑定目标。适用于数据在应用程序运行过程中不会改变的情况，如显示应用程序版本号等。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBlock Text="{Binding AppVersion, Mode=OneTime}"/&gt;
</code></pre>
    <h4>
     （二）实现数据绑定
    </h4>
    <p>
    </p>
    <ol>
     <li>
      <strong>
       创建数据源
      </strong>
      ：通常会创建一个 ViewModel 类来作为数据源。ViewModel 类应该实现
      <code>
       INotifyPropertyChanged
      </code>
      接口，以便在属性值发生变化时通知绑定目标更新。例如：
     </li>
    </ol>
    <pre><code class="language-cs">public class UserViewModel : INotifyPropertyChanged
{
    private string _name;
    public string Name
    {
        get { return _name; }
        set
        {
            _name = value;
            OnPropertyChanged(nameof(Name));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</code></pre>
    <p>
    </p>
    <ol>
     <li>
      <strong>
       在 XAML 中设置绑定
      </strong>
      ：在 XAML 文件中，将 UI 元素的属性绑定到 ViewModel 的属性上。假设在窗口的代码隐藏文件中创建了
      <code>
       UserViewModel
      </code>
      的实例，并将其设置为窗口的
      <code>
       DataContext
      </code>
      ：
     </li>
    </ol>
    <pre><code class="language-cs">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        UserViewModel viewModel = new UserViewModel();
        DataContext = viewModel;
    }
}
</code></pre>
    <p>
     在 XAML 中：
    </p>
    <pre><code class="language-XML">&lt;TextBox Text="{Binding Name}"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     这样，
     <code>
      TextBox
     </code>
     的
     <code>
      Text
     </code>
     属性就与
     <code>
      UserViewModel
     </code>
     中的
     <code>
      Name
     </code>
     属性绑定在一起了，当
     <code>
      Name
     </code>
     属性值改变时，
    </p>
    <p>
     <code>
      TextBox
     </code>
     中的文本会自动更新，反之，当用户在
     <code>
      TextBox
     </code>
     中输入新的文本时，
     <code>
      Name
     </code>
     属性的值也会相应更新（如果绑定模式是
     <code>
      TwoWay
     </code>
     ）。
    </p>
    <h4>
     （三）绑定到集合
    </h4>
    <p>
     在实际应用中，经常需要将 UI 元素绑定到集合数据上，例如将
     <code>
      ListView
     </code>
     或
     <code>
      ComboBox
     </code>
     绑定到一个
     <code>
      ObservableCollection
     </code>
     。
     <code>
      ObservableCollection
     </code>
     是一个动态集合，当集合中的元素发生添加、删除或修改操作时，会自动通知绑定的 UI 元素进行更新。
    </p>
    <p>
     以下是一个将
     <code>
      ListView
     </code>
     绑定到
     <code>
      ObservableCollection
     </code>
     的示例：
    </p>
    <pre><code class="language-cs">public class EmployeeViewModel
{
    public ObservableCollection&lt;Employee&gt; Employees { get; set; }

    public EmployeeViewModel()
    {
        Employees = new ObservableCollection&lt;Employee&gt;
        {
            new Employee { Name = "John Doe", Age = 30 },
            new Employee { Name = "Jane Smith", Age = 25 },
            new Employee { Name = "Bob Johnson", Age = 35 }
        };
    }
}

public class Employee
{
    public string Name { get; set; }
    public int Age { get; set; }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;DataTemplate x:Key="EmployeeTemplate"&gt;
        &lt;StackPanel Orientation="Horizontal"&gt;
            &lt;TextBlock Text="{Binding Name}" Margin="5"/&gt;
            &lt;TextBlock Text="{Binding Age}" Margin="5"/&gt;
        &lt;/StackPanel&gt;
    &lt;/DataTemplate&gt;
&lt;/Window.Resources&gt;
&lt;ListView ItemsSource="{Binding Employees}" ItemTemplate="{StaticResource EmployeeTemplate}"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在窗口的代码隐藏文件中设置
     <code>
      DataContext
     </code>
     ：
    </p>
    <pre><code class="language-cs">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        EmployeeViewModel viewModel = new EmployeeViewModel();
        DataContext = viewModel;
    }
}
</code></pre>
    <p>
    </p>
    <p>
     这样，
     <code>
      ListView
     </code>
     会显示
     <code>
      Employees
     </code>
     集合中的每个
     <code>
      Employee
     </code>
     对象，并且使用
     <code>
      EmployeeTemplate
     </code>
     定义的模板来呈现每个对象的
     <code>
      Name
     </code>
     和
     <code>
      Age
     </code>
     属性。
    </p>
    <h4>
     （四）数据绑定的其他特性
    </h4>
    <ol>
     <li>
      <strong>
       绑定转换器
      </strong>
      ：当绑定源和绑定目标的类型不匹配时，或者需要对绑定值进行一些转换时，可以使用绑定转换器。绑定转换器是实现了
      <code>
       IValueConverter
      </code>
      接口的类。例如，将一个布尔值转换为字符串显示：
     </li>
    </ol>
    <pre><code class="language-cs">public class BooleanToStringConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
        {
            return boolValue ? "Yes" : "No";
        }
        return null;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string stringValue)
        {
            return stringValue == "Yes";
        }
        return false;
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中使用转换器：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;local:BooleanToStringConverter x:Key="BooleanToStringConverter"/&gt;
&lt;/Window.Resources&gt;
&lt;TextBlock Text="{Binding IsActive, Converter={StaticResource BooleanToStringConverter}}"/&gt;
</code></pre>
    <p>
    </p>
    <ol>
     <li>
      <strong>
       绑定验证
      </strong>
      ：在用户输入数据时，需要对输入的数据进行验证，确保数据的有效性。WPF 提供了绑定验证机制，可以通过实现
      <code>
       IDataErrorInfo
      </code>
      接口或使用
      <code>
       ValidationRule
      </code>
      类来实现验证。例如，验证一个文本框输入的是否为有效的整数：
     </li>
    </ol>
    <pre><code class="language-cs">public class IntegerValidationRule : ValidationRule
{
    public override ValidationResult Validate(object value, CultureInfo cultureInfo)
    {
        if (int.TryParse(value as string, out _))
        {
            return ValidationResult.ValidResult;
        }
        return new ValidationResult(false, "请输入有效的整数。");
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中应用验证规则：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;local:IntegerValidationRule x:Key="IntegerValidationRule"/&gt;
&lt;/Window.Resources&gt;
&lt;TextBox&gt;
    &lt;TextBox.Text&gt;
        &lt;Binding Path="Age" UpdateSourceTrigger="PropertyChanged"&gt;
            &lt;Binding.ValidationRules&gt;
                &lt;local:IntegerValidationRule/&gt;
            &lt;/Binding.ValidationRules&gt;
        &lt;/Binding&gt;
    &lt;/TextBox.Text&gt;
&lt;/TextBox&gt;
</code></pre>
    <p>
    </p>
    <p>
     当用户输入的不是有效的整数时，文本框会显示验证错误信息。
    </p>
    <h3>
     五、样式和模板
    </h3>
    <h4>
     （一）样式基础
    </h4>
    <p>
     样式是一种用于集中设置 UI 元素属性的机制，可以将一组属性应用到多个元素上，实现统一的外观风格。样式可以定义在资源字典中，也可以直接在 XAML 文件中定义。
    </p>
    <p>
     以下是一个简单的样式定义示例：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Style x:Key="MyButtonStyle" TargetType="Button"&gt;
        &lt;Setter Property="Background" Value="LightBlue"/&gt;
        &lt;Setter Property="Foreground" Value="White"/&gt;
        &lt;Setter Property="FontSize" Value="14"/&gt;
    &lt;/Style&gt;
&lt;/Window.Resources&gt;
&lt;Button Style="{StaticResource MyButtonStyle}" Content="Styled Button"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，定义了一个名为
     <code>
      MyButtonStyle
     </code>
     的样式，目标类型是
     <code>
      Button
     </code>
     。通过
     <code>
      Setter
     </code>
     元素设置了按钮的背景色、前景色和字体大小。然后将这个样式应用到一个按钮上。
    </p>
    <h4>
     （二）隐式样式
    </h4>
    <p>
     隐式样式是一种不指定
     <code>
      x:Key
     </code>
     的样式，它会自动应用到所有指定
     <code>
      TargetType
     </code>
     的元素上。例如：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Style TargetType="Button"&gt;
        &lt;Setter Property="Background" Value="Green"/&gt;
        &lt;Setter Property="Foreground" Value="White"/&gt;
    &lt;/Style&gt;
&lt;/Window.Resources&gt;
&lt;Button Content="Implicit Styled Button"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，定义了一个隐式样式，目标类型是
     <code>
      Button
     </code>
     。所有在该窗口中的按钮都会自动应用这个样式。
    </p>
    <h4>
     （三）模板基础
    </h4>
    <p>
     模板用于自定义 UI 元素的可视化结构。WPF 提供了两种主要的模板类型：
     <code>
      ControlTemplate
     </code>
     和
     <code>
      DataTemplate
     </code>
     。
    </p>
    <ol>
     <li>
      <strong>
       ControlTemplate
      </strong>
      ：用于自定义控件的外观。例如，自定义一个按钮的模板：
     </li>
    </ol>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;ControlTemplate x:Key="CustomButtonTemplate" TargetType="Button"&gt;
        &lt;Border Background="{TemplateBinding Background}" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"&gt;
            &lt;ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/&gt;
        &lt;/Border&gt;
        &lt;ControlTemplate.Triggers&gt;
            &lt;Trigger Property="IsMouseOver" Value="True"&gt;
                &lt;Setter Property="Background" Value="LightGray"/&gt;
            &lt;/Trigger&gt;
        &lt;/ControlTemplate.Triggers&gt;
    &lt;/ControlTemplate&gt;
&lt;/Window.Resources&gt;
&lt;Button Template="{StaticResource CustomButtonTemplate}" Content="Custom Button"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，定义了一个
     <code>
      ControlTemplate
     </code>
     ，通过
     <code>
      Border
     </code>
     元素和
     <code>
      ContentPresenter
     </code>
     元素来构建按钮的外观。
     <code>
      TemplateBinding
     </code>
     用于将模板中的属性绑定到控件的实际属性上。
     <code>
      ControlTemplate.Triggers
     </code>
     用于定义触发条件，当鼠标悬停在按钮上时，改变按钮的背景色。
    </p>
    <ol>
     <li>
      <strong>
       DataTemplate
      </strong>
      ：用于定义数据项的呈现方式。例如，将一个列表框中的数据项以自定义的方式显示：
     </li>
    </ol>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;DataTemplate x:Key="PersonDataTemplate"&gt;
        &lt;StackPanel Orientation="Horizontal"&gt;
            &lt;TextBlock Text="{Binding Name}" Margin="5"/&gt;
            &lt;TextBlock Text="{Binding Age}" Margin="5"/&gt;
        &lt;/StackPanel&gt;
    &lt;/DataTemplate&gt;
&lt;/Window.Resources&gt;
&lt;ListBox ItemsSource="{Binding Persons}" ItemTemplate="{StaticResource PersonDataTemplate}"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，定义了一个
     <code>
      DataTemplate
     </code>
     ，用于显示
     <code>
      Persons
     </code>
     集合中的每个
     <code>
      Person
     </code>
     对象。
     <code>
      DataTemplate
     </code>
     中使用
     <code>
      StackPanel
     </code>
     水平排列
     <code>
      Name
     </code>
     和
     <code>
      Age
     </code>
     属性的文本块。
    </p>
    <h4>
     （四）资源字典
    </h4>
    <p>
     资源字典是一种用于集中管理样式、模板、画笔等资源的机制。可以将资源字典定义在单独的
     <code>
      .xaml
     </code>
     文件中，然后在多个 XAML 文件中引用。
    </p>
    <p>
     以下是一个资源字典文件
     <code>
      MyResources.xaml
     </code>
     的示例：
    </p>
    <pre><code class="language-XML">&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
    &lt;Style x:Key="MyButtonStyle" TargetType="Button"&gt;
        &lt;Setter Property="Background" Value="Orange"/&gt;
        &lt;Setter Property="Foreground" Value="White"/&gt;
    &lt;/Style&gt;
&lt;/ResourceDictionary&gt;
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 文件中引用资源字典：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;ResourceDictionary&gt;
        &lt;ResourceDictionary.MergedDictionaries&gt;
            &lt;ResourceDictionary Source="MyResources.xaml"/&gt;
        &lt;/ResourceDictionary.MergedDictionaries&gt;
    &lt;/ResourceDictionary&gt;
&lt;/Window.Resources&gt;
&lt;Button Style="{StaticResource MyButtonStyle}" Content="Button from Resource Dictionary"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     通过这种方式，可以实现资源的共享和复用，提高代码的可维护性。
    </p>
    <h3>
     六、动画和多媒体
    </h3>
    <h4>
     （一）动画基础
    </h4>
    <p>
     WPF 提供了丰富的动画系统，允许对 UI 元素的属性进行动态变化，从而创建出各种生动的效果。动画主要分为线性动画、关键帧动画和路径动画。
    </p>
    <ol>
     <li>
      <strong>
       线性动画
      </strong>
      ：线性动画是最简单的动画类型，它在指定的时间内从一个值线性变化到另一个值。例如，实现一个按钮在点击时逐渐变大的动画：
     </li>
    </ol>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Storyboard x:Key="GrowButtonAnimation"&gt;
        &lt;DoubleAnimation Storyboard.TargetProperty="Width"
                         From="100" To="150" Duration="0:0:0.5"/&gt;
        &lt;DoubleAnimation Storyboard.TargetProperty="Height"
                         From="50" To="75" Duration="0:0:0.5"/&gt;
    &lt;/Storyboard&gt;
&lt;/Window.Resources&gt;
&lt;Button Content="Animate Me" Click="Button_Click"&gt;
    &lt;Button.Triggers&gt;
        &lt;EventTrigger RoutedEvent="Button.Click"&gt;
            &lt;BeginStoryboard Storyboard="{StaticResource GrowButtonAnimation}"/&gt;
        &lt;/EventTrigger&gt;
    &lt;/Button.Triggers&gt;
&lt;/Button&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，定义了一个
     <code>
      Storyboard
     </code>
     ，其中包含两个
     <code>
      DoubleAnimation
     </code>
     ，分别对按钮的
     <code>
      Width
     </code>
     和
     <code>
      Height
     </code>
     属性进行动画处理。当按钮被点击时，触发
     <code>
      EventTrigger
     </code>
     ，开始播放动画。
    </p>
    <ol>
     <li>
      <strong>
       关键帧动画
      </strong>
      ：关键帧动画允许在动画过程中定义多个关键帧，每个关键帧指定一个特定的时间点和属性值。例如，实现一个按钮在不同时间点改变颜色的动画：
     </li>
    </ol>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Storyboard x:Key="ColorAnimationStoryboard"&gt;
        &lt;ColorAnimationUsingKeyFrames Storyboard.TargetProperty="(Control.Background).(SolidColorBrush.Color)" Duration="0:0:2"&gt;
            &lt;LinearColorKeyFrame Value="Red" KeyTime="0:0:0"/&gt;
            &lt;LinearColorKeyFrame Value="Green" KeyTime="0:0:1"/&gt;
            &lt;LinearColorKeyFrame Value="Blue" KeyTime="0:0:2"/&gt;
        &lt;/ColorAnimationUsingKeyFrames&gt;
    &lt;/Storyboard&gt;
&lt;/Window.Resources&gt;
&lt;Button Content="Color Animate" Click="Button_Click_1"&gt;
    &lt;Button.Triggers&gt;
        &lt;EventTrigger RoutedEvent="Button.Click"&gt;
            &lt;BeginStoryboard Storyboard="{StaticResource ColorAnimationStoryboard}"/&gt;
        &lt;/EventTrigger&gt;
    &lt;/Button.Triggers&gt;
&lt;/Button&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，使用
     <code>
      ColorAnimationUsingKeyFrames
     </code>
     定义了一个颜色动画，通过
     <code>
      LinearColorKeyFrame
     </code>
     指定了不同时间点的颜色值。
    </p>
    <ol>
     <li>
      <strong>
       路径动画
      </strong>
      ：路径动画允许元素沿着指定的路径移动。例如，让一个椭圆沿着一个圆形路径移动：
     </li>
    </ol>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Storyboard x:Key="PathAnimationStoryboard"&gt;
        &lt;PointAnimationUsingPath Storyboard.TargetProperty="(Canvas.LeftProperty)"
                                 Storyboard.TargetName="ellipse"
                                 Duration="0:0:5"
                                 RepeatBehavior="Forever"&gt;
            &lt;PointAnimationUsingPath.PathGeometry&gt;
                &lt;EllipseGeometry Center="200,200" RadiusX="100" RadiusY="100"/&gt;
            &lt;/PointAnimationUsingPath.PathGeometry&gt;
        &lt;/PointAnimationUsingPath&gt;
    &lt;/Storyboard&gt;
&lt;/Window.Resources&gt;
&lt;Canvas&gt;
    &lt;Ellipse x:Name="ellipse" Width="20" Height="20" Fill="Red" Canvas.Left="100" Canvas.Top="100"/&gt;
    &lt;Button Content="Start Animation" Canvas.Left="10" Canvas.Top="10" Click="Button_Click_2"&gt;
        &lt;Button.Triggers&gt;
            &lt;EventTrigger RoutedEvent="Button.Click"&gt;
                &lt;BeginStoryboard Storyboard="{StaticResource PathAnimationStoryboard}"/&gt;
            &lt;/EventTrigger&gt;
        &lt;/Button.Triggers&gt;
    &lt;/Button&gt;
&lt;/Canvas&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，使用
     <code>
      PointAnimationUsingPath
     </code>
     让椭圆沿着一个圆形路径移动，路径由
     <code>
      EllipseGeometry
     </code>
     定义。
    </p>
    <h4>
     （二）多媒体支持
    </h4>
    <p>
     WPF 提供了对多媒体的支持，包括音频和视频的播放。可以使用
     <code>
      MediaElement
     </code>
     控件来播放多媒体文件。
    </p>
    <p>
     以下是一个播放视频的示例：
    </p>
    <pre><code class="language-XML">&lt;MediaElement Source="video.mp4" Width="640" Height="360"
              LoadedBehavior="Play" UnloadedBehavior="Stop"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，
     <code>
      MediaElement
     </code>
     控件的
     <code>
      Source
     </code>
     属性指定了要播放的视频文件的路径。
     <code>
      LoadedBehavior
     </code>
     属性设置为
     <code>
      Play
     </code>
     表示当控件加载完成后自动播放视频，
     <code>
      UnloadedBehavior
     </code>
     属性设置为
     <code>
      Stop
     </code>
     表示当控件卸载时停止播放视频。
    </p>
    <h3>
     七、命令系统
    </h3>
    <h4>
     （一）命令基础
    </h4>
    <p>
     WPF 的命令系统提供了一种将用户操作（如按钮点击、菜单项选择等）与业务逻辑分离的机制。命令是一种抽象的操作，它定义了操作的执行逻辑和是否可以执行的判断逻辑。
    </p>
    <h4>
     （二）实现命令
    </h4>
    <p>
     WPF 中常用的命令实现方式是使用
     <code>
      RelayCommand
     </code>
     类，它是一个自定义的命令类，实现了
     <code>
      ICommand
     </code>
     接口。以下是一个
     <code>
      RelayCommand
     </code>
     类的实现：
    </p>
    <pre><code class="language-cs">public class RelayCommand : ICommand
{
    private readonly Action&lt;object&gt; _execute;
    private readonly Predicate&lt;object&gt; _canExecute;

    public RelayCommand(Action&lt;object&gt; execute, Predicate&lt;object&gt; canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }

    public void Execute(object parameter)
    {
        _execute(parameter);
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在 ViewModel 中使用
     <code>
      RelayCommand
     </code>
     ：
    </p>
    <pre><code class="language-cs">public class MainViewModel
{
    public RelayCommand MyCommand { get; set; }

    public MainViewModel()
    {
        MyCommand = new RelayCommand(ExecuteMyCommand, CanExecuteMyCommand);
    }

    private void ExecuteMyCommand(object parameter)
    {
        // 执行命令的逻辑
        MessageBox.Show("Command executed!");
    }

    private bool CanExecuteMyCommand(object parameter)
    {
        // 判断命令是否可以执行的逻辑
        return true;
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中绑定命令：
    </p>
    <pre><code class="language-XML">&lt;Button Content="Execute Command" Command="{Binding MyCommand}"/&gt;
</code></pre>
    <h4>
     （三）系统命令
    </h4>
    <p>
     WPF 还提供了一些内置的系统命令，如
     <code>
      ApplicationCommands.New
     </code>
     、
     <code>
      ApplicationCommands.Open
     </code>
     、
     <code>
      ApplicationCommands.Save
     </code>
     等。这些命令可以直接在 XAML 中使用，例如：
    </p>
    <pre><code class="language-XML">&lt;Menu&gt;
    &lt;MenuItem Header="File"&gt;
        &lt;MenuItem Header="New" Command="{x:Static ApplicationCommands.New}"/&gt;
        &lt;MenuItem Header="Open" Command="{x:Static ApplicationCommands.Open}"/&gt;
        &lt;MenuItem Header="Save" Command="{x:Static ApplicationCommands.Save}"/&gt;
    &lt;/MenuItem&gt;
&lt;/Menu&gt;
</code></pre>
    <p>
     系统命令会自动处理一些常见的操作，如快捷键绑定、命令状态更新等。
    </p>
    <p>
     <img alt="" height="600" src="https://i-blog.csdnimg.cn/direct/2d5bb260b23345aca1221e45131e57c2.png" width="1000"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34343937353831342f:61727469636c652f64657461696c732f313436313939323934" class_="artid" style="display:none">
 </p>
</div>


