---
layout: post
title: "3.14-进程间通信"
date: 2025-03-15 21:03:44 +0800
description: "3.14-进程间通信"
keywords: "3.14-进程间通信"
categories: ['Linux']
tags: ['Linux']
artid: "146285422"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146285422
    alt: "3.14-进程间通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146285422
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146285422
cover: https://bing.ee123.net/img/rand?artid=146285422
image: https://bing.ee123.net/img/rand?artid=146285422
img: https://bing.ee123.net/img/rand?artid=146285422
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     3.14-进程间通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_IPC_0">
     </a>
     进程间通信 IPC
    </h2>
    <ul>
     <li>
      进程间通信的原理，借助进程之间使用同一个内核，借助内核，传递数据。
     </li>
    </ul>
    <h3>
     <a id="_4">
     </a>
     进程间通信的方法
    </h3>
    <ol>
     <li>
      管道：最简单。
     </li>
     <li>
      信号：开销小。
     </li>
     <li>
      mmap映射：速度最快，非血缘关系之间。
     </li>
     <li>
      socket（本地套间字）：稳定性好。
     </li>
    </ol>
    <h3>
     <a id="_pipe_11">
     </a>
     管道 pipe
    </h3>
    <ul>
     <li>
      <p>
       实现原理：借助 Linux 内核使用环形队列机制，借助缓冲区（4k）实现。
      </p>
     </li>
     <li>
      <p>
       特质：
      </p>
      <ol>
       <li>
        本质：伪文件（实为内核缓冲区）
       </li>
       <li>
        用于进程间通信，由两个 fd 引用，一个读端，一个写端。
       </li>
       <li>
        规定数据从管道写端流入，读端流出。
       </li>
      </ol>
     </li>
     <li>
      <p>
       局限性：
      </p>
      <ol>
       <li>
        自己写，不能自己读。
       </li>
       <li>
        管道中的数据，不能反复读取。
       </li>
       <li>
        半双工通信（对讲机）。
       </li>
       <li>
        必须应用于血缘关系间。
       </li>
      </ol>
     </li>
    </ul>
    <h4>
     <a id="_25">
     </a>
     使用的函数
    </h4>
    <pre><code class="prism language-c">函数调用成功自动创建匿名管道，返回两个文件描述符，无需open，但需要手动close
<span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
参：
fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">:</span>
fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span>
返回值：
    成功：<span class="token number">0</span>
    失败：<span class="token operator">-</span><span class="token number">1</span>，errno
</code></pre>
    <ul>
     <li>
      父子进程管道通信
     </li>
    </ul>
    <h4>
     <a id="_40">
     </a>
     管道的读写行为
    </h4>
    <ul>
     <li>
      读管道：
      <ol>
       <li>
        管道有数据，read返回实际读到的字节数。
       </li>
       <li>
        管道有数据
        <ul>
         <li>
          无写端，read返回 0 （类似读到文件末尾）
         </li>
         <li>
          有写端，阻塞等待。
         </li>
        </ul>
       </li>
      </ol>
      <ul>
       <li>
        有写端：
        <ol>
         <li>
          无读端，异常终止。（SIGPIPE 信号）
         </li>
         <li>
          有读端
          <ul>
           <li>
            管道已满，阻塞
           </li>
           <li>
            未满，返回实际写出的字节数。
           </li>
          </ul>
         </li>
        </ol>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="_53">
     </a>
     管道的优劣
    </h4>
    <ul>
     <li>
      优点：简单
     </li>
     <li>
      缺点：
      <ol>
       <li>
        只能单向通信，实现双向通信需要两个管道。
       </li>
       <li>
        只能应用与父子兄弟（有公共祖先）进程间通信，无血缘关系进程间可以用 fifo 替代。
       </li>
      </ol>
     </li>
    </ul>
    <h3>
     <a id="_FIFO_60">
     </a>
     命名管道 FIFO
    </h3>
    <ul>
     <li>
      命名创建：mkfifo 管道名。
     </li>
     <li>
      函数创建
     </li>
    </ul>
    <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      可以用于任意关系间通信。
     </li>
     <li>
      管道中的数据一次性读取。
     </li>
     <li>
      读端：以O_RDONLY 打开 fifo 通道。
     </li>
     <li>
      写端：以 O_WRONLY/RDWR 打开同一个管道。
     </li>
    </ul>
    <h3>
     <a id="mmap_74">
     </a>
     mmap
    </h3>
    <h4>
     <a id="_76">
     </a>
     文件进程间通信
    </h4>
    <ul>
     <li>
      有血缘关系、无血缘关系的进程，都可以使用同一个文件来实现进程间通信。
     </li>
    </ul>
    <h4>
     <a id="_80">
     </a>
     建立映射
    </h4>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
参数：
	addr：指定映射区的首地址。通常传 <span class="token constant">NULL</span>，表示让系统自动分配
	length：共享内存映射区大小（<span class="token operator">&lt;=</span> 文件实际大小）。
	prot：共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ<span class="token operator">|</span>PROT_WRITE
	flag：标注共享内存映射区的共享属性
        MAP_SHARED：对共享内存所作的修改，会反映到物理磁盘上，IPC 专用。
        MAP_PRIVATE：对共享内存做的修改，不会反映到磁盘上。
	fd：用来创建共享内存映射区的哪个文件的文件描述符。
	offset：默认<span class="token number">0</span>，表示映射文件全部偏移位置，必须是 <span class="token number">4</span>k 整数倍。
返回值：
    成功：映射区的首地址。
    失败：MAP_FAILED（<span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>），errno
</code></pre>
    <ul>
     <li>
      munmap 释放共享内存映射
     </li>
    </ul>
    <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
参<span class="token number">1</span>：mmap（）返回值。
参<span class="token number">2</span>：共享内存映射区大小
    
返回值：
	成功：<span class="token number">0</span>
    失败：<span class="token operator">-</span><span class="token number">1</span>，errno
</code></pre>
    <h4>
     <a id="mmap_111">
     </a>
     mmap使用的注意事项
    </h4>
    <ol>
     <li>
      用于创建映射区的文件的大小必须是非 0。映射区的大小 &lt;= 文件大小。
     </li>
     <li>
      创建映射区，需要 read 权限。指定访问权限为 MAP_SHARED，mmap需要读写权限。应该 &lt;= 文件权限。
     </li>
     <li>
      文件描述符 fd，在 mmap 创建映射区完成，可以立即关闭，后续访问文件使用内存地址。
     </li>
     <li>
      offset 必须是 4096 的整数倍（MMU 映射的最小单位 4k）。
     </li>
     <li>
      映射区访问的权限设为私有，对内存做的所有修改都只在内存有效，不反映在磁盘上。
     </li>
    </ol>
    <h4>
     <a id="mmap__119">
     </a>
     mmap 函数保险调用方式
    </h4>
    <ol>
     <li>
      fd = open(“filename”, O_RDWR)
     </li>
     <li>
      mmap(NULL, size of valid file, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)
     </li>
    </ol>
    <h4>
     <a id="_124">
     </a>
     进程间通信
    </h4>
    <h5>
     <a id="_126">
     </a>
     父子间通信
    </h5>
    <ol>
     <li>
      父进程先创建映射区。open(O_RDWR); mmap(MAP_SHARED);
     </li>
     <li>
      fork() 创建子进程。
     </li>
     <li>
      一个进程使用映射区读，另一个进程写。
     </li>
    </ol>
    <h5>
     <a id="_132">
     </a>
     无血缘关系进程间通信
    </h5>
    <ol>
     <li>
      两个进程打开同一个文件，创建映射区。
     </li>
     <li>
      指定 flags 为 MAP_SHARED。
     </li>
     <li>
      一个进程使用映射区读，另一个进程写。
     </li>
    </ol>
    <h4>
     <a id="mmap__138">
     </a>
     mmap 特性
    </h4>
    <ul>
     <li>
      fifo、mmap 都可以应用于非血缘关系间通信。
      <ul>
       <li>
        mmap：数据可以重复读写。
       </li>
       <li>
        fifo：数据只能一次性读写。
       </li>
      </ul>
     </li>
     <li>
      直接操作内存，执行速度快
     </li>
    </ul>
    <h3>
     <a id="_144">
     </a>
     匿名映射
    </h3>
    <ul>
     <li>
      只能应用于有血缘关系的进程间通信。
     </li>
     <li>
      /dev/null：黑洞文件，无限向该文件写入数据。
     </li>
     <li>
      /dev/zero：无限向该文件读取数据，读到的都是 0。
     </li>
     <li>
      MAP_ANON 只在 Linux 中有效，系统中没有该选项，可以借助 /dev/zero 实现。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38373938343235382f:61727469636c652f64657461696c732f313436323835343232" class_="artid" style="display:none">
 </p>
</div>


