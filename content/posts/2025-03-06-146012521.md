---
layout: post
title: "子数组问题动态规划"
date: 2025-03-06 10:17:42 +0800
description: "用动态规划做子数组类的题时，对于状态表示我们可以直接设：dp[i]为以i元素结尾的子数组的... ... 后面就根据具体的题目要求填写，可能是子数组的和或者子数组的积等等，无论如何都可以以i元素结尾的子数组为研究对象去思考问题，如果解决不了就尝试增加状态，但研究对象不要改变。如果还解决不了那么再考虑改变或增加研究对象。"
keywords: "子数组问题——动态规划"
categories: ['算法']
tags: ['算法', '动态规划', 'Java', 'C']
artid: "146012521"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146012521
    alt: "子数组问题动态规划"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146012521
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146012521
cover: https://bing.ee123.net/img/rand?artid=146012521
image: https://bing.ee123.net/img/rand?artid=146012521
img: https://bing.ee123.net/img/rand?artid=146012521
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     子数组问题——动态规划
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      个人主页：
      <a href="https://blog.csdn.net/2302_80105876?spm=1000.2115.3001.5343" title="敲上瘾-CSDN博客">
       敲上瘾-CSDN博客
      </a>
     </p>
     <p>
      动态规划
     </p>
     <ul>
      <li>
       基础dp：
       <a href="https://blog.csdn.net/2302_80105876/article/details/145793038?spm=1001.2014.3001.5501" title="基础dp——动态规划-CSDN博客">
        基础dp——动态规划-CSDN博客
       </a>
      </li>
      <li>
       多状态dp：
       <a href="https://blog.csdn.net/2302_80105876/article/details/145832436?spm=1001.2014.3001.5501" title="多状态dp——动态规划-CSDN博客">
        多状态dp——动态规划-CSDN博客
       </a>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      目录
     </strong>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7" name="%E4%B8%80%E3%80%81%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7">
     一、解题技巧
    </h2>
    <p>
     区分子数组（子串）与子序列：
    </p>
    <ul>
     <li>
      子数组（子串）：在数列中的一段连续的元素组成的新数列，中间不可间断。
     </li>
     <li>
      子序列：在数列中从左往右
      <strong>
       <span style="color:#fe2c24">
        依次
       </span>
      </strong>
      挑选出元素组成的新数列，或者说在数列中随意删除一些元素后，剩下的元素组成的新数列。
     </li>
    </ul>
    <p>
     用动态规划做子数组类的题时，对于状态表示我们可以直接设：
    </p>
    <ul>
     <li>
      <strong>
       dp[i]为
       <span style="color:#ff9900">
        以i元素结尾的子数组
       </span>
       的... ...
      </strong>
     </li>
    </ul>
    <p>
     后面就根据具体的题目要求填写，可能是子数组的和或者子数组的积等等，无论如何都可以
     <strong>
      <span style="color:null">
       以i元素结尾的子数组
      </span>
     </strong>
     <span style="color:null">
      <u>
       为研究对象
      </u>
      去思考问题，如果解决不了就尝试
     </span>
     <span style="color:#ff9900">
      <strong>
       增加状态
      </strong>
     </span>
     <span style="color:null">
      ，但
      <u>
       研究对象不要改变
      </u>
      。如果还解决不了那么再考虑改变或增加研究对象。
     </span>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C" name="%E4%BA%8C%E3%80%81%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">
     二、最大子数组和
    </h2>
    <p>
     <img alt="" height="229" src="https://i-blog.csdnimg.cn/direct/07f169cd171f45c89345ec5d7f9cf1e1.png" width="859"/>
    </p>
    <p>
     <strong>
      状态表示
     </strong>
    </p>
    <p>
     如上技巧所述，我们直接设状态转移方程：
    </p>
    <ul>
     <li>
      <span style="color:#ff9900">
       <strong>
        dp[i]表示：以i位置结尾的子数组的最大和。
       </strong>
      </span>
     </li>
    </ul>
    <p>
     接下来只需要去尝试是否能写出正确的状态转移方程，如果能那么状态表示就是对的。
    </p>
    <p>
     <strong>
      状态转移方程：
     </strong>
    </p>
    <p>
     以i位置结尾的子数组我们可以分为两种：
    </p>
    <ol>
     <li>
      nums[i]单独构成一个子数组
     </li>
     <li>
      nums[i]和
      <span style="color:#fe2c24">
       <strong>
        以i-1结尾的最大和子数组
       </strong>
      </span>
      组合成的子数组。
     </li>
    </ol>
    <p>
     那么这个
     <span style="color:#fe2c24">
      <strong>
       以i-1结尾的最大子数组的值
      </strong>
     </span>
     <span style="color:null">
      就是一个重复子问题，我们假设在前面已经计算过了，即dp
     </span>
     [i-1]，然后需要注意两种情况只能取一种。那么：
    </p>
    <ul>
     <li>
      <span style="color:#ff9900">
       <strong>
        dp[i] = max(nums[i]+dp[i-1]，nums[i])
       </strong>
      </span>
     </li>
    </ul>
    <p>
     <strong>
      初始化
     </strong>
    </p>
    <p>
     初始化的目的主要有两个：
    </p>
    <ul>
     <li>
      保证填表的时候不越界。
     </li>
     <li>
      保证填表的正确性。
     </li>
    </ul>
    <p>
     因为这里有i-1，所以如果从0开始填表可能会越界，通常有两种解决方案：
    </p>
    <p>
     方法一：把dp[0]初始化（即dp[0]=nums[0]），然后从dp[1]位置开始填表（即从nums[1]位置开始记录）。
    </p>
    <p>
     方法二：开辟一个n+1的空间（n=nums.size()），让dp[0]=0（需要根据具体情况具体分析），然后从dp[1]位置开始填写，而dp[1]记录的是nums[0]的情况，也就是错开一位进行记录，所以需要注意映射关系。
    </p>
    <p>
     这题看似方法一更简洁，但对于其他题可能需要做更复杂的边界判断。所以在做动规题时更推荐使用方法二来解决边界问题。
    </p>
    <p>
     <strong>
      填表顺序
     </strong>
    </p>
    <p>
     从左往右。
    </p>
    <p>
     <strong>
      返回值
     </strong>
    </p>
    <p>
     dp表中的最大值。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code class="language-cpp">class Solution 
{
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums)
    {
        int n=nums.size(),ret=INT_MIN;
        vector&lt;int&gt; dp(n+1);
        for(int i=1;i&lt;n+1;i++)
        {
            dp[i]=max(nums[i-1],nums[i-1]+dp[i-1]);
            ret=max(ret,dp[i]);
        }    
        return ret;
    }
};</code></pre>
    <h2 id="%E4%B8%89%E3%80%81%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84" name="%E4%B8%89%E3%80%81%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84">
     三、乘积最大子数组
    </h2>
    <p>
     <img alt="" height="353" src="https://i-blog.csdnimg.cn/direct/80e5eda7fc134b76ad2c50c1ce871896.png" width="715"/>
    </p>
    <p>
     <strong>
      状态表示
     </strong>
    </p>
    <p>
     同样的我们假设状态表示为：
    </p>
    <p>
     dp[i]表示：以i位置结尾的子数组的最大乘积。
    </p>
    <p>
     那么状态转移方程dp[i]=max(dp[i-1]*nums[i]，nums[i])，我们想一想这样对吗？比如dp[i-1]*nums[i]，nums[i]乘以一个最大积的子数组就是最大吗？
    </p>
    <p>
     如果nums是一个负数不就变成最小乘积了吗，反之nums[i]小于0时乘以一个最小的数才能成为最大积。
    </p>
    <p>
     所以当nums[i]小于0时我们需要知道以i-1结尾的子数组的最小积。
    </p>
    <p>
     所以状态表示为：
    </p>
    <ul>
     <li>
      <strong>
       <span style="color:#ff9900">
        f[i]表示：以i位置结尾的子数组的最
        <span style="background-color:#f9eda6">
         大
        </span>
        乘积。
       </span>
      </strong>
     </li>
     <li>
      <strong>
       <span style="color:#ff9900">
        g[i]表示：以i位置结尾的子数组的最
        <span style="background-color:#f9eda6">
         小
        </span>
        乘积。
       </span>
      </strong>
     </li>
    </ul>
    <p>
     <span style="color:null">
      <strong>
       状态转移方程
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#fe2c24">
       <strong>
        nums[i]&gt;=0：
       </strong>
      </span>
      <ul>
       <li>
        <strong>
         <span style="color:#ff9900">
          f[i] = max(f[i-1]*nums[i]，nums[i])
         </span>
        </strong>
       </li>
       <li>
        <strong>
         <span style="color:#ff9900">
          g[i] = min(g[i-1]*nums[i]，nums[i])
         </span>
        </strong>
       </li>
      </ul>
     </li>
     <li>
      <span style="color:#fe2c24">
       <strong>
        nums[i] &lt; 0:
       </strong>
      </span>
      <ul>
       <li>
        <strong>
         <span style="color:#ff9900">
          f[i] = max(g[i-1]*nums[i]，nums[i])
         </span>
        </strong>
       </li>
       <li>
        <strong>
         <span style="color:#ff9900">
          g[i] = min(f[i-1]*nums[i]，nums[i])
         </span>
        </strong>
        <strong>
         <span style="color:#ff9900">
         </span>
        </strong>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <span style="color:#fe2c24">
      <strong>
       或：
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#ff9900">
       <strong>
        f[i]=max(nums[i],max(nums[i]*f[i-1],nums[i]*g[i-1]));
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#ff9900">
       <strong>
        g[i]=min(nums[i],min(nums[i]*f[i-1],nums[i]*g[i-1]));
       </strong>
      </span>
     </li>
    </ul>
    <p>
     <span style="color:null">
      <strong>
       初始化
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
      </strong>
      与上一题相同，为防止越界我们给两个dp表都多开辟一个空间，映射关系错开一位。
     </span>
    </p>
    <p>
     <span style="color:null">
      然后把两个dp表都初始化为1，因为这里是乘法，如果使用默认的0值那么这个结果都是0。
     </span>
    </p>
    <p>
     <span style="color:null">
      注：
     </span>
     dp[0]是我们为防止越界添加上的虚拟位置，它的值需要使得后面的填表正确。
    </p>
    <p>
     <span style="color:null">
      <strong>
       填表顺序
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
      </strong>
      从左往右，f表和g表一起填。
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
       返回值
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
      </strong>
      f表中的最大值。
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
       代码示例：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums)
    {
        int n=nums.size(), ret=INT_MIN;;
        vector&lt;int&gt; f(n+1,1),g(n+1,1);
        for(int i=1;i&lt;=n;i++)
        {
            f[i]=max(nums[i-1],max(nums[i-1]*f[i-1],nums[i-1]*g[i-1]));
            g[i]=min(nums[i-1],min(nums[i-1]*f[i-1],nums[i-1]*g[i-1]));
            ret=max(ret,f[i]);
        }
        return ret;
    }
};</code></pre>
    <h2 id="%E5%9B%9B%E3%80%81%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84" name="%E5%9B%9B%E3%80%81%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84">
     四、最长湍流子数组
    </h2>
    <p>
     <img alt="" height="420" src="https://i-blog.csdnimg.cn/direct/0d8ac9421b374d9489005077fe1c9b02.png" width="1033"/>
    </p>
    <p>
     题目的核心就一句话：
     <span style="color:#fe2c24">
      <strong>
       比较符号在子数组中的每个相邻元素对之间翻转。
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      然后找到满足这样的条件的最长子数组。
     </span>
    </p>
    <p>
     <strong>
      <span style="color:null">
       状态表示
      </span>
     </strong>
    </p>
    <p>
     <span style="color:null">
      假设状态表示为：
     </span>
    </p>
    <p>
     <span style="color:null">
      dp[i]表示：以i结尾的最长湍流子数组。
     </span>
    </p>
    <p>
     我们把数据的大小波动抽象成一条折线，如下把示例1化为折线图：
    </p>
    <p>
     <img alt="" height="460" src="https://i-blog.csdnimg.cn/direct/3eecd30eda694791b319dd8bccdd9692.png" width="696"/>
    </p>
    <p>
     结果取该段：
    </p>
    <p>
     <img alt="" height="314" src="https://i-blog.csdnimg.cn/direct/d44a6bc5e61d4a29a54cee53fa208333.png" width="263"/>
    </p>
    <p>
     也就是子数组要满足前一个元素是上升趋势那么下一个元素必须是下降，如果前一个元素是下降趋势那么下一个元素必须是上升。
    </p>
    <p>
     我们在做状态转移方程中主要是考虑两种情况，
    </p>
    <ol>
     <li>
      nums[i]单独构成一个子数组
     </li>
     <li>
      nums[i]接到前一个元素结尾构成的子数组中。
     </li>
    </ol>
    <p>
     第2种情况又需要分情况讨论，
    </p>
    <ul>
     <li>
      nums[i] &lt; nums[i-1]：只有前面的子数组最终状态是呈现上升趋势时nums[i]才能接上。
     </li>
     <li>
      nums[i] &gt; nums[i-1]：只有前面的子数组最终状态是呈现下降趋势时nums[i]才能接上。
     </li>
     <li>
      nums[i]==nums[i-1]：不能接入前面子数组。
     </li>
    </ul>
    <p>
     所以我们需要把状态转移细分为两种状态：
    </p>
    <ul>
     <li>
      <span style="color:#ff9900">
       <strong>
        f[i]表示：以i结尾并且最后一个元素呈
       </strong>
      </span>
      <span style="color:#ff9900">
       <strong>
        <span style="background-color:#f9eda6">
         上升
        </span>
        趋势的最长湍流子数组的
       </strong>
      </span>
      <span style="color:#fe2c24">
       <strong>
        长度
       </strong>
      </span>
      <span style="color:#ff9900">
       <strong>
        。
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#ff9900">
       <strong>
        g[i]表示：以i结尾并且最后一个元素呈
       </strong>
      </span>
      <span style="color:#ff9900">
       <strong>
        <span style="background-color:#f9eda6">
         下降
        </span>
        趋势的最长湍流子数组的
       </strong>
      </span>
      <span style="color:#fe2c24">
       <strong>
        长度
       </strong>
      </span>
      <span style="color:#ff9900">
       <strong>
        。
       </strong>
      </span>
     </li>
    </ul>
    <p>
     <strong>
      <span style="color:null">
       状态转移方程
      </span>
     </strong>
    </p>
    <ul>
     <li>
      nums[i] &lt; nums[i-1]：
      <ul>
       <li>
        f[i]=1
       </li>
       <li>
        g[i]=f[i-1]+1
       </li>
      </ul>
     </li>
     <li>
      nums[i] &gt; nums[i-1]：
      <ul>
       <li>
        f[i]=g[i-1]+1
       </li>
       <li>
        g[i]=1
       </li>
      </ul>
     </li>
     <li>
      nums[i]==nums[i-1]：
      <ul>
       <li>
        f[i]=1
       </li>
       <li>
        g[i]=1
       </li>
      </ul>
     </li>
    </ul>
    <p>
     因为任意一个子数组，最小的长度都是1，所以可以把两个dp表都初始化为1，那么状态转移方程可简化为：
    </p>
    <ul>
     <li>
      <span style="color:#ff9900">
       <strong>
        nums[i] &lt; nums[i-1]：g[i]+=f[i-1]
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#ff9900">
       <strong>
        nums[i] &gt; nums[i-1]：f[i]+=g[i-1]
       </strong>
      </span>
     </li>
    </ul>
    <p>
     <strong>
      初始化
     </strong>
    </p>
    <p>
     <span style="color:null">
      <strong>
      </strong>
      为防止越界我们给两个dp表都多开辟一个空间，映射关系错开一位。
     </span>
    </p>
    <p>
     <span style="color:null">
      然后把两个dp表都初始化为1。
     </span>
    </p>
    <p>
     <strong>
      填表顺序
     </strong>
    </p>
    <p>
     从左往右，f表和g表同时填写。
    </p>
    <p>
     <strong>
      返回值
     </strong>
    </p>
    <p>
     f表和g表中的最大那个元素
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int maxTurbulenceSize(vector&lt;int&gt;&amp; arr)
    {
        int n=arr.size(),ret=1;
        vector&lt;int&gt; f(n,1),g(n,1);
        for(int i=1;i&lt;n;i++)
        {
            if(arr[i]&lt;arr[i-1]) g[i]+=f[i-1];
            if(arr[i]&gt;arr[i-1]) f[i]+=g[i-1];
            ret=max(ret,max(f[i],g[i]));
        }    
        return ret;
    }
};</code></pre>
    <h2 id="%E4%BA%94%E3%80%81%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86" name="%E4%BA%94%E3%80%81%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">
     五、单词拆分
    </h2>
    <p>
     <img alt="" height="374" src="https://i-blog.csdnimg.cn/direct/f0355197ce4a4b5da1140b690afa9b18.png" width="942"/>
    </p>
    <p>
     <strong>
      状态表示
     </strong>
    </p>
    <p>
     <span style="color:null">
      根据经验直接设状态表示：
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#ff9900">
       <strong>
        dp[i]表示：从0到i位置结尾的字符串是否能被字典中的单词表示（bool类型）。
       </strong>
      </span>
     </li>
    </ul>
    <p>
     <strong>
      状态转移方程
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     因为在填写i时以前的每个子串是否能由字典表示已经知道，储存在dp表中。那么我们
     <strong>
      只需要找到
      <span style="color:#fe2c24">
       任意
      </span>
      一个j（0&lt;=j&lt;i）使得dp[j]=true，并且子字符串[j+1，i]能用字典表示，那么dp[i]=true，否则dp[i]=false。
     </strong>
    </p>
    <p>
     所以状态转移方程：
    </p>
    <ul>
     <li>
      <strong>
       <span style="color:#ff9900">
        dp[i] = (dp[i-1]&amp;&amp;s[i，i]能用字典表示) || (dp[i-2]&amp;&amp;s[i-1，i]能用字典表示) || ... ... ||(dp[0]&amp;&amp;s[1，i]能用字典表示)
       </span>
      </strong>
     </li>
    </ul>
    <p>
     <span style="color:#fe2c24">
      注：s[i-1，i]表示字符串中i-1到i这个子串。
     </span>
    </p>
    <p>
     <strong>
      初始化
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     为了让第一个字符元素也讨论进来，我们创建n+1的dp表，并把dp[0]初始化为true。
    </p>
    <p>
     <strong>
      填表顺序
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     从左往右
    </p>
    <p>
     <strong>
      返回值
     </strong>
    </p>
    <p>
     return dp[n]
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
    {
        int n=s.size();
        unordered_set&lt;string&gt; st(wordDict.begin(),wordDict.end());
        vector&lt;bool&gt; dp(n+1);
        dp[0]=true;
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=0;j&lt;i;j++)
            {
                if(dp[j]==false) continue;
                if(st.count(string(s.begin()+j,s.begin()+i)))
                {
                    dp[i]=true;
                    break;
                }
            }
        }   
        return dp[n];
    }
};</code></pre>
    <p>
     好题推荐：
    </p>
    <ul>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-subarray%2F" rel="nofollow" title="53. 最大子数组和">
       53. 最大子数组和
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-sum-circular-subarray%2F" rel="nofollow" title="918. 环形子数组的最大和">
       918. 环形子数组的最大和
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-product-subarray%2F" rel="nofollow" title="152. 乘积最大子数组">
       152. 乘积最大子数组
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-length-of-subarray-with-positive-product%2F" rel="nofollow" title="1567. 乘积为正数的最长子数组长度">
       1567. 乘积为正数的最长子数组长度
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Farithmetic-slices%2F" rel="nofollow" title="413. 等差数列划分">
       413. 等差数列划分
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flongest-turbulent-subarray%2F" rel="nofollow" title="978. 最长湍流子数组">
       978. 最长湍流子数组
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fword-break%2F" rel="nofollow" title="139. 单词拆分">
       139. 单词拆分
      </a>
     </li>
     <li>
      <a href="https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Funique-substrings-in-wraparound-string%2F" rel="nofollow" title="467. 环绕字符串中唯一的子字符串">
       467. 环绕字符串中唯一的子字符串
      </a>
     </li>
    </ul>
    <blockquote>
     <p>
      非常感谢您能耐心读完这篇文章。倘若您从中有所收获，还望多多支持呀！
      <img alt="74c0781738354c71be3d62e05688fecc.png" src="https://i-blog.csdnimg.cn/direct/74c0781738354c71be3d62e05688fecc.png"/>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303130353837362f:61727469636c652f64657461696c732f313436303132353231" class_="artid" style="display:none">
 </p>
</div>


