---
arturl_encode: "68747470:733a2f2f626c6f672e6373646e2e6e65742f637a686169692f:61727469636c652f64657461696c732f313436323437313435"
layout: post
title: "STM32配套程序接线图"
date: 2025-03-14 04:57:16 +0800
description: "江协STM32程序配套接线图"
keywords: "STM32配套程序接线图"
categories: ['Stm']
tags: ['嵌入式硬件', '单片机', 'Stm']
artid: "146247145"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146247145
    alt: "STM32配套程序接线图"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146247145
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146247145
cover: https://bing.ee123.net/img/rand?artid=146247145
image: https://bing.ee123.net/img/rand?artid=146247145
img: https://bing.ee123.net/img/rand?artid=146247145
---

# STM32配套程序接线图

![](https://i-blog.csdnimg.cn/direct/e98df5a99596400f9fc4478ee7d252ad.jpeg)

**1  工程模板**

**![](https://i-blog.csdnimg.cn/direct/32c7aa9f70c049caa495e723fc16257c.jpeg)**

**2 LED闪烁**

![](https://i-blog.csdnimg.cn/direct/d7302117836b40e8be89e009cbfd9ff1.jpeg)

**3LED流水灯**

![](https://i-blog.csdnimg.cn/direct/5c7ef5b1289a43c0bd02d9be812ae473.jpeg)

**4蜂鸣器**

![](https://i-blog.csdnimg.cn/direct/0bc7c9de398d41a2999f89bdb95f0ec2.jpeg)

**5按键控制LED**

![](https://i-blog.csdnimg.cn/direct/f3d8d2a2e1054ba4a4ac38cd98d03eb9.jpeg)

**6光敏传感器控制蜂鸣器**

![](https://i-blog.csdnimg.cn/direct/a9b7cc97024944e49e87049ff4bce577.jpeg)

**7OLED显示屏**

![](https://i-blog.csdnimg.cn/direct/15d36a2cd29b4b44ae8bdad9cf0672d0.jpeg)

**8对射式红外传感器计次**

![](https://i-blog.csdnimg.cn/direct/a551bee548ef47f1b452e067ae3693f7.jpeg)

**9旋转编码器计次**

![](https://i-blog.csdnimg.cn/direct/16441a5af9ee4c0f89d6ec43255aa96c.jpeg)

**10 定时器定时中断**

![](https://i-blog.csdnimg.cn/direct/5535ffa76f3c41c99980d191b93b000e.jpeg)

**11定时器外部时钟**

![](https://i-blog.csdnimg.cn/direct/9f2359a1505446389adb75ea6fd306bf.jpeg)

**12PWM驱动LED呼吸灯**

![](https://i-blog.csdnimg.cn/direct/66abe511b842412eab51a986ba7e6ce9.jpeg)

**13**
**PWM驱动舵机**

![](https://i-blog.csdnimg.cn/direct/f33a9b46a6c9469e921437dcdd31600a.jpeg)

**14**

**PWM驱动直流电机**

![](https://i-blog.csdnimg.cn/direct/a6443763ac824bdebe0b07b3929b8118.jpeg)

**15
输入捕获模式测频率**

![](https://i-blog.csdnimg.cn/direct/4bdf1463090345b0acf3a4af2d57ecca.jpeg)

**16
PWMI模式测频率占空比**

![](https://i-blog.csdnimg.cn/direct/c12a643b658042419daeff7bc8fad927.jpeg)

**17
PWM测速**

![](https://i-blog.csdnimg.cn/direct/1373cb08e06444d780682e19468c2054.jpeg)

**18
AD单通道**

![](https://i-blog.csdnimg.cn/direct/6fddda03e45e481f9de3a404ad7a774c.jpeg)

**19
AD多通道**

![](https://i-blog.csdnimg.cn/direct/5d1acda612bb425296a253c03caefdff.jpeg)

**20**

**DMA数据转运**

![](https://i-blog.csdnimg.cn/direct/3e9201ff18264d798eae9eed236f6ded.jpeg)

**21**
串口发送

![](https://i-blog.csdnimg.cn/direct/b0b3ca5b303f402d9c0c7246e5018cfa.jpeg)

**22串口发送加接收**

![](https://i-blog.csdnimg.cn/direct/c1472343b055417f97c499f10635f2bb.jpeg)

**23串口发送HEX数据包**

![](https://i-blog.csdnimg.cn/direct/6a2cc24c429746138ff63279a217e24e.jpeg)

**24串口发送文本数据包**

![](https://i-blog.csdnimg.cn/direct/d38f65a60bcf4c7c9719072f613751cb.jpeg)

**25**
**软件I2C读写MPU6050**

![](https://i-blog.csdnimg.cn/direct/683de25afa1349129c9a391999e3277f.jpeg)

**26软件SPI读写W25Q64**

![](https://i-blog.csdnimg.cn/direct/1320a8d441a643c29fc687587d8870c0.jpeg)

**27硬件SPI读写W25Q64**

![](https://i-blog.csdnimg.cn/direct/4f9c39d3571f4f44b73193f40d409164.jpeg)

**28读写备份寄存器**

![](https://i-blog.csdnimg.cn/direct/480c5fabaf444657988d6ec159f4ffb4.jpeg)

**29实时时钟**

![](https://i-blog.csdnimg.cn/direct/6e83ce73da1b4f08a37634d3039a4768.jpeg)

**30修改主频**

![](https://i-blog.csdnimg.cn/direct/485c9b3cfdb94cf28dc90f6c3bb789f9.jpeg)

**31**
**睡眠模式+串口发送+接收**

![](https://i-blog.csdnimg.cn/direct/92c48316548f47e9abb7a63e9b1e9d4d.jpeg)

**32**
停止模式+对射式红外传感器计次

![](https://i-blog.csdnimg.cn/direct/1f8d14f7b7fe463389d5e8713c18eaf6.jpeg)

**33待机模式+实时时钟**

![](https://i-blog.csdnimg.cn/direct/334d655909674865b37f7dc47aec8073.jpeg)

**34独立看门狗**

![](https://i-blog.csdnimg.cn/direct/de9050e0a229483b838e8a25f2ff1c28.jpeg)

**35窗口看门狗**

![](https://i-blog.csdnimg.cn/direct/821bbae85aeb48c89ce9bdb78100ab19.jpeg)

**36窗口看门狗**

![](https://i-blog.csdnimg.cn/direct/b62d61c5f86c47738e33cd87448c958e.jpeg)

**37读写内部FLASH**

![](https://i-blog.csdnimg.cn/direct/461b39238111407dae6df87d0703ed3c.jpeg)

**38读写芯片ID**

旋转编码器计次

include "stm32f10x.h"                  // Device header
  
#include "Delay.h"
  
#include "OLED.h"
  
#include "Encoder.h"

int16\_t Num;            //定义待被旋转编码器调节的变量

int main(void)
  
{
  
/\*模块初始化\*/
  
OLED\_Init();        //OLED初始化
  
Encoder\_Init();        //旋转编码器初始化
  
  
/\*显示静态字符串\*/
  
OLED\_ShowString(1, 1, "Num:");            //1行1列显示字符串Num:
  
  
while (1)
  
{
  
Num += Encoder\_Get();                //获取自上此调用此函数后，旋转编码器的增量值，并将增量值加到Num上
  
OLED\_ShowSignedNum(1, 5, Num, 5);    //显示Num
  
}
  
}

/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*OLED,H\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

#ifndef \_\_OLED\_H
  
#define \_\_OLED\_H

void OLED\_Init(void);
  
void OLED\_Clear(void);
  
void OLED\_ShowChar(uint8\_t Line, uint8\_t Column, char Char);
  
void OLED\_ShowString(uint8\_t Line, uint8\_t Column, char \*String);
  
void OLED\_ShowNum(uint8\_t Line, uint8\_t Column, uint32\_t Number, uint8\_t Length);
  
void OLED\_ShowSignedNum(uint8\_t Line, uint8\_t Column, int32\_t Number, uint8\_t Length);
  
void OLED\_ShowHexNum(uint8\_t Line, uint8\_t Column, uint32\_t Number, uint8\_t Length);
  
void OLED\_ShowBinNum(uint8\_t Line, uint8\_t Column, uint32\_t Number, uint8\_t Length);

#endif

/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*OLED,C\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

#include "stm32f10x.h"
  
#include "OLED\_Font.h"

/\*引脚配置\*/
  
#define OLED\_W\_SCL(x)        GPIO\_WriteBit(GPIOB, GPIO\_Pin\_8, (BitAction)(x))//SCL PB8
  
#define OLED\_W\_SDA(x)        GPIO\_WriteBit(GPIOB, GPIO\_Pin\_9, (BitAction)(x))//SDA PB9

/\*引脚初始化\*/
  
void OLED\_I2C\_Init(void)
  
{
  
RCC\_APB2PeriphClockCmd(RCC\_APB2Periph\_GPIOB, ENABLE);
  
  
GPIO\_InitTypeDef GPIO\_InitStructure;
  
GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_Out\_OD;
  
GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_50MHz;
  
GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_8;
  
GPIO\_Init(GPIOB, &GPIO\_InitStructure);
  
GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_9;
  
GPIO\_Init(GPIOB, &GPIO\_InitStructure);
  
  
OLED\_W\_SCL(1);
  
OLED\_W\_SDA(1);
  
}

/\*\*
  
\* @brief  I2C开始
  
\* @param  无
  
\* @retval 无
  
\*/
  
void OLED\_I2C\_Start(void)
  
{
  
OLED\_W\_SDA(1);
  
OLED\_W\_SCL(1);
  
OLED\_W\_SDA(0);
  
OLED\_W\_SCL(0);
  
}

/\*\*
  
\* @brief  I2C停止
  
\* @param  无
  
\* @retval 无
  
\*/
  
void OLED\_I2C\_Stop(void)
  
{
  
OLED\_W\_SDA(0);
  
OLED\_W\_SCL(1);
  
OLED\_W\_SDA(1);
  
}

/\*\*
  
\* @brief  I2C发送一个字节
  
\* @param  Byte 要发送的一个字节
  
\* @retval 无
  
\*/
  
void OLED\_I2C\_SendByte(uint8\_t Byte)
  
{
  
uint8\_t i;
  
for (i = 0; i < 8; i++)
  
{
  
OLED\_W\_SDA(!!(Byte & (0x80 >> i)));
  
OLED\_W\_SCL(1);
  
OLED\_W\_SCL(0);
  
}
  
OLED\_W\_SCL(1);    //额外的一个时钟，不处理应答信号
  
OLED\_W\_SCL(0);
  
}

/\*\*
  
\* @brief  OLED写命令
  
\* @param  Command 要写入的命令
  
\* @retval 无
  
\*/
  
void OLED\_WriteCommand(uint8\_t Command)
  
{
  
OLED\_I2C\_Start();
  
OLED\_I2C\_SendByte(0x78);        //从机地址
  
OLED\_I2C\_SendByte(0x00);        //写命令
  
OLED\_I2C\_SendByte(Command);
  
OLED\_I2C\_Stop();
  
}

/\*\*
  
\* @brief  OLED写数据
  
\* @param  Data 要写入的数据
  
\* @retval 无
  
\*/
  
void OLED\_WriteData(uint8\_t Data)
  
{
  
OLED\_I2C\_Start();
  
OLED\_I2C\_SendByte(0x78);        //从机地址
  
OLED\_I2C\_SendByte(0x40);        //写数据
  
OLED\_I2C\_SendByte(Data);
  
OLED\_I2C\_Stop();
  
}

/\*\*
  
\* @brief  OLED设置光标位置
  
\* @param  Y 以左上角为原点，向下方向的坐标，范围：0~7
  
\* @param  X 以左上角为原点，向右方向的坐标，范围：0~127
  
\* @retval 无
  
\*/
  
void OLED\_SetCursor(uint8\_t Y, uint8\_t X)
  
{
  
OLED\_WriteCommand(0xB0 | Y);                    //设置Y位置
  
OLED\_WriteCommand(0x10 | ((X & 0xF0) >> 4));    //设置X位置高4位
  
OLED\_WriteCommand(0x00 | (X & 0x0F));            //设置X位置低4位
  
}

/\*\*
  
\* @brief  OLED清屏
  
\* @param  无
  
\* @retval 无
  
\*/
  
void OLED\_Clear(void)
  
{
  
uint8\_t i, j;
  
for (j = 0; j < 8; j++)
  
{
  
OLED\_SetCursor(j, 0);
  
for(i = 0; i < 128; i++)
  
{
  
OLED\_WriteData(0x00);
  
}
  
}
  
}

/\*\*
  
\* @brief  OLED显示一个字符
  
\* @param  Line 行位置，范围：1~4
  
\* @param  Column 列位置，范围：1~16
  
\* @param  Char 要显示的一个字符，范围：ASCII可见字符
  
\* @retval 无
  
\*/
  
void OLED\_ShowChar(uint8\_t Line, uint8\_t Column, char Char)
  
{
  
uint8\_t i;
  
OLED\_SetCursor((Line - 1) \* 2, (Column - 1) \* 8);        //设置光标位置在上半部分
  
for (i = 0; i < 8; i++)
  
{
  
OLED\_WriteData(OLED\_F8x16[Char - ' '][i]);            //显示上半部分内容
  
}
  
OLED\_SetCursor((Line - 1) \* 2 + 1, (Column - 1) \* 8);    //设置光标位置在下半部分
  
for (i = 0; i < 8; i++)
  
{
  
OLED\_WriteData(OLED\_F8x16[Char - ' '][i + 8]);        //显示下半部分内容
  
}
  
}

/\*\*
  
\* @brief  OLED显示字符串
  
\* @param  Line 起始行位置，范围：1~4
  
\* @param  Column 起始列位置，范围：1~16
  
\* @param  String 要显示的字符串，范围：ASCII可见字符
  
\* @retval 无
  
\*/
  
void OLED\_ShowString(uint8\_t Line, uint8\_t Column, char \*String)
  
{
  
uint8\_t i;
  
for (i = 0; String[i] != '\0'; i++)
  
{
  
OLED\_ShowChar(Line, Column + i, String[i]);
  
}
  
}

/\*\*
  
\* @brief  OLED次方函数
  
\* @retval 返回值等于X的Y次方
  
\*/
  
uint32\_t OLED\_Pow(uint32\_t X, uint32\_t Y)
  
{
  
uint32\_t Result = 1;
  
while (Y--)
  
{
  
Result \*= X;
  
}
  
return Result;
  
}

/\*\*
  
\* @brief  OLED显示数字（十进制，正数）
  
\* @param  Line 起始行位置，范围：1~4
  
\* @param  Column 起始列位置，范围：1~16
  
\* @param  Number 要显示的数字，范围：0~4294967295
  
\* @param  Length 要显示数字的长度，范围：1~10
  
\* @retval 无
  
\*/
  
void OLED\_ShowNum(uint8\_t Line, uint8\_t Column, uint32\_t Number, uint8\_t Length)
  
{
  
uint8\_t i;
  
for (i = 0; i < Length; i++)
  
{
  
OLED\_ShowChar(Line, Column + i, Number / OLED\_Pow(10, Length - i - 1) % 10 + '0');
  
}
  
}

/\*\*
  
\* @brief  OLED显示数字（十进制，带符号数）
  
\* @param  Line 起始行位置，范围：1~4
  
\* @param  Column 起始列位置，范围：1~16
  
\* @param  Number 要显示的数字，范围：-2147483648~2147483647
  
\* @param  Length 要显示数字的长度，范围：1~10
  
\* @retval 无
  
\*/
  
void OLED\_ShowSignedNum(uint8\_t Line, uint8\_t Column, int32\_t Number, uint8\_t Length)
  
{
  
uint8\_t i;
  
uint32\_t Number1;
  
if (Number >= 0)
  
{
  
OLED\_ShowChar(Line, Column, '+');
  
Number1 = Number;
  
}
  
else
  
{
  
OLED\_ShowChar(Line, Column, '-');
  
Number1 = -Number;
  
}
  
for (i = 0; i < Length; i++)
  
{
  
OLED\_ShowChar(Line, Column + i + 1, Number1 / OLED\_Pow(10, Length - i - 1) % 10 + '0');
  
}
  
}

/\*\*
  
\* @brief  OLED显示数字（十六进制，正数）
  
\* @param  Line 起始行位置，范围：1~4
  
\* @param  Column 起始列位置，范围：1~16
  
\* @param  Number 要显示的数字，范围：0~0xFFFFFFFF
  
\* @param  Length 要显示数字的长度，范围：1~8
  
\* @retval 无
  
\*/
  
void OLED\_ShowHexNum(uint8\_t Line, uint8\_t Column, uint32\_t Number, uint8\_t Length)
  
{
  
uint8\_t i, SingleNumber;
  
for (i = 0; i < Length; i++)
  
{
  
SingleNumber = Number / OLED\_Pow(16, Length - i - 1) % 16;
  
if (SingleNumber < 10)
  
{
  
OLED\_ShowChar(Line, Column + i, SingleNumber + '0');
  
}
  
else
  
{
  
OLED\_ShowChar(Line, Column + i, SingleNumber - 10 + 'A');
  
}
  
}
  
}

/\*\*
  
\* @brief  OLED显示数字（二进制，正数）
  
\* @param  Line 起始行位置，范围：1~4
  
\* @param  Column 起始列位置，范围：1~16
  
\* @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
  
\* @param  Length 要显示数字的长度，范围：1~16
  
\* @retval 无
  
\*/
  
void OLED\_ShowBinNum(uint8\_t Line, uint8\_t Column, uint32\_t Number, uint8\_t Length)
  
{
  
uint8\_t i;
  
for (i = 0; i < Length; i++)
  
{
  
OLED\_ShowChar(Line, Column + i, Number / OLED\_Pow(2, Length - i - 1) % 2 + '0');
  
}
  
}

/\*\*
  
\* @brief  OLED初始化
  
\* @param  无
  
\* @retval 无
  
\*/
  
void OLED\_Init(void)
  
{
  
uint32\_t i, j;
  
  
for (i = 0; i < 1000; i++)            //上电延时
  
{
  
for (j = 0; j < 1000; j++);
  
}
  
  
OLED\_I2C\_Init();            //端口初始化
  
  
OLED\_WriteCommand(0xAE);    //关闭显示
  
  
OLED\_WriteCommand(0xD5);    //设置显示时钟分频比/振荡器频率
  
OLED\_WriteCommand(0x80);
  
  
OLED\_WriteCommand(0xA8);    //设置多路复用率
  
OLED\_WriteCommand(0x3F);
  
  
OLED\_WriteCommand(0xD3);    //设置显示偏移
  
OLED\_WriteCommand(0x00);
  
  
OLED\_WriteCommand(0x40);    //设置显示开始行
  
  
OLED\_WriteCommand(0xA1);    //设置左右方向，0xA1正常 0xA0左右反置
  
  
OLED\_WriteCommand(0xC8);    //设置上下方向，0xC8正常 0xC0上下反置

OLED\_WriteCommand(0xDA);    //设置COM引脚硬件配置
  
OLED\_WriteCommand(0x12);
  
  
OLED\_WriteCommand(0x81);    //设置对比度控制
  
OLED\_WriteCommand(0xCF);

OLED\_WriteCommand(0xD9);    //设置预充电周期
  
OLED\_WriteCommand(0xF1);

OLED\_WriteCommand(0xDB);    //设置VCOMH取消选择级别
  
OLED\_WriteCommand(0x30);

OLED\_WriteCommand(0xA4);    //设置整个显示打开/关闭

OLED\_WriteCommand(0xA6);    //设置正常/倒转显示

OLED\_WriteCommand(0x8D);    //设置充电泵
  
OLED\_WriteCommand(0x14);

OLED\_WriteCommand(0xAF);    //开启显示
  
  
OLED\_Clear();                //OLED清屏
  
}

/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*ENCODER,H\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

#ifndef \_\_ENCODER\_H
  
#define \_\_ENCODER\_H

void Encoder\_Init(void);
  
int16\_t Encoder\_Get(void);

#endif
  
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*ENCODER,C\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

#include "stm32f10x.h"                  // Device header

/\*\*
  
\* 函    数：编码器初始化
  
\* 参    数：无
  
\* 返 回 值：无
  
\*/
  
void Encoder\_Init(void)
  
{
  
/\*开启时钟\*/
  
RCC\_APB1PeriphClockCmd(RCC\_APB1Periph\_TIM3, ENABLE);            //开启TIM3的时钟
  
RCC\_APB2PeriphClockCmd(RCC\_APB2Periph\_GPIOA, ENABLE);            //开启GPIOA的时钟
  
  
/\*GPIO初始化\*/
  
GPIO\_InitTypeDef GPIO\_InitStructure;
  
GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_IPU;
  
GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_6 | GPIO\_Pin\_7;
  
GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_50MHz;
  
GPIO\_Init(GPIOA, &GPIO\_InitStructure);                            //将PA6和PA7引脚初始化为上拉输入
  
  
/\*时基单元初始化\*/
  
TIM\_TimeBaseInitTypeDef TIM\_TimeBaseInitStructure;                //定义结构体变量
  
TIM\_TimeBaseInitStructure.TIM\_ClockDivision = TIM\_CKD\_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
  
TIM\_TimeBaseInitStructure.TIM\_CounterMode = TIM\_CounterMode\_Up; //计数器模式，选择向上计数
  
TIM\_TimeBaseInitStructure.TIM\_Period = 65536 - 1;               //计数周期，即ARR的值
  
TIM\_TimeBaseInitStructure.TIM\_Prescaler = 1 - 1;                //预分频器，即PSC的值
  
TIM\_TimeBaseInitStructure.TIM\_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到
  
TIM\_TimeBaseInit(TIM3, &TIM\_TimeBaseInitStructure);             //将结构体变量交给TIM\_TimeBaseInit，配置TIM3的时基单元
  
  
/\*输入捕获初始化\*/
  
TIM\_ICInitTypeDef TIM\_ICInitStructure;                            //定义结构体变量
  
TIM\_ICStructInit(&TIM\_ICInitStructure);                            //结构体初始化，若结构体没有完整赋值
  
//则最好执行此函数，给结构体所有成员都赋一个默认值
  
//避免结构体初值不确定的问题
  
TIM\_ICInitStructure.TIM\_Channel = TIM\_Channel\_1;                //选择配置定时器通道1
  
TIM\_ICInitStructure.TIM\_ICFilter = 0xF;                            //输入滤波器参数，可以过滤信号抖动
  
TIM\_ICInit(TIM3, &TIM\_ICInitStructure);                            //将结构体变量交给TIM\_ICInit，配置TIM3的输入捕获通道
  
TIM\_ICInitStructure.TIM\_Channel = TIM\_Channel\_2;                //选择配置定时器通道2
  
TIM\_ICInitStructure.TIM\_ICFilter = 0xF;                            //输入滤波器参数，可以过滤信号抖动
  
TIM\_ICInit(TIM3, &TIM\_ICInitStructure);                            //将结构体变量交给TIM\_ICInit，配置TIM3的输入捕获通道
  
  
/\*编码器接口配置\*/
  
TIM\_EncoderInterfaceConfig(TIM3, TIM\_EncoderMode\_TI12, TIM\_ICPolarity\_Rising, TIM\_ICPolarity\_Rising);
  
//配置编码器模式以及两个输入通道是否反相
  
//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相
  
//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置
  
  
/\*TIM使能\*/
  
TIM\_Cmd(TIM3, ENABLE);            //使能TIM3，定时器开始运行
  
}

/\*\*
  
\* 函    数：获取编码器的增量值
  
\* 参    数：无
  
\* 返 回 值：自上此调用此函数后，编码器的增量值
  
\*/
  
int16\_t Encoder\_Get(void)
  
{
  
/\*使用Temp变量作为中继，目的是返回CNT后将其清零\*/
  
int16\_t Temp;
  
Temp = TIM\_GetCounter(TIM3);
  
TIM\_SetCounter(TIM3, 0);
  
return Temp;
  
}
  
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*main.C\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

#include "stm32f10x.h"                  // Device header
  
#include "Delay.h"
  
#include "OLED.h"
  
#include "Timer.h"
  
#include "Encoder.h"

int16\_t Speed;            //定义速度变量

int main(void)
  
{
  
/\*模块初始化\*/
  
OLED\_Init();        //OLED初始化
  
Timer\_Init();        //定时器初始化
  
Encoder\_Init();        //编码器初始化
  
  
/\*显示静态字符串\*/
  
OLED\_ShowString(1, 1, "Speed:");        //1行1列显示字符串Speed:
  
  
while (1)
  
{
  
OLED\_ShowSignedNum(1, 7, Speed, 5);    //不断刷新显示编码器测得的最新速度
  
}
  
}

/\*\*
  
\* 函    数：TIM2中断函数
  
\* 参    数：无
  
\* 返 回 值：无
  
\* 注意事项：此函数为中断函数，无需调用，中断触发后自动执行
  
\*           函数名为预留的指定名称，可以从启动文件复制
  
\*           请确保函数名正确，不能有任何差异，否则中断函数将不能进入
  
\*/
  
void TIM2\_IRQHandler(void)
  
{
  
if (TIM\_GetITStatus(TIM2, TIM\_IT\_Update) == SET)        //判断是否是TIM2的更新事件触发的中断
  
{
  
Speed = Encoder\_Get();                                //每隔固定时间段读取一次编码器计数增量值，即为速度值
  
TIM\_ClearITPendingBit(TIM2, TIM\_IT\_Update);            //清除TIM2更新事件的中断标志位
  
//中断标志位必须清除
  
//否则中断将连续不断地触发，导致主程序卡死
  
}
  
}
  
//linking...
  
//Program Size: Code=3648 RO-data=1788 RW-data=4 ZI-data=1636
  
//".\Objects\Project.axf" - 0 Error(s), 0 Warning(s).
  
//Build Time Elapsed:  00:00:09 2025 3 15