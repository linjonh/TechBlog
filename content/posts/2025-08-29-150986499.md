---
layout: post
title: "Java使用apache.commons.math3的DBSCAN实现自动聚类"
date: 2025-08-29T15:15:29+0800
description: "摘要：本文介绍DBSCAN聚类算法在Java中的实现，适用于未知类别数量(K值)的场景。通过Apache Commons Math3库的DBSCANClusterer，演示了如何对多维向量数据进行自动分类。示例代码展示了关键参数eps(邻域半径)和minPts(最小点数)的设置对聚类结果的影响，并将5个三维数据点成功分为3个簇。最后指出该算法可应用于文本分类，只需将文本转化为词频向量(TF)或语义向量(如BERT、Word2Vec等)输入即可实现自动归类。"
keywords: "Java使用apache.commons.math3的DBSCAN实现自动聚类"
categories: ['未分类']
tags: ['自然语言处理', '聚类', '机器学习', '人工智能', 'Nlp', 'Java']
artid: "150986499"
arturl: "https://blog.csdn.net/Janix520/article/details/150986499"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150986499
    alt: "Java使用apache.commons.math3的DBSCAN实现自动聚类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150986499
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150986499
cover: https://bing.ee123.net/img/rand?artid=150986499
image: https://bing.ee123.net/img/rand?artid=150986499
img: https://bing.ee123.net/img/rand?artid=150986499
---



# Java使用apache.commons.math3的DBSCAN实现自动聚类

> K-Means: 如果你能大致估计出类别的数量，K-Means通常也是一个高效的选择。但它对异常值敏感，且要求簇是球状的。对于一些不知道数据可能会有多少类别的时候，可用试试DBSCAN算法，因为你通常无法预先知道文章会自动分成多少类（K值未知），用DBSCAN是非常不错的，能自动判断拿出类别数量，这里讲解一下java的math3里面自带方法

### 示例

```java
package com.data;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.math3.ml.clustering.Cluster;
import org.apache.commons.math3.ml.clustering.DBSCANClusterer;
import org.apache.commons.math3.ml.clustering.DoublePoint;

public class TestDBSCAN {

	public static void main(String[] args) {
		List<DoublePoint> rawPoints = new ArrayList<>();
		rawPoints.add(new DoublePoint(new double[] { 0.1, 0.2, 0.3 }));
		rawPoints.add(new DoublePoint(new double[] { 0.2, 0.14, 0.22 }));

		// 此处故意设置两个比较大点的值，和小点的值
		rawPoints.add(new DoublePoint(new double[] { 0.3, 0.4, 0.43 }));
		rawPoints.add(new DoublePoint(new double[] { 0.88, 0.8, 0.8 }));

		rawPoints.add(new DoublePoint(new double[] { 0.02, 0.112, 0.08 }));

		// 多少距离内归纳为同一个簇(两个向量之间的距离)
		double eps = 0.24;

		// 需要几个点形成簇
		int minPts = 0;

		// 执行聚类
		DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<>(eps, minPts);
		List<Cluster<DoublePoint>> clusters = clusterer.cluster(rawPoints);

		System.out.println("==== 聚类结果 ====");
		System.out.println("发现簇数量: " + clusters.size());

		// 打印每个簇
		for (int i = 0; i < clusters.size(); i++) {
			System.out.println("\n簇 #" + (i + 1) + ":");
			for (DoublePoint p : clusters.get(i).getPoints()) {
				System.out.println("  " + Arrays.toString(p.getPoint()));
			}
		}

	}

}

```

打印结果，很明显的自动区分了3个类别

```java
==== 聚类结果 ====
发现簇数量: 3

簇 #1:
  [0.1, 0.2, 0.3]
  [0.2, 0.14, 0.22]
  [0.02, 0.112, 0.08]

簇 #2:
  [0.3, 0.4, 0.43]

簇 #3:
  [0.88, 0.8, 0.8]


```

```java
// 多少距离内归纳为同一个簇(两个向量之间的距离)
double eps = 0.24;

// 需要几个点形成簇
int minPts = 0;

关键在于这两个参数，eps，比如设置成1，所有的都是同一类，也就只有一个簇，
当minPts设置为1的时候，这里不会出现簇2 簇3，因为小于等于1不认为是一个簇(分类)，
所以具体根据数据调整参数即可

```

## 文本分类如何应用

既然上面讲述了算法，文本无非就是提取向量，扔进去计算，一般文本向量分为两种，词频向量(TF)，语义向量（bert，word2vec，大模型经常用到的那种），只要拿到向量扔进去就能自动归类，这样知道其中某一段文本的类别，其他自然都知道了，应用完全能根据自己需求实现，思路大致都是一样的



