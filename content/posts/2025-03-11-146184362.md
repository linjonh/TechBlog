---
layout: post
title: "LVDS系列3Xilinx的IOBUFDS原语"
date: 2025-03-11 17:29:38 +0800
description: "前述的IBUFDS原语只能接收外部差分信号，此时连接管脚为input管脚，OBUFDS只能向外部输出差分信号，此时连接管脚为output管脚，但差分信号还有可能出现IO类型，也就是inout管脚，一对差分信号，可以输入，也可以输出，此时使用IBUFDS和OBUFDS就不能解决问题，需要使用到IOBUFDS原语；此时T=1，输出缓存启用，可以看到在原语的图中，IO、IOB到O的路径没有受到T端口开关的影响，此时O的输出来自IO、IOB，而IO、IOB的值此时来自于I，所以O值与I值相同。"
keywords: "LVDS系列3：Xilinx的IOBUFDS原语"
categories: ['Lvds']
tags: ['Fpga']
artid: "146184362"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146184362
    alt: "LVDS系列3Xilinx的IOBUFDS原语"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146184362
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146184362
cover: https://bing.ee123.net/img/rand?artid=146184362
image: https://bing.ee123.net/img/rand?artid=146184362
img: https://bing.ee123.net/img/rand?artid=146184362
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LVDS系列3：Xilinx的IOBUFDS原语
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     前面两节讲解了差分转单端的IBUFDS原语和单端转差分的OBUFDS原语，今天来讲一个同时带有两者功能的原语IOBUFDS；
     <br/>
     前述的IBUFDS原语只能接收外部差分信号，此时连接管脚为input管脚，OBUFDS只能向外部输出差分信号，此时连接管脚为output管脚，但差分信号还有可能出现IO类型，也就是inout管脚，一对差分信号，可以输入，也可以输出，此时使用IBUFDS和OBUFDS就不能解决问题，需要使用到IOBUFDS原语；
     <br/>
     如有一个典型的例子，DDR接口中的DQS数据选通信号，就是差分双向管脚DQS_P、DQS_N；
     <br/>
     该信号为双向信号，因为该信号与DQ数据采集相关，当对DDR读取时，该信号由DRAM驱动，当向DDR写入时，该信号由内存控制器驱动；
     <br/>
     且由于DDR通信的频率速率比较高，通常达几千Mbps，且数据选通信号需要用于8/16或更多数据信号线的捕获，所以需要其在传输过程中受的影响尽可能小信号尽可能稳定，所以使用抗干扰能力更强的差分信号则成了必要；
     <br/>
     所以该信号就需要使用IOBUFDS这样的三态双向差分信号原语；
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c152660657bf401aa10d2be825164e55.png">
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/01a29bd7fa04402cb1a257c73db5ac5d.png">
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b8a8272e20d54288bcecb1c7cb95e67f.png">
        <br/>
         IOBUFDS原语：
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/33213ae3dcb64a918522d242f6fda9d4.png">
         <br/>
         IOBUFDS为差分输入/输出缓存原语。 T 管脚上的逻辑高电平表示禁用输出缓存。
         <br/>
         端口IO、IOB：双向端口，连接到焊盘上的双向差分信号；
         <br/>
         端口I：原语的输入端口，接收FPGA内部数据变换后从IO和IOB输出；
         <br/>
         端口O：原语的输出端口，IO和IOB接收数据转换后从O端口输出到FPGA内部；
         <br/>
         端口T：原语的输入端口，控制原语的功能模式；
        </img>
       </img>
      </img>
     </img>
    </p>
    <p>
     功能模式说明：
     <br/>
     输入模式（T=1）：
     <br/>
     IO和IOB由外部设备驱动，作为差分输入信号。
     <br/>
     内部逻辑将IO和IOB的差分值（IO - IOB）转换为单端信号输出至O。
     <br/>
     例如，若IO=1且IOB=0，则O=1；若IO=0且IOB=1，则O=0，此时功能与IBUFDS一致。
     <br/>
     若外部差分信号未驱动（高阻态），O可能保持前一次有效值或进入不定态（X），需通过外部约束或硬件设计避免此情况。
     <br/>
     此时T=1，输出缓存被禁用，I到IO、IOB的路径关闭，原语的I端口输入任何值（无论0/1或是悬空）都不会对IO、IOB的电压状态造成任何影响；
    </p>
    <p>
     输出模式（T=0）：
     <br/>
     I的单端信号被转换为差分信号，驱动到IO（与I同相）和IOB（与I反相）。
     <br/>
     例如，若I=1，则IO=1且IOB=0；若I=0，则IO=0且IOB=1，此时功能与OBUFDS一致。
     <br/>
     此时T=1，输出缓存启用，可以看到在原语的图中，IO、IOB到O的路径没有受到T端口开关的影响，此时O的输出来自IO、IOB，而IO、IOB的值此时来自于I，所以O值与I值相同。
    </p>
    <p>
      原语例化如下：
     <br/>
     7系：
     <br/>
     IOBUFDS #(
     <br/>
     .DIFF_TERM(“FALSE”), // Differential Termination (“TRUE”/“FALSE”)
     <br/>
     .IBUF_LOW_PWR(“TRUE”), // Low Power - “TRUE”, High Performance = “FALSE”
     <br/>
     .IOSTANDARD(“BLVDS_25”), // Specify the I/O standard
     <br/>
     .SLEW(“SLOW”) // Specify the output slew rate
     <br/>
     ) IOBUFDS_inst (
     <br/>
     .O(O), // Buffer output
     <br/>
     .IO(IO), // Diff_p inout (connect directly to top-level port)
     <br/>
     .IOB(IOB), // Diff_n inout (connect directly to top-level port)
     <br/>
     .I(I), // Buffer input
     <br/>
     .T(T) // 3-state enable input, high=input, low=output
     <br/>
     );
    </p>
    <p>
     Ultrascale+系：
     <br/>
     IOBUFDS IOBUFDS_inst (
     <br/>
     .O(O), // 1-bit output: Buffer output
     <br/>
     .I(I), // 1-bit input: Buffer input
     <br/>
     .IO(IO), // 1-bit inout: Diff_p inout (connect directly to top-level port)
     <br/>
     .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
     <br/>
     .T(T) // 1-bit input: 3-state enable input
     <br/>
     );
    </p>
    <p>
     可以看到两个原语的端口一致，不过7系的原语同样比Ultrascale+系多几个参数，Ultrascale+的参数如前述，被整合到约束部分；
     <br/>
     7系例化里可以看到参数DIFF_TERM、IBUF_LOW_PWR在IBUFDS部分讲解过，SLEW在OBUFDS部分讲解过，IOSTANDARD则是两节里都讲过，这里不再赘述；
     <br/>
     不过这里可以看到模板默认的电平标准是BLVDS，BLVDS 仅在 HR I/O bank 中可用，并且要求 VCCO 电压电平为 2.5V。 IOSTANDARD 称为BLVDS_25，在下一讲将简单汇总下FPGA中常见的差分电平标准。
    </p>
    <p>
      IOBUFDS原语仿真：
     <br/>
     测试模块：
     <br/>
     module top_7series_iobufds(
     <br/>
     input wire clk,
     <br/>
     input wire rst,
     <br/>
     inout wire PAD_IO,
     <br/>
     inout wire PAD_IOB,
     <br/>
     input wire iob_t,
     <br/>
     input wire iob_in,
     <br/>
     output wire iob_out
     <br/>
     );
    </p>
    <p>
     IOBUFDS #(
     <br/>
     .DIFF_TERM(“FALSE”), // Differential Termination (“TRUE”/“FALSE”)
     <br/>
     .IBUF_LOW_PWR(“TRUE”), // Low Power - “TRUE”, High Performance = “FALSE”
     <br/>
     .IOSTANDARD(“BLVDS_25”), // Specify the I/O standard
     <br/>
     .SLEW(“SLOW”) // Specify the output slew rate
     <br/>
     ) IOBUFDS_inst (
     <br/>
     .O(iob_out), // Buffer output
     <br/>
     .IO(PAD_IO), // Diff_p inout (connect directly to top-level port)
     <br/>
     .IOB(PAD_IOB), // Diff_n inout (connect directly to top-level port)
     <br/>
     .I(iob_in), // Buffer input
     <br/>
     .T(iob_t) // 3-state enable input, high=input, low=output
     <br/>
     );
    </p>
    <p>
     endmodule
    </p>
    <p>
     testbench：
     <br/>
     这里将原语的T端口每隔1000ns切换一次，且设置50ns变化一次的两个随机值分别赋值给端口IO/IOB和端口I；然后仿真查看根据T端口的变化，原语的各端口输入输出如何变化；
     <br/>
     module tb;
     <br/>
     reg clk;
     <br/>
     reg rst;
     <br/>
     reg data1;
     <br/>
     reg data2;
     <br/>
     wire PAD_IO;
     <br/>
     wire PAD_IOB;
     <br/>
     reg iob_t;
     <br/>
     wire iob_in;
     <br/>
     wire iob_out;
     <br/>
     wire pad_dio;
     <br/>
     wire pad_diob;
    </p>
    <p>
     initial begin
     <br/>
     clk = 0;
     <br/>
     rst = 1;
     <br/>
     #100
     <br/>
     rst = 0;
     <br/>
     end
    </p>
    <p>
     always #50 clk = ~clk;
    </p>
    <p>
     initial begin
     <br/>
     data1 = 0;
     <br/>
     data2 = 0;
     <br/>
     while(1)begin
     <br/>
     #50
     <br/>
     data1 = $random();
     <br/>
     data2 = $random();
     <br/>
     end
     <br/>
     end
    </p>
    <p>
     initial begin
     <br/>
     iob_t = 0;
     <br/>
     while(1)begin
     <br/>
     #1000
     <br/>
     iob_t = ~iob_t;
     <br/>
     end
     <br/>
     end
    </p>
    <p>
     assign iob_in = iob_t ? 1’bz : data1;
     <br/>
     assign {PAD_IO,PAD_IOB} = iob_t ? {data2,~data2} : 2’bz;
     <br/>
     assign pad_dio = PAD_IO;
     <br/>
     assign pad_diob = PAD_IOB;
    </p>
    <p>
     top_7series_iobufds inst_top_7series_iobufds(
     <br/>
     .clk (clk),
     <br/>
     .rst (rst),
     <br/>
     .PAD_IO (PAD_IO),
     <br/>
     .PAD_IOB (PAD_IOB),
     <br/>
     .iob_t (iob_t),
     <br/>
     .iob_in (iob_in),
     <br/>
     .iob_out (iob_out)
     <br/>
     );
    </p>
    <p>
     endmodule
     <br/>
      仿真结果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/59b75c607ff242f1a4794fee5616574c.png">
      <br/>
      仿真波形如图所示：
      <br/>
      为方便描述，上图中4根黄线将波形分为4个区域，区域1/3的iob_t设置为0，表示原语处于输出模式，区域2/4的iob_t设置为1，表示原语处于输入模式；
     </img>
    </p>
    <p>
     可以看到：
    </p>
    <p>
     区域1/3，输出模式下，iob_in输入的值将被转换为差分的同相的PAD_IO和反相的PAD_IOB输出，可以看到在此范围内，PAD_IO输出值与iob_in相同，PAD_IOB输出值与iob_in相反；
     <br/>
     此时iob_out的值与iob_in相同；
    </p>
    <p>
     区域2/4，输入模式下，PAD_IO和PAD_IOB将作为输入，转换后端口O输出，可以看到在此范围内，端口O输出与PAD_IO相同，与PAD_IOB相反；
     <br/>
     而且此时iob_in输入接口给了一个悬空的高阻状态，但是可以看到图中所示，这个iob_in的高阻输入也不会对PAD_IO和PAD_IOB产生任何影响；
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33383832383338322f:61727469636c652f64657461696c732f313436313834333632" class_="artid" style="display:none">
 </p>
</div>


