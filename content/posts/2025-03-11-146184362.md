---
layout: post
title: "LVDS系列3Xilinx的IOBUFDS原语"
date: 2025-03-11 17:29:38 +0800
description: "前述的IBUFDS原语只能接收外部差分信号，此时连接管脚为input管脚，OBUFDS只能向外部输出差分信号，此时连接管脚为output管脚，但差分信号还有可能出现IO类型，也就是inout管脚，一对差分信号，可以输入，也可以输出，此时使用IBUFDS和OBUFDS就不能解决问题，需要使用到IOBUFDS原语；此时T=1，输出缓存启用，可以看到在原语的图中，IO、IOB到O的路径没有受到T端口开关的影响，此时O的输出来自IO、IOB，而IO、IOB的值此时来自于I，所以O值与I值相同。"
keywords: "LVDS系列3：Xilinx的IOBUFDS原语"
categories: ['Lvds']
tags: ['Fpga']
artid: "146184362"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146184362
    alt: "LVDS系列3Xilinx的IOBUFDS原语"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146184362
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146184362
cover: https://bing.ee123.net/img/rand?artid=146184362
image: https://bing.ee123.net/img/rand?artid=146184362
img: https://bing.ee123.net/img/rand?artid=146184362
---

# LVDS系列3：Xilinx的IOBUFDS原语
前面两节讲解了差分转单端的IBUFDS原语和单端转差分的OBUFDS原语，今天来讲一个同时带有两者功能的原语IOBUFDS；
前述的IBUFDS原语只能接收外部差分信号，此时连接管脚为input管脚，OBUFDS只能向外部输出差分信号，此时连接管脚为output管脚，但差分信号还有可能出现IO类型，也就是inout管脚，一对差分信号，可以输入，也可以输出，此时使用IBUFDS和OBUFDS就不能解决问题，需要使用到IOBUFDS原语；
如有一个典型的例子，DDR接口中的DQS数据选通信号，就是差分双向管脚DQS\_P、DQS\_N；
该信号为双向信号，因为该信号与DQ数据采集相关，当对DDR读取时，该信号由DRAM驱动，当向DDR写入时，该信号由内存控制器驱动；
且由于DDR通信的频率速率比较高，通常达几千Mbps，且数据选通信号需要用于8/16或更多数据信号线的捕获，所以需要其在传输过程中受的影响尽可能小信号尽可能稳定，所以使用抗干扰能力更强的差分信号则成了必要；
所以该信号就需要使用IOBUFDS这样的三态双向差分信号原语；
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c152660657bf401aa10d2be825164e55.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/01a29bd7fa04402cb1a257c73db5ac5d.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b8a8272e20d54288bcecb1c7cb95e67f.png)
 IOBUFDS原语：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/33213ae3dcb64a918522d242f6fda9d4.png)
IOBUFDS为差分输入/输出缓存原语。 T 管脚上的逻辑高电平表示禁用输出缓存。
端口IO、IOB：双向端口，连接到焊盘上的双向差分信号；
端口I：原语的输入端口，接收FPGA内部数据变换后从IO和IOB输出；
端口O：原语的输出端口，IO和IOB接收数据转换后从O端口输出到FPGA内部；
端口T：原语的输入端口，控制原语的功能模式；
功能模式说明：
输入模式（T=1）：
IO和IOB由外部设备驱动，作为差分输入信号。
内部逻辑将IO和IOB的差分值（IO - IOB）转换为单端信号输出至O。
例如，若IO=1且IOB=0，则O=1；若IO=0且IOB=1，则O=0，此时功能与IBUFDS一致。
若外部差分信号未驱动（高阻态），O可能保持前一次有效值或进入不定态（X），需通过外部约束或硬件设计避免此情况。
此时T=1，输出缓存被禁用，I到IO、IOB的路径关闭，原语的I端口输入任何值（无论0/1或是悬空）都不会对IO、IOB的电压状态造成任何影响；
输出模式（T=0）：
I的单端信号被转换为差分信号，驱动到IO（与I同相）和IOB（与I反相）。
例如，若I=1，则IO=1且IOB=0；若I=0，则IO=0且IOB=1，此时功能与OBUFDS一致。
此时T=1，输出缓存启用，可以看到在原语的图中，IO、IOB到O的路径没有受到T端口开关的影响，此时O的输出来自IO、IOB，而IO、IOB的值此时来自于I，所以O值与I值相同。
 原语例化如下：
7系：
IOBUFDS #(
.DIFF\_TERM(“FALSE”), // Differential Termination (“TRUE”/“FALSE”)
.IBUF\_LOW\_PWR(“TRUE”), // Low Power - “TRUE”, High Performance = “FALSE”
.IOSTANDARD(“BLVDS\_25”), // Specify the I/O standard
.SLEW(“SLOW”) // Specify the output slew rate
) IOBUFDS\_inst (
.O(O), // Buffer output
.IO(IO), // Diff\_p inout (connect directly to top-level port)
.IOB(IOB), // Diff\_n inout (connect directly to top-level port)
.I(I), // Buffer input
.T(T) // 3-state enable input, high=input, low=output
);
Ultrascale+系：
IOBUFDS IOBUFDS\_inst (
.O(O), // 1-bit output: Buffer output
.I(I), // 1-bit input: Buffer input
.IO(IO), // 1-bit inout: Diff\_p inout (connect directly to top-level port)
.IOB(IOB), // 1-bit inout: Diff\_n inout (connect directly to top-level port)
.T(T) // 1-bit input: 3-state enable input
);
可以看到两个原语的端口一致，不过7系的原语同样比Ultrascale+系多几个参数，Ultrascale+的参数如前述，被整合到约束部分；
7系例化里可以看到参数DIFF\_TERM、IBUF\_LOW\_PWR在IBUFDS部分讲解过，SLEW在OBUFDS部分讲解过，IOSTANDARD则是两节里都讲过，这里不再赘述；
不过这里可以看到模板默认的电平标准是BLVDS，BLVDS 仅在 HR I/O bank 中可用，并且要求 VCCO 电压电平为 2.5V。
IOSTANDARD 称为BLVDS\_25，在下一讲将简单汇总下FPGA中常见的差分电平标准。
 IOBUFDS原语仿真：
测试模块：
module top\_7series\_iobufds(
input wire clk,
input wire rst,
inout wire PAD\_IO,
inout wire PAD\_IOB,
input wire iob\_t,
input wire iob\_in,
output wire iob\_out
);
IOBUFDS #(
.DIFF\_TERM(“FALSE”), // Differential Termination (“TRUE”/“FALSE”)
.IBUF\_LOW\_PWR(“TRUE”), // Low Power - “TRUE”, High Performance = “FALSE”
.IOSTANDARD(“BLVDS\_25”), // Specify the I/O standard
.SLEW(“SLOW”) // Specify the output slew rate
) IOBUFDS\_inst (
.O(iob\_out), // Buffer output
.IO(PAD\_IO), // Diff\_p inout (connect directly to top-level port)
.IOB(PAD\_IOB), // Diff\_n inout (connect directly to top-level port)
.I(iob\_in), // Buffer input
.T(iob\_t) // 3-state enable input, high=input, low=output
);
endmodule
testbench：
这里将原语的T端口每隔1000ns切换一次，且设置50ns变化一次的两个随机值分别赋值给端口IO/IOB和端口I；然后仿真查看根据T端口的变化，原语的各端口输入输出如何变化；
module tb;
reg clk;
reg rst;
reg data1;
reg data2;
wire PAD\_IO;
wire PAD\_IOB;
reg iob\_t;
wire iob\_in;
wire iob\_out;
wire pad\_dio;
wire pad\_diob;
initial begin
clk = 0;
rst = 1;
#100
rst = 0;
end
always #50 clk = ~clk;
initial begin
data1 = 0;
data2 = 0;
while(1)begin
#50
data1 = $random();
data2 = $random();
end
end
initial begin
iob\_t = 0;
while(1)begin
#1000
iob\_t = ~iob\_t;
end
end
assign iob\_in = iob\_t ? 1’bz : data1;
assign {PAD\_IO,PAD\_IOB} = iob\_t ? {data2,~data2} : 2’bz;
assign pad\_dio = PAD\_IO;
assign pad\_diob = PAD\_IOB;
top\_7series\_iobufds inst\_top\_7series\_iobufds(
.clk (clk),
.rst (rst),
.PAD\_IO (PAD\_IO),
.PAD\_IOB (PAD\_IOB),
.iob\_t (iob\_t),
.iob\_in (iob\_in),
.iob\_out (iob\_out)
);
endmodule
 仿真结果：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/59b75c607ff242f1a4794fee5616574c.png)
仿真波形如图所示：
为方便描述，上图中4根黄线将波形分为4个区域，区域1/3的iob\_t设置为0，表示原语处于输出模式，区域2/4的iob\_t设置为1，表示原语处于输入模式；
可以看到：
区域1/3，输出模式下，iob\_in输入的值将被转换为差分的同相的PAD\_IO和反相的PAD\_IOB输出，可以看到在此范围内，PAD\_IO输出值与iob\_in相同，PAD\_IOB输出值与iob\_in相反；
此时iob\_out的值与iob\_in相同；
区域2/4，输入模式下，PAD\_IO和PAD\_IOB将作为输入，转换后端口O输出，可以看到在此范围内，端口O输出与PAD\_IO相同，与PAD\_IOB相反；
而且此时iob\_in输入接口给了一个悬空的高阻状态，但是可以看到图中所示，这个iob\_in的高阻输入也不会对PAD\_IO和PAD\_IOB产生任何影响；