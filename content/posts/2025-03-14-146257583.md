---
layout: post
title: "对最近的刷题做一个小总结关于动态规划和贪心"
date: 2025-03-14 16:23:47 +0800
description: "双指针+动态规划dp+滚动数组优化dp"
keywords: "对最近的刷题做一个小总结(关于动态规划和贪心)"
categories: ['刷题日记']
tags: ['算法', '双指针', '动态规划']
artid: "146257583"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257583
    alt: "对最近的刷题做一个小总结关于动态规划和贪心"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257583
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257583
cover: https://bing.ee123.net/img/rand?artid=146257583
image: https://bing.ee123.net/img/rand?artid=146257583
img: https://bing.ee123.net/img/rand?artid=146257583
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     对最近的刷题做一个小总结(关于动态规划和贪心)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="1__4">
     </a>
     1. 小总结
    </h2>
    <p>
     最近刷了很多算法题，真正了解到的算法应是dfs，多元dfs，以及动态规划和贪心。
    </p>
    <p>
     dfs和多元dfs目前并没有真正深入研究过，不过熟悉套路之后，整体的编写还是挺简单的。
    </p>
    <p>
     对于动态规划，整体的逻辑还是很简单的，难就难在有些题，你看不出来可以用动态规划，比如“约瑟夫环”的问题，而且就算看出来是动态规划，如何确定状态表示，是从这里开始，还是到这里结束，是这两者都可以，还是只有一个可以，这些都是有讲究的，自己还需要再多刷一些动态规划的题目。不过，就我现在的感受而言，动态规划其实跟递推，函数递归等都很类似，本质上都是解决重复子问题。
    </p>
    <p>
     至于贪心，贪心算法确实是没有那么好get到的，它的原理很简单，关键在于想清楚该怎么“贪”，并且要能够确保这样子“贪”，是正确的，能够从局部最优得到全局最优，这个确定还是比较复杂的。
    </p>
    <hr/>
    <h2>
     <a id="2__16">
     </a>
     2. 两道算法题
    </h2>
    <p>
     来看一道双指针和一道动态规划的问题。
    </p>
    <h3>
     <a id="21__19">
     </a>
     2.1 数组中两个字符串的最小距离
    </h3>
    <blockquote>
     <p>
      题目描述：给定给定两个字符串str1和str2，再一个字符串数组strs，返回在strs中str1和str2的最小距离，如果str1或str2为null，或不在strs中，返回-1。
      <br/>
      输入描述：输入包含有多行，第一输入一个整数n（1 &lt;= n &lt;= 100000），代表数组strs的长度，第二行有两个字符串分别代表str1和str2，接下来n行，每行一个字符串，代表数组strs(保证题目中出现的所有字符串长度均小于等于10)
      <br/>
      输出描述：输出一行，包含一个整数，代表返回的值。
      <br/>
      补充说明：时间复杂度O(n)，额外空间复杂度O(1)
     </p>
    </blockquote>
    <p>
     <a href="https://www.nowcoder.com/practice/2c6a0a8e1d20492f92941400036e0890" rel="nofollow">
      OJ链接
     </a>
    </p>
    <p>
     这道题，是在一个给定的字符数组中，找出两个字符串之间的最小距离。
     <br/>
     考虑到，时间复杂度为O(n)，所以暴力的O(n ^ 2)遍历肯定是不行的，这题显然应该在给定的原字符数组中用双指针来实现，这样能够满足时空复杂度的要求。
    </p>
    <p>
     而要想做到使用双指针进行解决，必须找到一定的规律。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/46da823558ee493b91b52a7d2f8f7fc0.png">
      <br/>
      在上图中，如果想要找到两个字符串中的最小距离，有一点是很明确的：对于编号为4的“def”，编号为1的“abc”其实与之相距不可能是最小的，因为前面还有一个编号为2的"def"，也就是说，以编号为4的"def"为基准时，另外一个指针没必要从头开始找，
      <strong>
       而这一点就是本题可以使用双指针的规律所在。
      </strong>
     </img>
    </p>
    <p>
     我们代码的整体逻辑就是：
    </p>
    <ol>
     <li>
      先找到两个对应的字符串，然后根据下标，确定两个字符串的先后关系。
     </li>
     <li>
      靠后的字符串先不动，靠前的字符串接着循环去找下一个与自身相同的字符串，在这个过程中，不断更新距离，直到这个字符串在原先靠后的字符串之后为止。
     </li>
     <li>
      继续重复2中的逻辑，直到整个字符数组都被遍历完，跳出循环，此时得到的距离便是两个字符串在整个字符数组中，对应的最小距离。
     </li>
    </ol>
    <p>
     具体I/O代码如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	string s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> s1 <span class="token operator">&gt;&gt;</span> s2<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> arr<span class="token punctuation">;</span>
	arr<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	string tmp<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> tmp<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		arr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>sz <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> distance <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span>  arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s1<span class="token punctuation">)</span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> s2<span class="token punctuation">)</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			distance <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>distance<span class="token punctuation">,</span><span class="token function">abs</span><span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				i<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s1<span class="token punctuation">)</span>
					i<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				j<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> s2<span class="token punctuation">)</span>
					j<span class="token operator">++</span><span class="token operator">:</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">if</span><span class="token punctuation">(</span>distance <span class="token operator">==</span> INT_MAX<span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>distance<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="22__99">
     </a>
     2.2 孩子们的游戏
    </h3>
    <p>
     每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0… m-1报数…这样下去…直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b90205591df04d1483ddcb440c3701b1.png">
      <br/>
      要求时间复杂度为O(n),空间复杂度为O(n)。
      <br/>
      <a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow">
       OJ链接
      </a>
     </img>
    </p>
    <p>
     这是一道非常经典的约瑟夫环问题。
    </p>
    <p>
     约瑟夫环问题大致有两种解法：
    </p>
    <ol>
     <li>
      模拟实现约瑟夫环。使用循环链表可以对约瑟夫环进行很好地模拟，使用数组也可以模拟，不过没有循环链表那么方便，但是模拟的时间复杂度为O(m * n) ，空间复杂度为O(n)，在这道题中，通过模拟实现约瑟夫环来解决问题是不合题意的。
     </li>
     <li>
      使用动态规划解决约瑟夫环。使用动态规划解决约瑟夫环，寥寥几行代码便可以解决一个较为复杂的问题，是“四两拨千斤”的典范，且时空复杂度满足题意，故使用这种做法。
     </li>
    </ol>
    <p>
     如何用动态规划解决约瑟夫环。
    </p>
    <p>
     <strong>
      状态表示：dp[n]表示有n个人，最后留下来的那个人的编号
     </strong>
    </p>
    <p>
     <strong>
      状态转移方程：这里状态转移方程的确定是一个难点，状态转移方程应为：dp[n] = (dp[n - 1] + m) % n。这里的+m是映射回去时所加，模上一个n是防止加上m之后，编号超过n - 1。
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/491182f261524a1d8dba8fc9db2ce6f1.png">
      <br/>
      <strong>
       初始化：此处的动态规划只需用到前面一个的值，因此初始化dp[1]即可，dp[1]显然应该为0.
      </strong>
      <br/>
      <strong>
       填表顺序：一维dp，用到前面的值，因此从左往右填表。
      </strong>
      <br/>
      <strong>
       返回值：返回dp[n]即可。
      </strong>
     </img>
    </p>
    <p>
     <strong>
      不过,由于此题中要求空间复杂度为O(1)，因此不能直接用dp表，而使用滚动数组进行空间复杂度的优化。
     </strong>
    </p>
    <p>
     具体代码如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">LastRemaining_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            ret <span class="token operator">=</span> <span class="token punctuation">(</span>ret <span class="token operator">+</span> m<span class="token punctuation">)</span> <span class="token operator">%</span> i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38363033373832362f:61727469636c652f64657461696c732f313436323537353833" class_="artid" style="display:none">
 </p>
</div>


