---
layout: post
title: "策略模式Strategy-Pattern与状态模式State-Pattern的异同"
date: 2025-03-14 13:41:59 +0800
description: "两者均通过将行为委托给其他对象来实现功能解耦，遵循“组合优于继承”的原则。均支持扩展新的策略或状态，无需修改现有代码。两者在结构上相似，但设计目标和适用场景不同。：将状态相关的行为委托给具体的状态类。，状态变化由上下文或状态自身触发。：将算法逻辑委托给具体的策略类。，由客户端主动控制策略的选择。：持有策略或状态对象的引用。：定义行为方法的统一接口。"
keywords: "策略模式（Strategy Pattern）与状态模式（State Pattern）的异同"
categories: ['设计模式']
tags: ['策略模式', '状态模式']
artid: "146255529"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146255529
    alt: "策略模式Strategy-Pattern与状态模式State-Pattern的异同"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146255529
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146255529
cover: https://bing.ee123.net/img/rand?artid=146255529
image: https://bing.ee123.net/img/rand?artid=146255529
img: https://bing.ee123.net/img/rand?artid=146255529
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     策略模式（Strategy Pattern）与状态模式（State Pattern）的异同
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     <strong>
      相同点
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        行为委托
       </strong>
       <br/>
       两者均通过将行为委托给其他对象来实现功能解耦，遵循“组合优于继承”的原则。
      </p>
      <ul>
       <li>
        <p>
         <strong>
          策略模式
         </strong>
         ：将算法逻辑委托给具体的策略类。
        </p>
       </li>
       <li>
        <p>
         <strong>
          状态模式
         </strong>
         ：将状态相关的行为委托给具体的状态类。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        类结构相似
       </strong>
       <br/>
       两者在类图结构上高度相似，均包含：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          上下文类（Context）
         </strong>
         ：持有策略或状态对象的引用。
        </p>
       </li>
       <li>
        <p>
         <strong>
          抽象接口（Strategy/State）
         </strong>
         ：定义行为方法的统一接口。
        </p>
       </li>
       <li>
        <p>
         <strong>
          具体实现类（ConcreteStrategy/ConcreteState）
         </strong>
         ：实现具体行为。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        开闭原则
       </strong>
       <br/>
       均支持扩展新的策略或状态，无需修改现有代码。
      </p>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      不同点
     </strong>
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         维度
        </strong>
       </th>
       <th>
        <strong>
         策略模式
        </strong>
       </th>
       <th>
        <strong>
         状态模式
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         核心目的
        </strong>
       </td>
       <td>
        <strong>
         灵活替换算法
        </strong>
       </td>
       <td>
        <strong>
         管理对象的状态转换
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         控制权
        </strong>
       </td>
       <td>
        客户端主动选择策略
       </td>
       <td>
        状态对象自动触发状态转换
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         依赖关系
        </strong>
       </td>
       <td>
        策略之间相互独立
       </td>
       <td>
        状态之间可能相互依赖
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         生命周期
        </strong>
       </td>
       <td>
        策略的生命周期由客户端管理
       </td>
       <td>
        状态的转换由上下文或状态自身管理
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         典型场景
        </strong>
       </td>
       <td>
        算法选择（排序、支付方式）
       </td>
       <td>
        对象状态管理（订单、游戏角色状态）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         代码复杂度
        </strong>
       </td>
       <td>
        简单，仅需替换策略
       </td>
       <td>
        复杂，需处理状态转换逻辑
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      应用场景示例
     </strong>
    </h4>
    <h5>
     <strong>
      策略模式：支付方式选择
     </strong>
    </h5>
    <pre><code class="language-cpp">// 抽象策略接口
class PaymentStrategy {
public:
    virtual void pay(int amount) = 0;
};

// 具体策略类：信用卡支付
class CreditCardPayment : public PaymentStrategy {
public:
    void pay(int amount) override {
        std::cout &lt;&lt; "Paid " &lt;&lt; amount &lt;&lt; " via Credit Card." &lt;&lt; std::endl;
    }
};

// 具体策略类：支付宝支付
class AlipayPayment : public PaymentStrategy {
public:
    void pay(int amount) override {
        std::cout &lt;&lt; "Paid " &lt;&lt; amount &lt;&lt; " via Alipay." &lt;&lt; std::endl;
    }
};

// 上下文类（订单）
class Order {
private:
    PaymentStrategy* strategy;
public:
    void setStrategy(PaymentStrategy* strategy) {
        this-&gt;strategy = strategy;
    }
    void checkout(int amount) {
        strategy-&gt;pay(amount);
    }
};

// 使用示例
int main() {
    Order order;
    CreditCardPayment creditCard;
    AlipayPayment alipay;

    order.setStrategy(&amp;creditCard);
    order.checkout(100);  // 输出: Paid 100 via Credit Card.

    order.setStrategy(&amp;alipay);
    order.checkout(200);  // 输出: Paid 200 via Alipay.
}</code></pre>
    <h5>
     <strong>
      状态模式：订单状态管理
     </strong>
    </h5>
    <pre><code class="language-cpp">// 抽象状态接口
class OrderState {
public:
    virtual void handle(OrderContext* context) = 0;
};

// 具体状态类：待付款
class PendingPaymentState : public OrderState {
public:
    void handle(OrderContext* context) override {
        std::cout &lt;&lt; "Processing payment..." &lt;&lt; std::endl;
        context-&gt;setState(new PaidState()); // 状态转换
    }
};

// 具体状态类：已付款
class PaidState : public OrderState {
public:
    void handle(OrderContext* context) override {
        std::cout &lt;&lt; "Order is paid. Preparing for shipment." &lt;&lt; std::endl;
        context-&gt;setState(new ShippedState());
    }
};

// 上下文类（订单）
class OrderContext {
private:
    OrderState* state;
public:
    OrderContext() : state(new PendingPaymentState()) {}
    void setState(OrderState* newState) {
        delete state;
        state = newState;
    }
    void proceed() {
        state-&gt;handle(this);
    }
};

// 使用示例
int main() {
    OrderContext order;
    order.proceed();  // 输出: Processing payment... → 状态变为 PaidState
    order.proceed();  // 输出: Order is paid. Preparing for shipment. → 状态变为 ShippedState
}</code></pre>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        策略模式
       </strong>
       ：关注
       <strong>
        算法的灵活替换
       </strong>
       ，由客户端主动控制策略的选择。
      </p>
     </li>
     <li>
      <p>
       <strong>
        状态模式
       </strong>
       ：关注
       <strong>
        对象内部状态的动态转换
       </strong>
       ，状态变化由上下文或状态自身触发。
      </p>
     </li>
    </ul>
    <p>
     两者在结构上相似，但设计目标和适用场景不同。
     <strong>
      策略模式是“静态多态”，而状态模式是“动态多态”
     </strong>
     。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34303032363733392f:61727469636c652f64657461696c732f313436323535353239" class_="artid" style="display:none">
 </p>
</div>


