---
layout: post
title: "说一下redis事务底层原理"
date: 2025-03-04 21:24:11 +0800
description: "不支持回滚：如果事务中的某个命令失败，其他命令仍然会执行，Redis 不会自动回滚。部分失败问题：事务中的命令可能会部分成功、部分失败。性能开销：WATCH 机制会增加额外的性能开销。"
keywords: "说一下redis事务底层原理"
categories: ['未分类']
tags: ['计算机网络', '网络', '缓存', '数据库', 'Redis', 'Java', 'Acid']
artid: "146023501"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146023501
    alt: "说一下redis事务底层原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146023501
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146023501
cover: https://bing.ee123.net/img/rand?artid=146023501
image: https://bing.ee123.net/img/rand?artid=146023501
img: https://bing.ee123.net/img/rand?artid=146023501
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     说一下redis事务底层原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3 id="p14RW">
     Redis事务
    </h3>
    <h4 id="6cdcfe5d">
     <strong>
      1. 事务的基本流程
     </strong>
    </h4>
    <p id="u8d5a99cf">
     Redis 事务通过
     <code>
      MULTI
     </code>
     、
     <code>
      EXEC
     </code>
     、
     <code>
      WATCH
     </code>
     等命令实现，底层原理可以分为以下几个步骤：
    </p>
    <h5 id="2c0ab612">
     <strong>
      (1) MULTI 命令
     </strong>
    </h5>
    <ul>
     <li id="u563e36bf">
      当客户端发送
      <code>
       MULTI
      </code>
      命令时，Redis 会将客户端标记为“事务模式”。
     </li>
     <li id="ue16ac7f0">
      在事务模式下，客户端发送的所有命令不会立即执行，而是被放入一个队列（命令队列）中。
     </li>
    </ul>
    <h5 id="8773901f">
     <strong>
      (2) 命令入队
     </strong>
    </h5>
    <ul>
     <li id="u16cde1a5">
      在
      <code>
       MULTI
      </code>
      和
      <code>
       EXEC
      </code>
      之间，客户端发送的所有命令都会被追加到事务队列中。
     </li>
     <li id="u206eca6b">
      这些命令不会立即执行，而是等待
      <code>
       EXEC
      </code>
      命令的触发。
     </li>
    </ul>
    <h5 id="a06c444e">
     <strong>
      (3) EXEC 命令
     </strong>
    </h5>
    <ul>
     <li id="u2f0673d7">
      当客户端发送
      <code>
       EXEC
      </code>
      命令时，Redis 会依次执行事务队列中的所有命令。
     </li>
     <li id="u9c62b80d">
      执行过程中，所有命令是原子的，不会被其他客户端的命令打断。
     </li>
    </ul>
    <h5 id="167503b2">
     <strong>
      (4) WATCH 命令
     </strong>
    </h5>
    <ul>
     <li id="u4413b14c">
      <code>
       WATCH
      </code>
      命令用于实现乐观锁。
     </li>
     <li id="u6d988a08">
      当客户端对一个或多个键执行
      <code>
       WATCH
      </code>
      后，如果在
      <code>
       EXEC
      </code>
      执行之前，这些键被其他客户端修改，则当前事务会失败（返回
      <code>
       nil
      </code>
      ）
     </li>
    </ul>
    <p id="ua7feb456">
     watch我们可以指定监听一个键和多个键，然后exec批量执行
    </p>
    <pre id="QrkbO"><code>WATCH key [key ...]</code></pre>
    <hr id="mYagj"/>
    <h4 id="fe4252d6">
     <strong>
      2. 事务的原子性
     </strong>
    </h4>
    <ul>
     <li id="u9c7e92b1">
      Redis 事务的原子性是通过单线程模型实现的。
     </li>
     <li id="u40e3a035">
      Redis 是单线程的，所有命令都是顺序执行的。在
      <code>
       EXEC
      </code>
      执行时，事务队列中的命令会连续执行，不会被其他客户端的命令打断。
     </li>
    </ul>
    <hr id="j86P8"/>
    <h4 id="00af3d2b">
     <strong>
      3. 事务的一致性
     </strong>
    </h4>
    <ul>
     <li id="u91167bc1">
      Redis 事务的一致性是通过
      <code>
       WATCH
      </code>
      机制实现的。
     </li>
     <li id="ubf32db45">
      如果
      <code>
       WATCH
      </code>
      的键在事务执行期间被修改，事务会失败，从而保证数据的一致性。
     </li>
    </ul>
    <hr id="kxtGn"/>
    <h4 id="08fdfa56">
     <strong>
      4. 事务的局限性
     </strong>
    </h4>
    <ul>
     <li id="u1807715e">
      <strong>
       不支持回滚
      </strong>
      ：如果事务中的某个命令失败，其他命令仍然会执行，Redis 不会自动回滚。
     </li>
     <li id="ubb9a0aa5">
      <strong>
       部分失败问题
      </strong>
      ：事务中的命令可能会部分成功、部分失败。
     </li>
     <li id="uc6d158ea">
      <strong>
       性能开销
      </strong>
      ：
      <code>
       WATCH
      </code>
      机制会增加额外的性能开销。
     </li>
    </ul>
    <hr id="tga2i"/>
    <h3 id="429fd2db">
     <strong>
      Redis 7 对事务的优化
     </strong>
    </h3>
    <p id="uf3758d71">
     Redis 7 在事务机制上并没有完全改变底层实现，但引入了一些优化和改进：
    </p>
    <h4 id="439aa6a0">
     <strong>
      1. 性能优化
     </strong>
    </h4>
    <ul>
     <li id="u50ecf113">
      Redis 7 对事务的执行流程进行了优化，减少了事务模式下的性能开销。
     </li>
     <li id="ud6f7b03f">
      通过改进命令队列的处理方式，提高了事务的执行效率。
     </li>
    </ul>
    <h4 id="fa247d80">
     <strong>
      2. Lua 脚本的增强
     </strong>
    </h4>
    <ul>
     <li id="u0de28691">
      Redis 7 对 Lua 脚本的支持进行了增强，使得 Lua 脚本可以更好地与事务结合使用。
     </li>
     <li id="ubdb5495b">
      Lua 脚本在 Redis 7 中的执行效率更高，同时支持更多的 Redis 命令。
     </li>
    </ul>
    <h4 id="f9904aad">
     <strong>
      3. 更好的错误处理
     </strong>
    </h4>
    <ul>
     <li id="ub7de7698">
      Redis 7 改进了事务中的错误处理机制，使得事务失败时的错误信息更加清晰。
     </li>
     <li id="uecadc81d">
      如果事务中的某个命令失败，Redis 7 会返回更详细的错误信息，方便排查问题。
     </li>
    </ul>
    <h4 id="8f19554a">
     <strong>
      4. 功能增强
     </strong>
    </h4>
    <ul>
     <li id="ucd60aab2">
      Redis 7 引入了更多的命令和功能，可以与事务结合使用。
     </li>
     <li id="u24ff6c06">
      例如，Redis 7 支持更多的数据类型和操作，使得事务可以处理更复杂的场景。
     </li>
    </ul>
    <hr id="keveb"/>
    <h3 id="77d151dc">
     <strong>
      Redis 事务的底层实现细节
     </strong>
    </h3>
    <h4 id="fd2f48df">
     <strong>
      1. 命令队列
     </strong>
    </h4>
    <ul>
     <li id="u6519f3ac">
      在事务模式下，Redis 会为每个客户端维护一个命令队列。
     </li>
     <li id="u4e765bfe">
      所有在
      <code>
       MULTI
      </code>
      和
      <code>
       EXEC
      </code>
      之间发送的命令都会被追加到队列中。
     </li>
    </ul>
    <h4 id="a40115c7">
     <strong>
      2. 事务执行
     </strong>
    </h4>
    <ul>
     <li id="ue1f481fc">
      当
      <code>
       EXEC
      </code>
      命令被触发时，Redis 会依次执行命令队列中的所有命令。
     </li>
     <li id="u5296fcb0">
      执行过程中，Redis 会保证命令的原子性，不会被其他客户端的命令打断。
     </li>
    </ul>
    <h4 id="d8152238">
     <strong>
      3. WATCH 机制
     </strong>
    </h4>
    <ul>
     <li id="ube5eb829">
      <code>
       WATCH
      </code>
      命令会监视一个或多个键。
     </li>
     <li id="u2837c224">
      如果在
      <code>
       EXEC
      </code>
      执行之前，这些键被其他客户端修改，则当前事务会失败。
     </li>
     <li id="uc7bcaddb">
      <code>
       WATCH
      </code>
      的实现基于 Redis 的键空间通知机制。
     </li>
    </ul>
    <hr id="vkWdJ"/>
    <h3 id="25f9c7fa">
     <strong>
      总结
     </strong>
    </h3>
    <ul>
     <li id="u1744e8be">
      <strong>
       Redis 事务的底层原理
      </strong>
      是基于
      <code>
       MULTI/EXEC/WATCH
      </code>
      机制，通过命令队列和乐观锁实现原子性和一致性。
     </li>
     <li id="u78c94302">
      <strong>
       Redis 7
      </strong>
      在事务机制上进行了性能优化和功能增强，但底层实现并没有本质变化。
     </li>
     <li id="u660b8439">
      <strong>
       Redis 事务的局限性
      </strong>
      包括不支持回滚、部分失败问题和性能开销。
     </li>
     <li id="uf1fcdf50">
      如果需要更强大的事务支持，可以结合 Lua 脚本或使用支持 ACID 事务的数据库。
     </li>
    </ul>
    <hr id="zWjxx"/>
    <h3 id="hA9rP">
     Redis+Lua脚本实现手动回滚补偿
    </h3>
    <p id="ue9572b14">
     我们每一步执行失败，我们就依次撤销前面的操作
    </p>
    <p id="u58ecb6e7">
     可惜这个并不是真正的acid，我们的mysql执行事务的时候宕机了，它的事务没有提交所以数据并不会进到mysql里面
    </p>
    <p id="u1d8d06bf">
     而redis是人为控制的，所以我们执行lua脚本的时候宕机了，我们之前事务中执行的操作数据仍然进去了，这个是我们无法解决的
    </p>
    <pre id="HRJcP"><code>local key1 = KEYS[1]
local key2 = KEYS[2]
local key3 = KEYS[3]
local value = ARGV[1]

-- 记录原始值
local original_value1 = redis.call('GET', key1)
local original_value2 = redis.call('GET', key2)
local original_value3 = redis.call('GET', key3)

-- 第一步操作
redis.call('SET', key1, value)

-- 第二步操作
if redis.call('EXISTS', key2) == 0 then
    -- 手动回滚第一步操作
    redis.call('SET', key1, original_value1)
    return "Key2 does not exist"
end
redis.call('SET', key2, value)

-- 第三步操作
if redis.call('EXISTS', key3) == 0 then
    -- 手动回滚前两步操作
    redis.call('SET', key1, original_value1)
    redis.call('SET', key2, original_value2)
    return "Key3 does not exist"
end
redis.call('SET', key3, value)

return "Transaction successful"</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f4c554349415a5a5a2f:61727469636c652f64657461696c732f313436303233353031" class_="artid" style="display:none">
 </p>
</div>


