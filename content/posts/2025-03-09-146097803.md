---
layout: post
title: "C-链表List使用与实现拷贝交换与高效迭代器细致讲解"
date: 2025-03-09 09:39:35 +0800
description: "本篇文章主要讲解List容器的使用与List容器的模拟实现"
keywords: "C++ 链表List使用与实现：拷贝交换与高效迭代器细致讲解"
categories: ['C']
tags: ['链表', '数据结构', '学习', 'List', 'C']
artid: "146097803"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146097803
    alt: "C-链表List使用与实现拷贝交换与高效迭代器细致讲解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146097803
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146097803
cover: https://bing.ee123.net/img/rand?artid=146097803
image: https://bing.ee123.net/img/rand?artid=146097803
img: https://bing.ee123.net/img/rand?artid=146097803
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ 链表List使用与实现：拷贝交换与高效迭代器细致讲解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      目录
     </strong>
    </p>
    <p style="margin-left:0px">
     <a href="#list%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A" rel="nofollow">
      list的使用：
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC" rel="nofollow">
      构造与赋值
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE" rel="nofollow">
      元素访问
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C" rel="nofollow">
      修改操作
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%AE%B9%E9%87%8F%E6%9F%A5%E8%AF%A2" rel="nofollow">
      容量查询
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E9%93%BE%E8%A1%A8%E7%89%B9%E6%9C%89%E6%93%8D%E4%BD%9C" rel="nofollow">
      链表特有操作
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E6%8B%BC%E6%8E%A5%EF%BC%88Splice%EF%BC%89" rel="nofollow">
      拼接（Splice）
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#C%2B%2B11%20%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95" rel="nofollow">
      C++11 新增方法
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%B3%A8%E6%84%8F%EF%BC%9A" rel="nofollow">
      注意：
     </a>
    </p>
    <p style="margin-left:80px">
    </p>
    <p style="margin-left:0px">
     <a href="#stl_list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">
      stl_list的模拟实现：
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%89%BA%E6%9C%AF" rel="nofollow">
      一、链表节点设计的艺术
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#1.1%20%E7%BB%93%E6%9E%84%E4%BD%93%20vs%20%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">
      1.1 结构体 vs 类的选择
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%E4%BA%8C%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%B2%BE%E9%AB%93" rel="nofollow">
      二、迭代器实现的精髓
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9C%A8%E6%9C%AC%E6%96%87%E7%AB%A0%E5%90%8E%E9%9D%A2%E8%BF%98%E4%BC%9A%E6%9B%B4%E6%96%B0%EF%BC%89" rel="nofollow">
      2.1 为什么需要自定义迭代器？（迭代器在本文章后面还会更新）
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#2.2%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0" rel="nofollow">
      2.2 运算符重载的细节实现
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0" rel="nofollow">
      三、链表类的完整实现
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#3.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9" rel="nofollow">
      3.1 构造函数与哨兵节点
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#3.2%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%8C%83%E5%9B%B4%E8%8E%B7%E5%8F%96" rel="nofollow">
      3.2 迭代器范围获取
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#3.3%20%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90" rel="nofollow">
      3.3 核心操作实现解析
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%3Ainsert%28%29" rel="nofollow">
      插入操作:insert()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%B0%BE%E6%8F%92%EF%BC%9Apush_back%28%29" rel="nofollow">
      尾插：push_back()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%A4%B4%E6%8F%92%EF%BC%9Apush_front%28%29" rel="nofollow">
      头插：push_front()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%3Aerase%28%29" rel="nofollow">
      删除操作:erase()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%B0%BE%E5%88%A0%EF%BC%9Apop_back%28%29" rel="nofollow">
      尾删：pop_back()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%A4%B4%E5%88%A0%EF%BC%9Apop_front%28%29" rel="nofollow">
      头删：pop_front()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0size%28%29%E3%80%81empty%28%29" rel="nofollow">
      辅助函数实现size()、empty()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8x~list%28%29%E3%80%81%E6%B8%85%E9%99%A4%E6%95%B0%E6%8D%AEclear%28%29" rel="nofollow">
      析构函数销毁链表x~list()、清除数据clear()
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0list%28const%20list%3CT%3E%26%20lt%29" rel="nofollow">
      拷贝构造list(const list&amp; lt)
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E8%B5%8B%E5%80%BClist%3CT%3E%26%20operator%3D%3D%28%29%E3%80%81swap%28%29" rel="nofollow">
      赋值list&amp; operator==()、swap()
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%82%E6%95%B0%E8%A6%81%E3%80%8C%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%8D%EF%BC%9F" rel="nofollow">
      为什么参数要「按值传递」？
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A" rel="nofollow">
      运作原理：
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E4%BC%98%E5%8A%BF%EF%BC%9A" rel="nofollow">
      优势：
     </a>
    </p>
    <p style="margin-left:0px">
     <a href="#%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8" rel="nofollow">
      四、关键问题深度探讨
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%C2%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%9B%B4%E6%96%B0%E5%8E%9Fiterator%E7%B1%BB%EF%BC%89%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">
      自定义类型（更新原iterator类）​编辑
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#3.%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%87%8D%E8%BD%BD%C2%A0%20%C2%A0operator-%3E%28%29" rel="nofollow">
      3.方法三：重载   operator-&gt;()
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%8F%AF%E8%A7%86%E5%8C%96" rel="nofollow">
      内存布局可视化
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#PrintList%28%29%E3%80%81const_iterator" rel="nofollow">
      PrintList()、const_iterator
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%80%E4%BD%BF%E4%BB%A3%E7%A0%81%E5%86%97%E4%BD%99%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E8%83%BD%E5%A4%9F%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E3%80%82" rel="nofollow">
      方法二：方法一使代码冗余，我们需要学习一种方法能够解决这个问题。
     </a>
    </p>
    <p style="margin-left:0px">
     <a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">
      完整代码：
     </a>
    </p>
    <hr/>
    <p>
    </p>
    <p>
     <strong>
      本文章主要简要讲解list容器的使用与详细讲解list模拟实现以及相关问题上，所用到完整代码在文章末尾
     </strong>
    </p>
    <h2>
     list的使用：
    </h2>
    <h4>
     <strong>
      构造与赋值
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        构造函数
       </strong>
      </p>
      <pre><code class="language-cpp">list&lt;int&gt; lt;                // 空链表
list&lt;int&gt; lt2(5, 10);        // 5 个元素，每个初始化为 10
list&lt;int&gt; lt3(lt2.begin(), lt2.end()); // 通过迭代器范围构造
list&lt;int&gt; lt4 = {1, 2, 3};   // 初始化列表（C++11）</code></pre>
     </li>
     <li>
      <p>
       <strong>
        赋值操作
       </strong>
      </p>
      <pre><code class="language-cpp">lt = lt2;                    // 深拷贝赋值
lt.assign(3, 100);           // 替换内容为 3 个 100
lt.assign(lt2.begin(), lt2.end()); // 通过迭代器赋值</code></pre>
      <p>
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      元素访问
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        首尾元素front()、back()
       </strong>
      </p>
      <pre><code class="language-cpp">int front = lt.front();      // 首元素（不可修改空链表）
int back = lt.back();        // 尾元素（不可修改空链表）</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        迭代器begin()、rbegin()
       </strong>
      </p>
      <pre><code class="language-cpp">list&lt;int&gt;::iterator it = lt.begin(); // 正向迭代器
list&lt;int&gt;::reverse_iterator rit = lt.rbegin(); // 反向迭代器</code></pre>
      <p>
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      修改操作
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        插入
       </strong>
      </p>
      <pre><code class="language-cpp">lt.push_front(0);            // 头部插入
lt.push_back(4);             // 尾部插入

auto pos = lt.begin();
lt.insert(pos, 99);          // 在迭代器位置前插入
lt.insert(pos, 3, 88);       // 插入 3 个 88</code></pre>
     </li>
     <li>
      <p>
       <strong>
        删除
       </strong>
      </p>
      <pre><code class="language-cpp">lt.pop_front();              // 删除头部元素
lt.pop_back();               // 删除尾部元素

lt.erase(pos);               // 删除迭代器位置元素
lt.erase(pos, lt.end());     // 删除迭代器范围

lt.remove(4);               // 删除所有值为 4 的节点</code></pre>
     </li>
     <li>
      <p>
       <strong>
        清空链表（clear）
       </strong>
      </p>
      <pre><code class="language-cpp">lt.clear();                  // 清空所有元素</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      容量查询
     </strong>
    </h4>
    <pre><code class="language-cpp">bool isEmpty = lt.empty();      // 是否为空
size_t size = lt.size();        // 元素个数（O(n) 时间复杂度！）
lt.resize(10);                 // 调整链表大小</code></pre>
    <hr/>
    <h4>
     <strong>
      链表特有操作
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        拼接（Splice）
       </strong>
      </p>
      <pre><code class="language-cpp">// 将 lt2 的全部内容移动到 lt 的 pos 位置前
lt.splice(pos, lt2);         // lt2 会被清空

// 移动单个元素
auto it2 = lt2.begin();
//pos为目标位置，it2为需要移动的单个元素，拿走it2，再尾差pos，改变节点的指向
lt.splice(pos, lt2, it2);

// 移动范围
lt.splice(pos, lt2, lt2.begin(), lt2.end());</code></pre>
      <p>
       <strong>
        注意：被转移的节点会被清空
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        合并（Merge）
       </strong>
      </p>
      <pre><code class="language-cpp">// 前提：lt 和 lt2 必须已按相同顺序排序（升序或降序）
lt.sort();                   // 默认升序
lt2.sort();
lt.merge(lt2);               // 合并后 lt2 为空</code></pre>
     </li>
     <li>
      <p>
       <strong>
        排序（Sort）
       </strong>
      </p>
      <pre><code class="language-cpp">lt.sort();                   // 默认升序
lt.sort(greater&lt;int&gt;());     // 降序（需包含 &lt;functional&gt;）</code></pre>
     </li>
     <li>
      <p>
       <strong>
        去重（Unique）
       </strong>
      </p>
      <pre><code class="language-cpp">lt.sort();                   // 必须先排序！
lt.unique();                 // 删除连续重复元素</code></pre>
     </li>
     <li>
      <p>
       <strong>
        反转（Reverse）
       </strong>
      </p>
      <pre><code class="language-cpp">lt.reverse();                // 反转链表顺序</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      C++11 新增方法
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        原地构造（Emplace）
       </strong>
      </p>
      <pre><code class="language-cpp">lt.emplace_front(10);        // 在头部直接构造对象（避免拷贝）
lt.emplace_back(20);         // 尾部构造
lt.emplace(pos, 30);         // 指定位置构造</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        移动语义
       </strong>
      </p>
      <pre><code class="language-cpp">list&lt;int&gt; lt5 = std::move(lt); // 移动构造（高效转移资源）</code></pre>
      <p>
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     注意：
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        merge 前必须排序
       </strong>
      </p>
      <pre><code class="language-cpp">// 错误示例：lt 是降序，lt1 是升序
lt.sort(greater&lt;int&gt;());    // 降序
lt1.sort();                 // 升序
lt.merge(lt1);             // 未定义行为！

// 正确做法：统一顺序
lt.sort();                 // 升序
lt1.sort();
lt.merge(lt1);</code></pre>
     </li>
     <li>
      <p>
       <strong>
        unique 必须配合 sort
       </strong>
      </p>
      <pre><code class="language-cpp">// 错误用法：未排序时去重
lt.unique();               // 只能删除连续重复

// 正确用法
lt.sort();
lt.unique();               // 删除所有重复</code></pre>
     </li>
     <li>
      <p>
       <strong>
        迭代器失效
       </strong>
      </p>
      <ul>
       <li>
        <p>
         在插入/删除操作后，指向被修改位置的迭代器会失效，需重新获取。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
    </h4>
    <h2>
     stl_list的模拟实现：
    </h2>
    <h3>
     一、链表节点设计的艺术
    </h3>
    <h4>
     1.1 结构体 vs 类的选择
    </h4>
    <pre><code class="language-cpp">template&lt;class T&gt;
struct ListNode {
    ListNode&lt;T&gt;* _next;  // 后继指针
    ListNode&lt;T&gt;* _prev;  // 前驱指针
    T _data;             // 存储数据

    // 默认构造函数初始化三要素
    ListNode(const T&amp; x = T())
        :_next(nullptr),
        _prev(nullptr),
        _data(x)
    {}
};</code></pre>
    <p>
     <strong>
      设计要点分析
     </strong>
     ：
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        使用
        <code>
         struct
        </code>
        而非
        <code>
         class
        </code>
        的深层考量：
       </p>
       <ul>
        <li>
         <p>
          默认public访问权限，便于链表类直接操作节点指针
         </p>
        </li>
        <li>
         <p>
          符合C++标准库实现惯例，增强代码可读性
         </p>
        </li>
        <li>
         <p>
          节点本身无需封装，属于链表内部实现细节
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        三指针设计哲学：
       </p>
       <ul>
        <li>
         <p>
          <code>
           _next
          </code>
          和
          <code>
           _prev
          </code>
          构成双向链接的基石
         </p>
        </li>
        <li>
         <p>
          <code>
           _data
          </code>
          采用模板类型，支持任意数据类型存储
         </p>
        </li>
        <li>
         <p>
          默认构造函数的巧妙设计：同时支持无参构造和值初始化
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        内存布局可视化：
       </p>
       <pre><code class="language-cpp">+------+    +------+    +------+
| prev |&lt;--&gt;| prev |&lt;--&gt;| prev |
| data |    | data |    | data |
| next |---&gt;| next |---&gt;| next |
+------+    +------+    +------+</code></pre>
      </li>
     </ol>
    </blockquote>
    <h3>
     二、迭代器实现的精髓
    </h3>
    <h4>
     2.1 为什么需要自定义迭代器？（迭代器在本文章后面还会更新）
    </h4>
    <pre><code class="language-cpp">template&lt;class T&gt;
struct ListIterator {
    typedef ListNode&lt;T&gt; Node;
    typedef ListIterator&lt;T&gt; Self;

    Node* _node;  // 核心：封装节点指针

    // 构造函数实现指针到迭代器的转换
    ListIterator(Node* node):_node(node){}
};</code></pre>
    <blockquote>
     <p>
      <strong>
       关键问题解答
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        原生指针的局限性：
       </p>
       <ul>
        <li>
         <p>
          无法直接通过++操作跳转到下一个节点
         </p>
        </li>
        <li>
         <p>
          解引用操作不符合链表数据访问需求
         </p>
        </li>
        <li>
         <p>
          无法正确比较链表节点的位置关系
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        迭代器设计模式的优势：
       </p>
       <ul>
        <li>
         <p>
          统一容器访问接口
         </p>
        </li>
        <li>
         <p>
          隐藏底层数据结构差异
         </p>
        </li>
        <li>
         <p>
          支持算法泛型编程
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h4>
     2.2 运算符重载的细节实现
    </h4>
    <pre><code class="language-cpp">// 前置++：直接修改自身
Self&amp; operator++() {
    _node = _node-&gt;_next;  // 关键跳转逻辑
    return *this;
}

// 后置++：返回临时对象
Self operator++(int) {
    Self tmp(*this);      // 拷贝当前状态
    _node = _node-&gt;_next;
    return tmp;           // 返回旧值
}

//1. --it
Self&amp; operator--()
{
	_node = _node-&gt;_prev;
	return *this;
}
//2. it--
Self operator--(int)
{
	Self tmp(*this);
	_node = _node-&gt;_prev;
	return tmp;
}

// 解引用：访问节点数据
T&amp; operator*() {
    return _node-&gt;_data;  // 返回引用支持修改
}

//两个迭代器是否相等？
bool operator!=(const Self&amp; it)
{
	//即比较节点的指针，节点的指针相同，他们就相同
	return _node != it._node;
}


// 相等性比较的本质
bool operator==(const Self&amp; it) {
    return _node == it._node;  // 指针地址比较
}</code></pre>
    <blockquote>
     <p>
      <strong>
       实现细节剖析
      </strong>
      ：
     </p>
     <ol>
      <li>
       <p>
        前置与后置++的差异：
       </p>
       <ol>
        <li>
         <p>
          性能考量：避免不必要的拷贝
         </p>
        </li>
        <li>
         <p>
          语法区分：int参数占位符
         </p>
        </li>
       </ol>
      </li>
      <li>
       <p>
        解引用操作的注意事项：
       </p>
       <ul>
        <li>
         <p>
          返回引用以实现左值操作
         </p>
        </li>
        <li>
         <p>
          与const迭代器的兼容性设计
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        比较大小是否需要重载？不需要，一个类是否要重载一个运算符，需要看他是否有意义，节点后面的地址不能保证比前面的地址大，所以没什么意义。不需要重载
       </p>
      </li>
     </ol>
    </blockquote>
    <h3>
     三、链表类的完整实现
    </h3>
    <h4>
     3.1 构造函数与哨兵节点
    </h4>
    <p>
     重新定义类型名称便于阅读：
    </p>
    <pre><code class="language-cpp">
	template&lt;class T&gt;
	class list 
	{
		typedef ListNode&lt;T&gt; Node;

	public:
		//在这里定义好类型
		typedef ListIterator&lt;T&gt; iterator;
    };
</code></pre>
    <pre><code class="language-cpp">list() {
    _head = new Node;       // 创建哨兵节点
    _head-&gt;_next = _head;   // 自环初始化
    _head-&gt;_prev = _head;
    _size = 0;              // 尺寸计数器
}</code></pre>
    <blockquote>
     <p>
      <strong>
       哨兵节点的精妙之处
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        统一空链表和非空链表的操作
       </p>
      </li>
      <li>
       <p>
        简化边界条件处理
       </p>
      </li>
      <li>
       <p>
        保证迭代器end()的有效性
       </p>
      </li>
      <li>
       <p>
        内存布局示意图：
       </p>
       <pre><code class="language-cpp">[HEAD] &lt;-&gt; [NODE1] &lt;-&gt; [NODE2] &lt;-&gt; [HEAD]</code></pre>
      </li>
     </ul>
    </blockquote>
    <h4>
     3.2 迭代器范围获取
    </h4>
    <blockquote>
     <pre><code class="language-cpp">iterator begin() 
{
    // 1.有名对象
    //iterator it(_head-&gt;_next);
    //return it;
    // 2.隐式类型转换(单参数的构造函数支持隐式类型的转换)：
    //return _head-&gt;_next;
    // 3.匿名对象 
    return iterator(_head-&gt;_next);  // 隐式转换
}

iterator end() {
    return iterator(_head);         // 哨兵即终点
}</code></pre>
     <ul>
      <li>
       <p>
        统一使用匿名对象构造迭代器
       </p>
      </li>
      <li>
       <p>
        begin()指向首元节点，end()指向哨兵节点
       </p>
      </li>
      <li>
       <p>
        支持C++11范围for循环的关键
       </p>
      </li>
     </ul>
    </blockquote>
    <h4>
     3.3 核心操作实现解析
    </h4>
    <h4>
     插入操作:insert()
    </h4>
    <p>
     选定位置插入：insert()
    </p>
    <pre><code class="language-cpp">//在pos位置插入data
void insert(iterator pos, const T&amp; data) {
    Node* current = pos._node;
    Node* newnode = new Node(data);  // 内存申请
    
    // 四步链接法
    Node* prev = current-&gt;_prev;
    prev-&gt;_next = newnode;
    newnode-&gt;_prev = prev;
    newnode-&gt;_next = current;
    current-&gt;_prev = newnode;

    ++_size;  // 维护尺寸
}</code></pre>
    <h4>
     尾插：push_back()
    </h4>
    <pre><code class="language-cpp">void push_back(const T&amp; x)
{
	//1.还未写insert()时写的push_back()
	//Node* newnode = new Node(x);

	//Node* tail = _head-&gt;_prev; //指定被插的节点

	//tail-&gt;_next = newnode;
	//newnode-&gt;_prev = tail;
	//newnode-&gt;_next = _head;
	//_head-&gt;_prev = newnode;

	//2.写了insert()后写的push_back()
	insert(end(), x);
}</code></pre>
    <h4>
     头插：push_front()
    </h4>
    <pre><code class="language-cpp">void push_front(const T&amp; x)
{
	insert(begin(), x);
}</code></pre>
    <p>
     <strong>
      四步链接法示意图
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">Before: [PREV] &lt;-&gt; [CURRENT]
After:  [PREV] &lt;-&gt; [NEWNODE] &lt;-&gt; [CURRENT]</code></pre>
    <blockquote>
     <h4>
      删除操作:erase()
     </h4>
     <pre><code class="language-cpp">iterator erase(iterator pos) {
    Node* cur = pos._node;
    Node* prev = cur-&gt;_prev;
    Node* next = cur-&gt;_next;

    // 重新链接相邻节点
    prev-&gt;_next = next;
    next-&gt;_prev = prev;
    
    delete cur;     // 释放内存
    --_size;        // 更新尺寸
    
    return iterator(next);  // 返回有效迭代器
}</code></pre>
     <p>
      <strong>
       迭代器失效问题
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        删除操作使当前迭代器失效
       </p>
      </li>
      <li>
       <p>
        返回新迭代器的必要性
       </p>
      </li>
      <li>
       <p>
        正确使用模式示例：
       </p>
       <pre><code class="language-cpp">auto it = lst.begin();
while(it != lst.end()) {
    if(condition) {
        it = lst.erase(it);  // 接收返回值
    } else {
        ++it;
    }
}</code></pre>
      </li>
     </ul>
    </blockquote>
    <h4>
     尾删：pop_back()
    </h4>
    <blockquote>
     <pre><code class="language-cpp">//尾删  ，要--,不然删的是head(哨兵位)
void pop_back()
{
	erase(--end());  
}
</code></pre>
    </blockquote>
    <h4>
     头删：pop_front()
    </h4>
    <blockquote>
     <pre><code class="language-cpp">//头删
void pop_front()
{
	erase(begin());
}</code></pre>
    </blockquote>
    <h4>
     辅助函数实现size()、empty()
    </h4>
    <blockquote>
     <pre><code class="language-cpp">size_t size() const { return _size; }  // O(1)时间复杂度

bool empty() { return _size == 0; }    // 高效判空
</code></pre>
     <p>
      <strong>
       性能优化点
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        使用_size变量避免遍历计数
       </p>
      </li>
      <li>
       <p>
        empty()的常数时间复杂度
       </p>
      </li>
      <li>
       <p>
        clear()的通用实现方式
       </p>
      </li>
     </ul>
    </blockquote>
    <h4>
     析构函数销毁链表x~list()、清除数据clear()
    </h4>
    <pre><code class="language-cpp">//清除掉所有数据，有没有清除掉头结点？并没有（在析构函数中清除）
void clear()
{
	iterator it = begin();
	while (it != end())
	{
		it = erase(it);
	}
}

~list()
{
	clear();
	delete _head;
	_head = nullptr;
}</code></pre>
    <h4>
     拷贝构造list(const list&lt;T&gt;&amp; lt)
    </h4>
    <blockquote>
     <p>
      为了拷贝构造的实现方便我们将空链表的制作做了一个成员函数，因此默认的无参构造函数可以直接使用这个成员函数
     </p>
     <pre><code class="language-cpp">	void empty_init()
	{
		//创建一个头结点
		_head = new Node;
		_head-&gt;_next = _head;
		_head-&gt;_prev = _head;

		_size = 0;x
	}

	//构造函数  
	list()
	{
		empty_init();
	}</code></pre>
     <p>
      拷贝构造,默认拷贝构造是浅拷贝，所以需要我们自己实现一个深拷贝（防止指向同一个空间，析构两次同一空间导致错误）
     </p>
     <pre><code class="language-cpp">//lt2(lt1)
list(const list&lt;T&gt;&amp; lt)
{
	//首先：在这里我们先创建空链表
	//也就是：lt2.empty_init()直接给lt2创建一个空链表即创建一个哨兵位头结点
	empty_init();
	//直接遍历一遍lt1，尾插
	for (auto&amp; e : lt)//这里一定要加引用，因为如果T是string，就浅拷贝了
	{
		push_back(e);
	}
}</code></pre>
    </blockquote>
    <h4>
     赋值list&lt;T&gt;&amp; operator==()、swap()
    </h4>
    <p>
     调用库里的swap（&lt;algorithm&gt;）
    </p>
    <pre><code class="language-cpp">void swap(list&lt;T&gt;&amp; lt)
{
	std::swap(_head, lt._head);
	std::swap(_size, lt._size);
}

//赋值
//lt1 = lt3
list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt) //lt  = lt3;
{
	swap(lt);
}</code></pre>
    <blockquote>
     <p>
      <strong>
       为什么参数要「按值传递」？
      </strong>
     </p>
     <p>
      我的代码中赋值运算符的实现如下：
     </p>
     <pre><code class="language-cpp">list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt) { // 参数按值传递
    swap(lt);
    return *this;
}</code></pre>
     <p>
      <strong>
       运作原理
      </strong>
      ：
     </p>
     <ol>
      <li>
       <p>
        <strong>
         按值传递参数
        </strong>
        ：调用
        <code>
         operator=
        </code>
        时，
        <code>
         lt
        </code>
        是传入对象的
        <strong>
         副本
        </strong>
        （触发拷贝构造函数）。
       </p>
      </li>
      <li>
       <p>
        <strong>
         交换资源
        </strong>
        ：通过
        <code>
         swap
        </code>
        将当前对象的
        <code>
         _head
        </code>
        和
        <code>
         _size
        </code>
        与副本
        <code>
         lt
        </code>
        交换。
       </p>
      </li>
      <li>
       <p>
        <strong>
         自动析构副本
        </strong>
        ：函数结束时，临时副本
        <code>
         lt
        </code>
        被析构，释放原对象的旧资源。
       </p>
      </li>
     </ol>
     <p>
      <strong>
       优势
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        <strong>
         天然处理自我赋值
        </strong>
        ：即使
        <code>
         lt1 = lt1;
        </code>
        ，参数
        <code>
         lt
        </code>
        是原对象的副本，交换后旧资源由副本释放。
       </p>
      </li>
      <li>
       <p>
        <strong>
         异常安全
        </strong>
        ：拷贝过程（生成
        <code>
         lt
        </code>
        ）在交换前完成，若拷贝失败不会影响原对象。
       </p>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      小技巧：需要析构，就需要自己写深拷贝，不需要析构，默认浅拷贝
     </strong>
    </p>
    <h2>
     四、关键问题深度探讨
    </h2>
    <blockquote>
     <h3>
      自定义类型（更新原iterator类）
      <img alt="" src="https://i-blog.csdnimg.cn/direct/8c1f9a8b2eb240878cff08da56847472.png"/>
     </h3>
     <p>
      出现报错的原因是：内置类型才支持流插入提取，而A是自定义类型，所以在这里不支持，需要自己写运算符重载。
     </p>
     <p>
      1.方法一：改变提取方式
     </p>
     <pre><code class="language-cpp">			cout &lt;&lt; (*it)._a1 &lt;&lt; ":" &lt;&lt; (*it)._a2 &lt;&lt; endl;
</code></pre>
     <p>
      2.方法二：写流插入
     </p>
     <p>
      省略
     </p>
     <h4>
      <strong>
       3.方法三：重载   operator-&gt;()
      </strong>
     </h4>
     <pre><code class="language-cpp">		//it-&gt;
		T* operator-&gt;()
		{
			return &amp;_node-&gt;_data;//返回的是_data的地址
		}</code></pre>
     <p>
      实际上用箭头会方便很多。
     </p>
     <p>
      <img alt="" src="https://i-blog.csdnimg.cn/direct/07b331f57ed44af5a24505233c458933.png"/>
     </p>
     <p>
      编译器为了可读性，省略了一个→
     </p>
     <pre><code class="language-cpp">			cout &lt;&lt; it-&gt;_a1 &lt;&lt; ":" &lt;&lt; it-&gt;_a2 &lt;&lt; endl;
</code></pre>
     <p>
      实现原理：
     </p>
     <p>
      <img alt="" src="https://i-blog.csdnimg.cn/direct/d662a3ae156b4925b4a0d0e39fd00805.png"/>
     </p>
     <p>
      编译器隐藏了一个箭头实际上是:
     </p>
     <p>
      <strong>
       it-&gt;-&gt;_a1
      </strong>
     </p>
     <p>
      <strong>
       (it.operator-&gt;())-&gt;_a1,   (it.operator-&gt;())
      </strong>
      返回的是data的地址即T*，在这里就是我们的自定义类型 A*，有了A*此时就可以访问直接访问结构体成员_a1，_a2。从而得到他们的值。这里将it的行为当成A*  。
     </p>
     <p>
      内存布局可视化
     </p>
     <pre><code class="language-cpp">+---------------------+
| ListIterator对象     |
|   _node: 0x1000    |
+---------------------+
           |
           v
+---------------------+    +---------------------+
| ListNode&lt;A&gt;节点      |    | A结构体实例          |
|   _prev: 0x2000     |    |   _a1: 1           |
|   _next: 0x3000     |    |   _a2: 5           |
|   _data: 0x4000     |---&gt;+---------------------+
+---------------------+    </code></pre>
     <p>
      <strong>
       当调用
       <code>
        it-&gt;_a1
       </code>
       时：
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         通过
         <code>
          _node
         </code>
         找到数据节点
        </strong>
       </p>
      </li>
      <li>
       <p>
        <strong>
         获取
         <code>
          _data
         </code>
         的内存地址（0x4000）
        </strong>
       </p>
      </li>
      <li>
       <p>
        <strong>
         通过指针访问结构体成员
         <code>
          _a1
         </code>
        </strong>
       </p>
      </li>
     </ol>
    </blockquote>
    <h3>
     <code>
      PrintList()、const_iterator
     </code>
    </h3>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3b8ff95c6a864f3dbf59c0e529f05218.png"/>
    </p>
    <p>
     因为现在的clt是一个const成员变量，而begin()、end()还未加const
    </p>
    <p>
     加完const后编译通过：
     <strong>
      权限可以缩小但是不能扩大，非const成员可以调用const成员，const成员不能调用非const成员
     </strong>
    </p>
    <pre><code class="language-cpp">		iterator begin() const
		{
			return iterator(_head-&gt;_next);
		}

		iterator end() const
		{
			return iterator(_head);
		}</code></pre>
    <p>
     这样真的就没有问题了吗？
    </p>
    <p>
     按理来说，普通迭代器是能够修改的，但这里是const,是不能修改的：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6ab55eed98834abf89587b5c2187a271.png"/>
    </p>
    <p>
     <strong>
      实际上我们测试了一下，被修改了，说明代码有问题
     </strong>
    </p>
    <p>
     原因出在这里，由于这里可以让非const对象访问，访问后
     <strong>
      返回的是普通迭代器
     </strong>
     ，普通迭代器是支持被修改的
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/27bb5194d8a745d8b91880972a3e401f.png"/>
    </p>
    <p>
     所以我们需要再重载const版本的,
     <strong>
      返回值也要记得修改
     </strong>
    </p>
    <pre><code class="language-cpp">//const版本
const_iterator begin() const
{
	return const_iterator(_head-&gt;_next);
}

const_iterator end() const
{
	return const_iterator(_head);
}</code></pre>
    <p>
     <strong>
      const迭代器，需要的不是是迭代器不能被修改，
     </strong>
     <strong>
      而是迭代器指向的的内容不能被修改
     </strong>
     <strong>
      ，所以不能用
     </strong>
     const iterator，因为它是避免迭代器被修改。
    </p>
    <p>
     <strong>
      方法一：
     </strong>
     需要重新定义一个ListConstIterator的类，且在链表前面定义类型的时候加上const_iterator：
    </p>
    <p>
     对于ListConstIterator类，实际上只有的这里的逻辑和ListIterator不同：
     <strong>
      *it += 10会显示报错了
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/996e501c66f1465d97c281e095cb1df8.png"/>
    </p>
    <p>
     图示：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/583084ff1fd142a2bea8c5d07876911d.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/11adccbe5c1a43bf9865992e889e8191.png"/>
    </p>
    <h4>
     <strong>
      方法二：方法一使代码冗余，我们需要学习一种方法能够解决这个问题。
     </strong>
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/66a8cb8c5913484d93cffc9a7dab56dc.png"/>
    </p>
    <p>
     而我们知道，凡是类型不同就可以用模版来解决
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/625f1900a2f24de5a3f4b6d804283b17.png"/>
    </p>
    <p>
     Ref--&gt;reference,引用  Ptr --&gt;Pointer
    </p>
    <p>
     <strong>
      如图：本质相当于我们写了一个类模版，编译器实例化生成了两个类
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/599e23ca6415417ab7abfcfeb85f4bb2.png"/>
    </p>
    <p>
     最后达到目的。
    </p>
    <p>
    </p>
    <h2>
     完整代码：
    </h2>
    <pre><code class="language-cpp">#pragma once
#include&lt;assert.h&gt;
#include&lt;iostream&gt;
//#include&lt;vector&gt;
//#include&lt;list&gt;
#include&lt;algorithm&gt;

using namespace std;
namespace bit
{

	template&lt;class T&gt;

	//注意一下这里用的struct，数据想要全部公有的时候用struct
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;
		ListNode&lt;T&gt;* _prev;
		T _data;
		ListNode(const T&amp; x = T())
			:_next(nullptr),
			_prev(nullptr),
			_data(x)
		{}
	private:
		
	};


	//普通迭代器
	template&lt;class T ,class Ref , class Ptr&gt;
	struct ListIterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef ListIterator&lt;T, Ref, Ptr&gt; Self;

		Node* _node;

		//从本源来说迭代器还是一个节点的指针
		ListIterator(Node* node)
			:_node(node)
		{}

		//我们最想实现的是对于指针的++，即运算符的重载：
		//1.++it
		Self&amp; operator++()
		{
			//++是怎么+到下一个节点的，即交换值
			_node = _node-&gt;_next;
			return *this;
		}
		//2.it++
		Self operator++(int)
		{
			//1.调用拷贝构造，这里是一个浅拷贝，把一个迭代器给另外一个迭代器，it1,it2都指向一个节点
			Self tmp(*this);

			_node = _node-&gt;_next;
			//2.迭代器是否需要写析构？不需要，因为资源是属于链表的
			return tmp;
		}
		//1. --it
		Self&amp; operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}
		//2. it--
		Self operator--(int)
		{
			Self tmp(*this);
			_node = _node-&gt;_prev;
			return tmp;
		}

		//解引用：*it  返回的是_data
		//T&amp; operator*()
		Ref operator*()
		{
			return _node-&gt;_data;
		}


		//it-&gt;
		//T* operator-&gt;()
		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;//返回的是_data的地址
		}

		//两个迭代器是否相等？
		bool operator!=(const Self&amp; it)
		{
			//即比较节点的指针，节点的指针相同，他们就相同
			return _node != it._node;
		}

		bool operator==(const Self&amp; it)
		{
			return _node == it._node;
		}

		//比较大小是否需要重载？不需要，一个类是否要重载一个运算符，需要看他是否有意义
		//节点后面的地址不能保证比前面的地址大，所以没什么意义。不需要重载
		//迭代器的重点：指针，用类似指针的方式来访问容器

		//begin()和end()谁能提供，链表

	};



	//迭代器
	//template&lt;class T&gt;
	//struct ListConstIterator
	//{
	//	typedef ListNode&lt;T&gt; Node;
	//	typedef ListConstIterator&lt;T&gt; Self;

	//	Node* _node;

	//	//从本源来说迭代器还是一个节点的指针
	//	ListConstIterator(Node* node)
	//		:_node(node)
	//	{
	//	}

	//	//我们最想实现的是对于指针的++，即运算符的重载：
	//	//1.++it
	//	Self&amp; operator++()
	//	{
	//		//++是怎么+到下一个节点的，即交换值
	//		_node = _node-&gt;_next;
	//		return *this;
	//	}
	//	//2.it++
	//	Self operator++(int)
	//	{
	//		//1.调用拷贝构造，这里是一个浅拷贝，把一个迭代器给另外一个迭代器，it1,it2都指向一个节点
	//		Self tmp(*this);

	//		_node = _node-&gt;_next;
	//		//2.迭代器是否需要写析构？不需要，因为资源是属于链表的
	//		return tmp;
	//	}
	//	//1. --it
	//	Self&amp; operator--()
	//	{
	//		_node = _node-&gt;_prev;
	//		return *this;
	//	}
	//	//2. it--
	//	Self operator--(int)
	//	{
	//		Self tmp(*this);
	//		_node = _node-&gt;_prev;
	//		return tmp;
	//	}

	//	//如何控制*it不能被修改，即在这里加const
	//	const T&amp; operator*()
	//	{
	//		return _node-&gt;_data;
	//	}


	//	//如何控制it-&gt;不能被修改，即在这里加const 
	//	const T* operator-&gt;()
	//	{
	//		return &amp;_node-&gt;_data;//返回的是_data的地址
	//	}

	//	//两个迭代器是否相等？
	//	bool operator!=(const Self&amp; it)
	//	{
	//		//即比较节点的指针，节点的指针相同，他们就相同
	//		return _node != it._node;
	//	}

	//	bool operator==(const Self&amp; it)
	//	{
	//		return _node == it._node;
	//	}

	//	//比较大小是否需要重载？不需要，一个类是否要重载一个运算符，需要看他是否有意义
	//	//节点后面的地址不能保证比前面的地址大，所以没什么意义。不需要重载
	//	//迭代器的重点：指针，用类似指针的方式来访问容器

	//	//begin()和end()谁能提供，链表

	//};



	template&lt;class T&gt;
	class list 
	{
		typedef ListNode&lt;T&gt; Node;

	public:
		//在这里定义好类型
		//typedef ListIterator&lt;T&gt; iterator;
		//typedef ListConstIterator&lt;T&gt; const_iterator;
		typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;
		typedef ListIterator&lt;T,const T&amp;,const T*&gt; const_iterator;


		void empty_init()
		{
			//创建空链表
			_head = new Node;
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;

			_size = 0;
		}

		//构造函数  
		list()
		{
			empty_init();
		}

		//清除掉所有数据，有没有清除掉头结点？并没有（在析构函数中清除）
		void clear()
		{
			iterator it = begin();
			while (it != end())
			{
				it = erase(it);
			}
		}
		//析构函数
		~list()
		{
			clear();
			delete _head;
			_head = nullptr;
		}

		//lt2(lt1)
		//拷贝构造,默认拷贝构造是浅拷贝，所以需要我们自己实现一个
		list(const list&lt;T&gt;&amp; lt)
		{
			//首先：在这里我们先创建空链表
			//也就是：lt2.empty_init()直接给lt2创建一个空链表
			empty_init();
			//直接遍历一遍lt1，尾插
			for (auto&amp; e : lt)//这里一定要加引用，因为如果T是string，就浅拷贝了
			{
				push_back(e);
			}
		}
		void swap(list&lt;T&gt;&amp; lt)
		{
			std::swap(_head, lt._head);
			std::swap(_size, lt._size);
		}

		//赋值,按值传递
		//lt1 = lt3
		list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt) //lt  = lt3;
		{
			swap(lt);
			return *this;
		}

		//迭代器
		//1.原生指针能不能充当迭代器？不可以，这是建立在物理空间连续的情况下（画图解释）
		//2.++Node*能不能加到下一个节点，节点的解引用能取到当前节点的数据吗？不能
		//并且新new出来的地址和原来的地址也不会相同，头插和中间插入怎么保证在物理空间连续？从功能上未解决
		//因此我们在此重新封装一个类(内嵌类、typedef(在类域))，想一想日期类，可以日期相加，做各种操作的是合理的,使用封装的类
		//来重载运算符，重载运算符后我就可以自定义这些运算符的行为

		//普通版本
		iterator begin() 
		{
			// 1.有名对象
			//iterator it(_head-&gt;_next);
			//return it;
			// 2.隐式类型转换(单参数的构造函数支持隐式类型的转换)：
			//return _head-&gt;_next;
			// 3.匿名对象
			return iterator(_head-&gt;_next);
		}
		//end()是最后一个数据的下一个位置
		iterator end() 
		{
			return iterator(_head);
		}

		 //const版本
		const_iterator begin() const
		{
			// 1.有名对象
			//iterator it(_head-&gt;_next);
			//return it;
			// 2.隐式类型转换(单参数的构造函数支持隐式类型的转换)：
			//return _head-&gt;_next;
			// 3.匿名对象
			return const_iterator(_head-&gt;_next);
		}

		//end()是最后一个数据的下一个位置
		const_iterator end() const
		{
			return const_iterator(_head);
		}


		//注意这里我们都应该通过begin()、end()控制迭代器而不是控制节点了
		//尾插
		void push_back(const T&amp; x)
		{
			//1.还未写insert()时写的push_back()
			//Node* newnode = new Node(x);

			//Node* tail = _head-&gt;_prev; //指定被插的节点

			//tail-&gt;_next = newnode;
			//newnode-&gt;_prev = tail;
			//newnode-&gt;_next = _head;
			//_head-&gt;_prev = newnode;

			//2.写了insert()后写的push_back()
			insert(end(), x);
		}
		//头插
		void push_front(const T&amp; x)
		{
			insert(begin(), x);
		}

		//尾删  ，要--,不然删的是head(哨兵位)
		void pop_back()
		{
			erase(--end());  
		}
		//头删
		void pop_front()
		{
			erase(begin());
		}

		//在pos位置插入data
		void insert(iterator pos, const T&amp; data)
		{
			Node* current = pos._node; 
			Node* newnode = new Node(data);
			Node* prev = current-&gt;_prev;

			//prev newnode current 
			
			prev-&gt;_next = newnode;
			newnode-&gt;_prev = prev;
			newnode-&gt;_next = current;
			current-&gt;_prev = newnode;

			++_size;
		}
		//删除pos位置

		iterator erase(iterator pos) //请注意这里的pos位置迭代器会失效，为什么？可以看我的上篇vector中目录的更新erase()
		{
			//拿到当前位置
			Node* cur = pos._node;
			Node* prev = cur-&gt;_prev;
			Node* next = cur-&gt;_next;

			//prev cur next
			
			prev-&gt;_next = next;
			next-&gt;_prev = prev;
			delete cur;
			--_size;

			return iterator(next);//解决办法就是返回下一个位置的迭代器
		}


		size_t size() const
		{
			库里面:1. 遍历一遍计数
			//for ()
			//{

			//}
			//2. 我们通过构造函数来初始化,给insert、erase加上_size便于计数
			return _size;
		}

		bool empty()
		{
			return _size == 0;
		}
		
		//resize()不常用，我们这里不做模拟，没有扩容的概念，比我当前的_size大就尾插入，比当前的_size小就尾删

	private:
		Node* _head;
		size_t _size;
	};

	void test_list1()
	{
		list&lt;int&gt; lt;
		lt.push_back(1);
		lt.push_back(2);
		lt.push_back(3);
		lt.push_back(4);
		lt.push_back(5);
		//迭代器测试代码
		//这里需要遍历数据，所以要用到迭代器，于是现在我们写迭代器代码：
		list&lt;int&gt;::iterator it = lt.begin();
		cout &lt;&lt; *it &lt;&lt; endl;
		while (it != lt.end())
		{
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		lt.push_front(10);
		lt.push_front(20);
		lt.push_front(30);
		for (auto e : lt)
		{
			cout &lt;&lt; e &lt;&lt; " ";

		}
		cout &lt;&lt; endl;
		lt.pop_back();
		lt.pop_front();
		for (auto e : lt)
		{
			cout &lt;&lt; e &lt;&lt; " ";

		}
		cout &lt;&lt; endl;
	}

	//迭代器进一步优化
	struct A
	{
		int _a1;
		int _a2;

		A(int a1 = 0, int a2 = 0)
			:_a1(a1)
			,_a2(a2)
		{

		}
	};
	void test_list2()
	{
		list&lt;A&gt; lt;
		//如果这里有自定义类型A
		A aa1(1, 5);
		A aa2 = { 1,1 };
		lt.push_back(aa1);
		lt.push_back(A(2, 3));
		lt.push_back({ 4,5 });
		lt.push_back(aa2);

		list&lt;A&gt;::iterator it = lt.begin();
		while (it != lt.end())
		{
			cout &lt;&lt; it-&gt;_a1 &lt;&lt; ":" &lt;&lt; it-&gt;_a2 &lt;&lt; endl;
			++it;
		}

	}  

	void PrintList(const list&lt;int&gt;&amp; clt)
	{

		list&lt;int&gt;::const_iterator it = clt.begin();
		while (it != clt.end())
		{
			//*it += 10;
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
	}

	void test_list3()
	{
		list&lt;int&gt; lt1;
		lt1.push_back(1);
		lt1.push_back(2);
		lt1.push_back(3);
		lt1.push_back(4);
		lt1.push_back(5);
		PrintList(lt1);
		cout &lt;&lt; endl;

		//拷贝构造
		list&lt;int&gt; lt2(lt1);
		PrintList(lt2);
		cout &lt;&lt; endl;

		list&lt;int&gt; lt3 = lt1;
		PrintList(lt3);

	}



}</code></pre>
    <p>
    </p>
    <blockquote>
     <p>
      结语：
     </p>
     <p>
      随着这篇关于题目解析的博客接近尾声，我衷心希望我所分享的内容能为你带来一些启发和帮助。学习和理解的过程往往充满挑战，但正是这些挑战让我们不断成长和进步。我在准备这篇文章时，也深刻体会到了学习与分享的乐趣。
     </p>
     <p>
     </p>
     <p>
      在此，我要特别感谢每一位阅读到这里的你。是你的关注和支持，给予了我持续写作和分享的动力。我深知，无论我在某个领域有多少见解，都离不开大家的鼓励与指正。因此，如果你在阅读过程中有任何疑问、建议或是发现了文章中的不足之处，都欢迎你慷慨赐教。
     </p>
     <p>
     </p>
     <p>
      你的每一条反馈都是我前进路上的宝贵财富。同时，我也非常期待能够得到你的点赞、收藏，关注，这将是对我莫大的支持和鼓励。当然，我更期待的是能够持续为你带来有价值的内容，让我们在知识的道路上共同前行。
     </p>
    </blockquote>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f37373735363134312f:61727469636c652f64657461696c732f313436303937383033" class_="artid" style="display:none">
 </p>
</div>


