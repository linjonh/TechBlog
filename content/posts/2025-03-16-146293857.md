---
layout: post
title: "刷题记录-贪心-23968.-监控二叉树"
date: 2025-03-16 13:10:54 +0800
description: "代码实现：用哈希表记录信号强度，参照MC的红石电路，设定信号强度为2，每次衰减1不在哈希表内：暗节点值为2：监视器（灯）值为1：亮节点（被照亮）"
keywords: "刷题记录 贪心-23：968. 监控二叉树"
categories: ['刷题笔记']
tags: ['贪心算法', '算法', '笔记', '数据结构', 'Python', 'Leetcode']
artid: "146293857"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293857
    alt: "刷题记录-贪心-23968.-监控二叉树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293857
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293857
cover: https://bing.ee123.net/img/rand?artid=146293857
image: https://bing.ee123.net/img/rand?artid=146293857
img: https://bing.ee123.net/img/rand?artid=146293857
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     刷题记录 贪心-23：968. 监控二叉树
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     题目：
     <span contenteditable="false" tabindex="-1">
      <a href="https://leetcode.cn/problems/binary-tree-cameras/" rel="nofollow noopener noreferrer" target="_blank" title="968. 监控二叉树">
       968. 监控二叉树
      </a>
     </span>
    </p>
    <p>
     难度：困难
    </p>
    <p>
     给定一个二叉树，我们在树的节点上安装摄像头。
    </p>
    <p>
     节点上的每个摄影头都可以监视
     <strong>
      其父对象、自身及其直接子对象。
     </strong>
    </p>
    <p>
     计算监控树的所有节点所需的最小摄像头数量。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="163" src="https://i-blog.csdnimg.cn/img_convert/b9b280a99d44efe30326fb945d893468.png" width="138"/>
    </p>
    <pre><strong>输入：</strong>[0,0,null,0,0]
<strong>输出：</strong>1
<strong>解释：</strong>如图所示，一台摄像头足以监控所有节点。
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="312" src="https://i-blog.csdnimg.cn/img_convert/fd888cd1e435d5ff9309379f65ec7e29.png" width="139"/>
    </p>
    <pre><strong>输入：</strong>[0,0,null,0,null,0,null,null,0]
<strong>输出：</strong>2
<strong>解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
</pre>
    <p>
     <br/>
     <strong>
      提示：
     </strong>
    </p>
    <ol>
     <li>
      给定树的节点数的范围是
      <code>
       [1, 1000]
      </code>
      。
     </li>
     <li>
      每个节点的值都是 0。
     </li>
    </ol>
    <h2>
     一、模式识别
    </h2>
    <h3>
     1.二叉树
    </h3>
    <p>
     二叉树类的题目的第一问题就是确定遍历顺序：这是极其重要的一点
    </p>
    <p>
     检视节点 》 能同时考虑到左右孩子 》 后序
    </p>
    <h3>
     2.贪心
    </h3>
    <p>
     <strong>
      （1）定义三个状态： 暗节点， 监视器（灯），亮节点（被照亮）
     </strong>
    </p>
    <p>
     代码实现：用哈希表记录信号强度，参照MC的红石电路，设定信号强度为2，每次衰减1
    </p>
    <p>
     不在哈希表内：暗节点
    </p>
    <p>
     值为2：监视器（灯）
    </p>
    <p>
     值为1：亮节点（被照亮）
    </p>
    <p>
     <strong>
      （2）如何放监视器并维护哈希表
     </strong>
    </p>
    <p>
     ①判断是否放置监视器的条件：有暗孩子（有孩子，且至少有一个暗节点孩子）
    </p>
    <p>
     ②如果有孩子是监视器，则设定本节点为亮节点
    </p>
    <p>
     <strong>
      （3）贪心算法可能无法照顾到根节点
     </strong>
    </p>
    <p>
     容易忽略的是这个方法容易把根节点略过根节点，
    </p>
    <p>
     这个需要在代码最后打个补丁
    </p>
    <h2>
     二、代码实现
    </h2>
    <p>
     统一迭代法骨架 + 贪心判断：
    </p>
    <pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -&gt; int:
        if not root.left and not root.right: return 1
        ans = 0
        stk = [root]
        cache = {}
        while stk:
            node = stk.pop()
            if node:
                stk.append(node)
                stk.append(None)
                if node.right: stk.append(node.right)
                if node.left: stk.append(node.left)
            else:
                node = stk.pop()
                if (node.left and node.left not in cache) or (node.right and node.right not in cache):
                    cache[node] = 2
                    ans += 1
                elif (node.left and cache[node.left] == 2) or (node.right and cache[node.right] == 2):
                    cache[node] = 1
        if root not in cache: ans += 1
        return ans</code></pre>
    <p>
     指针迭代法骨架 + 贪心判断：
    </p>
    <pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -&gt; int:
        if not root.left and not root.right: return 1
        stk, node, prev = [], root, None
        cache = {}
        ans = 0
        while stk or node:
            while node:
                stk.append(node)
                node = node.left
            node = stk.pop()
            if not node.right or node.right == prev:
                if (node.left and node.left not in cache) or (node.right and node.right not in cache):
                    cache[node] = 2
                    ans += 1
                elif (node.left and cache[node.left] == 2) or (node.right and cache[node.right] == 2):
                    cache[node] = 1
                prev = node
                node = None
            else:
                stk.append(node)
                node = node.right
        if root not in cache: ans += 1
        return ans</code></pre>
    <p>
     递归：略，本题需要最后对根节点打补丁，用递归需要辅助函数，写起来比较繁琐
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343631303638342f:61727469636c652f64657461696c732f313436323933383537" class_="artid" style="display:none">
 </p>
</div>


