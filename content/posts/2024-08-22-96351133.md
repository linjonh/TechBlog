---
layout: post
title: "关于红黑树R-B-tree原理,看这篇如何"
date: 2024-08-22 18:25:36 +0800
description: "本文主要介绍了红黑树的相关原理，首先红黑树的基础二叉搜索树，我们先简单说了一下二叉搜索树，并且讲了一"
keywords: "关于红黑树(R-B tree)原理，看这篇如何"
categories: ['算法和数据结构']
tags: ['红黑树', '数据结构', '二叉树']
artid: "96351133"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=96351133
    alt: "关于红黑树R-B-tree原理,看这篇如何"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=96351133
featuredImagePreview: https://bing.ee123.net/img/rand?artid=96351133
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     关于红黑树(R-B tree)原理，看这篇如何
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     学过数据数据结构都知道二叉树的概念，而又有多种比较常见的二叉树类型，比如完全二叉树、满二叉树、二叉搜索树、均衡二叉树、完美二叉树等；今天我们要说的红黑树就是就是一颗非严格均衡的二叉树，均衡二叉树又是在二叉搜索树的基础上增加了自动维持平衡的性质，插入、搜索、删除的效率都比较高。红黑树也是实现TreeMap存储结构的基石。
    </p>
    <h3>
     <a id="__4">
     </a>
     一. 二叉搜索树
    </h3>
    <p>
     二叉搜索树又叫二叉查找树、二叉排序树，我们先看一下典型的二叉搜索树，这样的二叉树有何规则特点呢？
    </p>
    <blockquote>
     <ol>
      <li>
       节点的左子树小于节点本身；
      </li>
      <li>
       节点的右子树大于节点本身；
      </li>
      <li>
       左右子树同样为二叉搜索树；
      </li>
     </ol>
    </blockquote>
    <p>
     下图就是一颗典型的二叉搜索树
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/57fcdfa44321fbcd075b7783058547af.png"/>
    </p>
    <p>
     二叉搜索树是均衡二叉树的基础，我们看一下它的搜索步骤如何
    </p>
    <p>
     我们要从二叉树中找到值为
     <strong>
      58
     </strong>
     的节点
    </p>
    <p>
     <strong>
      第一步：首先查找到根节点，值为60的节点
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/8c567c17322eb698ed4575ad01b126d9.png"/>
    </p>
    <p>
     <strong>
      第二步：比较我们要找的值58与该节点的大小
     </strong>
    </p>
    <p>
     如果等于，那么恭喜，已经找到；
    </p>
    <p>
     如果小于，继续找左子树；
    </p>
    <p>
     如果大于，那么找右子树；
    </p>
    <p>
     很明显58 &lt; 60，因此我们找到左子树的节点 56，此时我们已经定位到了节点56
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/edd309089d0754b9a6db86dc40b271bf.png"/>
    </p>
    <p>
     <strong>
      第三步：按照第二步的规则继续找
     </strong>
    </p>
    <p>
     58 &gt; 56 我们需要继续找右子树，定位到了右子树节点58，恭喜，此时我们已经找到了。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/7eeeadd6d3e2ca1319cf39f4c088d18a.png"/>
    </p>
    <p>
     我们经过三步就已经找到了，其实就是我们平时所说的二分查找，这种二叉搜索树好像查找效率很高，但同样它也有缺陷，如下面这样的二叉搜索树。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/a1c600b19b4cb144277d8ee754458d4a.png"/>
    </p>
    <p>
     看到这样的二叉搜索树是否很别扭，典型的大长腿瘸子，但它也是二叉搜索树，如果我们要找值为50的节点，基本上和单链表查询没多大区别了，性能将大打折扣。这个时候我们的均衡二叉树就粉墨登场了，均衡二叉树就是在二叉搜索树的基础上添加了自动维持平衡的性质。
    </p>
    <p>
     上面的大长腿瘸子二叉搜索树经过自动平衡后，可能就成为了下面这样的二叉树。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/33d332ffaa6737b0e5a4393ce8670e14.png"/>
    </p>
    <p>
     经过了自动平衡，再去找值为50的节点，查找性能将提升很多。红黑树就是非严格均衡的二叉搜索树。
    </p>
    <h3>
     <a id="__72">
     </a>
     二. 红黑树规则特点
    </h3>
    <p>
     红黑树具体有哪些规则特点呢？
    </p>
    <blockquote>
     <ol>
      <li>
       节点分为红色或者黑色；
      </li>
      <li>
       根节点必为黑色；
      </li>
      <li>
       叶子节点都为黑色，且为null；
      </li>
      <li>
       连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；
      </li>
      <li>
       从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；
      </li>
      <li>
       新加入到红黑树的节点为红色节点；
      </li>
     </ol>
    </blockquote>
    <p>
     规则看着好像挺多，没错，因为红黑树也是均衡二叉树，需要具备自动维持平衡的性质，上面的6条就是红黑树给出的自动维持平衡所需要具备的规则
    </p>
    <p>
     我们看一看一个典型的红黑树到底是什么样儿？
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/a8aa6964fe44274a9f9f81c2ed0e9899.png"/>
    </p>
    <p>
     首先解读一下规则，除了字面上看到的意思，还隐藏了哪些意思呢？
    </p>
    <p>
     <strong>
      第一. 从根节点到叶子节点的最长路径不大于最短路径的2倍
     </strong>
    </p>
    <p>
     <strong>
      怎么样的路径算最短路径？
     </strong>
    </p>
    <p>
     从规则5中，我们知道从根节点到每个叶子节点的黑色节点数量是一样的，那么纯由黑色节点组成的路径就是最短路径；
    </p>
    <p>
     <strong>
      什么样的路径算是最长路径？
     </strong>
    </p>
    <p>
     根据规则4和规则3，若有红色节点，则必然有一个连接的黑色节点，当红色节点和黑色节点数量相同时，就是最长路径，也就是黑色节点（或红色节点）* 2
    </p>
    <p>
     <strong>
      第二. 为什么说新加入到红黑树中的节点为红色节点
     </strong>
    </p>
    <p>
     从规则4中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些，下面我们也会举例来说明。
    </p>
    <p>
     什么情况下，红黑树的结构会被破坏呢？破坏后又怎么维持平衡，维持平衡主要通过两种方式【
     <strong>
      变色
     </strong>
     】和【
     <strong>
      旋转
     </strong>
     】，【
     <strong>
      旋转
     </strong>
     】又分【
     <strong>
      左旋
     </strong>
     】和【
     <strong>
      右旋
     </strong>
     】，两种方式可相互结合。
    </p>
    <p>
     下面我们从插入和删除两种场景来举例说明
    </p>
    <h3>
     <a id="__118">
     </a>
     三. 红黑树节点插入
    </h3>
    <p>
     当我们插入值为66的节点时，红黑树变成了这样
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/46efa4899da3588f149934bc1ab3c2d4.png"/>
    </p>
    <p>
     很明显，这个时候结构依然遵循着上述6大规则，无需启动自动平衡机制调整节点平衡状态；
    </p>
    <p>
     如果再向里面插入值为51的节点呢，这个时候红黑树变成了这样
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/04f265fcf9e8d6cdea01bd6ce2ff0462.png"/>
    </p>
    <p>
     很明显现在的结构不遵循规则 4 了，这个时候就需要启动自动平衡机制调整节点平衡状态
    </p>
    <h4>
     <a id="31__134">
     </a>
     3.1 变色
    </h4>
    <p>
     我们可以通过变色的方式，使结构满足红黑树的规则
    </p>
    <ul>
     <li>
      首先解决结构不遵循规则 4 这一点（红色节点相连，节点49-51），需将节点49改为黑色；
     </li>
     <li>
      此时我们发现又违反了规则5（56-49-51-XX路径中黑色节点超过了其他路径），那么我们将节点45改为红色节点；
     </li>
     <li>
      哈哈，妹的，又违反了规则4（红色节点相连，节点56-45-43），那么我们将节点56和节点43改为黑色节点；
     </li>
     <li>
      但是我们发现此时又违反了规则5（60-56-XX路径的黑色节点比60-68-XX的黑色节点多），因此我们需要调整节点68为黑色；
     </li>
     <li>
      完成！！
     </li>
    </ul>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/4cb6f64a01dab4e21e466e8169de1eeb.png"/>
    </p>
    <p>
     最终调整完成后的树为：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/84aedc041800b76d6a9677f1a0153a36.png"/>
    </p>
    <p>
     但并不是什么时候都那么幸运，可以直接通过变色就达成目的，大多数时候还需要通过旋转来解决。
    </p>
    <p>
     如在下面这棵树的基础上，加入节点65.
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/a52ce9f6c73623d680edfe71162bfe5f.png"/>
    </p>
    <p>
     插入节点65后进行以下步骤
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b079362c5a8a0b04f77e6971a951d128.png"/>
    </p>
    <p>
     这个时候，你会发现对于节点64无论是红色节点还是黑色节点，都会违反规则5，路径中的黑色节点始终无法达成一致，这个时候仅通过【变色】已经无法达成目的。我们需要通过旋转操作，当然【旋转】操作一般还需要搭配【变色】操作。
    </p>
    <p>
     旋转包括【
     <strong>
      左旋
     </strong>
     】和【
     <strong>
      右旋
     </strong>
     】，
    </p>
    <h6>
     <a id="_176">
     </a>
     左旋：
    </h6>
    <p>
     逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点
    </p>
    <p>
     <strong>
      左旋操作步骤如下：
     </strong>
    </p>
    <p>
     首先断开节点PL与右子节点G的关系，同时将其右子节点的引用指向节点C2；然后断开节点G与左子节点C2的关系，同时将G的左子节点的应用指向节点PL
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/bd68e7938697af12e9f37beaf4937d16.png"/>
    </p>
    <h6>
     <a id="_187">
     </a>
     右旋：
    </h6>
    <p>
     顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点
    </p>
    <p>
     <strong>
      右旋操作步骤如下：
     </strong>
    </p>
    <p>
     首先断开节点G与左子节点PL的关系，同时将其左子节点的引用指向节点C2；然后断开节点PL与右子节点C2的关系，同时将PL的右子节点的应用指向节点G
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/ffdf83ebd425bff21fd667d69fff8e48.png"/>
    </p>
    <p>
     <strong>
      无法通过变色而进行旋转的场景分为以下四种：
     </strong>
    </p>
    <h4>
     <a id="32__202">
     </a>
     3.2 左左节点旋转
    </h4>
    <p>
     这种情况下，父节点和插入的节点都是左节点，如下图(
     <strong>
      旋转原始图1
     </strong>
     )这种情况下，我们要插入节点65
    </p>
    <p>
     规则如下：
     <strong>
      以祖父节点【右旋】，搭配【变色】
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/8e890cf99ef506667abdffcf5177c428.png"/>
    </p>
    <p>
     按照规则，步骤如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/db5e29b2378428b3383f6aeb500d387b.png"/>
    </p>
    <h4>
     <a id="33__220">
     </a>
     3.3 左右节点旋转
    </h4>
    <p>
     这种情况下，父节点是左节点，插入的节点是右节点，在旋转原始图1中，我们要插入节点67
    </p>
    <p>
     规则如下：
     <strong>
      先父节点【左旋】，然后祖父节点【右旋】，搭配【变色】
     </strong>
    </p>
    <p>
     按照规则，步骤如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/809fa323c98a18545473ce8b3ad14328.png"/>
    </p>
    <h4>
     <a id="34__235">
     </a>
     3.4 右左节点旋转
    </h4>
    <p>
     这种情况下，父节点是右节点，插入的节点是左节点，如下图(
     <strong>
      旋转原始图2
     </strong>
     )这种情况，我们要插入节点68
    </p>
    <p>
     规则如下：
     <strong>
      先父节点【右旋】，然后祖父节点【左旋】，搭配【变色】
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/60291bcc5f2e6a2bd04b330dc8cd3ddb.png"/>
    </p>
    <p>
     按照规则，步骤如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/d0e6a80e6c267a86d55e86484f379d56.png"/>
    </p>
    <h4>
     <a id="35__253">
     </a>
     3.5 右右节点旋转
    </h4>
    <p>
     这种情况下，父节点和插入的节点都是右节点，在旋转原始图2中，我们要插入节点70
    </p>
    <p>
     规则如下：
     <strong>
      以祖父节点【左旋】，搭配【变色】
     </strong>
    </p>
    <p>
     按照规则，步骤如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/7866c624f8a1604db6d559d56072692e.png"/>
    </p>
    <h4>
     <a id="36__266">
     </a>
     3.6 红黑树插入总结
    </h4>
    <table>
     <thead>
      <tr>
       <th>
       </th>
       <th>
        无需调整
       </th>
       <th>
        【变色】即可实现平衡
       </th>
       <th>
        【旋转+变色】才可实现平衡
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        情况1：
       </td>
       <td>
        当父节点为黑色时插入子节点
       </td>
       <td>
        空树插入根节点，将根节点红色变为黑色
       </td>
       <td>
        父节点为红色左节点，叔父节点为黑色，插入左子节点，那么通过【左左节点旋转】
       </td>
      </tr>
      <tr>
       <td>
        情况2：
       </td>
       <td>
        -
       </td>
       <td>
        父节点和叔父节点都为红色
       </td>
       <td>
        父节点为红色左节点，叔父节点为黑色，插入右子节点，那么通过【左右节点旋转】
       </td>
      </tr>
      <tr>
       <td>
        情况3：
       </td>
       <td>
        -
       </td>
       <td>
        -
       </td>
       <td>
        父节点为红色右节点，叔父节点为黑色，插入左子节点，那么通过【右左节点旋转】
       </td>
      </tr>
      <tr>
       <td>
        情况4：
       </td>
       <td>
        -
       </td>
       <td>
        -
       </td>
       <td>
        父节点为红色右节点，叔父节点为黑色，插入右子节点，那么通过【右右节点旋转】
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="__277">
     </a>
     四. 红黑树节点删除
    </h3>
    <p>
     相比较于红黑树的节点插入，删除节点更为复杂，我们从子节点是否为null和红色为思考维度来讨论。
    </p>
    <h4>
     <a id="41_null_281">
     </a>
     4.1 子节点至少有一个为null
    </h4>
    <p>
     当待删除的节点的子节点至少有一个为null节点时，删除了该节点后，将其有值的节点取代当前节点即可，若都为null，则将当前节点设置为null，当然如果违反规则了，则按需调整，如【变色】以及【旋转】。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/130e3e69852cd3ccae51e7f9d13bcb57.png"/>
    </p>
    <h4>
     <a id="42_null_290">
     </a>
     4.2 子节点都是非null节点
    </h4>
    <p>
     这种情况下，
    </p>
    <p>
     <strong>
      第一步：找到该节点的前驱或者后继
     </strong>
    </p>
    <p>
     前驱：
     <strong>
      左子树中值最大的节点
     </strong>
     （可得出其最多只有一个非null子节点，可能都为null）；
    </p>
    <p>
     后继：
     <strong>
      右子树中值最小的节点
     </strong>
     （可得出其最多只有一个非null子节点，可能都为null）；
    </p>
    <p>
     前驱和后继都是值最接近该节点值的节点，类似于该节点.prev = 前驱，该节点.next = 后继。
    </p>
    <p>
     <strong>
      第二步：将前驱或者后继的值复制到该节点中，然后删掉前驱或者后继
     </strong>
    </p>
    <p>
     如果删除的是左节点，则将前驱的值复制到该节点中，然后删除前驱；如果删除的是右节点，则将后继的值复制到该节点中，然后删除后继；
    </p>
    <p>
     这相当于是一种“取巧”的方法，我们删除节点的目的是使该节点的值在红黑树上不存在，因此专注于该目的，我们并不关注删除节点时是否真是我们想删除的那个节点，同时我们也不需考虑树结构的变化，因为树的结构本身就会因为自动平衡机制而经常进行调整。
    </p>
    <p>
     前面我们已经说了，我们要删除的实际上是前驱或者后继，因此我们就以前驱为主线来讲解，后继的学习可参考前驱，包括几种情况
    </p>
    <h5>
     <a id="421_null_310">
     </a>
     4.2.1 前驱为黑色节点，并且有一个非null子节点
    </h5>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/d3c9fed320b4b569d49bdefa05e76c77.png"/>
    </p>
    <p>
     分析：
    </p>
    <p>
     因为要删除的是左节点64，
     <strong>
      找到
     </strong>
     该节点的前驱63；
    </p>
    <p>
     然后用前驱的值63
     <strong>
      替换
     </strong>
     待删除节点的值64，此时两个节点（待删除节点和前驱）的值都为63；
    </p>
    <p>
     <strong>
      删除
     </strong>
     前驱63，此时成为上图过程中间环节，但我们发现其不符合红黑树规则4，因此需要进行自动平衡调整；
    </p>
    <p>
     这里直接通过【
     <strong>
      变色
     </strong>
     】即可完成。
    </p>
    <h5>
     <a id="422_null_327">
     </a>
     4.2.2 前驱为黑色节点，同时子节点都为null
    </h5>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/64e269ec8471aac8f252371d44c2d2da.png"/>
    </p>
    <p>
     分析：
    </p>
    <p>
     因为要删除的是左节点64，
     <strong>
      找到
     </strong>
     该节点的前驱63；
    </p>
    <p>
     然后用前驱的值63
     <strong>
      替换
     </strong>
     待删除节点的值64，此时两个节点（待删除节点和前驱）的值都为63；
    </p>
    <p>
     <strong>
      删除
     </strong>
     前驱63，此时成为上图过程中间环节，但我们发现其不符合红黑树规则5，因此需要进行自动平衡调整；
    </p>
    <p>
     这里直接通过【
     <strong>
      变色
     </strong>
     】即可完成。
    </p>
    <h5>
     <a id="423_null_344">
     </a>
     4.2.3 前驱为红色节点，同时子节点都为null
    </h5>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/5bf3f5885e93b8778796555f3f90ea4b.png"/>
    </p>
    <p>
     分析：
    </p>
    <p>
     因为要删除的是左节点64，
     <strong>
      找到
     </strong>
     该节点的前驱63；
    </p>
    <p>
     然后用前驱的值63
     <strong>
      替换
     </strong>
     待删除节点的值64，此时两个节点（待删除节点和前驱）的值都为63；
    </p>
    <p>
     <strong>
      删除
     </strong>
     前驱63，树的结构并没有打破规则。
    </p>
    <h4>
     <a id="43__359">
     </a>
     4.3 红黑树删除总结
    </h4>
    <p>
     红黑树删除的情况比较多，但也就存在以下情况：
    </p>
    <p>
     删除的是根节点，则直接将根节点置为null;
    </p>
    <p>
     待删除节点的左右子节点都为null，删除时将该节点置为null;
    </p>
    <p>
     待删除节点的左右子节点有一个有值，则用有值的节点替换该节点即可；
    </p>
    <p>
     待删除节点的左右子节点都不为null，则找前驱或者后继，将前驱或者后继的值复制到该节点中，然后删除前驱或者后继；
    </p>
    <p>
     节点删除后可能会造成红黑树的不平衡，这时我们需通过【变色】+【旋转】的方式来调整，使之平衡，上面也给出了例子，建议大家多多练习，而不必背下来。
    </p>
    <h3>
     <a id="__375">
     </a>
     五. 总结
    </h3>
    <p>
     本文主要介绍了红黑树的相关原理，首先红黑树的基础二叉搜索树，我们先简单说了一下二叉搜索树，并且讲了一下搜索的流程，然后就针对红黑树的6大规则特点，红黑树的插入操作，删除操作，都使用了大量的图形来加以说明，技术都是练出来的，有时候很多似是而非的地方，当动笔去写的时候，其实很好理解。红黑树的使用非常广泛，如TreeMap和TreeSet都是基于红黑树实现的，而Jdk8中HashMap当链表长度大于8时也会转化为红黑树，红黑树比较复杂，本人也是还在学习过程中，如果有不对的地方请批评指正，望共同进步谢谢。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f66656e67646f6e6773756978696e:2f61727469636c652f64657461696c732f3936333531313333" class_="artid" style="display:none">
 </p>
</div>


