---
layout: post
title: "C中继承的核心定义"
date: 2025-03-13 22:13:48 +0800
description: "继承‌ 是面向对象编程（OOP）的核心特性之一，允许一个类（称为‌子类/派生类‌）基于另一个类（称为‌父类/基类‌）构建，自动获得父类的成员（字段、属性、方法等），并可通过扩展或修改实现代码复用和多态行为。"
keywords: "C#中继承的核心定义‌"
categories: ['基础从入门到精通', 'C']
tags: ['开发语言', 'Winform', 'Vs', 'C']
artid: "146243578"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146243578
    alt: "C中继承的核心定义"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146243578
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146243578
cover: https://bing.ee123.net/img/rand?artid=146243578
image: https://bing.ee123.net/img/rand?artid=146243578
img: https://bing.ee123.net/img/rand?artid=146243578
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C#中继承的核心定义‌
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="1__0">
     </a>
     1. 继承的核心定义‌
    </h2>
    <p>
     <strong>
      ‌继承‌ 是面向对象编程（OOP）的核心特性之一，允许一个类（称为‌子类/派生类‌）基于另一个类（称为‌父类/基类‌）构建，自动获得父类的成员（字段、属性、方法等），并可通过扩展或修改实现代码复用和多态行为。
     </strong>
    </p>
    <h2>
     <a id="2_C__3">
     </a>
     2. C# 继承的关键特性‌
    </h2>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        说明、
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ‌单继承‌
       </td>
       <td>
        C# 只支持单类继承（一个类只能有一个直接基类）
       </td>
      </tr>
      <tr>
       <td>
        ‌接口多继承‌
       </td>
       <td>
        一个类可实现多个接口（class A : I1, I2, I3）
       </td>
      </tr>
      <tr>
       <td>
        ‌传递性‌
       </td>
       <td>
        继承关系可多层传递（如 A → B → C）
       </td>
      </tr>
      <tr>
       <td>
        ‌隐式继承‌
       </td>
       <td>
        所有类隐式继承 System.Object（除非显式指定其他基类）
       </td>
      </tr>
      <tr>
       <td>
        ‌成员可见性控制‌
       </td>
       <td>
        通过 public、protected、private 等修饰符控制继承成员的访问权限
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="3__12">
     </a>
     ‌3. 继承的语法‌
    </h2>
    <pre><code class="prism language-csharp"><span class="token comment">// 基类定义</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vehicle</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Brand <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Engine started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 派生类继承基类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Vehicle</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> Wheels <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Driving..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="4__30">
     </a>
     ‌4. 继承的核心操作‌
    </h2>
    <p>
     ‌(1) 访问基类成员‌
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
car<span class="token punctuation">.</span>Brand <span class="token operator">=</span> <span class="token string">"Toyota"</span><span class="token punctuation">;</span>  <span class="token comment">// 继承自 Vehicle</span>
car<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 调用基类方法</span>
</code></pre>
    <p>
     ‌(2) 重写方法（虚方法）‌
    </p>
    <pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Animal sound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Animal</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Woof!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     ‌(3) 抽象类与强制实现‌
    </p>
    <pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Shape</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 抽象方法（必须实现）</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Shape</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> Radius <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> Radius <span class="token operator">*</span> Radius<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="5__68">
     </a>
     ‌5. 构造函数与继承‌
    </h2>
    <p>
     ‌(1) 基类构造函数调用‌
    </p>
    <pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseClass</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">BaseClass</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* 初始化逻辑 */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 必须通过 base 调用基类构造函数</span>
    <span class="token keyword">public</span> <span class="token function">DerivedClass</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> name<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Name <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     ‌(2) 默认构造函数行为‌
     <br/>
     <strong>
      若基类‌没有无参构造函数‌，派生类必须显式调用基类的有参构造函数，否则编译错误。
     </strong>
    </p>
    <h2>
     <a id="6__91">
     </a>
     ‌6. 阻止继承‌
    </h2>
    <p>
     使用 sealed 关键字禁止其他类继承：
    </p>
    <pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">FinalClass</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>  <span class="token comment">// 不可被继承</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvalidDerived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">FinalClass</span></span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>  <span class="token comment">// 编译错误</span>
<span class="token preprocessor property"># ‌7. 继承与多态‌</span>
</code></pre>
    <p>
     通过继承实现‌运行时多态性‌：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
animal<span class="token punctuation">.</span><span class="token function">Speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出 "Woof!"（实际调用 Dog 类的方法）</span>
</code></pre>
    <h2>
     <a id="8__vs__109">
     </a>
     ‌8. 继承 vs 接口‌
    </h2>
    <table>
     <thead>
      <tr>
       <th>
        ‌场景‌ ‌
       </th>
       <th>
        类继承‌‌
       </th>
       <th>
        ‌接口实现‌
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        成员类型 ‌
       </td>
       <td>
        可继承字段、方法、属性等具体实现‌
       </td>
       <td>
        仅定义方法/属性签名（无实现）
       </td>
      </tr>
      <tr>
       <td>
        复用代码 ‌
       </td>
       <td>
        直接复用基类逻辑‌
       </td>
       <td>
        需重新实现所有接口成员
       </td>
      </tr>
      <tr>
       <td>
        设计目标 ‌
       </td>
       <td>
        表达 “is-a” 关系（如 Car 是 Vehicle） ‌
       </td>
       <td>
        表达 “can-do” 能力（如 IDisposable）
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="9__116">
     </a>
     ‌9. 最佳实践‌
    </h2>
    <ul>
     <li>
      <p>
       避免深度继承链‌
       <br/>
       超过 3 层的继承关系通常意味着设计问题，优先使用组合（has-a）而非继承（is-a）。
      </p>
     </li>
     <li>
      <p>
       ‌里氏替换原则（LSP）‌
       <br/>
       子类必须能够完全替代基类，不破坏原有逻辑。
      </p>
     </li>
     <li>
      <p>
       ‌开放封闭原则（OCP）‌
       <br/>
       通过继承扩展功能，而非修改基类代码。
      </p>
     </li>
    </ul>
    <h2>
     <a id="10__126">
     </a>
     ‌10. 典型应用场景‌
    </h2>
    <ul>
     <li>
      ‌UI控件框架‌：Button、TextBox 继承自 Control 基类
     </li>
     <li>
      ‌领域模型‌：Employee、Manager 继承自 Person 基类
     </li>
     <li>
      ‌插件系统‌：通过基类定义插件接口，子类实现具体功能
     </li>
    </ul>
    <p>
     <strong>
      通过合理使用继承，可以显著提升代码的可维护性和扩展性，但需谨慎避免过度设计。
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f70755f79755f68756e5f6a696e2f:61727469636c652f64657461696c732f313436323433353738" class_="artid" style="display:none">
 </p>
</div>


