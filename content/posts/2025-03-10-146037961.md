---
layout: post
title: "C模版进阶全知道"
date: 2025-03-10 19:37:54 +0800
description: "我们知道，函数模版是泛型编程的一种思想， 通过函数模版，我们无需再重复实现一些逻辑相似的代码，而是通过函数模版进行复用，通过实例化出不同的类，达到对应的目的。而有些场景对于一些复杂的类型，比如指针，引用等，贸然使用函数模版，可能达不到我们想要的效果，就比如，函数模版就像一个通用的\"工具箱\"，里面有各种工具（通用模板）。但是当你需要处理一个特殊的任务（比如打印字符串时加上引号），你专门准备了一个定制化的工具，这个工具只针对这个特殊任务，效果更好。这就是我们将学习的类特化。"
keywords: "【C++】模版进阶全知道"
categories: ['C']
tags: ['C']
artid: "146037961"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146037961
    alt: "C模版进阶全知道"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146037961
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146037961
cover: https://bing.ee123.net/img/rand?artid=146037961
image: https://bing.ee123.net/img/rand?artid=146037961
img: https://bing.ee123.net/img/rand?artid=146037961
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【C++】模版进阶全知道
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7cce7f2c85f84a90830b242b1736f4ef.jpeg">
      <br/>
      &gt; 🍃 本系列为初阶C++的内容，如果感兴趣，欢迎订阅🚩
     </img>
    </p>
    <p>
     &gt;小编会用最简单最生动的比方，让大家学懂
     <br/>
     &gt; 🎊个人主页:[小编的个人主页])
     <a href="https://blog.csdn.net/2401_83251330?spm=1011.2415.3001.5343" title="小编的个人主页">
      小编的个人主页
     </a>
     <br/>
     &gt;  🎀   🎉欢迎大家点赞👍收藏⭐文章
     <br/>
     &gt; ✌️ 🤞 🤟 🤘 🤙 👈 👉 👆 🖕 👇 ☝️ 👍
    </p>
    <hr/>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%F0%9F%90%BC%E5%89%8D%E8%A8%80%C2%A0" name="%F0%9F%90%BC%E5%89%8D%E8%A8%80%C2%A0">
     🐼前言
    </h2>
    <blockquote>
     <p>
      我们知道，函数模版是
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         泛型编程
        </span>
       </span>
      </strong>
      的一种思想， 通过函数模版，我们无需再重复实现一些逻辑相似的代码，而是通过函数模版进行复用，通过实例化出不同的类，达到对应的目的。而有些场景对于一些复杂的类型，比如指针，引用等，贸然使用函数模版，可能达不到我们想要的效果，就比如，函数模版就像一个通用的
      <strong>
       <span style="color:#ad720d">
        <span style="background-color:#ffd900">
         "工具箱"
        </span>
       </span>
      </strong>
      ，里面有各种工具（通用模板）。但是当你需要处理一个特殊的任务（比如打印字符串时加上引号），你专门准备了一个
      <strong>
       <span style="color:#faa572">
        <span style="background-color:#edf6e8">
         定制化
        </span>
       </span>
      </strong>
      的工具，
      <strong>
       <span style="color:#511b78">
        <span style="background-color:#efedf6">
         这个工具只针对这个特殊任务，效果更好
        </span>
       </span>
      </strong>
      。这就是我们将学习的类特化。
     </p>
    </blockquote>
    <h2 id="%F0%9F%90%BC%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96" name="%F0%9F%90%BC%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96">
     🐼函数模版特化
    </h2>
    <blockquote>
     我们先来看这样一个例子，比如实现一个泛型的比较函数,然后我们来比较内置类型，
     <span style="color:#98c091">
      <strong>
       <span style="background-color:#edf6e8">
        日期类，指针等
       </span>
      </strong>
     </span>
     。
     <pre><code class="language-cpp">template&lt;class T&gt;
bool cmp(T left, T right)
{
	return left &lt; right;
}

class Date
{
	friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}

	bool operator&lt;(const Date&amp; d)const
	{
		return (_year &lt; d._year) ||
			(_year == d._year &amp;&amp; _month &lt; d._month) ||
			(_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day);
	}

	bool operator&gt;(const Date&amp; d)const
	{
		return (_year &gt; d._year) ||
			(_year == d._year &amp;&amp; _month &gt; d._month) ||
			(_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day);
	}

	//private:
	int _year;
	int _month;
	int _day;
};

ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)
{
	_cout &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
	return _cout;
}

int main()
{
	cout &lt;&lt; cmp(1, 2) &lt;&lt; endl;//正确
	Date d1(2025,3,5);
	Date d2(2025,3,1);
	cout &lt;&lt; cmp(d1, d2) &lt;&lt; endl;//正确
	Date* d3 = new Date(2025, 3, 5);
	Date* d4 = new Date(2025, 3, 1);
	cout &lt;&lt; cmp(d3, d4) &lt;&lt; endl;//错误，不确定
	return 0;
}</code></pre>
     <p>
      我们发现，比较一些内置类型以及自定义类型(只要自定义类型重载了自已的比较逻辑)好像都没有什么问题，但是如果参数是Date*的指针，这样再套用com比较就有问题了，因此
      <strong>
       <span style="color:#1c7331">
        <span style="background-color:#edf6e8">
         指针在内存中分配的地址是不确定的
        </span>
       </span>
      </strong>
      ，每次编译时，分配的地址是随机的。我们打印出来的结果也总是不确定的，因此，我们需要专门写一个
      <strong>
       <span style="color:#1c7331">
        <span style="background-color:#edf6e8">
         Date*的比较逻辑基于cmp
        </span>
       </span>
      </strong>
      ，这就是函数的特化。
      <strong>
       <span style="color:#faa572">
        <span style="background-color:#fff5e6">
         这个函数专门用于比较日期类的指针！！!,为他量身定制的。
        </span>
       </span>
      </strong>
     </p>
     <pre><code class="language-cpp">//cmp的函数模版特化
template&lt;&gt;
bool cmp&lt;Date*&gt;(Date* left, Date* right)
{
	return *left &lt; *right;
}
</code></pre>
     <p>
      特化的格式，template&lt;&gt;里面什么都没有，特化的标志，
      <span style="color:#511b78">
       <strong>
        在
       </strong>
      </span>
      <span style="color:#be191c">
       <strong>
        <span style="background-color:#fef2f0">
         函数名
        </span>
       </strong>
      </span>
      <span style="color:#511b78">
       <strong>
        后面跟上你要特化的类型。
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#511b78">
       <strong>
        但是我们
       </strong>
      </span>
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         不常用函数模版的特化
        </span>
       </span>
      </strong>
      <span style="color:#511b78">
       <strong>
        ，因为我们完全可以再重载一个比较逻辑，不需要特化:
       </strong>
      </span>
     </p>
     <pre><code class="language-cpp">bool cmp(Date* left, Date* right)
{
	return *left &lt; *right;
}</code></pre>
     <p>
     </p>
    </blockquote>
    <h2 id="%F0%9F%90%BC%E7%B1%BB%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96" name="%F0%9F%90%BC%E7%B1%BB%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96">
     🐼类模版特化
    </h2>
    <blockquote>
     <p>
      类模版特化又分别，
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         全特化和偏特化
        </span>
       </span>
      </strong>
     </p>
     <p>
      全特化简单理解就是
      <strong>
       <span style="color:#79c6cd">
        <span style="background-color:#e7fafa">
         所有参数都确定化
        </span>
       </span>
      </strong>
      ，已经确定了:
     </p>
     <p>
      比如:
     </p>
     <pre><code class="language-cpp">
template&lt;class T1,class T2&gt;
class car
{
public:
	car() { cout &lt;&lt; "car&lt;T1, T2&gt;" &lt;&lt; endl; }

private:
	T1 _d1;
	T2 _d2;
};

//全特化
template&lt;&gt;
class car&lt;string,int&gt;
{
public:
		car() { cout &lt;&lt; "car&lt;string,int&gt;" &lt;&lt; endl; }

private:
	string _d1;
	int _d2;
};</code></pre>
     <p>
      两个模版参数特化时都确定了。（
      <strong>
       <span style="color:#511b78">
        <span style="background-color:#efedf6">
         相当于给一个人定制化的完完全全
        </span>
       </span>
      </strong>
      ）
     </p>
     <p>
      <br/>
      偏特化是
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         模版参数一部分特化或者是针对模版参数进一步限制
        </span>
       </span>
      </strong>
      :
     </p>
     <p>
      下面的例子:
     </p>
     <pre><code class="language-cpp">//偏特化
template&lt;class T1&gt;
//部分参数特化
class car&lt;T1, int&gt;
{
public:
	car() { cout &lt;&lt; "car&lt;T1, int&gt;" &lt;&lt; endl; }

private:
	T1 _d1;
	int _d2;
};

//参数进一步限制
template&lt;class T1, class T2&gt;
class car&lt;T1*, T2*&gt;
{
public:
	car() { cout &lt;&lt; "car&lt;T1*, T2*&gt;" &lt;&lt; endl; }

private:
	T1* _d1;
	T2* _d2;
};


template&lt;class T1, class T2&gt;
class car&lt;T1&amp;, T2&amp;&gt;
{
public:
	car() { cout &lt;&lt; "car&lt;T1&amp;, T2&amp;&gt;" &lt;&lt; endl; }

private:
	const T1&amp; _d1 =T1();
	const T2&amp; _d2 =T2();
};

int main()
{
	car&lt;int, double &gt; c0;
	car&lt;int, int&gt; c1;
	car&lt;string, int&gt; c2;
	car&lt;int*, int*&gt; c3;
	car&lt;int&amp;, int&amp;&gt; c4;

	return 0;
}</code></pre>
     <p>
      输出结果:
     </p>
     <p>
      <img alt="" height="233" src="https://i-blog.csdnimg.cn/direct/3cb034efdddd4cd78855fc5cadc38793.png" width="750"/>
     </p>
     <p>
      <strong>
       <span style="color:#1c7331">
        <span style="background-color:#edf6e8">
         由此知道，编译器在类模版参数特化时，有现成吃现成(即有对应的特化)，没有现成编译器才需要实例化
        </span>
       </span>
      </strong>
      。
      <strong>
       <span style="color:#b95514">
        <span style="background-color:#fff5e6">
         相等于给一个人部分化定制
        </span>
       </span>
      </strong>
     </p>
    </blockquote>
    <h2 id="%C2%A0%F0%9F%90%BC%E6%A8%A1%E7%89%88%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91" name="%C2%A0%F0%9F%90%BC%E6%A8%A1%E7%89%88%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91">
     🐼模版的分离编译
    </h2>
    <blockquote>
     <p>
      我们知道，一个源文件生成可执行程序分别要经过
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         预处理，编译，汇编，链接
        </span>
       </span>
      </strong>
      四个大阶段。
     </p>
     <p>
      一个程序可能由多个源文件构成，而每个源文件
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         单独编译形成目标文件
        </span>
       </span>
      </strong>
      ，链接时将
      <strong>
       <span style="color:#1c7331">
        <span style="background-color:#edf6e8">
         所有源文件链接起来共同形成一个可执行程序
        </span>
       </span>
      </strong>
      。
     </p>
     <p>
      分离编译是指将程序的不同部分编译成独立的对象文件（.o 或 .obj），然后在链接阶段将这些对象文件组合成最终的可执行文件。分离编译要求每个编译单元（.cpp 文件）在编译时是
      <strong>
       <span style="color:#1a439c">
        <span style="background-color:#eaf4fc">
         独立
        </span>
       </span>
      </strong>
      的，编译器无法看到其他编译单元的内容。
     </p>
     <p>
      也就是编译形成obj文件，就是
      <strong>
       <span style="color:#ed7976">
        <span style="background-color:#fef2f0">
         自已玩自已的
        </span>
       </span>
      </strong>
      (都是独立的)，等到链接时，把大家都链接起来。
     </p>
    </blockquote>
    <blockquote>
     <p>
      先说结论，模版的声明和定义分开，即在头文件中声明，在源文件中定义，这会引发
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         链接错误
        </span>
       </span>
      </strong>
      。
     </p>
     <p>
      原因:汇编完后的多个obj目标文件，
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         由于函数模版无法实例化，因此无法放入到函数表中
        </span>
       </span>
      </strong>
      ，链接时由于
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         寻址错误
        </span>
       </span>
      </strong>
      ，就会链接失败。
     </p>
     <p>
     </p>
     <p>
      即模板的实例化需要编译器在编译时知道模板的具体实现细节。如果模板的定义和实例化分布在不同的编译单元中，编译器在编译其中一个单元时可能无法看到模板的完整定义，从而无法生成正确的代码。
     </p>
    </blockquote>
    <blockquote>
     <p>
      比如，我在Myfile.h头文件中声明函数模版，在file中定义。
     </p>
     <p>
      "Myfile.h"
     </p>
     <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

template&lt;class T&gt;
void func2(const T&amp; x);
</code></pre>
     <p>
      "file1.cpp"
     </p>
     <pre><code class="language-cpp">template&lt;class T&gt;
void func2(const T&amp; x)
{
	cout &lt;&lt; x &lt;&lt; endl;
}</code></pre>
     <p>
      这时候会报出链接错误。
     </p>
     <p>
      <img alt="" height="41" src="https://i-blog.csdnimg.cn/direct/f7deebf90ef74d68808ada420c1580b7.png" width="1379"/>
     </p>
     <p>
      因此，
      <strong>
       <span style="color:#ff9900">
        <span style="background-color:#fff5e6">
         模版是不支持声明和定义分离的
        </span>
       </span>
      </strong>
      。
     </p>
     <p>
      解决办法:
     </p>
     <p>
      1.将声明和定义放在一起
     </p>
     <p>
      "Myfile.h"
     </p>
     <pre><code class="language-cpp">
template&lt;class T&gt;
void func2(const T&amp; x)
{
	cout &lt;&lt; x &lt;&lt; endl;
}</code></pre>
     <p>
      方法2：在定义时显示实例化
     </p>
     <pre><code class="language-cpp">
template&lt;class T&gt;
void func2(const T&amp; x)
{
	cout &lt;&lt; x &lt;&lt; endl;
}

template  void func2&lt;int&gt;(const int&amp; x);//显示实例化</code></pre>
     <p>
      这样，编译器在链接时就不会根据无法实例化而报出链接错误
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     <span style="color:#511b78">
      <strong>
       <span style="background-color:#ff9900">
        感谢你耐心地阅读到这里，你的支持是我不断前行的最大动力。如果你觉得这篇文章对你有所启发，哪怕只是一点点，那就请不吝点赞👍，收藏⭐️，关注🚩吧！你的每一个点赞都是对我最大的鼓励，每一次收藏都是对我努力的认可，每一次关注都是对我持续创作的鞭策。希望我的文字能为你带来更多的价值，也希望我们能在这个充满知识与灵感的旅程中，共同成长，一起进步。再次感谢你的陪伴，期待与你在未来的文章中再次相遇！⛅️🌈 ☀️
       </span>
      </strong>
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333235313333302f:61727469636c652f64657461696c732f313436303337393631" class_="artid" style="display:none">
 </p>
</div>


