---
layout: post
title: "力扣hot100_子串"
date: 2025-03-06 14:27:48 +0800
description: "的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。滑动窗口每次只向右移动一位。子数组是数组中元素的连续非空序列。所有字符的子串，则返回空字符串。所有字符的最小子串。"
keywords: "力扣hot100_子串"
categories: ['未分类']
tags: ['算法', '数据结构', 'Leetcode']
artid: "146069952"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146069952
    alt: "力扣hot100_子串"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146069952
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146069952
cover: https://bing.ee123.net/img/rand?artid=146069952
image: https://bing.ee123.net/img/rand?artid=146069952
img: https://bing.ee123.net/img/rand?artid=146069952
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     力扣hot100_子串
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="hot100_239_0">
     </a>
     hot100_239.滑动窗口最大值
    </h4>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，有一个大小为
     <code>
      k
     </code>
    </p>
    <p>
     的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的
     <code>
      k
     </code>
     个数字。滑动窗口每次只向右移动一位。
    </p>
    <p>
     返回
     <em>
      滑动窗口中的最大值
     </em>
     。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：nums = [1], k = 1
输出：[1]
</code></pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <pre><code>1 &lt;= nums.length &lt;= 105
</code></pre>
     </li>
     <li>
      <pre><code>-104 &lt;= nums[i] &lt;= 104
</code></pre>
     </li>
     <li>
      <p>
       <code>
        1 &lt;= k &lt;= nums.length
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="prism language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;deque&gt;
using namespace std;

class Solution{
	public:
		vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
			vector&lt;int&gt; result;		
			deque&lt;int&gt; maxqueue;	
			int len = 0;
			for(int i = 0; i &lt; nums.size(); i++){
				//将已经退出滑动窗口的元素出队 
				while(len &gt; 0 &amp;&amp; maxqueue.front() &lt; i-k+1){
					maxqueue.pop_front();
					len--;
				}
				//维护递减队列 
				while(len &gt; 0 &amp;&amp; nums[maxqueue.back()]&lt;= nums[i]){
					maxqueue.pop_back();
 					len--;
				}
				maxqueue.push_back(i);
				len++;
				if(i &gt;= k - 1){
					result.push_back(nums[maxqueue.front()]);
				}			
			}
			return result;
		}
};

int main(){
//	vector&lt;int&gt; nums = {1};
	vector&lt;int&gt; nums = {1,3,1,2,0,5};
	int k = 3;
	Solution A;
	vector&lt;int&gt; result = A.maxSlidingWindow(nums, k);
	for(int i = 0; i &lt; result.size(); i++){
		cout &lt;&lt; result[i] &lt;&lt; " ";
	}
	cout&lt;&lt;endl;
	return 0;
}
</code></pre>
    <h4>
     <a id="hot100_560k_92">
     </a>
     hot100_560.和为k的子数组
    </h4>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     和一个整数
     <code>
      k
     </code>
     ，请你统计并返回
     <em>
      该数组中和为
      <code>
       k
      </code>
      的子数组的个数
     </em>
     。
    </p>
    <p>
     子数组是数组中元素的连续非空序列。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><code>输入：nums = [1,1,1], k = 2
输出：2
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：nums = [1,2,3], k = 3
输出：2
</code></pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <pre><code>1 &lt;= nums.length &lt;= 2 * 104
</code></pre>
     </li>
     <li>
      <pre><code>-1000 &lt;= nums[i] &lt;= 1000
</code></pre>
     </li>
     <li>
      <pre><code>`-107 &lt;= k &lt;= 107`
</code></pre>
     </li>
    </ul>
    <pre><code class="prism language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
class Solution{
	public:
		int sunarraySum(vector&lt;int&gt;&amp; nums, int k){
			
			unordered_map&lt;int, int&gt; hashMap;
        hashMap[0] = 1;
        // 记录满足条件的子数组个数
        int count = 0;
        // 初始化前缀和
        int prefixSum = 0;
        for (int num : nums) {
            // 计算当前的前缀和
            prefixSum += num;
            // 检查是否存在 prefix_sum - k 的前缀和
            if (hashMap.find(prefixSum - k) != hashMap.end()) {
                // 加上满足条件的前缀和个数
                count += hashMap[prefixSum - k];
            }
            // 更新哈希表中的当前前缀和出现次数
            hashMap[prefixSum]++;
        }
			return count;
		}
};

int main(){
	vector&lt;int&gt; nums = {1, 2, 3};
	int k = 3;
	Solution A;
	cout &lt;&lt; A.sunarraySum(nums,k) &lt;&lt; endl;
	return 0;
}
</code></pre>
    <h4>
     <a id="hot100_76_165">
     </a>
     hot100_76.最小覆盖子串
    </h4>
    <p>
     给你一个字符串
     <code>
      s
     </code>
     、一个字符串
     <code>
      t
     </code>
     。返回
     <code>
      s
     </code>
     中涵盖
     <code>
      t
     </code>
     所有字符的最小子串。如果
     <code>
      s
     </code>
     中不存在涵盖
     <code>
      t
     </code>
     所有字符的子串，则返回空字符串
     <code>
      ""
     </code>
     。
    </p>
    <p>
     <strong>
      注意：
     </strong>
    </p>
    <ul>
     <li>
      对于t中重复字符，我们寻找的子字符串中该字符数量必须不少于t中该字符数量。
     </li>
     <li>
      如果s中存在这样的子串，我们保证它是唯一的答案。
     </li>
    </ul>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><code>输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
</code></pre>
    <p>
     <strong>
      示例 3:
     </strong>
    </p>
    <pre><code>输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
</code></pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <pre><code>m == s.length
</code></pre>
     </li>
     <li>
      <pre><code>n == t.length
</code></pre>
     </li>
     <li>
      <pre><code>1 &lt;= m, n &lt;= 10^5
</code></pre>
     </li>
     <li>
      <pre><code>s和t由英文字母组成
</code></pre>
      <pre><code class="prism language-c++">class Solution{
	public:
	string minWindow(string s, string t) {
		bool is_t[52] = {false};
		bool is_minstr = false;
		int	count[52] = {0};
		queue&lt;int&gt; Q;
		int k = t.length();
		int minl=0,minr=10^5+1;
		int l = 0;
		for(char a:t){
			int index = findIndex(a);
			is_t[index] = true;
			count[index]++;
		}
		for(int i = 0; i &lt; s.length(); i++){
			char a = s[i];
			int index = findIndex(a);
			if(Q.empty()&amp;&amp;!is_t[index]) {
				l++;
				continue;
			}
			else if(is_t[index] &amp;&amp; count[index]==0){
                Q.push(index);
				while(Q.front()!=index)	{
					char tempIndex = Q.front();
					count[tempIndex]++; 
					if(is_t[tempIndex])	k++;
					Q.pop();
					l++;
				}
				Q.pop();
				l++;
				while(!is_t[Q.front()])	{
					Q.pop();
					l++;
				}
			}
			else if(is_t[index] &amp;&amp; count[index] &gt; 0){
                Q.push(index);
				count[index]--;
				k--;
			}
            else{
                Q.push(index);
            }
			if(k == 0 &amp;&amp; i - l &lt; minr - minl){
				minr = i;
				minl = l;
				is_minstr = true;
			}
//			cout &lt;&lt; "k = " &lt;&lt;k &lt;&lt;endl;
//			cout&lt;&lt; "队首元素下标：" &lt;&lt; Q.front()&lt;&lt;endl;
		}
//		cout &lt;&lt; minl &lt;&lt; " " &lt;&lt; minr&lt;&lt;endl;
		if(!is_minstr)	return "";
		else{
			string minstr = "";
			for(int i = minl; i &lt;= minr; i++){
				minstr = minstr + s[i];
			}
			return minstr;
		}
		
	} 
	int findIndex(char a){
		int index;
		if(a&lt;='Z')	index = a-'A';
		else	index = a-'a'+26;
		return index;
	}
}; 
</code></pre>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34373131333936302f:61727469636c652f64657461696c732f313436303639393532" class_="artid" style="display:none">
 </p>
</div>


