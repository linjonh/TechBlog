---
layout: post
title: "Linux网络高级IO一五种IO模型同步通信异步通信非阻塞IO详细讲解"
date: 2024-05-14 00:05:40 +0800
description: "[Linux][网络][高级IO][一][五种IO模型][同步通信][异步通信][非阻塞IO]详细讲"
keywords: "网络同步和异步通信"
categories: ['网络编程', '系统编程', 'Linux']
tags: ['高级Io', '非阻塞Io', '网络', '异步通信', '同步通信', '五种Io模型', 'Linux']
artid: "138823649"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138823649
    alt: "Linux网络高级IO一五种IO模型同步通信异步通信非阻塞IO详细讲解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=138823649
featuredImagePreview: https://bing.ee123.net/img/rand?artid=138823649
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [Linux][网络][高级IO][一][五种IO模型][同步通信][异步通信][非阻塞IO]详细讲解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      目录
     </h4>
     <ul>
      <li>
       <a href="#0___3" rel="nofollow">
        0.预备知识 &amp;&amp; 思考问题
       </a>
      </li>
      <li>
       <a href="#1IO_18" rel="nofollow">
        1.五种IO模型
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#0_20" rel="nofollow">
          0.形象理解五种模型
         </a>
        </li>
        <li>
         <a href="#1IO_33" rel="nofollow">
          1.阻塞IO
         </a>
        </li>
        <li>
         <a href="#2IO_40" rel="nofollow">
          2.非阻塞IO
         </a>
        </li>
        <li>
         <a href="#3IO_47" rel="nofollow">
          3.信号驱动IO
         </a>
        </li>
        <li>
         <a href="#4_52" rel="nofollow">
          4.多路转接/多路复用
         </a>
        </li>
        <li>
         <a href="#5IO_57" rel="nofollow">
          5.异步IO
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#2IO_63" rel="nofollow">
        2.高级IO重要概念
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_vs__65" rel="nofollow">
          1.同步通信 vs 异步通信
         </a>
        </li>
        <li>
         <a href="#2_vs__77" rel="nofollow">
          2.阻塞 vs 非阻塞
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#3IO_83" rel="nofollow">
        3.非阻塞IO
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1fcntl_85" rel="nofollow">
          1.fcntl()
         </a>
        </li>
        <li>
         <a href="#2SetNonBlock_107" rel="nofollow">
          2.实现SetNonBlock
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="0___3">
     </a>
     0.预备知识 &amp;&amp; 思考问题
    </h2>
    <ul>
     <li>
      网络通信本质：IO
     </li>
     <li>
      IO效率问题：效率一定是非常低下的
     </li>
     <li>
      <font color="blue">
       <strong>
        IO为什么低效？
       </strong>
      </font>
      <ul>
       <li>
        在read/recv时，如果底层缓冲区没有数据，recd/recv会怎么办？
        <ul>
         <li>
          阻塞 --&gt; 等
         </li>
        </ul>
       </li>
       <li>
        在read/recv时，如果底层缓冲区有数据，read/recv会怎么办？
        <ul>
         <li>
          拷贝数据
         </li>
        </ul>
       </li>
       <li>
        <font color="red">
         <strong>
          综上：IO = 等 + 数据拷贝
         </strong>
        </font>
       </li>
      </ul>
     </li>
     <li>
      <font color="blue">
       <strong>
        何为低效的IO？
       </strong>
      </font>
      <ul>
       <li>
        单位时间内，大部分时间IO类接口都处于等的状态
       </li>
      </ul>
     </li>
     <li>
      <font color="blue">
       <strong>
        如何提高IO效率，使之高效？
       </strong>
      </font>
      <ul>
       <li>
        单位时间内，让等的比重变得越低，IO的效率就越高
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="1IO_18">
     </a>
     1.五种IO模型
    </h2>
    <h3>
     <a id="0_20">
     </a>
     0.形象理解五种模型
    </h3>
    <ul>
     <li>
      将五种模型抽象为钓鱼中的五种模式
      <ul>
       <li>
        **阻塞IO：**一直盯着鱼竿，直到鱼上钩
       </li>
       <li>
        **非阻塞IO：**没事看两眼，看到有鱼就拉杆，其余时间做自己的事情
       </li>
       <li>
        **信号驱动IO：**鱼竿上放个铃铛，若有鱼上钩，则铃铛会响，听到铃铛响则拉杆，其余时间做自己的事情
       </li>
       <li>
        **多路转接：**一次性布置100个钓竿，同时吊，哪里上钩则到哪里拉杆
       </li>
       <li>
        **异步IO：**让别人帮自己钓鱼，自己直接拿别人的成果
       </li>
      </ul>
     </li>
     <li>
      其中
      <strong>
       效率最高
      </strong>
      的是
      <strong>
       多路转接
      </strong>
      <ul>
       <li>
        单位时间内，等的比重是非常低的
       </li>
      </ul>
     </li>
     <li>
      **同步IO和异步IO区别：**有没有参与IO细节 --&gt; [参与等/参与拷贝/同时都参与]
      <ul>
       <li>
        除了异步IO，其余的都是同步IO
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="1IO_33">
     </a>
     1.阻塞IO
    </h3>
    <ul>
     <li>
      在内核将数据准备好之前，系统调用会一直等待，所有的套接字，默认都是阻塞方式
     </li>
     <li>
      阻塞IO是最常见的IO模型
     </li>
    </ul>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d030fe77a6219cca1c1eee7977387da3.png"/>
    </p>
    <h3>
     <a id="2IO_40">
     </a>
     2.非阻塞IO
    </h3>
    <ul>
     <li>
      如果内核还未将数据准备好，系统调用仍然会直接返回，并且返回EWOULDBLOCK错误码
     </li>
     <li>
      非阻塞IO往往需要程序员以循环的方式反复尝试读写文件描述符，这个过程称为
      <strong>
       轮询
      </strong>
      <ul>
       <li>
        这对CPU来说是较大的浪费，一般只有特定场景下才使用
        <br/>
        <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/018420cb1227e9176e55a52305a10228.png"/>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="3IO_47">
     </a>
     3.信号驱动IO
    </h3>
    <ul>
     <li>
      内核将数据准备好的时候，使用
      <strong>
       SIGIO信号
      </strong>
      通知应用程序进行IO操作
      <br/>
      <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/32932b714ed2b12a9096d3c3ad7f91e4.png"/>
     </li>
    </ul>
    <h3>
     <a id="4_52">
     </a>
     4.多路转接/多路复用
    </h3>
    <ul>
     <li>
      虽然从流程图上看起来和阻塞IO类似，
      <strong>
       实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态
      </strong>
      <br/>
      <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f820dd97825b29b254a8f63754c4fb4e.png"/>
     </li>
    </ul>
    <h3>
     <a id="5IO_57">
     </a>
     5.异步IO
    </h3>
    <ul>
     <li>
      由内核在数据拷贝完成时，通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据)
      <br/>
      <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c2ffdf3e19f7ed52d71a016ae7d2a1e8.png"/>
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="2IO_63">
     </a>
     2.高级IO重要概念
    </h2>
    <h3>
     <a id="1_vs__65">
     </a>
     1.同步通信 vs 异步通信
    </h3>
    <ul>
     <li>
      同步和异步
      <strong>
       关注的是消息通信机制
      </strong>
      <ul>
       <li>
        所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回，但是一旦调用返回，就得到返回值了
        <ul>
         <li>
          换句话说，就是由调用者主动等待这个调用的结果
         </li>
        </ul>
       </li>
       <li>
        异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果
        <ul>
         <li>
          换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果
         </li>
         <li>
          而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      另外，在讲多进程多线程的时候，也提到同步和互斥，这里的同步通信和进程之间的同步是完全不相干的概念
      <ul>
       <li>
        进程/线程同步也是进程/线程之间直接的制约关系
       </li>
       <li>
        是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、 传递信息所产生的制约关系，尤其是在访问临界资源的时候
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="2_vs__77">
     </a>
     2.阻塞 vs 非阻塞
    </h3>
    <ul>
     <li>
      阻塞和非阻塞
      <strong>
       关注的是程序在等待调用结果(消息，返回值)时的状态
      </strong>
      <ul>
       <li>
        阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回
       </li>
       <li>
        非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="3IO_83">
     </a>
     3.非阻塞IO
    </h2>
    <h3>
     <a id="1fcntl_85">
     </a>
     1.fcntl()
    </h3>
    <ul>
     <li>
      **功能：**控制一个文件描述符，默认都是阻塞IO
     </li>
     <li>
      <em>
       <em>
        原型：int fcntl(int fd, int cmd, … /
       </em>
       arg
       <em>
        / );
       </em>
      </em>
     </li>
     <li>
      <strong>
       参数：
      </strong>
      <ul>
       <li>
        **fd：**要设置的文件描述符
       </li>
       <li>
        **cmd：**要做什么
       </li>
       <li>
        **arg：**要设置什么状态
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回值：
      </strong>
      <ul>
       <li>
        具体返回值取决于命令操作
       </li>
       <li>
        失败返回-1，同时errno被设置
       </li>
      </ul>
     </li>
     <li>
      <strong>
       fcntl()有5种功能
      </strong>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        复制一个现有的描述符
       </th>
       <th>
        cmd=F_DUPFD
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        获得/设置文件描述符标记
       </td>
       <td>
        cmd=F_GETFD或F_SETFD
       </td>
      </tr>
      <tr>
       <td>
        获得/设置文件状态标记
       </td>
       <td>
        cmd=F_GETFL或F_SETFL
       </td>
      </tr>
      <tr>
       <td>
        获得/设置异步I/O所有权
       </td>
       <td>
        cmd=F_GETOWN或F_SETOWN
       </td>
      </tr>
      <tr>
       <td>
        获得/设置记录锁
       </td>
       <td>
        cmd=F_GETLK,F_SETLK或F_SETLKW
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      此处只使用第三种功能，获取/设置文件状态标记，就可以
      <strong>
       将一个文件描述符设置为非阻塞
      </strong>
      <ul>
       <li>
        <strong>
         以后对所有的fd，都可以统一用这个接口来更改阻塞/非阻塞，更为统一且方便
        </strong>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="2SetNonBlock_107">
     </a>
     2.实现SetNonBlock
    </h3>
    <ul>
     <li>
      基于fcntl，实现SetNonBlock()，将文件描述符设置为非阻塞
      <ul>
       <li>
        使用
        <strong>
         F_GETFL
        </strong>
        将当前的文件描述符的属性取出来(这是一个位图)
       </li>
       <li>
        然后再使用
        <strong>
         F_SETFL
        </strong>
        将文件描述符设置回去，设置回去的同时，加上一个
        <strong>
         O_NONBLOCK
        </strong>
        参数
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">SetNonBlock</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fl <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在底层获取当前fd对应的属性</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fl <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 设置非阻塞</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> fl <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在老的标志位的前提下新增内容</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373238313635362f:61727469636c652f64657461696c732f313338383233363439" class_="artid" style="display:none">
 </p>
</div>


