---
layout: post
title: "解决JDK-序列化导致的-Redis-Key-非预期编码问题"
date: 2025-03-06 08:42:51 +0800
description: "解决JDK 序列化导致的 Redis Key 非预期编码问题"
keywords: "jdkserialzationredisserializer 异常引起程序崩溃"
categories: ['未分类']
tags: ['开发语言', 'Redis', 'Java']
artid: "146051778"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146051778
    alt: "解决JDK-序列化导致的-Redis-Key-非预期编码问题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146051778
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146051778
cover: https://bing.ee123.net/img/rand?artid=146051778
image: https://bing.ee123.net/img/rand?artid=146051778
img: https://bing.ee123.net/img/rand?artid=146051778
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     解决JDK 序列化导致的 Redis Key 非预期编码问题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <pre><code class="language-java">@RequestMapping("/testList")
    @ResponseBody
    public String testList() {
        //清楚之前的数据
        redisTemplate.execute((RedisConnection redisConnection)-&gt;{
            //excute 要求回调方法中必须写 return语句，返回个东西
            //这个回调返回的对象，就会作为excute本身的返回值。
            redisConnection.flushAll();
            return null;
        });
        redisTemplate.opsForList().leftPush("key", "111");
        redisTemplate.opsForList().leftPush("key", "222");
        redisTemplate.opsForList().leftPush("key", "333");
        String value = (String) redisTemplate.opsForList().leftPop("key");
        System.out.println(value);
        value = (String) redisTemplate.opsForList().leftPop("key");
        System.out.println(value);

        return "ok";
    }</code></pre>
    <p>
     以上为List类型操作测试代码，没有什么问题。
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="78" src="https://i-blog.csdnimg.cn/direct/3757fbb025454c0495f3cf09224e01ca.png" width="410"/>
    </p>
    <p>
     浏览器正常响应
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="388" src="https://i-blog.csdnimg.cn/direct/c27e8e4f90ff4deeb3574fef01ad3ad0.png" width="1227"/>
    </p>
    <p>
     后端控制台也没有报错
    </p>
    <h2 id="%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%EF%BC%9A" name="%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%EF%BC%9A">
     问题产生原因：
    </h2>
    <p>
     <img alt="" height="116" src="https://i-blog.csdnimg.cn/direct/8794ec8b75db4ccab1aad81a5243771f.png" width="434"/>
    </p>
    <p>
     但是却在xshell终端中出现了，key值存储显示异常的问题，同时单纯的对“key”使用命令，没有效果。之后我查找相关资料，了解到这是JDK 序列化导致的 Redis Key 非预期编码问题。产生这个问题的主要原因是
     <code>
      RedisTemplate
     </code>
     默认使用JDK序列（
     <code>
      JdkSerializationRedisSerializer
     </code>
     ）作为
     <code>
      keySerializer
     </code>
     ，它会把 Key 进行 Java 对象序列化后存入 Redis，而不是存储原始字符串。
    </p>
    <h2 id="%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A" name="%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A">
     问题解决办法：
    </h2>
    <p>
     优化默认的序列化方式：
    </p>
    <p>
     Key 统一使用 StringRedisSerializer，避免 JDK 序列化的乱码问题。
     <br/>
     Value 根据类型动态选择合适的序列化方式：
     <br/>
     String 直接存 StringRedisSerializer。
     <br/>
     对象、集合 存 JSON（GenericJackson2JsonRedisSerializer）。
     <br/>
     避免 JSON 额外的 \"，保证字符串存储不会被 JSON 影响。
     <br/>
     支持 Java 8 时间类型的 JSON 序列化。
    </p>
    <pre><code class="language-java">package org.example.redisdemo.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import com.fasterxml.jackson.databind.jsontype.PolymorphicTypeValidator;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(factory);

        // 1. Key 和 HashKey 统一用 StringRedisSerializer
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringRedisSerializer);
        template.setHashKeySerializer(stringRedisSerializer);

        // 2. 配置 JSON 序列化器
        ObjectMapper objectMapper = new ObjectMapper();
        PolymorphicTypeValidator ptv = BasicPolymorphicTypeValidator.builder()
                .allowIfSubType(Object.class)
                .build();
        objectMapper.activateDefaultTyping(ptv, ObjectMapper.DefaultTyping.NON_FINAL);
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.registerModule(new JavaTimeModule());

        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(objectMapper);

        // 3. Value 序列化：String 类型的值用 StringRedisSerializer，其他用 JSON
        template.setValueSerializer(new RedisSerializer&lt;&gt;() {
            private final StringRedisSerializer stringSerializer = new StringRedisSerializer();

            @Override
            public byte[] serialize(Object o) {
                if (o instanceof String) {
                    return stringSerializer.serialize((String) o);
                }
                return jsonRedisSerializer.serialize(o);
            }

            @Override
            public Object deserialize(byte[] bytes) {
                if (bytes == null) return null;
                String str = stringSerializer.deserialize(bytes);
                return (str != null &amp;&amp; str.startsWith("\"") &amp;&amp; str.endsWith("\"")) ? jsonRedisSerializer.deserialize(bytes) : str;
            }
        });

        // 4. Hash Value 也做类似处理，避免 String 额外的 `\"`
        template.setHashValueSerializer(new RedisSerializer&lt;&gt;() {
            private final StringRedisSerializer stringSerializer = new StringRedisSerializer();

            @Override
            public byte[] serialize(Object o) {
                if (o instanceof String) {
                    return stringSerializer.serialize((String) o);
                }
                return jsonRedisSerializer.serialize(o);
            }

            @Override
            public Object deserialize(byte[] bytes) {
                if (bytes == null) return null;
                String str = stringSerializer.deserialize(bytes);
                return (str != null &amp;&amp; str.startsWith("\"") &amp;&amp; str.endsWith("\"")) ? jsonRedisSerializer.deserialize(bytes) : str;
            }
        });

        template.afterPropertiesSet();
        return template;
    }
}
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f6b7a665f7374756479686172642f:61727469636c652f64657461696c732f313436303531373738" class_="artid" style="display:none">
 </p>
</div>


