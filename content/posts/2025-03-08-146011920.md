---
layout: post
title: "SpringBoot统一功能处理"
date: 2025-03-08 11:15:52 +0800
description: "本期讲解：SpringBoot中的统一用户登录权限验证、异常处理和统一的格式返回。"
keywords: "【SpringBoot】统一功能处理"
categories: ['Spring']
tags: ['后端', 'Spring', 'Java', 'Boot']
artid: "146011920"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146011920
    alt: "SpringBoot统一功能处理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146011920
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146011920
cover: https://bing.ee123.net/img/rand?artid=146011920
image: https://bing.ee123.net/img/rand?artid=146011920
img: https://bing.ee123.net/img/rand?artid=146011920
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【SpringBoot】统一功能处理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr/>
    <h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%9F%E4%B8%80%E5%8A%9F%E8%83%BD%E5%A4%84%E7%90%86" name="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%9F%E4%B8%80%E5%8A%9F%E8%83%BD%E5%A4%84%E7%90%86">
     一、什么是统一功能处理
    </h2>
    <p>
     <strong>
      SpringBoot 统一功能处理：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       定义
      </strong>
      ：指在SpringBoot应用中，通过一些统一的处理机制，对具有共性的功能进行集中管理，以提高代码的可维护性和开发效率。
     </li>
     <li>
      <strong>
       应用范围
      </strong>
      ：通常包括统一异常处理、统一数据返回格式、统一用户认证与授权等。
     </li>
    </ul>
    <hr/>
    <h2 id="%E4%BA%8C%E3%80%81%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81" name="%E4%BA%8C%E3%80%81%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81">
     二、统一用户登录权限验证
    </h2>
    <h3 id="2.1%20%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8" name="2.1%20%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8">
     2.1 定义拦截器
    </h3>
    <blockquote>
     <p>
      在
      <strong>
       SpringMVC
      </strong>
      中
      <strong>
       HandlerInterceptor
      </strong>
      接口是一种用于拦截
      <strong>
       Http
      </strong>
      请求、响应的机制，它允许开发者在访问控制器（
      <strong>
       Controller
      </strong>
      ）之前加入一些自定义的规范，如拦截器中设置了
      <strong>
       session
      </strong>
      ，当
      <strong>
       Controller
      </strong>
      请求成功时返回
      <strong>
       true
      </strong>
      则进行后续相关操作返回
      <strong>
       false
      </strong>
      则结束。
     </p>
    </blockquote>
    <p>
     首先在项目中有以下类：
    </p>
    <ul>
     <li>
      ApplicationValue类 自定义的 session
     </li>
     <li>
      UserInterceptor类 自定义拦截器
     </li>
     <li>
      ApplicationConfig类 自定义拦截规范
     </li>
     <li>
      UserController类 自定义请求
     </li>
    </ul>
    <p>
     <strong>
      ApplicationValue：
     </strong>
    </p>
    <p>
    </p>
    <pre><code>/**
 * 全局变量
 * */
public class ApplicationValue {
    //自定义session key
    public static final String SESSION_KEY = "SESSION_KEY";
}
</code></pre>
    <p>
     <strong>
      UserInterceptor：
     </strong>
    </p>
    <pre><code>/**
 * 自定义拦截器
 */
@Component
public class UserInterceptor implements HandlerInterceptor {
    /**
     *  * 返回true代表拦截器验证成功继续执行后续代码
     *  * 返回false代表拦截器验证失败不执行后续代码
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    //前置通知
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("拦截器开始执行");
        //业务方法
        HttpSession session = request.getSession(false);
        if(session!=null &amp;&amp; session.getAttribute(ApplicationValue.SESSION_KEY) != null) {
            //登录成功
            return true;
        }
        return false;
    }
}</code></pre>
    <blockquote>
     <p>
      <strong>
       preHandle
      </strong>
      方法是
      <strong>
       UserInterceptor
      </strong>
      接口底下的一个请求达到控制器之间（
      <strong>
       Controller
      </strong>
      ）执行的一个方法。类似于
      <strong>
       Spring AOP
      </strong>
      中的前置通知。当请求满足拦截规则即 preHandle 方法返回 true 时则放行该请求，返回 false 则拦截该请求。
     </p>
     <p>
      上述获取
      <strong>
       session
      </strong>
      时，在
      <strong>
       getSession
      </strong>
      方法中加入一个
      <strong>
       false
      </strong>
      是为了当获取的
      <strong>
       session
      </strong>
      不存在时不创建一个新的会话而是返回一个
      <strong>
       null
      </strong>
      。
     </p>
    </blockquote>
    <hr/>
    <h3 id="2.2%20%E5%88%B6%E5%AE%9A%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99" name="2.2%20%E5%88%B6%E5%AE%9A%E6%8B%A6%E6%88%AA%E8%A7%84%E5%88%99">
     2.2 制定拦截规则
    </h3>
    <blockquote>
     <p>
      <strong>
       WebMvcConfigurer
      </strong>
      是
      <strong>
       Spring Framework
      </strong>
      提供的一个接口，它可以使开发者在
      <strong>
       Spring MVC
      </strong>
      中不使用
      <strong>
       xml
      </strong>
      文件来约束规则，而是通过
      <strong>
       java
      </strong>
      代码来扩展
      <strong>
       SpringMVC
      </strong>
      相关操作。如制定自定义对某些
      <strong>
       Web
      </strong>
      请求的拦截规则等。
     </p>
    </blockquote>
    <p>
     <strong>
      ApplicationConfig
     </strong>
     ：
    </p>
    <pre><code>@Configuration
public class ApplicationConfig implements WebMvcConfigurer {
    //将拦截器注入进来
    @Autowired
    private UserInterceptor userInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //指定拦截规则
        registry.addInterceptor(userInterceptor)
                .addPathPatterns("/**") //拦截所有请求
                .excludePathPatterns("/user/getuser") //排除拦截某个请求
                ;
    }
}</code></pre>
    <blockquote>
     <p>
      <strong>
       InterceptorRegistry
      </strong>
      是
      <strong>
       Spring Framework
      </strong>
      中的一个
      <span style="color:#0d0016">
       <strong>
        <span style="background-color:#d7d8d9">
         制定和管理拦截器
        </span>
       </strong>
      </span>
      的一个类。通过它底下的方法能放行或拦截某些请求。如
      <strong>
       addPathPatterns
      </strong>
      方法为拦截所有请求，
      <strong>
       excludePathPatterns
      </strong>
      为排除拦截某个请求。
     </p>
    </blockquote>
    <hr/>
    <h3 id="2.3%20%E5%88%9B%E5%BB%BA%E8%AF%B7%E6%B1%82" name="2.3%20%E5%88%9B%E5%BB%BA%E8%AF%B7%E6%B1%82">
     2.3 创建请求
    </h3>
    <p>
     <strong>
      UserController
     </strong>
     ：
    </p>
    <pre><code>@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/getuser")
    public String getUser() {
        System.out.println("user访问成功");
        return "hello user";
    }

    @RequestMapping("/login")
    public String login() {
        System.out.println("登录成功");
        return "welcome login";
    }
}
</code></pre>
    <blockquote>
     <p>
      上述代码中
      <strong>
       @RequestMapping
      </strong>
      为路由选择，它是
      <strong>
       SpringMVC
      </strong>
      中将
      <strong>
       Http
      </strong>
      请求映射到某一个类或方法上的注解。
     </p>
    </blockquote>
    <p>
     <strong>
      postman
     </strong>
     测试，在浏览器或第三方软件中输入
     <strong>
      localhost:8080/user/getuser
     </strong>
     就能访问到上面制定的请求。
    </p>
    <p>
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/0644aecf8cd74b84834308920adc02a5.png" width="500"/>
    </p>
    <p>
     编译器输出：
    </p>
    <p>
     <img alt="" height="74" src="https://i-blog.csdnimg.cn/direct/72b1c5a25f554f13996922e4e0dbefc2.png" width="500"/>
    </p>
    <p>
     此外，当你需要放行所有图片格式的数据时，图片我们知道有
     <strong>
      png
     </strong>
     、
     <strong>
      jpg
     </strong>
     、
     <strong>
      jpeg
     </strong>
     等类型的，我们不可能一个个的类型进行放行，此时可以将这些类型的图片放入一个文件夹，只需要放行这一个文件夹即可。
    </p>
    <hr/>
    <h3 id="2.4%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" name="2.4%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">
     2.4 拦截器底层原理
    </h3>
    <p>
     通过日常观察，在控制台打印信息中所有的
     <strong>
      Controller
     </strong>
     代码都会执行
     <strong>
      DispatcherServlet
     </strong>
     中的
     <strong>
      doDispatch
     </strong>
     调度方法，
     <strong>
      DispatcherServlet
     </strong>
     是前端控制器。
    </p>
    <p>
     <img alt="" height="54" src="https://i-blog.csdnimg.cn/direct/00dbc2bbff1d4511afe72f366663d674.png" width="500"/>
    </p>
    <blockquote>
     <p>
      在
      <strong>
       SpringBoot
      </strong>
      中，当一个
      <strong>
       Http
      </strong>
      请求到达
      <strong>
       Spring MVC
      </strong>
      中时，
      <strong>
       DispatcherServlet
      </strong>
      作为前端控制器，负责接收并处理这个请求，在这个过程中会用到
      <strong>
       doDispatch
      </strong>
      调度方法。
     </p>
     <p>
      <strong>
       doDispatch
      </strong>
      方法主要是负责调度和处理
      <strong>
       Http
      </strong>
      请求，
     </p>
    </blockquote>
    <p>
     拦截器底层主要代码：
    </p>
    <pre><code>
//调用预处理
 if (!mappedHandler.applyPreHandle(processedRequest, respon
se)) {
 return;
 }
 // 执⾏ Controller 中的业务
 mv = ha.handle(processedRequest, response, mappedHandler.g
etHandler());
 if (asyncManager.isConcurrentHandlingStarted()) {
 return;
}</code></pre>
    <p>
     <span style="color:#262626">
      开始执⾏ Controller 之前，会先调⽤ 预处理⽅法 applyPreHandle：
     </span>
    </p>
    <pre><code>boolean applyPreHandle(HttpServletRequest request, HttpServletResponse res
ponse) throws Exception {
 for(int i = 0; i &lt; this.interceptorList.size(); this.interceptorIndex
= i++) {
 // 获取项⽬中使⽤的拦截器 HandlerInterceptor
 HandlerInterceptor interceptor = (HandlerInterceptor)this.intercep
torList.get(i);
 if (!interceptor.preHandle(request, response, this.handler)) {
 this.triggerAfterCompletion(request, response, (Exception)null
);
 return false;
 }
 }
 return true;
}</code></pre>
    <p>
     <span style="color:#262626">
      在 applyPreHandle 中会获取所有的拦截器 HandlerInterceptor 并执⾏拦截器中
     </span>
    </p>
    <div>
     <span style="color:#262626">
      的 preHandle ⽅法。
     </span>
    </div>
    <hr/>
    <h2 id="%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" name="%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">
     三、统一异常处理
    </h2>
    <p>
     当访问一个不存在的请求时，浏览器会出现一大片英文表示访问错误，并显示错误状态码为500，如下所示：
    </p>
    <pre><code>@RequestMapping("/user")
public class UserController {

    @RequestMapping("/reg")
    public String reg(){
        Object obj = null;
        System.out.println(obj.hashCode());
        return "注册成功";
    }
}
</code></pre>
    <p>
     <img alt="" height="223" src="https://i-blog.csdnimg.cn/direct/a475d08bd0ed4711827dbea0ae51ef41.png" width="500"/>
    </p>
    <p>
     为了解决上述问题，可以使用
     <strong>
      @ControllerAdvice
     </strong>
     和
     <strong>
      @ExceptionAdvice
     </strong>
     这两个注解自定义设置某些异常对应返回的类型格式。如上述的空指针异常浏览器显示一大串英文字母，而通过这两个注解进行自定义设置一个 Ajax 格式，浏览器会显示一个状态码、异常提示、数据，让人看起来比较简洁，当然你也可以设置其他格式。
    </p>
    <blockquote>
     <p>
      @ControllerAdvice 注解是 SpringFramework 中的一个注解，它是一个控制器通知类，主要的作用是用于定义全局异常处理器，以及用于全局数据绑定或全局数据格式化的逻辑。它提供了一种集中化的方式来处理跨多个控制器的通用逻辑，比如异常处理、数据预处理和后处理等。
     </p>
     <p>
      @ExceptionAdvice 注解也是 SpringFramework 中的一个注解用于定义全局异常处理逻辑。它的主要功能是捕获特定类型的异常，并返回相应的响应数据，从而避免在每个控制器中重复编写异常处理代码。
     </p>
    </blockquote>
    <p>
     ExceptionAdvice：
    </p>
    <pre><code>@RestControllerAdvice
public class ExceptionAdvice {
    @ExceptionHandler(NullPointerException.class)//统一访问对象
    public RequestAjax doNullPointerException (NullPointerException e) {
        RequestAjax requestAjax = new RequestAjax();
        requestAjax.setCode(-1);
        requestAjax.setMas("空指针异常:" + e.getMessage());
        requestAjax.setData(null);
        return requestAjax;
    }
}
</code></pre>
    <p>
     RequestAjax：
    </p>
    <pre><code>@Data
public class RequestAjax {
    private int code; //状态码
    private String mas; // 状态码描述
    private Object data; // 返回数据
}</code></pre>
    <p>
     结果：
    </p>
    <p>
     <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/c92f209bc0e24e649beea39065815c5d.png" width="500"/>
    </p>
    <p>
     以上是针对单个空指针异常进行的异常处理，异常的种类是非常多的如空指针异常、栈溢出异常等。假设一个程序中有多个异常都按照空指针异常来处理是不行的，因此改为以下代码使得无论是什么异常都会报出如异常：XXX，相比一大面英文字母好很多。
    </p>
    <pre><code>    @ExceptionHandler(Exception.class)//统一访问对象
    public RequestAjax doException (Exception e) {
        RequestAjax requestAjax = new RequestAjax();
        requestAjax.setCode(-1);
        requestAjax.setMas("异常:" + e.getMessage());
        requestAjax.setData(null);
        return requestAjax;
    }</code></pre>
    <hr/>
    <h2 id="%E5%9B%9B%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BF%94%E5%9B%9E" name="%E5%9B%9B%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BF%94%E5%9B%9E">
     四、统一数据格式返回
    </h2>
    <p>
     <strong>
      ResponseBodyAdvice用途
     </strong>
     ：
    </p>
    <p id="">
     <strong>
      ResponseBodyAdvice
     </strong>
     是
     <strong>
      Spring 4.1
     </strong>
     引入的一个接口，用于在
     <strong>
      Controller
     </strong>
     方法返回响应体之前，对响应体的内容进行处理。它允许开发者拦截
     <strong>
      Controller
     </strong>
     方法的返回值，并对返回值进行修改、增强或定制化。具体来说，
     <strong>
      ResponseBodyAdvice
     </strong>
     有以下几个主要用途：
    </p>
    <ol>
     <li>
      <p id="">
       <strong>
        统一处理返回值结构
       </strong>
       ：
      </p>
      <ul>
       <li>
        可以对Controller方法的返回值进行统一的封装，例如，将所有API接口的返回值封装成统一的JSON结构，包含状态码、消息和数据等字段。
       </li>
       <li>
        便于前端统一处理不同接口的响应数据，提高开发效率。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        数据加密或压缩
       </strong>
       ：
      </p>
      <ul>
       <li>
        可以在响应体写入之前，对返回值进行加密或压缩处理，提高数据的安全性或传输效率。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        添加额外信息
       </strong>
       ：
      </p>
      <ul>
       <li>
        可以在返回值中添加一些额外的信息，例如时间戳、签名等，满足特定的业务需求。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     则有以下代码：
    </p>
    <pre><code>    @RequestMapping("/getuser")
    public String getUser() {
        System.out.println("user访问成功");
        return "hello user";
    }</code></pre>
    <pre><code>@ControllerAdvice
public class RespondAdvice implements ResponseBodyAdvice {

    @Autowired
    private ObjectMapper objectMapper;

    /**
     * 当supports为true时执行后续操作，否则不执行
     * @param returnType
     * @param converterType
     * @return
     */
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
       if (body instanceof RequestAjax) {
           return body;
       }
       if (body instanceof String) {
           RequestAjax requestAjax = RequestAjax.succ(body);
           try {
               return objectMapper.writeValueAsString(requestAjax);
           } catch (JsonProcessingException e) {
               e.printStackTrace();
           }
       }
        return RequestAjax.succ(body);
    }
}</code></pre>
    <p>
     <img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/c3b3cbeb788243f5a3065c5b6eb2d198.png" width="500"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36343931363331312f:61727469636c652f64657461696c732f313436303131393230" class_="artid" style="display:none">
 </p>
</div>


