---
layout: post
title: "深入理解-Java-虚拟机之垃圾收集"
date: 2025-03-08 12:34:12 +0800
description: "JVM 的垃圾收集机制通过可达性分析、分代收集和多样化的收集器，高效管理内存。串行适合小型应用，并行追求吞吐量，CMS 和 G1 优化停顿时间。理解 GC 原理和策略，有助于调优程序性能，避免内存溢出等问题。"
keywords: "深入理解 Java 虚拟机之垃圾收集"
categories: ['Java']
tags: ['开发语言', 'Java']
artid: "146114308"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146114308
    alt: "深入理解-Java-虚拟机之垃圾收集"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146114308
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146114308
cover: https://bing.ee123.net/img/rand?artid=146114308
image: https://bing.ee123.net/img/rand?artid=146114308
img: https://bing.ee123.net/img/rand?artid=146114308
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深入理解 Java 虚拟机之垃圾收集
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a95cb98cf4684b9f964080e1ff1e16df.png#pic_center">
      <br/>
      垃圾收集（Garbage Collection，GC）是 Java 虚拟机（JVM）内存管理的核心机制，主要针对
      <strong>
       Java 堆
      </strong>
      和
      <strong>
       方法区
      </strong>
      进行回收。线程私有的程序计数器、虚拟机栈和本地方法栈随线程生命周期结束而自然消失，无需 GC。本文将详细探讨 GC 的判定依据、算法、收集器及内存分配策略。
     </img>
    </p>
    <hr/>
    <h3>
     <a id="_6">
     </a>
     对象是否需要回收
    </h3>
    <h4>
     <a id="1__8">
     </a>
     1. 引用计数算法
    </h4>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：对象维护一个引用计数器，被引用时加 1，引用失效时减 1，计数为 0 时可回收。
     </li>
     <li>
      <strong>
       缺陷
      </strong>
      ：无法解决循环引用问题，例如两个对象互相引用，计数永不为 0。
     </li>
     <li>
      <strong>
       结论
      </strong>
      ：JVM 不采用此算法。
     </li>
    </ul>
    <h4>
     <a id="2__13">
     </a>
     2. 可达性分析算法
    </h4>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：从
      <strong>
       GC Roots
      </strong>
      开始搜索，可达对象存活，不可达对象死亡。
     </li>
     <li>
      <strong>
       GC Roots
      </strong>
      ：
      <ul>
       <li>
        虚拟机栈中的引用对象。
       </li>
       <li>
        本地方法栈中的引用对象。
       </li>
       <li>
        方法区中的静态属性和常量引用对象。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       应用
      </strong>
      ：JVM 主流采用此算法。
     </li>
    </ul>
    <h4>
     <a id="3__21">
     </a>
     3. 引用类型
    </h4>
    <p>
     Java 提供四种引用类型，影响对象回收：
    </p>
    <ul>
     <li>
      <strong>
       强引用
      </strong>
      ：
      <code>
       new
      </code>
      创建的对象，不会回收。
     </li>
     <li>
      <strong>
       软引用
      </strong>
      ：
      <code>
       SoftReference
      </code>
      ，内存不足时回收。
     </li>
     <li>
      <strong>
       弱引用
      </strong>
      ：
      <code>
       WeakReference
      </code>
      ，下次 GC 时回收，常用于缓存（如
      <code>
       WeakHashMap
      </code>
      ）。
     </li>
     <li>
      <strong>
       虚引用
      </strong>
      ：
      <code>
       PhantomReference
      </code>
      ，仅用于接收回收通知。
     </li>
    </ul>
    <h4>
     <a id="4__28">
     </a>
     4. 方法区回收
    </h4>
    <ul>
     <li>
      <strong>
       目标
      </strong>
      ：废弃常量和无用类。
     </li>
     <li>
      <strong>
       类卸载条件
      </strong>
      ：
      <ol>
       <li>
        所有实例已回收。
       </li>
       <li>
        类加载器已回收。
       </li>
       <li>
        <code>
         Class
        </code>
        对象未被引用。
       </li>
      </ol>
     </li>
     <li>
      <strong>
       控制
      </strong>
      ：通过
      <code>
       -Xnoclassgc
      </code>
      参数决定是否卸载。
     </li>
    </ul>
    <h4>
     <a id="5_finalize__36">
     </a>
     5. finalize() 方法
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：对象回收前可执行的自救方法。
     </li>
     <li>
      <strong>
       问题
      </strong>
      ：运行代价高、不确定性大，建议避免使用。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_42">
     </a>
     垃圾收集算法
    </h3>
    <h4>
     <a id="1__44">
     </a>
     1. 性能指标
    </h4>
    <ul>
     <li>
      <strong>
       停顿时间
      </strong>
      ：GC 导致的程序暂停时长。
     </li>
     <li>
      <strong>
       吞吐量
      </strong>
      ：用户代码运行时间占比。
     </li>
    </ul>
    <h4>
     <a id="2_MarkSweep_48">
     </a>
     2. 标记-清除（Mark-Sweep）
    </h4>
    <ul>
     <li>
      <strong>
       过程
      </strong>
      ：标记需回收对象，然后清除。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：效率低，产生内存碎片。
     </li>
    </ul>
    <h4>
     <a id="3_MarkCompact_52">
     </a>
     3. 标记-整理（Mark-Compact）
    </h4>
    <ul>
     <li>
      <strong>
       过程
      </strong>
      ：标记后将存活对象移至一端，清理边界外内存。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：解决碎片问题。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：整理开销大。
     </li>
    </ul>
    <h4>
     <a id="4_Copying_57">
     </a>
     4. 标记-复制（Copying）
    </h4>
    <ul>
     <li>
      <strong>
       过程
      </strong>
      ：内存分两块，存活对象复制到空闲块，清理已用块。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：无碎片。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：内存利用率低（改进为 Eden + 2 Survivor）。
     </li>
    </ul>
    <h4>
     <a id="5__62">
     </a>
     5. 分代收集
    </h4>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：根据对象生命周期分代，年轻代用复制算法，老年代用标记-清除或标记-整理。
     </li>
     <li>
      <strong>
       堆结构
      </strong>
      ：
      <ul>
       <li>
        <strong>
         新生代
        </strong>
        ：Eden + 2 Survivor，默认比例 8:1:1。
       </li>
       <li>
        <strong>
         老年代
        </strong>
        ：存放长生命周期对象。
       </li>
       <li>
        <strong>
         永久代
        </strong>
        ：JDK 8 前的方法区实现，现为元空间。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_71">
     </a>
     垃圾收集器
    </h3>
    <p>
     HotSpot 提供多种垃圾收集器，各有适用场景：
    </p>
    <h4>
     <a id="1_Serial_75">
     </a>
     1. 串行收集器（Serial）
    </h4>
    <ul>
     <li>
      <strong>
       特点
      </strong>
      ：单线程，Stop-The-World，适用于 Client 模式。
     </li>
     <li>
      <strong>
       组合
      </strong>
      ：
      <ul>
       <li>
        <strong>
         Serial
        </strong>
        ：年轻代，复制算法，
        <code>
         -XX:+UseSerialGC
        </code>
        。
       </li>
       <li>
        <strong>
         Serial Old
        </strong>
        ：老年代，标记-整理。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="2__81">
     </a>
     2. 并行收集器
    </h4>
    <ul>
     <li>
      <strong>
       目标
      </strong>
      ：高吞吐量，Server 模式默认。
     </li>
     <li>
      <strong>
       组合
      </strong>
      ：
      <ul>
       <li>
        <strong>
         Parallel Scavenge
        </strong>
        ：年轻代，复制算法，
        <code>
         -XX:+UseParallelGC
        </code>
        。
       </li>
       <li>
        <strong>
         Parallel Old
        </strong>
        ：老年代，标记-整理，
        <code>
         -XX:+UseParallelOldGC
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       参数
      </strong>
      ：
      <ul>
       <li>
        <code>
         -XX:MaxGCPauseMillis
        </code>
        ：控制停顿时间。
       </li>
       <li>
        <code>
         -XX:GCTimeRatio
        </code>
        ：设置吞吐量。
       </li>
       <li>
        <code>
         -XX:+UseAdaptiveSizePolicy
        </code>
        ：自适应调整。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="3_CMS_91">
     </a>
     3. 并发标记清除（CMS）
    </h4>
    <ul>
     <li>
      <strong>
       目标
      </strong>
      ：最短停顿时间。
     </li>
     <li>
      <strong>
       组合
      </strong>
      ：
      <code>
       -XX:+UseConcMarkSweepGC
      </code>
      ，ParNew（年轻代）+ CMS（老年代）+ Serial Old（备用）。
     </li>
     <li>
      <strong>
       步骤
      </strong>
      ：
      <ol>
       <li>
        初始标记（停顿）。
       </li>
       <li>
        并发标记。
       </li>
       <li>
        重新标记（停顿）。
       </li>
       <li>
        并发清除。
       </li>
      </ol>
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：内存碎片、浮动垃圾，需预留空间。
     </li>
    </ul>
    <h4>
     <a id="4_G1__101">
     </a>
     4. G1 收集器
    </h4>
    <ul>
     <li>
      <strong>
       特点
      </strong>
      ：兼顾吞吐量和停顿时间，JDK 9+ 默认，
      <code>
       -XX:+UseG1GC
      </code>
      。
     </li>
     <li>
      <strong>
       分区
      </strong>
      ：堆划分为多个 Region，动态分配角色。
     </li>
     <li>
      <strong>
       步骤
      </strong>
      ：
      <ol>
       <li>
        初始标记。
       </li>
       <li>
        并发标记。
       </li>
       <li>
        最终标记。
       </li>
       <li>
        筛选回收（优先高价值 Region）。
       </li>
      </ol>
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：无碎片，可预测停顿。
     </li>
    </ul>
    <h4>
     <a id="_111">
     </a>
     收集器对比
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        收集器
       </th>
       <th>
        类型
       </th>
       <th>
        代
       </th>
       <th>
        算法
       </th>
       <th>
        目标
       </th>
       <th>
        场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        Serial
       </td>
       <td>
        串行
       </td>
       <td>
        年轻代
       </td>
       <td>
        复制
       </td>
       <td>
        低停顿
       </td>
       <td>
        单核 Client 模式
       </td>
      </tr>
      <tr>
       <td>
        Serial Old
       </td>
       <td>
        串行
       </td>
       <td>
        老年代
       </td>
       <td>
        标记-整理
       </td>
       <td>
        低停顿
       </td>
       <td>
        CMS 备用
       </td>
      </tr>
      <tr>
       <td>
        ParNew
       </td>
       <td>
        并行
       </td>
       <td>
        年轻代
       </td>
       <td>
        复制
       </td>
       <td>
        低停顿
       </td>
       <td>
        与 CMS 配合
       </td>
      </tr>
      <tr>
       <td>
        Parallel Scavenge
       </td>
       <td>
        并行
       </td>
       <td>
        年轻代
       </td>
       <td>
        复制
       </td>
       <td>
        高吞吐量
       </td>
       <td>
        后台运算
       </td>
      </tr>
      <tr>
       <td>
        Parallel Old
       </td>
       <td>
        并行
       </td>
       <td>
        老年代
       </td>
       <td>
        标记-整理
       </td>
       <td>
        高吞吐量
       </td>
       <td>
        后台运算
       </td>
      </tr>
      <tr>
       <td>
        CMS
       </td>
       <td>
        并发
       </td>
       <td>
        老年代
       </td>
       <td>
        标记-清除
       </td>
       <td>
        低停顿
       </td>
       <td>
        Web 服务端
       </td>
      </tr>
      <tr>
       <td>
        G1
       </td>
       <td>
        并发
       </td>
       <td>
        全部
       </td>
       <td>
        标记-整理+复制
       </td>
       <td>
        低停顿+吞吐量
       </td>
       <td>
        服务端应用
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <a id="_125">
     </a>
     内存分配与回收策略
    </h3>
    <h4>
     <a id="1_Minor_GC_127">
     </a>
     1. Minor GC
    </h4>
    <ul>
     <li>
      <strong>
       触发
      </strong>
      ：Eden 区满。
     </li>
     <li>
      <strong>
       过程
      </strong>
      ：存活对象复制到 Survivor，年龄达阈值（默认 15，
      <code>
       -XX:MaxTenuringThreshold
      </code>
      ）晋升老年代。
     </li>
    </ul>
    <h4>
     <a id="2_Full_GC_131">
     </a>
     2. Full GC
    </h4>
    <ul>
     <li>
      <strong>
       触发条件
      </strong>
      ：
      <ol>
       <li>
        <code>
         System.gc()
        </code>
        （建议性，可禁用）。
       </li>
       <li>
        老年代空间不足。
       </li>
       <li>
        方法区（元空间）不足。
       </li>
       <li>
        Minor GC 晋升平均大小超老年代剩余空间。
       </li>
       <li>
        对象大于 Survivor 和老年代可用空间。
       </li>
      </ol>
     </li>
    </ul>
    <h4>
     <a id="3__139">
     </a>
     3. 分配策略
    </h4>
    <ul>
     <li>
      <strong>
       Eden 优先
      </strong>
      ：新对象分配在 Eden。
     </li>
     <li>
      <strong>
       大对象直入老年代
      </strong>
      ：
      <code>
       -XX:PretenureSizeThreshold
      </code>
      。
     </li>
     <li>
      <strong>
       长期存活晋升
      </strong>
      ：年龄超阈值。
     </li>
     <li>
      <strong>
       动态年龄判定
      </strong>
      ：Survivor 半满时提前晋升。
     </li>
     <li>
      <strong>
       空间担保
      </strong>
      ：老年代为 Minor GC 提供担保。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_148">
     </a>
     结语
    </h3>
    <p>
     JVM 的垃圾收集机制通过可达性分析、分代收集和多样化的收集器，高效管理内存。串行适合小型应用，并行追求吞吐量，CMS 和 G1 优化停顿时间。理解 GC 原理和策略，有助于调优程序性能，避免内存溢出等问题。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36343433323130362f:61727469636c652f64657461696c732f313436313134333038" class_="artid" style="display:none">
 </p>
</div>


