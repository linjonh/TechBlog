---
layout: post
title: "-Machine-Learning-十大基本机器学习算法"
date: 2025-03-12 12:41:38 +0800
description: "十大基本机器学习算法"
keywords: "对于k类线性分类问题,下列哪种svm分类策略可以避免“投票机制”"
categories: ['科研Python相关', '研其余知识']
tags: ['算法', '机器学习', '人工智能']
artid: "146196784"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146196784
    alt: "-Machine-Learning-十大基本机器学习算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146196784
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146196784
cover: https://bing.ee123.net/img/rand?artid=146196784
image: https://bing.ee123.net/img/rand?artid=146196784
img: https://bing.ee123.net/img/rand?artid=146196784
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Machine Learning: 十大基本机器学习算法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      机器学习算法分类：
     </strong>
     监督学习、无监督学习、强化学习
    </p>
    <p>
     <strong>
      基本的机器学习算法：
     </strong>
    </p>
    <p>
     线性回归、支持向量机(SVM)、最近邻居(KNN)、逻辑回归、决策树、k平均、随机森林、朴素贝叶斯、降维、梯度增强。
    </p>
    <p>
     <img alt="" height="423" src="https://i-blog.csdnimg.cn/direct/9d526ebf497e459ba8905831a08781ae.png" width="415"/>
    </p>
    <p>
     <strong>
      机器学习算法大致可以分为三类：
     </strong>
    </p>
    <ul>
     <li>
      <em>
       监督学习算法 (Supervised Algorithms）：
      </em>
      在监督学习训练过程中，可以由训练数据集学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。该算法要求特定的输入/输出，首先需要决定使用哪种数据作为范例。例如，文字识别应用中一个手写的字符，或一行手写文字。主要算法包括神经网络、支持向量机、最近邻居法、朴素贝叶斯法、决策树等。
     </li>
     <li>
      <em>
       无监督学习算法 (Unsupervised Algorithms):
      </em>
      这类算法没有特定的目标输出，算法将数据集分为不同的组。
     </li>
     <li>
      <em>
       强化学习算法 (Reinforcement Algorithms):
      </em>
      强化学习普适性强，主要基于决策进行训练，算法根据输出结果（决策）的成功或错误来训练自己，通过大量经验训练优化后的算法将能够给出较好的预测。类似有机体在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。
     </li>
    </ul>
    <p>
     <strong>
      【一句话总结】
     </strong>
     <br/>
     监督学习：跟着老师学（有标准答案）
     <br/>
     无监督学习：自己找规律（无标准答案）
     <br/>
     强化学习：边玩边学（用奖惩调参数）
    </p>
    <hr/>
    <h3>
     1. 线性回归算法 Linear Regression
    </h3>
    <p>
     回归分析（Regression Analysis）是统计学的数据分析方法，目的在于了解两个或多个变量间是否相关、相关方向与强度，并建立数学模型以便观察特定变量来预测其它变量的变化情况。
    </p>
    <p>
     线性回归算法（Linear Regression）的建模过程就是使用数据点来寻找最佳拟合线。
    </p>
    <p>
     <img alt="" height="47" src="https://i-blog.csdnimg.cn/direct/67dcd903f63344d3abf4bcdaad361665.png" width="704"/>
    </p>
    <h3>
     2. 支持向量机算法(Support Vector Machine,SVM)
    </h3>
    <p>
     支持向量机/网络算法(SVM)属于分类型算法。SVM模型将实例表示为空间中的点，将使用一条直线分隔数据点。需要注意的是，支持向量机需要对输入数据进行完全标记，仅直接适用于两类任务，应用将多类任务需要减少到几个二元问题。   尤其在二分类任务中效果显著。
    </p>
    <p>
     <strong>
      原理
     </strong>
     ：寻找最优超平面，最大化不同类别数据间的间隔。
     <span style="color:#fe2c24">
      通过核函数（如高斯核）将数据映射到高维空间解决非线性问题。
     </span>
    </p>
    <p>
     <img alt="" height="142" src="https://i-blog.csdnimg.cn/direct/b3fb7a87af184140ae212c7e24fb380e.png" width="831"/>
    </p>
    <h3>
     3. 最近邻居/k-近邻算法 (K-Nearest Neighbors,KNN)
    </h3>
    <p>
     KNN算法基于一个非常直观的思想：对于一个未知类别的数据点，可以通过查看它在特征空间中距离最近的K个邻居的类别或数值信息，来决定该数据点的类别或预测其值。
    </p>
    <p>
     <strong>
      曼哈顿距离（街区距离）：
     </strong>
     绝对值和，L1范数
    </p>
    <p>
     <strong>
      欧氏距离（直线距离）：
     </strong>
     平方和开方， L2范数
    </p>
    <p>
     算法的主要步骤如下：
    </p>
    <p>
     <strong>
      1. 计算距离
     </strong>
     ：常用的距离度量方法有欧氏距离、曼哈顿距离等。对于一个待预测的数据点，计算它与训练集中所有数据点的距离。
    </p>
    <p>
     <strong>
      2. 选择最近邻
     </strong>
     ：根据计算得到的距离，选取距离最小的K个数据点
    </p>
    <p>
     ​
     <strong>
      优点
     </strong>
     ：无需训练，简单直观，适合多分类问题
    </p>
    <p>
     <img alt="" height="155" src="https://i-blog.csdnimg.cn/direct/4e5f05436db847babfa58ab82c645564.png" width="651"/>
    </p>
    <hr/>
    <h4>
     <strong>
      最常用的「K 折交叉验证」步骤（以 5 折为例）
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       分块
      </strong>
      ：把数据随机分成 5 份（每份叫「折」Fold）。
      <br/>
      （例：奶茶用户数据 1000 条 → 分 5 组，每组 200 条）
     </li>
     <li>
      <strong>
       循环训练
      </strong>
      ：
      <ul>
       <li>
        第 1 轮：用第 2-5 组（800 条）训练模型，测第 1 组（200 条）→ 得准确率 85%
       </li>
       <li>
        第 2 轮：用第 1,3-5 组训练，测第 2 组 → 得准确率 88%
       </li>
       <li>
        ……（重复 5 次，每轮换不同的组当测试集）
       </li>
      </ul>
     </li>
     <li>
      <strong>
       汇总结果
      </strong>
      ：5 次准确率的平均分（如 86.6%），作为模型真实水平。
     </li>
    </ol>
    <h5>
     1.
     <strong>
      k 越小：听「最铁邻居」的，可能踩坑
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       例子
      </strong>
      ：你选餐厅时，只问最近的 1 个邻居（k=1）。
      <br/>
      → 若邻居是素食者，ta推荐的素菜馆，可能不适合爱吃肉的你（
      <strong>
       过拟合
      </strong>
      ，被局部噪声带偏）。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：捕捉细节（比如小众宝藏店）。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：怕异常值（比如邻居那天心情不好乱推荐）。
     </li>
     <li>
      <strong>
       适合
      </strong>
      ：数据干净、想保留细节的场景（如手写数字识别）。
     </li>
    </ul>
    <h5>
     2.
     <strong>
      k 越大：听「全班意见」，可能平庸
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       例子
      </strong>
      ：你问全班 50 个人（k=50），最终选了评分最高的连锁餐厅。
      <br/>
      → 虽然不踩雷，但可能错过你喜欢的特色小店（
      <strong>
       欠拟合
      </strong>
      ，模糊了个体差异）。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：抗噪声（少数差评被稀释）。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：忽略局部特征（比如你家楼下的隐藏好店）。
     </li>
     <li>
      <strong>
       适合
      </strong>
      ：数据噪声大、想平滑结果的场景（如用户偏好预测）。
     </li>
    </ul>
    <h3>
     4. ​
     <strong>
      逻辑回归（Logistic Regression）​
     </strong>
    </h3>
    <p>
     <strong>
      原理
     </strong>
     ：通过Sigmoid函数将线性组合映射到[0,1]，输出概率值进行二分类，损失函数为交叉熵。参数估计使用最大似然法。
    </p>
    <p>
     <img alt="" height="212" src="https://i-blog.csdnimg.cn/direct/7647e2d05f6a4e138c8202615fd0aa03.png" width="856"/>
    </p>
    <h4>
     <strong>
      最大似然法：
     </strong>
    </h4>
    <p>
     最大似然法 =「数据侦探」
     <strong>
      核心
     </strong>
     ：根据结果反推最合理的「剧本」（参数）。
    </p>
    <p>
     最大似然法是一种基于概率模型的参数估计方法，其核心思想是
     <strong>
      通过观测数据反推最可能生成这些数据的模型参数
     </strong>
     。
    </p>
    <p>
     <img alt="" height="154" src="https://i-blog.csdnimg.cn/direct/c6f284305b944d638132f880b66e613b.png" width="606"/>
    </p>
    <hr/>
    <h3>
     5. 决策树算法 Decision Tree
    </h3>
    <p>
     决策树是通过一系列规则对数据进行分类的过程。它提供一种在什么条件下会得到什么值的类似规则的方法。
    </p>
    <p>
     决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。
    </p>
    <p>
     不同的算法（ID3、C4.5、CART）在特征选择上使用不同的指标，但递归分割数据构建决策树的基本思想是一致的。
    </p>
    <blockquote>
     <ul>
      <li>
       <span style="color:#fe2c24">
        <strong>
         信息增益（ID3 算法）：
        </strong>
       </span>
      </li>
     </ul>
     <p>
      <strong>
       信息熵
      </strong>
      ：信息熵是用来衡量数据纯度的指标，它表示数据的不确定性程度。
     </p>
     <p>
      <strong>
       信息增益
      </strong>
      ：信息增益是指在划分数据集前后信息熵的减少量，它表示使用某个特征进行划分后，数据集的纯度提高了多少。
     </p>
     <p>
      ID3 算法在构建决策树时，会选择信息增益最大的特征作为当前节点的分割特征。
     </p>
     <ul>
      <li>
       <p>
        <span style="color:#fe2c24">
         <strong>
          增益率（C4.5 算法）：
         </strong>
        </span>
       </p>
      </li>
     </ul>
     <p>
      <strong>
       信息增益存在的问题
      </strong>
      ：信息增益倾向于选择取值较多的特征，因为取值较多的特征会将数据集划分成更多的子集，从而使信息熵降低得更多。为了解决这个问题，C4.5 算法引入了增益率。
     </p>
     <p>
      C4.5 算法在构建决策树时，会选择增益率最大的特征作为当前节点的分割特征。
     </p>
     <ul>
      <li>
       <span style="color:#fe2c24">
        <strong>
         基尼指数（CART 算法）：
        </strong>
       </span>
      </li>
     </ul>
     <p>
      <strong>
       基尼指数
      </strong>
      ：基尼指数也是用来衡量数据纯度的指标，它表示从数据集中随机抽取两个样本，其类别不一致的概率。
     </p>
     <p>
      CART 算法在构建决策树时，会选择基尼指数最小的特征作为当前节点的分割特征。
     </p>
    </blockquote>
    <p>
     <strong>
     </strong>
     <span style="color:#fe2c24">
      <strong>
       原理：
      </strong>
     </span>
     递归分割数据，选择信息增益（ID3）、增益率（C4.5）或基尼指数（CART）最大的特征作为节点，生成树形结构。
    </p>
    <p>
     一棵决策树的生成过程主要分为以下3个部分：
    </p>
    <ul>
     <li>
      <strong>
       特征选择：
      </strong>
      是指从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准标准，从而衍生出不同的决策树算法。
     </li>
     <li>
      <strong>
       决策树生成：
      </strong>
      根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。 树结构来说，递归结构是最容易理解的方式。
     </li>
     <li>
      <strong>
       决策树剪枝：
      </strong>
      决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。
     </li>
    </ul>
    <p>
     <strong>
      注意
     </strong>
     ：对于那些各类别样本数量不一致的数据，在决策树当中信息增益的结果偏向于那些具有更多数值的特征。
    </p>
    <h3>
     6. k-平均算法 K-Means
    </h3>
    <p>
     k-平均算法(K-Means)是一种无监督学习算法，为聚类问题提供了一种解决方案。
     <br/>
     K-Means 算法把 n 个点（可以是样本的一次观察或一个实例）划分到 k 个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。
    </p>
    <p>
     <strong>
      原理
     </strong>
     ：通过迭代优化，将数据划分为K个簇，使簇内样本距离质心最近。
     <u>
      目标是最小化簇内平方误差。
     </u>
    </p>
    <p>
     <img alt="" height="157" src="https://i-blog.csdnimg.cn/direct/ad7354e5bf0c4ac2a1d79f6d66b08a28.png" width="971"/>
    </p>
    <h3>
     7. 随机森林算法 Random Forest
    </h3>
    <p>
     <img alt="" height="141" src="https://i-blog.csdnimg.cn/direct/dd475e65a5a14cdbb401619330fd3c5e.png" width="794"/>
    </p>
    <p>
     随机森林算法（Random Forest）的名称由 1995 年由贝尔实验室提出的random decision forests 而来，正如它的名字所说的那样
     <u>
      ，随机森林可以看作一个决策树的集合。
      <br/>
      随机森林中每棵决策树估计一个分类，这个过程称为“投票（vote）”
     </u>
     。理想情况下，
     <strong>
      我们根据每棵决策树的每个投票，选择最多投票的分类。
     </strong>
    </p>
    <p>
     <strong>
      原理
     </strong>
     ：
     <span style="color:#fe2c24">
      集成多棵决策树，通过Bagging（有放回抽样）和随机特征选择降低方差，最终投票或平均结果。
     </span>
    </p>
    <p>
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/0dccab4bebaf44939e3ec7cdcd9c1e59.png" width="950"/>
    </p>
    <h3>
     8. 朴素贝叶斯算法 Naive Bayes
    </h3>
    <p>
     朴素贝叶斯的核心思想基于贝叶斯定理，通过计算后验概率来进行分类。
     <strong>
      其“朴素”之处
     </strong>
     在于假设特征之间是条件独立的，这一假设虽然在实际应用中并不总是成立，但在许多情况下，朴素贝叶斯依然能够取得令人满意的分类效果。这使得朴素贝叶斯成为许多实际应用中的首选模型，尤其是在处理高维数据和大规模数据集时，展现出其独特的优势。
    </p>
    <p>
     贝叶斯学派（Bayesian）在概率模型的参数估计中，认为参数是未观察到的随机变量，并且可以为其假设一个先验分布（prior distribution）。然后，基于观测到的数据，通过贝叶斯定理计算参数的后验分布（posterior distribution）。
     <span style="color:#fe2c24">
      <strong>
       这一过程体现了贝叶斯统计的核心思想：
      </strong>
     </span>
     将先验知识与观测数据结合，更新对参数的信念。
    </p>
    <p>
     朴素贝叶斯是一种超级 “单纯” 的分类算法，核心思想就像 “看菜下饭”—— 通过统计 “特征组合” 出现的概率来判断类别。
    </p>
    <hr/>
    <p>
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/9f9df217af4543d3971c15fa06a9abd5.png" width="398"/>
    </p>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/fbff6a2cc3b247a7be51ff524af686ab.png" width="495"/>
    </p>
    <p>
     <img alt="" height="81" src="https://i-blog.csdnimg.cn/direct/3bca7c1934514bf4965bf92b0028e06c.png" width="757"/>
    </p>
    <p>
     <img alt="" height="270" src="https://i-blog.csdnimg.cn/direct/4963506518284f84b95d4ca70fad82dc.png" width="594"/>
    </p>
    <p>
     <img alt="" height="490" src="https://i-blog.csdnimg.cn/direct/67e6facd6934451b9ff44dd01403f2ee.png" width="565"/>
    </p>
    <p>
     <strong>
      为什么叫 “朴素”？
     </strong>
    </p>
    <p>
     因为它做了一个 “天真” 的假设：
     <strong>
      所有特征之间完全独立
     </strong>
     （比如西瓜的 “表皮” 和 “重量” 互不影响）。虽然现实中特征可能相关（比如重的西瓜可能更成熟，表皮更光滑），但这个假设让计算变得超级简单，而且在文本分类（如垃圾邮件过滤）等场景中效果惊人。
    </p>
    <p>
     朴素贝叶斯就像一个 “统计小能手”，先数清楚每个类别里各个特征出现的次数，再假设特征之间互不干扰，最后用 “概率投票” 决定新样本的类别 —— 简单粗暴，但好用！
    </p>
    <hr/>
    <h3>
     9. 降维算法 Dimensional Reduction
    </h3>
    <p>
     在机器学习和统计学领域，
     <strong>
      降维是指在限定条件下，降低随机变量个数，得到一组“不相关”主变量的过程，并可进一步细分为特征选择和特征提取两大方法。
     </strong>
    </p>
    <p>
     一些数据集可能包含许多难以处理的变量。特别是资源丰富的情况下，系统中的数据将非常详细。在这种情况下，数据集可能包含数千个变量，其中大多数变量也可能是不必要的。在这种情况下，几乎不可能确定对我们的预测影响最大的变量。此时，我们需要使用降维算法，降维的过程中也可能需要用到其他算法，
     <strong>
      例如
     </strong>
     借用随机森林，决策树来识别最重要的变量。
    </p>
    <p>
     <strong>
      原理
     </strong>
     ：减少特征数量，保留主要信息。线性方法如PCA（主成分分析）通过方差最大化投影。
    </p>
    <p>
     <strong>
      特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      ​
      <strong>
       优点
      </strong>
      ：降低计算成本，去除噪声，可视化高维数据
     </li>
     <li>
      ​
      <strong>
       缺点
      </strong>
      ：可能丢失部分信息（如PCA对非线性关系失效）
     </li>
     <li>
      <strong>
       应用
      </strong>
      ：图像压缩、数据预处理，用于特征工程阶段
     </li>
    </ul>
    <p>
     <img alt="" height="155" src="https://i-blog.csdnimg.cn/direct/38c6d8ff776c47f99980fea215374287.png" width="770"/>
    </p>
    <h3>
     10. 梯度增强算法 Gradient Boosting
    </h3>
    <p>
     梯度增强算法（Gradient Boosting）使用多个弱算法来创建更强大的精确算法。它与使用单个估计量不同，而是使用多个估计量创建一个更稳定和更健壮的算法。
    </p>
    <p>
     <strong>
      原理
     </strong>
     ：迭代训练弱学习器（通常为决策树），每轮拟合残差的负梯度，逐步减少损失函数（如MSE、交叉熵）。XGBoost、LightGBM为其优化版本。
    </p>
    <p>
     <img alt="" height="229" src="https://i-blog.csdnimg.cn/direct/4fc0f89d87bf406686204789643fe40a.png" width="986"/>
    </p>
    <p>
     ​ GBDT(Gradient Boosting Decision Tree)，全名叫
     <strong>
      梯度提升决策树
     </strong>
     ，使用的是Boosting的思想。 ​
    </p>
    <h4>
     1.1 Boosting思想
    </h4>
    <p>
     Boosting方法训练   基分类器   时采用串行的方式，各个  基分类器  之间有依赖。它的基本思路是将  基分类器  层层叠加，每一层在训练的时候，对前一层  基分类器  分错的样本，给予更高的权重。测试时，根据各层分类器的结果的加权得到最终结果。
    </p>
    <p>
     Bagging与
     <strong>
      Boosting的串行训练方式
     </strong>
     不同，Bagging方法在训练过程中，各基分类器之间无强依赖，可以进行并行训练。
    </p>
    <h4>
     1.2 GBDT原来是这么回事
    </h4>
    <p>
     GBDT的原理很简单，就是所有弱分类器的结果相加等于预测值，然后下一个弱分类器去拟合误差函数对预测值的残差(这个残差就是预测值与真实值之间的误差)。当然了，它里面的弱分类器的表现形式就是各棵树。
    </p>
    <p>
     在 GBDT 里，当我们训练完足够多的决策树后，把每棵树的预测结果累加起来，再加上最初的基础预测值，就得到了一个非常接近真实值的预测结果。
    </p>
    <h3>
     <strong>
      <span style="color:#fe2c24">
       面试常问：
      </span>
     </strong>
    </h3>
    <ul>
     <li>
      「随机森林和 GBDT 的区别？？？」—— 前者是并行投票的「佛系树群」，后者是串行纠错的「卷王树群」
     </li>
     <li>
      每个算法配一个简笔画小场景，比如 KNN 画 5 个小人围着新用户，SVM 画一条宽线隔开猫猫狗狗
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353931333934352f:61727469636c652f64657461696c732f313436313936373834" class_="artid" style="display:none">
 </p>
</div>


