---
layout: post
title: "Unity-封装一个依赖于MonoBehaviour的计时器下-链式调用"
date: 2025-03-13 14:41:45 +0800
description: "受益匪浅"
keywords: "Unity 封装一个依赖于MonoBehaviour的计时器(下) 链式调用"
categories: ['框架学习', 'Unity', 'Unity']
tags: ['游戏引擎', 'Unity']
artid: "146226517"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146226517
    alt: "Unity-封装一个依赖于MonoBehaviour的计时器下-链式调用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146226517
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146226517
cover: https://bing.ee123.net/img/rand?artid=146226517
image: https://bing.ee123.net/img/rand?artid=146226517
img: https://bing.ee123.net/img/rand?artid=146226517
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity 封装一个依赖于MonoBehaviour的计时器(下) 链式调用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/2301_77947509/article/details/146190376?spm=1001.2014.3001.5501" title="[Unity] 封装一个依赖于MonoBehaviour的计时器(上)-CSDN博客">
       [Unity] 封装一个依赖于MonoBehaviour的计时器(上)-CSDN博客
      </a>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%E5%8A%A0%E5%85%A5%E7%AD%89%E5%BE%85%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4%22%E6%B0%B8%E8%BF%9C'%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95" name="1.%E5%8A%A0%E5%85%A5%E7%AD%89%E5%BE%85%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4%22%E6%B0%B8%E8%BF%9C'%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95">
     1.加入等待间隔时间"永远'执行方法
    </h2>
    <p>
     我将这个计时器修改为了支持链式调用,不过我还是发现了一个问题,有些地方的计时器要求是这样子的
    </p>
    <pre><code class="language-cs">using UnityEngine;

public class RegularTimer : MonoBehaviour
{
    private float timer = 0f;
    public float targetTime = 5f;

    private void Update()
    {
        timer += Time.deltaTime;
        if (timer &gt;= targetTime)
        {
            // 达到目标时间，执行相应操作
            Debug.Log("Timer reached!");
            timer = 0f;
        }
    }
}</code></pre>
    <p>
     但是我的协程计时器之中并没有随游戏"无限"进行的间隔计时器
    </p>
    <p>
     所以添加了一个无限循环执行的函数
    </p>
    <pre><code class="language-cs"> #region 无限循环执行
    /// &lt;summary&gt;
    /// 按固定时间间隔无限循环执行回调
    /// &lt;/summary&gt;
    /// &lt;param name="spacing"&gt;时间间隔（秒）&lt;/param&gt;
    /// &lt;param name="callback"&gt;回调函数&lt;/param&gt;
    public void LoopForever(float spacing, Action callback)
    {
        if (CheckTime(spacing))
        {
            StartCoroutine(LoopForeverHandle(spacing, () =&gt; callback?.Invoke()));
        }
    }

    public void LoopForever&lt;T&gt;(float spacing, T param, Action&lt;T&gt; callback)
    {
        if (CheckTime(spacing))
        {
            StartCoroutine(LoopForeverHandle(spacing, () =&gt; callback?.Invoke(param)));
        }
    }

    public void LoopForever&lt;T, K&gt;(float spacing, T param1, K param2, Action&lt;T, K&gt; callback)
    {
        if (CheckTime(spacing))
        {
            StartCoroutine(LoopForeverHandle(spacing, () =&gt; callback?.Invoke(param1, param2)));
        }
    }

    private IEnumerator LoopForeverHandle(float spacing, Action action)
    {
        while (true)
        {
            yield return new WaitForSeconds(spacing);
            action?.Invoke();
        }
    }
    #endregion</code></pre>
    <h2 id="%C2%A0%20%C2%A02.%E4%BF%AE%E6%94%B9%E4%B8%BA%E6%94%AF%E6%8C%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" name="%C2%A0%20%C2%A02.%E4%BF%AE%E6%94%B9%E4%B8%BA%E6%94%AF%E6%8C%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">
     2.修改为支持链式调用
    </h2>
    <p>
     有两个要点:
    </p>
    <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" name="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" style="background-color:transparent">
     实现链式调用
    </h3>
    <p>
     先别管怎么去写 看看怎么使用
    </p>
    <pre><code class="language-cs">     TimeManager.Instance.BeginChain().WaitTime().WaitRealTime();</code></pre>
    <p>
     如果想要每一次"点"出后面的方法 要求是Instance一致
    </p>
    <p>
     所以要是方法的返回值是本身不就行了
    </p>
    <pre><code class="language-cs">    public TimeManager BeginChain()
    {
        enumeratorQ.Clear();//别管这一句
        return this;
    }</code></pre>
    <p>
     完美解决问题
    </p>
    <p>
     <img alt="" height="216" src="https://i-blog.csdnimg.cn/direct/9fb3731cb3d04f7287f1b943b7c78a85.png" width="840"/>
    </p>
    <h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%E7%AE%A1%E7%90%86%22%E9%93%BE%E5%BC%8F%22%E8%B0%83%E5%BA%A6%E9%A1%BA%E5%BA%8F" name="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%E7%AE%A1%E7%90%86%22%E9%93%BE%E5%BC%8F%22%E8%B0%83%E5%BA%A6%E9%A1%BA%E5%BA%8F">
     管理"链式"调度顺序
    </h3>
    <p>
     因为链式调用是多个且有序的,所以一定要有个容器去存储,我画个图
    </p>
    <p>
     <img alt="" height="847" src="https://i-blog.csdnimg.cn/direct/329f2c5ff9134cc2804caeb26f0c4c46.png" width="1544"/>
    </p>
    <p>
     所以有没有想起什么? 先进先出 队列不就是这样的吗?
    </p>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/2301_77947509/article/details/142185342?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522bee420fdf9fe28f0ff441dfc5bf133de%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=bee420fdf9fe28f0ff441dfc5bf133de&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-142185342-null-null.nonecase&amp;utm_term=%E9%98%9F%E5%88%97&amp;spm=1018.2226.3001.4450" title="en造数据结构与算法 c#语言 数组实现队列很难？？？看我一击破之！！！-CSDN博客">
       en造数据结构与算法 c#语言 数组实现队列很难？？？看我一击破之！！！-CSDN博客
      </a>
     </p>
    </blockquote>
    <pre><code class="language-cs">  // 链式调用的队列
  private Queue&lt;IEnumerator&gt; enumeratorQ = new Queue&lt;IEnumerator&gt;();
  private bool isChaining; // 是否正在执行队列</code></pre>
    <p>
     然后就是自己解决如何去跑了 ,很简单,有调用就入队,跑起来就出队,全权由该队列管理即可
    </p>
    <blockquote>
     <p>
     </p>
     <pre><code class="language-cs">  public TimeManager BeginChain()
  {
      enumeratorQ.Clear();
      return this;
  }

  /// &lt;summary&gt;
  /// 开始执行链式调用
  /// &lt;/summary&gt;
  private void ExecuteChain()
  {
      if (!isChaining &amp;&amp; enumeratorQ.Count &gt; 0)
      {
          StartCoroutine(RunChain());
      }
  }
  /// &lt;summary&gt;
  /// 出队跑
  /// &lt;/summary&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  private IEnumerator RunChain()
  {
      isChaining = true;
      while (enumeratorQ.Count &gt; 0)
      {
           yield return StartCoroutine(enumeratorQ.Dequeue());
      }
      isChaining = false;
  }
</code></pre>
     <pre><code class="language-cs"> public TimeManager WaitTime(float waitTime, Action callback)
 {
     if (CheckTime(waitTime))
     {
         enumeratorQ.Enqueue(WaitTimeHandle(waitTime, () =&gt; callback?.Invoke()));
         ExecuteChain();
     }
     return this;
 }</code></pre>
    </blockquote>
    <h2 id="%C2%A0%203.%E6%B5%8B%E8%AF%95%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" name="%C2%A0%203.%E6%B5%8B%E8%AF%95%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">
     3.测试
    </h2>
    <h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%8D%B3%E6%97%B6%E6%96%B9%E6%B3%95%E2%80%8B%E7%BC%96%E8%BE%91" name="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%8D%B3%E6%97%B6%E6%96%B9%E6%B3%95%E2%80%8B%E7%BC%96%E8%BE%91">
     即时方法
     <img alt="" height="701" src="https://i-blog.csdnimg.cn/direct/31f3472819df4f088c63e9ccf9a75d55.png" width="800"/>
    </h2>
    <p>
     <img alt="" height="669" src="https://i-blog.csdnimg.cn/direct/82a56ebe98434955874402ccedbfff89.png" width="752">
      <img alt="" height="274" src="https://i-blog.csdnimg.cn/direct/961aea87d573473eb4d129d0c6570bb9.png" width="646"/>
     </img>
    </p>
    <h2 id="%22%E6%B0%B8%E4%B9%85%22%E6%96%B9%E6%B3%95%C2%A0" name="%22%E6%B0%B8%E4%B9%85%22%E6%96%B9%E6%B3%95%C2%A0">
     "永久"方法
    </h2>
    <pre><code class="language-cs">   private void Start()
   {
       //1秒后执行
       TimeManager.Instance.LoopForever(1,Callback);

    
   }

   private void Callback() { 
       Debug.Log("我是哈基咩");
   }</code></pre>
    <p>
     <img alt="" height="504" src="https://i-blog.csdnimg.cn/direct/44f74a84ef064a6cb554681312c902da.gif" width="1809"/>
    </p>
    <h2 id="%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%C2%A0" name="%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%C2%A0">
     链式调用
    </h2>
    <pre><code class="language-cs">using System;
using UnityEngine;

public class Test : MonoBehaviour
{
    private void Start()
    {
        // 链式调用测试
        TimeManager.Instance.BeginChain()
            // 1秒后执行 Callback
            .WaitTime(1f, Callback)
            // 等待120帧后执行 Callback1，并传递字符串参数
            .WaitFrame&lt;string&gt;(120, "在120帧后执行", Callback1)
            // 本帧结束时执行 Callback2，传递int和string参数
            .WaitForEndOfFrame&lt;int, string&gt;(520, "在本帧调的最后执行", Callback2)
            // 等待5秒，过程中反馈进度（Progress），完成后执行 Callback
            .WaitTimeWithProgress(5f, Progress, Callback);
    }

    private void Callback()
    {
        Debug.Log("我是哈基咩");
    }

    private void Callback1(string param1)
    {
        Debug.Log($"帧：{Time.frameCount}，我是哈基咩: {param1}");
    }

    private void Callback2(int param1, string param2)
    {
        Debug.Log($"帧：{Time.frameCount}，我是哈基咩: {param1} 我是咩咩 {param2}");
    }

    private void Progress(float param1)
    {
        Debug.Log($"我是哈基咩: {param1}");
    }
}</code></pre>
    <p>
     <img alt="" height="659" src="https://i-blog.csdnimg.cn/direct/29bf264e1927440bb38dacc67c3e5194.png" width="1791"/>
    </p>
    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A04.%E6%80%BB%E7%BB%93" name="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A04.%E6%80%BB%E7%BB%93">
     <img alt="" height="187" src="https://i-blog.csdnimg.cn/direct/f9e26f3cf52b4dfba1c1219766d9aeb9.png" width="1758">
      4.总结
     </img>
    </h2>
    <p>
     这是一次很好的体验 我从来没写过链式调用的代码 原来是这么一回事
    </p>
    <p>
     同时也做好了一个计时器以后就不用在每一个需要的地方进行update里面手搓辣
    </p>
    <pre><code class="language-cs">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TimeManager : MonoBehaviour
{
    private static TimeManager instance;
    public static TimeManager Instance =&gt; instance;

    // 链式调用的队列
    private Queue&lt;IEnumerator&gt; enumeratorQ = new Queue&lt;IEnumerator&gt;();
    private bool isChaining; // 是否正在执行队列

    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
        }
    }

    public TimeManager BeginChain()
    {
        enumeratorQ.Clear();
        return this;
    }

    /// &lt;summary&gt;
    /// 开始执行链式调用
    /// &lt;/summary&gt;
    private void ExecuteChain()
    {
        if (!isChaining &amp;&amp; enumeratorQ.Count &gt; 0)
        {
            StartCoroutine(RunChain());
        }
    }
    /// &lt;summary&gt;
    /// 出队跑
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private IEnumerator RunChain()
    {
        isChaining = true;
        while (enumeratorQ.Count &gt; 0)
        {
             yield return StartCoroutine(enumeratorQ.Dequeue());
        }
        isChaining = false;
    }

    #region 检查合法
    private bool CheckCount(int count)
    {
        if (count &lt; 0)
        {
            Debug.LogError("循环次数不能为负数！");
            return false;
        }
        return true;
    }

    private bool CheckTime(float time)
    {
        if (time &lt; 0)
        {
            Debug.LogError("等待时间不能为负数！");
            return false;
        }
        return true;
    }

    #endregion

    #region 等待固定时间秒
    public TimeManager WaitTime(float waitTime, Action callback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(WaitTimeHandle(waitTime, () =&gt; callback?.Invoke()));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitTime&lt;T&gt;(float waitTime, T param, Action&lt;T&gt; callback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(WaitTimeHandle(waitTime, () =&gt; callback?.Invoke(param)));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitTime&lt;T, K&gt;(float waitTime, T param1, K param2, Action&lt;T, K&gt; callback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(WaitTimeHandle(waitTime, () =&gt; callback?.Invoke(param1, param2)));
            ExecuteChain();
        }
        return this;
    }

    private IEnumerator WaitTimeHandle(float waitTime, Action action)
    {
        yield return new WaitForSeconds(waitTime);
        action?.Invoke();
    }
    #endregion

    #region 等待固定时间秒（不受缩放影响）
    public TimeManager WaitRealTime(float waitTime, Action callback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(WaitRealTimeHandle(waitTime, () =&gt; callback?.Invoke()));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitRealTime&lt;T&gt;(float waitTime, T param, Action&lt;T&gt; callback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(WaitRealTimeHandle(waitTime, () =&gt; callback?.Invoke(param)));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitRealTime&lt;T, K&gt;(float waitTime, T param1, K param2, Action&lt;T, K&gt; callback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(WaitRealTimeHandle(waitTime, () =&gt; callback?.Invoke(param1, param2)));
            ExecuteChain();
        }
        return this;
    }

    private IEnumerator WaitRealTimeHandle(float waitTime, Action action)
    {
        yield return new WaitForSecondsRealtime(waitTime);
        action?.Invoke();
    }
    #endregion

    #region 按固定时间间隔循环执行
    /// &lt;summary&gt;
    /// 按固定时间间隔循环执行
    /// &lt;/summary&gt;
    /// &lt;param name="spacing"&gt;&lt;/param&gt;
    /// &lt;param name="overNumber"&gt;&lt;/param&gt;
    /// &lt;param name="callback"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public TimeManager LoopTime(float spacing, int overNumber, Action callback)
    {
        if (CheckTime(spacing) &amp;&amp; CheckCount(overNumber))
        {
            enumeratorQ.Enqueue(LoopTimeHandle(spacing, overNumber, () =&gt; callback?.Invoke()));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager LoopTime&lt;T&gt;(float spacing, int overNumber, T param, Action&lt;T&gt; callback)
    {
        if (CheckTime(spacing) &amp;&amp; CheckCount(overNumber))
        {
            enumeratorQ.Enqueue(LoopTimeHandle(spacing, overNumber, () =&gt; callback?.Invoke(param)));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager LoopTime&lt;T, K&gt;(float spacing, int overNumber, T param1, K param2, Action&lt;T, K&gt; callback)
    {
        if (CheckTime(spacing) &amp;&amp; CheckCount(overNumber))
        {
            enumeratorQ.Enqueue(LoopTimeHandle(spacing, overNumber, () =&gt; callback?.Invoke(param1, param2)));
            ExecuteChain();
        }
        return this;
    }

    private IEnumerator LoopTimeHandle(float spacing, int overNumber, Action action)
    {
        for (int i = 0; i &lt; overNumber; i++)
        {
            yield return new WaitForSeconds(spacing);
            action?.Invoke();
        }
    }
    #endregion

    #region 等待固定帧执行一次
    /// &lt;summary&gt;
    /// 等待固定帧执行一次
    /// &lt;/summary&gt;
    /// &lt;param name="frameCount"&gt;&lt;/param&gt;
    /// &lt;param name="callback"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public TimeManager WaitFrame(int frameCount, Action callback)
    {
        if (CheckCount(frameCount))
        {
            enumeratorQ.Enqueue(WaitFrameHandle(frameCount, () =&gt; callback?.Invoke()));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitFrame&lt;T&gt;(int frameCount, T param, Action&lt;T&gt; callback)
    {
        if (CheckCount(frameCount))
        {
            enumeratorQ.Enqueue(WaitFrameHandle(frameCount, () =&gt; callback?.Invoke(param)));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitFrame&lt;T, K&gt;(int frameCount, T param1, K param2, Action&lt;T, K&gt; callback)
    {
        if (CheckCount(frameCount))
        {
            enumeratorQ.Enqueue(WaitFrameHandle(frameCount, () =&gt; callback?.Invoke(param1, param2)));
            ExecuteChain();
        }
        return this;
    }

    private IEnumerator WaitFrameHandle(int frameCount, Action action)
    {
        for (int i = 0; i &lt; frameCount; i++)
        {
            yield return null;
        }
        action?.Invoke();
    }
    #endregion

    #region 进度反馈
    /// &lt;summary&gt;
    /// 进度反馈
    /// &lt;/summary&gt;
    /// &lt;param name="waitTime"&gt;&lt;/param&gt;
    /// &lt;param name="progressCallback"&gt;&lt;/param&gt;
    /// &lt;param name="completeCallback"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public TimeManager WaitTimeWithProgress(float waitTime, Action&lt;float&gt; progressCallback, Action completeCallback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(ProgressTimer(waitTime, progressCallback, completeCallback));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitTimeWithProgress&lt;T&gt;(float waitTime, T param, Action&lt;float, T&gt; progressCallback, Action&lt;T&gt; completeCallback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(ProgressTimer(waitTime, param, progressCallback, completeCallback));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager WaitTimeWithProgress&lt;T, K&gt;(float waitTime, T param1, K param2, Action&lt;float, T, K&gt; progressCallback, Action&lt;T, K&gt; completeCallback)
    {
        if (CheckTime(waitTime))
        {
            enumeratorQ.Enqueue(ProgressTimer(waitTime, param1, param2, progressCallback, completeCallback));
            ExecuteChain();
        }
        return this;
    }

    private IEnumerator ProgressTimer(float duration, Action&lt;float&gt; progress, Action complete)
    {
        float startTime = Time.time;
        while (Time.time - startTime &lt; duration)
        {
            progress?.Invoke((Time.time - startTime) / duration);
            yield return null;
        }
        complete?.Invoke();
    }

    private IEnumerator ProgressTimer&lt;T&gt;(float duration, T param, Action&lt;float, T&gt; progress, Action&lt;T&gt; complete)
    {
        float startTime = Time.time;
        while (Time.time - startTime &lt; duration)
        {
            progress?.Invoke((Time.time - startTime) / duration, param);
            yield return null;
        }
        complete?.Invoke(param);
    }

    private IEnumerator ProgressTimer&lt;T, K&gt;(float duration, T param1, K param2, Action&lt;float, T, K&gt; progress, Action&lt;T, K&gt; complete)
    {
        float startTime = Time.time;
        while (Time.time - startTime &lt; duration)
        {
        
            progress?.Invoke((Time.time - startTime) / duration, param1, param2);
            yield return null;
        }
        complete?.Invoke(param1, param2);
    }
    #endregion

    #region 等待当前帧结束执行回调
    /// &lt;summary&gt;
    /// 等待当前帧结束执行回调
    /// &lt;/summary&gt;
    /// &lt;param name="callback"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public TimeManager WaitForEndOfFrame(Action callback)
    {
        enumeratorQ.Enqueue(WaitForEndOfFrameHandle(callback));
        ExecuteChain();
        return this;
    }

    public TimeManager WaitForEndOfFrame&lt;T&gt;(T param, Action&lt;T&gt; callback)
    {
        enumeratorQ.Enqueue(WaitForEndOfFrameHandle(param, callback));
        ExecuteChain();
        return this;
    }

    public TimeManager WaitForEndOfFrame&lt;T, K&gt;(T param1, K param2, Action&lt;T, K&gt; callback)
    {
        enumeratorQ.Enqueue(WaitForEndOfFrameHandle(param1, param2, callback));
        ExecuteChain();
        return this;
    }

    private IEnumerator WaitForEndOfFrameHandle(Action callback)
    {
        yield return new WaitForEndOfFrame();
        callback?.Invoke();
    }

    private IEnumerator WaitForEndOfFrameHandle&lt;T&gt;(T param, Action&lt;T&gt; callback)
    {
        yield return new WaitForEndOfFrame();
        callback?.Invoke(param);
    }

    private IEnumerator WaitForEndOfFrameHandle&lt;T, K&gt;(T param1, K param2, Action&lt;T, K&gt; callback)
    {
        yield return new WaitForEndOfFrame();
        callback?.Invoke(param1, param2);
    }
    #endregion

    #region 无限循环执行 
    /// &lt;summary&gt;
    /// 放在链式的最后!
    /// &lt;/summary&gt;
    /// &lt;param name="spacing"&gt;&lt;/param&gt;
    /// &lt;param name="callback"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public TimeManager LoopForever(float spacing, Action callback)
    {
        if (CheckTime(spacing))
        {
            enumeratorQ.Enqueue(LoopForeverHandle(spacing, () =&gt; callback?.Invoke()));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager LoopForever&lt;T&gt;(float spacing, T param, Action&lt;T&gt; callback)
    {
        if (CheckTime(spacing))
        {
            enumeratorQ.Enqueue(LoopForeverHandle(spacing, () =&gt; callback?.Invoke(param)));
            ExecuteChain();
        }
        return this;
    }

    public TimeManager LoopForever&lt;T, K&gt;(float spacing, T param1, K param2, Action&lt;T, K&gt; callback)
    {
        if (CheckTime(spacing))
        {
            enumeratorQ.Enqueue(LoopForeverHandle(spacing, () =&gt; callback?.Invoke(param1, param2)));
            ExecuteChain();
        }
        return this;
    }

    private IEnumerator LoopForeverHandle(float spacing, Action action)
    {
        while (true)
        {
            yield return new WaitForSeconds(spacing);
            action?.Invoke();
            //如果前期链式调用的时候把它算进去 就会卡死掉
            if (enumeratorQ.Count &gt; 0)
                yield break;
        }
    }
    #endregion

    public void Stop(IEnumerator func)
    {
        StopCoroutine(func);
        //停止退队的时候要还一个新的回去 不然其仍在队列之中
        if (enumeratorQ.Contains(func))
        {
            var tempQueue = new Queue&lt;IEnumerator&gt;();
            while (enumeratorQ.Count &gt; 0)
            {
                IEnumerator item = enumeratorQ.Dequeue();
                if (item != func)
                {
                    tempQueue.Enqueue(item);
                }
            }
            enumeratorQ = tempQueue;
        }
    }

    public void StopAll()
    {
        StopAllCoroutines();
        enumeratorQ.Clear();
        isChaining = false;
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373934373530392f:61727469636c652f64657461696c732f313436323236353137" class_="artid" style="display:none">
 </p>
</div>


