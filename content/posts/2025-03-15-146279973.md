---
layout: post
title: "A-SURVEY-ON-POST-TRAINING-OF-LARGE-LANGUAGE-MODELS大型语言模型的训练后优化综述第一部分"
date: 2025-03-15 21:43:34 +0800
description: "大型语言模型（LLMs）的进步构成了自然语言处理（NLP）中的一个关键章节，而后训练方法作为其从通用预训练架构到特定任务自适应系统的演进中的重要催化剂。本节概述了后训练语言模型（PoLMs）的历史轨迹，追溯了它们从BERT [2] 和GPT [1] 等基础预训练里程碑发展到当代如o1 [41] 和DeepSeek-R1 [28] 等先进后训练范式的历程。图3所示的这一进程反映了从建立广泛的语言能力到增强任务特定适应性、伦理对齐、推理复杂性以及多模态集成的转变，标志着LLM能力的一次变革之旅。"
keywords: "A SURVEY ON POST-TRAINING OF LARGE LANGUAGE MODELS——大型语言模型的训练后优化综述——第一部分"
categories: ['未分类']
tags: ['语言模型', '自然语言处理', '人工智能']
artid: "146279973"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146279973
    alt: "A-SURVEY-ON-POST-TRAINING-OF-LARGE-LANGUAGE-MODELS大型语言模型的训练后优化综述第一部分"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146279973
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146279973
cover: https://bing.ee123.net/img/rand?artid=146279973
image: https://bing.ee123.net/img/rand?artid=146279973
img: https://bing.ee123.net/img/rand?artid=146279973
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     A SURVEY ON POST-TRAINING OF LARGE LANGUAGE MODELS——大型语言模型的训练后优化综述——第一部分
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     arXiv 2025
    </p>
    <p>
     摘要
    </p>
    <p>
     大型语言模型（LLMs）的出现从根本上改变了自然语言处理，使其在从对话系统到科学研究的各个领域中变得不可或缺。然而，它们的
     <span style="color:#fe2c24">
      预训练架构
     </span>
     在
     <span style="color:#fe2c24">
      特定情境下
     </span>
     经常显示出
     <span style="color:#fe2c24">
      局限性
     </span>
     ，包括
     <span style="color:#fe2c24">
      有限的推理能力、伦理不确定性以及次优的领域特定表现
     </span>
     。这些挑战要求发展先进的训练后语言模型（PoLMs）来解决这些不足，如OpenAI-o1/o3和DeepSeek-R1（统称为大型推理模型，或LRMs）。本文首次对PoLMs进行了全面综述，系统地追踪了它们在五个核心范式中的演进：
     <span style="color:#fe2c24">
      微调，以提高任务特定准确性；对齐，确保与人类偏好的伦理一致性和对齐；推理，在奖励设计面临挑战的情况下推进多步推理；效率，在复杂性增加的情况下优化资源利用；集成与适应，扩展跨多种模式的能力同时解决一致性问题。
     </span>
     从2018年ChatGPT的基础对齐策略到2025年DeepSeek-R1创新的推理进步，我们展示了
     <span style="color:#fe2c24">
      PoLMs如何利用数据集减少偏见、深化推理能力和增强领域适应性
     </span>
     。我们的贡献包括开创性的PoLM演进综合、结构化的技术与数据集分类法以及强调LRMs在提升推理能力和领域灵活性方面角色的战略议程。作为该领域的首次综述，本工作不仅整合了最近的PoLM进展，并为未来研究建立了严格的理论框架，促进在精确度、伦理稳健性和科学及社会应用多样性方面表现出色的LLM的发展。
    </p>
    <p>
     关键词：训练后优化，大型语言模型，微调，对齐，推理，效率
    </p>
    <p>
     1 引言
    </p>
    <p>
     人们普遍认为，真正的智能赋予我们推理能力，使我们能够测试假设，并为未来的各种情况做好准备。 ——Jean Khalfa，《什么是智能？》（1994）
    </p>
    <p>
     语言模型（LMs）[1, 2]代表了
     <span style="color:#fe2c24">
      旨在模拟和生成人类语言的复杂计算框架
     </span>
     。这些模型通过使机器能够以模仿人类认知的方式理解、生成并与人类语言互动，彻底改变了自然语言处理（NLP）[3]领域。与通过互动和接触上下文环境自然获得语言技能的人类不同，机器必须经过广泛的数据驱动训练才能发展出类似的能力[4]。这是一个重大的研究挑战，因为要让机器在进行自然且上下文适当的对话时理解和生成人类语言，不仅需要庞大的计算资源，还需要精细的模型开发方法[5, 6]。
    </p>
    <p>
     诸如GPT-3 [7]、InstructGPT [8]和GPT-4 [9]等大型语言模型（LLMs）的出现标志着LM演进的一个变革阶段。这些模型以其
     <span style="color:#fe2c24">
      广泛的参数化和先进的学习能力
     </span>
     著称，设计用于
     <span style="color:#fe2c24">
      捕捉大规模数据集中的复杂语言结构、上下文关系和细微模式
     </span>
     。这使得LLMs不仅能预测后续词汇，还能在翻译、问答和摘要等多种任务中生成连贯且上下文相关的文本。LLMs的发展引发了显著的学术兴趣[5, 6, 10]，可以分为两个主要阶段：预训练和训练后优化。
    </p>
    <p>
     预训练。
     <span style="color:#fe2c24">
      预训练的概念源自
     </span>
     计算机视觉（
     <span style="color:#fe2c24">
      CV
     </span>
     ）任务中的
     <span style="color:#fe2c24">
      迁移学习
     </span>
     [10]。其主要目标是使用大量数据集开发一个通用模型，便于针对各种下游应用进行轻松微调。预训练的一个重要优势在于它能利用任何未标记的文本语料库，从而提供丰富的训练数据来源。
    </p>
    <p>
     （
     <span style="color:#fe2c24">
      预训练的一个关键优势就在于此
     </span>
     ：它利用了这种容易获取的、大量的未标记文本数据作为训练资源。通过这种方式，模型可以学习到语言的基本结构、词汇的意义、句子的组成等知识，即使没有具体的任务导向标签也可以进行有效的训练。这样的训练为后续的特定任务微调打下了坚实的基础，使得模型在面对具体任务时更加高效和准确。简单来说，
     <span style="color:#fe2c24">
      就是利用丰富的未标记文本数据来提升模型的基础能力，然后再根据具体任务的需求对模型进行细化调整
     </span>
     。）
    </p>
    <p>
     然而，早期如神经网络语言模型（NNLM）[11]和Word2vec[12]这样的静态预训练方法难以适应不同的文本语义环境，促使了BERT[2]和XLNet[13]等动态预训练技术的发展。BERT通过利用变换器架构并在大规模未标记数据集上采用自注意力机制有效地解决了静态方法的局限性。这项研究确立了“预训练和微调”的学习范式，激发了许多后续研究引入了包括GPT-2[14]和BART[15]在内的多种架构。
    </p>
    <p>
     <span style="color:#fe2c24">
      在自然语言处理（NLP）中，静态和动态预训练方法的区分主要在于模型如何理解和表示文本中的上下文信息。
     </span>
    </p>
    <p>
     <strong>
      静态预训练方法
     </strong>
     ：
    </p>
    <p>
     早期的静态预训练方法如神经网络语言模型（NNLM）和Word2vec，它们通常将每个词映射到一个固定维度的向量空间中，即所谓的词嵌入（word embeddings）。这种方法生成的词向量是静态的，意味着同一个词在不同上下文中总是被表示为相同的向量。例如，“银行”这个词无论是在“河岸”的意义上还是在“金融机构”的意义上，都会有一个固定的向量表示。
     <span style="color:#fe2c24">
      这种局限性使得这些模型难以捕捉词语在不同上下文中可能具有的多种含义或语义变化。
     </span>
    </p>
    <p>
     <strong>
      动态预训练方法
     </strong>
     ：
    </p>
    <p>
     相比之下，BERT、XLNet等动态预训练技术采用了一种更先进的机制来处理文本数据。这些模型利用了变换器架构及其自注意力机制，能够根据输入文本的具体上下文动态地调整每个词的表示形式。这意味着
     <span style="color:#fe2c24">
      同一个词在不同的句子或上下文中可以有不同的向量表示
     </span>
     ，从而更好地捕捉其多义性和语境依赖性。例如，“银行”一词在提及“河岸”时和在描述“金融机构”时，在BERT或XLNet模型中会有不同的向量表示，因为模型能够理解并利用周围的上下文信息。
    </p>
    <p>
     总的来说，
     <span style="color:#fe2c24">
      静态与动态的区别在于：静态预训练方法提供的是一个固定不变的词表示，而动态预训练方法则能够基于具体的上下文环境灵活调整词的表示，以更加准确地反映词语在特定语境下的实际意义。这使得动态方法在处理复杂的语言结构和细微语义差异方面更为有效。
     </span>
    </p>
    <p>
     训练后优化。
     <span style="color:#fe2c24">
      训练后优化
     </span>
     指的是在模型完成预训练之后所采用的技术和方法，
     <span style="color:#fe2c24">
      目的是为了精炼和适应特定任务或用户需求的模型
     </span>
     。随着拥有1750亿参数的GPT-3[7]发布，训练后优化领域经历了兴趣和创新的显著增长。出现了多种
     <span style="color:#fe2c24">
      提升模型性能
     </span>
     的方法，包括
     <span style="color:#fe2c24">
      使用标记数据集
     </span>
     或
     <span style="color:#fe2c24">
      特定任务数据调整模型参数的微调
     </span>
     [16, 17]；
     <span style="color:#fe2c24">
      优化模型以更好地与用户偏好对齐的对齐策略
     </span>
     [18, 19, 20]；
     <span style="color:#fe2c24">
      使模型能够融入领域特定知识的知识适应技术
     </span>
     [21, 22]；以及
     <span style="color:#fe2c24">
      增强模型逻辑推理和决策能力的推理改进
     </span>
     [23, 24]。这些统称为训练后语言模型（PoLMs）的技术共同促成了如GPT-4[9]、LLaMA-3[25]、Gemini-2.0[26]和Claude-3.5[27]等模型的发展，标志着LLM能力的重大进步。然而，训练后的模型往往难以在没有重新训练或重大参数调整的情况下适应新任务，这使得PTM（Post-training Models）开发成为一个活跃的研究领域。
    </p>
    <p>
     正如所强调的，
     <span style="color:#fe2c24">
      预训练语言模型
     </span>
     （PLMs）主要旨在
     <span style="color:#fe2c24">
      提供通用的知识和能力
     </span>
     ，而
     <span style="color:#fe2c24">
      后训练语言模型
     </span>
     （PoLMs）
     <span style="color:#fe2c24">
      专注于将这些模型适应特定的任务和需求
     </span>
     。这种适应的一个显著例子是最新推出的大型语言模型DeepSeek-R1 [28]，它展示了PoLMs在增强推理能力、与用户偏好对齐以及提高跨领域适应性方面的演变[29]。此外，开源LLM（例如LLaMA [30]、Gemma [31]和Nemotron [32]）和领域特定大数据集（如PromptSource [33]和Flan [34]）的日益普及，正在推动学术研究人员和行业从业者开发PoLMs的趋势。这一趋势凸显了量身定制的适应在PoLMs领域中重要性的日益增长。
    </p>
    <p>
    </p>
    <hr/>
    <h5>
     <strong>
      2. Gemma（Google）
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <h5>
     <strong>
      3. Nemotron（NVIDIA）
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      二、领域特定大数据集
     </strong>
    </h4>
    <h5>
     <strong>
      1. PromptSource
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h5>
     <strong>
      2. Flan（Finetuned Language Net）
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <ol>
     <li>
      <h4>
       <strong>
        一、开源大型语言模型（LLMs）
       </strong>
      </h4>
      <h5>
       <strong>
        1. LLaMA（Large Language Model Meta AI）
       </strong>
      </h5>
     </li>
     <li>
      <p>
       <strong>
        开发背景
       </strong>
       ：
       <br/>
       由
       <span style="color:#fe2c24">
        Meta AI（原Facebook AI 扎克伯格）于2023
       </span>
       年发布，旨在提供高效、可复现的开源模型，推动学术和产业界对LLM的研究。其目标是通过较小的参数量实现接近大模型的性能，降低计算资源门槛。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          模型架构
         </strong>
         ：基于Transformer，优化了训练效率和推理速度。
        </p>
       </li>
       <li>
        <p>
         <strong>
          参数量
         </strong>
         ：提供多种版本（7B、13B、33B、65B），适应不同资源需求。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        开发背景
       </strong>
       ：
       <br/>
       <span style="color:#fe2c24">
        Google于2024
       </span>
       年发布，作为其闭源模型（如Gemini）的轻量化开源版本，旨在促进安全、负责任的人工智能开发。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          模型架构
         </strong>
         ：基于Gemini技术栈，采用MoE（Mixture of Experts）架构的轻量化变体。
        </p>
       </li>
       <li>
        <p>
         <strong>
          参数量
         </strong>
         ：提供2B（20亿）和7B（70亿）版本，注重移动端和边缘设备部署。
        </p>
       </li>
       <li>
        <p>
         <strong>
          训练数据
         </strong>
         ：多语言文本，强调数据过滤和安全性。
        </p>
       </li>
       <li>
        <p>
         <strong>
          工具链支持
         </strong>
         ：配套提供JAX、TensorFlow等框架的优化工具。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        开发背景
       </strong>
       ：
       <br/>
       NVIDIA推出的开源模型系列，
       <span style="color:#fe2c24">
        专注于生成合成数据以训练垂直领域模型（如医疗、金融），解决高质量领域数据稀缺问题。
       </span>
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          模型架构
         </strong>
         ：基于Megatron-LM框架优化，支持千亿级参数分布式训练。
        </p>
       </li>
       <li>
        <p>
         <strong>
          核心功能
         </strong>
         ：生成逼真的领域文本（如病历、法律文件），支持数据隐私合规。
        </p>
       </li>
       <li>
        <p>
         <strong>
          训练技术
         </strong>
         ：结合强化学习（RLHF）和差分隐私（DP），确保生成数据的安全性。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用场景
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         生成医疗诊断报告、金融合规文档、法律合同草案。
        </p>
       </li>
       <li>
        <p>
         数据增强，提升小样本学习效果。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数据集内容
       </strong>
       ：
       <br/>
       包含超过
       <span style="color:#fe2c24">
        20万条自然语言提示（Prompts），覆盖200+任务类型（如文本分类、摘要、问答），支持多语言。
       </span>
      </p>
     </li>
     <li>
      <p>
       <strong>
        构建目的
       </strong>
       ：
       <br/>
       统一提示工程的标准化格式，解决不同模型提示设计不一致的问题，促进可复现研究。
      </p>
     </li>
     <li>
      <p>
       <strong>
        使用方式
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         提供模板化提示生成工具，支持动态变量注入（如“{text}需分类为：{label}”）。
        </p>
       </li>
       <li>
        <p>
         用于评估模型的零样本（Zero-Shot）和小样本（Few-Shot）学习能力。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        影响力
       </strong>
       ：
       <br/>
       成为提示工程研究的基准工具，推动如T0、FLAN等模型的训练优化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据集内容
       </strong>
       ：
       <br/>
       包含1.8万个任务指令，涵盖文本生成、推理、代码生成等，每个任务附带多组输入-输出示例。
      </p>
     </li>
     <li>
      <p>
       <strong>
        构建目的
       </strong>
       ：
       <br/>
       通过指令微调（Instruction Tuning）提升模型泛化能力，使其能根据自然语言指令执行多样化任务。
      </p>
     </li>
     <li>
      <p>
       <strong>
        使用方式
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         用于微调预训练模型（如T5、PaLM），使其适应下游任务。
        </p>
       </li>
       <li>
        <p>
         支持多任务联合训练，增强模型的任务理解和迁移能力。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        影响力
       </strong>
       ：
       <br/>
       FLAN-T5、FLAN-PaLM等模型在零样本任务中表现显著优于传统微调方法，推动指令驱动的模型开发范式。
      </p>
     </li>
    </ol>
    <p>
     在现有的文献中，PLMs（预训练）已经被广泛讨论和综述[10, 35, 36, 37]，而PoLMs（后训练）很少被系统地回顾。为了推进这些技术的发展，仔细审查现有研究成果以识别关键挑战、差距和进一步改进的机会至关重要。本综述旨在通过为后训练研究中的发展提供一个结构化的框架来填补这一空白。如图1所示，它探讨了后训练的多个阶段，特别关注从ChatGPT到DeepSeek所采用的方法。这些技术涵盖了广泛的策略，包括微调、LLM对齐、推理增强和效率提升。图中的蓝色部分特别突出了由DeepSeek应用的后训练方法集合，强调了有助于其成功适应用户偏好和领域特定需求的创新策略。
     <img alt="" height="412" src="https://i-blog.csdnimg.cn/direct/e4eb1e195ac149f9a998d2a34c87ece3.png" width="1059"/>
    </p>
    <p>
     这张图展示了大型语言模型（LLMs）后训练技术的演变，从初始方法到高级方法，并特别强调了DeepSeek模型的贡献。图中分为四个主要部分：微调（Fine-Tuning）、对齐（Alignment）、推理（Reasoning）和效率（Efficiency）。以下是每个部分的详细解释：
    </p>
    <h4>
     1. 微调（Fine-Tuning）
    </h4>
    <ul>
     <li>
      <strong>
       监督微调（Supervised Fine-Tuning）
      </strong>
      ：通过标注数据对预训练模型进行进一步训练，以适应特定任务。
     </li>
     <li>
      <strong>
       强化学习微调（Reinforcement Fine-Tuning）
      </strong>
      ：使用强化学习方法来优化模型在特定任务上的表现。
     </li>
    </ul>
    <h4>
     2. 对齐（Alignment）
    </h4>
    <ul>
     <li>
      <strong>
       基于人类反馈的强化学习（Reinforcement Learning with Human Feedback）
      </strong>
      ：通过人类反馈来指导模型的优化过程。
     </li>
     <li>
      <strong>
       直接偏好优化（Direct Preference Optimization-DPO）
      </strong>
      ：直接优化模型以匹配用户的偏好。
     </li>
     <li>
      <strong>
       群体相对策略优化（Group Relative Policy Optimization）
      </strong>
      ：通过比较不同策略来优化模型的表现。
     </li>
    </ul>
    <h4>
     3. 推理（Reasoning）
    </h4>
    <ul>
     <li>
      <strong>
       自我精炼推理（Self-Refine for Reasoning）
      </strong>
      ：模型通过自我反思和改进来增强其推理能力。
     </li>
     <li>
      <strong>
       强化学习推理（Reinforcement Learning for Reasoning）
      </strong>
      ：使用强化学习方法来提升模型的推理能力。
     </li>
    </ul>
    <h4>
     4. 效率（Efficiency）
    </h4>
    <ul>
     <li>
      <strong>
       模型压缩（Model Compression）
      </strong>
      ：减少模型参数的数量，以提高计算效率。
     </li>
     <li>
      <strong>
       参数高效的微调（Parameter-Efficient Fine-Tuning）
      </strong>
      ：通过少量参数调整来优化模型，减少计算资源的需求。
     </li>
     <li>
      <strong>
       知识蒸馏（Knowledge Distillation）
      </strong>
      ：将大型模型的知识转移到较小的模型中，以提高效率和性能。
     </li>
    </ul>
    <h4>
     DeepSeek 模型的贡献
    </h4>
    <p>
     DeepSeek 模型的贡献被特别突出显示（蓝色部分），包括：
    </p>
    <ul>
     <li>
      <strong>
       强化学习推理（Reinforcement Learning for Reasoning）
      </strong>
      ：通过强化学习方法显著提升了模型的推理能力。
     </li>
     <li>
      <strong>
       参数高效的微调（Parameter-Efficient Fine-Tuning）
      </strong>
      ：通过高效微调方法提高了模型的适应性和效率。
     </li>
    </ul>
    <p>
     这些技术的发展和应用推动了LLMs在各种任务中的表现，特别是在理解和生成自然语言方面的能力。
    </p>
    <p>
     1.1 主要贡献
    </p>
    <p>
     本文是
     <span style="color:#fe2c24">
      首个关于PoLMs的综合性综述
     </span>
     ，提供了对该领域最新进展的全面、系统的探索。尽管以往的综述通常侧重于LLM发展的具体方面，如偏好对齐[38]、参数有效的微调[39]以及LLM的基础技术[40]，但它们大多集中在狭窄的子话题上。相比之下，本综述采取了一种整体的方法，完整地回顾了后训练过程中常用的核型技术，并对其进行系统分类。此外，我们调查了这些方法不可或缺的数据集和现实世界应用，如图2所示，并确定了未来研究的开放挑战和有希望的方向。本综述的主要贡献如下：
    </p>
    <p>
     <img alt="" height="619" src="https://i-blog.csdnimg.cn/direct/3334c5bf1f444d79851b0f1d124511bf.png" width="977"/>
    </p>
    <h4>
     <strong>
      1. 技术分类（Technique）5种
     </strong>
    </h4>
    <h5>
     <strong>
      (1) 微调（Fine-Tuning）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        监督微调（Supervised Fine-Tuning）
       </strong>
       <br/>
       使用标注数据调整模型参数，优化特定任务（如文本分类、问答）。
       <br/>
       <strong>
        示例
       </strong>
       ：基于法律文本微调模型，使其能生成合规合同条款。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自适应微调（Adaptive Fine-Tuning）
       </strong>
       <br/>
       动态调整训练策略（如学习率、批次大小），适配不同数据分布。
       <br/>
       <strong>
        示例
       </strong>
       ：在金融领域，根据市场数据变化自动调整模型参数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        强化微调（Reinforcement Fine-Tuning）
       </strong>
       <br/>
       结合强化学习（RL）优化模型输出，最大化奖励信号（如用户满意度）。
       <br/>
       <strong>
        示例
       </strong>
       ：对话系统通过用户反馈优化回复质量。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      (2) 推理（Reasoning）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        自我优化（Self-Refine）
       </strong>
       <br/>
       模型通过迭代生成-评估-修正循环提升输出质量。
       <br/>
       <strong>
        示例
       </strong>
       ：数学解题时，模型自动检查步骤并修正逻辑错误。
      </p>
     </li>
     <li>
      <p>
       <strong>
        基于强化学习的推理（RL for Reasoning）
       </strong>
       <br/>
       利用强化学习框架（如PPO）训练模型解决复杂推理任务。
       <br/>
       <strong>
        示例
       </strong>
       ：代码生成任务中，通过单元测试结果作为奖励信号。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      (3) 整合与适应（Integration and Adaptation）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        多模态整合（Multi-modal Integration）
       </strong>
       <br/>
       融合文本、图像、音频等多模态数据，扩展模型能力。
       <br/>
       <strong>
        示例
       </strong>
       ：医疗助手结合医学影像和文本报告生成诊断建议。
      </p>
     </li>
     <li>
      <p>
       <strong>
        领域适应（Domain Adaptation）
       </strong>
       <br/>
       将通用模型迁移到垂直领域（如法律、金融）。
       <br/>
       <strong>
        示例
       </strong>
       ：在金融领域适配模型，使其理解财报术语。
      </p>
     </li>
     <li>
      <p>
       <strong>
        模型融合（Model Merging）
       </strong>
       <br/>
       合并多个专家模型参数，提升综合性能。
       <br/>
       <strong>
        示例
       </strong>
       ：联合法律和医疗模型，处理跨领域咨询。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      (4) 对齐（Alignment）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        基于人类反馈的强化学习（RLHF）
       </strong>
       <br/>
       通过人类标注的偏好数据对齐模型输出与人类价值观。
       <br/>
       <strong>
        示例
       </strong>
       ：确保聊天机器人避免生成有害内容。
      </p>
     </li>
     <li>
      <p>
       <strong>
        基于AI反馈的强化学习（RLAIF）
       </strong>
       <br/>
       使用AI模型（如奖励模型）替代人类标注，降低成本。
       <br/>
       <strong>
        示例
       </strong>
       ：用GPT-4自动评估生成文本的安全性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        直接偏好优化（Direct Preference Optimization）
       </strong>
       <br/>
       直接优化模型输出与偏好数据的匹配度，跳过显式奖励建模。
       <br/>
       <strong>
        示例
       </strong>
       ：通过对比正负样本优化对话回复。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      (5) 效率（Efficiency）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        模型压缩（Model Compression）
       </strong>
       <br/>
       量化、剪枝等技术减少模型体积，提升推理速度。
       <br/>
       <strong>
        示例
       </strong>
       ：将70B模型量化至4bit，部署至移动端。
      </p>
     </li>
     <li>
      <p>
       <strong>
        参数高效微调（Parameter-Efficient Fine-Tuning）
       </strong>
       <br/>
       LoRA、Adapter等方法仅调整少量参数适配任务。
       <br/>
       <strong>
        示例
       </strong>
       ：使用LoRA在1%参数上微调，实现医疗问答适配。
      </p>
     </li>
     <li>
      <p>
       <strong>
        知识蒸馏（Knowledge Distillation）
       </strong>
       <br/>
       用大模型指导小模型学习，保持性能的同时降低计算成本。
       <br/>
       <strong>
        示例
       </strong>
       ：将GPT-4的知识迁移至7B模型。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      2. 数据集支持（Dataset）7类
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        对话推理（Dialogue Reasoning）
       </strong>
       <br/>
       包含多轮对话数据，用于训练逻辑连贯的对话系统（如客服机器人）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多语言（Multilingual）
       </strong>
       <br/>
       支持跨语言任务（如翻译、多语言摘要），涵盖50+语种。
      </p>
     </li>
     <li>
      <p>
       <strong>
        代码（Code）
       </strong>
       <br/>
       代码片段与注释配对数据，优化代码生成和补全能力。
      </p>
     </li>
     <li>
      <p>
       <strong>
        问答（Question-Answering）
       </strong>
       <br/>
       开放域和领域特定问答数据（如SQuAD、HotpotQA）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        文本生成（Text Generation）
       </strong>
       <br/>
       长文本生成任务数据（如故事创作、新闻撰写）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        指令遵循（Instruction Following）
       </strong>
       <br/>
       结构化指令数据（如“写一首关于春天的诗”），提升模型对复杂指令的理解。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 应用场景（Application）
     </strong>
    </h4>
    <h5>
     <strong>
      (1) 专业领域（Professional Domain）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        法律助理
       </strong>
       ：合同审查、法律条文解释。
      </p>
     </li>
     <li>
      <p>
       <strong>
        医疗健康
       </strong>
       ：病历生成、药物交互检查。
      </p>
     </li>
     <li>
      <p>
       <strong>
        金融经济
       </strong>
       ：财报分析、风险评估。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      (2) 技术与逻辑推理（Technical and Logical Reasoning）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        数学推理
       </strong>
       ：解题步骤生成、定理证明。
      </p>
     </li>
     <li>
      <p>
       <strong>
        代码生成
       </strong>
       ：根据需求自动生成可执行代码。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      (3) 理解与交互（Understanding and Interaction）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        推荐系统
       </strong>
       ：个性化内容推荐（如新闻、商品）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        语音对话
       </strong>
       ：智能助手（如Siri、Alexa）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        视频理解
       </strong>
       ：视频内容摘要、场景标注。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     该图系统化梳理了LLM训练后的核心技术路径：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        技术驱动
       </strong>
       ：通过微调、对齐和效率优化提升模型能力；
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据支撑
       </strong>
       ：多模态、多领域数据集支持技术落地；
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景导向
       </strong>
       ：从通用任务到垂直领域，覆盖法律、医疗、金融等实际需求。
       <br/>
       此框架为模型迭代和应用部署提供了方法论指导，推动LLM从实验室走向产业化。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <hr/>
    <h5>
     <strong>
      2020–2021：规模化与多任务能力
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h5>
     <strong>
      2022–2023：对齐、效率与垂直应用
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h5>
     <strong>
      2024–2025：未来趋势与前沿探索
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <h5>
     <strong>
      2. Flamingo (2022)
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <h5>
     <strong>
      3. BLIP-2 (2023)
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <h5>
     <strong>
      4. LLaVA (2023)
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      二、效率创新：专家混合（MoE）架构
     </strong>
    </h4>
    <h5>
     <strong>
      1. Switch-C Transformer (2022)
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <h5>
     <strong>
      2. Mixtral (2023)
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      三、推理增强技术
     </strong>
    </h4>
    <h5>
     <strong>
      1. 自我游戏（Self-Play）
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <h5>
     <strong>
      2. 蒙特卡洛树搜索（MCTS）与思维链（CoT）集成
     </strong>
    </h5>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      四、技术发展的整体脉络
     </strong>
    </h4>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     <strong>
      意义
     </strong>
     ：
     <br/>
     突破传统稠密模型的计算瓶颈，实现“大模型容量，小模型开销”。
    </p>
    <p>
    </p>
    <ul>
     <li>
      全面的历史综合。我们提供了首个关于PoLMs的深入综合，追溯了它们从ChatGPT最初的基于人类反馈的强化学习（RLHF）到DeepSeek-R1创新的冷启动RL方法的演变。这种综合覆盖了关键技术（即微调、对齐、推理、效率以及集成和适应），分析了它们的发展及其相关挑战，如计算复杂性和伦理考量。通过以连贯的故事形式呈现这种进步，并辅以必要的参考文献，我们为研究人员提供了近年来后训练演进的全面概览，作为该领域的基础资源。
     </li>
     <li>
      <p>
       <strong>
        结构化分类与框架
       </strong>
       ：我们提出了一个结构化的分类体系，如图2所示，将训练后方法分为五类，并将数据集分为七种类型，同时在专业、技术和交互领域中构建了应用框架。该框架明确了这些方法之间的相互关系和实际影响，为它们的发展提供了系统的视角。通过提供明确定义的类别和分析见解，我们提高了初学者和专家的可访问性和理解度，建立了一个全面的指南，以应对训练后研究的复杂性。
      </p>
     </li>
     <li>
      <h4>
       未来展望
      </h4>
     </li>
     <li>
      <p>
       <strong>
        大型推理模型的出现
       </strong>
       ：我们强调了新兴趋势，特别是大型推理模型（LRMs）的崛起，如o1和DeepSeek-R1，它们利用大规模强化学习推动推理能力的发展。我们指出，持续的技术进步对于进一步增强推理能力和领域适应性至关重要。
      </p>
     </li>
     <li>
      <p>
       <strong>
        挑战与研究方向
       </strong>
       ：我们的分析确定了关键挑战，包括可扩展性限制、道德对齐风险以及多模态集成障碍。我们提出了诸如
       <span style="color:#fe2c24">
        自适应强化学习框架
       </span>
       和
       <span style="color:#fe2c24">
        公平性感知优化
       </span>
       等研究方向。这些方向旨在推动训练后方法的发展，确保大型语言模型（LLMs）达到更高的准确性和可靠性，以满足未来的需求。
      </p>
     </li>
     <li>
      <h4>
       1.2 组织结构
      </h4>
      <p>
       本综述系统地组织以全面探索后训练语言模型（PoLMs），涵盖其历史演变、方法论、数据集、应用及未来的发展轨迹。第2节提供PoLMs的历史概览。第3节探讨微调，包括第3.1节的监督微调（SFT）和第3.3节的强化微调（RFT）。第4节讨论对齐，覆盖第4.1节基于人类反馈的强化学习（RLHF）、第4.2节基于AI反馈的强化学习（RLAIF）以及第4.3节直接偏好优化（DPO）。第5节专注于推理，包括第5.1节的自我精炼方法和第5.2节的用于推理的强化学习。第6节调查提高效率的方法，包括第6.1节的模型压缩、第6.2节参数高效的微调（PEFT）和第6.3节的知识蒸馏。第7节研究整合与适应，涉及多模态方法、领域适应和模型合并。第8节回顾了后训练中使用的数据集。第9节探索LLM的应用。第10节评估开放问题和未来方向。最后，第11节总结并展望研究前景。
      </p>
      <h4>
       2 概述
      </h4>
      <h5>
       2.1 PoLMs的历史
      </h5>
      <p>
       大型语言模型（LLMs）的进步构成了自然语言处理（NLP）中的一个关键章节，而后训练方法作为其从通用预训练架构到特定任务自适应系统的演进中的重要催化剂。本节概述了后训练语言模型（PoLMs）的历史轨迹，追溯了它们从BERT [2] 和GPT [1] 等基础预训练里程碑发展到当代如o1 [41] 和DeepSeek-R1 [28] 等先进后训练范式的历程。图3所示的这一进程反映了从建立广泛的语言能力到增强任务特定适应性、伦理对齐、推理复杂性以及多模态集成的转变，标志着LLM能力的一次变革之旅。
      </p>
     </li>
     <li>
      <p>
      </p>
      <p>
       <img alt="" height="625" src="https://i-blog.csdnimg.cn/direct/3f4dca04be4347a6be5075b439f54e17.png" width="684"/>
      </p>
      <p>
      </p>
     </li>
     <li>
      <p>
       以下是图3中关于大语言模型（LLM）训练后技术发展时间轴（2018–2025）的详细解释，涵盖关键里程碑及其技术意义：
      </p>
      <hr/>
      <h4>
       <strong>
        图3：大语言模型训练后技术发展时间轴（2018–2025）
       </strong>
      </h4>
      <p>
       该图以时间顺序展示了LLM训练后技术的演进历程，标出了从基础技术突破到未来趋势的关键节点。
      </p>
      <hr/>
      <h5>
       <strong>
        2018–2019：基础架构与初步探索
       </strong>
      </h5>
     </li>
     <li>
      <p>
       <strong>
        2018年：Transformer架构提出
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：Vaswani等人提出Transformer模型，取代RNN和CNN，成为LLM的核心架构。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：自注意力机制大幅提升模型
         <span style="color:#fe2c24">
          对长文本的理解能力
         </span>
         ，奠定后续所有LLM的基础。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        2019年：BERT与预训练范式
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：
         <span style="color:#fe2c24">
          Google发布BERT
         </span>
         （Bidirectional Encoder Representations from Transformers），首次通过掩码语言建模（MLM）实现双向上下文建模。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：开启预训练-微调（Pre-training + Fine-tuning）范式，成为NLP任务的通用解决方案。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        2020年：GPT-3发布
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：OpenAI推出
         <span style="color:#fe2c24">
          1750亿
         </span>
         参数的GPT-3，展示零样本（Zero-Shot）和小样本（Few-Shot）学习能力。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：证明模型规模与任务泛化能力的正相关性，推动大模型研究热潮。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        2021年：T5与多任务统一框架
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：
         <span style="color:#fe2c24">
          Google提出T5
         </span>
         （Text-to-Text Transfer Transformer），将分类、生成等任务统一为文本到文本的格式。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：标准化多任务训练流程，提升模型的任务适应性。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        2022年：RLHF技术成熟
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：OpenAI在InstructGPT中应用基于人类反馈的强化学习（RLHF），显著提升模型输出与人类价值观的对齐性。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：成为ChatGPT等对话模型的核心技术，解决模型安全性和可控性问题。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        2023年：参数高效微调（PEFT）兴起
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：LoRA（Low-Rank Adaptation）、Adapter等技术实现仅调整少量参数即可适配新任务。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：降低微调成本，推动LLM在边缘设备和垂直领域的落地。
        </p>
        <h4>
         LoRA（Low-Rank Adaptation）
        </h4>
        <p>
         <strong>
          LoRA
         </strong>
         是一种用于微调预训练模型的高效方法，特别是在自然语言处理（NLP）领域。它的核心思想是通过低秩矩阵分解来适应预训练模型，从而减少微调过程中需要更新的参数数量。
        </p>
       </li>
       <li>
        <h5>
         优点
        </h5>
       </li>
       <li>
        <p>
         <strong>
          参数高效
         </strong>
         ：通过低秩分解，LoRA 显著减少了需要更新的参数数量。
        </p>
       </li>
       <li>
        <p>
         <strong>
          快速微调
         </strong>
         ：由于参数数量减少，微调过程更快，计算资源需求更低。
        </p>
       </li>
       <li>
        <p>
         <strong>
          保持预训练知识
         </strong>
         ：LoRA 在微调过程中保留了预训练模型的大部分知识，避免了从头开始训练。
        </p>
       </li>
       <li>
        <h5>
         缺点
        </h5>
       </li>
       <li>
        <p>
         <strong>
          适用范围有限
         </strong>
         ：LoRA 主要适用于具有大量矩阵运算的模型，对于一些非线性或复杂结构的模型可能不适用。
        </p>
       </li>
       <li>
        <p>
         <strong>
          需要选择合适的秩
         </strong>
         ：低秩分解的秩需要仔细选择，过低的秩可能导致模型表达能力不足，过高的秩则会增加计算成本。
        </p>
       </li>
       <li>
        <p>
         <span style="color:#fe2c24">
          假设预训练模型的权重矩阵为 W，LoRA 将其分解为两个较小的矩阵 A 和 B，使得 W=W+BA。在微调过程中，只有 A 和 B 的参数会被更新，而原始的 W 保持冻结状态。
         </span>
        </p>
       </li>
       <li>
        <h4>
         Adapter
        </h4>
        <p>
         <strong>
          Adapter
         </strong>
         是另一种用于微调预训练模型的技术，它通过在预训练模型中
         <span style="color:#fe2c24">
          插入小型的、可训练的网络模块（称为 Adapter 模块）来实现模型的适应性。
         </span>
         这些 Adapter 模块通常被设计为具有少量参数的前馈神经网络。
        </p>
        <h5>
         基本原理
        </h5>
       </li>
       <li>
        <p>
         <strong>
          模块化设计
         </strong>
         ：Adapter 方法在预训练模型的每一层或特定层之后插入一个小型的、可训练的网络模块。这些模块通常由几个全连接层和非线性激活函数组成。
        </p>
       </li>
       <li>
        <p>
         <strong>
          参数冻结
         </strong>
         ：在微调过程中，预训练模型的大部分权重被冻结，
         <span style="color:#fe2c24">
          只有 Adapter 模块的权重被更新。
         </span>
         这种方法确保了预训练模型的知识被保留，同时通过 Adapter 模块适应新的任务。
        </p>
       </li>
       <li>
        <h5>
         优点
        </h5>
       </li>
       <li>
        <p>
         <strong>
          参数高效
         </strong>
         ：Adapter 方法通过冻结预训练模型的大部分权重，仅更新少量的 Adapter 参数，从而实现高效的参数利用。
        </p>
       </li>
       <li>
        <p>
         <strong>
          灵活性高
         </strong>
         ：Adapter 模块可以根据不同的任务进行定制，提供了很高的灵活性。
        </p>
       </li>
       <li>
        <p>
         <strong>
          保留预训练知识
         </strong>
         ：由于大部分预训练权重被冻结，Adapter 方法能够很好地保留预训练模型的知识。
        </p>
       </li>
       <li>
        <h5>
         缺点
        </h5>
       </li>
       <li>
        <p>
         <strong>
          模块设计复杂
         </strong>
         ：设计有效的 Adapter 模块需要一定的专业知识，不同的任务可能需要不同的模块设计。
        </p>
       </li>
       <li>
        <p>
         <strong>
          计算开销
         </strong>
         ：虽然 Adapter 模块本身参数较少，但在前向和后向传播过程中会增加一定的计算开销。
        </p>
       </li>
       <li>
        <h5>
         应用场景
        </h5>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        2023年：多模态整合突破
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          技术内容
         </strong>
         ：GPT-4、Flamingo等模型支持文本、图像、音频的联合理解与生成。
        </p>
       </li>
       <li>
        <p>
         <strong>
          意义
         </strong>
         ：扩展LLM应用场景至跨模态任务（如医疗影像报告生成）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <span style="color:#fe2c24">
        <strong>
         2024年：AI反馈强化学习（RLAIF）
        </strong>
       </span>
      </p>
      <ul>
       <li>
        <p>
         <span style="color:#fe2c24">
          <strong>
           技术内容
          </strong>
          ：利用AI模型（如奖励模型）替代人类标注，实现自动化对齐。
         </span>
        </p>
       </li>
       <li>
        <p>
         <span style="color:#fe2c24">
          <strong>
           意义
          </strong>
          ：降低RLHF成本，推动模型在低资源场景的应用。
         </span>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <span style="color:#fe2c24">
        <strong>
         2025年：超高效模型压缩与部署
        </strong>
       </span>
      </p>
      <ul>
       <li>
        <p>
         <span style="color:#fe2c24">
          <strong>
           技术内容
          </strong>
          ：1-bit量化、动态稀疏训练等技术将千亿模型压缩至移动端可运行。
         </span>
        </p>
       </li>
       <li>
        <p>
         <span style="color:#fe2c24">
          <strong>
           意义
          </strong>
          ：实现LLM在物联网设备和实时系统中的普及。
         </span>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <span style="color:#fe2c24">
        <strong>
         2025年：通用人工智能（AGI）初步探索
        </strong>
       </span>
      </p>
      <ul>
       <li>
        <p>
         <span style="color:#fe2c24">
          <strong>
           技术内容
          </strong>
          ：模型通过自我优化（Self-Refine）和世界模型（World Models）实现复杂推理与规划能力。
         </span>
        </p>
       </li>
       <li>
        <p>
         <span style="color:#fe2c24">
          <strong>
           意义
          </strong>
          ：迈向具备通用问题解决能力的下一代AI系统。
         </span>
        </p>
       </li>
       <li>
        <p>
        </p>
        <p>
         以下是关于
         <strong>
          1-bit量化
         </strong>
         和
         <strong>
          动态稀疏训练
         </strong>
         两种技术的详细讲解，涵盖其原理、实现方法、应用场景及挑战：
        </p>
        <hr/>
        <h4>
         <strong>
          1. 1-bit量化（1-Bit Quantization）
         </strong>
        </h4>
        <h5>
         <strong>
          1.1 基本原理
         </strong>
        </h5>
        <p>
         1-bit量化是一种极端的模型压缩技术，将神经网络中的
         <span style="color:#fe2c24">
          权重或激活值从高精度（如32位浮点）压缩到仅用
          <strong>
           1位
          </strong>
          表示（通常为
          <strong>
           +1
          </strong>
          或
          <strong>
           -1
          </strong>
          ）。其核心思想是通过二值化大幅减少模型体积和计算开销，同时保持一定的性能。
         </span>
        </p>
       </li>
       <li>
        <h5>
         <strong>
          1.3 应用场景
         </strong>
        </h5>
       </li>
       <li>
        <p>
         <strong>
          边缘设备部署
         </strong>
         ：
         <br/>
         适用于手机、IoT设备等资源受限场景，如二值化ResNet在图像分类中的部署。
        </p>
       </li>
       <li>
        <p>
         <strong>
          大规模模型压缩
         </strong>
         ：
         <br/>
         <span style="color:#fe2c24">
          将千亿参数模型压缩至原体积的1/32，显著降低存储和传输成本
         </span>
         。
        </p>
       </li>
       <li>
        <hr/>
        <h4>
         <strong>
          2. 动态稀疏训练（Dynamic Sparse Training）
         </strong>
        </h4>
        <h5>
         <strong>
          2.1 基本原理
         </strong>
        </h5>
        <p>
         动态稀疏训练在训练过程中
         <strong>
          动态调整网络的稀疏性
         </strong>
         ，即根据权重的重要性自动决定保留或剪枝某些连接。与传统静态剪枝不同，动态稀疏允许网络在训练中逐步优化稀疏结构。
        </p>
       </li>
       <li>
        <p>
         <strong>
          稀疏模式动态调整
         </strong>
         ：
         <br/>
         每个训练步骤中，根据权重的显著性（如梯度或绝对值大小）动态选择保留的权重。
        </p>
       </li>
       <li>
        <p>
         <strong>
          自适应稀疏率
         </strong>
         ：
         <br/>
         可设定动态变化的稀疏率（如从高密度逐步增加稀疏性），平衡训练稳定性和模型轻量化。
        </p>
       </li>
       <li>
        <p>
         <strong>
          高效训练大规模模型
         </strong>
         ：
         <br/>
         减少训练时的内存和计算开销，如动态稀疏Transformer训练。
        </p>
       </li>
       <li>
        <p>
         <strong>
          结果
         </strong>
         ：
         <br/>
         训练内存减少40%，精度与稠密模型相当。
        </p>
       </li>
       <li>
        <hr/>
        <h4>
         <strong>
          3. 技术对比与结合
         </strong>
        </h4>
        <table>
         <thead>
          <tr>
           <th>
            <strong>
             技术
            </strong>
           </th>
           <th>
            <strong>
             优势
            </strong>
           </th>
           <th>
            <strong>
             局限性
            </strong>
           </th>
           <th>
            <strong>
             结合潜力
            </strong>
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td>
            <strong>
             1-bit量化
            </strong>
           </td>
           <td>
            极致压缩（1/32体积）、计算加速（位运算）
           </td>
           <td>
            精度损失显著，需复杂训练策略
           </td>
           <td>
            与知识蒸馏结合，补偿精度损失
           </td>
          </tr>
          <tr>
           <td>
            <strong>
             动态稀疏训练
            </strong>
           </td>
           <td>
            自适应稀疏结构、保持模型性能
           </td>
           <td>
            训练复杂度高，需专用优化器
           </td>
           <td>
            与量化结合，实现“稀疏+低比特”压缩
           </td>
          </tr>
         </tbody>
        </table>
       </li>
      </ul>
     </li>
     <li>
      <p>
       现代
       <span style="color:#fe2c24">
        PoLMs的历史
       </span>
       起始于
       <span style="color:#fe2c24">
        2018年的预训练革命
       </span>
       ，由
       <span style="color:#fe2c24">
        BERT [2] 和GPT [1] 的发布所标志
       </span>
       ，重新定义了NLP基准。
       <span style="color:#fe2c24">
        BERT的双向自动编码框架
       </span>
       利用变换器架构和自注意力机制，在捕捉上下文相互依赖性方面表现出色，
       <span style="color:#fe2c24">
        适用于问答
       </span>
       等任务；而
       <span style="color:#fe2c24">
        GPT的自回归设计则优先考虑生成连贯性，为文本生成树立了先例
       </span>
       。这些模型建立了“预训练和微调”的范式，并通过
       <span style="color:#fe2c24">
        T5 [42] 在2019年
       </span>
       的后续改进得到了统一，将多样化的任务置于一个文本到文本的框架下，促进了多任务学习，并为后训练进步奠定了坚实的基础。
      </p>
      <p>
       自2020年起，随着高效适应有限数据的各种任务的需求增长，PoLMs的格局开始显著演变。早期创新如前缀调整 [43] 和提示调整 [44] 引入了轻量级适应策略，通过修改模型输入而非重新训练整个架构来实现多任务灵活性，从而节省计算资源同时拓宽适用范围。在此期间，随着
       <span style="color:#fe2c24">
        2021年基于人类反馈的强化学习（RLHF）[45] 的出现
       </span>
       ，也见证了向用户中心优化的关键转变，
       <span style="color:#fe2c24">
        该技术利用人类评价使模型输出与主观偏好对齐，提高了对话环境中的实用性
       </span>
       。到2022年，通过采用近端策略优化（PPO）[46]，RLHF成熟起来，改善了对齐稳定性和缓解了对噪声反馈的过拟合。ChatGPT在2022年末的发布 [9] 巩固了这些进展，展示了RLHF在创建响应迅速、用户对齐的LLM方面的变革潜力，并激发了PoLMs研究的激增。与此同时，思维链（CoT）提示 [47] 作为一种推理增强策略出现，鼓励模型在复杂任务中阐述中间步骤，从而提高透明度和准确性，特别是在逻辑推理和问题解决领域。
      </p>
      <p>
       在2022年至2024年间，PoLMs多元化以应对领域特异性、伦理稳健性和多模态集成，反映出LLM细化的日益精细化的方法。
       <span style="color:#fe2c24">
        领域适应技术，如检索增强生成（RAG）[48] 出现，整合外部知识库，无需完全重新训练即可实现针对专门领域的上下文丰富输出
       </span>
       ——这是需要最新信息的专业应用的一个关键进步。伦理对齐努力加强，
       <span style="color:#fe2c24">
        2023年的直接偏好优化（DPO）[49] 简化了RLHF，通过直接优化模型输出以符合人类偏好，绕过了中间奖励建模，增强了效率和稳健性
       </span>
       。同时，追求多模态能力获得动力，PaLM-E [50] 和Flamingo [51] 等模型开创了视觉-语言集成，随后BLIP-2 [52] 和LLaVA [53] 将这些努力扩展到更广泛的领域，如医学成像。效率创新与这些发展并行，最显著的是专家混合（MoE）架构；谷歌的Switch-C Transformer [54] 在2022年引入了跨2048个专家激活1.6万亿参数的稀疏激活，而Mixtral [55] 改进了这一范式，平衡了可扩展性和性能。在此期间，推理增强，例如自我游戏 [56] 和蒙特卡洛树搜索（MCTS）与CoT的集成 [57]，通过模拟迭代推理路径进一步增强了LLMs的决策能力，为高级推理聚焦型模型奠定了基础。
      </p>
     </li>
     <li>
      <h4>
       <strong>
        一、多模态模型的演进
       </strong>
      </h4>
      <h5>
       <strong>
        1. PaLM-E (2023)
       </strong>
      </h5>
     </li>
     <li>
      <p>
       <strong>
        背景
       </strong>
       ：
       <br/>
       由Google开发，基于其大语言模型PaLM，通过集成视觉编码器实现多模态理解。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          视觉-语言联合训练
         </strong>
         ：将图像特征与文本序列嵌入同一空间，支持跨模态推理（如根据图像生成描述）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          参数规模
         </strong>
         ：最大版本达5620亿参数，覆盖视觉问答、机器人控制等任务。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用
       </strong>
       ：
       <br/>
       机器人自主操作（如根据指令抓取物体）、多模态对话系统。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       首次将大规模语言模型与视觉感知深度融合，推动具身智能（Embodied AI）的发展。
      </p>
     </li>
     <li>
      <p>
       <strong>
        背景
       </strong>
       ：
       <br/>
       谷歌的DeepMind实验室提出的多模态模型，专注于少样本学习（Few-Shot Learning）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          交叉注意力机制
         </strong>
         ：通过可学习的视觉-文本交互模块，动态对齐图像与文本特征。
        </p>
       </li>
       <li>
        <p>
         <strong>
          上下文学习
         </strong>
         ：支持通过少量示例（如3-5张图）快速适应新任务（如医疗影像分类）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用
       </strong>
       ：
       <br/>
       视频理解、跨模态检索（如根据文本描述搜索图像）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       解决传统多模态模型对大规模标注数据的依赖，提升模型灵活性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        背景
       </strong>
       ：
       <br/>
       由Salesforce Research推出，专注于高效多模态预训练。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          两阶段训练
         </strong>
         ：
        </p>
        <ol>
         <li>
          <p>
           <strong>
            视觉-语言对齐
           </strong>
           ：冻结视觉编码器和语言模型，仅训练轻量级适配器。
          </p>
         </li>
         <li>
          <p>
           <strong>
            端到端微调
           </strong>
           ：联合优化所有参数适配下游任务。
          </p>
         </li>
        </ol>
       </li>
       <li>
        <p>
         <strong>
          医学扩展
         </strong>
         ：引入医疗影像数据集（如MIMIC-CXR），支持X光片诊断报告生成。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用
       </strong>
       ：
       <br/>
       医学影像分析、放射科辅助诊断。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       降低多模态训练成本，推动AI在医疗领域的落地。
      </p>
     </li>
     <li>
      <p>
       <strong>
        背景
       </strong>
       ：
       <br/>
       由微软研究院开发，基于LLaMA的轻量化多模态模型。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          视觉指令微调
         </strong>
         ：通过合成数据（如GPT-4生成的图像-文本对）训练模型遵循复杂指令。
        </p>
       </li>
       <li>
        <p>
         <strong>
          高效架构
         </strong>
         ：使用线性投影层将图像特征映射到文本嵌入空间，减少计算开销。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用
       </strong>
       ：
       <br/>
       教育辅助（如根据图表解释物理原理）、工业质检（图像缺陷描述）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       证明小模型通过高质量合成数据可实现媲美大模型的多模态能力。
      </p>
     </li>
     <li>
      <p>
       <strong>
        背景
       </strong>
       ：
       <br/>
       <span style="color:#fe2c24">
        Google提出的稀疏激活MoE架构
       </span>
       ，旨在提升模型容量同时控制计算成本。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          动态路由
         </strong>
         ：每个输入token仅激活部分专家（如1-2个），减少计算量。
        </p>
       </li>
       <li>
        <p>
         <strong>
          参数规模
         </strong>
         ：包含2048个专家，总参数量达1.6万亿，但每次推理仅激活约1000亿参数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用
       </strong>
       ：
       <br/>
       大规模语言模型训练（如对话系统、文档生成）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        背景
       </strong>
       ：
       <br/>
       Mistral AI基于Switch-C的改进版本，优化专家选择策略。
      </p>
     </li>
     <li>
      <p>
       <strong>
        技术特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          均衡负载
         </strong>
         ：通过负载均衡损失函数，避免专家使用不均导致的性能下降。
        </p>
       </li>
       <li>
        <p>
         <strong>
          灵活部署
         </strong>
         ：支持动态调整激活专家数量，适配不同硬件资源。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用
       </strong>
       ：
       <br/>
       边缘设备上的实时翻译、个性化推荐系统。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       在保持性能的同时提升模型的可扩展性和部署效率。
      </p>
     </li>
     <li>
      <p>
       <strong>
        原理
       </strong>
       ：
       <br/>
       模型通过与环境或自身对抗生成训练数据，迭代优化策略（如AlphaGo的自我对弈）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        在LLM中的应用
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          合成数据生成
         </strong>
         ：模型生成问题-答案对，用于后续微调。
        </p>
       </li>
       <li>
        <p>
         <strong>
          对抗训练
         </strong>
         ：通过生成对抗样本提升鲁棒性（如防御提示注入攻击）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        案例
       </strong>
       ：
       <br/>
       OpenAI使用自我游戏训练GPT-4的数学推理能力。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       减少对人工标注的依赖，增强模型的复杂问题解决能力。
      </p>
     </li>
     <li>
      <p>
       <strong>
        原理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          MCTS
         </strong>
         ：通过模拟多条推理路径，选择最优解（如AlphaGo的决策过程）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          CoT
         </strong>
         ：引导模型生成逐步推理的中间步骤（如“先计算A，再推导B”）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结合方式
       </strong>
       ：
       <br/>
       在生成CoT时，使用MCTS评估不同推理路径的可靠性，选择置信度最高的路径。
      </p>
     </li>
     <li>
      <p>
       <strong>
        案例
       </strong>
       ：
       <br/>
       在数学解题中，模型生成多个解法路径，通过MCTS选择最可能正确的答案。
      </p>
     </li>
     <li>
      <p>
       <strong>
        意义
       </strong>
       ：
       <br/>
       提升模型在开放域推理任务中的准确性和可解释性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多模态融合
       </strong>
       ：
       <br/>
       从PaLM-E的视觉-语言联合训练，到LLaVA的轻量化指令微调，逐步实现跨模态任务的通用化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        效率突破
       </strong>
       ：
       <br/>
       MoE架构（如Switch-C、Mixtral）通过稀疏激活平衡模型容量与计算成本，推动LLM的规模化应用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        推理增强
       </strong>
       ：
       <br/>
       自我游戏和MCTS-CoT集成赋予模型更接近人类的复杂决策能力，为医疗诊断、自动驾驶等高风险场景奠定基础。
      </p>
     </li>
    </ul>
    <h4>
     专家混合（MoE）模型的重要架构进步
    </h4>
    <p>
     随着专家混合（MoE）模型的兴起，出现了一种重要的架构进步。这种模
     <span style="color:#fe2c24">
      型通过动态激活选择性的参数子集来优化计算效率，同时适应庞大的参数规模，从而与传统的密集架构区分开来
     </span>
     。这一范式由谷歌的
     <span style="color:#fe2c24">
      Switch-C Transformer [54] 在2022年开创
     </span>
     ，该模型拥有分布在2048个专家中的1.6万亿个参数，提供了一种
     <span style="color:#fe2c24">
      平衡资源需求和性能增益
     </span>
     的突破性方法。后续迭代如Mixtral [55] 和DeepSeek V2.5 [58] 进一步完善了这一框架——后者利用总共2360亿个参数，其中活跃于160个专家中的有210亿个参数，在LMSYS基准上取得了最先进的结果，并证明
     <span style="color:#fe2c24">
      稀疏MoE架构在可扩展性和效能方面可以与密集模型相匹敌
     </span>
     。这些发展标志着向以效率为中心的PoLMs转变，使得LLMs能够以减少的计算开销处理复杂任务，这是扩大其实际应用范围的关键步骤。到2025年，DeepSeek-R1 [28] 成为了PoLMs创新的一个里程碑，它从依赖传统的监督微调（SFT）转向采用思维链（CoT）推理和探索性的RL策略。DeepSeek-R1-Zero模型集成自我验证、反思和扩展的CoT生成，验证了开放研究范式中的RL驱动推理激励，引入蒸馏技术[28]将复杂的推理模式从更大架构转移到更小的架构。这种方法不仅相比独立的RL训练提供了优越的性能，还预示着一种面向LLMs的可扩展、以推理为中心的新范式，旨在解决后训练方法中持续存在的计算效率和任务适应性挑战。
    </p>
    <h4>
     2.2 PoLMs的公式基础
    </h4>
    <h5>
     2.2.1 策略优化原理
    </h5>
    <p>
     <span style="color:#fe2c24">
      近端策略优化（PPO）算法
     </span>
     [46]是一种关键的强化学习技术，特别适用于基于人类反馈的强化学习（RLHF）[45]等环境，其中保持稳定性和效率是至关重要的。PPO通过
     <strong>
      限制策略更新的大小
     </strong>
     来实现这些目标，确保
     <span style="color:#fe2c24">
      对模型行为的改变是渐进且受控的
     </span>
     ，从而防止性能出现灾难性的变化。这对于微调大规模语言模型尤其重要，因为
     <span style="color:#fe2c24">
      剧烈的策略更新可能导致不希望或不可预测的行为
     </span>
     。
     <img alt="" height="301" src="https://i-blog.csdnimg.cn/direct/d15e1ebd688c4f0eaa79cf4225a7d331.png" width="1111">
      <img alt="" height="246" src="https://i-blog.csdnimg.cn/direct/e97978cdbb0f43d7997bab159ae0656e.png" width="1114">
       <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/3ec1ab7e690f4cfe8b790e7dc10e10b9.png" width="1102"/>
      </img>
     </img>
    </p>
    <h4>
     2.2.2 基于人类反馈的强化学习（RLHF）原理
    </h4>
    <p>
     基于人类反馈的强化学习（RLHF）是一种利用学习过程中人类生成的反馈来使模型与人类偏好对齐的关键方法。这种方法包含一个明确捕捉人类输入的奖励函数，使得模型能够更好地适应用户偏好和实际应用。
     <img alt="" height="390" src="https://i-blog.csdnimg.cn/direct/fd7a246991a04ce1a5ad3b441584be29.png" width="1085"/>
    </p>
    <h4>
     2.2.3 直接偏好优化（DPO）原理
    </h4>
    <p>
     直接偏好优化（DPO）通过直接基于人类偏好优化模型输出而建立在RLHF之上，这些偏好通常以成对比较的形式表达。DPO消除了传统奖励函数的需求，而是专注于通过最大化基于偏好的奖励来优化模型行为。
    </p>
    <p>
     <img alt="" height="384" src="https://i-blog.csdnimg.cn/direct/2e1a495ae61a4c56809b54ab19b04586.png" width="1101"/>
    </p>
    <h4>
     2.2.4 群相对策略优化（GRPO）原理
    </h4>
    <p>
     群相对策略优化（GRPO）算法是强化学习中Proximal Policy Optimization（PPO）算法的一个变种，首次在DeepSeek之前的工作DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models [64]中提出。GRPO省略了批评模型，而是使用组分数估计基线，这相比PPO显著减少了训练资源消耗。
    </p>
    <p>
     <img alt="" height="302" src="https://i-blog.csdnimg.cn/direct/1951d497b7da44d588d59c8fa0baf15a.png" width="1132"/>
    </p>
    <h4>
     3 大型语言模型的微调
    </h4>
    <p>
     微调是将预训练的大型语言模型（LLMs）适应于特定任务的关键步骤，通过有针对性的参数调整来提升它们的能力。这一过程利用
     <strong>
      标记或特定任务的数据集
     </strong>
     来优化性能，弥合通用预训练与领域特定需求之间的差距。本章探讨了三种主要的微调范式：监督微调（§3.1），它使用注释数据集提高特定任务的准确性；自适应微调（§3.2），通过指令调优和基于提示的方法定制模型行为；以及强化微调（§3.3），它集成强化学习根据奖励信号迭代地细化输出，通过动态交互促进持续改进。
    </p>
    <h5>
     3.1 监督微调
    </h5>
    <p>
     监督微调（SFT）[45]通过利用特定任务的标记数据集将预训练的LLM适配到特定任务上。不同于依赖指令提示的指令调优，SFT直接使用标注数据调整模型参数，产生既精确又上下文敏感同时保留广泛泛化能力的模型。
     <strong>
      SFT弥合了预训练期间编码的广阔语言知识与目标应用的细微需求之间的鸿沟[36]
     </strong>
     。通过接触庞大的语料库，预训练的LLM获得了通用的语言模式，减少了对大量领域特定数据进行微调的依赖性。模型选择至关重要：在资源受限且数据集有限的情况下，较小的模型如T5 [42]表现优异，而较大的模型如GPT-4 [9]则凭借其优越的容量在复杂、数据丰富的任务中脱颖而出。
    </p>
    <p>
     这种微调方法使得预训练模型能够更加准确地理解和执行特定任务的要求，同时保持其在更广泛的应用场景中的有效性。通过这种方式，监督微调不仅增强了模型的专门能力，还确保了其在处理多样化任务时的有效性和灵活性。这种方法对于需要高精度和上下文理解的任务尤为重要，例如文本分类、情感分析、问答系统等。此外，通过合理选择模型大小和架构，可以根据具体应用场景的需求优化资源利用效率和性能表现。
    </p>
    <h4>
     3.1.1 监督微调（SFT）数据集准备
    </h4>
    <p>
     构建高质量的SFT数据集是一个多方面的过程，对于微调成功至关重要。
    </p>
    <p>
     <img alt="" height="310" src="https://i-blog.csdnimg.cn/direct/423eda0cfd7048a08c5e52a75be46d17.png" width="1111"/>
    </p>
    <h4>
     表1：2018至2025年间各大组织发布的预训练大型语言模型概览
    </h4>
    <p>
     此表详细列出了Meta、DeepSeek、OpenAI及其他实体的关键模型，包括它们的参数规模、训练数据量（已报告的情况下）、开源状态及发布时间线。开源状态用¥表示那些研究界可公开访问的模型，用q表示闭源专有模型。
     <img alt="" height="679" src="https://i-blog.csdnimg.cn/direct/de2d9162463743c3b74cbb44d96347a9.png" width="664"/>
    </p>
    <p>
     由于具体的表格内容没有给出，我提供了一个概括性的描述。实际的表格会列出不同组织发布的各种模型的具体信息，比如模型名称、参数数量、使用的训练数据规模、是否开源以及发布日期等细节。这些信息对于了解各组织在大型语言模型领域的贡献及其发展进程非常有用。
    </p>
    <h4>
     指令-实例对筛选与评估
    </h4>
    <p>
     <img alt="" height="239" src="https://i-blog.csdnimg.cn/direct/f9804df2e50c419893c56d2dbe16a566.png" width="1101"/>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       SFT数据集评估
      </span>
     </strong>
     ：评估SFT数据集涉及选择一个高质量子集Deval
     <img alt="" height="37" src="https://i-blog.csdnimg.cn/direct/4c8f846c4563460a8d8738c244fda043.png" width="67"/>
     ，作为模型性能的基准。此子集可以从精选数据集D′中抽样获得，也可以从独立部分派生以确保公正性。传统的SFT评估方法，如Few-Shot GPT [7]和微调策略[89]，都是资源密集型的，而
     <span style="color:#fe2c24">
      <strong>
       指令挖掘
      </strong>
     </span>
     [90]提供了一个更高效的替代方案。
     <strong>
      指令挖掘使用线性质量规则和一系列度量来测量数据集质量，如响应长度和平均奖励模型分数[65]，以评估这些度量与整体数据集质量之间的相关性。
     </strong>
    </p>
    <p>
     通过这种方式，不仅可以提高数据集的质量，还能更加有效地利用资源进行模型训练和评估。这种方法对于确保最终模型能够准确理解并执行特定任务至关重要，尤其是在面对多样化的应用场景时。此外，通过采用更为智能的数据筛选和评估技术，可以显著提升大型语言模型的适应性和实用性。
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/043617879724425d81a0401aab4602c4.png" width="942"/>
    </p>
    <h4>
     详细讲解监督微调（Supervised Fine-Tuning）过程
    </h4>
    <h5>
     图4: 监督微调的过程
    </h5>
    <p>
     监督微调是将预训练的大型语言模型（LLM）适配到特定任务的关键步骤。以下是图4中展示的监督微调过程的详细讲解：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        原始数据和知识
       </strong>
       ：
      </p>
      <ul>
       <li>
        <strong>
         原始数据
        </strong>
        ：包括文本、表格、图像等不同类型的数据，这些数据构成了预训练阶段的基础。
       </li>
       <li>
        <strong>
         知识
        </strong>
        ：通过特定处理（如标注、清洗等）将原始数据转化为可用于训练的知识。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        预训练（Pre-training）
       </strong>
       ：
      </p>
      <ul>
       <li>
        预训练模型（Base LLM）通过大量的原始数据进行训练，学习通用的语言模式和结构。这一阶段的目标是让模型具备广泛的语言理解和生成能力。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        监督微调（Supervised Fine-Tuning）
       </strong>
       ：
      </p>
      <ul>
       <li>
        在预训练模型的基础上，通过使用标记数据集进行监督微调。这些数据集包含具体的指令-实例对，用于指导模型如何执行特定任务。
       </li>
       <li>
        微调过程中，模型参数根据标记数据进行调整，以提高在特定任务上的表现。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        微调后的模型（Fine-Tuned LLM）
       </strong>
       ：
      </p>
      <ul>
       <li>
        经过监督微调后，模型能够更好地理解和执行特定任务。微调后的模型保留了预训练模型的泛化能力，同时增强了对特定任务的理解和执行能力。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        任务应用
       </strong>
       ：
      </p>
      <ul>
       <li>
        <strong>
         问答（Question Answering）
        </strong>
        ：模型能够回答具体问题，提供准确的答案。
       </li>
       <li>
        <strong>
         文本分类（Text Classification）
        </strong>
        ：模型能够对文本进行分类，识别不同的文本类别。
       </li>
       <li>
        <strong>
         信息检索（Information Retrieval）
        </strong>
        ：模型能够从大量文档中检索相关信息。
        <h4>
         3.1.2 监督微调（SFT）的过程
        </h4>
        <p>
         如图4所示，一旦数据集准备完毕，微调过程就开始了。这个过程首先使用一个通常通过大规模原始数据的无监督或自我监督预训练得到的预训练大型语言模型（LLM）。预训练阶段的目标是获取适用于各种任务的一般特征表示[36]。接下来，在微调阶段，使用特定任务的注释数据调整模型参数，使模型与给定应用的需求对齐。这一阶段常用的损失函数是交叉熵损失。对于有N个样本和C个类别的分类任务，它可以表示为：
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <img alt="" height="117" src="https://i-blog.csdnimg.cn/direct/d47755595f8a4425a456967be91a317d.png" width="1105"/>
    </h5>
    <p>
     一个显著的例子是
     <span style="color:#fe2c24">
      <strong>
       BERT模型[2]，它在广泛的语料库（如BooksCorpus和Wikipedia）上进行了广泛的预训练
      </strong>
     </span>
     。在微调阶段，这些广泛表示使用特定任务的数据（例如用于情感分析的IMDB数据集[91]）进行细化，使得BERT能够专精于诸如情感分类和问答等任务。
    </p>
    <h4>
     3.1.3 全参数微调
    </h4>
    <p>
     全参数微调是指调整预训练模型的所有参数，而不是像LoRA[92]或Prefix-tuning[43]这样的参数高效方法，它们只修改参数的一个子集。全参数微调常用于需要高精度的任务，如医疗和法律领域[93]，但它需要大量的计算资源。例如，微调一个具有650亿参数的模型可能需要超过100GB的GPU内存，这对资源受限的环境构成了挑战。为了缓解这种限制，引入了如LOMO[93]这样的内存优化技术，减少了梯度计算和优化器状态的内存占用。模型的参数根据以下规则更新：
    </p>
    <p>
     <img alt="" height="105" src="https://i-blog.csdnimg.cn/direct/252be6f1615247a7886a545e46508531.png" width="1092"/>
    </p>
    <p>
     从GPT-3到InstructGPT是一个全参数微调的显著例子，其中整个参数集使用专门为指令跟随任务设计的数据集进行了微调[45]。这种方法虽然能带来最佳性能，但由于需要更新所有参数，因此计算成本很高。
    </p>
    <h4>
     3.2 自适应微调
    </h4>
    <p>
     自适应微调修改预训练模型的行为以更好地满足用户特定需求并处理更广泛的任务。该方法引入额外的线索来指导模型输出生成，提供了一个定制模型响应的灵活框架。自适应微调中值得注意的方法包括
     <span style="color:#fe2c24">
      <strong>
       指令调优和基于提示的调优
      </strong>
     </span>
     ，这两种方法通过引入特定任务的指导，大大增强了LLMs的适应性。
    </p>
    <p>
     <img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/d67d71fe6a28482bb8e0318d7b516467.png" width="1060"/>
    </p>
    <h4>
     图5: 指令微调的工作流程
    </h4>
    <p>
     这张图详细展示了大型语言模型（LLM）中指令微调的一般流程，分为两个主要步骤：指令数据集构建和指令微调。
    </p>
    <h5>
     Step 1: Instruction Dataset Construction (指令数据集构建)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        Annotated Text (标注文本)
       </strong>
       :
      </p>
      <ul>
       <li>
        标注文本是经过人工或自动标注的数据，包含具体的任务指令和对应的输出。
       </li>
       <li>
        这些文本通过模板（Template）进行处理，生成更多的指令实例。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Seed Instruction (种子指令)
       </strong>
       :
      </p>
      <ul>
       <li>
        种子指令是初始的、基本的指令，用于引导模型生成更多相关的指令。
       </li>
       <li>
        使用ChatGPT等工具，可以基于种子指令生成更多的指令实例。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        More Instructions (更多指令)
       </strong>
       :
      </p>
      <ul>
       <li>
        通过模板和种子指令生成大量的指令实例，这些实例构成了指令数据集的基础。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     Step 2: Instruction Tuning (指令微调)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        Base LLM (基础LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        基础LLM是一个预训练的大型语言模型，已经具备了一定的语言理解和生成能力。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Instruction Tuning (指令微调)
       </strong>
       :
      </p>
      <ul>
       <li>
        使用构建好的指令数据集对基础LLM进行微调。
       </li>
       <li>
        微调的目标是使模型更好地理解和执行特定的任务指令。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Fine-Tuned LLM (微调后的LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        经过指令微调后，模型能够更准确地理解和执行特定任务的指令。
       </li>
       <li>
        微调后的模型在特定任务上的表现会显著提升。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     3.2.1 指令调优
    </h4>
    <p>
     指令调优[96]是一种通过在专门构建的指令数据集上微调基础大型语言模型（LLM）来细化模型的技术。这种方法显著提升了模型在各种任务和领域中的泛化能力，增强了其灵活性和准确性。如图5所示，该过程
     <strong>
      首先将现有的自然语言处理（NLP）数据集（例如用于文本分类、翻译和摘要的数据集）转换为包含任务描述、输入示例、预期输出和演示说明的自然语言指令
     </strong>
     。Self-Instruct[86]等技术通过自动产生额外的指令-输出对进一步丰富了这些数据集的多样性，扩展了模型对更广泛任务的接触。微调程序调整模型参数以与这些特定任务的指令对齐，结果是一个在熟悉和以前未见过的任务上都能稳健表现的LLM。例如，InstructGPT[45]和GPT-4[7]在广泛的应用中展示了显著提升的指令跟随能力。
    </p>
    <p>
     <strong>
      指令调优的有效性很大程度上取决于指令数据集的质量和广度
     </strong>
     。高质量的数据集应涵盖广泛的语言、领域和任务复杂性，以确保模型具有广泛的适用性[96]。此外，指令的清晰性和组织对于使模型能够有效地解释和执行任务至关重要。整合示范示例或包括思维链提示[47]等技术可以显著提高需要复杂推理的任务的表现。而且，在微调阶段确保任务分布平衡是至关重要的，以避免由于不平衡的任务覆盖而导致过拟合或模型性能下降。比例任务采样或加权损失函数等技术有助于解决这些问题，确保每个任务公平地贡献于微调过程。因此，通过精心构建和管理指令数据集，研究人员可以大大增强微调LLM的泛化能力，使其在广泛的任务和领域中表现出色[97]。
    </p>
    <h4>
     3.2.2 前缀调优
    </h4>
    <p>
     前缀调优[98]是一种参数高效的微调方法，
     <strong>
      涉及向语言模型的每个Transformer层添加一系列可训练的前缀标记（连续向量），同时保持核心模型参数不变。
     </strong>
     如图6(a)所示，这些前缀向量是任务特定的，并作为虚拟令牌嵌入发挥作用。为了优化前缀向量，使用了一种重新参数化技巧，其中学习了一个小型多层感知器（MLP）函数，将较小的矩阵映射到前缀参数，而不是直接优化前缀向量。这种方法已被证明能稳定训练过程。一旦前缀向量被优化，映射函数就会被丢弃，仅保留衍生的前缀向量以增强任务特定性能。这种策略允许在不修改基础模型参数的情况下，通过调整少量新增参数来适应新任务，从而提供一种高效且灵活的微调方案。
    </p>
    <h4>
     3.2.3 提示调优
    </h4>
    <p>
     提示调优[44, 100]是一种
     <strong>
      通过优化输入层的可训练向量
     </strong>
     而
     <strong>
      不是修改模型内部参数
     </strong>
     来高效适应大型语言模型的方法。如图6(b)所示，这项技术基于离散提示方法[101, 102]引入了软提示标记，这些标记可以是非限制格式[44]或作为前缀[100]结构化。学习到的提示嵌入与输入文本嵌入结合后由模型处理，从而在保持预训练权重冻结的同时引导模型输出。提示调优的两个显著实现是Ptuning[44]和标准提示调优[100]：
    </p>
    <ul>
     <li>
      <strong>
       Ptuning
      </strong>
      ：使用灵活的方法组合上下文、提示和目标标记，适用于理解和生成任务。这种方法通过双向LSTM架构增强了软提示表示的学习。
     </li>
     <li>
      <strong>
       标准提示调优
      </strong>
      ：采用更简单的设计，在输入前添加前缀提示，并且仅根据特定任务监督更新提示嵌入。
     </li>
    </ul>
    <p>
     研究表明，提示调优可以在许多任务中匹配全参数微调的性能，同时需要显著较少的可训练参数。然而，其成功紧密依赖于底层语言模型的能力，因为
     <strong>
      提示调优只修改输入层的一小部分参数[
     </strong>
     44]。基于这些进展，更新的方法如P-Tuning v2[99]已经证明提示调优策略可以有效地扩展到各种模型大小，处理以前认为需要全微调的复杂任务。这些发现将提示调优确立为传统微调的一种高效替代方案，提供相近的性能但减少了计算和内存成本。
    </p>
    <p>
     <img alt="" height="266" src="https://i-blog.csdnimg.cn/direct/a782b23121aa48e895a83988d685445f.png" width="1049"/>
    </p>
    <p>
     这张图展示了两种不同的微调技术：前缀调优（Prefix Tuning）和提示调优（Prompt Tuning），并详细说明了它们在参数微调上的不同方法。以下是详细的解释：
    </p>
    <h4>
     图6: 前缀调优与提示调优的比较
    </h4>
    <h5>
     a) Prefix Tuning (前缀调优)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        输入 (Input)
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据首先被处理。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        嵌入 (Embedding)
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被转换为嵌入向量，这是模型可以处理的形式。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        前缀 (Prefix)
       </strong>
       :
      </p>
      <ul>
       <li>
        在嵌入向量之前添加一组可训练的前缀向量。这些前缀向量是任务特定的，并且通过微调来优化。
       </li>
       <li>
        这些前缀向量作为虚拟令牌嵌入，用于调整模型对特定任务的理解。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        大型语言模型 (LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        经过前缀调优后的嵌入向量被输入到大型语言模型中进行处理。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     b) Prompt Tuning (提示调优)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        提示 (Prompt)
       </strong>
       :
      </p>
      <ul>
       <li>
        提示是一个包含任务描述和示例的文本序列，用于引导模型生成特定类型的输出。
       </li>
       <li>
        提示通常包括任务描述、输入示例和预期输出。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        输入 (Input)
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被转换为嵌入向量，这是模型可以处理的形式。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        嵌入 (Embedding)
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被转换为嵌入向量，这是模型可以处理的形式。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        大型语言模型 (LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        经过提示调优后的嵌入向量被输入到大型语言模型中进行处理。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     具体流程详解：
    </h4>
    <h5>
     a) Prefix Tuning (前缀调优)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        输入
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被处理成原始形式。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        嵌入
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被转换为嵌入向量。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        前缀
       </strong>
       :
      </p>
      <ul>
       <li>
        添加一组可训练的前缀向量，这些向量是任务特定的，并通过微调进行优化。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        大型语言模型 (LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        嵌入向量和前缀向量一起输入到大型语言模型中进行处理。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     b) Prompt Tuning (提示调优)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        提示
       </strong>
       :
      </p>
      <ul>
       <li>
        提供一个包含任务描述和示例的文本序列，用于引导模型生成特定类型的输出。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        输入
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被处理成原始形式。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        嵌入
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据被转换为嵌入向量。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        大型语言模型 (LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        嵌入向量和提示一起输入到大型语言模型中进行处理。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
    </h4>
    <h4>
     3.3 强化微调
    </h4>
    <p>
     强化微调(ReFT)[103]代表了一种高级技术，它将强化学习(RL)与监督微调(SFT)相结合以增强模型解决复杂动态问题的能力。不同于
     <strong>
      传统的SFT通常对每个问题使用单一的思维链(CoT)
     </strong>
     注释，
     <strong>
      ReFT使模型能够探索多个有效的推理路径
     </strong>
     ，从而提高其泛化能力和解决问题的技巧。ReFT过程从标准的SFT阶段开始，模型首先在标记数据上进行训练，通过监督注释学习基本的任务解决能力。初步微调之后，模型使用如近端策略优化(PPO)[46]等RL算法进一步细化。在强化阶段，模型为每个问题生成多个CoT注释，探索不同的潜在推理路径。通过比较模型预测的答案与真实答案来评估这些生成的路径，对正确输出给予奖励，对错误输出施加惩罚。这个迭代过程驱动模型调整其策略，最终改进其推理策略。这种方法使得模型不仅能够学习如何执行特定任务，还能通过不断的反馈和调整提升解决新问题的能力。
     <img alt="" height="422" src="https://i-blog.csdnimg.cn/direct/e131a1bfec464cfabff78e289774e704.png" width="1142"/>
    </p>
    <p>
     这张图展示了强化微调（Reinforcement Fine-Tuning, ReFT）的过程，具体分为两个主要阶段：监督微调（Supervised Fine-Tuning, SFT）和强化学习微调（Reinforced Fine-Tuning）。以下是详细的解释：
    </p>
    <h4>
     图7: 强化微调（ReFT）过程
    </h4>
    <h5>
     a) 监督微调 (Supervised Fine-Tuning)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        输入数据
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据表示为 (x,e,y)，其中 x 是输入文本，e 是嵌入向量，y 是目标输出。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        初始模型 (LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        初始的大型语言模型（LLM）接收输入数据 (x,e,y)。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        中间模型 (Intermediate LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        通过一系列迭代步骤，模型被逐步调整。这些步骤可能包括
        <strong>
         多次微调，以优化模型对特定任务的理解。
        </strong>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        最终微调模型 (Fine-tuned LLM)
       </strong>
       :
      </p>
      <ul>
       <li>
        经过监督微调后的模型能够更好地处理输入数据，并生成更准确的目标输出。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     b) 强化学习微调 (Reinforced Fine-Tuning)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        预热 (Warm-up)
       </strong>
       :
      </p>
      <ul>
       <li>
        在监督微调之后，模型进入预热阶段，准备进行强化学习。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        策略采样 (On-Policy sampling)
       </strong>
       :
      </p>
      <ul>
       <li>
        模型根据当前策略生成样本。这些样本用于评估模型在特定任务上的表现。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        强化学习 (Reinforcement Learning)
       </strong>
       :
      </p>
      <ul>
       <li>
        根据生成的样本，模型通过强化学习算法（如Proximal Policy Optimization, PPO）进行进一步优化。
       </li>
       <li>
        强化学习过程中，模型会收到奖励或惩罚信号，以指导其改进策略。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        最终策略 (Final Policy)
       </strong>
       :
      </p>
      <ul>
       <li>
        经过强化学习优化后，模型达到一个最终策略，该策略能够在特定任务上表现出更好的性能。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     具体流程详解：
    </h4>
    <h5>
     a) 监督微调 (Supervised Fine-Tuning)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        输入数据
       </strong>
       :
      </p>
      <ul>
       <li>
        输入数据 (x,e,y)(x,e,y) 被提供给初始模型。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        中间模型
       </strong>
       :
      </p>
      <ul>
       <li>
        通过多次迭代，模型逐步调整参数，以更好地适应输入数据。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        最终微调模型
       </strong>
       :
      </p>
      <ul>
       <li>
        最终微调模型能够更准确地处理输入数据并生成预期的输出。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     b) 强化学习微调 (Reinforced Fine-Tuning)
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        预热
       </strong>
       :
      </p>
      <ul>
       <li>
        监督微调后的模型进入预热阶段，准备进行强化学习。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        策略采样
       </strong>
       :
      </p>
      <ul>
       <li>
        模型根据当前策略生成样本，这些样本用于评估模型的表现。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        强化学习
       </strong>
       :
      </p>
      <ul>
       <li>
        根据生成的样本，模型通过强化学习算法进行优化，接收奖励或惩罚信号以改进策略。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        最终策略
       </strong>
       :
      </p>
      <ul>
       <li>
        经过强化学习优化后，模型达到一个最终策略，该策略能够在特定任务上表现出更好的性能。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        监督微调 (SFT)
       </strong>
       :
      </p>
      <ul>
       <li>
        通过监督学习调整模型参数，使其更好地适应特定任务。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        强化学习微调 (ReFT)
       </strong>
       :
      </p>
      <ul>
       <li>
        在监督微调的基础上，通过强化学习进一步优化模型策略，使其在特定任务上表现更好。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     这两种方法结合使用，使得模型不仅能够通过监督学习快速适应特定任务，还能通过强化学习进一步提升性能。
    </p>
    <h4>
     强化微调（ReFT）过程
    </h4>
    <p>
     如图7所示，强化微调（ReFT）过程分为两个阶段执行。上半部分展示了监督微调（SFT）阶段，在这个阶段，模型在几个epoch中迭代训练数据集，学习每个问题的正确思维链（CoT）注释。下半部分介绍了强化微调（ReFT）阶段：从经过SFT训练的模型开始，模型基于当前策略生成替代的CoT注释（e′），并将其预测的答案（y′）与真实答案（y）进行比较。对于正确的答案给予正面奖励，对于错误的答案则给予负面奖励，从而驱动模型改进其性能。这些奖励信号随后通过强化学习用于更新模型的策略，增强其生成准确且多样的CoT注释的能力。
    </p>
    <p>
     最近的研究表明，
     <span style="color:#fe2c24">
      <strong>
       ReFT显著优于传统的SFT方法
      </strong>
     </span>
     [103]。此外，推理时策略（如多数投票和重新排序）的集成可以进一步提高性能，允许模型在训练后精炼其输出。值得注意的是，
     <strong>
      ReFT在不需额外或扩增训练数据的情况下实现了这些改进，仅从SFT阶段使用的现有数据集中学习。这突显了模型的优越泛化能力，因为它能够更高效、有效地从可用数据中学习。
     </strong>
    </p>
    <h4>
    </h4>
    <p>
    </p>
    <ul>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f4177616e676a696e676161612f:61727469636c652f64657461696c732f313436323739393733" class_="artid" style="display:none">
 </p>
</div>


