---
layout: post
title: "Redisson-实现分布式锁源码浅析"
date: 2025-03-14 16:28:10 +0800
description: "发现锁已经被占有，返回剩余ttl（过期时间）。"
keywords: "Redisson 实现分布式锁源码浅析"
categories: ['未分类']
tags: ['分布式', 'Redis', 'Java']
artid: "146207591"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146207591
    alt: "Redisson-实现分布式锁源码浅析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146207591
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146207591
cover: https://bing.ee123.net/img/rand?artid=146207591
image: https://bing.ee123.net/img/rand?artid=146207591
img: https://bing.ee123.net/img/rand?artid=146207591
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redisson 实现分布式锁源码浅析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     大家好，我是此林。
    </p>
    <p>
     今天来分享Redisson分布式锁源码。还是一样，我们用
     <strong>
      问题驱动
     </strong>
     的方式展开讲述。
    </p>
    <p>
    </p>
    <h2>
     1. redis 中如何使用 lua 脚本？
    </h2>
    <p>
     Redis内置了lua解释器，lua脚本有两个好处：
    </p>
    <p>
     1. 减少多次Redis命令的网络传输开销。（当然也可以使用pipline命令）
    </p>
    <p>
     2. lua脚本所有命令能保证原子性，隔离性（Redis单线程），失败回滚
    </p>
    <p>
     综上所述，
     <strong>
      Redis中如果想要实现事务操作，可以使用lua脚本。
     </strong>
    </p>
    <blockquote>
     <p>
      Redis 本身也可以使用
      <strong>
       MULTI + WATCH乐观锁
      </strong>
      来实现，但是它只能保证命令执行的顺序性，无法保证失败回滚，无法保证原子性。
     </p>
     <p>
     </p>
     <p>
      <strong>
       所以，一般推荐使用 lua 脚本。
      </strong>
     </p>
    </blockquote>
    <p>
     使用案例：
    </p>
    <p>
     现在我们要去执行redis命令：
    </p>
    <pre><code class="language-bash">HSET info name john </code></pre>
    <p>
     1. lua脚本
    </p>
    <pre><code class="language-Lua">local hash_key = KEYS[1]    -- 哈希结构的键名（外部传入）
local key = ARGV[1]         -- 哈希字段（外部传入）
local value = ARGV[2]       -- 哈希字段值（外部传入）

return redis.call('HSET', hash_key, key, value)</code></pre>
    <p>
     因为KEYS[1]、ARGV[1]等都是外部传入，所以可以简化。
    </p>
    <pre><code class="language-Lua">return redis.call('HSET', KEYS[1], ARGV[1], ARGV[2])</code></pre>
    <p>
     redis.call()就是执行redis命令。
    </p>
    <p>
     2. redis 命令
    </p>
    <pre><code class="language-Lua">EVAL "return redis.call('HSET', KEYS[1], ARGV[1], ARGV[2])" 1 info name john</code></pre>
    <p>
     这里的1代表传入一个key。
    </p>
    <p>
     <img alt="" height="164" src="https://i-blog.csdnimg.cn/direct/55a6d9a884b648b19953b7e5c4f2c667.png" width="1120"/>
    </p>
    <p>
    </p>
    <h2>
     2. 如何使用Redisson？
    </h2>
    <p>
     <img alt="" height="698" src="https://i-blog.csdnimg.cn/direct/928bd6c558a04e2387449852fddec3d2.png" width="1116"/>
    </p>
    <p>
     这里的
    </p>
    <pre>boolean isLock = lock.tryLock(1, 10, TimeUnit.SECONDS);</pre>
    <p>
     是获取锁，
     <strong>
      第一个1表示：
     </strong>
     锁超时等待时间，在1秒内会不断重试获取锁，直到获取到。
    </p>
    <p>
     <strong>
      第二个10表示：
     </strong>
     锁释放时间，为10秒（防止java服务获取到锁后，突然宕机，导致redis锁永远不会被释放，避免造成死锁问题。）
    </p>
    <p>
    </p>
    <h2>
     3. Redisson源码？
    </h2>
    <h3>
     3.1. Redisson如何实现锁重入？
    </h3>
    <h2>
     <img alt="" height="473" src="https://i-blog.csdnimg.cn/direct/a54d7e945d694a228734a2a19930ad4f.png" width="1003"/>
    </h2>
    <p>
     其实归根结底，就是这段代码。Redisson本质上是使用hash结构来标志锁的，可能我们经常听到说用setnx命令来实现分布式锁，但是setnx无法实现锁的重入。
    </p>
    <p>
     所以Redisson用
     <strong>
      <span style="color:#fe2c24">
       hash（计数） + lua脚本（原子性）
      </span>
     </strong>
     <span style="color:#0d0016">
      实现可重入分布式锁。
     </span>
    </p>
    <p>
     先说明下参数：
    </p>
    <p>
     <strong>
      KEYS[1]：
     </strong>
     hash结构的键名，也就是我们之前手动指定的 anylock
    </p>
    <p>
     <strong>
      ARGV[1]：
     </strong>
     锁的释放时间
    </p>
    <p>
     <strong>
      ARGV[2]：
     </strong>
     hash结构的字段的键名，UUID:线程id
    </p>
    <p>
     我们直接去看redis：
    </p>
    <p>
     <img alt="" height="108" src="https://i-blog.csdnimg.cn/direct/6124deec50794487885cc2df65b03750.png" width="954"/>
    </p>
    <p>
     anyLock这个hash结构里，
    </p>
    <p>
     有字段的key为c3341b71-6edd-4db8-b626-9135cf727fd4:1，value为1
    </p>
    <p>
     了解了锁的结构后，我们再来看lua脚本。
    </p>
    <p>
     <img alt="" height="625" src="https://i-blog.csdnimg.cn/direct/a776ed31cbf648158835474b4e1106b9.png" width="1778"/>
    </p>
    <p>
     一图胜千言，总的来说，
    </p>
    <p>
     <strong>
      第一个if：
     </strong>
     处理线程第一次获取锁
    </p>
    <p>
     <strong>
      第二个if：
     </strong>
     处理线程重入获取锁
    </p>
    <p>
     <strong>
      最后：
     </strong>
     发现锁已经被占有，返回剩余ttl（过期时间）。
    </p>
    <h3>
     <br/>
     <br/>
     3.2. 如果抢锁失败呢？
    </h3>
    <p>
     之前说的锁的设置，其实就是图中框起来的方法里的实现。
    </p>
    <p>
     <img alt="" height="633" src="https://i-blog.csdnimg.cn/direct/887c5f07b37e4468acf260b62ac15c13.png" width="1781"/>
    </p>
    <p>
     接下来，如果ttl为null，抢锁成功了，直接返回true。
    </p>
    <p>
     如果ttl不为null，说明抢锁失败了，会去计算等待时间是否充足。
    </p>
    <p>
     <img alt="" height="463" src="https://i-blog.csdnimg.cn/direct/b5242d810f71460babb47159362aef27.png" width="904"/>
    </p>
    <p>
     这里的等待时间就是我们之前手动设置的1秒钟。
    </p>
    <p>
     如果锁等待时间还充足，那么执行它会去用pub-sub机制去
     <strong>
      订阅锁释放事件。（
     </strong>
     避免轮询 Redis 造成的性能损耗。
     <strong>
      ）
     </strong>
    </p>
    <p>
     <img alt="" height="362" src="https://i-blog.csdnimg.cn/direct/02d9f07b38314089bb109f01c4bc9344.png" width="995"/>
    </p>
    <p>
     如果订阅超时，触发失败回调，返回false。
    </p>
    <p>
     那么订阅成功了之后呢？会再次尝试抢锁。
    </p>
    <p>
     <img alt="" height="644" src="https://i-blog.csdnimg.cn/direct/e45340a5d066493fb197c13c0a639e5c.png" width="1451"/>
    </p>
    <p>
     还不行，那只能
     <strong>
      信号量挂起，
     </strong>
     具体通过
     <code>
      Semaphore
     </code>
     （
     <code>
      getLatch()
     </code>
     ）挂起当前线程，等待锁释放的 Pub/Sub 通知。
    </p>
    <p>
     <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/c6b78c6eb1924790ac8db1f214a78af6.png" width="1003"/>
    </p>
    <p>
     <strong>
      总结一下抢锁流程：
     </strong>
    </p>
    <p>
     <strong>
      抢锁成功，直接返回；抢锁失败，pub/sub机制订阅锁释放事件，通过信号量挂起线程，直到收到锁释放的消息才被唤醒。
     </strong>
    </p>
    <p>
    </p>
    <h3>
     3.3. 解锁流程是怎么样的？
    </h3>
    <p>
     看下图。本质还是那一段lua脚本。
    </p>
    <p>
     <img alt="" height="484" src="https://i-blog.csdnimg.cn/direct/8c29d49088d74455898f91d7a06e08d7.png" width="1657"/>
    </p>
    <p>
     先看下锁是不是线程自己的，不是的话直接返回null。
    </p>
    <p>
     如果锁是自己的，计数器减1。
    </p>
    <p>
     如果减1操作后还大于0，说明重入的还没完，刷新锁的超时释放时间。
    </p>
    <p>
     如果减1后小于等于0，直接删除，发布锁删除事件。
    </p>
    <blockquote>
     <ul>
      <li>
       返回nil表示锁不属于当前线程，应抛出异常。
      </li>
      <li>
       返回0表示锁未完全释放，仅更新了过期时间。
      </li>
      <li>
       返回1表示锁已释放，并发布事件。
      </li>
     </ul>
    </blockquote>
    <p>
    </p>
    <h3>
     3.4. Redisson的看门狗机制？
    </h3>
    <p>
     看门狗主要用于 ​
     <strong>
      解决锁的自动续期问题
     </strong>
     ，避免因业务执行时间过长导致锁超时自动释放。
    </p>
    <p>
     <span style="color:#fe2c24">
      注意一点：如果我们显式指定了leaseTime参数，看门狗机制就不会生效。这时候锁的过期时间由用户控制。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      像我们之前手动指定了锁释放时间10秒，它就不会走看门狗机制，Redisson默认锁释放时间是30秒。（见下图，单位毫秒）
     </span>
    </p>
    <p>
     <img alt="" height="55" src="https://i-blog.csdnimg.cn/direct/f006484c510f4247b9b42bb13273b38d.png" width="503"/>
    </p>
    <p>
     <img alt="" height="418" src="https://i-blog.csdnimg.cn/direct/a287ae9cb0d44728a807004efa4f5437.png" width="1357"/>
    </p>
    <p>
     在scheduledExpirationRenewal方法里，其实就是用了netty的时间轮进行定时任务调度，每隔10秒重置锁时间为30秒，直到业务执行结束。
    </p>
    <p>
     <img alt="" height="736" src="https://i-blog.csdnimg.cn/direct/4b9ce8d77eb04f69a9af3d7febc9c0bd.png" width="1253"/>
    </p>
    <p>
     每次续期成功后，会递归调用
     <code>
      renewExpiration()
     </code>
     ，形成 ​
     <strong>
      无限续期链
     </strong>
     ，直到锁被释放（主动释放或者客户端宕机）。
    </p>
    <p>
     关于​
     <strong>
      时间轮，
     </strong>
     这是一种高效的定时任务调度设计
     <strong>
      。
     </strong>
    </p>
    <p>
     <strong>
      感兴趣的朋友可以去看下之前写的文章：
     </strong>
    </p>
    <p>
     <a href="https://blog.csdn.net/2401_82540083/article/details/145392738?spm=1001.2014.3001.5501" title="时间轮：XXL-JOB 高效、精准定时任务调度实现思路分析_xxljob fasttriggerpool slowtrigger-CSDN博客">
      时间轮：XXL-JOB 高效、精准定时任务调度实现思路分析_xxljob fasttriggerpool slowtrigger-CSDN博客
     </a>
    </p>
    <p>
     至于为什么不使用ScheduledThreadPoolExecutor？
    </p>
    <p>
     是因为ScheduledThreadPoolExecutor的底层结构：基于优先级队列（堆实现）。插入任务的时间复杂度
     <code>
      O(log n)
     </code>
     ，每次插入需调整堆结构。
    </p>
    <p>
     使用时间轮插入任务的时间复杂度为
     <code>
      O(1)
     </code>
     ，直接哈希到时间槽（Bucket），并且支持同一槽内任务批量触发。
    </p>
    <p>
    </p>
    <h3>
     3.5. Redisson怎么解决死锁的？
    </h3>
    <p>
     主要就是设置了锁的超时释放时间，客户端宕机了会自动超时释放。
    </p>
    <p>
     然后还有一点支持重入，如果同一个线程两次去获取锁，因为支持重入，第二次就不会阻塞等待自己释放锁了。
    </p>
    <p>
     至于说看门狗机制会无限续期，客户端宕机了就续期不了，不会导致死锁。
    </p>
    <blockquote>
     <p>
      那你说：业务要是无限阻塞，永远执行不完呢？
     </p>
     <p>
      这个也不大可能，为什么业务会无限阻塞？这个时候肯定需要人工介入去排查问题了。
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     今天的分享就到这里了，我是此林。
    </p>
    <p>
     关注我吧，带你看不一样的世界！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38323534303038332f:61727469636c652f64657461696c732f313436323037353931" class_="artid" style="display:none">
 </p>
</div>


