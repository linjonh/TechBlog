---
layout: post
title: "嵌入式八股文面试题总结QTRTOSLinuxARMCC持续更新"
date: 2025-08-24T23:29:13+0800
description: "嵌入式八股文面试题总结（QT、RTOS、Linux、ARM、C/C++）（持续更新）"
keywords: "嵌入式八股文面试题总结（QT、RTOS、Linux、ARM、C/C++）（持续更新）"
categories: ['未分类']
tags: ['Qt', 'Linux', 'Arm']
artid: "150724914"
arturl: "https://blog.csdn.net/ZJQSDSA/article/details/150724914"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150724914
    alt: "嵌入式八股文面试题总结QTRTOSLinuxARMCC持续更新"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150724914
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150724914
cover: https://bing.ee123.net/img/rand?artid=150724914
image: https://bing.ee123.net/img/rand?artid=150724914
img: https://bing.ee123.net/img/rand?artid=150724914
---



# 嵌入式八股文面试题总结（QT、RTOS、Linux、ARM、C/C++）（持续更新）

### 一、QT

1、QT简介：QT是一个**跨平台的C++应用程序开发框架**，支持Windows、Linux、macOS、IOS、Android等  
2、QT优势：跨平台性、丰富的类库、**信号与槽机制**、文档和社区支持  
3、QT信号与槽机制：**用于对象间通信的机制**。当一个对象状态发生变化时，发出一个信号signal，另一个对象可以连接这个信号到一个slot函数上

```
当线程的信号与槽实现原理主要是由观察者模式与函数指针的联合使用
多线程的信号与槽实现原理本质上是事件机制
优势：类型安全，松散耦合
缺点：相比回调函数慢10倍，性能下忽略不计
本质：一种高级的、类型安全的对象间通信机制，替代传统的、不安全的回调函数（如函数指针）
用法：一个信号连接多个槽，多个信号连接一个槽

```

4、QT元对象系统：实现**信号与槽机制、属性系统、动态类型转换**等功能的基础，通过Q_OBJECT宏、元对象编译器（MOC）等技术实现。  
5、QT信号与槽机制**连接方法5种**：UI信号槽自动连接、Lamda表达式、自定义信号槽、QT4宏直接连接函数、QT5新式语法  
6、QT信号与槽机制**连接类型5种**：

```
AutoConnection（默认）
DirectConnection（槽立即被调用）
QueuedConnection（槽放入线程事件队列中）
BlockingQueuedConnection（会阻塞发送者的线程，直到solt处理完毕）
UniqueConnection（确保信号与槽之间只建立一次连接，避免重复连接）

```

7、QT信号和槽参数：信号的参数类型和数量必须与槽函数的参数类型和数量兼容，类型安全。  
8、QT中的事件机制（Event loop）：当开启事件循环时，会创建一个事件队列并监听，触发事件时（鼠标点击、键盘输入等）会经过过滤，筛选掉不需要处理的事件，将需要处理的事件发送到监听列队中，监听方根据处理策略将需要处理的事件取出，调用对应函数处理。  
9、**QT创建多线程的两种方式**：①使用QThread类。②继承QObject。  
10、QT子线程与主线程通信：通过信号与槽机制进行通信，使用Qt::Queuedonnection连接类型  
11、QT多线程的线程安全问题：使用互斥锁（QMutex），在访问共享资源时，使用互斥锁进行加锁和解锁操作，确保同一时间只有一个线程可以访问共享资源。  
12、QT中的布局管理器：水平、垂直、网格、表单布局  
13、QT自定义控件：继承QWidget或其他控件类，重写相关的虚函数来实现。

```
虚函数是C++实现运行时多态的核心机制。基类函数声明Virtual，派生类中才能使用override重写函数。C++ 虚函数学习

```

14、QT中连接MYSQL：安装mysql驱动，使用QSqlDatabase连接数据库  
15、QT中的内存管理机制的用法与原理：

```
用法：在子对象构造时传递父对象的指针即可，或者子对象调用setParent()函数设置或更换父对象。Qt中基本所有带有Parent与Children单词的函数基本都与内存管理相关。
原理：在设置父对象的时候，让父对象保存子对象的地址，然后在父对象的析构函数中释放子对象。即可完成内存管理，Qt中的内存管理规则为一个父对象可以管理多个子对象，而子对象最多只会有一个父对象，并且由于父对象需要管理多个子对象，导致必须使用容器存储，且所有子对象和父对象必须直接或间接继承同一个类。

```

16、QT窗口对象的父子关系如何指定？有什么作用与好处？

```
指定：窗口对象(QWidget)的父子关系可由子对象的构造函数中传递父对象的指针完成，或者子对象调用setParent()函数，传递父对象的指针。
作用：子窗口默认会成为父窗口的子窗口，会嵌套进父窗口中，在父窗口显示时同时显示，父窗口隐藏时同时隐藏。
好处：父窗口销毁时会带着子窗口一起销毁，子对象无需再调用delete

```

17、QT中如果一个信号的处理方法一直未被执行，有哪些可能？

```
槽函数对象已经被销毁

存在长期处理的事件函数导致程序卡在事件中

连接信号与槽时参数错误或未进行连接

单线程的信号与槽中配置的阻塞排队属性（BlockingQueuedConnection）导致死锁

多线程信号与槽的通信中，槽函数所在线程未开启事件循环

```

18、QT中信号与槽如何同步异步？

```
信号与槽中第五个参数默认情况下为QT：：AutoConnection，单线程时会自动选择QT：：DirectConnection（直连）。多线程时会自动选择QT：：QueuedConnection（排队方式）
QT默认单线程的信号与槽的连接为同步的，也就是QT：：DirectConnection（直连），只要信号触发，一定会优先执行槽函数，槽函数执行结束后则返回到信号调用的位置。
QT默认多线程的信号与槽的连接为异步的，也就是QT：：QueuedConnection（排队方式），信号触发后不会等待槽函数结束，会直接往后执行，而槽函数在事件循环中排队，等待签名的事件执行完再开始执行。
多线程中如果想同步需要将连接类型配置为QT：：BlockingQueuedConnection（阻塞排队方式）、

```

​

### 二、RTOS

1、一个处理器核心在某一个时刻只能运行一个任务  
2、RTOS中有一个实时任务调度器，按照优先级分配CPU时间  
3、调度器中有时间片、抢占式、合作式三种调度方式

```
时间片：每个任务都有相同的优先级，任务会运行固定的时间片个数或者遇到阻塞API函数。
抢占式：每个任务都有不同的优先级，任务会一直运行直到被高优先级任务抢占或者遇到阻塞式的API函数。
合作式：很少使用，用在资源有限的设备上。

```

4、FreeRtos中所有的通信和同步机制都是基于队列实现的，特性先入先出  
5、FreeRtos中信号量分为二值信号量、计数型信号量、互斥信号量、递归互斥信号量，作用资源管理和任务同步  
6、FreeRtos内核怎么调度的，运行态、就绪态、阻塞态、挂起态

### 三、Linux

1、Linux内核组成：进程调度、内存管理、虚拟文件系统、网络接口、进程间通信、模块管理器、系统调用接口  
2、用户空间：应用程序运行的区域，应用程序不能直接访问硬件或操作系统的内核。受限  
3、内核空间：Linux内核运行的区域，内核能够直接访问硬件资源（内存、I/O设备等）。最高权限  
4、用户空间通过系统调用进入内核空间，用户空间的进程崩溃不影响系统，内核空间出差会导致系统崩溃  
5、用户空间与内核空间通信：系统调用、中断、信号、管道、共享内存  
6、进程：具有独立的内存空间、栈等资源。需要通过进程间通信（IPC），代价高  
7、线程：共享进程的内存空间和资源。一个进程包含多个线程，线程间通信，成本低。共享内存可能导致数据竞争而崩溃，一个线程崩溃影响整个进程。  
8、多进程：独立性强，资源隔离，缺点是资源开销大  
9、多线程：资源共享，效率高，调度方便，缺点是同步问题、调度开销、性能限制  
10、多进程和多线程通信（IPC）方法：管道、命名管道、消息队列、共享内存、信号量、信号、套接字

```
     共享内存：用于大量数据传输，图形处理或音视频流传输。
     消息队列：任务管理系统、多进程日志收集服务。
     套接字：分布式系统中的进程通信，客户端与服务器的交互。

```

11、 线程通讯（锁）：信号量、读写锁、条件变量、互斥锁、自旋锁  
12、守护进程：在后台运行的特殊进程  
13、临界区：指一个访问共用资源的程序片段，而这些共用资源又无法被多个线程访问的特性。临界区用于保护共享资源。  
14、Linux中信号是如何处理的：信号是一种软件中断，用于通知进程发生了某种事情。处理流程：发送信号、处理信号、信号屏蔽  
15、Linux中的内存管理机制：分页、交换、伙伴系统、SLAB分配器  
16、虚拟内存：是一种内存管理技术，为每个进程提供了一个连续的虚拟地址空间，物理内存与硬盘上的虚拟内存结合，实现扩大内存的效果。  
17、内存映射：mmap函数，将文件或设备映射到内存中，运行程序直接对文件内存进行访问。  
18、中断：中断通常由硬件设施引发的。指系统停止当前正在运行的程序，以便处理其他紧急事件或请求。  
19、异常：异常通常由软件错误引起的。指程序运行过程中发生的，可能是程序本身错误。  
20、硬链接：通过文件索引节点进行链接，只能在同一文件系统内创建  
21、软链接：通过文件路径进行链接，可以跨越不同的文件系统  
22、堆（Heap）：动态分配的内存区域，由程序员分配和释放。通常位于栈的顶部。  
23、栈（Stack）：静态分配的内存区域，由系统分配和释放。通常位于内存的底部。

### 四、ARM

1、Stm32启动流程：引脚初始化-初始化栈指针-指向复位程序-设置异常中断-设置系统时钟-调用C库函数main  
2、STM32-GPIO引脚工作模式8种：模拟输入、浮空输入、上拉和下拉输入、开漏输出、推挽输出、复用开漏和复用推挽输出

```
APB1（低速外设总线）：DAC、USB、SPI、I2C、UART、CAN
APB2（高速外设总线）：ADC、I/0、高级TIM、串口1

```

3、串口配置步骤：串口时钟使能-串口复位-GPIO工作模式-串口参数初始化-使能串口-中断处理  
4、串行总线通信：

```
I2C半双工同步：多主多从，SDA（数据）+SCL（时钟）组成。
当多个I2C连接在总线上，需要接上拉电阻，所有I2C设备SDA和SCL都是开漏输出
（避免高低电平冲突，也就是总线竞争），不能输出高电平，高电平靠外部上拉电阻提供。
I2C通信流程：起始条件->地址帧->应答->数据帧->停止位

SPI全双工同步：单主多从，MISO（主入从出）+MOSI（主出从入）+SCLK（主时钟）+CS/SS（从片选）。
支持Mode0-3四种工作模式，通过时钟极性（CPOL）和时钟相位（CPHA）控制。
SPI通信流程：主设初始化SPI->主设备选中从设备->主设备发送数据（MOSI）并接收数据（MISO）->主设备释放从设备

RS485半双工异步：如果跑Modbus协议则是单主多从，A+B双线制，差分信号，信息通过两条线路的电压差来表示，抗干扰能力强。
总线两端接120Ω终端电阻是为了解决信号反射问题，提高通信稳定可靠。

CAN半双工异步：CAN网络中没有主从设备区别，一个CAN节点由控制器和收发器两个硬件部分组成。
CANH+CANL双线制，差分信号，有闭环（串120Ω终端电阻）和开环（串2.2kΩ终端电阻）两种总线拓扑结构。
采用广播通信的方式，一个CAN节点发送的数据帧可以被总线所有节点接收。
CAN网络通信有5种类型帧：数据帧、遥控帧、错误帧、过载帧、帧间空间
CAN网络数据帧组成：帧起始+仲裁段+控制段+数据段+CRC段+ACK段+帧结束

（同步通信共用时钟线，异步通信无专用时钟线，靠波特率约定）
（RS485（4线）全双工异步： A+B信号线，DE+RE方向线，差分信号）

```

5、TCP、UDP的区别

```
 TCP：可靠、面向连接的协议、网页浏览电子邮件场景、三次握手建立连接、四次挥手关闭连接
 UDP：不可靠、无连接的协议、视频音频在线游戏场景

```

6、OSI网络模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层  
7、常见的滤波算法：一阶补偿滤波、算术平均滤波、中位值滤波、限幅平均滤波、滑动平均滤波、卡尔曼滤波  
8、二分法：在有序数组中查找特定元素的搜索算法，时间复杂度最低

### 五、C/C++

1、New（C++）和malloc（C）都是动态分配内存的方法，他们的区别如下：

```
1、内存分配位置：new操作从自由存储器为对象动态分配内存空间，malloc函数从堆上动态分配内存。
2、内存分配成功返回类型：new操作内存分配成功返回对象类型的指针，malloc函数返回的是void*。
3、内存分配失败返回类型：new操作内存分配失败抛出bac_alloc异常，malloc函数返回的是NULL。
4、是否指定内存大小：new申请内存时不需要指定内存块大小，系统自动分配，malloc函数需要显性指出所需内存块大小。

```

2、指针和引用的相同和区别：

```
1、相同点：都是间接访问内存的方式、本身都占内存、都可以访问动态分配的内存
2、不同点：指针是实体，存储一个指向内存单元的地址。而引用是原变量的别名，存储的是原变量的值。

```

3、C语言中extern 的作用：是为了在C++中使用C语言的编译和链接方式，并且在一些特定情况下保证函数的正确导出和导入。  
4、Char和int之间转换：例如：char c=’A’; int i=(int)c;  
5、Static的用法：静态变量只初始化一次，在程序开始时被分配内存，并且只能在定义的作用域中被使用。  
6、Const的用法：使用该关键词定义的变量告知编译器无法被修改。并且将常变量存储在符合表中，而不是内存中。放在函数中确保返回值不会被修改。  
7、Volatile的作用：保证变量的可见性和一致性。  
8、Sizeof和strlen的区别：对于char str[]=”hello”; Sizeof(str)结果是6，strlen结果是5。对于int arr[]={1,2,3}; sizeof(arr)的结果是sizeof(int)*3即数组长度，strlen()函数因为数组没有’\0’无法计算

```
C里面全局变量和全局静态变量放在静态存储区里面，
C里面全局常量放在只读数据段里面
C里面局部变量和局部常量放在栈里面
C里面用户定义的（malloc），放在堆里面

```

13、虚函数是C++实现运行时多态的核心机制。基类函数声明Virtual，派生类中才能使用override重写函数。



