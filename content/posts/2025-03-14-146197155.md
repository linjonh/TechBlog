---
layout: post
title: "优选算法的匠心之艺二分查找专题一"
date: 2025-03-14 20:58:02 +0800
description: "当x与目标值进行比较时，left可以移动到x右边，那么x的左边已经判断过了都是小于目标值，但右边还是未知的，即使left与right相遇，那这个数依然是未知的。right指针移动的时候，一直是在合法的区间，left一直想要跳出这个不合法的区间，直到两个指针相遇，无需判断，相遇的位置就是我们要找的结果。我们先来思考暴力解法：由于x是非负整数，那么x的平方根定义是小于等于x的。如果x=17，我们可以从1开始向右枚举，如果找到一个数n，n*n小于等于x，且(n+1)*(n+1)大于x，则x的平方根则为n。"
keywords: "优选算法的匠心之艺：二分查找专题(一)"
categories: ['算法的魔法世界']
tags: ['算法', '数据结构']
artid: "146197155"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146197155
    alt: "优选算法的匠心之艺二分查找专题一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146197155
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146197155
cover: https://bing.ee123.net/img/rand?artid=146197155
image: https://bing.ee123.net/img/rand?artid=146197155
img: https://bing.ee123.net/img/rand?artid=146197155
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     优选算法的匠心之艺：二分查找专题(一)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e9ada9f9b46f458b8be0dd9cf4ec062a.gif"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/4c598cf573e94229a1a8440f7d0ff825.jpeg"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/746eed53086347e59dbd48a2fb36f44f.gif"/>
    </p>
    <blockquote>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        专栏：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927/category_12886469.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12886469&amp;sharerefer=PC&amp;sharesource=2401_85198927&amp;sharefrom=from_link" title="算法的魔法世界">
         算法的魔法世界
        </a>
       </strong>
      </span>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        个人主页：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927?type=blog" title="手握风云">
         手握风云
        </a>
       </strong>
      </span>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95" name="%E4%B8%80%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">
     一、二分查找算法
    </h2>
    <p>
     可能很多老铁在之前可能接触过朴素的二分查找思想，比如在一个有序数组中找到目标值。但二分查找算法不仅仅局限于数组有序的场景下，只要一个数组里面符合“二段性”，当数组中间的某一个值不符合要求，我们就可以把这个值左区间或者右区间舍去，再去另一个区间进行查找。这个“二段性”，并不一定从中间划分，也可以1/3、1/4出开始划分。但我们大部分还是选择从中间划分，因为从概率学角度讲，中间划分是数学期望最高的。二分查找算法细节特别多，也特别容易写出死循环。但我们要理解了算法原理和二分查找的模板，那么就非常简单了。
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3" name="%E4%BA%8C%E3%80%81%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3">
     二、例题讲解
    </h2>
    <h3 id="2.1.%C2%A0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" name="2.1.%C2%A0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">
     2.1.
     <a class="link-info" href="https://leetcode.cn/problems/binary-search/description/" rel="nofollow" title="二分查找">
      二分查找
     </a>
    </h3>
    <p class="img-center">
     <img alt="" height="364" src="https://i-blog.csdnimg.cn/direct/453cedbfe054479687b6826ee8e622f6.png" width="618"/>
    </p>
    <p>
     对于上面的题，我们可以先使用暴力解法，利用for循环遍历数组中的每一个元素来找到目标值，这个算法的时间复杂度为
     <img alt="O(n)=n" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3Dn">
      。
     </img>
    </p>
    <pre><code class="language-java">class Solution {
    public int search(int[] nums, int target) {
        for(int i = 0;i &lt; nums.length;i++){
            if(nums[i] == target){
                return i;
            }
        }
        return -1;
    }
}</code></pre>
    <p>
     接下来对这个算法进行优化，我们先设x = (right + left)/2。如果nums[x] &gt; target，那么left = x+1；如果nums[x] &lt; target，那么right = x-1；如果nums[x] = target，直接返回x，循环走下来找不到，返回-1。
    </p>
    <p>
     有些细节我们需要注意一下：1.循环结束的条件是什么？当x与目标值进行比较时，left可以移动到x右边，那么x的左边已经判断过了都是小于目标值，但右边还是未知的，即使left与right相遇，那这个数依然是未知的。所以循环结束的条件是left&gt;right，而不是left==right。2.为什么二分查找是正确的？二分查找虽然不像上面的暴力解法一个一个比较，但我们利用“二段性”以及数组的有序性，只比较一个数字就排除一半的区间。3.二分查找的时间复杂度。当我们的循环执行一次时，将区间划分为
     <img alt="\frac{n}{2}" class="mathcode" src="https://latex.csdn.net/eq?%5Cfrac%7Bn%7D%7B2%7D">
      ；循环执行两次时将区间划分为
      <img alt="\frac{n}{4}" class="mathcode" src="https://latex.csdn.net/eq?%5Cfrac%7Bn%7D%7B4%7D">
       ；循环执行三次时将区间划分为
       <img alt="\frac{n}{8}" class="mathcode" src="https://latex.csdn.net/eq?%5Cfrac%7Bn%7D%7B8%7D">
        ……最坏情况下left与right相遇，将区间划分为1，则
        <img alt="\frac{n}{2^{x}}=1" class="mathcode" src="https://latex.csdn.net/eq?%5Cfrac%7Bn%7D%7B2%5E%7Bx%7D%7D%3D1"/>
        ，时间复杂度为
        <img alt="O(n)=logn" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3Dlogn"/>
        。
       </img>
      </img>
     </img>
    </p>
    <p class="img-center">
     <img alt="" height="191" src="https://i-blog.csdnimg.cn/direct/be36476be3794e75aa0c7b7dc9d99546.png" width="469"/>
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">class Solution {
    public int search(int[] nums, int target) {
        int left = 0,right = nums.length-1;
        while(left &lt;= right){
            int mid = (left + right)/2;
            if(nums[mid] &gt; target) right = mid -1;
            else if(nums[mid] &lt; target) left = mid +1;
            else return mid;
        }
        return -1;
    }
}</code></pre>
    <pre><code class="language-java">        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            if(nums[……) 
                right = mid -1;
            else if(……) 
                left = mid +1;
            else 
                return mid;
        }</code></pre>
    <h3 id="2.2.%C2%A0%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE" name="2.2.%C2%A0%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE">
     2.2.
     <a class="link-info" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/" rel="nofollow" title="在排序数组中查找元素的第一个和最后一个位置">
      在排序数组中查找元素的第一个和最后一个位置
     </a>
    </h3>
    <p class="img-center">
     <img alt="" height="425" src="https://i-blog.csdnimg.cn/direct/5382c6de856c4599823a8a17f056e57a.png" width="529"/>
    </p>
    <p>
     我们的暴力解法，就是去从前往后遍历数组，找出起始位置用begin记录，然后找出结束位置用end记录，最终返回[begin,end]。很明显，暴力解法的时间复杂度为
     <img alt="O(n) =n" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%20%3Dn"/>
     。
    </p>
    <p>
     我们还是根据数组有序的特性，来利用二分查找进行优化。这里我们不能使用上面的朴素二分查找，因为找出的中间值无法确定是不是起始位置或者结束位置，我们向左和向右遍历数组找出起始与结束，所以时间复杂度依然是
     <img alt="O(n) =n" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%20%3Dn"/>
     。所以朴素的二分查找不能解决问题。
    </p>
    <p class="img-center">
     <img alt="" height="162" src="https://i-blog.csdnimg.cn/direct/6e2e077b45fc409b894615cafbb9d1e7.png" width="333"/>
    </p>
    <p>
     我们还是要回归到二分查找的本质，“二段性”。我们先来查找区间的左端点，我们假设中间下标mid对应值的值为x，让x与target进行比较。如果x小于target，说明mid位于左边的区间，让left = mid+1；如果x大于等于target（这里等于的时候，并不一定是最终位置），说明mid位于右边的区间，让right=mid（因为mid指向的位置有可能正好是左区间）。
    </p>
    <p class="img-center">
     <img alt="" height="338" src="https://i-blog.csdnimg.cn/direct/fa113b3e11c84725b71cecb2d97a9b75.png" width="584"/>
    </p>
    <p>
     我们需要处理一下细节：1.循环条件。right指针移动的时候，一直是在合法的区间，left一直想要跳出这个不合法的区间，直到两个指针相遇，无需判断，相遇的位置就是我们要找的结果。并且如果left=right，一直处于x&gt;=t的条件，而right指针又不会移动，就会陷入死循环。
    </p>
    <p class="img-center">
     <img alt="" height="262" src="https://i-blog.csdnimg.cn/direct/6ecd22f959084398bef72d23593c4798.png" width="409"/>
    </p>
    <p>
     2.找出中点操作。中点有两种求法，mid=left+(right-left)/2或者是mid=left+(right-left+1)/2。如果数组元素个数为偶数个，按照第二种求法，mid就会落在右边，又会陷入死循环，所以我们需要选择第一种求法。
    </p>
    <p>
     接下来是查找区间的右端点，与上面的查找左端点的方法大同小异，只是细节的处理不一样。我们要划分的区间为小于等于target与大于tareget两部分，求中点的方式要采用第二种，防止mid落在左边的元素造成死循环。
    </p>
    <p class="img-center">
     <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/1c79ae5bf561422c89bbf34919a68559.png" width="299"/>
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ret = new int[2];
        ret[0] = ret[1] = -1;

        //处理边界情况
        if (nums.length == 0) return ret;

        //查找左端点
        int left = 0, right = nums.length - 1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &lt; target) left = mid + 1;
            else right = mid;
        }
        //判断是否有结果
        if (nums[left] != target) return ret;
        else ret[0] = right;

        //二分右端点
        left = 0;
        right = nums.length - 1;
        while (left &lt; right) {
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] &lt;= target) left = mid;
            else right = mid - 1;
        }
        ret[1] = left;
        return ret;
    }
}</code></pre>
    <p>
     模板总结：
    </p>
    <pre><code class="language-java">//查找左端点
while (left &lt; right) {
    int mid = left + (right - left) / 2;
    if (……) left = mid + 1;
    else right = mid;
}

//查找右端点
while (left &lt; right) {
    int mid = left + (right - left + 1) / 2;
    if (……) left = mid;
    else right = mid - 1;
}</code></pre>
    <h3 id="2.3.%C2%A0x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9" name="2.3.%C2%A0x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9">
     2.3.
     <a class="link-info" href="https://leetcode.cn/problems/sqrtx/description/" rel="nofollow" title="x 的平方根 ">
      x 的平方根
     </a>
    </h3>
    <p class="img-center">
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/5c3207cb7d3e44f9a61e6fb3673c7dc0.png" width="431"/>
    </p>
    <p>
     题目要求不适用内置函数求平方根，我们需要自己写一个算法来求平方根。如果求出的平方根是小数，则舍去小数部分。
    </p>
    <p>
     我们先来思考暴力解法：由于x是非负整数，那么x的平方根定义是小于等于x的。其中0和1的平方根都为它本身。如果x=17，我们可以从1开始向右枚举，如果找到一个数n，n*n小于等于x，且(n+1)*(n+1)大于x，则x的平方根则为n。
    </p>
    <p class="img-center">
     <img alt="" height="184" src="https://i-blog.csdnimg.cn/direct/e67e3ca6dfe84d78a0f7f238f318cac1.png" width="471"/>
    </p>
    <p class="img-center">
     <img alt="" height="142" src="https://i-blog.csdnimg.cn/direct/4f9f79e10e724b3097e3c6375324401a.png" width="368"/>
    </p>
    <p>
     我们可以直接套用上面的模板。如果mid * mid &lt;= x，则left=mid； 如果mid * mid &gt; x，则right=mid+1。这里还有一点需要注意，mid*mid可能会因为数据太大造成溢出，所以mid用long来创建。
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">class Solution {
    public int mySqrt(int x) {
        if(x == 0) return 0;
        long left = 1,right = x;
        while(left &lt; right){
            long mid = left + (right-left+1)/2;
            if(mid * mid &lt;= x) left = mid;
            else right = mid-1;
        }
        return (int)left;
    }
}</code></pre>
    <h3 id="2.4.%C2%A0%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE" name="2.4.%C2%A0%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE" style="background-color:transparent">
     2.4.
     <a class="link-info" href="https://leetcode.cn/problems/search-insert-position/description/" rel="nofollow" title="搜索插入位置">
      搜索插入位置
     </a>
    </h3>
    <p class="img-center">
     <img alt="" height="372" src="https://i-blog.csdnimg.cn/direct/ad5934e72e60422a88cf0d5c1f8ac67f.png" width="489"/>
    </p>
    <p>
     通过上面的示例分析，插入结果分为两种：1.插入第一个大于等于target前的位置；2.插入数组的末尾。很明显，我们可以按照查找区间左端点的模板来解决。我们还需要判断一下示例3这种情况，也就是插入数组的末尾。
    </p>
    <p class="img-center">
     <img alt="" height="174" src="https://i-blog.csdnimg.cn/direct/975e5b6aa6064d7d8ea3d2bca202e9d3.png" width="387"/>
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0,right = nums.length-1;
        while(left &lt; right){
            int mid = left + (right - left)/2;
            if(nums[mid] &lt; target) left = mid+1;
            else right = mid;
        }
        if(nums[left] &lt; target) return left+1;
        return left;
    }
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38353139383932372f:61727469636c652f64657461696c732f313436313937313535" class_="artid" style="display:none">
 </p>
</div>


