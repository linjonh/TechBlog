---
layout: post
title: "k8s-网络基础解析"
date: 2025-03-16 13:35:56 +0800
description: "k8s中的网络是怎么构成的"
keywords: "k8s 网络基础解析"
categories: ['Docker']
tags: ['网络', '容器', 'Kubernetes']
artid: "146294369"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146294369
    alt: "k8s-网络基础解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146294369
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146294369
cover: https://bing.ee123.net/img/rand?artid=146294369
image: https://bing.ee123.net/img/rand?artid=146294369
img: https://bing.ee123.net/img/rand?artid=146294369
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     k8s 网络基础解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="k8s__0">
     </a>
     k8s 网络基础
    </h2>
    <p>
     k8s是为了解决大集群(Cluster)中容器部署、伸缩和管理的各种问题而出现的一种容器编排引擎。我们上次已经讲了
     <a href="https://blog.csdn.net/weixin_60214397/article/details/146269087">
      k8s的基础架构
     </a>
     ，如果大家对基础架构不了解，那么建议先观看k8s的基础架构，那么今天我们来分析，k8s中的网络是怎么构成的。
    </p>
    <h3>
     <a id="Node_5">
     </a>
     Node之间的通信
    </h3>
    <p>
     Node IP 是节点在物理网络或云网络中的真实IP地址，可以是内网IP，也可以是公网IP。
    </p>
    <p>
     构建集群时，必须保证所有节点可以通过Node IP互通，之后kubelet、kube-proxy 等组件通过 Node IP 连接到 API Server。
    </p>
    <p>
     在 Kubernetes 集群中，节点（Node）之间的通信是通过Node IP来实现的，具体示例有：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        通信类型
       </th>
       <th>
        参与组件
       </th>
       <th>
        协议
       </th>
       <th>
        目的
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ​
        <strong>
         控制平面通信
        </strong>
       </td>
       <td>
        API Server ↔ kubelet
       </td>
       <td>
        HTTPS
       </td>
       <td>
        节点状态上报、Pod 生命周期管理
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         控制平面通信
        </strong>
       </td>
       <td>
        API Server ↔ Scheduler
       </td>
       <td>
        HTTP
       </td>
       <td>
        资源调度决策
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         控制平面通信
        </strong>
       </td>
       <td>
        API Server ↔ Controller Manager
       </td>
       <td>
        HTTP
       </td>
       <td>
        集群状态维护（如 Deployment 扩缩容、Service 同步等）
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         数据平面通信
        </strong>
       </td>
       <td>
        kube-proxy ↔ API Server
       </td>
       <td>
        HTTPS
       </td>
       <td>
        同步 Service/Endpoint 信息
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     控制平面通信始终基于节点真实 IP，例如当新节点加入集群时，kubelet 使用 Node IP 访问 API Server，定期向API Server报告节点状态等。
    </p>
    <h3>
     <a id="pod_22">
     </a>
     pod中容器的通信
    </h3>
    <p>
     Pod 是 Kubernetes 的最小调度单元，​同一 Pod 内的所有容器共享同一个网络命名空间，具体表现为：
    </p>
    <ul>
     <li>
      共享同一 IP 地址
     </li>
     <li>
      共享同一端口空间（需避免端口冲突）
     </li>
     <li>
      共享同一网络设备（如虚拟网卡）
     </li>
     <li>
      共享同一主机名（hostname）
     </li>
    </ul>
    <p>
     此机制与 Docker 的
     <code>
      --network=container:&lt;id&gt;
     </code>
     模式原理一致。
    </p>
    <p>
     Kubernetes 创建 Pod 时，首先启动一个 ​pause 容器​（镜像为 k8s.gcr.io/pause）,用来创建并持有网络命名空间（Network Namespace）。其作为其他容器的网络基础设施锚点且生命周期与 Pod 完全绑定（Pod 终止时才会销毁）。
    </p>
    <p>
     其他业务容器通过 container 网络模式接入 pause 容器的网络命名空间。
    </p>
    <p>
     由于pod中所有容器共享同一个IP地址，所以他们之间可以直接通过
     <code>
      localhost
     </code>
     进行访问。注意，需要不同服务注册不同的端口号。此外，也可以通过共享内存或文件系统进行通讯。
    </p>
    <p>
     在docker原生模式下，Pod 通过 docker0 网桥获得私有 IP（如 172.17.0.0/16），此时Pod IP 仅在宿主机内部可达，跨节点通信需通过 NodePort 或外部负载均衡。
    </p>
    <p>
     此时 Pod 网络行为与传统 Docker 容器完全一致，要实现Pod IP 在全集群内可达，需要用到CNI网络插件。此时 Docker 仅作为容器运行时，网络由 CNI 插件接管。
    </p>
    <h3>
     <a id="pod_43">
     </a>
     集群中pod的相互通信
    </h3>
    <h4>
     <a id="CNI_45">
     </a>
     CNI介绍
    </h4>
    <p>
     Docker创建的IP只能在本地服务器上访问，怎么在才能在别的节点上访问这个 Pod IP，实现集群中所有pod的通信呢？
    </p>
    <p>
     Kubernets网络模型中，有一个叫CNI的网络接口。
    </p>
    <p>
     CNI（Container Network Interface，容器网络接口）​ 是 Kubernetes 中用于管理容器网络的标准接口规范，而 ​CNI 网络插件 是具体实现这一规范的组件，负责为容器（或 Pod）分配 IP 地址、配置网络设备、设置路由规则等，确保容器之间能够跨节点通信。
    </p>
    <p>
     Kubernetes 本身不直接处理容器网络，而是通过 CNI 插件将网络管理能力解耦。
    </p>
    <p>
     CNI可以为为每个 Pod 分配唯一的集群内 IP，并且可以确保Pod跨节点通信。
    </p>
    <h4>
     <a id="CNI_56">
     </a>
     CNI原理
    </h4>
    <p>
     1、 pod创建时：
    </p>
    <ul>
     <li>
      Kubernetes 调用 CNI 插件，为 Pod 创建虚拟网络接口（如 eth0）。
     </li>
     <li>
      分配 IP 地址，并配置路由规则（如 Pod 访问其他节点时的下一跳地址）。
     </li>
    </ul>
    <p>
     2、​跨节点通信：
    </p>
    <ul>
     <li>
      Overlay 模式​（如 Flannel VXLAN）：封装数据包，在物理网络之上构建虚拟网络。
     </li>
     <li>
      ​BGP 模式​（如 Calico）：通过路由协议将 Pod IP 通告到整个集群。
     </li>
     <li>
      Underlay 模式​（如 Macvlan）：直接使用物理网络设备分配 IP。
     </li>
    </ul>
    <p>
     3、 pod销毁时
    </p>
    <ul>
     <li>
      CNI 插件释放 IP 地址并清理网络配置。
     </li>
    </ul>
    <h4>
     <a id="BGP__69">
     </a>
     ​BGP 模式的实现
    </h4>
    <p>
     在 ​BGP（Border Gateway Protocol）模式下（如 Calico 的实现），​Pod IP 是全局路由可达的，数据包 ​无需 NAT 即可跨节点直达目标 Pod。
    </p>
    <p>
     每个节点 会通过 BGP 协议向集群 ​宣告本节点的 Pod 子网例。假如有两个节点，节点1和节点2：
    </p>
    <p>
     节点 1 的 Pod CIDR 为
     <code>
      10.244.1.0/24
     </code>
     <br/>
     节点 2 的 Pod CIDR 为
     <code>
      10.244.2.0/24
     </code>
    </p>
    <p>
     之后，每个节点通过 BGP 学习到其他节点的路由信息，我们可以查看节点1的的路由信息。
    </p>
    <pre><code class="prism language-sh"><span class="token comment"># 节点 1 的路由表</span>
$ <span class="token function">ip</span> route
<span class="token number">10.244</span>.2.0/24 via <span class="token number">192.168</span>.0.2 dev eth0  <span class="token comment"># 目标 Pod IP 段下一跳为节点 2 的物理 IP</span>
</code></pre>
    <p>
     结果显示，10.244.2.0/24网段的下一跳地址，指向了PDD所在节点的物理IP 。
    </p>
    <h4>
     <a id="BGP_87">
     </a>
     依据BGP协议跨节点通信的流程
    </h4>
    <p>
     下面我们观察跨节点通信流程，以
     <br/>
     以 ​Pod A（10.244.1.2）→ Pod B（10.244.2.3）为例子。
    </p>
    <p>
     1、源节点（节点 1）​：
    </p>
    <ul>
     <li>
      根据 Pod B 的 IP
      <code>
       10.244.2.3
      </code>
      匹配路由规则
      <code>
       10.244.2.0/24 via 192.168.0.2
      </code>
     </li>
     <li>
      直接通过物理网卡 eth0 将数据包发送到 ​节点 2 的物理 IP（
      <code>
       192.168.0.2
      </code>
      ）​
     </li>
    </ul>
    <p>
     2、目标节点：
    </p>
    <ul>
     <li>
      收到数据包后，根据本地路由规则 10.244.2.0/24 dev caliXXXX 转发到 Pod B 的虚拟网卡
     </li>
     <li>
      ​全程无 NAT 转换，源 IP 保持 10.244.1.2，目标 IP 保持 10.244.2.3
     </li>
    </ul>
    <p>
     3、BGP 对等体（Peer）配置
    </p>
    <ul>
     <li>
      ​BGP Speaker：每个节点运行 BGP 客户端（如 Calico 的 bird）
     </li>
    </ul>
    <h4>
     <a id="BGP_104">
     </a>
     BGP模式的必要条件
    </h4>
    <p>
     1、 网络基础设施的支持
    </p>
    <ul>
     <li>
      节点间物理网络需互通
     </li>
     <li>
      物理交换机/路由器需支持 BGP 协议
     </li>
    </ul>
    <p>
     2、 IP地址规划
    </p>
    <ul>
     <li>
      Pod CIDR 必须为 ​全局唯一且可路由 的 IP 段（如 10.244.0.0/16）
     </li>
     <li>
      节点物理 IP 需在同一 Layer 3 网络
     </li>
    </ul>
    <h4>
     <a id="CNI_116">
     </a>
     CNI的功能
    </h4>
    <p>
     下面我们总结CNI的功能。
    </p>
    <ul>
     <li>
      <p>
       节点上的 Pod 可以和其他任何节点上的 Pod 通信(称为扁平化网络)，即节点间 Pod 的互相访问；
      </p>
     </li>
     <li>
      <p>
       节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有 Pod 通信，即系统组件访问 Pod；
      </p>
     </li>
    </ul>
    <h4>
     <a id="_123">
     </a>
     验证命令
    </h4>
    <p>
     我们给出是否成功配置k8s网络的验证命令(需提前安装calicoctl工具):
    </p>
    <pre><code class="prism language-sh"><span class="token comment"># 查看节点 BGP 邻居状态</span>
calicoctl <span class="token function">node</span> status

<span class="token comment"># 检查节点路由表</span>
<span class="token function">ip</span> route show <span class="token operator">|</span> <span class="token function">grep</span> cali

<span class="token comment"># 测试跨节点 Pod 通信（tcpdump 抓包验证无 NAT）</span>
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> pod-a -- <span class="token function">curl</span> http://10.244.2.3
tcpdump <span class="token parameter variable">-i</span> eth0 <span class="token function">host</span> <span class="token number">192.168</span>.0.2 and port <span class="token number">80</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36303231343339372f:61727469636c652f64657461696c732f313436323934333639" class_="artid" style="display:none">
 </p>
</div>


