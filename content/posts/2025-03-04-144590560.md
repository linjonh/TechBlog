---
layout: post
title: "3.多线程获取音频AI的PCM数据"
date: 2025-03-04 10:41:15 +08:00
description: "RV1126多线程采集AI模块的数据，一般分为三个步骤：分别是初始化AI模块、启动AI模块开启采集、开启多线程采集AI数据并保存到本地。AI模块的初始化实际上就是对的参数进行设置、然后调用设置AI模块并使能设置完上面的AI模块后，就要开启AI模块的工作，使用的API是开启一个线程去采集每一帧VI模块的数据，使用的API是模块ID是RK_ID_AI，通道号ID是AI创建的通道ID号这个API的具体作用已经在之前的获取AI数据：while(1)mb ="
keywords: "3.多线程获取音频AI的PCM数据"
categories: ['未分类']
tags: ['音视频', '人工智能', 'Pcm']
artid: "144590560"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144590560
    alt: "3.多线程获取音频AI的PCM数据"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144590560
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144590560
cover: https://bing.ee123.net/img/rand?artid=144590560
image: https://bing.ee123.net/img/rand?artid=144590560
img: https://bing.ee123.net/img/rand?artid=144590560
---

# 3.多线程获取音频AI的PCM数据
* * *
### ****一********RV1126多线程获取音频PCM数据的流程****
![](https://i-blog.csdnimg.cn/direct/e611548b60aa45589f6bb36b09afbc47.png)
RV1126多线程采集AI模块的数据，一般分为三个步骤：分别是初始化AI模块、启动AI模块开启采集、开启多线程采集AI数据并保存到本地。
#### ****1.1.初始化AI模块：****
AI模块的初始化实际上就是对****AI\_CHN\_ATTR\_S**** 的参数进行设置、然后调用****RK\_MPI\_AI\_SetChnAttr****
设置AI模块并使能****RK\_MPI\_AI\_EnableChn，**** 代码如下：
****AI\_CHN\_ATTR\_S ai\_chn\_s;****
****ai\_chn\_s.pcAudioNode = AUDIO\_PATH;****
****ai\_chn\_s.u32Channels = 2;****
****ai\_chn\_s.u32NbSamples = 1024;****
****ai\_chn\_s.u32SampleRate = 48000;****
****ai\_chn\_s.enAiLayout = AI\_LAYOUT\_NORMAL;****
****ai\_chn\_s.enSampleFormat = RK\_SAMPLE\_FMT\_S16;****
****ret = RK\_MPI\_AI\_SetChnAttr(AI\_CHN, &ai\_chn\_s);****
****if(ret)****
****{****
****printf("RK\_MPI\_AI\_SetChnAttr Failed...\n");****
****}****
****ret = RK\_MPI\_AI\_EnableChn(********AI\_CHN********);****
****if(ret)****
****{****
****printf("RK\_MPI\_AI\_EnableChn Failed...\n");****
****}****
#### ****1.2.启动AI模块：****
设置完上面的AI模块后，就要开启AI模块的工作，使用的API是****RK\_MPI\_********AI********\_StartStream********。****
代码如下：
****....................................................................****
****ret = RK\_MPI\_AI\_StartStream(AI\_CHN);****
****if(ret)****
****{****
****printf("RK\_MPI\_AI\_StartStream Failed...\n");****
****}****
****.......................................................................****
#### ****1.3.开启多线程获取PCM音频数据：****
开启一个线程去采集每一帧VI模块的数据，使用的API是****RK\_MPI\_SYS\_GetMediaBuffer，****
模块ID是RK\_ID\_AI，通道号ID是AI创建的通道ID号****。**** 这个API的具体作用已经在之前的获取AI数据：
........................................
while(1)
{
.........................
mb = ****RK\_MPI\_SYS\_GetMediaBuffer****(RK\_ID\_AI, s32\_chn\_id, -1);
****fwrite(********RK\_MPI\_MB\_GetPtr********(mb),********RK\_MPI\_MB\_Get********Size(mb),
1, pcm\_file********);****
.......................
}
### ****二代码实战****
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include "rkmedia\_api.h"
#define AUDIO\_PATH "default"
#define AI\_CHN 0
//获取PCM数据的线程
void * get\_ai\_pcm\_thread(void * args)
{
pthread\_detach(pthread\_self());
FILE * pcm\_file = fopen("test\_ai.pcm", "w+");
MEDIA\_BUFFER mb ;
while (1)
{
//获取PCM数据的线程
mb = RK\_MPI\_SYS\_GetMediaBuffer(RK\_ID\_AI, AI\_CHN, -1);
if(!mb)
{
printf("RK\_MPI\_SYS\_GetMediaBuffer Failed....\n");
break;
}
printf("get\_pcm\_data success...\n");
fwrite(RK\_MPI\_MB\_GetPtr(mb), RK\_MPI\_MB\_GetSize(mb), 1, pcm\_file);
RK\_MPI\_MB\_ReleaseBuffer(mb);
}
}
int main(int argc, char *argv[])
{
int ret;
AI\_CHN\_ATTR\_S ai\_chn\_s;
ai\_chn\_s.pcAudioNode = AUDIO\_PATH; //音频路径，默认default
ai\_chn\_s.u32SampleRate = 48000; //音频采样率
ai\_chn\_s.u32Channels = 2; //音频通道数
ai\_chn\_s.u32NbSamples = 1024; //音频采样个数，这里固定1024
ai\_chn\_s.enSampleFormat = RK\_SAMPLE\_FMT\_S16;
ai\_chn\_s.enAiLayout = AI\_LAYOUT\_NORMAL; //NORMAL
ret = RK\_MPI\_AI\_SetChnAttr(AI\_CHN, &ai\_chn\_s); //设置AI模块
if(ret)
{
printf("Set Ai\_Chn\_Attr Failed....\n");
}
else
{
printf("Set Ai\_Chn\_Attr Success....\n");
}
ret = RK\_MPI\_AI\_EnableChn(AI\_CHN); //使能AI模块
if(ret)
{
printf("Enable Ai\_Chn\_Attr Failed....\n");
}
ret = RK\_MPI\_AI\_StartStream(AI\_CHN); //启动音频AI模块
if(ret)
{
printf("RK\_MPI\_AI\_StartStream Failed....\n");
}
pthread\_t pid;
pthread\_create(&pid, NULL, get\_ai\_pcm\_thread, NULL);
while (1)
{
sleep(2);
}
RK\_MPI\_AI\_DisableChn(AI\_CHN);
return 0;
}
### 三ffplay播放pcm数据需要的命令：
ffplay -ar 采样率 -channels 通道数 -f 采样格式(s16le) -i pcm文件