---
layout: post
title: "Elasticsearch语义文本-更简单更好更精炼更强大-8.18"
date: 2025-03-14 09:16:17 +0800
description: "我们最新的 semantic_text 迭代带来了大量改进。除了简化 _source 中的表示之外，其好处还包括减少冗长程度、更高效的磁盘利用率以及更好地与其他 Elasticsearch 功能集成。你现在可以使用突出显示来检索与你的查询最相关的块。也许最重要的是，它现在是一个正式发的功能！我们在字段类型上经历了一段漫长的旅程，而这一最新版本承诺让语义搜索变得前所未有的简单。除了在_source中简化。"
keywords: "Elasticsearch：语义文本 - 更简单、更好、更精炼、更强大 8.18"
categories: ['Elasticsearch', 'Elastic', 'Ai']
tags: ['数据库', '搜索引擎', '大数据', '全文检索', '人工智能', 'Elasticsearch', 'Ai']
artid: "146248157"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146248157
    alt: "Elasticsearch语义文本-更简单更好更精炼更强大-8.18"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146248157
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146248157
cover: https://bing.ee123.net/img/rand?artid=146248157
image: https://bing.ee123.net/img/rand?artid=146248157
img: https://bing.ee123.net/img/rand?artid=146248157
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Elasticsearch：语义文本 - 更简单、更好、更精炼、更强大 8.18
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     作者：来自 Elastic
     <a href="https://www.elastic.co/search-labs/author/mike-pellegrini" rel="nofollow" title="Mike Pellegrini">
      Mike Pellegrini
     </a>
    </p>
    <p class="img-center">
     <img alt="" height="457" src="https://i-blog.csdnimg.cn/direct/bc1fbb13835a44e8a2b122c087a63530.webp" width="800"/>
    </p>
    <p>
     我们最新的 semantic_text 迭代带来了大量改进。除了简化 _source 中的表示之外，其好处还包括减少冗长程度、更高效的磁盘利用率以及更好地与其他 Elasticsearch 功能集成。你现在可以使用突出显示来检索与你的查询最相关的块。也许最重要的是，它现在是一个正式发的功能！
    </p>
    <p>
    </p>
    <p>
     我们在
     <code>
      <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/semantic-text.html" rel="nofollow" title="semantic_text">
       semantic_text
      </a>
     </code>
     字段类型上经历了一段漫长的旅程，而这一最新版本承诺让语义搜索变得前所未有的简单。除了在
     <code>
      _source
     </code>
     中简化
     <code>
      semantic_text
     </code>
     的表示外，它还带来了减少冗余、更高效的磁盘利用率以及更好的 Elasticsearch 其他功能集成等优势。你现在可以使用高亮功能来检索与你查询最相关的文本片段。而最重要的是，它现已成为一个正式发布的功能！
    </p>
    <p>
    </p>
    <h2>
     语义搜索的演进
    </h2>
    <p>
     多年来，我们对语义搜索的方法不断发展，目标是让它尽可能简单。在
     <code>
      semantic_text
     </code>
     字段类型推出之前，执行语义搜索需要手动完成以下步骤：
    </p>
    <ul>
     <li>
      配置映射以兼容你的嵌入向量。
     </li>
     <li>
      配置一个摄取管道，以使用机器学习模型生成嵌入向量。
     </li>
     <li>
      使用该管道来摄取你的文档。
     </li>
     <li>
      在查询时使用相同的机器学习模型为查询文本生成嵌入向量。
     </li>
    </ul>
    <p>
     <a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/134473784" rel="nofollow" title="当时，我们称这种设置为 “简单”">
      当时，我们称这种设置为 “简单”
     </a>
     ，但我们知道，我们可以让它变得更简单。于是，
     <code>
      semantic_text
     </code>
     诞生了。
    </p>
    <p>
    </p>
    <h2>
     初始阶段
    </h2>
    <p>
     我们在 Elasticsearch 8.15 中引入了
     <code>
      semantic_text
     </code>
     ，目标是简化语义搜索。如果你对
     <code>
      semantic_text
     </code>
     还不熟悉，建议先阅读我们的
     <a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/139957669" rel="nofollow" title="原始博客文章">
      原始博客文章
     </a>
     ，以了解我们的方法背景。
    </p>
    <p>
     我们最初将
     <code>
      semantic_text
     </code>
     作为 Beta 功能发布，是有充分理由的。在软件开发中，有一句广为流传的真理：让某样东西变得简单，往往是极其困难的，
     <code>
      semantic_text
     </code>
     也不例外。在它的背后，有许多复杂的组件协同工作，以实现这种 “魔法般” 的语义搜索体验。我们希望花时间确保这些组件正确无误，然后再将该功能正式推出。事实证明，这段时间的投入是值得的 —— 我们在最初的方法上进行了多次迭代，增加了新功能，并优化了存储，使
     <code>
      semantic_text
     </code>
     变得更简单、更精炼，并且更具长期可维护性。
    </p>
    <p>
     我们最初的实现依赖于修改
     <code>
      _source
     </code>
     来存储推理结果。这导致
     <code>
      semantic_text
     </code>
     字段具有相对复杂的子字段结构：
    </p>
    <pre><code>GET test-index/_doc/doc1
{
  "_index": "test-sparse",
  "_id": "doc1",
  "_source": {
    "infer_field": {
      "text": "these are not the droids you're looking for. He's free to go around",
      "inference": {
        "inference_id": "my-elser-endpoint",
        "model_settings": {
          "task_type": "sparse_embedding"
        },
        "chunks": [
          {
            "text": "these are not the droids you're looking for. He's free to go around",
            "embeddings": {
              "##oid": 1.9103845,
              "##oids": 1.768872,
              "free": 1.693662,
              "dr": 1.6103356,
              "around": 1.4376559,
              "these": 1.1396849

              …
            }
          }
        ]
      }
    }
  }
}</code></pre>
    <p>
     这种结构带来了一些问题：
    </p>
    <ul>
     <li>
      <strong>
       过于冗长。
      </strong>
      除了原始值外，它还包含元数据和文本分片信息，使 API 响应既难以阅读，又比实际需要的更大。
     </li>
     <li>
      <strong>
       增加了磁盘上的索引大小。
      </strong>
      由于嵌入向量可能非常大，它们实际上被存储了两次：一次用于 Lucene 索引以支持检索，另一次存储在
      <code>
       _source
      </code>
      中。这极大地影响了
      <code>
       semantic_text
      </code>
      在大规模数据集上的可扩展性。
     </li>
     <li>
      <strong>
       管理起来不够直观。
      </strong>
      原始提供的文本值存储在
      <code>
       text
      </code>
      子字段中，因此需要特殊处理才能在后续操作中获取该值。这导致
      <code>
       semantic_text
      </code>
      字段的行为与文本字段族中的其他字段不一致，从而带来了一系列复杂的连锁反应，使得它更难集成到更高级的工作流中。
     </li>
    </ul>
    <p>
    </p>
    <h2>
     语义文本即文本
    </h2>
    <p>
     我们的改进版本优雅地解决了这些问题，通过优化
     <code>
      semantic_text
     </code>
     在
     <code>
      _source
     </code>
     中的表示方式，使其更加简洁。与其在
     <code>
      semantic_text
     </code>
     字段内直接存储元数据和文本分片信息的复杂子字段结构，我们现在改用一个
     <strong>
      隐藏的元字段（metafield）
     </strong>
     来处理这些内容。这意味着，我们不再需要修改
     <code>
      _source
     </code>
     来存储推理结果。
    </p>
    <p>
     从实际效果来看，这一改进意味着你提交用于索引的文档
     <code>
      _source
     </code>
     ，在检索时依然会以相同的
     <code>
      _source
     </code>
     返回，不会再被额外修改或扩展。
    </p>
    <pre><code>GET test-index/_doc/doc1
{
  "_index": "test-sparse",
  "_id": "doc1",
  "_source": {
    "infer_field": "these are not the droids you're looking for. He's free to go around"
  }
}</code></pre>
    <p>
    </p>
    <h2>
     结构简化带来的变化
    </h2>
    <p>
     你会注意到，
     <code>
      _source
     </code>
     结构中不再包含
     <code>
      text
     </code>
     或
     <code>
      inference
     </code>
     之类的子字段。现在，
     <code>
      _source
     </code>
     保持与索引时提供的内容完全一致，变得更加简单！
    </p>
    <blockquote>
     <p>
      🚨
      <strong>
       注意
      </strong>
      ：如果你的代码依赖于解析
      <code>
       semantic_text
      </code>
      字段在搜索结果或
      <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html" rel="nofollow" title="Get API">
       Get API
      </a>
      返回值中的子字段结构，这将是一个
      <strong>
       破坏性变更
      </strong>
      。也就是说，如果你以前解析的是
      <code>
       infer_field.text
      </code>
      子字段的值，你需要更新代码，使其改为解析
      <code>
       infer_field
      </code>
      的值。我们尽力避免破坏性变更，但由于
      <code>
       _source
      </code>
      结构调整而移除子字段结构，这次变更不可避免。
     </p>
    </blockquote>
    <h4>
     这一简化带来的主要优势：
    </h4>
    <ul>
     <li>
      <strong>
       更易使用。
      </strong>
      不再需要解析复杂的子字段结构来获取原始文本值，直接读取字段值即可。
     </li>
     <li>
      <strong>
       减少冗余。
      </strong>
      元数据和文本分片信息不会再干扰 API 响应，使其更加简洁。
     </li>
     <li>
      <strong>
       提高磁盘利用率。
      </strong>
      嵌入向量不再存储在
      <code>
       _source
      </code>
      中，减少了存储占用。
     </li>
     <li>
      <strong>
       更好的集成性。
      </strong>
      使
      <code>
       semantic_text
      </code>
      更好地支持 Elasticsearch 其他功能，如多字段（multi-fields）、文档的部分更新（partial updates）以及重新索引（reindexing）。
     </li>
    </ul>
    <p>
     让我们稍微扩展一下最后一点，因为它涵盖了几个领域。通过这种简化，semantic_text 字段现在可以用作
     <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-fields.html" rel="nofollow" title="multi-fields">
      multi-fields
     </a>
     的源和目标
    </p>
    <pre><code>PUT multi-field-source-example-index
{
  "mappings": {
    "properties": {
      "inference": {
        "type": "semantic_text",
        "fields": {
          "text": {
            "type": "text"
           }
        }
      }
    }
  }
}

PUT multi-field-target-example-index
{
  "mappings": {
    "properties": {
      "text": {
        "type": "text",
        "fields": {
          "inference": {
            "type": "semantic_text"
           }
        }
      }
    }
  }
}</code></pre>
    <p>
     <code>
      semantic_text
     </code>
     字段现在还支持通过
     <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" rel="nofollow" title="Bulk API">
      Bulk API
     </a>
     进行部分文档更新：
    </p>
    <pre><code>PUT partial-update-example-index
{
  "mappings": {
    "properties": {
      "inference": {
        "type": "semantic_text"
      },
      "source_field": {
        "type": "text",
        "copy_to": "inference"
      }
    }
  }
}

POST my-index/_doc/1
{
  "inference": "a test value",
  "source_field": "another test value"
}

POST my-index/_bulk
{ "update": {"_id": "1"} }
{ "doc": {"source_field": "a different test value"} }</code></pre>
    <p>
     现在，你可以将数据重新索引到使用不同
     <code>
      inference_id
     </code>
     的
     <code>
      semantic_text
     </code>
     字段中。
    </p>
    <pre><code>PUT source-index
{
  "mappings": {
    "properties": {
      "inference": {
        "type": "semantic_text",
        "inference_id": "my-elser-endpoint"
      }
    }
  }
}

PUT dest-index
{
  "mappings": {
    "properties": {
      "inference": {
        "type": "semantic_text",
        "inference_id": "my-e5-endpoint"
      }
    }
  }
}

POST dest-index/_doc/1
{
  "inference": "a test value"
}

POST _reindex
{
  "source": {
    "index": "source-index"
  },
  "dest": {
    "index": "dest-index"
  }
}</code></pre>
    <p>
    </p>
    <h2>
     语义高亮（Semantic Highlighting）
    </h2>
    <p>
     <code>
      semantic_text
     </code>
     最受欢迎的功能请求之一，就是能够在字段内检索最相关的文本片段。这一功能对于 RAG（检索增强生成）应用至关重要。此前，我们（非官方地）通过
     <code>
      inner_hits
     </code>
     提供了一些临时解决方案，但现在我们决定淘汰
     <code>
      inner_hits
     </code>
     ，转而采用更精简的方案：
     <strong>
      高亮（highlighting）
     </strong>
     。
    </p>
    <p>
     高亮是一种常见的
     <strong>
      词法搜索技术
     </strong>
     ，通常用于文本字段。由于
     <code>
      semantic_text
     </code>
     属于文本字段家族，因此将高亮技术适配到
     <code>
      semantic_text
     </code>
     是合理的。为此，我们新增了
     <strong>
      语义高亮（semantic highlighter）
     </strong>
     ，它可以帮助你检索与查询最相关的文本片段：
    </p>
    <pre><code>PUT highlighting-index
{
  "mappings": {
    "properties": {
      "inference": {
        "type": "semantic_text"
      }
    }
  }
}

POST highlighting-index/_doc/1
{
  "inference": ["Yosemite is one of the most popular national parks in the USA", "Park visitors should dispose of their trash properly in bear-proof trash bins to avoid attracting bears", "Bears are quite clever and curious though, so visitors should always be on the lookout for bear activity regardless"]
}

GET highlighting-index/_search
{
  "query": {
    "semantic": {
      "field": "inference",
      "query": "Where should I throw away my trash?"
    }
  },
  "highlight": {
    "fields": {
      "inference": {
        "order": "score",
        "number_of_fragments": 1
      }
    }
  }
}

{
    "took": 6,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 1,
            "relation": "eq"
        },
        "max_score": 15.898441,
        "hits": [
            {
                "_index": "highlighting-index",
                "_id": "1",
                "_score": 15.898441,
                "_source": {
                    "inference": [
                        "Yosemite is one of the most popular national parks in the USA",
                        "Park visitors should dispose of their trash properly in bear-proof trash bins to avoid attracting bears",
                        "Bears are quite clever and curious though, so visitors should always be on the lookout for bear activity regardless"
                    ]
                },
                "highlight": {
                    "inference": [
                        "Park visitors should dispose of their trash properly in bear-proof trash bins to avoid attracting bears"
                    ]
                }
            }
        ]
    }
}


GET highlighting-index/_search
{
  "query": {
    "semantic": {
      "field": "inference",
      "query": "Are bears smart?"
    }
  },
  "highlight": {
    "fields": {
      "inference": {
        "order": "score",
        "number_of_fragments": 1
      }
    }
  }
}

{
    "took": 20,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 1,
            "relation": "eq"
        },
        "max_score": 18.584934,
        "hits": [
            {
                "_index": "highlighting-index",
                "_id": "1",
                "_score": 18.584934,
                "_source": {
                    "inference": [
                        "Yosemite is one of the most popular national parks in the USA",
                        "Park visitors should dispose of their trash properly in bear-proof trash bins to avoid attracting bears",
                        "Bears are quite clever and curious though, so visitors should always be on the lookout for bear activity regardless"
                    ]
                },
                "highlight": {
                    "inference": [
                        "Bears are quite clever and curious though, so visitors should always be on the lookout for bear activity regardless"
                    ]
                }
            }
        ]
    }
}</code></pre>
    <p>
     请参阅
     <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/semantic-text.html#semantic-text-highlighting" rel="nofollow" title="semantic_text 文档">
      semantic_text 文档
     </a>
     ，了解如何使用高亮功能的更多信息。
    </p>
    <h4>
    </h4>
    <h2>
     <strong>
      正式上线
     </strong>
    </h2>
    <p>
     随着
     <code>
      _source
     </code>
     表示方式的调整，我们现在正式宣布
     <code>
      semantic_text
     </code>
     <strong>
      已成为正式发布的功能
     </strong>
     🎉！这意味着我们承诺不再对该功能进行破坏性更改，并正式支持在生产环境中使用。作为用户，你可以放心地将
     <code>
      semantic_text
     </code>
     集成到生产工作流中，Elastic 也将持续提供支持，确保长期稳定性。
    </p>
    <h4>
    </h4>
    <h2>
     <strong>
      从 Beta 迁移
     </strong>
    </h2>
    <p>
     为了确保从 Beta 版本的平稳迁移，所有在
     <strong>
      Elasticsearch 8.15 至 8.17 版本创建的索引
     </strong>
     ，或
     <strong>
      在 1 月 30 日之前在 Serverless 中创建的索引
     </strong>
     ，仍将按照 Beta
     <code>
      _source
     </code>
     结构运行。换句话说，它们仍将使用 Beta 版本的
     <code>
      _source
     </code>
     表示方式。
    </p>
    <p>
     我们建议尽早迁移到正式发布版本的
     <code>
      _source
     </code>
     结构。你可以通过
     <strong>
      重新索引（
      <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html" rel="nofollow" title="reindexing">
       reindexing
      </a>
      ）到新索引
     </strong>
     来完成迁移：
    </p>
    <pre><code>PUT my-new-index
{
  "mappings": {
    "properties": {
      "inference": {
        "type": "semantic_text"
      }
    }
  }
}

POST _reindex
{
  "source": {
    "index": "my-old-index"
  },
  "dest": {
    "index": "my-new-index"
  },
  "script": {
    "source": "ctx._source.inference = ctx._source.inference.text"
  }
}</code></pre>
    <p>
     请注意
     <code>
      script
     </code>
     参数的使用，它用于适配
     <code>
      _source
     </code>
     表示方式的更改。该脚本会从
     <code>
      text
     </code>
     子字段提取值，并直接赋给
     <code>
      semantic_text
     </code>
     字段。
    </p>
    <p>
    </p>
    <h2>
     <strong>
      立即尝试
     </strong>
    </h2>
    <p>
     这些更改将在
     <strong>
      Elasticsearch 8.18+
     </strong>
     （Stack 版）中提供，但如果你想现在就体验，它们已在
     <strong>
      Serverless
     </strong>
     版本中可用。此外，它们还与我们同期推出的
     <strong>
      语义搜索简化
     </strong>
     方案完美结合。使用这两者，可以让你的语义搜索能力更上一层楼！
    </p>
    <p>
     你可以通过
     <strong>
      <a class="link-info" href="https://www.elastic.co/demo-gallery/vector-search" rel="nofollow" title="自助式 Search AI 实践课程">
       自助式 Search AI 实践课程
      </a>
     </strong>
     亲自体验向量搜索。现在就
     <strong>
      开启
      <a class="link-info" href="https://cloud.elastic.co/registration?onboarding_token=search&amp;cta=cloudregistration&amp;tech=trial&amp;plcmt=cross%20module&amp;pg=search-labs" rel="nofollow" title="免费云试用">
       免费云试用
      </a>
     </strong>
     ，或在
     <a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/143747798" rel="nofollow" title="本地安装">
      本地安装
     </a>
     Elastic 进行尝试！
    </p>
    <p>
    </p>
    <p>
     原文：
     <a href="https://www.elastic.co/search-labs/blog/semantic-text-ga#try-it-out-yourself" rel="nofollow" title="Semantic Text: Simpler, better, leaner, stronger - Elasticsearch Labs">
      Semantic Text: Simpler, better, leaner, stronger - Elasticsearch Labs
     </a>
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f5562756e7475546f7563682f:61727469636c652f64657461696c732f313436323438313537" class_="artid" style="display:none">
 </p>
</div>


