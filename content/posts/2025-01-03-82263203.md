---
layout: post
title: "Java-正则表达式"
date: 2025-01-03 17:34:22 +0800
description: "介绍前段时间使用Java的正则表达式做一些字符串匹配的任务，现将学到的正则表达式的知识整理成文。Ja"
keywords: "java正则表达式 (?m)"
categories: ['Java']
tags: ['非贪婪', '边界匹配符', '正则表达式', 'Java']
artid: "82263203"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=82263203
    alt: "Java-正则表达式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=82263203
featuredImagePreview: https://bing.ee123.net/img/rand?artid=82263203
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java 正则表达式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     介绍
    </h3>
    <p>
     前段时间使用Java的正则表达式做一些字符串匹配的任务，现将学到的正则表达式的知识整理成文。
    </p>
    <p>
     Java中Spring.class涉及到正则表达式。如Spring.split()， matches()，replaceAll()等方法。
    </p>
    <p>
     Java中更一般使用正则表达式的方式是利用Pattern.class和Matcher.class，所在package为
     <em>
      java.util.regex
     </em>
    </p>
    <p>
     Java中正则表达式相关API使用不难掌握，不过重点在于编写合适的正则表达式，尤其是利用字符类和量词的使用。
    </p>
    <h3>
     <a id="_10">
     </a>
     正则表达式
    </h3>
    <p>
     Java中正则表达式与之前使用的Python是有区别的，区别在于Java对于反斜线(\)处理的不同。
     <br/>
     在Python中"\d"表示 匹配一位数字(0-9)，而Java中匹配一位数字(0-9)，需要的正则表达式为"\\d"。
     <br/>
     不过换行符和制表符只需要单反斜线“\n\t”。
    </p>
    <h4>
     <a id="_16">
     </a>
     字符
    </h4>
    <p>
     给出构造正则表达式的常用字符
    </p>
    <table>
     <thead>
      <tr>
       <th>
        字符
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        B
       </td>
       <td>
        指定字符B
       </td>
      </tr>
      <tr>
       <td>
        \xhh
       </td>
       <td>
        十六进制值为oxhh的字符
       </td>
      </tr>
      <tr>
       <td>
        \uhhhh
       </td>
       <td>
        十六进制值为oxhhhh的Unicode字符
       </td>
      </tr>
      <tr>
       <td>
        \t
       </td>
       <td>
        tab
       </td>
      </tr>
      <tr>
       <td>
        \n
       </td>
       <td>
        换行
       </td>
      </tr>
      <tr>
       <td>
        \r
       </td>
       <td>
        回车
       </td>
      </tr>
      <tr>
       <td>
        \e
       </td>
       <td>
        转义
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_32">
     </a>
     字符类
    </h4>
    <p>
     字符类在编写正则表达式起到重要的作用，我们给出一些常用的构造正则表达式的字符类。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        字符类
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        . (小数点)
       </td>
       <td>
        任意字符
       </td>
      </tr>
      <tr>
       <td>
        [abc]
       </td>
       <td>
        [ ] 中括号，包含a,b,c中任意字符
       </td>
      </tr>
      <tr>
       <td>
        [^abc]
       </td>
       <td>
        [ ]中括号加^, 表示否定，除a,b,c之外的
       </td>
      </tr>
      <tr>
       <td>
        [a-z]
       </td>
       <td>
        从a到z的任意字符
       </td>
      </tr>
      <tr>
       <td>
        [a-z&amp;&amp;[hi]]
       </td>
       <td>
        &amp;&amp;表示交集，即包含h或i
       </td>
      </tr>
      <tr>
       <td>
        \s
       </td>
       <td>
        空白字符，包含空格，换行，回车，tab，换页
       </td>
      </tr>
      <tr>
       <td>
        \S
       </td>
       <td>
        大写为小写的取反，非空白字符，等价于[^\s]
       </td>
      </tr>
      <tr>
       <td>
        \d
       </td>
       <td>
        数字0-9
       </td>
      </tr>
      <tr>
       <td>
        \D
       </td>
       <td>
        非数字，等价于[^0-9]
       </td>
      </tr>
      <tr>
       <td>
        \w
       </td>
       <td>
        词字符，数字，大小写字母，等价于[0-9a-zA-Z]
       </td>
      </tr>
      <tr>
       <td>
        \W
       </td>
       <td>
        非词，等价于[^\w]
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_52">
     </a>
     逻辑操作符
    </h4>
    <p>
     组合一个或多个表达式，通过逻辑操作符实现。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        逻辑操作符
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        XY
       </td>
       <td>
        Y跟在X后面，并且XY同时满足
       </td>
      </tr>
      <tr>
       <td>
        X|Y
       </td>
       <td>
        X或者Y
       </td>
      </tr>
      <tr>
       <td>
        (X)
       </td>
       <td>
        () 小括号表示捕获组(group)，可以对group进行处理，尤其是获取其中的内容
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_64">
     </a>
     边界匹配符
    </h4>
    <p>
     针对边界的匹配，给出边界匹配符。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        边界匹配符
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ^
       </td>
       <td>
        一行的开始
       </td>
      </tr>
      <tr>
       <td>
        $
       </td>
       <td>
        一行的结束
       </td>
      </tr>
      <tr>
       <td>
        \b
       </td>
       <td>
        词的边界
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_76">
     </a>
     量词
    </h4>
    <p>
     量词描述了一个模式匹配文本的方式，包含
    </p>
    <ul>
     <li>
      贪婪型：量词默认是贪婪的，发现尽可能多的匹配
     </li>
     <li>
      勉强型：通过问号(?)指定，匹配最小的字符数，也称为懒惰型，最少匹配，非贪婪。
     </li>
     <li>
      占有型：通过加号(+)指定，当用于字符串时防止匹配失败时回溯。
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        贪婪型
       </th>
       <th>
        勉强型
       </th>
       <th>
        占有型
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        X?
       </td>
       <td>
        X??
       </td>
       <td>
        X?+
       </td>
       <td>
        匹配0个或1个X
       </td>
      </tr>
      <tr>
       <td>
        X*
       </td>
       <td>
        X*?
       </td>
       <td>
        X*+
       </td>
       <td>
        匹配0个或多个X
       </td>
      </tr>
      <tr>
       <td>
        X+
       </td>
       <td>
        X+?
       </td>
       <td>
        X++
       </td>
       <td>
        匹配1个或多个X
       </td>
      </tr>
      <tr>
       <td>
        X{n}
       </td>
       <td>
        X{n}?
       </td>
       <td>
        X{n}+
       </td>
       <td>
        恰好匹配n个X
       </td>
      </tr>
      <tr>
       <td>
        X{n,}
       </td>
       <td>
        X{n,}?
       </td>
       <td>
        X{n,}+
       </td>
       <td>
        至少匹配n个X
       </td>
      </tr>
      <tr>
       <td>
        X{n,m}
       </td>
       <td>
        X{n,m}?
       </td>
       <td>
        X{n,m}+
       </td>
       <td>
        至少匹配n个X，最多匹配m个X
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_95">
     </a>
     正则表达式使用
    </h3>
    <h4>
     <a id="String_97">
     </a>
     String
    </h4>
    <p>
     String.class提供了一些方法，如用于切分的split()方法，用于验证是否匹配的matches()方法，用于替换操作的replaceAll方法。简单示例如下：
    </p>
    <pre><code>	/**
     * String中正则表达式的测试
     *
     * @throws Exception 异常情况
     */
    @Test
    public void testStringRegex() throws Exception {

        // split
        // 结果：[some, examples, of, regex, test]
        String query = "some examples of regex test";
        String[] parts = query.split(" ");
        System.out.println(Arrays.toString(parts));

        // matches 整个字符串是否匹配
        // 结果：false
        String regex = "regex";
        boolean isMatched = query.matches(regex);
        System.out.println(isMatched);

        // replaceAll
        // 结果：some &lt;REGEX&gt; examples &lt;REGEX&gt; of &lt;REGEX&gt; regex &lt;REGEX&gt; test
        String replaceQuery = " &lt;REGEX&gt; ";
        String newQuery = query.replaceAll(" ", replaceQuery);
        System.out.println(newQuery);
    }
</code></pre>
    <h4>
     <a id="PatternMatcher_132">
     </a>
     Pattern和Matcher
    </h4>
    <p>
     正则表达式更一般的用法是使用*java.util.regex.*下的Matcher和Pattern类。
    </p>
    <p>
     通过Pattern类的静态方法
     <em>
      static Pattern.compile()
     </em>
     编译正则表达式，利用Pattern的*matcher()*方法生产Matcher对象。根据Matcher对象提供的API完成相应的操作。
    </p>
    <p>
     我们以获取字符串中的电话号码和Html中的标题为例，实现正则表达式的匹配。示例如下：
    </p>
    <pre><code>package com.notepad.thinkingnote.regexes;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Description: 正则表达式
 * &lt;p&gt;
 * Create:      2018/8/25 21:37
 *
 * @author Marvin Yang
 */
public class RegexUtils {

    /**
     *  获取content中全部的手机号码
     *
     * @param content 待匹配内容
     * @return 电话号码集合
     */
    public List&lt;String&gt; getPhoneNumber(String content) {
        List&lt;String&gt; phoneNumbers = new ArrayList&lt;&gt;();
        Matcher matcher = PHONE_PATTERN.matcher(content);
        while (matcher.find()) {
            // group=2对应(1\\d{10}), 匹配的值即为手机号码
            phoneNumbers.add(matcher.group(2));
        }
        return phoneNumbers;
    }

    /**
     * 从Html中获取title
     *
     * @param content a html
     * @return the title of a html
     */
    public String getHtmlTitle(String content) {
        Matcher matcher = TITLE_PATTERN.matcher(content);
        return matcher.find()? matcher.group(1):null;
    }

    /** 手机号码 */
    private static final String PHONE_REGEX = "(^|\\D)(1\\d{10})($|\\D)";
    private static final Pattern PHONE_PATTERN;

    /** html 标题 */
    private static final String HTML_TITLE_REGEX = "&lt;title&gt;(.*?)&lt;/title&gt;";
    private static final Pattern TITLE_PATTERN;

    static {
        PHONE_PATTERN = Pattern.compile(PHONE_REGEX);
        
        // 不区分大小写
        TITLE_PATTERN = Pattern.compile(HTML_TITLE_REGEX, Pattern.CASE_INSENSITIVE);
    }
}

</code></pre>
    <p>
     构造单测样例如下：
    </p>
    <pre><code>package com.notepad.thinkingnote.regexes;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.*;

/**
 * Description: 正则表达式单测
 * &lt;p&gt;
 * Create:      2018/8/25 21:45
 *
 * @author Marvin Yang
 */
public class RegexUtilsTest {

    private RegexUtils regexUtils = new RegexUtils();

    @Test
    public void getPhoneNumber() {
        // test 1: 有电话号码
        String content = "紧急情况请拨打13845697569";
        List&lt;String&gt; phoneNumbers = regexUtils.getPhoneNumber(content);
        System.out.println(String.format("[%s] has phone number : [%s]", content, phoneNumbers));

        // test 2: 数字12位
        content = "紧急情况请拨打138456975690";
        phoneNumbers = regexUtils.getPhoneNumber(content);
        System.out.println(String.format("[%s] has phone number : [%s]", content, phoneNumbers));

        // test 3: 开头不是1
        content = "紧急情况请拨打23845697569";
        phoneNumbers = regexUtils.getPhoneNumber(content);
        System.out.println(String.format("[%s] has phone number : [%s]", content, phoneNumbers));

        // test 4: 数字在开头
        content = "13845697569紧急情况请拨打";
        phoneNumbers = regexUtils.getPhoneNumber(content);
        System.out.println(String.format("[%s] has phone number : [%s]", content, phoneNumbers));
    }

    @Test
    public void getHtmlTitle() throws Exception {
        // test 1: 正常情况
        String content = "&lt;title&gt;学而不厌 诲人不倦 - 第 1 页 - CSDN博客&lt;/title&gt;";
        String title = regexUtils.getHtmlTitle(content);
        System.out.println(String.format("get title [%s] from content: [%s]", title, content));


        // test 1: 不区分大小写
        content = "&lt;TITLE&gt;学而不厌 诲人不倦 - 第 1 页 - CSDN博客&lt;/TITLE&gt;";
        title = regexUtils.getHtmlTitle(content);
        System.out.println(String.format("get title [%s] from content: [%s]", title, content));
    }
}
</code></pre>
    <h3>
     <a id="_268">
     </a>
     总结
    </h3>
    <p>
     本文对Java的正则表达式的使用进行了简单的介绍，已经利用Pattern和Matcher进行匹配的样例。当然重要的还是正则表达式的编写，不一定非得很复杂， 重点是适合我们处理的问题。
    </p>
    <h3>
     <a id="_274">
     </a>
     参考文献
    </h3>
    <blockquote>
     <p>
      Java编程思想第四版 第十三章
     </p>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f796d61696e69:2f61727469636c652f64657461696c732f3832323633323033" class_="artid" style="display:none">
 </p>
</div>


