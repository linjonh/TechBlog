---
layout: post
title: "Spring-Boot-日志"
date: 2025-03-10 21:39:46 +0800
description: "了解日志文件的用途、学习SpringBoot 日志文件的配置 "
keywords: "Spring Boot 日志"
categories: ['Javaee']
tags: ['日志', '外观模式', 'Spring', 'Java', 'Boot']
artid: "146132751"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146132751
    alt: "Spring-Boot-日志"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146132751
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146132751
cover: https://bing.ee123.net/img/rand?artid=146132751
image: https://bing.ee123.net/img/rand?artid=146132751
img: https://bing.ee123.net/img/rand?artid=146132751
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring Boot 日志
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b4b791ae470f45f6b04701ac162b316e.png"/>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <h2>
     一、为什么要学习日志
    </h2>
    <p>
     日志对我们来说并不陌生，从JavaSE部分，我们就在使用 System.out.print 来打印日志了.通过打
     <br/>
     印日志来
     <span style="background-color:#c7e6ea">
      发现和定位问题
     </span>
     ，或者根据日志来分析程序的运行过程.在 Spring 的学习中，也经常根据控制台的日志来
     <span style="background-color:#cccccc">
      分析
     </span>
     和定位问题.
    </p>
    <p>
     随着项目的复杂度提升，我们对日志的打印也有了更高的需求，而不仅仅是定位排查问题.
    </p>
    <p>
     比如需要记录一些用户的操作记录（一些审计公司会要求），也可能需要使用日志来记录用户的一些喜好，
     <span style="background-color:#f9eda6">
      把日志持久化
     </span>
     ，后续进行数据分析等.但是 System.out.print 不能很好的满足我们的需求，我们就需要使用一些
     <span style="background-color:#dad5e9">
      专门日志框架
     </span>
     （专业的事情交给专业的人去做）.
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E8%AE%A4%E8%AF%86%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F" name="%E4%BA%8C%E3%80%81%E8%AE%A4%E8%AF%86%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">
     二、认识日志格式
    </h2>
    <p>
     <img alt="" height="384" src="https://i-blog.csdnimg.cn/direct/c42cda9cfc86445ba7b8e7ff51e6e73e.png" width="2377"/>
    </p>
    <p>
     1️⃣时间日期：精确到毫秒
     <br/>
     2️⃣日志级别：ERROR,WARN,INFO,DEBUG或TRACE
     <br/>
     3️⃣进程 ID
     <br/>
     4️⃣线程名
     <br/>
     5️⃣Logger 名（通常使用源代码的类名）
     <br/>
     6️⃣日志内容
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8" name="%E4%B8%89%E3%80%81%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8">
     三、日志使用
    </h2>
    <p>
     SpringBoot 内置了
     <span style="background-color:#dad5e9">
      日志框架
     </span>
     Slf4j ，我们可以直接在程序中调用
     <span style="color:#fe2c24">
      <span style="background-color:#fbd4d0">
       Slf4j
      </span>
     </span>
     来输出日志
    </p>
    <h3 id="%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97" name="%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97">
     打印日志
    </h3>
    <h4 id="%E6%AD%A5%E9%AA%A4" name="%E6%AD%A5%E9%AA%A4">
     步骤
    </h4>
    <p>
     • 在程序中得到日志对象.
    </p>
    <p>
     需要使用志工厂
     <span style="background-color:#dad5e9">
      LoggerFactory
     </span>
    </p>
    <pre><code class="language-java">private static Logger logger = LoggerFactory.getLogger(CaptchaController.class);</code></pre>
    <blockquote>
     <p>
      LoggerFactory.getLogger 需要传递⼀个参数, 标识这个日志的名称. 这样可以更清晰的知道是哪个类输出的日志. 当有问题时, 可以更方便直观的定位到问题类
     </p>
    </blockquote>
    <p>
     • 使用日志对象输出要打印的内容.
    </p>
    <p>
     日志对象的打印方法有很多种，我们可以先使用
     <span style="background-color:#f9eda6">
      info()
     </span>
     方法来输出日志
    </p>
    <pre><code class="language-java">logger.info("Logger生成验证码: " + code);</code></pre>
    <h3 id="%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D" name="%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D">
     日志框架介绍
    </h3>
    <p>
     <img alt="" height="462" src="https://i-blog.csdnimg.cn/direct/042bb772c03349f3aafd45f6a08c673e.png" width="1012"/>
    </p>
    <p>
     SLF4J不同于其他日志框架, 它不是一个真正的日志实现, 而是一个抽象层, 对日志框架制定的一种规范, 标准, 接口. 所有SLF4J并不能独立使用, 需要和具体的日志框架配合使用.
    </p>
    <h4 id="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F(%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F)" name="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F(%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F)" style="background-color:transparent">
     门面模式(外观模式)
    </h4>
    <p>
     SLF4J是门面模式的典型应用(但不仅仅使用了门面模式).
    </p>
    <p>
     门面模式(Facade Pattern)又称为外观模式，提供了一个统一的接口，用来访问子系统中的一群接口.其主要特征是定义了一个高层接口，让子系统更容易使用.
    </p>
    <p>
     <img alt="" height="243" src="https://i-blog.csdnimg.cn/direct/0a9718d0c6004072acaee002d975876e.png" width="1624"/>
    </p>
    <p>
     <img alt="" height="432" src="https://i-blog.csdnimg.cn/direct/7897c4804c154814b4193a3445d170fb.png" width="941"/>
    </p>
    <p>
     门面模式主要包含2种角色：
     <br/>
     外观角色(Facade):也称门面角色，系统对外的统一接口.
     <br/>
     子系统角色(SubSystem):可以同时有一个或多个SubSystem.每个SubSytem都不是一个单独的类，
     <br/>
     而是一个类的集合.SubSystem并不知道Facade的存在，对于SubSystem而言，Facade只是另一个客户端而已（即Facade对SubSystem透明）
    </p>
    <p>
     <img alt="" height="130" src="https://i-blog.csdnimg.cn/direct/31db6dbdd92445c4b84e225bd359907c.png" width="1624"/>
    </p>
    <p>
     <img alt="" height="665" src="https://i-blog.csdnimg.cn/direct/01d703ffa14f4cce94286ebf2b21ef59.png" width="1674"/>
    </p>
    <h4 id="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" name="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">
     门面模式的实现
    </h4>
    <p>
     场景: 回家, 我们会开各个屋的灯. 离开家时, 会关闭各个屋的灯. 如果家里设置⼀个总开关, 来控制整个屋的灯就会很方便.
    </p>
    <p>
     没建门面前
    </p>
    <pre><code class="language-java">package com.example.demo.facade;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public interface Light {
    void on();
    void off();
}

public HallLight implements Light {
    private static Logger logger = LoggerFactory.getLogger(HallLight.class);

    @Override
    public void on() {
        logger.info("打开走廊灯");
    }

    @Override
    public void off() {
        logger.info("关闭走廊灯");
    }
}

public LivingRoomLight implements Light {
    private static Logger logger = LoggerFactory.getLogger(LivingRoomLight.class);

    @Override
    public void on() {
        logger.info("打开客厅灯");
    }

    @Override
    public void off() {
        logger.info("关闭客厅灯");
    }
}

public BedRoomLight implements Light {
    private static Logger logger = LoggerFactory.getLogger(BedRoomLight.class);

    @Override
    public void on() {
        logger.info("打开卧室灯");
    }

    @Override
    public void off() {
        logger.info("关闭卧室灯");
    }
}

public class Main {
    public static void main(String[] args) {
        HallLight hallLight = new HallLight();
        LivingRoomLight livingRoomLight = new LivingRoomLight();
        BedRoomLight bedRoomLight = new BedRoomLight();
        hallLight.on();
        livingRoomLight.on();
        bedRoomLight.on();
    }
}</code></pre>
    <p>
     我们使用门面模式的实现
    </p>
    <pre><code class="language-java">package com.example.demo.facade;

public class LightFacade {
    void lightOn() {
        HallLight hallLight = new HallLight();
        LivingRoomLight livingRoomLight = new LivingRoomLight();
        BedRoomLight bedRoomLight = new BedRoomLight();
        hallLight.on();
        livingRoomLight.on();
        bedRoomLight.on();
    }

    void lightOff() {
        HallLight hallLight = new HallLight();
        LivingRoomLight livingRoomLight = new LivingRoomLight();
        BedRoomLight bedRoomLight = new BedRoomLight();
        hallLight.off();
        livingRoomLight.off();
        bedRoomLight.off();
    }
}
</code></pre>
    <pre><code class="language-java">package com.example.demo.facade;

public class Main {
    public static void main(String[] args) {
        LightFacade lightFacade = new LightFacade();
        lightFacade.lightOn();
        lightFacade.lightOff();
    }
}
</code></pre>
    <h4 id="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9" name="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9">
     门面模式的优点
    </h4>
    <p>
     ●减少了系统的相互依赖，实现了客户端与子系统的耦合关系，这使得子系统的变化不会影响到调用它的客户端.
     <br/>
     ●提高了灵活性，简化了客户端对子系统的使用难度，客户端无需关心子系统的具体实现方式，而只需要和门面对象交互即可.
     <br/>
     ●提高了安全性，可以灵活设定访问权限，不在门面对象中开通方法，就无法访问.
    </p>
    <p>
     SLF4J 就是其他日志框架的门面. SLF4J 可以理解为是提供日志服务的统一API接口, 并不涉及到具体的日志逻辑实现.
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB" name="%E5%9B%9B%E3%80%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">
     四、日志级别
    </h2>
    <p>
     日志级别代表着日志信息对应问题的严重性, 为了更快的筛选符合目标的日志信息.
    </p>
    <h3 id="%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E5%88%86%E7%B1%BB" name="%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E5%88%86%E7%B1%BB">
     日志级别分类
    </h3>
    <p>
     日志的级别从高到低依次为：FATAL、ERROR、WARN、INFO、DEBUG、TRACE
     <br/>
     🔺FATAL: 致命信息，表示需要立即被处理的系统级错误.
     <br/>
     🔺ERROR: 错误信息，级别较高的错误日志信息，但仍然不影响系统的继续运行.
     <br/>
     🔺WARN: 警告信息，不影响使用，但需要注意的问题.
     <br/>
     🔺INFO: 普通信息，用于记录应用程序正常运行时的一些信息，例如系统启动完成、请求处理完成等.
     <br/>
     🔺DEBUG: 调试信息，需要调试时候的关键信息打印.
     <br/>
     🔺TRACE: 追踪信息，比 DEBUG 更细粒度的信息事件（除非有特殊用意，否则请使用 DEBUG级别替代）.
    </p>
    <p>
     <img alt="" height="325" src="https://i-blog.csdnimg.cn/direct/47b074accb9f411b869708fd95a01280.png" width="1291"/>
    </p>
    <h3 id="%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BD%BF%E7%94%A8" name="%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BD%BF%E7%94%A8">
     日志级别的使用
    </h3>
    <pre><code class="language-java">package com.example.demo.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RequestMapping("/logger")
@RestController
public class LoggerLevelController {
    private static Logger logger = LoggerFactory.getLogger(LoggerLevelController.class);

    @RequestMapping("/print")
    public String print() {
        logger.trace("trace级别日志......");
        logger.debug("debug级别日志......");
        logger.info("info级别日志......");
        logger.warn("warn级别日志......");
        logger.error("error级别日志......");
        return "打印日志";
    }
}
</code></pre>
    <p>
     <img alt="" height="194" src="https://i-blog.csdnimg.cn/direct/a03f6a77f8324aadbe18a47c6956baab.png" width="576"/>
    </p>
    <p>
     <img alt="" height="392" src="https://i-blog.csdnimg.cn/direct/a76a65287cbe43c5996002bcc40c931f.png" width="1558"/>
    </p>
    <p>
     结果发现, 只打印了info, warn和error级别的日志.
    </p>
    <p>
     这与日志级别的配置有关, 日志的输出级别
     <span style="background-color:#f3f3f4">
      默认是 info 级别
     </span>
     , 所以只会打印
     <span style="background-color:#e7fafa">
      大于等于
     </span>
     此级别的日志, 也就是 info, warn和error.
    </p>
    <h3 id="%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE" name="%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE">
     日志配置
    </h3>
    <h4 id="%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB" name="%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">
     配置日志级别
    </h4>
    <pre><code>logging:
  level:
    root: debug</code></pre>
    <p>
     <img alt="" height="319" src="https://i-blog.csdnimg.cn/direct/e6121d302bce49769dcd14b10da1c1ed.png" width="1745"/>
    </p>
    <p>
     日志级别也可以
     <span style="background-color:#faa572">
      分类
     </span>
     来设置
    </p>
    <pre><code>logging:
  level:
    root: info
    com:
      example:
        demo:
          controller: trace</code></pre>
    <p>
     <img alt="" height="581" src="https://i-blog.csdnimg.cn/direct/b5b9869319854d95ba212f7dfee237b8.png" width="1722"/>
    </p>
    <h4 id="%E6%97%A5%E5%BF%97%E6%8C%81%E4%B9%85%E5%8C%96" name="%E6%97%A5%E5%BF%97%E6%8C%81%E4%B9%85%E5%8C%96">
     日志持久化
    </h4>
    <p>
     以上的日志都是输出在控制台上的, 然日在线上环境中, 我们需要
     <span style="background-color:#d4e9d5">
      把日志保存下来
     </span>
     , 以便出现问题之后追溯问题. 把日志保存下来就叫持久化.
    </p>
    <p>
     日志持久化有两种方式
    </p>
    <p>
     <img alt="" height="126" src="https://i-blog.csdnimg.cn/direct/1844c66312c14fe8abd2c124ddd18d80.png" width="1123"/>
    </p>
    <p>
     1️⃣配置日志文件名
    </p>
    <pre><code>logging:
  file:
    name: logger/springboot.log</code></pre>
    <p>
     后⾯可以跟绝对路径或者相对路径
     <br/>
     <img alt="" height="707" src="https://i-blog.csdnimg.cn/direct/c70910a78be048df859aa98d8421f07e.png" width="1919"/>
    </p>
    <p>
     2️⃣配置日志的存储目录
    </p>
    <pre><code>logging:
  file:
    path: D:/temp</code></pre>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/direct/2b548951080241eda92f02d8f4f0eff4.png" width="1060"/>
    </p>
    <pre><code>logging:
  file:
    path: D:/temp/aaa/springboot.log</code></pre>
    <p>
     <img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/dad5d4ec388b43c4a7c65a9585b97358.png" width="1026"/>
    </p>
    <p>
     这种方式只能设置日志的路径, 文件名为固定的
     <span style="background-color:#fbd4d0">
      spring.log
     </span>
    </p>
    <blockquote>
     <p>
      ⚠️logging.file.name 和 logging.file.path 两个都配置的情况下, 只生效其一, 以 logging.file.name 为准.
     </p>
    </blockquote>
    <h4 id="%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2" name="%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2">
     配置日志文件分割
    </h4>
    <p>
     如果我们的日志都放在一个文件中, 随着项目的运行, 日志文件会越来越大, 需要对日志文件进行分割.
    </p>
    <pre><code class="language-java">logging:
  file:
    #path: D:/temp/aaa/springboot.log
    name: logger/springboot.log
  logback:
    rollingpolicy:
      max-file-size: 1KB
      file-name-pattern: ${LOG_FILE}.%d{yyyy-MM-dd}.%i</code></pre>
    <p>
     <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/58f3a15cb9214b2daddb3df5d9476e98.png" width="358"/>
    </p>
    <blockquote>
     <p>
      1.日志文件超过 1KB 就分割（设置 1KB 是为了更好展示.企业开发通常设置为200M,500M等，此处没有明确标准)
      <br/>
      2.分割后的日志文件名为：日志名.日期.索引
     </p>
    </blockquote>
    <h2 id="%E4%BA%94%E3%80%81%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA" name="%E4%BA%94%E3%80%81%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA">
     五、更简单的日志输出
    </h2>
    <p>
     每次都使用 LoggerFactory.getLogger(xxx.class) 很繁琐, 且每个类都添加一遍, lombok 给我们提供了⼀种更简单的方式.
    </p>
    <p>
     1️⃣添加 lombok 框架支持
    </p>
    <p>
     2️⃣使用 @Slf4j 注解输出日志
    </p>
    <p>
     lombok 提供的 @Slf4j 会帮我们提供⼀个日志对象 log, 我们直接使用就可以.
    </p>
    <pre><code class="language-java">package com.example.demo.controller;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RequestMapping("/logger2")
@RestController
public class LoggerLevelController2 {
    //private static Logger logger = LoggerFactory.getLogger(LoggerLevelController2.class);

    @RequestMapping("/print")
    public String print() {
        log.trace("trace级别日志......");
        log.debug("debug级别日志......");
        log.info("info级别日志......");
        log.warn("warn级别日志......");
        log.error("error级别日志......");
        return "打印日志";
    }
}
</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303134313033372f:61727469636c652f64657461696c732f313436313332373531" class_="artid" style="display:none">
 </p>
</div>


