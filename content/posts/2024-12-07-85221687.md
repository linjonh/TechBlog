---
layout: post
title: "数据结构与算法-五大常用算法总结分治法,回溯法,分治限界法,贪心算法,动态规划法"
date: 2024-12-07 23:44:53 +0800
description: "1.分治法（Recurrence and Divide-Conquer）       对于一个规模为"
keywords: "数据结构常见的算法对比"
categories: ['数据结构与算法']
tags: ['贪心算法', '回溯法', '动态规划', '分治法', '分支界限']
artid: "85221687"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=85221687
    alt: "数据结构与算法-五大常用算法总结分治法,回溯法,分治限界法,贪心算法,动态规划法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=85221687
featuredImagePreview: https://bing.ee123.net/img/rand?artid=85221687
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构与算法- 五大常用算法总结（分治法，回溯法，分治限界法，贪心算法，动态规划法）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      1.分治法（Recurrence and Divide-Conquer）
     </strong>
    </p>
    <p>
     对于一个规模为n的问题，若该问题可以容易解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解决这些子问题。然后将各个子问题的解合并得到原问题的解
    </p>
    <p>
     <strong>
      2.回溯法（Back Tracking Method）
     </strong>
    </p>
    <p>
     在回溯法中，每次扩大当前部分解时，都面临一个可选的状态集合，新的部分解就通过在该集合中选择构造而成。这样的状态集合，其结构是一棵多叉树，每个树结点代表一个可能的部分解，它的儿子是在它的基础上生成的其他部分解。树根为初始状态，这样的状态集合称为状态
     <span style="color:#f33b45;">
      <strong>
       空间树
      </strong>
     </span>
     。
     <br/>
     回溯法对任一解的生成，一般都采用逐步扩大解的方式。每前进一步，都试图在当前部分解的基础上扩大该部分解。它在问题的状态空间树中，从开始结点（根结点）出发，以
     <span style="color:#f33b45;">
      <strong>
       深度优先搜索
      </strong>
     </span>
     整个状态空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点。这个新结点成为新的活结点，并成为当前扩展结点。如果在当前扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的活结点处，并使这个活结点成为当前扩展结点。回溯法以这种工作方式递归地在状态空间中搜索，直到找到所要求的解或解空间中已无活结点时为止。
     <br/>
     <span style="color:#f33b45;">
      <strong>
       回溯法与穷举法
      </strong>
     </span>
     有某些联系，它们都是基于试探的。穷举法要将一个解的各个部分全部生成后，才检查是否满足条件，若不满足，则直接放弃该完整解，然后再尝试另一个可能的完整解，它并没有沿着一个可能的完整解的各个部分逐步回退生成解的过程。而对于回溯法，一个解的各个部分是逐步生成的，当发现当前生成的某部分不满足约束条件时，就放弃该步所做的工作，退到上一步进行新的尝试，而不是放弃整个解重来。
    </p>
    <p>
     <strong>
      3.分治限界法（Branch-and-Bound）
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     分支限界法常以
     <span style="color:#f33b45;">
      <strong>
       广度优先
      </strong>
     </span>
     或以最小耗费（最大效益）优先的方式搜索问题的解空间树。
     <br/>
     在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。
    </p>
    <p>
     <span style="color:#f33b45;">
      <strong>
       分治界限与回溯法之间的差异:
      </strong>
     </span>
    </p>
    <p>
     1）控制条件:回溯法一般使用约束函数产生部分解，如果瞒住约束条件则继续扩大该解；否则丢弃重新搜索，而在分治界限法中，除了使用约束函数外，还使用更有小的评判函数---目标函数控制搜索进程，使尽快得到最优解
    </p>
    <p>
     2).搜索方式：回溯法种的搜索一般是以
     <span style="color:#f33b45;">
      <strong>
       深度优先反向
      </strong>
     </span>
     搜索，而在分支界限中一般是以
     <strong>
      <span style="color:#f33b45;">
       广度优先方式
      </span>
     </strong>
     进行
    </p>
    <p>
     从活结点表中选择下一扩展结点的不同方式导致不同的分支界限方法。常用的有下列两种方式
    </p>
    <ul>
     <li>
      队列式(FIFO) 分支界限法：将活结点表组成一个队列，并按照队列的先进先出原则选取下一个结点为当前扩展结点
     </li>
     <li>
      优先队列式分支界限法：将活结点表组织成一个优先队列。并按照优先队列中结点优先级选取优先级最高的下一个结点成      为当前扩展结点
     </li>
    </ul>
    <p>
     <strong>
      4.贪心算法（Greedy Method）
     </strong>
    </p>
    <p>
     贪心算法通过一系列的选择得到问题的解。它所做出的每一个选择都是当前状态下局部最好选择，即贪心选择。这种启发式的策略并不总能获得最优解。然而在许多情况下的确能得到最优解
    </p>
    <p>
     性质: 贪心选择性质和最优子结构性质
    </p>
    <p>
     <strong>
      贪心选择性质:
     </strong>
     贪心选择性质是指所求问题的整体最优解可以通过一序列局部最优的选择（贪心选择）来达到。它采用自顶向下的方式将所求问题简化为规模更小的子问题
    </p>
    <p>
     <strong>
      最优子结构的性质:
     </strong>
     当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
    </p>
    <p>
     <strong>
      5.动态规划法（Dynamic Programming）
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     动态规划算法的基本思想与分治法和回溯法类似，也是基于问题的划分解决方案（多步决策，递增生成子解）。动态规划是一种将问题实例分解为更小的，相似的子问题，并存储于子问题的解而避免计算重复的子问题，以解决最优化问题的算法策略。但在递增生成子解的过程中，力图朝最优方向进行，而且也不回溯，因此比动态规划效率要高，且常用来求最优解，而不像回溯法那样可直接求全解
    </p>
    <p>
     <span style="color:#f33b45;">
      <strong>
       注意事项与满足条件:即最优化原理（最优子结构性质）和子问题的重叠性
      </strong>
     </span>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f77656978696e5f3433383730303236:2f61727469636c652f64657461696c732f3835323231363837" class_="artid" style="display:none">
 </p>
</div>


