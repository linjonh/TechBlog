---
layout: post
title: "刷leetcode-hot100-动态规划3.12-"
date: 2025-03-13 00:19:01 +0800
description: "/负数：负数奇数【若无0，则为左边数组，右边数组取max】,有0，分成两半，看左边负数个数，右边负数个数，依旧是无0的操作。//首先不用管0,因为int a = 1,int max = nums[0],如果遇到0，a = 1即可。//一个很厉害的方法是从左向右和从右向左遍历一次，负数？//看了评论区，两个能合起来：负数偶数【不用管，遍历取max】，//负数和0分开处理，负数看奇数偶数，0分左右两边/就是0。//全是整数【负数，0，正数】，乘积max,连续子数组。//负数和0如何处理。"
keywords: "刷leetcode hot100--动态规划3.12 "
categories: ['未分类']
tags: ['算法', '动态规划', 'Leetcode']
artid: "146200625"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146200625
    alt: "刷leetcode-hot100-动态规划3.12-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146200625
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146200625
cover: https://bing.ee123.net/img/rand?artid=146200625
image: https://bing.ee123.net/img/rand?artid=146200625
img: https://bing.ee123.net/img/rand?artid=146200625
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     刷leetcode hot100--动态规划3.12
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     第一题乘积max子数组[1h++]
    </h3>
    <p>
     emmmm感觉看不懂题解
    </p>
    <h4>
     线性dp【计划学一下acwing，挨个做一下】
    </h4>
    <p>
     <a href="https://www.bilibili.com/video/BV1qu4y1t7NW/?spm_id_from=333.337.search-card.all.click&amp;vd_source=dc9b43cdb02413275be41ff8ba7cb900" rel="nofollow" title="线性动态规划 相似题解析 最长上升子序列 最大上升子序列和 最大连续子段和 乘积最大子数组_哔哩哔哩_bilibili">
      线性动态规划 相似题解析 最长上升子序列 最大上升子序列和 最大连续子段和 乘积最大子数组_哔哩哔哩_bilibili
     </a>
    </p>
    <p>
     <img alt="" height="693" src="https://i-blog.csdnimg.cn/direct/8d2c8d57bd0e43ceb71d6dde8b4f44ab.png" width="1219"/>
    </p>
    <p>
     比较奇怪的就是有正负数和0，如何处理？
    </p>
    <p>
     核心是维护一个max和min
    </p>
    <blockquote>
     <p>
      //全是整数【负数，0，正数】，乘积max,连续子数组
     </p>
     <p>
      //暴力求解？？起始i,终止j，遍历
     </p>
     <p>
      //dp[n]以nums[n]结束的连续子数组的max乘积
     </p>
     <p>
      //初始化dp[n] = nums[n]
     </p>
     <p>
      //有负数怎么办？？，或者说其实是整数的话，只用关注0，负数
     </p>
     <p>
      //负数和0如何处理
     </p>
     <p>
      //负数和0分开处理，负数看奇数偶数，0分左右两边/就是0
     </p>
     <p>
      //看了评论区，两个能合起来：负数偶数【不用管，遍历取max】，
     </p>
     <p>
      //首先不用管0,因为int a = 1,int max = nums[0],如果遇到0，a = 1即可
     </p>
     <p>
      //负数：负数奇数【若无0，则为左边数组，右边数组取max】,有0，分成两半，看左边负数个数，右边负数个数，依旧是无0的操作
     </p>
     <p>
      //一个很厉害的方法是从左向右和从右向左遍历一次，负数？？取max
     </p>
     <p>
      //dp想法是维护min和max
     </p>
    </blockquote>
    <p>
     题解：
    </p>
    <pre><code class="hljs">class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        long maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i &lt; nums.size(); ++i) {
            long mx = maxF, mn = minF;
            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));
            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));
            if(minF&lt;INT_MIN) {
                minF=nums[i];
            }
            ans = max(maxF, ans);
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363635333630352f:61727469636c652f64657461696c732f313436323030363235" class_="artid" style="display:none">
 </p>
</div>


