---
layout: post
title: "go-context学习"
date: 2025-03-09 17:47:17 +0800
description: "返回这个context的deadline(结束时间）和ok，如果context设置了deadline,ok=ture，反之ok=false。context接口源码中有两个实现，context.Background()和context.TODO()，都返回一个emptyCtx。Done()返回一个chan，当调用<-ctx.Done()，会一直阻塞，如果ctx的deadline时间到了，才能从chan返回。cotext还有很多其他方法，相当于返回context的一个特定实现，各有不同的功能。"
keywords: "go context学习"
categories: ['未分类']
tags: ['Golang']
artid: "146133247"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146133247
    alt: "go-context学习"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146133247
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146133247
cover: https://bing.ee123.net/img/rand?artid=146133247
image: https://bing.ee123.net/img/rand?artid=146133247
img: https://bing.ee123.net/img/rand?artid=146133247
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     go context学习
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="1Context_1">
     </a>
     1.Context接口
    </h3>
    <p>
     Context接口只有四个方法，以下是context源码。
    </p>
    <pre><code>type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() &lt;-chan struct{}
	Err() error
	Value(key any) any
}

</code></pre>
    <h3>
     <a id="2emptyCtx_13">
     </a>
     2.emptyCtx
    </h3>
    <p>
     context接口源码中有两个对外的实现，context.Background()和context.TODO()，都返回一个emptyCtx。
    </p>
    <p>
     Background()和TODO()可以看作是emptyCtx的别名，用法如下：
    </p>
    <ul>
     <li>
      Background(),当我们自己创建一个context,可以用context.Background();
     </li>
     <li>
      TODO(),当我们调用一个方法，方法有个参数是context，我们又没有context可以传，就可以传context.TODO()。
     </li>
    </ul>
    <pre><code>func Background() Context {
	return backgroundCtx{}
}
func TODO() Context {
	return todoCtx{}
}
type backgroundCtx struct{ emptyCtx }
type todoCtx struct{ emptyCtx }

type emptyCtx struct{}
func (emptyCtx) Deadline() (deadline time.Time, ok bool) {
	return
}
func (emptyCtx) Done() &lt;-chan struct{} {
	return nil
}
func (emptyCtx) Err() error {
	return nil
}
func (emptyCtx) Value(key any) any {
	return nil
}
</code></pre>
    <h3>
     <a id="3Deadline_47">
     </a>
     3.Deadline()方法
    </h3>
    <pre><code>Deadline() (deadline time.Time, ok bool)
</code></pre>
    <p>
     返回这个context的deadline(结束时间）和ok，如果context设置了deadline,ok=ture，反之ok=false
     <br/>
     如下可以看到，context如果没有设置deadline,则默认时间是“0001-01-01 00:00:00 +0000 UTC”
    </p>
    <pre><code>func TestContextDeadline(t *testing.T) {
	ctx := context.Background()
	deadline, ok := ctx.Deadline()
	fmt.Println(deadline)     //输出，0001-01-01 00:00:00 +0000 UTC
	fmt.Print(ok)  // 输出，false
}
</code></pre>
    <p>
     下面这是设置了时间的，可以看到dealine是当前时间加10秒，
    </p>
    <pre><code>func TestContextDeadline(t *testing.T) {
	fmt.Println(time.Now())
	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	deadline, ok := ctx.Deadline()
	fmt.Println(deadline)
	fmt.Println(ok)
}
输出：
2025-03-09 15:58:20.2027155 +0800 CST m=+0.001014101
2025-03-09 15:58:30.2080898 +0800 CST m=+10.006388401
true
</code></pre>
    <p>
     如里对一个子contex设置的deadline时间比已有的contex大(就是比父context大)，则不会生效
    </p>
    <pre><code>func TestContextDeadline2(t *testing.T) {
	fmt.Println(time.Now())
	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	fmt.Println(ctx.Deadline())
	ctx2, _ := context.WithDeadline(ctx, time.Now().Add(15*time.Second))
	fmt.Println(ctx2.Deadline())
}
输出：
2025-03-09 18:11:08.6194041 +0800 CST m=+0.001034701
2025-03-09 18:11:18.6251276 +0800 CST m=+10.006758201 true
2025-03-09 18:11:18.6251276 +0800 CST m=+10.006758201 true
</code></pre>
    <p>
     ctx2的dealine并没有加15秒，而是和父deadline一样。
     <br/>
     如果子deadline比父小，子deadline就会生效，并且父deadline不受影响。如下：
    </p>
    <pre><code>func TestContextDeadline2(t *testing.T) {
	fmt.Println(time.Now())
	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	fmt.Println(ctx.Deadline())
	ctx2, _ := context.WithDeadline(ctx, time.Now().Add(5*time.Second))
	fmt.Println(ctx2.Deadline())
	fmt.Println(ctx.Deadline())
}
输出：
2025-03-09 18:16:08.5541102 +0800 CST m=+0.003605801
2025-03-09 18:16:18.5612081 +0800 CST m=+10.010703701 true
2025-03-09 18:16:13.5612081 +0800 CST m=+5.010703701 true
2025-03-09 18:16:18.5612081 +0800 CST m=+10.010703701 true
</code></pre>
    <h3>
     <a id="4Done_112">
     </a>
     4.Done()方法
    </h3>
    <pre><code>Done() &lt;-chan struct{}
</code></pre>
    <p>
     Done()返回一个chan，当调用&lt;-ctx.Done()，会一直阻塞，如果ctx的deadline时间到了，才能从chan返回
    </p>
    <pre><code>func TestContextDone(t *testing.T) {
	fmt.Println(time.Now())
	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	deadline, ok := ctx.Deadline()
	fmt.Println(deadline)
	fmt.Println(ok)
	&lt;-ctx.Done()   //Done()会一直阻塞等到deadline时间到了才结束
	fmt.Println(time.Now())    //当前时间加了10秒，因为&lt;-ctx.Done() 阻塞了10秒
}
输出：
2025-03-09 16:02:27.898926 +0800 CST m=+0.001548101
2025-03-09 16:02:37.9048716 +0800 CST m=+10.007493701
true
2025-03-09 16:02:37.9052627 +0800 CST m=+10.007884801
</code></pre>
    <p>
     注意context.WithDeadline（）方法还返回一个cancel
    </p>
    <pre><code>func TestContextDeadline(t *testing.T) {
	fmt.Println(time.Now())
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	deadline, ok := ctx.Deadline()
	fmt.Println(deadline)
	fmt.Println(ok)
	cancel()    //cancel会让context立刻结束，
	&lt;-ctx.Done() ///Done()不会阻塞
	fmt.Println(time.Now())
}
输出：
2025-03-09 17:25:36.815137 +0800 CST m=+0.001292801
2025-03-09 17:25:46.8209512 +0800 CST m=+10.007107001
true
2025-03-09 17:25:36.8209512 +0800 CST m=+0.007107001
</code></pre>
    <p>
     如果ctx没有设置deadline，ctx.Done()返回nil
    </p>
    <pre><code>func TestContextDone(t *testing.T) {
	ctx := context.Background()
	fmt.Println(ctx.Done())   //输出nil
}
</code></pre>
    <h3>
     <a id="5Err_163">
     </a>
     5.Err方法
    </h3>
    <pre><code>Err() error
</code></pre>
    <p>
     返回一个错误，有两种错误
     <br/>
     1.deadline时间到了
     <br/>
     2.ctx被cancel了
    </p>
    <p>
     以下是deadline时间到了的示例：
    </p>
    <ul>
     <li>
      ctx设置10秒后结束 ，第一次调用ctx.Err()，输出nill(因为还没到10秒，ctx还没结束）
     </li>
     <li>
      等到11秒后，ctx.Err()输出了结束原因context deadline exceeded（deadline到时间结束）。
     </li>
    </ul>
    <p>
     <strong>
      如果ctx结束了，调用ctx.Err()返回的结果一样，下面调用了三次，结果一样。
     </strong>
    </p>
    <pre><code>func TestContextErr(t *testing.T) {
	fmt.Println(time.Now())
	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	fmt.Println(ctx.Err())
	time.Sleep(11 * time.Second)
	fmt.Println(time.Now())
	fmt.Println(ctx.Err())
	fmt.Println(ctx.Err())
	fmt.Println(ctx.Err())
}
输出：
2025-03-09 16:17:04.7489444 +0800 CST m=+0.001009401
&lt;nil&gt;
2025-03-09 16:17:15.7551472 +0800 CST m=+11.007212201
context deadline exceeded
context deadline exceeded
context deadline exceeded
</code></pre>
    <p>
     以下是cancel示例
    </p>
    <pre><code>func TestContextDeadline(t *testing.T) {
	fmt.Println(time.Now())
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	deadline, ok := ctx.Deadline()
	fmt.Println(deadline)
	fmt.Println(ok)
	cancel()      //调用了cancel()
	&lt;-ctx.Done() 
	fmt.Println(time.Now())
	fmt.Println(ctx.Err())
}
输出：
2025-03-09 17:54:11.8989047 +0800 CST m=+0.001138201
2025-03-09 17:54:21.9048333 +0800 CST m=+10.007066801
true
2025-03-09 17:54:11.9048333 +0800 CST m=+0.007066801
context canceled
</code></pre>
    <h3>
     <a id="6Value_217">
     </a>
     6.Value方法（）
    </h3>
    <pre><code>Value(key any) any
</code></pre>
    <p>
     就是往context存了key/value形式的数据，然后通过Value()方法取出这个值。
    </p>
    <pre><code>func TestContextValue(t *testing.T) {
	ctx := context.WithValue(context.Background(), "name", "daniel")
	fmt.Println(ctx.Value("name"))     //输出daniel
}
</code></pre>
    <h3>
     <a id="7contex_231">
     </a>
     7.contex应用场景
    </h3>
    <p>
     context是多线程安全的，常用于并发控制技术，在不同的goroutine之间同步请求特定的数据、取消信号以及处理请求的dealine(截止日期)。
     <br/>
     <strong>
      通知其他goroutine结束
     </strong>
     <br/>
     如下所示，设置findUser()方法只能查找用户10秒钟，10秒后强制结束这个goroutine。
    </p>
    <pre><code>func findUser(ctx context.Context, id int) {
	//输出ctx结束时间
	fmt.Println(ctx.Deadline())
	for {
		//模拟根据id查找用户
		time.Sleep(2 * time.Second)
		select {
		case &lt;-ctx.Done():
			fmt.Println("ctx被取消，查找结束")
			fmt.Println(ctx.Err())
			fmt.Println(time.Now())
			return
		default:
			fmt.Println("正在查找中...")
		}
	}
}

func TestContext(t *testing.T) {
	fmt.Println(time.Now())
	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	go findUser(ctx, 100)
	time.Sleep(20 * time.Second)
}
输出：
2025-03-09 16:46:05.7818671 +0800 CST m=+0.000000001
2025-03-09 16:46:15.7892368 +0800 CST m=+10.007369701 true
正在查找中...
正在查找中...
正在查找中...
正在查找中...
ctx被取消，查找结束
context deadline exceeded
2025-03-09 16:46:15.7919931 +0800 CST m=+10.010126001
</code></pre>
    <h3>
     <a id="8context_272">
     </a>
     8.其他context方法
    </h3>
    <p>
     cotext还有很多其他方法，相当于返回context的一个特定实现（context内部的实现），各有不同的功能。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9a9f45eb3c5b4bafa23907b7157e8ea7.png">
      <br/>
      ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
      <br/>
      比如上面这个会返回一个带deadline方法，其实是返回一个timerCtx，里面记下了deadline,
      <br/>
      可以看到这些方法里面都有c.m.lock()方法，所以context是多线程安全的。
      <br/>
      context源码也比较简单，有兴趣自行看看源码。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a03d3661d7b8420ab9d5da19bd95a6e0.png">
       <br/>
       timerCtx开头是小写的，也就是context内部的实现
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/eb0592115ccc4a74a431a5410a24ec06.png">
        <br/>
        context.WithDeadlineCause（）也可以自定义一个cause
       </img>
      </img>
     </img>
    </p>
    <pre><code>func TestContextDeadlineCause(t *testing.T) {
	ctx, _ := context.WithDeadlineCause(context.Background(),
		time.Now().Add(10*time.Second), errors.New("my error"))
	fmt.Println(context.Cause(ctx))
	time.Sleep(11 * time.Second)  //context.Cause(ctx）先输出nill，等结事时间到了才输出真正的cause
	fmt.Println(context.Cause(ctx))
}
输出
&lt;nil&gt;
my error
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32313135393936332f:61727469636c652f64657461696c732f313436313333323437" class_="artid" style="display:none">
 </p>
</div>


