---
layout: post
title: "32构造函数"
date: 2025-03-14 17:25:27 +0800
description: "function  类型名(形参, ...){this.新属性名=形参;... = ...;"
keywords: "32、构造函数"
categories: ['前端面试题']
tags: ['开发语言', 'Javascript', 'Ecmascript']
artid: "146258240"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146258240
    alt: "32构造函数"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146258240
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146258240
cover: https://bing.ee123.net/img/rand?artid=146258240
image: https://bing.ee123.net/img/rand?artid=146258240
img: https://bing.ee123.net/img/rand?artid=146258240
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     32、构造函数
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     <strong>
      <strong>
       1、用构造函数反复创建多个相同结果的对象
      </strong>
     </strong>
    </h2>
    <table border="1" cellspacing="0">
     <tbody>
      <tr>
       <td style="vertical-align:top; width:401.5000pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <strong>
           问题
          </strong>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          如果想反复创建多个相同结构
         </span>
         <span style="color:#000000">
          ，
         </span>
         <span style="color:#000000">
          但是内容不同的对象时
         </span>
         <span style="color:#000000">
          ，
         </span>
         <span style="color:#000000">
          用
         </span>
         <span style="color:#000000">
          {
          <!-- -->
         </span>
         <span style="color:#000000">
          }创建
         </span>
         <span style="color:#000000">
          会代码重复，及其不便于维护！
         </span>
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; width:401.5000pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <strong>
           解决
          </strong>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <span style="color:#7030a0">
           <strong>
            今后只要想反复创建同一类型的多个相同结构不同内容的对象时
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            ，
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            都用构造函数来创建
           </strong>
          </span>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <span style="color:#c00000">
           <strong>
            专门描述同一类型所有对象的同一结构的函数
           </strong>
          </span>
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; width:401.5000pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <strong>
           如何
          </strong>
         </strong>
         <strong>
          <strong>
           :
          </strong>
         </strong>
         <strong>
         </strong>
         <strong>
          <strong>
           2
          </strong>
         </strong>
         <strong>
          <strong>
           步
          </strong>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <strong>
           i. 先定义构造函数
          </strong>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         function  类型名(形参, ...){
         <!-- -->
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#00b0f0">
          this.
         </span>
         新属性名=形参;
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         ... = ... ;
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <s>
          <span style="color:#7f7f7f">
           <s>
            this.新方法名
           </s>
          </span>
         </s>
         <s>
          <span style="color:#7f7f7f">
           <s>
            =
           </s>
          </span>
         </s>
         <s>
          <span style="color:#7f7f7f">
           <s>
            function(){
            <!-- -->
           </s>
          </span>
         </s>
         <br/>
         <s>
         </s>
         <s>
         </s>
         <s>
         </s>
         <s>
          <span style="color:#7f7f7f">
           <s>
            ... this.属性名
           </s>
          </span>
         </s>
         <s>
         </s>
         <s>
          <span style="color:#7f7f7f">
           <s>
            ...
           </s>
          </span>
         </s>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <s>
          <span style="color:#7f7f7f">
           <s>
            }
           </s>
          </span>
         </s>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         }
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <strong>
           ii. 调用构造函数创建新对象
          </strong>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         var 新对象名=new 类型名();
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; width:401.5000pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <strong>
           优点
          </strong>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         代码重用，便于维护！
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h2>
     2、new构造函数时都做了什么?
    </h2>
    <p>
     <br/>
     1.创建一个空对象
     <br/>
     var obj = {};
     <br/>
     <br/>
     2.链接到原型,将obj的proto指向构造函数的prototype
     <br/>
     obj._proto = 类名._prototype;
     <br/>
     <br/>
     4.绑定this值,让function函数的this指向obj,并执行函数体
     <br/>
     类名.call(obj);
     <br/>
     <br/>
     5.返回这个对象
    </p>
    <h2>
     <strong>
      3、构造函数的问题
     </strong>
    </h2>
    <table border="1" cellspacing="0">
     <tbody>
      <tr>
       <td style="vertical-align:top; width:426.1000pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <strong>
          <span style="color:#7030a0">
           <strong>
            如果将方法的定义放在构造函数内
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            ，
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            每调用一次构造函数
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            ，
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            创建一个新对象
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            ，
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            都会反复创建相同的方法的副本
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            ！——
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            浪费内存
           </strong>
          </span>
         </strong>
         <strong>
          <span style="color:#7030a0">
           <strong>
            ！
           </strong>
          </span>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#ff0000">
          今后，
         </span>
         <span style="color:#ff0000">
          所有多个子对象共用的属性值或方法定义
         </span>
         <span style="color:#ff0000">
          ，
         </span>
         <span style="color:#ff0000">
          都要添加到原型对象中
         </span>
         <span style="color:#ff0000">
          :
         </span>
         <span style="color:#ff0000">
          强行赋值
         </span>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#ff0000">
          构造函数
         </span>
         <span style="color:#ff0000">
          .
         </span>
         <span style="color:#ff0000">
          prototype.新成员
         </span>
         <span style="color:#ff0000">
          =新值。
         </span>
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code>&lt;script&gt;
    //定义构造函数描述所有学生对象的同一结构
    function Student(sname, sage){
      this.sname=sname;
      this.sage=sage;
      //构造函数中不要包含方法定义！
    }
    //输出Student类型的原型对象
    console.log(Student.prototype);

    //向Student的原型对象中强行添加新共有方法
    Student.prototype.intr=function(){
      console.log(`I'm ${this.sname}, I'm ${this.sage}`)
    }
    console.log(Student.prototype);

    //反复调用构造函数创建lilei和hmm
    var lilei=new Student("Li Lei",11);
    var hmm=new Student("Han Meimei",12);

    //亲子鉴定   
    console.log(
    //李磊的 爹     是不是Student的老公
      lilei.__proto__==Student.prototype
    );//true

    console.log(
      //李磊的爹    是不是hmm的爹
      lilei.__proto__==hmm.__proto__
    );//true

    console.log(lilei);

    console.log(hmm);

    lilei.intr();

    hmm.intr();
&lt;/script&gt;</code></pre>
    <p>
     <span style="color:#be191c">
      <strong>
       注：根据 ES6 规范，箭头函数不能用作构造函数，使用
       <code>
        new
       </code>
       调用会抛出错误。其次，箭头函数是否有
       <code>
        prototype
       </code>
       属性？没有，普通函数才有
       <code>
        prototype
       </code>
       属性，箭头函数没有，所以
       <code>
        person.prototype
       </code>
       是
       <code>
        undefined
       </code>
       ，无法添加方法。
      </strong>
     </span>
    </p>
    <h2>
     4、
     <strong>
      <strong>
       自有属性和共有属性
      </strong>
     </strong>
    </h2>
    <table border="1" cellspacing="0">
     <tbody>
      <tr>
       <td style="vertical-align:top; width:439.6500pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         a.
         <strong>
          <span style="color:#c00000">
           <strong>
            自有属性
           </strong>
          </span>
         </strong>
         : 保存在当前对象自身内部的属性，只归当前对象自己所有的属性。今后，凡是构造函数中this.后的属性，都会成为自对象的自有属性
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; width:439.6500pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         b.
         <strong>
          <span style="color:#c00000">
           <strong>
            共有属性
           </strong>
          </span>
         </strong>
         : 保存在原型对象/父对象中的，归多个子对象共有的属性
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; width:439.6500pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         c.
         <strong>
          <span style="color:#c00000">
           <strong>
            获取属性值
           </strong>
          </span>
         </strong>
         : 无论自有属性，还是共有属性，都可用:
         <strong>
          <u>
           <span style="color:#000000">
            <strong>
             <u>
              子对象
             </u>
            </strong>
           </span>
          </u>
         </strong>
         <strong>
          <u>
           <span style="color:#000000">
            <strong>
             <u>
              .属性名
             </u>
            </strong>
           </span>
          </u>
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; width:439.6500pt">
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         d.
         <strong>
          <span style="color:#c00000">
           <strong>
            修改属性值
           </strong>
          </span>
         </strong>
         :
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          1
         </span>
         <span style="color:#000000">
          ).
         </span>
         <span style="color:#000000">
          修改
         </span>
         <strong>
          <span style="color:#000000">
           <strong>
            自有属性
           </strong>
          </span>
         </strong>
         <span style="color:#000000">
          的值
         </span>
         <span style="color:#000000">
          :
         </span>
         <strong>
          <u>
           <span style="color:#c00000">
            <strong>
             <u>
              子对象
             </u>
            </strong>
           </span>
          </u>
         </strong>
         <strong>
          <u>
           <span style="color:#c00000">
            <strong>
             <u>
              .属性名=属性值
             </u>
            </strong>
           </span>
          </u>
         </strong>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          2). 修改
         </span>
         <strong>
          <span style="color:#000000">
           <strong>
            共有属性
           </strong>
          </span>
         </strong>
         <span style="color:#000000">
          的值
         </span>
         <span style="color:#000000">
          :
         </span>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          i. 错误
         </span>
         <span style="color:#000000">
          :
         </span>
         <s>
          <span style="color:#000000">
           <s>
            子对象
           </s>
          </span>
         </s>
         <s>
          <span style="color:#000000">
           <s>
            .
           </s>
          </span>
         </s>
         <s>
          <span style="color:#000000">
           <s>
            共有属性
           </s>
          </span>
         </s>
         <s>
          <span style="color:#000000">
           <s>
            =属性值
           </s>
          </span>
         </s>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          如果强行给子对象不存在的属性赋值
         </span>
         <span style="color:#000000">
          ，
         </span>
         <span style="color:#000000">
          不会去原型对象中查找属性
         </span>
         <span style="color:#000000">
          。而是自动给当前子对象自己添加一个新属性。
         </span>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          如果新属性与原型对象中的属性同名
         </span>
         <span style="color:#000000">
          ，
         </span>
         <span style="color:#000000">
          按就近原则
         </span>
         <span style="color:#000000">
          ，
         </span>
         <span style="color:#000000">
          只要访问子对象
         </span>
         <span style="color:#000000">
          .属性名时，永远只能使用自己自有的属性。不在去原型对象中查找。
         </span>
        </p>
        <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
         <span style="color:#000000">
          ii. 正确
         </span>
         <span style="color:#000000">
          :
         </span>
         <span style="color:#000000">
          只要想修改原型对象中共有的属性
         </span>
         <span style="color:#000000">
          ，
         </span>
         <span style="color:#000000">
          都必须用原型对象来修改
         </span>
         <span style="color:#000000">
          :
         </span>
         <strong>
          <u>
           <span style="color:#c00000">
            <strong>
             <u>
              构造函数
             </u>
            </strong>
           </span>
          </u>
         </strong>
         <strong>
          <u>
           <span style="color:#c00000">
            <strong>
             <u>
              .
             </u>
            </strong>
           </span>
          </u>
         </strong>
         <strong>
          <u>
           <span style="color:#c00000">
            <strong>
             <u>
              prototype.共有属性
             </u>
            </strong>
           </span>
          </u>
         </strong>
         <strong>
          <u>
           <span style="color:#c00000">
            <strong>
             <u>
              =属性值
             </u>
            </strong>
           </span>
          </u>
         </strong>
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     5、
     <strong>
      <strong>
       原型链
      </strong>
     </strong>
    </h2>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     a. 什么是: 由多级父对象/原型对象逐级继承，形成的链式结构
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     b. 保存着: 一个对象可用的所有属性和方法！
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     c. 控制着: 对象属性和方法的使用顺序:
     <strong>
      <span style="color:#7030a0">
       <strong>
        就近原则
       </strong>
      </span>
     </strong>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     1). 优先在当前对象内部查找自有属性
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     2). 当前对象内部没有想要的属性，才自动延_ _proto_ _去父对象中查找！
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353630303136352f:61727469636c652f64657461696c732f313436323538323430" class_="artid" style="display:none">
 </p>
</div>


