---
layout: post
title: "Spark-中的窗口函数"
date: 2025-03-15 23:36:16 +0800
description: "窗口函数通过Window分区（Partitioning）：将数据分为多个组（类似于GROUP BY排序（Ordering）：在每个分区内对数据进行排序。窗口范围（Frame）：定义窗口的大小（如当前行及其前后若干行）。.partitionBy(\"column1\", \"column2\") // 按列分区.orderBy(\"column3\") // 按列排序.rowsBetween(start, end) // 定义窗口范围（可选）：指定分区的列。orderBy：指定排序的列。：定义窗口的范围（如。"
keywords: "Spark 中的窗口函数"
categories: ['未分类']
tags: ['大数据', 'Spark', 'Scala']
artid: "146287696"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146287696
    alt: "Spark-中的窗口函数"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146287696
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146287696
cover: https://bing.ee123.net/img/rand?artid=146287696
image: https://bing.ee123.net/img/rand?artid=146287696
img: https://bing.ee123.net/img/rand?artid=146287696
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spark 中的窗口函数
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Spark 中，
     <strong>
      窗口函数（Window Functions）
     </strong>
     是一种强大的工具，用于在分组数据上执行复杂的聚合操作，同时保留原始数据的行。窗口函数允许你在数据的某个“窗口”内进行计算，例如计算排名、累积和、移动平均等。
    </p>
    <p>
     窗口函数的核心思想是定义一个“窗口”（通过
     <code>
      Window
     </code>
     类），然后在这个窗口上应用聚合函数（如
     <code>
      row_number
     </code>
     、
     <code>
      rank
     </code>
     、
     <code>
      sum
     </code>
     、
     <code>
      avg
     </code>
     等）。
    </p>
    <hr/>
    <h4>
     1.
     <strong>
      窗口函数的基本概念
     </strong>
    </h4>
    <h5>
     （1）窗口的定义
    </h5>
    <p>
     窗口函数通过
     <code>
      Window
     </code>
     类定义，主要包括以下两个部分：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        分区（Partitioning）
       </strong>
       ：将数据分为多个组（类似于
       <code>
        GROUP BY
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序（Ordering）
       </strong>
       ：在每个分区内对数据进行排序。
      </p>
     </li>
     <li>
      <p>
       <strong>
        窗口范围（Frame）
       </strong>
       ：定义窗口的大小（如当前行及其前后若干行）。
      </p>
     </li>
    </ul>
    <h5>
     （2）常见的窗口函数
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        排名函数
       </strong>
       ：
       <code>
        row_number
       </code>
       、
       <code>
        rank
       </code>
       、
       <code>
        dense_rank
       </code>
       、
       <code>
        percent_rank
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        聚合函数
       </strong>
       ：
       <code>
        sum
       </code>
       、
       <code>
        avg
       </code>
       、
       <code>
        min
       </code>
       、
       <code>
        max
       </code>
       、
       <code>
        count
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        分析函数
       </strong>
       ：
       <code>
        lead
       </code>
       、
       <code>
        lag
       </code>
       、
       <code>
        first_value
       </code>
       、
       <code>
        last_value
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     2.
     <strong>
      窗口函数的语法
     </strong>
    </h4>
    <h5>
     （1）定义窗口
    </h5>
    <pre><code class="language-Scala">import org.apache.spark.sql.expressions.Window

val windowSpec = Window
  .partitionBy("column1", "column2") // 按列分区
  .orderBy("column3")                // 按列排序
  .rowsBetween(start, end)           // 定义窗口范围（可选）</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         partitionBy
        </code>
       </strong>
       ：指定分区的列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         orderBy
        </code>
       </strong>
       ：指定排序的列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         rowsBetween
        </code>
       </strong>
       ：定义窗口的范围（如
       <code>
        Window.unboundedPreceding
       </code>
       表示从分区的第一行开始）。
      </p>
     </li>
    </ul>
    <h5>
     （2）应用窗口函数
    </h5>
    <pre><code class="language-Scala">import org.apache.spark.sql.functions._

val resultDF = df.withColumn("new_column", F.row_number().over(windowSpec))</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         withColumn
        </code>
       </strong>
       ：添加新列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         row_number().over(windowSpec)
        </code>
       </strong>
       ：在定义的窗口上应用
       <code>
        row_number
       </code>
       函数。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     3.
     <strong>
      窗口函数的示例
     </strong>
    </h4>
    <h5>
     示例 1：计算每个部门的工资排名
    </h5>
    <p>
     假设有一个 DataFrame，包含用户的姓名、部门和工资：
    </p>
    <pre><code class="language-Scala">import org.apache.spark.sql.{SparkSession, functions =&gt; F}
import org.apache.spark.sql.expressions.Window

val spark = SparkSession.builder()
  .appName("Window Function Example")
  .master("local[*]")
  .getOrCreate()

// 示例数据
val data = Seq(
  ("Alice", "HR", 3000),
  ("Bob", "IT", 4000),
  ("Charlie", "HR", 3500),
  ("David", "IT", 4500),
  ("Eva", "Finance", 5000)
)

// 创建 DataFrame
val df = spark.createDataFrame(data).toDF("name", "department", "salary")

// 定义窗口：按部门分区，按工资降序排序
val windowSpec = Window
  .partitionBy("department")
  .orderBy(F.desc("salary"))

// 计算每个部门的工资排名
val rankedDF = df.withColumn("rank", F.row_number().over(windowSpec))

// 显示结果
rankedDF.show()</code></pre>
    <p>
     <strong>
      输出：
     </strong>
    </p>
    <pre><code class="language-Scala">+-------+----------+------+----+
|   name|department|salary|rank|
+-------+----------+------+----+
|    Eva|   Finance|  5000|   1|
|  Alice|        HR|  3000|   2|
|Charlie|        HR|  3500|   1|
|   David|        IT|  4500|   1|
|    Bob|        IT|  4000|   2|
+-------+----------+------+----+</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         partitionBy("department")
        </code>
       </strong>
       ：按部门分区。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         orderBy(F.desc("salary"))
        </code>
       </strong>
       ：按工资降序排序。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         row_number()
        </code>
       </strong>
       ：计算每行的排名。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     示例 2：计算每个部门的累积工资
    </h5>
    <p>
     使用
     <code>
      sum
     </code>
     函数计算每个部门的累积工资：
    </p>
    <pre><code class="language-Scala">// 定义窗口：按部门分区，按工资升序排序
val windowSpec = Window
  .partitionBy("department")
  .orderBy("salary")
  .rowsBetween(Window.unboundedPreceding, Window.currentRow)

// 计算累积工资
val cumulativeDF = df.withColumn("cumulative_salary", F.sum("salary").over(windowSpec))

// 显示结果
cumulativeDF.show()</code></pre>
    <p>
     <strong>
      输出：
     </strong>
    </p>
    <pre><code class="language-Scala">+-------+----------+------+----------------+
|   name|department|salary|cumulative_salary|
+-------+----------+------+----------------+
|    Eva|   Finance|  5000|            5000|
|  Alice|        HR|  3000|            3000|
|Charlie|        HR|  3500|            6500|
|    Bob|        IT|  4000|            4000|
|   David|        IT|  4500|            8500|
+-------+----------+------+----------------+</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         rowsBetween(Window.unboundedPreceding, Window.currentRow)
        </code>
       </strong>
       ：定义窗口范围为从分区的第一行到当前行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         sum("salary").over(windowSpec)
        </code>
       </strong>
       ：计算累积工资。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     示例 3：计算每个部门的工资移动平均
    </h5>
    <pre><code class="language-Scala">使用 avg 函数计算每个部门的工资移动平均（当前行及其前一行）：

// 定义窗口：按部门分区，按工资升序排序，窗口范围为当前行及其前一行
val windowSpec = Window
  .partitionBy("department")
  .orderBy("salary")
  .rowsBetween(-1, Window.currentRow)

// 计算移动平均
val movingAvgDF = df.withColumn("moving_avg", F.avg("salary").over(windowSpec))

// 显示结果
movingAvgDF.show()</code></pre>
    <p>
     <strong>
      输出：
     </strong>
    </p>
    <pre><code class="language-Scala">+-------+----------+------+----------+
|   name|department|salary| moving_avg|
+-------+----------+------+----------+
|    Eva|   Finance|  5000|    5000.0|
|  Alice|        HR|  3000|    3000.0|
|Charlie|        HR|  3500|    3250.0|
|    Bob|        IT|  4000|    4000.0|
|   David|        IT|  4500|    4250.0|
+-------+----------+------+----------+</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         rowsBetween(-1, Window.currentRow)
        </code>
       </strong>
       ：定义窗口范围为当前行及其前一行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         avg("salary").over(windowSpec)
        </code>
       </strong>
       ：计算移动平均。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     4.
     <strong>
      常见的窗口函数
     </strong>
    </h4>
    <h5>
     （1）排名函数
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         row_number()
        </code>
       </strong>
       ：为每行分配一个唯一的序号（从 1 开始）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         rank()
        </code>
       </strong>
       ：计算排名，相同值会有相同的排名，后续排名会跳过。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         dense_rank()
        </code>
       </strong>
       ：计算排名，相同值会有相同的排名，后续排名不会跳过。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         percent_rank()
        </code>
       </strong>
       ：计算百分比排名。
      </p>
     </li>
    </ul>
    <h5>
     （2）聚合函数
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         sum()
        </code>
       </strong>
       ：计算窗口内的总和。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         avg()
        </code>
       </strong>
       ：计算窗口内的平均值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         min()
        </code>
       </strong>
       ：计算窗口内的最小值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         max()
        </code>
       </strong>
       ：计算窗口内的最大值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         count()
        </code>
       </strong>
       ：计算窗口内的行数。
      </p>
     </li>
    </ul>
    <h5>
     （3）分析函数
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         lead()
        </code>
       </strong>
       ：获取当前行之后的某一行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         lag()
        </code>
       </strong>
       ：获取当前行之前的某一行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         first_value()
        </code>
       </strong>
       ：获取窗口内的第一个值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         last_value()
        </code>
       </strong>
       ：获取窗口内的最后一个值。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     5.
     <strong>
      窗口范围的定义
     </strong>
    </h4>
    <p>
     窗口范围通过
     <code>
      rowsBetween
     </code>
     或
     <code>
      rangeBetween
     </code>
     定义：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         rowsBetween(start, end)
        </code>
       </strong>
       ：基于行的偏移量定义窗口范围。
      </p>
      <ul>
       <li>
        <p>
         <code>
          Window.unboundedPreceding
         </code>
         ：从分区的第一行开始。
        </p>
       </li>
       <li>
        <p>
         <code>
          Window.unboundedFollowing
         </code>
         ：到分区的最后一行结束。
        </p>
       </li>
       <li>
        <p>
         <code>
          Window.currentRow
         </code>
         ：当前行。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         rangeBetween(start, end)
        </code>
       </strong>
       ：基于值的范围定义窗口范围（适用于数值或日期类型）。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     6.
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        窗口函数
       </strong>
       用于在分组数据上执行复杂的聚合操作，同时保留原始数据的行。
      </p>
     </li>
     <li>
      <p>
       通过
       <code>
        Window
       </code>
       类定义窗口，包括分区、排序和窗口范围。
      </p>
     </li>
     <li>
      <p>
       常见的窗口函数包括排名函数、聚合函数和分析函数。
      </p>
     </li>
     <li>
      <p>
       窗口范围可以通过
       <code>
        rowsBetween
       </code>
       或
       <code>
        rangeBetween
       </code>
       定义。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36333332323132322f:61727469636c652f64657461696c732f313436323837363936" class_="artid" style="display:none">
 </p>
</div>


