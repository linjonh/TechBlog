---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343230373936392f:61727469636c652f64657461696c732f313436313332363335"
layout: post
title: "算法笔记cin和getline的并用如何区分两个数据对C中stdtuple类"
date: 2025-03-09 17:40:12 +08:00
description: "但是使用完毕cin之后通常会按\\n，就使用getline进行读取一行数据的时候，会出问题，因为getline没有像cin一样忽略前置空白字符的能力，所以他会直接读取\\n，代表完成了一次数据的读取工作，但实际上这次读取什么也没读取上来。仅读到第一个空白字符就会停止，但是不会对空白字符读取进行读取。那么就会有一个问题，输入流中会存在空白字符，再次的读取的时候，就会直接读取到空白字符了吗？cin的机制是，对于前置的空白字符，也就是第一个读取到的就是空白字符的时候，会忽略这个空白字符，继续向下读取。"
keywords: "[算法笔记]cin和getline的并用、如何区分两个数据对、C++中std::tuple类"
categories: ['未分类']
tags: ['算法', '笔记']
artid: "146132635"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146132635
    alt: "算法笔记cin和getline的并用如何区分两个数据对C中stdtuple类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146132635
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146132635
cover: https://bing.ee123.net/img/rand?artid=146132635
image: https://bing.ee123.net/img/rand?artid=146132635
img: https://bing.ee123.net/img/rand?artid=146132635
---

# [算法笔记]cin和getline的并用、如何区分两个数据对、C++中std::tuple类

#### 1.cin和getline的并用

std::cin是C++标准库<iostream>中定义的一个输入流对象，他用于从标准输入流中读取数据，当使用该对象的operator>>时候，会将用户从键盘输入到输入流中的内容提取出来，赋值给参数对象。如果输入流中没有数据的时候，通常会阻塞等待。

他在读取的时候，不是将整个输入流中的内容都提取出阿里，通常会以空白字符（\n、\t以及空格）作为分隔符。仅读到第一个空白字符就会停止，但是不会对空白字符读取进行读取。那么就会有一个问题，输入流中会存在空白字符，再次的读取的时候，就会直接读取到空白字符了吗？

cin的机制是，对于前置的空白字符，也就是第一个读取到的就是空白字符的时候，会忽略这个空白字符，继续向下读取。所以不会有一直读取不到数据的问题。

但是使用完毕cin之后通常会按\n，就使用getline进行读取一行数据的时候，会出问题，因为getline没有像cin一样忽略前置空白字符的能力，所以他会直接读取\n，代表完成了一次数据的读取工作，但实际上这次读取什么也没读取上来。所以cin类中还提供了一个ignore函数，该函数可以用来忽略输入流中的前n个字符。或者遇到文件结束符才会停下。这样就可以使用该函数，忽略掉\n之后再让getline进行读取操作了。

> istream& ignore( streamsize count = 1, int delim = Traits::eof() );

#### 2.如何区分两个数据对

显然这非常好区分，可以使用一个pair结构去存储这个内容，然后定制一个对比函数，来进行对两个pair的比较就可以很好的区分出来了，不存在的话，在放入数组当中。但是这样的话，需要遍历对比数组中的所有元素对才可以。

如果我们想要快速的查看一个数据对是否存在的时候怎么办呢？我们可以使用哈希map或者红黑树来进行快速判断，但是这样的话[1,4]与[4,1]就无法进行区分了，哈希map会把他当成两个数据进行存储两份，但是我们本意是存储一份的。所以我们存储的时候，可以对数据对进行排序，让小的作为key值，大的作为value值，之后再进行存储。

还有一个办法就是将两个数据通过特定的计算，让他形成一个唯一的键值，存放在set或者是哈希set当这种，那么到时候只需要对比这个键值存不存在，就知道了这个元素对是否存在了。例如假设存在[u，v]数据对，u和v的取值在100以内，那么我们可以有以下的算法:

> int key = u * (max\_number + 1) + v;

这里还有一个点在于 ，如果我们想让[1,4]与[4,1]当成一个数据对的时候，在往map、set、哈希map与哈希set内部存放的时候，可以定义小的作为key，大的作为value，就不会重复的存放同一个数据对了。

#### 3.C++中std::tuple类

std::tuple是 C++ 标准库中的一个模板类，它可以用来将多个不同类型的对象组合成一个单一的对象，类似于一个可以存储不同类型元素的容器。

**定义和初始化**

std::tuple类是一个可变参数模板类，也就是说他可以传递任意多数量的任意类型的参数。

> // 使用构造函数定义和初始化tuple对象
>
> std::tuple<int, float, std::string> myTuple(10, 3.14, "Hello");
>
> // 使用make\_tuple来构造一个tuple对象
>
> auto anotherTuple = std::make\_tuple(20, 2.718, "World"); return 0; }

**访问元素**

> std::get<索引值>(tuple对象)的形式进行访问元素
>
> 例如：std::get<0>(myTuple);