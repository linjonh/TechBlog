---
layout: post
title: "envsetup和python-venv"
date: 2025-03-09 15:32:14 +0800
description: "了解！虽然你已熟悉基本用法，但我们可以更，结合嵌入式开发中可能的用例来深入探讨venv的作用。venv（虚拟环境）的核心是numpy 1.19numpy 1.21aptpytest直接全局安装会导致版本冲突，用venv在 Linux 系统中，许多系统工具（如aptansible）依赖系统自带的 Python。若全局安装第三方库（如requests）可能导致依赖冲突，甚至破坏系统工具。通过venv假设你编写了一个若你的工具需要兼容 Python 3.8 和 3.10，可通过venv假设你正在开发一个。"
keywords: "envsetup和python venv"
categories: ['我的博客']
tags: ['Python', 'Android']
artid: "146133143"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146133143
    alt: "envsetup和python-venv"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146133143
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146133143
cover: https://bing.ee123.net/img/rand?artid=146133143
image: https://bing.ee123.net/img/rand?artid=146133143
img: https://bing.ee123.net/img/rand?artid=146133143
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     envsetup和python venv
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     了解！虽然你已熟悉基本用法，但我们可以更
     <strong>
      聚焦场景和实际意义
     </strong>
     ，结合嵌入式开发中可能的用例来深入探讨
     <code>
      venv
     </code>
     的作用。
    </p>
    <hr/>
    <h4>
     <a id="Python_venv__4">
     </a>
     <strong>
      Python venv 的核心本质
     </strong>
    </h4>
    <p>
     <code>
      venv
     </code>
     （虚拟环境）的核心是
     <strong>
      隔离性
     </strong>
     ，它通过创建独立的 Python 运行环境，解决以下问题：
    </p>
    <ol>
     <li>
      <strong>
       依赖冲突
      </strong>
      ：不同项目可能需要同一库的不同版本（如
      <code>
       numpy 1.19
      </code>
      vs
      <code>
       numpy 1.21
      </code>
      ）。
     </li>
     <li>
      <strong>
       系统环境干净性
      </strong>
      ：避免因安装全局 Python 包污染系统环境，导致系统工具崩溃（如 Linux 的包管理器
      <code>
       apt
      </code>
      依赖特定 Python 版本）。
     </li>
     <li>
      <strong>
       可移植性
      </strong>
      ：通过
      <code>
       requirements.txt
      </code>
      记录依赖，轻松复现环境。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_12">
     </a>
     <strong>
      嵌入式开发中的典型使用场景
     </strong>
    </h4>
    <h5>
     <a id="_1_13">
     </a>
     <strong>
      场景 1：不同项目依赖隔离
     </strong>
    </h5>
    <p>
     假设你有两个嵌入式相关项目：
    </p>
    <ul>
     <li>
      <strong>
       项目 A
      </strong>
      ：使用
      <code>
       pyserial 3.5
      </code>
      与设备通信。
     </li>
     <li>
      <strong>
       项目 B
      </strong>
      ：需要
      <code>
       pyserial 4.0
      </code>
      +
      <code>
       pytest
      </code>
      做自动化测试。
     </li>
    </ul>
    <p>
     直接全局安装会导致版本冲突，用
     <code>
      venv
     </code>
     隔离：
    </p>
    <pre><code class="prism language-bash"><span class="token comment"># 为项目 A 创建虚拟环境</span>
python <span class="token parameter variable">-m</span> venv ~/venvs/project_a
<span class="token builtin class-name">source</span> ~/venvs/project_a/bin/activate
pip <span class="token function">install</span> <span class="token assign-left variable">pyserial</span><span class="token operator">==</span><span class="token number">3.5</span>

<span class="token comment"># 为项目 B 创建虚拟环境</span>
python <span class="token parameter variable">-m</span> venv ~/venvs/project_b
<span class="token builtin class-name">source</span> ~/venvs/project_b/bin/activate
pip <span class="token function">install</span> <span class="token assign-left variable">pyserial</span><span class="token operator">==</span><span class="token number">4.0</span> pytest
</code></pre>
    <h5>
     <a id="_2_Python__31">
     </a>
     <strong>
      场景 2：保护系统 Python 环境
     </strong>
    </h5>
    <p>
     在 Linux 系统中，许多系统工具（如
     <code>
      apt
     </code>
     、
     <code>
      ansible
     </code>
     ）依赖系统自带的 Python。若全局安装第三方库（如
     <code>
      requests
     </code>
     ）可能导致依赖冲突，甚至破坏系统工具。通过
     <code>
      venv
     </code>
     隔离：
    </p>
    <pre><code class="prism language-bash"><span class="token comment"># 为自定义脚本创建独立环境</span>
python <span class="token parameter variable">-m</span> venv ~/venvs/my_script
<span class="token builtin class-name">source</span> ~/venvs/my_script/bin/activate
pip <span class="token function">install</span> requests  <span class="token comment"># 不影响系统 Python</span>
</code></pre>
    <h5>
     <a id="_3_CICD_40">
     </a>
     <strong>
      场景 3：团队协作与 CI/CD
     </strong>
    </h5>
    <p>
     假设你编写了一个
     <strong>
      嵌入式设备日志分析工具
     </strong>
     （Python 脚本），需分享给团队：
    </p>
    <ol>
     <li>
      在虚拟环境中安装依赖并生成
      <code>
       requirements.txt
      </code>
      ：
      <pre><code class="prism language-bash">python <span class="token parameter variable">-m</span> venv log_analyzer_venv
<span class="token builtin class-name">source</span> log_analyzer_venv/bin/activate
pip <span class="token function">install</span> pandas matplotlib  <span class="token comment"># 安装所需库</span>
pip freeze <span class="token operator">&gt;</span> requirements.txt  <span class="token comment"># 生成依赖清单</span>
</code></pre>
     </li>
     <li>
      将脚本和
      <code>
       requirements.txt
      </code>
      提交到 Git。其他成员克隆后，一键复现环境：
      <pre><code class="prism language-bash">python <span class="token parameter variable">-m</span> venv venv
<span class="token builtin class-name">source</span> venv/bin/activate
pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt
</code></pre>
     </li>
    </ol>
    <h5>
     <a id="_4_Python__56">
     </a>
     <strong>
      场景 4：测试不同 Python 版本
     </strong>
    </h5>
    <p>
     若你的工具需要兼容 Python 3.8 和 3.10，可通过
     <code>
      venv
     </code>
     快速切换（需系统已安装多版本 Python）：
    </p>
    <pre><code class="prism language-bash"><span class="token comment"># 使用 Python 3.8 创建环境</span>
python3.8 <span class="token parameter variable">-m</span> venv py38_env
<span class="token builtin class-name">source</span> py38_env/bin/activate
python <span class="token parameter variable">--version</span>  <span class="token comment"># 输出 3.8.x</span>

<span class="token comment"># 使用 Python 3.10 创建环境</span>
python3.10 <span class="token parameter variable">-m</span> venv py310_env
<span class="token builtin class-name">source</span> py310_env/bin/activate
python <span class="token parameter variable">--version</span>  <span class="token comment"># 输出 3.10.x</span>
</code></pre>
    <hr/>
    <h4>
     <a id="venv__vs__72">
     </a>
     <strong>
      venv 的优势 vs 替代方案
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        工具
       </th>
       <th>
        优势
       </th>
       <th>
        适用场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         venv
        </strong>
       </td>
       <td>
        轻量、Python 内置、无需额外安装
       </td>
       <td>
        大多数 Python 项目隔离
       </td>
      </tr>
      <tr>
       <td>
        virtualenv
       </td>
       <td>
        更灵活（支持旧版 Python）
       </td>
       <td>
        需要兼容 Python 2.x 的项目
       </td>
      </tr>
      <tr>
       <td>
        conda
       </td>
       <td>
        可管理非 Python 依赖（如 C 库）
       </td>
       <td>
        科学计算、复杂依赖项目
       </td>
      </tr>
      <tr>
       <td>
        Docker
       </td>
       <td>
        完全隔离的系统环境
       </td>
       <td>
        需要完整环境复现的部署场景
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_venv_82">
     </a>
     <strong>
      何时应该使用 venv？
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       开发 Python 应用/脚本
      </strong>
      ：即使是一个小工具，也建议隔离环境。
     </li>
     <li>
      <strong>
       多人协作
      </strong>
      ：确保所有人的依赖版本一致。
     </li>
     <li>
      <strong>
       使用 pip 安装库
      </strong>
      ：避免污染全局环境。
     </li>
     <li>
      <strong>
       测试不同依赖组合
      </strong>
      ：快速验证版本兼容性。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_90">
     </a>
     <strong>
      嵌入式开发中的实际联动案例
     </strong>
    </h4>
    <p>
     假设你正在开发一个
     <strong>
      基于 Android 的嵌入式设备调试工具链
     </strong>
     ：
    </p>
    <ol>
     <li>
      用
      <code>
       envsetup
      </code>
      编译 Android 系统镜像。
     </li>
     <li>
      用
      <code>
       venv
      </code>
      创建一个 Python 环境，运行自定义脚本：
      <ul>
       <li>
        通过
        <code>
         adb
        </code>
        与设备通信。
       </li>
       <li>
        使用
        <code>
         pandas
        </code>
        分析设备日志。
       </li>
       <li>
        用
        <code>
         matplotlib
        </code>
        生成性能报告。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     此时，
     <code>
      venv
     </code>
     确保脚本依赖的库（如
     <code>
      adb
     </code>
     的 Python 封装库）不会影响 Android 编译环境或其他系统工具。
    </p>
    <hr/>
    <p>
     作为嵌入式软件工程师，你可能在开发中需要同时接触系统级编译环境和脚本工具开发。以下是
     <code>
      Android envsetup
     </code>
     和
     <code>
      Python venv
     </code>
     的详细对比和示例说明：
    </p>
    <hr/>
    <h4>
     <a id="1_Android_envsetup_106">
     </a>
     <strong>
      1. Android envsetup
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：Android 源码开发中的环境配置工具
     <br/>
     <strong>
      场景
     </strong>
     ：用于配置 Android 源码编译环境，提供快捷命令和开发工具链
     <br/>
     <strong>
      核心功能
     </strong>
     ：
    </p>
    <ul>
     <li>
      定义编译环境变量（如
      <code>
       ANDROID_BUILD_TOP
      </code>
      ）
     </li>
     <li>
      提供快捷命令（如
      <code>
       lunch
      </code>
      ,
      <code>
       mm
      </code>
      ,
      <code>
       mmp
      </code>
      ）
     </li>
     <li>
      集成 Android 编译工具链（如
      <code>
       make
      </code>
      ,
      <code>
       soong
      </code>
      ）
     </li>
    </ul>
    <h5>
     <a id="_114">
     </a>
     示例步骤：
    </h5>
    <pre><code class="prism language-bash"><span class="token comment"># 进入 Android 源码目录</span>
<span class="token builtin class-name">cd</span> ~/aosp

<span class="token comment"># 加载环境配置脚本（核心操作）</span>
<span class="token builtin class-name">source</span> build/envsetup.sh

<span class="token comment"># 选择目标设备（例如 Pixel 6 的编译配置）</span>
lunch aosp_oriole-userdebug

<span class="token comment"># 编译单个模块（例如编译 Settings 模块）</span>
mm <span class="token parameter variable">-j8</span>

<span class="token comment"># 编译整个系统</span>
<span class="token function">make</span> <span class="token parameter variable">-j8</span>
</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       envsetup.sh
      </code>
      是 Android 源码编译的入口脚本，所有编译操作前必须执行。
     </li>
     <li>
      <code>
       lunch
      </code>
      命令会设置
      <code>
       TARGET_PRODUCT
      </code>
      等环境变量，决定编译目标设备的固件。
     </li>
     <li>
      <code>
       mm
      </code>
      是编译当前目录模块的快捷命令（依赖
      <code>
       Android.mk
      </code>
      或
      <code>
       Android.bp
      </code>
      ）。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="2_Python_venv_139">
     </a>
     <strong>
      2. Python venv
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：Python 虚拟环境管理工具
     <br/>
     <strong>
      场景
     </strong>
     ：隔离不同 Python 项目的依赖环境，避免全局包污染
     <br/>
     <strong>
      核心功能
     </strong>
     ：
    </p>
    <ul>
     <li>
      创建独立的 Python 解释器副本
     </li>
     <li>
      隔离 pip 安装的第三方库
     </li>
     <li>
      通过激活脚本（
      <code>
       activate
      </code>
      ）切换环境
     </li>
    </ul>
    <h5>
     <a id="_147">
     </a>
     示例步骤：
    </h5>
    <pre><code class="prism language-bash"><span class="token comment"># 创建虚拟环境（默认使用当前 Python 版本）</span>
python <span class="token parameter variable">-m</span> venv myenv

<span class="token comment"># 激活虚拟环境（不同系统命令不同）</span>
<span class="token comment"># Linux/macOS</span>
<span class="token builtin class-name">source</span> myenv/bin/activate
<span class="token comment"># Windows</span>
myenv<span class="token punctuation">\</span>Scripts<span class="token punctuation">\</span>activate.bat

<span class="token comment"># 在虚拟环境中安装依赖</span>
pip <span class="token function">install</span> <span class="token assign-left variable">requests</span><span class="token operator">==</span><span class="token number">2.28</span>.0

<span class="token comment"># 运行 Python 脚本（使用虚拟环境中的库）</span>
python my_script.py

<span class="token comment"># 退出虚拟环境</span>
deactivate
</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       venv
      </code>
      是 Python 3.3+ 内置工具，无需额外安装。
     </li>
     <li>
      虚拟环境中的
      <code>
       pip
      </code>
      安装的包会存储在
      <code>
       myenv/lib/python3.x/site-packages
      </code>
      目录。
     </li>
     <li>
      适合管理不同项目的依赖冲突（例如一个项目用
      <code>
       TensorFlow 1.x
      </code>
      ，另一个用
      <code>
       TensorFlow 2.x
      </code>
      ）。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_175">
     </a>
     <strong>
      对比总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        Android envsetup
       </th>
       <th>
        Python venv
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         用途
        </strong>
       </td>
       <td>
        Android 源码编译环境配置
       </td>
       <td>
        Python 项目依赖隔离
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         作用对象
        </strong>
       </td>
       <td>
        全局编译环境（整个源码树）
       </td>
       <td>
        单个 Python 项目
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         核心命令
        </strong>
       </td>
       <td>
        <code>
         source build/envsetup.sh
        </code>
        ,
        <code>
         lunch
        </code>
        ,
        <code>
         mm
        </code>
       </td>
       <td>
        <code>
         python -m venv
        </code>
        ,
        <code>
         activate
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         依赖管理
        </strong>
       </td>
       <td>
        通过
        <code>
         Android.mk
        </code>
        /
        <code>
         Android.bp
        </code>
        文件
       </td>
       <td>
        通过
        <code>
         requirements.txt
        </code>
        或
        <code>
         pipenv
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         典型场景
        </strong>
       </td>
       <td>
        编译 AOSP 系统镜像或模块
       </td>
       <td>
        开发独立 Python 应用或脚本
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_186">
     </a>
     <strong>
      嵌入式开发中的联动场景
     </strong>
    </h4>
    <p>
     假设你在开发 Android 系统的嵌入式设备时，可能会同时用到两者：
    </p>
    <ol>
     <li>
      用
      <code>
       envsetup
      </code>
      编译 Android 系统镜像（如
      <code>
       aosp_car_x86_64-userdebug
      </code>
      ）。
     </li>
     <li>
      用
      <code>
       venv
      </code>
      创建一个 Python 环境，运行自动化测试脚本（如通过 ADB 控制设备）。
      <br/>
      此时两者分工明确，互不干扰：
      <code>
       envsetup
      </code>
      管理编译环境，
      <code>
       venv
      </code>
      管理 Python 脚本依赖。
     </li>
    </ol>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031333331383031392f:61727469636c652f64657461696c732f313436313333313433" class_="artid" style="display:none">
 </p>
</div>


