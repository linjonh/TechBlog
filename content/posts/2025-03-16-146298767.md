---
layout: post
title: "Java集合-HashMap"
date: 2025-03-16 19:00:10 +0800
description: "HashMap是 Java 集合框架中的一个重要类，位于java.util包中。它实现了Map接口，基于哈希表的数据结构来存储键值对（key-value pairs）。HashMapnull，并且是非同步的（非线程安全的），null键在HashMap中只能存在一个。"
keywords: "Java集合 - HashMap"
categories: ['Java']
tags: ['开发语言', 'Java']
artid: "146298767"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146298767
    alt: "Java集合-HashMap"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146298767
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146298767
cover: https://bing.ee123.net/img/rand?artid=146298767
image: https://bing.ee123.net/img/rand?artid=146298767
img: https://bing.ee123.net/img/rand?artid=146298767
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java集合 - HashMap
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <code>
      HashMap
     </code>
     是 Java 集合框架中的一个重要类，位于
     <code>
      java.util
     </code>
     包中。它实现了
     <code>
      Map
     </code>
     接口，基于哈希表的数据结构来存储键值对（key-value pairs）。
     <code>
      HashMap
     </code>
     <strong>
      允许使用
      <code>
       null
      </code>
      作为键和值
     </strong>
     ，并且是非同步的（非线程安全的），null键在HashMap中只能存在一个。
    </p>
    <p>
    </p>
    <h3>
     1. 主要特点
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        键值对存储
       </strong>
       ：
       <code>
        HashMap
       </code>
       存储的是键值对，每个键对应一个值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        无序
       </strong>
       ：
       <code>
        HashMap
       </code>
       不保证元素的顺序，即插入顺序和遍历顺序不一定一致。
      </p>
     </li>
     <li>
      <p>
       <strong>
        允许 null 键和 null 值
       </strong>
       ：
       <code>
        HashMap
       </code>
       允许一个
       <code>
        null
       </code>
       键和多个
       <code>
        null
       </code>
       值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        非线程安全
       </strong>
       ：
       <code>
        HashMap
       </code>
       不是线程安全的，如果在多线程环境中使用，需要外部同步。
      </p>
     </li>
     <li>
      <p>
       <strong>
        基于哈希表
       </strong>
       ：
       <code>
        HashMap
       </code>
       使用哈希表来存储数据，通过哈希函数计算键的哈希值，并将其映射到表中的某个位置。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <h3>
     2. 核心方法
    </h3>
    <ul>
     <li>
      <p>
       <code>
        <strong>
         put
        </strong>
        (K key, V value)
       </code>
       ：将指定的键值对插入到
       <code>
        HashMap
       </code>
       中。如果键已经存在，则更新对应的值。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         get
        </strong>
        (Object key)
       </code>
       ：返回指定键所映射的值，如果键不存在则返回
       <code>
        null
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         remove
        </strong>
        (Object key)
       </code>
       ：删除指定键对应的键值对。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         containsKey
        </strong>
        (Object key)
       </code>
       ：判断
       <code>
        HashMap
       </code>
       中是否包含指定的键。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         containsValue
        </strong>
        (Object value)
       </code>
       ：判断
       <code>
        HashMap
       </code>
       中是否包含指定的值。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         keySet
        </strong>
        ()
       </code>
       ：返回
       <code>
        HashMap
       </code>
       中所有键的集合。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         values
        </strong>
        ()
       </code>
       ：返回
       <code>
        HashMap
       </code>
       中所有值的集合。
      </p>
     </li>
     <li>
      <p>
       <code>
        <strong>
         entrySet
        </strong>
        ()
       </code>
       ：返回
       <code>
        HashMap
       </code>
       中所有键值对的集合。
      </p>
     </li>
    </ul>
    <pre><code class="language-java">import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // 创建一个HashMap
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();

        // 添加键值对
        map.put("Alice", 25);
        map.put("Bob", 30);
        map.put("Charlie", 35);

        // 获取值
        System.out.println("Alice's age: " + map.get("Alice")); // 输出: 25

        // 遍历HashMap
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
            System.out.println(entry.getKey() + " is " + entry.getValue() + " years old.");
        }

        // 删除键值对
        map.remove("Bob");
        System.out.println("After removing Bob: " + map);

        // 判断是否包含键
        System.out.println("Contains key 'Alice': " + map.containsKey("Alice")); // 输出: true

        // 判断是否包含值
        System.out.println("Contains value 35: " + map.containsValue(35)); // 输出: true
    }
}</code></pre>
    <h4>
    </h4>
    <h3>
     3. 底层原理
    </h3>
    <p>
     HashMap的底层使用
     <strong>
      hash表
     </strong>
     ,即
     <strong>
      散列表
     </strong>
     数据结构(
     <strong>
      数组
     </strong>
     +
     <strong>
      链表或红黑树
     </strong>
     )
    </p>
    <p style="margin-left:0in; text-align:left">
     <span style="color:#262626">
      1.
     </span>
     <span style="color:#262626">
      当我们往
     </span>
     <span style="color:#262626">
      HashMap
     </span>
     <span style="color:#262626">
      中
     </span>
     <span style="color:#262626">
      put
     </span>
     <span style="color:#262626">
      元素时，利用
     </span>
     <span style="color:#262626">
      key
     </span>
     <span style="color:#262626">
      的
     </span>
     <strong>
      <span style="color:#262626">
       hashCode
      </span>
     </strong>
     <span style="color:#262626">
      重新
     </span>
     <span style="color:#262626">
      hash
     </span>
     <span style="color:#262626">
      计算出当前对象的元素在数组中的下标
     </span>
    </p>
    <p style="margin-left:0in; text-align:left">
     <span style="color:#262626">
      2.
     </span>
     <span style="color:#262626">
      存储时，如果出现
     </span>
     <span style="color:#262626">
      hash
     </span>
     <span style="color:#262626">
      值相同的
     </span>
     <span style="color:#262626">
      key
     </span>
     <span style="color:#262626">
      ，此时有两种情况。
     </span>
    </p>
    <p style="margin-left:0in; text-align:left">
     <span style="color:#262626">
      a.
     </span>
     <span style="color:#262626">
      如果
     </span>
     <span style="color:#262626">
      key
     </span>
     <span style="color:#262626">
      相同，则覆盖原始值；
     </span>
    </p>
    <p style="margin-left:0in; text-align:left">
     <span style="color:#262626">
      b.
     </span>
     <span style="color:#262626">
      如果
     </span>
     <span style="color:#262626">
      key
     </span>
     <span style="color:#262626">
      不同（出现冲突），则将当前的
     </span>
     <span style="color:#262626">
      key-value
     </span>
     <span style="color:#262626">
      放入链表或红黑树中
     </span>
    </p>
    <p style="margin-left:0in; text-align:left">
     <span style="color:#262626">
      3.
     </span>
     <span style="color:#262626">
      获取时，直接找到
     </span>
     <strong>
      <span style="color:#262626">
       hash
      </span>
     </strong>
     <span style="color:#262626">
      <strong>
       值对应的下标
      </strong>
      ，在进一步判断
     </span>
     <span style="color:#262626">
      key
     </span>
     <span style="color:#262626">
      是否相同，从而找到对应值。
     </span>
    </p>
    <p>
     当两个键的哈希值映射到同一个桶时，会发生哈希冲突。HashMap通过以下方式解决冲突：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        链表
       </strong>
       ：在 Java 8 之前，冲突的键值对以链表形式存储。
      </p>
     </li>
     <li>
      <p>
       <strong>
        红黑树
       </strong>
       ：在 Java 8 及以后，当链表长度超过阈值（默认是 8）时，链表会转换为红黑树，以提高查找效率。
      </p>
     </li>
    </ul>
    <p>
     在 Java 8 中，
     <code>
      HashMap
     </code>
     引入了红黑树来优化性能。当链表长度超过阈值（默认是 8）时，链表会转换为红黑树；当红黑树的节点数减少到一定阈值（默认是 6）时，红黑树会退化为链表。
    </p>
    <h4>
     <strong>
      3.1 为什么引入红黑树？
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       链表的时间复杂度是 O(n)，而红黑树的时间复杂度是 O(log n)。
      </p>
     </li>
     <li>
      <p>
       当哈希冲突严重时，红黑树可以显著提高查找效率。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     4. 扩容机制
    </h3>
    <p>
     HashMap的容量是动态调整的，当元素数量超过当前容量与负载因子的乘积时，会触发扩容（resize）。
    </p>
    <h4>
     4.1
     <strong>
      负载因子
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       负载因子（load factor）是一个浮点数，默认是 0.75。
      </p>
     </li>
     <li>
      <p>
       它表示
       <code>
        HashMap
       </code>
       在扩容之前可以达到的填充比例。例如，默认容量是 16，负载因子是 0.75，则当元素数量超过
       <code>
        16 * 0.75 = 12
       </code>
       时，会触发扩容。
      </p>
     </li>
    </ul>
    <h4>
     4.2
     <strong>
      扩容过程
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       创建一个新的数组，容量是原数组的 2 倍。
      </p>
     </li>
     <li>
      <p>
       将原数组中的键值对重新哈希到新数组中。
      </p>
     </li>
     <li>
      <p>
       重新哈希时，键值对可能会被分配到新的位置。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <h3>
     5. 线程安全
    </h3>
    <p>
     HashMap是非线程安全的(相对比线程安全的HashTable)，如果要在线程安全的情况下使用HashMap，有下面几种方式。
    </p>
    <h4>
     1. 使用
     <strong>
      <code>
       Collections的方法synchronizedMap
      </code>
     </strong>
    </h4>
    <p>
     Java 提供了
     <code>
      Collections.synchronizedMap
     </code>
     方法，可以将
     <code>
      HashMap
     </code>
     包装成一个线程安全的
     <code>
      Map
     </code>
     。
    </p>
    <pre><code class="language-java">// 创建一个普通的HashMap
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();

// 使用Collections.synchronizedMap包装HashMap
Map&lt;String, Integer&gt; synchronizedMap = Collections.synchronizedMap(map);</code></pre>
    <p>
     <code>
      Collections.synchronizedMap
     </code>
     返回一个同步的
     <code>
      Map
     </code>
     ，内部通过一个全局锁（
     <code>
      mutex
     </code>
     ）来保证线程安全。所有对
     <code>
      Map
     </code>
     的操作（如
     <code>
      put
     </code>
     、
     <code>
      get
     </code>
     、
     <code>
      remove
     </code>
     等）都会被同步。
    </p>
    <h4>
     <strong>
      2. 使用
      <code>
       ConcurrentHashMap
      </code>
     </strong>
    </h4>
    <p>
     <code>
      ConcurrentHashMap
     </code>
     是 Java 提供的线程安全的哈希表实现，专门为高并发场景设计。
    </p>
    <pre><code class="language-java">// 创建一个ConcurrentHashMap
Map&lt;String, Integer&gt; concurrentMap = new ConcurrentHashMap&lt;&gt;();</code></pre>
    <p>
     <code>
      ConcurrentHashMap
     </code>
     使用分段锁（Java 7）或 CAS + synchronized（Java 8 及以后）来实现线程安全。在 Java 8 中，
     <code>
      ConcurrentHashMap
     </code>
     采用了更细粒度的锁机制，每个桶（bucket）独立加锁，减少了锁竞争。
    </p>
    <h4>
     3.
     <strong>
      手动加锁
     </strong>
    </h4>
    <p>
     如果需要对
     <code>
      HashMap
     </code>
     进行更灵活的控制，可以手动加锁（
     <code>
      ReentrantLock
     </code>
     或
     <code>
      synchronized
     </code>
     ）。
    </p>
    <pre><code class="language-java">private final Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
private final Lock lock = new ReentrantLock();

public void put(String key, Integer value) {
    lock.lock();
    try {
        map.put(key, value);
    } finally {
        lock.unlock();
    }
}

public Integer get(String key) {
    lock.lock();
    try {
        return map.get(key);
    } finally {
        lock.unlock();
    }
}</code></pre>
    <h4>
     4.
     <strong>
      使用
      <code>
       Hashtable
      </code>
     </strong>
    </h4>
    <p>
     <code>
      Hashtable
     </code>
     是 Java 早期提供的线程安全的哈希表实现。
     <code>
      Hashtable
     </code>
     的所有方法都是同步的（使用
     <code>
      synchronized
     </code>
     关键字）。但是HashTable性能较差，因为所有操作都需要竞争同一把锁。已经过时，不推荐使用。
    </p>
    <h4>
     小结
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3480ab06da0e45f2a6171b34237112b9.png"/>
    </p>
    <p>
     在实际开发中，
     <strong>
      <code>
       ConcurrentHashMap
      </code>
      是最推荐的方式
     </strong>
     ，因为它既能保证线程安全，又能提供优异的性能。如果并发需求不高，可以使用
     <code>
      Collections.synchronizedMap
     </code>
     。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f48617264776f726b696e674875616e672f:61727469636c652f64657461696c732f313436323938373637" class_="artid" style="display:none">
 </p>
</div>


