---
layout: post
title: "C之list"
date: 2025-03-09 19:52:29 +0800
description: "（3）迭代器实现：由于链表在内存内部是不连续的，所以用迭代器的指针无法去直接++或者--，想要实现迭代器的基本功能必须对其他的运算符进行重载。（4）排序：sort()默认是升序，要实现降序可以使用仿函数greater<int> ls，less<int> ls用于升序。首先是重载*，需要返回内部的值，++则是返回下一个节点，--则是返回前一个节点。（5）两个链表合并：使用merge函数传合并的对象，最后传的对象内部会空。（7）剪切：有两个链表对象1和2，将2的值剪切到1里面去，最后2会空。"
keywords: "C++之list"
categories: ['未分类']
tags: ['开发语言', 'List', 'C']
artid: "146136455"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146136455
    alt: "C之list"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146136455
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146136455
cover: https://bing.ee123.net/img/rand?artid=146136455
image: https://bing.ee123.net/img/rand?artid=146136455
img: https://bing.ee123.net/img/rand?artid=146136455
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++之list
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     list是链表的意思，由一个个节点组成
    </p>
    <p>
     一、基本接口使用：
    </p>
    <p>
     （1）与vector相同，有个尾插，也可以使用迭代器遍历：
    </p>
    <pre><code class="language-cpp">void test_list1()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);

	list&lt;int&gt;::iterator it = lt.begin();
	while (it != lt.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	//假如要删除指定位置的数据：
	//it = lt.begin();
	//lt.erase(it + 3);//物理空间不连续找不到指定位置
}</code></pre>
    <p>
     （2）emplace_back：也是插入，但是和尾插有区别：
    </p>
    <p>
     假设有一个类A：
    </p>
    <pre><code class="language-cpp">struct A
{
public:
	A(int a1 = 1, int a2 = 1)
		:_a1(a1)
		,_a2(a2)
	{}
	int _a1;
	int _a2;

};</code></pre>
    <p>
     插入A对象的数据：
    </p>
    <pre><code class="language-cpp">void test_list2()
{
	list&lt;A&gt; lt1;
	A aa1(1, 1);
	lt1.push_back(aa1);
	lt1.push_back(A(2,2));
	lt1.emplace_back(aa1);
	lt1.emplace_back(A(2, 2));
}
</code></pre>
    <p>
     但是emplace_back支持直接传构造A对象的参数，push_back不支持：
    </p>
    <pre><code class="language-cpp">void test_list2()
{
	list&lt;A&gt; lt1;
	A aa1(1, 1);
	lt1.push_back(aa1);
	lt1.push_back(A(2,2));
	lt1.emplace_back(aa1);
	lt1.emplace_back(A(2, 2));

	//lt.push_back(3, 3);//不支持这样写
	lt1.emplace_back(3, 3);
}</code></pre>
    <p>
     （3）查询某个值并删除：
    </p>
    <pre><code class="language-cpp">void test_list3()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.emplace_back(2);
	lt.emplace_back(3);
	lt.emplace_back(4);
	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	//删除某个值：
	int x;
	cin &gt;&gt; x;
	//找到x：
	auto it = find(lt.begin(), lt.end(), x);
	if (it != lt.end())
	{
		lt.erase(it);
	}

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
    <p>
     （4）排序：sort()默认是升序，要实现降序可以使用仿函数greater&lt;int&gt; ls，less&lt;int&gt; ls用于升序。lt.sort(ls)，这样就可以实现降序。也可以直接传匿名对象lt.sort(greater&lt;int&gt;())。
    </p>
    <pre><code class="language-cpp">void test_list4()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(20);
	lt.push_back(3);
	lt.push_back(5);
	lt.push_back(4);
	lt.push_back(6);
	lt.push_back(1);

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	//排序：
	lt.sort();//默认实现升序

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	//降序，使用仿函数
	//less&lt;int&gt; ls;//用于升序
	//greater&lt;int&gt; ls;//用于降序
	//两个都是类模板
	//lt.sort(ls);//这样就实现了降序
	//也可以直接传匿名对象：
	lt.sort(greater&lt;int&gt;());

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
    <p>
     （5）两个链表合并：使用merge函数传合并的对象，最后传的对象内部会空。
    </p>
    <pre><code class="language-cpp">void test5()
{
	//两个链表合并：
	list&lt;double&gt; first, second;
	first.push_back(3.1);
	first.push_back(2.2);
	first.push_back(2.9);

	second.push_back(3.7);
	second.push_back(7.1);
	second.push_back(1.4);

	first.sort();
	second.sort();

	//合并：
	first.merge(second);//取小的尾插，second最后空了
}
</code></pre>
    <p>
     （6）去重：
    </p>
    <pre><code class="language-cpp">void test_list6()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(20);
	lt.push_back(5);
	lt.push_back(5);
	lt.push_back(4);
	lt.push_back(6);
	lt.push_back(1);

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	//去重，先排序：
	lt.sort();
	lt.unique();

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
    <p>
     <img alt="" height="48" src="https://i-blog.csdnimg.cn/direct/a7fcf3bf727848ea9f2f0acb6bd126bd.png" width="747">
      （7）剪切：有两个链表对象1和2，将2的值剪切到1里面去，最后2会空。
     </img>
    </p>
    <pre><code class="language-cpp">void test_list7()
{
	list&lt;int&gt; mylist1,mylist2;
	list&lt;int&gt;::iterator it;

	for (int i = 1; i &lt;= 4; i++)
		mylist1.push_back(i);
	for (int i = 1; i &lt;= 4; i++)
		mylist2.push_back(i * 10);



	it = mylist1.begin();
	it++;

	mylist1.splice(it, mylist2);//将2的所有值剪切到1里面去

	for (auto e : mylist1)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
    <p>
     <img alt="" height="28" src="https://i-blog.csdnimg.cn/direct/e798ac00ef674e29a8f04f4a350d2ee5.png" width="822"/>
    </p>
    <p>
     二、实现一个链表：
    </p>
    <p>
     （1） 一个链表需要一个类来表示节点，还要一个类来实现链表的链接。
    </p>
    <pre><code class="language-cpp">template &lt;class T&gt;
struct list_node//节点
{
	T _data;
	list_node&lt;T&gt;* _next;
	list_node&lt;T&gt;* _prev;

	list_node(const T&amp; data = T())
		:_data(data)
		, _next(nullptr)
		, _prev(nullptr)
	{}

};
template &lt;class T&gt;
class list
{
	typedef list_node&lt;T&gt; Node;
public:
	list()
	{
		empty_init();
	}

	void empty_init()
	{
		_head = new Node();
		_head-&gt;_next = _head;
		_head-&gt;_prev = _head;
		_size = 0;
	}
	size_t size()const 
	{
		return _size;
	}
	bool empty()const
	{
		return _size == 0;
	}
private:
	Node* _head;
	size_t _size;
};</code></pre>
    <p>
     用_size来记录节点的个数。
    </p>
    <p>
     （2）基本的实现：
    </p>
    <pre><code class="language-cpp">void push_back(const T&amp; x)
{
	Node* newnode = new Node(x);
	Node* tail = _head-&gt;_prev;

	tail-&gt;_next = newnode;
	newnode-&gt;_prev = tail;
	newnode-&gt;_next = _head;
	_head-&gt;_prev = newnode;
}

void push_front(T&amp; x)
{
	insert(begin(), x);
}

void insert(iterator pos, const T&amp; x)
{
	Node* cur = pos._node;
	Node* prev = cur-&gt;_prev;

	Node* newnode = new Node(x);

	newnode-&gt;next = cur;
	cur-&gt;_prev = newnode;
	newnode-&gt;_prev = prev;
	prev-&gt;_next = newnode;

	++_size;

}

void pop_back()
{
	erase(--end());
}

void front_back()
{
	erase(begin);
}</code></pre>
    <p>
     （3）迭代器实现：由于链表在内存内部是不连续的，所以用迭代器的指针无法去直接++或者--，想要实现迭代器的基本功能必须对其他的运算符进行重载。需要写一个专门的类去封装迭代器。使用struct去定义类默认的成员都是公有，这样可以省事很多，方便之后的调用。
    </p>
    <p>
     首先是重载*，需要返回内部的值，++则是返回下一个节点，--则是返回前一个节点。++和--分为前置和后置，后置则要返回原来的值。
    </p>
    <pre><code class="language-cpp">struct list_iterator//默认是公有
{
	typedef list_node&lt;T&gt; Node;
	typedef list_iterator&lt;T&gt; Self;
	Node* _node;

	list_iterator(Node* node)
		:_node(node)
	{}
	
	T&amp; operator*()//重载*
	{
		return _node-&gt;_data;
	}

	Self&amp; operator++()
	{
		_node = _node-&gt;_next;
		return *this;
	}

	Self&amp; operator--()
	{
		_node = _node-&gt;_prev;
		return *this;
	}

	Self&amp; operator++(int)
	{
		Self tmp(*this);

		_node = _node-&gt;_next;
		return tmp;
	}

	Self&amp; operator--(int)
	{
		Self tmp(*this);

		_node = _node-&gt;_prev;
		return tmp;
	}

	T* operator-&gt;()
	{
		return &amp;_node-&gt;_data;
	}

	bool operator !=(const Self&amp; s)//两个迭代器比较
	{
		return _node != s._node;
	}
};</code></pre>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303436303136362f:61727469636c652f64657461696c732f313436313336343535" class_="artid" style="display:none">
 </p>
</div>


