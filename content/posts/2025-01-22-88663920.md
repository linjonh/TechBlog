---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3232303534323835:2f61727469636c652f64657461696c732f3838363633393230"
layout: post
title: "操作系统中锁的实现原理"
date: 2025-01-22 16:26:06 +08:00
description: "在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制"
keywords: "操作系统中锁的底层实现原理"
categories: ['高性能计算']
tags: ['锁', '操作系统']
artid: "88663920"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=88663920
    alt: "操作系统中锁的实现原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=88663920
featuredImagePreview: https://bing.ee123.net/img/rand?artid=88663920
---

# 操作系统中锁的实现原理

在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。

所谓的锁，说白了就是内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

看起来很简单，大家有没有想过，OS是怎样保证这个锁操作本身的原子性呢？举个例子，在多核环境中，两个核上的代码同时申请一个锁，两个核同时取出锁变量，同时判断说这个锁是空闲状态，然后有同时修改为上锁状态，同时返回成功。。。两个核同时获取到了锁，这种情况可能吗？废话，当然是不可能，可能的话，我们使用锁还有啥意义。但是，咦？等等，虽然我知道肯定不可能，但是你刚才说的貌似还有点道理，看来OS实现这个锁还不是看起来这么简单，还是有点道道的。

为了弄明白锁的实现原理，我们首先看看如果OS不采用任何其他手段，什么情况下会导致上锁失败？假如我们把加锁过程用如下伪码表示：
  
1、read lock；
  
2、判断lock状态；
  
3、如果已经加锁，失败返回；
  
4、把锁状态设置为上锁；
  
5、返回成功。
  
明白汇编的同学一看就明白上述每一步都能对应到一条汇编语句，所以我们可以认为每一步本身是原子的。

那么什么情况能够导致两个线程同时获取到锁呢？
  
1、中断：假设线程A执行完第一步，发生中断，中断返回后，OS调度线程B，线程B也来加锁并且加锁成功，这时OS调度线程A执行，线程从第二步开始执行，也加锁成功。
  
2、多核：当然了，想想上面举的例子，描述的就是两个核同时获取到锁的情况。

既然明白锁失败的原因，解决手段就很明确了：
  
先考虑单核场景：
  
1、既然只有中断才能把上锁过程打断，造成多线程操作失败。我先关中断不就得了，在加锁操作完成后再开中断。
  
2、上面这个手段太笨重了，能不能硬件做一种加锁的原子操作呢？能，大名鼎鼎的“test and set”指令就是做这个事情的。（怎么，test and set是干什么的？同学，看来你上课时不够专心啊，赶紧回头复习复习）

通过上面的手段，单核环境下，锁的实现问题得到了圆满的解决。那么多核环境呢？简单嘛，还是“test and set”不就得了，这是一条指令，原子的，不会有问题的。真的吗，单独一条指令能够保证该指令在单个核上执行过程中不会被中断打断，但是两个核同时执行这个指令呢？。。。我再想想，硬件执行时还是得从内存中读取lock，判断并设置状态到内存，貌似这个过程也不是那么原子嘛。对，多个核执行确实会存在这个问题。怎么办呢？首先我们得明白这个地方的关键点，关键点是两个核会并行操作内存而且从操作内存这个调度来看“test and set”不是原子的，需要先读内存然后再写内存，如果我们保证这个内存操作是原子的，就能保证锁的正确性了。确实，硬件提供了锁内存总线的机制，我们在锁内存总线的状态下执行test and set操作，就能保证同时只有一个核来test and set，从而避免了多核下发生的问题。

总结一下，在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制；OS基于这几个CPU硬件机制，就能够实现锁；再基于锁，就能够实现各种各样的同步机制（信号量、消息、Barrier等等等等）。所以要想理解OS的各种同步手段，首先需要理解本文介绍的内容，这时最原点的机制，所有的OS上层同步手段都基于此。