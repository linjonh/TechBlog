---
layout: post
title: "高效查找树"
date: 2023-07-07 18:16:46 +0800
description: "前缀树/字典树（Trie Tree）简介Trie Tree是一种用于快速检索的多叉树，主要用于统计和"
keywords: "查找树的子树"
categories: ['知识综合']
tags: ['前缀树']
artid: "51020002"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51020002
    alt: "高效查找树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51020002
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51020002
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     高效查找树
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3 id="前缀树字典树trie-tree">
     前缀树/字典树（Trie Tree）
    </h3>
    <ul>
     <li>
      <p>
       简介
      </p>
      <p>
       Trie Tree是一种用于快速检索的多叉树，主要用于统计和排序大量字符串问题，常被搜索引擎系统用于文本词频统计。
      </p>
      <p>
       其主要特点是最大限度地减少无谓的字符串比较，查询效率比哈希表高。
      </p>
      <p>
       Trie Tree的核心思想是空间换时间。利用公共前缀来降低查询时间的开销，从而提高效率。
      </p>
      <p>
       TrieTree的每一层节点数是26^i级别。为了节省空间，可以用动态链表或数组模拟动态。空间花费不超过单词数*单词长度。
      </p>
      <p>
       Trie Tree实质是存储多个字符串的树。相邻节点间的边代表一个字符，树的每条分支代表一个子串，树的叶节点代表完整的字符串。相同的字符串前缀共享同一条分支。
      </p>
     </li>
     <li>
      <p>
       性质
      </p>
      <p>
       1）根节点不包含字符，除根节点外每一个节点都只包含一个字符；
      </p>
      <p>
       2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串；
      </p>
      <p>
       3）每个节点的所有子节点包含的字符都不相同。
      </p>
     </li>
     <li>
      <p>
       实现
      </p>
      <p>
       构建Trie Tree就是逐一把每个单词的每个字母插入Trie树中。插入前先确定前缀是否存在，存在就共享，否则就创建对应的节点和边即可。
      </p>
      <p>
       Trie Tree的插入、删除、查找利用一次遍历即可，即遍历过程中找其对应的子树，进行相关判断等。
      </p>
      <p>
       实现Trie Tree的结构主要有三种：
      </p>
      <p>
       1）对每个节点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容是儿子对应在大数组上的位置，即标号；
      </p>
      <p>
       2）对每个节点挂接一个链表，按一定顺序记录每个儿子；
      </p>
      <p>
       3）是用左儿子，右兄弟表示法记录这棵树。
      </p>
      <p>
       三种方法比较：第一种方法容易实现，但空间要求较大；第二种方法轻易实现，空间要求相对较小，但耗时；第三种方法：空间要求最小，但费时不易编写。
      </p>
     </li>
     <li>
      <p>
       应用
      </p>
      <p>
       1）字符串检索：事先将已知的一些字符串（字典）的有关信息保存到Trie Tree里，查找另外一些位置字符串是否出现过或者出现频率；
      </p>
      <p>
       2）字符串最长公共前缀：利用多个字符创的公共前缀来节省存储空间，反之，把大量字符串存储到一颗Trie树上，可快速得到某些字符串的公共前缀；
      </p>
      <p>
       3）排序：Trie Tree主要先序遍历，输出相应的字符串便是字典排序的结果；
      </p>
      <p>
       4）作为其他数据结构和算法的辅助结构等。
      </p>
      <p>
       具体应用如海量数据查找、统计以及搜索引擎中热门查询等。
      </p>
     </li>
    </ul>
    <h3 id="基数树radix-tree">
     基数树（Radix Tree）
    </h3>
    <ul>
     <li>
      <p>
       简介
      </p>
      <p>
       Radix Tree是一种多叉搜索树，树的叶子节点是实际数据的条目。每个节点有一个固定的、2^n指针指向子节点（每个指针称为槽slot，n为划分的基的大小）。
      </p>
      <p>
       Radix Tree与Trie Tree思想类似，可把Trie Tree看做一个特殊的Radix Tree（其基为26），Radix Tree可看做是Trie Tree的变异。
      </p>
      <p>
       Radix一般用于长整型到对象的映射，它能固定层高。它是空间换时间的数据结构。
      </p>
     </li>
     <li>
      <p>
       插入删除
      </p>
      <p>
       Radix Tree与二叉树类似，只是查找方式上，如unsigned int类型，每一个比特位作为树节点判断。
      </p>
      <p>
       其插入过程是从根节点开始，遇到0指向左节点，遇到1指向右节点，插入过程中构造树节点，删除过程中删除树节点。但malloc太多时，可以使用池化技术，预先分配多个节点。为防止树过高，可以使用多个比特位作为树节点进行判断，但多比特会使节点的子节点槽变多，增大节点体积，一般选2或4个比特位。
      </p>
      <p>
       插入：依据数据的比特位，在树中向下查找，若没有相应节点，则生成相应节点，直到数据的比特位访问完，则建立节点映射相应的对象。
      </p>
      <p>
       删除：“惰性删除”，即沿着路径查找到叶节点，直接删除叶节点，中间的非叶节点不删除。
      </p>
     </li>
     <li>
      <p>
       用途
      </p>
      <p>
       主要用于长整型数据类型的路由。它可以根据一个长整型快速查找其对应的对象指针。比hash映射简单，且更节省空间。
      </p>
      <p>
       IDR（ID Radix）机制：将对象的身份鉴别整数值ID与对象指针建立关联表，完成从ID与指针之间的相互转换。IDR机制使用radix树状结构作为由id进行索引获取指针的稀疏数组，通过使用位图可以快速分配新的ID，IDR机制避免了使用固定尺寸的数组存放指针。
      </p>
      <p>
       内存管理：address_space结构通过radix树跟踪绑定到地址映射上的核心页，该radix树允许内存管理代码快速查找标识为dirty或writeback的页。Linux内核使用radix树在文件内偏移快速定位文件缓存页。Linux（2.6.7）内核中的分叉为64（2^6)，树高位6（64位系统）或者11（32位系统），用来快速定位32位或64位偏移，radix tree中的每一个叶子节点指向文件内相应偏移所对应的Cache项。
      </p>
      <p>
       radix树主要提供有效存储，代替固定尺寸数组提供了键值到指针的快速查找。它能解决Hash冲突、Hash大小设计的难题。
      </p>
     </li>
     <li>
      <p>
       参考文献
      </p>
      <p>
       <a href="http://dongxicheng.org/structure/trietree/" rel="nofollow">
        http://dongxicheng.org/structure/trietree/
       </a>
      </p>
      <p>
       <a href="http://blog.csdn.net/v_july_v/article/details/6897097">
        http://blog.csdn.net/v_july_v/article/details/6897097
       </a>
      </p>
      <p>
       <a href="http://blog.csdn.net/yang_yulei/article/details/46371975">
        http://blog.csdn.net/yang_yulei/article/details/46371975
       </a>
      </p>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f797a68616e67365f3130:2f61727469636c652f64657461696c732f3531303230303032" class_="artid" style="display:none">
 </p>
</div>


