---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f797a68616e67365f3130:2f61727469636c652f64657461696c732f3531303230303032"
layout: post
title: "高效查找树"
date: 2023-07-07 18:16:46 +08:00
description: "前缀树/字典树（Trie Tree）简介Trie Tree是一种用于快速检索的多叉树，主要用于统计和"
keywords: "查找树的子树"
categories: ['知识综合']
tags: ['前缀树']
artid: "51020002"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51020002
    alt: "高效查找树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51020002
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51020002
---

# 高效查找树

### 前缀树/字典树（Trie Tree）

* 简介

  Trie Tree是一种用于快速检索的多叉树，主要用于统计和排序大量字符串问题，常被搜索引擎系统用于文本词频统计。

  其主要特点是最大限度地减少无谓的字符串比较，查询效率比哈希表高。

  Trie Tree的核心思想是空间换时间。利用公共前缀来降低查询时间的开销，从而提高效率。

  TrieTree的每一层节点数是26^i级别。为了节省空间，可以用动态链表或数组模拟动态。空间花费不超过单词数*单词长度。

  Trie Tree实质是存储多个字符串的树。相邻节点间的边代表一个字符，树的每条分支代表一个子串，树的叶节点代表完整的字符串。相同的字符串前缀共享同一条分支。
* 性质

  1）根节点不包含字符，除根节点外每一个节点都只包含一个字符；

  2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串；

  3）每个节点的所有子节点包含的字符都不相同。
* 实现

  构建Trie Tree就是逐一把每个单词的每个字母插入Trie树中。插入前先确定前缀是否存在，存在就共享，否则就创建对应的节点和边即可。

  Trie Tree的插入、删除、查找利用一次遍历即可，即遍历过程中找其对应的子树，进行相关判断等。

  实现Trie Tree的结构主要有三种：

  1）对每个节点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容是儿子对应在大数组上的位置，即标号；

  2）对每个节点挂接一个链表，按一定顺序记录每个儿子；

  3）是用左儿子，右兄弟表示法记录这棵树。

  三种方法比较：第一种方法容易实现，但空间要求较大；第二种方法轻易实现，空间要求相对较小，但耗时；第三种方法：空间要求最小，但费时不易编写。
* 应用

  1）字符串检索：事先将已知的一些字符串（字典）的有关信息保存到Trie Tree里，查找另外一些位置字符串是否出现过或者出现频率；

  2）字符串最长公共前缀：利用多个字符创的公共前缀来节省存储空间，反之，把大量字符串存储到一颗Trie树上，可快速得到某些字符串的公共前缀；

  3）排序：Trie Tree主要先序遍历，输出相应的字符串便是字典排序的结果；

  4）作为其他数据结构和算法的辅助结构等。

  具体应用如海量数据查找、统计以及搜索引擎中热门查询等。

### 基数树（Radix Tree）

* 简介

  Radix Tree是一种多叉搜索树，树的叶子节点是实际数据的条目。每个节点有一个固定的、2^n指针指向子节点（每个指针称为槽slot，n为划分的基的大小）。

  Radix Tree与Trie Tree思想类似，可把Trie Tree看做一个特殊的Radix Tree（其基为26），Radix Tree可看做是Trie Tree的变异。

  Radix一般用于长整型到对象的映射，它能固定层高。它是空间换时间的数据结构。
* 插入删除

  Radix Tree与二叉树类似，只是查找方式上，如unsigned int类型，每一个比特位作为树节点判断。

  其插入过程是从根节点开始，遇到0指向左节点，遇到1指向右节点，插入过程中构造树节点，删除过程中删除树节点。但malloc太多时，可以使用池化技术，预先分配多个节点。为防止树过高，可以使用多个比特位作为树节点进行判断，但多比特会使节点的子节点槽变多，增大节点体积，一般选2或4个比特位。

  插入：依据数据的比特位，在树中向下查找，若没有相应节点，则生成相应节点，直到数据的比特位访问完，则建立节点映射相应的对象。

  删除：“惰性删除”，即沿着路径查找到叶节点，直接删除叶节点，中间的非叶节点不删除。
* 用途

  主要用于长整型数据类型的路由。它可以根据一个长整型快速查找其对应的对象指针。比hash映射简单，且更节省空间。

  IDR（ID Radix）机制：将对象的身份鉴别整数值ID与对象指针建立关联表，完成从ID与指针之间的相互转换。IDR机制使用radix树状结构作为由id进行索引获取指针的稀疏数组，通过使用位图可以快速分配新的ID，IDR机制避免了使用固定尺寸的数组存放指针。

  内存管理：address\_space结构通过radix树跟踪绑定到地址映射上的核心页，该radix树允许内存管理代码快速查找标识为dirty或writeback的页。Linux内核使用radix树在文件内偏移快速定位文件缓存页。Linux（2.6.7）内核中的分叉为64（2^6)，树高位6（64位系统）或者11（32位系统），用来快速定位32位或64位偏移，radix tree中的每一个叶子节点指向文件内相应偏移所对应的Cache项。

  radix树主要提供有效存储，代替固定尺寸数组提供了键值到指针的快速查找。它能解决Hash冲突、Hash大小设计的难题。
* 参考文献

  <http://dongxicheng.org/structure/trietree/>

  <http://blog.csdn.net/v_july_v/article/details/6897097>

  <http://blog.csdn.net/yang_yulei/article/details/46371975>