---
layout: post
title: "es-索引详解"
date: 2025-03-09 20:56:38 +0800
description: "在 Elasticsearch 中，**索引（Index）**是核心概念之一，类似于关系型数据库中的“表”。索引用于存储、组织和检索文档（Document）。"
keywords: "es-索引详解"
categories: ['Elasticsearch']
tags: ['Elasticsearch']
artid: "146138069"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146138069
    alt: "es-索引详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146138069
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146138069
cover: https://bing.ee123.net/img/rand?artid=146138069
image: https://bing.ee123.net/img/rand?artid=146138069
img: https://bing.ee123.net/img/rand?artid=146138069
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     es-索引详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Elasticsearch 中，**索引（Index）**是核心概念之一，类似于关系型数据库中的“表”。索引用于存储、组织和检索文档（Document）。以下是关于 Elasticsearch 索引的详细解析：
    </p>
    <hr/>
    <h2>
     1.
     <strong>
      索引的基本概念
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       索引
      </strong>
      ：一个索引是一个逻辑命名空间，用于存储具有相似结构的文档。例如，可以创建一个名为
      <code>
       products
      </code>
      的索引来存储所有产品信息。
     </li>
     <li>
      <strong>
       文档
      </strong>
      ：文档是索引中的基本数据单元，以 JSON 格式存储。例如，一个产品文档可能包含
      <code>
       name
      </code>
      、
      <code>
       price
      </code>
      、
      <code>
       description
      </code>
      等字段。
     </li>
     <li>
      <strong>
       类型（Type）
      </strong>
      ：在 Elasticsearch 6.x 及之前版本中，索引可以包含多个类型（类似于表）。但从 7.x 开始，类型已被弃用，每个索引只能包含一种类型（默认是
      <code>
       _doc
      </code>
      ）。
     </li>
     <li>
      <strong>
       分片（Shard）
      </strong>
      ：索引被划分为多个分片，分片是数据的物理存储单元。分片可以分布在不同的节点上，从而实现分布式存储和并行处理。
     </li>
     <li>
      <strong>
       副本（Replica）
      </strong>
      ：每个分片可以有多个副本，用于提高数据的可用性和容错性。
     </li>
    </ul>
    <h2>
     2.
     <strong>
      索引的创建
     </strong>
    </h2>
    <p>
     es 支持动态映射（自动推断字段类型）和显式映射（手动定义字段类型）。
    </p>
    <h3>
     显式创建
    </h3>
    <pre><code>PUT /products   
{
   "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 2
   },
   "mappings": {
    "properties": {
      "name": { "type": "text" },
      "price": { "type": "float" },
      "description": { "type": "text", "analyzer": "english" },
      "extra": {
        "type": "text",
        "index": false
      },
      "number" : {
        "type" : "keyword",
        "null_value": "NULL"
      }
    }
   }   
}
</code></pre>
    <ul>
     <li>
      该索引名为
      <code>
       products
      </code>
      ，包含 3 个分片和 2 个副本。
     </li>
     <li>
      定义了5个字段：
      <code>
       name
      </code>
      （文本类型）、
      <code>
       price
      </code>
      （浮点类型）、
      <code>
       description
      </code>
      （文本类型，使用英文分词器）、extra（文本类型，不创建倒排索引）、number（keyword类型，通过NULL可筛选出没有手机号的文档）
     </li>
     <li>
     </li>
    </ul>
    <p>
     筛选出number为空的文档
    </p>
    <pre><code>GET products/_search
{
  "query": {
    "match": {
      "number":"NULL"
    }
  }
}
</code></pre>
    <p>
    </p>
    <h3>
     动态创建（不建议）
    </h3>
    <pre><code>POST /products/_doc/1   
{
   "name": "Laptop",
   "price": 999.99,
   "description": "A powerful laptop for professionals."
}
</code></pre>
    <ul>
     <li>
      Elasticsearch 会自动推断字段类型：
      <code>
       name
      </code>
      和
      <code>
       description
      </code>
      为文本类型，
      <code>
       price
      </code>
      为浮点类型。
     </li>
    </ul>
    <p>
     动态创建的类型，与实际需要的类型可能不一致，不建议使用
    </p>
    <hr/>
    <h2>
     3.
     <strong>
      索引维护
     </strong>
    </h2>
    <h3>
     <strong>
      查看索引
     </strong>
    </h3>
    <pre><code>GET /products
</code></pre>
    <h3>
     <strong>
      删除索引
     </strong>
    </h3>
    <pre><code>DELETE /products</code></pre>
    <p>
    </p>
    <h2>
     <strong>
      4.索引的性能优化
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       合理设置分片数量
      </strong>
      ：分片数量过多会增加集群负担，过少会影响查询性能。
     </li>
     <li>
      <strong>
       使用副本提高可用性
      </strong>
      ：副本可以提高数据的可用性和查询性能。
     </li>
     <li>
      <strong>
       优化映射
      </strong>
      ：避免使用不必要的字段类型（如
      <code>
       keyword
      </code>
      用于大文本）。
     </li>
     <li>
      <strong>
       定期清理旧数据
      </strong>
      ：使用索引生命周期管理（ILM）自动删除或归档旧数据
     </li>
    </ul>
    <h3>
     避免排序
    </h3>
    <blockquote>
     <p>
      将term、match转换成filter
     </p>
    </blockquote>
    <p>
     使用score计算分数
    </p>
    <pre><code>GET /my_index/_search   
{
   "query": {
    "bool": {
      "must": [
        { "term": { "status": "active" } },
        { "match": { "description": "powerful laptop" } }
      ]
    }
   }   
}
</code></pre>
    <p>
     转换成不需要score计算分数
    </p>
    <pre><code>GET /my_index/_search   
{
   "query": {
    "bool": {
      "filter": [
        { "term": { "status": "active" } },
        { "match": { "description": "powerful laptop" } }
      ]
      }
      }      
}      
</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     优化排序与聚合
    </h3>
    <p>
     <strong>
      <code>
       eager_global_ordinals
      </code>
     </strong>
     可以加速 排序、聚合
    </p>
    <blockquote>
     <p>
      原理：
      <strong>
       <code>
        global_ordinals
       </code>
      </strong>
      <span style="color:#ff9900">
       全局序数是一种将字段值映射为连续整数的机制
      </span>
      。例如，字段值
      <code>
       ["apple", "banana", "cherry"]
      </code>
      可能被映射为
      <code>
       [0, 1, 2]
      </code>
     </p>
     <p>
     </p>
     <p>
      默认情况下，全局序数是在查询时动态生成的。这意味着每次执行聚合或排序操作时，Elasticsearch 都需要遍历字段值并生成全局序数。
     </p>
     <p>
      对于高基数字段（字段值种类多），生成全局序数可能会消耗大量时间和资源。
     </p>
     <p>
      启用
      <code>
       eager_global_ordinals
      </code>
      时，Elasticsearch 会在索引刷新（Refresh）或段合并（Segment Merge）时
      <span style="color:#ff9900">
       预先生成全局序数
      </span>
     </p>
    </blockquote>
    <p>
     <strong>
      适用场景
     </strong>
    </p>
    <ul>
     <li>
      高基数字段
     </li>
     <li>
      频繁聚合或排序
     </li>
     <li>
      实时性要求高
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      增加索引开销：在索引刷新或段合并时生成全局序数会增加 CPU 和内存开销。
     </li>
     <li>
      占用更多内存：全局序数需要存储在内存中，可能会增加内存使用量
     </li>
    </ul>
    <p>
     <strong>
      启用
      <code>
       eager_global_ordinals
      </code>
     </strong>
    </p>
    <pre><code>PUT /my_index   
{
   "mappings": {
    "properties": {
      "my_field": {
        "type": "keyword",
        "eager_global_ordinals": true
      }
    }
   }   
}
</code></pre>
    <p>
    </p>
    <h3>
     避免不必要的字段类型
    </h3>
    <h4>
     字段不创建索引
    </h4>
    <pre><code>PUT /my_index   
{
   "mappings": {
    "properties": {
      "name": {
        "type": "text"
      },
      "metadata": {
        "type": "object",
        "enabled": false
      },
      "description": {
        "type": "text",
        "index": false
      }
    }
   }   
}
</code></pre>
    <blockquote>
     <p>
      <code>
       name
      </code>
      字段：正常索引，可以用于搜索。
     </p>
     <p>
      <code>
       metadata
      </code>
      字段：禁用整个对象的索引功能。
     </p>
     <p>
      <code>
       description
      </code>
      字段：禁用索引，无法用于搜索。
     </p>
    </blockquote>
    <p>
     <strong>
      禁用索引后的字段特性
     </strong>
    </p>
    <blockquote>
     <p>
      无法搜索：禁用索引的字段无法用于查询（如
      <code>
       match
      </code>
      、
      <code>
       term
      </code>
      等）。
     </p>
     <p>
      可以存储：字段的值仍然会存储在
      <code>
       _source
      </code>
      中，可以通过
      <code>
       _source
      </code>
      获取。
     </p>
     <p>
      <span style="color:#fe2c24">
       可以用于聚合
      </span>
      ：禁用索引的字段仍然可以用于聚合操作（如
      <code>
       terms
      </code>
      、
      <code>
       sum
      </code>
      等），性能会降低。
     </p>
     <p>
      可以用于脚本：字段的值可以在脚本中使用。
     </p>
    </blockquote>
    <p>
     <strong>
      禁用索引的适用场景
     </strong>
    </p>
    <blockquote>
     <p>
      日志数据：某些字段（如原始日志）可能不需要搜索，但需要存储。
     </p>
     <p>
      大文本字段：某些大文本字段（如文章内容）可能不需要搜索，但需要存储。
     </p>
     <p>
      敏感数据：某些敏感数据（如密码、密钥）不需要索引，但需要存储。
     </p>
    </blockquote>
    <p>
     <strong>
      注意事项
     </strong>
    </p>
    <blockquote>
     <p>
      无法恢复索引：
      <span style="color:#fe2c24">
       如果需要重新启用索引，必须重新创建索引或使用
       <code>
        reindex
       </code>
      </span>
     </p>
     <p>
      存储开销：禁用索引的字段仍然会占用存储空间，因为其值存储在
      <code>
       _source
      </code>
      中。
     </p>
     <p>
      聚合性能：禁用索引的字段在聚合时可能会影响性能，因为需要从
      <code>
       _source
      </code>
      中提取数据。
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     不使用fielddata
    </h4>
    <p>
    </p>
    <h3>
     <strong>
      索引的生命周期管理（ILM）
     </strong>
    </h3>
    <h4>
     <strong>
      创建策略
     </strong>
    </h4>
    <pre><code>PUT _ilm/policy/my_custom_policy   
{
   "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "50GB",
            "max_age": "30d"
          }
        }
      },
      "delete": {
        "min_age": "90d",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
</code></pre>
    <blockquote>
     <p>
      该策略定义了索引的生命周期：在
      <code>
       hot
      </code>
      阶段，当索引大小超过 50GB 或创建时间超过 30 天时，滚动到新索引；在
      <code>
       delete
      </code>
      阶段，当索引创建时间超过 90 天时，删除索引。
     </p>
     <p>
      (场景：删除3年之前的数据)
     </p>
    </blockquote>
    <h4>
     将策略绑定到索引
    </h4>
    <pre><code>PUT /my_index   
{
   "settings": {
    "index.lifecycle.name": "my_custom_policy"
  }
}
</code></pre>
    <p>
    </p>
    <h4>
     验证是否生效
    </h4>
    <pre><code>GET /my_index/_ilm/explain</code></pre>
    <p>
     <img alt="" height="557" src="https://i-blog.csdnimg.cn/direct/922801d641514ae88a1ac7eac8079f46.png" width="563"/>
    </p>
    <p>
    </p>
    <h2 style="background-color:transparent">
     其他
    </h2>
    <h3>
     添加字段禁止自动创建倒排索引
    </h3>
    <p>
     dynamic的取值类型如下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         取值
        </strong>
       </th>
       <th>
        <strong>
         是否添加字段到映射
        </strong>
       </th>
       <th>
        <strong>
         是否存储字段数据
        </strong>
       </th>
       <th>
        <strong>
         是否抛出异常
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         <code>
          true
         </code>
        </strong>
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
       <td>
        否
       </td>
       <td>
        数据结构不固定，需要动态添加字段。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          false
         </code>
        </strong>
       </td>
       <td>
        否
       </td>
       <td>
        是
       </td>
       <td>
        否
       </td>
       <td>
        数据结构固定，但需要存储未知字段。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          strict
         </code>
        </strong>
       </td>
       <td>
        -
       </td>
       <td>
        -
       </td>
       <td>
        <span style="color:#fe2c24">
         是
        </span>
       </td>
       <td>
        数据结构严格固定，不允许未知字段。
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      true: 默认，添加倒排索引、储存字段
     </p>
     <p>
      false:只会存储字段
     </p>
     <p>
      <code>
       strict：不支持自动添加字段，需要手动维护
      </code>
     </p>
     <p>
      （建议：如果字段是动态的，需要自动映射，则使用true；否则使用
      <code>
       strict。避免出现创建多余的映射现象。。原因：
       <span style="color:#fe2c24">
        索引不容易修改，建议手动创建映射
       </span>
      </code>
      ）
     </p>
    </blockquote>
    <p>
     手动添加字段：
    </p>
    <pre><code class="hljs">PUT /my_index/_mapping   
{
   "properties": {
    "age": { "type": "integer" }
  }
}
</code></pre>
    <p>
    </p>
    <h3 style="background-color:transparent">
     索引模板
    </h3>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f447261796d6f6e645f66656e672f:61727469636c652f64657461696c732f313436313338303639" class_="artid" style="display:none">
 </p>
</div>


