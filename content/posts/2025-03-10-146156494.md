---
layout: post
title: "Spring-Boot3整合Knife4j4.5.0"
date: 2025-03-10 17:36:53 +0800
description: "Spring Boot 是用于简化 Spring 应用开发的框架，通过自动配置和约定大于配置原则，能让开发者快速搭建和运行 Spring 应用。Knife4j 是基于 Swagger 增强的 API 文档生成工具，可方便展示和调试 API 接口，生成美观易用的 API 文档。以下将详细介绍如何从零开始把 Spring Boot 3.3.0 与 Knife4j 4.5.0 进行整合。可以通过配置文件或者 Java 代码对 Knife4j 的界面进行一些自定义设置，例如修改文档标题、描述等。@Bean。"
keywords: "Spring Boot3整合Knife4j（4.5.0）"
categories: ['未分类']
tags: ['数据库', 'Spring', 'Java', 'Boot']
artid: "146156494"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146156494
    alt: "Spring-Boot3整合Knife4j4.5.0"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146156494
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146156494
cover: https://bing.ee123.net/img/rand?artid=146156494
image: https://bing.ee123.net/img/rand?artid=146156494
img: https://bing.ee123.net/img/rand?artid=146156494
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring Boot3整合Knife4j（4.5.0）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     整体概述
    </h4>
    <p>
     Spring Boot 是用于简化 Spring 应用开发的框架，通过自动配置和约定大于配置原则，能让开发者快速搭建和运行 Spring 应用。Knife4j 是基于 Swagger 增强的 API 文档生成工具，可方便展示和调试 API 接口，生成美观易用的 API 文档。以下将详细介绍如何从零开始把 Spring Boot 3.3.0 与 Knife4j 4.5.0 进行整合。
    </p>
    <h4>
     步骤 1：创建 Spring Boot 项目
    </h4>
    <h5>
     方式一：使用 Spring Initializr
    </h5>
    <p>
     Spring Initializr 是在线的 Spring Boot 项目生成器，提供图形化界面，便于快速创建项目。
    </p>
    <ol>
     <li>
      打开浏览器，访问
      <a href="https://start.spring.io/" rel="nofollow" title="Spring Initializr">
       Spring Initializr
      </a>
      。
     </li>
     <li>
      在页面做如下配置：
      <ul>
       <li>
        <strong>
         Project
        </strong>
        ：选
        <code>
         Maven Project
        </code>
        ，Maven 是项目管理和构建工具，可管理项目依赖、编译、打包等操作。
       </li>
       <li>
        <strong>
         Language
        </strong>
        ：选
        <code>
         Java
        </code>
        ，使用 Java 语言开发。
       </li>
       <li>
        <strong>
         Spring Boot
        </strong>
        ：选
        <code>
         3.3.0
        </code>
        ，即要使用的 Spring Boot 版本。
       </li>
       <li>
        <strong>
         Group
        </strong>
        ：通常是公司或组织域名倒序，如
        <code>
         com.example
        </code>
        ，用于唯一标识项目所属组织或团队。
       </li>
       <li>
        <strong>
         Artifact
        </strong>
        ：是项目名称，如
        <code>
         spring - boot - knife4j - demo
        </code>
        ，是项目在 Maven 仓库的唯一标识符。
       </li>
       <li>
        <strong>
         Dependencies
        </strong>
        ：点击
        <code>
         Add Dependencies
        </code>
        按钮，搜索并添加
        <code>
         Spring Web
        </code>
        依赖，
        <code>
         Spring Web
        </code>
        用于开发 Web 应用，包含 Spring MVC 等核心组件。
       </li>
      </ul>
     </li>
     <li>
      配置完成后，点击
      <code>
       Generate
      </code>
      按钮，浏览器会下载项目压缩包。
     </li>
     <li>
      解压下载的压缩包，用喜欢的集成开发环境（IDE）打开项目。以 IntelliJ IDEA 为例，打开 IDE，选
      <code>
       File
      </code>
      -&gt;
      <code>
       Open
      </code>
      ，再选解压后的项目文件夹。
     </li>
    </ol>
    <h5>
     方式二：使用 IDE 自带的 Spring Initializr
    </h5>
    <p>
     若使用 IntelliJ IDEA，也可通过其自带的 Spring Initializr 创建项目：
    </p>
    <ol>
     <li>
      打开 IntelliJ IDEA，选
      <code>
       File
      </code>
      -&gt;
      <code>
       New
      </code>
      -&gt;
      <code>
       Project
      </code>
      。
     </li>
     <li>
      在左侧面板选
      <code>
       Spring Initializr
      </code>
      ，按上述步骤 2 配置。
     </li>
     <li>
      点击
      <code>
       Next
      </code>
      ，选项目存储位置，再点击
      <code>
       Finish
      </code>
      完成项目创建。
     </li>
    </ol>
    <h4>
     步骤 2：添加 Knife4j 依赖
    </h4>
    <p>
     在项目的
     <code>
      pom.xml
     </code>
     文件中添加 Knife4j 依赖。
     <code>
      pom.xml
     </code>
     是 Maven 项目配置文件，用于管理项目依赖和构建信息。打开
     <code>
      pom.xml
     </code>
     文件，在
     <code>
      &lt;dependencies&gt;
     </code>
     标签内添加以下代码：
    </p>
    <pre><code class="language-XML">&lt;dependencies&gt;
    &lt;!-- Spring Web 依赖，用于开发 Web 应用 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- Knife4j 依赖，用于生成和展示 API 文档 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
     添加依赖后，Maven 会自动从中央仓库下载所需库文件。在 IntelliJ IDEA 中，IDE 会自动检测
     <code>
      pom.xml
     </code>
     文件变化，并提示导入依赖，点击
     <code>
      Import Changes
     </code>
     按钮，等待依赖下载完成。
    </p>
    <h4>
     <strong>
      步骤 3： Knife4j 界面自定义配置
     </strong>
    </h4>
    <pre><code class="language-java">package org.example.test1;

import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class Knife4jConfig {
    @Bean
    public GroupedOpenApi api4() {
        return GroupedOpenApi.builder()
                .group("all")
                .displayName("所有接口")
                .packagesToScan("org.example.test1")
                // 自定义全局响应码
//                .addOpenApiCustomizer((this::setCustomStatusCode))
                .build();
    }
}</code></pre>
    <h4>
     步骤 4：创建实体类
    </h4>
    <p>
     实体类用于表示业务数据，使用 Swagger 注解为实体类和其属性添加描述信息，以便在 API 文档中清晰展示。
    </p>
    <p>
     @Schema 注解用于为实体类添加描述信息，name 为实体类在文档中的名称，description 为详细描述
    </p>
    <p>
     @Schema 注解为属性添加描述信息，description 为属性描述，example 为示例值
    </p>
    <pre><code class="language-java">import io.swagger.v3.oas.annotations.media.Schema;

// @Schema 注解用于为实体类添加描述信息，name 为实体类在文档中的名称，description 为详细描述
@Schema(name = "User", description = "用户实体类")
public class User {

    // @Schema 注解为属性添加描述信息，description 为属性描述，example 为示例值
    @Schema(description = "用户 ID", example = "1")
    private Long id;

    @Schema(description = "用户名", example = "张三")
    private String username;

    @Schema(description = "用户邮箱", example = "666@example.com")
    private String email;

    // 构造函数、Getter 和 Setter 方法
    public User() {
    }

    public User(Long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}</code></pre>
    <h4>
     步骤 5：创建 Controller
    </h4>
    <p>
     Controller 负责处理客户端请求并返回响应。使用更多 Swagger 注解描述接口的请求参数、响应结果等信息。
    </p>
    <p>
     // @Tag 用于对 API 接口进行分组和描述，name 为分组名称，description 为分组详细描述
    </p>
    <p>
     // @Operation 描述接口的操作信息，summary 为摘要，description 为详细描述
    </p>
    <p>
     // @ApiResponses 定义接口的响应状态码和对应的响应信息
    </p>
    <pre><code class="language-java">import io.swagger.v3.oas.annotations.Operation; // 导入Swagger Operation注解，用于描述API操作
import io.swagger.v3.oas.annotations.Parameter; // 导入Swagger Parameter注解，用于描述API参数
import io.swagger.v3.oas.annotations.media.Content; // 导入Swagger Content注解，用于定义API响应内容类型
import io.swagger.v3.oas.annotations.media.Schema; // 导入Swagger Schema注解，用于定义API响应模式
import io.swagger.v3.oas.annotations.responses.ApiResponse; // 导入Swagger ApiResponse注解，用于定义API响应信息
import io.swagger.v3.oas.annotations.responses.ApiResponses; // 导入Swagger ApiResponses注解，用于定义多个API响应信息
import io.swagger.v3.oas.annotations.tags.Tag; // 导入Swagger Tag注解，用于对API进行分组和描述
import org.springframework.web.bind.annotation.*; // 导入Spring MVC注解，用于处理HTTP请求

import java.util.ArrayList; // 导入ArrayList类，用于动态数组操作
import java.util.List; // 导入List接口

// @RestController 是 @Controller 和 @ResponseBody 的组合注解，标识该类是RESTful风格的控制器
@RestController
// @RequestMapping 用于映射请求的URL前缀
@RequestMapping("/api/users")
// @Tag 用于对API接口进行分组和描述，name 为分组名称，description 为分组详细描述
@Tag(name = "用户管理接口", description = "提供用户相关的操作接口")
public class UserController {

    private List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 创建一个List集合用于存储用户数据

    // @Operation 描述接口的操作信息，summary 为摘要，description 为详细描述
    @Operation(summary = "获取所有用户", description = "返回所有用户的列表")
    // @ApiResponses 定义接口的响应状态码和对应的响应信息
    @ApiResponses(value = {
            // @ApiResponse 具体描述某个响应状态码的信息，responseCode 为响应状态码，description 为描述，content 为响应内容
            @ApiResponse(responseCode = "200", description = "成功获取用户列表",
                    content = {@Content(mediaType = "application/json",
                            // @Schema 指定响应内容的数据结构
                            schema = @Schema(implementation = User.class))}})
    })
    @GetMapping
    public List&lt;User&gt; getUsers() { // 定义一个GET请求处理方法，返回用户列表
        return users; // 返回用户列表
    }

    @Operation(summary = "根据 ID 获取用户", description = "根据用户 ID 获取单个用户信息")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "成功获取用户信息",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = User.class))}),
            @ApiResponse(responseCode = "404", description = "未找到该用户", content = @Content)})
    // @Parameter 描述接口的请求参数，description 为参数描述，example 为示例值
    @GetMapping("/{id}")
    public User getUserById(@Parameter(description = "用户 ID", example = "1") @PathVariable Long id) { // 定义一个GET请求处理方法，根据ID获取用户信息
        return users.stream() // 将用户列表转换为流
               .filter(user -&gt; user.getId().equals(id)) // 过滤出ID匹配的用户
               .findFirst() // 查找第一个匹配的用户
               .orElse(null); // 如果没有找到，返回null
    }

    @Operation(summary = "创建用户", description = "创建一个新的用户")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "用户创建成功",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = User.class))}})
    @PostMapping
    public User createUser(@Parameter(description = "用户信息", required = true) @RequestBody User user) { // 定义一个POST请求处理方法，创建新用户
        users.add(user); // 将新用户添加到列表
        return user; // 返回创建的用户
    }


    @Operation(summary = "获取所有用户2", description = "返回所有用户的列表")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "成功获取用户列表",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = User.class))}})
    @GetMapping
    public List&lt;User&gt; getUsers2(@Parameter(name = "X-Token", description = "自定义请求头 token", in = ParameterIn.HEADER) @RequestHeader(required = false) String token) { // 定义一个GET请求处理方法，返回用户列表，支持自定义请求头参数
        return users; // 返回用户列表
    }

}</code></pre>
    <h4>
     步骤 6：启动 Spring Boot 应用
    </h4>
    <p>
     在 IDE 中找到项目的启动类（通常是包含
     <code>
      main
     </code>
     方法且带有
     <code>
      @SpringBootApplication
     </code>
     注解的类），右键点击并选择
     <code>
      Run
     </code>
     启动 Spring Boot 应用。启动成功后，控制台会输出启动信息，表明应用已在默认端口（通常是 8080）启动。
    </p>
    <h4>
     步骤 7：访问 Knife4j 文档页面
    </h4>
    <p>
     打开浏览器，访问以下 URL 查看 Knife4j 生成的 API 文档：
     <a href="http://localhost:8080/doc.html" rel="nofollow" title="http://localhost:8080/doc.html">
      http://localhost:8080/doc.html
     </a>
    </p>
    <h3>
     <strong>
      在Springboot的yml文件中配置Knife4j
     </strong>
    </h3>
    <pre><code class="language-java"># Knife4j配置
# springdoc-openapi配置
springdoc:
  # get请求多参数时不需要添加额外的@ParameterObject和@Parameter注解
  default-flat-param-object: true
  # 启用swaggerUI
  swagger-ui:
    #自定义swagger前端请求路径，输入http：127.0.0.1:8080/swagger-ui.html会自动重定向到swagger页面
    path: /swagger-ui.html
    enabled: true
    #    tags-sorter: alpha # 标签的排序方式 alpha:按照子母顺序排序（@ApiSupport注解排序不生效，因此需要设置）
    #    operations-sorter: alpha # 接口的排序方式 alpha:按照子母顺序排序（@ApiOperationSupport注解排序生效，因此这里不作设置）
    operations-sorter: order # 设置规则为order，该规则会使用Knife4j的增强排序扩展规则`x-order`
  # 启用文档，默认开启
  api-docs:
    path: /v3/api-docs    #swagger后端请求地址
    enabled: true
# knife4j相关配置 可以不用改
knife4j:
  enable: true    #开启knife4j，无需添加@EnableKnife4j注解
  setting:
    language: ZH_CN   # 中文:ZH_CN 英文:EN
    enable-swagger-models: true
    enable-dynamic-parameter: false
    footer-custom-content: "&lt;strong&gt;Copyright ©️ 2024 Keyidea. All Rights Reversed&lt;/strong&gt;"
    enable-footer-custom: true
    enable-footer: true
    enable-document-manage: true
  documents: #文档补充说明
    - name: MarkDown语法说明
      locations: classpath:static/markdown/grammar/*
      group: 01-系统接口 # 此处分组必须使用在Knife4jConfig已存在的分组名group，当存在displayName时，使用displayName名称
    - name: 补充文档
      locations: classpath:static/markdown/others/*
      group: 01-系统接口 # 此处分组必须使用在Knife4jConfig已存在的分组名group，当存在displayName时，使用displayName名称
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36353332343730332f:61727469636c652f64657461696c732f313436313536343934" class_="artid" style="display:none">
 </p>
</div>


