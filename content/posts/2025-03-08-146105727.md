---
layout: post
title: "C-语言数据结构三栈和队列"
date: 2025-03-08 12:45:10 +0800
description: "好比排队收银，排在队伍前面的顾客先结账离开队伍，而后到的顾客要在后面依次等待。就像往一个桶里放东西，最后放进去的东西会在最上面，取的时候最先被取出。在数据结构中，一个节点通常由多个部分组成，其中用于存储实际数据的部分称为。栈是一种特殊的线性表，它只允许在固定的一端进行插入和删除元素操作。队列是只允许在一端插入数据，在另一端删除数据的特殊线性表。"
keywords: "C 语言数据结构（三）：栈和队列"
categories: ['未分类']
tags: ['算法', '数据结构', 'C']
artid: "146105727"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146105727
    alt: "C-语言数据结构三栈和队列"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146105727
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146105727
cover: https://bing.ee123.net/img/rand?artid=146105727
image: https://bing.ee123.net/img/rand?artid=146105727
img: https://bing.ee123.net/img/rand?artid=146105727
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C 语言数据结构（三）：栈和队列
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      💬 ：如果你在阅读过程中有任何疑问或想要进一步探讨的内容，欢迎在评论区畅所欲言！我们一起学习、共同成长~！
     </p>
     <p>
      👍 ：如果你觉得这篇文章还不错，不妨顺手点个赞、加入收藏，并分享给更多的朋友噢~！
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <h2>
     <span style="color:#1a439c">
      <strong>
       1. 栈
      </strong>
     </span>
    </h2>
    <h3 id="1.1%20%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" name="1.1%20%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">
     <span style="color:#9c8ec1">
      1.1 栈的概念及结构
     </span>
    </h3>
    <blockquote>
     <p>
      栈是一种特殊的线性表，它只允许在固定的一端进行插入和删除元素操作。
     </p>
     <p>
     </p>
     <p>
      允许进行插入和删除操作的一端称为栈顶；另一端不允许进行插入和删除操作，称为栈底。
     </p>
     <p>
     </p>
     <p>
      栈中的数据元素遵守
      <strong>
       后进先出
      </strong>
      （LIFO，Last In First Out）的原则——
      <strong>
       最后进栈的数据元素会最先被取出
      </strong>
      。就像往一个桶里放东西，最后放进去的东西会在最上面，取的时候最先被取出。
     </p>
     <p>
     </p>
     <ul>
      <li>
       <strong>
        压栈
       </strong>
       ：栈的
       <strong>
        插入
       </strong>
       操作叫做进栈 / 压栈 / 入栈。
      </li>
      <li>
       <strong>
        出栈
       </strong>
       ：栈的
       <strong>
        删除
       </strong>
       操作叫做出栈。
      </li>
     </ul>
    </blockquote>
    <h3 id="" name="">
    </h3>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/51619fd4c1fa49c693be757830717dc8.png"/>
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/fb1fa060e7b94820b857e6a307dda1e8.png"/>
    </p>
    <h3 id="1.2%20%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" name="1.2%20%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">
     <span style="color:#9c8ec1">
      1.2 栈的实现
     </span>
    </h3>
    <p>
     栈的实现一般可使用数组或链表，
     <strong>
      相对而言数组的结构实现更优。
     </strong>
    </p>
    <ul>
     <li>
      若使用数组，一般来说数组末端作栈顶。在栈顶插入数据，只需简单地移动索引，且数组元素在内存中连续存储，访问速度快。
     </li>
     <li>
      若使用链表，每次插入数据要创建新节点并修改指针，涉及内存的动态分配和指针操作。
     </li>
    </ul>
    <pre><code>// 定长的静态栈的结构在实际中一般不实用，下面实现支持动态增长的栈

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

// 定义栈中存储的数据类型
typedef int STDataType;

// 定义栈的结构体
typedef struct Stack
{
    STDataType* a;  // 指向动态分配的数组，用于存储栈中的元素
    int top;        // 栈顶指针，指示栈顶元素的位置
    int capacity;   // 栈的当前容量
} Stack;

// 初始化栈
void StackInit(Stack* ps)
{
    // 确保传入的栈指针不为空
    assert(ps);
    // 初始分配一定的容量，这里假设初始容量为 4
    ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);
    if (ps-&gt;a == NULL)
    {
        perror("malloc fail");
        return;
    }
    // 初始化栈顶指针为 0，表示栈为空
    ps-&gt;top = 0;
    
    ps-&gt;capacity = 4;
}

// 入栈操作
void StackPush(Stack* ps, STDataType data)
{
    assert(ps);

    // 检查栈是否已满，如果已满则扩容
    if (ps-&gt;top == ps-&gt;capacity)
    {
        STDataType* tmp = (STDataType*)realloc(ps-&gt;a, ps-&gt;capacity * 2 * sizeof(STDataType));
        if (tmp == NULL)
        {
            perror("realloc fail");
            return;
        }
        // 更新栈的数组指针
        ps-&gt;a = tmp;
        
        ps-&gt;capacity *= 2;
    }
    // 将数据放入栈顶位置
    ps-&gt;a[ps-&gt;top] = data;
    
    ps-&gt;top++;   // 表示添加栈顶元素
}

// 出栈操作
void StackPop(Stack* ps)
{
    assert(ps);
    // 确保栈不为空才能进行出栈操作
    assert(ps-&gt;top &gt; 0);
    
    ps-&gt;top--;   // 表示移除栈顶元素
}

// 获取栈顶元素
STDataType StackTop(Stack* ps)
{
    assert(ps);
    // 确保栈不为空才能获取栈顶元素
    assert(ps-&gt;top &gt; 0);
    // 返回栈顶元素
    return ps-&gt;a[ps-&gt;top - 1];
}

// 获取栈中有效元素个数
int StackSize(Stack* ps)
{
    assert(ps);
    // 栈顶指针的值即为栈中有效元素的个数
    return ps-&gt;top;
}

// 检测栈是否为空，如果为空返回非零结果，如果不为空返回 0
int StackEmpty(Stack* ps)
{
    assert(ps);

    // 当栈顶指针为 0 时，栈为空
    return ps-&gt;top == 0;
}

// 销毁栈
void StackDestroy(Stack* ps)
{
    assert(ps);

    // 释放动态分配的数组内存
    free(ps-&gt;a);
    // 将数组指针置为 NULL，避免野指针
    ps-&gt;a = NULL;
    
    ps-&gt;top = 0;
    
    ps-&gt;capacity = 0;
}

int main()
{
    Stack st;

    // 初始化栈
    StackInit(&amp;st);

    // 入栈操作
    StackPush(&amp;st, 1);
    StackPush(&amp;st, 2);
    StackPush(&amp;st, 3);
    StackPush(&amp;st, 4);
    
    printf("Top element: %d\n", StackTop(&amp;st));
    // 打印栈中元素个数
    printf("Stack size: %d\n", StackSize(&amp;st));

    // 出栈操作
    StackPop(&amp;st);
    
    printf("Top element after pop: %d\n", StackTop(&amp;st));
    
    printf("Stack size after pop: %d\n", StackSize(&amp;st));

    // 检测栈是否为空
    printf("Is stack empty? %s\n", StackEmpty(&amp;st) ? "Yes" : "No");

    // 销毁栈
    StackDestroy(&amp;st);

    return 0;
}</code></pre>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ea30c871c8cd489d9a42e152ad9cc46b.png"/>
    </p>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：（1）初始化、出栈、获取栈顶元素、获取栈中元素个数和检测栈是否为空的操作时间复杂度均为 O(1)。（2）入栈操作在不需扩容时时间复杂度为 O(1)，扩容时平均时间复杂度也接近 O(1)。（3）销毁栈操作的时间复杂度为 O(1)。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：主要取决于栈中元素的个数，空间复杂度为 O(n)，n 是栈中元素的个数。
     </li>
    </ul>
    <hr/>
    <h2 id="2.%20%E9%98%9F%E5%88%97" name="2.%20%E9%98%9F%E5%88%97">
     <span style="color:#1a439c">
      2. 队列
     </span>
    </h2>
    <h3 id="2.1%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" name="2.1%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">
     <span style="color:#9c8ec1">
      2.1 队列的概念及结构
     </span>
    </h3>
    <blockquote>
     <p>
      队列是只允许在一端插入数据，在另一端删除数据的特殊线性表。
     </p>
     <p>
     </p>
     <p>
      队列有
      <strong>
       先进先出
      </strong>
      （FIFO，First In First Out）的特性——先
      <strong>
       进入队列的元素先出队列
      </strong>
      。好比排队收银，排在队伍前面的顾客先结账离开队伍，而后到的顾客要在后面依次等待。
     </p>
     <p>
     </p>
     <ul>
      <li>
       <strong>
        入队列
       </strong>
       ：插入数据操作。进行插入操作的一端称为队尾。
      </li>
      <li>
       <strong>
        出队列
       </strong>
       ：删除数据操作。进行删除操作的一端称为队头。
      </li>
     </ul>
    </blockquote>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/c8f19a301ff84cc9b3100da5f42cbc10.png"/>
    </h3>
    <h3 id="2.2%20%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" name="2.2%20%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent">
     <span style="color:#9c8ec1">
      2.2 队列的实现
     </span>
    </h3>
    <p>
     队列的实现可使用数组或链表，
     <strong>
      相对而言使用链表的结构实现更优。
     </strong>
    </p>
    <ul>
     <li>
      若使用数组，出队列即在数组头部删除元素，而由于数组元素在内存中连续存储，删除头部元素后，要将后面所有元素依次向前移动一位来填补空缺，此过程涉及大量的数据移动操作，效率较低；
     </li>
     <li>
      若使用链表，出队列删除头部节点时，只需修改头指针指向原头节点的下一个节点，然后释放原头节点的内存即可，效率更高。
     </li>
    </ul>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

// 定义队列存储的数据类型
typedef int QDataType;

// 定义队列节点的结构体，每个节点包含两部分
// 1. pNext：指向下一个节点的指针，用于连接队列中的各个节点
// 2. data：存储队列中的数据
typedef struct QListNode
{
    struct QListNode* pNext;
    QDataType data;
} QNode;

// 定义队列的结构体，包含两个指针
// 1. front：指向队列的头部节点
// 2. rear：指向队列的尾部节点 
typedef struct Queue
{
    QNode* front;
    QNode* rear;
} Queue;

// 初始化队列 
void QueueInit(Queue* q) 
{
    // 断言队列指针不为空，避免传入空指针导致程序崩溃
    assert(q);

    // 初始化队头和队尾指针为 NULL，表示队列为空
    q-&gt;front = NULL;
    q-&gt;rear = NULL;
}

// 队尾入队列 
void QueuePush(Queue* q, QDataType data) 
{
    assert(q);
    // 为新节点分配内存
    QNode* newNode = (QNode*)malloc(sizeof(QNode));
    if (newNode == NULL) 
    {
        perror("malloc fail");
        return;
    }
    // 给新节点的“数据域”赋值
    newNode-&gt;data = data;
    
    // 新节点的下一个节点指针置为 NULL，因为新节点将成为尾节点，其后无其他节点
    newNode-&gt;pNext = NULL;

    if (q-&gt;rear == NULL) 
    {
        // 如果队列为空，新节点既是队头也是队尾
        q-&gt;front = newNode;
        q-&gt;rear = newNode;
    }
    else 
    {
        // 新节点连接到队尾
        q-&gt;rear-&gt;pNext = newNode;
        // 更新队尾指针指向新节点
        q-&gt;rear = newNode;
    }
}

// 队头出队列 
void QueuePop(Queue* q) 
{
    assert(q);

    // 断言队列不为空
    assert(!QueueEmpty(q));

    // 保存队头节点的下一个节点的指针
    QNode* next = q-&gt;front-&gt;pNext;
    free(q-&gt;front);
    q-&gt;front = next;

    if (q-&gt;front == NULL) 
    {
        // 如果队头为空，说明队列已空，将队尾指针也置为 NULL
        q-&gt;rear = NULL;
    }
}

// 获取队列头部元素 
QDataType QueueFront(Queue* q) 
{
    assert(q);
    assert(!QueueEmpty(q));

    // 返回队头节点的数据
    return q-&gt;front-&gt;data;
}

// 获取队列队尾元素 
QDataType QueueBack(Queue* q) 
{
    assert(q);
    assert(!QueueEmpty(q));
    return q-&gt;rear-&gt;data;
}

// 获取队列中有效元素个数 
int QueueSize(Queue* q) 
{
    assert(q);
    int size = 0;
    QNode* cur = q-&gt;front;
    // 遍历队列，统计节点个数
    while (cur) 
    {
        size++;
        cur = cur-&gt;pNext;
    }
    return size;
}

// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
int QueueEmpty(Queue* q) 
{
    assert(q);
    // 队头指针为空则队列为空
    return q-&gt;front == NULL;
}

// 销毁队列 
void QueueDestroy(Queue* q) 
{
    assert(q);
    QNode* cur = q-&gt;front;

    // 遍历队列，释放每个节点的内存
    while (cur) 
    {
        QNode* next = cur-&gt;pNext;
        free(cur);
        cur = next;
    }
    
    q-&gt;front = NULL;
    q-&gt;rear = NULL;
}

int main() 
{
    Queue q;   // 声明一个 Queue 类型的变量，为队列分配了内存空间
    QueueInit(&amp;q);   // 初始化队列

    // 入队操作
    QueuePush(&amp;q, 1);
    QueuePush(&amp;q, 2);
    QueuePush(&amp;q, 3);

    // 输出队头/尾元素
    printf("Queue front: %d\n", QueueFront(&amp;q));
    printf("Queue back: %d\n", QueueBack(&amp;q));

    // 输出队列元素个数
    printf("Queue size: %d\n", QueueSize(&amp;q));

    // 出队操作
    QueuePop(&amp;q);
    printf("Queue front after pop: %d\n", QueueFront(&amp;q));

    // 销毁队列
    QueueDestroy(&amp;q);

    return 0;
}</code></pre>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/cd59c1f43ebb4fa18bbf11cd74d6ee71.png"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：
      <code>
       QueueSize
      </code>
      和
      <code>
       QueueDestroy
      </code>
      函数的时间复杂度为 O(n)，其余函数的时间复杂度均为 O(1)。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：所有函数的空间复杂度均为 O(1)。整个队列的空间复杂度为 O(n)，其中
      <code>
       n
      </code>
      是队列中元素的数量。
     </li>
    </ul>
    <p>
    </p>
    <blockquote>
     <p>
      在数据结构中，一个节点通常由多个部分组成，其中用于存储实际数据的部分称为
      <strong>
       数据域
      </strong>
      。而用于存储指向下一个节点地址的部分称为
      <strong>
       指针域
      </strong>
      。
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38363635303134332f:61727469636c652f64657461696c732f313436313035373237" class_="artid" style="display:none">
 </p>
</div>


