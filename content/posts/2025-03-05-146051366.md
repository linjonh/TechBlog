---
layout: post
title: "Redis-常见数据类型"
date: 2025-03-05 19:47:57 +0800
description: "官方文档1）Redis 的命令有上百个，如果纯靠死记硬背比较困难，但是如果理解 Redis 的一些机制，会发现这些命令有很强的通用性。2）Redis 不是万金油，有些数据结构和命令必须在特定场景下使用，一旦使用不当可能对 Redis 本身或者应用本身造成致命伤害。"
keywords: "Redis 常见数据类型"
categories: ['Redis']
tags: ['数据库', 'Redis']
artid: "146051366"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146051366
    alt: "Redis-常见数据类型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146051366
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146051366
cover: https://bing.ee123.net/img/rand?artid=146051366
image: https://bing.ee123.net/img/rand?artid=146051366
img: https://bing.ee123.net/img/rand?artid=146051366
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis 常见数据类型
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="u8576424f">
     官方文档
     <a href="https://redis.io/docs/latest/commands/" rel="nofollow" title="RedisCommands">
      RedisCommands
     </a>
    </p>
    <p id="ud27bd656">
     1）Redis 的命令有上百个，如果纯靠死记硬背比较困难，但是如果理解 Redis 的一些机制，会发现这些命令有很强的通用性。
    </p>
    <p id="u9e5027aa">
     2）Redis 不是万金油，有些数据结构和命令必须在特定场景下使用，一旦使用不当可能对 Redis 本身或者应用本身造成致命伤害。
    </p>
    <p id="uc1669904">
    </p>
    <h2 id="k9BV3">
     基本全局命令
    </h2>
    <p id="u1b326600">
     Redis 有 5 种数据结构，但它们都是键值对种的值，对于键来说有一些通用的命令。
    </p>
    <h3 id="gwl41">
     KEYS
    </h3>
    <p id="u16a742a3">
     返回所有满足样式（pattern）的 key。支持如下统配样式。
    </p>
    <p id="u44054577">
     • h?llo 匹配 hello , hallo 和 hxllo （匹配任意一个字符）
    </p>
    <p id="ua5a75397">
     • h*llo 匹配 hllo 和heeeello （匹配0个或多个字符）
    </p>
    <p id="uce4c233d">
     • h[ae]llo 匹配hello 和hallo 但不匹配 hillo （只匹配a字符和e字符）
    </p>
    <p id="u26262ee4">
     • h[^e]llo 匹配hallo , hbllo , ... 但不匹配 hello （只匹配非e字符的其他字符）
    </p>
    <p id="ud1f9f440">
     • h[a-b]llo 匹配hallo 和 hbllo （匹配a-b之间的所有字符）
    </p>
    <p id="u88c7649b">
     语法：
    </p>
    <pre id="kLcdf"><code>KEYS pattern</code></pre>
    <p id="uae4ab6bc">
    </p>
    <p class="img-center">
     <img alt="" height="272" id="u62d0a0c1" src="https://i-blog.csdnimg.cn/img_convert/70f2acbcc625a9ddbd1c2f811fd8b83c.png" width="475"/>
    </p>
    <p id="u6bcb6868">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u14a09426">
     时间复杂度：O(N)
    </p>
    <p id="ufebcf07d">
     返回值：匹配 pattern 的所有 key。
    </p>
    <h3 id="xRMnJ">
     EXISTS
    </h3>
    <p id="u6c2046fd">
     判断某个 key 是否存在。
    </p>
    <p id="u31727ff1">
     语法：
    </p>
    <pre id="Xb0si"><code>EXISTS key [key ...]</code></pre>
    <p id="u35dc5606">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ueaf8beb1">
     时间复杂度：O(1)
    </p>
    <p id="u94663bb5">
     返回值：key 存在的个数。
    </p>
    <p id="u8713df4b">
    </p>
    <p class="img-center">
     <img alt="" height="193" id="u1e1327db" src="https://i-blog.csdnimg.cn/img_convert/f067a46a2cac5eda65e4d1841b96f355.png" width="544"/>
    </p>
    <h3 id="V6WD2">
     DEL
    </h3>
    <p id="ubd35e6ba">
     删除指定的 key。
    </p>
    <p id="ue7d29b83">
     语法：
    </p>
    <pre id="pw2Ya"><code>DEL key [key ...]</code></pre>
    <p id="uda5a79a1">
    </p>
    <p class="img-center">
     <img alt="" height="114" id="TPvvj" src="https://i-blog.csdnimg.cn/img_convert/d5afe9be4c47e0bedd634dc17b065ce9.png" width="422"/>
    </p>
    <p id="u1dd763c9">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ub16a17d3">
     时间复杂度：O(1)
    </p>
    <p id="u60e9b76f">
     返回值：删除掉的 key 的个数。
    </p>
    <h3 id="hDgXq">
     EXPIRE
    </h3>
    <p id="uc2e29205">
     为指定的 key 添加秒级的过期时间（Time To Live TTL）
    </p>
    <p id="u85510860">
     语法：
    </p>
    <pre id="eGwHj"><code>EXPIRE key seconds</code></pre>
    <p id="u038cfa0b">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u52081890">
     时间复杂度：O(1)
    </p>
    <p id="u046d5961">
     返回值：1 表示设置成功。0 表示设置失败。
    </p>
    <p id="ud09910ff">
    </p>
    <p class="img-center">
     <img alt="" height="213" id="uaf4d49ae" src="https://i-blog.csdnimg.cn/img_convert/6df55855c62e5e869c7108b20fb857ec.png" width="478"/>
    </p>
    <h3 id="aQhTB">
     TTL
    </h3>
    <p id="u38796588">
     获取指定 key 的过期时间，秒级。
    </p>
    <pre id="QDkbF"><code>TTL key</code></pre>
    <p id="u1d384558">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u17e938eb">
     时间复杂度：O(1)
    </p>
    <p id="ube77be88">
     返回值：剩余过期时间。-1 表示没有关联过期时间，-2 表示 key 不存在。
    </p>
    <p id="u89a69f6e">
    </p>
    <p class="img-center">
     <img alt="" height="189" id="xsubm" src="https://i-blog.csdnimg.cn/img_convert/5373a42550fdd7ecb5421f4eaeaa3f9d.png" width="460"/>
    </p>
    <p id="u91628cd4">
     💡 EXPIRE 和 TTL 命令都有对应的支持毫秒为单位的版本：PEXPIRE 和 PTTL
    </p>
    <hr id="h0BMs"/>
    <h4 id="rrejV">
     键的过期机制
    </h4>
    <p id="u960ba394">
    </p>
    <p class="img-center">
     <img alt="" height="293" id="OLgoA" src="https://i-blog.csdnimg.cn/img_convert/71e0e0bef864ea5b3879c677806a5bdf.png" width="771"/>
    </p>
    <h3 id="hiWRb">
     TYPE
    </h3>
    <p id="u41a465e9">
     返回 key 对应的数据类型。
    </p>
    <p id="ud98f3f6d">
     语法：
    </p>
    <pre id="O9RuX"><code>TYPE key</code></pre>
    <p id="u85a83584">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u2740b947">
     时间复杂度：O(1)
    </p>
    <p id="u065e9691">
     返回值： none , string , list , set , zset , hash and stream .。
    </p>
    <p id="ucc90cdb2">
    </p>
    <p class="img-center">
     <img alt="" height="211" id="u28c0087a" src="https://i-blog.csdnimg.cn/img_convert/67016d97ce0dfea3704f89293dd7c6e8.png" width="613"/>
    </p>
    <h4 id="iIIBk">
     数据结构和内部编码
    </h4>
    <p id="u85b1d3ba">
     type 命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、list（列表）、hash（哈希）、set（集合）、zset（有序集合），但这些只是 Redis 对外的数据结构。
    </p>
    <p id="u7c50bff6">
    </p>
    <p class="img-center">
     <img alt="" height="675" id="u85cc1e3f" src="https://i-blog.csdnimg.cn/img_convert/b97c536a317ff9943cc79efb904971e4.png" width="748"/>
    </p>
    <p id="u15a876b7">
     实际上 Redis 针对每种数据结构都有自己的底层内部编码实现，而且是多种实现，这样 Redis 会在合适的场景选择合适的内部编码
    </p>
    <table id="f8wsm">
     <tbody>
      <tr>
       <td>
        <p id="uc9c99fad">
         数据结构
        </p>
       </td>
       <td>
        <p id="u71aa18c4">
         内部编码
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u6c92716c">
         string
        </p>
       </td>
       <td>
        <p id="u55cf81ca">
         raw(最基本的字符串)
        </p>
        <p id="ube84a38a">
         int(计数)
        </p>
        <p id="u24f49322">
         embstr(针对段字符串进行的特殊优化)
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="ufc467e8b">
         hash
        </p>
       </td>
       <td>
        <p id="u93ec42b7">
         hashtable(哈希表)
        </p>
        <p id="ub91387a0">
         ziplist(压缩列表，在哈希表里面元素比较少的时候，可能就优化成ziplist)
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u87fd4832">
         list
        </p>
       </td>
       <td>
        <p id="u4a729f24">
         linkedlist(链表)
        </p>
        <p id="uee557b2f">
         ziplist(压缩列表)
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="uf773810e">
         set
        </p>
       </td>
       <td>
        <p id="ud0b365a7">
         hashtable(哈希表)
        </p>
        <p id="ucd9f04a6">
         intset(集合中存的都是整数)
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u6540df66">
         zset
        </p>
       </td>
       <td>
        <p id="ubadd5e7b">
         skiplist(跳表)
        </p>
        <p id="u7788c298">
         ziplist(压缩列表)
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p id="u783a1b46">
     可以看到每种数据结构都有至少两种以上的内部编码实现，例如 list 数据结构包含了 linkedlist 和ziplist 两种内部编码。同时有些内部编码，例如 ziplist，可以作为多种数据结构的内部实现，可以通过 object encoding 命令查询内部编码：
    </p>
    <p id="ub132a641">
    </p>
    <p class="img-center">
     <img alt="" height="243" id="u69e1e58d" src="https://i-blog.csdnimg.cn/img_convert/afd01e8faf40b75a3a64ad55ce322efd.png" width="554"/>
    </p>
    <p id="ud2eae533">
    </p>
    <p id="u3465717a">
    </p>
    <h2 id="uP8IJ">
     String字符串
    </h2>
    <p id="u7dbf4863">
     字符串类型是 Redis 最基础的数据类型，关于字符串需要特别注意：
    </p>
    <p id="u3b1df36f">
     1）首先 Redis 中所有的键的类型都是字符串类型，而且其他几种数据结构也都是在字符串类似基础上构建的，例如列表和集合的元素类型是字符串类型，所以字符串类型能为其他 4 种数据结构的学习奠定基础。
    </p>
    <p id="u545eea83">
     2）字符串类型的值实际可以是字符串，包含一般格式的字符串或者类似 JSON、XML 格式的字符串；数字，可以是整型或者浮点型；甚至是二进制流数据，例如图片、音频、视频等。不过一个字符串的最大值不能超过 512 MB。
    </p>
    <p id="uc13d8a44">
     由于 Redis 内部存储字符串完全是按照二进制流的形式保存的，所以 Redis 是不处理字符集编码问题的，客户端传入的命令中使用的是什么字符集编码，就存储什么字符集编码
    </p>
    <p id="u4be82f6b">
    </p>
    <p class="img-center">
     <img alt="" height="671" id="gbNgH" src="https://i-blog.csdnimg.cn/img_convert/33f59bab780bbde77f2d301bd277b6fd.png" width="769"/>
    </p>
    <h3 id="EOPDI">
     典型使用场景
    </h3>
    <h4 id="dsLm5">
     缓存(Cache)功能
    </h4>
    <p id="ub57b97ad">
     Redis 作为缓冲层，MySQL 作为存储层，绝大部分请求的数据都是从 Redis 中获取。由于 Redis 具有支撑高并发的特性，所以缓存通常能起到加速读写和降低后端压力的作用。
    </p>
    <p id="ubd912c2a">
     Redis + MySQL 组成的缓存存储架构
    </p>
    <p class="img-center">
     <img alt="" height="656" id="u5b175b0a" src="https://i-blog.csdnimg.cn/img_convert/d585c1e620d1207a8a46fc1cb55216ce.png" width="727"/>
    </p>
    <ol>
     <li id="ueff3dc5b">
      假设业务是根据用户uid获取用户信息
     </li>
    </ol>
    <pre id="ry0nV"><code>UserInfo getUserInfo(long uid)</code></pre>
    <ol>
     <li id="u2adff498">
      首先从 Redis 获取用户信息，我们假设用户信息保存在 "user:info:&lt;uid&gt;" 对应的键中：
     </li>
    </ol>
    <pre id="Q6lPt"><code>// 根据 uid 得到 Redis 的键
String key = "user:info:" + uid;
// 尝试从 Redis 中获取对应的值
String value = Redis 执行命令：get key;
// 如果缓存命中（hit）
if (value != null) {
// 假设我们的用户信息按照 JSON 格式存储
UserInfo userInfo = JSON 反序列化(value);
return userInfo;
}</code></pre>
    <ol>
     <li id="uba6a6614">
      如果没有从 Redis 中得到用户信息，及缓存 miss，则进一步从 MySQL 中获取对应的信息，随后写入缓存并返回：
     </li>
    </ol>
    <pre id="AeEcb"><code>// 如果缓存未命中（miss）
if (value == null) {
// 从数据库中，根据 uid 获取用户信息
UserInfo userInfo = MySQL 执行 SQL：select * from user_info where uid =
&lt;uid&gt;
// 如果表中没有 uid 对应的用户信息
if (userInfo == null) {
响应 404
return null;
}
// 将用户信息序列化成 JSON 格式
String value = JSON 序列化(userInfo);
// 写入缓存，为了防止数据腐烂（rot），设置过期时间为 1 小时（3600 秒）
Redis 执行命令：set key value ex 3600
// 返回用户信息
return userInfo;
}</code></pre>
    <p id="ua1817a07">
     通过增加缓存功能，在理想情况下，每个用户信息，一个小时期间只会有一次 MySQL 查询，极大地提升了查询效率，也降低了 MySQL 的访问数。
    </p>
    <h4 id="jwT8J">
     计数(Counter)功能
    </h4>
    <p id="ud9fb36f9">
     许多应用都会使用 Redis 作为计数的基础工具，它可以实现快速计数、查询缓存的功能，同时数据可以异步处理或者落地到其他数据源。例如视频网站的视频播放次数可以使用Redis 来完成：用户每播放一次视频，相应的视频播放数就会自增 1。
    </p>
    <p class="img-center">
     <img alt="" height="628" id="u3b5d31c1" src="https://i-blog.csdnimg.cn/img_convert/823eaecefc718b267a41313a3a92d144.png" width="728"/>
    </p>
    <pre id="gtcUt"><code>// 在 Redis 中统计某视频的播放次数
long incrVideoCounter(long vid) {
    key = "video:" + vid;
    long count = Redis 执行命令：incr key
    return counter;
}
// 实际中要开发一个成熟、稳定的真实计数系统，要面临的挑战远不止如此简单：防作弊、按
// 照不同维度计数、避免单点问题、数据持久化到底层数据源等。</code></pre>
    <h4 id="PF6aL">
     共享会话(Session)
    </h4>
    <p id="u46068626">
     一个分布式 Web 服务将用户的 Session 信息（例如用户登录信息）保存在各自的服务器中，但这样会造成一个问题：出于负载均衡的考虑，分布式服务会将用户的访问请求均衡到不同的服务器上，并且通常无法保证用户每次请求都会被均衡到同一台服务器上，这样当用户刷新一次访问是可能会发现需要重新登录，这个问题是用户无法容忍的。
    </p>
    <p id="uea56e7fe">
     Session 分散存储
    </p>
    <p id="udf4e8184">
    </p>
    <p class="img-center">
     <img alt="" height="516" id="u8aa39dc6" src="https://i-blog.csdnimg.cn/img_convert/4fbc26c36c23eb9d2813ccac30897e2b.png" width="728"/>
    </p>
    <p id="u48a37b4c">
     为了解决这个问题，可以使用 Redis 将用户的 Session 信息进行集中管理，如图 2-13 所示，在这种模式下，只要保证 Redis 是高可用和可扩展性的，无论用户被均衡到哪台 Web 服务器上，都集中从Redis 中查询、更新 Session 信息。
    </p>
    <p id="uba9faabf">
     Redis 集中管理 Session
    </p>
    <p id="uae35acab">
    </p>
    <p class="img-center">
     <img alt="" height="717" id="u6834a68c" src="https://i-blog.csdnimg.cn/img_convert/89c6731d044f963dd5c630e03fdd0237.png" width="731"/>
    </p>
    <h4 id="CKrfF">
     手机验证码
    </h4>
    <p id="u35f90502">
     很多应用出于安全考虑，会在每次进行登录时，让用户输入手机号并且配合给手机发送验证码，然后让用户再次输入收到的验证码并进行验证，从而确定是否是用户本人。为了短信接口不会频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过 5 次。
    </p>
    <p id="uf3eb67d0">
     短信验证码
    </p>
    <p id="ua1a69985">
    </p>
    <p class="img-center">
     <img alt="" height="161" id="u87f84dad" src="https://i-blog.csdnimg.cn/img_convert/d7d1e42d700aefa4a85a4c4318776e31.png" width="726"/>
    </p>
    <p id="u119c6347">
     此功能可以用以下伪代码说明基本实现思路：
    </p>
    <pre id="tLO8j"><code>String 发送验证码(phoneNumber) {
    key = "shortMsg:limit:" + phoneNumber;
    // 设置过期时间为 1 分钟（60 秒）
    // 使用 NX，只在不存在 key 时才能设置成功
    bool r = Redis 执行命令：set key 1 ex 60 nx
    if (r == false) {
        // 说明之前设置过该手机的验证码了
        long c = Redis 执行命令：incr key
    if (c &gt; 5) {
        // 说明超过了一分钟 5 次的限制了
        // 限制发送
        return null;
    }
}
// 说明要么之前没有设置过手机的验证码；要么次数没有超过 5 次
String validationCode = 生成随机的 6 位数的验证码();
    validationKey = "validation:" + phoneNumber;
    // 验证码 5 分钟（300 秒）内有效
    Redis 执行命令：set validationKey validationCode ex 300;
    // 返回验证码，随后通过手机短信发送给用户
    return validationCode ;
}
// 验证用户输入的验证码是否正确
bool 验证验证码(phoneNumber, validationCode) {
    validationKey = "validation:" + phoneNumber;
    String value = Redis 执行命令：get validationKey;
    if (value == null) {
        // 说明没有这个手机的验证码记录，验证失败
        return false;
    }
    if (value == validationCode) {
        return true;
    } else {
        return false;
    }
}</code></pre>
    <h2 id="w9Fe9">
    </h2>
    <h3 id="IuweX">
     常见命令
    </h3>
    <h3 id="heEE7">
     SET
    </h3>
    <p id="ub82bb4bc">
     将 string 类型的 value 设置到 key 中。如果 key 之前存在，则覆盖，无论原来的数据类型是什么。之前关于此 key 的 TTL (获取指定key的过期时间)也全部失效。
    </p>
    <pre id="ni4Kd"><code>SET key value [expiration EX seconds|PX milliseconds] 1 [NX|XX]
set key value ex 10 相当于 set key value expire key 10
// 但是单个命令是原子的，保证这条语句是在同一时间执行的，分开写不能保证语句是同一时间执行的</code></pre>
    <p id="ub5bb89a9">
    </p>
    <p class="img-center">
     <img alt="" height="110" id="EJbi3" src="https://i-blog.csdnimg.cn/img_convert/e32f1f207207c17dd4da7ed4e4ee9f32.png" width="540"/>
    </p>
    <p id="u15f5f8d6">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u1cb70eb7">
     时间复杂度：O(1)
    </p>
    <p id="u46ddb7a5">
     SET 命令支持多种选项来影响它的行为：
    </p>
    <p id="u4b1afd75">
     • EX seconds —— 使用秒作为单位设置 key 的过期时间。
    </p>
    <p id="ud1d99a23">
     • PX milliseconds —— 使用毫秒作为单位设置 key 的过期时间。
    </p>
    <p id="u32c56e71">
     • NX —— 只在 key 不存在时才进行设置，即如果 key 之前已经存在，设置不执行。
    </p>
    <p id="u855a9628">
     • XX —— 只在 key 存在时才进行设置，即如果 key 之前不存在，设置不执行。
    </p>
    <p id="u32c4fa28">
     注意：由于带选项的 SET 命令可以被 SETNX 、SETEX 、PSETEX 等命令代替，所以之后的版本中，Redis 可能进行合并。
    </p>
    <p id="u6767aeda">
     返回值：
    </p>
    <p id="ua66a8dad">
     • 如果设置成功，返回 OK。
    </p>
    <p id="u536f88cd">
     • 如果由于 SET 指定了 NX 或者 XX 但条件不满足，SET 不会执行，并返回 (nil)。
    </p>
    <p id="uc34ec225">
    </p>
    <p class="img-center">
     <img alt="" height="597" id="u377a964b" src="https://i-blog.csdnimg.cn/img_convert/35f5fbedbf6dc0f48b3fa54d314ab6a0.png" width="879"/>
    </p>
    <h3 id="btq6j">
     GET
    </h3>
    <p id="ue4495c1e">
     获取 key 对应的 value。如果 key 不存在，返回 nil。如果 value 的数据类型不是 string，会报错。
    </p>
    <p id="u7555abca">
     语法：
    </p>
    <pre id="In4pQ"><code>GET key</code></pre>
    <p id="u5ef8b131">
    </p>
    <p class="img-center">
     <img alt="" height="193" id="nbKYE" src="https://i-blog.csdnimg.cn/img_convert/38ab100c06dba0b5716c5db3710ab23b.png" width="367"/>
    </p>
    <p id="u9c370b8a">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ufb098f4c">
     时间复杂度：O(1)
    </p>
    <p id="u03799873">
     返回值：key 对应的 value，或者 nil 当 key 不存在。
    </p>
    <h3 id="HXEmY">
     MGET和MSET
    </h3>
    <p id="uf888e768">
     MGET 一次性获取多个 key 的值。如果对应的 key 不存在或者对应的数据类型不是 string，返回 nil。
    </p>
    <p id="u879738fd">
     MSET 一次性设置多个 key 的值。
    </p>
    <pre id="IvKNC"><code>MGET key [key ...]
MSET key value [key value ...]</code></pre>
    <p id="u60698406">
     命令有效版本：1.0.0 之后
    </p>
    <p id="uc85e7543">
     时间复杂度：O(N) N 是 key 数量
    </p>
    <p id="uf1b8b65a">
     MGET 返回值：对应 value 的列表
    </p>
    <p id="ub35402b6">
     MSET返回值：永远是 OK
    </p>
    <p id="u1819565d">
    </p>
    <p class="img-center">
     <img alt="" height="200" id="u7079dca1" src="https://i-blog.csdnimg.cn/img_convert/d63aab23a273a0db0ccc7a775d0638c9.png" width="681"/>
    </p>
    <hr id="Pv3QW"/>
    <h4 id="J8r8F">
     多次get和单词mget
    </h4>
    <p id="u4152e3d1">
    </p>
    <p class="img-center">
     <img alt="" height="688" id="ubb4d643a" src="https://i-blog.csdnimg.cn/img_convert/ed3c7d345f0162d9229e477404da51d2.png" width="570"/>
    </p>
    <p id="u487068e9">
     使用 mget / mset 由于可以有效地减少了网络时间，所以性能相较更高。会使用批量操作，可以有效提高业务处理效率，但是要注意，每次批量操作所发送的键的数量也不是无节制的，否则可能造成单一命令执行时间过长，导致 Redis 阻塞。
    </p>
    <h3 id="P40J2">
     SETNX
    </h3>
    <p id="uc4f29ddd">
     设置 key-value 但只允许在 key 之前不存在的情况下。
    </p>
    <pre id="FmppK"><code>SETNX key value</code></pre>
    <p id="ubc3df571">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u3d4bb950">
     时间复杂度：O(1)
    </p>
    <p id="ubff2c703">
     返回值：1 表示设置成功。0 表示没有设置。
    </p>
    <p class="img-center">
     <img alt="" height="190" id="u4d95e550" src="https://i-blog.csdnimg.cn/img_convert/10b0e1239cb497ef478b42b1c3cf0166.png" width="481"/>
    </p>
    <h3 id="cycDZ">
     计数命令
    </h3>
    <h5 id="jwtG4">
     INCR
    </h5>
    <p id="u050d7eb0">
     将 key 对应的 string 表示的数字加一。如果 key 不存在，则视为 key 对应的 value 是 0。如果 key 对应的 string 不是一个整型或者范围超过了 64 位有符号整型，则报错。
    </p>
    <pre id="GnTfE"><code>INCR key</code></pre>
    <p id="u195bc7c4">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ue45c099a">
     时间复杂度：O(1)
    </p>
    <p id="u30aefda4">
     返回值：integer 类型的加完后的数值。
    </p>
    <p class="img-center">
     <img alt="" height="307" id="u0a0cc7c0" src="https://i-blog.csdnimg.cn/img_convert/f4844a3c730a8967949c72e3d14050ee.png" width="881"/>
    </p>
    <h5 id="u5ke9">
     INCRBY
    </h5>
    <p id="uf2d617a8">
     将 key 对应的 string 表示的数字加上对应的值。如果 key 不存在，则视为 key 对应的 value 是 0。如果 key 对应的 string 不是一个整型或者范围超过了 64 位有符号整型，则报错。
    </p>
    <pre id="A6hw0"><code>INCRBY key decrement</code></pre>
    <p id="ud039fc30">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u5a801903">
     时间复杂度：O(1)
    </p>
    <p id="u71b9c8b4">
     返回值：integer 类型的加完后的数值。
    </p>
    <p class="img-center">
     <img alt="" height="111" id="u381b669a" src="https://i-blog.csdnimg.cn/img_convert/839c69cd08d59fda1af03c9a8a0e8ee4.png" width="626"/>
    </p>
    <h5 id="gNTak">
     DECR
    </h5>
    <p id="ud730f316">
     将 key 对应的 string 表示的数字减一。如果 key 不存在，则视为 key 对应的 value 是 0。如果 key 对应的 string 不是一个整型或者范围超过了 64 位有符号整型，则报错。
    </p>
    <pre id="ELZwP"><code>DECR key</code></pre>
    <p id="u2598df9a">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u13026277">
     时间复杂度：O(1)
    </p>
    <p id="ufb38a380">
     返回值：integer 类型的减完后的数值。
    </p>
    <p id="ua5a61a7f">
    </p>
    <p class="img-center">
     <img alt="" height="181" id="uf67db210" src="https://i-blog.csdnimg.cn/img_convert/61841f0a3f800d4bf2dc1e21577727f3.png" width="598"/>
    </p>
    <h5 id="B1jZ8">
     DECYBY
    </h5>
    <p id="ub6b500b5">
     将 key 对应的 string 表示的数字减去对应的值。如果 key 不存在，则视为 key 对应的 value 是 0。如果 key 对应的 string 不是一个整型或者范围超过了 64 位有符号整型，则报错。/dmk
    </p>
    <pre id="Q1d4I"><code>DECRBY key decrement</code></pre>
    <p id="u8ccf4b3e">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ufa0608eb">
     时间复杂度：O(1)
    </p>
    <p id="u48f7dcca">
     返回值：integer 类型的减完后的数值。
    </p>
    <p class="img-center">
     <img alt="" height="192" id="u0bcd9ada" src="https://i-blog.csdnimg.cn/img_convert/e59474f6108d42339be5d6b017c2f875.png" width="817"/>
    </p>
    <h5 id="zpuq1">
     INCRBYFLOAT
    </h5>
    <p id="u7d032e8e">
     将 key 对应的 string 表示的浮点数加上对应的值。如果对应的值是负数，则视为减去对应的值。如果key 不存在，则视为 key 对应的 value 是 0。如果 key 对应的不是 string，或者不是一个浮点数，则报错。允许采用科学计数法表示浮点数。
    </p>
    <pre id="VDwI8"><code>INCRBYFLOAT key increment</code></pre>
    <p id="u4dc7c648">
     命令有效版本：2.6.0 之后
    </p>
    <p id="u3f1399dc">
     时间复杂度：O(1)
    </p>
    <p id="u0cab4030">
     返回值：加/减完后的数值。
    </p>
    <p id="u9f0f3b83">
    </p>
    <p class="img-center">
     <img alt="" height="280" id="ufc6ed476" src="https://i-blog.csdnimg.cn/img_convert/80bd9486d04862d6e3686ffc7290150d.png" width="522"/>
    </p>
    <p id="u2ef26df6">
     很多存储系统和编程语言内部使用 CAS 机制实现计数功能，会有一定的 CPU 开销，但在 Redis 中完全不存在这个问题，因为 Redis 是单线程架构，任何命令到了 Redis 服务端都要顺序执行。
    </p>
    <h3 id="RMUUO">
     其他命令
    </h3>
    <h3 id="c1j2q">
     APPEND
    </h3>
    <p id="u46d52086">
     如果 key 已经存在并且是一个 string，命令会将 value 追加到原有 string 的后边。如果 key 不存在，则效果等同于 SET 命令。
    </p>
    <pre id="srMQ0"><code>APPEND KEY VALUE</code></pre>
    <p id="ub87bd7ea">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u0e3ca564">
     时间复杂度：O(1). 追加的字符串一般长度较短, 可以视为 O(1).
    </p>
    <p id="u4fe7d22c">
     返回值：追加完成之后 string 的长度。
    </p>
    <p id="u0e6360a2">
    </p>
    <p class="img-center">
     <img alt="" height="263" id="u82d93fec" src="https://i-blog.csdnimg.cn/img_convert/49c6e51267589fd6f443d8e9eb4e607d.png" width="553"/>
    </p>
    <h3 id="eN32I">
     GETRANGE
    </h3>
    <p id="u4137e524">
     返回 key 对应的 string 的子串，由 start 和 end 确定（左闭右闭）。可以使用负数表示倒数。-1 代表倒数第一个字符，-2 代表倒数第二个，其他的与此类似。超过范围的偏移量会根据 string 的长度调整成正确的值。
    </p>
    <pre id="k1YSR"><code>GETRANGE key start end</code></pre>
    <p id="u2559944d">
     命令有效版本：2.4.0 之后
    </p>
    <p id="uf33235b2">
     时间复杂度：O(N). N 为 [start, end] 区间的长度. 由于 string 通常比较短, 可以视为是 O(1)
    </p>
    <p id="u61f13e99">
     返回值：string 类型的子串
    </p>
    <p id="u90ff772d">
    </p>
    <p class="img-center">
     <img alt="" height="127" id="ud7b70985" src="https://i-blog.csdnimg.cn/img_convert/ad37a3a3dfed4ef0deae1b45d9dbe9a1.png" width="496"/>
    </p>
    <p class="img-center">
     <img alt="" height="68" id="u05b96ade" src="https://i-blog.csdnimg.cn/img_convert/1805b10d5889794d7cc77e096ee3b856.png" width="511"/>
    </p>
    <h3 id="ExHr0">
     SETRANGE
    </h3>
    <p id="u6a7bcf96">
     覆盖字符串的一部分，从指定的偏移开始。
    </p>
    <pre id="xBcxC"><code>SETRANGE key offset value</code></pre>
    <p id="uf46dd39a">
     命令有效版本：2.2.0 之后
    </p>
    <p id="u12bf1b08">
     时间复杂度：O(N), N 为 value 的长度. 由于一般给的 value 比较短, 通常视为 O(1).
    </p>
    <p id="ub4ccb7ce">
     返回值：替换后的 string 的长度。
    </p>
    <p id="u9899cf0d">
    </p>
    <p class="img-center">
     <img alt="" height="207" id="ue7a2e56c" src="https://i-blog.csdnimg.cn/img_convert/065b08982a8cd5b24cf50f482f294ae9.png" width="556"/>
    </p>
    <h3 id="aY44v">
     STRLEN
    </h3>
    <p id="u1bcd1d09">
     获取 key 对应的 string 的长度。当 key 存放的类似不是 string 时，报错。
    </p>
    <pre id="PSbIS"><code>STRLEN key</code></pre>
    <p id="ubde79fa4">
     命令有效版本：2.2.0 之后
    </p>
    <p id="u7d89e996">
     时间复杂度：O(1)
    </p>
    <p id="uebca4fe6">
     返回值：string 的长度。或者当 key 不存在时，返回 0。
    </p>
    <p class="img-center">
     <img alt="" height="154" id="uef1c2fe9" src="https://i-blog.csdnimg.cn/img_convert/df23260fd6c68405c9c5c9b83bf96313.png" width="559"/>
    </p>
    <h3 id="d9gOB">
     字符串类型命令
    </h3>
    <p id="u5fa80bcc">
    </p>
    <p class="img-center">
     <img alt="" height="767" id="GVfMl" src="https://i-blog.csdnimg.cn/img_convert/2d8ed24c8a00d9678b8dc8e48eff6acc.png" width="755"/>
    </p>
    <p id="u22469972">
    </p>
    <h2 id="WmwJd">
     Hash哈希
    </h2>
    <p id="uc3cdb172">
     几乎所有的主流编程语言都提供了哈希（hash）类型，它们的叫法可能是哈希、字典、关联数组、映射。在 Redis 中，哈希类型是指值本身又是一个键值对结构，形如 key = "key"，value = { {field1, value1 }, ..., {fieldN, valueN } }
    </p>
    <p id="ub09cba06">
     字符串和哈希类型对比
    </p>
    <p class="img-center">
     <img alt="" height="433" id="Zs660" src="https://i-blog.csdnimg.cn/img_convert/3ef11294d00aee1db97788112e6a3925.png" width="728"/>
    </p>
    <p id="ud60e28a4">
     哈希类型中的映射关系通常称为 field-value，用于区分 Redis 整体的键值对（key-value），注意这里的 value 是指 field 对应的值，不是键（key）对应的值，请注意 value 在不同上下文的作用。
    </p>
    <h3 id="JyyBn">
     命令
    </h3>
    <h4 id="q4AGQ">
     HSET/HGET
    </h4>
    <pre id="DhZC7"><code>HSET key field value [field value ...]
HGET key field</code></pre>
    <p id="u9612f838">
    </p>
    <p class="img-center">
     <img alt="" height="155" id="uddb8b7ce" src="https://i-blog.csdnimg.cn/img_convert/810694a5ff8a4caadfd641e61e7f7f88.png" width="668"/>
    </p>
    <h4 id="iE22q">
     HEXISTS
    </h4>
    <p id="u14310ff8">
     判断 hash 中是否有指定的字段。
    </p>
    <pre id="PaBp8"><code>HEXISTS key field</code></pre>
    <p id="uc8cc6e66">
     命令有效版本：2.0.0 之后
    </p>
    <p id="uabd67716">
     时间复杂度：O(1)
    </p>
    <p id="u903abfb1">
     返回值：1 表示存在，0 表示不存在。
    </p>
    <p id="u0924a2d0">
    </p>
    <p class="img-center">
     <img alt="" height="211" id="uc2ea47b2" src="https://i-blog.csdnimg.cn/img_convert/f8c4ac3ce0e14bc8f38e7bdd996ba22b.png" width="636"/>
    </p>
    <h4 id="n7ujr">
     HDEL
    </h4>
    <p id="ufce411f8">
     删除 hash 中指定的字段。
    </p>
    <pre id="Pw5cK"><code>HDEL key field [field ...]</code></pre>
    <p id="u5bad1542">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u74acb7e2">
     时间复杂度：删除一个元素为 O(1). 删除 N 个元素为 O(N).
    </p>
    <p id="u75b4b14b">
     返回值：本次操作删除的字段个数。
    </p>
    <p class="img-center">
     <img alt="" height="208" id="ue6821cf2" src="https://i-blog.csdnimg.cn/img_convert/fff7e7f96c5ab2efa38ffb36e7876efe.png" width="609"/>
    </p>
    <h4 id="fC9Ju">
     HKEYS
    </h4>
    <p id="ud241a034">
     获取hash中的所有字段
    </p>
    <pre id="TxhAR"><code>HKEYS key</code></pre>
    <p id="ubf037fd7">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u69325d40">
     时间复杂度：O(N), N 为 field 的个数.
    </p>
    <p id="uea866ffd">
     返回值：字段列表。
    </p>
    <p id="u14f97e86">
    </p>
    <p class="img-center">
     <img alt="" height="283" id="u362a4387" src="https://i-blog.csdnimg.cn/img_convert/8cbf55686506f0773483a0f8e58b75da.png" width="689"/>
    </p>
    <h4 id="k3U3X">
     HVALS
    </h4>
    <p id="ubf569a44">
     获取hash中所有的值
    </p>
    <pre id="SEfKT"><code>HVALS key</code></pre>
    <p id="uf3888d3b">
     命令有效版本：2.0.0 之后
    </p>
    <p id="uf4c4193d">
     时间复杂度：O(N), N 为 field 的个数.
    </p>
    <p id="ubebdfca6">
     返回值：所有的值。
    </p>
    <p class="img-center">
     <img alt="" height="119" id="udc10cae8" src="https://i-blog.csdnimg.cn/img_convert/2ca9379fcaff333cc94ce50f844014e7.png" width="686"/>
    </p>
    <h4 id="h7C3D">
     HGETALL
    </h4>
    <p id="u332f98cf">
     获取hash中所有字段以及对应的值
    </p>
    <pre id="Dj4Yb"><code>HGETALL key</code></pre>
    <p id="u671b609e">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u882bf52b">
     时间复杂度：O(N), N 为 field 的个数.
    </p>
    <p id="u21388417">
     返回值：字段和对应的值。
    </p>
    <p class="img-center">
     <img alt="" height="181" id="u0d4d822e" src="https://i-blog.csdnimg.cn/img_convert/c8bfaf2d472b7a657c573d5e33891f7b.png" width="706"/>
    </p>
    <h4 id="Su0fh">
     HMGET
    </h4>
    <p id="uf502e015">
     一次获取hash中多个字段
    </p>
    <pre id="mwQLt"><code>HMGET key field [field ...]</code></pre>
    <p id="u4f4fa033">
     命令有效版本：2.0.0 之后
    </p>
    <p id="uc4546cda">
     时间复杂度：只查询一个元素为 O(1), 查询多个元素为 O(N), N 为查询元素个数.
    </p>
    <p id="u352fe84b">
     返回值：字段对应的值或者 nil。
    </p>
    <p id="ue4e76bdb">
    </p>
    <p class="img-center">
     <img alt="" height="336" id="ua8b9623d" src="https://i-blog.csdnimg.cn/img_convert/bfcb79977d24a7b77ef231dcf1ad02b0.png" width="689"/>
    </p>
    <p id="u01c95a97">
     在使用 HGETALL 时，如果哈希元素个数比较多，会存在阻塞 Redis 的可能。如果开发人员只需要获取部分 field，可以使用 HMGET，如果一定要获取全部 field，可以尝试使用 HSCAN命令，该命令采用渐进式遍历哈希类型
    </p>
    <h4 id="KmLlV">
     HLEN
    </h4>
    <p id="u61081173">
     获取hash中所有字段的个数
    </p>
    <pre id="mXEm7"><code>HLEN key</code></pre>
    <p id="ua5beadb7">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u90495bc4">
     时间复杂度：O(1)
    </p>
    <p id="ufe9e9a9c">
     返回值：字段个数。
    </p>
    <p class="img-center">
     <img alt="" height="72" id="ub7239411" src="https://i-blog.csdnimg.cn/img_convert/49af0fc893b42dd9785d5797fc84cd52.png" width="630"/>
    </p>
    <h4 id="EMARU">
     HSETNX
    </h4>
    <p id="u73f5bcce">
     在字段不存在的情况下，设置 hash 中的字段和值。
    </p>
    <pre id="yrGVI"><code>HSETNX key field value</code></pre>
    <p id="u89adc2f8">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u4c89f534">
     时间复杂度：O(1)
    </p>
    <p id="u1df5c882">
     返回值：1 表示设置成功，0 表示失败。
    </p>
    <p id="u885e717c">
    </p>
    <p class="img-center">
     <img alt="" height="146" id="u1f520e87" src="https://i-blog.csdnimg.cn/img_convert/4abefc849666679277d9463959aa9c2b.png" width="704"/>
    </p>
    <h4 id="QFalp">
     HINCRBY
    </h4>
    <p id="u02949a5d">
     将 hash 中字段对应的数值添加指定的值。
    </p>
    <pre id="nNj5h"><code>HINCRBY key field increment</code></pre>
    <p id="u997a5945">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u946754d0">
     时间复杂度：O(1)
    </p>
    <p id="u52e0048e">
     返回值：该字段变化之后的值。
    </p>
    <p id="ud578e926">
    </p>
    <p class="img-center">
     <img alt="" height="184" id="u7cc0a34f" src="https://i-blog.csdnimg.cn/img_convert/5b25ba28331774e8366d38c83fbc0ce0.png" width="648"/>
    </p>
    <h4 id="XStLE">
     HINCRBYFLOAT
    </h4>
    <p id="u24cf16ff">
     HINCRBY 的浮点数版本。
    </p>
    <pre id="Gz1va"><code>HINCRBYFLOAT key field increment</code></pre>
    <p id="ud848cf86">
     命令有效版本：2.6.0 之后
    </p>
    <p id="u8961e810">
     时间复杂度：O(1)
    </p>
    <p id="ufdf6be04">
     返回值：该字段变化之后的值。
    </p>
    <p class="img-center">
     <img alt="" height="126" id="u5e4ff73c" src="https://i-blog.csdnimg.cn/img_convert/2b06fb9a669270a65b7268b8251c7845.png" width="610"/>
    </p>
    <h3 id="Pt8zV">
     内部编码
    </h3>
    <p id="ud8d36cfe">
     哈希的内部编码有两种：
    </p>
    <p id="u6ee915a7">
     • ziplist（压缩列表）：当哈希类型元素个数小于 hash-max-ziplist-entries 配置（默认 512 个）、同时所有值都小于 hash-max-ziplist-value 配置（默认 64 字节）时，Redis 会使用 ziplist 作为哈希的内部实现，ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable 更加优秀。
    </p>
    <p id="uad0a512e">
     • hashtable（哈希表）：当哈希类型无法满足 ziplist 的条件时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为 O(1)。
    </p>
    <ol>
     <li id="u3c3b0ba0">
      当 field 个数比较少且没有大的 value 时，内部编码为 ziplist：
     </li>
    </ol>
    <pre id="T2tiw"><code>127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2
OK
127.0.0.1:6379&gt; object encoding hashkey
"ziplist"</code></pre>
    <ol>
     <li id="u561f0c4f">
      当有 value 大于 64 字节时，内部编码会转换为 hashtable：
     </li>
    </ol>
    <pre id="JKKvH"><code>127.0.0.1:6379&gt; hset hashkey f3 "one string is bigger than 64 bytes ... 省略..."
OK
127.0.0.1:6379&gt; object encoding hashkey
"hashtable"</code></pre>
    <ol>
     <li id="ud6f5a913">
      当 field 个数超过 512 时，内部编码也会转换为 hashtable：
     </li>
    </ol>
    <pre id="rrhx3"><code>127.0.0.1:6379&gt; hmset hashkey f1 v1 h2 v2 f3 v3 ... 省略 ... f513 v513
OK
127.0.0.1:6379&gt; object encoding hashkey
"hashtable"</code></pre>
    <h3 id="iTyaU">
     使用场景
    </h3>
    <p id="u0fca002f">
     为关系型数据表记录的两条用户信息，用户的属性表现为表的列，每条用户信息表现为行。如果映射关系表示这两个用户信息
    </p>
    <p id="u97978315">
     关系型数据表保存用户信息
    </p>
    <p class="img-center">
     <img alt="" height="191" id="u6e0c8c10" src="https://i-blog.csdnimg.cn/img_convert/4c42fbfd3638dbd229cdcdb22487775d.png" width="729"/>
    </p>
    <p id="u97978315">
     映射关系表示用户信息
    </p>
    <p class="img-center">
     <img alt="" height="395" id="u466abf5f" src="https://i-blog.csdnimg.cn/img_convert/be9a613142c975638559e653eef53fa7.png" width="725"/>
    </p>
    <p id="u97978315">
     相比于使用 JSON 格式的字符串缓存用户信息，哈希类型变得更加直观，并且在更新操作上变得更灵活。可以将每个用户的 id 定义为键后缀，多对 field-value 对应用户的各个属性，类似如下伪代码：
    </p>
    <pre id="iVM9t"><code>UserInfo getUserInfo(long uid) {
    // 根据 uid 得到 Redis 的键
    String key = "user:" + uid;
    // 尝试从 Redis 中获取对应的值
    userInfoMap = Redis 执行命令：hgetall key;
    // 如果缓存命中（hit）
    if (value != null) {
        // 将映射关系还原为对象形式
        UserInfo userInfo = 利用映射关系构建对象(userInfoMap);
        return userInfo;
    }
    // 如果缓存未命中（miss）
    // 从数据库中，根据 uid 获取用户信息
    UserInfo userInfo = MySQL 执行 SQL：select * from user_info where uid = &lt;uid&gt;
    // 如果表中没有 uid 对应的用户信息
    if (userInfo == null) {
        响应 404
        return null;
    }
    // 将缓存以哈希类型保存
    Redis 执行命令：hmset key name userInfo.name age userInfo.age city
    userInfo.city
    // 写入缓存，为了防止数据腐烂（rot），设置过期时间为 1 小时（3600 秒）
    Redis 执行命令：expire key 3600
    // 返回用户信息
    return userInfo;
}</code></pre>
    <p id="u9b324968">
     但是需要注意的是哈希类型和关系型数据库有两点不同之处：
    </p>
    <p id="u709b5dc4">
     • 哈希类型是稀疏的，而关系型数据库是完全结构化的，例如哈希类型每个键可以有不同的 field，而关系型数据库一旦添加新的列，所有行都要为其设置值，即使为 null，如图 2-18 所示。
    </p>
    <p id="u97c977f0">
     • 关系数据库可以做复杂的关系查询，而 Redis 去模拟关系型复杂查询，例如联表查询、聚合查询等基本不可能，维护成本高。
    </p>
    <h2 id="ah6JF">
     List列表
    </h2>
    <p id="u46220256">
     列表类型是用来存储多个有序的字符串，a、b、c、d、e 五个元素从左到右组成了一个有序的列表，列表中的每个字符串称为元素（element），一个列表最多可以存储 个元素。在 Redis 中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。
    </p>
    <p id="u0ad45b94">
    </p>
    <p class="img-center">
     <img alt="" height="310" id="u76ffc29a" src="https://i-blog.csdnimg.cn/img_convert/7a0f6061b09ecf7dd1e86ccccf8c620e.png" width="728"/>
    </p>
    <p class="img-center">
     <img alt="" height="331" id="uabeb12fb" src="https://i-blog.csdnimg.cn/img_convert/1ff08b2e3502b8bd6b4446d298b03ffe.png" width="731"/>
    </p>
    <h3 id="F3RnZ">
     命令
    </h3>
    <h4 id="pVQj4">
     LPUSH/RPUSH
    </h4>
    <p id="uecf03e5c">
     将一个或者多个元素从左侧放入（头插）到 list 中。
    </p>
    <pre id="KeHol"><code>LPUSH key element [element ...]
RPUSH key element [element ...]</code></pre>
    <p id="u5f40fee0">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u63b2d937">
     时间复杂度：只插入一个元素为 O(1), 插入多个元素为 O(N), N 为插入元素个数.
    </p>
    <p id="u79cd53a9">
     返回值：插入后 list 的长度。
    </p>
    <p class="img-center">
     <img alt="" height="165" id="u14261bed" src="https://i-blog.csdnimg.cn/img_convert/90cd616a864b36594ac89d08b5f18124.png" width="709"/>
    </p>
    <h4 id="NgWQd">
     LPUSHX/RPUSHX
    </h4>
    <p id="u5700f31f">
     在 key 存在时，将一个或者多个元素从左/右侧侧放入（头/尾插）到 list 中。不存在，直接返回
    </p>
    <pre id="pQCNa"><code>LPUSHX key element [element ...]
RPUSHX key element [element ...]</code></pre>
    <p id="u16fb8cfa">
     命令有效版本：2.0.0 之后
    </p>
    <p id="ufa7e69bc">
     时间复杂度：只插入一个元素为 O(1), 插入多个元素为 O(N), N 为插入元素个数.
    </p>
    <p id="u0c9d2594">
     返回值：插入后 list 的长度。
    </p>
    <p class="img-center">
     <img alt="" height="333" id="u3e9b5fe8" src="https://i-blog.csdnimg.cn/img_convert/8fa6617bd82eba5d98e51bcaff466f26.png" width="708"/>
    </p>
    <h4 id="K0Y2K">
     LRANGE
    </h4>
    <p id="u92b28c53">
     获取从 start 到 end 区间的所有元素，左闭右闭。
    </p>
    <pre id="naQc9"><code>LRANGE key start stop</code></pre>
    <p id="u083061f6">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ufdd2b7ea">
     时间复杂度：O(N)
    </p>
    <p id="u9cc40e62">
     返回值：指定区间的元素。
    </p>
    <p id="u9389f6c7">
    </p>
    <p class="img-center">
     <img alt="" height="278" id="uc56146f9" src="https://i-blog.csdnimg.cn/img_convert/7b156a0a655968e66cbbe7e588a904a3.png" width="708"/>
    </p>
    <h4 id="tCp25">
     L/RPOP
    </h4>
    <p id="ua117a2d8">
     从 list 左/右侧取出元素（即头/尾删）。
    </p>
    <pre id="qdvRk"><code>LPOP key
RPOP key</code></pre>
    <p id="u026801b8">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u8ac2c613">
     时间复杂度：O(1)
    </p>
    <p id="ue8d41eca">
     返回值：取出的元素或者 nil
    </p>
    <p class="img-center">
     <img alt="" height="240" id="u10375003" src="https://i-blog.csdnimg.cn/img_convert/0a254ef3b02e4a3610aa733065beb9ab.png" width="727"/>
    </p>
    <h4 id="vW1Ks">
     LINDEX
    </h4>
    <p id="u1309c0dd">
     获取从左数第 index 位置的元素。
    </p>
    <pre id="H61BG"><code>LINDEX key index</code></pre>
    <p id="u666439fc">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ua96898ad">
     时间复杂度：O(N)
    </p>
    <p id="ufdeb48d4">
     返回值：取出的元素或者 nil。
    </p>
    <p id="ue5f472da">
    </p>
    <p class="img-center">
     <img alt="" height="152" id="u044fae45" src="https://i-blog.csdnimg.cn/img_convert/2c3e0699e765f8bfe2a4910c91f1e854.png" width="637"/>
    </p>
    <h4 id="tUohg">
     LINSERT
    </h4>
    <p id="u88d81d15">
     在特定位置插入元素。
    </p>
    <pre id="Xbvgy"><code>LINSERT key &lt;BEFORE | AFTER&gt; 1 pivot element</code></pre>
    <p id="ud0334815">
     命令有效版本：2.2.0 之后
    </p>
    <p id="ufecbff7b">
     时间复杂度：O(N)
    </p>
    <p id="udc785cfa">
     返回值：插入后的 list 长度。
    </p>
    <p id="u295c04c5">
    </p>
    <p class="img-center">
     <img alt="" height="412" id="u39c2f244" src="https://i-blog.csdnimg.cn/img_convert/0020ed84e6ec9c5e389ba0900b9c8a7e.png" width="730"/>
    </p>
    <h4 id="UnBSe">
     LLEN
    </h4>
    <p id="u87a07ca6">
     获取 list 长度。
    </p>
    <pre id="FAsRb"><code>LLEN key</code></pre>
    <p id="u6e5848b2">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u8e47a5b0">
     时间复杂度：O(1)
    </p>
    <p id="u6be69ea5">
     返回值：list 的长度。
    </p>
    <p class="img-center">
     <img alt="" height="187" id="uf1e8538b" src="https://i-blog.csdnimg.cn/img_convert/9353701171d30be1b5d9dc8bede2d3ee.png" width="662"/>
    </p>
    <h4 id="fRjeL">
     阻塞版本命令
    </h4>
    <p id="u8f996cb3">
     blpop 和 brpop 是 lpop 和 rpop 的阻塞版本，和对应非阻塞版本的作用基本一致，除了：
    </p>
    <p id="u9d4d72c7">
     • 在列表中有元素的情况下，阻塞和非阻塞表现是一致的。但如果列表中没有元素，非阻塞版本会理解返回 nil，但阻塞版本会根据 timeout，阻塞一段时间，期间 Redis 可以执行其他命令，但要求执行该命令的客户端会表现为阻塞状态（如图 2-22 所示）。
    </p>
    <p id="ue280c51d">
     • 命令中如果设置了多个键，那么会从左向右进行遍历键，一旦有一个键对应的列表中可以弹出元素，命令立即返回。
    </p>
    <p id="u3cbf03cc">
     • 如果多个客户端同时多一个键执行 pop，则最先执行命令的客户端会得到弹出的元素。
    </p>
    <p id="u92c559b5">
     阻塞版本的 blpop 和 非阻塞版本 lpop 的区别
    </p>
    <p class="img-center">
     <img alt="" height="302" id="ucc0e977e" src="https://i-blog.csdnimg.cn/img_convert/b934726fd1605cb2da3ed9900ee4b5bf.png" width="711"/>
    </p>
    <p class="img-center">
     <img alt="" height="562" id="u30f2e7ab" src="https://i-blog.csdnimg.cn/img_convert/00203e90dc82a61dea776ab8d53d9cc2.png" width="705"/>
    </p>
    <p id="u92c559b5">
    </p>
    <p class="img-center">
     <img alt="" height="604" id="uec11b6d5" src="https://i-blog.csdnimg.cn/img_convert/0e9e21a7645447e75a34e42d24ef8faf.png" width="711"/>
    </p>
    <h4 id="LuRYY">
     列表命令小结
    </h4>
    <p id="ue7468433">
    </p>
    <p class="img-center">
     <img alt="" height="555" id="ue10d3052" src="https://i-blog.csdnimg.cn/img_convert/f672b91eb0de98cb45d879ba0b792b6d.png" width="715"/>
    </p>
    <h3 id="r3PO0">
     内部编码
    </h3>
    <p id="u9836e099">
     列表类型的内部编码有两种：
    </p>
    <p id="u7303db9c">
     • ziplist（压缩列表）：当列表的元素个数小于 list-max-ziplist-entries 配置（默认 512 个），同时列表中每个元素的长度都小于 list-max-ziplist-value 配置（默认 64 字节）时，Redis 会选用ziplist 来作为列表的内部编码实现来减少内存消耗。
    </p>
    <p id="u5d7b2196">
     • linkedlist（链表）：当列表类型无法满足 ziplist 的条件时，Redis 会使用 linkedlist 作为列表的内部实现。
    </p>
    <ol>
     <li id="u80c5a302">
      当元素个数较少且没有大元素时，内部编码为 ziplist：
     </li>
    </ol>
    <pre id="boRj7"><code>127.0.0.1:6379&gt; rpush listkey e1 e2 e3
OK
127.0.0.1:6379&gt; object encoding listkey
"ziplist"</code></pre>
    <ol>
     <li id="ucc824318">
      当元素个数超过 512 时，内部编码为 linkedlist：
     </li>
    </ol>
    <pre id="ecKdl"><code>127.0.0.1:6379&gt; rpush listkey e1 e2 e3 ... 省略 e512 e513
OK
127.0.0.1:6379&gt; object encoding listkey
"linkedlist"</code></pre>
    <ol>
     <li id="u7bdab30b">
      当某个元素的长度超过 64 字节时，内部编码为 linkedlist
     </li>
    </ol>
    <pre id="gzNj9"><code>127.0.0.1:6379&gt; rpush listkey "one string is bigger than 64 bytes ... 省略 ..."
OK
127.0.0.1:6379&gt; object encoding listkey
"linkedlist"</code></pre>
    <h3 id="n0v2h">
     使用场景
    </h3>
    <p id="ue0ca0250">
     消息队列
    </p>
    <p id="u03440eaa">
     Redis 可以使用 lpush + brpop 命令组合实现经典的阻塞式生产者-消费者模型队列，生产者客户端使用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式地从队列中"争抢" 队首元素。通过多个客户端来保证消费的负载均衡和高可用性。
    </p>
    <p id="u5df804dd">
     Redis 阻塞消息队列模型
    </p>
    <p class="img-center">
     <img alt="" height="270" id="u5901c691" src="https://i-blog.csdnimg.cn/img_convert/4ce72abc5a6e58e0b1988e13e0097af5.png" width="725"/>
    </p>
    <hr id="Ll4H3"/>
    <p id="u185844ad">
     分频道的消息队列
    </p>
    <p id="u97a835e2">
     Redis 同样使用 lpush + brpop 命令，但通过不同的键模拟频道的概念，不同的消费者可以通过 brpop 不同的键值，实现订阅不同频道的理念。
    </p>
    <p id="uf5f84c80">
    </p>
    <p class="img-center">
     <img alt="" height="495" id="ucb3c0a5b" src="https://i-blog.csdnimg.cn/img_convert/4e32570b5801caf16a6edde7387dc4a5.png" width="728"/>
    </p>
    <hr id="Sdn8P"/>
    <p id="uf5a7d038">
     微博 Timeline
    </p>
    <p id="ub13cf8ec">
     每个用户都有属于自己的 Timeline（微博列表），现需要分页展示文章列表。此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。
    </p>
    <ol>
     <li id="uec1ce3e8">
      每篇微博使用哈希结构存储，例如微博中 3 个属性：title、timestamp、content：
     </li>
    </ol>
    <pre id="NhZgT"><code>hmset mblog:1 title xx timestamp 1476536196 content xxxxx
...
hmset mblog:n title xx timestamp 1476536196 content xxxxx</code></pre>
    <ol>
     <li id="u16269e05">
      向用户 Timeline 添加微博，user:&lt;uid&gt;:mblogs 作为微博的键：
     </li>
    </ol>
    <pre id="wsNKV"><code>lpush user:1:mblogs mblog:1 mblog:3
...
lpush user:k:mblogs mblog:9</code></pre>
    <ol>
     <li id="u7ed43c03">
      分页获取用户的 Timeline，例如获取用户的前 10 篇微博：
     </li>
    </ol>
    <pre id="nf5Wn"><code>keylist = lrange user:1:mblogs 0 9
for key in keylist {
    hgetall key
}</code></pre>
    <h2 id="ztflH">
     Set集合
    </h2>
    <p id="ueb02d8d9">
     集合类型也是保存多个字符串类型的元素的，但和列表类型不同的是，集合中 元素之间是无序的，元素不允许重复，。一个集合中最多可以存储 个元素。Redis 除了支持集合内的增删查改操作，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多问题。
    </p>
    <p id="u31af47bc">
     集合类型
    </p>
    <p id="ubc405f52">
    </p>
    <p class="img-center">
     <img alt="" height="267" id="ub78a2753" src="https://i-blog.csdnimg.cn/img_convert/2aaf1bf1afb8d2a215500b096d6fd84a.png" width="730"/>
    </p>
    <h3 id="CI6DE">
     普通命令
    </h3>
    <h4 id="Vykkc">
     SADD
    </h4>
    <p id="ub05eb727">
     将一个或者多个元素添加到 set 中。注意，重复的元素无法添加到 set 中。
    </p>
    <pre id="xwdqF"><code>SADD key member [member ...]</code></pre>
    <p id="ucdee7ba5">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u5e978b34">
     时间复杂度：O(1)
    </p>
    <p id="ucea0785f">
     返回值：本次添加成功的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="151" id="u7abf11a4" src="https://i-blog.csdnimg.cn/img_convert/652ce485a3592c7fc214bd4e6cd7d053.png" width="696"/>
    </p>
    <h4 id="PYoNH">
     SMEMBERS
    </h4>
    <p id="u48d2007b">
     获取一个 set 中的所有元素，注意，元素间的顺序是无序的。
    </p>
    <pre id="GriLE"><code>SMEMBERS key</code></pre>
    <p id="ud864426f">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ub02908ec">
     时间复杂度：O(N)
    </p>
    <p id="u0fda8662">
     返回值：所有元素的列表。
    </p>
    <p class="img-center">
     <img alt="" height="270" id="u5b2dd2b6" src="https://i-blog.csdnimg.cn/img_convert/998e2e54f1014414fa6a2d0a797c7526.png" width="706"/>
    </p>
    <h4 id="fcOkB">
     SCARD
    </h4>
    <p id="ua807b513">
     获取一个 set 的基数（cardinality），即 set 中的元素个数。
    </p>
    <pre id="e1kRN"><code>SCARD key</code></pre>
    <p id="u38358a62">
     命令有效版本：1.0.0 之后
    </p>
    <p id="uef8a82f9">
     时间复杂度：O(1)
    </p>
    <p id="u4d211f94">
     返回值：set 内的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="315" id="u442ff0e2" src="https://i-blog.csdnimg.cn/img_convert/a8e8633661859c00ea5039dc4f4a6d7c.png" width="729"/>
    </p>
    <h4 id="uptUv">
     SPOP
    </h4>
    <p id="uc7aff54c">
     从 set 中删除并返回一个或者多个元素。注意，由于 set 内的元素是无序的，所以取出哪个元素实际是未定义行为，即可以看作随机的。
    </p>
    <pre id="wColH"><code>SPOP key [count]</code></pre>
    <p id="ue2fd46b0">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u2d0ef2fe">
     时间复杂度：O(N), n 是 count
    </p>
    <p id="ubea9214e">
     返回值：取出的元素。
    </p>
    <p class="img-center">
     <img alt="" height="232" id="u9cf7e51c" src="https://i-blog.csdnimg.cn/img_convert/6abc98335c23f8723659579bc8bec305.png" width="730"/>
    </p>
    <h4 id="h956D">
     SMOVE
    </h4>
    <p id="u8afb5c55">
     将一个元素从源 set 取出并放入目标 set 中。
    </p>
    <pre id="uYLtL"><code>SMOVE source destination member</code></pre>
    <p id="uc038d9c6">
     命令有效版本：1.0.0 之后
    </p>
    <p id="ue721b6d7">
     时间复杂度：O(1)
    </p>
    <p id="ufdcd05d7">
     返回值：1 表示移动成功，0 表示失败。
    </p>
    <p class="img-center">
     <img alt="" height="301" id="u0de007b0" src="https://i-blog.csdnimg.cn/img_convert/df94e758fd373ec2f64ca31ccea83cc7.png" width="662"/>
    </p>
    <h4 id="FjQsv">
     SREM
    </h4>
    <p id="ud61dc525">
     将指定的元素从 set 中删除。
    </p>
    <pre id="uM1jP"><code>SREM key member [member ...]</code></pre>
    <p id="u632ecbe0">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u46da6a58">
     时间复杂度：O(N), N 是要删除的元素个数.
    </p>
    <p id="ue67883ba">
     返回值：本次操作删除的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="406" id="u2b472a3d" src="https://i-blog.csdnimg.cn/img_convert/35a527cbfeea4261558069c8af15329d.png" width="690"/>
    </p>
    <h3 id="SURsb">
     集合间的操作
    </h3>
    <p id="u54003b8e">
     交集（inter）、并集（union）、差集（diff）
    </p>
    <p class="img-center">
     <img alt="" height="579" id="u7567364c" src="https://i-blog.csdnimg.cn/img_convert/b3e8e93b073a5390f92d323de2975d2e.png" width="731"/>
    </p>
    <h4 id="CzbKQ">
     SINTER
    </h4>
    <p id="ud5226b94">
     获取给定 set 的交集中的元素。
    </p>
    <pre id="WmhGu"><code>SINTER key [key ...]</code></pre>
    <p id="u9c4b4168">
     命令有效版本：1.0.0 之后
    </p>
    <p id="uad54739d">
     时间复杂度：O(N * M), N 是最小的集合元素个数. M 是最大的集合元素个数.
    </p>
    <p id="udc431590">
     返回值：交集的元素。
    </p>
    <p class="img-center">
     <img alt="" height="229" id="u5ccaf152" src="https://i-blog.csdnimg.cn/img_convert/1d8a6bf64baa862782fdd30fe2f03dfb.png" width="674"/>
    </p>
    <h4 id="kDUUW">
     SINTERSTORE
    </h4>
    <p id="u09fcbf1f">
     获取给定 set 的交集中的元素并保存到目标 set 中。
    </p>
    <pre id="o6KtP"><code>SINTERSTORE destination key [key ...]</code></pre>
    <p id="u29a761d2">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u5d8b9255">
     时间复杂度：O(N * M), N 是最小的集合元素个数. M 是最大的集合元素个数.
    </p>
    <p id="uc405b936">
     返回值：交集的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="316" id="uf763fd18" src="https://i-blog.csdnimg.cn/img_convert/4078e79597eb6165381f1d894a3536d3.png" width="729"/>
    </p>
    <h4 id="ctlvm">
     SUNION
    </h4>
    <p id="ubfb98bf9">
     获取给定 set 的并集中的元素。
    </p>
    <pre id="UaH6L"><code>SUNION key [key ...]</code></pre>
    <p id="ua9776004">
     命令有效版本：1.0.0 之后
    </p>
    <p id="uadeb36c9">
     时间复杂度：O(N), N 给定的所有集合的总的元素个数.
    </p>
    <p id="uf60e95a7">
     返回值：并集的元素。
    </p>
    <p id="u19f9b03a">
    </p>
    <p class="img-center">
     <img alt="" height="455" id="u4d5eeffb" src="https://i-blog.csdnimg.cn/img_convert/58f62d24cb7144b52f11b6b7f4f30c99.png" width="710"/>
    </p>
    <h4 id="VzRED">
     SUNIONSTORE
    </h4>
    <p id="u8da1c216">
     获取给定 set 的并集中的元素并保存到目标 set 中。
    </p>
    <pre id="cgsOB"><code>SUNIONSTORE destination key [key ...]</code></pre>
    <p id="u1a0bee09">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u5ccf8507">
     时间复杂度：O(N), N 给定的所有集合的总的元素个数.
    </p>
    <p id="uebdc9c94">
     返回值：并集的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="212" id="u5429a9d0" src="https://i-blog.csdnimg.cn/img_convert/cd9ce2ccb96e75530c01a189a69934cc.png" width="724"/>
    </p>
    <h4 id="v9U2X">
     SDIFF
    </h4>
    <p id="u98ae2997">
     获取给定 set 的差集中的元素。
    </p>
    <pre id="pjgv8"><code>SDIFF key [key ...]</code></pre>
    <p id="u5dedb7be">
     命令有效版本：1.0.0 之后
    </p>
    <p id="u9ca46992">
     时间复杂度：O(N), N 给定的所有集合的总的元素个数.
    </p>
    <p id="ucff94bc2">
     返回值：差集的元素。
    </p>
    <p class="img-center">
     <img alt="" height="263" id="u6bb18ad2" src="https://i-blog.csdnimg.cn/img_convert/f20302019ab0df94a49e18d86dc29071.png" width="634"/>
    </p>
    <h4 id="Klr4u">
     SDIFFSTORE
    </h4>
    <p id="u26ad711c">
     获取给定 set 的差集中的元素并保存到目标 set 中。
    </p>
    <pre id="Cs6uk"><code>SDIFFSTORE destination key [key ...]</code></pre>
    <p id="u1dbebaf2">
     命令有效版本：1.0.0 之后
    </p>
    <p id="uafb55909">
     时间复杂度：O(N), N 给定的所有集合的总的元素个数.
    </p>
    <p id="ub48d3c00">
     返回值：差集的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="372" id="uc3c30c8e" src="https://i-blog.csdnimg.cn/img_convert/848f172fa607a15378eaea782909080b.png" width="729"/>
    </p>
    <h4 id="gVQit">
     集合命令小结
    </h4>
    <p id="u317dc4bf">
    </p>
    <p class="img-center">
     <img alt="" height="472" id="ue42f84ee" src="https://i-blog.csdnimg.cn/img_convert/d0486b6ac51577f745a72423235d6642.png" width="716"/>
    </p>
    <h3 id="ZhDpA">
     内部编码
    </h3>
    <p id="u17d99ed8">
     • intset（整数集合）：当集合中的元素都是整数并且元素的个数小于 set-max-intset-entries 配置（默认 512 个）时，Redis 会选用 intset 来作为集合的内部实现，从而减少内存的使用。
    </p>
    <p id="u01589fde">
     • hashtable（哈希表）：当集合类型无法满足 intset 的条件时，Redis 会使用 hashtable 作为集合的内部实现。
    </p>
    <ol>
     <li id="u04897aeb">
      当元素个数较少并且都为整数时，内部编码为 intset：
     </li>
    </ol>
    <pre id="f0HIR"><code>127.0.0.1:6379&gt; sadd setkey 1 2 3 4
(integer) 4
127.0.0.1:6379&gt; object encoding setkey
"intset"</code></pre>
    <ol>
     <li id="u7e491be1">
      当元素个数超过 512 个，内部编码为 hashtable：
     </li>
    </ol>
    <pre id="DyW21"><code>127.0.0.1:6379&gt; sadd setkey 1 2 3 4
(integer) 513
127.0.0.1:6379&gt; object encoding setkey
"hashtable"</code></pre>
    <ol>
     <li id="ue115611c">
      当存在元素不是整数时，内部编码为 hashtable：
     </li>
    </ol>
    <pre id="VQFxe"><code>127.0.0.1:6379&gt; sadd setkey a
(integer) 1
127.0.0.1:6379&gt; object encoding setkey
"hashtable"</code></pre>
    <h3 id="SqWk9">
     使用场景
    </h3>
    <p id="u6a442128">
     集合类型比较典型的使用场景是标签（tag）。例如 A 用户对娱乐、体育板块比较感兴趣，B 用户对历史、新闻比较感兴趣，这些兴趣点可以被抽象为标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于增强用户体验和用户黏度都非常有帮助。 例如一个电子商务网站会对不同标签的用户做不同的产品推荐。
    </p>
    <p id="u390a914e">
     下面的演示通过集合类型来实现标签的若干功能。
    </p>
    <ol>
     <li id="uae5e8a1d">
      给用户添加标签
     </li>
    </ol>
    <pre id="GIitH"><code>sadd user:1:tags tag1 tag2 tag5
sadd user:2:tags tag2 tag3 tag5
...
sadd user:k:tags tag1 tag2 tag4</code></pre>
    <ol>
     <li id="ua0420904">
      给标签添加用户
     </li>
    </ol>
    <pre id="RmypK"><code>sadd tag1:users user:1 user:3
sadd tag2:users user:1 user:2 user:3
...
sadd tagk:users user:1 user:4 user:9 user:28</code></pre>
    <ol>
     <li id="udf72f7b1">
      删除用户下的标签
     </li>
    </ol>
    <pre id="vPa2H"><code>srem user:1:tags tag1 tag5
...</code></pre>
    <ol>
     <li id="u9b3013fb">
      删除标签下的用户
     </li>
    </ol>
    <pre id="JFutt"><code>srem tag1:users user:1
srem tag5:users user:1
...</code></pre>
    <ol>
     <li id="ub8f85a7c">
      计算用户的共同兴趣标签
     </li>
    </ol>
    <pre id="BKGFM"><code>sinter user:1 1:tags user:2:tags</code></pre>
    <h2 id="ZKW2x">
     Zset有序集合
    </h2>
    <p id="u0287134f">
     有序集合相对于字符串、列表、哈希、集合来说会有一些陌生。它保留了集合不能有重复成员的特点，但与集合不同的是，有序集合中的每个元素都有一个唯一的浮点类型的分数（score）与之关联，着使得有序集合中的元素是可以维护有序性的，但这个有序不是用下标作为排序依据而是用这个分数。
    </p>
    <p class="img-center">
     <img alt="" height="458" id="u53098e3f" src="https://i-blog.csdnimg.cn/img_convert/5d11b0d799b6fe211dbaa7feddb4db8b.png" width="729"/>
    </p>
    <p id="u0287134f">
     有序集合提供了获取指定分数和元素范围查找、计算成员排名等功能，合理地利用有序集合，可以帮助我们在实际开发中解决很多问题。
    </p>
    <p id="uba2d23a3">
     有序集合中的元素是不能重复的，但分数允许重复。类比于一次考试之后，每个人一定有一个唯一的分数，但分数允许相同。
    </p>
    <p id="u1091a66b">
    </p>
    <p class="img-center">
     <img alt="" height="208" id="u2c546814" src="https://i-blog.csdnimg.cn/img_convert/778c07645ae8367f4164b3ae5c9a2b86.png" width="709"/>
    </p>
    <h3 id="fDFND">
     普通命令
    </h3>
    <h4 id="dDFA9">
     ZADD
    </h4>
    <p id="u20fb7993">
     添加或者更新指定的元素以及关联的分数到 zset 中，分数应该符合 double 类型，+inf/-inf 作为正负极限也是合法的。
    </p>
    <p id="u7411810a">
     ZADD 的相关选项：
    </p>
    <p id="u3a87020b">
     • XX：仅仅用于更新已经存在的元素，不会添加新元素。
    </p>
    <p id="ufccfedab">
     • NX：仅用于添加新元素，不会更新已经存在的元素。
    </p>
    <p id="u602542d3">
     • CH：默认情况下，ZADD 返回的是本次添加的元素个数，但指定这个选项之后，就会还包含本次更新的元素的个数。
    </p>
    <p id="u5076134b">
     • INCR：此时命令类似 ZINCRBY 的效果，将元素的分数加上指定的分数。此时只能指定一个元素和分数。
    </p>
    <pre id="BS25E"><code>ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]</code></pre>
    <p id="ubc549333">
     命令有效版本：1.2.0 之后
    </p>
    <p id="u40aea69b">
     时间复杂度：O(log(N))
    </p>
    <p id="uf8bf3f3a">
     返回值：本次添加成功的元素个数。
    </p>
    <h4 id="UOCQG">
     ZCARD
    </h4>
    <p id="ub7040eed">
     获取一个 zset 的基数（cardinality），即 zset 中的元素个数。
    </p>
    <pre id="fYOYg"><code>ZCARD key</code></pre>
    <p id="u3f1744c6">
     命令有效版本：1.2.0 之后
    </p>
    <p id="ua8f742fa">
     时间复杂度：O(1)
    </p>
    <p id="u1978c7d6">
     返回值：zset 内的元素个数。
    </p>
    <p id="u4873c614">
    </p>
    <p class="img-center">
     <img alt="" height="154" id="uf88bdb6f" src="https://i-blog.csdnimg.cn/img_convert/463c6c491e912701a8cba4d2465b49a8.png" width="704"/>
    </p>
    <h4 id="nP11z">
     ZCOUNT
    </h4>
    <p id="u0f835719">
     返回分数在 min 和 max 之间的元素个数。默认情况下，min 和 max 都是包含的，可以通过 ( 排除。
    </p>
    <pre id="Ev86i"><code>ZCOUNT key min max</code></pre>
    <p id="u1b5950cd">
     命令有效版本：2.0.0 之后
    </p>
    <p id="uc36e5fb5">
     时间复杂度：O(log(N))
    </p>
    <p id="u96896a34">
     返回值：满足条件的元素列表个数。
    </p>
    <p class="img-center">
     <img alt="" height="350" id="u7507a4be" src="https://i-blog.csdnimg.cn/img_convert/6ebf2e94070a01d67ee55e0aed81f9ca.png" width="727"/>
    </p>
    <h4 id="q2S49">
     ZRANGE
    </h4>
    <p id="u1bb3aad9">
     返回指定区间里的元素，分数按照升序。带上 WITHSCORES 可以把分数也返回。
    </p>
    <pre id="DRj37"><code>ZRANGE key start 1 stop [WITHSCORES]</code></pre>
    <p id="u0dc1aff6">
     此处的 [start, stop] 为下标构成的区间. 从 0 开始, 支持负数.
    </p>
    <p id="ufa299364">
     命令有效版本：1.2.0 之后
    </p>
    <p id="u1fad3e0f">
     时间复杂度：O(log(N)+M)
    </p>
    <p id="ub3da39eb">
     返回值：区间内的元素列表。
    </p>
    <p class="img-center">
     <img alt="" height="189" id="ufa5d04b1" src="https://i-blog.csdnimg.cn/img_convert/0419e1a4d034e8ca19dcd9dd12c24228.png" width="731"/>
    </p>
    <h4 id="ZKv4S">
     ZREVRANGE
    </h4>
    <p id="u798218e4">
     返回指定区间里的元素，分数按照降序。带上 WITHSCORES 可以把分数也返回。
    </p>
    <p id="u12ca2a9a">
     <strong>
      这个命令可能在 6.2.0 之后废弃，并且功能合并到 ZRANGE 中。
     </strong>
    </p>
    <pre id="vlN37"><code>ZREVRANGE key start stop [WITHSCORES]</code></pre>
    <p id="u02bc05f5">
     命令有效版本：1.2.0 之后
    </p>
    <p id="u8ed6567a">
     时间复杂度：O(log(N)+M)
    </p>
    <p id="u14a644d8">
     返回值：区间内的元素列表。
    </p>
    <p class="img-center">
     <img alt="" height="361" id="u0965fec0" src="https://i-blog.csdnimg.cn/img_convert/254e75617402442a4675053f47b17a36.png" width="732"/>
    </p>
    <h4 id="PBuh0">
     ZRANGEBYSCORE
    </h4>
    <p id="u9687d078">
     返回分数在 min 和 max 之间的元素，默认情况下，min 和 max 都是包含的，可以通过 ( 排除。
    </p>
    <p id="u3bf55799">
     <strong>
      这个命令可能在 6.2.0 之后废弃，并且功能合并到 ZRANGE 中。
     </strong>
    </p>
    <pre id="pyLVi"><code>ZRANGEBYSCORE key min 1 max [WITHSCORES]</code></pre>
    <p id="ua99fde4f">
     命令有效版本：1.0.5 之后
    </p>
    <p id="u0255086d">
     时间复杂度：O(log(N)+M)
    </p>
    <p id="u62247189">
     返回值：区间内的元素列表。
    </p>
    <p id="uadea0f1d">
    </p>
    <p class="img-center">
     <img alt="" height="274" id="u4ca281bc" src="https://i-blog.csdnimg.cn/img_convert/e18d83bb61b3396d45af2bbc83e27e83.png" width="728"/>
    </p>
    <h4 id="oQGrI">
     ZPOPMAX
    </h4>
    <p id="u61c2949d">
     删除并返回分数最高的 count 个元素。
    </p>
    <pre id="GI2Eq"><code>ZPOPMAX key [count]</code></pre>
    <p id="u097aca7a">
     命令有效版本：5.0.0 之后
    </p>
    <p id="u1fa65b42">
     时间复杂度：O(log(N) * M)
    </p>
    <p id="u63169c5d">
     返回值：分数和元素列表。
    </p>
    <p id="ubb7b9238">
    </p>
    <p class="img-center">
     <img alt="" height="127" id="u8a663e40" src="https://i-blog.csdnimg.cn/img_convert/5cc023e2e48b96ecdb30b27d38df7b5d.png" width="735"/>
    </p>
    <h4 id="t5sQw">
     BZPOPMAX
    </h4>
    <p id="uc9930a07">
     ZPOPMAX 的阻塞版本。
    </p>
    <pre id="Nbocr"><code>BZPOPMAX key [key ...] timeout</code></pre>
    <p id="u80d94d28">
     命令有效版本：5.0.0 之后
    </p>
    <p id="u2c3d60ec">
     时间复杂度：O(log(N))
    </p>
    <p id="uf5d0b0da">
     返回值：元素列表。
    </p>
    <h4 id="iwejG">
     ZPOPMIN
    </h4>
    <p id="ua91c31c7">
     删除并返回分数最低的 count 个元素。
    </p>
    <pre id="tidWh"><code>ZPOPMIN key [count]</code></pre>
    <p id="u6b9aa087">
     命令有效版本：5.0.0 之后
    </p>
    <p id="ue9aa4177">
     时间复杂度：O(log(N) * M)
    </p>
    <p id="u18ded66d">
     返回值：分数和元素列表。
    </p>
    <p class="img-center">
     <img alt="" height="311" id="uc779d394" src="https://i-blog.csdnimg.cn/img_convert/39efb4b7e4aca1b2995276b01242f3b5.png" width="732"/>
    </p>
    <h4 id="jBGva">
     BZPOPMIN
    </h4>
    <p id="u882bc13e">
     ZPOPMIN 的阻塞版本。
    </p>
    <pre id="F623h"><code>BZPOPMIN key [key ...] timeout</code></pre>
    <p id="ub289b731">
     命令有效版本：5.0.0 之后
    </p>
    <p id="u04de40e7">
     时间复杂度：O(log(N))
    </p>
    <p id="u26b07bec">
     返回值：元素列表。
    </p>
    <h4 id="Gbw6X">
     ZRANK
    </h4>
    <p id="uf2fb0a06">
     返回指定元素的排名，升序。
    </p>
    <pre id="l67Tv"><code>ZRANK key member</code></pre>
    <p id="u7eff77c0">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u3ecee22d">
     时间复杂度：O(log(N))
    </p>
    <p id="u17332321">
     返回值：排名。
    </p>
    <p id="ud1b316d7">
    </p>
    <p class="img-center">
     <img alt="" height="302" id="uf151b268" src="https://i-blog.csdnimg.cn/img_convert/ef28452b3578ff1847d31a183bf4a190.png" width="727"/>
    </p>
    <h4 id="MoAGb">
     ZREVRANK
    </h4>
    <p id="uf1fd5982">
     返回指定元素的排名，降序。
    </p>
    <pre id="Lm2VM"><code>ZREVRANK key member</code></pre>
    <p id="ud554457a">
     命令有效版本：2.0.0 之后
    </p>
    <p id="ucf3537ec">
     时间复杂度：O(log(N))
    </p>
    <p id="ud066d3aa">
     返回值：排名。
    </p>
    <p class="img-center">
     <img alt="" height="427" id="u4b3d1f00" src="https://i-blog.csdnimg.cn/img_convert/600c50c43b00bf50c5e0510bff18e10b.png" width="734"/>
    </p>
    <h4 id="fM3NG">
     ZSCORE
    </h4>
    <p id="u632f74d8">
     返回指定元素的分数。
    </p>
    <pre id="ZdpYB"><code>ZSCORE key member</code></pre>
    <p id="u886d8e66">
     命令有效版本：1.2.0 之后
    </p>
    <p id="ua9c88b65">
     时间复杂度：O(1)
    </p>
    <p id="ue02b08de">
     返回值：分数。
    </p>
    <p class="img-center">
     <img alt="" height="227" id="u55a439ed" src="https://i-blog.csdnimg.cn/img_convert/828b84f33605e6cb8f5453298c5ab8e4.png" width="729"/>
    </p>
    <h4 id="ipVdz">
     ZREM
    </h4>
    <p id="u51e0a22b">
     删除指定的元素。
    </p>
    <pre id="xIsuO"><code>ZREM key member [member ...]</code></pre>
    <p id="u87226048">
     命令有效版本：1.2.0 之后
    </p>
    <p id="u580974d0">
     时间复杂度：O(M*log(N))
    </p>
    <p id="u249bac83">
     返回值：本次操作删除的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="347" id="uf4c26dbe" src="https://i-blog.csdnimg.cn/img_convert/933d99806c3b5395067e792c4b49201b.png" width="729"/>
    </p>
    <h4 id="wQlLE">
     ZREMRANGEBYRANK
    </h4>
    <p id="u66bea564">
     按照排序，升序删除指定范围的元素，左闭右闭。
    </p>
    <pre id="Z1lKa"><code>ZREMRANGEBYRANK key start stop</code></pre>
    <p id="u060ae777">
     命令有效版本：2.0.0 之后
    </p>
    <p id="ua18db11a">
     时间复杂度：O(log(N)+M)
    </p>
    <p id="ue406d361">
     返回值：本次操作删除的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="347" id="u41b93234" src="https://i-blog.csdnimg.cn/img_convert/c02e0797359c57205d94656bcc4670a3.png" width="733"/>
    </p>
    <h4 id="IXB08">
     ZREMRANGEBYSCORE
    </h4>
    <p id="u80d94b6a">
     按照分数删除指定范围的元素，左闭右闭。
    </p>
    <pre id="Hgrfr"><code>ZREMRANGEBYSCORE key min max</code></pre>
    <p id="uf373dbc2">
     命令有效版本：1.2.0 之后
    </p>
    <p id="u90e28420">
     时间复杂度：O(log(N)+M)
    </p>
    <p id="u64c46c20">
     返回值：本次操作删除的元素个数。
    </p>
    <p class="img-center">
     <img alt="" height="261" id="u101433da" src="https://i-blog.csdnimg.cn/img_convert/c554a695e964ea51fe8afdc886f48e00.png" width="731"/>
    </p>
    <h4 id="x8pmA">
     ZINCRBY
    </h4>
    <p id="u446e8738">
     为指定的元素的关联分数添加指定的分数值。
    </p>
    <pre id="ayQL4"><code>ZINCRBY key increment member</code></pre>
    <p id="ub1e1bf3f">
     命令有效版本：1.2.0 之后
    </p>
    <p id="udd17e922">
     时间复杂度：O(log(N))
    </p>
    <p id="u56b80a7d">
     返回值：增加后元素的分数。
    </p>
    <p id="ub5c28bb0">
    </p>
    <p class="img-center">
     <img alt="" height="130" id="u873c88f1" src="https://i-blog.csdnimg.cn/img_convert/b3f1773101b36c2d2c9f7d7f59b3c6a7.png" width="732"/>
    </p>
    <h4 id="BuheX">
     ZINTERSTORE
    </h4>
    <p id="uaff5d5b0">
     求出给定有序集合中元素的交集并保存进目标有序集合中，在合并过程中以元素为单位进行合并，元素对应的分数按照不同的聚合方式和权重得到新的分数。
    </p>
    <pre id="qy21i"><code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight
[weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</code></pre>
    <p id="u5f03848b">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u7703e4db">
     时间复杂度：O(N*K)+O(M*log(M)) N 是输入的有序集合中, 最小的有序集合的元素个数; K 是输入了
    </p>
    <p id="u9e4fdc2b">
     几个有序集合; M 是最终结果的有序集合的元素个数.
    </p>
    <p id="ue2945e96">
     返回值：目标集合中的元素个数
    </p>
    <p id="u4a314937">
    </p>
    <p class="img-center">
     <img alt="" height="254" id="uaa9826f1" src="https://i-blog.csdnimg.cn/img_convert/93b1369cc409b8d1919c7d575129f9ee.png" width="726"/>
    </p>
    <p id="ud0ce90c1">
     2 表示后面会指定 2 个有序集合 作为输入集合，分别是 zset1 和 zset2。 如果你有更多的有序集合参与交集计算，可以增加这个数字，并在后面列出这些集合的名称。
    </p>
    <h4 id="ivd2K">
     ZUNIONSTORE
    </h4>
    <p id="ud30fdb08">
     求出给定有序集合中元素的并集并保存进目标有序集合中，在合并过程中以元素为单位进行合并，元素对应的分数按照不同的聚合方式和权重得到新的分数。
    </p>
    <pre id="devGf"><code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight
[weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</code></pre>
    <p id="u4c201ccc">
     命令有效版本：2.0.0 之后
    </p>
    <p id="u51916cf8">
     时间复杂度：O(N)+O(M*log(M)) N 是输入的有序集合总的元素个数; M 是最终结果的有序集合的元素
    </p>
    <p id="u0917e01a">
     个数.
    </p>
    <p id="ua886a810">
     返回值：目标集合中的元素个数
    </p>
    <p class="img-center">
     <img alt="" height="353" id="u16969e70" src="https://i-blog.csdnimg.cn/img_convert/38de427489bc33166cbbb50712f357e9.png" width="729"/>
    </p>
    <h3 id="K18w5">
     内部编码
    </h3>
    <ol>
     <li id="u60820baa">
      ziplist（压缩列表）：当有序集合的元素个数小于 zset-max-ziplist-entries 配置（默认 128 个），同时每个元素的值都小于 zset-max-ziplist-value 配置（默认 64 字节）时，Redis 会用 ziplist 来作为有序集合的内部实现，ziplist 可以有效减少内存的使用。
     </li>
     <li id="u2c2e8bab">
      skiplist（跳表）：当 ziplist 条件不满足时，有序集合会使用 skiplist 作为内部实现，因为此时ziplist 的操作效率会下降。
     </li>
    </ol>
    <hr id="rrV2o"/>
    <pre id="PwvQW"><code>当元素个数较少且每个元素较小时，内部编码为 ziplist：
127.0.0.1:6379&gt; zadd zsetkey 50 e1 60 e2 30 e3
(integer) 3
127.0.0.1:6379&gt; object encoding zsetkey
"ziplist"


当元素个数超过 128 个，内部编码 skiplist
127.0.0.1:6379&gt; zadd zsetkey 50 e1 60 e2 30 e3 ... 省略 ... 82 e129
(integer) 129
127.0.0.1:6379&gt; object encoding zsetkey
"skiplist"


当某个元素大于 64 字节时，内部编码 skiplist：
127.0.0.1:6379&gt; zadd zsetkey 50 "one string bigger than 64 bytes ... 省略 ..."
(integer) 1
127.0.0.1:6379&gt; object encoding zsetkey
"skiplist"</code></pre>
    <h3 id="I1YL8">
     使用场景
    </h3>
    <p id="uaaf3428d">
     有序集合比较典型的使用场景就是排行榜系统。例如常见的网站上的热榜信息，榜单的维度可能是多方面的：按照时间、按照阅读量、按照点赞量。本例中我们使用点赞数这个维度，维护每天的热榜：
    </p>
    <p id="u7422e0cd">
     假如用户A发布了一篇文章，并获得了3个赞，可以使用有序集合的zadd和zincrby功能，之后在获得赞继续使用zincrby，如果用户删除文章了，需要将用户从榜单中删除掉，可以使用zrem。展示获赞最多的10个用户，可以使用zrevrange命令实现
    </p>
    <h2 id="H1tCw">
     渐进式遍历
    </h2>
    <p id="u7b8c89cc">
     Redis 使用 scan 命令进行渐进式遍历键，进而解决直接使用 keys 获取键时可能出现的阻塞问题。每次 scan 命令的时间复杂度是 O(1)，但是要完整地完成所有键的遍历，需要执行多次 scan。
    </p>
    <p id="ua39b1597">
    </p>
    <p class="img-center">
     <img alt="" height="240" id="u734bba67" src="https://i-blog.csdnimg.cn/img_convert/67c33f4e64e54982777f16ee5bdef69d.png" width="728"/>
    </p>
    <p id="u76f4f489">
     首次 scan 从 0 开始.
    </p>
    <p id="u30f7203c">
     当 scan 返回的下次位置为 0 时, 遍历结束.
    </p>
    <h3 id="BH4vE">
     SCAN
    </h3>
    <p id="ude6a4670">
     以渐进式的方式进行键的遍历。
    </p>
    <pre id="GZ0kf"><code>SCAN cursor [MATCH pattern] [COUNT 1 count] [TYPE type]</code></pre>
    <p id="u1bc3f92f">
     命令有效版本：2.8.0 之后
    </p>
    <p id="ue45bd3e6">
     时间复杂度：O(1)
    </p>
    <p id="ua0ac85d8">
     返回值：下一次 scan 的游标（cursor）以及本次得到的键。
    </p>
    <p id="u232dc735">
     渐进性遍历 scan 虽然解决了阻塞的问题，但如果在遍历期间键有所变化（增加、修改、删除），可能导致遍历时键的重复遍历或者遗漏，这点务必在实际开发中考虑。
    </p>
    <h2 id="PYk26">
     数据库管理
    </h2>
    <p id="u3814e5a0">
     Redis 提供了几个面向 Redis 数据库的操作，分别是 dbsize、select、flushdb、flushall 命令，
    </p>
    <h3 id="KAlup">
     切换数据库
    </h3>
    <pre id="DR534"><code>select dbIndex</code></pre>
    <p id="ue6533803">
     许多关系型数据库，例如 MySQL 支持在一个实例下有多个数据库存在的，但是与关系型数据库用字符来区分不同数据库名不同，Redis 只是用数字作为多个数据库的实现。Redis 默认配置中是有 16个数据库。select 0 操作会切换到第一个数据库，select 15 会切换到最后一个数据库。0 号数据库和15 号数据库保存的数据是完全不冲突的，即各种有各自的键值对。默认情况下，我们处于数据库 0。
    </p>
    <p id="ubb1805a3">
     Redis 管理的数据库
    </p>
    <p id="u3ac436c9">
    </p>
    <p class="img-center">
     <img alt="" height="634" id="u5ff472aa" src="https://i-blog.csdnimg.cn/img_convert/1ff9d8d26210eb28bf4714b73665c863.png" width="732"/>
    </p>
    <p id="u7926b975">
     Redis 中虽然支持多数据库，但随着版本的升级，其实不是特别建议使用多数据库特性。如果真的需要完全隔离的两套键值对，更好的做法是维护多个 Redis 实例，而不是在一个Redis 实例中维护多数据库。这是因为本身 Redis 并没有为多数据库提供太多的特性，其次无论是否有多个数据库，Redis 都是使用单线程模型，所以彼此之间还是需要排队等待命令的执行。同时多数据库还会让开发、调试和运维工作变得复杂。所以实践中，始终使用数据库 0 其实是一个很好的选择。
    </p>
    <h3 id="wgLpB">
     清除数据库
    </h3>
    <p id="u5d1e3843">
     flushdb / flushall 命令用于清除数据库，区别在于 flushdb 只清除当前数据库，flushall 会清楚所有数据库。
    </p>
    <p id="uf39637f8">
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37333838383233392f:61727469636c652f64657461696c732f313436303531333636" class_="artid" style="display:none">
 </p>
</div>


