---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343139373435352f:61727469636c652f64657461696c732f313436323737353132"
layout: post
title: "UDP-Socket"
date: 2025-03-15 15:30:27 +0800
description: "网络编程基础概念，UDP Socket的常用接口和基础实现流程"
keywords: "UDP Socket"
categories: ['网络编程']
tags: ['网络协议', '网络', 'Udp']
artid: "146277512"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146277512
    alt: "UDP-Socket"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146277512
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146277512
cover: https://bing.ee123.net/img/rand?artid=146277512
image: https://bing.ee123.net/img/rand?artid=146277512
img: https://bing.ee123.net/img/rand?artid=146277512
---

# UDP Socket

## 网络编程基础概念理解

**IP地址：**
IP地址是互联网上每个设备的唯一标识。
  
格式：

* IPv4：4组数字，如 192.168.1.1（共约43亿个，已不足）。
* IPv6：8组16进制数，如 2001:0db8:85a3::8a2e:0370:7334（解决IPv4不足的问题）。

分类：

* 公有IP：全球唯一，用于互联网通信。
* 私有IP：局域网内使用（如 192.168.x.x，10.x.x.x）。

**端口号(Port)：**
区分同一设备上的不同服务或应用程序，标识该主机中的进程。

端口号分类：

* 知名端口（0-1023）：预留给系统服务，如 80（HTTP）、443（HTTPS）、22（SSH）。
* 注册端口（1024-49151）：分配给常见应用，如 3306（MySQL）、3389（远程桌面）。
* 动态端口（49152-65535）：临时分配给客户端程序（如浏览器访问网站时随机生成）。

【
**IP : Port = 标识互联网中该IP对应的主机上对应端口号的进程，也就是套接字Socket。**
】

**网络字节序：**
  
计算机在存储多字节数据（如整数、IP地址）时，有两种不同的排列方式：大端序 和 小端序。

**网络字节序统一规定网络传输时数据的字节序，为大端序。**

为了保证字节排序方式一定相同，从主机发送数据到网络上 和 从网络上接收数据到主机 都需要对数据字节排序方式进行转换。

**端口号转换函数：**
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2bd0a895a2d24f4197f15f17d2430539.png)

```c
#include <arpa/inet.h>  // Linux
// #include <winsock2.h>  // Windows

uint16_t port = 8080;
uint16_t network_port = htons(port);  // 主机序 → 网络序
uint16_t host_port = ntohs(network_port);  // 网络序 → 主机序

```

**IP地址转换函数：**
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/75ca832265054b30a8a3d128711f03ed.png)

```c
#include <arpa/inet.h>

// 字符串IP → 网络字节序二进制
const char *ip_str = "192.168.1.1";
struct in_addr ip_bin;
if (inet_pton(AF_INET, ip_str, &ip_bin) != 1) {
    // 转换失败处理
}

// 网络字节序二进制 → 字符串IP
char ip_str_buffer[INET_ADDRSTRLEN];
const char *result = inet_ntop(AF_INET, &ip_bin, ip_str_buffer, sizeof(ip_str_buffer));
if (result == NULL) {
    // 转换失败处理
}

```

## sockaddr 结构，sockaddr\_in 结构和sockaddr\_un 结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a8c00c9b66b04b0d8faeaf7f546e30f5.png)
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/82e24eeb329a4db5905db48db0c1423a.png)
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1cdd8ef18a6c49e3a76a0c4127f5a661.png)

## UDP协议

UDP（User Datagram Protocol 用户数据报协议）： 传输层协议，面向数据报，用于需要“高速传输”的场景，例如视频通话、在线游戏等。

**核心特性：**

1. 无连接：无需建立连接，直接发送数据（没有三次握手）。
2. 不可靠传输：不保证数据是否到达、是否按序到达、是否重复。
3. 轻量高效：没有确认应答、重传、流量控制等机制，传输开销极小，速度极快。
4. 支持广播/组播：可以一次性向多个设备发送数据（如直播流媒体）。

## UDP Socket编程常用接口

### 创建Socket

接口：
`socket()`
创建通信端点。

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9bee48891923495c937b87c410255abf.png)

```c
 int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
 
 if (sockfd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

```

### 绑定IP和端口（仅服务端需要）

接口：
`bind()`
用于将套接字与特定的 IP 地址 和 端口号 绑定，使其能够在该地址和端口上监听或接收数据。

```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/436ff578691b43198c93a822f78b8749.png)

```c
 struct sockaddr_in servaddr;
    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(8080);

 if (bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

```

**注：**
udp客户端不需要显示绑定，系统会自动进行绑定。
  
服务器端需要一直固定的IP和端口号，而客户端不需要固定的，只需要在每次连接的时候是固定的就行。

### 收发数据

接口：
`sendto()`
向指定的目标地址发送数据（UDP 是无连接的，每次需明确目标地址）。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ebec3e5862f54ebd8a604fe6115205a8.png)

```c
const char* msg = "Hello from UDP server";
struct sockaddr_in destaddr;
destaddr.sin_family = AF_INET;
destaddr.sin_port = htons(8080);
destaddr.sin_addr.s_addr = inet_addr("192.168.1.100");  // 目标IP

ssize_t n = sendto(sockfd, msg, strlen(msg), 0,
                 (struct sockaddr*)&destaddr, sizeof(destaddr));
                 
if (n < 0) {
    perror("sendto failed");
}

//client发数据给server，虽然客户端不需要绑定，但要发给server还是需要
//在struct sockaddr_in server；之后把服务端的端口号和IP赋值给server
//因为客户端需要知道服务端的 IP:Port


```

接口：
`recvfrom()`
接收数据并获取发送方的地址信息（UDP 需要获取来源地址以回复）。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/525089c481504c0188b94c0d1e2842e0.png)

```c
char buffer[1024];
struct sockaddr_in cliaddr;
socklen_t len = sizeof(cliaddr);

ssize_t n = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                    (struct sockaddr*)&cliaddr, &len);
                    
if (n < 0) {
    perror("recvfrom failed");
}

//服务端接收到客户端传来的信息后，cliaddr中就存储进了客户端的IP:端口号

```

**注： recvfrom() 函数会将接收到的数据包中的源地址信息自动填入传进函数的那个结构体中。**

### 关闭连接

接口：
`close()`
用于释放套接字资源。

```c
close(sockfd);  // Linux

```