---
layout: post
title: "从vue源码解析Vue.set和this.set"
date: 2025-03-05 20:40:11 +0800
description: "最近死磕了一段时间vue源码，想想觉得还是要输出点东西，我们先来从Vue提供的Vue.set()和this.$set()这两个api看看它内部是怎么实现的。"
keywords: "vue3 $set"
categories: ['未分类']
tags: ['前端', 'Vue', 'Javascript']
artid: "146052378"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146052378
    alt: "从vue源码解析Vue.set和this.set"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146052378
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146052378
cover: https://bing.ee123.net/img/rand?artid=146052378
image: https://bing.ee123.net/img/rand?artid=146052378
img: https://bing.ee123.net/img/rand?artid=146052378
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     从vue源码解析Vue.set()和this.$set()
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2 id="A7V0i">
     前言
    </h2>
    最近死磕了一段时间vue源码，想想觉得还是要输出点东西，我们先来从Vue提供的Vue.set()和this.$set()这两个api看看它内部是怎么实现的。
    <h2 id="Q0zOb">
     Vue.set()和this.$set()应用的场景
    </h2>
    平时做项目的时候难免不会对 数组或者对象 进行这样的骚操作操作，结果发现，咦~~，他喵的，怎么页面没有重新渲染。
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
        <br/>
        5
        <br/>
        6
        <br/>
        7
        <br/>
        8
        <br/>
        9
        <br/>
        10
       </th>
       <th align="left">
        <code>
         const vueInstance = ``new
        </code>
        <code>
         Vue({
         <!-- -->
        </code>
        <br/>
        <code>
         ``data: {
         <!-- -->
        </code>
        <br/>
        <code>
         ``arr: [1, 2],
        </code>
        <br/>
        <code>
         ``obj1: {
         <!-- -->
        </code>
        <br/>
        <code>
         ``a: 3
        </code>
        <br/>
        <code>
         ``}
        </code>
        <br/>
        <code>
         ``}
        </code>
        <br/>
        <code>
         });
        </code>
        <br/>
        <code>
         vueInstance.$data.arr[0] = 3; ``// 这种骚操作页面不会重新渲染
        </code>
        <br/>
        <code>
         vueInstance.$data.obj1.b = 3; ``// 这种骚操作页面不会重新渲染
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     查了一下官方文档，发现人家早就说过这种情况
    </p>
    <p>
     Vue.set()向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)
    </p>
    <p>
     所以按照官网的写法，我们应该使用下面这种写法：
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
       </th>
       <th align="left">
        <code>
         Vue.set(vueInstance.$data.arr, 0, 3); ``// 这样操作数组可以让页面重新渲染
        </code>
        <br/>
        <code>
         vueInstance.$set(vueInstance.$data.arr, 0, 3); ``// 这样操作数组也可以让页面重新渲染
        </code>
        <br/>
        <code>
         Vue.set(vueInstance.$data.obj1, b, 3); ``// 这样操作对象可以让页面重新渲染
        </code>
        <br/>
        <code>
         vueInstance.$set(vueInstance.$data.obj1, b, 3); ``// 这样操作对象也可以让页面重新渲染
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <h2 id="iHUfz">
     Vue.set()和this.$set()实现原理
    </h2>
    是时候看一波这两个api的源码了，我们先来看看Vue.set()的源码：
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
       </th>
       <th align="left">
        <code>
         import { set } from ``'../observer/index'
        </code>
        <br/>
        <code>
         ...
        </code>
        <br/>
        <code>
         Vue.set = set
        </code>
        <br/>
        <code>
         ...
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     再来看看
     <code>
      this.$set()
     </code>
     的源码：
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
       </th>
       <th align="left">
        <code>
         import { set } from ``'../observer/index'
        </code>
        <br/>
        <code>
         ...
        </code>
        <br/>
        <code>
         Vue.prototype.$set = set
        </code>
        <br/>
        <code>
         ...
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     结果我们发现
     <code>
      Vue.set()和this.$set()
     </code>
     这两个api的实现原理基本一模一样，都是使用了set函数。set函数是从 …/observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。
    </p>
    <p>
     接下来我们根据 …/observer/index 中找出set函数：
    </p>
    <p>
     | 1
     <br/>
     2
     <br/>
     3
     <br/>
     4
     <br/>
     5
     <br/>
     6
     <br/>
     7
     <br/>
     8
     <br/>
     9
     <br/>
     10
     <br/>
     11
     <br/>
     12
     <br/>
     13
     <br/>
     14
     <br/>
     15
     <br/>
     16
     <br/>
     17
     <br/>
     18
     <br/>
     19
     <br/>
     20
     <br/>
     21
     <br/>
     22
     <br/>
     23
     <br/>
     24
     <br/>
     25
     <br/>
     26
     <br/>
     27
     <br/>
     28
     <br/>
     29
     <br/>
     30
     <br/>
     31 |
     <code>
      function
     </code>
     <code>
      set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
      <!-- -->
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (process.env.NODE_ENV !== ``'production'
     </code>
     <code>
      &amp;&amp;
     </code>
     <br/>
     <code>
      ``(isUndef(target) || isPrimitive(target))
     </code>
     <br/>
     <code>
      ``) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``warn(
     </code>
     Cannot set reactive property on undefined,
     <code>
      null
     </code>
     , or primitive value: ${(target: any)}
     <code>
      )
     </code>
     <br/>
     <code>
      ``}
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``target.length = Math.max(target.length, key)
     </code>
     <br/>
     <code>
      ``target.splice(key, 1, val)
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      ``}
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (key ``in
     </code>
     <code>
      target &amp;&amp; !(key ``in
     </code>
     <code>
      Object.prototype)) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``target[key] = val
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      ``}
     </code>
     <br/>
     <code>
      ``const ob = (target: any).__ob__
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (target._isVue || (ob &amp;&amp; ob.vmCount)) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``process.env.NODE_ENV !== ``'production'
     </code>
     <code>
      &amp;&amp; warn(
     </code>
     <br/>
     <code>
      ``'Avoid adding reactive properties to a Vue instance or its root $data '
     </code>
     <code>
      +
     </code>
     <br/>
     <code>
      ``'at runtime - declare it upfront in the data option.'
     </code>
     <br/>
     <code>
      ``)
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      ``}
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (!ob) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``target[key] = val
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      ``}
     </code>
     <br/>
     <code>
      ``defineReactive(ob.value, key, val)
     </code>
     <br/>
     <code>
      ``ob.dep.notify()
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      }
     </code>
     |
     <br/>
     | :— | :— |
    </p>
    <p>
     我们发现set函数接收三个参数分别为 target、key、val，其中target的值为数组或者对象，这正好和官网给出的调用
     <code>
      Vue.set()
     </code>
     方法时传入的参数参数对应上。如下图所示：
    </p>
    <p>
     <img alt="" src=""/>
    </p>
    <p>
     我们接着往下看：
    </p>
    <p>
     | 1
     <br/>
     2
     <br/>
     3
     <br/>
     4
     <br/>
     5 |
     <code>
      if
     </code>
     <code>
      (process.env.NODE_ENV !== ``'production'
     </code>
     <code>
      &amp;&amp;
     </code>
     <br/>
     <code>
      ``(isUndef(target) || isPrimitive(target))
     </code>
     <br/>
     <code>
      ``) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``warn(
     </code>
     Cannot set reactive property on undefined,
     <code>
      null
     </code>
     , or primitive value: ${(target: any)}
     <code>
      )
     </code>
     <br/>
     <code>
      ``}
     </code>
     |
     <br/>
     | :— | :— |
    </p>
    <p>
     我们先看isUndef和isPrimitive方法，从名字就可以看出，isUndef是判断target是不是等于undefined或者null。isPrimitive是判断target的数据类型是不是string、number、symbol、boolean中的一种。所以这里的意思是如果当前环境不是生产环境并且
     <code>
      isUndef(target) || isPrimitive(target)
     </code>
     为真的时候，那么就抛出错误警告。
    </p>
    <h2 id="LuoRj">
     数组的实现原理
    </h2>
    接着向下看：
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
        <br/>
        5
       </th>
       <th align="left">
        <code>
         if
        </code>
        <code>
         (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
         <!-- -->
        </code>
        <br/>
        <code>
         ``target.length = Math.max(target.length, key)
        </code>
        <br/>
        <code>
         ``target.splice(key, 1, val)
        </code>
        <br/>
        <code>
         ``return
        </code>
        <code>
         val
        </code>
        <br/>
        <code>
         ``}
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     这里实际就是修改数组时调用set方法时让我们能够触发响应的代码，不过在分析这段代码之前我们来看看vue中的数组实际上是长什么样的。 下图分别是vue中的数组和普通的js数组：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/62e0c733db84b98071e02d5f6b4d6ee1.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a63d412f8b77a1823ff7f3125eebf874.png"/>
    </p>
    <p>
     vue中的数组我们命名为arrVue，js中的普通数组命名为arrJs。其实我们平时调用普通数组的push、pop等方法是调用的Array原型上面定义的方法， 从图中我们可以看出arrJs的原型是指向Array.prototype，也就是说 arrJs.
     <strong>
      proto
     </strong>
     == Array.prototype 。
    </p>
    <p>
     但是在vue的数组中，我们发现arrVue的原型其实不是指向的Array.prototype，而是指向的一个对象（我们这里给这个对象命名为arrayMethods）。arrayMethods上面只有7个push、pop等方法，并且arrayMethods的原型才是指向的Array.prototype。所以我们在vue中调用数组的push、pop等方法时其实不是直接调用的数组原型给我们提供的push、pop等方法，而是调用的arrayMethods给我们提供的push、pop等方法。vue为什么要给数组的原型链上面加上这个arrayMethods呢？这里涉及到了vue的数据响应的原理，我们这篇文章暂时不谈论数据响应原理的具体实现。这里你可以理解成vue在arrayMethods对象中做过了特殊处理，如果你调用了arrayMethods提供的push、pop等7个方法，那么它会触发当前收集的依赖（这里收集的依赖可以暂时理解成渲染函数），导致页面重新渲染。换句话说，对于数组的操作，我们只有使用arrayMethods提供的那7个方法才会导致页面渲染，这也就解释了为什么我们使用 vueInstance.$data.arr[0] = 3; 时不会导致页面出现渲染。
    </p>
    <p>
     搞清楚vue中的数组具体是怎么实现了之后，我们再来看上面的代码：
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
        <br/>
        5
       </th>
       <th align="left">
        <code>
         if
        </code>
        <code>
         (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
         <!-- -->
        </code>
        <br/>
        <code>
         ``target.length = Math.max(target.length, key)
        </code>
        <br/>
        <code>
         ``target.splice(key, 1, val)
        </code>
        <br/>
        <code>
         ``return
        </code>
        <code>
         val
        </code>
        <br/>
        <code>
         ``}
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     首先if判断当前target是不是数组，并且key的值是有效的数组索引。然后将target数组的长度设置为target.length和key中的最大值，这里为什么要这样做呢?是因为我们可能会进行下面这种骚操作：
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
       </th>
       <th align="left">
        <code>
         arr1 = [1,3];
        </code>
        <br/>
        <code>
         Vue.set(arr1,10,1) ``// 如果不那样做，这种情况就会出问题
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     接着向下看，我们发现这里直接调用了target.splice(key, 1, val)，在前面我们说过调用arrayMethods提供的push、pop等7个方法可以导致页面重新渲染，刚好splice也是属性arrayMethods提供的7个方法中的一种。
    </p>
    <p>
     总结一下Vue.set数组实现的原理：其实Vue.set()对于数组的处理其实就是调用了splice方法，是不是发现其实很简单~~
    </p>
    <h2 id="LBsBM">
     对象的实现原理
    </h2>
    我们接着向下看代码：
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
        <br/>
        4
       </th>
       <th align="left">
        <code>
         if
        </code>
        <code>
         (key ``in
        </code>
        <code>
         target &amp;&amp; !(key ``in
        </code>
        <code>
         Object.prototype)) {
         <!-- -->
        </code>
        <br/>
        <code>
         ``target[key] = val
        </code>
        <br/>
        <code>
         ``return
        </code>
        <code>
         val
        </code>
        <br/>
        <code>
         ``}
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     这里先判断如果key本来就是对象中的一个属性，并且key不是Object原型上的属性。说明这个key本来就在对象上面已经定义过了的，直接修改值就可以了，可以自动触发响应。
    </p>
    <p>
     关于对象的依赖收集和触发原理我们本文也不做详细解释，你可以暂时先这样理解。vue是使用的Object.defineProperty给对象做了一层拦截，当触发get的时候就会进行依赖收集（这里收集的依赖还是像数组那样，理解成渲染函数），当触发set的时候就会触发依赖，导致渲染函数执行页面重新渲染。那么第一次是在哪里触发get的呢？其实是在首次加载页面渲染的时候触发的，这里会进行递归将对象的属性都依赖收集，所以我们修改对象已有属性值得时候会导致页面重新渲染。这也刚好解释了我们使用 vueInstance.$data.obj1.b = 3; 的时候为什么页面不会重新渲染，因为这里的属性b不是对象的已有属性，也就是说属性b没有进行过依赖收集，所以才会导致修改属性b的值页面不会重新渲染。
    </p>
    <p>
     我们接着向下看代码：
    </p>
    <p>
     | 1
     <br/>
     2
     <br/>
     3
     <br/>
     4
     <br/>
     5
     <br/>
     6
     <br/>
     7
     <br/>
     8
     <br/>
     9
     <br/>
     10
     <br/>
     11
     <br/>
     12 |
     <code>
      const ob = (target: any).__ob__
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (target._isVue || (ob &amp;&amp; ob.vmCount)) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``process.env.NODE_ENV !== ``'production'
     </code>
     <code>
      &amp;&amp; warn(
     </code>
     <br/>
     <code>
      ``'Avoid adding reactive properties to a Vue instance or its root $data '
     </code>
     <code>
      +
     </code>
     <br/>
     <code>
      ``'at runtime - declare it upfront in the data option.'
     </code>
     <br/>
     <code>
      ``)
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      ``}
     </code>
     <br/>
     <code>
      ``if
     </code>
     <code>
      (!ob) {
      <!-- -->
     </code>
     <br/>
     <code>
      ``target[key] = val
     </code>
     <br/>
     <code>
      ``return
     </code>
     <code>
      val
     </code>
     <br/>
     <code>
      ``}
     </code>
     |
     <br/>
     | :— | :— |
    </p>
    <p>
     首先定义变量ob的值为 target.
     <strong>
      ob
     </strong>
     ，这个
     <strong>
      ob
     </strong>
     属性到底是什么对象呢？vue给响应式对象都加了一个
     <strong>
      ob
     </strong>
     属性，如果一个对象有这个
     <strong>
      ob
     </strong>
     属性，那么就说明这个对象是响应式对象，我们修改对象已有属性的时候就会触发页面渲染。
    </p>
    <p>
     <code>
      target._isVue || (ob &amp;&amp; ob.vmCount)
     </code>
     的意思是：当前的target对象是vue实例对象或者是根数据对象，那么就会抛出错误警告。
    </p>
    <p>
     if (!ob) 为真说明当前的target对象不是响应式对象，那么直接赋值返回即可。
    </p>
    <p>
     接着向下看：
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        1
        <br/>
        2
        <br/>
        3
       </th>
       <th align="left">
        <code>
         defineReactive(ob.value, key, val)
        </code>
        <br/>
        <code>
         ``ob.dep.notify()
        </code>
        <br/>
        <code>
         ``return
        </code>
        <code>
         val
        </code>
       </th>
      </tr>
     </thead>
    </table>
    <p>
     这里其实才是vue.set()真正处理对象的地方。 defineReactive(ob.value, key, val) 的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。
    </p>
    <p>
     ob.dep.notify() 这句代码的意思是触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。
    </p>
    <p>
     总结
    </p>
    <p>
     从源码层次看vue提供的vue.set()和this.$set()这两个api还是很简单的，由于本文没有详细解释vue依赖收集和触发，所以有的地方说的还是很模糊。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e6373:646e2e6e65742f79696e7869616e677a686f6e6771696e672f:61727469636c652f64657461696c732f313436303532333738" class_="artid" style="display:none">
 </p>
</div>


