---
layout: post
title: "MS-SQL2000-数据库置疑解决方法"
date: 2023-01-31 11:03:00 +0800
description: "数据库被置疑后的解决方法(一)A．我们使用默认方式建立一个供恢复使用的数据库(如test)。可以在S"
keywords: "只供dbo使用"
categories: ['Mssql']
tags: ['数据库', 'Sqlserver', 'Sql', 'Sql', 'Server', 'Microsoft', 'Database']
artid: "7077008"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=7077008
    alt: "MS-SQL2000-数据库置疑解决方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=7077008
featuredImagePreview: https://bing.ee123.net/img/rand?artid=7077008
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MS SQL2000 数据库置疑解决方法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     数据库被置疑后的解决方法(一)
    </h4>
    <p>
     A．我们使用默认方式建立一个供恢复使用的数据库(如test)。可以在SQL Server Enterprise Manager
     <br/>
     里面建立。
     <br/>
     B．停掉数据库服务器。
     <br/>
     C．将刚才生成的数据库的日志文件test_log.ldf删除，用要恢复的数据库mdf文件覆盖刚才生成的数据
     <br/>
     库数据文件test_data.mdf。
     <br/>
     D．启动数据库服务器。此时会看到数据库test的状态为"置疑"。这时候不能对此数据库进行任何*作。
     <br/>
     E．设置数据库允许直接*作系统表。此*作可以在SQL Server Enterprise Manager里面选择数据库服
     <br/>
     务器，按右键，选择"属性"，在"服务器设置"页面中将"允许对系统目录直接修改"一项选中。也可以
     <br/>
     使用如下语句来实现。
     <br/>
     use master
     <br/>
     go
     <br/>
     sp_configure 'allow updates',1
     <br/>
     go
     <br/>
     reconfigure with override
     <br/>
     go
     <br/>
     F．设置test为紧急修复模式
     <br/>
     update sysdatabases set status=-32768 where dbid=DB_ID('test')
     <br/>
     此时可以在SQL Server Enterprise Manager里面看到该数据库处于"只读\置疑\脱机\紧急模式"可以
     <br/>
     看到数据库里面的表，但是仅仅有系统表
     <br/>
     G．下面执行真正的恢复*作，重建数据库日志文件
     <br/>
     dbcc rebuild_log('test','C:\Program Files\Microsoft SQL Server\MSSQL\Data\test_log.ldf')
     <br/>
     执行过程中，如果遇到下列提示信息：
    </p>
    <p>
     服务器: 消息 5030，级别 16，状态 1，行 1
     <br/>
     未能排它地锁定数据库以执行该*作。
     <br/>
     DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。
    </p>
    <p>
     说明您的其他程序正在使用该数据库，如果刚才您在F步骤中使用SQL Server Enterprise Manager
     <br/>
     打开了test库的系统表，那么退出SQL Server Enterprise Manager就可以了。
     <br/>
     <br/>
     正确执行完成的提示应该类似于：
    </p>
    <p>
     警告: 数据库 'test' 的日志已重建。已失去事务的一致性。应运行 DBCC CHECKDB 以验证物理一致
     <br/>
     性。将必须重置数据库选项，并且可能需要删除多余的日志文件。
     <br/>
     DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。
     <br/>
     <br/>
     此时打开在SQL Server Enterprise Manager里面会看到数据库的状态为"只供DBO使用"。此时可以
     <br/>
     访问数据库里面的用户表了。
     <br/>
     H．验证数据库一致性（可省略）
     <br/>
     dbcc checkdb('test')
     <br/>
     <br/>
     一般执行结果如下：
     <br/>
     <br/>
     CHECKDB 发现了 0 个分配错误和 0 个一致性错误（在数据库 'test' 中）。
     <br/>
     DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。
     <br/>
     <br/>
     I．设置数据库为正常状态
     <br/>
     sp_dboption 'test','dbo use only','false'
     <br/>
     如果没有出错，那么恭喜，现在就可以正常的使用恢复后的数据库啦。
     <br/>
     J．最后一步，我们要将步骤E中设置的"允许对系统目录直接修改"一项恢复。因为平时直接*作系统表
     <br/>
     是一件比较危险的事情。当然，我们可以在SQL Server Enterprise Manager里面恢复，也可以使用
     <br/>
     如下语句完成
     <br/>
     sp_configure 'allow updates',0
     <br/>
     go
     <br/>
     reconfigure with override
     <br/>
     go
    </p>
    <p>
     <br/>
     --数据库（如test) 分离后再附加
    </p>
    <p>
     EXEC sp_detach_db 'test'
    </p>
    <p>
     EXEC sp_attach_db 'test','c:\Program Files\Microsoft SQL Server\MSSQL\Data\test.mdf','c:\Program Files\Microsoft SQL Server\MSSQL\Data\test_log.ldf'
    </p>
    <h4>
     <br/>
     SQL code如何修复SQLSERVER 数据库置疑之(二)
    </h4>
    <p>
     如果 SQL Server 因为磁盘可用空间不足，而不能完成数据库的恢复，那么  SQL Server 2000 会返回错误 1105 并且将 sysdatabases 中的 status 列设为置疑。
    </p>
    <p>
     你可以看到在SQLSERVER 的ERROR LOG 和OS的应用程序日志中应该有1105的错误信息:
    </p>
    <p>
     SQL Server事务日志可能会被填满，这会阻止之后的数据库操作，包括UPDATE， DELETE， INSERT 和CHECKPOINT。
     <br/>
     事务日志填满会导致1105错误:
     <br/>
     Can't allocate space for object syslogs in database dbname because
     <br/>
     the logsegment is full。 If you ran out of space in syslogs， dump
     <br/>
     the transaction log。 Otherwise use ALTER DATABASE or
     <br/>
     sp_extendsegment to increase the size of the segment。
    </p>
    <p>
     这种现象可能出现于任何一个数据库中，包括Master和TempDB。一些难以预见的因素可能消耗日志空间。 例如:
     <br/>
     一个大型事务， 尤其像批量数据更新、插入或删除。
     <br/>
     一个未提交的事务。
     <br/>
     检查点处理程序截除时所需的带宽过大。
     <br/>
     截除时超过阈值
     <br/>
     上述各种条件互相作用的结果。
     <br/>
     用于发布的标记事务没有被日志读取程序读走
    </p>
    <p>
     <br/>
     下面是修复的步骤和收缩日志的步骤:
    </p>
    <p>
     1.在命令提示符下运行以下命令启动 SQL Server：
    </p>
    <p>
     SQLSERVER -f -m
    </p>
    <p>
     备注：-m 开关以单用户模式启动 SQL Server。在单用户模式下，只能成功建立一个连接。 请注意是否有任何其他客户机或服务可能会在您通过 SQL Server 查询分析器    建立连接前使用那个连接。
    </p>
    <p>
     2. 重置置疑数据库的状态。
    </p>
    <p>
     sp_resetstatus 'database_name'
    </p>
    <p>
     下面是结果集：
    </p>
    <p>
     Database'database_name'status reset!
     <br/>
     WARNING: You must reboot SQL Server prior to accessing this database!
    </p>
    <p>
     <br/>
     3. 用 ALTER DATABASE 向数据库添加一个数据文件或日志文件:
    </p>
    <p>
     USE master
     <br/>
     GO
     <br/>
     CREATE DATABASE db_name ON
     <br/>
     (
     <br/>
     NAME = dbname_dat1,
     <br/>
     FILENAME = 'D:\MSSQL\Data\dbname_dat1.ndf',
     <br/>
     SIZE = 1000MB,
     <br/>
     FILEGROWTH = 50MB
     <br/>
     )
     <br/>
     GO
     <br/>
     --更改该数据库以添加一个 2GB 大小的新数据文件
     <br/>
     ALTER DATABASE db_name
     <br/>
     ADD FILE
     <br/>
     (
     <br/>
     NAME = dbname_dat2,
     <br/>
     FILENAME = 'F:\MSSQL\DATA\dbname_dat2.ndf',
     <br/>
     SIZE = 2000MB,
     <br/>
     FILEGROWTH = 50MB
     <br/>
     )
     <br/>
     GO
     <br/>
     --更改该数据库以添加一个1GB 大小的新日志文件
     <br/>
     ALTER DATABASE db_name
     <br/>
     ADD LOG FILE
     <br/>
     ( NAME = db_name_log2,
     <br/>
     FILENAME = 'F:\MSSQL\Data\db_name_log2.ldf',
     <br/>
     SIZE = 1000MB,
     <br/>
     FILEGROWTH = 20MB),
     <br/>
     GO
    </p>
    <p>
     4. 停止并重新启动 SQL Server:
     <br/>
     用新的数据文件或日志文件所提供的额外空间，SQL Server 应该能完成数据库的恢复。
    </p>
    <p>
     5. 释放磁盘空间并且重新运行恢复操作,按照下面的步骤收缩日志。
     <br/>
     sp_resetstatus 关闭数据库的置疑标志，但是原封不动地保持数据库的其它选项。
    </p>
    <p>
     <br/>
     为从根本上解决这样的问题,你可以按下面的操作配置SQLSERVER 2000:
     <br/>
     a.如果不需要恢复到指定的时间点,你可以将数据库的恢复模式配置为简单,这样
     <br/>
     UPDATE,DELETE,SELECT就不会记录日志,日志就不会增加的很大:
    </p>
    <p>
     USE MASTER
    </p>
    <p>
     GO
     <br/>
     ALTER DATABASE DB_NAME SET RECOVERY SIMPLE
     <br/>
     b.如果你的恢复模式是全部,你一定要配置日志字段收缩:
    </p>
    <p>
     USE MASTER
    </p>
    <p>
     GO
     <br/>
     sp_dboption 'databasename','trunc. log on chkpt.',true
     <br/>
     sp_dboption 'databasename','autoshrink',true
     <br/>
     c.通过每日备份将日志收缩:
     <br/>
     BACKUP DATABASE DATABASE_NAME TO BACKUP_DEVICES
     <br/>
     BACKUP LOG DATABASE_NAME TO LOG_DEVICES
     <br/>
     OR
     <br/>
     BACKUP LOG DATABASE_NAME with truncate_only
    </p>
    <p>
     **检查日志的容量:DBCC SQLPERF (LOGSPACE) 这时日志并没有收缩!
    </p>
    <p>
     d.每天在备份数据库完成之后,重新启动MS SQLSERVER SERVICE.
     <br/>
     USE DATABASE_NAME
     <br/>
     go
     <br/>
     DBCC  SHRINKFILE(2,truncateonly)
    </p>
    <p>
     **检查日志的容量:DBCC SQLPERF (LOGSPACE) 这时日志已经收缩!
    </p>
    <p>
     e.手动快速收缩日志:
     <br/>
     / *run  below  script,you  will  shrink  you  database  log  files
     <br/>
     immediately,  in  my  experience,you  need  to  run  the  script  for  3  or
     <br/>
     4  minutes  before stopping  it  manually  */
     <br/>
     use  databasename
     <br/>
     dbcc  shrinkfile(2,notruncate)
     <br/>
     dbcc  shrinkfile(2,truncateonly)
     <br/>
     create  table  t1(char1  char(4000))
     <br/>
     go
     <br/>
     declare  @i  int
     <br/>
     select  @i=0
     <br/>
     while(1=1)
     <br/>
     begin
     <br/>
     while(@i&lt;100)
     <br/>
     begin
     <br/>
     INSERT  INTO  T1  VALUES  ('A')
     <br/>
     SELECT  @I=@I+1
     <br/>
     END
     <br/>
     TRUNCATE  table  T1
     <br/>
     BACKUP  LOG  youdatabasename  with  truncate_only
     <br/>
     end
     <br/>
     GO
    </p>
    <p>
    </p>
    <p>
     注意  只有在您的主要支持提供者指导下或有疑难解答建议的做法时，才可以使用
     <br/>
     sp_resetstatus。否则，可能会损坏数据库。
    </p>
    <p>
     由于该过程修改了系统表，系统管理员必须在运行 sp_resetstatus这个过程前，启用系统表更新。要
     <br/>
     启 用更新，使用下面的过程：
    </p>
    <p>
     USE master
     <br/>
     GO
     <br/>
     sp_configure 'allow updates', 1
     <br/>
     GO
     <br/>
     RECONFIGURE WITH OVERRIDE
     <br/>
     GO
     <br/>
     过程创建后，立即禁用系统表更新：
    </p>
    <p>
     sp_configure 'allow updates', 0
     <br/>
     GO
     <br/>
     RECONFIGURE WITH OVERRIDE
     <br/>
     GO
     <br/>
     只有系统管理员才能执行 sp_resetstatus。执行该过程后，立即关闭 SQL Server。
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f6f6e3179686163:6b2f61727469636c652f64657461696c732f37303737303038" class_="artid" style="display:none">
 </p>
</div>


