---
layout: post
title: "日志系统项目准备工作了解类的设计模式如单例模式工厂模式代理模式"
date: 2025-03-12 17:06:03 +0800
description: "类的职责应该单⼀，⼀个⽅法只做⼀件事。职责划分清晰了，每次改动到最⼩单位的⽅法或 类。使⽤建议：两个完全不⼀样的功能不应该放⼀个类中，⼀个类中应该是⼀组相关性很⾼的函 数、数据的封装⽤例：⽹络聊天：⽹络通信 & 聊天，应该分割成为⽹络通信类 & 聊天类1.2 开闭原则对扩展开放，对修改封闭使⽤建议：对软件实体的改动，最好⽤扩展⽽⾮修改的⽅式。◦⽤例：超时卖货：商品价格---不是修改商品的原来价格，⽽是新增促销价格。1.3 里氏替换原则。"
keywords: "日志系统项目——准备工作了解类的设计模式如单例模式、工厂模式、代理模式"
categories: ['日志项目']
tags: ['设计模式', '单例模式', '代理模式']
artid: "146205741"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146205741
    alt: "日志系统项目准备工作了解类的设计模式如单例模式工厂模式代理模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146205741
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146205741
cover: https://bing.ee123.net/img/rand?artid=146205741
image: https://bing.ee123.net/img/rand?artid=146205741
img: https://bing.ee123.net/img/rand?artid=146205741
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     日志系统项目——准备工作了解类的设计模式如单例模式、工厂模式、代理模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.六大原则
    </h2>
    <h3>
     1.1 单一职责原则
    </h3>
    <p>
     <span style="color:#1f2329">
      类的职责应该单⼀，⼀个⽅法只做⼀件事。职责划分清晰了，每次改动到最⼩单位的⽅法或 类。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      使⽤建议：两个完全不⼀样的功能不应该放⼀个类中，⼀个类中应该是⼀组相关性很⾼的函 数、数据的封装
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⽤例：⽹络聊天：⽹络通信 &amp; 聊天，应该分割成为⽹络通信类 &amp; 聊天类
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      1.2 开闭原则
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      对扩展开放，对修改封闭
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      使⽤建议：对软件实体的改动，最好⽤扩展⽽⾮修改的⽅式。
     </span>
     <span style="color:#1456f0">
      ◦
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⽤例：超时卖货：商品价格---不是修改商品的原来价格，⽽是新增促销价格。
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      1.3 里氏替换原则
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      通俗点讲，就是只要⽗类能出现的地⽅，⼦类就可以出现，⽽且替换为⼦类也不会产⽣任何错 误或异常。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      在继承类时，务必重写⽗类中所有的⽅法，尤其需要注意⽗类的protected⽅法，⼦类尽量不要暴露⾃⼰的public⽅法供外界调⽤。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
     </span>
     <span style="color:#1f2329">
      使⽤建议：⼦类必须完全实现⽗类的⽅法，孩⼦类可以有⾃⼰的个性。覆盖或实现⽗类的⽅法 时，输⼊参数可以被放⼤，输出可以缩⼩
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⽤例：跑步运动员类-会跑步，⼦类⻓跑运动员-会跑步且擅⻓⻓跑， ⼦类短跑运动员-会跑步且擅⻓短跑
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      1.4 依赖倒置原则
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      ⾼层模块不应该依赖低层模块，两者都应该依赖其抽象. 不可分割的原⼦逻辑就是低层模式，原⼦逻辑组装成的就是⾼层模块。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      模块间依赖通过抽象（接⼝）发⽣，具体类之间不直接依赖
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      使⽤建议：每个类都尽量有抽象类，任何类都不应该从具体类派⽣。尽量不要重写基类的⽅ 法。结合⾥⽒替换原则使⽤。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⽤例：奔驰⻋司机类--只能开奔驰； 司机类 -- 给什么⻋，就开什么⻋； 开⻋的⼈：司机--依 赖于抽象
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      1.5 迪米特原则
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      尽量减少对象之间的交互，从⽽减⼩类之间的耦合。⼀个对象应该对其他对象有最少的了解。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      对类的低耦合提出了明确的要求：
     </span>
     <span style="color:#1f2329">
      只和直接的朋友交流， 朋友之间也是有距离的。⾃⼰的就是⾃⼰的（如果⼀个⽅法放在本类 中，既不增加类间关系，也对本类不产⽣负⾯影响，那就放置在本类中）。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⽤例：⽼师让班⻓点名--⽼师给班⻓⼀个名单，班⻓完成点名勾选，返回结果，⽽不是班⻓点 名，⽼师勾选
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      1.6 接口隔离原则
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      客⼾端不应该依赖它不需要的接⼝，类间的依赖关系应该建⽴在最⼩的接⼝上
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      使⽤建议：接⼝设计尽量精简单⼀，但是不要对外暴露没有实际意义的接⼝。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⽤例：修改密码，不应该提供修改⽤⼾信息接⼝，⽽就是单⼀的最⼩修改密码接⼝，更不要暴 露数据库操作
     </span>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#1f2329">
      从整体上来理解六⼤设计原则，可以简要的概括为⼀句话，⽤抽象构建框架，⽤实现扩展细节，具体 到每⼀条设计原则，则对应⼀条注意事项：
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      单⼀职责原则告诉我们实现类要职责单⼀；
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      ⾥⽒替换原则告诉我们不要破坏继承体系；
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      依赖倒置原则告诉我们要⾯向接⼝编程；
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      接口隔离原则告诉我们在设计接口时要精简单一
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      迪米特原则告诉我们要降低类的耦合度
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      开闭原则告诉我们要对外开放拓展，关闭修改
     </span>
    </p>
    <h2>
     <span style="color:#1f2329">
      2 单例模式
     </span>
    </h2>
    <p>
     <span style="color:#1f2329">
      单例模式：⼀个类只能创建⼀个对象，即单例模式，该设计模式可以保证系统中该类只有⼀个实例，并提供⼀个访问它的全局访问点，该实例被所有程序模块共享。⽐如在某个服务器程序中，该服务器的配置信息 存放在⼀个⽂件中，这些配置数据由⼀个单例对象统⼀读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种⽅式简化了在复杂环境下的配置管理。
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      2.1 饿汉模式
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      饿汉模式: 程序启动时就会创建⼀个唯⼀的实例对象。 因为单例对象已经确定， 所以⽐较适⽤于多线程环境中， 多线程获取单例对象不需要加锁， 可以有效的避免资源竞争， 提⾼性能。
     </span>
    </p>
    <pre><code class="language-cpp">//饿汉模式
template&lt;class T&gt;
class server{
    private:
        server(){};
        ~server(){};
    public:
        server(const server&amp;) = delete;
        server&amp; operator=(const server&amp;) = delete;
        server&amp; getinstens()
        {
            return _etc;
        }
    private:
        static server&lt;T&gt; _etc;
};

template&lt;class T&gt;
server&lt;T&gt; server&lt;T&gt;::_etc;</code></pre>
    <h3>
     <span style="color:#1f2329">
      2.2 懒汉模式
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      懒汉模式:第⼀次使⽤要使⽤单例对象的时候创建实例对象。如果单例对象构造特别耗时或者耗费济源(加载插件、加载⽹络资源等)， 可以选择懒汉模式， 在第⼀次使⽤的时候才创建对象。
     </span>
    </p>
    <pre><code class="language-cpp">/ 懒汉模式
class Myclient{
    private:
        Myclient();
        ~Myclient();
    public:
        Myclient(const Myclient&amp;) = delete;
        Myclient&amp; operator=(const Myclient&amp;) = delete;
        Myclient* getinsten()
        {
            //线程不安全
            if(_cli == nullptr) _cli = new Myclient();
            return _cli;
        }
    private:
        static Myclient* _cli;
};</code></pre>
    <p>
     <span style="color:#1f2329">
      第一种方法写的懒汉模式明显线程不安全，我们可以通过加锁来让这个过程是线程安全的但是会增加额外的开销，这里并不提倡这种加锁的方式，我们这里采用Effective C++中提供的一个方式
     </span>
    </p>
    <pre><code class="language-cpp">Myclient* Myclient::_cli = nullptr;
template&lt;class T&gt;
class Myclient {
private:
    Myclient() {}
    ~Myclient() {}

public:
    Myclient(const Myclient&amp;) = delete;
    Myclient&amp; operator=(const Myclient&amp;) = delete;

    static Myclient&lt;T&gt;&amp; getInstance() {
        static Myclient&lt;T&gt; instance_;
        return instance_;
    }
};</code></pre>
    <h2>
     3 工厂模式
    </h2>
    <p>
     <span style="color:#1f2329">
      ⼯⼚模式是⼀种创建型设计模式， 它提供了⼀种创建对象的最佳⽅式。在⼯⼚模式中，我们创建对象 时不会对上层暴露创建逻辑，⽽是通过使⽤⼀个共同结构来指向新创建的对象，以此实现创建-使⽤的分离。
     </span>
    </p>
    <h3>
     3.1 简单工厂模式
    </h3>
    <p>
     <span style="color:#1f2329">
      简单⼯⼚模式: 简单⼯⼚模式实现由⼀个⼯⼚对象通过类型决定创建出来指定产品类的实例。假设有个⼯⼚能⽣产出⽔果，当客⼾需要产品的时候明确告知⼯⼚⽣产哪类⽔果，⼯⼚需要接收⽤⼾提供的类别信息，当新增产品的时候，⼯⼚内部去添加新产品的⽣产⽅式。
     </span>
    </p>
    <p>
     <img alt="" height="701" src="https://i-blog.csdnimg.cn/direct/44b05355c6e74dab826494942f6b608b.png" width="722"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
class Fruit
{
public:
    Fruit() {}
    virtual void show() = 0;
};
class Apple : public Fruit
{
public:
    Apple() {}
    virtual void show()
    {
        std::cout &lt;&lt; "我是⼀个苹果" &lt;&lt; std::endl;
    }
};
class Banana : public Fruit
{
public:
    Banana() {}
    virtual void show()
    {
        std::cout &lt;&lt; "我是⼀个⾹蕉" &lt;&lt; std::endl;
    }
};
class FruitFactory
{
public:
    static std::shared_ptr&lt;Fruit&gt; create(const std::string &amp;name)
    {
        if (name == "苹果")
        {
            return std::make_shared&lt;Apple&gt;();
        }
        else if (name == "⾹蕉")
        {
            return std::make_shared&lt;Banana&gt;();
        }
        return std::shared_ptr&lt;Fruit&gt;();
    }
};
int main()
{
    std::shared_ptr&lt;Fruit&gt; fruit = FruitFactory::create("苹果");
    fruit-&gt;show();
    fruit = FruitFactory::create("⾹蕉");
    fruit-&gt;show();
    return 0;
}</code></pre>
    <p>
     <span style="color:#1f2329">
      这个模式的结构和管理产品对象的⽅式⼗分简单， 但是它的扩展性⾮常差，当我们需要新增产品的时候，就需要去修改⼯⼚类新增⼀个类型的产品创建逻辑，违背了开闭原则。
     </span>
    </p>
    <h3>
     3.2 工厂方法模式
    </h3>
    <p>
     <span style="color:#1f2329">
      ⼯⼚⽅法模式: 在简单⼯⼚模式下新增多个⼯⼚，多个产品，每个产品对应⼀个⼯⼚。假设现在有A、B 两种产品，则开两个⼯⼚，⼯⼚ A 负责⽣产产品 A，⼯⼚ B 负责⽣产产品 B，⽤⼾只知道产品的⼯⼚名，⽽不知道具体的产品信息，⼯⼚不需要再接收客⼾的产品类别，⽽只负责⽣产产品。
     </span>
    </p>
    <p>
     <img alt="" height="734" src="https://i-blog.csdnimg.cn/direct/b769a97cec594bdf907f617a7a0fee87.png" width="990"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
class Fruit
{
public:
    Fruit() {}
    virtual void show() = 0;
};
class Apple : public Fruit
{
public:
    Apple() {}
    virtual void show()
    {
        std::cout &lt;&lt; "我是⼀个苹果" &lt;&lt; std::endl;
    }

private:
    std::string _color;
};
class Banana : public Fruit
{
public:
    Banana() {}
    virtual void show()
    {
        std::cout &lt;&lt; "我是⼀个⾹蕉" &lt;&lt; std::endl;
    }
};
class FruitFactory
{
public:
    virtual std::shared_ptr&lt;Fruit&gt; create() = 0;
};
class AppleFactory : public FruitFactory
{
public:
    virtual std::shared_ptr&lt;Fruit&gt; create()
    {
        return std::make_shared&lt;Apple&gt;();
    }
};
class BananaFactory : public FruitFactory
{
public:
    virtual std::shared_ptr&lt;Fruit&gt; create()
    {
        return std::make_shared&lt;Banana&gt;();
    }
};

int main()
{
    std::shared_ptr&lt;FruitFactory&gt; factory(new AppleFactory());
    std::shared_ptr&lt;Fruit&gt; fruit = factory-&gt;create();
    fruit-&gt;show();
    factory.reset(new BananaFactory());
    std::shared_ptr&lt;Fruit&gt; fruit2 = factory-&gt;create();
    fruit2-&gt;show();
    return 0;
}</code></pre>
    <p>
     <span style="color:#1f2329">
      ⼯⼚⽅法模式每次增加⼀个产品时，都需要增加⼀个具体产品类和⼯⼚类，这会使得系统中类的个数成倍增加，在⼀定程度上增加了系统的耦合度
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      3.3 抽象工厂模式
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      抽象⼯⼚模式: ⼯⼚⽅法模式通过引⼊⼯⼚等级结构，解决了简单⼯⼚模式中⼯⼚类职责太重的问题，但由于⼯⼚⽅法模式中的每个⼯⼚只⽣产⼀类产品，可能会导致系统中存在⼤量的⼯⼚类，势必会增加系统的开销。此时，我们可以考虑将⼀些相关的产品组成⼀个产品族（位于不同产品等级结构中功能相关联的产品组成的家族），由同⼀个⼯⼚来统⼀⽣产，这就是抽象⼯⼚模式的基本思想。
     </span>
     <img alt="" height="785" src="https://i-blog.csdnimg.cn/direct/7c197f7debb74145b4b5f961bcd55b27.png" width="1013"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
// 抽象⼯⼚：围绕⼀个超级⼯⼚创建其他⼯⼚。每个⽣成的⼯⼚按照⼯⼚模式提供对象。
//  思想：将⼯⼚抽象成两层，抽象⼯⼚ &amp; 具体⼯⼚⼦类， 在⼯⼚⼦类种⽣产不同类型的⼦产品
class Fruit
{
public:
    Fruit() {}
    virtual void show() = 0;
};
class Apple : public Fruit
{
public:
    Apple() {}
    virtual void show()
    {
        std::cout &lt;&lt; "我是⼀个苹果" &lt;&lt; std::endl;
    }

private:
    std::string _color;
};
class Banana : public Fruit
{
public:
    Banana() {}
    virtual void show()
    {
        std::cout &lt;&lt; "我是⼀个⾹蕉" &lt;&lt; std::endl;
    }
};

class Animal
{
public:
    virtual void voice() = 0;
};
class Lamp : public Animal
{
public:
    void voice() { std::cout &lt;&lt; "咩咩咩\n"; }
};
class Dog : public Animal
{
public:
    void voice() { std::cout &lt;&lt; "汪汪汪\n"; }
};

class Factory
{
public:
    virtual std::shared_ptr&lt;Fruit&gt; getFruit(const std::string &amp;name) = 0;
    virtual std::shared_ptr&lt;Animal&gt; getAnimal(const std::string &amp;name) = 0;
};

class FruitFactory : public Factory
{
public:
    virtual std::shared_ptr&lt;Animal&gt; getAnimal(const std::string &amp;name)
    {
        return std::shared_ptr&lt;Animal&gt;();
    }
    virtual std::shared_ptr&lt;Fruit&gt; getFruit(const std::string &amp;name)
    {
        if (name == "苹果")
        {
            return std::make_shared&lt;Apple&gt;();
        }
        else if (name == "⾹蕉")
        {
            return std::make_shared&lt;Banana&gt;();
        }
        return std::shared_ptr&lt;Fruit&gt;();
    }
};

class AnimalFactory : public Factory
{
public:
    virtual std::shared_ptr&lt;Fruit&gt; getFruit(const std::string &amp;name)
    {
        return std::shared_ptr&lt;Fruit&gt;();
    }
    virtual std::shared_ptr&lt;Animal&gt; getAnimal(const std::string &amp;name)
    {
        if (name == "⼩⽺")
        {
            return std::make_shared&lt;Lamp&gt;();
        }
        else if (name == "⼩狗")
        {
            return std::make_shared&lt;Dog&gt;();
        }
        return std::shared_ptr&lt;Animal&gt;();
    }
};
class FactoryProducer
{
public:
    static std::shared_ptr&lt;Factory&gt; getFactory(const std::string &amp;name)
    {
        if (name == "动物")
        {
            return std::make_shared&lt;AnimalFactory&gt;();
        }
        else
        {
            return std::make_shared&lt;FruitFactory&gt;();
        }
    }
};
</code></pre>
    <p>
     <span style="color:#1f2329">
      抽象⼯⼚模式适⽤于⽣产多个⼯⼚系列产品衍⽣的设计模式，增加新的产品等级结构复杂，需要对原有系统进⾏较⼤的修改，甚⾄需要修改抽象层代码，违背了“开闭原则”。
     </span>
    </p>
    <h2>
     4. 建造者模式
    </h2>
    <p>
     <span style="color:#1f2329">
      建造者模式：建造者模式是⼀种创建型设计模式， 使⽤多个简单的对象⼀步⼀步构建成⼀个复杂的对象，能够将⼀个复杂的对象的构建与它的表⽰分离，提供⼀种创建对象的最佳⽅式。主要⽤于解决对象的构建过于复杂的问题。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      建造者模式主要基于五个核⼼类实现：
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      抽象产品类
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      具体产品类：⼀个具体的产品对象类
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      抽象Builder类：创建⼀个产品对象所需的各个部件的抽象接⼝
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      具体产品的Builder类：实现抽象接⼝，构建各个部件
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      指挥者Director类：统⼀组建过程，提供给调⽤者使⽤，通过指挥者来构造产品
     </span>
    </p>
    <p>
     <img alt="" height="843" src="https://i-blog.csdnimg.cn/direct/b08e713d47314bd58bda4f0545f17673.png" width="1270"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
/*抽象电脑类*/
class Computer
{
public:
    using ptr = std::shared_ptr&lt;Computer&gt;;
    Computer() {}
    void setBoard(const std::string &amp;board) { _board = board; }
    void setDisplay(const std::string &amp;display) { _display = display; }
    virtual void setOs() = 0;
    std::string toString()
    {
        std::string computer = "Computer:{\n";
        computer += "\tboard=" + _board + ",\n";
        computer += "\tdisplay=" + _display + ",\n";
        computer += "\tOs=" + _os + ",\n";
        computer += "}\n";
        return computer;
    }

protected:
    std::string _board;
    std::string _display;
    std::string _os;
};
/*具体产品类*/
class MacBook : public Computer
{
public:
    using ptr = std::shared_ptr&lt;MacBook&gt;;
    MacBook() {}
    virtual void setOs()
    {
        _os = "Max Os X12";
    }
};
/*抽象建造者类：包含创建⼀个产品对象的各个部件的抽象接⼝*/
class Builder
{
public:
    using ptr = std::shared_ptr&lt;Builder&gt;;
    virtual void buildBoard(const std::string &amp;board) = 0;
    virtual void buildDisplay(const std::string &amp;display) = 0;
    virtual void buildOs() = 0;
    virtual Computer::ptr build() = 0;
};

/*具体产品的具体建造者类：实现抽象接⼝，构建和组装各个部件*/
class MacBookBuilder : public Builder
{
public:
    using ptr = std::shared_ptr&lt;MacBookBuilder&gt;;
    MacBookBuilder() : _computer(new MacBook()) {}
    virtual void buildBoard(const std::string &amp;board)
    {
        _computer-&gt;setBoard(board);
    }
    virtual void buildDisplay(const std::string &amp;display)
    {
        _computer-&gt;setDisplay(display);
    }
    virtual void buildOs()
    {
        _computer-&gt;setOs();
    }
    virtual Computer::ptr build()
    {
        return _computer;
    }

private:
    Computer::ptr _computer;
};

/*指挥者类，提供给调⽤者使⽤，通过指挥者来构造复杂产品*/
class Director
{
public:
    Director(Builder *builder) : _builder(builder) {}
    void construct(const std::string &amp;board, const std::string &amp;display)
    {
        _builder-&gt;buildBoard(board);
        _builder-&gt;buildDisplay(display);
        _builder-&gt;buildOs();
    }

private:
    Builder::ptr _builder;
};
</code></pre>
    <p>
    </p>
    <h2>
     5.代理模式
    </h2>
    <p>
     <span style="color:#1f2329">
      代理模式指代理控制对其他对象的访问， 也就是代理对象控制对原对象的引⽤。在某些情况下，⼀个对象不适合或者不能直接被引⽤访问，⽽代理对象可以在客⼾端和⽬标对象之间起到中介的作⽤。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      代理模式的结构包括⼀个是真正的你要访问的对象(⽬标类)、⼀个是代理对象。⽬标对象与代理对象实现同⼀个接⼝，先访问代理类再通过代理类访问⽬标对象。代理模式分为静态代理、动态代理：
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      静态代理指的是，在编译时就已经确定好了代理类和被代理类的关系。也就是说，在编译时就已经
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      确定了代理类要代理的是哪个被代理类。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      动态代理指的是，在运⾏时才动态⽣成代理类，并将其与被代理类绑定。这意味着，在运⾏时才能确定代理类要代理的是哪个被代理类。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      以租房为例，房东将房⼦租出去，但是要租房⼦出去，需要发布招租启⽰， 带⼈看房，负责维修，这些⼯作中有些操作并⾮房东能完成，因此房东为了图省事，将房⼦委托给中介进⾏租赁。 代理模式实现：
     </span>
    </p>
    <pre><code class="language-cpp">/*房东要把⼀个房⼦通过中介租出去理解代理模式*/
#include &lt;iostream&gt;
#include &lt;string&gt;
class RentHouse
{
public:
    virtual void rentHouse() = 0;
};
/*房东类：将房⼦租出去*/
class Landlord : public RentHouse
{
public:
    void rentHouse()
    {
        std::cout &lt;&lt; "将房⼦租出去\n";
    }
};
/*中介代理类：对租房⼦进⾏功能加强，实现租房以外的其他功能*/
class Intermediary : public RentHouse
{
public:
    void rentHouse()
    {
        std::cout &lt;&lt; "发布招租启⽰\n";
        std::cout &lt;&lt; "带⼈看房\n";
        _landlord.rentHouse();
        std::cout &lt;&lt; "负责租后维修\n";
    }

private:
    Landlord _landlord;
};
int main()
{
    Intermediary intermediary;
    intermediary.rentHouse();
    return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393634343931392f:61727469636c652f64657461696c732f313436323035373431" class_="artid" style="display:none">
 </p>
</div>


