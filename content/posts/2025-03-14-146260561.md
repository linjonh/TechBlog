---
layout: post
title: "OkHttp-的证书设置"
date: 2025-03-14 17:12:27 +0800
description: "可以有效增强 HTTPS 通信的安全性，防止中间人攻击（如抓包工具 Charles/Fiddler 的拦截）。是 HTTPS 协议的默认端口号，若服务器 HTTPS 端口自己设置的，则需要修改。如果需要更细粒度的控制（如仅信任特定证书）OpenSSL 要连接的 HTTPS 服务域名，计算 DER 格式公钥的 SHA256 哈希。（服务器证书的公钥 SHA256 哈希值）将公钥转换为 DER 格式（二进制）。替换为你实际要连接的服务器地址和端口。建立与目标服务器的 SSL 连接。从连接中提取证书的公钥部分。"
keywords: "OkHttp 的证书设置"
categories: ['未分类']
tags: ['Okhttp']
artid: "146260561"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146260561
    alt: "OkHttp-的证书设置"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146260561
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146260561
cover: https://bing.ee123.net/img/rand?artid=146260561
image: https://bing.ee123.net/img/rand?artid=146260561
img: https://bing.ee123.net/img/rand?artid=146260561
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     OkHttp 的证书设置
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Android 开发中，通过 OkHttp 自定义
     <code>
      SSLSocketFactory
     </code>
     和
     <code>
      X509TrustManager
     </code>
     可以有效增强 HTTPS 通信的安全性，防止中间人攻击（如抓包工具 Charles/Fiddler 的拦截）。以下是实现防抓包的关键技术方案：
    </p>
    <p>
     <strong>
      一、Okhttp设置固定证书
     </strong>
     （推荐）
    </p>
    <p>
     OkHttp 内置了证书固定功能，无需自定义
     <code>
      SSLSocketFactory
     </code>
     ，直接配置即可
    </p>
    <pre><code class="language-Kotlin">         val certificatePinner = CertificatePinner.Builder()
                .add("example.com:443", "sha256/+o+LjQ5sWk3ABG4Gl7yZib6xTZ6F7OQ09qW7P9G+Z/Y=")
                .build()
         httpClient.certificatePinner(certificatePinner)</code></pre>
    <p>
     1、
     <span style="color:#1c7331">
      example.com:
     </span>
     OpenSSL 要连接的 HTTPS 服务域名，
     <span style="color:#fe2c24">
      你需要替换为实际的目标域名
     </span>
    </p>
    <p>
     2、
     <span style="color:#1c7331">
      443:
     </span>
     是 HTTPS 协议的默认端口号，若服务器 HTTPS 端口自己设置的，则需要修改
    </p>
    <p>
     3、
     <span style="color:#1c7331">
      sha256/******
     </span>
     : OpenSSL 获取到的证书
    </p>
    <p>
     <strong>
      1、获取证书
     </strong>
     （服务器证书的公钥 SHA256 哈希值）
    </p>
    <p>
     在终端运行以下命令获取证书
    </p>
    <pre><code class="language-bash">openssl s_client -connect example.com:443 | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64</code></pre>
    <ol>
     <li>
      <p>
       <strong>
        连接到服务器
       </strong>
       ：
       <code>
        openssl s_client -connect example.com:443
       </code>
       建立与目标服务器的 SSL 连接。
       <span style="color:#fe2c24">
        注意⚠️：
        <code>
         example.com:443
        </code>
        替换为你实际要连接的服务器地址和端口
       </span>
      </p>
     </li>
     <li>
      <p>
       <strong>
        提取证书
       </strong>
       ：
       <code>
        openssl x509 -pubkey
       </code>
       从连接中提取证书的公钥部分。
      </p>
     </li>
     <li>
      <p>
       <strong>
        转换格式
       </strong>
       ：
       <code>
        openssl pkey -pubin -outform der
       </code>
       将公钥转换为 DER 格式（二进制）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        计算哈希
       </strong>
       ：
       <code>
        openssl dgst -sha256 -binary
       </code>
       计算 DER 格式公钥的 SHA256 哈希。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Base64 编码
       </strong>
       ：
       <code>
        openssl enc -base64
       </code>
       将二进制哈希值转换为 Base64 字符串。
      </p>
     </li>
    </ol>
    <p>
     二、
     <strong>
      自定义 SSLSocketFactory + X509TrustManager
     </strong>
    </p>
    <p>
     如果需要更细粒度的控制（如仅信任特定证书）
    </p>
    <h5>
     <strong>
      1. 创建自定义 TrustManager
     </strong>
    </h5>
    <pre><code class="language-Kotlin">class CustomTrustManager : X509TrustManager {
    private val trustedCertificates by lazy { loadTrustedCertificates() }

    private fun loadTrustedCertificates(): List&lt;X509Certificate&gt; {
        // 从 assets 或 raw 目录加载证书（如 .crt 或 .pem 文件）
        val inputStream = context.assets.open("certificate.crt")
        val certificateFactory = CertificateFactory.getInstance("X.509")
        return certificateFactory.generateCertificate(inputStream) as X509Certificate
    }

    override fun checkClientTrusted(chain: Array&lt;X509Certificate&gt;, authType: String) {
        // 客户端证书验证
        throw CertificateException("Client certificates not supported!")
    }

    override fun checkServerTrusted(chain: Array&lt;X509Certificate&gt;, authType: String) {
        // 验证服务器证书链是否与预置证书匹配
        if (!trustedCertificates.contains(chain[0])) {
            throw CertificateException("Untrusted server certificate!")
        }
    }

    override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt; = arrayOf()
}</code></pre>
    <p>
     <strong>
      2. 创建自定义 SSLSocketFactory
     </strong>
    </p>
    <pre><code class="language-Kotlin">class CustomSSLSocketFactory(private val trustManager: X509TrustManager) : SSLSocketFactory() {
        private val sslContext by lazy {
            SSLContext.getInstance("TLS").apply {
                init(null, arrayOf(trustManager), SecureRandom())
            }
        }

        override fun createSocket(s: Socket, host: String, port: Int, autoClose: Boolean): Socket {
            return sslContext.socketFactory.createSocket(s, host, port, autoClose)
        }

        // 其他重写方法（直接委托给 sslContext.socketFactory）
        override fun getDefaultCipherSuites(): Array&lt;String&gt; {
            sslContext.socketFactory.defaultCipherSuites
        }

        override fun getSupportedCipherSuites(): Array&lt;String&gt; {
            sslContext.socketFactory.supportedCipherSuites
        }

        override fun createSocket(host: String, port: Int): Socket {
            sslContext.socketFactory.createSocket(host, port)
        }

        override fun createSocket(host: String, port: Int, localHost: InetAddress, localPort: Int): Socket {
            sslContext.socketFactory.createSocket(host, port, localHost, localPort)
        }

        override fun createSocket(address: InetAddress, port: Int): Socket {
            sslContext.socketFactory.createSocket(address, port)
        }

        override fun createSocket(address: InetAddress, port: Int, localAddress: InetAddress, localPort: Int): Socket {
            sslContext.socketFactory.createSocket(address, port, localAddress, localPort)
        }

    }</code></pre>
    <h5>
     <strong>
      3. 配置 OkHttpClient
     </strong>
    </h5>
    <pre><code class="language-Kotlin"> val trustManager = CustomTrustManager()
    val sslSocketFactory = CustomSSLSocketFactory(trustManager)
    val okHttpClient =
        OkHttpClient.Builder()
            .sslSocketFactory(sslSocketFactory, trustManager)
            .hostnameVerifier { hostname, session -&gt;
                HttpsURLConnection.getDefaultHostnameVerifier().verify(hostname, session)
            }.build()</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031323233363933362f:61727469636c652f64657461696c732f313436323630353631" class_="artid" style="display:none">
 </p>
</div>


