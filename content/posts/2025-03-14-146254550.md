---
layout: post
title: "C-Primer学习笔记三"
date: 2025-03-14 12:36:34 +0800
description: "这是一篇关于《C++ Primer》学习笔记"
keywords: "《C++ Primer》学习笔记（三）"
categories: ['编程语言']
tags: ['笔记', '学习', 'C']
artid: "146254550"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146254550
    alt: "C-Primer学习笔记三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146254550
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146254550
cover: https://bing.ee123.net/img/rand?artid=146254550
image: https://bing.ee123.net/img/rand?artid=146254550
img: https://bing.ee123.net/img/rand?artid=146254550
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     《C++ Primer》学习笔记（三）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h6 style="margin-left:0px; margin-right:0px; text-align:justify">
     <span style="color:#0d0016">
      <strong>
       第三部分：类设计者的工具
      </strong>
     </span>
    </h6>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      1.一个类通过定义五种特殊的成员函数来控制拷贝、移动、赋值和销毁操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么，拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么，称这些操作为拷贝控制操作。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      2.如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值则此构造函数是拷贝构造函数。如果没有为一个类定义拷贝构造函数，编译器会定义一个，称为合成拷贝构造函数。与合成默认构造函数不同，即使定义了其他构造函数，编译器也会合成一个拷贝构造函数。一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝，内置类型的成员则直接拷贝。虽然不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝（P441）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      3.当使用直接初始化时，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。拷贝初始化通常使用拷贝构造函数来完成。拷贝初始化不仅发生在用=定义变量时，还会在以下情况中发生：将一个对象作为实参传递给一个非引用类型的形参、从一个返回类型为非引用类型的函数返回一个对象、用花括号列表初始化一个数组中的元素或一个聚合类中的成员。某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。当传递一个实参或从函数返回一个值时，不能隐式使用一个explicit构造函数，如果希望使用一个explicit构造函数，就必须显式地使用（P442）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      4.重载赋值运算符：重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。重载运算符的参数表示运算符的运算对象，某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递（P443）。与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个，称为合成拷贝赋值运算符。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      5.注意拷贝构造函数和拷贝赋值运算符的区别，如果是在对象初始化过程中使用”=”，则调用的是拷贝构造函数，而如果对象已经存在，此时使用”=”调用的是拷贝赋值运算符。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      6.析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数。由于析构函数不接受参数，所以不能被重载，对于一个给定的类，它的析构函数是唯一的。在一个析构函数中，首先执行函数体然后销毁成员，成员按初始化顺序的逆序销毁。在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的，在析构函数体执行完毕后，成员会自动被销毁。成员销毁时发生什么完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做（P445）。当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数，合成析构函数的函数体一般为空。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      7.有几个基本原则如下：如果一个类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符（否则可能出现二次delete等错误，具体可参考P447）。需要拷贝构造函数的类也需要拷贝赋值运算符，反之亦然。可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本，当在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样），如果不希望合成的成员是内联函数，应该只对成员的类外定义使用=default。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      8.可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝（例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲）。删除的函数是这样一种函数：虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出希望将它定义为删除的。与=default 不同，=delete 必须出现在函数第一次声明的时候。与=default的另一个不同之处是，可以对任何函数指定=delete（只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。值得注意的是，不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如果一个成员无法被销毁，则对象整体也就无法被销毁了。总之，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的拷贝控制成员函数（即拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数）将被定义为删除的，具体参考P450。在新标准之前，通过声明（但不定义）private的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      9.通常，若在一个类中需要管理类外资源，如通过动态分配的内存，则该类必须定义拷贝控制成员（即拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数），具体定义方式有两种：将类的行为定义的像一个值，即当拷贝一个对象时，副本和原对象是完全独立的，就像是整型的赋值；或者将类的行为定义的像一个指针，即当拷贝一个对象时，副本和原对象使用相同的底层数据，改变副本也会改变原对象，就像是指针的赋值，具体参考P453。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      10.除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的，这类算法在需要交换两个元素时会调用swap。如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap，标准库的swap为了交换两个对象可能需要进行一次拷贝和两次赋值，有时候会造成不必要的性能损失，所以通常编写类自己的swap函数（P458）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      11.新标准的一个最主要的特性是可以移动而非拷贝对象的能力，在新标准中，可以用容器保存不可拷贝的类型，只要它们能被移动即可。标准库容器、string和shared_ptr类既支持移动也支持拷贝，IO类和unique_ptr类可以移动但不能拷贝。可以通过&amp;&amp;来获得右值引用，右值引用有一个重要的性质：他只能绑定到一个将要销毁的对象上。类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。对于常规引用（为了与右值引用区分开来，可以称之为左值引用），不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上。由于右值引用只能绑定到临时对象上，所以其所引用的对象将要被销毁且该对象没有其他用户（P471）。虽然不能将一个右值引用直接绑定到一个左值上，但可以显式地将一个左值转换为对应的右值引用类型。还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。如：int &amp;&amp;rr3=std::move(rr1);，move 调用告诉编译器有一个左值，但希望像一个右值一样处理它。调用move 就意味着承诺除了对rr1赋值或销毁它外，将不再使用它。使用move的代码应该使用std::move而不是move，这样做可以避免潜在的名字冲突。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      12.为了让自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符，这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态，即销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象。不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept，noexcept用于承诺一个函数不会抛出异常，具体原因见P474。在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设，移后源的值在移动后处于什么状态取决于具体实现。只有当一个类没有定义任何自己版本的拷贝控制成员（即拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数），且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。什么时候将移动操作定义为删除delete的见P476。如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数，通常对于左值使用拷贝赋值，对于右值使用移动赋值。如果一个类有一个拷贝构造函数但未定义移动构造函数，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使试图通过调用move 来移动它们时也是如此，即用拷贝代替移动操作（P477）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      13.三五原则：所有五个拷贝控制成员（即拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数）应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作，这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      14.新标准库中定义了一种移动迭代器适配器，一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。通过调用标准库的make_move_iterator 函数可以将一个普通迭代器转换为一个移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器，具体用法参考P480。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      15.允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式：一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。一般来说不需要为函数操作定义接受一个const X&amp;&amp;或是一个（普通的）X&amp;参数的版本。因为当希望从实参“窃取”数据时，通常传递一个右值引用，为了达到这目的，实参不能是const的，因为要改变源数据中的指针。类似的，从一个对象进行拷贝的操作不应该改变该对象，因此通常不需要定义一个接受一个（普通的）X&amp;参数的版本。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      16.可以通过在成员函数后面加上引用限定符&amp;或&amp;&amp;来强制在调用成员函数时.左侧的运算对象是左值还是右值，类似const 限定符引用限定符只能用于(非static)成员函数，且必须同时出现在函数的声明和定义中。一个函数可以同时用const和引用限定，但引用限定符必须跟随在const限定符之后。就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本，而且可以综合引用限定符和const来区分一个成员函数的重载版本（P484）。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      17.重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，也就是说当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。另外只能重载已有的运算符，而无权发明新的运算符号。对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。如果是将运算符作为非成员函数重载，通常情况下将运算符作用于类型正确的实参，以这种间接方式“调用”重载的运算符函数，如：data1+data2;（data1和data2是重载运算符+的满足形参要求的类的对象）。但也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参，如：operator+(data1，data2);，如果是作为类的成员函数进行重载的，可以这样调用：data1+=data2;或data1.operator+=(data2);。运算符的重载版本无法保留求值顺序和短路求值属性，所以对于某些运算符，不应该重载他们，例如&amp;&amp;和||。还有一个原因使得一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应（P491）。运算符是否可以被重载参考下图：
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="338" src="https://i-blog.csdnimg.cn/direct/643d665c81744c82a077341af7b65b57.png" width="784"/>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      18.重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容，逻辑运算符和关系运算符应该返回 bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。当把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。究竟是将运算符重载为类的成员函数还是普通的非成员函数，选择标准可参考P493。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      19.输入输出运算符必须被重载为非成员函数，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元函数（P495）。通常情况下，会把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换，因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用（P497）。可以重载赋值运算符，但不论形参的类型是什么，赋值运算符都必须定义为成员函数（P500）。如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用，下标运算符必须是成员函数（P501）。定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员，因为他们改变的正好是所操作对象的状态。为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用，后置运算符可通过调用各自的前置版本来完成实际的工作。在重载时为了区分前置和后置，后置版本接受一个额外的（不被使用）int 类型的形参，当使用后置运算符时，编译器为这个形参提供一个值为0的实参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算，如operator++()表示前置版本，而operator++(int)表示后置版本（P503）。箭头运算符-&gt;永远不能丢掉成员访问这个最基本的含义，当重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。箭头运算符-&gt;必须是类的成员，解引用运算符*通常也是类的成员。对于point-&gt;mem的执行过程，按照point是指针还是重载了operator-&gt;的对象有不同解析和执行过程，具体参考P505。函数调用运算符()必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别，如果类定义了调用运算符，则该类的对象称作函数对象（P506）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      20.当编写了一个lambda表达式后，编译器将该表达式翻译成一个未命名类的未命名对象，若lambda表达式通过引用捕获变量则生成的未命名对象不会存储任何数据成员，若捕获的是值则会存储捕获的数据成员，具体参考P509。lambda 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      21.标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义成模板的形式，可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，plus&lt;string&gt;表示令string加法运算符作用于string对象，plus&lt;int&gt; intAdd; int sum=intAdd(10，20);的结果为sum值为30。下图所列的类型定义在 functional 头文件中：
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="260" src="https://i-blog.csdnimg.cn/direct/4d06630f3b404167a37e5f9dfb94e898.png" width="818"/>
    </p>
    <p style="margin-left:0; margin-right:0; text-align:justify">
     <span style="color:#0d0016">
      上述表示运算符的函数对象类常用来替换算法中的默认运算符。在默认情况下排序算法使用operator&lt;将序列按照升序排列，如果要执行降序排列的话，可以传入一个 greater类型的对象，该类将产生一个调用运算符并负责执行待排序类型的大于运算。例如，如果svec是一个vector&lt;string&gt;，可有sort(svec.begin()，svec.end()，greater&lt;string&gt;());，该语句将按照降序对svec进行排序（P510）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      22.C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind 创建的对象以及重载了函数调用运算符的类和其他对象一样，可调用的对象也有类型。例如，每个lambda有它自己唯一的未命名的类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。然而两个不同类型的可调用对象却可能共享同一种调用形式，调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如int(int， int)是一个函数类型，它接受两个 int、返回一个 int。可以用function类来管理这些具有相同调用形式的可调用对象，如下图：
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="418" src="https://i-blog.csdnimg.cn/direct/c2a15a48765a426f8f0ab64497b072e2.png" width="807"/>
    </p>
    <p style="margin-left:0; margin-right:0; text-align:justify">
     <span style="color:#0d0016">
      function 是一个模板，当创建一个具体的function 类型时必须提供额外的信息，如：function&lt;int(int，int)&gt; 声明了一个 function 类型，它可以表示接受两个 int、返回一个 int 的可调用对象。不能直接将重载函数的名字存入function类型的对象中，可以通过存储函数指针或使用lambda表达式来解决上述问题，消除二义性（P513）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      23.类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：operator type()const;，其中type 表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型，例如：operator int() const{return val;};该函数将类转换为int类型。因此不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值。类型转换运算符通常不应该改变待转换对象的内容，因此类型转换运算符一般被定义成const 成员。类型转换运算符是隐式执行的，某些时候可能会导致意外的结果，例如：cin&lt;&lt;i;会导致cin被隐式转换为int类型。可以通过explicit关键字显示定义类型转换运算符来防止错误的自动隐式转换，如：explicit operator int() const {return val;}，当类型转换运算符是显式定义时，也能执行类型转换，不过必须通过显式的强制类型转换才可以：static_cast&lt;int&gt;(si)+3;。但是如果表达式被用作条件，编译器会将显示定义的类型转换自动执行，如：while(std：：cin&gt;&gt;value)（P516）。在定义重载函数、转换构造函数和类型转换运算符时要合理定义，避免二义性（P517）。当调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，这是因为用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的。当通过类类型的对象（或者该对象的指针及引用）进行函数调用时，只考虑该类的成员函数。而当在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内（P521）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      24.通过继承联系在一起的类构成一种层次关系，通常在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。基类通过在其成员函数的声明语句之前加上关键字 virtual使得该函数成为虚函数执行动态绑定，任何构造函数之外的非静态函数都可以是虚函数，关键字virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此（P528）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      25.派生类必须通过使用类派生列表明确指出它是从哪个或哪些基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private（P529）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      26.派生类经常（但不总是）覆盖它继承的虚函数，如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在形参列表后面、或者在const成员函数的const 关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字 override。在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上（P530）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      27.尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分（P531）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      28.如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表。如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明，所以一个类不能派生它本身。一个类是基类，同时它也可以是一个派生类。每个类都会继承直接基类的所有成员。有时会定义这样一种类，我们不希望其他类继承它。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final（P533）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      29.当使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知，基类的指针或引用的静态类型可能与其动态类型不一致（P534）。之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上，并不存在基类向派生类的隐式类型转换。派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与期望的有所差别，实际上还是通过基类的构造函数或者赋值运算符参数中的基类引用类型的隐式转换实现的（派生类引用向基类的引用隐式转换，P535）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      30.动态绑定只有通过指针或引用调用虚函数时才会发生，如果通过普通类型的表达式访问虚函数如base.virt()（其中base是某个类，virt()是其虚函数成员）则不会发生动态绑定。在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数，在派生类的派生类中它也是虚函数。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*，只不过这样的返回类型要求从D到B的类型转换是可访问的（P537）。派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的，这时派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。在C++11新标准中可以使用override 关键字来说明派生类中的虚函数，这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以发现一些错误。如果使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错（P538）。只有虚函数才能被覆盖，还能把某个函数指定为final，如果已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误。和其他函数一样，虚函数也可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。换句话说，如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此，此时传入派生类函数的将是基类函数定义的默认实参。在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，使用作用域运算符可以实现这一目的（P539）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      31.纯虚函数：和普通的虚函数不一样，一个纯虚函数无须定义，可通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数，其中=0只能出现在类内部的虚函数声明语句处。纯虚函数是没有实际意义的，一般只声明不定义，但也可以为纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说不能在类的内部为一个=0的函数提供函数体。含有（或者未经覆盖直接继承：派生类没有重新覆盖定义基类中的纯虚函数，就会直接继承这个纯虚函数，所以此时派生类仍然是抽象基类）纯虚函数的类是抽象基类，抽象基类负责定义接口，而后续的其他类可以覆盖该接口。不允许（直接）创建一个抽象基类的对象（P541）。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      32.一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员，protected说明符可以看做是public和private中和后的产物：和私有成员类似，受保护的成员对于类的用户来说是不可访问的；和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的；派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权（不能直接通过基类对象来访问基类中受保护的成员，如直接访问base.prot，具体参考P543）。某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关。继承之后派生类中的访问权限参考下图：
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="179" src="https://i-blog.csdnimg.cn/direct/75bc3cc758de450c99b9c0b6b7d29d12.png" width="792"/>
    </p>
    <p style="margin-left:0; margin-right:0; text-align:justify">
     <span style="color:#0d0016">
      派生类向基类转换的可访问性（即是否可以转换），遵循的原则为：对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行，具体参考P544。每个类负责控制各自成员的访问权限，也就是说对基类的访问权限由基类本身控制，即使对于派生类中的基类部分成员也是如此（P545）。就像友元关系不能传递一样，友元关系同样也不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员，即不能继承友元关系。通过在类的内部使用using声明语句，可以将该类的直接或间接基类中的任何可访问成员（例如非私有成员）标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。也就是说，如果一条using声明语句出现在类的private部分，则该名字只能被类的成员和友元访问；如果using声明语句位于 public部分，则类的所有用户都能访问它；如果using声明语句位于protected部分，则该名字对于成员、友元和派生类是可访问的。派生类只能为那些它可以访问的名字提供using 声明。默认情况下，使用 class 关键字定义的派生类是私有继承的，而使用struct 关键字定义的派生类是公有继承的。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      33.每个类定义自己的作用域，在这个作用域内定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。和其他作用域一样，派生类也能重新定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。可以通过作用域运算符来使用一个被隐藏的基类成员，除了覆盖继承而来的虚函数以外，派生类最好不要重用其他定义在基类中的名字，类中被函数调用时具体的解析和查找过程见P549。定义派生类中的函数也不会重载其基类中的成员，和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉（注意隐藏和覆盖的区别）。基类与派生类中的虚函数必须有相同的形参列表，假如基类与派生类的虚函数接受的实参不同，就无法通过基类的引用或指针调用派生类的虚函数了（可以理解为如果形参列表不同实际上是在派生类中重新定义了一个同名的重载函数，因为基类中那个同名但形参不同的函数被隐式继承到派生类里面了，此时基类和派生类中的这俩函数是一模一样的）。和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖（只要在派生类中定义了一个同名函数，其他基类中的同名函数就被隐藏了，除了基类中的同名虚函数被隐式继承下来）。一种好的解决方案是为重载的成员提供一条using声明语句，这样就无须覆盖基类中的每一个重载版本了。using 声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义（前提是基类函数的每个实例在派生类中都必须是可访问的）（P551）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      34.当delete一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况，和其他函数一样，通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本，和其他虚函数一样，析构函数的虚属性也会被继承（P552）。基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作（注意是直接基类）。派生类中删除的拷贝控制与基类的关系：如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作；如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分；和过去一样，编译器将不会合成一个删除掉的移动操作。当使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分。在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝
     </span>
     <a name="_Hlk192845449">
      <span style="color:#0d0016">
       （或移动）
      </span>
     </a>
     <span style="color:#0d0016">
      基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数（P555）。与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。在析构函数体执行完成后，对象的成员会被隐式销毁，对象的基类部分也是隐式销毁的。对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。派生类对象的基类部分将首先被构建，当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。所以如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本。在C++11新标准中，派生类能够重用其直接基类定义的构造函数。尽管这些构造函数并非以常规的方式继承而来，但是为了方便，不妨称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数（默认、拷贝和移动构造函数是无法被继承的，除此之外的构造函数可以被继承）。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。派生类可以通过using声明来继承直接基类中的构造函数（默认、拷贝和移动构造函数除外），具体参考P557。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      35.一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。模板定义以关键字 template开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用小于号(&lt;)和大于号(&gt;)包围起来，如：
     </span>
    </p>
    <blockquote>
     <p style="margin-left:0; margin-right:0; text-align:justify">
      <span style="color:#0d0016">
       template &lt;typename T&gt;
      </span>
     </p>
     <p style="margin-left:0; margin-right:0; text-align:justify">
      <span style="color:#0d0016">
       int compare(const T &amp;v1, const T &amp;v2){
       <!-- -->
      </span>
     </p>
     <p style="margin-left:0; margin-right:0; text-align:justify">
      <span style="color:#0d0016">
       if(v1&lt;v2)return -1;
      </span>
     </p>
     <p style="margin-left:0; margin-right:0; text-align:justify">
      <span style="color:#0d0016">
       if(v2&lt;v1)return 1;
      </span>
     </p>
     <p style="margin-left:0; margin-right:0; text-align:justify">
      <span style="color:#0d0016">
       return 0;}
      </span>
     </p>
    </blockquote>
    <p style="margin-left:0; margin-right:0; text-align:justify">
     <span style="color:#0d0016">
      当调用一个函数模板时，编译器通常用函数实参来推断板实参。即当调用 compare 时，编译器使用实际传入的实参的类型来确定绑定到模板参数T的类型，编译器用推断出来的模版参数实例化一个特定版本的函数，这些编译器生成的版本通常被称为模版的实例。可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换（P579）。类型参数前必须使用关键字class或typename，在模板参数列表中，这两个关键字的含义相同，可以互换使用。除了定义类型参数，还可以在模板中定义非类型参数，一个非类型参数表示一个值而非一个类型，可通过一个特定的类型名而非关键字class或typename来指定非类型参数。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式，从而允许编译器在编译时实例化模板。一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用一个普通（非static）的局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化（P580）。函数模板可以声明为inline或constexpr的，如同非模板函数一样，inline或constexpr说明符放在模板参数列表之后，返回类型之前。泛型代码有两个重要原则：模版中的函数参数是const的引用（保证模版可用于不能拷贝的类型）；函数体中的条件判断仅使用&lt;比较运算（减少对实参类型的要求，增加代码可移植性）。当编译器遇到一个模板定义时，它并不生成代码。为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      36.与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，必须在模板名后的尖括号中提供额外信息。类似函数模板，类模板以关键字 template开始，后跟模板参数列表。一个类模板的每个实例都形成一个独立的类。与其他任何类相同，既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。类模板的成员函数本身是一个普通函数，类模板的每个实例都有其自己版本的成员函数，类模板的成员函数具有和模板相同的模板参数，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表，具体参考P586。与其他任何定义在类模板外的成员一样，在类模版外定义构造函数也要以关键字template和模板参数列表开始。默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化，如果一个成员函数没有被使用，则它不会被实例化。在一个类模板的作用域内，可以直接使用模板名而不必指定模板实参，例如若Blob&lt;T&gt;是一个类模板，则在该类模板的作用域内Blob等价于Blob&lt;T&gt;。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      37.当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例，具体参考P589。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      38.可以定义一个typedef来引用实例化的类，如：typedef Blob&lt;string&gt; StrBlob;，但是无法定义一个typedef来引用Blob&lt;T&gt;，新标准允许为类模板定义一个类型别名，如：template&lt;typename T&gt; using twin=pair&lt;T，T&gt;;，则twin&lt;int&gt; win;此句将win定义为一个pair&lt;int，int&gt;。与任何其他 static 数据成员相同，模板类的每个 static 数据成员必须有且仅有一个定义，但是类模板的每个实例都有一个独有的static对象。类似任何其他成员函数，一个static成员函数只有在使用时才会实例化（P591）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      39.类似函数参数的名字，一个模板参数的名字也没有什么内在含义，通常将类型参数命名为T，但实际上可以使用任何名字。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是与大多数其他上下文不同，在模板内不能重用模板参数名。由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次。与函数参数相同，声明中的模板参数的名字不必与定义中相同，但一个给定模板的每个声明和定义必须有相同数量和种类（即类型或非类型）的参数。对于形如T::size_type *p;的语句由于不知道T的具体类型，所以编译器无法知道该语句是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘，默认情况下C++假定这里的T::size_type不是类型，如果希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，可通过使用关键字 typename 来实现这一点：typename T:: size_type *p;，这里只能使用typename而不能使用class（P593）。就像能为函数参数提供默认实参一样，也可以提供默认模板实参，形式和普通函数的默认实参类似，与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时它才可以有默认实参（P594）。无论何时使用一个类模板，都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来，特别是如果一个类模板为其所有模板参数都提供了默认实参，且希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      40.一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数，这种成员被称为成员模板，成员模板不能是虚函数。与任何其他模板相同，成员模板也是以模板参数列表开始的。对于类模板，也可以为其定义成员模板，在此情况下类和成员各自有自己的、独立的模板参数。与类模板的普通函数成员不同，成员模板是函数模板，当在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表（P596）。为了实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。与往常一样，在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      41.当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重（即使在不同的源文件中都实例化了相同的模板函数或类，链接器会确保它们不会出现重复定义的问题，链接器在遇到多个相同的实例化时，会进行合并处理，通常是只保留一个符号）。在新标准中，可以通过显式实例化来避免这种开销：extern template declaration;//实例化声明，template declaration;//实例化定义，当编译器遇到extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义（P598）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      42.将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。一个模板类型参数可以用作多个函数形参的类型，由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。如果希望允许对函数实参进行正常的类型转换，可以将函数模板定义为两个类型参数：template &lt;typename A，typenameB&gt;int func(const A&amp; v1，const B&amp; v2);。函数模板可以有用普通类型定义的参数，即不涉及板类型参数的类型，这种函数实参不进行特殊处理，它们正常转换为对应形参的类型（P602）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      43.在某些情况下，编译器无法推断出模板实参的类型，其他一些情况下，我们希望允许用户控制模板实例化。如：T1 sum(T2，T3);编译器无法根据函数的参数推断出这个函数模版的返回类型，此时调用者必须为sum显示提供一个显示模版实参，如：auto val=sum&lt;long&gt;(i，j);，显式模板实参按由左至右的顺序与对应的模板参数匹配（这里的第一个指的是函数模版定义中的第一个模版参数），第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部(最右)参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。对于用普通类型定义的函数参数，允许进行正常的类型转换，出于同样的原因，对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换（P604）。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      44.有时为了让编译器自动推到模版函数的返回类型可以使用尾置返回类型，有时只能获取返回值的引用类型，可以使用remove_reference类型转换模版进行转换，具体参考P605，常见的类型转换模版如下图：
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="719" src="https://i-blog.csdnimg.cn/direct/a2a9c862306d47cd992909460ada0a7d.png" width="804"/>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      45.当用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值（P607）。当一个函数参数是模板类型参数的一个普通（左值）引用时（即形如T&amp;），只能传递给它一个左值（如一个变量或一个返回引用类型的表达式）。实参可以是const类型，也可以不是。如果实参是const的，则T将被推断为 const 类型。如果一个函数参数的类型是const T&amp;，可以传递给它任何类型的实参：一个对象（const或非const）、一个临时对象或是一个字面常量值。如果一个函数参数是指向模板参数类型的右值引用（如，T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）。这是由于“折叠”规则的存在：通常不能（直接）定义一个引用的引用，但是通过类型别名或通过模板类型参数间接定义是可以的。如果间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右值引用，只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X：X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp;&amp;都折叠成类型X&amp;；类型X&amp;&amp;&amp;&amp;折叠成X&amp;&amp;（P609）。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      46.虽然不能隐式地将一个左值转换为右值引用，但可以用static_cast显式地将一个左值转换为一个右值引用。如果一个函数参数是指向模板类型参数的右值引用(如T&amp;&amp;)，它对应的实参的 const 属性和左值/右值属性将得到保持。forward是一个标准库模版，forward返回显示实参类型的右值引用，即forward&lt;T&gt;返回类型为T&amp;&amp;，当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节，具体参考P613。
     </span>
    </p>
    <p style="text-align:justify">
     <span style="color:#0d0016">
      47.函数模板可以被另一个模板或一个普通非模板函数重载，与往常一样，名字相同的函数必须具有不同数量或类型的参数。如果涉及函数模板，则函数匹配规则有所变化，具体参考P615。一个可变参数模板就是一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为参数包。存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。可以用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或多个类型的列表，一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：template &lt;typename T，typename… Args&gt; void foo(const T &amp;t，const Args&amp;… rest); 声明了foo是一个可变参数函数模板，它有一个名为的类型参数，和一个名为Args的模板参数包。这个包表示零个或多个额外的类型参数，foo的函数参数列表包含一个const&amp;类型的参数，指向T的类型，还包含一个名为rest的函数参数包，此包表示零个或多个函数参数。与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数目。当需要知道包中有多少元素时，可以使用sizeof…运算符。类似sizeof，sizeof…也返回一个常量表达式，而且不会对其实参求值（P620）。对于一个参数包，除了获取其大小外，能对它做的唯一的事情就是扩展它。当扩展一个包时，还要提供用于每个扩展元素的模式。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。可通过在模式右边放一个省略号（…）来触发扩展操作，具体参考P621。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      48.编写单一模板，使之对任何可能的模板实参都是最适合的，都能实例化，这并不总是能办到，在某些情况下，通用模板的定义对特定类型是不适合的。当不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本（特例化可以理解为对一部分类型重新单独定义）。当特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参，为了指出正在实例化一个模板，应使用关键字template后跟一个空尖括号对(&lt;&gt;)。空尖括号指出我们将为原模板的所有模板参数提供实参。当定义函数模板的特例化版本时，本质上是接管了编译器的工作，即为原模板的一个特殊实例提供了定义。一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配（P626）。为了特例化一个模板，原模板的声明必须在作用域中。而且在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中，否则可能重新被编译器重新实例化，造成预期之外的结果。与函数模板不同，类模板的特例化不必为所有模板参数提供实参。可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性，只能部分特例化类模板，而不能部分特例化函数模板，可以只特例化特定成员函数而不是特例化整个模板（P629）。
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363335353638372f:61727469636c652f64657461696c732f313436323534353530" class_="artid" style="display:none">
 </p>
</div>


