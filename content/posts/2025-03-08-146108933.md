---
arturl_encode: "68747470733a2f2f626c:6f672e6373646e2e6e65742f544d313639353634383136342f:61727469636c652f64657461696c732f313436313038393333"
layout: post
title: "游戏引擎学习第144天"
date: 2025-03-08 00:49:13 +08:00
description: "补码是一种非常重要且高效的有符号整数表示方法，它让负数的表示和加法运算与正数相同，从而简化了计算机的运算逻辑。通过补码，计算机能够更高效地处理有符号数和无符号数的加法、减法等运算，而无需额外的符号判断和处理。总的来说，浮动点数不使用二进制补码主要是因为其运算过程中的指数部分和尾数部分需要独立处理，补码并不能有效地支持这种操作。使用偏移量表示法来编码指数值使得浮动点数的运算更为高效和简便。同时，补码表示对于浮动点数的运算并没有带来明显的优势，因此标准浮动点数表示方法并没有采用补码。"
keywords: "游戏引擎学习第144天"
categories: ['游戏引擎学习']
tags: ['游戏引擎', '学习']
artid: "146108933"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146108933
    alt: "游戏引擎学习第144天"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146108933
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146108933
cover: https://bing.ee123.net/img/rand?artid=146108933
image: https://bing.ee123.net/img/rand?artid=146108933
img: https://bing.ee123.net/img/rand?artid=146108933
---

# 游戏引擎学习第144天

## 今天的计划：对混音器进行SIMD化

今天的工作计划是对声音混音部分进行SIMD化优化。之前我们已经完成了大部分的声音混音功能，包括播放声音、流式处理、音调变化、音量调节等基本功能，但我想对其进行一些调整，特别是将其改成SIMD（单指令多数据）模式。这样做的目的是为了查看SIMD在这个架构中是否有任何影响，同时确保在处理样本时没有任何问题。

此任务的目标不是为了优化性能，而是为了确保我们在使用SIMD技术时，能够处理四个样本一批的操作，而且这个过程相对简单，不需要做过多复杂的工作。因此，今天的目标是对现有的声音代码进行简单的SIMD化处理，并检查是否能够顺利执行。

接下来我们会进入声音代码部分，目前的代码已经相对完整，主要包含了“播放声音”的功能，这个功能目前已经可以满足我们的需求。接下来我会将其转换为SIMD模式。如果你不熟悉SIMD或SSE，之前已经详细讲解过，如果不清楚的话，建议回看之前的讲解视频，这部分内容会有详细的解释。

在进行SIMD操作时，我们需要通过SIMD指令来批量处理数据，特别是对于x86架构的处理器，我们需要确保能够一次性处理至少四个数据样本。某些操作会比较直接，但也需要确保数据对齐。虽然我们可以使用非对齐数据进行处理，但为了性能和缓存优化，通常最好使用对齐的数据，这样会更高效，并且读取和写入速度也会更快。

## 对临时缓冲区进行对齐

我们计划确保临时缓冲区能够按照SIMD对齐的要求进行对齐。之前我们已经做过一些工作，确保可以对齐数据，如果需要16字节对齐的话，我们可以直接告诉分配器需要16字节对齐，这部分工作已经完成，因此现在我们可以继续进行。

接下来，我准备对混音通道的部分进行修改，首先清理掉混音通道的设置，然后看看是否能够将其改为适应SIMD处理的格式。为了确保输出的样本数总是4的倍数，我打算在代码中加入一个断言，强制要求输出的样本数始终是4的倍数。这可能需要我们回到平台层，确保在分配缓冲区时，始终将样本数四舍五入为4的倍数。

不过在思考的过程中，我意识到，实际上我并不真的需要关注这个问题。虽然我一开始认为这是必要的，但现在想来，这一点并不重要。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d34d718779da4870b8cdf69898ea0ad3.png#pic_center)

## 确保临时声音缓冲区足够大，能够容纳所有样本

这些是临时缓冲区，因此我们可以简单地说，我们只需要确保声音样本的数量能够容纳所有的样本，但实际上并不需要担心样本数量是否超出范围。因为在最后将样本复制到16位数值时，只有在那个阶段，我们才需要关心样本是否超出四倍样本的限制。

所以我们可以选择将样本数四舍五入到2的幂次方，这样就能确保缓冲区大小合适，同时也不需要担心其他不必要的超出问题。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/09b1051ce44d4a109ec9c53351f970e0.png#pic_center)

## 解释Align16

有时候我们在代码中用
`value + 15`
这样的方式，目的是为了将某个数值四舍五入到下一个16的倍数，这可能会让一些人感到困惑。基本上这是为了将数值向上舍入到最近的2的幂次倍数（比如16）。做这件事的最简单方式是加上
`(16 - 1)`
，也就是加上15，然后通过位运算将低于16的位清除掉，这样就能达到对齐的效果。
  
这个技巧其实是为了确保内存对齐，特别是在我们处理SIMD（单指令多数据流）时，通常需要按照特定的字节对齐（例如16字节对齐）来提高处理效率。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e061b09940b54d2c972ca2dd98486ce2.png#pic_center)

## 适用于任何2的幂次的对齐宏：AlignPow2

首先，代码的目标是确保音频样本的数量可以适配SIMD操作，并且需要处理一些与内存对齐和样本数相关的问题。为了保证对齐，可以使用一种技巧，将值加上15，然后通过位运算确保结果符合所需的对齐要求。这里使用的技巧是向上舍入到16的倍数，这种方式对于二的幂次倍数有效，而其他倍数则需要使用不同的方法。

接着，代码中的样本计数要进行处理，使其能够适应SIMD操作的要求。具体来说，样本计数会向上舍入为4的倍数（即每次处理4个样本），这可以通过一些位运算实现。为了分配适当的内存空间，程序会根据样本数量分配对应的内存，并确保每次处理的都是对齐的。

然后，清空缓存的过程也被处理。在初始化音频缓冲区时，需要确保每个缓冲区的值都被清零，可以使用SIMD指令来快速清零，这样能够更高效地完成初始化操作。

在音频混合过程中，浮动值会在一个范围内进行处理，而不是回到0到1的标准范围。这里的混音范围是从-3到+3，这样能更自然地处理音频信号，而不必将它们强制回到0到1范围内。因此，音频信号的处理会在这个范围内进行，避免了过多的转换，从而简化了计算过程。

总的来说，代码中的关键任务是确保音频数据的对齐、内存分配、缓冲区初始化以及混音范围的处理。这些步骤能够确保音频处理能够在SIMD架构下高效运行，并避免不必要的计算和转换。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a73def11239e4c12b8e18fda151a5719.png#pic_center)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/880c7ac9651e4fcb9ca5932d34410c38.png#pic_center)

## 将样本夹紧到有符号16位整数的范围

在讨论音频值的“限制”（clamping）时，目标是将音频值限制在16位有符号整数的范围内。尽管音频混合过程使用的是浮点数表示，但我们希望最终将值转换为16位有符号整数的最大值和最小值。因此，我们需要找到16位有符号整数的最大和最小值，并进行相应的处理。

首先，对于最大值，16位有符号整数的最大值是32767，即二进制表示为
`0111111111111111`
，其中最高位为0表示正数。为了得到这个值，实际操作时需要使用类似
`0x7FFF`
的表示方式。

对于最小值，16位有符号整数的最小值是-32768，即二进制表示为
`1000000000000000`
，其中最高位为1表示负数。为了表示这个最小值，我们需要使用
`0x8000`
的表示方式。在计算过程中，利用了二补码（Two’s complement）表示法，这是计算机中常用的一种符号数表示方法。

二补码表示法的优点是，它使得整数的加减法操作可以统一处理，不需要额外的符号位操作。对于负数，二补码通过对数值取反加一来表示负数，这使得计算机能够更加高效地执行加减运算。

最后，在处理这些音频值时，我们需要确保音频样本值在处理时不会超出16位有符号整数的范围。通过这种方式，混音结果可以得到有效的限制，从而避免数值溢出或不正确的音频结果。

简而言之，音频值的“限制”过程就是将浮点值映射到16位有符号整数的最大和最小值之间，以确保音频数据在合理的范围内。

## （中场休息）二进制补码

二进制数的表示和计算在计算机系统中非常重要，特别是对于有符号和无符号整数的表示。让我们从一个简单的四位二进制数开始讲解。

#### 无符号整数的表示：

一个4位的无符号整数能够表示的最大值是15，因为每一位的值分别代表1、2、4和8（从右到左）。如果每一位都设置为1，计算方式如下：

* 1 + 2 + 4 + 8 = 15

所以，这个4位的无符号数最大值是15，对应的二进制值是1111。

#### 有符号整数的表示：

有符号整数的表示需要区分正数和负数，因此需要用到符号位来标识。通常，计算机采用最高位（即最左边的位）作为符号位。如果符号位为1，则表示负数；如果符号位为0，则表示正数或零。

但如果直接将最高位作为符号位，剩余的位用于表示数值，会导致处理过程中的特殊情况。例如，如果两个数的符号不同，那么加法运算会变得复杂，需要进行符号判断和不同的运算。

#### 补码表示：

为了避免这种特殊情况，计算机采用了
**补码**
表示法。在补码中，负数的表示并不是在原有的无符号数值上加上一个符号位，而是通过将数字取反并加1来表示负数。这样做的好处是，负数和正数的加法操作都可以通过相同的加法运算来处理，不需要单独的加法规则。

例如，负数 -1 的补码表示是所有位为1（1111，对于4位来说），-2 的补码是 1110，-3 是 1101，以此类推。这种表示方式允许计算机在加法时避免特殊的符号处理。

#### 为什么使用补码：

使用补码的主要原因是，它允许计算机使用相同的加法电路来处理有符号和无符号数。无论是负数还是正数，加法运算规则完全相同，只是通过补码的方式让负数能够自然地表现出来。通过这种方式，计算机不需要区分符号位和数值位，它可以直接使用标准的加法操作。

#### 补码的优势：

* **简化运算**
  ：通过补码，所有的加法、减法运算都可以使用相同的硬件电路来实现，无需特殊处理负数。
* **表示范围**
  ：补码使得负数和正数的表示范围更加对称，负数的最大值（例如 -8）与正数的最大值（例如 7）相比，有一个额外的负数位。
* **溢出和回绕**
  ：当加法运算超过数值范围时，二进制表示会自动回绕。例如，两个最大值相加会回绕到最小值。

#### 进制范围：

考虑一个4位的补码系统，数值范围为 -8 到 +7，其中：

* 最大正数是 7（0111）。
* 最大负数是 -8（1000）。
    
  补码允许我们在表示负数时，使用与正数相同的二进制加法方式，而不需要进行特殊处理。

#### 补码的应用：

* **无需特殊符号检查**
  ：因为负数和正数的加法都通过相同的加法规则进行处理，硬件的实现更加简洁和高效。
* **溢出处理**
  ：当数值超出范围时，计算机会自动进行回绕处理，不需要额外的判断。

#### 总结：

补码是一种非常重要且高效的有符号整数表示方法，它让负数的表示和加法运算与正数相同，从而简化了计算机的运算逻辑。通过补码，计算机能够更高效地处理有符号数和无符号数的加法、减法等运算，而无需额外的符号判断和处理。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e401c743b4ea4620b4bb119b6d431105.png#pic_center)

## 回到SIMD

我们想要从源数据中读取数据，并将其转换为浮动点数（floating point values），而不是将数据转换成整型（casting down to integer）后逐一处理。问题在于我们并不清楚当前的缓冲区是否适合存储一个多于四倍的数量（multiple of four）。我们知道有一些数据，但我们不能确定输出的缓冲区大小是否合适。然而，解决方法很简单，我们可以确保输出缓冲区总是适合的，通过强制平台层始终给我们额外的填充空间，从而避免在循环中进行特殊的处理。

接下来，我们讨论如何将两个音频通道的浮动点数值转换成16位整数。我们已经有了现成的代码来处理这些数值，并知道该如何进行四舍五入。现在，我们需要确定哪个方法适合在这段代码中使用。例如，有的代码可以做截断（truncating），而其他则可以进行四舍五入（rounding），我们需要找到合适的函数来完成这个任务。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/52e3b176b37a4aa5ba28af712ad41f21.png#pic_center)

## 对样本进行四舍五入

我们正在使用
`_mm_cvtps_epi32`
这个函数来对数据进行四舍五入处理，这个函数能够将浮动点数转换为整数，而不是直接进行截断。通过这个方法，我们可以确保在读取源数据时，浮动点数会被自动四舍五入为整数，从而简化了处理过程。

具体来说，我们读取了源数据，然后通过这个函数进行了四舍五入。这样一来，浮动点数就变成了整数值，接下来我们可以将这些整数值继续处理。这一步非常直接简单，四舍五入后的结果就是我们想要的整数。

最终，我们得到了处理后的数据，已完成浮动点数到整数的转换，处理过程顺利，没有什么特别复杂的步骤。

## 从32位整数转换为16位整数。无需clamp！

接下来，我们需要将32位的浮动点数转换为16位整数，确保数据符合我们的输出要求。然而，虽然浮动点数经过四舍五入已经转变为整数，但是它们仍然是32位整数，而我们需要的是16位整数。

为了解决这个问题，我们需要对32位的整数进行降位转换，具体来说，就是将32位的整数转换为16位整数。在这方面，我们可以使用“打包（pack）”操作，来将32位整数打包成16位整数。

经过一些查找后，发现可以使用带符号饱和的打包方式。饱和意味着如果原始值大于16位整数的最大范围，值会被自动限制在16位整数的范围内。这样，我们无需手动进行数值修剪（clamping），因为饱和操作会自动处理超过范围的数值，将其限制为最大或最小值。

这种自动处理饱和的功能实际上非常方便，可以节省额外的处理步骤。接下来，我们可以使用这个方法将32位整数转换为16位整数，并确保数据的正确性。

不过，目前遇到的问题是，虽然数据已成功转换为16位整数，但它们还没有被交织（interleaved）。我们还需要对数据进行交织处理，确保它们按正确的格式排列。

## 寻找能交错16位值的内在指令

目前的问题是，虽然我们已经将32位浮动点数转换为16位整数，但这些16位整数并没有被交织在一起。换句话说，虽然数据已经被成功打包成一个缓冲区，但它们仍然是分散的，并没有按照我们期望的交替排列顺序存储。

最开始，数据存储在内存中以32位浮动点数的形式，并且排列在内存中的顺序可能像这样：L0、L1、L2、L3等，分别代表四个通道的浮动点数数据。然后，在进行打包操作后，数据会被整理成一个包含8个值的单一缓冲区，依然是32位整数，包含L0、L1、L2、L3等数据，但这些数据仍然不按交织的形式排列。

交织排列意味着我们希望数据按照交替的顺序排列，像这样：L0、R0、L1、R1、L2、R2、L3、R3，这样才能符合输出缓冲区的要求，因为输出缓冲区期望数据是交替排列的。为了达到这一点，我们需要将数据重新排列，确保每一对通道的数据交替存储。

目前，现有的“解包”操作（unpack）或“洗牌”操作（shuffle）并不能满足这个需求，特别是16位数据的交织洗牌功能似乎并不存在。我们可以使用一些16位的洗牌指令，但是这些指令并不适合我们的需求，因为它们只能操作数据的低部分，或者无法完全按我们需要的方式进行排列。

虽然可以通过某些指令对32位数据进行洗牌，但对于16位数据的交织，我们没有找到直接的解决方案。基于目前的选择，可能需要通过其他的方式或者额外的技巧来实现数据的交织处理。

## 在打包之前交错样本

为了实现数据的交织排列，可能需要提前对数据进行“洗牌”操作。我们可以在打包数据之前，先将数据按需要的顺序重新排列。这意味着在数据打包之前，先对左右声道的数据进行交织，将它们排列成交替的形式。

具体来说，可以通过使用一些解包操作（unpack）来实现数据的交织。我们可以先读取左声道和右声道的数据，然后执行“解包”操作，将左声道和右声道的数据交替排列。首先，使用一个低位解包操作（_mm_unpacklo_epi32），将两个通道的样本交替地排列。通过这种方式，将每对数据交替地放入内存中，得到交织后的结果。

接下来，再执行一个高位解包操作（_mm_unpackhi_epi32），对剩下的样本进行同样的操作。这样，左声道和右声道的数据就被正确地交织在一起，形成交替的排列顺序。

然后，使用打包操作（_mm_packs_epi32）将数据重新打包成一个连续的缓冲区，这时数据已经处于我们想要的交织顺序。打包操作会将数据压缩成16位整数，并且这些数据已经处于正确的顺序，可以直接写入输出缓冲区。

最终，可以直接将交织后的数据写入输出缓冲区，通过合适的样本转换操作完成数据的写入。这样，数据就能够按照期望的顺序输出，并且保证正确性。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6709219a74304c6080fca543b4556e6a.png#pic_center)

## 使用结构化输入进行调试输出

然而，仍然需要注意一个问题：是否会发生越界写入。在尝试运行时，发现可能存在越界写入的问题，这导致了没有听到声音。为了解决这个问题，需要确保在内存缓冲区写入时不会覆盖其他重要数据。通过检查代码发现，越界写入可能是由于处理缓冲区时没有正确管理内存边界，导致部分数据被错误覆盖。

总之，虽然数据转换和交织操作看起来都没有问题，但最终的输出没有声音，问题可能出在内存写入时没有正确控制边界。因此，下一步的任务是仔细检查内存管理，确保没有越界写入的情况发生。

## 在平台层填充缓冲区，确保始终有空间进行覆盖

首先，确认了程序中的处理逻辑大致是正确的，但需要确保在处理过程中正确地对缓冲区进行填充（padding）。为了保证处理数据时不会发生越界问题，必须在代码中确保始终为数据分配足够的空间。

具体来说，在确定辅助缓冲区大小时，应该确保它始终能被四整除。这样做是为了确保每个数据样本都有足够的空间，避免因空间不足而发生内存溢出或数据损坏。虽然辅助缓冲区的大小没有直接告诉我们需要多少空间，但通过计算样本数量和每个样本的大小，可以推算出所需的总空间大小。

每个样本是16位的（即2字节），因此可以根据样本的数量和每个样本的大小来确定所需的缓冲区空间。为了避免内存溢出，可以假设一个最大可能的超额空间，确保分配的缓冲区大小足够大，能够容纳所有数据。

最终，只要正确处理这些对齐和填充的问题，就可以确保程序在处理数据时不会出错，保证缓冲区操作的安全性。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d1e2cb6721fb49ba879fd9902852d7bd.png#pic_center)

## 去除不必要的Clamp操作

在调试过程中，发现了一个有趣的细节，之前以为需要手动进行数值的Clamp，但实际上，Clamp操作会在后续的打包（pack）步骤中自动完成。这是因为在执行32位到16位的转换时，打包操作会自动处理超出范围的数值，将其进行Clamp，而不需要我们显式地进行比较和判断。

这意味着，在将32位浮点数转换为16位整数时，系统会自动处理值的范围问题，不会导致溢出或无效的数值。这个过程非常简便，不需要额外的Clamp步骤。因此，原本需要自己手动实现的Clamp操作可以完全交给打包过程来处理，这也节省了开发中的一些复杂性。

总的来说，这个细节让整个流程变得更为简洁高效，避免了手动处理数值范围问题。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ddcc002f871a4a45b5deb6f04c28ba20.png#pic_center)

## 使用对齐的加载和存储

在这个过程中，我们可以通过使用
`store`
指令将数据存储到指定的位置，确保数据的对齐。具体来说，我们可以使用类似
`store`
指令的方式，将数据从寄存器存储到内存中，而在存储时，我们需要确保这些数据被正确对齐。这里可能还需要将数据转换为特定的类型，比如将其转换为浮点数指针（
`float*`
），尽管这一点并没有特别的理由，可能是系统要求这样做。

另外，在加载数据时，也可以使用类似的方式进行操作。例如，我们可以使用
`load`
指令加载数据，并确保加载的数据经过正确的转换。这个转换也是为了确保数据格式与存储格式兼容。在这一步，也同样需要将数据转换为浮点数指针类型，尽管并没有显而易见的原因。

最终，所有这些步骤使得我们的转换循环能够顺利进行，而代码的结构变得更加清晰和一致。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/65e2db214be14f0c976f54a742892155.png#pic_center)

## 下一集的计划

现在唯一需要做的事情就是确保混合循环可以处理宽度（for wide），这会稍微复杂一些，因为混合循环需要进行一些调整。我们需要确保样本数（SamplesToMix）总是符合宽度要求（for wide），同时要修复一些bug，确保处理音量时能够同步完成。

接下来，混合循环的处理会涉及到对样本的操作，其中包含了计算音量（volume）和样本的乘积。这部分的操作会在每次迭代中进行，最终输出一个正确的混合音频样本。需要特别注意的是，我们必须确保样本数在循环时是按照宽度（for wide）来处理的，这可能会稍微复杂一些。

此外，虽然可以通过使用掩码来避免强制为宽度（for wide），但将样本缓冲区始终保持为宽度对齐（multiple of 4）似乎是一个更合适的方案。这样可以确保在其他部分的代码中处理音频时，所有样本都按照4字节对齐，避免因不对齐引起的潜在问题。这样，所有的音频样本都可以保持同步处理。

最后，应该在平台代码中进行调整，确保样本数总是被四字节对齐（aligned by 4）。通过这种方式，可以确保每次处理的音频样本总是以宽度对齐的方式进行，避免出现任何不对齐的情况。这将使得音频处理更加稳定并且避免由于边界不对齐而导致的错误。

因此，下一步将在周一进行处理，确保所有音频样本都按照正确的宽度对齐进行操作。

## 更多的二进制补码。完整示例

关于二进制补码的讨论，可以从一个简单的例子开始。考虑一个三位的二进制数。对于无符号（unsigned）数，三位二进制数的值从 0 到 7，对应如下：

```
000 -> 0
001 -> 1
010 -> 2
011 -> 3
100 -> 4
101 -> 5
110 -> 6
111 -> 7

```

而对于有符号（signed）数，补码表示的范围不同，正数和零是一样的，但负数的表示会有不同的值。具体来说，当最高位（符号位）为 1 时，表示负数。例如：

```
000 -> 0
001 -> 1
010 -> 2
011 -> 3
100 -> -4
101 -> -3
110 -> -2
111 -> -1

```

补码的一个重要特性是，即使对这些值进行加法运算，仍然会得到正确的数学结果。比如如果加
`2`
和
`5`
，结果是
`7`
，无论是无符号还是有符号运算。

然后，如果考虑负数和加法，情况会稍微复杂一些。例如，负数的加法操作会以补码的形式自动处理。假设我们将
`-3`
与
`2`
相加，得到的结果是
`-1`
，这是补码的正确计算结果。

补码的优点是，它允许在加法器和减法器上使用相同的电路进行计算。通过补码的表示方式，计算机能够使用统一的硬件架构来处理加法、减法等运算，而不需要为负数特别设计不同的电路，这样更高效。

此外，乘法运算也是一样的，乘法会自动处理正数和负数。例如，如果将
`-1`
乘以
`2`
，期望得到
`-2`
，而实际计算也能得到正确的结果。

在讨论二进制补码时，还涉及了溢出问题。例如，如果将
`7`
乘以
`2`
，结果是
`14`
，但是由于表示范围的限制，二进制只能表示从
`0`
到
`7`
，溢出的部分会被丢掉。对于溢出情况，可以通过模运算（例如
`14 % 7`
）来理解溢出的结果，最终得到的是正确的结果。

补码的核心概念是，无论进行加法、减法还是乘法，补码都能够保证计算的正确性和高效性。而如果使用其他编码方式（如原码或反码），则需要针对负数和正数进行特殊处理，这会使得运算更加复杂和低效。

总的来说，补码使得计算机能够高效地处理正负数的运算，简化了硬件设计，并避免了特殊情况的处理。

## 为什么二进制补码没有用在浮点数上，如果它能使有符号的算术变得更简单？

关于为什么浮动点数不使用二进制补码（two’s complement）来表示，首先可以从浮动点数的编码方式来思考。浮动点数通常是由三部分组成：符号位、指数位和尾数（mantissa）。符号位表示数值的正负，指数部分用于表示该数字的指数，而尾数则表示有效数字。

#### 浮动点数的编码

在浮动点数的标准表示中，通常会将一个隐含的1加到尾数部分。因此，浮动点数的表示方式可以理解为“1.xxxx * 2^n”的形式，其中n是指数值。这里的关键是指数部分，它表示数值的大小范围，而尾数部分则表示小数部分的精确度。

#### 为什么不使用二进制补码？

在补码系统中，负数的表示通过改变数值的符号位来实现。对于整数，补码使得加法和减法非常简单高效。然而，在浮动点数中，除了符号位以外，指数部分和尾数部分都需要处理不同的操作方式，这使得直接使用补码变得不太适用。

首先，浮动点数运算（如加法、乘法等）主要是通过对指数部分进行操作来完成的。浮动点数加法时，通常会对两个数的指数进行对齐，然后再对尾数进行加法运算。如果使用补码，指数部分的负数表示和尾数的处理可能会导致不必要的复杂性，因为指数部分的操作需要更高的灵活性来处理范围变动。

#### 指数的偏移量表示法（Bias）

浮动点数通常使用偏移量表示法（Bias）来存储指数值，而不是使用补码。指数值加上一个固定的偏移量（比如偏移量为64）来表示实际的指数。这种表示方法避免了直接使用补码的复杂性，同时也简化了浮动点数比较和排序的过程。如果直接使用补码表示指数，则会增加额外的复杂性，特别是在进行浮动点数比较时。

#### 偏移量的使用

在浮动点数的表示中，指数通常不会直接存储为补码，而是采用一个所谓的“偏移量表示法”。例如，对于IEEE 754标准的浮动点数，指数部分会加上一个偏移量（如对于32位浮动点数，偏移量为127），这样可以使得指数值总是非负。这样做的好处是简化了浮动点数的加法和比较运算。

#### 总结

总的来说，浮动点数不使用二进制补码主要是因为其运算过程中的指数部分和尾数部分需要独立处理，补码并不能有效地支持这种操作。使用偏移量表示法来编码指数值使得浮动点数的运算更为高效和简便。同时，补码表示对于浮动点数的运算并没有带来明显的优势，因此标准浮动点数表示方法并没有采用补码。

## 你不打算做性能分析，看看它变得有多快吗？

在目前的阶段，并没有计划对音频处理部分进行性能分析。主要的目标是确保音频处理能够支持“wide”模式的运行，而不是优化性能。尽管优化可能是以后会考虑的内容，但目前更多的是关注于确保程序的基本功能能够正常工作。

## 当你实现音频流的分块加载时；我相信代码实际上会加载整个文件（使用平台层的VirtualAlloc）每次处理一个块。这只是调试模式下的代码特性吗？

在实现音频流处理时，当前的代码会将整个文件加载到内存中，且以一种非常简化的方式进行处理，这种方式主要是为了调试的便利。具体来说，所有的加载代码最终都会被替换成从资产文件中拉取数据的逻辑。对于调试时使用的加载方法，比如调试加载WAV文件或位图的代码，这些只是临时的，并不需要在最终版本中保留。因此，调试代码的内存分配方式不影响最终的功能，只要它们不会导致程序崩溃，就不需要关心它们如何执行。调试代码的唯一目的是为测试提供数据。

## 音频会影响调试模式下的帧率吗？

在调试模式下，音频流的加载会影响帧率，特别是当渲染错误发生时，帧率会大幅降低。即使将分辨率调低，帧率依然会受到影响。在调试模式下，渲染性能比较低，而在发布版本中，渲染会更加流畅。因此，调试版本的性能通常较差，而发布版本的优化较好，这是因为软件光栅化器的优化不足。

针对性能问题，有考虑过进行一些优化，特别是通过将渲染代码单独编译并启用优化。这意味着可以只编译渲染相关的代码，并在编译时启用优化，从而提升性能。为了实现这一点，可以通过手动优化代码，并将其编译为一个目标文件，而不生成完整的可执行文件。这样可以确保只优化渲染代码，并避免其他不必要的调试内容。

此外，为了避免链接错误，可以修改代码来跳过静态函数的处理。通过设置预处理宏，可以在调试时控制哪些部分的代码被优化，从而简化问题。如果要完成这个步骤，可能需要对一些外部符号进行处理，例如调整对全局内存的引用。

最后，优化过程的关键是将渲染循环单独处理，以确保其在调试模式下保持优化。而其他部分的代码可以保持在调试模式下，这样就能保证在测试时能够平衡性能和调试信息的完整性。

## 如果1111（-1）应该小于0000（0），那么CPU级别上的数字比较是如何工作的？

在讨论数字比较时，问题提出了如何处理一个值在二进制形式下的符号问题。例如，比较一个值
`1111`
是否小于
`0000`
。回答认为数字比较是通过特殊处理来实现的，而不是采用通用的比较方式。可以通过查看汇编代码来深入了解这个过程。

举例来说，给定一个带符号的数值（例如 -100）和两个无符号数值，进行比较时，会先加载这些值，然后比较它们。汇编代码会通过执行
`CMP`
指令（比较指令），实际上是通过将这两个值相减来进行比较，然后根据结果跳转。通过观察汇编代码，比较操作不会特别区分有符号和无符号数，只要按照指定的逻辑执行相应的比较即可。

汇编指令
`CMP`
会将两个操作数相减，然后设置状态标志，标志的设置方式与
`SUB`
（减法）指令相同。通过查看这些标志，可以判断出两个数的大小关系。无论是带符号数还是无符号数，基本上都可以通过检查结果的符号（是否为负）来得出比较结果。例如，在进行
`2 - (-3)`
或
`(-1) - 2`
时，得到的结果可以用来确定哪个值更大或更小。

在比较时，通过将两个数相减并观察结果的符号，可以得出它们的大小关系。即使是无符号数，通过这种方法依然能够正确得出比较结果。这是因为比较结果最终是通过符号来判断的，而不需要特别处理符号位。对于比较值是否大于或小于，只要通过计算结果的符号即可得到正确的判断。

总结来说，通过减法指令和符号标志的运用，可以非常简便地完成数字的大小比较，而不需要额外对有符号和无符号数进行特别的区分。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6aa6067aa77e4d4e9d7bb9b78a8ce7be.png#pic_center)