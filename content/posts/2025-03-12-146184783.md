---
layout: post
title: "react__jsx语法"
date: 2025-03-12 14:59:22 +0800
description: "本文集中介绍了react中jsx语法的基础知识"
keywords: "react__jsx语法"
categories: ['React']
tags: ['前端', 'React', 'Javascript']
artid: "146184783"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146184783
    alt: "react__jsx语法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146184783
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146184783
cover: https://bing.ee123.net/img/rand?artid=146184783
image: https://bing.ee123.net/img/rand?artid=146184783
img: https://bing.ee123.net/img/rand?artid=146184783
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     react__jsx语法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在我看来，写在return里面的内容属于jsx
    </p>
    <p>
     1、在jsx中可以使用
     <span style="color:#b95514">
      <strong>
       大括号
      </strong>
     </span>
     来识别表达式
    </p>
    <p>
     大括号里可以写：引起来的字符串
    </p>
    <p>
     大括号里可以写：javascript变量
    </p>
    <p>
     大括号里可以写：函数调用和方法调用
    </p>
    <p>
     大括号里可以写：javascript对象
    </p>
    <p>
     2、在jsx中实现
     <span style="color:#b95514">
      <strong>
       列表渲染
      </strong>
     </span>
     可以使用map方法
    </p>
    <pre><code class="language-javascript">const list = [
    {
        id:'001',
        name:'d'
    },
    {
        id:'002',
        name:'q'
    },
    {
        id:'003',
        name:'s'
    }
}

&lt;ul&gt;
    { list.map(item=&gt; &lt;li key={item.id}&gt;item.name&lt;/li&gt;) }
&lt;/ul&gt;</code></pre>
    <p>
     3、在jsx中实现
     <span style="color:#ad720d">
      <strong>
       条件渲染
      </strong>
     </span>
     可以使用逻辑运算符或者三元表达式
    </p>
    <pre><code class="language-javascript">对于一些基础的条件渲染：

{ true &amp;&amp; &lt;h1&gt;dqs&lt;/h1&gt; }

{ true? &lt;h1&gt;dqs&lt;/h1&gt; :&lt;h1&gt;dhj&lt;/h1&gt; }

对于复杂的条件渲染：

let articleType = 6

const thisContent = ()=&gt;{
  if(articleType === 0){
    return &lt;h1&gt;我是0&lt;/h1&gt;
  }else if(articleType === 1){
    return &lt;h1&gt;我是1&lt;/h1&gt;
  }else{
    return &lt;h1&gt;我什么也不是&lt;/h1&gt;
  }
}

</code></pre>
    <p>
     4、
     <span style="color:#ad720d">
      <strong>
       事件绑定
      </strong>
     </span>
    </p>
    <pre><code class="language-javascript">on + 事件名称 = { 事件处理程序 }

const handleClick  = ( e )=&gt;{ }

不带参数： 

onClick = { handleClick }

带参数：

onClick = { ()=&gt; handleClick("dqs") }

带e带参数：

onClick = { (e)=&gt; handleClick("dqs" , e) } </code></pre>
    <p>
     5、
     <span style="color:#b95514">
      <strong>
       react组件
      </strong>
     </span>
    </p>
    <p>
     关于组件的声明其实就是一个首字母大写的函数，渲染组件把函数名当成标签来写
    </p>
    <pre><code class="language-javascript">//内部存放了组件的逻辑和视图UI
function MainBox (){
    return (

    )
}

function Main (){
    return (
        &lt;Mainbox&gt;&lt;/Mainbox&gt;
    )
}</code></pre>
    <p>
     6、react
     <span style="color:#0d0016">
      hook 函数
     </span>
    </p>
    <p>
     <span style="color:#b95514">
      <strong>
       react hook函数使用规则：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      1、只能在组件中或者其他自定义的hook函数中调用
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      2、只能在组件的顶层调用，不能在if for 或者其他函数中
     </span>
    </p>
    <p>
     <strong>
      useState
     </strong>
     ：允许我们向组件添加一个状态变量，从而影响组件渲染的结果。
    </p>
    <p>
     注：与普通js不同，
     <span style="color:#0d0016">
      状态变量一旦发生变
     </span>
     化，视图UI也会跟着变化，
     <span style="color:#fe2c24">
      数据驱动视图
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
     </span>
     <span style="color:#333333">
      useState是一个函数，返回值是一个数组，
     </span>
    </p>
    <p>
     <span style="color:#333333">
      第一个值为状态变量，
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      第二个值是用来修改状态变量的函数，用该set函数修改视图才会更新，
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      useState的参数将作为状态变量的初始值。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      对于对象类型的变量：
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      let [user , setUser] = useState({name:'Jack'})
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      setUser(
      <br/>
      {
      <br/>
      ...user,
      <br/>
      name:'dqs'
      <br/>
      }
      <br/>
      )
     </span>
    </p>
    <p>
     <strong>
      useRef
     </strong>
     ：主要用于在react中获取/操作dom
    </p>
    <p>
     注：const inputRef = useRef(null)
    </p>
    <p>
     &lt;input type='text' ref={inputRef} /&gt;
    </p>
    <p>
     其中inputRef.current可用来获取
    </p>
    <p>
     <strong>
      useEffect
     </strong>
     ：用于在react中不是由事件引起，而是由渲染本身引起的操作,例:ajax请求，更改dom
    </p>
    <p>
     写法：useEffect(()=&gt;{
     <!-- -->
    </p>
    <p>
     },[])
    </p>
    <p>
     注：第一个为副作用函数，放置要执行的操作
    </p>
    <p>
     第二个防止依赖项，若为空，则只在渲染完执行一次
    </p>
    <p>
     关于依赖项注解：
    </p>
    <p>
     没有依赖项时，则在初始渲染时和组件更新时执行一次
    </p>
    <p>
     依赖项为空数组时，则仅仅在初始渲染时执行一次
    </p>
    <p>
     添加了特定依赖项，则在初始渲染时和依赖项变化时执行一次
    </p>
    <p>
     清除副作用：
    </p>
    <p>
     清理副作用函数最常见的执行时机是在组件卸载时自动执行
    </p>
    <p>
     return ()=&gt;{    //清除副作用逻辑
    </p>
    <p>
     }
    </p>
    <p>
     <strong>
      自定义hook：
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     自定义hook是以use打头的函数，通过自定义hook函数可以实现逻辑的封装和复用
    </p>
    <p>
     7、基础
     <span style="color:#b95514">
      <strong>
       样式控制
      </strong>
     </span>
    </p>
    <p>
     <strong>
      <span style="color:#0d0016">
       行内样式：
      </span>
     </strong>
    </p>
    <p>
     style={ { color:'red' } }
    </p>
    <p>
     <strong>
      类名控制：
     </strong>
    </p>
    <p>
     className='container'
    </p>
    <p>
     如果需要动态类名控制：可以选用classnames库
    </p>
    <p>
     className={classNames('foot' , {active: type === item.type})}
    </p>
    <p>
     8、受控表单绑定
    </p>
    <p>
     对于react input输入框和state数据的双向绑定
    </p>
    <pre><code class="language-javascript">let [count , setCount] = useState(1)

&lt;input/
    type='text',
    value={count}
    onChange={(e)=&gt;setCount(e.target.value)}
&gt;</code></pre>
    <p>
     9、
     <span style="color:#b95514">
      <strong>
       组件通信
      </strong>
     </span>
    </p>
    <p>
     <strong>
      父子通信：
     </strong>
    </p>
    <p>
     父传子：传递数据，在子组件标签上绑定属性
    </p>
    <p>
     &lt;Son name={"dqs"}&gt;&lt;/Son&gt;
    </p>
    <p>
     子组件通过props参数接受数据
    </p>
    <p>
     function Son(props){
    </p>
    <p>
     }
    </p>
    <p>
     props说明：其中props是一个对象
    </p>
    <p>
     可传递任意对象：数值 字符串 布尔值 数组 对象 函数 JSX
    </p>
    <p>
     子组件中只能读取，不能修改
    </p>
    <p>
     引用的子组件时，标签内部可以写内容，用props.children来接收。
    </p>
    <p>
     子传父：在子组件中调用父组件的函数，并携带参数
    </p>
    <p>
     父组件中声明函数，传给子组件，
    </p>
    <p>
     子组件接受并触发，带个参数
    </p>
    <p>
     <strong>
      兄弟通信：
     </strong>
    </p>
    <p>
     1、通过子传父先传给父组件
    </p>
    <p>
     2、通过父传子再传给另一个子组件
    </p>
    <p>
     <strong>
      跨层通信：
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     使用context机制来实现跨层通信
    </p>
    <p>
     1、使用createContext创建一个上下文对象Ctx， const Ctx = createContext()
    </p>
    <p>
     2、在顶层组件通过Ctx.provider组件提供数据 ，
    </p>
    <p>
     &lt;Ctx.Provider value={name}&gt;&lt;/Ctx.Provider&gt;
    </p>
    <p>
     3、在底层组件中通过useContext来获取数据
    </p>
    <p>
     const value = useContext(Ctx)
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34333835323631322f:61727469636c652f64657461696c732f313436313834373833" class_="artid" style="display:none">
 </p>
</div>


