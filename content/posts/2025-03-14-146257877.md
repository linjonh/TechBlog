---
layout: post
title: "深入理解静态与动态代理设计模式从理论到实践"
date: 2025-03-14 17:02:29 +0800
description: "切入点:额外功能加入的位置目的:由程序员根据自己的需要，决定额外功能加入倒哪个原始方法中rigisterlogin简单测试:所有方法都作为切入点 加入额外功能-- 所有的方法 都作为切入点 加入额外功能 login register-->"
keywords: "深入理解静态与动态代理设计模式：从理论到实践"
categories: ['Spring']
tags: ['开发语言', '后端', 'Spring', 'Java']
artid: "146257877"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257877
    alt: "深入理解静态与动态代理设计模式从理论到实践"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257877
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257877
cover: https://bing.ee123.net/img/rand?artid=146257877
image: https://bing.ee123.net/img/rand?artid=146257877
img: https://bing.ee123.net/img/rand?artid=146257877
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深入理解静态与动态代理设计模式：从理论到实践
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     静态代理设计模式
    </h2>
    <h3>
     1.为什么需要代理设计模式？
    </h3>
    <ul>
     <li>
      javaEE分层开发中，哪个层次对于我们来讲最重要
     </li>
    </ul>
    <blockquote>
     <p>
      DAO----&gt;Service----&gt;Controller
     </p>
     <p>
     </p>
     <p>
      JavaEE分层中，最为重要的是Service层
     </p>
    </blockquote>
    <ul>
     <li>
      Service层包含了那些代码
     </li>
    </ul>
    <blockquote>
     <p>
      Service层=核心功能(几十行 上百代码) +额外功能(附加功能)
     </p>
     <p>
     </p>
     <p>
      <strong>
       <span style="color:#6eaad7">
        1.核心功能
       </span>
      </strong>
     </p>
     <p>
      业务运算
     </p>
     <p>
      DAO调用
     </p>
     <p>
      <strong>
       <span style="color:#6eaad7">
        2.额外功能
       </span>
      </strong>
     </p>
     <p>
      1.不属于业务
     </p>
     <p>
      2.可有可无
     </p>
     <p>
      3.代码量很小
     </p>
     <p>
      事务、日志、性能
     </p>
     <p>
     </p>
     <p>
      <img alt="" height="573" src="https://i-blog.csdnimg.cn/direct/c936786296ab4a0f8d524c388b9ea03f.png" width="1032"/>
     </p>
    </blockquote>
    <ul>
     <li>
      额外功能书写在Service层中好不好？
     </li>
    </ul>
    <blockquote>
     <p>
      Service层调用者角度(Controller):需要再Service层中书写额外功能
     </p>
     <p>
      <span style="color:#e6b223">
       软件设计者:Service层不需要额外功能
      </span>
     </p>
    </blockquote>
    <h3>
     现实生活中的解决方案
    </h3>
    <blockquote>
     <p>
      对话例子:
     </p>
     <h5>
      <strong>
       场景 1：直接找房东租房（无代理模式）
      </strong>
     </h5>
     <p>
      <strong>
       房客
      </strong>
      ：你好，我想租你的房子，能带我看看吗？
     </p>
     <p>
      <strong>
       房东
      </strong>
      ：额……我只负责签合同，广告、带看这些不归我管，你自己去找吧。
     </p>
     <p>
      <strong>
       房客
      </strong>
      ：（无奈）这太麻烦了，我得自己找房源、安排时间，还可能被忽悠。
     </p>
     <h5>
      <strong>
       场景 2：通过中介租房（静态代理）
      </strong>
     </h5>
     <p>
      <strong>
       房客
      </strong>
      ：你好，我想租房，你能帮我介绍吗？
     </p>
     <p>
      <strong>
       中介
      </strong>
      ：当然！我这有很多房源信息，还能带你去看房，满意的话就签合同。
     </p>
     <p>
      （中介带房客去看房后……）
     </p>
     <p>
      <strong>
       房客
      </strong>
      ：这房子不错，我想租。
     </p>
     <p>
      <strong>
       中介
      </strong>
      ：好，那我帮你联系房东签合同吧。
     </p>
     <p>
      <strong>
       房东
      </strong>
      ：好的，我们来签合同吧。（完成租房）
     </p>
     <h5>
      <strong>
       场景 3：更换中介（动态代理）
      </strong>
     </h5>
     <p>
      <strong>
       房客
      </strong>
      ：（租房体验不满意）这个中介效率太低了，我想换个更好的。
     </p>
     <p>
      <strong>
       中介公司
      </strong>
      ：没问题！我们这有多个中介，你可以换一个更专业的。
     </p>
     <p>
      （更换代理后，房客又顺利租到了房子）
     </p>
     <p>
     </p>
     <p>
      <img alt="" height="564" src="https://i-blog.csdnimg.cn/direct/790b4bea4ba6495a925ecd368e1b58a4.png" width="1106"/>
     </p>
    </blockquote>
    <h3>
     2.代理设计模式
    </h3>
    <h3>
     1.1概念
    </h3>
    <blockquote>
     <p>
      通过代理类：为原始类(目标)增加额外功能
     </p>
     <p>
      好处：利于原始类(目标的维护)
     </p>
    </blockquote>
    <h3>
     <strong>
      1.2名词解释
     </strong>
    </h3>
    <blockquote>
     <p>
      <strong>
       1.目标类 原始类
      </strong>
      <br/>
      指的是 业务类(核心功能---&gt;业务运算 DAO调用)
     </p>
     <p>
     </p>
     <p>
      <strong>
       2.目标方法 原始方法
      </strong>
     </p>
     <p>
      目标类(原始类)中的方法 就是目标方法(原始方法)
     </p>
     <p>
     </p>
     <p>
      <strong>
       3.额外功能(附加功能)
      </strong>
     </p>
     <p>
      日志、事务、性能
     </p>
    </blockquote>
    <h3>
     1.3代理开发的核心要素
    </h3>
    <blockquote>
     <p>
      <span style="color:#38d8f0">
       <strong>
        代理类=目标类(原始类)+额外功能+原始类(目标类)实现相同的接口
       </strong>
      </span>
     </p>
     <p>
     </p>
     <p>
      房东----&gt;public interface UserService{
      <!-- -->
     </p>
     <p>
      m1方法
     </p>
     <p>
      m2方法
     </p>
     <p>
      }
     </p>
     <p>
      UserServiceImpl implements UserService{
      <!-- -->
     </p>
     <p>
      m1----&gt;业务调用 DAO调用
     </p>
     <p>
      m2
     </p>
     <p>
      }
     </p>
     <p>
      UserServiceProxy implements UserService
     </p>
     <p>
     </p>
     <p>
     </p>
    </blockquote>
    <h3>
     1.4编码
    </h3>
    <blockquote>
     <p>
      <strong>
       静态代理
      </strong>
      :为每一个原始类，手工编写一个代理类
     </p>
    </blockquote>
    <pre><code class="language-java">public class UserServiceProxy implements UserService{
    private UserServiceImpl userService=new UserServiceImpl();
    @Override
    public void register(User user) {
        System.out.println("---log");
        userService.register(user);
    }

    @Override
    public void login(String name, String password) {
        System.out.println("---log");
        userService.login(name, password);
    }
}</code></pre>
    <h3>
     1.5静态里存在的问题
    </h3>
    <blockquote>
     <p>
      <span style="color:#fe2c24">
       <strong>
        1.静态类文件数量过多，不利于项目管理
       </strong>
      </span>
     </p>
     <p>
      UserServiceImpl UserServiceProxy
     </p>
     <p>
      OrderServiceImpl OrderServiceProxy
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        2.额外功能维护性差
       </span>
      </strong>
     </p>
     <p>
      代理类中 额外功能修改复杂
     </p>
     <p>
      <img alt="" height="232" src="https://i-blog.csdnimg.cn/direct/2af805b1756f4e90b8a2997813518ca2.png" width="833"/>
     </p>
    </blockquote>
    <h2>
     <strong>
      Spring动态代理
     </strong>
    </h2>
    <blockquote>
     <p>
      <strong>
       概念：通过代理类为原始类(目标类增加额外功能)
      </strong>
     </p>
     <p>
      好处:利于原始类(目标类的维护)
     </p>
    </blockquote>
    <h3>
     搭建开发环境
    </h3>
    <pre><code class="language-java">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;5.2.14.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
            &lt;version&gt;1.8.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.3&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
    <h3>
     Spring动态代理开发步骤
    </h3>
    <h4>
     1.创建原始对象(目标对象)
    </h4>
    <pre><code class="language-java">public class UserServiceImpl implements UserService{

    @Override
    public void register(User user) {
        System.out.println("用户注册成功");
    }

    @Override
    public void login(String name, String password) {
        System.out.println("用户登录成功");
    }
}</code></pre>
    <blockquote>
     <pre>&lt;bean id="userService" class="proxy.UserServiceImpl"&gt;&lt;/bean&gt;</pre>
    </blockquote>
    <h4>
     2.额外功能
    </h4>
    <p>
     MethodBeforeAdvice接口
    </p>
    <blockquote>
     <p>
      额外功能书写在接口的视线中，运行在原始方法执行之前运行额外功能
     </p>
    </blockquote>
    <pre><code class="language-java">public class Before implements MethodBeforeAdvice {
    /*
        作用：需要把原始方法之前运行的额外功能 写在before方法中
     */
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println("------额外功能开发--------");
    }
}
</code></pre>
    <h4>
     3.定义切入点
    </h4>
    <blockquote>
     <p>
      <span style="color:#be191c">
       <strong>
        切入点:额外功能加入的位置
       </strong>
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       目的:由程序员根据自己的需要，决定额外功能加入倒哪个原始方法中
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       rigister
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       login
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       简单测试:所有方法都作为切入点 加入额外功能
      </span>
     </p>
    </blockquote>
    <pre><code class="language-java">  &lt;aop:config&gt;
&lt;!--        所有的方法 都作为切入点 加入额外功能 login register--&gt;
        &lt;aop:pointcut id="pc" expression="execution(* *(..))"/&gt;
    &lt;/aop:config&gt;</code></pre>
    <h4>
     4.组装(2.3整合)
    </h4>
    <pre><code class="language-java">&lt;aop:config&gt;
&lt;!--        所有的方法 都作为切入点 加入额外功能 login register--&gt;
        &lt;aop:pointcut id="pc" expression="execution(* *(..))"/&gt;
        &lt;aop:advisor advice-ref="before" pointcut-ref="pc"&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;</code></pre>
    <h4>
     5.调用
    </h4>
    <blockquote>
     <p>
      目的:获得Spring工厂创建的动态代理对象，并进行调用
     </p>
     <p>
      ApplicationContext applicaton=new ClassPathXmlApplication("/applicationContext.xml");
     </p>
     <p>
      注意:
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        1.Spring工厂通过原始对象的id值获得是代理对象
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2.获得代理对象后，可以通过生命接口类型，进行对象存储
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        UserService userService=(UserService)application.getBean("userService");
       </strong>
      </span>
     </p>
     <p>
      application.getBean("userService")
     </p>
    </blockquote>
    <h3>
     动态代理细节分析
    </h3>
    <h4>
     1.Spring创建的动态代理类在哪里？
    </h4>
    <blockquote>
     <p>
      Spring框架在运行时，通过动态字节码奇数，在JVM创建，运行在JVM内部，等程序结束后，回合JVM一起消失
     </p>
     <p>
     </p>
     <p>
      <strong>
       动态字节码技术
      </strong>
     </p>
     <p>
      通过第三方动态字节码框架，在JVM中创建对应类的字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失
     </p>
     <p>
     </p>
     <p>
      <strong>
       结论：动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理，类文件数量过多，影响项目管理问题
      </strong>
     </p>
     <p>
     </p>
     <p>
      <img alt="" height="747" src="https://i-blog.csdnimg.cn/direct/a623dc72aed548bf894487af70e2dbf0.png" width="1038"/>
     </p>
     <p>
     </p>
     <p>
     </p>
     <p>
     </p>
    </blockquote>
    <h4>
     2.动态代理编程简化代理开发
    </h4>
    <blockquote>
     <p>
      <strong>
       在额外功能不改变的情况下，创建其它目标类(原始类)的代理对象时，只需要指定原始(目标对象)即可。
      </strong>
     </p>
    </blockquote>
    <h4>
     3.动态代理可维护性大大增强
    </h4>
    <p>
     (当前代理不想用 直接替换即可)
    </p>
    <pre><code class="language-java">&lt;bean id="userService" class="proxy.UserServiceImpl"&gt;&lt;/bean&gt;

    &lt;bean id="before" class="dynamic.Before"&gt;&lt;/bean&gt;
    &lt;bean id="before2" class="dynamic.Before2"&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
&lt;!--        所有的方法 都作为切入点 加入额外功能 login register--&gt;
        &lt;aop:pointcut id="pc" expression="execution(* *(..))"/&gt;
        &lt;aop:advisor advice-ref="before2" pointcut-ref="pc"&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
</code></pre>
    <h3>
     MethodBeforeAdvice详解
    </h3>
    <blockquote>
     <pre>接口作用:额外功能在原始方法执行之前，进行额外功能操作
public void before(Method method, Object[] objects, Object o) throws Throwable {
    System.out.println("------额外功能开发--------");
}
<strong>Object O:额外对象所增加给的原始对象
Object []objects:所增加切入点方法的参数
Method method:额外功能所增加的所在的方法 切入点</strong>
</pre>
     <p>
      <img alt="" height="198" src="https://i-blog.csdnimg.cn/direct/37b0ee26712d43888f922680ac0f7e16.png" width="1011"/>
     </p>
     <p>
     </p>
     <p>
      before方法在实战中，如何使用
      <br/>
      根据需要使用，不一定用到，可以能不用
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     ---Spring学习笔记(跟整理) 来源:
     <a href="https://www.bilibili.com/video/BV185411477k?spm_id_from=333.788.player.switch&amp;vd_source=1a0ea0ae04e238b36f8b312d4f1665d8&amp;p=76" rel="nofollow" title="076_动态代理细节分析3_哔哩哔哩_bilibili">
      076_动态代理细节分析3_哔哩哔哩_bilibili
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34343736363330352f:61727469636c652f64657461696c732f313436323537383737" class_="artid" style="display:none">
 </p>
</div>


