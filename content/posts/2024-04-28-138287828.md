---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37343431353135332f:61727469636c652f64657461696c732f313338323837383238"
layout: post
title: Linux冯诺依曼体系结构操作系统进程概念一.初识进程
date: 2024-04-28 18:54:27 +0800
description: "操作系统的设计目的是管理计算机系统的软硬件资源，为用"
keywords: 冯诺依曼
categories: ['Linux']
tags: ['运维', '算法', '机器学习', '服务器', '开发语言', 'Linux', 'C']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138287828
    alt: Linux冯诺依曼体系结构操作系统进程概念一.初识进程
artid: 138287828
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=138287828
featuredImagePreview: https://bing.ee123.net/img/rand?artid=138287828
---

# Linux：冯诺依曼体系结构、操作系统、进程概念（一.初识进程）

---

#### 文章目录

* [1.冯诺依曼体系结构](#1_12)
* + [总线与数据传输通路](#_26)
  + [为什么有内存这个部分](#_52)
  + [计算机存储结构](#_68)
* [2.操作系统(Operator System)](#2Operator_System_104)
* + [2.1 概念](#21__106)
  + [2.2 设计OS的目的](#22_OS_118)
  + [2.3 理解“管理”](#23__131)
  + - [先描述再组织](#_154)
  + [2.4 用户使用](#24__175)
  + - [系统调用和库函数（lib）概念](#lib_192)
  + [总结](#_212)
* [3.初识进程](#3_224)
* + [3.1 基本事实与引入](#31__226)
  + [3.2 进程概念](#32__260)
  + [3.3 描述进程—PCB](#33_PCB_288)
  + [3.4 task\_struct—linux中的PCB](#34_task_structlinuxPCB_296)

---

## 1.冯诺依曼体系结构

冯诺依曼体系结构是计算机体系结构中的一种基本设计原则，它描述了计算机系统的组成和运作方式。该体系结构由计算机科学家约翰·冯·诺伊曼（John von Neumann）于20世纪中期提出，被广泛应用于现代计算机系统的设计和实现中。

冯诺依曼体系结构包括以下几个关键组成部分：

1. **存储器（Memory）**
   ：冯诺依曼体系结构中的存储器用于存储指令和数据。这里的
   存储器通常指的是内存
   ，包括随机存储器（RAM）和只读存储器（ROM）。存储器中的数据可以根据地址进行读取和写入操作。
2. **中央处理器（CPU）**
   ：CPU是计算机的核心部件，负责执行指令并处理数据。CPU包括运算器（Arithmetic Logic Unit，ALU）和控制器（Control Unit）。运算器执行算术和逻辑运算，而控制器负责指挥数据的流动和执行指令的顺序。
3. **输入/输出设备（Input/Output Devices）**
   ：输入/输出设备用于与外部世界交互，包括键盘、鼠标、显示器、打印机等。在冯诺依曼体系结构中，所有的输入和输出都通过存储器进行传递，即输入设备将数据写入内存，输出设备从内存读取数据。
4. **存储器-中央处理器之间的数据传输通路**
   ：冯诺依曼体系结构中，存储器和中央处理器之间有一条数据总线（Data Bus）和一条地址总线（Address Bus），用于传输数据和地址信息。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f43b9e71e78004ad44b03260563c9eb0.png)

### 总线与数据传输通路

在计算机系统中，
各个设备之间通过总线连接在主板
上。总线是一组电子管道或连接，它
允许数据在设备之间传输
，以及设备与 CPU 或内存之间进行通信。总线可以传输各种类型的数据，包括指令、地址和数据。

> **设备之间的数据流动本质是数据在
> 不同设备之间来回拷贝
> ，拷贝的整体速度是决定计算机效率的重要指标**

总线的作用是将计算机中的各种硬件设备连接起来，使它们可以相互通信和协作。通过总线，CPU 可以访问内存中的数据和指令，外部设备（如键盘、鼠标、硬盘等）可以与 CPU 或内存进行数据交换。

总线通常分为
三种类型：地址总线、数据总线和控制总线
。

1. 地址总线（Address Bus）：用于指示数据在内存或 I/O 设备中的位置。地址总线的宽度决定了系统可以寻址的内存空间大小。例如，32位地址总线可以寻址 2^32 个不同的内存单元，即 4GB 的内存空间。
2. 数据总线（Data Bus）：用于在 CPU、内存和 I/O 设备之间传输数据。数据总线的宽度决定了系统一次可以传输的数据位数。例如，32位数据总线可以一次传输 32 位（4 字节）的数据。
3. 控制总线（Control Bus）：用于控制数据的传输和操作。控制总线包括各种控制信号，如读写信号、时钟信号、中断信号等，用于指示数据传输的方向和时序。

总线连接在主板上，通过电路板上的导线和连接器进行物理连接。当 CPU 或其他设备需要访问内存或进行数据交换时，它们会通过总线发送相应的控制信号和数据，然后在目标设备上进行处理或存储。

> 1. **数据传输通路**
>    ：
>
> * 数据传输通路通常指的是在
>   芯片内部或芯片之间的数据传输路径
>   ，它们可以是在 CPU 芯片内部的各种通路，也可以是连接芯片之间的内部通路，比如连接 CPU 和内存、连接 CPU 和缓存等。数据传输通路的主要特点是速度非常快，因为它们通常是直接连接在芯片内部或紧密连接的芯片之间，所以传输速度非常高。
>
> 2. **总线**
>    ：
>
> * 总线是计算机系统中
>   不同组件之间进行数据传输的通道
>   。它是连接 CPU、内存、输入输出设备和其他部件的物理通道，用于在它们之间传输数据和控制信号。总线分为地址总线、数据总线和控制总线三种，其中地址总线用于指示数据的存储位置，数据总线用于传输实际的数据，控制总线用于控制数据传输的时序和流向。总线的主要特点是它连接了整个计算机系统的各个部件，因此它的带宽和传输速度通常比较有限，而且需要考虑更多的时序和控制问题。

### 为什么有内存这个部分

1. **平衡速度差异：**

   CPU 的速度远远快于外部设备，如硬盘、光驱等
   。内存作为介于CPU和外部设备之间的媒介，可以帮助平衡这种速度差异。CPU 可以快速地从内存中读取或写入数据，而内存则可以暂时存储来自外部设备的数据，使得 CPU 不必等待外部设备完成读写操作。
2. **提高效率：**
   内存的引入使得计算机的运行更加高效。CPU 可以直接从内存中读取数据进行运算，而无需每次都去访问外部设备。这样可以大大提高数据访问速度，加快计算机的响应速度，提高整体性能。
3. **缓存作用：**
   内存可以看作是一个非常大的缓存，存储了 CPU 需要频繁访问的数据和程序。通过在内存中暂时存储数据，可以减少 CPU 对外部设备的访问次数，提高计算机系统的效率。
4. **降低成本：**
   内存的成本相对于 CPU 来说比较低廉，这使得计算机更加实用和经济。如果没有内存，CPU 将不得不直接与外部设备进行交互，这不仅会降低计算机的性能，还会增加硬件成本，使得计算机变得更加昂贵。

> * **外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取。**
> * **所有设备都只能直接和内存打交道**
> * **所有程序运行前都要先加载到内存里**

### 计算机存储结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/082f27830f0f393aca69f3831553d82d.png)

1. CPU 寄存器（Registers）：

   * 保存来自高速缓存（Cache）的字。
   * 最小、最快、最贵的存储设备，通常位于 CPU 内部。
2. 高速缓存（Cache）：

   * 芯片内的缓存，保存来自芯片外缓存的缓存行。
   * 包括芯片内高速缓存和芯片外高速缓存（如 SRAM、DRAM）。
   * 提供比主存储器更快的访问速度，用于加速对常用数据和指令的访问。
3. 主存储器（Main Memory）：

   * 保存来自外部存储器（如磁盘、光盘、固态硬盘）的文件。
   * 包括随机访问存储器（RAM）和只读存储器（ROM）。
   * 速度介于高速缓存和外部存储器之间，价格适中。
4. 外部存储器（External Storage）：

   * 包括磁盘、光盘、固态硬盘（如 Flash、PROM、EPROM、E2PROM）等。
   * 保存大量数据和文件，但访问速度相对较慢，价格相对较低。
   * 提供长期存储和备份的功能，但通常不适合频繁的读写操作。
5. 远程二级存储（Remote Secondary Storage）：

   * 包括分布式文件系统、Web 服务器等。
   * 提供远程存储和共享的功能，通常用于跨网络访问和备份数据。

> **所以，我们上面看到的存储器是特指主存储器——内存**
>
> **计算机中不止有内存能存储。内存是计算机中用于临时存储数据和程序的一种存储介质，用于存储当前正在运行的程序和数据，是CPU能够直接访问的存储设备**

---

## 2.操作系统(Operator System)

### 2.1 概念

> **操作系统（Operating System，简称OS）是一种系统软件，它负责管理和控制计算机硬件资源，并为应用程序提供运行环境的软件集合**
>
> * **操作系统就是一个软件，是第一个被加载的软件**
> * **负责管理计算机的软硬件资源，并为用户程序提供执行环境**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bbdfb4b2c1cebfd86de85de05db2f231.png)

### 2.2 设计OS的目的

* **与硬件交互**
  ：操作系统需要与计算机硬件交互，控制和管理硬件资源的使用。
* **管理软硬件资源**
  ：操作系统管理计算机的所有软硬件资源，包括处理器、内存、文件系统、输入输出设备等。
* **为用户程序提供执行环境**
  ：操作系统提供一个良好的执行环境，使用户程序能够在计算机上运行并相互协作

  > **对下
  > 管理
  > 好软硬件资源 ---- 手段**
  >   
  > **对上提供一个良好的运行环境 ---- 目的**
  > （还是要让我们用户自己用的舒服，如果没有操作系统帮我们，那什么都要自己来弄）

### 2.3 理解“管理”

> **我们能下这样一个定义：**
>
> **在整个计算机软硬件架构中，操作系统的定位是
> 一款纯正的“搞管理”的软件
> 。它不仅仅是一个程序集合，更是一个管理计算机系统的核心。**

先聚焦于管理硬件部分：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0b461107f7e869946d2cea18e119b0ec.png)

> **操作系统、驱动程序和底层硬件之间的关系可以简单描述为：
> 操作系统通过驱动程序与底层硬件进行交互和控制
> 。**
>
> 1. **操作系统：操作系统是计算机系统中的核心软件，负责管理计算机的资源、提供用户界面、执行程序和控制外部设备等。操作系统通过提供各种服务和接口，使应用程序能够在计算机上运行并与硬件设备进行交互。**
> 2. **驱动程序：驱动程序是一种软件，用于与特定硬件设备进行通信和控制。驱动程序通常由硬件制造商提供，通过操作系统的驱动程序接口（API）与操作系统进行交互。当操作系统需要与某个硬件设备通信时，会调用相应的驱动程序来完成这些操作。**
> 3. **底层硬件：底层硬件是指计算机系统中的物理设备，如处理器、内存、硬盘、显卡、网卡等。这些硬件设备是计算机系统的基础，操作系统和应用程序需要通过驱动程序来与这些硬件设备进行通信和控制。**
>
> **操作系统通过驱动程序来管理和控制底层硬件，使得应用程序可以方便地访问和使用硬件设备。驱动程序充当了操作系统与硬件之间的桥梁，帮助操作系统实现对硬件设备的有效管理和控制。**

#### 先描述再组织

**"管理"指的是操作系统对计算机系统中的各种资源进行组织、分配、调度和控制，以实现有效的资源利用和系统运行**
。

> **对于硬件的管理本质上就是一个
> 先描述再组织
> 的过程。**
>
> * **描述：结构体进行描述 （定义一个struct啊，里面放属性）**
> * **组织：使用数据结构进行组织（比如把各种硬件的struct放在链表里，这样可以进程查找，操作）**

1. 描述被管理对象

   被操作系统管理的对象包括进程、内存、文件和硬件设备。这些对象在操作系统中通过数据结构来进行描述和组织。
2. 组织被管理对象

   操作系统通过使用数据结构如结构体、链表等来组织被管理对象，以便对其进行管理和操作。

> 不只是硬件部分使用了这种思想，后面进程部分的内容也会用到这样的的思想

### 2.4 用户使用

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cebb1571f941cebfc39ba29280a8feb6.png)

操作系统要给用户提供提供一个良好的运行环境：稳定，高效，安全

> **为了保证这些，操作系统就不能直接让用户访问内部所有数据。**
>
> **用户操作接口
> 的存在正是为了限制用户对内部数据的直接访问，并为用户提供一种安全、稳定且易于使用的方式与操作系统进行交互**
>
> **系统调用接口
> 是操作系统提供给用户程序的一组函数或方法，用于让用户程序能够请求操作系统提供的各种服务和资源。系统调用接口允许用户程序在运行过程中向操作系统发出请求，以便执行特权操作或访问受保护资源**
> （也是操作系统提供给我们用户来访问调用数据资源的方式）

通过限制用户对内部数据的直接访问，并提供用户操作接口和系统调用接口，操作系统可以有效地保证系统的稳定性、高效性和安全性

#### 系统调用和库函数（lib）概念

操作系统
通过暴露系统调用接口给用户程序来提供服务
。用户程序可以通过系统调用与操作系统进行交互，获取所需的服务和资源。有时，为了简化用户程序的开发，有心的开发者会对部分系统调用进行适度封装成库函数（库函数由用户提供），供用户程序调用。

> 那printf函数与scanf函数，二者都要使用硬件。
>
> 但是二者又是c语言里的库函数，但是能访问到硬件资源。就能说明，二者一定封装了系统调用接口，所以才能一直顺着剪头向下

库函数实现时，如果内部封装了多种操作系统的系统调用，那该语言便具有可移植性

那我们为什么之前一直没有直接使用过系统调用呢？

> **直接使用系统调用需要对操作系统较为熟悉，而且不方便。**
>
> **所以库函数封装了系统调用后，更方便我们使用**

### 总结

操作系统的设计目的是管理计算机系统的软硬件资源，为用户程序提供执行环境。它通过对资源的描述和组织，以及提供系统调用和库函数的方式，来实现对计算机系统的管理和控制。

> 1. 从上到下是不可以发生越级访问。
> 2. 不可以绕过操作系统
> 3. 操作系统从头到尾是贯穿的

---

## 3.初识进程

### 3.1 基本事实与引入

> 在操作系统中，当一个程序被加载到内存中运行时，通常会涉及到内存中的数据拷贝。这涉及到两个概念：
> **加载（Load）
> **和**
> 拷贝（Copy）**
> 。
>
> 1. **加载（Load）**
>    ：加载是指将程序的可执行文件（二进制文件）从磁盘加载到内存中，以便在CPU上执行。这个过程包括将程序的代码段、数据段、堆、栈等部分加载到内存中，并建立起对应的内存映射关系。
> 2. **拷贝（Copy）**
>    ：在某些情况下，加载到内存中的程序数据可能需要进行拷贝。这种情况通常发生在涉及进程间通信或者动态链接的情况下。例如：
>
> * **进程间通信**
>   ：如果多个进程需要共享某些数据，那么这些数据需要在不同进程的地址空间中拷贝。
> * **动态链接**
>   ：当程序使用动态链接库时，库函数的代码和数据需要从共享库加载到进程的地址空间中，这可能涉及到数据的拷贝。

1. 我们可以同时启动多个程序 — 此时便有多个.exe加载到内存

   > 加载程序到内存是指操作系统将程序的可执行文件（通常是二进制文件，如.exe文件）中的代码和数据加载到系统的内存空间中，并为其分配一定的内存空间以供运行
2. 操作系统肯定要管理多个加载到内存的程序呢
3. 操作系统如何管理加载到内存的程序呢? ? 先描述，在组织：

   > 1. **描述程序：**
   > * 操作系统首先需要描述每个加载到内存的程序。这通常通过定义
   >   `struct`
   >   来完成，比如进程控制块（
   >   PCB
   >   ）或进程描述符。PCB包含了关于进程的各种信息，如进程ID、状态、程序计数器、内存分配情况、资源占用情况等。
   > 2. **组织程序：**
   > * 加载到内存的程序可能会被
   >   组织成一个进程队列或进程表
   >   。这样的组织方式使得操作系统能够轻松地访问和管理每个程序。进程队列可以按照优先级、状态或其他标准进行排序，以便操作系统能够有效地调度和管理这些程序

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4446496f290d6b8924a5bd5ac234b4b2.png)

> 1. 加载程序到内存:
> 2. 创建PCB对象:
> 3. 通过对PCB的管理，来对程序进行管理
> 4. 对于进程的管理就是对PCB链表增删查改

### 3.2 进程概念

![进程17](https://i-blog.csdnimg.cn/blog_migrate/dee06bf0765d03f98071b5884b1292f2.png)

课本概念：程序的一个执行实例，正在执行的程序等

内核观点：担当分配系统资源（CPU时间，内存）的实体

> **进程=内核PCB对象+可执行程序 ==> 进程=内核数据结构+可执行程序**
>
> 内核数据结构是操作系统内核中用于组织和管理系统资源的数据形式或组织方式。这些数据结构通常用于描述和维护系统的状态、进程信息、内存分配、文件系统、设备驱动等方面的内容。一些常见的内核数据结构包括：
>
> 1. **进程控制块（PCB）：**
>    用于描述和管理进程的数据结构，包括进程的标识符、状态、优先级、程序计数器、寄存器状态等信息。
> 2. **内存管理数据结构：**
>    包括页表、段表、内存映射等数据结构，用于管理系统的内存分配和地址映射。
> 3. **文件控制块（FCB）：**
>    用于描述和管理文件的数据结构，包括文件的属性、位置、权限等信息。
> 4. **设备控制块（DCB）：**
>    用于描述和管理设备的数据结构，包括设备的标识符、状态、缓冲区等信息。
> 5. **系统调用表：**
>    用于存储系统调用的函数指针或入口地址，以便用户程序可以通过系统调用接口访问操作系统提供的功能。
> 6. **中断向量表（IVT）：**
>    用于存储系统中断处理程序的入口地址，以便操作系统可以在发生硬件中断时进行处理。
> 7. **内核堆栈：**
>    用于保存操作系统内核代码执行过程中的临时数据和状态信息。

### 3.3 描述进程—PCB

> 进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合。操作系统学科里称之为PCB（process control block）
>
> 而在Linux操作系统下的PCB是
> `task_struct`

### 3.4 task\_struct—linux中的PCB

在Linux内核中，描述进程的
结构体
被称为
`task_struct`
。
`task_struct`
是 Linux 内核中非常重要的数据结构，用于表示和管理进程。每个正在运行或等待运行的进程都有一个对应的
`task_struct`
结构体。

`task_struct`
结构体包含了大量描述进程状态和属性的字段，其中包括：

1. **进程标识符（PID）：**
   用于唯一标识一个进程。
2. **进程状态：**
   表示进程当前的状态，如运行、就绪、阻塞等。
3. **进程优先级和调度信息：**
   包括进程的优先级、调度策略等。
4. **进程描述符（Files Descriptor）：**
   记录了进程打开的文件描述符。
5. **进程的父子关系：**
   包括父进程、子进程和兄弟进程等关系。
6. **进程的执行状态：**
   包括进程的程序计数器、堆栈指针等执行状态信息。
7. **进程的内存管理信息：**
   如内存映射、页表等。
8. **进程的资源限制：**
   如内存限制、CPU 时间限制等。
9. **信号处理器：**
   记录了进程注册的信号处理函数和等待的信号。
10. **进程的调试信息：**
    如调试状态、跟踪状态等。

```c
struct task_struct {
    // 进程标识符
    pid_t pid;
    
    // 进程状态
    int state;
    
    // 进程优先级和调度信息
    int priority;
    int policy;
    
    // 进程描述符
    struct files_struct *files;
    
    // 进程的父子关系
    struct task_struct *parent;
    struct list_head children;
    
    // 进程的执行状态
    struct pt_regs *thread_regs;
    unsigned long stack;
    
    // 进程的内存管理信息
    struct mm_struct *mm;
    
    // 进程的资源限制
    struct rlimit rlim;
    
    // 信号处理器
    struct sigaction sigaction[_NSIG];
    
    // 进程的调试信息
    int debug_flags;
    // 其他字段...
};

```

---

今天就先到这里把，下次就能把进程查看、状态、优先级什么的给讲讲了