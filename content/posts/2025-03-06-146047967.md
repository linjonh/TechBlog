---
layout: post
title: "单例模式的五种实现方式"
date: 2025-03-06 08:48:11 +0800
description: "单例模式的五种实现方式"
keywords: "单例模式的五种实现方式"
categories: ['设计模式']
tags: ['设计模式', '开发语言', '单例模式', 'Java']
artid: "146047967"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146047967
    alt: "单例模式的五种实现方式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146047967
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146047967
cover: https://bing.ee123.net/img/rand?artid=146047967
image: https://bing.ee123.net/img/rand?artid=146047967
img: https://bing.ee123.net/img/rand?artid=146047967
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     单例模式的五种实现方式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <h3>
      1、饿汉式
     </h3>
    </blockquote>
    <p>
     <strong>
      ①实现：
     </strong>
     在类加载的时候就初始化实例
    </p>
    <p>
     <strong>
      ②优点：
     </strong>
     线程安全
    </p>
    <p>
     <strong>
      ③缺点：
     </strong>
     实例在类加载的时候创建，可能会浪费资源
    </p>
    <pre><code class="language-java">//饿汉式
public class EagerSingleton{
    
    private EagerSingleton(){}   //私有构造方法
    
    private static EagerSingleton instance = new EagerSingleton();

    public static EagerSingleton getInstance(){
        return instance;
    }
    
}</code></pre>
    <p>
    </p>
    <blockquote>
     <h3>
      2、懒汉式
     </h3>
    </blockquote>
    <p>
     <strong>
      ①实现：
     </strong>
     在首次获取实例的时候再创建实例
    </p>
    <p>
     <strong>
      ②优点：
     </strong>
     延迟加载，节省资源
    </p>
    <p>
     <strong>
      ③缺点：
     </strong>
     线程不安全
    </p>
    <pre><code class="language-java">public class LazySingleton{

    private LazySingleton(){}    //  私有构造方法

    private static LazySingleton instance;

    public static LazySingleton getInstance(){
        if(instance != null){
            instance = new LazySingleton();
        }
        return instance;
    }

}</code></pre>
    <p>
    </p>
    <blockquote>
     <h3>
      3、双重检查锁
     </h3>
    </blockquote>
    <p>
     <strong>
      ①实现：
     </strong>
     通过双重检查+加锁+volatile方式实现
    </p>
    <p>
     <strong>
      ②优点：
     </strong>
     线程安全
    </p>
    <p>
     <strong>
      ③缺点：
     </strong>
     稍微复杂
    </p>
    <pre><code class="language-java">public class DoubleCheckedSingleton{

    private DoubleCheckedSingleton(){}

    private static volatile DoubleCheckedSingleton instance;

    public static DoubleCheckedSingleton getInstance(){
        if(instance != null){
            sychronized (DoubleCheckedSingleton.class){
                if(instance != null){
                    instance = new DoubleCheckedSingleton();
                }
            }
        }
        return instance;
    }
 }</code></pre>
    <p>
    </p>
    <blockquote>
     <h3>
      4、静态内部类
     </h3>
    </blockquote>
    <p>
     <strong>
      ①实现：
     </strong>
     静态内部类创建示例
    </p>
    <p>
     <strong>
      ②优点：
     </strong>
     线程安全
    </p>
    <p>
     <strong>
      ③缺点：
     </strong>
     无法通过参数构造实例
    </p>
    <pre><code class="language-java">public class InnerClassSingleton{
    
    private InnerClassSingleton(){}

    private static class SingletonHolder{
        private static final InnerClassSingleton instance = new InnerClassSingleton();
    }
    
    public static InnerClassSingleton getInstance(){
        return SingletonHolder.instance;
    }
}</code></pre>
    <p>
    </p>
    <blockquote>
     <h3>
      5、枚举
     </h3>
    </blockquote>
    <p>
     <strong>
      ①实现：
     </strong>
     通过枚举类型天然的单例特性实现
    </p>
    <p>
     <strong>
      ②优点：
     </strong>
     线程安全、代码简洁、防止反射和序列化破坏单例
    </p>
    <p>
     <strong>
      ③缺点：
     </strong>
     属于饿汉式，会浪费资源
    </p>
    <pre><code class="language-java">public emun EnumSingleton{
    INSTANCE;
}</code></pre>
    <p>
    </p>
    <p>
     Runtime类就是通过饿汉式的方式实现的单例模式
    </p>
    <p>
     <img alt="" height="297" src="https://i-blog.csdnimg.cn/direct/93b233e24279430b90349d42807798b4.png" width="742"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36323336363739372f:61727469636c652f64657461696c732f313436303437393637" class_="artid" style="display:none">
 </p>
</div>


