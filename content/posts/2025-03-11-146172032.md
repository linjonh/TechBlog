---
layout: post
title: "java双亲委派机制"
date: 2025-03-11 10:25:20 +0800
description: "双亲委派机制是指当一个类加载器收到类加载请求时，它不会立即尝试加载该类，而是将请求委派给父类加载器去完成。每一层的类加载器都会依次向上委派，直到启动类加载器（Bootstrap ClassLoader）。如果父类加载器无法完成加载（在自己的搜索范围内找不到该类），子类加载器才会尝试加载。双亲委派机制是Java类加载机制的核心设计，通过层次化的类加载器结构和委派机制，保证了类的唯一性、安全性和一致性。"
keywords: "java双亲委派机制"
categories: ['未分类']
tags: ['开发语言', 'Java']
artid: "146172032"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146172032
    alt: "java双亲委派机制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146172032
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146172032
cover: https://bing.ee123.net/img/rand?artid=146172032
image: https://bing.ee123.net/img/rand?artid=146172032
img: https://bing.ee123.net/img/rand?artid=146172032
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java双亲委派机制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Java的双亲委派机制（Parent Delegation Model）是类加载器（ClassLoader）在加载类时采用的一种工作模型。它是Java类加载机制的核心设计之一，主要用于保证类的唯一性和安全性。以下是双亲委派机制的详细说明：
    </p>
    <hr/>
    <h4>
     1. 什么是双亲委派机制？
    </h4>
    <p>
     双亲委派机制是指当一个类加载器收到类加载请求时，它不会立即尝试加载该类，而是将请求委派给父类加载器去完成。每一层的类加载器都会依次向上委派，直到启动类加载器（Bootstrap ClassLoader）。如果父类加载器无法完成加载（在自己的搜索范围内找不到该类），子类加载器才会尝试加载。
    </p>
    <hr/>
    <h4>
     2. 双亲委派机制的工作流程
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        收到类加载请求
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当一个类加载器收到类加载请求时，首先检查该类是否已经被加载过。
        </p>
       </li>
       <li>
        <p>
         如果已经加载过，则直接返回对应的
         <code>
          Class
         </code>
         对象。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        委派给父类加载器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果该类未被加载过，类加载器会将加载请求委派给父类加载器。
        </p>
       </li>
       <li>
        <p>
         父类加载器会重复同样的过程，继续向上委派，直到启动类加载器。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        父类加载器尝试加载
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果父类加载器可以完成加载，则返回对应的
         <code>
          Class
         </code>
         对象。
        </p>
       </li>
       <li>
        <p>
         如果父类加载器无法完成加载（在自己的搜索范围内找不到该类），则子类加载器会尝试加载。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        子类加载器加载
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果子类加载器也无法加载该类，则抛出
         <code>
          ClassNotFoundException
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     3. 双亲委派机制的类加载器层次结构
    </h4>
    <p>
     Java中的类加载器按照层次结构组织，主要包括以下几种类加载器：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        启动类加载器（Bootstrap ClassLoader）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         负责加载JVM核心类库（如
         <code>
          rt.jar
         </code>
         ），由C++实现，是JVM的一部分。
        </p>
       </li>
       <li>
        <p>
         是其他类加载器的顶级父加载器。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        扩展类加载器（Extension ClassLoader）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         负责加载
         <code>
          &lt;JAVA_HOME&gt;/lib/ext
         </code>
         目录下的类库。
        </p>
       </li>
       <li>
        <p>
         由
         <code>
          sun.misc.Launcher$ExtClassLoader
         </code>
         实现。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用程序类加载器（Application ClassLoader）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         负责加载用户类路径（
         <code>
          classpath
         </code>
         ）下的类库。
        </p>
       </li>
       <li>
        <p>
         由
         <code>
          sun.misc.Launcher$AppClassLoader
         </code>
         实现。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        自定义类加载器（Custom ClassLoader）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         用户可以通过继承
         <code>
          java.lang.ClassLoader
         </code>
         类实现自定义类加载器。
        </p>
       </li>
       <li>
        <p>
         自定义类加载器的父加载器是应用程序类加载器。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     4. 双亲委派机制的优点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        避免类的重复加载
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过委派机制，可以确保一个类只会被加载一次，从而避免类的重复加载。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        保护核心类库的安全
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         核心类库（如
         <code>
          java.lang
         </code>
         包）由启动类加载器加载，用户无法通过自定义类加载器篡改核心类库。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        保证类的唯一性
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         同一个类在不同的类加载器加载时会被认为是不同的类，双亲委派机制可以确保类的唯一性。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     5. 双亲委派机制的实现
    </h4>
    <p>
     双亲委派机制的实现主要体现在
     <code>
      ClassLoader
     </code>
     的
     <code>
      loadClass
     </code>
     方法中。以下是
     <code>
      loadClass
     </code>
     方法的简化逻辑：
    </p>
    <pre>protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 1. 检查类是否已经被加载
    Class&lt;?&gt; c = findLoadedClass(name);
    if (c == null) {
        try {
            // 2. 委派给父类加载器
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                // 3. 如果父类加载器为null，则委派给启动类加载器
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // 父类加载器无法加载
        }

        if (c == null) {
            // 4. 父类加载器无法加载时，自己尝试加载
            c = findClass(name);
        }
    }
    // 5. 如果需要解析，则解析该类
    if (resolve) {
        resolveClass(c);
    }
    return c;
}</pre>
    <hr/>
    <h4>
     6. 打破双亲委派机制的场景
    </h4>
    <p>
     在某些特殊场景下，可能需要打破双亲委派机制，例如：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        SPI（Service Provider Interface）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如JDBC驱动加载，核心类库（如
         <code>
          java.sql.DriverManager
         </code>
         ）需要调用用户实现的类（如
         <code>
          com.mysql.cj.jdbc.Driver
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         通过
         <code>
          Thread.currentThread().getContextClassLoader()
         </code>
         获取线程上下文类加载器来加载用户类。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        OSGi
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         OSGi是一个模块化框架，每个模块有自己的类加载器，模块之间通过类加载器隔离。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        热部署
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在应用运行时动态加载新的类文件，通常需要自定义类加载器。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     7. 示例：双亲委派机制的工作过程
    </h4>
    <p>
     假设有以下类加载器层次结构：
    </p>
    <ul>
     <li>
      <p>
       启动类加载器（Bootstrap ClassLoader）
      </p>
     </li>
     <li>
      <p>
       扩展类加载器（Extension ClassLoader）
      </p>
     </li>
     <li>
      <p>
       应用程序类加载器（Application ClassLoader）
      </p>
     </li>
    </ul>
    <p>
     当应用程序类加载器收到加载
     <code>
      java.lang.String
     </code>
     的请求时：
    </p>
    <ol>
     <li>
      <p>
       应用程序类加载器将请求委派给扩展类加载器。
      </p>
     </li>
     <li>
      <p>
       扩展类加载器将请求委派给启动类加载器。
      </p>
     </li>
     <li>
      <p>
       启动类加载器成功加载
       <code>
        java.lang.String
       </code>
       ，并返回
       <code>
        Class
       </code>
       对象。
      </p>
     </li>
    </ol>
    <p>
     如果加载的是用户自定义类
     <code>
      com.example.MyClass
     </code>
     ：
    </p>
    <ol>
     <li>
      <p>
       应用程序类加载器将请求委派给扩展类加载器。
      </p>
     </li>
     <li>
      <p>
       扩展类加载器将请求委派给启动类加载器。
      </p>
     </li>
     <li>
      <p>
       启动类加载器无法加载
       <code>
        com.example.MyClass
       </code>
       ，扩展类加载器也无法加载。
      </p>
     </li>
     <li>
      <p>
       应用程序类加载器尝试加载，并成功加载
       <code>
        com.example.MyClass
       </code>
       。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     8. 总结
    </h4>
    <p>
     双亲委派机制是Java类加载机制的核心设计，通过层次化的类加载器结构和委派机制，保证了类的唯一性、安全性和一致性。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f7a68676c68792f:61727469636c652f64657461696c732f313436313732303332" class_="artid" style="display:none">
 </p>
</div>


