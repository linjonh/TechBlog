---
layout: post
title: "Redis面试篇"
date: 2025-03-14 11:56:00 +0800
description: "缓存穿透是指客户端频繁访问一些不存在的缓存数据，由于缓存中没有这些数据的记录，每次请求都直接访问数据库，导致数据库压力增大，但是数据库中也不存在(就是指大量请求不存在的资源,大量请求不存在的资源大概率就是被黑客攻击了......)如何解决?缓存空值：当查询一个不存在的key时，先访问缓存，缓存中没有访问数据库，数据库中也没有用的话就用redis做一个空标记 ，将空结果也写入缓存，并设置一个较短的过期时间。"
keywords: "Redis面试篇"
categories: ['未分类']
tags: ['Redis']
artid: "146254069"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146254069
    alt: "Redis面试篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146254069
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146254069
cover: https://bing.ee123.net/img/rand?artid=146254069
image: https://bing.ee123.net/img/rand?artid=146254069
img: https://bing.ee123.net/img/rand?artid=146254069
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis面试篇
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 name="Redis%E9%9D%A2%E8%AF%95%E7%AF%87">
     Redis面试篇
    </h2>
    <h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" name="1.%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
     1.什么是Redis？作用是什么？
    </h3>
    <p>
     Redis（Remote Dictionary Server）是一个
     <strong>
      基于内存的高性能 NoSQL 数据库
     </strong>
     ，通常用于
     <strong>
      缓存
     </strong>
     、
     <strong>
      分布式存储
     </strong>
     和
     <strong>
      消息队列
     </strong>
     。它支持
     <strong>
      键值（key-value）存储
     </strong>
     ，并且可以存储
     <strong>
      字符串、哈希、列表、集合、有序集合等多种数据结构
     </strong>
    </p>
    <p>
     <strong>
      Redis 的主要作用
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        缓存（提高系统性能）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          存储热点数据
         </strong>
         ，减少数据库访问压力，提高查询速度。
        </p>
       </li>
       <li>
        <p>
         例如：存储用户信息、文章内容、商品信息等，避免每次都查数据库。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分布式锁（保证并发安全）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         在高并发场景下，多个线程/进程可能同时访问一个资源，Redis 的
         <strong>
          SETNX
         </strong>
         、
         <strong>
          Redisson
         </strong>
         可以实现
         <strong>
          分布式锁
         </strong>
         ，防止数据冲突。
        </p>
       </li>
       <li>
        <p>
         例如：限流、秒杀活动、库存扣减。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        计数器和限流（防止系统被滥用）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         适用于访问量统计、限流（如接口请求次数限制）。
        </p>
       </li>
       <li>
        <p>
         例如：某接口
         <strong>
          1 分钟内最多访问 10 次
         </strong>
         ，超过就返回错误。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Session 共享（解决分布式会话问题）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         在分布式系统中，多个服务器需要共享 Session（如用户登录状态），可以使用 Redis 统一存储。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        消息队列（异步处理任务）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         Redis 的
         <code>
          List
         </code>
         和
         <code>
          Pub/Sub
         </code>
         可用于实现
         <strong>
          消息队列
         </strong>
         ，提高系统吞吐量。
        </p>
       </li>
       <li>
        <p>
         例如：
         <strong>
          订单系统
         </strong>
         →
         <strong>
          消息队列
         </strong>
         →
         <strong>
          异步处理支付、物流
         </strong>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        排行榜（游戏、社交场景）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         Redis 的
         <strong>
          有序集合（Sorted Set）
         </strong>
         可以存储分数排名，如游戏积分榜、热搜榜。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3 id="2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" name="2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">
     2.什么是缓存穿透、缓存击穿、缓存雪崩
    </h3>
    <h4 id="2.1%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" name="2.1%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">
     2.1缓存穿透
    </h4>
    <p>
     缓存穿透是指客户端频繁访问一些不存在的缓存数据，由于缓存中没有这些数据的记录，每次请求都直接访问数据库，导致数据库压力增大，但是数据库中也不存在(就是指大量请求不存在的资源,大量请求不存在的资源大概率就是被黑客攻击了......)
    </p>
    <p>
     <strong>
      如何解决?
     </strong>
     缓存空值：当查询一个不存在的key时，先访问缓存，缓存中没有访问数据库，数据库中也没有用的话就用redis做一个空标记 ，将空结果也写入缓存，并设置一个较短的过期时间 。下次再遇到相同的请求时判断是否存在空标记 key，存在这个空标记则直接返回缓存中的空值，避免再次查询数据库。(但这种标记过多的话会消耗资源,不推荐)
    </p>
    <p>
     使用分布式锁:当请求发现缓存不存在时，可以使用分布式锁机制，避免多个相同的请求同时访问数据库。这样，只让一个请求去加载数据，其他请求等待，从而减轻数据库压力.
    </p>
    <p>
     <strong>
      布隆过滤器
     </strong>
     :布隆过滤器是一种数据结构,在查询缓存和数据库之前，利用布隆过滤器来存储这个 key ，判断key是否存在,存在则直接放行.如果该key不存在则直接被拦截返回，不必查询缓存或数据库，节约存储空间。
    </p>
    <p>
     对疯狂请求不存在数据的ip进行拉黑
    </p>
    <p>
     缓存穿透无敌解决方法(能用上的方法全用上 ^_^ ) 布隆过滤器+空对象+分布式锁:
    </p>
    <p>
     1.当缓存不存在时，先通过布隆过滤器进行初步筛选,
    </p>
    <p>
     2.如果布隆过滤器判定数据可能存在，则检查是否存在空对象缓存。
    </p>
    <p>
     3.如果空对象缓存不存在，再使用分布式锁防止多个相同请求同时访问数据库。
    </p>
    <p>
     4.最后，如果数据库查询结果为空，将结果缓存为空对象，以防后续重复查询
    </p>
    <h4 id="2.2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" name="2.2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">
     2.2缓存击穿
    </h4>
    <p>
     <strong>
      缓存击穿
     </strong>
     是指某个
     <strong>
      热点数据
     </strong>
     在缓存中失效的
     <strong>
      瞬间
     </strong>
     有大量的并发请求同时访问该数据，由于该数据在缓存中失效，大量请求同时访问数据库，造成数据库压力骤增。这种情况通常发生在热点数据或访问频繁的数据上。
    </p>
    <p>
     <strong>
      如何解决?
     </strong>
     <strong>
      互斥锁机制
     </strong>
     :当缓存失效时，通过加锁的方式保证只有一个线程去查询数据库并更新缓存，其他线程等待缓存更新完成后再获取数据。
    </p>
    <p>
     缓存不设置过期时间:对于极为重要的热点数据，可以设置其缓存永不过期，同时后台启动线程定期刷新该缓存,但如果重要的热点数据过多,不推荐此方法
    </p>
    <p>
     监控热门数据，实时调整key的过期时长
    </p>
    <h4 id="2.3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" name="2.3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">
     <strong>
      2.3缓存雪崩
     </strong>
    </h4>
    <p>
     redis中
     <strong>
      大量key同时过期
     </strong>
     ，导致大量请求直接访问数据库，瞬间引发数据库压力激增，甚至导致数据库崩溃。
    </p>
    <p>
     如何解决? 缓存的过期时间使用随机值,这样减少了大量缓存同时过期的情况.
    </p>
    <p>
     实时调整，监控哪些数据是热门数据，实时的调整key的过期时长.
    </p>
    <p>
     使用锁机制,未获取锁的请求只能进行等待
    </p>
    <h3 id="3.redis%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96" name="3.redis%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96">
     3.redis如何持久化
    </h3>
    <p>
     Redis 是
     <strong>
      基于内存
     </strong>
     的数据库，但为了防止数据丢失，它提供了
     <strong>
      两种持久化机制
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        RDB（Redis Database）—— 快照存储
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        AOF（Append Only File）—— 追加日志存储
       </strong>
      </p>
     </li>
    </ol>
    <h4 id="1.%20RDB%EF%BC%88%E5%BF%AB%E7%85%A7%E5%AD%98%E5%82%A8%EF%BC%89" name="1.%20RDB%EF%BC%88%E5%BF%AB%E7%85%A7%E5%AD%98%E5%82%A8%EF%BC%89">
     <strong>
      1. RDB（快照存储）
     </strong>
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：Redis 以
     <strong>
      二进制快照
     </strong>
     的形式将数据库的
     <strong>
      整个数据
     </strong>
     保存到磁盘文件（
     <code>
      .rdb
     </code>
     ）中，在发生故障时可以恢复。
    </p>
    <p>
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ✅ 适用于
     <strong>
      大规模数据的定期备份
     </strong>
     ，恢复速度快。 ✅ 占用空间小，存储效率高。 ❌ 如果 Redis
     <strong>
      意外崩溃
     </strong>
     ，则
     <strong>
      最后一次快照之后的数据可能丢失
     </strong>
     。
    </p>
    <h4 id="2.%20AOF%EF%BC%88%E8%BF%BD%E5%8A%A0%E6%97%A5%E5%BF%97%EF%BC%89" name="2.%20AOF%EF%BC%88%E8%BF%BD%E5%8A%A0%E6%97%A5%E5%BF%97%EF%BC%89">
     <strong>
      2. AOF（追加日志）
     </strong>
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：Redis 记录所有的
     <strong>
      写操作命令
     </strong>
     （如
     <code>
      SET
     </code>
     、
     <code>
      DEL
     </code>
     ），并将它们
     <strong>
      以日志形式
     </strong>
     （
     <code>
      .aof
     </code>
     文件）追加到磁盘，Redis
     <strong>
      重启时可重放这些命令恢复数据
     </strong>
     。
    </p>
    <p>
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ✅
     <strong>
      数据安全
     </strong>
     ，即使 Redis
     <strong>
      意外崩溃
     </strong>
     ，
     <strong>
      AOF 也能最大限度减少数据丢失
     </strong>
     。 ✅ 适用于
     <strong>
      高实时性数据
     </strong>
     （例如：秒杀、交易系统）。 ❌
     <strong>
      日志文件较大
     </strong>
     ，可能会影响 Redis 启动速度。
    </p>
    <h3 id="4.Redis%20%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5" name="4.Redis%20%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">
     4.
     <strong>
      Redis 的过期策略和内存淘汰策略
     </strong>
    </h3>
    <p>
     Redis 作为
     <strong>
      内存数据库
     </strong>
     ，存储空间是有限的，因此需要
     <strong>
      过期策略
     </strong>
     和
     <strong>
      内存淘汰策略
     </strong>
     来管理数据。
    </p>
    <h4 id="4.1%20Redis%20%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%EF%BC%88%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%EF%BC%89" name="4.1%20Redis%20%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%EF%BC%88%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%EF%BC%89">
     <strong>
      4.1 Redis 过期策略（如何删除过期数据）
     </strong>
    </h4>
    <p>
     Redis 允许
     <strong>
      设置键的过期时间
     </strong>
     （TTL），当键过期后，就会被删除。Redis 提供了
     <strong>
      三种删除策略
     </strong>
     ：
    </p>
    <p>
     <strong>
      （1）定期删除（默认）
     </strong>
    </p>
    <p>
     <strong>
      机制
     </strong>
     ：Redis
     <strong>
      每 100ms
     </strong>
     进行一次
     <strong>
      过期键的扫描
     </strong>
     ，随机检查一部分过期键，并删除过期的键。
    </p>
    <p>
     ✅
     <strong>
      优点
     </strong>
     ：减少了系统负担，不会影响 Redis 性能。 ❌
     <strong>
      缺点
     </strong>
     ：如果过期键过多，可能
     <strong>
      不会一次性删除完
     </strong>
     ，导致
     <strong>
      内存占用增加
     </strong>
     。
    </p>
    <p>
     <strong>
      （2）惰性删除
     </strong>
    </p>
    <p>
     <strong>
      机制
     </strong>
     ：当
     <strong>
      客户端访问一个键
     </strong>
     时，Redis 发现它已经
     <strong>
      过期
     </strong>
     ，就会
     <strong>
      立刻删除
     </strong>
     这个键。
    </p>
    <p>
     ✅
     <strong>
      优点
     </strong>
     ：仅在访问时删除，减少 CPU 负担。 ❌
     <strong>
      缺点
     </strong>
     ：如果某些键
     <strong>
      一直不被访问
     </strong>
     ，它们可能
     <strong>
      不会被删除
     </strong>
     ，从而
     <strong>
      占用内存
     </strong>
     。
    </p>
    <p>
     <strong>
      （3）定期删除 + 惰性删除（默认策略）
     </strong>
    </p>
    <p>
     Redis 默认使用
     <strong>
      定期删除 + 惰性删除
     </strong>
     ，既能避免频繁扫描，也能确保访问时自动删除过期键。
    </p>
    <h4 id="4.2Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5" name="4.2Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">
     4.2Redis内存淘汰策略
    </h4>
    <p>
     如果 Redis
     <strong>
      占满了可用内存
     </strong>
     ，就需要删除一些数据来释放空间。Redis 提供了
     <strong>
      6 种内存淘汰策略
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        策略名称
       </th>
       <th>
        说明
       </th>
       <th>
        适用场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         noeviction（默认）
        </strong>
       </td>
       <td>
        不删除任何数据，直接报错（写入失败）
       </td>
       <td>
        适合
        <strong>
         持久化数据
        </strong>
        ，不希望丢失
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         allkeys-lru
        </strong>
       </td>
       <td>
        删除
        <strong>
         最久未使用
        </strong>
        的键（全局 LRU）
       </td>
       <td>
        适用于
        <strong>
         缓存
        </strong>
        ，需要高命中率
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         volatile-lru
        </strong>
       </td>
       <td>
        删除
        <strong>
         设置了过期时间
        </strong>
        的最久未使用键
       </td>
       <td>
        适用于
        <strong>
         缓存+持久化
        </strong>
        混合场景
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         allkeys-random
        </strong>
       </td>
       <td>
        随机删除
        <strong>
         任何键
        </strong>
       </td>
       <td>
        适用于
        <strong>
         无固定热点
        </strong>
        的场景
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         volatile-random
        </strong>
       </td>
       <td>
        只随机删除
        <strong>
         有过期时间
        </strong>
        的键
       </td>
       <td>
        适用于
        <strong>
         部分数据需要持久化
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         volatile-ttl
        </strong>
       </td>
       <td>
        优先删除
        <strong>
         过期时间最短
        </strong>
        的键
       </td>
       <td>
        适用于
        <strong>
         定期更新数据
        </strong>
        的场景
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="5.Redis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" name="5.Redis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">
     5.Redis的分布式锁
    </h3>
    <p>
     Redis 的分布式锁是一种
     <strong>
      基于 Redis 实现的分布式并发控制机制
     </strong>
     ，用于保证多个进程或线程在分布式环境下对共享资源的
     <strong>
      互斥访问
     </strong>
     。
    </p>
    <h4 id="5.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F" name="5.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F">
     <strong>
      5.1 为什么需要分布式锁？
     </strong>
    </h4>
    <p>
     在
     <strong>
      分布式系统
     </strong>
     中，多个应用可能会
     <strong>
      同时
     </strong>
     操作同一个资源（如库存、订单等），导致数据
     <strong>
      不一致
     </strong>
     ，这时就需要
     <strong>
      分布式锁
     </strong>
     来保证
     <strong>
      同一时间
     </strong>
     只有一个进程能执行操作。
    </p>
    <p>
     <strong>
      示例问题
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        秒杀系统
       </strong>
       ：多个用户同时抢购，导致库存超卖。
      </p>
     </li>
     <li>
      <p>
       <strong>
        订单支付
       </strong>
       ：用户 A 和 B 同时支付同一笔订单，可能出现
       <strong>
        重复扣款
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        任务调度
       </strong>
       ：多个服务器执行同一任务，可能导致任务被执行
       <strong>
        多次
       </strong>
       。
      </p>
     </li>
    </ul>
    <h4 id="5.2%20Redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0" name="5.2%20Redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0">
     <strong>
      5.2 Redis 分布式锁的基本实现
     </strong>
    </h4>
    <p>
     使用
     <code>
      SETNX
     </code>
     （SET if Not Exists） 命令创建锁：
    </p>
    <pre>SETNX mylock "locked"</pre>
    <p>
     <strong>
      锁的基本实现
     </strong>
    </p>
    <pre>public boolean tryLock(String lockKey, String requestId, int expireTime) {
    String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);
    return "OK".equals(result);
}</pre>
    <p>
     ✅
     <strong>
      解释
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        lockKey
       </code>
       ：锁的 key（比如
       <code>
        "order_lock"
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <code>
        requestId
       </code>
       ：每个锁
       <strong>
        唯一
       </strong>
       的 ID，保证同一客户端能释放自己的锁。
      </p>
     </li>
     <li>
      <p>
       <code>
        "NX"
       </code>
       ：只在 key
       <strong>
        不存在
       </strong>
       时才设置（保证互斥性）。
      </p>
     </li>
     <li>
      <p>
       <code>
        "PX expireTime"
       </code>
       ：自动
       <strong>
        过期时间
       </strong>
       （避免死锁）。
      </p>
     </li>
     <li>
      <p>
       <code>
        "OK".equals(result)
       </code>
       ：返回
       <code>
        "OK"
       </code>
       表示加锁成功。
      </p>
     </li>
    </ul>
    <p>
     🔴
     <strong>
      问题
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        锁可能无法释放
       </strong>
       ：如果服务崩溃，锁不会自动释放，导致死锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        误删其他线程的锁
       </strong>
       ：如果锁过期后被其他线程重新加锁，当前线程仍然认为自己持有锁，会误删别人的锁。
      </p>
     </li>
    </ol>
    <h4 id="5.3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96" name="5.3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96">
     5.3分布式锁的优化
    </h4>
    <p>
     <strong>
      （1）设置锁的自动过期时间
     </strong>
    </p>
    <p>
     防止
     <strong>
      死锁
     </strong>
     ：
    </p>
    <pre>SET order_lock "locked" NX PX 10000</pre>
    <p>
     NX表示key不存在时才创建，保证互斥性
    </p>
    <p>
     PX 10000 → 10 秒后自动释放锁
    </p>
    <p>
     <strong>
      （2）使用 Redisson 实现分布式锁
     </strong>
    </p>
    <p>
     <a href="https://github.com/redisson/redisson" title="Redisson">
      Redisson
     </a>
     是 Redis 官方推荐的 Java 客户端，提供了
     <strong>
      高效
     </strong>
     的分布式锁实现：
    </p>
    <pre>RLock lock = redissonClient.getLock("order_lock");
try {
    lock.lock(10, TimeUnit.SECONDS);
    // 执行业务逻辑
} finally {
    lock.unlock();//释放锁
}</pre>
    <p>
     <strong>
      Redisson 优势
     </strong>
     ：
    </p>
    <p>
     自动续期（Watchdog 机制）：如果持有锁的线程还在执行，Redisson 会自动延长锁的过期时间。 避免误删锁：保证释放的是自己的锁。
    </p>
    <p>
     <strong>
      Redis 分布式锁核心要点
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        使用
        <code>
         SETNX
        </code>
        +
        <code>
         PX
        </code>
        设定锁的过期时间
       </strong>
       ，避免死锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        删除锁时使用 Lua 脚本
       </strong>
       ，保证
       <strong>
        原子性
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        使用 Redisson 进行优化
       </strong>
       ，提供自动续期，避免误删锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        适用于高并发场景
       </strong>
       （如秒杀、库存扣减），但可靠性不如 Zookeeper。
      </p>
     </li>
    </ol>
    <p>
     Redis 分布式锁虽然
     <strong>
      高效
     </strong>
     ，但并非绝对可靠，建议使用
     <strong>
      Redisson
     </strong>
     或
     <strong>
      Zookeeper
     </strong>
     进行优化！ 🚀
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37343432313939302f:61727469636c652f64657461696c732f313436323534303639" class_="artid" style="display:none">
 </p>
</div>


