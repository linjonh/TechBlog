---
layout: post
title: "栈和队列2"
date: 2025-03-06 17:07:49 +0800
description: "上篇文章，我们讲到栈是用数组实现的，它入栈和出栈的时间复杂度都是O（1），那我如果要使用链表来实现栈应该怎么做呢？那我们先假设使用(找到链表的倒数第一个元素)。(找到链表的倒数第二个元素)。那么此时，有聪明的同学可能会想到：那我如果给它再加一个尾巴节点时间复杂度又是多少呢？因为有last节点，时间复杂度变为时间复杂度仍为,因为是单链表last只能找到last后面的节点无法找到它前面的节点。时间复杂度。由于栈的特性，时间复杂度也为因此，在使用单链表实现栈时一般采用头插法。"
keywords: "栈和队列2"
categories: ['未分类']
tags: ['开发语言', 'Java']
artid: "146032691"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146032691
    alt: "栈和队列2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146032691
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146032691
cover: https://bing.ee123.net/img/rand?artid=146032691
image: https://bing.ee123.net/img/rand?artid=146032691
img: https://bing.ee123.net/img/rand?artid=146032691
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     栈和队列2
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1、链表实现栈
    </h2>
    <p>
     上篇文章，我们讲到栈是用数组实现的，它入栈和出栈的时间复杂度都是O（1），那我如果要使用链表来实现栈应该怎么做呢？
    </p>
    <p>
     那我们先假设使用
     <strong>
      单链表
     </strong>
     能否实现栈：
     <img alt="" height="530" src="https://i-blog.csdnimg.cn/direct/904ac491467146c197034bb646495ef8.png" width="1716"/>
    </p>
    <p>
     <strong>
      尾插法：
     </strong>
    </p>
    <p>
     <strong>
      入栈：
     </strong>
     时间复杂度：
     <strong>
      O（n）
     </strong>
     (找到链表的倒数第一个元素)。
    </p>
    <p>
     <strong>
      出栈：
     </strong>
     时间复杂度：
     <strong>
      O（n）
     </strong>
     (找到链表的倒数第二个元素)。
    </p>
    <p>
     那么此时，有聪明的同学可能会想到：那我如果给它再加一个尾巴节点时间复杂度又是多少呢？
     <img alt="" height="497" src="https://i-blog.csdnimg.cn/direct/997092464d3f4dc2b1143e0d2d785569.png" width="1685">
      <strong>
       入栈：
      </strong>
      因为有last节点，时间复杂度变为
      <strong>
       O（1
      </strong>
      ）。
     </img>
    </p>
    <p>
     <strong>
      出栈：
     </strong>
     时间复杂度仍为
     <strong>
      O（n）
     </strong>
     ,因为是单链表last只能找到last后面的节点无法找到它前面的节点。
    </p>
    <p>
     <strong>
      头插法：
     </strong>
    </p>
    <p>
     <strong>
      入栈：
     </strong>
     时间复杂度
     <strong>
      O（1）
     </strong>
     。
    </p>
    <p>
     <strong>
      出栈：
     </strong>
     由于栈
     <strong>
      先进后出
     </strong>
     的特性，时间复杂度也为
     <strong>
      O（1）。
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       因此，在使用单链表实现栈时一般采用头插法。
      </span>
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     假设
     <strong>
      双链表
     </strong>
     实现栈：
     <img alt="" height="744" src="https://i-blog.csdnimg.cn/direct/66decd5a04994a34abb22b135a974788.png" width="1839"/>
    </p>
    <p>
     如果使用双链表实现栈：那么无论从那边出入栈时间复杂度都为O（1）。
    </p>
    <p>
     如下代码所示：就是用链表创建了一个名为stack的对象，它可以正常使用push（），pop（），isEmpty()。
    </p>
    <pre><code>        LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();
        System.out.println(stack.isEmpty());
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack.peek());</code></pre>
    <p>
     点进LinkedList中，可以看见LinkedList的底层是实现了这些方法的。
    </p>
    <p>
     <img alt="" height="900" src="https://i-blog.csdnimg.cn/direct/a89b41d144b34304b034737a6b6e4e6c.png" width="1085"/>
    </p>
    <h2>
     2、队列
    </h2>
    <h3>
     2.1 概念
    </h3>
    <p>
     <strong>
      队列
     </strong>
     ：只允许在
     <strong>
      一端进行插入数据操作
     </strong>
     ，在
     <strong>
      另一端进行删除数据操作
     </strong>
     的特殊
     <strong>
      线性表
     </strong>
     ，队列具有
     <strong>
      先进先出FIFO(First In First Out)
     </strong>
     的特性。
     <strong>
      入队列
     </strong>
     ：进行
     <strong>
      插入操作
     </strong>
     的一段称为
     <strong>
      队尾
     </strong>
     。
     <strong>
      出队列
     </strong>
     ：进行
     <strong>
      删除操作
     </strong>
     的一端称为
     <strong>
      队头
     </strong>
     。
    </p>
    <p>
     <img alt="" height="916" src="https://i-blog.csdnimg.cn/direct/f2d71d9386f746329e735664298db35b.png" width="1530"/>
    </p>
    <p>
     我们也可以将链表当作一个队列，入队时使用尾插法，出队时删除头节点即可。 代码如下：
    </p>
    <pre><code>        //普通队列
        Queue&lt;Integer&gt; queue1 = new LinkedList&lt;&gt;();
        //入队
        queue1.offer(1);
        queue1.offer(2);
        queue1.offer(3);
        queue1.add(4);
        System.out.println(queue1);
        //出队
        System.out.println(queue1.poll());//1
        //获取队头元素
        System.out.println(queue1.peek());//2</code></pre>
    <h3>
     2.2 队列的使用
    </h3>
    <p>
     <strong>
      在Java中,
     </strong>
     <strong>
      Queue是一个接口，而链表实现了这个接口
     </strong>
    </p>
    <p>
     <img alt="" height="749" src="https://i-blog.csdnimg.cn/direct/2add6b0d7cbf46aa913f674554056f2f.png" width="1645"/>
    </p>
    <p>
     那细心的同学就会发现Queue下面还有个Deque，那这个Deque是什么呢？
    </p>
    <p>
     Deque是双端队列，能够在同一端进出元素。
     <img alt="" height="628" src="https://i-blog.csdnimg.cn/direct/0ade58b0803f4631847022a1e02f6959.png" width="1678"/>
    </p>
    <p>
     常用方法有这些：
     <img alt="" height="299" src="https://i-blog.csdnimg.cn/direct/9f7452b18e014b97840642d163342b18.png" width="964"/>
     <strong>
      <span style="color:#fe2c24">
       注意：因为Queue只是一个接口，实例化的时候，必须要实例化一个LinkedList的对象，因为是LinkedList实现了Queue接口 。
      </span>
     </strong>
    </p>
    <p>
     <span style="color:#fe2c24">
     </span>
     <span style="color:#0d0016">
      在Queue的结构中，不止存在offer( ),poll( )和peek( )还存在add( ),remove( )和element方法，
     </span>
    </p>
    <p>
     <img alt="" height="352" src="https://i-blog.csdnimg.cn/direct/bf9458267e7149b29fc44f73c5723fd0.png" width="689"/>
    </p>
    <p>
     在Java的Queue接口中，add/offer、remove/poll、element/peek
     <strong>
     </strong>
     是两组
     <span style="color:#fe2c24">
      <strong>
       功能类似但行为不同
      </strong>
     </span>
     的方法。他们的核心区别在于
     <span style="color:#fe2c24">
      <strong>
       对队列边界条件（满或空）
      </strong>
     </span>
     的处理方式 。
     <img alt="" height="484" src="https://i-blog.csdnimg.cn/direct/a15f9458d35b40d6870d4349e9309264.png" width="1564"/>
    </p>
    <p>
     <img alt="" height="193" src="https://i-blog.csdnimg.cn/direct/fd68fb7e4ed74e5db000875de3b6c31a.png" width="843"/>
    </p>
    <p>
     可以看到使用add（）方法在队列满时抛出了异常。
     <img alt="" height="197" src="https://i-blog.csdnimg.cn/direct/656a156997f44fe2bedc237d92ebe92c.png" width="847"/>
     <img alt="" height="215" src="https://i-blog.csdnimg.cn/direct/058ed6278e1b480a84a14494a1edf10a.png" width="1084"/>
    </p>
    <p>
     在队列未满时，offer( )返回true，队列满了则返回false，不报异常。
    </p>
    <p>
     <img alt="" height="559" src="https://i-blog.csdnimg.cn/direct/c34d5f3a50db44c794ccde3a4cf3b8f3.png" width="1573"/>
     在队列为空时：poll( )方法返回空
    </p>
    <p>
     <img alt="" height="126" src="https://i-blog.csdnimg.cn/direct/a5e2816eeb5947259b6670d399ca1947.png" width="556"/>
    </p>
    <p>
     <img alt="" height="37" src="https://i-blog.csdnimg.cn/direct/f15f769047dd4db095c4e84376c28879.png" width="725"/>
     remove( )方法报异常
     <img alt="" height="165" src="https://i-blog.csdnimg.cn/direct/655b9be3648743028b9bdc00ba39055e.png" width="669"/>
    </p>
    <p>
     <img alt="" height="251" src="https://i-blog.csdnimg.cn/direct/644be79a132840618bcc63279a807df3.png" width="2369"/>
     <img alt="" height="511" src="https://i-blog.csdnimg.cn/direct/5fb7227cbafb491f8717ce3d7ee4c8f8.png" width="1551"/>
    </p>
    <p>
     在队列为空时：peek( )方法返回空
     <img alt="" height="128" src="https://i-blog.csdnimg.cn/direct/67910675b8e844788c437c111ce9977d.png" width="547"/>
     <img alt="" height="154" src="https://i-blog.csdnimg.cn/direct/1579a725af0e409889c3e586e4c9a27f.png" width="522"/>
    </p>
    <p>
     element（ ）方法抛异常
     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/417554738efb46d8bdaed111f3ddedaa.png" width="896"/>
    </p>
    <h2>
     <img alt="" height="236" src="https://i-blog.csdnimg.cn/direct/03f261bcb2f6421eb36380f3fa8dc15d.png" width="1555"/>
     3、队列的模拟实现
    </h2>
    <p>
     我们使用双向链表来实现一个队列：
     <img alt="" height="467" src="https://i-blog.csdnimg.cn/direct/204933ff6eb0449a85d72fe6693de4b4.png" width="1138"/>
    </p>
    <pre><code>//双向链表的节点    
static class ListNode {
        private int val;
        private ListNode prev;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
        private ListNode front;//队头
        private ListNode rear;//队尾
        private int usedSize;</code></pre>
    <h3>
     3.1 offer( )方法
    </h3>
    <p>
     使用头插法，进行入队。
    </p>
    <pre><code> //在头插入元素
    public void offer(int x){
        ListNode listNode = new ListNode(x);
        if(front == null){//第一次插入
            front = rear = listNode;
        }else{
            listNode.next = front;
            front.prev = listNode;
            front = listNode;
        }
        usedSize++;
    }</code></pre>
    <h3>
     3.2 poll( )方法
    </h3>
    <p>
     在上面的offer（ ）方法中我们使用头插法进行插入，根据先进先出的原则，应当在尾巴节点进行删除。
    </p>
    <pre><code>//出队列  相当于删除尾巴结点
    public int poll(){
        if(front == null){
            throw new NullElementException("没有元素可被删除");
        }
        if(front == rear){
            int x = front.val;
            front = null;
            rear = null;
            usedSize--;
            return x;
        }
        int ret = rear.val;
        rear = rear.prev;
        rear.next = null;
        usedSize--;
        return ret;
    }</code></pre>
    <h3>
     3.3 peek( )方法
    </h3>
    <pre><code>    public int peek(){
        if(front == null){
            throw new NullElementException("没有元素可被删除");
        }
        return rear.val;
    }</code></pre>
    <h3>
     3.4 isEmpty( )
    </h3>
    <pre><code>    public  boolean isEmpty(){
        return usedSize == 0;
    }</code></pre>
    <h2>
     4、双端队列
    </h2>
    <p>
     双端队列：指允许两端都可以进行入队和出队操作的队列，deque是"double ended queue"的简称。那就说明元素可以从队头出队和入队，也可以从队尾出队和入队。
    </p>
    <p>
     <img alt="" height="197" src="https://i-blog.csdnimg.cn/direct/eebce17f5f37418190bee5091a4a62c5.png" width="873"/>
     <strong>
      <span style="color:#fe2c24">
       注意：Queue和Queue都是一个接口，使用时必须创建LinkList对象。
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="760" src="https://i-blog.csdnimg.cn/direct/3a9ae4edd3934054b36fa02492d464ee.png" width="1579"/>
    </p>
    <p>
     可以看到Stack也实现了Deque接口，所以有了如下代码：
    </p>
    <pre><code> Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();
        stack.push(1);
        stack.offer(2);</code></pre>
    <p>
     此外，双端队列可以有线性数组实现和链式实现 ：
    </p>
    <pre><code>        Deque&lt;Integer&gt; deque1 = new ArrayDeque&lt;&gt;();//双端队列的数组实现
        Deque&lt;Integer&gt; deque2 = new LinkedList&lt;&gt;();//双端队列的链式实现</code></pre>
    <h2>
     5、 面试题
    </h2>
    <h3>
     5.1
     <a href="https://leetcode.cn/problems/design-circular-queue/description/" rel="nofollow" title="622. 设计循环队列 - 力扣（LeetCode）">
      622. 设计循环队列 - 力扣（LeetCode）
     </a>
     <img alt="" height="775" src="https://i-blog.csdnimg.cn/direct/f64361175ed54034944e5152edeb982a.png" width="1236"/>
     那么我们要如何实现这个队列呢？首先，我们知道，通过数组也可以实现队列：
     <img alt="" height="453" src="https://i-blog.csdnimg.cn/direct/17f016c98ab643e3bf6436322c6307f7.png" width="1620"/>
    </h3>
    <p>
     队尾进，队头出，插入完后rear++。入队完成后：
     <img alt="" height="479" src="https://i-blog.csdnimg.cn/direct/1d01f4b010fd46adb49c129ff7680c59.png" width="1635"/>
     出队的时候，只需要让front++即可，但是这么做会浪费出队元素的空间，那个空间无法再进行入队。
    </p>
    <p>
     这时候我们想到可以让数组循环起来，这样就不会浪费那个空间，那如何让数组循环起来呢？很简单嘛，就像我们玩软尺一样，把数组卷起来不就行了！！！
    </p>
    <p>
     front表示数组的第一个元素的下标，rear表示当前可插入元素的下标。
     <img alt="" height="547" src="https://i-blog.csdnimg.cn/direct/e04ef21a7c464b748923fcc89a4cb424.png" width="1518"/>
    </p>
    <p>
     这时候如果要元素出队，只需让front往后走就行了，并不会影响后面的元素入队。
     <img alt="" height="687" src="https://i-blog.csdnimg.cn/direct/e6f88c54bd7b4cb4b1892c483c554ddd.png" width="1010"/>
     <img alt="" height="694" src="https://i-blog.csdnimg.cn/direct/4aee39987bc841e0b6606f8c080d6bb5.png" width="1035"/>
    </p>
    <p>
     由上面所述，我们知道了循环队列通过数组实现，但实现循环队列还有最重要的一点：判断队列是否已满。
    </p>
    <p>
     判断队列是否已满可以采用3种方法：
    </p>
    <p>
     1、定义一个Usesized，入队Usesized++,出队Usesized--，当Usesized == 数组长度时，说明数组已满。
    </p>
    <p>
     2、定义一个flg（Boolean），当第二次rear == front时，说明队列已满，此时flg = true。
    </p>
    <p>
     3、浪费一个空间来进行区分，当rear的下一个就是front说明队列已满。效果如图所示：
     <img alt="" height="727" src="https://i-blog.csdnimg.cn/direct/0166dbb61bee410caf2e821d61590361.png" width="1138"/>
    </p>
    <p>
     那现在问题又来了，这里数组被卷起来了，如果想让rear往后走还是rear++吗？显然不对，通过上图，7的后面的下标是0，而你++后的下标应该是8。所以，这里让rear往后走应该是
     <span style="color:#fe2c24">
      （rear + 1）% length(数组长度) ，front同理：（front + 1）% length。
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
     </span>
     <span style="color:#0d0016">
      综上所述很容易得到下述代码：
     </span>
    </p>
    <pre><code class="hljs"> //通过数组实现循环队列
    //判定：循环队列是否已满：1、定义usesized==len
    //2、标记
    //3、浪费一个空间进行区分
    private int[] elem;
    private int front;//队头下标
    private int rear;//队尾下标
    public MyCircularQueue(int k) {
        elem = new int[k+1];
    }
    //入队
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        elem[rear] = value;
        rear = (rear+1) % elem.length;
        return true;
    }
    //从队头出队
    public boolean deQueue() {
        //空的 不能出
        if(isEmpty()){
            return false;
        }
        //不空 则保存队头元素    然后front往后走
        //（当前位置+偏移次数）%数组长度
        front = (front+1)%elem.length;
        return true;
    }
    //得到队头元素
    public int Front() {
        if (isEmpty()){
            return -1;
        }
        return elem[front];
    }
    //得到队尾元素
    public int Rear() {
        if (isEmpty()){
            return -1;
        }
        //判断队尾的前一个是否合法
        int index = rear == 0 ? (elem.length-1) : (rear-1);
        return elem[index];
    }

    public boolean isEmpty() {
        return front == rear;
    }

    public boolean isFull() {
        return (rear+1) % elem.length == front;
    }</code></pre>
    <p>
     <span style="color:#fe2c24">
      这里还需要注意：1、若队列不为空时，获取队尾元素时rear==0，说明rear已经走了一圈回来了，不能通过rear-1获取队尾元素，而是通过elem.length-1下标来获取。
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      2、因为我们需要多一个空间来判断数组是否已满，所以需要申请k+1个空间。
     </span>
    </p>
    <h3>
     5.2
     <a href="https://leetcode.cn/problems/implement-stack-using-queues/description/" rel="nofollow" title="225. 用队列实现栈 - 力扣（LeetCode）">
      225. 用队列实现栈 - 力扣（LeetCode）
     </a>
    </h3>
    <p>
     这里先提出一个问题，一个队列能够实现栈吗？答案是不能，因为队列是先进先出的数据结构；而栈是先进后出的数据结构。一个队列根本实现不了栈，所以我们需要两个队列。
     <img alt="" height="487" src="https://i-blog.csdnimg.cn/direct/e2ecb807189246a39d1ae329ff9302f2.png" width="1131"/>
     当qu1和qu2都为空时说明，我们模拟实现的栈为空。
    </p>
    <p>
     出栈：因为栈要出的是栈顶的元素，也就是队列中最后一个出的元素，所以我们可以在不为空的队列中先出size() - 1个元素，最后剩下的那个元素就是我们要出的元素。
    </p>
    <p>
     入栈：入到不为空的队列即可，如果两个队列都为空就入到qu1。
    </p>
    <p>
     <strong>
      入栈：
     </strong>
     <img alt="" height="431" src="https://i-blog.csdnimg.cn/direct/2ddecfb60f5b43b489933d0b25005d8c.png" width="977"/>
    </p>
    <p>
     <strong>
      出栈
     </strong>
     ：
     <img alt="" height="595" src="https://i-blog.csdnimg.cn/direct/0fae94bbd4f248d3b35cf6cf0bbf2c25.png" width="960"/>
    </p>
    <p>
     <strong>
      top方法：
     </strong>
     将不为空的队列的元素全部出队，最后一个出队的元素就是栈顶元素。
    </p>
    <pre><code class="hljs">class MyStack {
  Queue&lt;Integer&gt; queue1;
  Queue&lt;Integer&gt; queue2;
    public MyStack() {
        queue1 = new LinkedList&lt;&gt;();
        queue2 = new LinkedList&lt;&gt;();
    }
    //入栈:入到不为空的队列,如果都为空，入到qu1即可
    public void push(int x) {
        if(!queue1.isEmpty()){
            queue1.offer(x);
        }else if (!queue2.isEmpty()){
            queue2.offer(x);
        }else{
            queue1.offer(x);
        }
    }
    //出栈时，出不为空的队列，出size-1个，最后那一个就是我要出栈的元素
    public int pop() {
        if (empty()){
            return -1;
        }
        if(!queue1.isEmpty()){
            int size = queue1.size();//这里的队列的长度随着元素的弹出会改变
            for (int i = 0; i &lt; size-1; i++) {
                int x = queue1.poll();
                queue2.offer(x);
            }
            return queue1.poll();
        } else {
            int size = queue2.size();
            for (int i = 0; i &lt; size-1; i++) {
               int x = queue2.poll();
               queue1.offer(x);
           }
           return queue2.poll();
        }
    }
    //peek
    //将所有元素通过tmp记录后入到另一个栈里面，最后tmp记录的元素就是我要peek的元素
    public int top() {
        if (empty()){
            return -1;
        }
        int x = -1;
        if(!queue1.isEmpty()){
            int size = queue1.size();//这里的队列的长度随着元素的弹出会改变
            for (int i = 0; i &lt; size; i++) {
                 x = queue1.poll();
                queue2.offer(x);
            }
            return x;
        } else {
            int size = queue2.size();
            for (int i = 0; i &lt; size; i++) {
                x = queue2.poll();
                queue1.offer(x);
            }
            return x;
        }
    }
    //栈是否为空
    public boolean empty() {
        //两个队列都为空的时候，说明我模拟实现的栈为空
        return queue1.isEmpty() &amp;&amp; queue2.isEmpty();
    }
}</code></pre>
    <p>
     <span style="color:#fe2c24">
      需要注意的是因为在出栈的过程中，栈的长度在不断变小，所以需要定义一个变量获取栈的长度，防止出栈出少元素。
     </span>
    </p>
    <h3>
     5.3
     <a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow" title="232. 用栈实现队列 - 力扣（LeetCode）">
      232. 用栈实现队列 - 力扣（LeetCode）
     </a>
    </h3>
    <p>
     一个队列实现不了栈，那一个栈能实现队列吗?同样不能，所以我们同样需要两个栈来实现队列。
    </p>
    <p>
     <strong>
      入队：
     </strong>
     直接将所有元素入到s1(第一个栈)。
    </p>
    <p>
     <strong>
      出队：
     </strong>
     将s1（第一个栈）的元素全部倒到s2（第二个栈）中，再出第二个栈的元素。
    </p>
    <p>
     <strong>
      入队
     </strong>
     ：
     <img alt="" height="353" src="https://i-blog.csdnimg.cn/direct/d021b104e3c24704a70220b1fc420ad7.png" width="1178"/>
    </p>
    <p>
     <strong>
      出队 ：
     </strong>
     <img alt="" height="346" src="https://i-blog.csdnimg.cn/direct/8a8530e997c446179d792a3c6bd5fc56.png" width="1169"/>
    </p>
    <pre><code class="hljs">class MyQueue {
   //入队时，把所有元素放到第一个栈中
    //出队时（判断空不空）把第一个栈的所有元素全部倒回第二个栈中，出第二个栈的栈顶元素
    //定义两个栈
    Stack&lt;Integer&gt; s1;
    Stack&lt;Integer&gt; s2;
    //构造方法
    public MyQueue() {
        s1 = new Stack&lt;&gt;();
        s2 = new Stack&lt;&gt;();
    }
    //统一入到s1
    public void push(int x) {
        s1.push(x);
    }
    //出的时候统一出s2的
    public int pop() {
        if(s1.empty()){
            return -1;
        }
        while(!s1.empty()){
            s2.push(s1.pop());
        }
        int x = s2.pop();
        while(!s2.empty()){
            s1.push(s2.pop());
        }
        return x;
    }

    public int peek() {
        if(s1.empty()){
            return -1;
        }
        while(!s1.empty()){
            s2.push(s1.pop());
        }
        int x = s2.peek();
        while(!s2.empty()){
            s1.push(s2.pop());
        }
        return x;
    }

    public boolean empty() {
        return s1.empty();
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f43784b363636363636372f:61727469636c652f64657461696c732f313436303332363931" class_="artid" style="display:none">
 </p>
</div>


