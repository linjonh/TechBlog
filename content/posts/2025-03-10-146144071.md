---
layout: post
title: "-ROWNUM-与-ROW_NUMBER-OVER-"
date: 2025-03-10 09:26:34 +0800
description: "可以实现更灵活的行号生成逻辑，但务必注意排序明确性和性能影响，特别是在生产环境的大数据量场景中。：为导出的Excel文件添加自增序号列。：为结果集的每一行生成唯一序号。：相同查询可能返回不同行号顺序。当处理百万级数据时，无排序的。时，两者都可能返回不同顺序。慢约 30%（测试数据）生成从1开始递增的序号列。整个结果集视为一个分区。分配（无明确排序保证）"
keywords: " ROWNUM 与 ROW_NUMBER() OVER ()"
categories: ['数据库']
tags: ['数据库', 'Sql', 'Oracle']
artid: "146144071"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146144071
    alt: "-ROWNUM-与-ROW_NUMBER-OVER-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146144071
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146144071
cover: https://bing.ee123.net/img/rand?artid=146144071
image: https://bing.ee123.net/img/rand?artid=146144071
img: https://bing.ee123.net/img/rand?artid=146144071
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ROWNUM 与 ROW_NUMBER() OVER ()
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h4 id="%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" name="%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">
     <strong>
      基础概念
     </strong>
    </h4>
    <h5 id="1.%20%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B" name="1.%20%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B">
     1. 函数原型
    </h5>
    <pre><code class="language-sql">ROW_NUMBER() OVER ([PARTITION BY 列] ORDER BY 排序列 [ASC|DESC]) </code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：为结果集的每一行生成唯一序号
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：当省略
       <code>
        PARTITION BY
       </code>
       和
       <code>
        ORDER BY
       </code>
       时：
      </p>
      <ul>
       <li>
        <p>
         整个结果集视为一个分区
        </p>
       </li>
       <li>
        <p>
         行号按数据库
         <strong>
          默认顺序
         </strong>
         分配（无明确排序保证）
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4 id="%E5%9C%A8%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E8%A1%A8%E7%8E%B0" name="%E5%9C%A8%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E8%A1%A8%E7%8E%B0">
     <strong>
      在示例代码中的具体表现
     </strong>
    </h4>
    <pre><code class="language-sql">SELECT 
  row_number() over () as rownum,  -- 生成行号
  other_columns...
FROM table</code></pre>
    <p>
     <strong>
      实际效果
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       生成从1开始递增的序号列
      </p>
     </li>
     <li>
      <p>
       序号分配顺序与
       <strong>
        物理存储顺序
       </strong>
       或
       <strong>
        执行计划数据访问顺序
       </strong>
       相关
      </p>
     </li>
     <li>
      <p>
       <strong>
        无稳定性保证
       </strong>
       ：相同查询可能返回不同行号顺序
      </p>
     </li>
    </ul>
    <h4 id="%E4%B8%8E%20ROWNUM%20%E4%BC%AA%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB" name="%E4%B8%8E%20ROWNUM%20%E4%BC%AA%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB">
     <strong>
      与 ROWNUM 伪列的区别
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        <code>
         ROW_NUMBER() OVER ()
        </code>
       </th>
       <th>
        <code>
         ROWNUM
        </code>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        生成阶段
       </td>
       <td>
        结果集确定后计算
       </td>
       <td>
        数据提取时即时生成
       </td>
      </tr>
      <tr>
       <td>
        排序影响
       </td>
       <td>
        可配合显式 ORDER BY 稳定序号
       </td>
       <td>
        受 WHERE 条件过滤顺序影响
       </td>
      </tr>
      <tr>
       <td>
        分页查询
       </td>
       <td>
        适合在已排序数据上分页
       </td>
       <td>
        需嵌套子查询实现分页
       </td>
      </tr>
      <tr>
       <td>
        性能
       </td>
       <td>
        有窗口函数计算开销
       </td>
       <td>
        原生支持无额外消耗
       </td>
      </tr>
      <tr>
       <td>
        典型应用场景
       </td>
       <td>
        复杂排序、分组编号
       </td>
       <td>
        简单行计数、限制返回行数
       </td>
      </tr>
     </tbody>
    </table>
    <h4 id="%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94" name="%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94">
     <strong>
      示例对比
     </strong>
    </h4>
    <h5 id="%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%91%98%E5%B7%A5%E8%A1%A8" name="%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%91%98%E5%B7%A5%E8%A1%A8">
     场景：查询员工表
    </h5>
    <pre><code class="language-sql">-- 使用 ROW_NUMBER()
SELECT 
  row_number() over () as rn, 
  employee_id, 
  last_name
FROM employees;

-- 使用 ROWNUM
SELECT 
  ROWNUM, 
  employee_id, 
  last_name
FROM employees;</code></pre>
    <pre></pre>
    <p>
     <strong>
      结果差异
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       当无
       <code>
        ORDER BY
       </code>
       时，两者都可能返回不同顺序
      </p>
     </li>
     <li>
      <p>
       添加排序后：
      </p>
      <pre><code class="language-sql">-- 稳定排序的行号
SELECT 
  row_number() over (ORDER BY hire_date) as rn,
  employee_id,
  last_name
FROM employees;

-- ROWNUM 需嵌套查询
SELECT 
  ROWNUM,
  t.*
FROM (
  SELECT 
    employee_id,
    last_name
  FROM employees
  ORDER BY hire_date
) t;</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4 id="%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" name="%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">
     <strong>
      典型应用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        数据导出编号
       </strong>
      </p>
      <pre><code class="language-sql">SELECT 
  row_number() over () as 序号,
  product_name,
  unit_price
FROM products</code></pre>
      <p>
       <strong>
        效果
       </strong>
       ：为导出的Excel文件添加自增序号列
      </p>
     </li>
     <li>
      <p>
       <strong>
        分页查询（需配合排序）
       </strong>
      </p>
      <pre><code class="language-sql">SELECT *
FROM (
  SELECT 
    row_number() over (ORDER BY create_time DESC) as rn,
    order_id,
    customer_id
  FROM orders
) 
WHERE rn BETWEEN 21 AND 40;</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        分组编号
       </strong>
      </p>
      <pre><code class="language-sql">SELECT 
  department_id,
  row_number() over (PARTITION BY department_id ORDER BY salary DESC) as rank,
  employee_name,
  salary
FROM employees;</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        性能问题
       </strong>
      </p>
      <blockquote>
       <ul>
        <li>
         <p>
          当处理百万级数据时，无排序的
          <code>
           row_number() over ()
          </code>
          比
          <code>
           ROWNUM
          </code>
          慢约 30%（测试数据）
         </p>
        </li>
        <li>
         <p>
          解决方法：使用
          <code>
           /*+ MATERIALIZE */
          </code>
          提示强制物化结果
         </p>
        </li>
       </ul>
      </blockquote>
     </li>
     <li>
      <p>
       <strong>
        顺序不确定性
       </strong>
      </p>
      <pre><code class="language-sql">-- 危险用法：不同执行可能得到不同序号
SELECT row_number() over () as id, name FROM users;

-- 正确用法：添加 ORDER BY
SELECT row_number() over (ORDER BY user_id) as id, name FROM users;</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        与 WHERE 条件配合
       </strong>
      </p>
      <pre><code class="language-sql">-- 行号生成在 WHERE 过滤之后
SELECT 
  row_number() over () as rn,
  product_id
FROM products
WHERE stock_qty &gt; 0;</code></pre>
      <p>
      </p>
     </li>
    </ol>
    <hr/>
    <h4 id="%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" name="%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95">
     <strong>
      高级用法
     </strong>
    </h4>
    <h5 id="1.%20%E5%8A%A8%E6%80%81%E9%87%8D%E7%BD%AE%E5%BA%8F%E5%8F%B7" name="1.%20%E5%8A%A8%E6%80%81%E9%87%8D%E7%BD%AE%E5%BA%8F%E5%8F%B7">
     1. 动态重置序号
    </h5>
    <pre><code class="language-sql">SELECT 
  row_number() over (PARTITION BY NULL ORDER BY NULL) as seq, -- 等效于 row_number() over ()
  device_id,
  sensor_value
FROM iot_data;</code></pre>
    <h5 id="2.%20%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%BC%96%E5%8F%B7" name="2.%20%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%BC%96%E5%8F%B7">
     2. 多维度编号
    </h5>
    <pre><code class="language-sql">SELECT 
  row_number() over (ORDER BY region) as global_seq,
  row_number() over (PARTITION BY region ORDER BY sales DESC) as region_rank,
  region,
  salesperson,
  sales_amount
FROM sales_data;</code></pre>
    <hr/>
    <h4 id="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE" name="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">
     <strong>
      性能优化建议
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        减少窗口范围
       </strong>
      </p>
      <pre><code class="language-sql">SELECT /*+ FIRST_ROWS(100) */ 
  row_number() over (ORDER BY log_time) as rn,
  log_message
FROM app_logs
WHERE log_level = 'ERROR';</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        配合物化视图
       </strong>
      </p>
      <pre><code class="language-sql">CREATE MATERIALIZED VIEW mv_sales_rank
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
AS 
SELECT 
  row_number() over (ORDER BY total_sales DESC) as rank,
  salesperson_id
FROM sales;</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        索引优化
       </strong>
      </p>
      <pre><code class="language-sql">CREATE INDEX idx_employees_hiredate ON employees(hire_date);
-- 使排序窗口函数能利用索引</code></pre>
      <p>
      </p>
     </li>
    </ol>
    <hr/>
    <p>
     通过合理使用
     <code>
      row_number() over ()
     </code>
     ，可以实现更灵活的行号生成逻辑，但务必注意排序明确性和性能影响，特别是在生产环境的大数据量场景中。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36303837323633372f:61727469636c652f64657461696c732f313436313434303731" class_="artid" style="display:none">
 </p>
</div>


