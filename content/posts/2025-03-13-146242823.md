---
layout: post
title: "Java面试集合框架体系"
date: 2025-03-13 21:28:40 +0800
description: "Java面试：集合框架体系"
keywords: "Java面试：集合框架体系"
categories: ['Java']
tags: ['面试', '职场和发展', 'Java']
artid: "146242823"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146242823
    alt: "Java面试集合框架体系"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146242823
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146242823
cover: https://bing.ee123.net/img/rand?artid=146242823
image: https://bing.ee123.net/img/rand?artid=146242823
img: https://bing.ee123.net/img/rand?artid=146242823
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java面试：集合框架体系
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3e0b0c230eee483280b94a89f9b969a7.png"/>
    </p>
    <h2 id="%E4%B8%80%E3%80%81ArrayList" name="%E4%B8%80%E3%80%81ArrayList">
     一、ArrayList
    </h2>
    <h3 id="1.%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89" name="1.%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89">
     1.数组（Array）
    </h3>
    <p>
     是一种用
     <strong>
      连续的内存空间
     </strong>
     存储
     <strong>
      相同数据类型
     </strong>
     数据的
     <strong>
      线性
     </strong>
     数据结构
    </p>
    <blockquote>
     <p>
      <strong>
       数组如何获取其他元素的地址值？
      </strong>
     </p>
     <p>
      寻址公式：
      <em>
       a[i] = baseAddress + i * dataTypeSize
      </em>
     </p>
     <ul>
      <li>
       baseAddress：数组的首地址
      </li>
      <li>
       dataTypeSize：代表数组中元素类型的大小，例如int型，dataTypeSize = 4个字节
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题1：为什么数组索引从0开始呢？假如从1开始不行吗？
      </u>
     </p>
     <ul>
      <li>
       在根据数组索引获取元素的时候，会用
       <strong>
        索引
       </strong>
       和
       <strong>
        寻址公式
       </strong>
       来计算内存所对应的元素数据，寻址公式是：
       <strong>
        数组的首地址+索引 * 存储数据的类型大小
       </strong>
      </li>
      <li>
       如果数组的索引从1开始，寻址公式中就需要增加一次减法操作，对于CPU来说就多了一次指令，影响性能
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题2：操作数组的时间复杂度
      </u>
     </p>
     <ul>
      <li>
       查找：随机查询（根据索引查询） O(1)
      </li>
      <li>
       查找：未知索引查询 O(n)
      </li>
      <li>
       查找：未知索引查询（将数组排序后）
       <strong>
        二分查找O(log n)
       </strong>
      </li>
      <li>
       插入/删除：O(n)
      </li>
     </ul>
    </blockquote>
    <h3 id="2.ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" name="2.ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">
     2.ArrayList源码分析
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" name="%EF%BC%881%EF%BC%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">
     （1）成员变量
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ab8f66f940064a008077afdab1350437.png"/>
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" name="%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">
     （2）构造方法
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f864c97a29774905b85ffbcaf621a700.png"/>
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C" name="%EF%BC%883%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C">
     （3）添加和扩容操作
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2f5fb523599248daa8f5a82c12c39ce1.png"/>
    </p>
    <blockquote>
     <p>
      <u>
       面试题1：ArrayList底层的实现原理是什么？
      </u>
     </p>
     <ul>
      <li>
       ArrayList底层是用动态的数组实现的
      </li>
      <li>
       ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10
      </li>
      <li>
       ArrayList在进行扩容的时候是原来容量的
       <strong>
        1.5倍
       </strong>
       ，每次扩容都需要
       <strong>
        拷贝数组
       </strong>
      </li>
      <li>
       ArrayList在添加数据的时候：
      </li>
      <li>
       确保数组已使用长度（size）加1之后足够存下下一个数据；
      </li>
      <li>
       计算数组的容量，如果当前数组已使用长度+1后的长度大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）；
      </li>
      <li>
       确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上；
      </li>
      <li>
       返回添加成功布尔值。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题2：ArrayList list = new ArrayList（10）中的list扩容几次？
      </u>
     </p>
     <p style="text-align:center">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/bac21550121742f9a3cbb2f0f07de6fc.png"/>
     </p>
     <ul>
      <li>
       该语句只是声明和实例了一个ArrayList，指定了容量为10，未扩容
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题3：如何实现数组和List之间的转换？
      </u>
     </p>
     <p style="text-align:center">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/391e241dd3944a608fb062c8d98c2477.png"/>
     </p>
     <ul>
      <li>
       数组转List，使用JDK中java.util.Arrays工具类的asList方法
      </li>
      <li>
       List转数组，使用List的toArray方法。无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组
      </li>
     </ul>
     <p>
      <u>
       追问：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗？
      </u>
     </p>
     <ul>
      <li>
       Arrays.asList转换List之后，如果修改了数组的内容，list
       <strong>
        会受影响
       </strong>
       ，因为它的底层使用的是Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个
       <strong>
        内存地址
       </strong>
      </li>
      <li>
       list用了toArray转数组后，如果修改了list内容，数组
       <strong>
        不会影响
       </strong>
       ，当调用了toArray以后，在底层是其进行了数组的
       <strong>
        拷贝
       </strong>
       ，与原来的元素
       <strong>
        无关
       </strong>
       ，所以即使list修改了以后，数组也不受影响
      </li>
     </ul>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81LinkedList" name="%E4%BA%8C%E3%80%81LinkedList">
     二、LinkedList
    </h2>
    <h3 id="1.%E9%93%BE%E8%A1%A8" name="1.%E9%93%BE%E8%A1%A8">
     1.链表
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e624c95476a24cb69c7bd370a0e1a262.png"/>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/c22fedc3e0f04b7faed6d6ef10701fa5.png"/>
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <caption>
      链表操作数据的时间复杂度
     </caption>
     <tbody>
      <tr>
       <td>
       </td>
       <td>
        查询
       </td>
       <td>
        新增删除
       </td>
      </tr>
      <tr>
       <td>
        单向链表
       </td>
       <td>
        头O(1)，其他O(n)
       </td>
       <td>
        头O(1)，其他O(n)
       </td>
      </tr>
      <tr>
       <td>
        双向链表
       </td>
       <td>
        <p>
         头尾O(1)，其他O(n)，
        </p>
        <p>
         给定节点O(1)
        </p>
       </td>
       <td>
        <p>
         头尾O(1)，其他O(n)，
        </p>
        <p>
         给定节点O(1)
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="2.LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" name="2.LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">
     2.LinkedList源码分析
    </h3>
    <blockquote>
     <p>
      <u>
       面试题1：ArrayList和LinkedList的区别是什么？
      </u>
     </p>
     <p>
      （1）底层数据结构
     </p>
     <ul>
      <li>
       ArrayList是
       <strong>
        动态数组
       </strong>
       的数据结构实现
      </li>
      <li>
       LinkedList是
       <strong>
        双向链表
       </strong>
       的数据结构实现
      </li>
     </ul>
     <p>
      （2）操作数据效率
     </p>
     <ul>
      <li>
       ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】，LinkedList不支持下表查询
      </li>
      <li>
       查找（未知索引）：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)
      </li>
      <li>
       新增和删除：
      </li>
      <li>
       ArrayList尾部插入和删除为O(1)，其他为O(n)
      </li>
      <li>
       LinkedList头尾节点增删为O(1)，其他为O(n)
      </li>
     </ul>
     <p>
      （3）内存空间占用
     </p>
     <ul>
      <li>
       ArrayList底层是数组，内存连续，节省内存
      </li>
      <li>
       LinkedList是双向链表需要存储数据，和两个指针，更占用内存
      </li>
     </ul>
     <p>
      （4）线程安全
     </p>
     <ul>
      <li>
       ArrayList和LinkedList都不是线程安全的
      </li>
      <li>
       如果需要保证线程安全，有两种方案：
      </li>
      <li>
       在方法内使用，局部变量则是线程安全的
      </li>
      <li>
       使用线程安全的ArrayList和LinkedList
      </li>
     </ul>
     <p style="text-align:center">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/cb716ea2efef4b10a956a1352a48726b.png"/>
     </p>
    </blockquote>
    <blockquote>
     <p name="%E4%B8%89%E3%80%81HashMap">
      补充：线程安全是编程中的术语，指某个函数、函数库在
      <strong>
       并发
      </strong>
      环境中被调用时，能够正确地处理
      <strong>
       多个线程
      </strong>
      之间的
      <strong>
       共享变量
      </strong>
      ，使程序功能正确完成。
     </p>
    </blockquote>
    <h2 id="%E4%B8%89%E3%80%81HashMap" name="%E4%B8%89%E3%80%81HashMap">
     三、HashMap
    </h2>
    <h3 id="1.%E4%BA%8C%E5%8F%89%E6%A0%91" name="1.%E4%BA%8C%E5%8F%89%E6%A0%91">
     1.二叉树
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b496556ee08e4e6b850ca5535d6b574c.png"/>
    </p>
    <h3 id="2.%E7%BA%A2%E9%BB%91%E6%A0%91" name="2.%E7%BA%A2%E9%BB%91%E6%A0%91">
     2.红黑树
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/139b05c26386443eb95bf8174da298d2.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/54a90caf248a4babaad7260ec15b6a55.png"/>
    </p>
    <h3 id="3.%E6%95%A3%E5%88%97%E8%A1%A8" name="3.%E6%95%A3%E5%88%97%E8%A1%A8">
     3.散列表
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/c9dc826690554f9aaf60263293a62f65.png"/>
    </p>
    <h3 id="4.HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" name="4.HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">
     4.HashMap源码分析
    </h3>
    <h4>
     （1）常见属性
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/4edd53c255b24bfabbcdeaa1f4c9bc27.png"/>
    </p>
    <h4>
     （2）添加数据
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/860b5712a01f45c6a731673800f70481.png"/>
    </p>
    <h4>
     （3）扩容
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/45ed1dae3da64785942fd7689c4f95a9.png"/>
    </p>
    <h4>
     （4）寻址（不会）
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a345ced5cf1646348d1ab86fc979f422.png"/>
    </p>
    <blockquote>
     <p>
      <u>
       面试题1：说一下HashMap的实现原理？
      </u>
     </p>
     <ul>
      <li>
       数据结构：底层使用hash表，即数组和链表或红黑树
      </li>
      <li>
       当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
      </li>
      <li>
       存储时，如果出现hash值相同的key：
      </li>
      <li>
       如果key相同，则覆盖原始值；
      </li>
      <li>
       如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中
      </li>
      <li>
       获取时，直接找到hash值对应的下标。在进一步判断key是否相同，从而找到对应值
      </li>
     </ul>
     <p>
      补充：链表的长度大于8且数组长度大于64时，转换为红黑树
     </p>
     <p>
      <u>
       追问：HashMap的jdk1.7和jdk1.8有什么区别？
      </u>
     </p>
     <ul>
      <li>
       JDK1.8之前采用的是
       <strong>
        拉链法
       </strong>
       。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可
      </li>
      <li>
       jdk1.8在解决哈希冲突时，当链表长度大于阈值（默认为8）且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容resize（）时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题2：HashMap的put方法的具体流程？
      </u>
     </p>
     <ul>
      <li>
       判断键值对数组table是否为空或为null，否则执行resize()进行扩容（
       <strong>
        初始化
       </strong>
       ）
      </li>
      <li>
       根据键值key计算hash值得到数组索引
      </li>
      <li>
       判断table[i] == null条件成立，直接新建节点添加
      </li>
      <li>
       如果table[i] == null不成立：
      </li>
      <li>
       判断table[i]的首个元素是否和key一样，如果相同直接覆盖value
      </li>
      <li>
       判断table[i]是否为treeNode（即红黑树），如果是红黑树，则直接在树中插入键值对
      </li>
      <li>
       遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，如果大于8，将链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在则直接覆盖value
      </li>
      <li>
       插入成功后，判断实际存在的键值对数量size是否超过了最大容量，如果超过，进行扩容
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题3：讲一讲HashMap的扩容机制
      </u>
     </p>
     <ul>
      <li>
       在添加元素或初始化的时候需要调用
       <strong>
        resize
       </strong>
       方法进行扩容，第一次添加数据初始化数组长度为
       <strong>
        16
       </strong>
       ，以后每次扩容都是达到了扩容阈值（数组长度*0.75）
      </li>
      <li>
       每次扩容的时候，都是扩容之前容量的
       <strong>
        两倍
       </strong>
      </li>
      <li>
       扩容之后，会新创建一个数组，需要把老数组中的数据
       <strong>
        挪动
       </strong>
       到新的数组中：
      </li>
      <li>
       没有hash冲突的节点，则直接使用
       <strong>
        e.hash&amp;(newCap - 1)
       </strong>
       计算新数组的索引位置
      </li>
      <li>
       如果是红黑树，进行红黑树的添加
      </li>
      <li>
       如果是链表，则需要
       <strong>
        遍历
       </strong>
       链表，可能需要拆分链表，判断
       <strong>
        （e.hash&amp;oldCap）
       </strong>
       是否为0，该元素的位置要么停留在原始位置，要么移动到（
       <strong>
        原始位置+增加的数组大小
       </strong>
       ）这个位置上
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <u>
       面试题4：hashMap的寻址算法（不会）
      </u>
     </p>
     <p style="text-align:center">
      <u>
       <img alt="" src="https://i-blog.csdnimg.cn/direct/fb256303eb4544fc90c48b5b4abb6aa2.png"/>
      </u>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393639303830352f:61727469636c652f64657461696c732f313436323432383233" class_="artid" style="display:none">
 </p>
</div>


