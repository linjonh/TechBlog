---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34393432363131352f:61727469636c652f64657461696c732f313436323136303833"
layout: post
title: "力扣hot100二刷链表"
date: 2025-03-12 21:54:47 +0800
description: "第二次刷题不在idea写代码，而是直接在leetcode网站上写，“逼”自己掌握常用的函数。"
keywords: "力扣hot100二刷——链表"
categories: ['手撕算法']
tags: ['面试', '链表', '算法', '后端', 'Leetcode']
artid: "146216083"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216083
    alt: "力扣hot100二刷链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216083
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216083
cover: https://bing.ee123.net/img/rand?artid=146216083
image: https://bing.ee123.net/img/rand?artid=146216083
img: https://bing.ee123.net/img/rand?artid=146216083
---

# 力扣hot100二刷——链表

第二次刷题不在idea写代码，而是直接在leetcode网站上写，“逼”自己掌握常用的函数。

| 标志 | 掌握程度 | 解释 | 办法 |
| --- | --- | --- | --- |
| ⭐ | Fully 完全掌握 | 看到题目就有思路，编程也很流利 |  |
| ⭐⭐ | Basically 基本掌握 | 需要稍作思考，或者看到提示方法后能解答 |  |
| ⭐⭐⭐ | Slightly 稍微掌握 | 需要看之前写过的代码才能想起怎么做 | 多做 |
| ⭐⭐⭐⭐ | absolutely no 完全没有掌握 | 需要看题解才知道怎么做 | 背 |
| ⭐⭐⭐⭐⭐ | 有难度的高频题 | 需要看题解才知道怎么做，而且过几天就忘了这道题怎么做了 | 背背 |

| 22 | ⭐⭐ | Easy | 链表 | 160/相交链表 | 哈希表法，时间复杂度始终是O(M+N) 双指针法，时间复杂度最差是O(M+N)，指针A遍历完链表A再接着遍历链表B；指针B遍历完链表A再遍历链表A，两者走了相同距离时，即为答案（相交节点或者空节点） |  |
| --- | --- | --- | --- | --- | --- | --- |
| 23 | ⭐ | Easy | 链表 | 206/反转链表 | 定义三个指针：lastNode curNode nextNode，curNode 从头节点开始遍历直到curtNode == null时结束遍历 | ListNode lastNode = null; |
| 24 | ⭐⭐⭐ | Easy | 链表 | 234/回文链表 | 错误的思路：先翻转链表，再比较翻转前后的链表，这样做翻转前的链表已经不存在了，没法比较 正确思路：快慢指针先找到链表的中点，然后反转后半段链表，再比较链表的前半段和后半段 |  |
| 25 | ⭐ | Easy | 链表 | 141/环形链表 | 易错点：首先要排除输入为null的情况：if(head == null) return null; 快慢指针遍历链表，如果两指针相同则存在环形 |  |
| 26 | ⭐⭐ | Medium | 链表 | 142/环形链表II | 在141题的基础上，多加一部即可 快慢指针相遇，证明有环 快指针指向头节点，慢指针不变，两指针同时向后移动，直至相遇即为环节点 |  |
| 27 | ⭐⭐⭐ | Easy | 链表 | 21/合并两个有序链表 | 思路很简单，但程序有细节要注意 定义两个指针，分别指向两个链表的头节点 当两个指针所指节点均不为空时，比较它们的大小，谁小就加在新链表后，并且后移该指针 跳出循环后，可能两条链表的节点都被加入新链表了，也有可能有一条链表还有节点没被加入新链表，所以要手动判断并加入。 |  |
| 28 | ⭐ | Medium | 链表 | 2/两数相加 | 要注意，判断最后的进位是否 > 0，> 0的话，链表最后再加上这个进位 对应位相加（要判断，节点是否为空，为空的话相当于加 0） 求出当前节点的值：（进位 + 节点1的值 + 节点2的值）% 10 更新进位：（进位 + 节点1的值 + 节点2的值）/ 10 记得后移指针 |  |
| 29 | ⭐⭐⭐ | Medium | 链表 | 19/删除链表的倒数第N个节点 | 定义快慢指针，快指针比慢指针快n个节点。 要注意的是，如果快指针到达队尾，说明要删的恰好是头节点，那么直接返回第二个节点 快慢指针向后移，直到快指针到达尽头（下个节点为空），此时要删的就是慢指针的下个节点 |  |
| 30 | ⭐⭐⭐ | Medium | 链表 | 24/两两交换链表中的节点 | 哨兵节点+遍历链表的同时交换相邻节点 创建一个哨兵节点，并维护pre、cur、next三个节点 当pre.next null&&pre.next.next null 时，遍历链表，并交换节点。 程序开始先排除head == null || head.next == null的情况 |  |
| 31 | ⭐⭐⭐⭐ | Hard | 链表 | 25/K个一组反转链表 | 把链表分为三部分：已经反转的、要反转的、未反转的 找到此次要反转的部分的尾节点end，并把尾节点的下个节点置空；end.next == null ,结束遍历 反转此部分链表（重点） 将该部分链表加到已经反转部分的后面 |  |
| 32 | ⭐⭐⭐ | Medium | 链表 | 138/随机链表的复制 | 使用哈希表来保存节点 遍历链表，将节点保存到哈希表Map<Node, Node> 再次遍历链表，将原节点中的next、random拷贝到新节点中 |  |
| 33 | ⭐⭐⭐⭐ | Medium | 链表 | 148/排序链表 | 归并排序 快慢指针将链表分为两半，一半为left，一半为right，如果head == null || head.next == null说明不可以再分了，就结束递归 left链表和right链表进行比较排序并合并，算法如21题。 最后要将不为空的节点加入到链表最后，再返回头节点。 |  |
| 34 | ⭐⭐⭐ | Hard | 链表 | 23/合并k个升序链表 | 升序的优先级队列 PriorityQueue 遍历数组，将每个链表的头节点加入到队列中 当队列不为空时，循环执行以下操作 2.1 移除队头节点（最小节点） 2.2 将该节点的下一个节点加入到队列（如果不为null的话） |  |
| 35 | ⭐⭐⭐⭐⭐ | Medium | 链表 | 146/LRU缓存 | 双向链表+哈希表 哈希表保存<key, Node>，便于查找key 建立双向链表类与dummy哨兵节点 LRUCache(int capacity) 初始化容量、dummy节点的pre和next get操作 getKey()函数查找key是否存在，存在则返回value，否则返回-1； put操作 getKey()函数查找key是否存在，存在则更改原来的value为新的value；否则putFront()函数将key加入到最前面，并且要判断是否超出容量，超出的话要remove()删除尾节点 getkey() 查找哈希表中是否存在key，存在则putFront()函数将该节点加入到最前面，并返回Node，否则返回null putFront() 将节点加入到最前面，也就是dummy的后面 remove() 删除尾节点，也就是dummy的前面 | PriorityQueue pq = new PriorityQueue<>((a,b) -> a.val - b.val); |

图片版：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d0cb5e3c7d86414db1c5f32b8f6130e9.png)