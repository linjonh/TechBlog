---
layout: post
title: "力扣hot100二刷链表"
date: 2025-03-12 21:54:47 +0800
description: "第二次刷题不在idea写代码，而是直接在leetcode网站上写，“逼”自己掌握常用的函数。"
keywords: "力扣hot100二刷——链表"
categories: ['手撕算法']
tags: ['面试', '链表', '算法', '后端', 'Leetcode']
artid: "146216083"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216083
    alt: "力扣hot100二刷链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216083
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216083
cover: https://bing.ee123.net/img/rand?artid=146216083
image: https://bing.ee123.net/img/rand?artid=146216083
img: https://bing.ee123.net/img/rand?artid=146216083
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     力扣hot100二刷——链表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     第二次刷题不在idea写代码，而是直接在leetcode网站上写，“逼”自己掌握常用的函数。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        标志
       </th>
       <th>
        掌握程度
       </th>
       <th>
        解释
       </th>
       <th>
        办法
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ⭐
       </td>
       <td>
        Fully 完全掌握
       </td>
       <td>
        看到题目就有思路，编程也很流利
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐
       </td>
       <td>
        Basically 基本掌握
       </td>
       <td>
        需要稍作思考，或者看到提示方法后能解答
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Slightly 稍微掌握
       </td>
       <td>
        需要看之前写过的代码才能想起怎么做
       </td>
       <td>
        多做
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        absolutely no 完全没有掌握
       </td>
       <td>
        需要看题解才知道怎么做
       </td>
       <td>
        背
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐⭐⭐⭐
       </td>
       <td>
        有难度的高频题
       </td>
       <td>
        需要看题解才知道怎么做，而且过几天就忘了这道题怎么做了
       </td>
       <td>
        背背
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th>
        22
       </th>
       <th>
        ⭐⭐
       </th>
       <th>
        Easy
       </th>
       <th>
        链表
       </th>
       <th>
        160/相交链表
       </th>
       <th>
        哈希表法，时间复杂度始终是O(M+N) 双指针法，时间复杂度最差是O(M+N)，指针A遍历完链表A再接着遍历链表B；指针B遍历完链表A再遍历链表A，两者走了相同距离时，即为答案（相交节点或者空节点）
       </th>
       <th>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        23
       </td>
       <td>
        ⭐
       </td>
       <td>
        Easy
       </td>
       <td>
        链表
       </td>
       <td>
        206/反转链表
       </td>
       <td>
        定义三个指针：lastNode curNode nextNode，curNode 从头节点开始遍历直到curtNode == null时结束遍历
       </td>
       <td>
        ListNode lastNode = null;
       </td>
      </tr>
      <tr>
       <td>
        24
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Easy
       </td>
       <td>
        链表
       </td>
       <td>
        234/回文链表
       </td>
       <td>
        错误的思路：先翻转链表，再比较翻转前后的链表，这样做翻转前的链表已经不存在了，没法比较 正确思路：快慢指针先找到链表的中点，然后反转后半段链表，再比较链表的前半段和后半段
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        25
       </td>
       <td>
        ⭐
       </td>
       <td>
        Easy
       </td>
       <td>
        链表
       </td>
       <td>
        141/环形链表
       </td>
       <td>
        易错点：首先要排除输入为null的情况：if(head == null) return null; 快慢指针遍历链表，如果两指针相同则存在环形
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        26
       </td>
       <td>
        ⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        142/环形链表II
       </td>
       <td>
        在141题的基础上，多加一部即可 快慢指针相遇，证明有环 快指针指向头节点，慢指针不变，两指针同时向后移动，直至相遇即为环节点
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        27
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Easy
       </td>
       <td>
        链表
       </td>
       <td>
        21/合并两个有序链表
       </td>
       <td>
        思路很简单，但程序有细节要注意 定义两个指针，分别指向两个链表的头节点 当两个指针所指节点均不为空时，比较它们的大小，谁小就加在新链表后，并且后移该指针 跳出循环后，可能两条链表的节点都被加入新链表了，也有可能有一条链表还有节点没被加入新链表，所以要手动判断并加入。
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        28
       </td>
       <td>
        ⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        2/两数相加
       </td>
       <td>
        要注意，判断最后的进位是否 &gt; 0，&gt; 0的话，链表最后再加上这个进位 对应位相加（要判断，节点是否为空，为空的话相当于加 0） 求出当前节点的值：（进位 + 节点1的值 + 节点2的值）% 10 更新进位：（进位 + 节点1的值 + 节点2的值）/ 10 记得后移指针
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        29
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        19/删除链表的倒数第N个节点
       </td>
       <td>
        定义快慢指针，快指针比慢指针快n个节点。 要注意的是，如果快指针到达队尾，说明要删的恰好是头节点，那么直接返回第二个节点 快慢指针向后移，直到快指针到达尽头（下个节点为空），此时要删的就是慢指针的下个节点
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        30
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        24/两两交换链表中的节点
       </td>
       <td>
        哨兵节点+遍历链表的同时交换相邻节点 创建一个哨兵节点，并维护pre、cur、next三个节点 当pre.next
        <mark>
         null&amp;&amp;pre.next.next
        </mark>
        null 时，遍历链表，并交换节点。 程序开始先排除head == null || head.next == null的情况
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        31
       </td>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        Hard
       </td>
       <td>
        链表
       </td>
       <td>
        25/K个一组反转链表
       </td>
       <td>
        把链表分为三部分：已经反转的、要反转的、未反转的 找到此次要反转的部分的尾节点end，并把尾节点的下个节点置空；end.next == null ,结束遍历 反转此部分链表（重点） 将该部分链表加到已经反转部分的后面
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        32
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        138/随机链表的复制
       </td>
       <td>
        使用哈希表来保存节点 遍历链表，将节点保存到哈希表Map&lt;Node, Node&gt; 再次遍历链表，将原节点中的next、random拷贝到新节点中
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        33
       </td>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        148/排序链表
       </td>
       <td>
        归并排序 快慢指针将链表分为两半，一半为left，一半为right，如果head == null || head.next == null说明不可以再分了，就结束递归 left链表和right链表进行比较排序并合并，算法如21题。 最后要将不为空的节点加入到链表最后，再返回头节点。
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        34
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Hard
       </td>
       <td>
        链表
       </td>
       <td>
        23/合并k个升序链表
       </td>
       <td>
        升序的优先级队列 PriorityQueue 遍历数组，将每个链表的头节点加入到队列中 当队列不为空时，循环执行以下操作 2.1 移除队头节点（最小节点） 2.2 将该节点的下一个节点加入到队列（如果不为null的话）
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        35
       </td>
       <td>
        ⭐⭐⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        链表
       </td>
       <td>
        146/LRU缓存
       </td>
       <td>
        双向链表+哈希表 哈希表保存&lt;key, Node&gt;，便于查找key 建立双向链表类与dummy哨兵节点 LRUCache(int capacity) 初始化容量、dummy节点的pre和next get操作 getKey()函数查找key是否存在，存在则返回value，否则返回-1； put操作 getKey()函数查找key是否存在，存在则更改原来的value为新的value；否则putFront()函数将key加入到最前面，并且要判断是否超出容量，超出的话要remove()删除尾节点 getkey() 查找哈希表中是否存在key，存在则putFront()函数将该节点加入到最前面，并返回Node，否则返回null putFront() 将节点加入到最前面，也就是dummy的后面 remove() 删除尾节点，也就是dummy的前面
       </td>
       <td>
        PriorityQueue pq = new PriorityQueue&lt;&gt;((a,b) -&gt; a.val - b.val);
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     图片版：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d0cb5e3c7d86414db1c5f32b8f6130e9.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34393432363131352f:61727469636c652f64657461696c732f313436323136303833" class_="artid" style="display:none">
 </p>
</div>


