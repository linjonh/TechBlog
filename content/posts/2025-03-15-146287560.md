---
layout: post
title: "java设计模式面试题3道"
date: 2025-03-15 23:23:13 +0800
description: "如果没有volatile，步骤3可能会被提前，导致其他线程看到未完全初始化的instance，从而引发错误。策略模式是一种行为型设计模式，用于定义一系列算法，并将它们封装在独立的类中，客户端可以根据需求动态选择算法。双重校验锁（DCL）：通过两次检查instance是否为null，避免不必要的同步，提高性能。题目：请实现一个简单的工厂模式，用于创建不同类型的支付方式（如微信支付、支付宝支付）。题目：请实现一个策略模式，用于计算不同类型的折扣（如无折扣、9折、8折）。线程安全的实现方式。"
keywords: "java设计模式面试题3道"
categories: ['Java']
tags: ['设计模式', '单例模式', 'Java']
artid: "146287560"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146287560
    alt: "java设计模式面试题3道"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146287560
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146287560
cover: https://bing.ee123.net/img/rand?artid=146287560
image: https://bing.ee123.net/img/rand?artid=146287560
img: https://bing.ee123.net/img/rand?artid=146287560
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java设计模式面试题3道
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     面试题1：单例模式（Singleton Pattern）
     <br/>
     题目：请实现一个线程安全的单例模式，并解释为什么需要使用volatile关键字。
     <br/>
     考察点：
     <br/>
     对单例模式的理解。
     <br/>
     线程安全的实现方式。
     <br/>
     对volatile关键字的理解。
     <br/>
     参考答案：
     <br/>
     单例模式确保一个类只有一个实例，并提供一个全局访问点。线程安全的单例模式可以通过双重校验锁（DCL）实现。代码如下：
     <br/>
     java
     <br/>
     复制
     <br/>
     public class Singleton {
     <!-- -->
     <br/>
     private static volatile Singleton instance = null;
    </p>
    <pre><code>private Singleton() {
    // 私有构造函数，防止外部实例化
}

public static Singleton getInstance() {
    if (instance == null) { // 第一次检查
        synchronized (Singleton.class) { // 同步块
            if (instance == null) { // 第二次检查
                instance = new Singleton();
            }
        }
    }
    return instance;
}
</code></pre>
    <p>
     }
     <br/>
     解释：
     <br/>
     双重校验锁（DCL）：通过两次检查instance是否为null，避免不必要的同步，提高性能。
     <br/>
     volatile关键字：防止指令重排序问题。在多线程环境下，instance = new Singleton()可能会被JVM优化为以下步骤：
     <br/>
     分配内存空间。
     <br/>
     调用构造函数初始化对象。
     <br/>
     将instance指向分配的内存空间。
     <br/>
     如果没有volatile，步骤3可能会被提前，导致其他线程看到未完全初始化的instance，从而引发错误。
     <br/>
     拓展问题：
     <br/>
     如何通过枚举实现单例模式？
     <br/>
     如何防止单例被反射破坏？
     <br/>
     面试题2：工厂模式（Factory Pattern）
     <br/>
     题目：请实现一个简单的工厂模式，用于创建不同类型的支付方式（如微信支付、支付宝支付）。
     <br/>
     考察点：
     <br/>
     对工厂模式的理解。
     <br/>
     编码能力。
     <br/>
     对接口和多态的掌握。
     <br/>
     参考答案：
     <br/>
     工厂模式是一种创建型设计模式，用于封装对象的创建逻辑。以下是简单工厂模式的实现：
     <br/>
     java
     <br/>
     复制
     <br/>
     // 支付接口
     <br/>
     interface Payment {
     <!-- -->
     <br/>
     void pay();
     <br/>
     }
    </p>
    <p>
     // 微信支付
     <br/>
     class WeChatPay implements Payment {
     <!-- -->
     <br/>
     @Override
     <br/>
     public void pay() {
     <!-- -->
     <br/>
     System.out.println(“Paying via WeChat…”);
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     // 支付宝支付
     <br/>
     class Alipay implements Payment {
     <!-- -->
     <br/>
     @Override
     <br/>
     public void pay() {
     <!-- -->
     <br/>
     System.out.println(“Paying via Alipay…”);
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     // 工厂类
     <br/>
     class PaymentFactory {
     <!-- -->
     <br/>
     public static Payment getPayment(String type) {
     <!-- -->
     <br/>
     if (“wechat”.equalsIgnoreCase(type)) {
     <!-- -->
     <br/>
     return new WeChatPay();
     <br/>
     } else if (“alipay”.equalsIgnoreCase(type)) {
     <!-- -->
     <br/>
     return new Alipay();
     <br/>
     } else {
     <!-- -->
     <br/>
     throw new IllegalArgumentException("Unsupported payment type: " + type);
     <br/>
     }
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     // 客户端代码
     <br/>
     public class Client {
     <!-- -->
     <br/>
     public static void main(String[] args) {
     <!-- -->
     <br/>
     Payment payment = PaymentFactory.getPayment(“wechat”);
     <br/>
     payment.pay();
     <br/>
     }
     <br/>
     }
     <br/>
     拓展问题：
     <br/>
     简单工厂模式和工厂方法模式的区别是什么？
     <br/>
     如何将上述代码改为工厂方法模式？
     <br/>
     面试题3：策略模式（Strategy Pattern）
     <br/>
     题目：请实现一个策略模式，用于计算不同类型的折扣（如无折扣、9折、8折）。
     <br/>
     考察点：
     <br/>
     对策略模式的理解。
     <br/>
     对接口和多态的掌握。
     <br/>
     编码能力。
     <br/>
     参考答案：
     <br/>
     策略模式是一种行为型设计模式，用于定义一系列算法，并将它们封装在独立的类中，客户端可以根据需求动态选择算法。
     <br/>
     java
     <br/>
     复制
     <br/>
     // 折扣策略接口
     <br/>
     interface DiscountStrategy {
     <!-- -->
     <br/>
     double calculate(double price);
     <br/>
     }
    </p>
    <p>
     // 无折扣策略
     <br/>
     class NoDiscountStrategy implements DiscountStrategy {
     <!-- -->
     <br/>
     @Override
     <br/>
     public double calculate(double price) {
     <!-- -->
     <br/>
     return price;
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     // 9折策略
     <br/>
     class TenPercentDiscountStrategy implements DiscountStrategy {
     <!-- -->
     <br/>
     @Override
     <br/>
     public double calculate(double price) {
     <!-- -->
     <br/>
     return price * 0.9;
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     // 8折策略
     <br/>
     class TwentyPercentDiscountStrategy implements DiscountStrategy {
     <!-- -->
     <br/>
     @Override
     <br/>
     public double calculate(double price) {
     <!-- -->
     <br/>
     return price * 0.8;
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     // 上下文类
     <br/>
     class DiscountContext {
     <!-- -->
     <br/>
     private DiscountStrategy strategy;
    </p>
    <pre><code>public DiscountContext(DiscountStrategy strategy) {
    this.strategy = strategy;
}

public double applyDiscount(double price) {
    return strategy.calculate(price);
}

public void setStrategy(DiscountStrategy strategy) {
    this.strategy = strategy;
}
</code></pre>
    <p>
     }
    </p>
    <p>
     // 客户端代码
     <br/>
     public class Client {
     <!-- -->
     <br/>
     public static void main(String[] args) {
     <!-- -->
     <br/>
     DiscountContext context = new DiscountContext(new NoDiscountStrategy());
     <br/>
     System.out.println("Price with no discount: " + context.applyDiscount(100));
    </p>
    <pre><code>    context.setStrategy(new TenPercentDiscountStrategy());
    System.out.println("Price with 10% discount: " + context.applyDiscount(100));

    context.setStrategy(new TwentyPercentDiscountStrategy());
    System.out.println("Price with 20% discount: " + context.applyDiscount(100));
}
</code></pre>
    <p>
     }
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f57616e6759616f6c6f7665313331342f:61727469636c652f64657461696c732f313436323837353630" class_="artid" style="display:none">
 </p>
</div>


