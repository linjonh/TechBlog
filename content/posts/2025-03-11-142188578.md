---
layout: post
title: "02.06回文链表"
date: 2025-03-11 19:22:22 +0800
description: "这个方法通过快慢指针和链表反转的技巧，避免了额外的空间开销，是一个比较高效的解决方案。编写一个函数，检查输入的链表是否是回文的。"
keywords: "回文链表 提示"
categories: ['题解']
tags: ['链表', '数据结构', 'Leetcode']
artid: "142188578"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=142188578
    alt: "02.06回文链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=142188578
featuredImagePreview: https://bing.ee123.net/img/rand?artid=142188578
cover: https://bing.ee123.net/img/rand?artid=142188578
image: https://bing.ee123.net/img/rand?artid=142188578
img: https://bing.ee123.net/img/rand?artid=142188578
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     02.06、回文链表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="0206_httpsleetcodecnproblemspalindromelinkedlistlccidescription_0">
     </a>
     02.06、
     <a href="https://leetcode.cn/problems/palindrome-linked-list-lcci/description/" rel="nofollow">
      [简单] 回文链表
     </a>
    </h3>
    <h4>
     <a id="1_2">
     </a>
     1、题目描述
    </h4>
    <p>
     编写一个函数，检查输入的链表是否是回文的。
    </p>
    <h4>
     <a id="2_8">
     </a>
     2、解题思路：
    </h4>
    <ol>
     <li>
      <strong>
       快慢指针找中点：
      </strong>
      <ul>
       <li>
        利用快慢指针的技巧来找到链表的中间节点。慢指针
        <code>
         slow
        </code>
        每次移动一步，而快指针
        <code>
         fast
        </code>
        每次移动两步。这样，当快指针到达链表末尾时，慢指针恰好位于链表中间。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       反转后半部分链表：
      </strong>
      <ul>
       <li>
        在找到中间节点后，将链表的后半部分反转。我们从
        <code>
         slow-&gt;next
        </code>
        开始反转链表，最终
        <code>
         newhead
        </code>
        将指向反转后的后半部分链表的头节点。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       对比前半部分和后半部分：
      </strong>
      <ul>
       <li>
        反转链表的后半部分后，将它与前半部分进行比较。如果所有节点值相等，则说明链表是回文的。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回结果：
      </strong>
      <ul>
       <li>
        如果比较过程中发现不一致，则返回
        <code>
         false
        </code>
        。如果全部节点相等，则返回
        <code>
         true
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="3_21">
     </a>
     3、代码实现与详细注释
    </h4>
    <pre><code>class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 如果链表为空或只有一个节点，直接返回 true
        if (head == nullptr || head-&gt;next == nullptr) {
            return true;
        }

        // 使用快慢指针找到链表的中间节点
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
            slow = slow-&gt;next;  // 慢指针每次移动一步
            fast = fast-&gt;next-&gt;next;  // 快指针每次移动两步
        }

        // 将链表的后半部分反转
        ListNode* newhead = slow-&gt;next;  // newhead 指向后半部分的开始节点
        ListNode* prev = nullptr;  // 用于反转链表
        while (newhead-&gt;next) {
            ListNode* next = newhead-&gt;next;  // 保存下一个节点
            newhead-&gt;next = prev;  // 当前节点的 next 指向前一个节点
            prev = newhead;  // prev 指向当前节点，逐步推进
            newhead = next;  // newhead 移动到下一个节点
        }
        newhead-&gt;next = prev;  // 最后一个节点反转后，形成新的链表

        // 对比前半部分和反转后的后半部分是否相同
        slow = head;  // slow 回到链表头部
        while (newhead) {  // 遍历反转后的链表
            if (newhead-&gt;val != slow-&gt;val) {  // 如果值不相等，返回 false
                return false;
            }
            slow = slow-&gt;next;  // 两个指针同时移动
            newhead = newhead-&gt;next;
        }

        // 如果链表前后部分相同，则返回 true
        return true;
    }
};
</code></pre>
    <h4>
     <a id="4_69">
     </a>
     4、时间复杂度和空间复杂度：
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度：
      </strong>
      O(n)，其中 n 是链表的长度。我们遍历链表两次，一次是找到中点，另一次是进行比较。
     </li>
     <li>
      <strong>
       空间复杂度：
      </strong>
      O(1)，因为只使用了常数额外空间。
     </li>
    </ul>
    <p>
     这个方法通过快慢指针和链表反转的技巧，避免了额外的空间开销，是一个比较高效的解决方案。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6d6d6c68626a6b2f:61727469636c652f64657461696c732f313432313838353738" class_="artid" style="display:none">
 </p>
</div>


