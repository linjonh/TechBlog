---
layout: post
title: "åªè¯»æŸ¥è¯¢çš„é›¶åˆ†é…ä¹‹è·¯EF-Core-Dapper-MemoryPack-çš„ç»„åˆä¼˜åŒ–"
date: 2025-09-11T22:51:42+0800
description: "æ–‡ç« æå‡ºé¢å‘åªè¯»æ¥å£çš„â€œä¸‰è½¨å¹¶è¡Œâ€æ€§èƒ½æ–¹æ¡ˆï¼šå¸¸è§„ç”¨ EF Core ç¼–è¯‘æŸ¥è¯¢+AsNoTracking æ˜¾å¼æŠ•å½±ï¼›çƒ­ç‚¹ç”¨ Dapper éç¼“å†²+æ‰å¹³ DTOï¼›å¯¹å¤–ä»¥ MemoryPack ç›´å†™ IBufferWriterï¼ŒJSON ä½œä¸ºå›é€€ã€‚é…å¥— BenchmarkDotNetã€dotnet-counters/trace ä¸åˆ†æ®µ Flushï¼Œç³»ç»Ÿæ€§é™ä½åˆ†é…ä¸ p95/p99 å°¾å»¶è¿Ÿã€‚"
keywords: "åªè¯»æŸ¥è¯¢çš„â€œé›¶åˆ†é…â€ä¹‹è·¯ï¼šEF Core + Dapper + MemoryPack çš„ç»„åˆä¼˜åŒ–"
categories: ['æœªåˆ†ç±»']
tags: ['Efcore', 'Dto', 'Dapper', 'C', 'Benchmarkdotnet', '.Net']
artid: "151590722"
arturl: "https://blog.csdn.net/Kookoos/article/details/151590722"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151590722
    alt: "åªè¯»æŸ¥è¯¢çš„é›¶åˆ†é…ä¹‹è·¯EF-Core-Dapper-MemoryPack-çš„ç»„åˆä¼˜åŒ–"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151590722
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151590722
cover: https://bing.ee123.net/img/rand?artid=151590722
image: https://bing.ee123.net/img/rand?artid=151590722
img: https://bing.ee123.net/img/rand?artid=151590722
---



# åªè¯»æŸ¥è¯¢çš„â€œé›¶åˆ†é…â€ä¹‹è·¯ï¼šEF Core + Dapper + MemoryPack çš„ç»„åˆä¼˜åŒ–



## ğŸš€ åªè¯»æŸ¥è¯¢çš„â€œé›¶åˆ†é…â€ä¹‹è·¯ï¼šEF Core + Dapper + MemoryPack çš„ç»„åˆä¼˜åŒ–

**ç›®æ ‡**ï¼šåœ¨åªè¯»æ¥å£çš„**çƒ­è·¯å¾„**ä¸Šï¼ŒæŠŠå…³é”®è·¯å¾„ä¸Šçš„ä¸´æ—¶å¯¹è±¡ä¸å¤åˆ¶é™è‡³æœ€ä½ï¼Œé™ä½ GC å‹åŠ›ä¸ p95/p99 å°¾å»¶è¿Ÿï¼Œæå‡ååã€‚  
 **ä¸»çº¿ï¼ˆâ€œä¸‰è½¨å¹¶è¡Œâ€ï¼‰**

1. **EF Core**ï¼šç¼–è¯‘æŸ¥è¯¢ + `AsNoTracking()` + æ˜¾å¼æŠ•å½±ï¼ˆä¸­ä½ QPS çš„é»˜è®¤è·¯å¾„ï¼‰ï¼›
2. **Dapper**ï¼šæ‰‹å†™ SQL + **éç¼“å†²**æµå¼ï¼ˆ`buffered:false`ï¼‰+ æ‰å¹³ DTOï¼ˆçƒ­ç‚¹/å¤§ç»“æœé›†ï¼‰ï¼›
3. **åºåˆ—åŒ–**ï¼š**MemoryPack** + `HttpResponse.BodyWriter`ï¼ˆ`IBufferWriter<byte>`ï¼‰**ç›´å†™**ï¼›æµè§ˆå™¨/é€šç”¨ç”Ÿæ€ â†’ **å›é€€ System.Text.Json**ï¼ˆé… Source Generatorï¼‰ã€‚

> â„¹ï¸ æœ¯è¯­æ¾„æ¸…ï¼šâ€œ**é›¶åˆ†é…**â€æ˜¯å·¥ç¨‹ç›®æ ‡ï¼Œå³**å°½é‡å°†å…³é”®è·¯å¾„ä¸Šçš„**ä¸­é—´å¯¹è±¡/å¤åˆ¶å»é™¤æˆ–æ˜¾è‘—é™ä½ï¼›å—å­—ç¬¦ä¸²ã€ç½‘ç»œç¼“å†²ã€è¿è¡Œåº“å†…éƒ¨å¯¹è±¡ç­‰å½±å“ï¼Œç«¯åˆ°ç«¯â€œç»å¯¹é›¶åˆ†é…â€ä¸å¯è¾¾ã€‚

---

---

### ğŸ—ï¸ æ¶æ„é¸Ÿç°ï¼ˆä¸‰è½¨å¹¶è¡Œæ€»è§ˆï¼‰

åºåˆ—åŒ–è½¨






Dapper è½¨






EF Core è½¨











































EF Core è½¨





Dapper è½¨





DTO æµ





Row æµ





PipeWriter.FlushAsync







MemoryPack / JSON å†™å‡º  
IBufferWriter






Dapper  
buffered:false






ğŸ—„ï¸ PostgreSQL






EF Core ç¼–è¯‘æŸ¥è¯¢  
AsNoTracking + æŠ•å½±






ğŸ‘¤ Client






ASP.NET Core Minimal API

---

### 1) ğŸ§­ é€‚ç”¨ä¸è¾¹ç•Œ

* **é€‚ç”¨**ï¼šåªè¯» APIã€åˆ—è¡¨é¡µã€å¯¼å‡ºã€æŠ¥è¡¨å¿«ç…§ï¼›ä¸€è‡´æ€§çº§åˆ«ä»¥â€œè¯»å·²æäº¤/å¿«ç…§è¯»â€ä¸ºä¸»ã€‚
* **æš‚ä¸è®¨è®º**ï¼šå¤æ‚å¯¹è±¡å›¾ï¼ˆå»ºè®®**æ˜¾å¼æŠ•å½± DTO**ï¼Œé¿å… `Include` æ‹‰æ•´å›¾ï¼‰ã€å¼ºäº‹åŠ¡è¯»å†™æ··åˆã€‚

---

### 2) âš™ï¸ ä¸‰è½¨å¹¶è¡Œï¼šæ€»ä½“è®¾è®¡

* **EF Core è½¨ï¼ˆå¯ç»´æŠ¤ï¼‰**ï¼š  
   `AsNoTracking()` + **æŠ•å½± DTO** + **ç¼–è¯‘æŸ¥è¯¢**ï¼›ç”¨ `TagWith("hotpath:...")` æ ‡æ³¨ï¼Œä¾¿äºæ—¥å¿—/æ‰§è¡Œè®¡åˆ’å®šä½ã€‚ç¼–è¯‘æŸ¥è¯¢æŠŠ LINQ é¢„ç¼–è¯‘ä¸ºå§”æ‰˜ï¼Œé€‚åˆ**é«˜é‡å¤åº¦**æŸ¥è¯¢ï¼ˆæ˜¯å¦é‡‡ç”¨ä»¥åŸºå‡†è¯„ä¼°ä¸ºå‡†ï¼‰ã€‚
* **Dapper è½¨ï¼ˆæ€§èƒ½ä¼˜å…ˆï¼‰**ï¼š  
   ç¨³å®š SQL + æ‰å¹³ DTOï¼Œå¿…è¦æ—¶ `buffered:false` **éç¼“å†²**æµå¼ï¼Œæ˜æ˜¾é™ä½å¤§ç»“æœé›†å³°å€¼å†…å­˜ï¼ˆ**è¿æ¥åœ¨æšä¸¾å…¨è¿‡ç¨‹å¿…é¡»ä¿æŒæ‰“å¼€**ï¼‰ã€‚
* **åºåˆ—åŒ–/è¾“å‡ºè½¨**ï¼š  
   **MemoryPack** ä»¥ `IBufferWriter<byte>`/`PipeWriter` **ç›´å†™**ï¼›`Accept` ä¸æ”¯æŒæ—¶å›é€€ System.Text.Jsonï¼ˆå»ºè®®å¯ç”¨ **Source Generation** ä»¥å‡å°‘åå°„ã€å…¼å®¹ AOT/Trimï¼‰ã€‚å¯¹ `BodyWriter`ï¼Œ**è°ƒç”¨ `FlushAsync`** æ‰ä¼šæŠŠç¼“å†²æ¨å…¥å“åº”ä½“ã€‚

---

### 3) ğŸ§© EF Coreï¼šç¼–è¯‘æŸ¥è¯¢ + ç¦è·Ÿè¸ª + æ˜¾å¼æŠ•å½±

**å‡†åˆ™**

1. **ç¼–è¯‘æŸ¥è¯¢**ï¼š`EF.CompileQuery/CompileAsyncQuery` å°† LINQ è¡¨è¾¾å¼ç¼–è¯‘ä¸ºå§”æ‰˜ï¼Œ**ç»•è¿‡æŸ¥è¯¢ç¼“å­˜æŸ¥æ‰¾**ï¼Œåœ¨**é«˜é‡å¤åº¦**åœºæ™¯æ›´ä¼˜ï¼ˆå…ˆåšåŸºå‡†ï¼‰ã€‚
2. **åªè¯»ç¦è·Ÿè¸ª**ï¼š`AsNoTracking()` æ˜¯åªè¯»æŸ¥è¯¢çš„å¸¸è§„é€‰æ‹©ï¼›`AsNoTrackingWithIdentityResolution` ä¼šåœ¨æ— è·Ÿè¸ªä¸‹åš**èº«ä»½è§£æ**ï¼ˆå»é‡ç›¸åŒä¸»é”®å®ä¾‹ï¼‰ï¼Œä»…åœ¨ç¡®éœ€è¯­ä¹‰æ—¶ä½¿ç”¨ã€‚
3. **æŸ¥è¯¢æ ‡ç­¾**ï¼š`TagWith("hotpath:xxx")` å†™å…¥ SQL æ³¨é‡Šï¼Œå¸®åŠ©æŠŠ LINQ ä¸ç”Ÿæˆ SQL/æ—¥å¿—å¯¹åº”ã€‚

**ç¤ºä¾‹**

```csharp
// EF Core 8/9
using Microsoft.EntityFrameworkCore;

public sealed record OrderDto(int Id, string No, decimal Amount, DateTime CreatedAt);

public static class Queries
{
    // ç¼–è¯‘æŸ¥è¯¢ï¼šåªè¯» + æŠ•å½± + é™åˆ¶æ¡æ•°
    public static readonly Func<AppDbContext, int, IAsyncEnumerable<OrderDto>>
    GetRecentOrders = EF.CompileAsyncQuery((AppDbContext db, int take) =>
        db.Orders
          .TagWith("hotpath:list-orders")   // èµ·å§‹å¤„æ ‡æ³¨ï¼Œä¾¿äºæ—¥å¿—/æ‰§è¡Œè®¡åˆ’å®šä½
          .AsNoTracking()
          .OrderByDescending(x => x.CreatedAt)
          .Select(x => new OrderDto(x.Id, x.No, x.Amount, x.CreatedAt))
          .Take(take));
}

```

---

### 4) ğŸ§µ Dapperï¼šæ‰å¹³ DTO + **éç¼“å†²**æµå¼ï¼ˆçƒ­ç‚¹/å¤§ç»“æœé›†ï¼‰

* **åˆ—é¡ºåºä¸ DTO å¯¹é½**ï¼Œé™ä½æ˜ å°„å¼€é”€ï¼›
* **éç¼“å†²**ï¼š`buffered:false` ä½¿ç»“æœ**å»¶è¿Ÿæšä¸¾**ï¼Œç»“åˆâ€œè¾¹è¯»è¾¹å†™â€æ˜¾è‘—é™ä½å³°å€¼å†…å­˜ï¼›**åŠ¡å¿…ä¿è¯è¿æ¥åœ¨æšä¸¾å…¨è¿‡ç¨‹ä¿æŒæ‰“å¼€**ï¼›
* **AOT/è£å‰ªå‹å¥½**ï¼šå¯è¯„ä¼° **Dapper.AOT**ï¼ˆæ„å»ºæœŸç”Ÿæˆ/æ‹¦æˆªå™¨ï¼‰ï¼Œå‡å°‘è¿è¡Œæ—¶åå°„/å‘å°„ã€‚

**ç¤ºä¾‹ï¼ˆæµå¼ JSONï¼šå–æ¶ˆä»¤ç‰Œ + åˆ†æ®µ Flush + STJ SourceGen + ç»Ÿä¸€é™é‡ + æ—  RegisterForDisposeï¼‰**

```csharp
using System.Data;
using System.Text.Json;
using System.Text.Json.Serialization;
using Dapper;

public readonly record struct OrderRow(int Id, string No, decimal Amount, DateTime CreatedAt);

// System.Text.Json Source Generator ä¸Šä¸‹æ–‡ï¼ˆAOT/æ€§èƒ½å‹å¥½ï¼‰
[JsonSourceGenerationOptions(
    GenerationMode = JsonSourceGenerationMode.Serialization,
    WriteIndented = false)]
[JsonSerializable(typeof(OrderRow))]
[JsonSerializable(typeof(OrderRow[]))]
[JsonSerializable(typeof(OrderDto))]
public partial class SourceGenContext : JsonSerializerContext {}

app.MapGet("/orders/dapper-json", async (IDbConnection cnn, HttpContext ctx, int take, CancellationToken ct) =>
{
    take = Math.Clamp(take, 0, 50_000); // ç»Ÿä¸€é™é‡ï¼Œé˜²æ­¢è¯¯ç”¨æ‹‰çˆ†å†…å­˜/å¸¦å®½

    const string sql = """
        select id as Id, no as No, amount as Amount, created_at as CreatedAt
        from orders
        order by created_at desc
        limit @take;
    """;

    // éç¼“å†²=å»¶è¿Ÿæšä¸¾ï¼šè¿æ¥éœ€ä¿æŒæ‰“å¼€ï¼ˆå‡è®¾ç”± DI æ‰˜ç®¡ç”Ÿå‘½å‘¨æœŸï¼Œä¸é¢å¤–æ³¨å†Œé‡Šæ”¾ï¼‰
    if (cnn.State != ConnectionState.Open) cnn.Open();

    ctx.Response.ContentType = "application/json";
    using var json = new Utf8JsonWriter(ctx.Response.BodyWriter,
        new JsonWriterOptions { SkipValidation = true });

    json.WriteStartArray();

    int counter = 0;
    foreach (var row in cnn.Query<OrderRow>(sql, new { take }, buffered: false))
    {
        if (ct.IsCancellationRequested) break; // åŒæ­¥éç¼“å†²æ— æ³•æŠŠ CT ä¼ å…¥ DB å‘½ä»¤

        JsonSerializer.Serialize(json, row, SourceGenContext.Default.OrderRow);

        // å¯é€‰ï¼šåˆ†æ®µ Flushï¼Œé™ä½å°¾å»¶è¿Ÿï¼ˆé˜ˆå€¼å¯æ ¹æ®ç½‘ç»œ/ä»£ç†è°ƒä¼˜ï¼›é»˜è®¤ä¸å¿…é¢‘ç¹åˆ·ï¼‰
        if ((++counter % 2000) == 0)
        {
            json.Flush();
            await ctx.Response.BodyWriter.FlushAsync(ct);
        }
    }

    json.WriteEndArray();
    json.Flush();                                 // åˆ·åˆ° PipeWriter ç¼“å†²
    await ctx.Response.BodyWriter.FlushAsync(ct); // æ¨åˆ°å“åº”ä½“ï¼ˆç½‘ç»œï¼‰
});

```

#### ğŸ“¡ Dapper éç¼“å†²åºåˆ—åŒ–æ—¶åº

Client






ASP.NET Core






IDbConnection






PostgreSQL






Utf8JsonWriter






















GET /orders/dapper-json


Open()


Execute Query (buffered:false)





éç¼“å†²=é€è¡Œæšä¸¾ï¼Œé¿å…ä¸€æ¬¡æ€§ç‰©åŒ–

Row


Serialize(row)








loop


[rows]




writer.Flush() å°†æ•°æ®åˆ·å…¥ç®¡é“ç¼“å†²

BodyWriter.FlushAsync() æ¨åˆ°å“åº”ä½“ï¼ˆç½‘ç»œï¼‰





Client




ASP.NET Core




IDbConnection




PostgreSQL




Utf8JsonWriter

---

### 5) ğŸ“¦ EF â†’ JSON æµå¼ç«¯ç‚¹

```csharp
using System.Text.Json;

app.MapGet("/orders/ef-json-stream", async (AppDbContext db, HttpContext ctx, int take, CancellationToken ct) =>
{
    take = Math.Clamp(take, 0, 50_000);

    ctx.Response.ContentType = "application/json";
    using var json = new Utf8JsonWriter(ctx.Response.BodyWriter);

    json.WriteStartArray();

    await foreach (var x in Queries.GetRecentOrders(db, take).WithCancellation(ct))
    {
        JsonSerializer.Serialize(json, x, SourceGenContext.Default.OrderDto);
    }

    json.WriteEndArray();
    json.Flush();
    await ctx.Response.BodyWriter.FlushAsync(ct);
});

```

---

### 6) ğŸ“¤ è¾“å‡ºé›¶æ‹·è´ä¼˜å…ˆï¼š**MemoryPack + BodyWriter** ç›´å†™ï¼ˆäºŒè¿›åˆ¶ä¼˜å…ˆï¼ŒJSON å›é€€ï¼‰

* **MemoryPack**ï¼šæºç ç”Ÿæˆã€AOT å‹å¥½ï¼Œæ”¯æŒç›´æ¥åºåˆ—åŒ–åˆ° `IBufferWriter<byte>`/`Stream`ï¼›é€‚åˆå¤§å¯¹è±¡/é«˜ QPS è¿”å›ä½“ã€‚
* **ASP.NET Core**ï¼š`HttpResponse.BodyWriter` ä¸º `PipeWriter`ï¼Œç¼“å†²å†™ï¼›**è°ƒç”¨ `FlushAsync`** æ§åˆ¶ä½•æ—¶æŠŠç¼“å†²å†™è¿›å“åº”ä½“ã€‚
* **å†…å®¹åå•†**ï¼šçº¦å®š `Accept: application/x-memorypack` ç”¨äºŒè¿›åˆ¶ï¼›å¦åˆ™å›é€€ JSONï¼ˆå»ºè®® STJ Source Generation ä»¥å‡å°‘åå°„ä¸ AOT é£é™©ï¼‰ã€‚MVC åœºæ™¯å¯ç”¨ MemoryPack çš„ Formatter ç®€åŒ–é…ç½®ã€‚

**ç¤ºä¾‹ï¼ˆåª’ä½“ç±»å‹ `application/x-memorypack` + ç»Ÿä¸€é™é‡ï¼‰**

```csharp
using MemoryPack;
using System.Text.Json;

[MemoryPackable]
public partial record OrderDto(int Id, string No, decimal Amount, DateTime CreatedAt);

app.MapGet("/orders/ef-mpk", async (AppDbContext db, HttpContext ctx, int take, CancellationToken ct) =>
{
    take = Math.Clamp(take, 0, 50_000);

    var list = new List<OrderDto>(Math.Min(take, 8192));
    await foreach (var x in Queries.GetRecentOrders(db, take).WithCancellation(ct))
        list.Add(x);

    var accept = ctx.Request.Headers.Accept.ToString();
    if (accept.Contains("application/x-memorypack", StringComparison.OrdinalIgnoreCase))
    {
        ctx.Response.ContentType = "application/x-memorypack";
        MemoryPackSerializer.Serialize(ctx.Response.BodyWriter, list); // ç›´å†™ IBufferWriter<byte>
        await ctx.Response.BodyWriter.FlushAsync(ct);
    }
    else
    {
        ctx.Response.ContentType = "application/json";
        using var json = new Utf8JsonWriter(ctx.Response.BodyWriter);
        json.WriteStartArray();
        foreach (var x in list)
            JsonSerializer.Serialize(json, x, SourceGenContext.Default.OrderDto);
        json.WriteEndArray();
        json.Flush();
        await ctx.Response.BodyWriter.FlushAsync(ct);
    }
});

```

---

### ğŸ§  è¯»è·¯å¾„é€‰æ‹©å†³ç­–æ ‘

å¦





æ˜¯





å¦





æ˜¯















æ˜¯





å¦







å¼€å§‹






QPS â‰¥ 1k/s  
ä¸”æŸ¥è¯¢å­—æ®µç¨³å®š?






EF Core ç¼–è¯‘æŸ¥è¯¢  
+ AsNoTracking + æŠ•å½±






ç»“æœé›† > 100k rows  
æˆ– p95 > 200ms?






Dapper éç¼“å†² + æ‰å¹³ DTO






å¸¦å®½æ•æ„Ÿ/å†…ç½‘å¯¹æ¥?






MemoryPack + BodyWriter ç›´å†™






System.Text.Json (SourceGen)

> æ³¨ï¼šé˜ˆå€¼ä¸º**ç¤ºä¾‹**ï¼Œè¯·ä¾æ®ä½ çš„åŸºå‡†ä¸çº¿ä¸ŠæŒ‡æ ‡è®¾å›¢é˜Ÿé—¨æ§›ã€‚

---

### 7) ğŸ” Hot Path å®¡è®¡æ¸…å•ï¼ˆæŠŠåˆ†é…â€œçœ‹å¾—è§â€ï¼‰

* **åˆ†é…/GC ç›‘æ§**ï¼š`dotnet-counters monitor System.Runtime` è§‚å¯Ÿ Allocation Rateã€Gen0/1/2ã€å †å¤§å°ã€‚
* **æ‰§è¡ŒæœŸè¿½è¸ª**ï¼š`dotnet-trace collect -- <command>` é‡‡é›† EventPipe äº‹ä»¶ï¼Œé… PerfView/SpeedScope åˆ†æ **Alloc Stacks/FlameGraph**ã€‚
* **ä»£ç ä¾§**ï¼šé¿å…ä¸­é—´ `ToList()`/`string.Format`/é“¾å¼ LINQ éšå¼åˆ†é…ï¼›JSON è·¯å¾„ç”¨ `Utf8JsonWriter(IBufferWriter<byte>)`ï¼›EF é»˜è®¤ `AsNoTracking()`ï¼Œ`AsNoTrackingWithIdentityResolution` ä»…åœ¨ç¡®éœ€å»é‡å®ä¾‹æ—¶ä½¿ç”¨ã€‚

âš”ï¸ wrk / bombardier






ğŸŸ¦ ASP.NET Core åº”ç”¨






ğŸ§® dotnet-counters






ğŸ§µ dotnet-trace






ğŸ“Š Allocation Rate/GC Gen






ğŸ”§ ä¿®å¤: å» ToList/å¯ç”¨éç¼“å†²/ç›´å†™ç­‰

---

### 8) ğŸ§ª åŸºå‡†æ–¹æ³•å­¦ï¼ˆBenchmarkDotNetï¼‰

* **å¾®åŸºå‡†**

  + Case Aï¼šEF æ™®é€šæŸ¥è¯¢ vs **ç¼–è¯‘æŸ¥è¯¢**ï¼ˆé«˜é‡å¤åº¦ï¼‰ï¼›
  + Case Bï¼šEF æŠ•å½± DTO vs Dapperï¼ˆç›¸åŒå­—æ®µã€ç›¸åŒç­›é€‰ï¼‰ï¼›
  + Case Cï¼šSTJï¼ˆSourceGenï¼‰vs **MemoryPack**ï¼ˆS/M/L å¯¹è±¡ã€æ‰¹é‡è§„æ¨¡ï¼‰ã€‚
* **é‡‡é›†**ï¼š`[MemoryDiagnoser]` è¾“å‡º **Allocated B/Op** ä¸ GC æ¬¡æ•°ï¼›`[Benchmark(Baseline = true)]` è®¾åŸºçº¿ã€‚
* **ç«¯åˆ°ç«¯**ï¼šé…åˆ `wrk`/`bombardier` è¿›è¡Œåå/å°¾å»¶è¿Ÿå¯¹æ¯”ï¼Œæ—è·¯è·‘ `dotnet-counters`ã€‚

**åŸºå‡†éª¨æ¶**

```csharp
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.EntityFrameworkCore;

[MemoryDiagnoser] // é‡‡é›†åˆ†é…/GC æŒ‡æ ‡
public class EfCompiledVsNormal
{
    private AppDbContext _db = default!;

    [GlobalSetup]
    public void Setup() => _db = DbFactory.Create();

    [Benchmark(Baseline = true)]
    public async Task<List<OrderDto>> Normal()
      => await _db.Orders.AsNoTracking()
            .OrderByDescending(x => x.CreatedAt)
            .Select(x => new OrderDto(x.Id, x.No, x.Amount, x.CreatedAt))
            .Take(1000).ToListAsync();

    [Benchmark]
    public async Task<List<OrderDto>> Compiled()
    {
        var list = new List<OrderDto>(1000);
        await foreach (var x in Queries.GetRecentOrders(_db, 1000))
            list.Add(x);
        return list;
    }
}

public static class Program
{
    public static void Main() => BenchmarkRunner.Run<EfCompiledVsNormal>();
}

```

ğŸ§° GlobalSetup: é¢„ç½® DB/æ•°æ®






Case A: EF æ™®é€š vs ç¼–è¯‘æŸ¥è¯¢






Case B: EF æŠ•å½± vs Dapper






Case C: STJ vs MemoryPack






BenchmarkDotNet  
MemoryDiagnoser






ğŸ“ˆ ops/s, p95/p99, Allocated B/op, GC æ¬¡æ•°






ğŸ§­ è°ƒæ•´çƒ­è·¯å¾„ä¸é…ç½®

---

### 9) ğŸ§° å¯å¤ç°å®éªŒæ¨¡æ¿ï¼ˆæœ€å°å·¥ç¨‹ï¼‰

**1) æ–°å»ºå·¥ç¨‹ & ä¾èµ–**

```bash
dotnet new web -n ZeroAllocRead
cd ZeroAllocRead
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet add package Dapper
dotnet add package MemoryPack
# å¯é€‰ï¼ˆAOT/Trim å‹å¥½ï¼‰
dotnet add package Dapper.AOT

```

**2) Docker èµ·åº“ï¼ˆPostgreSQL 16ï¼‰**

```yaml
# docker-compose.yml
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: devpass
      POSTGRES_USER: dev
      POSTGRES_DB: demo
    ports: ["5432:5432"]

```

```bash
docker compose up -d

```

**3) åˆå§‹åŒ–è¡¨ä¸æ•°æ®ï¼ˆpsql ç¤ºä¾‹ï¼‰**

```sql
create table orders(
  id serial primary key,
  no text not null,
  amount numeric not null,
  created_at timestamp not null default now()
);

insert into orders(no,amount,created_at)
select 'ORD-'||g, (random()*1000)::numeric, now() - (g||' minutes')::interval
from generate_series(1, 500000) as g;

```

**4) ä»£ç è½åœ°**

* å»º `Queries.cs`ï¼ˆç¬¬ 3 èŠ‚ï¼‰ï¼›
* åœ¨ `Program.cs` æ·»åŠ ç¬¬ 4ã€5ã€6 èŠ‚çš„ Minimal APIï¼›
* é…ç½®è¿æ¥ä¸²ä¸ DbContext æ³¨å†Œï¼›
* è¿è¡Œï¼š`dotnet run`ã€‚
* éªŒè¯ï¼š

  + `GET /orders/ef-mpk`ï¼š

    - `Accept: application/x-memorypack` â†’ MemoryPack äºŒè¿›åˆ¶ï¼›
    - `Accept: application/json` â†’ JSONï¼ˆSTJ Source Generationï¼‰ã€‚
  + `GET /orders/dapper-json`ï¼šå¤§åˆ†é¡µä¸‹è§‚å¯Ÿå†…å­˜æ›²çº¿æ›´ç¨³ã€‚
  + `GET /orders/ef-json-stream`ï¼šEF è·¯å¾„çš„ JSON æµå¼å¯¹ç…§æ ·ä¾‹ã€‚

---

### 10) ğŸ” é€‰æ‹©ä¸å›æ»š

| åœºæ™¯ | é¦–é€‰è·¯å¾„ |
| --- | --- |
| å˜æ›´é¢‘ç¹ã€ä¸­ä½ QPS | **EF Core**ï¼ˆç¼–è¯‘æŸ¥è¯¢ + æŠ•å½± + AsNoTrackingï¼‰ |
| çƒ­ç‚¹/å­—æ®µå›ºå®š/é«˜ QPS | **Dapper** éç¼“å†² + æ‰å¹³ DTO |
| æœåŠ¡é—´/å¸¦å®½æ•æ„Ÿ | **MemoryPack** + `BodyWriter` ç›´å†™ï¼›å…¬å…± API â†’ **JSON å›é€€** |

**é£é™©ä¸å›æ»š**

* **AOT/Trim**ï¼šæ™®é€š Dapper ä¾èµ–è¿è¡Œæ—¶åå°„/å‘å°„ï¼›**Dapper.AOT** ç”¨ç”Ÿæˆä»£ç æ›¿ä»£ï¼Œæ›´é€‚é… AOTã€‚
* **èº«ä»½è§£æ**ï¼š`AsNoTrackingWithIdentityResolution` ä»…åœ¨ç¡®éœ€æ—¶ä½¿ç”¨ã€‚
* **åè®®ç‰ˆæœ¬åŒ–**ï¼šMemoryPack è¾“å‡ºå»ºè®®åŠ é­”æ•°/ç‰ˆæœ¬ï¼›MVC å¯ç”¨ MemoryPack çš„ Formatter ç®€åŒ–é…ç½®ã€‚



