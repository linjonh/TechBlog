---
layout: post
title: "Scala统计每个单词出现的个数并打印"
date: 2025-03-05 22:56:33 +0800
description: "Hadoop: 2\"Hadoop\"\"Spark\"\\\\s+Map复制代码forif-else。"
keywords: "Scala：统计每个单词出现的个数并打印"
categories: ['Scala']
tags: ['开发语言', 'Scala']
artid: "146053567"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053567
    alt: "Scala统计每个单词出现的个数并打印"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053567
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053567
cover: https://bing.ee123.net/img/rand?artid=146053567
image: https://bing.ee123.net/img/rand?artid=146053567
img: https://bing.ee123.net/img/rand?artid=146053567
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Scala：统计每个单词出现的个数并打印
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="382" src="https://i-blog.csdnimg.cn/direct/14db66035c2645058ff7372c6d4576c8.png" width="1593"/>
    </h4>
    <p id="Q1：为什么要用 split(" style="margin-left:120px">
     <a href="#Q1：为什么要用%20split%28" rel="nofollow">
      Q1：为什么要用 split(" +") 而不是 split(" ")？
     </a>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
    </p>
    <h4 id="问题拆解：" name="问题拆解：" style="background-color:transparent">
     <strong>
      问题拆解：
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       目标
      </strong>
      ：统计每个单词出现的次数。
     </li>
     <li>
      <strong>
       输入
      </strong>
      ：一个包含多个字符串的列表，每个字符串中有多个单词。
     </li>
     <li>
      <strong>
       输出
      </strong>
      ：每个单词及其出现次数，例如
      <code>
       Hadoop: 2
      </code>
      。
     </li>
    </ol>
    <hr/>
    <h4 id="解题步骤：" name="解题步骤：">
     <strong>
      解题步骤：
     </strong>
    </h4>
    <h5 id="1. 拆分所有字符串为单词" name="1. 拆分所有字符串为单词">
     <strong>
      1. 拆分所有字符串为单词
     </strong>
    </h5>
    <ul>
     <li>
      每个字符串（如
      <code>
       "Hadoop Spark"
      </code>
      ）需要拆分成独立的单词（
      <code>
       "Hadoop"
      </code>
      和
      <code>
       "Spark"
      </code>
      ）。
     </li>
     <li>
      使用
      <code>
       split("\\s+")
      </code>
      方法按空格分割字符串（
      <code>
       \\s+
      </code>
      表示匹配一个或多个空格）。
     </li>
    </ul>
    <h5 id="2. 遍历所有单词并统计" name="2. 遍历所有单词并统计">
     <strong>
      2. 遍历所有单词并统计
     </strong>
    </h5>
    <ul>
     <li>
      创建一个可变的
      <code>
       Map
      </code>
      来存储单词和对应的出现次数。
     </li>
     <li>
      遍历每个单词：
      <ul>
       <li>
        如果单词已经在 Map 中，将次数 +1。
       </li>
       <li>
        如果不在 Map 中，添加该单词并将次数设为 1。
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="3. 打印结果" name="3. 打印结果">
     <strong>
      3. 打印结果
     </strong>
    </h5>
    <ul>
     <li>
      遍历 Map 中的所有键值对，按格式输出。
     </li>
    </ul>
    <hr/>
    <h4 id="基础版代码实现：" name="基础版代码实现：">
     <strong>
      基础版代码实现：
     </strong>
    </h4>
    <pre><code class="language-Scala">object WordCountBasic extends App {
  val list1 = List(
    "Hadoop Spark",
    "Spark Scala",
    "Scala Java",
    "Scala Akka",
    "Hadoop Java Scala"
  )

  // 步骤1：创建一个可变的Map来存储结果
  val wordCount = scala.collection.mutable.HashMap[String, Int]()

  // 步骤2：遍历每个字符串
  for (sentence &lt;- list1) {
    // 拆分当前字符串为单词数组
    val words = sentence.split("\\s+")
    // 遍历每个单词
    for (word &lt;- words) {
      // 如果Map中已有该单词，次数+1；否则添加单词，次数设为1
      if (wordCount.contains(word)) {
        wordCount(word) += 1
      } else {
        wordCount(word) = 1
      }
    }
  }

  // 步骤3：打印结果
  for ((word, count) &lt;- wordCount) {
    println(s"$word: $count")
  }
}</code></pre>
    <hr/>
    <h4 id="代码解释：" name="代码解释：">
     <strong>
      代码解释：
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       可变Map
      </strong>
      ：用
      <code>
       mutable.HashMap
      </code>
      存储单词计数，方便修改值。
     </li>
     <li>
      <strong>
       双层循环
      </strong>
      ：
      <ul>
       <li>
        外层循环
        <code>
         for (sentence &lt;- list1)
        </code>
        ：遍历列表中的每个字符串。
       </li>
       <li>
        内层循环
        <code>
         for (word &lt;- words)
        </code>
        ：遍历每个字符串拆分后的单词。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       统计逻辑
      </strong>
      ：
      <ul>
       <li>
        <code>
         if (wordCount.contains(word))
        </code>
        ：检查单词是否已存在。
       </li>
       <li>
        <code>
         wordCount(word) += 1
        </code>
        ：存在则次数+1。
       </li>
       <li>
        <code>
         wordCount(word) = 1
        </code>
        ：不存在则初始化为1。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       最终输出
      </strong>
      ：遍历 Map 并打印每个键值对。
     </li>
    </ol>
    <hr/>
    <h4 id="输出结果：" name="输出结果：">
     <strong>
      输出结果：
     </strong>
    </h4>
    <p>
     复制代码
    </p>
    <pre><code>Hadoop: 2
Spark: 2
Scala: 4
Java: 2
Akka: 1</code></pre>
    <hr/>
    <h4 id="为什么这样设计？" name="为什么这样设计？">
     <strong>
      为什么这样设计？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       新手友好
      </strong>
      ：用基础的
      <code>
       for
      </code>
      循环和
      <code>
       if-else
      </code>
      代替高阶函数，逻辑更直观。
     </li>
     <li>
      <strong>
       可变性
      </strong>
      ：使用可变 Map 可以逐步更新状态，符合新手对“变量”的直觉。
     </li>
     <li>
      <strong>
       分步拆解
      </strong>
      ：明确的三步走（拆分、统计、打印），降低理解难度。
     </li>
    </ul>
    <hr/>
    <pre><code class="language-Scala">object WordCountBasic extends App</code></pre>
    <h4 id="%E7%BB%A7%E6%89%BF%E7%9A%84APP%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%C2%A0" name="%E7%BB%A7%E6%89%BF%E7%9A%84APP%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%C2%A0">
     继承的APP是个啥？
    </h4>
    <p>
     在Scala中，
     <code>
      App
     </code>
     是一个特质（trait）。
    </p>
    <ol>
     <li>
      <strong>
       简化主方法
      </strong>
      <ul>
       <li>
        当一个Scala类扩展了
        <code>
         App
        </code>
        特质时，它就不需要显式地定义
        <code>
         main
        </code>
        方法了。例如在你给出的
        <code>
         WordCountBasic
        </code>
        类扩展了
        <code>
         App
        </code>
        ，就可以直接在类体中编写可执行的代码，就好像这些代码是写在
        <code>
         main
        </code>
        方法内部一样。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       执行入口
      </strong>
      <ul>
       <li>
        当运行这个类时，Scala运行时会查找这个类中的可执行代码（类似于查找传统的
        <code>
         main
        </code>
        方法）并执行它。这是一种更简洁的方式来编写Scala程序的入口点，相比于定义一个包含
        <code>
         main
        </code>
        方法的类。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     当一个类扩展了
     <code>
      App
     </code>
     特质时，可以省略
     <code>
      def main(args: Array[String]): Unit = {}
     </code>
     这种传统的定义主方法的形式。
    </p>
    <ol>
     <li>
      <strong>
       原理
      </strong>
      <ul>
       <li>
        当类扩展
        <code>
         App
        </code>
        时，Scala编译器会在背后生成一个合适的
        <code>
         main
        </code>
        方法。这个生成的
        <code>
         main
        </code>
        方法会执行类体中的代码，就好像这些代码是写在传统的
        <code>
         main
        </code>
        方法内部一样。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       示例对比
      </strong>
      <ul>
       <li>
        传统方式：
        <ul>
         <li>
          如果不使用
          <code>
           App
          </code>
          ，你需要像这样定义一个类：
         </li>
        </ul>
        <pre><code class="language-Scala">object WordCountTraditional {
  def main(args: Array[String]): Unit = {
    // 这里编写主逻辑，比如
    println("Hello, world!")
  }
}</code></pre>
       </li>
       <li>
        使用
        <code>
         App
        </code>
        方式：
        <pre><code class="language-Scala">object WordCountApp extends App {
  println("Hello, world!")
}</code></pre>
       </li>
       <li>
        在这两个示例中，
        <code>
         WordCountApp
        </code>
        以更简洁的方式实现了与
        <code>
         WordCountTraditional
        </code>
        类似的功能，不需要显式地定义
        <code>
         main
        </code>
        方法。
       </li>
      </ul>
     </li>
    </ol>
    <h3 id="%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" name="%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" style="background-color:transparent">
     使用高阶函数式编程
    </h3>
    <pre><code class="language-Scala">object WordCount {
  def main(args: Array[String]): Unit = {
    val list1 = List(
      "Hadoop Spark",
      "Spark Scala",
      "Scala Java", 
      "Scala Akka",
      "Hadoop Java Scala"
    )

    val wordCounts = list1
      .flatMap(_.split(" +"))        // 步骤1+2：拆分并展平
      .groupBy(identity)             // 步骤3：按单词分组
      .mapValues(_.size)             // 步骤3：统计每组的数量
      .toList                        // 转换为列表
      .sortBy(_._1)                  // 步骤4：按单词排序

    wordCounts.foreach { case (word, count) =&gt;
      println(s"$word: $count")      // 步骤4：打印结果
    }
  }
}</code></pre>
    <p>
    </p>
    <h4 id="第一步：理解基础操作" name="第一步：理解基础操作">
     <strong>
      第一步：理解基础操作
     </strong>
    </h4>
    <p>
     假设我们有一个简单的列表：
    </p>
    <pre><code class="language-Scala">val simpleList = List("Hello World", "Hello Scala")</code></pre>
    <h5 id="目标：" name="目标：">
     <strong>
      目标
     </strong>
     ：
    </h5>
    <p>
     统计每个单词出现的次数，结果应该是：
    </p>
    <p>
     复制代码
    </p>
    <pre><code class="language-Scala">Hello → 2
World → 1
Scala → 1</code></pre>
    <hr/>
    <h4 id="第二步：拆分字符串" name="第二步：拆分字符串">
     <strong>
      第二步：拆分字符串
     </strong>
    </h4>
    <p>
     每个句子需要拆分成单词：
    </p>
    <pre><code class="language-Scala">// 拆分第一个元素 "Hello World" → Array("Hello", "World")
val split1 = simpleList(0).split(" ")  // 按空格拆分
println(split1.mkString(", "))  // 输出: Hello, World</code></pre>
    <p>
     <strong>
      问题
     </strong>
     ：如果直接对整个列表用
     <code>
      map
     </code>
     ，会得到嵌套结构：
    </p>
    <pre><code class="language-Scala">val splitAll = simpleList.map(_.split(" ")) 
// 结果：List(Array("Hello", "World"), Array("Hello", "Scala"))</code></pre>
    <hr/>
    <h4 id="第三步：展平列表（flatMap）" name="第三步：展平列表（flatMap）">
     <strong>
      第三步：展平列表（
      <code>
       flatMap
      </code>
      ）
     </strong>
    </h4>
    <p>
     用
     <code>
      flatMap
     </code>
     把嵌套的数组变成“平”的列表：
    </p>
    <pre><code class="language-Scala">val allWords = simpleList.flatMap(_.split(" "))
// 结果：List("Hello", "World", "Hello", "Scala")</code></pre>
    <p>
     <strong>
      为什么用
      <code>
       flatMap
      </code>
      ？
     </strong>
    </p>
    <ul>
     <li>
      <code>
       map
      </code>
      的结果：
      <code>
       List(Array(...), Array(...))
      </code>
      （两层结构）
     </li>
     <li>
      <code>
       flatMap
      </code>
      的结果：
      <code>
       List("Hello", "World", "Hello", "Scala")
      </code>
      （一层结构）
     </li>
    </ul>
    <hr/>
    <h4 id="第四步：分组统计（groupBy）" name="第四步：分组统计（groupBy）">
     <strong>
      第四步：分组统计（
      <code>
       groupBy
      </code>
      ）
     </strong>
    </h4>
    <p>
     把相同的单词分到同一组：
    </p>
    <pre><code class="language-Scala">val groups = allWords.groupBy(word =&gt; word)
// 结果：
// Map(
//   "Hello" -&gt; List("Hello", "Hello"),
//   "World" -&gt; List("World"),
//   "Scala" -&gt; List("Scala")
// )</code></pre>
    <p>
     <strong>
      解释
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       groupBy(word =&gt; word)
      </code>
      表示按单词本身分组
     </li>
     <li>
      <code>
       word =&gt; word
      </code>
      可以简写为
      <code>
       identity
      </code>
      （等价函数）
     </li>
    </ul>
    <hr/>
    <h4 id="第五步：统计每组数量" name="第五步：统计每组数量">
     <strong>
      第五步：统计每组数量
     </strong>
    </h4>
    <p>
     对每个分组计算元素个数：
    </p>
    <pre><code class="language-Scala">val counts = groups.map { case (word, list) =&gt; 
  (word, list.size) 
}
// 结果：Map("Hello" -&gt; 2, "World" -&gt; 1, "Scala" -&gt; 1)</code></pre>
    <hr/>
    <h4 id="第六步：排序并打印" name="第六步：排序并打印">
     <strong>
      第六步：排序并打印
     </strong>
    </h4>
    <p>
     将结果按字母顺序排序：
    </p>
    <pre><code class="language-Scala">val sorted = counts.toList.sortBy(_._1) // 按单词排序
sorted.foreach { case (word, count) =&gt;
  println(s"$word: $count")
}</code></pre>
    <hr/>
    <h4 id="完整代码（针对原题）" name="完整代码（针对原题）">
     <strong>
      完整代码（针对原题）
     </strong>
    </h4>
    <p>
     现在将上述步骤应用到原题的数据：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code class="language-Scala">object WordCount {
  def main(args: Array[String]): Unit = {
    val list1 = List(
      "Hadoop Spark",
      "Spark Scala",
      "Scala Java", 
      "Scala Akka",
      "Hadoop Java Scala"
    )

    // 步骤1+2：拆分并展平所有单词
    val allWords = list1.flatMap(_.split(" +")) // " +" 表示1个或多个空格

    // 步骤3：分组
    val groups = allWords.groupBy(identity) // 按单词分组

    // 步骤4：统计数量
    val counts = groups.mapValues(_.size) // 计算每组的长度

    // 步骤5：排序并打印
    counts.toList          // 转换为List
      .sortBy(_._1)        // 按单词排序
      .foreach { case (word, count) =&gt; 
        println(s"$word: $count") 
      }
  }
}</code></pre>
    <hr/>
    <h4 id="关键概念解释" name="关键概念解释" style="background-color:transparent">
     <strong>
      关键概念解释
     </strong>
    </h4>
    <h5 id="1. flatMap" name="1. flatMap">
     1.
     <code>
      flatMap
     </code>
    </h5>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：先做
      <code>
       map
      </code>
      （转换），再
      <code>
       flatten
      </code>
      （展平）
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="language-Scala">List("a b", "c").flatMap(_.split(" ")) → List("a", "b", "c")</code></pre>
     </li>
    </ul>
    <h5 id="2. groupBy" name="2. groupBy">
     2.
     <code>
      groupBy
     </code>
    </h5>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：按规则分组，返回
      <code>
       Map[Key, List[Value]]
      </code>
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="language-Scala">List("a", "b", "a").groupBy(identity) → Map("a" -&gt; List("a", "a"), "b" -&gt; List("b"))</code></pre>
     </li>
    </ul>
    <h5 id="3. mapValues" name="3. mapValues">
     3.
     <code>
      mapValues
     </code>
    </h5>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：对
      <code>
       Map
      </code>
      中的值做转换，保留键不变
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="language-Scala">Map("a" -&gt; List(1,2)).mapValues(_.size) → Map("a" -&gt; 2)</code></pre>
     </li>
    </ul>
    <hr/>
    <h4 id="执行结果" name="执行结果">
     <strong>
      执行结果
     </strong>
    </h4>
    <p>
     运行代码后输出：
    </p>
    <pre><code class="language-Scala">Akka: 1
Hadoop: 2
Java: 2
Scala: 4
Spark: 2</code></pre>
    <hr/>
    <h4 id="新手常见疑问" name="新手常见疑问">
     <strong>
      新手常见疑问
     </strong>
    </h4>
    <h5 id='Q1：为什么要用 split(" +") 而不是 split(" ")？' name='Q1：为什么要用 split(" +") 而不是 split(" ")？'>
     Q1：为什么要用
     <code>
      split(" +")
     </code>
     而不是
     <code>
      split(" ")
     </code>
     ？
    </h5>
    <ul>
     <li>
      <code>
       split(" ")
      </code>
      会把连续空格拆分成空字符串，例如
      <code>
       "a b"
      </code>
      →
      <code>
       Array("a", "", "b")
      </code>
     </li>
     <li>
      <code>
       split(" +")
      </code>
      中的
      <code>
       +
      </code>
      表示匹配一个或多个空格，能正确处理连续空格
     </li>
    </ul>
    <h5 id="Q2：identity 是什么？" name="Q2：identity 是什么？">
     Q2：
     <code>
      identity
     </code>
     是什么？
    </h5>
    <ul>
     <li>
      <code>
       identity
      </code>
      是一个预定义的函数，等价于
      <code>
       x =&gt; x
      </code>
     </li>
     <li>
      例如：
      <code>
       groupBy(identity)
      </code>
      和
      <code>
       groupBy(x =&gt; x)
      </code>
      完全一样
     </li>
    </ul>
    <h5 id="Q3：sortBy(_._1) 中的 _._1 是什么意思？" name="Q3：sortBy(_._1) 中的 _._1 是什么意思？">
     Q3：
     <code>
      sortBy(_._1)
     </code>
     中的
     <code>
      _._1
     </code>
     是什么意思？
    </h5>
    <ul>
     <li>
      <code>
       _
      </code>
      表示元组，例如
      <code>
       ("Scala", 4)
      </code>
     </li>
     <li>
      <code>
       _._1
      </code>
      表示取元组的第一个元素（即单词），
      <code>
       _._2
      </code>
      是第二个元素（即计数）
     </li>
    </ul>
    <hr/>
    <h4 id="调试技巧" name="调试技巧" style="background-color:transparent">
     <strong>
      调试技巧
     </strong>
    </h4>
    <p>
     如果中间步骤不理解，可以插入
     <code>
      println
     </code>
     查看数据：
    </p>
    <pre><code class="language-Scala">val allWords = list1.flatMap(_.split(" +"))
println(s"拆分后的单词：$allWords")  // 查看展平后的结果</code></pre>
    <h4 style="background-color:transparent">
     另一种写法（大差不差）
    </h4>
    <p>
     <img alt="" height="805" src="https://i-blog.csdnimg.cn/direct/bff588785a524e9cb6ee70d1883ba09c.png" width="1382"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f37393438303432322f:61727469636c652f64657461696c732f313436303533353637" class_="artid" style="display:none">
 </p>
</div>


