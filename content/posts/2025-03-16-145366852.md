---
layout: post
title: "C语言函数和数组实践与应用开发简单的扫雷游戏"
date: 2025-03-16 21:03:41 +0800
description: "通过本次实践，我们不仅实现了经典的扫雷游戏，还学习了如何设计和实现一个简单的游戏。在实现过程中，我们使用了数组、函数、随机数生成等C语言知识，同时也体会到了模块化编程的好处。希望这篇文章能帮助你更好地理解扫雷游戏的实现过程，激发你对编程的兴趣。"
keywords: "【C语言】函数和数组实践与应用：开发简单的扫雷游戏"
categories: ['未分类']
tags: ['游戏', 'Java', 'C']
artid: "145366852"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145366852
    alt: "C语言函数和数组实践与应用开发简单的扫雷游戏"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145366852
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145366852
cover: https://bing.ee123.net/img/rand?artid=145366852
image: https://bing.ee123.net/img/rand?artid=145366852
img: https://bing.ee123.net/img/rand?artid=145366852
---

# 【C语言】函数和数组实践与应用：开发简单的扫雷游戏

## 1.扫雷游戏分析和设计

### 1.1扫雷游戏的功能说明（游戏规则）

> 1.使用控制台实现经典的扫雷游戏  
>  2.游戏可以通过菜单实现继续玩或者退出游戏  
>  3.扫雷的棋盘是9*9的格子  
>  4.默认随机布置10个雷  
>  5.可以排查雷

  * 如果位置不是雷，就显示周围有几个雷
  * 如果位置是雷，就炸死游戏结束
  * 把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束

![扫雷游戏界面](https://i-blog.csdnimg.cn/direct/492c9f76e0594fb1995cacef2df45357.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c1900eabc13a416d958cb187a69c9c88.png)  
C语言代码实现界面：  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3dfe1418c63a437ebb35de9abe14424f.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d5a5e0d6851b4a44bd32b21f0c59c557.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/725185342ced43d0a9d732161c6cc36a.png)

### 1.2游戏的分析与设计

#### 1.2.1游戏的分析

> 扫雷的过程中，布置的雷和排查出的雷的信息都需要存储，所以我们需要一定的数据结构来存储这些信息。  
>  因为我们需要在9x9的棋盘上布置雷的信息和排查雷，我们首先想到的就是创建一个9x9的数组来存放信息。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/509b47a691db48c1b40ae2612ca0eaaf.png)  
那如果这个位置布置雷，我们就存放1，没有布置雷就存放0

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fbbe3824cfff4af2b1707656144b71cf.png)

假设我们排查(1,5)这个坐标时，我们访问周围的一圈8个黄色位置，统计周围雷的个数是1  
假设我们排查(8,6)这个坐标时，我们访问周围的一圈8个黄色位置，统计周围雷的个数时，最下面的三个坐标就会越界，为了防止越界，我们在设计的时候，给数组扩大一圈，雷还是布置在中间的9x9的坐标上，周围一圈不去布置雷就行，这样就解决了越界的问题。所以我们将存放数据的数组创建成11x11是比较合适。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/babb8c6211be4dcbaeac6e1bc65ad5b1.png)

> 再继续分析，我们在棋盘上布置了雷，棋盘上雷的信息“1  
>
> 湘曾的信息(0)假设我们排查了某个位置后，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的。那这个雷的个数信息存放在哪里呢?如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能或产生混淆和打印上的困难。  
>
> 这里我们肯定有办法解决，比如:雷和非雷的信息不要使用数字，使用某些字符就行，这样就避免冲突了，但是这样做棋盘上有雷和非雷的信息，还有排查出的雷的个数信息，就比较混杂，不够方便。  
>
> 这里我们采用另外一种方案，我们专门给一个棋盘(对应一个数组mine)存放布置好的雷的信息，再给另外一个棋盘(对应另外一个数组show)存放排查出的雷的信息。这样就互不干扰了，把雷布置到mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期排查参考。  
>
> 同时为了保持神秘，show数组开始时初始化为字符，为了保持两个数组的类型一致，可以使用同一套函数处理，mine数组最开始也初始化为字符’0’，布置雷改成’1’。如下:

![左边是mine数组布置雷后的状态，右边是show输出初始化的状态](https://i-blog.csdnimg.cn/direct/ca54fbf163ef4f1ca1b9151231c829ef.png)

对应的数组是

    
    
    char mine[11][11] = {0};//⽤来存放布置好的雷的信息
    char show[11][11] = {0};//⽤来存放排查出的雷的个数信息
    

#### 1.2.2 文件结构设计

我们可以设计如下三个文件放入一个项目中进行

    
    
    test.c //⽂件中写游戏的测试逻辑 
    game.c //⽂件中写游戏中函数的实现等
    game.h //⽂件中写游戏需要的数据类型和函数声明
    

## 2\. 代码实现

### 2.1 game.h文件

    
    
    #pragma once
    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>
    #define EASY_COUNT 10
    #define ROW 9
    #define COL 9
    #define ROWS ROW+2
    #define COLS COL+2
    // 初始化棋盘
    void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);
    // 打印棋盘
    void DisplayBoard(char board[ROWS][COLS], int row, int col);
    // 布置雷
    void SetMine(char board[ROWS][COLS], int row, int col);
    // 排查雷
    void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);
    

### 2.2 game.c文件

    
    
    #include "game.h"
    
    // 初始化棋盘
    void InitBoard(char board[ROWS][COLS], int rows, int cols, char set) {
        int i = 0;
        for (i = 0; i < rows; i++) {
            int j = 0;
            for (j = 0; j < cols; j++) {
                board[i][j] = set;
            }
        }
    }
    
    // 打印棋盘
    void DisplayBoard(char board[ROWS][COLS], int row, int col) {
        int i = 0;
        printf("--------扫雷游戏-------\n");
        for (i = 0; i <= col; i++) {
            printf("%d ", i);
        }
        printf("\n");
        for (i = 1; i <= row; i++) {
            printf("%d ", i);
            int j = 0;
            for (j = 1; j <= col; j++) {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }
    
    // 布置雷
    void SetMine(char board[ROWS][COLS], int row, int col) {
        int count = EASY_COUNT;
        while (count) {
            int x = rand() % row + 1;
            int y = rand() % col + 1;
            if (board[x][y] == '0') {
                board[x][y] = '1';
                count--;
            }
        }
    }
    
    // 获取周围雷的数量
    int GetMineCount(char mine[ROWS][COLS], int x, int y) {
        return (mine[x - 1][y] + mine[x - 1][y - 1] + mine[x][y - 1] + mine[x + 1][y - 1] +
                mine[x + 1][y] + mine[x + 1][y + 1] + mine[x][y + 1] + mine[x - 1][y + 1] - 8 * '0');
    }
    
    // 排查雷
    void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col) {
        int x = 0;
        int y = 0;
        int win = 0;
        while (win < row * col - EASY_COUNT) {
            printf("请输入要排查的坐标:>");
            scanf("%d %d", &x, &y);
            if (x >= 1 && x <= row && y >= 1 && y <= col) {
                if (mine[x][y] == '1') {
                    printf("很遗憾，你被炸死了\n");
                    DisplayBoard(mine, ROW, COL);
                    break;
                } else {
                    int count = GetMineCount(mine, x, y);
                    show[x][y] = count + '0';
                    DisplayBoard(show, ROW, COL);
                    win++;
                }
            } else {
                printf("坐标非法，重新输入\n");
            }
        }
        if (win == row * col - EASY_COUNT) {
            printf("恭喜你，排雷成功\n");
            DisplayBoard(mine, ROW, COL);
        }
    }
    

### 2.3 test.c文件

    
    
    #include "game.h"
    
    void menu() {
        printf("***********************\n");
        printf("***** 1. play *****\n");
        printf("***** 0. exit *****\n");
        printf("***********************\n");
    }
    
    void game() {
        char mine[ROWS][COLS];  // 存放布置好的雷
        char show[ROWS][COLS];  // 存放排查出的雷的信息
        // 初始化棋盘
        InitBoard(mine, ROWS, COLS, '0');
        InitBoard(show, ROWS, COLS, '*');
        // 打印棋盘
        DisplayBoard(show, ROW, COL);
        // 布置雷
        SetMine(mine, ROW, COL);
        // 排查雷
        FindMine(mine, show, ROW, COL);
    }
    
    int main() {
        int input = 0;
        srand((unsigned int)time(NULL));
        do {
            menu();
            printf("请选择:>");
            scanf("%d", &input);
            switch (input) {
                case 1:
                    game();
                    break;
                case 0:
                    printf("退出游戏\n");
                    break;
                default:
                    printf("选择错误，重新选择\n");
                    break;
            }
        } while (input);
        return 0;
    }
    

## 3\. 游戏运行效果

运行程序后，玩家可以通过输入坐标来排查雷。如果排查到雷，游戏结束；如果成功排查出所有非雷位置，游戏胜利。

## 4\. 游戏扩展

为了增加游戏的趣味性，我们可以进行以下扩展：  
提供不同难度的选择，例如9×9棋盘10个雷、16×16棋盘40个雷、30×16棋盘99个雷。  
如果排查位置不是雷且周围没有雷，可以展开周围的一片区域。  
增加标记雷的功能。  
添加排雷时间显示。

## 5\. 总结

通过本次实践，我们不仅实现了经典的扫雷游戏，还学习了如何设计和实现一个简单的游戏。在实现过程中，我们使用了数组、函数、随机数生成等C语言知识，同时也体会到了模块化编程的好处。希望这篇文章能帮助你更好地理解扫雷游戏的实现过程，激发你对编程的兴趣。



