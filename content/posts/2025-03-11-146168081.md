---
layout: post
title: "Redis-哨兵模式详解实现高可用与自动故障转移"
date: 2025-03-11 02:42:30 +0800
description: "Redis 哨兵模式是一种高可用性解决方案，通过部署多个哨兵节点来监控 Redis 主从节点的状态，并在主节点故障时自动进行故障转移。Redis 哨兵模式是一种高效、可靠的高可用性解决方案，适用于需要自动故障转移和读写分离的场景。"
keywords: "Redis 哨兵模式详解：实现高可用与自动故障转移"
categories: ['未分类']
tags: ['缓存', '数据库', 'Redis']
artid: "146168081"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146168081
    alt: "Redis-哨兵模式详解实现高可用与自动故障转移"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146168081
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146168081
cover: https://bing.ee123.net/img/rand?artid=146168081
image: https://bing.ee123.net/img/rand?artid=146168081
img: https://bing.ee123.net/img/rand?artid=146168081
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis 哨兵模式详解：实现高可用与自动故障转移
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="%E5%BC%95%E8%A8%80" name="%E5%BC%95%E8%A8%80">
     引言
    </h3>
    <p>
     在现代分布式系统中，
     <strong>
      高可用性
     </strong>
     是一个至关重要的需求。Redis 作为一个高性能的内存数据库，提供了
     <strong>
      哨兵模式（Sentinel Mode）
     </strong>
     ，用于实现 Redis 的高可用性和自动故障转移。通过哨兵模式，Redis 可以在主节点故障时自动将从节点提升为新的主节点，从而保证系统的持续运行。
    </p>
    <hr/>
    <h3 id="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9F" name="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9F">
     1. 什么是 Redis 哨兵模式？
    </h3>
    <h4 id="1.1%20%E5%AE%9A%E4%B9%89" name="1.1%20%E5%AE%9A%E4%B9%89">
     1.1 定义
    </h4>
    <p>
     Redis 哨兵模式是一种高可用性解决方案，通过部署多个哨兵节点来监控 Redis 主从节点的状态，并在主节点故障时自动进行故障转移。
    </p>
    <h4 id="1.2%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" name="1.2%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">
     1.2 核心概念
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        主节点（Master）
       </strong>
       ：负责处理写操作，并将数据同步到从节点。
      </p>
     </li>
     <li>
      <p>
       <strong>
        从节点（Slave）
       </strong>
       ：复制主节点的数据，并提供读操作。
      </p>
     </li>
     <li>
      <p>
       <strong>
        哨兵节点（Sentinel）
       </strong>
       ：监控 Redis 节点的状态，并在主节点故障时进行故障转移。
      </p>
     </li>
    </ul>
    <hr/>
    <h3 id="2.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" name="2.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">
     2. Redis 哨兵模式的工作原理
    </h3>
    <p>
     主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。 谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是
     <strong>
      哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例
     </strong>
    </p>
    <h4 id="2.1%20%E7%9B%91%E6%8E%A7" name="2.1%20%E7%9B%91%E6%8E%A7">
     2.1 监控
    </h4>
    <p>
     哨兵节点会定期向 Redis 主从节点发送心跳检测，以监控它们的状态。
    </p>
    <h4 id="2.2%20%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B" name="2.2%20%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B">
     2.2 故障检测
    </h4>
    <p>
     如果哨兵节点检测到主节点不可用，它会通知其他哨兵节点进行确认。
    </p>
    <h4 id="2.3%20%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB" name="2.3%20%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">
     2.3 故障转移
    </h4>
    <p>
     当多数哨兵节点确认主节点故障后，哨兵节点会选举一个从节点作为新的主节点，并更新其他从节点的配置。
    </p>
    <h4 id="2.4%20%E9%80%9A%E7%9F%A5" name="2.4%20%E9%80%9A%E7%9F%A5">
     2.4 通知
    </h4>
    <p>
     哨兵节点会通知客户端新的主节点地址，客户端可以重新连接到新的主节点。
    </p>
    <p>
     <img alt="" height="1009" src="https://i-blog.csdnimg.cn/direct/5ac6717945f54fc29f2dcace84af9f92.png" width="1252"/>
    </p>
    <p>
     这里的哨兵有两个作用：
    </p>
    <p>
     1.通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
    </p>
    <p>
     2.当哨兵监测到master宕机，会自动将slave切换成master，然后通过
     <strong>
      发布订阅模式
     </strong>
     通知其他的从服务器，修改配置文件，让它们切换主机。
    </p>
    <p>
     然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
    </p>
    <p>
     <img alt="" height="721" src="https://i-blog.csdnimg.cn/direct/2ab45cff6de54918af11c80feb373383.png" width="1402"/>
    </p>
    <p>
     假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认 为主服务器不可用，这个现象成为
     <strong>
      主观下线
     </strong>
     。当后面的哨兵也检测到主服务器不可用，并且数量达到一 定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为
     <strong>
      客观下线。
     </strong>
    </p>
    <h3 id="3.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95" name="3.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">
     3. Redis 哨兵模式的配置方法
    </h3>
    <h4 id="3.1%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" name="3.1%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">
     3.1 配置文件
    </h4>
    <p>
     每个哨兵节点需要一个配置文件，通常命名为
     <code>
      sentinel.conf
     </code>
     。以下是一个简单的哨兵配置文件示例：
    </p>
    <blockquote>
     <p>
      # sentinel.conf
      <br/>
      port 26379
      <br/>
      sentinel monitor mymaster 127.0.0.1 6379 2
      <br/>
      sentinel down-after-milliseconds mymaster 5000
      <br/>
      sentinel failover-timeout mymaster 10000
      <br/>
      sentinel parallel-syncs mymaster 1
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       <strong>
        port
       </strong>
       ：哨兵节点的端口号。
      </p>
     </li>
     <li>
      <p>
       <strong>
        sentinel monitor
       </strong>
       ：监控的主节点名称、IP 地址、端口号和法定人数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        sentinel down-after-milliseconds
       </strong>
       ：主节点不可用的超时时间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        sentinel failover-timeout
       </strong>
       ：故障转移的超时时间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        sentinel parallel-syncs
       </strong>
       ：故障转移时并行同步的从节点数量。
      </p>
     </li>
    </ul>
    <h4 id="3.2%20%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9" name="3.2%20%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9">
     3.2 启动哨兵节点
    </h4>
    <p>
     启动哨兵节点的命令如下：
    </p>
    <blockquote>
     <p>
      redis-sentinel /path/to/sentinel.conf
     </p>
    </blockquote>
    <hr/>
    <h3 id="4.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" name="4.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">
     4. Redis 哨兵模式的使用场景
    </h3>
    <h4 id="4.1%20%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" name="4.1%20%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7">
     4.1 高可用性
    </h4>
    <p>
     通过哨兵模式，Redis 可以在主节点故障时自动进行故障转移，从而保证系统的高可用性。
    </p>
    <h4 id="4.2%20%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB" name="4.2%20%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">
     4.2 自动故障转移
    </h4>
    <p>
     哨兵模式可以自动检测主节点故障并进行故障转移，减少人工干预。
    </p>
    <h4 id="4.3%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" name="4.3%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">
     4.3 读写分离
    </h4>
    <p>
     通过哨兵模式，可以将读操作分发到从节点，从而分担主节点的负载。
    </p>
    <hr/>
    <h3 id="5.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" name="5.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">
     5. Redis 哨兵模式的优缺点
    </h3>
    <h4 id="5.1%20%E4%BC%98%E7%82%B9" name="5.1%20%E4%BC%98%E7%82%B9">
     5.1 优点
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        高可用性
       </strong>
       ：通过自动故障转移实现高可用性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自动故障检测
       </strong>
       ：自动检测主节点故障并进行故障转移。
      </p>
     </li>
     <li>
      <p>
       <strong>
        读写分离
       </strong>
       ：支持读写分离，分担主节点的负载。
      </p>
     </li>
    </ul>
    <h4 id="5.2%20%E7%BC%BA%E7%82%B9" name="5.2%20%E7%BC%BA%E7%82%B9">
     5.2 缺点
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        配置复杂
       </strong>
       ：哨兵模式的配置相对复杂，需要部署多个哨兵节点。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据丢失
       </strong>
       ：在主节点故障时，可能会丢失部分未同步的数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        性能开销
       </strong>
       ：哨兵节点会定期监控 Redis 节点的状态，增加一定的性能开销。
      </p>
     </li>
    </ul>
    <hr/>
    <h3 id="6.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B" name="6.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">
     6. Redis 哨兵模式的实际应用示例
    </h3>
    <h4 id="6.1%20%E9%85%8D%E7%BD%AE%20Redis%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6" name="6.1%20%E9%85%8D%E7%BD%AE%20Redis%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">
     6.1 配置 Redis 主从复制
    </h4>
    <p>
     首先，配置 Redis 主从复制。假设我们有一个主节点和两个从节点：
    </p>
    <h5 id="%E4%B8%BB%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE" name="%E4%B8%BB%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE">
     主节点配置
    </h5>
    <pre><code class="language-bash"># redis-master.conf
port 6379</code></pre>
    <h5 id="%E4%BB%8E%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE" name="%E4%BB%8E%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE">
     从节点配置
    </h5>
    <pre><code class="language-bash"># redis-slave1.conf
port 6380
replicaof 127.0.0.1 6379

# redis-slave2.conf
port 6381
replicaof 127.0.0.1 6379</code></pre>
    <p>
     启动主节点和从节点：
    </p>
    <pre><code class="language-bash">redis-server /path/to/redis-master.conf
redis-server /path/to/redis-slave1.conf
redis-server /path/to/redis-slave2.conf</code></pre>
    <h4 id="6.2%20%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9" name="6.2%20%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9">
     6.2 配置哨兵节点
    </h4>
    <p>
     接下来，配置三个哨兵节点：
    </p>
    <h5 id="%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%201%20%E9%85%8D%E7%BD%AE" name="%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%201%20%E9%85%8D%E7%BD%AE">
     哨兵节点 1 配置
    </h5>
    <pre><code class="language-bash"># sentinel1.conf
port 26379
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1</code></pre>
    <h5 id="%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%202%20%E9%85%8D%E7%BD%AE" name="%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%202%20%E9%85%8D%E7%BD%AE">
     哨兵节点 2 配置
    </h5>
    <pre><code class="language-bash"># sentinel2.conf
port 26380
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1</code></pre>
    <h5 id="%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%203%20%E9%85%8D%E7%BD%AE" name="%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%203%20%E9%85%8D%E7%BD%AE">
     哨兵节点 3 配置
    </h5>
    <pre><code class="language-bash"># sentinel3.conf
port 26381
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1</code></pre>
    <p>
     启动哨兵节点：
    </p>
    <pre><code class="language-bash">redis-sentinel /path/to/sentinel1.conf
redis-sentinel /path/to/sentinel2.conf
redis-sentinel /path/to/sentinel3.conf</code></pre>
    <h4 id="6.3%20%E6%A8%A1%E6%8B%9F%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB" name="6.3%20%E6%A8%A1%E6%8B%9F%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">
     6.3 模拟故障转移
    </h4>
    <p>
     手动停止主节点，观察哨兵节点是否能够自动进行故障转移：
    </p>
    <pre><code class="language-bash">redis-cli -p 6379 shutdown</code></pre>
    <p>
     查看哨兵日志，确认故障转移过程：
    </p>
    <pre><code class="language-bash">tail -f /path/to/sentinel1.log</code></pre>
    <p>
     问题：如果之前的master 重启回来，会不会双master 冲突？
    </p>
    <p>
     之前的回来只能做小弟了
    </p>
    <hr/>
    <h3 id="7.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" name="7.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">
     7. Redis 哨兵模式的常见问题
    </h3>
    <h4 id="7.1%20%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F" name="7.1%20%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F">
     7.1 哨兵节点数量
    </h4>
    <p>
     哨兵节点的数量应为奇数，以确保在故障检测和故障转移时能够达成多数共识。
    </p>
    <h4 id="7.2%20%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1" name="7.2%20%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">
     7.2 数据丢失
    </h4>
    <p>
     在主节点故障时，可能会丢失部分未同步的数据。可以通过配置
     <code>
      min-slaves-to-write
     </code>
     和
     <code>
      min-slaves-max-lag
     </code>
     参数来减少数据丢失的风险。
    </p>
    <h4 id="7.3%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E8%BF%9E" name="7.3%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E8%BF%9E">
     7.3 客户端重连
    </h4>
    <p>
     客户端需要支持哨兵模式，能够在主节点故障时重新连接到新的主节点。
    </p>
    <hr/>
    <h3 id="8.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88" name="8.%20Redis%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">
     8. Redis 哨兵模式的替代方案
    </h3>
    <p>
     虽然 Redis 哨兵模式功能强大，但在某些场景下可能需要更高级的功能或更简单的解决方案。以下是一些常见的替代方案：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        Redis Cluster
       </strong>
       ：提供分布式存储和自动分片功能，适合大规模数据存储场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Twemproxy
       </strong>
       ：一个轻量级的代理工具，用于实现 Redis 的高可用性和负载均衡。
      </p>
     </li>
    </ul>
    <hr/>
    <h3 id="%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E" name="%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">
     <strong>
      哨兵配置说明
     </strong>
    </h3>
    <pre><code class="language-bash"> # Example sentinel.conf
 # 哨兵sentinel实例运行的端口 默认26379
 port 26379
 # 哨兵sentinel的工作目录
dir /tmp
 # 哨兵sentinel监控的redis主节点的 ip port 
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。
# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了
# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;
 sentinel monitor mymaster 127.0.0.1 6379 2
# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都
要提供密码
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码
# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
 sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
 # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒
# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;
 sentinel down-after-milliseconds mymaster 30000
 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同
步，
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。
# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;
 sentinel parallel-syncs mymaster 1
 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： 
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的
master那里同步数据时。
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超
时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了
# 默认三分钟
# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;
 sentinel failover-timeout mymaster 180000
 # SCRIPTS EXECUTION
 #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮
件通知相关人员。
#对于脚本的运行结果有以下规则：
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执
行。
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等
等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常
运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果
sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执
行的，否则sentinel无法正常启动成功。
#通知脚本
# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;
 sentinel notification-script mymaster /var/redis/notify.sh
 # 客户端重新配置主节点参数脚本
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master
地址已经发生改变的信息。
# 以下参数将会在调用脚本时传给脚本:
 # &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;
 # 目前&lt;state&gt;总是“failover”,
 # &lt;role&gt;是“leader”或者“observer”中的一个。 
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的
slave)通信的
# 这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;
 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre>
    <hr/>
    <h3 id="9.%20%E6%80%BB%E7%BB%93" name="9.%20%E6%80%BB%E7%BB%93">
     9. 总结
    </h3>
    <p>
     Redis 哨兵模式是一种高效、可靠的高可用性解决方案，适用于需要自动故障转移和读写分离的场景。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f69736f6c7573696f6e2f:61727469636c652f64657461696c732f313436313638303831" class_="artid" style="display:none">
 </p>
</div>


