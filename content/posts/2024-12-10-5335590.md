---
layout: post
title: "-Python与C之间的相互调用Python-C-API及Python-ctypes库转"
date: 2024-12-10 15:07:35 +0800
description: "准备工作：闲话少说，看看Python C API。事实上，Python C API比起Lua的API"
keywords: "python的c语言扩展的api使用文档"
categories: ['未分类']
tags: ['String', 'Python', 'Methods', 'Import', 'C', 'Api']
artid: "5335590"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=5335590
  alt: "-Python与C之间的相互调用Python-C-API及Python-ctypes库转"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=5335590
featuredImagePreview: https://bing.ee123.net/img/rand?artid=5335590
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python与C之间的相互调用（Python C API及Python ctypes库）【转】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     准备工作：
    </h4>
    <p>
     闲话少说，看看Python C API。事实上，Python C API比起Lua的API了来说，清晰了很多，这也符合Pythonic的风格，就算这时Python C　API是设计给C语言使用者使用的，还是这样的风格，比起Lua API那种汇编式的接口，（据说为了效率，可以直接操作每个数据）强了太多了。
     <br/>
     要使用Python C API，用普通的二进制包是不行的，得下源码包。这里我用3.1.1的源码包为例：
     <a href="http://www.python.org/ftp/python/3.1.1/Python-3.1.1.tar.bz2" rel="nofollow" title="Grab the Source for the Python 3.1 Release">
      Source Distribution
     </a>
     <br/>
     Python的源码在Windows的版本中已经完全换到VS2008了，直接用VS2008打开在PCbuild目录下的工程即可，对于VS2005及 以前的用户打开PC目录下的其他版本工程。我们编译debug版本的pythoncore会得到 python31_d.lib,python31_d.dll两个文件，需要的头文件在Include目录下，还需要将pyconfig.h文件从 PCBuild目录下拷贝到Include中，（硬要直接指定也可以）这样准备工作就已经齐了。
     <br/>
     <br/>
     Python C API有两个方向的使用方式，从C中调用Python脚本及利用C扩展Python。
     <br/>
     先讲简单的从C中调用Python，也就是常说的在C中内嵌Python。
    </p>
    <h4>
     C中内嵌Python
    </h4>
    <p>
     新建立一个工程，首先需要将工作目录设置到Python-3.1.1PCbuild中，以获取到动态库，至于静态库的包含，Include目录的指 定，那自然也是少不了的。文件中需要包含Python.h文件，这也是必须的。
     <br/>
     接口中
     <br/>
     Py_Initialize();
     <br/>
     Py_Finalize();
     <br/>
     一对的调用是必须的，一个用于初始化Python的动态库，一个用于释放。释放时会输出[31818 refs]，意义不明。
     <span style="font-size: x-small;">
      <span style="font-family: 宋体;">
       <br/>
      </span>
     </span>
    </p>
    <p>
     <span style="font-size: x-small;">
      <span style="font-family: 宋体;">
       <span style="font-size: small;">
        PyRun_SimpleString
       </span>
      </span>
     </span>
    </p>
    <p style="font-family: Courier New;">
     <span style="font-size: small;">
      可用于 执行简单的Python语句。如下：
     </span>
    </p>
    <p style="font-family: Courier New;">
     <span style="font-family: monospace;">
      <br/>
      <span style="color: #a020f0;">
       #include
      </span>
      <span style="color: #ff00ff;">
       "python.h"
      </span>
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      main(
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      argc,
      <span style="color: #2e8b57;">
       <strong>
        char
       </strong>
      </span>
      * argv[])
      <br/>
      {
      <!-- -->
      <br/>
      Py_Initialize();
      <br/>
      <br/>
      PyRun_SimpleString(
      <span style="color: #ff00ff;">
       "print(
      </span>
      <span style="color: #6a5acd;">
       "
      </span>
      <span style="color: #ff00ff;">
       Hello World
      </span>
      <span style="color: #6a5acd;">
       "
      </span>
      <span style="color: #ff00ff;">
       )"
      </span>
      );
      <br/>
      Py_Finalize();
      <br/>
      <br/>
      system(
      <span style="color: #ff00ff;">
       "PAUSE"
      </span>
      );
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      <span style="color: #ff00ff;">
       0
      </span>
      ;
      <br/>
      }
     </span>
    </p>
    <p style="font-family: Courier New;">
    </p>
    <p style="font-family: Courier New;">
     <span style="font-family: monospace;">
      此时，输出为：
     </span>
    </p>
    <p style="font-family: Courier New;">
     Hello World
     <br/>
     [31829 refs]
     <br/>
     请按任意键继续. . .
    </p>
    <p style="font-family: Courier New;">
    </p>
    <p style="font-family: Courier New;">
     此时可以执行一些Python语句了，并且，特别需要注意的是，在一个 Py_Initialize();与Py_Finalize();之间，Python语句执行是在同一个执行环境中，不懂什么意思？看个示例就知道了。
    </p>
    <p style="font-family: Courier New;">
     <span style="font-family: monospace;">
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      main(
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      argc,
      <span style="color: #2e8b57;">
       <strong>
        char
       </strong>
      </span>
      * argv[])
      <br/>
      {
      <!-- -->
      <br/>
      Py_Initialize();
      <br/>
      <br/>
      PyRun_SimpleString(
      <span style="color: #ff00ff;">
       "str =
      </span>
      <span style="color: #6a5acd;">
       "
      </span>
      <span style="color: #ff00ff;">
       Hello World
      </span>
      <span style="color: #6a5acd;">
       "
      </span>
      <span style="color: #ff00ff;">
       "
      </span>
      );
      <br/>
      PyRun_SimpleString(
      <span style="color: #ff00ff;">
       "print(str)"
      </span>
      );
      <br/>
      <br/>
      Py_Finalize();
      <br/>
      <br/>
      system(
      <span style="color: #ff00ff;">
       "PAUSE"
      </span>
      );
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      <span style="color: #ff00ff;">
       0
      </span>
      ;
      <br/>
      }
      <br/>
     </span>
    </p>
    <p style="font-family: Courier New;">
     <span style="font-family: monospace;">
      此例与上例输出是一样的，懂我的意思了吧？意思就是以前执行的语句对后面的语句是有效的，相当于在同一个交互式命令行中顺序执行 语句。
     </span>
    </p>
    <h4 style="font-family: Courier New;">
     <span style="font-family: monospace;">
      获取返回值
      <br/>
     </span>
    </h4>
    <p style="font-family: Courier New;">
     <span style="font-family: monospace;">
      PyRun_SimpleString有的缺点，文档中的描述是：
     </span>
    </p>
    <p style="font-family: Courier New;">
     Returns
     <span class="pre">
      0
     </span>
     on success or
     <span class="pre">
      -1
     </span>
     if an exception was raised.
    </p>
    <p style="font-family: Courier New;">
     那么你就无法在Python及C语言中传递任何信息。我们需要高级点的函数 才行。
    </p>
    <p>
     PyObject* PyRun_String(const char *str, int start, PyObject *globals, PyObject *locals)
     <br/>
     就是干这个的。
     <br/>
     但是需要注意的是此函数的一些参数的获取，按照想当然的给他们置空可是不行的，如下例所示：
     <br/>
     <span style="font-family: monospace;">
      <br/>
      <span style="color: #a020f0;">
       #include
      </span>
      <span style="color: #ff00ff;">
       "python.h"
      </span>
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      main(
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      argc,
      <span style="color: #2e8b57;">
       <strong>
        char
       </strong>
      </span>
      * argv[])
      <br/>
      {
      <!-- -->
      <br/>
      Py_Initialize();
      <br/>
      <br/>
      PyRun_SimpleString(
      <span style="color: #ff00ff;">
       "x = 10"
      </span>
      );
      <br/>
      PyRun_SimpleString(
      <span style="color: #ff00ff;">
       "y = 20"
      </span>
      );
      <br/>
      PyObject* mainModule = PyImport_ImportModule(
      <span style="color: #ff00ff;">
       "__main__"
      </span>
      );
      <br/>
      PyObject* dict = PyModule_GetDict(mainModule);
      <br/>
      PyObject* resultObject = PyRun_String(
      <span style="color: #ff00ff;">
       "x + y"
      </span>
      , Py_eval_input, dict, dict);
      <br/>
      <br/>
      <span style="color: #804040;">
       <strong>
        if
       </strong>
      </span>
      (resultObject)
      <br/>
      {
      <!-- -->
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        long
       </strong>
      </span>
      result = PyLong_AsLong(resultObject);
      <br/>
      printf(
      <span style="color: #ff00ff;">
       "
      </span>
      <span style="color: #6a5acd;">
       %d
      </span>
      <span style="color: #ff00ff;">
       "
      </span>
      , result);
      <br/>
      Py_DECREF(resultObject);
      <br/>
      }
      <br/>
      <br/>
      Py_Finalize();
      <br/>
      <br/>
      system(
      <span style="color: #ff00ff;">
       "PAUSE"
      </span>
      );
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      <span style="color: #ff00ff;">
       0
      </span>
      ;
      <br/>
      }
      <br/>
      这里我利用了一个知识，那就是
     </span>
     <span style="font-family: monospace;">
      PyRun_SimpleString实际是将所有的代码都放在
     </span>
     <span style="font-family: monospace;">
      <span style="color: #ff00ff;">
       __main__
      </span>
     </span>
     模块中运行，注意啊，没有导入正确的模块及其dict，你会运行失败，失败的很惨。至此，C语言已经于Python来了个交互了。
     <br/>
     呵呵，突然觉得深入下去就没有尽头了。。。。。。。还是点到为止吧。
     <br/>
     稍微深入点的可以去看《Programming Python》一书。在
     <a href="http://wiki.woodpecker.org.cn/moin/PP3eD#Chapter_23._Embedding_Python_.2BUYVdTA-Python" id="x2s-" rel="nofollow" title="啄木鸟">
      啄木鸟
     </a>
     上有此书及一些译文。Part VI: Integration 部分Chapter 23. Embedding Python，有相关的知识。
    </p>
    <h4>
     利用C扩展Python
    </h4>
    <p>
     此部分在《Programming Python》的Chapter 22. Extending Python 部分有介绍。
     <br/>
     这里也只能开个头了，最多告诉你，其实，这些都没有什么难的。稍微复杂点的情况《
     <span style="font-size: small;">
      <a href="http://blog.csdn.net/vagrxie/archive/2009/01/15/3779247.aspx" rel="noopener noreferrer" target="_blank">
       <span style="color: #c60a00;">
        python
       </span>
       <span style="color: #c60a00;">
        c
       </span>
       <span style="color: #c60a00;">
        api
       </span>
       使用心得...
      </a>
     </span>
     》一文中有介绍。
     <br/>
     配置上与前面讲的类似，一般来说，利用C扩展Python最后会生成一个动态库，不过这个动态库的后缀会设为.pyd，只有这样，import的时候才会 自动的查询到。
     <br/>
     另外，为Python写扩展要遵循Python的那套规则，固定的几个命名。
     <br/>
     首先看自带的例子：
     <br/>
     <span style="font-family: monospace;">
      <br/>
      <span style="color: #a020f0;">
       #include
      </span>
      <span style="color: #ff00ff;">
       "Python.h"
      </span>
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      PyObject *
      <br/>
      ex_foo(PyObject *self, PyObject *args)
      <br/>
      {
      <!-- -->
      <br/>
      printf(
      <span style="color: #ff00ff;">
       "Hello, world
      </span>
      <span style="color: #6a5acd;">
       n
      </span>
      <span style="color: #ff00ff;">
       "
      </span>
      );
      <br/>
      Py_INCREF(Py_None);
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      Py_None;
      <br/>
      }
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      PyMethodDef example_methods[] = {
      <!-- -->
      <br/>
      {
      <!-- -->
      <span style="color: #ff00ff;">
       "foo"
      </span>
      , ex_foo, METH_VARARGS,
      <span style="color: #ff00ff;">
       "foo() doc string"
      </span>
      },
      <br/>
      {
      <!-- -->
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <span style="color: #ff00ff;">
       NULL
      </span>
      }
      <br/>
      };
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      <span style="color: #2e8b57;">
       <strong>
        struct
       </strong>
      </span>
      PyModuleDef examplemodule = {
      <!-- -->
      <br/>
      PyModuleDef_HEAD_INIT,
      <br/>
      <span style="color: #ff00ff;">
       "example"
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       "example module doc string"
      </span>
      ,
      <br/>
      -
      <span style="color: #ff00ff;">
       1
      </span>
      ,
      <br/>
      example_methods,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      <br/>
      };
      <br/>
      <br/>
      PyMODINIT_FUNC
      <br/>
      PyInit_example(
      <span style="color: #2e8b57;">
       <strong>
        void
       </strong>
      </span>
      )
      <br/>
      {
      <!-- -->
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      PyModule_Create(&amp;examplemodule);
      <br/>
      }
      <br/>
     </span>
     这个例子包含了全部C语言为Python写扩展时的基本信息：
     <br/>
     1.
     <span style="font-family: monospace;">
      PyInit_example是最后的出口，其中需要注意的是 example不仅仅代表example的意思，还代表了最后生成的库会用example命名，也就是你调用此库会需要使用
      <br/>
      import example
     </span>
     <br/>
     的形式。
     <br/>
     2.
     <span style="font-family: monospace;">
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      <span style="color: #2e8b57;">
       <strong>
        struct
       </strong>
      </span>
      PyModuleDef examplemodule的存在也是必须的，指定了整个模块的信息，比如上面
     </span>
     的"example module doc string"，
     <span style="font-family: monospace;">
      模块的说明文字。每个参数的含义上面已经有些演示了。
     </span>
     全部内容可以参考文档中关于PyModuleDef的说明
     <br/>
     3.
     <span style="font-family: monospace;">
      example_methods是一个函数列表，事实上表示此模块中 含有的函数。此例中仅含有
     </span>
     foo一个函数。
     <br/>
     <span style="font-family: monospace;">
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      PyObject *
      <br/>
      ex_foo(PyObject *self, PyObject *args)
      <br/>
      {
      <!-- -->
      <br/>
      printf(
      <span style="color: #ff00ff;">
       "Hello, world
      </span>
      <span style="color: #6a5acd;">
       n
      </span>
      <span style="color: #ff00ff;">
       "
      </span>
      );
      <br/>
      Py_INCREF(Py_None);
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      Py_None;
      <br/>
      }
     </span>
     <br/>
     <span style="font-family: monospace;">
      就是整个函数的具体实现了，此函数表示输出"Hello, world"，还是hello world。。。。。。。。这个world还真忙啊。。。。天天有人say hello。
      <br/>
      <br/>
      这个Python本身附带的例子有点太简单了，我给出一个稍微复杂点的例子，还是我最喜欢的MessageBox,最后的效果自然还是Hello world。。。。。。。。。。。
      <br/>
      <br/>
      <span style="color: #a020f0;">
       #include
      </span>
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      PyObject *
      <br/>
      MessageBox(PyObject *self, PyObject *args)
      <br/>
      {
      <!-- -->
      <br/>
      LPCSTR lpText;
      <br/>
      LPCSTR lpCaption;
      <br/>
      UINT uType;
      <br/>
      <br/>
      PyArg_ParseTuple(args,
      <span style="color: #ff00ff;">
       "ssi"
      </span>
      , &amp;lpText, &amp;lpCaption, &amp;uType);
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        int
       </strong>
      </span>
      result = MessageBoxA(
      <span style="color: #ff00ff;">
       0
      </span>
      , lpText, lpCaption, uType);
      <br/>
      <br/>
      PyObject* resultObject = Py_BuildValue(
      <span style="color: #ff00ff;">
       "
      </span>
      <span style="color: #6a5acd;">
       %i
      </span>
      <span style="color: #ff00ff;">
       "
      </span>
      , result);
      <br/>
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      resultObject;
      <br/>
      }
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      PyMethodDef c_methods[] = {
      <!-- -->
      <br/>
      {
      <!-- -->
      <span style="color: #ff00ff;">
       "MessageBox"
      </span>
      , MessageBox, METH_VARARGS,
      <span style="color: #ff00ff;">
       "MessageBox() "
      </span>
      },
      <br/>
      {
      <!-- -->
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <span style="color: #ff00ff;">
       NULL
      </span>
      }
      <br/>
      };
      <br/>
      <br/>
      <span style="color: #2e8b57;">
       <strong>
        static
       </strong>
      </span>
      <span style="color: #2e8b57;">
       <strong>
        struct
       </strong>
      </span>
      PyModuleDef win32module = {
      <!-- -->
      <br/>
      PyModuleDef_HEAD_INIT,
      <br/>
      <span style="color: #ff00ff;">
       "Win32API"
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       "Win32 API MessageBox"
      </span>
      ,
      <br/>
      -
      <span style="color: #ff00ff;">
       1
      </span>
      ,
      <br/>
      c_methods,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      ,
      <br/>
      <span style="color: #ff00ff;">
       NULL
      </span>
      <br/>
      };
      <br/>
      <br/>
      PyMODINIT_FUNC
      <br/>
      PyInit_Win32API(
      <span style="color: #2e8b57;">
       <strong>
        void
       </strong>
      </span>
      )
      <br/>
      {
      <!-- -->
      <br/>
      <span style="color: #804040;">
       <strong>
        return
       </strong>
      </span>
      PyModule_Create(&amp;win32module);
      <br/>
      }
      <br/>
     </span>
     <br/>
     需要注意的还是需要注意，唯一有点区别的是这里我有从Python中传进来的参数及从C中传出去的返回值了。
     <br/>
     <span style="font-family: monospace;">
      PyArg_ParseTuple
     </span>
     用于解析参数
     <br/>
     <span style="font-family: monospace;">
      Py_BuildValue 用于构建一个Python的值返回
      <br/>
      他们的构建和解析形式有点类似于sprintf等C常见的形式，可是每个字符代表的东西不一定一样，需要注意，文档中比较详细，此例中展示的是 String及int的转换。
      <br/>
      <br/>
      以生成动态库的方式编译此文件后，并指定为Win32API.pyd文件，然后将其拷贝到Python_d所在的目录（用Python3.1.1源代码生 成的调试版本Python），此时import会首先查找*_d.pyd形式的动态库，不然只会搜索release版。
      <br/>
      首先看看库的信息：
      <br/>
     </span>
     &gt;&gt;&gt; import Win32API
     <br/>
     [44692 refs]
     <br/>
     &gt;&gt;&gt; dir(Win32API)
     <br/>
     ['MessageBox', '__doc__', '__file__', '__name__', '__package__']
     <br/>
     [44705 refs]
     <br/>
     &gt;&gt;&gt; help(Win32API)
     <br/>
     Help on module Win32API:
     <br/>
     <br/>
     NAME
     <br/>
     Win32API - Win32 API MessageBox
     <br/>
     <br/>
     FILE
     <br/>
     d:python-3.1.1pcbuildwin32api_d.pyd
     <br/>
     <br/>
     FUNCTIONS
     <br/>
     MessageBox(...)
     <br/>
     MessageBox()
     <br/>
     <br/>
     <br/>
     [68311 refs]
     <br/>
     注意到文档的作用了吧？还注意到dir的强大。。。。。。。。。。。。。此时MessageBox已经在Win32API中了，直接调用吧。我这里忽略了 窗口的句柄，需要注意。
    </p>
    <div id="x7w3" style="text-align: left;">
     <img alt="" src="http://docs.google.com/File?id=dhn3dw87_46f7s3j4x8_b" style="width: 565px; height: 103px;">
     </img>
    </div>
    <p>
     多么繁忙的World啊。。。。。。。。
     <br/>
     此时你会想，太强大了，我要将整个的Win32 API到处，于是Python就能像C/C++语言一样完全操作整个操作系统了，并且，这还是动态的！！！！
     <br/>
     没错，不过多大的工作量啊。。。。。。不过，Python这么流行，总是有人做这样的事情的，于是PyWindows出世了。去安装一个，于是你什么都有 了。
     <br/>
     &gt;&gt;&gt; import win32api
     <br/>
     &gt;&gt;&gt; win32api.MessageBox(0, "Great", "Hello World", 0)
     <br/>
     1
     <br/>
     这样，就能达到上面全部的效果。。。。。。。。。。。
    </p>
    <div id="zso2" style="text-align: left;">
     <img alt="" src="http://docs.google.com/File?id=dhn3dw87_47fdxnq7dm_b" style="width: 565px; height: 106px;">
     </img>
    </div>
    <p>
    </p>
    <h3>
     Python ctypes
    </h3>
    <p>
     如此这般，原来Python还是离不开C啊（虽然Python本身使用C写的）。。。，直到。。。。某年某月ctypes横空出世了，于是，完全不 懂C语言的人，也可以直接用Python来完成这样的工作了。毫无疑问，Python越来越自成体系了，他们的目标是，没有其他语言！-_-!在 Python v3.1.1的文档中如此描述，
     <br/>
     <span class="pre">
      ctypes
     </span>
     — A foreign function library for Python
     <br/>
     然后：It can be used to wrap these libraries in pure Python.
     <br/>
     注意，他们要的是Pure Python！（我不是想要挑起语言战争。。。。。）
     <br/>
     Guido van Rossum开始说，wrap these,in pure Python。。。。不要再用foreign语言，血统不pure的家伙了。
     <br/>
     <br/>
     <br/>
     闲话少说，看看ctypes，因为是pure Python嘛，所以看起来很简单，事实上文档也比较详细（当然，还是遗漏了一些细节），下面都以Windows中的Python3.1.1的操作为例：
     <br/>
     &gt;&gt;&gt; import ctypes
     <br/>
     &gt;&gt;&gt; from ctypes import *
     <br/>
     &gt;&gt;&gt; dir(ctypes)
     <br/>
     ['ARRAY', 'ArgumentError', 'Array', 'BigEndianStructure', 'CDLL', 'CFUNCTYPE', '
     <br/>
     DEFAULT_MODE', 'DllCanUnloadNow', 'DllGetClassObject', 'FormatError', 'GetLastEr
     <br/>
     ror', 'HRESULT', 'LibraryLoader', 'LittleEndianStructure', 'OleDLL', 'POINTER',
     <br/>
     'PYFUNCTYPE', 'PyDLL', 'RTLD_GLOBAL', 'RTLD_LOCAL', 'SetPointerType', 'Structure
     <br/>
     ', 'Union', 'WINFUNCTYPE', 'WinDLL', 'WinError', '_CFuncPtr', '_FUNCFLAG_CDECL',
     <br/>
     '_FUNCFLAG_PYTHONAPI', '_FUNCFLAG_STDCALL', '_FUNCFLAG_USE_ERRNO', '_FUNCFLAG_U
     <br/>
     SE_LASTERROR', '_Pointer', '_SimpleCData', '__builtins__', '__doc__', '__file__'
     <br/>
     , '__name__', '__package__', '__path__', '__version__', '_c_functype_cache', '_c
     <br/>
     alcsize', '_cast', '_cast_addr', '_check_HRESULT', '_check_size', '_ctypes_versi
     <br/>
     on', '_dlopen', '_endian', '_memmove_addr', '_memset_addr', '_os', '_pointer_typ
     <br/>
     e_cache', '_string_at', '_string_at_addr', '_sys', '_win_functype_cache', '_wstr
     <br/>
     ing_at', '_wstring_at_addr', 'addressof', 'alignment', 'byref', 'c_bool', 'c_buf
     <br/>
     fer', 'c_byte', 'c_char', 'c_char_p', 'c_double', 'c_float', 'c_int', 'c_int16',
     <br/>
     'c_int32', 'c_int64', 'c_int8', 'c_long', 'c_longdouble', 'c_longlong', 'c_shor
     <br/>
     t', 'c_size_t', 'c_ubyte', 'c_uint', 'c_uint16', 'c_uint32', 'c_uint64', 'c_uint
     <br/>
     8', 'c_ulong', 'c_ulonglong', 'c_ushort', 'c_void_p', 'c_voidp', 'c_wchar', 'c_w
     <br/>
     char_p', 'cast', 'cdll', 'create_string_buffer', 'create_unicode_buffer', 'get_e
     <br/>
     rrno', 'get_last_error', 'memmove', 'memset', 'oledll', 'pointer', 'py_object',
     <br/>
     'pydll', 'pythonapi', 'resize', 'set_conversion_mode', 'set_errno', 'set_last_er
     <br/>
     ror', 'sizeof', 'string_at', 'windll', 'wstring_at']
     <br/>
     <br/>
     一个这样的小玩意儿包含的东西还真不少啊，可以看到主要包括一些C语言的类型定义。
     <br/>
     当你import ctypes的时候，一些动态库已经载入了：
     <br/>
     &gt;&gt;&gt; print(windll.kernel32)
     <br/>
     <br/>
     &gt;&gt;&gt; print(windll.user32)
     <br/>
     <br/>
     &gt;&gt;&gt; print(windll.msvcrt)
     <br/>
     <br/>
     <br/>
     直接来使用试试吧，我们最喜欢的自然是Hello World。这里直接调用MessageBox。查查MSDN，MessageBox在User32中，我们调用它。
     <br/>
     &gt;&gt;&gt; MessageBox = windll.user32.MessageBoxW
     <br/>
     &gt;&gt;&gt; MessageBox(0,"Great","Hello World", 0)
     <br/>
     然后，就调用了MessageBox了。。。。。。。。
    </p>
    <div id="s1mk" style="text-align: left;">
     <img alt="" src="http://docs.google.com/File?id=dhn3dw87_44cmn6c2db_b" style="width: 481px; height: 111px;">
     </img>
    </div>
    <p>
     怎么？晕了？比较一下ctypes库及Python C API吧。。。。于是，K&amp;R哭了。。。。。。。。。。。。。
     <br/>
     故事以下图开始
    </p>
    <div id="eryw" style="text-align: left;">
     <img alt="" src="http://docs.google.com/File?id=dhn3dw87_48d28vfdhk_b" style="width: 435px; height: 231px;">
     </img>
    </div>
    <p>
     以下图结束：
    </p>
    <div id="qpsr" style="text-align: left;">
     <img alt="" src="http://docs.google.com/File?id=dhn3dw87_49hf4wzzht_b" style="width: 550px; height: 306px;">
     </img>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f66616365766f69:642f61727469636c652f64657461696c732f35333335353930" class_="artid" style="display:none">
 </p>
</div>
