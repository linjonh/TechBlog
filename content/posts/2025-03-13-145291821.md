---
layout: post
title: "实战篇执行计划解析"
date: 2025-03-13 17:21:45 +0800
description: "数据库优化器可能会根据连接方式、连接条件等因素选择不同的执行计划。你可以通过EXPLAIN关键字查看两个查询的执行计划，以便更好地理解优化器的选择。观察执行计划并查看其中的关键信息，这可以帮助你理解查询优化器是如何选择执行计划的，从而找到可能导致性能差异的原因。"
keywords: "【实战篇】执行计划解析"
categories: ['Mysql']
tags: ['数据库', 'Mysql']
artid: "145291821"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145291821
    alt: "实战篇执行计划解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145291821
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145291821
cover: https://bing.ee123.net/img/rand?artid=145291821
image: https://bing.ee123.net/img/rand?artid=145291821
img: https://bing.ee123.net/img/rand?artid=145291821
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【实战篇】执行计划解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     执行计划解析
    </h2>
    <h3>
     <a id="_2">
     </a>
     获取执行计划
    </h3>
    <p>
     数据库优化器可能会根据连接方式、连接条件等因素选择不同的执行计划。你可以通过
     <code>
      EXPLAIN
     </code>
     关键字查看两个查询的执行计划，以便更好地理解优化器的选择。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">-- 替换 ... 部分为你的查询内容</span>
</code></pre>
    <p>
     观察执行计划并查看其中的关键信息，这可以帮助你理解查询优化器是如何选择执行计划的，从而找到可能导致性能差异的原因。
    </p>
    <h3>
     <a id="_15">
     </a>
     内容含义
    </h3>
    <p>
     执行计划是数据库优化器生成的一种表示查询执行方式的输出。它提供了关于查询如何执行的详细信息，包括表的访问顺序、使用的索引、连接方式等。
    </p>
    <p>
     执行计划的输出可能会因数据库管理系统而异，下面是一些通用的解释：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        ID：
       </strong>
       序号，每个操作的唯一标识符，通常从 1 开始递增。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Select Type：
       </strong>
       表示查询的类型，包括
       <code>
        SIMPLE
       </code>
       （简单查询）、
       <code>
        PRIMARY
       </code>
       （主查询）、
       <code>
        SUBQUERY
       </code>
       （子查询）等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Table：
       </strong>
       表名，操作涉及的表。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Type：
       </strong>
       访问表的方式，包括
       <code>
        ALL
       </code>
       （全表扫描）、
       <code>
        INDEX
       </code>
       （索引扫描）、
       <code>
        range
       </code>
       （范围扫描）等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Possible Keys：
       </strong>
       可能用于执行查询的索引。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Key：
       </strong>
       实际用于执行查询的索引。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Key Length：
       </strong>
       索引的长度。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Ref：
       </strong>
       显示连接的列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Rows：
       </strong>
       预计需要检查的行数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        filtered：
       </strong>
       表示经过表扫描或索引扫描后，通过过滤条件的行的百分比。具体来说，它表示在执行计划的某个步骤中，有多少行满足查询的 WHERE 子句或其他过滤条件。
       <code>
        filtered
       </code>
       列的值范围是 0 到 100，表示过滤条件满足的行的百分比。以下是一些可能的情况：
      </p>
      <ul>
       <li>
        如果
        <code>
         filtered
        </code>
        为 100%，表示所有经过扫描的行都满足过滤条件。
       </li>
       <li>
        如果
        <code>
         filtered
        </code>
        为 0%，表示没有一行满足过滤条件。
       </li>
       <li>
        如果
        <code>
         filtered
        </code>
        介于 0% 和 100% 之间，表示部分行满足过滤条件。
       </li>
      </ul>
      <p>
       这个值的大小可以帮助开发人员分析查询性能。如果
       <code>
        filtered
       </code>
       较低，可能意味着过滤条件不够严格，导致了更多的行需要被检查。反之，如果
       <code>
        filtered
       </code>
       较高，则说明过滤条件较为有效，减少了不必要的行扫描，提高了查询性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Extra：
       </strong>
       其他信息，可能包括文件排序、临时表等。
      </p>
     </li>
    </ol>
    <blockquote>
     <p>
      通过观察执行计划的输出，你可以了解查询是如何执行的，哪些步骤可能导致性能问题。
     </p>
     <p>
      以下是一些常见的优化提示：
     </p>
    </blockquote>
    <ul>
     <li>
      <strong>
       使用索引：
      </strong>
      确保查询中的条件列上有索引。
     </li>
     <li>
      <strong>
       避免全表扫描：
      </strong>
      尽量避免
      <code>
       ALL
      </code>
      类型的访问，特别是对大表的情况。
     </li>
     <li>
      <strong>
       合理使用连接：
      </strong>
      确保连接条件足够明确，选择合适的连接类型。
     </li>
     <li>
      <strong>
       考虑分区表：
      </strong>
      对于大表，使用分区表可以提高查询性能。
     </li>
     <li>
      <strong>
       注意临时表和文件排序：
      </strong>
      如果看到
      <code>
       Using temporary
      </code>
      或
      <code>
       Using filesort
      </code>
      ，可能需要考虑索引或调整查询。
     </li>
    </ul>
    <h3>
     <a id="_61">
     </a>
     访问表的方式
    </h3>
    <p>
     以下是几种常见的访问表的方式：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        ALL
       </strong>
       :
      </p>
      <ul>
       <li>
        全表扫描，效率最低。所有行都被读取来找到匹配的行。
       </li>
       <li>
        通常出现是因为缺少合适的索引。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        index
       </strong>
       :
      </p>
      <ul>
       <li>
        全索引扫描，类似于全表扫描，但扫描的是索引树而不是数据行。
       </li>
       <li>
        比全表扫描更快，因为索引树的大小通常比数据行小。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        range
       </strong>
       :
      </p>
      <ul>
       <li>
        范围扫描，通过索引查找位于指定范围内的行。
       </li>
       <li>
        适用于范围条件查询，比如
        <code>
         BETWEEN
        </code>
        ,
        <code>
         &lt;
        </code>
        ,
        <code>
         &gt;
        </code>
        ,
        <code>
         &lt;=
        </code>
        ,
        <code>
         &gt;=
        </code>
        等。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        ref
       </strong>
       :
      </p>
      <ul>
       <li>
        非唯一索引扫描，返回所有匹配某一单个值的行。
       </li>
       <li>
        常见于非唯一索引和前缀索引的查询。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        eq_ref
       </strong>
       :
      </p>
      <ul>
       <li>
        <p>
         唯一索引扫描，返回最多一条匹配的行。
        </p>
       </li>
       <li>
        <p>
         通常用于主键或唯一索引查询。
        </p>
       </li>
       <li>
        <p>
         在执行计划中，
         <code>
          eq_ref
         </code>
         是一种连接方式，表示
         <strong>
          等值连接
         </strong>
         。具体来说，
         <code>
          eq_ref
         </code>
         是指
         <strong>
          使用索引
         </strong>
         查找关联表的唯一行。
        </p>
        <p>
         <img alt="image" src="https://i-blog.csdnimg.cn/img_convert/9c39785faecc0c4583faeffd0e119d11.webp?x-oss-process=image/format,png"/>
        </p>
        <blockquote>
         <p>
          一般情况下，
          <code>
           eq_ref
          </code>
          出现在连接条件中使用了【唯一或主键索引】，并且查询优化器能够确定被引用的表中的每个值只与另一表中的一个唯一值匹配。
         </p>
        </blockquote>
        <p>
         举例说明，假设有两张表 A 和 B，它们通过 A 表的主键或唯一键与 B 表关联。执行计划中的
         <code>
          eq_ref
         </code>
         表示对于 A 表的每一行，在 B 表中都只有一行与之匹配。
        </p>
        <pre><code class="prism language-sql"><span class="token comment">-- 示例表结构</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> A <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    <span class="token keyword">data</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> B <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    a_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    other_data <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>a_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> A<span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 查询</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> A
<span class="token keyword">JOIN</span> B <span class="token keyword">ON</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>a_id<span class="token punctuation">;</span>
</code></pre>
        <p>
         在上述查询中，如果使用了 A 表的主键或唯一键索引，那么连接操作的类型可能会显示为
         <code>
          eq_ref
         </code>
         。
        </p>
        <p>
         总的来说，
         <code>
          eq_ref
         </code>
         是一种高效的连接方式，因为它表示连接的列是唯一的，每行都只匹配一次。这通常是通过主键或唯一键来实现的。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        const
       </strong>
       :
      </p>
      <ul>
       <li>
        常量查询，当查询结果最多有一条匹配的行，并且优化器能够将其视为常量。
       </li>
       <li>
        通常用于主键或唯一索引的等值查询。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        system
       </strong>
       :
      </p>
      <ul>
       <li>
        表只有一行（系统表），是
        <code>
         const
        </code>
        类型的特例。
       </li>
       <li>
        查询效率最高。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        NULL
       </strong>
       :
      </p>
      <ul>
       <li>
        MySQL 无需访问表或索引直接就能得出结果。
       </li>
       <li>
        例如
        <code>
         SELECT 1 + 1
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="Covering_Index_140">
     </a>
     覆盖索引（Covering Index）
    </h3>
    <p>
     覆盖索引是指
     <strong>
      一个索引包含了查询所需的所有列
     </strong>
     ，不需要再回表（访问数据行）来获取数据。这样能显著提高查询性能，因为索引通常比数据行小且紧凑。
    </p>
    <h4>
     <a id="_144">
     </a>
     示例：
    </h4>
    <p>
     假设有一张表
     <code>
      users
     </code>
     ，有索引
     <code>
      idx_name_email (name, email)
     </code>
     ：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> users <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_name_email <span class="token punctuation">(</span>name<span class="token punctuation">,</span> email<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     如果执行以下查询：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> email <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'John'</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     MySQL 可以直接从
     <code>
      idx_name_email
     </code>
     索引中获取
     <code>
      name
     </code>
     和
     <code>
      email
     </code>
     ，而不需要回表查询，从而提高查询性能。
    </p>
    <h3>
     <a id="Index_Condition_Pushdown_ICP_168">
     </a>
     索引下推（Index Condition Pushdown, ICP）
    </h3>
    <p>
     索引下推是在 MySQL 5.6 及之后引入的优化技术。在使用索引扫描时，MySQL 优化器会将查询条件 “推” 到索引扫描过程中，而不是在索引扫描后再进行过滤。
    </p>
    <h4>
     <a id="_172">
     </a>
     示例：
    </h4>
    <p>
     假设有一张表
     <code>
      employees
     </code>
     ，有索引
     <code>
      idx_last_name_first_name (last_name, first_name)
     </code>
     ：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    last_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    first_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hire_date <span class="token keyword">DATE</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_last_name_first_name <span class="token punctuation">(</span>last_name<span class="token punctuation">,</span> first_name<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     如果执行以下查询：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> last_name <span class="token operator">=</span> <span class="token string">'Smith'</span> <span class="token operator">AND</span> first_name <span class="token operator">LIKE</span> <span class="token string">'J%'</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     使用索引下推，MySQL 优化器会在扫描
     <code>
      idx_last_name_first_name
     </code>
     索引时，同时应用
     <code>
      first_name LIKE 'J%'
     </code>
     过滤条件，而不是扫描完索引后再应用过滤条件。这减少了不必要的行访问，提高了查询效率。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35343038383233342f:61727469636c652f64657461696c732f313435323931383231" class_="artid" style="display:none">
 </p>
</div>


