---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313737363535302f:61727469636c652f64657461696c732f313436333032343230"
layout: post
title: "计算机操作系统进程4"
date: 2025-03-16 22:55:24 +08:00
description: "上一篇我们仅仅讲了一点关于线程同步的概念，临界区和同步机制应遵循的规则，这篇我们文章仅仅给大家讲一下软硬件的是如何实现同步机制的，下面我们会使用类c语言来进行实现，正好也复习了一下C语言的内容。提示：以下是本篇文章正文内容，下面案例可供参考。"
keywords: "计算机操作系统进程（4）"
categories: ['未分类']
tags: ['运维', '服务器', 'Windows', 'Linux', 'C']
artid: "146302420"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146302420
    alt: "计算机操作系统进程4"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146302420
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146302420
cover: https://bing.ee123.net/img/rand?artid=146302420
image: https://bing.ee123.net/img/rand?artid=146302420
img: https://bing.ee123.net/img/rand?artid=146302420
---

# 计算机操作系统进程（4）

## 系列文章目录

第二章：进程的描述与控制

---

#### 文章目录

* [系列文章目录](#_0)
* [前言](#_12)
* [一、](#pandas_22)
  临界区的概念和描述：
* [二、](#_26)
  硬件同步机制：
  + [1.](#1_27)
    关中断
  + [2.](#2_41)
    利用Test-and-Set指令实现互斥
  + 3.利用Swap指令实现进程的互斥
* [总结](#_55)

---

## 前言

上一篇我们仅仅讲了一点关于线程同步的概念，临界区和同步机制应遵循的规则，这篇我们文章仅仅给大家讲一下软硬件的是如何实现同步机制的，下面我们会使用类c语言来进行实现，正好也复习了一下C语言的内容。

---

`提示：以下是本篇文章正文内容，下面案例可供参考`

## 一、临界区的概念和描述：

**临界区很重要，所以我还是想先给基础打好，带着大家再复习一下**

不论是软件临界资源还是硬件临界资源，多个进程必须互斥地对它进行访问。在每个进程中访问临界资源的那段代码称为临界区。

下面是对访问临界资源的循环进程描述如下：

```cpp
 while(True){
 
   进入区//enter section
   临界区//critical section
   退出区//exit section
   剩余区//reminder section


}
```

## 

进入区是因为如果此刻该临界资源正在被某进程访问，则本进程不能进入临界区。所以必须在临界区前面添加一段用于检查上述的代码。

退出区是为了用于将临界区正在访问的标志恢复为未被访问的标志。（
下面都有具体实现
）

剩余区就是进程中除上述进入区，临界区及退出区之外的其它部分的代码在这里都称为剩余区。

**至于同步机制应遵循的原则就看我上面进程（3）的内容吧**

**1.空闲让进 2.忙则等待 3.有限等待 4.让权等待（例子： 释放CPU资源）**

## 

## 二、硬件同步机制：

### 1.关中断

关中断是 实现互斥的最简单方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断，这样进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程和线程切换。

但万事都有利有弊，缺点就是：

（1）滥用关中断权力可能导致严重后果

（2）关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力

（3）关中断方法也不适用于多CPU系统，因为一个又阻止不了多个。

### 2.利用Test-and-Set指令实现互斥

```cpp
boolean TS(boolean *lock){
   boolean old;
     old = *lock; 
   *lock = TRUE;
    return old;
}
do{
....

while TS(&lock);     


critical section;
Lock = FALSE;
remainder section;

}while(TRUE);
```

以我的理解给大家解释一下，其实这里面按字面意思理解就行，就是我们把Lock变量当作一把锁，因为我们要实现互斥肯定要只能当前有一个线程来运行，然后刚开始的临界资源就是空闲的，所以Lock置为False，这时肯定能进入临界区，此
**时TS当中的Lock已经变成了TRUE，即上锁了，**

**然后该进程访问完临界资源后就将Lock置为False，下一个线程就可以再进来了。**

### 3.利用Swap指令实现进程的互斥

```cpp
void Swap(boolean *a,boolean *b){
      boolean temp;
    temp = *a;
   *a = *b;
   *b = temp;
}
do{

key = TRUE;
do{

swap(&lock,&key);

}while(key!=FALSE);
//临界区操作;
lock = FALSE;
......

}while(TRUE);

```

swap函数是一个对换指令，用于交换两个字的内容。

这其实本质也是一个设置一个锁，方法是为每一个临界资源设置一个全局的布尔变量Lock，其初值为false，在每个进程中再利用一个局部布尔变量Key。

当临界资源忙碌时，其他访问进程必须不断的进行测试，处于一种“忙等”状态，不符合“让权等待”的原则，造成处理机的浪费，同时也很难它们用于解决复杂的进程的同步问题。

**注意：这里面的Key是一个全局变量，所有进程都共享，进来的时候Key都先为TRUE，注意这里的每个进程都是会重头做的。**

---

## 总结

以上就是今天要讲的内容，仅仅讲了一个硬件同步机制，时间太晚了，下节我们再讲信号量机制和进程的经典同步问题，生产者和消费者等等，谢谢大家，我会持续更新的。