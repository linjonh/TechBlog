---
layout: post
title: "计算机操作系统进程4"
date: 2025-03-16 22:55:24 +0800
description: "上一篇我们仅仅讲了一点关于线程同步的概念，临界区和同步机制应遵循的规则，这篇我们文章仅仅给大家讲一下软硬件的是如何实现同步机制的，下面我们会使用类c语言来进行实现，正好也复习了一下C语言的内容。提示：以下是本篇文章正文内容，下面案例可供参考。"
keywords: "计算机操作系统进程（4）"
categories: ['未分类']
tags: ['运维', '服务器', 'Windows', 'Linux', 'C']
artid: "146302420"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146302420
    alt: "计算机操作系统进程4"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146302420
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146302420
cover: https://bing.ee123.net/img/rand?artid=146302420
image: https://bing.ee123.net/img/rand?artid=146302420
img: https://bing.ee123.net/img/rand?artid=146302420
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     计算机操作系统进程（4）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <a id="_0">
     </a>
     系列文章目录
    </h2>
    <p>
     第二章：进程的描述与控制
    </p>
    <hr/>
    <p>
    </p>
    <div>
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#_0" rel="nofollow">
        系列文章目录
       </a>
      </li>
      <li>
       <a href="#_12" rel="nofollow">
        前言
       </a>
      </li>
      <li>
       <a href="#pandas_22" rel="nofollow">
        一、
       </a>
       临界区的概念和描述：
      </li>
      <li>
       <a href="#_26" rel="nofollow">
        二、
       </a>
       硬件同步机制：
       <ul>
        <li>
         <a href="#1_27" rel="nofollow">
          1.
         </a>
         关中断
        </li>
        <li>
         <a href="#2_41" rel="nofollow">
          2.
         </a>
         利用Test-and-Set指令实现互斥
        </li>
        <li>
         3.利用Swap指令实现进程的互斥
        </li>
       </ul>
      </li>
      <li>
       <a href="#_55" rel="nofollow">
        总结
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_12">
     </a>
     前言
    </h2>
    <p>
     上一篇我们仅仅讲了一点关于线程同步的概念，临界区和同步机制应遵循的规则，这篇我们文章仅仅给大家讲一下软硬件的是如何实现同步机制的，下面我们会使用类c语言来进行实现，正好也复习了一下C语言的内容。
    </p>
    <hr/>
    <p>
     <code>
      提示：以下是本篇文章正文内容，下面案例可供参考
     </code>
    </p>
    <h2>
     <a id="pandas_22">
     </a>
     一、临界区的概念和描述：
    </h2>
    <p>
     <span style="color:#1c7331">
      <strong>
       临界区很重要，所以我还是想先给基础打好，带着大家再复习一下
      </strong>
     </span>
    </p>
    <p>
     不论是软件临界资源还是硬件临界资源，多个进程必须互斥地对它进行访问。在每个进程中访问临界资源的那段代码称为临界区。
    </p>
    <p>
     下面是对访问临界资源的循环进程描述如下：
    </p>
    <p>
    </p>
    <pre><code class="language-cpp"> while(True){
 
   进入区//enter section
   临界区//critical section
   退出区//exit section
   剩余区//reminder section


}</code></pre>
    <h2>
     <a id="_26">
     </a>
    </h2>
    <p>
     进入区是因为如果此刻该临界资源正在被某进程访问，则本进程不能进入临界区。所以必须在临界区前面添加一段用于检查上述的代码。
    </p>
    <p>
     退出区是为了用于将临界区正在访问的标志恢复为未被访问的标志。（
     <span style="color:#fe2c24">
      下面都有具体实现
     </span>
     ）
    </p>
    <p>
     剩余区就是进程中除上述进入区，临界区及退出区之外的其它部分的代码在这里都称为剩余区。
    </p>
    <p>
     <strong>
      至于同步机制应遵循的原则就看我上面进程（3）的内容吧
     </strong>
    </p>
    <p>
     <strong>
      1.空闲让进 2.忙则等待 3.有限等待 4.让权等待（例子： 释放CPU资源）
     </strong>
    </p>
    <h2>
    </h2>
    <h2>
     二、硬件同步机制：
    </h2>
    <h3>
     <a id="1_27">
     </a>
     1.关中断
    </h3>
    <p>
     关中断是 实现互斥的最简单方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断，这样进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程和线程切换。
    </p>
    <p>
     但万事都有利有弊，缺点就是：
    </p>
    <p>
     （1）滥用关中断权力可能导致严重后果
    </p>
    <p>
     （2）关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力
    </p>
    <p>
     （3）关中断方法也不适用于多CPU系统，因为一个又阻止不了多个。
    </p>
    <h3>
     <a id="2_41">
     </a>
     2.利用Test-and-Set指令实现互斥
    </h3>
    <p>
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">boolean TS(boolean *lock){
   boolean old;
     old = *lock; 
   *lock = TRUE;
    return old;
}
do{
....

while TS(&amp;lock);     


critical section;
Lock = FALSE;
remainder section;

}while(TRUE);</code></pre>
    <p>
     以我的理解给大家解释一下，其实这里面按字面意思理解就行，就是我们把Lock变量当作一把锁，因为我们要实现互斥肯定要只能当前有一个线程来运行，然后刚开始的临界资源就是空闲的，所以Lock置为False，这时肯定能进入临界区，此
     <span style="color:#fe2c24">
      <strong>
       时TS当中的Lock已经变成了TRUE，即上锁了，
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       然后该进程访问完临界资源后就将Lock置为False，下一个线程就可以再进来了。
      </strong>
     </span>
    </p>
    <p>
    </p>
    <h3>
     3.利用Swap指令实现进程的互斥
    </h3>
    <p>
    </p>
    <pre><code class="language-cpp">void Swap(boolean *a,boolean *b){
      boolean temp;
    temp = *a;
   *a = *b;
   *b = temp;
}
do{

key = TRUE;
do{

swap(&amp;lock,&amp;key);

}while(key!=FALSE);
//临界区操作;
lock = FALSE;
......

}while(TRUE);
</code></pre>
    <p>
     swap函数是一个对换指令，用于交换两个字的内容。
    </p>
    <p>
     这其实本质也是一个设置一个锁，方法是为每一个临界资源设置一个全局的布尔变量Lock，其初值为false，在每个进程中再利用一个局部布尔变量Key。
    </p>
    <p>
     当临界资源忙碌时，其他访问进程必须不断的进行测试，处于一种“忙等”状态，不符合“让权等待”的原则，造成处理机的浪费，同时也很难它们用于解决复杂的进程的同步问题。
    </p>
    <p>
     <strong>
      注意：这里面的Key是一个全局变量，所有进程都共享，进来的时候Key都先为TRUE，注意这里的每个进程都是会重头做的。
     </strong>
    </p>
    <hr/>
    <p>
    </p>
    <h2>
     <a id="_55">
     </a>
     总结
    </h2>
    <p>
     以上就是今天要讲的内容，仅仅讲了一个硬件同步机制，时间太晚了，下节我们再讲信号量机制和进程的经典同步问题，生产者和消费者等等，谢谢大家，我会持续更新的。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313737363535302f:61727469636c652f64657461696c732f313436333032343230" class_="artid" style="display:none">
 </p>
</div>


