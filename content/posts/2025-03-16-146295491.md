---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38323931313736382f:61727469636c652f64657461696c732f313436323935343931"
layout: post
title: "2操作系统之软件基础"
date: 2025-03-16 20:37:34 +08:00
description: "操作系统的软件基础部分。这里的文件， 没有详解。如果对linux的命令熟练掌握的话。应该就有文件基础知识了。"
keywords: "2、操作系统之软件基础"
categories: ['操作系统']
tags: ['运维', '服务器', 'Windows', 'Ubuntu', 'Linux', 'Centos', 'C']
artid: "146295491"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146295491
    alt: "2操作系统之软件基础"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146295491
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146295491
cover: https://bing.ee123.net/img/rand?artid=146295491
image: https://bing.ee123.net/img/rand?artid=146295491
img: https://bing.ee123.net/img/rand?artid=146295491
---

# 2、操作系统之软件基础

## 一、硬件支持系统 ，系统管理硬件

* **操作系统核心功能**
  可以分为：
  + **守护者**
    ：对硬件和软件资源的管理
  + **协调者**
    ：通过机制，将各种各样的硬件资源适配给软件使用。
* 所以为了更好的管理硬件，操作系统引进了软件。其中
  **3大核心部分**
  是：
  + 文件【我们需要知道怎么用文件来访问磁盘和I/O设备】
  + 虚拟内存【虚拟内存是虚拟的，
    **为应用程序提供远大于物理内存限制的虚拟地址空间**
    。】
  + 进程【真正用来访问资源的部分】
      
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5a9d2157b36642178b5bab1d15d107b9.png)

## 二、进程（process）

### 1、理解

进程就是一个
**正在执行的程序实例**
。

> 进程的结构
>
> * 每个进程里都有一个
>   `独立的地址空间`
>   。
>   + 这个空间一开始是0 ，不断的运行，就成了连续的存储空间。在这个空间，不仅程序能运行起来，还能调用各种数据，等等。
> * 每个进程都有相关的
>   `资源`
>   + 这些资源有PS ， PC寄存器等等。
>
> **简而言之**
> ：进程就是一个被封装的容器，它有运行资源的一切信息。

* 如果 我开了QQ，又开了微信。那我的进程就有2个，它要如何
  **合理地获得CPU资源**
  ？

  + **操作系统通过时间片轮转等调度策略**
    ，
    **周期性地挂起**
    一个进程并
    **启动**
    另一个，确保所有进程都能公平地获得CPU资源。
  + 当进程被
    **暂时挂起**
    ，就必须保存状态了。以便未来某个时候可以继续使用。状态下的信息【比如寄存器，地址空间，上下文等等】都会被存储在
    `进程表`
    中。
    - **`进程表`
      用于跟踪系统中所有进程的状态信息**
      。
* **shell和进程**

  + 用户可以使用shell来控制进程。让一个进程产生更多进程（这些由进程产生的进程就是
    `子进程`
    ）【可能有些抽象，可以这样理解，如下：】。
    - ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/909049aa3b0a44eb91366c379564b4cb.png)
    - 我在shell使用
      `ls`
      命令，这个命令展现了当前路径有的文件件。我本来是在运行shell的linux环境虚拟机【当前一个主进程】，我想看文件夹，我为了看文件夹，使用了ls命令，在执行这个ls命令的过程就是
      `子进程`
      。
  + 所以进程就有树的样子了-----
    `进程树`
    。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/572a2f8139ff4646b92e4658ba331380.png)
* **进程该如何通信**
  ？

  + 当进程间协同工作完后，使用机制来交换信息，也就是
    `进程间通信（IPC）`
    机制。
  + 除了
    `进程间通信（IPC）`
    外，操作系统还使用一系列的
    `系统调用`
    来管理进程资源。
* **进程接收信息，如果信息经常不能准时到达**
  ？

  + 为了确保可靠传输，进程会采用
    `定时器`
    。【这种行为也就是异步】
    - 比如：进程在外部信息发送出去的第4秒还没有接收到。就发一个通知提醒，就可能重新发送了。

> **异步行为**
> 【分为软件异步、硬件异步】：
>   
> 异步行为是指任务可以并发执行，不需要等待前一个任务完成。异步操作不会阻塞当前线程，任务完成后通过回调、Promise 或事件通知。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c3959991b7c74b7db28b09b282372ff1.png)

* 那么事件1发生什么事情？
  + **事件1作用：保护现场**
    。
  + **保护的内容有**
    - PC值----由CPU保护
    - PSW寄存器—操作系统软件保护
    - 基础寄存器—操作系统软件保护
    - 不过在现代有可以都用CPU保护的了。CortexM芯片等等。
* 事件2发生什么事情？
  + 事件2作用：确定中断入口在哪里
  + 硬件CPU来准备—操作系统OS和CPU都能来提供
    `中断向量表【中断处理函数的数组空间】`
    。
* 事件3发生什么事情？
  + 事件3作用：中断处理函数
  + 操作系统来准备。
* 事件4发生什么事情？
  + 事件4作用：中断返回【
    **普通函数**
    返回】
  + 软件实现，编译器来实现。
  + 特定的汇编写，不能c语言。
    - 普通函数
      * PC值—>硬件保护
      * PSW寄存器—>不需要保护。
      * 基础寄存器—>编译器保护

> **同步行为**
>   
> 同步行为是指
> **任务按顺序执行**
> ，前一个任务完成后，才能开始下一个任务。同步操作会阻塞当前线程，直到任务完成。

## 三、虚拟内存

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/50c8c5a9fe8448e280ab58a49258be87.png)
  
从下往上看，分为进程代码和数据区、堆数据区、共享库区、堆栈区、内核内存区。

这部分的基础先了解这个图片就行了。

> 常驻内存是指一直都在，不能删掉。

## 四、并发和并行

* **并发**
  是指多个任务在
  **同一时间段内交替执行**
  ，
  **但在任意时刻可能只有一个任务在运行**
  。并发通过任务切换（上下文切换）实现，给人一种多个任务同时运行的错觉。
* 如图：同一时间段内

```bash
时间轴： |----任务A----|----任务B----|----任务A----|----任务B----|

```

* **并行**
  是指
  **多个任务在同一时刻同时执行**
  。并行需要多核 CPU 或多个处理器，每个任务运行在不同的核心上。
* 如图：同一时刻内

```bash
时间轴： |----任务A----|
          |----任务B----|
          	 |----任务C----|

```

## 五、系统调用【超重点】

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/21678089719a4da1bba7886befe55ff7.png)

> 通过上图能明白，硬件不能直接让用户使用它。
>   
> 所以提出了
> `系统调用`
> 。

* 系统调用

  + 定义：系统调用是操作系统内核（Kernel）为应用程序提供的一组接口，
    **允许用户程序（运行在用户态）请求内核（运行在内核态）代为执行特权操作**
    （如文件读写、进程创建等）。
  + 系统调用
    **依赖硬件和OS（操作系统）**
    。
* **系统调用的工作原理**
* (1) 调用流程

  + **用户程序触发调用**
    - 通过
      **特定函数**
      （如C标准库中的 printf() → 底层调用 write()）或直接代码
      **触发**
      。
  + **用户态 → 内核态切换**
    - 通过
      **软中断**
      （如 int 0x80）或专用指令（如 syscall）
      **进入内核态**
      。
  + **执行内核服务**
    - 内核根据系统调用号（如 Linux 的 read 对应 0 号）调用对应的内核函数。
  + **返回结果**
    - 内核将结果传递给用户程序，
      **回到用户态**
      继续执行。
* (2) 系统调用号（syscall number）

  + **每个系统调用对应唯一编号**
    ，通过
    **寄存器传递**
    （如 x86-64 Linux 中，rax 存放系统调用号）。
  + 示例：Linux 的 sys\_write 在 x86-64 中的调用号是 1，可通过命令 grep \_\_NR\_write /usr/include/asm/unistd\_64.h 查看。
* (3) 参数传递

  + 寄存器传递参数：参数按顺序放入 rdi, rsi, rdx, r10, r8, r9（x86-64 架构）。
      
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6b8e1bd2bddb4b9287ad0d4f5bb2a822.png)