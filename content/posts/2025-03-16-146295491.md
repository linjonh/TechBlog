---
layout: post
title: "2操作系统之软件基础"
date: 2025-03-16 20:37:34 +0800
description: "操作系统的软件基础部分。这里的文件， 没有详解。如果对linux的命令熟练掌握的话。应该就有文件基础知识了。"
keywords: "2、操作系统之软件基础"
categories: ['操作系统']
tags: ['运维', '服务器', 'Windows', 'Ubuntu', 'Linux', 'Centos', 'C']
artid: "146295491"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146295491
    alt: "2操作系统之软件基础"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146295491
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146295491
cover: https://bing.ee123.net/img/rand?artid=146295491
image: https://bing.ee123.net/img/rand?artid=146295491
img: https://bing.ee123.net/img/rand?artid=146295491
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     2、操作系统之软件基础
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="__0">
     </a>
     一、硬件支持系统 ，系统管理硬件
    </h2>
    <ul>
     <li>
      <strong>
       操作系统核心功能
      </strong>
      可以分为：
      <ul>
       <li>
        <strong>
         守护者
        </strong>
        ：对硬件和软件资源的管理
       </li>
       <li>
        <strong>
         协调者
        </strong>
        ：通过机制，将各种各样的硬件资源适配给软件使用。
       </li>
      </ul>
     </li>
     <li>
      所以为了更好的管理硬件，操作系统引进了软件。其中
      <strong>
       3大核心部分
      </strong>
      是：
      <ul>
       <li>
        文件【我们需要知道怎么用文件来访问磁盘和I/O设备】
       </li>
       <li>
        虚拟内存【虚拟内存是虚拟的，
        <strong>
         为应用程序提供远大于物理内存限制的虚拟地址空间
        </strong>
        。】
       </li>
       <li>
        进程【真正用来访问资源的部分】
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5a9d2157b36642178b5bab1d15d107b9.png"/>
       </li>
      </ul>
     </li>
    </ul>
    <h2>
     <a id="process_10">
     </a>
     二、进程（process）
    </h2>
    <h3>
     <a id="1_11">
     </a>
     1、理解
    </h3>
    <p>
     进程就是一个
     <strong>
      正在执行的程序实例
     </strong>
     。
    </p>
    <blockquote>
     <p>
      进程的结构
     </p>
     <ul>
      <li>
       每个进程里都有一个
       <code>
        独立的地址空间
       </code>
       。
       <ul>
        <li>
         这个空间一开始是0 ，不断的运行，就成了连续的存储空间。在这个空间，不仅程序能运行起来，还能调用各种数据，等等。
        </li>
       </ul>
      </li>
      <li>
       每个进程都有相关的
       <code>
        资源
       </code>
       <ul>
        <li>
         这些资源有PS ， PC寄存器等等。
        </li>
       </ul>
      </li>
     </ul>
     <p>
      <strong>
       简而言之
      </strong>
      ：进程就是一个被封装的容器，它有运行资源的一切信息。
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       如果 我开了QQ，又开了微信。那我的进程就有2个，它要如何
       <strong>
        合理地获得CPU资源
       </strong>
       ？
      </p>
      <ul>
       <li>
        <strong>
         操作系统通过时间片轮转等调度策略
        </strong>
        ，
        <strong>
         周期性地挂起
        </strong>
        一个进程并
        <strong>
         启动
        </strong>
        另一个，确保所有进程都能公平地获得CPU资源。
       </li>
       <li>
        当进程被
        <strong>
         暂时挂起
        </strong>
        ，就必须保存状态了。以便未来某个时候可以继续使用。状态下的信息【比如寄存器，地址空间，上下文等等】都会被存储在
        <code>
         进程表
        </code>
        中。
        <ul>
         <li>
          <strong>
           <code>
            进程表
           </code>
           用于跟踪系统中所有进程的状态信息
          </strong>
          。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        shell和进程
       </strong>
      </p>
      <ul>
       <li>
        用户可以使用shell来控制进程。让一个进程产生更多进程（这些由进程产生的进程就是
        <code>
         子进程
        </code>
        ）【可能有些抽象，可以这样理解，如下：】。
        <ul>
         <li>
          <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/909049aa3b0a44eb91366c379564b4cb.png"/>
         </li>
         <li>
          我在shell使用
          <code>
           ls
          </code>
          命令，这个命令展现了当前路径有的文件件。我本来是在运行shell的linux环境虚拟机【当前一个主进程】，我想看文件夹，我为了看文件夹，使用了ls命令，在执行这个ls命令的过程就是
          <code>
           子进程
          </code>
          。
         </li>
        </ul>
       </li>
       <li>
        所以进程就有树的样子了-----
        <code>
         进程树
        </code>
        。
       </li>
       <li>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/572a2f8139ff4646b92e4658ba331380.png"/>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        进程该如何通信
       </strong>
       ？
      </p>
      <ul>
       <li>
        当进程间协同工作完后，使用机制来交换信息，也就是
        <code>
         进程间通信（IPC）
        </code>
        机制。
       </li>
       <li>
        除了
        <code>
         进程间通信（IPC）
        </code>
        外，操作系统还使用一系列的
        <code>
         系统调用
        </code>
        来管理进程资源。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        进程接收信息，如果信息经常不能准时到达
       </strong>
       ？
      </p>
      <ul>
       <li>
        为了确保可靠传输，进程会采用
        <code>
         定时器
        </code>
        。【这种行为也就是异步】
        <ul>
         <li>
          比如：进程在外部信息发送出去的第4秒还没有接收到。就发一个通知提醒，就可能重新发送了。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      <strong>
       异步行为
      </strong>
      【分为软件异步、硬件异步】：
      <br/>
      异步行为是指任务可以并发执行，不需要等待前一个任务完成。异步操作不会阻塞当前线程，任务完成后通过回调、Promise 或事件通知。
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c3959991b7c74b7db28b09b282372ff1.png"/>
    </p>
    <ul>
     <li>
      那么事件1发生什么事情？
      <ul>
       <li>
        <strong>
         事件1作用：保护现场
        </strong>
        。
       </li>
       <li>
        <strong>
         保护的内容有
        </strong>
        <ul>
         <li>
          PC值----由CPU保护
         </li>
         <li>
          PSW寄存器—操作系统软件保护
         </li>
         <li>
          基础寄存器—操作系统软件保护
         </li>
         <li>
          不过在现代有可以都用CPU保护的了。CortexM芯片等等。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      事件2发生什么事情？
      <ul>
       <li>
        事件2作用：确定中断入口在哪里
       </li>
       <li>
        硬件CPU来准备—操作系统OS和CPU都能来提供
        <code>
         中断向量表【中断处理函数的数组空间】
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      事件3发生什么事情？
      <ul>
       <li>
        事件3作用：中断处理函数
       </li>
       <li>
        操作系统来准备。
       </li>
      </ul>
     </li>
     <li>
      事件4发生什么事情？
      <ul>
       <li>
        事件4作用：中断返回【
        <strong>
         普通函数
        </strong>
        返回】
       </li>
       <li>
        软件实现，编译器来实现。
       </li>
       <li>
        特定的汇编写，不能c语言。
        <ul>
         <li>
          普通函数
          <ul>
           <li>
            PC值—&gt;硬件保护
           </li>
           <li>
            PSW寄存器—&gt;不需要保护。
           </li>
           <li>
            基础寄存器—&gt;编译器保护
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      <strong>
       同步行为
      </strong>
      <br/>
      同步行为是指
      <strong>
       任务按顺序执行
      </strong>
      ，前一个任务完成后，才能开始下一个任务。同步操作会阻塞当前线程，直到任务完成。
     </p>
    </blockquote>
    <h2>
     <a id="_69">
     </a>
     三、虚拟内存
    </h2>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/50c8c5a9fe8448e280ab58a49258be87.png">
      <br/>
      从下往上看，分为进程代码和数据区、堆数据区、共享库区、堆栈区、内核内存区。
     </img>
    </p>
    <p>
     这部分的基础先了解这个图片就行了。
    </p>
    <blockquote>
     <p>
      常驻内存是指一直都在，不能删掉。
     </p>
    </blockquote>
    <h2>
     <a id="_76">
     </a>
     四、并发和并行
    </h2>
    <ul>
     <li>
      <strong>
       并发
      </strong>
      是指多个任务在
      <strong>
       同一时间段内交替执行
      </strong>
      ，
      <strong>
       但在任意时刻可能只有一个任务在运行
      </strong>
      。并发通过任务切换（上下文切换）实现，给人一种多个任务同时运行的错觉。
     </li>
     <li>
      如图：同一时间段内
     </li>
    </ul>
    <pre><code class="prism language-bash">时间轴： <span class="token operator">|</span>----任务A----<span class="token operator">|</span>----任务B----<span class="token operator">|</span>----任务A----<span class="token operator">|</span>----任务B----<span class="token operator">|</span>
</code></pre>
    <ul>
     <li>
      <strong>
       并行
      </strong>
      是指
      <strong>
       多个任务在同一时刻同时执行
      </strong>
      。并行需要多核 CPU 或多个处理器，每个任务运行在不同的核心上。
     </li>
     <li>
      如图：同一时刻内
     </li>
    </ul>
    <pre><code class="prism language-bash">时间轴： <span class="token operator">|</span>----任务A----<span class="token operator">|</span>
          <span class="token operator">|</span>----任务B----<span class="token operator">|</span>
          	 <span class="token operator">|</span>----任务C----<span class="token operator">|</span>
</code></pre>
    <h2>
     <a id="_91">
     </a>
     五、系统调用【超重点】
    </h2>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/21678089719a4da1bba7886befe55ff7.png"/>
    </p>
    <blockquote>
     <p>
      通过上图能明白，硬件不能直接让用户使用它。
      <br/>
      所以提出了
      <code>
       系统调用
      </code>
      。
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       系统调用
      </p>
      <ul>
       <li>
        定义：系统调用是操作系统内核（Kernel）为应用程序提供的一组接口，
        <strong>
         允许用户程序（运行在用户态）请求内核（运行在内核态）代为执行特权操作
        </strong>
        （如文件读写、进程创建等）。
       </li>
       <li>
        系统调用
        <strong>
         依赖硬件和OS（操作系统）
        </strong>
        。
       </li>
       <li>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        系统调用的工作原理
       </strong>
      </p>
     </li>
     <li>
      <p>
       (1) 调用流程
      </p>
      <ul>
       <li>
        <strong>
         用户程序触发调用
        </strong>
        <ul>
         <li>
          通过
          <strong>
           特定函数
          </strong>
          （如C标准库中的 printf() → 底层调用 write()）或直接代码
          <strong>
           触发
          </strong>
          。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         用户态 → 内核态切换
        </strong>
        <ul>
         <li>
          通过
          <strong>
           软中断
          </strong>
          （如 int 0x80）或专用指令（如 syscall）
          <strong>
           进入内核态
          </strong>
          。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         执行内核服务
        </strong>
        <ul>
         <li>
          内核根据系统调用号（如 Linux 的 read 对应 0 号）调用对应的内核函数。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         返回结果
        </strong>
        <ul>
         <li>
          内核将结果传递给用户程序，
          <strong>
           回到用户态
          </strong>
          继续执行。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       (2) 系统调用号（syscall number）
      </p>
      <ul>
       <li>
        <strong>
         每个系统调用对应唯一编号
        </strong>
        ，通过
        <strong>
         寄存器传递
        </strong>
        （如 x86-64 Linux 中，rax 存放系统调用号）。
       </li>
       <li>
        示例：Linux 的 sys_write 在 x86-64 中的调用号是 1，可通过命令 grep __NR_write /usr/include/asm/unistd_64.h 查看。
       </li>
      </ul>
     </li>
     <li>
      <p>
       (3) 参数传递
      </p>
      <ul>
       <li>
        寄存器传递参数：参数按顺序放入 rdi, rsi, rdx, r10, r8, r9（x86-64 架构）。
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6b8e1bd2bddb4b9287ad0d4f5bb2a822.png"/>
       </li>
      </ul>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38323931313736382f:61727469636c652f64657461696c732f313436323935343931" class_="artid" style="display:none">
 </p>
</div>


