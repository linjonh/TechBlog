---
layout: post
title: "操作系统-ELF文件从形成到加载轮廓"
date: 2025-03-07 19:58:03 +0800
description: "symtab本质.symtab是源码中函数名、变量名和代码对应关系的“映射表”，记录程序的符号及其在目标文件或可执行文件中的位置和属性。"
keywords: "[操作系统] ELF文件从形成到加载轮廓"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "146103834"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146103834
    alt: "操作系统-ELF文件从形成到加载轮廓"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146103834
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146103834
cover: https://bing.ee123.net/img/rand?artid=146103834
image: https://bing.ee123.net/img/rand?artid=146103834
img: https://bing.ee123.net/img/rand?artid=146103834
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [操作系统] ELF文件从形成到加载轮廓
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/4e5c1ed59f40c875ccc858c5900f6354.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c59cd819c2415e5997ad45db0b98853a.gif"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="font_stylecolorrgb313541font_5">
     </a>
     目标文件
    </h2>
    <p>
     编译和链接这两个步骤，在Windows下被IDE封装的很完美，我们一般是使用一键编译并运行，但是当链接出错的话我们就束手无措了。在Linux下有gcc/g++编译器，可以直接展示出编译链接的过程。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/549b1f9793aa9d75d1ecbea8aba8a646.png"/>
    </p>
    <p>
     在软件开发中，编译是将程序的源代码（通常是人类可读的高级语言，如 C/C++）翻译成 CPU 能够直接执行的机器代码（二进制代码）。通过这一步骤，源文件被转换为目标文件，为后续的链接奠定基础。
    </p>
    <h5>
     <a id="_12">
     </a>
     编译过程与目标文件的生成
    </h5>
    <p>
     以一个简单的例子为例：假设我们有一个源文件
     <code>
      hello.c
     </code>
     ，其内容如下：
    </p>
    <pre><code class="prism language-c"><span class="token comment">// hello.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     使用
     <code>
      gcc
     </code>
     编译器，我们可以通过以下命令编译该源文件：
    </p>
    <pre><code class="prism language-bash">$ gcc <span class="token parameter variable">-c</span> hello.c
</code></pre>
    <p>
     编译完成后，生成一个扩展名为
     <code>
      .o
     </code>
     的文件（例如
     <code>
      hello.o
     </code>
     ），被称为
     <strong>
      目标文件
     </strong>
     （Object File）。我们可以通过以下命令查看生成的文件：
    </p>
    <pre><code class="prism language-bash">$ <span class="token function">ls</span>
hello.c  hello.o
</code></pre>
    <h6>
     <a id="_37">
     </a>
     目标文件的特性：
    </h6>
    <ul>
     <li>
      目标文件是二进制文件，通常采用 ELF（Executable and Linkable Format）格式（在 Linux/x86_64 系统中）。
     </li>
     <li>
      使用
      <code>
       file
      </code>
      命令可以检查目标文件的类型，例如：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ <span class="token function">file</span> hello.o
hello.o: ELF <span class="token number">64</span>-bit LSB relocatable, x86-64, version <span class="token number">1</span> <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped
</code></pre>
    <ul>
     <li>
      ELF 是一种通用的文件格式，用于封装二进制代码、数据和符号信息，是 Linux 系统中目标文件、可执行文件和共享库的标准格式。
     </li>
     <li>
      目标文件包含编译后的机器代码，但还未与库文件或其他目标文件链接，因此不能直接运行。
     </li>
    </ul>
    <p>
     通过编译过程，我们可以生成目标文件，并了解 ELF 格式作为二进制文件封装的重要作用。
    </p>
    <blockquote>
     <p>
      如果我们修改了一个源文件，那么我们只需要单独编译这一个文啊进，而不是重新编译整个工会测过，将目标文件编译后重新链接即可。
     </p>
    </blockquote>
    <h2>
     <a id="ELF_56">
     </a>
     ELF文件：编译与链接基础
    </h2>
    <p>
     为了全面理解编译和链接的细节，我们需要深入了解 ELF（Executable and Linkable Format）文件格式。ELF 是一种通用的二进制文件格式，在 Linux 系统中广泛用于目标文件、可执行文件、共享库以及内核转储等。以下是 ELF 文件的四种主要类型及其特点：
    </p>
    <h5>
     <a id="ELF__59">
     </a>
     ELF 文件的四种类型
    </h5>
    <ol>
     <li>
      <strong>
       可重定位文件（Relocatable File）
      </strong>
      <ul>
       <li>
        即
        <code>
         .o
        </code>
        文件（目标文件）。
       </li>
       <li>
        包含适合与其他目标文件链接，以创建可执行文件或共享目标文件的代码和数据。
       </li>
       <li>
        这些文件是在编译阶段生成的，通常通过
        <code>
         gcc -c
        </code>
        命令生成，尚未进行最终的地址解析和链接。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       可执行文件（Executable File）
      </strong>
      <ul>
       <li>
        即可直接运行的程序文件（如
        <code>
         a.out
        </code>
        或其他二进制可执行文件）。
       </li>
       <li>
        通过链接器将多个目标文件和库文件组合后生成，包含完整的机器代码和数据，可由操作系统加载并执行。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       共享目标文件（Shared Object File）
      </strong>
      <ul>
       <li>
        即
        <code>
         .so
        </code>
        文件（动态库）。
       </li>
       <li>
        可以在运行时由多个程序共享加载，节省内存空间，但需要确保运行环境中有正确的库文件支持。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       内核转储（Core Dumps）
      </strong>
      <ul>
       <li>
        用于存储当前进程的执行上下文，通常在进程因信号（如段错误）触发时生成。
       </li>
       <li>
        这些文件可用于调试，分析程序崩溃的原因。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="ELF__74">
     </a>
     ELF 文件的结构组成
    </h5>
    <p>
     一个 ELF 文件由以下四个主要部分组成：
    </p>
    <ol>
     <li>
      <strong>
       ELF 头（ELF Header）
      </strong>
      <ul>
       <li>
        位于文件开头，描述文件的主要特性，如目标架构（例如 x86-64）、文件类型（可重定位、可执行等）以及版本信息。
       </li>
       <li>
        其主要作用是定位文件的其他部分，为解析文件提供基础。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       程序头表（Program Header Table）
      </strong>
      <ul>
       <li>
        列出文件中的所有有效段（Segments）及其属性。
       </li>
       <li>
        记录每个段的起始位置、偏移量和长度，因为这些段在二进制文件中紧密排列，程序头表提供必要的描述信息以区分和加载这些段。
       </li>
       <li>
        主要用于可执行文件和共享库，在加载时由操作系统或动态链接器使用。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       节头表（Section Header Table）
      </strong>
      <ul>
       <li>
        包含对文件中的节（Sections）的描述，记录每个节的类型、位置、大小等信息。
       </li>
       <li>
        节是 ELF 文件的基本组成单位，用于组织和存储不同的数据和代码。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       节（Sections）
      </strong>
      <ul>
       <li>
        ELF 文件中的基本数据单元，包含特定类型的信息。各种数据和代码存储在不同的节中，常见节包括：
        <ul>
         <li>
          <strong>
           代码节（.text）
          </strong>
          ：保存机器指令，是程序的主要执行部分。
         </li>
         <li>
          <strong>
           数据节（.data）
          </strong>
          ：保存已初始化的全局变量和局部静态变量。
         </li>
         <li>
          其他节如
          <code>
           .bss
          </code>
          （未初始化的全局变量和静态变量）、
          <code>
           .rodata
          </code>
          （只读数据，如字符串字面量）等，具体取决于文件类型和编译选项。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/2e5c204ea53824302140548799def8c7.png"/>
    </p>
    <h2>
     <a id="font_stylecolorrgb313541ELFfont_97">
     </a>
     ELF从形成到加载轮廓
    </h2>
    <h3>
     <a id="ELF__98">
     </a>
     ELF 文件形成可执行文件
    </h3>
    <p>
     ELF（Executable and Linkable Format）文件是 Linux 系统中编译和链接的核心格式。为了生成可执行文件，涉及以下两个主要步骤，并补充相关的知识点：
    </p>
    <h4>
     <a id="Step1_CC__o__101">
     </a>
     Step-1：将多份 C/C++ 源代码翻译成目标
     <code>
      .o
     </code>
     文件
    </h4>
    <ul>
     <li>
      <strong>
       编译过程
      </strong>
      ：通过编译器（如
      <code>
       gcc
      </code>
      或
      <code>
       g++
      </code>
      ）将 C/C++ 源代码（
      <code>
       .c
      </code>
      或
      <code>
       .cpp
      </code>
      文件）翻译成目标文件（
      <code>
       .o
      </code>
      文件）。编译器会执行以下几个阶段：
      <ol>
       <li>
        <strong>
         预处理（Preprocessing）
        </strong>
        ：处理
        <code>
         #include
        </code>
        、宏定义和条件编译指令，生成预处理文件（
        <code>
         .i
        </code>
        文件）。
       </li>
       <li>
        <strong>
         编译（Compilation）
        </strong>
        ：将预处理后的代码转换为汇编代码（
        <code>
         .s
        </code>
        文件），生成特定架构的机器指令。
       </li>
       <li>
        <strong>
         汇编（Assembly）
        </strong>
        ：将汇编代码转换为二进制目标文件（
        <code>
         .o
        </code>
        文件），格式为 ELF 可重定位文件。
       </li>
      </ol>
     </li>
     <li>
      <strong>
       命令示例
      </strong>
      ：使用
      <code>
       gcc -c
      </code>
      编译源文件，例如：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ gcc <span class="token parameter variable">-c</span> source1.c <span class="token parameter variable">-o</span> source1.o
$ gcc <span class="token parameter variable">-c</span> source2.c <span class="token parameter variable">-o</span> source2.o
</code></pre>
    <ul>
     <li>
      <strong>
       目标文件的特性
      </strong>
      ：
      <ul>
       <li>
        目标文件是二进制文件，采用 ELF 格式，类型为
        <strong>
         可重定位文件（Relocatable File）
        </strong>
        。
       </li>
       <li>
        包含适合链接的代码（
        <code>
         .text
        </code>
        Section）、数据（
        <code>
         .data
        </code>
        和
        <code>
         .bss
        </code>
        Section）、符号表（
        <code>
         .symtab
        </code>
        ）和重定位信息（
        <code>
         .rela
        </code>
        ），但地址尚未最终确定（符号引用未解析）。
       </li>
       <li>
        目标文件不能直接执行，需通过链接器进一步处理。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       知识点扩展
      </strong>
      ：
      <ul>
       <li>
        编译器会根据目标架构（如 x86-64）生成对应的机器代码。
       </li>
       <li>
        如果源代码包含外部函数或变量引用（未定义符号），目标文件会记录这些符号的重定位信息，供链接器解析。
       </li>
       <li>
        使用
        <code>
         gcc -Wall
        </code>
        可启用警告选项，
        <code>
         gcc -g
        </code>
        可生成调试信息（
        <code>
         .debug
        </code>
        Section），便于调试。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="Step2_o__Section__122">
     </a>
     Step-2：将多份
     <code>
      .o
     </code>
     文件的 Section 进行合并
    </h4>
    <ul>
     <li>
      <strong>
       链接过程
      </strong>
      ：在链接阶段，链接器（如
      <code>
       ld
      </code>
      ）将多个目标文件（
      <code>
       .o
      </code>
      文件）的各个 Section 合并，并可能与库文件（如静态库
      <code>
       .a
      </code>
      或动态库
      <code>
       .so
      </code>
      ）结合，生成最终的可执行文件（
      <code>
       .out
      </code>
      或指定名称）。
     </li>
     <li>
      <strong>
       Section 合并细节
      </strong>
      ：
      <ol>
       <li>
        链接器读取每个目标文件的节头表（Section Header Table），识别
        <code>
         .text
        </code>
        （代码）、
        <code>
         .data
        </code>
        （初始化数据）、
        <code>
         .bss
        </code>
        （未初始化数据）、
        <code>
         .rodata
        </code>
        （只读数据）等 Section。
       </li>
       <li>
        根据 Section 的属性（如可读、可写、可执行）和逻辑关系，合并这些 Section，形成连续的内存布局。
       </li>
       <li>
        解析符号表（
        <code>
         .symtab
        </code>
        ）和重定位表（
        <code>
         .rela
        </code>
        ），解决未定义符号（如函数或变量的引用），确保所有地址引用正确。
       </li>
       <li>
        如果使用动态链接，还会处理动态符号表（
        <code>
         .dynsym
        </code>
        ）和全局偏移表/过程链接表（
        <code>
         .got.plt
        </code>
        ），为运行时加载动态库做准备。
       </li>
      </ol>
     </li>
     <li>
      <strong>
       命令示例
      </strong>
      ：生成可执行文件：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ gcc source1.o source2.o <span class="token parameter variable">-o</span> program
</code></pre>
    <p>
     或直接从源文件生成：
    </p>
    <pre><code class="prism language-bash">$ gcc source1.c source2.c <span class="token parameter variable">-o</span> program
</code></pre>
    <ul>
     <li>
      <strong>
       注意事项
      </strong>
      ：
      <ul>
       <li>
        实际合并是在链接时进行的，但并非简单地将 Section 逐一拼接。链接器还会处理符号解析、地址分配、库文件的合并等复杂操作。
       </li>
       <li>
        静态链接会将静态库（
        <code>
         .a
        </code>
        ）内容直接嵌入可执行文件；动态链接则引用动态库（
        <code>
         .so
        </code>
        ），仅记录加载信息，运行时由动态链接器（如
        <code>
         /lib64/ld-linux-x86-64.so.2
        </code>
        ）加载。
       </li>
       <li>
        链接阶段可能出现错误，如“undefined reference”（未定义引用），通常因缺少库文件或符号定义不一致引起。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       知识点扩展
      </strong>
      ：
      <ul>
       <li>
        链接器会优化空间利用率，将小块 Section 合并成较大的连续块，减少内存页面碎片（页面大小通常为 4KB）。
       </li>
       <li>
        如果目标文件包含调试信息，链接器会保留
        <code>
         .debug
        </code>
        Section，便于使用
        <code>
         gdb
        </code>
        调试。
       </li>
       <li>
        链接器支持脚本（如
        <code>
         ld
        </code>
        的 linker script），可自定义内存布局和 Section 合并规则。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/66921d68f6c6a91f29d85113818aee80.png"/>
    </p>
    <hr/>
    <h3>
     <a id="ELF__154">
     </a>
     ELF 可执行文件加载
    </h3>
    <p>
     当生成的 ELF 可执行文件加载到内存中时，操作系统会根据其结构完成对ELF中不同的Section的合并，形成segment。
    </p>
    <h4>
     <a id="Section__Segment_157">
     </a>
     Section 合并为 Segment
    </h4>
    <ul>
     <li>
      <strong>
       Section 与 Segment 的关系
      </strong>
      ：
      <ul>
       <li>
        ELF 文件中的 Section（如
        <code>
         .text
        </code>
        、
        <code>
         .data
        </code>
        、
        <code>
         .rodata
        </code>
        ）是链接视图的逻辑单元，描述文件内容的组织方式。
       </li>
       <li>
        在加载时，操作系统根据 Section 的属性（如可读、可写、可执行）和程序头表（Program Header Table）中的信息，将具有相同属性的 Section 合并成
        <strong>
         Segment（段）
        </strong>
        ，作为执行视图的物理加载单元。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       合并原则
      </strong>
      ：
      <ul>
       <li>
        相同属性：如可读（R）、可写（W）、可执行（E）等。
       </li>
       <li>
        空间分配：需要加载时申请内存空间，合并后形成连续的内存区域。
       </li>
       <li>
        权限控制：合并后的 Segment 可定义为只读段（如包含
        <code>
         .text
        </code>
        和
        <code>
         .rodata
        </code>
        ）、可读写段（如包含
        <code>
         .data
        </code>
        和
        <code>
         .bss
        </code>
        ）或可执行段。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       加载效率
      </strong>
      ：
      <ul>
       <li>
        内存中的存储和磁盘存储类似，也是以4KB为单位进行存储，所以在合并原则的约束下，类似的Section可以合并，从而减少内存浪费。
       </li>
       <li>
        合并减少页面碎片（页面大小通常为 4KB），提高内存使用效率。例如：
        <ul>
         <li>
          如果
          <code>
           .text
          </code>
          部分为 4097 字节，
          <code>
           .init
          </code>
          部分为 512 字节，未合并时需 3 个页面（4096 × 3 = 12288 字节）；合并后可能仅需 2 个页面（4096 × 2 = 8192 字节）。
         </li>
        </ul>
       </li>
       <li>
        操作系统将 Segment 映射到虚拟内存，使用分页机制管理物理内存，提高加载和执行性能。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       知识点扩展
      </strong>
      ：
      <ul>
       <li>
        合并方式已在 ELF 文件生成时通过
        <code>
         **程序头表(Program header table)**
        </code>
        确定，程序头表记录了每个 Segment 的起始地址、长度、权限和文件偏移等信息。
       </li>
       <li>
        动态链接的 Segment 可能包含
        <code>
         .dynamic
        </code>
        和
        <code>
         .got.plt
        </code>
        Section，用于运行时解析共享库符号。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="_Section__Segment_174">
     </a>
     查看可执行程序的 Section 和 Segment
    </h4>
    <ul>
     <li>
      <strong>
       查看 Section（节头表）
      </strong>
      ：使用
      <code>
       readelf -S
      </code>
      命令。例如：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ readelf <span class="token parameter variable">-S</span> a.out
</code></pre>
    <p>
     输出显示可执行文件中的各个 Section，如
     <code>
      .text
     </code>
     （代码）、
     <code>
      .data
     </code>
     （初始化数据）、
     <code>
      .rodata
     </code>
     （只读数据）、
     <code>
      .bss
     </code>
     （未初始化数据）等，及其属性（地址、偏移、大小、权限等）。
    </p>
    <ul>
     <li>
      <strong>
       查看 Segment（程序头表）
      </strong>
      ：使用
      <code>
       readelf -l
      </code>
      命令。例如：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ readelf <span class="token parameter variable">-l</span> a.out
</code></pre>
    <p>
     输出显示程序头表中的 Segment 信息，包括类型（如
     <code>
      LOAD
     </code>
     、
     <code>
      DYNAMIC
     </code>
     ）、虚拟地址、文件偏移、文件大小、内存大小、权限（R/W/E）和对齐方式。
    </p>
    <pre><code>- `LOAD` 段：需要加载到内存的代码和数据段，可能包含 `.text`、`.data` 等 Section。  
- `DYNAMIC` 段：用于动态链接，包含动态库加载信息。  
- `GNU_STACK` 段：指定栈的权限（通常可读写）。
</code></pre>
    <h5>
     <a id="_Section_195">
     </a>
     查看可执行程序的 Section:
    </h5>
    <pre><code class="prism language-bash">$ readelf <span class="token parameter variable">-S</span> a.out
</code></pre>
    <pre><code class="prism language-bash">There are <span class="token number">30</span> section headers, starting at offset 0x1a50:

Section Headers:
  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">]</span>                   NULL             0000000000000000  00000000  <span class="token comment"># 空 Section，用于占位</span>
       0000000000000000  0000000000000000           <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>
  <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span> .interp           PROGBITS         0000000000400238  00000238  <span class="token comment"># 程序解释器路径（动态链接器）</span>
       000000000000001c  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
  <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">]</span> .note.ABI-tag     NOTE             0000000000400254  00000254  <span class="token comment"># ABI 版本信息</span>
       0000000000000020  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">]</span> .note.gnu.build-i NOTE             0000000000400274  00000274  <span class="token comment"># 构建 ID，唯一标识可执行文件</span>
       0000000000000024  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">]</span> .gnu.hash         GNU_HASH         0000000000400298  00000298  <span class="token comment"># GNU 哈希表，加速符号查找</span>
       0000000000000024  0000000000000000   A       <span class="token number">5</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span> <span class="token number">5</span><span class="token punctuation">]</span> .dynsym           DYNSYM           00000000004002c0  000002c0  <span class="token comment"># 动态符号表</span>
       00000000000000f0  0000000000000018   A       <span class="token number">6</span>     <span class="token number">1</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span> <span class="token number">6</span><span class="token punctuation">]</span> .dynstr           STRTAB           00000000004003b0  000003b0  <span class="token comment"># 动态字符串表（符号名称）</span>
       000000000000008b  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
  <span class="token punctuation">[</span> <span class="token number">7</span><span class="token punctuation">]</span> .gnu.version      VERSYM           000000000040043c  0000043c  <span class="token comment"># 符号版本信息</span>
       0000000000000014  0000000000000002   A       <span class="token number">5</span>     <span class="token number">0</span>     <span class="token number">2</span>
  <span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">]</span> .gnu.version_r    VERNEED          0000000000400450  00000450  <span class="token comment"># 符号版本需求信息</span>
       0000000000000020  0000000000000000   A       <span class="token number">6</span>     <span class="token number">1</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span> <span class="token number">9</span><span class="token punctuation">]</span> .rela.dyn         RELA             0000000000400470  00000470  <span class="token comment"># 动态重定位表</span>
       0000000000000030  0000000000000018   A       <span class="token number">5</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> .rela.plt         RELA             00000000004004a0  000004a0  <span class="token comment"># PLT（过程链接表）重定位表</span>
       00000000000000c0  0000000000000018  AI       <span class="token number">5</span>    <span class="token number">23</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> .init             PROGBITS         0000000000400560  00000560  <span class="token comment"># 程序初始化代码</span>
       000000000000001a  0000000000000000  AX       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> .plt              PROGBITS         0000000000400580  00000580  <span class="token comment"># 过程链接表（PLT）</span>
       0000000000000090  0000000000000010  AX       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">16</span>
  <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> .text             PROGBITS         0000000000400610  00000610  <span class="token comment"># 程序代码段</span>
       00000000000001e2  0000000000000000  AX       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">16</span>
  <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> .fini             PROGBITS         00000000004007f4  000007f4  <span class="token comment"># 程序终止代码</span>
       0000000000000009  0000000000000000  AX       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> .rodata           PROGBITS         0000000000400800  00000800  <span class="token comment"># 只读数据段</span>
       0000000000000024  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> .eh_frame_hdr     PROGBITS         0000000000400824  00000824  <span class="token comment"># 异常处理框架头</span>
       0000000000000034  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> .eh_frame         PROGBITS         0000000000400858  00000858  <span class="token comment"># 异常处理框架数据</span>
       00000000000000f4  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> .init_array       INIT_ARRAY       0000000000600de0  00000de0  <span class="token comment"># 初始化函数指针数组</span>
       0000000000000008  0000000000000008  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> .fini_array       FINI_ARRAY       0000000000600de8  00000de8  <span class="token comment"># 终止函数指针数组</span>
       0000000000000008  0000000000000008  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> .jcr              PROGBITS         0000000000600df0  00000df0  <span class="token comment"># Java 类注册信息</span>
       0000000000000008  0000000000000000  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> .dynamic          DYNAMIC          0000000000600df8  00000df8  <span class="token comment"># 动态链接信息</span>
       0000000000000200  0000000000000010  WA       <span class="token number">6</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> .got              PROGBITS         0000000000600ff8  00000ff8  <span class="token comment"># 全局偏移表（GOT）</span>
       0000000000000008  0000000000000008  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span> .got.plt          PROGBITS         0000000000601000  00001000  <span class="token comment"># PLT 相关的 GOT</span>
       0000000000000058  0000000000000008  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> .data             PROGBITS         0000000000601058  00001058  <span class="token comment"># 数据段</span>
       0000000000000004  0000000000000000  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
  <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> .bss              NOBITS           0000000000601060  0000105c  <span class="token comment"># 未初始化数据段</span>
       0000000000000010  0000000000000000  WA       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">16</span>
  <span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> .comment          PROGBITS         0000000000000000  0000105c  <span class="token comment"># 编译器注释信息</span>
       000000000000002d  0000000000000001  MS       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
  <span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span> .symtab           SYMTAB           0000000000000000  00001090  <span class="token comment"># 符号表</span>
       0000000000000678  0000000000000018          <span class="token number">28</span>    <span class="token number">46</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span> .strtab           STRTAB           0000000000000000  00001708  <span class="token comment"># 字符串表（符号名称）</span>
       000000000000023f  0000000000000000           <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
  <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> .shstrtab         STRTAB           0000000000000000  00001947  <span class="token comment"># Section 名称字符串表</span>
       0000000000000108  0000000000000000           <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
</code></pre>
    <blockquote>
     <p>
      <code>
       .text
      </code>
      :
     </p>
     <ul>
      <li>
       存储程序的代码段，即编译后的机器指令。
      </li>
      <li>
       包括函数、主程序、库函数等所有可执行代码。
      </li>
     </ul>
     <p>
      <code>
       .data
      </code>
      ：
     </p>
     <ul>
      <li>
       存储已初始化的全局变量，存储数据段。
      </li>
     </ul>
     <p>
      <code>
       .bss
      </code>
      （better save space）：
     </p>
     <ul>
      <li>
       为初始化的全局变量不会在
       <code>
        data
       </code>
       ，而是在
       <code>
        bss
       </code>
       中记录有多少个变量，因为所有的全局变量都是未知的，没有初始化，过于臃肿。
      </li>
      <li>
       在运行的时候会从
       <code>
        bss
       </code>
       读取，初始化为
       <code>
        0
       </code>
       。这就是为什么为初始化的变量会自动初始化为
       <code>
        0
       </code>
       的原因。
      </li>
     </ul>
    </blockquote>
    <h5>
     <a id="_Section__Segment_283">
     </a>
     查看 Section 合并的 Segment:
    </h5>
    <pre><code class="prism language-bash">$ readelf <span class="token parameter variable">-l</span> a.out
</code></pre>
    <pre><code class="prism language-bash">Elf <span class="token function">file</span> <span class="token builtin class-name">type</span> is EXEC <span class="token punctuation">(</span>Executable <span class="token function">file</span><span class="token punctuation">)</span>
Entry point 0x4003e0  <span class="token comment"># 程序入口地址</span>
There are <span class="token number">9</span> program headers, starting at offset <span class="token number">64</span>

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040  <span class="token comment"># 程序头表信息</span>
                 0x00000000000001f8 0x00000000000001f8  R E    <span class="token number">8</span>
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238  <span class="token comment"># 程序解释器路径</span>
                 0x000000000000001c 0x000000000000001c  R      <span class="token number">1</span>
      <span class="token punctuation">[</span>Requesting program interpreter: /lib64/ld-linux-x86-64.so.2<span class="token punctuation">]</span>  <span class="token comment"># 动态链接器路径</span>
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000  <span class="token comment"># 可加载段（代码段）</span>
                 0x0000000000000744 0x0000000000000744  R E    <span class="token number">200000</span>
  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10  <span class="token comment"># 可加载段（数据段）</span>
                 0x0000000000000218 0x0000000000000220  RW     <span class="token number">200000</span>
  DYNAMIC        0x0000000000000e28 0x0000000000600e28 0x0000000000600e28  <span class="token comment"># 动态链接信息</span>
                 0x00000000000001d0 0x00000000000001d0  RW     <span class="token number">8</span>
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254  <span class="token comment"># 注释信息（ABI、构建 ID）</span>
                 0x0000000000000044 0x0000000000000044  R      <span class="token number">4</span>
  GNU_EH_FRAME   0x00000000000005a0 0x00000000004005a0 0x00000000004005a0  <span class="token comment"># 异常处理框架信息</span>
                 0x000000000000004c 0x000000000000004c  R      <span class="token number">4</span>
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000  <span class="token comment"># 栈权限（RW，不可执行）</span>
                 0x0000000000000000 0x0000000000000000  RW     <span class="token number">10</span>
  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10  <span class="token comment"># 重定位只读段</span>
                 0x00000000000001f0 0x00000000000001f0  R      <span class="token number">1</span>

 Section to Segment mapping:
  Segment Sections<span class="token punctuation">..</span>.
   00     
   01     .interp  <span class="token comment"># 程序解释器路径</span>
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame  <span class="token comment"># 代码段</span>
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss  <span class="token comment"># 数据段</span>
   04     .dynamic  <span class="token comment"># 动态链接信息</span>
   05     .note.ABI-tag .note.gnu.build-id  <span class="token comment"># 注释信息</span>
   06     .eh_frame_hdr  <span class="token comment"># 异常处理框架信息</span>
   07     
   08     .init_array .fini_array .jcr .dynamic .got  <span class="token comment"># 初始化相关段</span>
</code></pre>
    <h5>
     <a id="Section__Segment__329">
     </a>
     Section 合并为 Segment 的原因与意义:
    </h5>
    <ul>
     <li>
      <strong>
       减少页面碎片
      </strong>
      ：未合并时，小块 Section 可能分散占用多个内存页面，导致浪费（页面大小为 4KB 的整数倍）。合并后，连续的 Segment 减少页面使用，优化内存效率。
     </li>
     <li>
      <strong>
       权限管理和安全
      </strong>
      ：不同 Segment 可定义不同的访问权限（如
      <code>
       .text
      </code>
      为可执行只读，
      <code>
       .data
      </code>
      为可读写），由操作系统通过内存保护机制（如 MMU）实现，提高程序安全性。
     </li>
     <li>
      <strong>
       性能优化
      </strong>
      ：连续的 Segment 加载更快，减少虚拟内存映射和页面故障（page fault）。
     </li>
     <li>
      <strong>
       知识点扩展
      </strong>
      ：
      <ul>
       <li>
        现代操作系统使用虚拟内存管理单元（MMU）将 Segment 映射到物理内存，并通过页表实现地址转换。
       </li>
       <li>
        如果程序使用动态库，加载时动态链接器（如
        <code>
         ld-linux.so
        </code>
        ）会解析
        <code>
         .dynamic
        </code>
        和
        <code>
         .got.plt
        </code>
        Section，加载共享库并绑定符号。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_341">
     </a>
     链接视图与执行视图：节头表与程序头表的区别与应用
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        链接视图（Linking View）
       </strong>
      </p>
      <ul>
       <li>
        对应**节头表（Section Header Table）**。
       </li>
       <li>
        提供细粒度的文件结构，适合静态链接分析。链接器根据节头表合并 Section，生成优化后的 Segment。
       </li>
       <li>
        <strong>
         主要内容
        </strong>
        ：
        <ul>
         <li>
          每个 Section 有自己的属性（如类型、地址、偏移、大小、权限），由节头表描述。
         </li>
         <li>
          Section 内容紧密排列在文件中，但不一定连续（地址可能虚拟分配）
         </li>
        </ul>
       </li>
       <li>
        <strong>
         常见 Section 及其作用
        </strong>
        ：
        <ul>
         <li>
          <code>
           .text
          </code>
          ：保存机器指令，是程序执行的核心，权限通常为可执行只读。
         </li>
         <li>
          <code>
           .data
          </code>
          ：保存已初始化的全局变量和局部静态变量，权限为可读写。
         </li>
         <li>
          <code>
           .rodata
          </code>
          ：保存只读数据（如字符串字面量），只能存在于只读段（通常与
          <code>
           .text
          </code>
          合并）。
         </li>
         <li>
          <code>
           .bss
          </code>
          ：为未初始化的全局变量和局部静态变量预留空间，实际数据在运行时初始化，权限为可读写。
         </li>
         <li>
          <code>
           .symtab
          </code>
          ：符号表，记录函数名、变量名与代码或数据的对应关系，用于链接阶段解析符号引用。
         </li>
         <li>
          <code>
           .rela
          </code>
          ：重定位表，记录需要调整地址的符号引用位置，链接器根据此表修正地址。
         </li>
         <li>
          <code>
           .debug
          </code>
          ：调试信息，包含源代码行号、变量名和类型等，供调试工具（如
          <code>
           gdb
          </code>
          ）使用。
         </li>
         <li>
          <code>
           .got.plt
          </code>
          ：全局偏移表和过程链接表，用于动态链接，保存共享库函数的间接引用地址，运行时由动态链接器修改。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         查看方法
        </strong>
        ：使用
        <code>
         readelf -S
        </code>
        命令查看目标文件（如
        <code>
         hello.o
        </code>
        ）或可执行文件（如
        <code>
         a.out
        </code>
        ）的节头表。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        执行视图（Execution View）
       </strong>
      </p>
      <ul>
       <li>
        对应**程序头表（Program Header Table）**。
       </li>
       <li>
        指导操作系统加载可执行文件，完成进程内存的初始化，服务于运行时的内存加载和初始化
       </li>
       <li>
        <strong>
         告诉操作系统哪些模块可以被加载进内存。
        </strong>
       </li>
       <li>
        <strong>
         加载进内存之后哪些分段是可读可写，哪些分段是只读，哪些分段是可执行的。
        </strong>
       </li>
       <li>
        包含 Segment 信息（如
        <code>
         LOAD
        </code>
        、
        <code>
         DYNAMIC
        </code>
        、
        <code>
         GNU_STACK
        </code>
        ），描述每个 Segment 的虚拟地址、文件偏移、大小、权限和对齐方式。
       </li>
       <li>
        一个
        <strong>
         可执行程序
        </strong>
        的ELF文件中一定会有
        <code>
         **Program Header Table**
        </code>
       </li>
       <li>
        <strong>
         典型 Segment 类型
        </strong>
        ：
        <ul>
         <li>
          <code>
           LOAD
          </code>
          ：需要加载到内存的代码和数据段，包含
          <code>
           .text
          </code>
          、
          <code>
           .data
          </code>
          、
          <code>
           .rodata
          </code>
          等 Section。
         </li>
         <li>
          <code>
           DYNAMIC
          </code>
          ：动态链接信息，包含共享库依赖和符号解析数据。
         </li>
         <li>
          <code>
           GNU_STACK
          </code>
          ：栈段的权限设置（通常可读写）。
         </li>
         <li>
          <code>
           GNU_RELRO
          </code>
          ：只读重定位段，保护动态链接后的数据免受修改。
         </li>
        </ul>
       </li>
       <li>
        每个程序头表项（Program Header Entry）
        <strong>
         描述一个 Segment 的属性
        </strong>
        ，包括：
        <ul>
         <li>
          类型（如 LOAD：需要加载到内存的代码或数据段，DYNAMIC：动态链接信息）。
         </li>
         <li>
          虚拟地址（加载到内存时的起始地址）。
         </li>
         <li>
          文件偏移（在文件中的起始位置）。
         </li>
         <li>
          文件大小和内存大小（可能不同，如 .bss 段在内存中扩展）。
         </li>
         <li>
          权限标志（如可读 R、可写 W、可执行 E）。
         </li>
         <li>
          对齐方式（确保内存页面对齐，通常为 4KB 的倍数）。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         查看方法
        </strong>
        ：使用
        <code>
         readelf -l
        </code>
        命令查看可执行文件的程序头表。
        <ul>
         <li>
          当文件读取到内存中的时候，操作系统通过程序头表加载 Segment 到虚拟内存，结合分页机制映射到物理内存，通过读取到的Segment的内容权限对页表进行设置对应的权限，所以一个进程在启动的时候就可以可以知道什么区域是什么权限。
         </li>
         <li>
          动态链接的程序在加载时，动态链接器（如
          <code>
           /lib64/ld-linux-x86-64.so.2
          </code>
          ）解析
          <code>
           .dynamic
          </code>
          和
          <code>
           .got.plt
          </code>
          ，加载共享库并绑定符号，确保程序运行时能访问外部函数。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      总结
     </strong>
     ：
    </p>
    <ul>
     <li>
      节头表用于链接阶段，提供 Section 级别的详细信息，服务于链接器合并和优化。
     </li>
     <li>
      程序头表用于执行阶段，指导操作系统加载和初始化内存中的 Segment，服务于程序运行。
     </li>
    </ul>
    <blockquote>
     <p>
      二者说白了就是，一个在链接时用，一个在运行时用。
     </p>
     <p>
      执行命令查看的内容在
      <code>
       3.2.2
      </code>
      中已展示。
     </p>
    </blockquote>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/583f36e2e8238026a066a74016888fbc.png"/>
    </p>
    <h4>
     <a id="_400">
     </a>
     符号表
    </h4>
    <h5>
     <a id="symtab__401">
     </a>
     <code>
      .symtab
     </code>
     符号表的基本概念
    </h5>
    <ul>
     <li>
      <strong>
       定义
      </strong>
      ：
      <code>
       .symtab
      </code>
      是 ELF 文件中的一个重要 Section（节），称为符号表（Symbol Table）。它是存储程序中符号（函数名、变量名等）及其相关信息的表格，用于描述源码中的标识符（如函数、变量）与目标文件或可执行文件中代码和数据的对应关系。
     </li>
     <li>
      <strong>
       位置
      </strong>
      ：
      <code>
       .symtab
      </code>
      通常位于目标文件（
      <code>
       .o
      </code>
      ）或可执行文件（
      <code>
       .out
      </code>
      ）中，属于链接视图（Linking View）的部分，存储在节头表（Section Header Table）中描述的 Section 中。
     </li>
     <li>
      <strong>
       作用
      </strong>
      ：
      <ul>
       <li>
        在编译和链接阶段，符号表帮助编译器和链接器解析、跟踪和绑定源码中的符号（如函数名
        <code>
         main
        </code>
        、变量
        <code>
         label
        </code>
        ），确保程序的正确连接和地址分配。
       </li>
       <li>
        在调试阶段，符号表为调试工具（如
        <code>
         gdb
        </code>
        ）提供符号信息，映射源码中的标识符到内存地址，便于定位和分析。
       </li>
       <li>
        在生产环境中，可以通过编译选项（如
        <code>
         gcc -s
        </code>
        ）去除
        <code>
         .symtab
        </code>
        ，减小文件大小，但会失去调试能力。
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      类似于数组，将每个符号分隔，独立存储。
     </p>
    </blockquote>
    <hr/>
    <h5>
     <a id="_symtab__414">
     </a>
     如何理解
     <code>
      .symtab
     </code>
     与源码的对应关系
    </h5>
    <p>
     <code>
      .symtab
     </code>
     是源码中函数名、变量名和代码对应关系的“桥梁”，具体来说：
    </p>
    <ul>
     <li>
      <strong>
       源码中的函数名和变量名
      </strong>
      ：
      <ul>
       <li>
        在 C/C++ 源码中，程序员定义了函数（如
        <code>
         int main(void)
        </code>
        ）和变量（如
        <code>
         char label[] = "helloworld";
        </code>
        ）。这些名称是人类可读的标识符。
       </li>
       <li>
        编译器在生成目标文件时，将这些标识符（符号）记录到
        <code>
         .symtab
        </code>
        中，并关联到目标文件中对应的代码（
        <code>
         .text
        </code>
        Section）或数据（
        <code>
         .data
        </code>
        、
        <code>
         .bss
        </code>
        或
        <code>
         .rodata
        </code>
        Section）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       代码的对应关系
      </strong>
      ：
      <ul>
       <li>
        编译器将源码翻译成机器代码后，函数和变量会被分配到特定的内存地址或 Section。
       </li>
       <li>
        <code>
         .symtab
        </code>
        记录每个符号的名称、类型、地址（或偏移量）、大小和所属 Section。例如：
        <ul>
         <li>
          函数
          <code>
           main
          </code>
          可能记录在
          <code>
           .text
          </code>
          Section，符号表条目显示其类型为
          <code>
           FUNC
          </code>
          （函数），地址为某个虚拟地址。
         </li>
         <li>
          变量
          <code>
           label
          </code>
          可能记录在
          <code>
           .data
          </code>
          或
          <code>
           .rodata
          </code>
          Section，符号表条目显示其类型为
          <code>
           OBJECT
          </code>
          （对象/变量），地址为数据段的偏移量。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <strong>
       未定义符号（Undefined Symbols）
      </strong>
      ：
      <ul>
       <li>
        如果源码引用了外部函数或变量（如标准库的
        <code>
         printf
        </code>
        ），但未在当前文件定义，
        <code>
         .symtab
        </code>
        会标记这些符号为
        <code>
         UND
        </code>
        （未定义），等待链接器从其他目标文件或库（如
        <code>
         libc
        </code>
        ）中解析和绑定。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="symtab__430">
     </a>
     <code>
      .symtab
     </code>
     的结构与内容
    </h5>
    <p>
     符号表（
     <code>
      .symtab
     </code>
     ）由多个符号表条目（Symbol Table Entries）组成，每个条目包含以下字段（可以通过
     <code>
      nm
     </code>
     或
     <code>
      readelf -s
     </code>
     查看）：
    </p>
    <ul>
     <li>
      <strong>
       Name
      </strong>
      ：符号的名称（如
      <code>
       main
      </code>
      、
      <code>
       label
      </code>
      、
      <code>
       printf
      </code>
      ）。
     </li>
     <li>
      <strong>
       Value
      </strong>
      ：符号的地址（在目标文件或可执行文件中，可能为 0 或虚拟地址，链接后确定）。
     </li>
     <li>
      <strong>
       Size
      </strong>
      ：符号占用的字节数（例如，函数的大小或变量的长度）。
     </li>
     <li>
      <strong>
       Type
      </strong>
      ：符号的类型，常见类型包括：
      <ul>
       <li>
        <code>
         NOTYPE
        </code>
        ：未指定类型（通常为未定义符号）。
       </li>
       <li>
        <code>
         OBJECT
        </code>
        ：变量或数据对象（如
        <code>
         label
        </code>
        ）。
       </li>
       <li>
        <code>
         FUNC
        </code>
        ：函数（如
        <code>
         main
        </code>
        ）。
       </li>
       <li>
        <code>
         SECTION
        </code>
        ：Section 本身。
       </li>
       <li>
        <code>
         FILE
        </code>
        ：源文件名称。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       Binding
      </strong>
      ：符号的绑定属性，常见绑定包括：
      <ul>
       <li>
        <code>
         LOCAL
        </code>
        ：本地符号，仅在当前文件可见。
       </li>
       <li>
        <code>
         GLOBAL
        </code>
        ：全局符号，可被其他文件引用。
       </li>
       <li>
        <code>
         WEAK
        </code>
        ：弱符号，如果未定义则可被忽略。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       Section Index
      </strong>
      ：符号所属的 Section（如
      <code>
       .text
      </code>
      、
      <code>
       .data
      </code>
      、
      <code>
       .bss
      </code>
      或
      <code>
       UND
      </code>
      表示未定义）。
     </li>
    </ul>
    <p>
     <strong>
      示例：符号表条目
     </strong>
    </p>
    <p>
     假设有一个简单的 C 源码：
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">char</span> label<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     编译生成目标文件
     <code>
      example.o
     </code>
     ：
    </p>
    <pre><code class="prism language-bash">$ gcc <span class="token parameter variable">-c</span> example.c <span class="token parameter variable">-o</span> example.o
$ nm example.o
</code></pre>
    <p>
     输出可能如下（简化）：
    </p>
    <pre><code class="prism language-plain">0000000000000000 T main           # 地址 0x0，类型 FUNC，绑定 GLOBAL，位于 .text
0000000000000000 D label          # 地址 0x0，类型 OBJECT，绑定 GLOBAL，位于 .data
                 U printf          # 未定义，类型 NOTYPE，绑定 GLOBAL，位于 UND（需链接 libc）
</code></pre>
    <ul>
     <li>
      <code>
       main
      </code>
      ：函数，存储在
      <code>
       .text
      </code>
      Section，地址为 0（可重定位文件中的相对地址，链接后确定）。
     </li>
     <li>
      <code>
       label
      </code>
      ：变量，存储在
      <code>
       .data
      </code>
      Section，地址为 0（链接后确定）。
     </li>
     <li>
      <code>
       printf
      </code>
      ：未定义符号，标记为
      <code>
       U
      </code>
      ，需从标准库
      <code>
       libc
      </code>
      中解析。
     </li>
    </ul>
    <p>
     链接生成可执行文件
     <code>
      example
     </code>
     ：
    </p>
    <pre><code class="prism language-bash">$ gcc example.o <span class="token parameter variable">-o</span> example
$ nm example
</code></pre>
    <p>
     输出中
     <code>
      main
     </code>
     和
     <code>
      label
     </code>
     的地址变为具体值（如
     <code>
      0x401000
     </code>
     ），
     <code>
      printf
     </code>
     的地址也从
     <code>
      libc
     </code>
     绑定。
    </p>
    <hr/>
    <h5>
     <a id="symtab__492">
     </a>
     <code>
      .symtab
     </code>
     的生成与使用
    </h5>
    <ul>
     <li>
      <strong>
       生成过程
      </strong>
      ：
      <ul>
       <li>
        编译器（如
        <code>
         gcc
        </code>
        ）在编译源代码时，解析源码中的函数和变量，生成目标文件（
        <code>
         .o
        </code>
        ）。
       </li>
       <li>
        编译器创建
        <code>
         .symtab
        </code>
        Section，记录符号的名称、类型和临时地址（相对于 Section 的偏移）。
       </li>
       <li>
        如果符号是外部引用（未定义），标记为
        <code>
         UND
        </code>
        ，等待链接器处理。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       使用场景
      </strong>
      ：
      <ul>
       <li>
        <strong>
         链接阶段
        </strong>
        ：链接器（如
        <code>
         ld
        </code>
        ）读取
        <code>
         .symtab
        </code>
        ，解析未定义符号（如
        <code>
         printf
        </code>
        ），从库文件（如
        <code>
         libc.a
        </code>
        或
        <code>
         libc.so
        </code>
        ）或其他目标文件中查找定义，分配最终地址。
       </li>
       <li>
        <strong>
         调试阶段
        </strong>
        ：调试工具（如
        <code>
         gdb
        </code>
        ）使用
        <code>
         .symtab
        </code>
        将源码中的函数名和变量名映射到内存地址，方便设置断点、查看变量值。
       </li>
       <li>
        <strong>
         分析阶段
        </strong>
        ：工具如
        <code>
         nm
        </code>
        和
        <code>
         readelf -s
        </code>
        可查看符号表，分析程序结构和依赖。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_symtab_504">
     </a>
     如何查看
     <code>
      .symtab
     </code>
    </h5>
    <p>
     您可以使用以下命令查看符号表：
    </p>
    <ul>
     <li>
      <strong>
       使用
       <strong>
        <code>
         nm
        </code>
       </strong>
       命令
      </strong>
      ：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ nm hello.o    <span class="token comment"># 查看目标文件的符号表</span>
$ nm a.out      <span class="token comment"># 查看可执行文件的符号表</span>
</code></pre>
    <pre><code>- 输出显示符号名称、地址、类型和 Section（如 `T` 为 `.text`，`D` 为 `.data`，`U` 为未定义）。
</code></pre>
    <ul>
     <li>
      <strong>
       使用
       <strong>
        <code>
         readelf -s
        </code>
       </strong>
       命令
      </strong>
      ：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ readelf <span class="token parameter variable">-s</span> hello.o    <span class="token comment"># 详细查看目标文件的符号表</span>
</code></pre>
    <pre><code>- 输出包括符号的名称、值、大小、类型、绑定和 Section 索引，提供更详细的信息。
</code></pre>
    <p>
     示例输出（如
     <code>
      readelf -s hello.o
     </code>
     ）：
    </p>
    <pre><code class="prism language-plain">Symbol table '.symtab' contains 13 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000000    17 OBJECT  GLOBAL DEFAULT    3 label
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT    1 main
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
</code></pre>
    <ul>
     <li>
      <code>
       label
      </code>
      ：
      <code>
       OBJECT
      </code>
      类型，
      <code>
       GLOBAL
      </code>
      绑定，位于 Section 3（可能为
      <code>
       .data
      </code>
      或
      <code>
       .rodata
      </code>
      ），大小为 17 字节（字符串
      <code>
       "helloworld\0"
      </code>
      的长度加终止符）。
     </li>
     <li>
      <code>
       main
      </code>
      ：
      <code>
       FUNC
      </code>
      类型，
      <code>
       GLOBAL
      </code>
      绑定，位于 Section 1（
      <code>
       .text
      </code>
      ），大小为 0（实际大小由链接后确定）。
     </li>
     <li>
      <code>
       printf
      </code>
      ：
      <code>
       NOTYPE
      </code>
      类型，
      <code>
       GLOBAL
      </code>
      绑定，位于
      <code>
       UND
      </code>
      （未定义），需链接器从
      <code>
       libc
      </code>
      解析。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_543">
     </a>
     注意事项
    </h5>
    <ul>
     <li>
      <strong>
       去除符号表
      </strong>
      ：在生产环境中，为了减小文件大小，可以使用
      <code>
       strip
      </code>
      命令去除
      <code>
       .symtab
      </code>
      和调试信息：
     </li>
    </ul>
    <pre><code class="prism language-bash">$ strip hello.o    <span class="token comment"># 去除符号表和调试信息</span>
</code></pre>
    <p>
     但这会使调试变得困难。
    </p>
    <ul>
     <li>
      <strong>
       动态链接与符号表
      </strong>
      ：
      <ul>
       <li>
        可执行文件可能还有
        <code>
         .dynsym
        </code>
        （动态符号表），用于动态链接，记录与共享库相关的符号（如
        <code>
         libc
        </code>
        中的函数）。
       </li>
       <li>
        <code>
         .symtab
        </code>
        和
        <code>
         .dynsym
        </code>
        的区别在于：
        <code>
         .symtab
        </code>
        包含所有符号（包括本地和全局），而
        <code>
         .dynsym
        </code>
        只包含与动态链接相关的全局符号。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       符号表的大小
      </strong>
      ：
      <code>
       .symtab
      </code>
      可能占较大空间，尤其在包含大量函数和变量的程序中。通过优化代码或使用
      <code>
       gcc -fvisibility=hidden
      </code>
      减少导出符号，可以减小符号表大小。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_symtab_559">
     </a>
     总结：如何理解
     <code>
      .symtab
     </code>
    </h5>
    <ul>
     <li>
      <strong>
       本质
      </strong>
      ：
      <code>
       .symtab
      </code>
      是源码中函数名、变量名和代码对应关系的“映射表”，记录程序的符号及其在目标文件或可执行文件中的位置和属性。
     </li>
     <li>
      <strong>
       作用
      </strong>
      ：
      <ul>
       <li>
        帮助链接器解析和绑定符号，确保程序正确连接。
       </li>
       <li>
        辅助调试工具定位源码和内存地址之间的关系。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       对应关系
      </strong>
      ：
      <ul>
       <li>
        源码中的
        <code>
         int main(void)
        </code>
        对应
        <code>
         .symtab
        </code>
        中的
        <code>
         main
        </code>
        条目，指向
        <code>
         .text
        </code>
        Section 的代码。
       </li>
       <li>
        源码中的
        <code>
         char label[] = "helloworld";
        </code>
        对应
        <code>
         .symtab
        </code>
        中的
        <code>
         label
        </code>
        条目，指向
        <code>
         .data
        </code>
        或
        <code>
         .rodata
        </code>
        Section 的数据。
       </li>
       <li>
        外部引用（如
        <code>
         printf
        </code>
        ）标记为未定义（
        <code>
         UND
        </code>
        ），链接时从标准库（如
        <code>
         libc
        </code>
        ）解析。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       查看与验证
      </strong>
      ：使用
      <code>
       nm
      </code>
      、
      <code>
       readelf -s
      </code>
      查看符号表，结合源码和目标文件理解符号的定义和引用。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="ELF__572">
     </a>
     ELF 头信息与文件结构
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/e7ab5c14779c1fecf91b61526ef96b10.png"/>
    </p>
    <p>
     ELF 头（ELF Header）位于文件开头，
     <strong>
      描述文件的基本信息，并定位程序头表和节头表
     </strong>
     。
    </p>
    <p>
     <strong>
      查看目标文件（
     </strong>
     <code>
      **.o**
     </code>
     ** 文件）**
    </p>
    <pre><code class="prism language-bash">$ readelf <span class="token parameter variable">-h</span> hello.o
ELF Header:
  Magic:   7f <span class="token number">45</span> 4c <span class="token number">46</span> 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64    <span class="token comment"># 64 位 ELF 文件</span>
  Data:                              <span class="token number">2</span>'s complement, little endian    <span class="token comment"># 小端字节序</span>
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>    <span class="token comment"># ELF 格式版本</span>
  OS/ABI:                            UNIX - System V    <span class="token comment"># 目标操作系统</span>
  ABI Version:                       <span class="token number">0</span>    <span class="token comment"># ABI 版本</span>
  Type:                              REL <span class="token punctuation">(</span>Relocatable <span class="token function">file</span><span class="token punctuation">)</span>    <span class="token comment"># 文件类型为可重定位文件</span>
  Machine:                           Advanced Micro Devices X86-64    <span class="token comment"># 目标架构</span>
  Version:                           0x1
  Entry point address:               0x0    <span class="token comment"># 入口地址（可重定位文件无入口）</span>
  Start of program headers:          <span class="token number">0</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>    <span class="token comment"># 程序头表偏移（目标文件无程序头表）</span>
  Start of section headers:          <span class="token number">728</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>    <span class="token comment"># 节头表偏移</span>
  Flags:                             0x0    <span class="token comment"># 特定标志（无特殊标志）</span>
  Size of this header:               <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>    <span class="token comment"># ELF 头大小</span>
  Size of program headers:           <span class="token number">0</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>    <span class="token comment"># 程序头表项大小（目标文件无程序头表）</span>
  Number of program headers:         <span class="token number">0</span>    <span class="token comment"># 程序头表项数量</span>
  Size of section headers:           <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>    <span class="token comment"># 节头表项大小</span>
  Number of section headers:         <span class="token number">13</span>    <span class="token comment"># 节头表项数量</span>
  Section header string table index: <span class="token number">12</span>    <span class="token comment"># 节名字符串表的索引</span>
</code></pre>
    <p>
     <strong>
      查看可执行文件
     </strong>
    </p>
    <pre><code class="prism language-bash">$ gcc *.o <span class="token parameter variable">-o</span> a.out
$ readelf <span class="token parameter variable">-h</span> a.out
ELF Header:
  Magic:   7f <span class="token number">45</span> 4c <span class="token number">46</span> 02 01 01 00 00 00 00 00 00 00 00 00 <span class="token comment"># ELF文件的标识符</span>
  Class:                             ELF64
  Data:                              <span class="token number">2</span>'s complement, little endian
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - System V
  ABI Version:                       <span class="token number">0</span>
  Type:                              DYN <span class="token punctuation">(</span>Shared object <span class="token function">file</span><span class="token punctuation">)</span>    <span class="token comment"># 文件类型为共享对象（可执行文件）</span>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060    <span class="token comment"># 程序入口地址</span>
  Start of program headers:          <span class="token number">64</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>    <span class="token comment"># 程序头表偏移</span>
  Start of section headers:          <span class="token number">14768</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>    <span class="token comment"># 节头表偏移</span>
  Flags:                             0x0
  Size of this header:               <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">56</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">13</span>
  Size of section headers:           <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">31</span>
  Section header string table index: <span class="token number">30</span>
</code></pre>
    <p>
     <strong>
      ELF 头的作用：
     </strong>
    </p>
    <ul>
     <li>
      ELF 头定义了文件的基本特性（如架构、字节序、文件类型）和结构布局（如程序头表和节头表的偏移量）。
     </li>
     <li>
      <code>
       Magic
      </code>
      （魔数
      <code>
       7f 45 4c 46
      </code>
      ），每个二进制文件都有，随机，系统可以通过
      <code>
       magic
      </code>
      标识文件为 ELF 格式，防止误解析。
      <ul>
       <li>
        例如图片会解析为图片，按照图片格式打开，视频会解析为视频格式，按照视频格式打开，
        <code>
         exe
        </code>
        会直接运行。
       </li>
      </ul>
     </li>
     <li>
      <code>
       Type
      </code>
      字段区分文件类型：
      <code>
       REL
      </code>
      （可重定位）、
      <code>
       EXEC
      </code>
      （可执行）、
      <code>
       DYN
      </code>
      （共享对象）。
     </li>
     <li>
      程序头表和节头表的偏移量（
      <code>
       Start of program headers
      </code>
      和
      <code>
       Start of section headers
      </code>
      ）用于定位文件的其他部分，确保解析器正确读取数据。
     </li>
     <li>
      可执行文件的入口地址（
      <code>
       Entry point address
      </code>
      ）指定程序启动时的起始指令地址（通常指向用于存储代码的
      <code>
       .text
      </code>
      Section 的起始位置）。
     </li>
    </ul>
    <h4>
     <a id="_641">
     </a>
    </h4>
    <h3>
     <a id="font_stylecolorrgb313541ELFfont_642">
     </a>
     ELF区域和文件偏移量之间的关系
    </h3>
    <blockquote>
     <p>
      <strong>
       ELF 文件的整体结构：像一本书
      </strong>
     </p>
    </blockquote>
    <p>
     想象 ELF 文件是一本书，每个部分都有自己的“页码”（偏移量）和作用：
    </p>
    <ul>
     <li>
      <strong>
       ELF 头
      </strong>
      是封面和目录，告诉你这本书的基本信息和结构。
     </li>
     <li>
      <strong>
       程序头表
      </strong>
      是搬运清单，告诉操作系统如何把书的内容搬到内存。
     </li>
     <li>
      <strong>
       节（Sections）
      </strong>
      是书的章节，包含具体的代码、数据等内容。
     </li>
     <li>
      <strong>
       节头表
      </strong>
      是详细目录，记录每个章节的位置和属性。
      <br/>
      偏移量就像页码，告诉你每个部分从文件的哪一“页”开始。下面，我们逐一拆解这些部分和它们在文件中的偏移量关系。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="ELF_HeaderELF__656">
     </a>
     ELF Header（ELF 头）
    </h4>
    <ul>
     <li>
      <strong>
       位置
      </strong>
      ：文件的最开头，偏移量固定为 0。
     </li>
     <li>
      <strong>
       作用
      </strong>
      ：ELF 头是整个文件的“门面”，提供文件的基本信息和导航指南。
     </li>
     <li>
      <strong>
       内容
      </strong>
      ：
      <ul>
       <li>
        文件类型（例如，可执行文件、共享库、目标文件）。
       </li>
       <li>
        目标架构（例如 x86、ARM）。
       </li>
       <li>
        程序头表和节头表的起始偏移量（分别由字段
        <code>
         e_phoff
        </code>
        和
        <code>
         e_shoff
        </code>
        指定）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       偏移量关系
      </strong>
      ：
      <ul>
       <li>
        因为它是文件的起点，偏移量始终是 0。
       </li>
       <li>
        它的大小通常是固定的（比如 52 字节或 64 字节，取决于 32 位或 64 位架构），所以下一个区域（通常是程序头表）的偏移量从 ELF 头结束处开始。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       通俗理解
      </strong>
      ：
      <br/>
      ELF 头就像书的封面，告诉你这本书是小说还是教材（文件类型），适合谁看（架构），以及“正文”（程序头表）和“目录”（节头表）从哪页开始。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="Program_Header_Table_671">
     </a>
     Program Header Table（程序头表）
    </h4>
    <ul>
     <li>
      <strong>
       位置
      </strong>
      ：通常紧随 ELF 头之后，但具体偏移量由 ELF 头中的
      <code>
       e_phoff
      </code>
      字段指定。
     </li>
     <li>
      <strong>
       作用
      </strong>
      ：程序头表是一张“搬运清单”，告诉操作系统如何将文件加载到内存中运行。
     </li>
     <li>
      <strong>
       内容
      </strong>
      ：
      <ul>
       <li>
        描述了文件中的段（Segment），比如代码段（
        <code>
         .text
        </code>
        ）、数据段（
        <code>
         .data
        </code>
        ）等。
       </li>
       <li>
        每个段的信息包括：文件偏移量（从文件开头计算）、虚拟内存地址、大小、权限（可读、可写、可执行）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       偏移量关系
      </strong>
      ：
      <ul>
       <li>
        它的起始位置由
        <code>
         e_phoff
        </code>
        决定。例如，如果
        <code>
         e_phoff = 64
        </code>
        ，意味着程序头表从文件第 64 字节开始。
       </li>
       <li>
        程序头表是一个连续的表格，每个条目大小固定（32 位系统是 32 字节，64 位是 56 字节），条目数量由 ELF 头中的
        <code>
         e_phnum
        </code>
        指定。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       通俗理解
      </strong>
      ：
      <br/>
      程序头表就像物流清单，告诉搬运工（操作系统）：“把这部分货物（段）搬到内存的这个地址，注意有些货物只能看（只读），有些可以改（可写）。” 它的“页码”（偏移量）由 ELF 头告诉你。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="SectionsSection_1Section_2_685">
     </a>
     Sections（节，Section 1、Section 2、…）
    </h4>
    <ul>
     <li>
      <strong>
       位置
      </strong>
      ：通常在程序头表之后，但具体位置由节头表中的条目指定，可能是分散的。
     </li>
     <li>
      <strong>
       作用
      </strong>
      ：节是文件的“逻辑章节”，用来组织代码、数据和元信息，方便链接器和调试工具使用。
     </li>
     <li>
      <strong>
       内容
      </strong>
      ：
      <ul>
       <li>
        常见的节包括：
        <ul>
         <li>
          <code>
           .text
          </code>
          ：存储程序的机器代码。
         </li>
         <li>
          <code>
           .data
          </code>
          ：存储初始化过的全局变量。
         </li>
         <li>
          <code>
           .bss
          </code>
          ：存储未初始化的全局变量（不占文件空间，只记录大小）。
         </li>
         <li>
          <code>
           .symtab
          </code>
          ：存储符号表（函数名、变量名等）。
         </li>
        </ul>
       </li>
       <li>
        每个节有自己的类型、大小和文件偏移量。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       偏移量关系
      </strong>
      ：
      <ul>
       <li>
        每个节的起始偏移量记录在节头表中（后面会讲到）。
       </li>
       <li>
        这些偏移量是从文件开头计算的字节数。例如，
        <code>
         .text
        </code>
        节可能从偏移量 1024 开始，
        <code>
         .data
        </code>
        节从 2048 开始。
       </li>
       <li>
        节的位置不一定是连续的，可能根据文件类型（目标文件、可执行文件）有所不同。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       通俗理解
      </strong>
      ：
      <br/>
      节就像书中的章节，每章有不同的内容（代码、数据、符号表），但具体从哪页开始要看“目录”（节头表）。操作系统运行程序时不直接用节，而是通过段来加载它们。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="Section_Header_Table_704">
     </a>
     Section Header Table（节头表）
    </h4>
    <ul>
     <li>
      <strong>
       位置
      </strong>
      ：通常在文件末尾，具体偏移量由 ELF 头中的
      <code>
       e_shoff
      </code>
      字段指定。
     </li>
     <li>
      <strong>
       作用
      </strong>
      ：节头表是一张“详细目录”，记录所有节的属性和位置，方便链接器或调试工具查找。
     </li>
     <li>
      <strong>
       内容
      </strong>
      ：
      <ul>
       <li>
        每个节的条目包括：名称、类型、文件偏移量、大小、权限等。
       </li>
       <li>
        例如，一个条目可能说：
        <code>
         .text
        </code>
        节从偏移量 1024 开始，大小 512 字节，可执行。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       偏移量关系
      </strong>
      ：
      <ul>
       <li>
        它的起始位置由
        <code>
         e_shoff
        </code>
        决定。例如，
        <code>
         e_shoff = 5000
        </code>
        意味着节头表从文件第 5000 字节开始。
       </li>
       <li>
        节头表也是一个连续的表格，每个条目大小固定（32 位系统是 40 字节，64 位是 64 字节），条目数量由 ELF 头中的
        <code>
         e_shnum
        </code>
        指定。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       通俗理解
      </strong>
      ：
      <br/>
      节头表就像书的详细目录，告诉你：“第 1 章（
      <code>
       .text
      </code>
      ）从 10 页开始，讲故事；第 2 章（
      <code>
       .data
      </code>
      ）从 20 页开始，放插图。” 它的“页码”（偏移量）由 ELF 头指明。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_718">
     </a>
     整体偏移量关系总结
    </h4>
    <p>
     ELF 文件中的每个区域通过偏移量紧密关联，以下是它们的位置和依赖关系：
    </p>
    <ul>
     <li>
      <strong>
       ELF 头
      </strong>
      ：偏移量 0，固定在开头，告诉我们程序头表（
      <code>
       e_phoff
      </code>
      ）和节头表（
      <code>
       e_shoff
      </code>
      ）的偏移量。
     </li>
     <li>
      <strong>
       程序头表
      </strong>
      ：偏移量由
      <code>
       e_phoff
      </code>
      指定，描述段的偏移量和内存映射。
     </li>
     <li>
      <strong>
       节（Sections）
      </strong>
      ：偏移量由节头表指定，可能分散在文件中，存储具体内容。
     </li>
     <li>
      <strong>
       节头表
      </strong>
      ：偏移量由
      <code>
       e_shoff
      </code>
      指定，通常在末尾，记录所有节的偏移量和属性。
     </li>
    </ul>
    <h5>
     <a id="_726">
     </a>
     图解（假设的偏移量示例）
    </h5>
    <pre><code class="prism language-plain">文件偏移量 (字节):
0          64          128         1024       2048       5000
|----------|-----------|-----------|----------|----------|----------|
ELF 头     程序头表    (其他内容)  .text 节   .data 节   节头表
</code></pre>
    <ul>
     <li>
      ELF 头（0-64 字节）：告诉我们程序头表从 64 开始，节头表从 5000 开始。
     </li>
     <li>
      程序头表（64-128 字节）：描述段的偏移量（如 .text 从 1024 开始）。
     </li>
     <li>
      节（1024、2048 等）：具体内容的位置由节头表指定。
     </li>
     <li>
      节头表（5000 开始）：记录 .text 在 1024，.data 在 2048。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="SectionSegment_741">
     </a>
     节（Section）与段（Segment）的偏移量区别
    </h4>
    <ul>
     <li>
      <strong>
       段
      </strong>
      ：由程序头表管理，用于内存加载。一个段可能包含多个节（比如
      <code>
       .text
      </code>
      和
      <code>
       .rodata
      </code>
      合成一个只读段）。段的偏移量记录在程序头表中。
     </li>
     <li>
      <strong>
       节
      </strong>
      ：由节头表管理，用于链接和调试。节的偏移量记录在节头表中，可能与段的偏移量重叠。
     </li>
     <li>
      <strong>
       通俗理解
      </strong>
      ：段是大箱子，装着几个小盒子（节）。搬家时（加载内存）看箱子清单（程序头表），整理东西时（链接调试）看盒子标签（节头表）。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_748">
     </a>
     为什么要理解偏移量关系？
    </h4>
    <ul>
     <li>
      <strong>
       文件结构分析
      </strong>
      ：通过偏移量，可以用工具（如
      <code>
       readelf
      </code>
      或
      <code>
       objdump
      </code>
      ）定位 ELF 文件的每一部分。
     </li>
     <li>
      <strong>
       内存映射
      </strong>
      ：程序头表的偏移量决定了程序运行时如何加载到内存。
     </li>
     <li>
      <strong>
       调试与链接
      </strong>
      ：节头表的偏移量帮助查找代码、数据或符号的具体位置。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="ELF__755">
     </a>
     总结：ELF 文件就像一本书的搬家过程
    </h4>
    <ul>
     <li>
      <strong>
       ELF 头
      </strong>
      （封面）：告诉你书的类型和目录页码。
     </li>
     <li>
      <strong>
       程序头表
      </strong>
      （搬运清单）：告诉操作系统怎么把书的内容搬到内存。
     </li>
     <li>
      <strong>
       节
      </strong>
      （章节）：书的实际内容，位置由目录指定。
     </li>
     <li>
      <strong>
       节头表
      </strong>
      （目录）：详细记录每个章节的页码和信息。
      <br/>
      偏移量是这些部分的“导航坐标”，ELF 头是起点，程序头表和节头表是指路牌，带你找到每个区域的具体位置。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f534446736f756c2f:61727469636c652f64657461696c732f313436313033383334" class_="artid" style="display:none">
 </p>
</div>


