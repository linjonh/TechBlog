---
layout: post
title: "嵌入式系统数据无损压缩"
date: 2024-12-10 15:28:34 +0800
description: "嵌入式系统中的数据无损压缩,主要是来源于对于数据传输或者存贮的空间的需求,另外由于嵌入式系统的资源限"
keywords: "嵌入式压缩算法"
categories: ['未分类']
tags: ['嵌入式', '图片', '压缩']
artid: "103421247"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=103421247
  alt: "嵌入式系统数据无损压缩"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=103421247
featuredImagePreview: https://bing.ee123.net/img/rand?artid=103421247
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     嵌入式系统数据无损压缩
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     嵌入式系统中的数据无损压缩,主要是来源于对于数据传输或者存贮的空间的需求,另外由于嵌入式系统的资源限制,因此对于压缩效率,MIPS和内存的需求是选择一个压缩/解压算法的需要平衡的三个条件.
    </p>
    <p>
     对于嵌入式系统来说,通常可能在以下一些场合需要使用压缩和解压缩算法:
    </p>
    <p>
     1)FIRMWARE
    </p>
    <p>
     2)需要传输或者保存的数据
    </p>
    <p>
     3)字库的压缩
    </p>
    <p>
     4)GUI系统的图片的压缩
    </p>
    <p>
     1)FIRMWARE
    </p>
    <p>
     对于FIRMWARE的压缩,常用易用的压缩/解压缩算法是ZLIB,这个压缩算法比较好的均衡了压缩率和解压时间,通常,压缩率大概在50%左右,解压的过程大概在1KB/S/MIPS,需要的解压的内存是比较小的,通常在几十KB.
    </p>
    <p>
     如果你希望获取比ZLIB更高的压缩效率,可以尝试使用LZMA,LZMA对于一般的FIRMWARE的压缩效率比ZLIB要高一些,基本上可以压缩到原大小的1/3左右,但是对于嵌入式系统来说,不要去尝试使用这个压缩工具进行压缩,压缩需要的MIPS和时间是比较长的,基本上低MIPS的系统是很难忍受的,但是解压是另外的一面,解压的速度比ZLIB要慢不少,有时候为了获取高压缩率,这个压缩算法也是可以值得尝试的.
    </p>
    <p>
     另外一种可以尝试的压缩方法是LZO,压缩率比较低,大概只能压缩到原来的文件大小的2/3,但是它提供了超快的解压速度和0内存需求,实际测试由ADS编译出来的ARM系统的FIRMEWARE解压速度可以到10KB/S/MIPS,也就是说如果你有一个200MHz的CPU,一般情况下你可以在一秒内解压2MB的FIRMWARE,这个对于很多系统来说是足够了.
    </p>
    <p>
     2)需要传输或者保存的数据
    </p>
    <p>
     对于类似文本类的或者其它相关性强的数据,如果考虑到存储空间或者传输效率,有时候使用压缩算法也是一个比较好的选择,LZO是首选,当然你也可以使用ZLIB, CMMB的ESG数据就是使用ZLIB进行压缩的.
    </p>
    <p>
     3)字库的压缩
    </p>
    <p>
     对于需要使用中文界面的嵌入式系统来说,字库对于整个FIRMWARE大小是贡献比较大的,一般小型的GUI是无法使用矢量字库的,因此常见的情况是使用某个特定大小的字库,如果字库是按照GBK方式进行排序的,那么字库相对来说会小一些,因为GBK是连续的,但是如果使用UNICODE方式排序的字库,那么字库的压缩是一件比较麻烦的事情.
    </p>
    <p>
     常用的字库的压缩包括了分段法和字库本身的压缩,但是考虑到嵌入式系统的CPU的速度,一般字库本身不大会去压缩.
    </p>
    <p>
     4)GUI系统的图片的压缩
    </p>
    <p>
     使用BMP图片对于一个希望用很多图片的系统是蛮可怕的,虽然BMP的DRAW相对很简单,但是实在是太大了.
    </p>
    <p>
     如果CPU速度还不错,内存也蛮多的,那么PNG的格式应该是个很好的选择,无损,又支持ALPHA
    </p>
    <p>
     但是对于一些嵌入式系统来说,可能更希望直接能ON TIME DRAW的图像,这些图像在实际的应用中不希望每次都先去解码然后再DRAW,那么可以参考PNG的方式对原始的点阵图像进行压缩,并在DRAW的时候复原图像,由于仅仅使用了简单的算术编码方式,所以DRAW的速度实际上证明也是相当快的,一下是一个DRAW的函数,你应该可以猜出反向的算法:
    </p>
    <p>
     //直接填充一块RLE图片,need make sure it is the same size
     <br/>
     void CL_RLE_DRAW(unsigned short sx, unsigned short sy, unsigned short width, unsigned short heigh, unsigned short *pGRAM,const unsigned short *pIcon)
     <br/>
     {
     <!-- -->
     <br/>
     unsigned short i,j;
    </p>
    <p>
     unsigned short Val,Count;
    </p>
    <p>
     i=0;
     <br/>
     j=0;
    </p>
    <p>
     while(j&lt;heigh)
     <br/>
     {
     <!-- -->
     <br/>
     Val=*pIcon;
     <br/>
     if(Val&amp;0x8000)
     <br/>
     {
     <!-- -->
     <br/>
     Count = (Val &amp; 0x7fff) + 1;
     <br/>
     while (Count–)
     <br/>
     {
     <!-- -->
     <br/>
     *pIcon++;
     <br/>
     Val=
     <em>
      pIcon;
      <br/>
      pGRAM[320
     </em>
     (sy+j)+(sx+i)] =Val;
     <br/>
     i++;
     <br/>
     if(i==width)
     <br/>
     {
     <!-- -->
     <br/>
     j++;
     <br/>
     i=0;
     <br/>
     }
    </p>
    <p>
     }
     <br/>
     *pIcon++;
    </p>
    <p>
     }
     <br/>
     else
     <br/>
     {
     <!-- -->
    </p>
    <p>
     Count=Val+1;
     <br/>
     *pIcon++;
    </p>
    <p>
     Val=
     <em>
      pIcon;
      <br/>
      while(Count–)
      <br/>
      {
      <!-- -->
      <br/>
      pGRAM[320
     </em>
     (sy+j)+(sx+i)] =Val;
     <br/>
     i++;
     <br/>
     if(i==width)
     <br/>
     {
     <!-- -->
     <br/>
     j++;
     <br/>
     i=0;
     <br/>
     }
     <br/>
     }
     <br/>
     *pIcon++;
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     }
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031303436363939372f:61727469636c652f64657461696c732f313033343231323437" class_="artid" style="display:none">
 </p>
</div>
