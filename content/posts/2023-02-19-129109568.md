---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35333032323831332f:61727469636c652f64657461696c732f313239313039353638"
layout: post
title: "软件工程导论第六版第5章-总体设计复习笔记"
date: 2023-02-19 13:55:39 +08:00
description: "文章探讨了软件设计的基本目的和任务，强调了模块化、抽象、逐步求精、信息隐藏和局部化以及模块独立性的重"
keywords: "软件工程总体设计笔记"
categories: ['计算机专业相关课程学习笔记']
tags: ['软件工程', '数据库']
artid: "129109568"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=129109568
    alt: "软件工程导论第六版第5章-总体设计复习笔记"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=129109568
featuredImagePreview: https://bing.ee123.net/img/rand?artid=129109568
---

# [软件工程导论(第六版)]第5章 总体设计（复习笔记）

> #### 文章目录
>
> * + [5.1 设计过程](#51__12)
>   + [5.2 设计原理](#52__32)
>   + - [5.2.1 模块化](#521__33)
>     - [5.2.2 抽象](#522__43)
>     - [5.2.3 逐步求精](#523__52)
>     - [5.2.4 信息隐藏和局部化](#524__62)
>     - [5.2.5 模块独立](#525__69)
>   + [5.3 启发规则](#53__110)
>   + [5.4 描绘软件结构的图形工具](#54__130)
>   + - [5.4.1 层次图](#541__131)
>     - [5.4.2 HIPO图](#542_HIPO_139)
>     - [5.4.3 结构图](#543__144)
>   + [5.5 面向数据流的设计方法](#55__158)

---

* 目的
  + 总体设计的基本目的就是回答“概括地说，系统应该如何实现”这个问题。
* 总体设计又称为概要设计或初步设计
* 主要任务
  + （1）划分出组成系统的物理元素——程序、文件、数据库、人工过程和文档等。
  + （2）确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。
  + 【注意】每个物理元素的具体实现是详细阶段的任务。
* 必要性
  + 可以站在全局高度上，以较少的成本选出最佳方案和最合理的软件结构并开发出较高质量的软件系统。

### 5.1 设计过程

* 设计过程的两个主要组成阶段
  + （1）系统设计阶段，确定系统的具体实现方案。
  + （2）结构设计阶段，确定软件结构。
* 典型的总体设计过程
  + ①设想供选择的方案；
  + ②选取合理的方案
  + ③推荐最佳方案
  + ④功能分解
  + ⑤设计软件结构
  + ⑥设计数据库
  + ⑦制定测试计划
  + ⑧书写文档
    - 系统说明
    - 用户手册
    - 测试计划
    - 详细的实现计划
    - 数据库设计结果
  + ⑨审查和复查。

### 5.2 设计原理

#### 5.2.1 模块化

* （1）定义
  + 模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。
* （2）优点
  + ① 使软件结构清晰，不仅容易设计也容易阅读和理解。
  + ② 使软件容易测试和调试，有助于提高软件的可靠性。
  + ③ 提高软件的可修改性。
  + ④ 有助于软件开发工程的组织管理。
* 【注意】模块是构成程序的基本构件。

#### 5.2.2 抽象

* （1）定义
  + 抽象就是抽出事物的本质特性而暂时不考虑它们的细节。
* （2）优点
  + ① 简化了软件的设计和实现；
  + ② 提高了软件的可理解性和可测试性；
  + ③ 使得软件更容易维护。
* 软件工程过程的每一步都是对软件解法的抽象层次的一次精化

#### 5.2.3 逐步求精

* （1）定义
  + 定义为：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。
* （2）原理
  + ① 逐步求精是一种自顶向下的设计策略。
  + ② 求精实际上是细化过程。
* 逐步求精如此重要？
  + 因为人类的认知过程遵循Miller法则，一个人在任何时候都只能把注意力集中在（7+2）个知识块上
* 抽象与求精是一对互补概念

#### 5.2.4 信息隐藏和局部化

* （1）局部化定义
  + 指把一些关系密切的软件元素物理地放得彼此靠近。
* （2）信息隐藏原理
  + 使得一个模块内包含的信息（主要是实现细节）对于不需要这些信息的模块来说，是不能访问的。
* 局部化有助于信息隐藏

#### 5.2.5 模块独立

* （1）定义
  + 开发的模块具有独立功能而且和其他模块之间没有过多的相互作用的模块，就可以做到模块独立。
  + 模块独立的概念是模块化、抽象、信息隐藏和局部化的直接结果。
* （2）模块的独立程度由两个定性标准衡量：耦合和内聚。
* （3）耦合
  + ① 定义
    - 耦合是对一个软件结构内不同模块之间互连程度的度量。
  + ② 分类
    - a. 完全独立，模块间没有任何连接；
    - b. 数据耦合，模块之间仅通过交换数据来交换信息；
    - c．控制耦合，模块之间传递的信息有控制信息；
    - d．特征耦合，传递的数据为整个数据结构，但只使用其中的一部分数据元素；
    - e.公共环境耦合，模块之间通过公共数据环境相互作用；
    - f.内容耦合
      * 模块访问模块内部数据
      * 模块进入另一个模块没有通过正常入口
      * 模块之间部分程序代码重叠
      * 一个模块有多个入口
    - 数据耦合<公共环境耦合<特征耦合<控制耦合<内容耦合（越低越好）
* （4）内聚
  + ① 定义
    - 内聚衡量一个模块内部各个元素彼此结合的紧密程度。
  + ② 分类
    - 偶然内聚，模块内任务的关系松散
    - 逻辑内聚，模块完成的任务逻辑上属于相同或类似的一类
    - 时间内聚，模块的任务必须在同一时间段执行
    - 过程内聚，模块内处理元素相关且按一定的次序
    - 通信内聚，模块中所有元素使用同一个输入或产生同一个的输出
    - 顺序内聚，模块中的功能必须顺序执行
    - 功能内聚，模块中所有处理元素属于一个整体，完成一个单一的功能
    - ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bfd6fdb791aef79f2abd3e43c4dd1763.png)
    - 低内聚（偶然内聚<逻辑内聚<时间内聚）
    - 中内聚（过程内聚<通信内聚）
    - 高内聚（顺序内聚<功能内聚）
* 【注意】考生牢记：设计的软件尽量满足“高内聚、低耦合”和“高扇入、低扇出”原则。
* 模块独立性比较强的模块应该是具有高内聚性和低耦合度。
* 在进行软件结构设计时应该遵循的最主要的原理是模块独立原理；
* 自顶向下逐步求精是进行软件结构设计的常用途径；
* 抽象和逐步求精是互补的。

### 5.3 启发规则

* 改进软件结构提高模块独立性
* 模块规模应该适中
* 深度、宽度、扇出和扇入都应适当
  + （1）深度
    - 深度表示软件结构中控制的层数。
  + （2）宽度
    - 宽度是软件结构内同一个层次上的模块总数的最大值。宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。
  + （3）扇出
    - 扇出是一个模块直接控制的模块数目。
  + （4）扇入
    - 扇入表明有多少个上级模块直接调用它。
* 模块的作用域应该在控制域之内
  + （1）定义
    - ① 模块的作用域定义为受该模块内一个判定影响的所有模块的集合。
    - ② 模块的控制域是这个模块本身以及所有直接或间接从属于它的模块的集合。
* 力争降低模块接口的复杂程度
* 设计单入口单出口的模块
* 模块功能应该可以预测

### 5.4 描绘软件结构的图形工具

#### 5.4.1 层次图

* （1）作用
  + 层次图用来描绘软件的层次结构。
* （2）符号
  + ① 矩形框代表一个模块。
  + ② 方框间的连线表示调用关系。
* ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fd1d78d230949c7ecef1f32ac680694d.png)

#### 5.4.2 HIPO图

* HIPO图是“层次图加输入/处理/输出图”的缩写。
* 在层次图里除了最顶层的方框外，每个方框都加了编号。
* ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/77aa4e0bccb6e95d3247b320576fab43.png)

#### 5.4.3 结构图

* 结构图的符号表示分为两类：
* （1）基本符号
  + ① 方框代表一个模块，框内注明模块的名字或主要功能；
  + ② 方框之间的箭头（或直线）表示模块的调用关系；
  + ③ 尾部是空心圆的箭头表示传递的是数据，实心圆的箭头表示传递的是控制信息。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/77e2364a9ff40a6ce9bb938b8a8d7090.png)
* （2）特殊符号
  + ① 表示当模块M中某个判定为真时调用模块A，为假时调用模块B，如图所示；
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f759d51f668f94dc4eeced192f6d6934.png)
  + ② 表示模块M循环调用模块A、B和C，如图所示。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/577b345071d2df79c17fcafa30c90b3b.png)

### 5.5 面向数据流的设计方法

* 面向数据流的设计方法的目标：给出设计软件结构的一个系统化的途径
* 通常使用数据流图描绘信息在系统中加工和流动的情况
* 结构化设计方法是基于数据流的设计方法
* 信息流的类型
  + （1）变换流
    - 变换流具有如下特征：
      * ① 信息沿输入通路进入系统，同时由外部形式变换成内部形式；
      * ② 进入系统的信息通过变换中心，经加工处理后沿输出通路变成外部形式离开软件系。
    - ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/20916c187d0ea62a156bb3949c7b6dbf.png)
  + （2）事务流
    - 事务流是“以事务为中心”的数据流，即数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。
    - 事务流完成接收输入数据、分析每个事务确定事务类型、根据事务选择活动通路的任务
    - ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cfec058eb60e903e91c52e5cbbf52138.png)
* 设计过程
  + 下图说明了使用面向数据流方法逐步设计的过程。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7ada51e17d784fded94b3359472d23ea.png)
  + 【注意】任何设计过程都不是机械的一成不变的。
* 变换分析
  + 变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构
  + （1）适用性
    - 一般说来，如果数据流不具有显著的事务特点，最好使用变换分析。
  + （2）设计步骤
    - ① 复查基本系统模型；
    - ② 复查并精化数据流图；
    - ③ 确定数据流图具有变换特性还是事务特性；
    - ④ 确定输入流和输出流的边界，从而孤立出变换中心；
    - ⑤ 第一级分解；
    - ⑥ 第二级分解；
    - ⑦ 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。
* 事务分析
  + （1）适用性
    - 在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事务分析方法为宜。
  + （2）设计
    - 事务分析的映射方法如图所示。
    - ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d58b440404ff02b819e0e31a79016750.png)
* 设计优化
  + （1）设计优化时应遵循的原则。
    - ① 应该开发能够满足所有功能和性能要求，而且按照设计原理和启发式设计规则衡量是值得接收的软件。
    - ② 应该在设计的早期阶段尽量对软件结构进行精化。
    - ③ 结构简单通常既表示设计风格优雅，又表明效率高。
    - ④ 对于时间是决定性因素的应用场合，可能需要在详细设计阶段或在编写程序的过程中进行优化。
  + （2）可以采用以下几种方法对时间起决定性作用的软件进行优化。
    - ① 在不考虑时间因素的前提下开发并精化软件结构。
    - ② 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程（算法），以求提高效率。
    - ③ 使用高级程序设计语言编写程序。
    - ④ 在软件中孤立出那些大量占用处理机资源的模块。
    - ⑤ 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率。