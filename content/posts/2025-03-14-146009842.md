---
layout: post
title: "JVM-的不同组成部分分别有什么作用"
date: 2025-03-14 15:07:04 +0800
description: "除了启动类加载器，每个类加载器都有一个父类加载器。当一个类加载器需要加载类时，它首先会委托给父类加载器去加载，只有当父类加载器无法加载时，才由自己加载。"
keywords: "JVM 的不同组成部分分别有什么作用？"
categories: ['Jvm', 'Java', '2025']
tags: ['Jvm']
artid: "146009842"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146009842
    alt: "JVM-的不同组成部分分别有什么作用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146009842
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146009842
cover: https://bing.ee123.net/img/rand?artid=146009842
image: https://bing.ee123.net/img/rand?artid=146009842
img: https://bing.ee123.net/img/rand?artid=146009842
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM 的不同组成部分分别有什么作用？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     JVM（Java Virtual Machine）主要由以下几个核心组成部分构成：
    </p>
    <p>
     <strong>
      1. 类加载器子系统 (Class Loader Subsystem):
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        作用：
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         加载类：
        </strong>
        负责查找并加载 Java 类文件（.class 文件）到 JVM 中。 类文件可以来自本地文件系统、网络、JAR 包等。
       </li>
       <li>
        <strong>
         链接类：
        </strong>
        将加载的类合并到 JVM 的运行时状态中，包括验证、准备和解析（可选）三个阶段。
        <ul>
         <li>
          <strong>
           验证 (Verification):
          </strong>
          确保类文件的结构符合 JVM 规范，并且不会危害 JVM 的安全。
         </li>
         <li>
          <strong>
           准备 (Preparation):
          </strong>
          为类的静态变量分配内存，并设置默认初始值（例如，int 类型的默认值为 0，boolean 类型的默认值为 false）。
         </li>
         <li>
          <strong>
           解析 (Resolution):
          </strong>
          将类、接口、字段和方法的符号引用解析为直接引用（可选，可以延迟到运行时）。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         初始化类：
        </strong>
        执行类的初始化代码（静态变量赋值和静态代码块）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        类加载器类型：
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         启动类加载器 (Bootstrap Class Loader):
        </strong>
        加载 Java 核心类库（
        <code>
         &lt;JAVA_HOME&gt;/jre/lib
        </code>
        ）。
       </li>
       <li>
        <strong>
         扩展类加载器 (Extension Class Loader):
        </strong>
        加载 Java 扩展类库（
        <code>
         &lt;JAVA_HOME&gt;/jre/lib/ext
        </code>
        或
        <code>
         java.ext.dirs
        </code>
        指定的目录）。
       </li>
       <li>
        <strong>
         应用程序类加载器 (Application Class Loader):
        </strong>
        加载应用程序的类（classpath）。
       </li>
       <li>
        <strong>
         自定义类加载器：
        </strong>
        开发者可以自定义类加载器，实现特殊的类加载逻辑。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        双亲委派模型：
       </strong>
       除了启动类加载器，每个类加载器都有一个父类加载器。当一个类加载器需要加载类时，它首先会委托给父类加载器去加载，只有当父类加载器无法加载时，才由自己加载。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      2. 运行时数据区 (Runtime Data Areas):
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       作用：
      </strong>
      JVM 在运行 Java 程序时管理的内存区域，用于存储程序运行过程中需要的数据。
     </li>
     <li>
      <strong>
       主要区域：
      </strong>
      <ul>
       <li>
        <p>
         <strong>
          方法区 (Method Area):
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           存储内容：
          </strong>
          类信息（类名、父类、接口、字段、方法等）、常量、静态变量、即时编译器编译后的代码。
         </li>
         <li>
          <strong>
           共享性：
          </strong>
          所有线程共享。
         </li>
         <li>
          <strong>
           HotSpot VM 中的实现：
          </strong>
          <ul>
           <li>
            JDK 1.7 及之前：永久代 (Permanent Generation)。
           </li>
           <li>
            JDK 1.8 及之后：元空间 (Metaspace)（使用本地内存）。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           运行时常量池 (Runtime Constant Pool):
          </strong>
          方法区的一部分，存放编译期生成的各种字面量和符号引用。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          堆 (Heap):
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           存储内容：
          </strong>
          对象实例和数组。
         </li>
         <li>
          <strong>
           共享性：
          </strong>
          所有线程共享。
         </li>
         <li>
          <strong>
           垃圾回收：
          </strong>
          是垃圾回收的主要区域。
         </li>
         <li>
          <strong>
           划分：
          </strong>
          通常划分为新生代（Young Generation）和老年代（Old Generation）。
          <ul>
           <li>
            新生代又可以划分为 Eden 区、Survivor from 区和 Survivor to 区。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          虚拟机栈 (VM Stack):
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           存储内容：
          </strong>
          方法调用的局部变量、操作数栈、动态链接、方法出口等信息。
         </li>
         <li>
          <strong>
           共享性：
          </strong>
          每个线程都有自己的虚拟机栈（线程私有）。
         </li>
         <li>
          <strong>
           栈帧 (Stack Frame):
          </strong>
          每次方法调用都会创建一个栈帧，用于存储方法的局部变量等信息。方法执行完毕后，栈帧会被销毁。
         </li>
         <li>
          <strong>
           异常：
          </strong>
          <ul>
           <li>
            <code>
             StackOverflowError
            </code>
            : 线程请求的栈深度大于虚拟机允许的深度。
           </li>
           <li>
            <code>
             OutOfMemoryError
            </code>
            : 虚拟机栈无法申请到足够的内存（如果可以动态扩展）。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          本地方法栈 (Native Method Stack):
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           存储内容：
          </strong>
          与虚拟机栈类似，但用于支持 native 方法（使用 C、C++ 等编写的方法）的执行。
         </li>
         <li>
          <strong>
           共享性：
          </strong>
          每个线程都有自己的本地方法栈（线程私有）。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          程序计数器 (Program Counter Register):
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           存储内容：
          </strong>
          当前线程正在执行的字节码指令的地址（行号）。
         </li>
         <li>
          <strong>
           共享性：
          </strong>
          每个线程都有自己的程序计数器（线程私有）。
         </li>
         <li>
          <strong>
           特点：
          </strong>
          是唯一一个在 Java 虚拟机规范中没有规定任何
          <code>
           OutOfMemoryError
          </code>
          情况的区域。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      3. 执行引擎 (Execution Engine):
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       作用：
      </strong>
      负责执行 Java 字节码指令。
     </li>
     <li>
      <strong>
       主要组件：
      </strong>
      <ul>
       <li>
        <p>
         <strong>
          解释器 (Interpreter):
         </strong>
        </p>
        <ul>
         <li>
          逐条解释执行字节码指令。
         </li>
         <li>
          优点：启动速度快，不需要等待编译。
         </li>
         <li>
          缺点：执行速度慢，特别是对于频繁执行的代码。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          即时编译器 (JIT Compiler):
         </strong>
        </p>
        <ul>
         <li>
          将热点代码（经常执行的代码，例如循环体、频繁调用的方法）编译为本地机器码，提高执行效率。
         </li>
         <li>
          优点：执行速度快（接近本地代码）。
         </li>
         <li>
          缺点：编译需要时间，会增加启动时间。
         </li>
         <li>
          <strong>
           HotSpot VM 中的 JIT 编译器：
          </strong>
          <ul>
           <li>
            <strong>
             Client Compiler (C1):
            </strong>
            优化速度快，但优化程度较低。适用于客户端应用或对启动速度要求较高的场景。
           </li>
           <li>
            <strong>
             Server Compiler (C2):
            </strong>
            优化速度慢，但优化程度较高。适用于服务端应用或对性能要求较高的场景。
           </li>
           <li>
            <strong>
             分层编译 (Tiered Compilation):
            </strong>
            根据程序的运行情况，选择不同的编译器进行优化。
            <ul>
             <li>
              <strong>
               第 0 层：
              </strong>
              解释执行。
             </li>
             <li>
              <strong>
               第 1 层：
              </strong>
              使用 C1 编译，不开启 profiling。
             </li>
             <li>
              <strong>
               第 2 层：
              </strong>
              使用 C1 编译，仅开启方法和循环回边的 profiling。
             </li>
             <li>
              <strong>
               第 3 层：
              </strong>
              使用 C1 编译，开启所有 profiling。
             </li>
             <li>
              <strong>
               第 4 层：
              </strong>
              使用 C2 编译。
             </li>
            </ul>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          垃圾回收器 (Garbage Collector):
         </strong>
        </p>
        <ul>
         <li>
          负责自动回收不再使用的对象，释放内存。
         </li>
         <li>
          不同的 JVM 实现有不同的垃圾回收器。
         </li>
         <li>
          <strong>
           常见的垃圾回收器：
          </strong>
          <ul>
           <li>
            Serial GC
           </li>
           <li>
            Parallel GC
           </li>
           <li>
            CMS GC (Concurrent Mark Sweep)
           </li>
           <li>
            G1 GC (Garbage-First)
           </li>
           <li>
            ZGC
           </li>
           <li>
            Shenandoah
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          本地方法接口 (JNI, Java Native Interface):
         </strong>
        </p>
        <ul>
         <li>
          允许 Java 代码调用本地方法 (C/C++ 等编写的方法).
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      总结：
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        JVM 组成部分
       </th>
       <th>
        作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        类加载器子系统
       </td>
       <td>
        加载类文件（.class 文件）到 JVM 中，包括加载、链接（验证、准备、解析）和初始化三个阶段。
       </td>
      </tr>
      <tr>
       <td>
        运行时数据区
       </td>
       <td>
        JVM 在运行 Java 程序时管理的内存区域，包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。
       </td>
      </tr>
      <tr>
       <td>
        执行引擎
       </td>
       <td>
        执行 Java 字节码指令，包括解释器、即时编译器、垃圾回收器。
       </td>
      </tr>
      <tr>
       <td>
        本地方法接口(JNI)
       </td>
       <td>
        允许Java代码与本地代码(通常是C或C++)交互
       </td>
      </tr>
     </tbody>
    </table>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6e6d736f66746b6c622f:61727469636c652f64657461696c732f313436303039383432" class_="artid" style="display:none">
 </p>
</div>


