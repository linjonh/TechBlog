---
layout: post
title: "MySQL表空间碎片原理和解决方案"
date: 2025-03-08 13:13:25 +0800
description: "mysql碎片原理和解决方案"
keywords: "mysql碎片问题"
categories: ['Mysql']
tags: ['数据库', 'Mysql']
artid: "146114743"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146114743
    alt: "MySQL表空间碎片原理和解决方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146114743
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146114743
cover: https://bing.ee123.net/img/rand?artid=146114743
image: https://bing.ee123.net/img/rand?artid=146114743
img: https://bing.ee123.net/img/rand?artid=146114743
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL表空间碎片原理和解决方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h5>
     <a id="_1">
     </a>
     一、表空间与碎片的基本概念
    </h5>
    <ul>
     <li>
      <strong>
       表空间
      </strong>
      ：MySQL中存储表数据和索引的物理文件（如InnoDB的.ibd文件）。分为系统表空间和独立表空间。
     </li>
     <li>
      <strong>
       碎片
      </strong>
      ：数据在物理存储上不连续，分为
      <strong>
       行级碎片
      </strong>
      （单行跨多页）和
      <strong>
       页级碎片
      </strong>
      （页内空间未充分利用）。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_7">
     </a>
     二、碎片产生原因
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        频繁增删改（DML）操作
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         DELETE
        </strong>
        ：删除数据后，页内产生空闲空间，但不会立即回收。
       </li>
       <li>
        <strong>
         UPDATE
        </strong>
        ：变长字段更新导致行扩容，可能触发行迁移（Row Migration），原位置留下空洞。
       </li>
       <li>
        <strong>
         INSERT
        </strong>
        ：非顺序插入（如随机主键）引发页分裂，新页利用率低。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        索引设计不合理
       </strong>
      </p>
      <ul>
       <li>
        随机主键（如UUID）导致页分裂频繁。
       </li>
       <li>
        未使用覆盖索引，增删改时需调整多索引结构。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        自动递增列间隙
       </strong>
      </p>
      <ul>
       <li>
        自增ID事务回滚后，ID不连续，导致页内空隙。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        大字段存储
       </strong>
      </p>
      <ul>
       <li>
        TEXT/BLOB等大对象可能存储在溢出页，增加碎片。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <a id="_25">
     </a>
     三、碎片监控与评估
    </h5>
    <p>
     通过
     <code>
      information_schema.TABLES
     </code>
     计算碎片率：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> 
  TABLE_NAME<span class="token punctuation">,</span>
  DATA_LENGTH<span class="token punctuation">,</span>
  INDEX_LENGTH<span class="token punctuation">,</span>
  DATA_FREE<span class="token punctuation">,</span>
  <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DATA_FREE <span class="token operator">/</span> <span class="token punctuation">(</span>DATA_LENGTH <span class="token operator">+</span> INDEX_LENGTH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> FragmentationRate
<span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span><span class="token keyword">TABLES</span> 
<span class="token keyword">WHERE</span> TABLE_SCHEMA <span class="token operator">=</span> <span class="token string">'your_database'</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       DATA_FREE
      </strong>
      ：未使用的字节数，值越大碎片可能越多。
     </li>
     <li>
      <strong>
       碎片率 &gt; 20%
      </strong>
      时建议整理。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_42">
     </a>
     四、解决方案与优化策略
    </h5>
    <h6>
     <a id="1__44">
     </a>
     1. 手动整理碎片
    </h6>
    <ul>
     <li>
      <strong>
       OPTIMIZE TABLE
      </strong>
      （锁表）：
      <pre><code class="prism language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> your_table<span class="token punctuation">;</span> <span class="token comment">-- InnoDB下转为ALTER TABLE重建</span>
</code></pre>
     </li>
     <li>
      <strong>
       ALTER TABLE重建
      </strong>
      ：
      <pre><code class="prism language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> your_table <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span> <span class="token comment">-- 重建表并整理碎片</span>
</code></pre>
     </li>
     <li>
      <strong>
       在线工具
      </strong>
      ：使用
      <code>
       pt-online-schema-change
      </code>
      （Percona Toolkit）避免锁表：
      <pre><code class="prism language-bash">pt-online-schema-change <span class="token parameter variable">--alter</span><span class="token operator">=</span><span class="token string">"ENGINE=InnoDB"</span> <span class="token assign-left variable">D</span><span class="token operator">=</span>your_database,t<span class="token operator">=</span>your_table <span class="token parameter variable">--execute</span>
</code></pre>
     </li>
    </ul>
    <h6>
     <a id="2__58">
     </a>
     2. 预防碎片的设计优化
    </h6>
    <ul>
     <li>
      <strong>
       使用自增主键
      </strong>
      ：减少页分裂。
      <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> users <span class="token punctuation">(</span>
  id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
  name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       合理选择数据类型
      </strong>
      ：避免过度使用VARCHAR或大字段。
     </li>
     <li>
      <strong>
       索引优化
      </strong>
      ：
      <ul>
       <li>
        避免冗余索引。
       </li>
       <li>
        使用覆盖索引减少回表查询。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="3_InnoDB_71">
     </a>
     3. InnoDB参数调优
    </h6>
    <ul>
     <li>
      <strong>
       innodb_file_per_table=ON
      </strong>
      ：启用独立表空间，方便单表管理。
     </li>
     <li>
      <strong>
       innodb_fill_factor
      </strong>
      ：设置页填充率（默认100%），预留空间减少页分裂（仅适用于某些版本）。
     </li>
    </ul>
    <h6>
     <a id="4__75">
     </a>
     4. 分区表管理
    </h6>
    <ul>
     <li>
      按时间或范围分区，定期清理旧分区：
      <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> logs <span class="token punctuation">(</span>
  id <span class="token keyword">INT</span><span class="token punctuation">,</span>
  log_time <span class="token keyword">DATETIME</span>
<span class="token punctuation">)</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>log_time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
  <span class="token keyword">PARTITION</span> p2020 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">PARTITION</span> p2021 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_89">
     </a>
     五、实战示例
    </h5>
    <p>
     <strong>
      场景
     </strong>
     ：用户日志表
     <code>
      user_logs
     </code>
     因频繁删除，碎片率达35%。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        监控碎片
       </strong>
       ：
      </p>
      <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> 
  TABLE_NAME<span class="token punctuation">,</span>
  <span class="token function">ROUND</span><span class="token punctuation">(</span>DATA_FREE <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> Free_MB<span class="token punctuation">,</span>
  <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DATA_FREE <span class="token operator">/</span> <span class="token punctuation">(</span>DATA_LENGTH <span class="token operator">+</span> INDEX_LENGTH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> FragRate
<span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span><span class="token keyword">TABLES</span>
<span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'user_logs'</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        在线整理
       </strong>
       ：
      </p>
      <pre><code class="prism language-bash">pt-online-schema-change <span class="token parameter variable">--alter</span><span class="token operator">=</span><span class="token string">"ENGINE=InnoDB"</span> <span class="token assign-left variable">D</span><span class="token operator">=</span>test,t<span class="token operator">=</span>user_logs <span class="token parameter variable">--execute</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        效果验证
       </strong>
       ：
      </p>
      <ul>
       <li>
        数据文件大小减少30%。
       </li>
       <li>
        查询
        <code>
         SELECT * FROM user_logs WHERE user_id=100
        </code>
        耗时从120ms降至45ms。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <a id="_112">
     </a>
     六、注意事项
    </h5>
    <ul>
     <li>
      <strong>
       锁表风险
      </strong>
      ：OPTIMIZE TABLE会阻塞写操作，建议在低峰期执行。
     </li>
     <li>
      <strong>
       磁盘空间
      </strong>
      ：重建表需要额外空间（至少原表大小）。
     </li>
     <li>
      <strong>
       复制环境
      </strong>
      ：主从架构中，OPTIMIZE TABLE会复制到从库，可能引发延迟。
     </li>
    </ul>
    <p>
     通过合理设计、定期监控和碎片整理，可显著提升MySQL存储效率与查询性能。
    </p>
    <hr/>
    <h5>
     <a id="MySQL_120">
     </a>
     七、MySQL高碎片率表引发的性能问题详解
    </h5>
    <hr/>
    <h6>
     <a id="A_124">
     </a>
     A、碎片对存储结构的直接影响
    </h6>
    <p>
     MySQL（尤其是InnoDB引擎）的数据和索引以
     <strong>
      页（Page）
     </strong>
     为单位存储（默认16KB），页通过B+树索引组织。高碎片率会破坏页的连续性和紧凑性，具体表现为：
    </p>
    <ol>
     <li>
      <strong>
       页内空间浪费
      </strong>
      ：页中存在大量空闲空间（例如DELETE后未回收）。
     </li>
     <li>
      <strong>
       页分布离散
      </strong>
      ：数据页在物理磁盘上不连续（例如频繁INSERT导致页分裂）。
     </li>
     <li>
      <strong>
       行迁移（Row Migration）
      </strong>
      ：UPDATE导致行长度变化后，原页空间无法容纳，行被迁移到新页，留下空洞。
     </li>
    </ol>
    <hr/>
    <h5>
     <a id="B_132">
     </a>
     B、性能问题的具体表现与原理
    </h5>
    <h6>
     <a id="1_IO_134">
     </a>
     1.
     <strong>
      I/O效率下降
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       随机I/O增加
      </strong>
      ：
      <ul>
       <li>
        数据页物理分布离散，查询时需多次跳转读取不同磁盘位置。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：范围查询
        <code>
         SELECT * FROM logs WHERE time BETWEEN '2023-01-01' AND '2023-12-31'
        </code>
        ，若数据页分散，需多次寻道（传统HDD寻道时间约10ms，SSD约0.1ms）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       页利用率低
      </strong>
      ：
      <ul>
       <li>
        页内空闲空间多，相同数据量需占用更多页。
       </li>
       <li>
        <strong>
         影响
        </strong>
        ：全表扫描（如无索引查询）需读取更多物理页，增加I/O负载。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="2_Buffer_Pool_142">
     </a>
     2.
     <strong>
      缓冲池（Buffer Pool）效率降低
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       缓存命中率下降
      </strong>
      ：
      <ul>
       <li>
        Buffer Pool缓存的是
        <strong>
         页
        </strong>
        ，碎片导致相同数据占用更多页，使得有效数据在缓存中的比例降低。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：原本100页的数据因碎片变为150页，Buffer Pool容量不变时，换出频率增加，触发更多磁盘读取。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       冷数据占用缓存
      </strong>
      ：
      <ul>
       <li>
        碎片页中可能包含已删除的无效数据，导致缓存被无用数据占据。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="3__149">
     </a>
     3.
     <strong>
      索引查询效率下降
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       B+树深度增加
      </strong>
      ：
      <ul>
       <li>
        页分裂可能导致索引树层级变高（如从3层变为4层），查询需遍历更多节点。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：主键查询
        <code>
         SELECT * FROM orders WHERE id=1000
        </code>
        ，若B+树层级增加，需多一次页读取。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       范围查询性能劣化
      </strong>
      ：
      <ul>
       <li>
        叶子节点不连续时，范围扫描需跨多个离散页。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：索引范围查询
        <code>
         SELECT * FROM users WHERE age BETWEEN 20 AND 30
        </code>
        ，若叶子节点分散，需多次I/O。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="4__157">
     </a>
     4.
     <strong>
      写入性能下降
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       页分裂代价
      </strong>
      ：
      <ul>
       <li>
        插入非顺序主键（如UUID）时，频繁页分裂导致写放大（Write Amplification）。
       </li>
       <li>
        <strong>
         影响
        </strong>
        ：页分裂需复制部分数据到新页，增加CPU和I/O开销。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       行迁移开销
      </strong>
      ：
      <ul>
       <li>
        UPDATE导致行迁移时，需额外写入新页并标记原页空间为空洞，增加写操作延迟。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="5__164">
     </a>
     5.
     <strong>
      维护操作成本增加
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       备份与恢复时间增长
      </strong>
      ：
      <ul>
       <li>
        物理备份工具（如
        <code>
         mysqldump
        </code>
        或
        <code>
         xtrabackup
        </code>
        ）需拷贝更多碎片页，耗时更长。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       统计信息不准确
      </strong>
      ：
      <ul>
       <li>
        碎片导致
        <code>
         InnoDB
        </code>
        计算的行数估算偏差，可能生成次优执行计划。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_172">
     </a>
     八、典型性能案例分析
    </h5>
    <h6>
     <a id="1_174">
     </a>
     场景1：全表扫描性能下降
    </h6>
    <ul>
     <li>
      <strong>
       表结构
      </strong>
      ：
      <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> sensor_data <span class="token punctuation">(</span>
  id <span class="token keyword">BIGINT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
  <span class="token keyword">timestamp</span> <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
  <span class="token keyword">value</span> <span class="token keyword">FLOAT</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       问题
      </strong>
      ：高频DELETE旧数据后，碎片率40%。
     </li>
     <li>
      <strong>
       查询
      </strong>
      ：
      <code>
       SELECT AVG(value) FROM sensor_data WHERE timestamp &gt; NOW() - INTERVAL 1 DAY;
      </code>
     </li>
     <li>
      <strong>
       影响
      </strong>
      ：
      <ul>
       <li>
        数据页分散，需扫描更多物理页。
       </li>
       <li>
        Buffer Pool中大量页为碎片空洞，有效数据缓存不足，磁盘IPS（每秒I/O操作数）飙升。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="2_189">
     </a>
     场景2：索引范围查询延迟
    </h6>
    <ul>
     <li>
      <strong>
       表结构
      </strong>
      ：
      <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> messages <span class="token punctuation">(</span>
  msg_id <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span> <span class="token comment">-- UUID类型主键</span>
  user_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
  content <span class="token keyword">TEXT</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       问题
      </strong>
      ：随机主键导致页分裂，碎片率30%。
     </li>
     <li>
      <strong>
       查询
      </strong>
      ：
      <code>
       SELECT * FROM messages WHERE user_id=100 ORDER BY msg_id LIMIT 100;
      </code>
     </li>
     <li>
      <strong>
       影响
      </strong>
      ：
      <ul>
       <li>
        主键索引的叶子节点不连续，需多次随机I/O遍历索引。
       </li>
       <li>
        ORDER BY需额外排序（若无法利用索引顺序），临时表可能使用磁盘空间。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="3_204">
     </a>
     场景3：事务回滚段压力
    </h6>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：高碎片表的UPDATE操作频繁触发行迁移。
     </li>
     <li>
      <strong>
       影响
      </strong>
      ：
      <ul>
       <li>
        行迁移产生更多Undo Log，增加回滚段压力。
       </li>
       <li>
        长事务可能导致Undo Purge滞后，进一步加剧碎片。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_212">
     </a>
     九、性能问题量化验证
    </h5>
    <h6>
     <a id="1_SHOW_STATUSIO_214">
     </a>
     1. 通过
     <code>
      SHOW STATUS
     </code>
     观察I/O变化
    </h6>
    <p>
     – 观察物理读请求
     <br/>
     SHOW GLOBAL STATUS LIKE ‘Innodb_buffer_pool_reads’;
     <br/>
     – 碎片整理前：高数值（直接从磁盘读取）
     <br/>
     – 碎片整理后：数值下降（更多请求命中Buffer Pool）
    </p>
    <h6>
     <a id="2_EXPLAIN_222">
     </a>
     2. 查询计划分析（EXPLAIN）
    </h6>
    <ul>
     <li>
      <strong>
       碎片表
      </strong>
      ：
      <pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fragmented_table <span class="token keyword">WHERE</span> range_column <span class="token operator">BETWEEN</span> <span class="token number">1</span> <span class="token operator">AND</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token comment">-- 可能显示"rows"估算值远小于实际扫描行数，导致优化器选择低效索引。</span>
</code></pre>
     </li>
    </ul>
    <h6>
     <a id="3__229">
     </a>
     3. 监控工具
    </h6>
    <ul>
     <li>
      <strong>
       Percona Monitoring and Management (PMM)
      </strong>
      ：
      <ul>
       <li>
        观察磁盘I/O等待时间（
        <code>
         disk_io_wait
        </code>
        ）和Buffer Pool命中率（
        <code>
         innodb_buffer_pool_hit_rate
        </code>
        ）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       pt-query-digest
      </strong>
      ：
      <ul>
       <li>
        分析慢查询日志，定位因碎片导致的效率下降查询。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_237">
     </a>
     十、总结：碎片如何一步步拖慢数据库
    </h5>
    <ol>
     <li>
      <strong>
       物理存储层
      </strong>
      ：数据页分散 → 随机I/O增加 → 磁盘响应时间上升。
     </li>
     <li>
      <strong>
       内存层
      </strong>
      ：Buffer Pool缓存低效 → 缓存命中率下降 → 物理I/O请求激增。
     </li>
     <li>
      <strong>
       索引层
      </strong>
      ：B+树结构松散 → 查询路径变长 → CPU和I/O消耗增加。
     </li>
     <li>
      <strong>
       事务层
      </strong>
      ：行迁移与Undo Log膨胀 → 锁竞争加剧 → 并发性能下降。
     </li>
    </ol>
    <p>
     通过定期监控碎片率（
     <code>
      information_schema.TABLES
     </code>
     ）并适时执行
     <code>
      OPTIMIZE TABLE
     </code>
     或
     <code>
      ALTER TABLE
     </code>
     重建，可有效避免上述性能劣化链。
    </p>
    <hr/>
    <p>
     在MySQL的InnoDB存储引擎中，页（Page）内的碎片是可以被重新利用的，但具体能否被有效利用取决于操作类型、存储结构设计以及数据变更模式。以下是详细说明：
    </p>
    <hr/>
    <h5>
     <a id="_251">
     </a>
     十一、页内碎片的重新利用机制
    </h5>
    <p>
     在InnoDB中，**页（Page）**是数据存储的基本单位（默认16KB）。页内碎片分为两类：
    </p>
    <ol>
     <li>
      <strong>
       行内碎片（Row Fragmentation）
      </strong>
      <ul>
       <li>
        单行数据因更新（UPDATE）导致字段长度变化，原位置无法完全容纳新数据，触发行迁移（Row Migration），原页留下空洞。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       页内未分配空间（Free Space）
      </strong>
      <ul>
       <li>
        因删除（DELETE）或页分裂（Page Split）导致页中存在未使用的空闲空间。
       </li>
      </ul>
     </li>
    </ol>
    <h6>
     <a id="1_INSERT_258">
     </a>
     1.
     <strong>
      INSERT操作对碎片的利用
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       顺序插入
      </strong>
      ：
      <br/>
      若主键为自增（AUTO_INCREMENT），新数据会按顺序填充到新页或当前页的尾部，
      <strong>
       无法利用页内已有的碎片
      </strong>
      。
      <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token punctuation">(</span>
  id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
  <span class="token keyword">data</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       随机插入
      </strong>
      ：
      <br/>
      若主键为随机值（如UUID），新数据可能插入到页的空闲位置（若空间足够），
      <strong>
       可复用页内碎片
      </strong>
      。
      <pre><code class="prism language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t1 <span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>UUID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
    <h6>
     <a id="2_UPDATE_273">
     </a>
     2.
     <strong>
      UPDATE操作对碎片的利用
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       行长度不变
      </strong>
      ：
      <br/>
      若更新后的行长度不变，直接在原位置修改，不产生碎片。
      <pre><code class="prism language-sql"><span class="token keyword">UPDATE</span> t1 <span class="token keyword">SET</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token string">'new_value'</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       行长度增大
      </strong>
      ：
      <br/>
      若新数据无法放入原位置，触发行迁移，原页留下空洞（可能被后续插入复用）。
      <pre><code class="prism language-sql"><span class="token comment">-- 原数据: data VARCHAR(10) → 更新为 data VARCHAR(50)</span>
<span class="token keyword">UPDATE</span> t1 <span class="token keyword">SET</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token string">'a_very_long_string_that_exceeds_original_space'</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       行长度缩小
      </strong>
      ：
      <br/>
      缩小后的剩余空间会保留在页内，供后续插入或更新使用。
      <pre><code class="prism language-sql"><span class="token comment">-- 原数据: data VARCHAR(50) → 更新为 data VARCHAR(10)</span>
<span class="token keyword">UPDATE</span> t1 <span class="token keyword">SET</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token string">'short'</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
    <h6>
     <a id="3_DELETE_292">
     </a>
     3.
     <strong>
      DELETE操作后的碎片利用
     </strong>
    </h6>
    <ul>
     <li>
      删除数据后，页内空间被标记为“可重用”，但不会立即释放到磁盘。后续的插入或更新可能复用这些空间。
      <pre><code class="prism language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">-- 后续插入可能复用该位置</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t1 <span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'reuse_deleted_space'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
    <h6>
     <a id="4_Page_Split_300">
     </a>
     4.
     <strong>
      页分裂（Page Split）后的碎片利用
     </strong>
    </h6>
    <ul>
     <li>
      当插入数据导致页空间不足时，InnoDB会触发页分裂，将约50%的数据移动到新页。原页和新页均会残留空闲空间，后续插入可能复用这些空间。
      <br/>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-sql"><span class="token comment">-- 假设页已满，插入新数据触发页分裂</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t1 <span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'data_causing_page_split'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_310">
     </a>
     十二、碎片无法被利用的场景
    </h5>
    <h6>
     <a id="1__312">
     </a>
     1.
     <strong>
      空间不匹配
     </strong>
    </h6>
    <ul>
     <li>
      若页内空闲空间为200字节，但新插入的行需要300字节，则无法复用该碎片。此时会申请新页。
     </li>
    </ul>
    <h6>
     <a id="2__315">
     </a>
     2.
     <strong>
      索引结构限制
     </strong>
    </h6>
    <ul>
     <li>
      主键索引（聚簇索引）要求数据按主键顺序存储，非主键插入可能无法有效利用碎片。
      <br/>
      <strong>
       示例
      </strong>
      ：
      <br/>
      若主键为自增ID，即使页内有碎片，新数据仍需追加到页尾部。
     </li>
    </ul>
    <h6>
     <a id="3_LOB_320">
     </a>
     3.
     <strong>
      大对象（LOB）存储
     </strong>
    </h6>
    <ul>
     <li>
      TEXT/BLOB等大字段可能存储在溢出页（Off-page），其对应的主页内仅保留20字节指针，碎片难以被普通数据行复用。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_325">
     </a>
     十三、优化碎片利用的策略
    </h5>
    <h6>
     <a id="1__327">
     </a>
     1.
     <strong>
      合理设计表结构
     </strong>
    </h6>
    <ul>
     <li>
      使用自增主键减少页分裂。
      <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t2 <span class="token punctuation">(</span>
  id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
  <span class="token keyword">data</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      避免过度使用可变长度字段（如VARCHAR）。
     </li>
    </ul>
    <h6>
     <a id="2__337">
     </a>
     2.
     <strong>
      定期整理碎片
     </strong>
    </h6>
    <ul>
     <li>
      使用
      <code>
       OPTIMIZE TABLE
      </code>
      或
      <code>
       ALTER TABLE
      </code>
      重建表：
      <pre><code class="prism language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> t1<span class="token punctuation">;</span> <span class="token comment">-- 锁表操作</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t1 <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span> <span class="token comment">-- 重建表</span>
</code></pre>
     </li>
     <li>
      使用在线工具（如
      <code>
       pt-online-schema-change
      </code>
      ）避免锁表。
     </li>
    </ul>
    <h6>
     <a id="3__345">
     </a>
     3.
     <strong>
      监控与调优
     </strong>
    </h6>
    <ul>
     <li>
      通过
      <code>
       information_schema.TABLES
      </code>
      监控碎片率：
      <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> 
  TABLE_NAME<span class="token punctuation">,</span>
  <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DATA_FREE <span class="token operator">/</span> <span class="token punctuation">(</span>DATA_LENGTH <span class="token operator">+</span> INDEX_LENGTH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token keyword">AS</span> FragmentationRate
<span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span><span class="token keyword">TABLES</span>
<span class="token keyword">WHERE</span> TABLE_SCHEMA <span class="token operator">=</span> <span class="token string">'your_db'</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      调整
      <code>
       innodb_fill_factor
      </code>
      （某些版本支持），预留页空间减少分裂。
     </li>
    </ul>
    <h6>
     <a id="4__356">
     </a>
     4.
     <strong>
      避免全表删除
     </strong>
    </h6>
    <ul>
     <li>
      使用
      <code>
       TRUNCATE TABLE
      </code>
      代替
      <code>
       DELETE FROM table
      </code>
      ，直接回收空间。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_361">
     </a>
     十四、示例：碎片利用的完整流程
    </h4>
    <ol>
     <li>
      <strong>
       初始状态
      </strong>
      <br/>
      页内有3行数据，占用总空间12KB（剩余4KB空闲）。
     </li>
     <li>
      <strong>
       DELETE操作
      </strong>
      <br/>
      删除1行，释放4KB空间，页内空闲空间变为8KB。
     </li>
     <li>
      <strong>
       INSERT操作
      </strong>
      <br/>
      插入新行（需3KB空间），直接复用删除产生的空闲空间。
     </li>
     <li>
      <strong>
       UPDATE操作
      </strong>
      <br/>
      更新某行数据，长度从2KB增至3KB，若原位置空间不足，触发行迁移，原位置留下2KB空洞。
     </li>
     <li>
      <strong>
       后续插入
      </strong>
      <br/>
      新插入1KB数据，可填充行迁移产生的空洞。
     </li>
    </ol>
    <hr/>
    <h5>
     <a id="_375">
     </a>
     十五、碎片利用总结
    </h5>
    <ul>
     <li>
      <strong>
       可以复用
      </strong>
      ：页内碎片可通过后续的INSERT/UPDATE操作部分复用，尤其是随机插入和非聚簇索引的写入。
     </li>
     <li>
      <strong>
       无法复用
      </strong>
      ：当碎片空间不足或受索引结构限制时，仍需分配新页。
     </li>
     <li>
      <strong>
       优化关键
      </strong>
      ：通过合理设计表结构、监控碎片率及定期维护，最大化碎片利用率，减少空间浪费和I/O开销。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f6e616e676f6e6768656e2f:61727469636c652f64657461696c732f313436313134373433" class_="artid" style="display:none">
 </p>
</div>


