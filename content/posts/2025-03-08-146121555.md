---
layout: post
title: "OkHttp工作原理-拦截器链深度解析"
date: 2025-03-08 20:57:00 +0800
description: "摘要：OKHttp 是一款高效的 HTTP 客户端库，由 Square 公司开发，支持 Android 和 Java 应用。它简化了 HTTP 请求处理，支持同步/异步请求、连接池、缓存、拦截器等特性。"
keywords: "《OkHttp：工作原理 & 拦截器链深度解析》"
categories: ['Android']
tags: ['Retrofit', 'Okhttp', 'Kotlin', 'Java', 'Http', 'Android']
artid: "146121555"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146121555
    alt: "OkHttp工作原理-拦截器链深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146121555
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146121555
cover: https://bing.ee123.net/img/rand?artid=146121555
image: https://bing.ee123.net/img/rand?artid=146121555
img: https://bing.ee123.net/img/rand?artid=146121555
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     《OkHttp：工作原理 &amp; 拦截器链深度解析》
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     OKHttp 是一款高效的 HTTP 客户端库，由 Square 公司开发，支持 Android 和 Java 应用。它简化了 HTTP 请求处理，支持同步/异步请求、连接池、缓存、拦截器等特性。以下是其使用流程图和原理的详细解析：
    </p>
    <p>
     <img alt="" height="530" src="https://i-blog.csdnimg.cn/direct/60b536ab19524e51b1d8fd08f8e46301.png" width="485"/>
    </p>
    <hr/>
    <h4 id="%E4%B8%80%E3%80%81OKHttp%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" name="%E4%B8%80%E3%80%81OKHttp%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">
     一、OKHttp 的基本使用
    </h4>
    <h5 id="1.%20%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96" name="1.%20%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">
     1. 添加依赖
    </h5>
    <p>
     在 Gradle 中添加依赖：
    </p>
    <pre><code class="language-Groovy">implementation 'com.squareup.okhttp3:okhttp:4.9.3' // 最新版本以官方为准</code></pre>
    <h5 id="2.%20%E5%8F%91%E8%B5%B7%20HTTP%20%E8%AF%B7%E6%B1%82" name="2.%20%E5%8F%91%E8%B5%B7%20HTTP%20%E8%AF%B7%E6%B1%82">
     2. 发起 HTTP 请求
    </h5>
    <p>
     <strong>
      同步请求示例：
     </strong>
    </p>
    <pre><code class="language-java">OkHttpClient client = new OkHttpClient();

Request request = new Request.Builder()
    .url("https://api.example.com/data")
    .build();

try (Response response = client.newCall(request).execute()) {
    if (response.isSuccessful()) {
        String responseData = response.body().string();
        System.out.println(responseData);
    }
} catch (IOException e) {
    e.printStackTrace();
}</code></pre>
    <p>
     <strong>
      注意：
     </strong>
     同步请求需在子线程执行（Android 中主线程禁止网络操作）。
    </p>
    <p>
     <strong>
      异步请求示例：
     </strong>
    </p>
    <pre><code class="language-java">client.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        e.printStackTrace();
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        if (response.isSuccessful()) {
            String responseData = response.body().string();
            // 注意：回调在后台线程，需切换线程更新 UI
        }
    }
});</code></pre>
    <h5 id="3.%20%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88Interceptor%EF%BC%89" name="3.%20%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88Interceptor%EF%BC%89">
     3. 拦截器（Interceptor）
    </h5>
    <p>
     拦截器用于监控、修改请求和响应。例如添加统一请求头：
    </p>
    <pre><code class="language-java">OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(new Interceptor() {
        @Override
        public Response intercept(Chain chain) throws IOException {
            Request originalRequest = chain.request();
            Request newRequest = originalRequest.newBuilder()
                .header("Authorization", "Bearer token")
                .build();
            return chain.proceed(newRequest);
        }
    })
    .build();</code></pre>
    <h5 id="4.%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE" name="4.%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE">
     4. 高级配置
    </h5>
    <pre><code class="language-java">OkHttpClient client = new OkHttpClient.Builder()
    .connectTimeout(10, TimeUnit.SECONDS) // 连接超时
    .readTimeout(30, TimeUnit.SECONDS)    // 读取超时
    .writeTimeout(30, TimeUnit.SECONDS)   // 写入超时
    .cookieJar(new CookieJar() {          // Cookie 管理
        private final HashMap&lt;HttpUrl, List&lt;Cookie&gt;&gt; cookieStore = new HashMap&lt;&gt;();
        @Override
        public void saveFromResponse(HttpUrl url, List&lt;Cookie&gt; cookies) {
            cookieStore.put(url, cookies);
        }
        @Override
        public List&lt;Cookie&gt; loadForRequest(HttpUrl url) {
            return cookieStore.getOrDefault(url, new ArrayList&lt;&gt;());
        }
    })
    .build();</code></pre>
    <hr/>
    <h4 id="%E4%BA%8C%E3%80%81OKHttp%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86" name="%E4%BA%8C%E3%80%81OKHttp%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">
     二、OKHttp 核心原理
    </h4>
    <h5 id="1.%20%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Interceptor%20Chain%EF%BC%89" name="1.%20%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Interceptor%20Chain%EF%BC%89">
     1. 责任链模式（Interceptor Chain）
    </h5>
    <p>
     OKHttp 的核心是
     <strong>
      拦截器链
     </strong>
     ，每个请求会依次经过多个拦截器处理：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        自定义拦截器
       </strong>
       ：开发者添加的拦截器，最先执行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        RetryAndFollowUpInterceptor
       </strong>
       ：处理重定向和失败重试。
      </p>
     </li>
     <li>
      <p>
       <strong>
        BridgeInterceptor
       </strong>
       ：补全请求头（如
       <code>
        Content-Type
       </code>
       、
       <code>
        Cookie
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        CacheInterceptor
       </strong>
       ：根据缓存策略返回缓存或请求网络。
      </p>
     </li>
     <li>
      <p>
       <strong>
        ConnectInterceptor
       </strong>
       ：建立与服务器的连接（复用连接池中的连接）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        CallServerInterceptor
       </strong>
       ：向服务器发送请求并读取响应。
      </p>
     </li>
    </ul>
    <h5 id="2.%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%88ConnectionPool%EF%BC%89" name="2.%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%88ConnectionPool%EF%BC%89">
     2. 连接池（ConnectionPool）
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：复用 TCP 连接，减少握手开销。
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认配置
       </strong>
       ：最大空闲连接数 5，存活时间 5 分钟。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：通过
       <strong>
        <code>
         RealConnectionPool
        </code>
       </strong>
       管理空闲连接，清理过期连接。
      </p>
     </li>
    </ul>
    <h5 id="3.%20%E8%AF%B7%E6%B1%82%E8%B0%83%E5%BA%A6%EF%BC%88Dispatcher%EF%BC%89" name="3.%20%E8%AF%B7%E6%B1%82%E8%B0%83%E5%BA%A6%EF%BC%88Dispatcher%EF%BC%89">
     3. 请求调度（Dispatcher）
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        同步请求
       </strong>
       ：直接执行，但需开发者自行管理线程。
      </p>
     </li>
     <li>
      <p>
       <strong>
        异步请求
       </strong>
       ：通过
       <code>
        Dispatcher
       </code>
       管理线程池，默认最大并发请求数 64，单个域名最大并发 5。
      </p>
     </li>
    </ul>
    <h5 id="4.%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" name="4.%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">
     4. 缓存机制
    </h5>
    <ul>
     <li>
      <p>
       基于 HTTP 缓存协议（如
       <code>
        Cache-Control
       </code>
       、
       <code>
        ETag
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       缓存目录需开发者指定，通过
       <code>
        Cache
       </code>
       类配置：
      </p>
      <pre><code class="language-java">Cache cache = new Cache(context.getCacheDir(), 10 * 1024 * 1024); // 10MB 缓存
OkHttpClient client = new OkHttpClient.Builder().cache(cache).build();</code></pre>
     </li>
    </ul>
    <h5 id="5.%20%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7" name="5.%20%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7">
     5. 其他特性
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        HTTP/2 支持
       </strong>
       ：多路复用、头部压缩。
      </p>
     </li>
     <li>
      <p>
       <strong>
        WebSocket
       </strong>
       ：通过
       <code>
        <span style="background-color:#f9eda6">
         okhttp-ws
        </span>
       </code>
       模块支持长连接。
      </p>
     </li>
     <li>
      <p>
       <strong>
        HTTPS
       </strong>
       ：支持 TLS 1.3，可配置证书校验策略。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="%E4%B8%89%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" name="%E4%B8%89%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">
     三、拦截器工作原理
    </h4>
    <p>
     OKHttp 的五大核心拦截器构成了其高效的网络请求处理链，每个拦截器职责明确，协同工作。以下是它们的详细工作流程和原理：
    </p>
    <h5 id="3.1%20%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" name="3.1%20%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">
     3.1 拦截器链的执行顺序
    </h5>
    <p>
     OKHttp 的请求处理基于
     <strong>
      责任链模式
     </strong>
     ，五大核心拦截器按固定顺序依次处理请求和响应：请求从第一个拦截器进入，逐步传递到最后一个拦截器（
     <strong>
      <code>
       CallServerInterceptor
      </code>
     </strong>
     ），
     <strong>
      <span style="color:#6eaad7">
       响应则逆向返回
      </span>
     </strong>
     。
    </p>
    <p>
     <img alt="" height="638" src="https://i-blog.csdnimg.cn/direct/a6d7e7284f7644acb8886694e9fa9810.png" width="651"/>
    </p>
    <hr/>
    <h5 id="3.2%20%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" name="3.2%20%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">
     3.2 五大拦截器的工作原理
    </h5>
    <p>
     <span style="color:#4da8ee">
      <strong>
       1. RetryAndFollowUpInterceptor
      </strong>
     </span>
    </p>
    <p>
     <strong>
      核心职责
     </strong>
     ：处理请求失败的重试与重定向。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        重试机制
       </strong>
       ：
       <br/>
       若请求因网络问题（如连接超时、IO 异常）失败，根据配置决定是否重试（默认最多 20 次）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        重定向处理
       </strong>
       ：
       <br/>
       若服务器返回 3xx 状态码（如 302 临时跳转），自动构建新请求并重新发起。
      </p>
     </li>
     <li>
      <p>
       <strong>
        流程示例
       </strong>
       ：
      </p>
      <pre><code class="language-java">Request → RetryAndFollowUpInterceptor → 发送请求 → 失败 → 判断是否重试 → 重新执行链  
Response ← 处理重定向 → 生成新 Request → 重新执行链</code></pre>
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       2. BridgeInterceptor
      </strong>
     </span>
    </p>
    <p>
     <strong>
      核心职责
     </strong>
     ：桥接应用代码与网络请求，补充请求头、处理 Cookie 和响应编码。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        请求头补充
       </strong>
       ：
       <br/>
       自动添加
       <strong>
        <code>
         User-Agent
        </code>
        、
        <code>
         Host
        </code>
        、
        <code>
         Content-Type
        </code>
       </strong>
       等头信息。
       <br/>
       若请求体为
       <strong>
        <code>
         RequestBody
        </code>
       </strong>
       ，自动计算
       <strong>
        <code>
         Content-Length
        </code>
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Cookie 管理
       </strong>
       ：
       <br/>
       通过
       <strong>
        <code>
         CookieJar
        </code>
       </strong>
       读取请求对应的 Cookie，写入
       <strong>
        <code>
         Cookie
        </code>
       </strong>
       头；保存响应中的
       <strong>
        <code>
         Set-Cookie
        </code>
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        响应解码
       </strong>
       ：
       <br/>
       若响应头包含
       <strong>
        <code>
         Content-Encoding: gzip
        </code>
       </strong>
       ，自动解压响应体。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       3. CacheInterceptor
      </strong>
     </span>
    </p>
    <p>
     <strong>
      核心职责
     </strong>
     ：根据缓存策略管理本地缓存，减少重复请求。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        缓存命中逻辑
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         根据请求生成缓存 Key，检查本地是否有有效缓存。
        </p>
       </li>
       <li>
        <p>
         若缓存未过期且有效（如
         <strong>
          <code>
           Cache-Control: max-age=3600
          </code>
         </strong>
         ），直接返回缓存响应，
         <strong>
          不再执行后续拦截器
         </strong>
         。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        缓存更新逻辑
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         若缓存过期或需要验证（如
         <strong>
          <code>
           Cache-Control: no-cache
          </code>
         </strong>
         ），添加条件头（如
         <strong>
          <code>
           If-Modified-Since
          </code>
         </strong>
         ）发起请求。
        </p>
       </li>
       <li>
        <p>
         若服务器返回 304 Not Modified，更新缓存元数据并返回缓存响应。
        </p>
       </li>
       <li>
        <p>
         若服务器返回新数据，写入缓存。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <img alt="" height="485" src="https://i-blog.csdnimg.cn/direct/997044065acf492aa6b2c47e6c297476.png" width="640"/>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      <span style="color:#4da8ee">
       4. ConnectInterceptor
      </span>
     </strong>
    </p>
    <p>
     <strong>
      核心职责
     </strong>
     ：建立与服务器的 TCP/TLS 连接，复用连接池。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        连接复用机制
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         根据请求的 URL、代理配置等生成连接标识（
         <strong>
          <code>
           Address
          </code>
         </strong>
         ）。
        </p>
       </li>
       <li>
        <p>
         从连接池（
         <strong>
          <code>
           ConnectionPool
          </code>
         </strong>
         ）中查找可用连接，若存在则复用。
        </p>
       </li>
       <li>
        <p>
         若无可用连接，创建新连接并加入连接池。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        连接释放
       </strong>
       ：
       <br/>
       请求完成后，连接被标记为空闲，连接池根据策略（默认最大空闲连接数 5，存活时间 5 分钟）清理过期连接。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       5. CallServerInterceptor
      </strong>
     </span>
    </p>
    <p>
     <strong>
      核心职责
     </strong>
     ：执行实际的网络 I/O 操作，发送请求并读取响应。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        请求发送
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         将请求头写入网络流。
        </p>
       </li>
       <li>
        <p>
         若有请求体（如 POST 数据），分块写入流。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        响应接收
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         读取响应头（如状态码、Content-Type）。
        </p>
       </li>
       <li>
        <p>
         读取响应体，支持分块传输（
         <strong>
          <code>
           Transfer-Encoding: chunked
          </code>
         </strong>
         ）。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        资源管理
       </strong>
       ：
       <br/>
       确保请求和响应流正确关闭，异常时释放连接。
      </p>
     </li>
    </ul>
    <hr/>
    <h5 id="3.3%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE" name="3.3%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE">
     3.3 拦截器协作流程图
    </h5>
    <pre><code class="language-java">请求发起 → RetryAndFollowUpInterceptor（重试/重定向）  
           ↓  
           BridgeInterceptor（补全请求头）  
           ↓  
           CacheInterceptor（查询缓存）  
           ↓  
           ConnectInterceptor（建立连接）  
           ↓  
           CallServerInterceptor（发送请求）  

响应返回 ← CallServerInterceptor（读取响应）  
           ↑  
           ConnectInterceptor（释放连接）  
           ↑  
           CacheInterceptor（更新缓存）  
           ↑  
           BridgeInterceptor（解压响应）  
           ↑  
           RetryAndFollowUpInterceptor（处理最终结果）</code></pre>
    <hr/>
    <h5 id="3.4%20%E5%85%B3%E9%94%AE%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" name="3.4%20%E5%85%B3%E9%94%AE%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90">
     3.4 关键场景分析
    </h5>
    <p>
     <strong>
      场景 1：缓存命中
     </strong>
    </p>
    <ol>
     <li>
      <p>
       请求到达
       <strong>
        <code>
         CacheInterceptor
        </code>
       </strong>
       ，发现有效缓存。
      </p>
     </li>
     <li>
      <p>
       直接返回缓存响应，后续拦截器（如
       <strong>
        <code>
         ConnectInterceptor
        </code>
       </strong>
       ）不再执行。
      </p>
     </li>
     <li>
      <p>
       节省网络开销，提升响应速度。
      </p>
     </li>
    </ol>
    <p>
     <strong>
      场景 2：重定向处理
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         CallServerInterceptor
        </code>
       </strong>
       收到 302 响应。
      </p>
     </li>
     <li>
      <p>
       响应返回到
       <strong>
        <code>
         RetryAndFollowUpInterceptor
        </code>
       </strong>
       ，生成新请求。
      </p>
     </li>
     <li>
      <p>
       重新执行整个拦截器链，直到成功或超出重试次数。
      </p>
     </li>
    </ol>
    <hr/>
    <h5 id="3.5%20%E6%80%BB%E7%BB%93" name="3.5%20%E6%80%BB%E7%BB%93">
     3.5 总结
    </h5>
    <p>
     OKHttp 通过五大拦截器的分工协作，实现了高效、灵活的网络请求处理：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        RetryAndFollowUpInterceptor
       </strong>
       ：保障请求的可靠性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        BridgeInterceptor
       </strong>
       ：简化开发，自动处理协议细节。
      </p>
     </li>
     <li>
      <p>
       <strong>
        CacheInterceptor
       </strong>
       ：优化性能，减少重复请求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        ConnectInterceptor
       </strong>
       ：从连接池中复用已有连接，跳过 TCP/TLS 握手，降低延迟。。
      </p>
     </li>
     <li>
      <p>
       <strong>
        CallServerInterceptor
       </strong>
       ：完成最终的网络 I/O。
      </p>
     </li>
    </ul>
    <p>
     理解拦截器链的流程，有助于开发者定制拦截器（如日志打印、加密）或优化网络行为（如缓存策略、连接池配置）。
    </p>
    <h4 id="" name="">
    </h4>
    <h4 id="%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96" name="%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96">
     四、常见问题与优化
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        内存泄漏
       </strong>
      </p>
      <ul>
       <li>
        <p>
         确保
         <code>
          Callback
         </code>
         或
         <code>
          Call
         </code>
         在 Activity/Fragment 销毁时取消：
        </p>
        <pre><code class="language-java">private Call call;
call = client.newCall(request);
call.enqueue(callback);

// 在 onDestroy() 中取消
if (call != null) call.cancel();</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        全局配置
       </strong>
      </p>
      <ul>
       <li>
        <p>
         推荐将
         <code>
          OkHttpClient
         </code>
         实例化为单例，避免重复创建连接池。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        自定义 DNS
       </strong>
      </p>
      <ul>
       <li>
        <p>
         替换默认 DNS 以优化解析：
        </p>
        <pre><code class="language-java">client = new OkHttpClient.Builder()
    .dns(hostname -&gt; {
        // 自定义 DNS 解析逻辑
        return InetAddress.getAllByName(hostname);
    })
    .build();</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" name="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">
     五、总结
    </h4>
    <p>
     <strong>
      OKHttp 的优势
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        高效
       </strong>
       ：连接池、HTTP/2 支持、缓存机制。
      </p>
     </li>
     <li>
      <p>
       <strong>
        灵活
       </strong>
       ：拦截器链可深度定制请求流程。
      </p>
     </li>
     <li>
      <p>
       <strong>
        易用
       </strong>
       ：简洁的 API 设计，支持同步/异步调用。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      适用场景
     </strong>
     ：移动端 API 调用、文件下载/上传、需要精细控制网络行为的场景。
    </p>
    <p>
     通过理解其原理，开发者能更好地优化网络层设计（如统一日志、请求加密、性能监控），并高效解决实际问题。
    </p>
    <p>
    </p>
    <p>
     其它推荐：
    </p>
    <p>
     <a class="link-info" href="https://blog.csdn.net/weijiangbc0/article/details/146150205?spm=1001.2014.3001.5502" title="《RxJava 深度解析：工作原理、核心操作符与高效实践指南》">
      《RxJava 深度解析：工作原理、核心操作符与高效实践指南》
     </a>
    </p>
    <p>
     <a class="link-info" href="https://blog.csdn.net/weijiangbc0/article/details/145509298?spm=1001.2014.3001.5502" title="《Binder机制原理分析· AIDL示例详解》">
      《Binder机制原理分析· AIDL示例详解》
     </a>
    </p>
    <p>
     <a class="link-info" href="https://blog.csdn.net/weijiangbc0/article/details/145355976?spm=1001.2014.3001.5502" title="《Android View 的事件分发机制解析》">
      《Android View 的事件分发机制解析》
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f7765696a69616e676263302f:61727469636c652f64657461696c732f313436313231353535" class_="artid" style="display:none">
 </p>
</div>


