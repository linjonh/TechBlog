---
layout: post
title: "C-.NET-EFCore-性能优化"
date: 2025-09-11T10:50:53+0800
description: "本文总结了EF Core性能优化的10个关键技巧：1)利用查询缓存减少编译开销；2)批量操作提升写入效率；3)避免延迟加载引发的N+1问题；4)采用异步操作提高吞吐量；5)只读查询禁用变更跟踪；6)确保查询字段建立索引；7)监控SQL日志优化查询；8)分页查询保证有序性；9)复杂查询使用原生SQL；10)合理配置连接池大小。这些方法涵盖了查询优化、批处理、异步编程等核心方面，可显著提升EF Core应用性能。"
keywords: "C# .NET EFCore 性能优化"
categories: ['C']
tags: ['性能优化', 'C', 'C', '.Net']
artid: "151573511"
arturl: "https://blog.csdn.net/weixin_42629287/article/details/151573511"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151573511
    alt: "C-.NET-EFCore-性能优化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151573511
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151573511
cover: https://bing.ee123.net/img/rand?artid=151573511
image: https://bing.ee123.net/img/rand?artid=151573511
img: https://bing.ee123.net/img/rand?artid=151573511
---



# C# .NET EFCore 性能优化


[#王者杯·14天创作挑战营·第5期#](https://activity.csdn.net/writing?id=10949)

#### 查询缓存优化

利用EF Core的查询缓存机制，相同的查询语句会被缓存，避免重复编译。对于频繁执行的查询，可以显式启用缓存：

```csharp
var compiledQuery = EF.CompileQuery(
    (DbContext context, int id) => 
        context.Products.FirstOrDefault(p => p.Id == id));

```

#### 批量操作处理

使用`AddRange`或`RemoveRange`替代单条操作，结合`SaveChanges`的批处理能力：

```csharp
context.Products.AddRange(productList);
context.SaveChanges();

```

启用批处理需要配置SQL Server提供程序：

```csharp
optionsBuilder.UseSqlServer(connectionString, 
    o => o.MaxBatchSize(100));

```

#### 延迟加载慎用

导航属性的延迟加载会导致N+1查询问题。显式加载或预加载更高效：

```csharp
var orders = context.Orders
    .Include(o => o.OrderDetails)
    .ToList();

```

#### 异步操作提升吞吐量

使用`async/await`避免线程阻塞：

```csharp
var product = await context.Products
    .FirstOrDefaultAsync(p => p.Id == id);

```

#### 跟踪行为控制

只读查询禁用变更跟踪：

```csharp
var products = context.Products
    .AsNoTracking()
    .Where(p => p.Price > 100)
    .ToList();

```

#### 索引优化

确保查询字段有数据库索引：

```csharp
modelBuilder.Entity<Product>()
    .HasIndex(p => p.CategoryId);

```

#### SQL日志监控

开发阶段开启日志检查生成SQL：

```csharp
optionsBuilder.UseLoggerFactory(loggerFactory)
    .EnableSensitiveDataLogging();

```

#### 分页查询优化

使用`Skip`/`Take`时确保有序：

```csharp
var pagedData = context.Products
    .OrderBy(p => p.Id)
    .Skip(20)
    .Take(10)
    .ToList();

```

#### 原始SQL复杂查询

高性能场景直接执行SQL：

```csharp
var products = context.Products
    .FromSqlRaw("SELECT * FROM Products WITH (NOLOCK)")
    .ToList();

```

#### 连接池配置

调整DbContext池大小避免资源争用：

```csharp
services.AddDbContextPool<AppDbContext>(options => 
    options.UseSqlServer(connectionString), poolSize: 128);

```



