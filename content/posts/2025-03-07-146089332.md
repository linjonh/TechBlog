---
layout: post
title: "C-模版"
date: 2025-03-07 15:12:17 +0800
description: "模版是泛型编程的基础 -> 什么是泛型编程？-> 代码复用的一种手段 -> 什么手段？-> 编写与类型无关的通用代码，所以模版就是一段与类型无关的通用代码！函数模版代表了一个函数家族，该函数模版与类型无关，使用时被参数化，根据实参类型生成特定类型的函数；class 类模版名//类成员template <class T>//template(关键字) + <class/typename T(T是根据传入的类型实例化出对应的类型)>class Apublic:A(T a,T b)_a = a;"
keywords: "C++ 模版★★★"
categories: ['未分类']
tags: ['模版', '开发语言', 'Windows', 'Visual', 'Studio', 'Java', 'C', 'C']
artid: "146089332"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146089332
    alt: "C-模版"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146089332
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146089332
cover: https://bing.ee123.net/img/rand?artid=146089332
image: https://bing.ee123.net/img/rand?artid=146089332
img: https://bing.ee123.net/img/rand?artid=146089332
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ 模版★★★
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Hello！！大家早上中午晚上好！！今天来复习模版部分知识点！！！
    </p>
    <h2>
     一、什么是模版？
    </h2>
    <p>
     模版是泛型编程的基础 -&gt; 什么是泛型编程？-&gt; 代码复用的一种手段 -&gt; 什么手段？ -&gt; 编写与类型无关的通用代码，所以模版就是一段与类型无关的通用代码！
    </p>
    <h2 style="background-color:transparent">
     二、什么是函数模版？
    </h2>
    <h5>
     模版分两类，一类是函数模版，一类是类模版；
    </h5>
    <h5>
     2.1函数模版的定义
    </h5>
    <p>
     函数模版代表了一个函数家族，该函数模版与类型无关，使用时被参数化，根据实参类型生成特定类型的函数；
    </p>
    <h5>
     2.2函数模版语法
    </h5>
    <p>
     template&lt;typename  T1,typename T2,...,typename Tn&gt;
    </p>
    <p>
     返回类型 函数名(参数列表){}
    </p>
    <h5>
     2.3简单的函数模版
    </h5>
    <pre><code class="language-cpp">template &lt;typename T&gt;
T Add(T a1, T a2)
{
	return a1 + a2;
}

int main()
{
	int a = 1, b = 2;
	double a1 = 1.2, b1 = 2.2;
	cout&lt;&lt;Add(a, b)&lt;&lt;endl;
	cout &lt;&lt; Add(a1, b1) &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="272" src="https://i-blog.csdnimg.cn/direct/77ca375bb7a246af8e4f348ca7d3f490.png" width="1952"/>
    </p>
    <h5 style="background-color:transparent">
     2.4模版的实例化：
    </h5>
    <p>
     <img alt="" height="914" src="https://i-blog.csdnimg.cn/direct/0e798ab5321045ceaf092e9e49ff482c.png" width="2436"/>
    </p>
    <p>
     只要写出通用的函数模版，编译器会根据传入的实参自动实例化出对应参数类型的函数！
    </p>
    <h5 style="background-color:transparent">
     2.5显式实例化
    </h5>
    <p>
     上面编译器根据参数类型自动推导出对应的函数，属于隐式实例化；当编译器不能自动推导的时候就需要显式实例化：
    </p>
    <p>
     <img alt="" height="782" src="https://i-blog.csdnimg.cn/direct/5c673532e074479a81850b12efe52067.png" width="1176"/>
    </p>
    <p>
     当Add传参第一个参数为int，第二个参数为double，且模版参数只有一个的时候，编译器不懂该实例化成int还是double，就会报错；这时有两个方法解决：一是强制类型转换，二是显式实例化
    </p>
    <p>
     <img alt="" height="482" src="https://i-blog.csdnimg.cn/direct/56e1655786d940cc8c1a89cb5a96c164.png" width="1420"/>
    </p>
    <p>
     显式实例化（只需要在函数名后加&lt;类型名&gt;）：
    </p>
    <p>
     <img alt="" height="608" src="https://i-blog.csdnimg.cn/direct/d6d1bbdaf53141e5a1c25ab40eedfbce.png" width="1572"/>
    </p>
    <p>
     注意：当参数类型不匹配时，编译器会尝试类型转换，如果转换失败还是会报错！
    </p>
    <h2>
     三、类模版
    </h2>
    <h5>
     3.1类模版的定义
    </h5>
    <pre><code class="language-cpp">template &lt;class T1,class T2,...,calss Tn&gt;
class 类模版名
{
    //类成员
};</code></pre>
    <p>
     简单的类模版：
    </p>
    <pre><code class="language-cpp">template &lt;class T&gt;//template(关键字) + &lt;class/typename T(T是根据传入的类型实例化出对应的类型)&gt;
class A
{
public:
	A(T a,T b)
	{
		_a = a;
		_b = b;
	}
	T Add()
	{
		return _a + _b;
	}
private:
	T _a;
	T _b;
};
int main()
{
	A&lt;int&gt; a(3, 5);//显式实例化对象a，并用3,5初始化
	cout &lt;&lt; a.Add() &lt;&lt; endl;//调用对象a里的成员函数Add()
    A&lt;double&gt; b(3.3, 5.5);
    cout &lt;&lt; b.Add() &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="314" src="https://i-blog.csdnimg.cn/direct/4cc43264b255477fb74bedf12f2fc753.png" width="1966"/>
    </p>
    <h5>
     3.2类模板的实例化
    </h5>
    <p>
     <img alt="" height="1292" src="https://i-blog.csdnimg.cn/direct/4abba20e9f9c4a4e991372f4d5c2480b.png" width="2202"/>
    </p>
    <h5>
     3.3非类型模版参数
    </h5>
    <p>
     模版参数分类型模版参数和非类型模版参数；
    </p>
    <p>
     跟在class 或typename 后面的是类型模版参数，没有跟在class或typename后面的是非类型模版参数；
    </p>
    <p>
     非类型模版参数：
     <strong>
      必须是常量，必须在编译时就能确定
     </strong>
     ！
    </p>
    <p>
     简单的非类型模版参数：
    </p>
    <pre><code class="language-cpp">template &lt;class T,size_t N=20&gt;//T为类型模版参数，size_t N=20为非类型模版参数
class Array
{
public:
	T&amp; operator[](size_t index)
	{
		return _arr[index];
	}
	size_t size()
	{
		return _size;
	}
private:
	T _arr[N];//使用非类型模版参数定义一个静态数组
	size_t size=0;

};</code></pre>
    <p>
     注意：非类型模版参数
     <strong>
      不能是 浮点型、不能是 类对象、不能是字符串
     </strong>
     ！
    </p>
    <h2>
     四、模版的特化
    </h2>
    <p>
     对于某些特殊的类型如果不进行特殊处理会参数错误的结果，这时候就需要模版的特化！！
    </p>
    <p>
     模版的特化必须要有模版原型才能特化！！
    </p>
    <p>
     例：两个数比小
    </p>
    <p>
    </p>
    <h5>
     4.1函数模版的特化
    </h5>
    <p>
     建议直接写函数就行！
    </p>
    <h5>
     4.2类模版的特化
    </h5>
    <p>
     类模板原形：
    </p>
    <pre><code class="language-cpp">template &lt;class T1,class T2&gt;
class A
{
public:
	A(T1 a, T2 b)
	{
		_a = a;
		_b = b;
	}
private:
	T1 _a;
	T2 _b;
};</code></pre>
    <p>
     类模版全特化：
    </p>
    <pre><code class="language-cpp">template&lt;&gt;//template 后面＋&lt;&gt;
class A&lt;double, double&gt;
{
public:
	A(double a, double b)
	{
		cout &lt;&lt; "A(double a,double b)" &lt;&lt; endl;
		_a = a;
		_b = b;
	}
private:
	double _a;
	double _b;
};</code></pre>
    <p>
     类模板的半特化：
    </p>
    <pre><code class="language-cpp">template&lt;class T1&gt;
class A&lt;T1, double&gt;
{
public:
	A(T1 a, double b)
	{
		cout &lt;&lt; "A(T1 a,double b)" &lt;&lt; endl;
		_a = a;
		_b = b;
	}
private:
	T1 _a; 
	double _b;
};</code></pre>
    <p>
     类模版的偏特化（针对模版参数更进一步的限制）：
    </p>
    <pre><code class="language-cpp">//两个参数偏特化为指针类型
template &lt;class T1, class T2&gt;
class A&lt;T1*, T2*&gt;
{
public:
	A(T1* a, T2* b)
	{
		cout &lt;&lt; "A(T1* a,T2* b)" &lt;&lt; endl;
		*_a = *a;
		*_b = *b;
	}
private:
	T1* _a;
	T2* _b;
};</code></pre>
    <pre><code class="language-cpp">//两个参数偏特化为引用类型
template &lt;class T1, class T2&gt;
class A&lt;T1&amp;, T2&amp;&gt;
{
public:
	A(T1&amp;a, T2&amp; b)
	{
		cout &lt;&lt; "A(T1&amp; a,T2&amp; b)" &lt;&lt; endl;
		_a = a;
		_b = b;
	}
private:
	T1&amp; _a;
	T2&amp; _b;
};</code></pre>
    <p>
     测试：
    </p>
    <pre><code class="language-cpp">int main()
{
	int aa = 10;
	int bb = 20;
	A&lt;int, int&gt; a(1, 2);
	A&lt;double, double&gt; b(1.1, 2.2);
	A&lt;int, double&gt; c(11, 22.2);
	A&lt;int*, int*&gt;d(&amp;aa, &amp;bb);
	A&lt;int&amp;, int&amp;&gt;e(aa, bb);
	return 0;
}</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="414" src="https://i-blog.csdnimg.cn/direct/5b0186fe182d461bba38a4a6cc0bbaf2.png" width="1954"/>
    </p>
    <h2>
     五、模版分离编译
    </h2>
    <p>
     当类模板的声明和定义分离在不同文件时，执行会发生错误
    </p>
    <pre><code class="language-cpp">//a.cpp定义
 #define _CRT_SECURE_NO_WARNINGS 1
#include "a.h"
template&lt;class T&gt;
T Add(T a, T b)
{
	return a + b;
}</code></pre>
    <pre><code class="language-cpp">//a.h声明
#pragma once
template &lt;class T&gt;
T Add(T t1, T t2);</code></pre>
    <pre><code class="language-cpp">//test.cpp测试调用
#include "a.h"
int main()
{
	cout &lt;&lt; Add(1, 2) &lt;&lt; endl;
	cout &lt;&lt; Add(1.1, 2.2) &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     运行报错：
    </p>
    <p>
     <img alt="" height="220" src="https://i-blog.csdnimg.cn/direct/8bd47da3ec3b46c49f779ffd134a1cf2.png" width="2384"/>
    </p>
    <p>
     原因分析：
    </p>
    <p>
     因为每个.cpp文件都是分离编译生成各自的.obj文件，编译时，编译器看向.app文件时，没有看到对Add函数模版的实例化，不会实例化出具体的Add函数代码；然后在链接阶段，test.cpp调用了Add函数发生错误！！
    </p>
    <p>
     解决方法：
    </p>
    <p>
     声明定义在同一文件中！
    </p>
    <pre><code class="language-cpp">#pragma once
//在.h文件内直接定义，不分离
template&lt;class T&gt;
T Add(T a, T b)
{
	return a + b;
}</code></pre>
    <pre><code class="language-cpp">//test.cpp
#include "a.h"
int main()
{
	cout &lt;&lt; Add(1, 2) &lt;&lt; endl;
	cout &lt;&lt; Add(1.1, 2.2) &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     <img alt="" height="296" src="https://i-blog.csdnimg.cn/direct/40aa0b22ae104c0ab665f1757855065f.png" width="2322"/>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#fe2c24">
      好了，今天就复习到这里！！如果您有收获请点赞收藏+关注哦！谢谢！！！
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      如果您有更好的建议欢迎评论区留言！！
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      咱下期见！！！
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333233383039352f:61727469636c652f64657461696c732f313436303839333332" class_="artid" style="display:none">
 </p>
</div>


