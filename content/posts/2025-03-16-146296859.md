---
layout: post
title: "C一文吃透STL容器list"
date: 2025-03-16 19:27:09 +0800
description: "list，作为STL中的双向链表容器，以其灵活的操作方式和特定的性能特性，在众多编程任务中崭露头角。与数组等其他容器相比，list有着自己独特的内部结构和行为模式。它不需要像数组那样进行大规模的内存重新分配来适应元素的增减，而是能够高效地在任意位置进行元素的插入和删除操作。无论是在需要频繁修改元素顺序的算法中，还是在构建复杂的数据结构关系时，list都能发挥不可替代的作用。本文将深入剖析C++ STL中的list。"
keywords: "【C++】一文吃透STL容器——list"
categories: ['C']
tags: ['数据结构', '开发语言', 'List', 'C']
artid: "146296859"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296859
    alt: "C一文吃透STL容器list"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296859
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296859
cover: https://bing.ee123.net/img/rand?artid=146296859
image: https://bing.ee123.net/img/rand?artid=146296859
img: https://bing.ee123.net/img/rand?artid=146296859
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【C++】一文吃透STL容器——list
    </h1>
   </div>
  </div>
 </div>
 <a data-report-click='{"spm":"1001.2101.3001.8632"}' data-report-query="spm=1001.2101.3001.8632" data-report-view='{"spm":"1001.2101.3001.8632"}' href="https://activity.csdn.net/writing?id=10858" id="creatActivityHref" style="display:block;margin-top:16px;font-size:16px;color:#5094d5;font-weight:500" target="_blank">
  #新星杯·14天创作挑战营·第9期#
 </a>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="800" src="https://i-blog.csdnimg.cn/direct/7246009c63124215be6d0feb14de2344.png" width="1067"/>
    </h2>
    <h2 id="%E5%89%8D%E8%A8%80" name="%E5%89%8D%E8%A8%80">
     前言
    </h2>
    <p>
     <code>
      list
     </code>
     ，作为STL中的
     <u>
      <span style="color:#fe2c24">
       <strong>
        双向链表
       </strong>
      </span>
     </u>
     容器，以其灵活的操作方式和特定的性能特性，在众多编程任务中崭露头角。与数组等其他容器相比，
     <code>
      list
     </code>
     有着自己独特的内部结构和行为模式。它不需要像数组那样进行大规模的内存重新分配来适应元素的增减，而是能够高效地在任意位置进行元素的插入和删除操作。无论是在需要频繁修改元素顺序的算法中，还是在构建复杂的数据结构关系时，
     <code>
      list
     </code>
     都能发挥不可替代的作用。
    </p>
    <p>
     本文将深入剖析C++ STL中的
     <code>
      list
     </code>
     容器，从它的基本定义、内部结构，到常用的成员函数操作，再到实际应用中的性能考量等多方面进行全面的介绍，带领读者逐步揭开
     <code>
      list
     </code>
     容器的神秘面纱，领略其在C++编程世界中的强大功能和独特价值。
    </p>
    <hr/>
    <h2 id="list%E7%9A%84%E6%9E%84%E9%80%A0" name="list%E7%9A%84%E6%9E%84%E9%80%A0">
     list的构造
    </h2>
    <p>
     还是那句话，
     <u>
      <span style="color:#0d0016">
       <strong>
        要使用，就要先创造
       </strong>
      </span>
     </u>
    </p>
    <p>
     list提供了多种构造方式，以满足不同的初始化需求。以下是常见的list构造方法
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       方法一:无参构造
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; emptyList;</code></pre>
    <blockquote>
     <p>
      朴实无华，创建一个空的list类对象
     </p>
    </blockquote>
    <p>
     <span style="color:#956fe7">
      <strong>
       方法二:用 n 个 x 值初始化一个list对象
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">list&lt;int&gt; lt(n,x);</code></pre>
    <blockquote>
     <p>
      <span style="color:#fe2c24">
       <strong>
        注意:
       </strong>
      </span>
      使用这种构造方式时，如果只传递数量，而没有传递初始值，则会调用该类型默认的构造函数对list中的元素进行初始化
     </p>
    </blockquote>
    <p>
     <span style="color:#956fe7">
      <strong>
       方法三:使用迭代器区间初始化
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1,2,3,4,5};
std::list&lt;int&gt; lt(vec.begin(),vec.end()); </code></pre>
    <blockquote>
     <p>
      STL容器的宗门底蕴，只要有迭代器，均可以使用迭代器对容器进行初始化
     </p>
    </blockquote>
    <h2 id="list%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0" name="list%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">
     list的常用函数
    </h2>
    <p>
     知道了如何创造，接下来就是如何使用了
    </p>
    <p>
     见识一list容器提供的常用函数
    </p>
    <h3 id="%E5%A4%B4%E6%8F%92%E2%80%94%E2%80%94push_front%E5%87%BD%E6%95%B0" name="%E5%A4%B4%E6%8F%92%E2%80%94%E2%80%94push_front%E5%87%BD%E6%95%B0">
     头插——push_front函数
    </h3>
    <p>
     <code>
      push_front
     </code>
     是
     <code>
      std::list
     </code>
     提供的一个成员函数，用于在列表的前端插入一个新元素。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">void push_front(const T&amp; value);</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       参数说明:
      </strong>
     </span>
    </p>
    <ul>
     <li>
      const T&amp; value:要插入的元素的常量引用。
     </li>
    </ul>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本使用：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList;
myList.push_front(10);//使用 push_front 在列表前端插入元素</code></pre>
    <h3 id="%E5%A4%B4%E5%88%A0%E2%80%94%E2%80%94pop_front%E5%87%BD%E6%95%B0" name="%E5%A4%B4%E5%88%A0%E2%80%94%E2%80%94pop_front%E5%87%BD%E6%95%B0">
     头删——pop_front函数
    </h3>
    <p>
     <code>
      pop_back
     </code>
     是
     <code>
      std::list
     </code>
     提供的一个成员函数，用于移除列表中的最后一个元素。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">void pop_back();</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本用法:
      </strong>
     </span>
    </p>
    <pre><code> myList.pop_back();</code></pre>
    <h3 id="%E5%B0%BE%E6%8F%92%E2%80%94%E2%80%94push_back%E5%87%BD%E6%95%B0" name="%E5%B0%BE%E6%8F%92%E2%80%94%E2%80%94push_back%E5%87%BD%E6%95%B0">
     尾插——push_back函数
    </h3>
    <p>
     push_back()用于在列表的末尾插入一个新元素。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">void push_back(const T&amp; value);</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       参数说明:
      </strong>
     </span>
    </p>
    <ul>
     <li>
      const T&amp;value要插入的元素的常量引用。
     </li>
    </ul>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本用法:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList;
myList.push_back(10);// 使用 push_back 在列表末尾插入元素</code></pre>
    <h3 id="%E5%B0%BE%E5%88%A0%E2%80%94%E2%80%94pop_back%E5%87%BD%E6%95%B0" name="%E5%B0%BE%E5%88%A0%E2%80%94%E2%80%94pop_back%E5%87%BD%E6%95%B0">
     尾删——pop_back函数
    </h3>
    <p>
     pop_back是list提供的一个成员函数，用于移除列表中的最后一个元素。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">void pop_back();</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本用法:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList = {10, 20, 30, 40, 50};
     myList.pop_back();</code></pre>
    <h2 id="list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" name="list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">
     list的迭代器
    </h2>
    <p>
     在
     <a class="link-info" href="https://blog.csdn.net/2402_85267481/article/details/146186127" title="【C++】一文熟练STL容器——vector">
      【C++】一文熟练STL容器——vector
     </a>
     中，我们说过，迭代器类似于指针
    </p>
    <p>
     怎么用指针，怎么就用迭代器
    </p>
    <p>
     但迭代器只是接近指针，并不是真正的原生指针，只是用封装屏蔽了底层差异
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       list的迭代器就不是原生指针，而是一个 指向list某个结点 的指针
      </strong>
     </span>
    </p>
    <p>
     它的造型是这样的
    </p>
    <pre><code class="language-cpp">typedef ListNode&lt;T&gt; Node;
Node* _node;</code></pre>
    <p>
     这个_node 指向的数据的造型，是这样的
    </p>
    <pre><code class="language-cpp">struct ListNode {
		T data;
		ListNode&lt;T&gt;* prev;
		ListNode&lt;T&gt;* next;
}</code></pre>
    <p>
     这个结构体，就是list存储实际数据的载体
    </p>
    <p>
     <u>
      <span style="color:#0d0016">
       <strong>
        它内部有两个指针，分别指向前一个ListNode类对象和下一个ListNode类对象，以此达到连接的效果，让不连续的每个ListNode对象在逻辑上成为一个线性结构
       </strong>
      </span>
     </u>
    </p>
    <p>
     我们对指针进行++，就是希望指针直接指向下一个数据
    </p>
    <p>
     而对list迭代器进行++,就是希望迭代器直接指向下一个ListNode对象
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       ListNode的原生指针显然做不到这一点，因为list的数据元素并不是连续的，盲目对原生指针 ++ ，指针会指向一个未知的位置，从而引发解引用错误
      </strong>
     </span>
    </p>
    <p>
     因此list迭代器就是对
     <u>
      <span style="color:#fe2c24">
       <strong>
        ListNode的原生指针进行封装，内部实现一系列方法，指向外提供简单的接口，以此屏蔽底层的差异。
       </strong>
      </span>
     </u>
    </p>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94begin%E5%87%BD%E6%95%B0" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94begin%E5%87%BD%E6%95%B0">
     迭代器函数——begin函数
    </h3>
    <p>
     begin函数用于返回一个指向列表中第一个元素的迭代器。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">iterator begin();
</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       返回值说明:
      </strong>
     </span>
    </p>
    <ul>
     <li>
      iterator可修改元素的迭代器。
     </li>
    </ul>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本用法:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList = {10, 20, 30, 40, 50};
auto it = myList.begin();//返回第一个迭代器</code></pre>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94end%E5%87%BD%E6%95%B0" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94end%E5%87%BD%E6%95%B0">
     迭代器函数——end函数
    </h3>
    <p>
     end函数用于返回一个指向列表末尾的迭代器。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">iterator end();</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       返回值说明:
      </strong>
     </span>
    </p>
    <ul>
     <li>
      iterator:可修改元素的迭代器。
     </li>
    </ul>
    <p>
     <strong>
      <span style="color:#956fe7">
       基本用法:
      </span>
     </strong>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList = {10, 20, 30, 40, 50};
auto it = myList.end(); </code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       <span style="background-color:#ffd900">
        使用 begin() 与 end() 对 list对象 进行遍历
       </span>
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList = {10, 20, 30, 40, 50};

    // 使用 begin() 和 end() 遍历并输出列表中的元素
    std::cout &lt;&lt; "列表中的元素: ";
    for (auto it = myList.begin(); it != myList.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       <span style="background-color:#ffd900">
        运行结果:
       </span>
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
      </strong>
     </span>
     <img alt="" height="37" src="https://i-blog.csdnimg.cn/direct/6136013f4e5f4b7abb31c4663abe95dc.png" width="384"/>
    </p>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94insert%E5%87%BD%E6%95%B0" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94insert%E5%87%BD%E6%95%B0">
     迭代器函数——insert函数
    </h3>
    <p>
     insert函数用于在列表的指定位置插入一个或多个新元素。
    </p>
    <p>
     list的底层是双向链表，使用insert进行插入，不会影响其他存在的数据。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">iterator insert(const_iterator pos, const T&amp; value);</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       参数说明:
      </strong>
     </span>
    </p>
    <ul>
     <li>
      pos:插入位置的迭代器，指向要插入新元素的位置。
     </li>
     <li>
      value要插入的元素的常量引用或右值引用。
     </li>
    </ul>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本用法:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList = {1, 2, 3};
myList.insert(myList.end(), 4);//等同于push_back</code></pre>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94erase%E5%87%BD%E6%95%B0" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94erase%E5%87%BD%E6%95%B0">
     迭代器函数——erase函数
    </h3>
    <p>
     erase函数用于移除列表中的一个或多个元素。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       函数造型:
      </strong>
     </span>
    </p>
    <pre><code>iterator erase(const_iterator pos);</code></pre>
    <p>
     <span style="color:#956fe7">
      <strong>
       参数说明:
      </strong>
     </span>
    </p>
    <ul>
     <li>
      pos指向要删除的单个元素的迭代器。
     </li>
    </ul>
    <p>
     <strong>
      <span style="color:#956fe7">
       返回值说明：
      </span>
     </strong>
    </p>
    <ul>
     <li>
      返回指向下一个元素的迭代器。
     </li>
    </ul>
    <p>
     <span style="color:#956fe7">
      <strong>
       基本用法:
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">std::list&lt;int&gt; myList = {1, 2, 3, 4, 5};
     it = myList.erase(it);</code></pre>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88">
     迭代器失效
    </h3>
    <p>
     list的底层结构为带头结点的
     <span style="color:#fe2c24">
      <strong>
       双向循环链表
      </strong>
     </span>
     ，因此在list中进行插入时是不会导致list的迭代器失效的，只有在删除时才会失效，并且失效的只有指向被删除节点的迭代器，其他迭代器不会受到影响。
    </p>
    <h2 id="%C2%A0%E8%A1%A5%E5%85%85%E5%87%BD%E6%95%B0" name="%C2%A0%E8%A1%A5%E5%85%85%E5%87%BD%E6%95%B0">
     补充函数
    </h2>
    <p>
     list提供的接口函数不止我们介绍的这些，但我们介绍的都是重要的，建议记住
    </p>
    <p>
     以下是一些不常用的函数
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       <span style="background-color:#ffd900">
        与容量相关
       </span>
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="154" src="https://i-blog.csdnimg.cn/direct/bfeb1020c8ab4cb1857caf9243647edb.png" width="805"/>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       <span style="background-color:#ffd900">
        与元素访问相关
       </span>
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="99" src="https://i-blog.csdnimg.cn/direct/0346f4209bfe46ceb954a6f9f63642a0.png" width="787"/>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       <span style="background-color:#ffd900">
        与交换相关
       </span>
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="97" src="https://i-blog.csdnimg.cn/direct/08d45449d45b47e2b0efe79e3d7d32a3.png" width="739"/>
    </p>
    <hr/>
    <h2 id="%C2%A0%E7%BB%93%E8%AF%AD" name="%C2%A0%E7%BB%93%E8%AF%AD">
     结语
    </h2>
    <p>
     我们对 list 容器的探索即将告一段落，但探索的道路永无止境。list作为C++ STL中一个重要的组成部分，与我们之前和后续要学习的其他容器和算法都有着千丝万缕的联系。比如，如何结合迭代器更高效地操作list，或者如何与其他容器配合使用来解决复杂的问题，这些都是值得我们深入研究的课题。希望大家以此次对list的学习为起点，不断探索和实践，进一步挖掘C++ STL的强大潜力。
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38353236373438312f:61727469636c652f64657461696c732f313436323936383539" class_="artid" style="display:none">
 </p>
</div>


