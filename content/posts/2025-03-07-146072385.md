---
layout: post
title: "使用数据库和缓存的时候,是如何解决数据不一致的问题的"
date: 2025-03-07 00:00:06 +0800
description: "读写双删相对出现数据不一致的概率比较低，但也并不是一定的，如果在A线程删除缓存之后，更新数据库之前，此时有另一个线程B进来进行读操作，因为B的缓存未命中直接访问数据库，然后又会把数据写入缓存，此时缓存里的数据就是更新前的数据，但是A依然会进行更新数据库的操作，然后就导致数据库的数据和缓存不一致，当线程C来访问的时候，因为缓存命中，所以直接读到了旧数据。在应用里负责管理缓存，读取时先查缓存，如果命中了则返回缓存，如果未命中就查询数据库，然后返回缓存，返回缓存的同时把数据给写入缓存中。"
keywords: "使用数据库和缓存的时候，是如何解决数据不一致的问题的？"
categories: ['未分类']
tags: ['缓存', '数据库', '数据一致性']
artid: "146072385"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146072385
    alt: "使用数据库和缓存的时候,是如何解决数据不一致的问题的"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146072385
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146072385
cover: https://bing.ee123.net/img/rand?artid=146072385
image: https://bing.ee123.net/img/rand?artid=146072385
img: https://bing.ee123.net/img/rand?artid=146072385
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     使用数据库和缓存的时候，是如何解决数据不一致的问题的？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="1_2">
     </a>
     1.缓存更新策略
    </h3>
    <h4>
     <a id="11_Cache_Aside_4">
     </a>
     1.1. 缓存旁路模式（Cache Aside）
    </h4>
    <p>
     在应用里负责管理缓存，读取时先查缓存，如果命中了则返回缓存，如果未命中就查询数据库，然后返回缓存，返回缓存的同时把数据给写入缓存中。更新的时候则是先更新数据库，然后再删除缓存。
    </p>
    <p>
     <strong>
      读：
     </strong>
     先查缓存，缓存命中则之间返回，未命中则查数据库，数据库返回数据的同时写入缓存中。这样子下一次再查的时候就可以命中缓存了。
    </p>
    <p>
     <strong>
      写：
     </strong>
     先更新数据库，更新之后删除缓存。
    </p>
    <p>
     优点是比较简单，对数据一致性要求不高的时候大多数场景能用，缺点就是可能会有短时间的数据不一致问题，主要是在写操作中删除缓存的时候。为什么会有数据不一致的时候呢？如果在把A改为B之后，缓存里还是A，但是在删除缓存之前，此时另一个线程已经进来了要读取缓存，那么它读取到的就是A（也就是旧的数据），它命中缓存了所以不会再访问数据库，但是此时数据库是B，明显出现了数据不一致的问题。这种情况一般是在并发情况出现。
    </p>
    <h4>
     <a id="12Write_Through_13">
     </a>
     1.2.写穿透模式（Write Through）
    </h4>
    <p>
     更新数据库的同时更新缓存，保障数据一致。
    </p>
    <p>
     <strong>
      读：
     </strong>
     直接查缓存。
    </p>
    <p>
     <strong>
      写：
     </strong>
     先更新数据库再更新缓存。
    </p>
    <p>
     优点是数据一致性比较高，缺点是每次写操作都会更新缓存，缓存的压力可能会比较大。
    </p>
    <h4>
     <a id="13Write_Back_22">
     </a>
     1.3.写回模式（Write Back）
    </h4>
    <p>
     <strong>
      读：
     </strong>
     直接查缓存。
    </p>
    <p>
     <strong>
      写：
     </strong>
     先更新缓存，然后异步更新数据库。
    </p>
    <h4>
     <a id="14_27">
     </a>
     1.4.读写双删（属于缓存旁路模式的扩展）
    </h4>
    <p>
     在应用里负责管理缓存，读取时先查缓存，如果命中了则返回缓存，如果未命中就查询数据库，然后返回缓存，返回缓存的同时把数据给写入缓存中。更新的时候则是先更新数据库，然后再删除缓存，隔段时间再删除一次缓存，也就是一共删了两次缓存。
    </p>
    <p>
     <strong>
      读：
     </strong>
     先查缓存，缓存命中则之间返回，未命中则查数据库，数据库返回数据的同时写入缓存中。这样子下一次再查的时候就可以命中缓存了。
    </p>
    <p>
     <strong>
      写：
     </strong>
     先删除缓存，然后更新数据库，更新之后再次删除缓存。
    </p>
    <p>
     要知道
     <strong>
      缓存旁路模式
     </strong>
     在并发情况下，可能会出现数据不一致问题，如果并发量比较高的话，出现问题的概率就会变大，所以有了读写双删这个扩展的方式。
    </p>
    <p>
     具体实现：
     <br/>
     1.先删除缓存（防止更新数据库后获取缓存的请求获取到旧数据）
     <br/>
     2.然后更新数据库
     <br/>
     3.然后删除缓存（防止此时的缓存里的数据和数据库里的不一致）
    </p>
    <p>
     读写双删相对出现数据不一致的概率比较低，但也并不是一定的，如果在A线程删除缓存之后，更新数据库之前，此时有另一个线程B进来进行读操作，因为B的缓存未命中直接访问数据库，然后又会把数据写入缓存，此时缓存里的数据就是更新前的数据，但是A依然会进行更新数据库的操作，然后就导致数据库的数据和缓存不一致，当线程C来访问的时候，因为缓存命中，所以直接读到了旧数据。
    </p>
    <h4>
     <a id="15Double_Delete_43">
     </a>
     1.5.
     <strong>
      读写双删（Double Delete）
     </strong>
    </h4>
    <p>
     具体实现：
     <br/>
     1.先删除缓存（防止更新数据库后获取缓存的请求获取到旧数据）
     <br/>
     2.然后更新数据库
     <br/>
     3.等待一段时候后
     <br/>
     4.然后删除缓存（防止此时的缓存里的数据和数据库里的不一致）
    </p>
    <h3>
     <a id="_51">
     </a>
     缓存失效策略
    </h3>
    <h4>
     <a id="21_52">
     </a>
     2.1.主动失效
    </h4>
    <p>
     在数据库更新的时候，立刻删除缓存或者更新缓存。
     <br/>
     <strong>
      读：
     </strong>
     直接查缓存。
    </p>
    <p>
     <strong>
      写：
     </strong>
     先写数据库，然后删缓存或者立马更新缓存。
    </p>
    <h4>
     <a id="22_58">
     </a>
     2.2.被动失效
    </h4>
    <p>
     给缓存设置TTL（过期时间），过期后自动失效。
     <br/>
     <strong>
      读：
     </strong>
     直接查缓存。
    </p>
    <p>
     <strong>
      写：
     </strong>
     写入缓存时，设置TTL
    </p>
    <p>
     优点是比较简单，缺点就是在缓存过期后、更新缓存前，可能会有短暂的数据不一致。
    </p>
    <h3>
     <a id="_66">
     </a>
     双写一致性策略
    </h3>
    <h4>
     <a id="31_67">
     </a>
     3.1.分布式锁
    </h4>
    <p>
     在更新数据库和缓存的时候，使用分布式锁，确保操作是原子性的（要么都成功要么都失败）。主要流程就是【获取分布式锁&gt;&gt;更新数据库&gt;&gt;更新缓存&gt;&gt;释放分布式锁】，优点是确保强一致性，缺点也很明显，因为加了锁所以没法支持并行操作，多线程到这里变成排队的单线程操作，会导致性能比较低。适用于对性能要求不高并且对数据一致性要求很高的场景。
    </p>
    <h4>
     <a id="32_70">
     </a>
     3.2.消息队列
    </h4>
    <p>
     通过消息队列通知更新缓存，确保最终一致性（和强一致不一样）。主要流程就是【更新数据&gt;&gt;发送消息&gt;&gt;消费者读取消息更新缓存】，优点是异步操作，性能较好，缺点也是因为异步，所以缓存会有延迟，如果在更新缓存之前有其他请求获取缓存，可能就会出现数据不一致的情况。
    </p>
    <h3>
     <a id="_73">
     </a>
     其他一致性策略
    </h3>
    <h4>
     <a id="41_74">
     </a>
     4.1.读写分离
    </h4>
    <p>
     顾名思义，就是把读和写分开处理，读操作是从缓存中读数据，写操作则是更新数据库，并且更新缓存（即时或者异步都可），优点就是读性能会很好，缺点就是写操作时可能会导致数据库和缓存出现数据不一致的问题。
    </p>
    <h4>
     <a id="42_77">
     </a>
     4.2.版本控制
    </h4>
    <p>
     给缓存添加一个版本号，每次更新缓存都增加版本号，确保版本和数据库的版本一致。优点就是能保障数据的一致性，缺点是实现起来比较复杂。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33313836303634372f:61727469636c652f64657461696c732f313436303732333835" class_="artid" style="display:none">
 </p>
</div>


