---
layout: post
title: "LinuxExt系列文件系统"
date: 2025-03-12 20:26:38 +0800
description: "物理磁盘了解，OS_Ext文件系统了解，软硬链接"
keywords: "【Linux】Ext系列文件系统"
categories: ['Linux']
tags: ['软硬链接', '物理磁盘', 'Linux', 'Ext', 'C']
artid: "146213860"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146213860
    alt: "LinuxExt系列文件系统"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146213860
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146213860
cover: https://bing.ee123.net/img/rand?artid=146213860
image: https://bing.ee123.net/img/rand?artid=146213860
img: https://bing.ee123.net/img/rand?artid=146213860
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Linux】Ext系列文件系统
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%20%E6%95%B4%E4%BD%93%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE" name="1.%20%E6%95%B4%E4%BD%93%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">
     1. 整体学习思维导图
    </h2>
    <p>
     <img alt="" height="542" src="https://i-blog.csdnimg.cn/direct/ddfeed046a024e0ab5bfccc8b46324f1.png" width="1101">
     </img>
    </p>
    <h2 id="2.%20%E8%AE%A4%E8%AF%86%E7%90%86%E8%A7%A3%E7%A3%81%E7%9B%98" name="2.%20%E8%AE%A4%E8%AF%86%E7%90%86%E8%A7%A3%E7%A3%81%E7%9B%98">
     2. 认识理解磁盘
    </h2>
    <p>
     了解文件系统离不开存储文件的硬件--磁盘，我们需要认识一下磁盘的构造！
    </p>
    <p>
     <img alt="" height="492" src="https://i-blog.csdnimg.cn/direct/bc2ee5eb235942569c5c817f339b4e3e.png" width="1300">
     </img>
    </p>
    <p>
     磁盘如图所示，我们可以看见许多部件：磁头，盘片，机械臂杆，主轴等等，并且一个磁盘由多个盘片构成，一张盘片的正反面都可以存储信息，正反也存在着两个读写的磁头。
    </p>
    <h3 id="%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86" name="%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86">
     存储原理
    </h3>
    <p>
     首先需要定位到需要读取的
     <strong>
      柱面，
     </strong>
     然后确定对应的
     <strong>
      磁头
     </strong>
     <strong>
      ，
     </strong>
     此时的盘片正在高速转动，磁头定位到我们需要读取的
     <strong>
      扇区
     </strong>
     ，我们知道盘片由一个个小的磁性分子组成，磁性存在着两级正好对应计算机中的0和1，写入文件时我们只需要改变其磁性即可实现，读取文件时我们收集其磁性的排列进行解读即可得到信息。
    </p>
    <ul>
     <li>
      <p>
       CHS定址
      </p>
     </li>
    </ul>
    <p>
     指的就是我们前面定位的过程：先确定柱面(cylinder)，次之磁头(head)，最后是扇区(sector)！
    </p>
    <h3 id="%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84" name="%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">
     物理结构
    </h3>
    <p>
     我们从硬件物理的角度来看，磁盘由一个个盘片构成，物理结构是一种圆形的，那么磁盘在我们计算机是以什么样的存储方式描述的呢？答案是线性的结构，类似于数组一样的，那么圆形怎么到线性的结构？我们知道盘片就像一圈圈的
     <strong>
      磁道
     </strong>
     "卷"起来的,我们将他舒展开来不就是一个线性的结构吗？
    </p>
    <p>
     <img alt="" height="426" src="https://i-blog.csdnimg.cn/direct/e5f13c498a1248318ff6e9e0c39916dc.png" width="1303">
     </img>
    </p>
    <h3 id="%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84" name="%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">
     逻辑结构
    </h3>
    <p>
     对于一个盘片来说磁道展开是一个一维数组，我们的磁盘由多个盘片组成，多个盘片构成的就是柱面，这个柱面的构造展示给我们的就是一个多维数组的样子：
    </p>
    <p class="img-center">
     <img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/dd55398a313347beaab1aea19da7a8f1.png" width="517"/>
    </p>
    <ul>
     <li>
      <p>
       多个柱面
      </p>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="798" src="https://i-blog.csdnimg.cn/direct/43d0566b64f74aaf801049898e9be2ea.png" width="555"/>
    </p>
    <p>
     但是在我们所学的c/c++底层中的多维数组最后还是一个线性的一维数组，我们将柱面拼接起来，磁盘拼接起来，我们就会得到一个线性的数组结构！
    </p>
    <p>
     <img alt="" height="167" src="https://i-blog.csdnimg.cn/direct/c7efb63ee2764ef69ea71d2ee1b49c49.png" width="1280"/>
    </p>
    <h3 id="CHS%20%26%26%20LAB%20%E5%AE%9A%E5%9D%80" name="CHS%20%26%26%20LAB%20%E5%AE%9A%E5%9D%80">
     CHS &amp;&amp; LAB 定址
    </h3>
    <p>
     OS文件系统访问磁盘，不以扇区为单位，而是以"块"为单位，一般单次访问是4KB(连续的8个扇区)，这个访问的大小可以调整。对于物理磁盘来说是CHS寻址，但是对于OS来说就需要换一种形式的寻址-&gt;LAB！
    </p>
    <ul>
     <li>
      <p>
       LAB和CHS的相互转换
      </p>
      <ul>
       <li>
        <p>
         <strong>
          LAB = 柱面号 *
         </strong>
         <strong>
          磁头
         </strong>
         <strong>
          数 * 每个
         </strong>
         <strong>
          磁道
         </strong>
         <strong>
          的
         </strong>
         <strong>
          扇区
         </strong>
         <strong>
          个数 + 磁头号 * 每个磁道的扇区个数 + 扇区个数 - 1（-1是因为LAB地址从0开始，扇区号基本从1开始）
         </strong>
        </p>
       </li>
       <li>
        <p>
         <strong>
          CHS = LAB % (
         </strong>
         <strong>
          磁头
         </strong>
         <strong>
          数 * 每个
         </strong>
         <strong>
          磁道
         </strong>
         <strong>
          的
         </strong>
         <strong>
          扇区
         </strong>
         <strong>
          个数) + LAB % (磁头号 * 每个磁道的扇区个数) + LAB % (每个磁道的扇区个数) + 1
         </strong>
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     有了这个转换关系，我们OS就可以使用一串数字去访问对应的磁盘位置了！
    </p>
    <h2 id="3.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" name="3.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">
     3. 文件系统
    </h2>
    <h3 id="3.1%20%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5" name="3.1%20%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5">
     3.1 块的概念
    </h3>
    <p>
     我们前面提到过"块"，单次访问扇区的速率太低，我们OS一次访问8个扇区，我们将其命名为一个块,块的大小常见的是4KB,"块"是文件存储的最小单位
    </p>
    <pre><code class="language-bash">[ouyang@iZ2ze0j6dd76e0o9qypo2rZ ~]$ stat Linux_Git/
  File: ‘Linux_Git/’
  Size: 4096              Blocks: 8          IO Block: 4096   directory
Device: fd01h/64769d        Inode: 1315336     Links: 3
Access: (0775/drwxrwxr-x)  Uid: ( 1001/  ouyang)   Gid: ( 1001/  ouyang)
Access: 2025-02-27 10:18:08.496640943 +0800
Modify: 2025-02-27 10:18:06.488552668 +0800
Change: 2025-02-27 10:18:06.488552668 +0800
 Birth: -</code></pre>
    <p>
     块号 = LAB / 8
    </p>
    <h3 id="3.2%20%E5%88%86%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5" name="3.2%20%E5%88%86%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5">
     3.2 分区的概念
    </h3>
    <p>
     我们知道现在计算机的存在着好几个盘：C/D/E等等，其实底层他们是一块总的内存是通过分区来实现多个盘的，比如一个800G的存储，我们可能会以300G为单位分区为3个区，每个区含有大量的快组成：
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/3e7266edb9b14175bae48e562aa6ec6f.png" width="1280"/>
    </p>
    <p>
     一个分区又可以分为多个组，每个组这边以30G来划分：
    </p>
    <p>
     <img alt="" height="196" src="https://i-blog.csdnimg.cn/direct/428f8fba8de848fab156286ba6e6b435.png" width="1179">
     </img>
    </p>
    <h3 id="3.3%20inode%E6%A6%82%E5%BF%B5" name="3.3%20inode%E6%A6%82%E5%BF%B5">
     3.3 inode概念
    </h3>
    <p>
     我们之前了解过一个
     <code>
      文件 = 内容 + 属性
     </code>
     组成的，在Linux中文件的内容和属性是分开存储的，每个文件的属性被存储在一个结构体中
     <code>
      struct inode
     </code>
     之中。
    </p>
    <pre><code class="language-bash">[ouyang@iZ2ze0j6dd76e0o9qypo2rZ ~]$ ls -l
total 28
drwxrwxr-x 2 ouyang ouyang 4096 Dec 15 11:00 dir_2024_12_11
drwxrwxr-x 4 ouyang ouyang 4096 Dec 16 08:40 dir_2024_12_15
drwxrwxr-x 3 ouyang ouyang 4096 Dec  8 10:40 dir_2024_12_3
drwxrwxr-x 2 ouyang ouyang 4096 Dec 11 16:04 dir_2024_12_8
drwxrwxr-x 3 ouyang ouyang 4096 Jan 25 11:44 dir_2025
drwxrwxr-x 3 ouyang ouyang 4096 Feb 27 10:18 Linux_Git
-rw-rw-r-- 1 ouyang ouyang  827 Oct 23 15:00 vimrc-install.sh</code></pre>
    <pre><code class="language-cpp">struct inode
{
    int type;
    int size;
    ....
    int inode_number; // inode号
};</code></pre>
    <p>
     这个结构体的大小是固定的128字节，一个数据块4KB可以存储32个inode,并且每一个文件都有一个inode，并且inode内部有一个标识符叫做inode号。
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/8b2ff68bbb4a4e5facf335af0b39bfbc.png" width="662"/>
    </p>
    <p>
     <code>
      • 文件名属性并未纳入到inode数据结构内部
     </code>
    </p>
    <p>
     <code>
      • inode的大小⼀般是128字节或者256，我们后面统⼀128字节
     </code>
    </p>
    <p>
     <code>
      • 任何文件的内容大小可以不同，但是属性大小⼀定是相同的
     </code>
    </p>
    <h2 id="4.%20Ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" name="4.%20Ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">
     4. Ext2文件系统
    </h2>
    <p>
     <img alt="" height="806" src="https://i-blog.csdnimg.cn/direct/7d1a862241ba4c6a81add1f71d25c63a.png" width="1280"/>
    </p>
    <p>
     每个分区会被划分为多个
     <code>
      Block Group(块组)
     </code>
     ,进一步划分是为了更加方便管理。
    </p>
    <ul>
     <li>
      <p>
       Data Blocks
      </p>
     </li>
    </ul>
    <p>
     这一块区域主要用于存储文件的内容部分
    </p>
    <ul>
     <li>
      <p>
       Inode Table
      </p>
     </li>
    </ul>
    <p>
     这块区域主要用于存储文件的属性部分，使用结构体存储
    </p>
    <ul>
     <li>
      <p>
       Block/Inode Bitmap
      </p>
     </li>
    </ul>
    <p>
     位图部分，主要是用于表示Data Blocks/Inode Table某个块是否被占用，更加快速找到未占用的块进行访问
    </p>
    <ul>
     <li>
      <p>
       GDT
      </p>
     </li>
    </ul>
    <p>
     块组描述符，描述块组的属性信息，整个分区被划分为多少块组就存在多少GDT，GDT用于存储一个块组的描述信息，比如从哪到哪是Data Blocks/Inode Table/（Block/Inode Bitmap），还存在多少空闲的inode和数据块等等。
    </p>
    <ul>
     <li>
      <p>
       Super Block
      </p>
     </li>
    </ul>
    <p>
     是描述整个文件操作系统的描述符，和GDT的作用相似。记录的信息主要有：bolck和inode的总量，未使用的block和inode的数量，⼀个block和inode的大小，最近⼀次挂载的时间，最近⼀次写入数据的时间，最近⼀次检验磁盘的时间等其他文件系统的相关信息。SuperBlock的信息被破坏，可以说整个文件系统结构就被破坏了。
    </p>
    <p>
     <em>
      <strong>
       <span style="color:#fe2c24">
        注意
       </span>
       ：
      </strong>
     </em>
    </p>
    <ul>
     <li>
      <p>
       每个分区内部，inode编号和块号都是唯一的，所以我们只需要拿到inode_number就可以知道文件在哪个分组之中。
      </p>
     </li>
     <li>
      <p>
       格式化的本质：我们平时可能有过这种感觉：下载一个软件很慢，删除一个软件很快。这是为什么呢？我们下载一个软件是需要实打实的写入到
       <code>
        Data Blocks
       </code>
       ,但是我们删除一个软件只需要将其对应的位图位置改为未占用，后来的数据直接覆盖写入即可！
      </p>
     </li>
    </ul>
    <h2 id="5.%20Linux%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95" name="5.%20Linux%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95">
     5. Linux下的目录
    </h2>
    <p>
     首先我们知道以下几点：
    </p>
    <ul>
     <li>
      <p>
       inode中并没有保存文件名，那么文件名保存在哪？
      </p>
      <ul>
       <li>
        <p>
         文件名保存在当前文件所在的目录文件之中，那么目录文件名呢？保存在根目录文件之中，根目录文件名由OS管理加载。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       我们平时使用Linux系统寻找文件，都是路径+文件名，并没有使用inode号寻找，为什么可以找到？
      </p>
      <ul>
       <li>
        <p>
         存在一个映射的哈希表管理者文件名和inode号的映射关系。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     由以上两点我们得到一个信息：我们访问任何文件都需要其对应的路径进行查找，并且这个路径由/路径开始，对这个路径进行解析找到对应的文件内容块无疑是一次I/O操作，这会带来效率问题，因此OS在进行路径解析时候，会把我们历史访问的所有目录(路径)形成一棵多叉树进行保存，Linux系统的树状目录结构就是这么来的。
    </p>
    <pre><code class="language-bash">[ouyang@iZ2ze0j6dd76e0o9qypo2rZ linux_-git_-warehouse]$ tree dir_2025_1_10
dir_2025_1_10
└── Test.cpp

0 directories, 1 file</code></pre>
    <p>
     Linux中，在内核中维护树状路径结构的内核结构体叫做：
     <code>
      struct dentry
     </code>
    </p>
    <h3 id="5.1%20%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA" name="5.1%20%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA">
     5.1 挂载分区
    </h3>
    <p>
     我们已经能够根据inode号在指定分区找文件了，也已经能根据目录文件内容，找指定的inode了，在指定的分区内，我们可以为所欲为了。可是：
    </p>
    <p>
     问题：inode不是不能跨分区吗？Linux不是可以有多个分区吗？我怎么知道我在哪⼀个分区？？？
    </p>
    <ul>
     <li>
      <p>
       磁盘-&gt;分区-&gt;格式化-&gt;我们不能使用该分区，需要有一个目录进行关联才可以使用！
      </p>
     </li>
     <li>
      <p>
       分区写入文件系统，无法直接使用，需要和指定的目录关联，进行挂载才能使用。所以，可以根据访问目标文件的"路径前缀"准确判断我在哪⼀个分区。通过这样进入一个目录就相当于进入一个分区。
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="682" src="https://i-blog.csdnimg.cn/direct/9bdc6b217c2447fcb2f40c34d55685a5.png" width="1280"/>
    </p>
    <h2 id="6.%20%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5" name="6.%20%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5">
     6. 软硬链接
    </h2>
    <h3 id="6.1%20%E6%A6%82%E5%BF%B5%2F%E5%BA%94%E7%94%A8" name="6.1%20%E6%A6%82%E5%BF%B5%2F%E5%BA%94%E7%94%A8">
     6.1 概念/应用
    </h3>
    <ul>
     <li>
      <p>
       软连接：
      </p>
     </li>
    </ul>
    <pre><code class="language-bash">ln -s obj desc
ln -s code_soft /home/ouyang/Linux_Git/linux_-git_-warehouse/dir_2025_3_2/code.c(绝对路径)</code></pre>
    <p>
     软链接是一个独立的文件，他拥有独立的
     <code>
      inode number
     </code>
     ,软连接相当于创建一个快捷方式
    </p>
    <p>
     <img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/d29bc58d080c4cabaf38134b06402b6e.png" width="1199"/>
    </p>
    <ul>
     <li>
      <p>
       硬链接：
      </p>
     </li>
    </ul>
    <pre><code class="language-bash">ln  obj desc
ln  code_head /home/ouyang/Linux_Git/linux_-git_-warehouse/dir_2025_3_2/code.c(绝对路径)</code></pre>
    <pre><code class="language-bash">[ouyang@iZ2ze0j6dd76e0o9qypo2rZ linux_-git_-warehouse]$ ll
total 92
drwxrwxr-x 2 ouyang ouyang 4096 Dec 24 10:21 dir_2024_12_23
drwxrwxr-x 2 ouyang ouyang 4096 Feb 22 21:52 dir_2024_12_24</code></pre>
    <pre><code class="language-bash">[ouyang@iZ2ze0j6dd76e0o9qypo2rZ dir_2025_3_2]$ sudo ln code_Hard /home/ouyang/Linux_Git/linux_-git_-warehouse/dir_2025_3_2/Test.c 
[ouyang@iZ2ze0j6dd76e0o9qypo2rZ dir_2025_3_2]$ ls -li
total 8
1315789 -rw-rw-r-- 2 ouyang ouyang    0 Mar  3 09:35 code_Hard
1315786 drwxrwxr-x 2 ouyang ouyang 4096 Mar  3 09:29 dir
1315788 -rw-rw-r-- 1 ouyang ouyang    0 Mar  3 09:31 Test
1315789 -rw-rw-r-- 2 ouyang ouyang    0 Mar  3 09:35 Test.c
1315783 drwxrwxr-x 3 ouyang ouyang 4096 Mar  3 09:27 Test_Dir</code></pre>
    <p>
     硬链接之后，不是一个独立的文件，文件的
     <code>
      inode number
     </code>
     相等，相当于一个引用，对应的引用计数会++，可以用作于备份，只有当连接数为0时，磁盘才会释放其文件的空间内容！
    </p>
    <p>
     硬链接的新文件名也和原本的
     <code>
      inode number
     </code>
     进行了一次映射关系！
    </p>
    <ul>
     <li>
      <p>
       我们在删除文件时干了两件事情：1.在目录中将对应的记录删除，2.将硬连接数-1，如果为0，则将对应的磁盘释放。
      </p>
     </li>
     <li>
      <p>
       . / .. 表示当前目录和上级目录也是硬链接的一种使用！
      </p>
     </li>
    </ul>
    <h4 id="%E6%8E%A2%E7%A9%B6%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%9A" name="%E6%8E%A2%E7%A9%B6%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%9A">
     探究硬链接：
    </h4>
    <ul>
     <li>
      <p>
       硬链接只能给普通文件建立，不能给目录建立！
      </p>
     </li>
    </ul>
    <pre><code class="language-bash">[ouyang@iZ2ze0j6dd76e0o9qypo2rZ dir_2025_3_2]$ ln Dir_link_hard /home/ouyang/Linux_Git/linux_-git_-warehouse/dir_2025_3_2/Test_Dir/
ln: ‘Dir_link_hard’: hard link not allowed for directory</code></pre>
    <ul>
     <li>
      <p>
       问题：为啥
       <code>
        .
       </code>
       和
       <code>
        ..
       </code>
       文件是对目录的硬链接？这不和上面构成矛盾吗?
      </p>
      <ul>
       <li>
        <p>
         Linux 允许给
         <code>
          .
         </code>
         和
         <code>
          ..
         </code>
         建立硬链接，不允许用户自己对目录建立硬链接
        </p>
       </li>
       <li>
        <p>
         不允许用户建立链接是防止树结构查找出现路径循环问题！
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="" height="381" src="https://i-blog.csdnimg.cn/direct/ae3f5a811c7741d68e169cb88d767657.png" width="984"/>
    </p>
    <ul>
     <li>
      <p>
       <code>
        .
       </code>
       和
       <code>
        ..
       </code>
       的名字是特殊处理的，就是为了防止路径循环问题，也是为了方便用户操作！
      </p>
     </li>
     <li>
      <p>
       软连接不也是会带来路径循环问题吗，如果说硬链接的处理方式是特殊名字，软连接的处理方式是什么？
      </p>
      <ul>
      </ul>
      <img alt="" height="95" src="https://i-blog.csdnimg.cn/direct/80f5262161ed49d69e6e13a8ed9b674d.png" width="867"/>
      <ul>
      </ul>
     </li>
    </ul>
    <p>
     软连接文件前带了一个
     <code>
      l
     </code>
     作为区分！
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313537373739382f:61727469636c652f64657461696c732f313436323133383630" class_="artid" style="display:none">
 </p>
</div>


