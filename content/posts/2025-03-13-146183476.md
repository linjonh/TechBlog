---
layout: post
title: "React类组件下"
date: 2025-03-13 16:52:53 +0800
description: "设置默认值，使用ref来从DOM节点中获取表单数据，defaultValue设置默认值，不去控制后续的更新非受控组件可以减少你的代码量，也不会受外部的控制。"
keywords: "React:类组件（下）"
categories: ['React']
tags: ['前端', 'Vue', 'Javascript']
artid: "146183476"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146183476
    alt: "React类组件下"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146183476
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146183476
cover: https://bing.ee123.net/img/rand?artid=146183476
image: https://bing.ee123.net/img/rand?artid=146183476
img: https://bing.ee123.net/img/rand?artid=146183476
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     React:类组件（下）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <span style="color:#333333">
      <strong>
       表单中的非受控组件
      </strong>
     </span>
    </h2>
    <p>
     <span style="color:#333333">
      设置默认值，使用ref来从
     </span>
     <span style="color:#333333">
      DOM
     </span>
     <span style="color:#333333">
      节点中获取表单数据，defaultValue设置默认值，不去控制后续的更新
     </span>
    </p>
    <pre><code class="language-javascript">import React, { Component } from 'react';

class App extends Component {
    myUsername = React.createRef()
      handleReset = () =&gt; {
    if (this.myUsername.current) {
      this.myUsername.current.value = ''; // 直接操作 DOM 元素的值,不能在onClick里修改，因为ref是只读的
    }
  };
  render() {
    return (
        &lt;div&gt;
            &lt;h1&gt;登录页&lt;/h1&gt;
            &lt;input type="text" ref={this.myUsername}  defaultValue={'孩子们我不想上学'}/&gt;
            &lt;button onClick={()=&gt;{console.log(this.myUsername.current.value)
            }}&gt;登录&lt;/button&gt;
            &lt;button onClick={()=&gt;this.handleReset()}&gt;重置&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</code></pre>
    <div>
     非受控组件可以减少你的代码量，也不会受外部的控制
    </div>
    <div>
     <img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/7f22a74cb51349cab9df54c370380e40.png" width="340">
     </img>
    </div>
    <div>
    </div>
    <h2>
     表单的受控组件
    </h2>
    <div>
    </div>
    <div>
     <p>
      受控组件其实就是把ref的值设为一个状态，input在React里其实更像一个组件，而不是一个普通的input标签
     </p>
     <pre><code class="language-javascript">import React, { Component } from 'react';

class App extends Component {
  
    myUsername = React.createRef()
      handleReset = () =&gt; {
    if (this.myUsername.current) {
      this.myUsername.current.value = ''; // 直接操作 DOM 元素的值,不能在onClick里修改，因为ref是只读的
    }
    }
      state = {
    usename:'august'
}

  render() {
    return (
        &lt;div&gt;
            &lt;h1&gt;登录页&lt;/h1&gt;
            &lt;input type="text" ref={this.myUsername}  defaultValue={this.state.usename}/&gt;
            &lt;button onClick={()=&gt;{console.log(this.myUsername.current.value)
            }}&gt;登录&lt;/button&gt;
            &lt;button onClick={()=&gt;this.handleReset()}&gt;重置&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</code></pre>
     <p>
      但是这时候没有设置onChange事件，通过onChange监听input，需要在input
      <strong>
       察觉到值变化以后立即
      </strong>
      更新状态
     </p>
     <p>
      <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/b9390948aca34130a99e8aeb4985b13d.png" width="307"/>
     </p>
     <p>
      这种行为和原生js里的onInput事件更相似
     </p>
     <p>
      对于
      <code>
       &lt;input type="text"&gt;
      </code>
      和
      <code>
       &lt;textarea&gt;
      </code>
      ，
      <code>
       onChange
      </code>
      在元素失去焦点（
      <code>
       blur
      </code>
      ）时触发。
     </p>
     <p>
      <img alt="" height="386" src="https://i-blog.csdnimg.cn/direct/500e3595e01c4f9399cca81fdd87eee0.png" width="567"/>
     </p>
     <p>
      受控组件的优点是实现了父子通信，在重新渲染的同时，还可以把更改的状态传给其他组件
     </p>
    </div>
    <div>
     <pre><code class="language-javascript">import React from 'react'
import axios from 'axios'
class Cinema extends React.Component{
    constructor() {
        super()

        this.state = {
            cinemaList: [],
            myText:''
        }
        //用axios请求数据
        axios.get('https://apis.netstart.cn/maoyan/index/moreCinemas?day=2021-11-12&amp;offset=0&amp;limit=20&amp;districtId=-1&amp;lineId=-1&amp;hallType=-1&amp;brandId=-1&amp;serviceId=-1&amp;areaId=-1&amp;stationId=-1&amp;item&amp;updateShowDay=true&amp;reqId=1636710166221&amp;cityId=1&amp;lat=23.135636443326355&amp;lng=1').then(res =&gt; {
            console.log(res)
            this.setState({
                cinemaList: res.data
            })
        }).catch(err =&gt; {
            console.log(err)
        })

    }
    //生命周期函数更适合发送ajax请求
    render() {
        
        return (
            &lt;div&gt;
                &lt;input value={this.state.myText} onChange={(e) =&gt; {
                    this.setState({
                    myText:e.target.value
                    })
                }}  /&gt;
                      {
                        this.getCinemaList().map(item =&gt; &lt;dl key={item.cinemaId}&gt;
                            &lt;dt&gt;{ item.title}&lt;/dt&gt;
                            &lt;dd&gt;{ item.location}&lt;/dd&gt;

                        &lt;/dl&gt;)
                    }
             
                  &lt;/div&gt; 
        )
 
    }
    getCinemaList() {
        return this.state.cinemaList.filter(item =&gt; item.title.includes(this.state.myText)||item.location.includes(this.state.myText))
    
    }
}
export default Cinema</code></pre>
     <p>
      受控组件没有操作dom，而非受控组件操作dom
     </p>
    </div>
    <div>
     使用受控组件修改之前写的todolist:
     <pre><code class="language-javascript">import React, { Component } from "react" 
class App extends Component{

    a=100
        state = {
        list: [
            {
            id:1,text:'111',isChecked:false
            },
            { id: 2, text: '222',isChecked:false },
            {id:3,text:'333',isChecked:false}
            ],
            myText: '',
            
}
    render(){
        return (
            &lt;div&gt;
                &lt;input value={this.state.myText} onChange={(e) =&gt; {
                    this.setState({
                        myText:e.target.value
                    })
                }} /&gt;
                {/* //把ref绑定在input上 */}
                &lt;button onClick={this.handleClick}&gt;add&lt;/button&gt;
               
                &lt;ul&gt;
                    {
                        this.state.list.map((item, index) =&gt; &lt;li key={item.id}&gt; &lt;input type="checkbox" checked={this.state.list.isChecked} onChange={()=&gt;this.handleCheck(index)} /&gt;
                            
                       &lt;span style={<!-- -->{textDecoration:item.isChecked?'line-through':''}}&gt; {item.text}&lt;/span&gt;&lt;button onClick={() =&gt; this.handleDel(index)}&gt;delete&lt;/button&gt;&lt;/li&gt;)
}
                &lt;/ul&gt;
                {/* { this.state.list.length?null:&lt;div&gt;暂无待办事项&lt;/div&gt;} */}
                {/* { this.state.list.length===0&amp;&amp;&lt;div&gt;暂无待办事项&lt;/div&gt;} */}
                &lt;div className="hidden"&gt;暂无待办事项&lt;/div&gt;
              
            &lt;/div&gt;
        )
    }
    handleCheck(index) {
    //console.log(index)
        let newList = [...this.state.list]
        newList[index].isChecked = !newList[index].isChecked
        this.setState({
            list:newList
        })

}

    handleClick = (e) =&gt; {
        //this.state.list.push(this.myref.current.value)不能直接修改状态
        let newList = [...this.state.list]
        newList.push({
            id:this.state.list.length+1,
            text: this.state.myText,
            isChecked:false
        })
        this.setState({
            list: newList,
            myText:''
        })
        
    }
    handleDel = (index) =&gt; {
        console.log('del',index)
        let newList =this.state.list.slice()
        newList.splice(index, 1)
        this.setState(
            {list:newList}
        )
    }
}
export default App</code></pre>
     <p>
      修改的部分主要是把组件设置为受控的，并且增添的删除时加上删除线的功能，主要是通过控制组件的checked的状态来设置文字的css样式，用map方法把index传给onChange里的回调函数，并且把复选框作为list里每个元素的一个属性，
     </p>
    </div>
    <div>
     <p>
      <img alt="" height="247" src="https://i-blog.csdnimg.cn/direct/5530dd03272347d797cb1e83714fe42e.png" width="545"/>
     </p>
     <div>
      <span style="color:#777777">
       注意
      </span>
      <span style="color:#777777">
       :
      </span>
      <span style="color:#777777">
       另一种说法（广义范围的说法），
      </span>
      <span style="color:#777777">
       React
      </span>
      <span style="color:#777777">
       组件的数据渲染是否被调用者传递的
      </span>
      <span style="color:#777777">
       props
      </span>
      <span style="color:#777777">
       完全控制，控制则
      </span>
     </div>
     <div>
      <span style="color:#777777">
       为受控组件，否则非受控组件。
      </span>
     </div>
    </div>
    <h2 style="background-color:transparent">
     父子通信
    </h2>
    <p>
     为什么要进行父传子通信
    </p>
    <p>
     父传子是为了更好的实现组件的复用，父亲需要提不同的要求给子组件，如果没有属性的传递，就无法实现复用
    </p>
    <p>
     子传父是为什么？
    </p>
    <p>
     状态是局部的，使用的时候需要传递；如果需要实现一个抽屉的效果，点击导航栏的按钮，触发一个列表，再触发关闭列表的效果；如果将导航栏和列表做成两个组件的时候，父组件App在使用这两个组件的时候，根据状态（isShow）来确定是否显示列表，这个状态肯定要写在父组件里，可是按钮被写在子组件里，按钮是否被点击的状态此时就需要传递给父组件，这就是子传父的必要性
    </p>
    <p>
     像这样：
    </p>
    <div>
     <pre><code class="language-javascript">import React, { Component } from 'react';

class Navbar extends Component{
    render() {
        return (
            &lt;div style={<!-- -->{background:'red'}}&gt;
                &lt;button onClick={() =&gt; {
                    console.log('子通知父，让父的isShow取反,这里的this.props就是父组件给子组件传递的回调函数', this.props)
                    this.props.event()
                    
                }}&gt;click&lt;/button&gt;
                &lt;span&gt;Navbar&lt;/span&gt;
            &lt;/div&gt;

        )
    }
}
class Slidebar extends Component{
    render() {
        return (
            &lt;div style={<!-- -->{ background: 'yellow' }}&gt;
                &lt;ul&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
            &lt;/ul&gt;
            &lt;/div&gt;
            
        )
    }
}

class App extends Component {
    state = {
        isShow:false
    }
  render() {
    return (
      &lt;div&gt;
            &lt;Navbar event={() =&gt; {
                console.log('父组件定义event事件')
                
            }}&gt;&lt;/Navbar&gt;
            {this.state.isShow&amp;&amp;&lt;Slidebar&gt;&lt;/Slidebar&gt;}
      &lt;/div&gt;
    );
  }
}

export default App;</code></pre>
     <p>
      event这个回调函数是父传给子的，子拿到之后就可以执行
     </p>
     <p>
      <strong>
       父传子通过属性（一些字符串什么的）传递,子传父通过回调函数（父如果传给子一个回调函数就证明我们需要子传父，需要子在自己的作用域里调用父传过来的回调函数）来执行
      </strong>
      （之前没理解这句话，现在真理解了）
     </p>
     <pre><code class="language-javascript">import React, { Component } from 'react';

class Navbar extends Component{
    render() {
        return (
            &lt;div style={<!-- -->{background:'red'}}&gt;
                &lt;button onClick={() =&gt; {
                    console.log('子通知父，让父的isShow取反,这里的this.props就是父组件给子组件传递的回调函数', this.props)
                    this.props.event()
                    
                }}&gt;click&lt;/button&gt;
                &lt;span&gt;Navbar&lt;/span&gt;
            &lt;/div&gt;

        )
    }
}
class Slidebar extends Component{
    render() {
        return (
            &lt;div style={<!-- -->{ background: 'yellow' }}&gt;
                &lt;ul&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                    &lt;li&gt;qq&lt;/li&gt;
                 
            &lt;/ul&gt;
            &lt;/div&gt;
            
        )
    }
}

class App extends Component {
    state = {
        isShow:false
    }
    handleEvent = () =&gt; {
        this.setState({
            isShow:!this.state.isShow
        })
    }
  render() {
    return (
      &lt;div&gt;
            &lt;Navbar event={this.handleEvent}&gt;&lt;/Navbar&gt;
            {this.state.isShow&amp;&amp;&lt;Slidebar&gt;&lt;/Slidebar&gt;}
      &lt;/div&gt;
    );
  }
}

export default App;</code></pre>
     <p>
      现在就可以通过点击子组件的按钮控制父组件的列表是否显示了
     </p>
    </div>
    <h2>
     非受控组件的实例
    </h2>
    <p>
     父组件触发事件更改状态以后会引起render的渲染，但是更改不了子组件里的state
    </p>
    <pre><code class="language-javascript">import React, { Component } from 'react';
import '../../2-advance/css/01-卖座.css'
class Tabbar extends Component {
    state={
      list: [
            {
                id:1,  text:'电影'
            },
            {
                id: 2, text: '影院'
            },
            {
                id: 3, text: '我的'
            },
        ],
        current: 0      
    }
    render() {
        // this.state.current = this.props.parentcurrent
        // this.setState({
        //     current:this.props.parentcurrent
        // })不能这么写，这么写render调用setState，setState更改完状态又调用render
    return (
        &lt;div&gt;
            &lt;ul&gt;
                  {
                this.state.list.map((item, index) =&gt;
                &lt;li key={item.id} className={this.state.
                current === index ? 'active' : ''} onClick={() =&gt; this.handleClick(index)}&gt;{item.text}&lt;/li&gt;)
        }   
              &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
   handleClick(index) {
        console.log(index)
        this.setState({
            current: index
        })   
       this.props.myEvent(index)
    }
    
}

export default Tabbar;</code></pre>
    <div>
     也就是说render察觉到状态被其父组件改变了会渲染，但是只会在子组件第一次执行的时候创建列表在列表里声明current的值，而之后无论current怎么改变，只会触发渲染，而不会真正的改变列表里的current这个状态
    </div>
    <div>
    </div>
    <div>
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/4146a1ba303946c1b228733b56c11097.png" width="767">
     </img>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
     这算是状态组件比较不方便的地方就是提升代码维护的难度
    </div>
    <div>
     <img alt="" height="80" src="https://i-blog.csdnimg.cn/direct/9f78df92b0ff4df4aa71e594e02272fe.png" width="744">
     </img>
    </div>
    <div>
    </div>
    <div>
    </div>
    <h2>
     状态组件、无状态组件、受控组件、非受控组件的区别
    </h2>
    <div>
     <table>
      <thead>
       <tr>
        <th>
         概念
        </th>
        <th>
         特点
        </th>
        <th>
         适用场景
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <strong>
          受控组件
         </strong>
        </td>
        <td>
         值由 React 状态管理，数据流单向
        </td>
        <td>
         需要严格控制的表单或输入场景
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          非受控组件
         </strong>
        </td>
        <td>
         值由 DOM 管理，数据流双向
        </td>
        <td>
         简单表单或直接操作 DOM 场景
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          状态组件
         </strong>
        </td>
        <td>
         组件内部有状态逻辑，可以是类组件或函数组件
        </td>
        <td>
         需要管理复杂状态的场景
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          无状态组件
         </strong>
        </td>
        <td>
         组件内部没有状态逻辑，完全依赖
         <code>
          props
         </code>
        </td>
        <td>
         纯展示型或逻辑简单的场景
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <h2 style="background-color:transparent">
     受控组件的实例
    </h2>
    <p>
     核心是剥离子组件的状态，通过父组件的通信传递
    </p>
    <div>
     只由自己控制的，就定义在state里，由外界控制的，通过props传入，记住这条规则就行了
    </div>
    <div>
    </div>
    <div>
     <img alt="" height="141" src="https://i-blog.csdnimg.cn/direct/7a4c4d2e475e477e9a4223fdab2ae629.png" width="437">
     </img>
    </div>
    <div>
     接收props
    </div>
    <div>
     <img alt="" height="93" src="https://i-blog.csdnimg.cn/direct/93ae70e4c63f49988cc9a1b9c77c8653.png" width="733">
     </img>
    </div>
    <div>
     为了减少状态的使用，并且让父组件通过更改props的属性值来控制子组件，应该用props而不是state
    </div>
    <div>
     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/43a70efe237b49e3a20ed21f88b3d9b9.png" width="768"/>
    </div>
    <div>
    </div>
    <div>
     这是类组件的做法，如果是函数式组件就没有这么麻烦，因为属性可以直接当参数传递：
    </div>
    <div>
    </div>
    <div>
     子组件：
     <pre><code class="language-javascript">const Tabbar=(props) =&gt; {


function handleClick(index){
       props.myEvent(index)
    }
    if (!props.list) {
        return &lt;div&gt;No data available&lt;/div&gt;
    }
    return (
        &lt;div&gt;
            &lt;ul&gt;
                  {
                props.list.map((item, index) =&gt;
                &lt;li key={item.id} className={props.
                current === index ? 'active' : ''} onClick={() =&gt;handleClick(index)}&gt;{item.text}&lt;/li&gt;)
        }   
              &lt;/ul&gt;
      &lt;/div&gt;
    );
}



export default Tabbar;</code></pre>
     <p>
      父组件：
     </p>
     <pre><code class="language-javascript">import React, { Component } from "react" 
import './css/01-卖座.css'
import Film from './maizuo受控/Film'
import Center from './maizuo受控/Center'
import Cinema from './maizuo受控/Cinema'
import Tabbar from './maizuo受控/Tabbar'
import Navbar from './maizuo受控/Navbar'
import { current } from "@reduxjs/toolkit"
class App extends Component{

        state = {
            current: 0,
             list: [
            {
                id:1,  text:'电影'
            },
            {
                id: 2, text: '影院'
            },
            {
                id: 3, text: '我的'
            },
        ],
    }
    which() {
        switch (this.state.current) {
           case 0:return &lt;Film&gt;&lt;/Film&gt;
           case 1:return &lt;Cinema&gt;&lt;/Cinema&gt;
            case 2: return &lt;Center&gt;&lt;/Center&gt;
            default:return null
        }
    }

    render(){
        return (
            &lt;div&gt;
                
                &lt;Navbar myEvent={() =&gt; {
                    console.log('Navbar')
                    this.setState({
                        current:2
                    })
                }}&gt;&lt;/Navbar&gt;
                {/* {其实感觉这里也可以拿路由来写} */}
                {this.which()}
                &lt;Tabbar myEvent={(index )=&gt;{console.log('父组件定义')
                    this.setState({
                    current:index
                    })
                }   
                    //通过属性传给Tabbar

                } current={this.state.current} list={this.state.list}&gt;&lt;/Tabbar&gt;
                
            &lt;/div&gt;
        )
    }
   
}
export default App</code></pre>
     <p>
      讨厌类组件的指来指去
     </p>
    </div>
    <h2>
     父子通信的表单域组件
    </h2>
    <p>
     感觉没什么多说的，就是受控组件
    </p>
    <div>
     <pre><code class="language-javascript">import React, { Component } from 'react';


class Field extends Component {
  render() {
    return (
        &lt;div style={<!-- -->{ background: 'yellow' }}&gt;
            &lt;label &gt;{ this.props.label}&lt;/label&gt;
            &lt;input type={this.props.type} onChange={(e) =&gt; { this.props.onChangeEvent(e.target.value) }} /&gt;
        {/* //每次点击按钮触发回调函数并且把e.target.value传递回去,子传父通过回调函数 */}
      &lt;/div&gt;
    );
  }
}



class App extends Component {
  render() {
    return (
        &lt;div&gt;
            &lt;h1&gt;登录页面&lt;/h1&gt;
            &lt;Field label='用户名' type='text' onChangeEvent={
                (value)=&gt;{console.log(value)
            }}&gt;&lt;/Field&gt;
            &lt;Field label='密码' type='password' onChangeEvent={
                (value) =&gt; {console.log(value) 
            }}&gt;&lt;/Field&gt;
            &lt;button &gt;登录&lt;/button&gt;
            &lt;button &gt;取消&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</code></pre>
     <p>
      这是具体的设置属性为state
     </p>
    </div>
    <div>
     <pre><code class="language-javascript">     &lt;input type={this.props.type} onChange={(e) =&gt; { this.props.onChangeEvent(e.target.value) }} value={this.props.value} /&gt;
        {/* //每次点击按钮触发回调函数并且把e.target.value传递回去,子传父通过回调函数 */}
    
        &lt;Field label='用户名' type='text' onChangeEvent={
        (value) =&gt; {
           // console.log(value)
         this.setState({
              username:value
             })
                    //读取本地存储的信息当作默认值属性传递给子组件
            }} value={this.state.username}&gt;&lt;/Field&gt;
           </code></pre>
     <p>
      这里把this.state.value传过去
     </p>
    </div>
    <div>
     <img alt="" height="194" src="https://i-blog.csdnimg.cn/direct/83038de09add4ae38d631cc9b59a65d3.png" width="406"/>
    </div>
    <div>
    </div>
    <h2>
     ref版表单域组件
    </h2>
    <p>
     访问ref
    </p>
    <div>
     <img alt="" height="256" src="https://i-blog.csdnimg.cn/direct/f7d66eb5f1b943818ac7df2f3869a660.png" width="698"/>
    </div>
    <div>
     通过ref绑定的Field，获取Field组件的函数clear:
    </div>
    <div>
    </div>
    <div>
     <pre><code class="language-javascript">import React, { Component ,} from 'react';


class Field extends Component {
    state={
        value:''
    }
    clear() {
        this.setState({
            value:''
        })
    }
  render() {
    return (
        &lt;div style={<!-- -->{ background: 'yellow' }}&gt;
            &lt;label &gt;{ this.props.label}&lt;/label&gt;
            &lt;input type={this.props.type} onChange={(e) =&gt; {
                this.setState({
                    //没有父传子子传父
                    value:e.target.value
                })
            }} /&gt;
        {/* //每次点击按钮触发回调函数并且把e.target.value传递回去,子传父通过回调函数 */}
      &lt;/div&gt;
    );
  }
}



class App extends Component {
   username=React.createRef()
   password=React.createRef()
  render() {
    return (
        &lt;div&gt;
            &lt;h1&gt;登录页面&lt;/h1&gt;
            &lt;Field label='用户名' type='text' ref={this.username}&gt;&lt;/Field&gt;
            &lt;Field label='密码' type='password'ref={this.password}&gt;&lt;/Field&gt;
            &lt;button onClick={() =&gt; {
              console.log(this.username.current.state.value,this.password.current.state.value)
               
            }} &gt;登录&lt;/button&gt;
            &lt;button onClick={() =&gt; {
                this.username.current.clear()
            }}&gt;取消&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</code></pre>
     <p>
      情况的时候把value值设置回去：
     </p>
     <pre><code class="language-javascript">&lt;input type={this.props.type} onChange={(e) =&gt; {
                this.setState({
                    //没有父传子子传父
                    value: e.target.value
                })
            }} value={this.state.value} /&gt;</code></pre>
     <p>
      避免暴露的使用方法，一些方法可以封装出来：
     </p>
     <pre><code class="language-javascript">  setValue(value) {
        this.setValue({
        value:value
    })
}

 &lt;div style={<!-- -->{ background: 'yellow' }}&gt;
            &lt;label &gt;{ this.props.label}&lt;/label&gt;
            &lt;input type={this.props.type} onChange={(e) =&gt; {
               this.setValue(e.target.value)
            }} value={this.state.value} /&gt;
        {/* //每次点击按钮触发回调函数并且把e.target.value传递回去,子传父通过回调函数 */}
      &lt;/div&gt;</code></pre>
    </div>
    <div>
     低耦合好维护，直来直去，不像受控组件绕来绕去
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f41755f7573742f:61727469636c652f64657461696c732f313436313833343736" class_="artid" style="display:none">
 </p>
</div>


