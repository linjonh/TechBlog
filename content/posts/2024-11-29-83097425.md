---
layout: post
title: 软件工程导论概念集合
date: 2024-11-29 22:26:30 +0800
description: "《软件工程导论》主编：薛继伟 哈尔滨工业大学出版社第一"
keywords: 软件工程导论薛继伟pdf
categories: ['计算机基础']
tags: ['软件工程']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=83097425
    alt: 软件工程导论概念集合
artid: 83097425
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=83097425
featuredImagePreview: https://bing.ee123.net/img/rand?artid=83097425
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     软件工程导论概念集合
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     《软件工程导论》主编：薛继伟 哈尔滨工业大学出版社
    </p>
    <hr/>
    <h3>
     <a id="_4">
     </a>
     第一章软件工程概述
    </h3>
    <ul>
     <li>
      软件：软件是程序以及所有使程序正确运行所需的相关文档和配置信息。软件=程序+数据+文档
     </li>
     <li>
      软件危机：随着计算机应用的普及，软件的数量急剧增加，众多因素导致了软件开发过程中所开发的软件产品质量低下，众多软件无法满足用户需求，软件的可维护性差，以至于问题不断堆积矛盾日益尖锐，称此现象为软件危机。
     </li>
     <li>
      软件工程：软件工程是一类工程，是将理论和知识应用于实践的学科，它借鉴了工程的原则和方法，以求高效的开发高质量的软件。
     </li>
     <li>
      软件生命周期：是指软件在生产到报废的生命周期，包括可行性分析，项目开发计划，需求分析，概要设计，详细设计，编码，测试，维护等阶段。
     </li>
     <li>
      瀑布模型：详见《软件工程导论》薛继伟-哈尔滨工业大学出版社
     </li>
     <li>
      快速原型原型模型:详见《软件工程导论》薛继伟-哈尔滨工业大学出版社
     </li>
     <li>
      增量模型：详见《软件工程导论》薛继伟-哈尔滨工业大学出版社
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_14">
     </a>
     第二章软件工程方法与工具
    </h3>
    <ul>
     <li>
      UML
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       UML：UML是用来对软件密集系统进行可视化建模的一种语言，是对面向对象开发系统的产品进行说明、可视化、和文档编制的一种标准语言。
      </li>
      <li>
       用例图：用例描述了系统的工作方式，以及系统提供的服务。用例图描述了系统外部参与者如何使用系统提供的服务。（P.37）
      </li>
      <li>
       类图：类图用来表示系统中的类以及类与类之间的关系描述系统的静态结构，用于逻辑视图中。（P.38）
      </li>
      <li>
       对象图：对象图是类图的示例，描述了一组对象以及他们之间的关系，表示类的对象实例。对象图表示在某一时刻这些类的实例以及这些实例之间的关系。
      </li>
      <li>
       状态图：状态图表示一个状态机，强调对象行为的时间顺序，显示一个对象的状态以及状态与状态之间的转换。
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      对象之间的关系
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       依赖：依赖是一种使用关系，表示一个元素以某一钟方法依赖于另一个元素，一个事物的变化会影响到另一个使用它的事物。
      </li>
      <li>
       关联：关联是一种结构关系，说明一个事物的对象与另一个事物的对象之间的联系，表示模型元素及链接实例。
      </li>
      <li>
       泛化：泛化是一种“一般事物”（父类）与“特殊事物”（子类）之间的关系，表示一般与特殊关系，即“一般元素”是“特殊元素”的泛化，“特殊元素”是“一般元素”的特化。
      </li>
      <li>
       聚集：聚集表示整体与部分的关系，即“部分元素”是“整体元素”的一部分。
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      面向对象
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       对象
      </li>
      <li>
       类
      </li>
      <li>
       封装
      </li>
      <li>
       继承
      </li>
      <li>
       多态
      </li>
      <li>
       消息
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h3>
     <a id="_37">
     </a>
     第三章软件立项
    </h3>
    <ul>
     <li>
      可行性研究：可行性分析的目的是从各个方面去综合对比分析，对比成功或者失败的可能性有多大，是否值得进行立项等。一般可行性分析的要素有：市场可行性分析、政策（政府）可行性分析、技术可行性分析和成本效益分析。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_41">
     </a>
     第四章软件需求分析
    </h3>
    <ul>
     <li>
      需求分析：收集用户需求，找到用户真正的需求，确定系统具体需要什么功能。
     </li>
     <li>
      需求规格说明书：需求分析的产物为需求规格说明书。
     </li>
     <li>
      需求验证：需求验证是指需求规格说明书完成之后，对需求规格说明书文档进行验证的活动，目的是发现并纠正说明书中的错误、遗漏和不一致的地方。以确保所有的系统需求规格说明书最大限度的正确、清晰、完整、无歧义并符合标准和规范。
     </li>
     <li>
      数据流图（泡图）：从数据加工的角度，以图形的方式来表达系统的逻辑功能，数据在系统内部的逻辑流向，和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。
     </li>
     <li>
      数据字典：数据字典是关于数据的信息集合，即数据字典的作用是为数据流图上的每一个成分加一定义和说明。
     </li>
     <li>
      ER图（实体-联系图）：表示数据对象及其关系，也叫做E-R图。包括数据对象、对象的属性、对象间相互连接的关系。
     </li>
     <li>
      功能模型：功能模型表示系统的“功能”性质，它指明了系统要应该“做什么”，反映了用户对目标系统的需求。
     </li>
     <li>
      对象模型：表示静态的，结构化的，系统的数据性质。是对模拟客观世界实体的对象以及对象和对象之间的关系的映射，描述了系统的静态结构。
     </li>
     <li>
      动态模型：UML动态模型图主要包括交互图和行为图，交互图又分为时序图和协作图，行为图又分为状态图和活动图。在开发交互式系统的时候动态模型非常重要。
     </li>
     <li>
      程序设计语言（过程设计语言PDl）：又称为伪码.它是一种用于描述模块算法设计和处理细节的语言.
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_54">
     </a>
     第五章软件设计
    </h3>
    <ul>
     <li>
      概要设计：把需求转换为需要的体系结构，概要设计就是设计
      <strong>
       软件的结构
      </strong>
      ，该结构有哪些模块组成，这些模块的层次结构是怎么样的，模块之间的调用关系是什么样的，每个模块的功能是什么。
     </li>
     <li>
      详细设计：为每个模块的功能进行详细的描述，把功能描述转变为精确的、结构化的过程描述，即该模块的控制结构是怎样的，先做什么，后座什么，有什么样的判定条件，有生重复处理等，并用相应的表示工具将这些控制结构表示出来。
     </li>
     <li>
      软件体系结构：一个程序或者计算机系统的软件体系包括一个或者一组软件构件、软件构件的外部的可见特征性，及其相互关系。（1997年）
     </li>
     <li>
      抽象：暂时忽略事物之间的微小差别，将彼此之间相似，共性的东西进行概括。
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       控制抽象：从指令到汇编语言再到高级语言，让程序员在更高的层次进行抽象，屏蔽不同机器和指令集之间的差异。
      </li>
      <li>
       过程抽象：将处理过程抽象为存储过程，函数和方法，通过提供不同的参数实现具体化。
      </li>
      <li>
       数据抽象：使用数据抽象能够设计出数据库表和字段，或者设计出类的属性。
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      模块：具有相对独立性的，由数据说明执行语句等程序对象构成的集合。（在高级语言中模块体现为函数、子过程、过程）
     </li>
     <li>
      模块化：每个模块有特定的子功能，各个模块按照一定的方法组合起来称为一个整体，从而从而实现整个系统的功能。
     </li>
     <li>
      模块独立性：是指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最小，接口最简单。
     </li>
     <li>
      信息隐蔽：是指一个模块将自身的内部信息向其他模块隐藏起来，以避免其他模块不恰当的访问和修改。
     </li>
     <li>
      耦合：模块与模块之间的联系越高，耦合性就越大。
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       数据耦合：两个模块之间仅仅通过模块参数交换信息，且交换的信息全部为简单数据。
      </li>
      <li>
       公共耦合：两个或者多个模块通过应用公共数据相互联系。
      </li>
      <li>
       内容耦合：一个模块对另一个模块的内容进行了直接的引用甚至是修改，或者通过非正常的入口，进入到另一个的内部，或者一个模块具有多个入口，或者两个模块共享一部分代码。
      </li>
      <li>
       控制耦合：一个模块通过传送开关、标志、名字等控制信息，明显的对另一个模块的功能进行控制。
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      内聚: 标志着一个模块内各个元素彼此的紧密程度，他是信息隐藏和局部化概念的自然扩展。主要有一下7中内聚类型，内聚性逐渐增大。
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       偶然内聚：一个模块内各个语句段之间的联系十分松散或者直接没有联系，或者根本没有什么联系，很可能是在一种场合允许修改该模块，而另外一种场合不允许修改该模块。
      </li>
      <li>
       逻辑内聚：一个模块实现多个逻辑上相同或类似的一类功能。
      </li>
      <li>
       时间内聚：模块内的多个功能在同一个时间内执行。
      </li>
      <li>
       过程内聚：模块内各个部分相关，并且必须按照特定的次序执行。
      </li>
      <li>
       通信内聚：模块内各个元素都使用同一个输入数据和（或）都产生同一个数据输出。
      </li>
      <li>
       顺序内聚：模块的各个功能必须顺序执行（往往后一个功能需要依托前一个功能的结果）。
      </li>
      <li>
       功能内聚：模块内所有处理元素属于同一个整体，完成一个单一的功能。
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      数据流类型：
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       变换型：信息流沿输入通路进入系统，同时由外部形式装换成内部形式，进入系统的数据流经过变换中心，加工处理之后，再沿输出通路变换成外部形式离开软件系统。
      </li>
      <li>
       事务型：数据沿输入通路进入到一个处理T后，这个处理根据输入数据的类型在若干个动作系列中选择一个来执行。
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      程序流程图：即程序框图。
     </li>
     <li>
      PAD图：用于详细设计的图形表达工具，只能用于结构化程序的描述。
     </li>
     <li>
      NS图：即无线流程图。
     </li>
     <li>
      面向对象设计（OOD）：建立在面向对象分析之上的，把分析阶段得到的需求转变为符合成本和重量要求的抽象的系统实现方案的过程。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_92">
     </a>
     第六章软件实现
    </h3>
    <ul>
     <li>
      编码：通过选定的程序语言，将详细设计阶段的模块过程性描述，转变为特定语言书写的源程序（源代码）。
     </li>
     <li>
      编码风格：代码应该是正确的、有效的、可维护的、易读易懂的。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_97">
     </a>
     第七章软件测试
    </h3>
    <h5>
     <a id="_98">
     </a>
     一、软件测试：是为了发现错误而执行程序的过程，或者说是根据软件开发的各个阶段的规格说明书和程序内部结构而精心设计的一批测试用例。并且用这些用例来运行程序，发现其中的错误。有一下几种测试方法：
    </h5>
    <h5>
     <a id="1_99">
     </a>
     1、黑盒测试：根据被测程序的
     <strong>
      功能
     </strong>
     来进行测试，也称为功能测试或者是数据驱动测试，主要着眼于程序的外部结构，不考虑内部的逻辑结构，针对
     <strong>
      软件界面
     </strong>
     和
     <strong>
      软件功能
     </strong>
     进行测试。（在已知产品的功能情款下，通过测试检验已知功能是否能正常使用）。
    </h5>
    <blockquote>
     <ul>
      <li>
       等价类划分法：完全不考虑软件的内部结构，只是根基软件的规格说明书设计测试用例，因为不可能输入所有情款的测试数据（
       <strong>
        穷举测试是不可能实现的
       </strong>
       ），所以采用等价类分化的方法将输入数据的可能值分为若干个等价类，使每一个等价类中的任何一个测试用例，都能代表同一等价类中的其他测试用例。
      </li>
      <li>
       边界值分析法：程序往往会在处理边界情况是后发生错误，边界值是指输入或者输出的等价类边界上的值。当使用边界值分析法选取测试用例的时候，选择的测试数据应该刚好等于，刚好小于，刚好大于等价类的边界值的数据。
      </li>
      <li>
       错误推测法：往往根据测试人员的检验与直觉，推测程序中可能存在的各种错误，从而有针对性的编写检查这些错误的测试用例进行有针对性的测试。
      </li>
      <li>
       因果图法：在测试用例输入条件之间会存在着联系，不同的联系会产生不同的结果。所以必须考虑一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑测试用例。
      </li>
     </ul>
    </blockquote>
    <h5>
     <a id="2_105">
     </a>
     2、白盒测试：是以程序的
     <strong>
      结构
     </strong>
     为依据，又称为结构测试。它是按照程序内部的结构测试程序。检查程序中的每一条路是否都能按照预定的要求正常工作。
    </h5>
    <blockquote>
     <ul>
      <li>
       逻辑覆盖测试：是以程序
       <strong>
        内部的逻辑结构为基础
       </strong>
       的设计测试用例的技术。
      </li>
     </ul>
     <blockquote>
      <ul>
       <li>
        语句覆盖
       </li>
       <li>
        判定覆盖
       </li>
       <li>
        条件覆盖
       </li>
       <li>
        判定/条件覆盖
       </li>
      </ul>
     </blockquote>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       路径测试：测试
       <strong>
        程序运行的路径
       </strong>
       ，保证程序中的每一条可能执行到的路径至少测试一次。
       <br/>
       ####软件测试过程：（P.206）
      </li>
      <li>
       1、单元测试：针对程序模块，进行正确性的测试。
      </li>
      <li>
       2、集成测试：又称为组装测试或者联合测试，在单元测试的基础上，将模块或组件按照设计的要求租转起来，同时进行测试，主要目的是发现与接口有关的问题，即模块与模块之间的协作与通信。
      </li>
      <li>
       3、确认测试：经过集成测试之后软件已经组装起来了，接口方面的错误也已经排除，之后进行确认测试（有效性测试），主要任务是验证软件的有效性，验证软件功能和性能是否与用户的需求一直。
      </li>
     </ul>
     <blockquote>
      <ul>
       <li>
        α测试和β测试用以发现只有最终的用户才可以发现的错误。
       </li>
       <li>
        α测试：是在受控制的环境下进行的测试，主要是评价软件的FURPS（即功能、可使用性、可靠性、性能、和支持），尤其注重产品的界面和特色。
       </li>
       <li>
        β测试：是指软件的一个或者多个用户在一个或多个用户的实际使用环境下进行的测试。开发者不在测试现场，主要衡量产品的FURPS，着重于产品的支持性，包括文档，客户培训和支持产品生产能力。
       </li>
      </ul>
     </blockquote>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       4、系统测试：通过确认测试之后的软件作为基于计算机系统的一个元素，除了被测程序之外硬件，等实际环境下的测试。
      </li>
     </ul>
    </blockquote>
    <h5>
     <a id="_123">
     </a>
     二、软件调试：调试的任务就是根据测试时发现的错误，找出错误的原因和具体位置，并进行改正。改正后重新测试。
    </h5>
    <hr/>
    <h3>
     <a id="_126">
     </a>
     第八章软件维护
    </h3>
    <h5>
     <a id="_127">
     </a>
     软件维护：在软件交付使用之后，为了纠正软件的错误，满足新的需求，或者适应新的软件、硬件环境而对软件进行修改的过程。
    </h5>
    <ul>
     <li>
      可维护性：是指维护人员为了满足用户的需求而对软件系统出现的错误和缺陷进行修正，或对系统进行完善的难易程度。
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       改正性维护（纠错性维护）：软件产品投入使用支出会暴露出各种各样的错误，改正性维护是针对在系统运行过程中暴露的错误而进行的一种维护活动。
      </li>
      <li>
       完善性维护：随着软件产品平稳运行之后，用户往往会提出新的需求或者对性能的要求，为了满足这种要求，维护人员需要扩展软件的功能，提升软件的性能，是产品有更高的效率。
      </li>
      <li>
       适应性维护：软件产品在使用过程中会随着软件、硬件环境的变化，为了使软件产品适应这种环境的变化而对软件产品做出的维护，称为适应性维护。
      </li>
      <li>
       预防性维护：此目的是为了在问题有可能发生之前，主动的提高软件的可靠性，为今后的维护工作创造更加便利的条件，提高软件的可维护性。
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h3>
     <a id="_135">
     </a>
     第九章软件质量保证
    </h3>
    <ul>
     <li>
      软件质量：软件质量是软件产品满足规定的和隐含的与需求能力有关的全部特征和特性。包括：①软件产品满足用户需要的程度；②软件拥有所期望的各种属性组合的程度：③用户对软件产品的综合反映度；④软件在使用过程中满足用户需要的程度。
     </li>
     <li>
      软件质量的属性：
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       功能性：软件按照需求正确执行任务的能力。
      </li>
      <li>
       可靠性：软件在特定条件下和特殊时间内，不出故障，维持其正常性能水准的能力的程度。
      </li>
      <li>
       易使用性：用户为使用一个软件而付出的努力以及其他代价的程度，也就是用户使用软件的容易程度。
      </li>
      <li>
       效率：指在特定的条件下，软件功能与所占用资源之间的比例关系。
      </li>
      <li>
       可维护性：是指当发现错误，运行环境改变或用户需求改变的时候，程序可被修改的难易程度。
      </li>
      <li>
       可移植性：是指将软件从一种环境移植到另一种环境的难易程度，主要体现为代码的可移植性。
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h2>
     <a id="PS_146">
     </a>
     PS：
    </h2>
    <ul>
     <li>
      期末考复习资料整理；
     </li>
     <li>
      文章为《软降工程导论》（主编：薛继伟 哈尔滨工业大学出版社）的内容要点抽取。知识点以原书为准。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f6d305f3338303732373339:2f61727469636c652f64657461696c732f3833303937343235" class_="artid" style="display:none">
 </p>
</div>


