---
layout: post
title: "React-中-Hooks-函数及作用"
date: 2025-03-06 14:45:27 +0800
description: "作用：将组件逻辑提取到可重用的函数中。示例// 副作用逻辑优化建议将通用的逻辑提取到自定义 Hooks 中，提高代码复用性。将通用的逻辑提取到自定义 Hooks 中，提高代码复用性和可维护性。"
keywords: "React 中 Hooks 函数及作用"
categories: ['未分类']
tags: ['前端框架', '前端', 'React']
artid: "146070449"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146070449
    alt: "React-中-Hooks-函数及作用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146070449
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146070449
cover: https://bing.ee123.net/img/rand?artid=146070449
image: https://bing.ee123.net/img/rand?artid=146070449
img: https://bing.ee123.net/img/rand?artid=146070449
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     React 中 Hooks 函数及作用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     React Hooks 是 React 16.8 引入的一种新特性，它允许你在函数组件中使用状态（state）和其他 React 特性（如生命周期方法）。Hooks 提供了一种更简洁、更灵活的方式来编写组件逻辑，但如果不加以优化，可能会导致性能问题。以下是 React Hooks 的深度解析和优化建议。
    </p>
    <hr/>
    <h3>
     <a id="1__React_Hooks__4">
     </a>
     1.
     <strong>
      常用的 React Hooks 及作用
     </strong>
    </h3>
    <h4>
     <a id="11_useState_6">
     </a>
     1.1
     <code>
      useState
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于在函数组件中管理状态。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">const [count, setCount] = useState(0);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        避免在渲染过程中频繁调用
        <code>
         setState
        </code>
        ，可以使用函数式更新来减少不必要的渲染：
        <pre><code class="prism language-jsx">setCount(prevCount =&gt; prevCount + 1);
</code></pre>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="12_useEffect_18">
     </a>
     1.2
     <code>
      useEffect
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于在函数组件中执行副作用操作（如数据获取、订阅、手动 DOM 操作等）。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">useEffect(() =&gt; {
  console.log("Component mounted or updated");
  return () =&gt; {
    console.log("Component will unmount");
  };
}, [dependencies]);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        明确依赖项数组，避免不必要的副作用执行。
       </li>
       <li>
        在清理函数中释放资源（如取消订阅、清除定时器等）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="13_useContext_33">
     </a>
     1.3
     <code>
      useContext
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于在函数组件中访问 React 的上下文（Context）。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">const theme = useContext(ThemeContext);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        将上下文的值拆分为多个小的上下文，避免不必要的组件重新渲染。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="14_useReducer_42">
     </a>
     1.4
     <code>
      useReducer
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于管理复杂的状态逻辑，类似于 Redux 的 reducer。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">const [state, dispatch] = useReducer(reducer, initialState);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        在状态逻辑复杂时使用
        <code>
         useReducer
        </code>
        ，可以更好地组织代码。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="15_useMemo_51">
     </a>
     1.5
     <code>
      useMemo
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于缓存计算结果，避免在每次渲染时重新计算。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        仅在计算开销较大时使用
        <code>
         useMemo
        </code>
        ，避免过度使用。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="16_useCallback_60">
     </a>
     1.6
     <code>
      useCallback
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于缓存回调函数，避免在每次渲染时创建新的函数。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">const memoizedCallback = useCallback(() =&gt; {
  doSomething(a, b);
}, [a, b]);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        仅在需要将回调函数传递给子组件时使用
        <code>
         useCallback
        </code>
        。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="17_useRef_71">
     </a>
     1.7
     <code>
      useRef
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：用于保存可变值（如 DOM 引用或计时器 ID），且不会触发重新渲染。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">const inputRef = useRef(null);
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         useRef
        </code>
        来存储与渲染无关的值，避免滥用状态。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="18__Hooks_80">
     </a>
     1.8 自定义 Hooks
    </h4>
    <ul>
     <li>
      <strong>
       作用
      </strong>
      ：将组件逻辑提取到可重用的函数中。
     </li>
     <li>
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-jsx">function useCustomHook(initialValue) {
  const [value, setValue] = useState(initialValue);
  useEffect(() =&gt; {
    // 副作用逻辑
  }, [value]);
  return [value, setValue];
}
</code></pre>
     </li>
     <li>
      <strong>
       优化建议
      </strong>
      ：
      <ul>
       <li>
        将通用的逻辑提取到自定义 Hooks 中，提高代码复用性。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="2_Hooks__97">
     </a>
     2.
     <strong>
      Hooks 的深度优化
     </strong>
    </h3>
    <h4>
     <a id="21__99">
     </a>
     2.1 减少不必要的重新渲染
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：Hooks 的使用不当可能导致组件频繁重新渲染。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         React.memo
        </code>
        包裹组件，避免不必要的渲染。
       </li>
       <li>
        使用
        <code>
         useMemo
        </code>
        和
        <code>
         useCallback
        </code>
        缓存值和函数。
       </li>
       <li>
        确保
        <code>
         useEffect
        </code>
        的依赖项数组正确，避免不必要的副作用执行。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="22__useEffect_106">
     </a>
     2.2 避免滥用
     <code>
      useEffect
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：过度使用
      <code>
       useEffect
      </code>
      可能导致性能问题。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        将副作用逻辑拆分为多个
        <code>
         useEffect
        </code>
        ，每个
        <code>
         useEffect
        </code>
        只关注一个功能。
       </li>
       <li>
        在
        <code>
         useEffect
        </code>
        中清理资源（如取消订阅、清除定时器）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="23__useContext__112">
     </a>
     2.3 优化
     <code>
      useContext
     </code>
     的使用
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：当上下文的值发生变化时，所有使用该上下文的组件都会重新渲染。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        将上下文拆分为多个小的上下文，减少不必要的渲染。
       </li>
       <li>
        使用
        <code>
         useMemo
        </code>
        或
        <code>
         useSelector
        </code>
        （如 Redux）来优化上下文的使用。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="24__useMemo__useCallback_118">
     </a>
     2.4 合理使用
     <code>
      useMemo
     </code>
     和
     <code>
      useCallback
     </code>
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：过度使用
      <code>
       useMemo
      </code>
      和
      <code>
       useCallback
      </code>
      可能导致性能问题。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        仅在计算开销较大或需要传递回调函数给子组件时使用
        <code>
         useMemo
        </code>
        和
        <code>
         useCallback
        </code>
        。
       </li>
       <li>
        避免在每次渲染时都创建新的函数或值。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="25__useReducer__124">
     </a>
     2.5 使用
     <code>
      useReducer
     </code>
     管理复杂状态
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：当状态逻辑复杂时，使用
      <code>
       useState
      </code>
      可能导致代码难以维护。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         useReducer
        </code>
        来管理复杂的状态逻辑，类似于 Redux 的 reducer。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="26__129">
     </a>
     2.6 避免在渲染过程中执行高开销操作
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：在渲染过程中执行高开销操作（如大量计算或 DOM 操作）可能导致性能问题。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        将高开销操作放到
        <code>
         useEffect
        </code>
        或
        <code>
         useMemo
        </code>
        中执行。
       </li>
       <li>
        使用 Web Workers 来处理计算密集型任务。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="27__Reactmemo__135">
     </a>
     2.7 使用
     <code>
      React.memo
     </code>
     优化子组件
    </h4>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：父组件重新渲染时，子组件也会重新渲染。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         React.memo
        </code>
        包裹子组件，避免不必要的渲染。
       </li>
       <li>
        确保传递给子组件的 props 是稳定的（使用
        <code>
         useMemo
        </code>
        或
        <code>
         useCallback
        </code>
        ）。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="3_Hooks__143">
     </a>
     3.
     <strong>
      Hooks 的最佳实践
     </strong>
    </h3>
    <h4>
     <a id="31__145">
     </a>
     3.1 遵循单一职责原则
    </h4>
    <ul>
     <li>
      每个 Hook 应该只关注一个功能，避免将多个逻辑混合在一个 Hook 中。
     </li>
    </ul>
    <h4>
     <a id="32__Hooks_148">
     </a>
     3.2 提取自定义 Hooks
    </h4>
    <ul>
     <li>
      将通用的逻辑提取到自定义 Hooks 中，提高代码复用性和可维护性。
     </li>
    </ul>
    <h4>
     <a id="33__ESLint__151">
     </a>
     3.3 使用 ESLint 插件
    </h4>
    <ul>
     <li>
      使用
      <code>
       eslint-plugin-react-hooks
      </code>
      插件，确保 Hooks 的使用符合规则（如依赖项数组的正确使用）。
     </li>
    </ul>
    <h4>
     <a id="34__Hooks_154">
     </a>
     3.4 测试 Hooks
    </h4>
    <ul>
     <li>
      使用
      <code>
       @testing-library/react-hooks
      </code>
      测试自定义 Hooks，确保其行为符合预期。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="4__159">
     </a>
     4.
     <strong>
      总结
     </strong>
    </h3>
    <p>
     React Hooks 提供了一种更简洁、更灵活的方式来编写组件逻辑，但如果不加以优化，可能会导致性能问题。通过合理使用
     <code>
      useMemo
     </code>
     、
     <code>
      useCallback
     </code>
     、
     <code>
      useEffect
     </code>
     等 Hooks，并结合最佳实践，可以显著提升 React 应用的性能和可维护性。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323930303134302f:61727469636c652f64657461696c732f313436303730343439" class_="artid" style="display:none">
 </p>
</div>


