---
layout: post
title: "详解软件测试中白盒测试基本概念及四种白盒测试方法以及六种逻辑覆盖法语句覆盖判定覆盖条件覆盖判定条件覆盖条件组合覆盖路径覆盖"
date: 2021-12-13 17:34:34 +0800
description: "+次，点赞199次，在这篇文章中，我们将讲解白盒测试的基本概念，_白盒测试"
keywords: "白盒测试"
categories: ['软件测试']
tags: ['软件测试', '编程语言', 'Java', 'C']
artid: "121907540"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=121907540
    alt: "详解软件测试中白盒测试基本概念及四种白盒测试方法以及六种逻辑覆盖法语句覆盖判定覆盖条件覆盖判定条件覆盖条件组合覆盖路径覆盖"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=121907540
featuredImagePreview: https://bing.ee123.net/img/rand?artid=121907540
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     详解软件测试中白盒测试基本概念及四种白盒测试方法以及六种逻辑覆盖法（语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在这篇文章中，我们将讲解白盒测试的基本概念，以及四大常用的
     <span style="color:#e6b223;">
      <strong>
       白盒测试方法
      </strong>
     </span>
     。
    </p>
    <h2>
     <span style="color:#ad720d;">
      一、白盒测试基本概念
     </span>
    </h2>
    <h3 id="1%E3%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AE%9A%E4%B9%89">
     <span style="color:#ad720d;">
      1、白盒测试的定义
     </span>
    </h3>
    <p>
     白盒测试又称为
     <span style="color:#e6b223;">
      <strong>
       结构测试
      </strong>
     </span>
     或
     <span style="color:#e6b223;">
      <strong>
       逻辑驱动测试
      </strong>
     </span>
     ，它是把测试对象看成一个
     <span style="color:#e6b223;">
      <strong>
       透明
      </strong>
     </span>
     的盒子，它允许测试人员利用程序
     <span style="color:#e6b223;">
      <strong>
       内部的逻辑结构
      </strong>
     </span>
     设计测试用例，对程序所有逻辑路径进行测试。
    </p>
    <h3 id="2%E3%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1">
     <span style="color:#ad720d;">
      2、白盒测试的测试对象
     </span>
    </h3>
    <p>
     白盒测试的测试对象是基于被测试程序的
     <span style="color:#e6b223;">
      <strong>
       源代码
      </strong>
     </span>
     ，而不是软件的需求规格说明书。
    </p>
    <p>
     使用白盒测试方法时，测试人员必须全面了解程序内部逻辑结构，检查程序的
     <span style="color:#e6b223;">
      <strong>
       内部结构
      </strong>
     </span>
     ，从检查程序的逻辑着手，对相关的逻辑路径进行测试，最后得出测试结果。
    </p>
    <h3 id="3%E3%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%9F%E5%88%99">
     <span style="color:#ad720d;">
      3、白盒测试的原则
     </span>
    </h3>
    <p>
     采用白盒测试方法必须遵循以下原则：
    </p>
    <ul>
     <li>
      <p>
       保证一个模块中的
       <span style="color:#e6b223;">
        <strong>
         所有独立路径至少被测试一次
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       对所有的逻辑判定均需测试
       <span style="color:#e6b223;">
        <strong>
         取真和取假
        </strong>
       </span>
       两种情况。
      </p>
     </li>
     <li>
      <p>
       在上下边界及可操作范围内运行所有循环。
      </p>
     </li>
     <li>
      <p>
       检查程序的内部数据结构，保证其结构的有效性。
      </p>
     </li>
    </ul>
    <h3 id="4%E3%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB">
     <span style="color:#ad720d;">
      4、白盒测试的分类
     </span>
    </h3>
    <p>
     白盒测试方法有两大类：
     <span style="color:#e6b223;">
      <strong>
       静态测试方法
      </strong>
     </span>
     和
     <span style="color:#e6b223;">
      <strong>
       动态测试方法
      </strong>
     </span>
     。
    </p>
    <p>
     <strong>
      <span style="color:#e6b223;">
       静态测试
      </span>
      ：
     </strong>
     不要求在计算机上实际执行所测试的程序，主要以一些人工的模拟技术对软件进行分析和测试，如
     <span style="color:#e6b223;">
      <strong>
       代码检查法
      </strong>
     </span>
     、
     <span style="color:#e6b223;">
      <strong>
       静态结构分析法
      </strong>
     </span>
     等；
    </p>
    <p>
     <strong>
      <span style="color:#e6b223;">
       动态测试
      </span>
      ：
     </strong>
     是通过输入一组预先按照
     <span style="color:#e6b223;">
      <strong>
       一定的测试准则
      </strong>
     </span>
     构造实际数据来动态运行程序，达到发现程序错误的过程。白盒测试中的动态分析技术主要有
     <span style="color:#e6b223;">
      <strong>
       逻辑覆盖法
      </strong>
     </span>
     和
     <span style="color:#e6b223;">
      <strong>
       基本路径测试法
      </strong>
     </span>
     。（
     <span style="color:#fe2c24;">
      ★ ★ ★
     </span>
     ）
    </p>
    <p>
     下面将对两种白盒测试方法进行讲解。
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">
     <span style="color:#ad720d;">
      二、静态白盒测试
     </span>
    </h2>
    <h3 id="1%E3%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E6%B3%95">
     <span style="color:#ad720d;">
      1、代码检查法
     </span>
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%AE%9A%E4%B9%89">
     <span style="color:#ad720d;">
      （1）代码审查的定义
     </span>
    </h4>
    <p>
     代码审查（Code Review）是指对
     <span style="color:#e6b223;">
      <strong>
       计算机源代码
      </strong>
     </span>
     进行系统地审查，找出并修正在软件开发初期未发现的错误，提升软件质量及开发者的技术。
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E7%9B%AE%E7%9A%84">
     <span style="color:#ad720d;">
      （2）代码审查的目的
     </span>
    </h4>
    <p>
     代码审查的目的是
     <span style="color:#e6b223;">
      <strong>
       为了产生合格的代码
      </strong>
     </span>
     ，
     <span style="color:#e6b223;">
      <strong>
       检查源程序编码是否符合详细设计的编码规定
      </strong>
     </span>
     ，确保编码与设计的一致性和可追踪性。
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E6%96%B9%E6%B3%95">
     <span style="color:#ad720d;">
      （3）代码审查的方法
     </span>
    </h4>
    <p>
     代码审查包括
     <span style="color:#e6b223;">
      <strong>
       桌面检查
      </strong>
     </span>
     、
     <span style="color:#e6b223;">
      <strong>
       代码审查
      </strong>
     </span>
     和
     <span style="color:#e6b223;">
      <strong>
       走查
      </strong>
     </span>
     。
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       1）桌面检查（程序员自己检查）
      </strong>
     </span>
    </p>
    <p>
     这是一种
     <span style="color:#e6b223;">
      <strong>
       传统的
      </strong>
     </span>
     检查方法，由程序员检查自己编写的程序。程序员在程序通过编译之后，对源程序代码进行分析、检查，并补充相关的文档，目的是发现程序中的错误。
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       2）代码审查（审查小组通过读程序和对照错误检查表进行检查）
      </strong>
     </span>
    </p>
    <p>
     代码审查是由若干
     <span style="color:#e6b223;">
      <strong>
       程序员
      </strong>
     </span>
     和
     <span style="color:#e6b223;">
      <strong>
       测试员
      </strong>
     </span>
     组成一个审查小组，通过阅读、讨论和争议，对程序进行静态分析的过程。
     <strong>
      <span style="color:#e6b223;">
       具体过程如下
      </span>
      ：
     </strong>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       第一步，
      </strong>
     </span>
     小组负责人提前把设计规格说明书、控制流程图、程序文本及有关要求、规范等分发给小组成员，作为审查的依据。小组成员在充分阅读这些材料后，进入审查的下一步。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       第二步，召开程序审查会。
      </strong>
     </span>
     每个成员将所发材料作为审查依据，但是由程序员讲解程序的结构、逻辑和源程序。在此过程中，小组成员可以提出自己的疑问；程序员在讲解自己的程序时，也能发现自己原来没有注意到的问题。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       注意：
      </strong>
     </span>
     在进行代码检查前应准备好需求文档、程序设计文档、程序的源代码清单、代码编码标准、代码缺陷检查表和流程图等。
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       3）走查 （审查小组需要准备有代表性的测试用例沿程序逻辑运行）
      </strong>
     </span>
    </p>
    <p>
     走查与代码审查基本相同，
     <span style="color:#e6b223;">
      <strong>
       其过程分为两步：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       第一步：
      </strong>
     </span>
     把材料先发给走查小组每个成员，让他们认真研究程序。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       第二步：
      </strong>
     </span>
     开会。
    </p>
    <p>
     与代码审查不同的是，让审查小组成员“充当”计算机，即首先由测试组成员为所测程序准备一批有代表性的测试用例，提交给走查小组。走查小组开会，集体扮演计算机角色，让测试用例沿着程序的逻辑运行一遍，随时记录程序的踪迹，提供给最后阶段的分析和讨论使用。
    </p>
    <h4 id="%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E8%A7%84%E5%88%99">
     <span style="color:#ad720d;">
      （4）代码检查规则
     </span>
    </h4>
    <p>
     在代码检查中，需要依据被测试软件的特点，选用适当的
     <span style="color:#e6b223;">
      <strong>
       标准
      </strong>
     </span>
     与
     <span style="color:#e6b223;">
      <strong>
       规则规范
      </strong>
     </span>
     。
    </p>
    <h4 id="%E2%80%8B%EF%BC%885%EF%BC%89%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E9%A1%B9%E7%9B%AE">
     <img alt="" height="675" src="https://i-blog.csdnimg.cn/blog_migrate/7d52dcdf03372ff6a36ff56678549fde.png" width="889"/>
    </h4>
    <h4>
     <span style="color:#ad720d;">
      （5）代码检查项目
     </span>
    </h4>
    <ul>
     <li>
      <p>
       目录文件组织
      </p>
     </li>
     <li>
      <p>
       检查函数
      </p>
     </li>
     <li>
      <p>
       数据类型及变量
      </p>
     </li>
     <li>
      <p>
       检查条件判断语句
      </p>
     </li>
     <li>
      <p>
       检查循环体制
      </p>
     </li>
     <li>
      <p>
       检查代码注释
      </p>
     </li>
     <li>
      <p>
       桌面检查
      </p>
     </li>
     <li>
      <p>
       其他检查
      </p>
     </li>
    </ul>
    <h3 id="2%E3%80%81%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E6%B3%95">
     <span style="color:#ad720d;">
      2、静态结构分析法
     </span>
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E5%AE%9A%E4%B9%89">
     <span style="color:#ad720d;">
      （1）定义
     </span>
    </h4>
    <p>
     在静态结构分析法中，测试人员通常通过使用测试工具分析程序源代码的系统结构、数据结构、数据接口、内部控制逻辑等内部结构，
     <span style="color:#e6b223;">
      <strong>
       生成函数调用关系图
      </strong>
     </span>
     、
     <span style="color:#e6b223;">
      <strong>
       模块控制流图
      </strong>
     </span>
     、
     <span style="color:#e6b223;">
      <strong>
       内部文件调用关系图
      </strong>
     </span>
     等各种图形、图表，清晰地标识整个软件的组成结构。
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E7%9B%AE%E7%9A%84">
     <span style="color:#ad720d;">
      （2）目的
     </span>
    </h4>
    <p>
     通过分析这些图表，包括控制流分析、数据流分析、接口分析、表达式分析等，使其便于阅读与理解，然后可以通过分析这些图表，检查软件有没有存在缺陷或错误。
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">
     <span style="color:#ad720d;">
      （3）静态结构分析的两种方法
     </span>
    </h4>
    <p>
     <span style="color:#e6b223;">
      <strong>
       1）通过生成各种图表，来帮助对源程序的静态分析
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       常用的各种引用表主要有：
      </strong>
     </span>
     <strong>
      ①
     </strong>
     标号交叉引用表；
     <strong>
      ②
     </strong>
     变量交叉引用表；
     <strong>
      ③
     </strong>
     子程序（宏、函数）引用表；
     <strong>
      ④
     </strong>
     等价表；
     <strong>
      ⑤
     </strong>
     常数表。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       常用的各种关系图、控制流图主要有：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①函数调用关系图：
      </strong>
     </span>
     列出所有函数，用连线表示调用关系，通过应用程序各函数之间的调用关系展示了系统的结构。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②模块控制流图：
      </strong>
     </span>
     由
     <span style="color:#e6b223;">
      <strong>
       许多结点和连接结点的边
      </strong>
     </span>
     组成的图形，其中每个结点代表一条或多条语句，
     <span style="color:#e6b223;">
      <strong>
       边表示节点间的控制流向
      </strong>
     </span>
     ，用于
     <span style="color:#e6b223;">
      <strong>
       显示函数的内部逻辑结构。
      </strong>
     </span>
     （
     <span style="color:#fe2c24;">
      ★ ★ ★
     </span>
     ）
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       2) 错误静态分析
      </strong>
     </span>
    </p>
    <p>
     静态错误分析主要用于确定在源程序中
     <span style="color:#e6b223;">
      <strong>
       是否有某类错误或“危险”结构
      </strong>
     </span>
     。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①类型和单位分析：
      </strong>
     </span>
     数据类型的错误和单位上的不一致。
    </p>
    <p>
     <strong>
      <span style="color:#e6b223;">
       ②引用分析：
      </span>
     </strong>
     引用异常，变量赋值先引用，或赋值未引用。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ③表达式分析：
      </strong>
     </span>
     表达式错误，不正确使用括号，数组下标越界等。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ④接口分析：
      </strong>
     </span>
     模块的接口，参数的一致性。
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">
     <span style="color:#ad720d;">
      三、动态白盒测试
     </span>
    </h2>
    <h3 id="1%E3%80%81%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95">
     <span style="color:#ad720d;">
      1、逻辑覆盖法
     </span>
    </h3>
    <h4>
     <span style="color:#ad720d;">
      （1）定义
     </span>
    </h4>
    <p>
     逻辑覆盖是
     <span style="color:#e6b223;">
      <strong>
       以程序内部的逻辑结构为基础
      </strong>
     </span>
     来设计测试用例的测试技术，通过对程序内部的逻辑结构的遍历来实现程序的覆盖。它属于白盒测试中动态测试技术之一。
    </p>
    <h4 id="%EF%BC%882%EF%BC%896%E7%A7%8D%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95">
     <span style="color:#ad720d;">
      （2）6种逻辑覆盖方法
     </span>
    </h4>
    <p>
     从覆盖源程序语句的详尽程度分析，
     <span style="color:#e6b223;">
      <strong>
       逻辑覆盖包括以下6种覆盖标准：
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <p>
       语句覆盖（SC）；
      </p>
     </li>
     <li>
      <p>
       判定覆盖（DC）；
      </p>
     </li>
     <li>
      <p>
       条件覆盖（CC）；
      </p>
     </li>
     <li>
      <p>
       判定-条件覆盖（CDC）；
      </p>
     </li>
     <li>
      <p>
       条件组合覆盖（MCC）；
      </p>
     </li>
     <li>
      <p>
       路径覆盖。
      </p>
     </li>
    </ul>
    <p>
     接下来将对这6种逻辑覆盖方法进行一一讲解。
    </p>
    <p>
     <span style="color:#ad720d;">
      1）语句覆盖（SC）
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①定义：
      </strong>
     </span>
     语句覆盖(Statement Coverage)的含义就
     <span style="color:#e6b223;">
      <strong>
       是设计足够的测试用例，使得被测程序中每条语句至少执行一次
      </strong>
     </span>
     。又称行覆盖、段覆盖、基本块覆盖，它是最常见的覆盖方式。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②例子展示
      </strong>
      🌰
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Question：
      </strong>
     </span>
    </p>
    <p>
     如下java语言程序语句和对应的程序流程图：
    </p>
    <pre><code class="language-java">public class Test{
    public void Test1(int x,int y,int z){
        if(y&gt;1 &amp;&amp; z==0){
            x=(int)(x/y)
        }
        if(y==2 || x&gt;1){
            x=x+1
        }
    }
}</code></pre>
    <p>
     <img alt="" height="646" src="https://i-blog.csdnimg.cn/blog_migrate/aed72149cb7cfd3cc06a184a5b309e51.png" width="922"/>
    </p>
    <p>
     请使用
     <span style="color:#e6b223;">
      <strong>
       语句覆盖
      </strong>
     </span>
     来为该程序设计测试用例。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Answer：
      </strong>
     </span>
    </p>
    <p>
     为了使每条语句都能够至少执行一次，我们可以构造以下测试用例：
    </p>
    <p>
     输入：
     <code>
      x=4
     </code>
     ,
     <code>
      y=2
     </code>
     ,
     <code>
      z=0
     </code>
    </p>
    <p>
     执行路径为：
     <code>
      sacbed
     </code>
    </p>
    <p>
     语句覆盖虽然可以测试执行语句是否被执行到，但却
     <span style="color:#e6b223;">
      <strong>
       无法测试程序中存在的逻辑错误
      </strong>
     </span>
     。因此，
     <span style="color:#e6b223;">
      <strong>
       语句覆盖是一种弱覆盖
      </strong>
     </span>
     。
    </p>
    <p>
     例如，如果上述程序中的第一个逻辑判断符号
     <code>
      “&amp;&amp;”
     </code>
     误写了
     <code>
      “||”
     </code>
     ，使用测试用例同样可以覆盖
     <code>
      sacbed
     </code>
     路径上的全部执行语句，但却无法发现错误。同样，如果第二个逻辑判断符号
     <code>
      “||”
     </code>
     误写了
     <code>
      “&amp;&amp;”
     </code>
     ，使用同样的测试用例也可以执行
     <code>
      sacbed
     </code>
     路径上的全部执行语句，但却无法发现上述逻辑错误。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ③语句覆盖的目的：
      </strong>
     </span>
    </p>
    <p>
     语句覆盖的目的是测试程序中的代码是否被执行，
     <span style="color:#e6b223;">
      <strong>
       它只测试代码中的执行语句，这里的执行语句不包括头文件、注释、空行
      </strong>
     </span>
     等。
    </p>
    <p>
     语句覆盖在多分支的程序中，只能覆盖
     <span style="color:#e6b223;">
      <strong>
       某一条路径
      </strong>
     </span>
     ，使得该路径中的每一个语句至少被执行一次，但
     <span style="color:#e6b223;">
      <strong>
       不会考虑各种分支组合情况
      </strong>
     </span>
     。
    </p>
    <p>
     <span style="color:#ad720d;">
      2）判定覆盖（DC）
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①定义：
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <p>
       判定覆盖(Decision Coverage)又称为
       <span style="color:#e6b223;">
        <strong>
         分支覆盖
        </strong>
       </span>
       ，其原则是
       <span style="color:#e6b223;">
        <strong>
         设计足够的测试用例
        </strong>
       </span>
       ，使得程序中每个判定语句的取真和取假分支
       <span style="color:#e6b223;">
        <strong>
         至少被执行一次
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       除了双值的
       <span style="color:#e6b223;">
        <strong>
         判定语句
        </strong>
       </span>
       外，还有
       <span style="color:#e6b223;">
        <strong>
         多值判定语句
        </strong>
       </span>
       ，如
       <span style="color:#e6b223;">
        <strong>
         case语句
        </strong>
       </span>
       ，因此判定覆盖更一般的含义是：
       <span style="color:#e6b223;">
        <strong>
         使得每一个判定获得每一种可能的结果至少一次
        </strong>
       </span>
       。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②例子展示
      </strong>
      🌰
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Question：
      </strong>
     </span>
    </p>
    <p>
     如下java语言程序语句和对应的程序流程图：
    </p>
    <pre><code class="language-java">public class Test{
    public void Test2(int x,int y,int z){
        if(y&gt;1 &amp;&amp; z==0){
            x=(int)(x/y)
        }
        if(y==2 || x&gt;1){
            x=x+1
        }
    }
}</code></pre>
    <p>
     <img alt="" height="649" src="https://i-blog.csdnimg.cn/blog_migrate/cf6e9c4836220416542c54150f8d1a90.png" width="913"/>
    </p>
    <p>
     请使用
     <span style="color:#e6b223;">
      <strong>
       判定覆盖
      </strong>
     </span>
     来为该程序设计测试用例。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Answer：
      </strong>
     </span>
    </p>
    <p>
     以上述代码为例，构造以下测试用例即可实现判定覆盖标准：
    </p>
    <p>
     输入：①
     <code>
      x=1,y=3,z=0
     </code>
     ，执行路径为
     <code>
      sacbd
     </code>
    </p>
    <p>
     （判断的结果分别为
     <span style="color:#e6b223;">
      <strong>
       T，F
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：②
     <code>
      x=3,y=1,z=1
     </code>
     ，执行路径为
     <code>
      sabed
     </code>
    </p>
    <p>
     （判断的结果分别为
     <span style="color:#e6b223;">
      <strong>
       F，T
      </strong>
     </span>
     ）
    </p>
    <p>
     上述两组测试用例不仅满足了判定覆盖，而且满足了语句覆盖，从这一点可以看出判定覆盖比语句覆盖更强一些。所以
     <span style="color:#e6b223;">
      <strong>
       只要满足了判定覆盖就一定满足语句覆盖，反之则不然
      </strong>
     </span>
     。
    </p>
    <p>
     判定覆盖仍然具有和语句覆盖一样无法发现逻辑判断符号
     <code>
      “&amp;&amp;”
     </code>
     误写了
     <code>
      “||”
     </code>
     的逻辑错误。
    </p>
    <p>
     判定覆盖仅仅判断判定语句执行的最终结果而
     <span style="color:#e6b223;">
      <strong>
       忽略每个条件的取值
      </strong>
     </span>
     ，所以也属于
     <span style="color:#e6b223;">
      <strong>
       弱覆盖
      </strong>
     </span>
     。
    </p>
    <p>
     <span style="color:#ad720d;">
      3）条件覆盖（CC）
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①定义：
      </strong>
     </span>
    </p>
    <p>
     条件覆盖(Condition Coverage)指的是
     <span style="color:#e6b223;">
      <strong>
       设计足够的测试用例
      </strong>
     </span>
     ，使判定语句中的
     <span style="color:#e6b223;">
      <strong>
       每个逻辑条件取真值与取假值至少出现一次
      </strong>
     </span>
     。
    </p>
    <p>
     例如，对于判定语句
     <code>
      if(a&gt;1 OR c&lt;0)
     </code>
     中存在
     <code>
      a&gt;1、c&lt;0
     </code>
     两个逻辑条件，设计条件覆盖测试用例时，要保证
     <code>
      a&gt;1、c&lt;0
     </code>
     的“真”、“假”值至少出现一次。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②例子展示
      </strong>
      🌰
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Question：
      </strong>
     </span>
    </p>
    <p>
     如下java语言程序语句和对应的程序流程图：
    </p>
    <pre><code class="language-java">public class Test{
    public void Test3(int x,int y,int z){
        if(y&gt;1 &amp;&amp; z==0){
            x=(int)(x/y)
        if(y==2 || x&gt;1){
            x=x+1
        }
    }
}</code></pre>
    <p>
     <img alt="" height="645" src="https://i-blog.csdnimg.cn/blog_migrate/a41c7445ced3750b0e1e4ee9b27f6b14.png" width="979"/>
    </p>
    <p>
     请使用
     <span style="color:#e6b223;">
      <strong>
       条件覆盖
      </strong>
     </span>
     来为该程序设计测试用例。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Answer：
      </strong>
     </span>
    </p>
    <p>
     要使程序中每个判断的每个条件都至少取真值、假值一次，我们可以构造以下测试用例：
    </p>
    <p>
     输入：①
     <code>
      x=1,y=2,z=0
     </code>
     ，执行路径为
     <code>
      sacbed
     </code>
    </p>
    <p>
     （条件的结果分别为
     <span style="color:#e6b223;">
      <strong>
       TTTF
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：②
     <code>
      x=2,y=1,z=1
     </code>
     ，执行路径为
     <code>
      sabed
     </code>
    </p>
    <p>
     （条件的结果分别为
     <span style="color:#e6b223;">
      <strong>
       FFFT
      </strong>
     </span>
     ）
    </p>
    <p>
     从条件覆盖的测试用例可知，使用2个测试用例就达到了使每个逻辑条件取真值与取假值都至少出现了一次，但从测试用例的执行路径来看，
     <span style="color:#e6b223;">
      <strong>
       条件分支覆盖的状态下仍旧不能满足判定覆盖
      </strong>
     </span>
     ，即没有覆盖
     <code>
      bd
     </code>
     这条路径。相比于语句覆盖与判定覆盖，条件覆盖达到了逻辑条件的最大覆盖率，但却不能保证判定覆盖。
    </p>
    <p>
     <span style="color:#ad720d;">
      4）判定-条件覆盖（CDC）
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①定义：
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <p>
       要求设计足够的测试用例，使得判定语句中
       <span style="color:#e6b223;">
        <strong>
         所有条件的可能取值至少出现一次
        </strong>
       </span>
       ，同时，
       <span style="color:#e6b223;">
        <strong>
         所有判定语句的可能结果也至少出现一次
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       例如，对于判定语句
       <code>
        if(a&gt;1 AND c&lt;1)
       </code>
       ，该判定语句有
       <code>
        a&gt;1、c&lt;1
       </code>
       两个条件，则在设计测试用例时，要保证
       <code>
        a&gt;1、c&lt;1
       </code>
       两个条件取“真”、“假”值至少一次，同时，判定语句
       <code>
        if(a&gt;1 AND c&lt;1)
       </code>
       取“真”、“假”也至少出现一次。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②例子展示
      </strong>
      🌰
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Question：
      </strong>
     </span>
    </p>
    <p>
     如下java语言程序语句和对应的程序流程图：
    </p>
    <pre><code class="language-java">public class Test{
    public void Test3(int x,int y,int z){
        if(y&gt;1 &amp;&amp; z==0){
            x=(int)(x/y)
        }
        if(y==2 || x&gt;1){
            x=x+1
        }
    }
}</code></pre>
    <p>
     <img alt="" height="639" src="https://i-blog.csdnimg.cn/blog_migrate/4c613c1950848da22d9f8d01a29087bf.png" width="986"/>
    </p>
    <p>
     请使用
     <span style="color:#e6b223;">
      <strong>
       判定条件覆盖
      </strong>
     </span>
     来为该程序设计测试用例。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Answer：
      </strong>
     </span>
    </p>
    <p>
     为满足判定-条件覆盖原则，我们可以构造以下测试用例：
    </p>
    <p>
     输入：①
     <code>
      x=4,y=2,z=0
     </code>
     ，覆盖路径：
     <code>
      sacbed
     </code>
    </p>
    <p>
     （判断的结果分别为
     <span style="color:#e6b223;">
      <strong>
       TT
      </strong>
     </span>
     ，条件的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       TTTT
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：②
     <code>
      x=1,y=1,z=1
     </code>
     ，覆盖路径：
     <code>
      sabd
     </code>
    </p>
    <p>
     （判断的结果分别为
     <span style="color:#e6b223;">
      <strong>
       FF
      </strong>
     </span>
     ，条件的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       FFFF
      </strong>
     </span>
     ）
    </p>
    <p>
     判定-条件覆盖满足了
     <span style="color:#e6b223;">
      <strong>
       判定覆盖准则
      </strong>
     </span>
     和
     <span style="color:#e6b223;">
      <strong>
       条件覆盖准则
      </strong>
     </span>
     ，弥补了二者的不足。但是判定-条件覆盖不一定比条件覆盖的逻辑更强。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ③判定-条件覆盖的缺点：
      </strong>
     </span>
     没有考虑条件的组合情况。
    </p>
    <p>
     <span style="color:#ad720d;">
      5）条件组合覆盖（MCC）
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①定义：
      </strong>
     </span>
    </p>
    <p>
     条件组合(Multiple Condition Coverage)指的是设计足够的测试用例，使得
     <span style="color:#e6b223;">
      <strong>
       每个判定中条件的各种可能组合都至少执行一次
      </strong>
     </span>
     。满足了判定覆盖、条件覆盖、判定-条件覆盖准则。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②例子展示
      </strong>
      🌰
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Question：
      </strong>
     </span>
    </p>
    <p>
     如下java语言程序语句和对应的程序流程图：
    </p>
    <pre><code class="language-java">public class Test{
    public void Test4(int x,int y,int z){
        if(y&gt;1 &amp;&amp; z==0){
            x=(int)(x/y)
        }
        if(y==2 || x&gt;1){
            x=x+1
        }
    }
}</code></pre>
    <p>
     <img alt="" height="643" src="https://i-blog.csdnimg.cn/blog_migrate/156c176d4aa43ffd8dff13e544c43de3.png" width="985"/>
    </p>
    <p>
     请使用
     <span style="color:#e6b223;">
      <strong>
       条件组合覆盖
      </strong>
     </span>
     来为该程序设计测试用例。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Answer：
      </strong>
     </span>
    </p>
    <p>
     为满足
     <span style="color:#e6b223;">
      <strong>
       条件组合覆盖
      </strong>
     </span>
     原则，我们可以构造以下测试用例：
    </p>
    <p>
     输入：①
     <code>
      x=4,y=2,z=0
     </code>
     ，覆盖路径：
     <code>
      sacbed
     </code>
     （条件的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       TTTT
      </strong>
     </span>
     ）
    </p>
    <p>
     输入： ②
     <code>
      x=1,y=2,z=1
     </code>
     ，覆盖路径：
     <code>
      sabed
     </code>
     （条件的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       TFTF
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：③
     <code>
      x=2,y=1,z=0
     </code>
     ，覆盖路径：
     <code>
      sabed
     </code>
     （条件的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       FTFT
      </strong>
     </span>
     ）
    </p>
    <p>
     输入： ④
     <code>
      x=1,y=1,z=1
     </code>
     ，覆盖路径：
     <code>
      sabd
     </code>
     （条件的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       FFFF
      </strong>
     </span>
     ）
    </p>
    <p>
     由于这4个条件每个条件都有取“真”、“假”两个值，因此所有条件结果的组合有
     <span style="color:#e6b223;">
      <strong>
       <img alt="2^{4}" class="mathcode" src="https://latex.csdn.net/eq?%5Cfn_cm%202%5E%7B4%7D"/>
      </strong>
     </span>
     <span style="color:#0d0016;">
      <strong>
       =16种
      </strong>
     </span>
     。但是，当一个程序中判定语句较多时，其条件取值的组合数目也较多。需要设计的测试用例也会增加，这样反而会使测试效率降低。
    </p>
    <p>
     <span style="color:#ad720d;">
      6）路径覆盖
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ①定义：
      </strong>
     </span>
    </p>
    <p>
     路径覆盖指的是
     <span style="color:#e6b223;">
      <strong>
       设计足够的测试用例
      </strong>
     </span>
     ，使得程序中的
     <span style="color:#e6b223;">
      <strong>
       每一条可能组合的路径都至少执行一次
      </strong>
     </span>
     。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       ②例子展示
      </strong>
      🌰
     </span>
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Question：
      </strong>
     </span>
    </p>
    <p>
     如下java语言程序语句和对应的程序流程图：
    </p>
    <pre><code class="language-java">public class Test{
    public void Test5(int x,int y,int z){
        if(y&gt;1 &amp;&amp; z==0){
            x=(int)(x/y)
        }
        if(y==2 || x&gt;1){
            x=x+1
        }
    }
}</code></pre>
    <p>
     <img alt="" height="646" src="https://i-blog.csdnimg.cn/blog_migrate/ccff385a32b454ea40106b5fbc1b2eb5.png" width="963"/>
    </p>
    <p>
     请使用
     <span style="color:#e6b223;">
      <strong>
       路径覆盖
      </strong>
     </span>
     来为该程序设计测试用例。
    </p>
    <p>
     <span style="color:#e6b223;">
      <strong>
       Answer：
      </strong>
     </span>
    </p>
    <p>
     为满足路径覆盖原则，我们可以构造以下测试用例：
    </p>
    <p>
     输入：①
     <code>
      x=4,y=2,z=0
     </code>
     ，覆盖路径：
     <code>
      sacbed
     </code>
    </p>
    <p>
     （判定的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       TT
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：②
     <code>
      x=1,y=2,z=1
     </code>
     ，覆盖路径：
     <code>
      sabed
     </code>
    </p>
    <p>
     （判定的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       FT
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：③
     <code>
      x=1,y=3,z=0
     </code>
     ，覆盖路径：
     <code>
      sacbd
     </code>
    </p>
    <p>
     （判定的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       TF
      </strong>
     </span>
     ）
    </p>
    <p>
     输入：④
     <code>
      x=1,y=1,z=1
     </code>
     ，覆盖路径：
     <code>
      sabd
     </code>
    </p>
    <p>
     （判定的结果分别为：
     <span style="color:#e6b223;">
      <strong>
       FF
      </strong>
     </span>
     ）
    </p>
    <h3 id="2%E3%80%81%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E6%B3%95">
     <span style="color:#ad720d;">
      2、基本路径测试法
     </span>
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E7%8B%AC%E7%AB%8B%E8%B7%AF%E5%BE%84">
     <span style="color:#ad720d;">
      （1）独立路径
     </span>
    </h4>
    <p>
     独立路径是指包括一组以前没有处理的的语句或条件的一条路径。
    </p>
    <p>
     从控制流图来看，一条独立路径是至少包含一条在其他独立路径中
     <span style="color:#e6b223;">
      <strong>
       从未有过的边
      </strong>
     </span>
     的路径。
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE">
     <span style="color:#ad720d;">
      （2）程序控制流图
     </span>
    </h4>
    <p>
     <span style="color:#ad720d;">
      <strong>
       1）程序控制流图的定义
      </strong>
     </span>
    </p>
    <p>
     控制流程图是描述
     <span style="color:#e6b223;">
      <strong>
       程序控制流
      </strong>
     </span>
     的一种图示方式。
     <span style="color:#e6b223;">
      <strong>
       （有向图）
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       2）控制流图的两种图形符号
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <p>
       图中的每一个圆圈称为流图的结点，表示一个或多个无分支的语句或源程序语句。
      </p>
     </li>
     <li>
      <p>
       流图中的箭头称为边或连接，表示控制流线。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#ad720d;">
      <strong>
       3）程序控制流图的5种基本结构
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="574" src="https://i-blog.csdnimg.cn/blog_migrate/ce981f594a8061e261379e98044e6da3.png" width="1133"/>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       4）程序控制流图的描述
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <p>
       程序控制流图实际上可以看作是一种简化了的程序流程图。
      </p>
     </li>
     <li>
      <p>
       在控制流图中，
       <span style="color:#e6b223;">
        <strong>
         只关注程序的流程，不关心各个处理框的细节
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       因此，原来程序流程图中的各个
       <span style="color:#e6b223;">
        <strong>
         处理框（包括语句框、判断框、输入/输出框等）
        </strong>
       </span>
       <span style="color:#ffd900;">
        <strong>
         <em>
          都被简化为
         </em>
        </strong>
       </span>
       <span style="color:#e6b223;">
        <strong>
         结点
        </strong>
       </span>
       ，一般用
       <span style="color:#e6b223;">
        <strong>
         圆圈
        </strong>
       </span>
       表示，而原来程序流程图中的
       <span style="color:#e6b223;">
        <strong>
         带有箭头的控制流
        </strong>
       </span>
       变成了控制流图中的
       <span style="color:#e6b223;">
        <strong>
         有向边
        </strong>
       </span>
       。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#ad720d;">
      <strong>
       5）举个栗子
      </strong>
      🌰
     </span>
    </p>
    <p>
     下图是典型的程序流程图转换为相对应的流图。对（a）图所示的程序流程图进行简化，得到（b）图所示的流图。
    </p>
    <p>
     <img alt="" height="616" src="https://i-blog.csdnimg.cn/blog_migrate/ea7a3cc93cc57190931075e872ed9935.png" width="945"/>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       6）注意事项
      </strong>
     </span>
    </p>
    <p>
     在将程序流程图简化成控制流图时，应注意如下几点：
    </p>
    <ul>
     <li>
      <p>
       一组顺序结构可以映射为一个
       <span style="color:#e6b223;">
        <strong>
         单一的结点
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       在选择多分支结构中分支的汇集处时，即使没有执行语句也应该添加一个
       <span style="color:#e6b223;">
        <strong>
         汇聚结点
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       边和结点圈定的范围叫做
       <span style="color:#e6b223;">
        <strong>
         区域
        </strong>
       </span>
       ，当对区域计数时，
       <span style="color:#e6b223;">
        <strong>
         图形外的区域也应记为一个区域（开放区域）
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       如果判断中的条件表达式是由多个逻辑运算符（OR，AND…）连接的复合条件表达式，则
       <span style="color:#e6b223;">
        <strong>
         需要改为一系列只有单个条件的嵌套的判断
        </strong>
       </span>
       。
      </p>
     </li>
    </ul>
    <h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6">
     <span style="color:#ad720d;">
      （3）软件复杂度
     </span>
    </h4>
    <ul>
     <li>
      <p>
       <span style="color:#e6b223;">
        <strong>
         软件复杂度
        </strong>
       </span>
       是指理解和处理软件的难易程度。
      </p>
     </li>
     <li>
      <p>
       <span style="color:#e6b223;">
        <strong>
         程序复杂度是软件度量的重要组成部分
        </strong>
        。
       </span>
      </p>
     </li>
     <li>
      <p>
       <span style="color:#e6b223;">
        <strong>
         度量方法：
        </strong>
       </span>
       <code>
        McCabe
       </code>
       度量法（环路度量）
      </p>
     </li>
    </ul>
    <h4 id="%EF%BC%884%EF%BC%89%E7%A8%8B%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6">
     <span style="color:#ad720d;">
      （4）程序复杂度
     </span>
    </h4>
    <p>
     环路复杂度又称为
     <span style="color:#e6b223;">
      <strong>
       圈复杂度
      </strong>
     </span>
     ，是一种为
     <span style="color:#e6b223;">
      <strong>
       程序逻辑复杂度
      </strong>
     </span>
     提供定量尺度的软件度量。它可以提供程序基本路径集的
     <span style="color:#e6b223;">
      <strong>
       独立路径数量
      </strong>
     </span>
     ，这是确保所有语句至少执行一次的过程所必须的
     <span style="color:#e6b223;">
      <strong>
       最少测试用例数
      </strong>
     </span>
     。常用于
     <span style="color:#e6b223;">
      <strong>
       基本路径测试法
      </strong>
     </span>
     。
    </p>
    <h4 id="%EF%BC%885%EF%BC%89%E7%8E%AF%E8%B7%AF%E5%A4%8D%E6%9D%82%E5%BA%A6">
     <span style="color:#ad720d;">
      （5）环路复杂度
     </span>
    </h4>
    <p>
     <code>
      McCabe
     </code>
     复杂性度量方式有如下三种：
    </p>
    <p>
     ⭐️⭐️⭐️
    </p>
    <p>
     <img alt="" height="145" src="https://i-blog.csdnimg.cn/blog_migrate/baaa861fa785f7ddef5c30dd4f89ddb2.png" width="323"/>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       1）通过控制流图的区域个数来计算
      </strong>
     </span>
    </p>
    <p>
     公式：
     <code>
      V(G)＝区域数
     </code>
    </p>
    <p>
     程序的环路复杂性为控制流图的区域数（即封闭的区域数+1）。
    </p>
    <p>
     在下图中可以看到，有
     <code>
      1
     </code>
     和
     <code>
      2
     </code>
     两个封闭区域，因此，环路复杂度V(G)＝2 + 1 = 3。
    </p>
    <p>
     （２个封闭的区域＋１个开放区域）
    </p>
    <p>
     <img alt="" height="579" src="https://i-blog.csdnimg.cn/blog_migrate/8701948efdb713122426806c27b39e8e.png" width="1089"/>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       2）通过控制流图的边数和结点数来计算
      </strong>
     </span>
    </p>
    <p>
     公式：
     <code>
      V(G) = e - n + 2
     </code>
    </p>
    <p>
     其中，
     <code>
      e
     </code>
     即
     <code>
      edge
     </code>
     ，表示图中
     <span style="color:#e6b223;">
      <strong>
       边的数目
      </strong>
     </span>
     ；
     <code>
      n
     </code>
     即
     <code>
      node
     </code>
     ，表示
     <span style="color:#e6b223;">
      <strong>
       结点个数
      </strong>
     </span>
     。
    </p>
    <p>
     下图中V(G)= e - n + 2 = ７条边 − ６个结点 + 2 = 3。
    </p>
    <p>
     因此，环路复杂度V(G)＝３。
    </p>
    <p>
     <img alt="" height="596" src="https://i-blog.csdnimg.cn/blog_migrate/85bfdd7970faf817e3998da90bdafbcf.png" width="1110"/>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       3）通过控制流图中的判定结点个数来计算
      </strong>
     </span>
    </p>
    <p>
     公式：
     <code>
      V(G) = P + 1
     </code>
    </p>
    <p>
     其中，P表示判定结点的数目。所谓判定节点数，即有多个分支的节点，比如下图中的节点
     <code>
      2
     </code>
     ，它可以走3或者5，这个时候它就需要做判断了。所以，
     <code>
      2
     </code>
     是一个判定节点。同样地，下面的 节点
     <code>
      3
     </code>
     也像节点
     <code>
      2
     </code>
     一样分析。
    </p>
    <p>
     因此，图中V(G)=２个判定结点＋1 = 3，所以环路复杂度为３。
    </p>
    <p>
     <img alt="" height="614" src="https://i-blog.csdnimg.cn/blog_migrate/9af5faeedc847c371a17644ef2c2c3ab.png" width="1118"/>
    </p>
    <p>
     讲到这里，我们来给
     <span style="color:#e6b223;">
      <strong>
       环路复杂性
      </strong>
     </span>
     做个小结。事实上，程序的环路复杂性给出了程序基本路径
     <span style="color:#e6b223;">
      <strong>
       集中的独立路径条数
      </strong>
     </span>
     ，这是确保可执行语句
     <span style="color:#e6b223;">
      <strong>
       至少执行一次
      </strong>
     </span>
     所必需的测试用例数目的上界。
    </p>
    <p>
     通过对以上三个例子的了解，相信大家对环路复杂度的三种求解方式有了一个新的认识。有了上面一系列内容的铺垫，我们来开始讲解
     <span style="color:#e6b223;">
      <strong>
       基本路径测试法
      </strong>
     </span>
     。
    </p>
    <h4 id="%EF%BC%886%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E6%B3%95">
     <span style="color:#ad720d;">
      （6）基本路径测试法
     </span>
    </h4>
    <p>
     <span style="color:#ad720d;">
      <strong>
       1）基本路径测试法是什么
      </strong>
     </span>
    </p>
    <p>
     路径测试就是从
     <span style="color:#e6b223;">
      <strong>
       一个程序的入口
      </strong>
     </span>
     开始，执行所经历的各个语句的完整过程。
     <span style="color:#e6b223;">
      <strong>
       从广义的角度讲
      </strong>
     </span>
     ，任何有关路径分析的测试都可以被称为
     <span style="color:#e6b223;">
      <strong>
       路径测试
      </strong>
     </span>
     。
    </p>
    <p>
     完成路径测试的理想情况就是做到
     <span style="color:#e6b223;">
      <strong>
       路径覆盖
      </strong>
     </span>
     ，但对于复杂性较大的程序要做到所有的路径覆盖（测试所有可执行路径）是不可能的。
    </p>
    <p>
     在不能做到所有路径覆盖的情况下，如果某一程序的
     <span style="color:#e6b223;">
      <strong>
       每一个独立路径
      </strong>
     </span>
     都被执行到，那么就可以认为程序中的每个语句都已经检验过了，即达到了
     <span style="color:#e6b223;">
      <strong>
       语句覆盖
      </strong>
     </span>
     。这种测试方法就是通常所说的
     <span style="color:#e6b223;">
      <strong>
       基路径测试法
      </strong>
     </span>
     。
    </p>
    <p>
     基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径的集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       2）基本路径测试法的4个步骤
      </strong>
     </span>
    </p>
    <p>
     基本路径测试法包括以下4个步骤：
    </p>
    <ul>
     <li>
      <p>
       以
       <span style="color:#e6b223;">
        <strong>
         详细设计
        </strong>
       </span>
       或
       <span style="color:#e6b223;">
        <strong>
         源代码
        </strong>
       </span>
       作为基础，绘制程序的
       <span style="color:#e6b223;">
        <strong>
         控制流图
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       计算得到的控制流图G的
       <span style="color:#e6b223;">
        <strong>
         环路复杂性V（G）
        </strong>
       </span>
       。
      </p>
     </li>
     <li>
      <p>
       <span style="color:#e6b223;">
        <strong>
         确定独立路径的集合
        </strong>
       </span>
       。通过程序控制流图导出基本路径集，列出程序的独立路径。所谓独立路径，是指至少包含一条新边的路径，也就是包含一些前面的路径未包含的语句，当所有的语句都包含了，基路径集就够了。
       <span style="color:#e6b223;">
        <strong>
         （线性无关路径）
        </strong>
       </span>
      </p>
     </li>
     <li>
      <p>
       <span style="color:#e6b223;">
        <strong>
         设计测试用例
        </strong>
       </span>
       ，确保基本路径集中每条路径的执行。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#ad720d;">
      <strong>
       3）例子阐述1
      </strong>
     </span>
     <span style="color:#e6b223;">
      🌰
     </span>
    </p>
    <p>
     依据以下代码，用基本路径测试法，设计该程序的测试用例。
    </p>
    <pre><code class="language-java">if(a&gt;8 &amp;&amp; b&gt;10)   //1,2
    m=m+1;       //3
if(a=10 || c&gt;5)  //4,5
   m=m+5;       //6</code></pre>
    <pre><span style="color:#ad720d;"><strong>解答：</strong></span></pre>
    <p>
     <strong>
      ①绘制程序控制流图，如下图所示。
     </strong>
    </p>
    <p>
     <img alt="" height="658" src="https://i-blog.csdnimg.cn/blog_migrate/b7543b3333b36a4bcf6addce4ddf6816.png" width="943"/>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       ②计算环路复杂度
      </strong>
     </span>
    </p>
    <p>
     V(G)=4（3个封闭区域+1个开放区域）
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       ③确定线性无关路径：
      </strong>
     </span>
    </p>
    <p>
     路径1：
     <code>
      1、4、6
     </code>
    </p>
    <p>
     路径2：
     <code>
      1、4、5、6
     </code>
    </p>
    <p>
     路径3：
     <code>
      1、2、4、5、6
     </code>
    </p>
    <p>
     路径4：
     <code>
      1、2、3、4、5、6
     </code>
    </p>
    <p>
     <span style="color:#ad720d;">
      <strong>
       ④设计测试用例
      </strong>
     </span>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         编号
        </strong>
       </th>
       <th>
        <strong>
         输入数据
        </strong>
       </th>
       <th>
        <strong>
         预期输出
        </strong>
       </th>
       <th>
        <strong>
         覆盖路径
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1
       </td>
       <td>
        a=2,b=3,c=4
       </td>
       <td>
        m=0
       </td>
       <td>
        1、4、6
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        a=2,b=3,c=8
       </td>
       <td>
        m=5
       </td>
       <td>
        1、4、5、6
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        a=10,b=6,c=8
       </td>
       <td>
        m=5
       </td>
       <td>
        1、2、4、5、6
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        a=10,b=15,c=8
       </td>
       <td>
        m=6
       </td>
       <td>
        1、2、3、4、5、6
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <span style="color:#ad720d;">
      <strong>
       4）例子阐述2
      </strong>
      🌰
     </span>
    </p>
    <p>
     依据以下代码，用基本路径测试法，设计该程序的测试用例。
    </p>
    <pre><code class="language-java">class Test{
    static void permute_args(int panonopt_start, int panonopt_end, int opt_eng, int ncycle){
        int cstart, cycle, i, j, nnonopts, nopts, pos; //1
    
        nnonopts = panonopt_end - panonopt_start;
        nopts = opt_end - panonopt_end;
        cyclelen = (opt_end - panonopt_start)/ncycle;
    
        for(i = 0; i &lt; ncycle; i++){ //2
            cstart = panonopt_end + i; //3
            pos = cstart;
            for(j = 0; j &lt; cyclelen; j++){ //4
                if(pos &gt;= panonopt_end){ //5
                    pos -= nnonopts; //6
                }else{
                    pos += nopts; //7
                }
            }
        }
    } //8
}</code></pre>
    <p>
     【问题1】请针对上述java程序给出满足100%DC（判定覆盖）所需的逻辑条件。
    </p>
    <p>
     【问题2】请画出上述程序的控制流图，并计算其控制流图的环路复杂度V(G)。
    </p>
    <p>
     【问题3】请给出问题2种控制流图的线性无关路径。
    </p>
    <p>
     <strong>
      解答：
     </strong>
    </p>
    <p>
     <strong>
      【问题1】
     </strong>
    </p>
    <p>
     满足100%判定的逻辑条件为：
    </p>
    <pre><code class="language-java">i&lt;ncycle;
i&gt;=ncycle;
j&lt;cyclelen;
j&gt;=yclelen;
pos&gt;=panonopt_end;
pos&lt;panonopt_end; </code></pre>
    <p>
     <strong>
      【问题2】
     </strong>
    </p>
    <p>
     控制流图如下图所示，V(G)=4。
    </p>
    <p>
     <img alt="" height="647" src="https://i-blog.csdnimg.cn/blog_migrate/cb15cef7bacfead4303762c0c49375cf.png" width="948"/>
    </p>
    <p>
     <strong>
      【问题3】
     </strong>
    </p>
    <p>
     线性无关路径：
    </p>
    <p>
     路径1：
     <code>
      1、2、8
     </code>
    </p>
    <p>
     路径2：
     <code>
      1、2、3、4、2…
     </code>
    </p>
    <p>
     路径3：
     <code>
      1、2、3、4、5、6、4…
     </code>
    </p>
    <p>
     路径4：
     <code>
      1、2、3、4、5、7、4…
     </code>
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">
     <span style="color:#ad720d;">
      四、写在最后
     </span>
    </h2>
    <p>
     对于软件测试中的白盒测试来说，主要需要了解白盒测试的基本概念，静态和动态白盒测试的方法，内容较黑盒测试来说逻辑性会更强一些。同时，值得注意的是，在动态测试中的基本路径测试法中，线性无关路径的识别要尤为小心，在计算过程中很容易出现多写的问题。因此，在此基础上，大家可以再多找几道相关的题目进行练习，举一反三。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34323934343539342f:61727469636c652f64657461696c732f313231393037353430" class_="artid" style="display:none">
 </p>
</div>


