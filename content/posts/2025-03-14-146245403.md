---
layout: post
title: "2024年第十五届蓝桥杯软件CC大学A组五子棋对弈"
date: 2025-03-14 00:03:39 +0800
description: "2024年第十五届蓝桥杯软件C/C++大学A组——五子棋对弈、蓝桥杯"
keywords: "2024年第十五届蓝桥杯软件C/C++大学A组——五子棋对弈"
categories: ['Bridge', 'Blue']
tags: ['蓝桥杯', 'C', 'C']
artid: "146245403"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146245403
    alt: "2024年第十五届蓝桥杯软件CC大学A组五子棋对弈"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146245403
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146245403
cover: https://bing.ee123.net/img/rand?artid=146245403
image: https://bing.ee123.net/img/rand?artid=146245403
img: https://bing.ee123.net/img/rand?artid=146245403
---

# 2024年第十五届蓝桥杯软件C/C++大学A组——五子棋对弈

## 蓝桥杯原题：

![](https://i-blog.csdnimg.cn/direct/e96a6d5024994d73806ee92669e1d9ef.png)

## 题目描述：

“在五子棋的对弈中，友谊的小船说翻就翻？ ” 不！对小蓝和小桥来说，五子棋不仅是棋盘上的较量，更是心与心之间的沟通。这两位挚友秉承着 “
友谊第一，比赛第二” 的宗旨，决定在一块 5 × 5 的棋盘上，用黑白两色的棋子来决出胜负。但他们又都不忍心让对方失落，于是决定用一场和棋（平局）
作为彼此友谊的见证。  
比赛遵循以下规则：  
1\. 棋盘规模 ：比赛在一个 5 × 5 的方格棋盘上进行，共有 25 个格子供下棋使用。  
2\. 棋子类型 ：两种棋子，黑棋与白棋，代表双方。小蓝持白棋，小桥持黑棋。  
3\. 先手规则 ：白棋（小蓝）具有先手优势，即在棋盘空白时率先落子（下棋）。  
4\. 轮流落子 ：玩家们交替在棋盘上放置各自的棋子，每次仅放置一枚。  
5\. 胜利条件 ：率先在横线、竖线或斜线上形成连续的五个同色棋子的一方获胜。  
6\. 平局条件 ：当所有 25 个棋盘格都被下满棋子，而未决出胜负时，游戏以平局告终。  
在这一设定下，小蓝和小桥想知道，有多少种不同的棋局情况（终局不同看成不同情况，终局相同而落子顺序不同看成同一种情况），既确保棋盘下满又保证比赛结果为平局。  
答案提交：  
这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

**答案是3126376**

这个问题细节问题比较多，容易绕进去

首先用序号表示棋子坐标

  * int x = n / 5;
  * int y = n % 5;
  * a[x][y] = c;

其次这里是白棋先手，很容易造成干扰，第一不知道如何下手。第二认为结果是黑白色对称的，找出一种结果，结果直接乘2，但其实是错误的，因为白色先手，就决定了黑白结果不是对称的。

对第一个问题在这里**我们不要想着第一步怎么走，下一步怎么走** 。

我认为我们直接全部遍历，就相当于，对着填满25棵棋子的棋盘一格一格进行判断，找出平局而已。

还有在写代码时，注意控制代码的边界，边界大小控制不对，结果可能就相差很远。

代码如下：

    
    
    #include<bits/stdc++.h>
    using namespace std;
    
    int a[10][10];//棋盘
    int ret = 0;
    void find(int w, int b, int n, int c)//白棋数、黑棋数、序号、颜色
    {
    	//此时结果已出
    	if (w >= 14 || b >= 13 || n >= 25)return;
    	//序号转换成坐标
    	int x = n / 5;
    	int y = n % 5;
    	a[x][y] = c;
    
    	if (y == 4)//横向最后一个子已落，判断横向是否为5子同色，每一行都会判断
    	{
    		bool color = 0;
    		for (int i = 0; i < 5; i++)
    		{
    			if (a[x][i] != a[x][0]) color = 1;
    		}
    		if (color==0)return;
    	}
    
    	if (x == 4)//纵向最后一个子已落，判断纵向是否为5子同色，每一列都会判断
    	{
    		bool color = 0;
    		for (int i = 0; i < 5; i++)
    		{
    			if (a[i][y] != a[0][y]) color = 1;
    		}
    		if (color == 0)return;
    	}
    
    	if (n == 20)//判断第一条对角线是否为5子同色，当id=20时，第一条对角线填满
    	{
    		bool color = 0;
    		for (int i = 0; i < 5; i++)
    		{
    			if (a[i][4 - i] != a[4][0]) color = 1;
    		}
    		if (color == 0)return;
    	}
    
    	if (n == 24)//判断第二条对角线是否为5子同色，当id=25时，第二条对角线填满
    	{
    		bool color = 0;
    		for (int i = 0; i < 5; i++)
    		{
    			if (a[i][ i] != a[4][4]) color = 1;
    		}
    		if (color == 0)return;
    	}
    
    	if(n == 24) //最后一个子
    	{
    		ret++;
    		return;
    	}
    	if (n != 24)//没有到最后一个子，就继续遍历
    	{
    		find(w + 1, b, n + 1, 1);//下一步为白
    		x = (n + 1) / 5, y = (n + 1) % 5;
    		a[x][y] = 0;//撤销白棋
    
    		find(w , b+1, n + 1, 2);//下一步为黑
    		x = (n + 1) / 5, y = (n + 1) % 5;
    		a[x][y] = 0;
    	}
    }
    
    
    int main()
    {
    	find(1, 0, 0, 1);//枚举第一个格子放白棋的所有情况,注意这里不是落棋的第一步！！！只是在所有棋子都落下后遍历平局的情景
    	find(0, 1, 0, 2);//枚举第一个格子放黑棋的所有情况，最后结果不能直接用2倍的第一个白棋的结果，因为白棋是先手这里白棋和黑棋并不是对称的
    	cout << ret;
    	return 0;
    }

![](https://i-blog.csdnimg.cn/direct/65ef223d5d5c4d618bad96ed05403a63.jpeg)

少年没有乌托邦，心向远方自明朗！

如果这个博客对你有帮助，给博主一个免费的点赞就是最大的帮助❤  
欢迎各位点赞，收藏和关注哦❤  
如果有疑问或有不同见解，欢迎在评论区留言❤  
后续会继续更新**大连理工大学** 相关课程和有关**蓝桥杯** 的内容和示例  
点赞加关注，学习不迷路，好，本次的学习就到这里啦！！！

ok，我们下次再见！



