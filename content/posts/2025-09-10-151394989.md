---
layout: post
title: "0基础Java学习过程记录枚举注解"
date: 2025-09-10T23:49:58+0800
description: "本文主要介绍了Java中枚举和注解的基本概念及使用方法。 一、枚举部分： 枚举是包含有限特定对象的特殊类，可通过自定义类或enum关键字实现 自定义类实现枚举时需私有化构造器、内部创建对象并对外暴露 enum关键字简化了枚举实现，自动继承Enum类 介绍了name()、ordinal()、values()等enum常用方法 二、注解部分： 注解是用于修饰程序元素的元数据，不影响程序逻辑但可被编译运行 详细介绍了@Override、@Deprecated、@SuppressWarnings三种基本注解的用法 "
keywords: "0基础Java学习过程记录——枚举、注解"
categories: ['未分类']
tags: ['学习', '初学', 'Java']
artid: "151394989"
arturl: "https://blog.csdn.net/2301_79577376/article/details/151394989"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151394989
    alt: "0基础Java学习过程记录枚举注解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151394989
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151394989
cover: https://bing.ee123.net/img/rand?artid=151394989
image: https://bing.ee123.net/img/rand?artid=151394989
img: https://bing.ee123.net/img/rand?artid=151394989
---



# 0基础Java学习过程记录——枚举、注解



## 一、枚举

### 1.基本介绍

（1）枚举对应英文 enumeration，简写为 enum

（2）枚举是一组常量的集合

（3）可以理解为：枚举属于一种特殊的类，里面只包含一组有限的特定的对象

### 2.实现方式

#### （1）自定义类实现枚举

##### 1）步骤

1.不需要提供setXxx方法，因为枚举对象的值通常为只读

2.对枚举对象/属性使用 final+static共同修饰，实现底层优化

3.枚举对象名通常使用全部大写，遵循敞亮的命名规范

4.枚举对象根据需要也可以有多个属性

```

package com.figiting.enum_;

/**
 * @version 1.0
 * @autor 疯小丢
 */
public class Enumeration01 {
    public static void main(String[] args) {
        System.out.println(Season.SPRING);
        System.out.println(Season.SUMMER);
        System.out.println(Season.AUTUMN);
        System.out.println(Season.WINNER);

    }
}


class Season{
    private String name;
    private String desc;

    //定义了四个对象
    public static final Season SPRING = new Season("春天","温暖");
    public static final Season SUMMER = new Season("夏天","炎热");
    public static final Season AUTUMN = new Season("秋天","凉爽");
    public static final Season WINNER = new Season("冬天","寒冷");

    //1.构造器私有化，防止直接new
    //3.在Season内部，直接创建固定对象
    //4.优化，可以加入final修饰符
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    //2.去掉set相关方法，只读不修改，防止属性被修改
    /*public void setName(String name) {
        this.name = name;
    }*/

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }

    /*public void setDesc(String desc) {
        this.desc = desc;
    }*/
}

```

##### 2）特点

1.构造器私有化

2.本类内部创建一组对象

3.对外暴露对象（通过为对象添加public final static修饰符）

4.可以提供get方法，但是不要提供set

#### （2）使用enum关键字

```

package com.figiting.enum_;

/**
 * @version 1.0
 * @autor 疯小丢
 */
public class Enumeration02 {
    public static void main(String[] args) {
        //使用Season2枚举类演示方法
        Season2 autumn = Season2.AUTUMN;
        //输出枚举对象的名称
        System.out.println(autumn.name());
        //输出该枚举对象的次序/编号，从0开始编号
        System.out.println(autumn.ordinal());
        //values()返回枚举对象，Season[]
        Season2[] values = Season2.values();
        for(Season2 season : values){//增强for循环
            //依次从数组中取出
            System.out.println(season);
        }

        //valueOf():将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常
        //执行流程
        //1.根据输入的“AUTUMN"到Season2的枚举对象去查找
        //2.如果找到了就返回，没有就报错
        Season2 autumn1 = Season2.valueOf("AUTUMN");
        System.out.println("autumn1=" + autumn1);
        System.out.println(autumn == autumn1);

        //compareTo:比较两个枚举常量，比较的就是编号
        //1.把Season2.AUTUMN枚举对象的编号和Season2.SPRING枚举对象的编号进行比较
        //2.结果  两编号相减
        System.out.println(Season2.AUTUMN.compareTo(Season2.SPRING));
    }
}


enum Season2{
    //1.使用关键字eum来实现枚举类
    //2.public static final Season SPRING = new Season("春天","温暖");
    // SPRING("春天","温暖");即常量名(实参列表)
    //3.如果有多个常量(对象).使用,号间隔即可
    //4.如果使用enum实现枚举，要求将定义常量对象写在前面,枚举对象必须放在枚举类的行首
    //5.如果使用的是无参构造器创建常量对象则可以使用What,可以省略()


    SPRING("春天","温暖"),
    AUTUMN("秋天","凉爽");
    //SUMMER("夏天","炎热"), What();//调用无参构造器，或What
    private String name;
    private String desc;

    //定义了四个对象
/*  public static final Season SPRING = new Season("春天","温暖");
    public static final Season SUMMER = new Season("夏天","炎热");
    public static final Season AUTUMN = new Season("秋天","凉爽");
    public static final Season WINNER = new Season("冬天","寒冷");*/

    private Season2() {
    }

    private Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    //2.去掉set相关方法，只读不修改，防止属性被修改
    /*public void setName(String name) {
        this.name = name;
    }*/

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }

    /*public void setDesc(String desc) {
        this.desc = desc;
    }*/
}


```

##### 1）说明

1.当使用enum关键字开发一个枚举类时，默认会继承Enum类

![](https://i-blog.csdnimg.cn/direct/6e611c6ca1174ddcb2c85b1eda3bcd07.png)

2.将传统的

public static final Season SPRING = new Season("春天","温暖");  简化成

SPRING("春天","温暖");  这里必须知道调用的是哪个构造器

3.如果使用无参构造器创建枚举对象时，则实参列表和小括号都可以省略

4.当有多个枚举对象时，使用，号间隔，最后一个分号结尾

5.枚举对象必须放在枚举类的行首

2）enum常用方法的使用

1.toString：Enum类已经重写过，返回的是当前对象名，子类可以重写该方法，用于返回对象的属性信息

2.name：返回当前对象名（常量名），子类中不能重写

3.ordinal：返回当前对象的位置号，默认从0开始

4.values：返回当前枚举类中所有的常量

5.valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常

6.compareTo：比较两个枚举常量，比较的是编号

```

public class Enumeration02 {
    public static void main(String[] args) {
        //使用Season2枚举类演示方法
        Season2 autumn = Season2.AUTUMN;
        //输出枚举对象的名称
        System.out.println(autumn.name());
        //输出该枚举对象的次序/编号，从0开始编号
        System.out.println(autumn.ordinal());
        //values()返回枚举对象，Season[]
        Season2[] values = Season2.values();
        for(Season2 season : values){//增强for循环
            //依次从数组中取出
            System.out.println(season);
        }

        //valueOf():将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常
        //执行流程
        //1.根据输入的“AUTUMN"到Season2的枚举对象去查找
        //2.如果找到了就返回，没有就报错
        Season2 autumn1 = Season2.valueOf("AUTUMN");
        System.out.println("autumn1=" + autumn1);
        System.out.println(autumn == autumn1);

        //compareTo:比较两个枚举常量，比较的就是编号
        //1.把Season2.AUTUMN枚举对象的编号和Season2.SPRING枚举对象的编号进行比较
        //2.结果  两编号相减
        System.out.println(Season2.AUTUMN.compareTo(Season2.SPRING));
    }
}

```

### 3.使用细节

（1）使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum，而Java是单继承机制

（2）枚举类和普通类一样，可以实现接口，形式如下：

enum 类名 implements 接口1，接口2{}

```

package com.figiting.enum_;

/**
 * @version 1.0
 * @autor 疯小丢
 */
public class EnumDetail {
    public static void main(String[] args) {
        Music.CLASSICMUSIC.playing();
    }
}

class A {

}
//1.使用enum关键字后就不能再继承其它类，因为enum会隐式继承Enum，而Java是单继承机制
//enum Season3 extends A {
//
//}
//2.enum实现的枚举类仍然是一个类，所以还是可以实现接口
interface  IPlaying {
    public  void playing();
}

enum Music implements IPlaying {
    CLASSICMUSIC;
    public void playing(){
        System.out.println("播放好听的音乐...");
    }
}

```

## 二、注解

### 1.初步理解

（1）注解（Annotation）也被称为元数据（Metadata），用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息

（2）和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息

（3）在JavaSE中，注解的使用目的比较简单，例如标记过的时的功能，忽略警告等，在JavaEE中注解占据更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等

### 2.基本介绍

使用Annotation时要在其前面增加 @符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素

### 3.基本的Annotation应用案例

#### （1）@Override

限定某个方法，重写父类方法，该注解只能用于方法

##### 使用说明：

```

package com.figiting.annotation_;

/**
 * @version 1.0
 * @autor 疯小丢
 */
public class Override {
    public static void main(String[] args) {

    }
}

class Father{
    public void fly() {
        System.out.println("Father fly...");
    }
}

class Son extends Father{
    //1. @Override注解放在fly方法上，表示子类fly方法重写了父类的fly
    //2. 这里如果没有写@Override，还是重写了父类的fly
    //3. 如果写了，编译器就会检查该方法是否真的重写了父类的方法
    //如果重写了则编译通过，如果没有构成重写，则编译错误
    //即进行语法校验
    //4.@Override定义，@interface表示注解类
    //public @interface Override {
    //}
    @java.lang.Override
    public void fly() {
        System.out.println("Son fly...");
    }
}

```

1）@Override 表示制定重写父类的方法，如果父类没有fly方法，则不会报错

2）如果不写@Override注解，而父类仍有public void fly（）{}，仍然构成重写

3）如果写了，编译器就会检查该方法是否真的重写了父类的方法，如果重写了则编译通过，如果没有构成重写，则编译错误。即进行语法检验

4）@Override只能修饰方法，不能修饰其他类，包，属性等

5）注解源码：

![](https://i-blog.csdnimg.cn/direct/011164698e004566a3f5be681c5fa4bb.png)

#### （2）@Deprecated

用于表示某个程序元素（类，方法等）已过时

```

package com.figiting.annotation_;

/**
 * @version 1.0
 * @autor 疯小丢
 */
public class Deprecated_ {
    public static void main(String[] args) {
        A a = new A();
        a.hi();
        System.out.println(a.n1);
    }
}

//1.@Deprecated 修饰某个元素，表示该元素已经过时
//2.即不再推荐使用，但是仍然可以使用
//3.@Deprecated类的源码
//4.可以修饰方法、类、字段、包、参数等
//5.可以做版本升级过度使用
@Deprecated
class A {
    public int n1 = 10;
    public void hi(){

    }
}
```

注解源码：

![](https://i-blog.csdnimg.cn/direct/cd6cee98d6c4468faa0a876476023d55.png)

#### （3）@SuppressWarnings

抑制编译器警告

```

package com.figiting.annotation_;

import java.util.ArrayList;
import java.util.List;

/**
 * @version 1.0
 * @autor 疯小丢
 */
public class SuppressWarnings_ {
    //1.当我们不希望看到这些警告时，可以使用SuppressWarnings注解来抑制警告信息
    //2.在{"all"}中，可以写入希望抑制(不显示)的警告信息
    //3
    //4.关于SuppressWarnings作用范围和放置的位置有关
    //比如@SuppressWarnings放置在main方法，则抑制警告范围就是main
    //5.源码
    //(1)放置的位置就是 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE
    //(2)该注解类有数组String[] value();设置一个数组,比如{"rawtypes","unchecked","unused"}
    @SuppressWarnings({"rawtypes","unchecked","unused"})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("");
        list.add("");
        list.add("");
        int i;
        System.out.println(list.get(1));
    }
}

```

##### 可以指定的警告类型

1.all，抑制所有警告

2.cast，抑制与强制转型作业相关的警告

3.dep-ann，抑制与淘汰注释相关的警告

4.deprecation，抑制与淘汰相关警告

5.fallthrough，抑制与switch陈述式中遗漏break相关的警告

6.finally，抑制与未传回finally区块相关的警告

7.hiding，抑制2与隐藏变数的区域变数相关的警告

8.incomplete-switch，抑制与switch陈述式（enum case）中遗漏项目相关的警告

9.javadoc，抑制与javadoc相关的警告

10.nls，抑制与非nls字串文字相关的警告

11.rawtypes，抑制与使用raw类型相关的警告

12.resource，抑制与使用Closeable类型的资源相关的警告

13.restriction，抑制与使用不建议或禁止参照相关的警告

14.serial，抑制与可序化的类别遗漏serialVersionUID栏位相关的警告

15.static-access，抑制与静态存取不正确相关的1警告

16.static-method，抑制与可宣告为static的方法相关的警告

17.super，抑制与置换方法相关但不含super呼叫的警告

18.synthetic-access，抑制与内部类别的存取未最佳化相关的警告

19.sync-override，抑制因为置换同步方法而遗漏同步化的警告

20.unchecked，抑制与未检查的作业相关的警告

21.unqualified-field-access，抑制与栏位存取不合格相关的警告

22.unused，抑制与未用的程式码及停用的程式码相关的警告

生成@SupperssWarnings时直接点击左侧的黄色提示就可以选择，注意可以指定生成的位置

### 4.元注解

#### （1）基本介绍

JDK的元注解用于修饰其他Annotation

元注解本身作用不大，但要清楚它是干什么的

#### （2）种类

##### 1）@Retention 注解

###### 1.说明

只能用于修饰一个Annotation定义，用于指定该Annotation 可以保留多长时间，  
@Rentention包含一个RetentionPolicy类型的成员变量，使用@Rentention  
时必须为该value成员变量指定值

###### 2.@Retention的三种值

1)RetentionPolicy.SOURCE:编译器使用后，直接丢弃这种策略的注释  
2) RetentionPolicy.CLASS:编译器将把注释记录在class文件中，当运行Java程  
序时，JVM不会保留注解。这是默认值  
3)RetentionPolicy.RUNTIME:编译器将把注释记录在class文件中，当运行  
Java程序时，JVM会保留注释.程序可以通过反射获取该注释

##### 2）@Target

###### 基本说明

用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪  
些程序元素.@Target 也包含一个名为value的成员变量。

##### 3）@Documented

###### 基本说明

@Documented:用于指定被该元 Annotationi修饰的 Annotation类将被  
javadoc 工具提取成文档，即在生成文档时，可以看到该注释。  
说明：定义为Documented的注解必须设置Retention值为RUNTIME。

##### 4）@Inherited

###### 基本说明

被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰  
的Annotation，则其子类将自动具有该注解



