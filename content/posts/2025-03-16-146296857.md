---
layout: post
title: "游戏引擎学习第163天"
date: 2025-03-16 16:25:04 +0800
description: "因为我们的资源处理器并不是游戏的一部分，所以它可以使用库。我说过我不介意让它使用库，而我提到这个的原因是，今天我们确实有一个选择——可以使用库。"
keywords: "游戏引擎学习第163天"
categories: ['游戏引擎学习']
tags: ['游戏引擎', '学习']
artid: "146296857"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296857
    alt: "游戏引擎学习第163天"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296857
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296857
cover: https://bing.ee123.net/img/rand?artid=146296857
image: https://bing.ee123.net/img/rand?artid=146296857
img: https://bing.ee123.net/img/rand?artid=146296857
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     游戏引擎学习第163天
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     我们可以在资源处理器中使用库
    </h2>
    <p>
     因为我们的资源处理器并不是游戏的一部分，所以它可以使用库。我说过我不介意让它使用库，而我提到这个的原因是，今天我们确实有一个选择——可以使用库。
    </p>
    <h2>
     <a id="_Windows__3">
     </a>
     生成字体位图的两种方式：求助于 Windows 或使用库
    </h2>
    <p>
     基本上，我们在资源处理器中有两种方式来实现这一点。一种是直接从Windows获取字体，另一种是使用某种库。
    </p>
    <p>
     最初，我的想法是直接展示如何从Windows获取字体，因为这样非常直接。当你在Windows上运行资源处理器时，你可以直接提取字体，而其他平台如Linux也有类似的API可以用来提取字体，操作起来也非常简单。
    </p>
    <p>
     不过，经过一番思考，尤其是在看到有人提议可以在这里使用库之后，我开始重新考虑这个问题。
    </p>
    <h2>
     <a id="_stb__10">
     </a>
     决定使用 stb 库
    </h2>
    <p>
     如果要使用库的话，会选择哪些库。我总是推荐使用STB库，因为这些库是由Simon Barrett编写的，专门为游戏开发者设计，且非常方便集成到项目中。
    </p>
    <p>
     我的想法是，今天可以通过STB库来展示如何获取字体，顺便教大家如何使用这些库，因为这些库是我推荐的，且它们设计得非常简洁易用。由于之前设定的规则是游戏代码中不使用库，因此在实际的游戏代码中我们不会使用这些库。这个规则虽然有些随意，但也是整个系列的一个原则——游戏的代码要完全由我们从头开始编写。
    </p>
    <p>
     今天的目的是为了回应大家的请求，展示如何使用STB库获取字体，同时也可以在之后介绍如何直接通过Windows来获取字体，如果有人对此有兴趣的话。而且，如果有人想在自己的游戏中使用这个库，现在就可以了解如何操作了。
    </p>
    <p>
     此外，STB库的一个好处是，它们非常易于使用，哪怕是对于那些注重细节的开发者来说，也不会像其他一些库那样带来痛苦和困扰。因此，使用这些库会非常方便，适合各种开发者使用。
    </p>
    <h2>
     <a id="stb__19">
     </a>
     stb 库
    </h2>
    <p>
     如果打算使用STB库，可以按照以下步骤操作：首先，搜索“STB libraries”，就能找到STB的官方网站，网址是
     <code>
      stb
     </code>
     。在这个页面上，提供了很多非常实用的库。
    </p>
    <p>
     其中，STB图像库（stb_image）是一个很棒的选择，能够快速将图像加载功能加入到代码中。这个库只包含一个文件，而且支持多种常见的图像格式，比如JPEG、PNG、BMP和PSD等。它的实现不会按照完整的规范来读取图像，而是只读取游戏开发者通常需要的部分，这样能简化使用的复杂度。
    </p>
    <p>
     如果有人问我如果要用这些库会选择哪些，我会推荐这些库，因为它们非常简洁易用，而且会减少开发过程中的痛苦和困扰。除此之外，STB库是公共领域的，这意味着没有任何使用限制。你可以自由地分发它们，不需要特别的授权或者标注出处。虽然如果使用这些库发布产品时，可以适当感谢一下开发者，但并不是强制要求的。
    </p>
    <p>
     在STB官网上，每个库都有简单的描述，说明它们的用途和功能。总体来说，这些库是非常适合开发者使用的，特别是当需要快速实现某些功能时，STB库可以大大减少开发难度。
    </p>
    <p>
     <a href="https://github.com/nothings/stb">
      https://github.com/nothings/stb
     </a>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/183034e942994dabbae5bac1d2c01669.png#pic_center"/>
    </p>
    <h2>
     <a id="stb_truetype__32">
     </a>
     stb_truetype 库
    </h2>
    <p>
     如果你特别想处理字体相关的内容，特别是想要将字体文件转换为位图格式，应该关注的库是
     <strong>
      stb_truetype
     </strong>
     。这个库正是实现了我们所需要的功能，能够将TrueType字体文件进行栅格化处理，生成适合渲染的位图。它完全符合我们资产处理器的需求，可以准确地将字体转换为我们需要的格式。
    </p>
    <p>
     <strong>
      stb_truetype
     </strong>
     库的功能非常简单明了，专门为处理TrueType字体文件设计，能够轻松地将字体转换为位图，这对于开发过程中需要渲染文字的部分非常有帮助。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3c78c8cebe084e98a7eff59b2959628e.png#pic_center"/>
    </p>
    <h2>
     <a id="stb__39">
     </a>
     stb 库的结构
    </h2>
    <p>
     这些库的结构非常简单明了。每个库都是一个单独的头文件（
     <code>
      .h
     </code>
     文件）。比如
     <strong>
      stb_truetype
     </strong>
     库，它的实现方式很特别。这个库的头文件内部实际上包含了一个预处理指令（
     <code>
      #define
     </code>
     ），用于决定是否包含库的实现部分。
    </p>
    <p>
     具体来说，如果你只需要头文件中的声明部分，可以直接包含这个
     <code>
      .h
     </code>
     文件。如果你还需要实现部分（即
     <code>
      .c
     </code>
     文件的代码），你只需要在包含头文件之前定义一个预处理指令，比如
     <code>
      #define STB_TRUETYPE_IMPLEMENTATION
     </code>
     ，这样编译器就会把实现部分的代码包含进来。如果你没有定义这个预处理指令，库的实现部分就不会被编译进项目中，只有头文件中的声明部分会被编译。
    </p>
    <p>
     也就是说，这个库的实现方式实际上是将头文件和源文件合并为一个文件。你只需要一个文件就可以使用该库，不需要单独的
     <code>
      .h
     </code>
     和
     <code>
      .c
     </code>
     文件。这种方式非常方便，尤其适合简单集成的场景。
    </p>
    <p>
     如果要使用这个库，首先需要从
     <strong>
      stb_truetype
     </strong>
     的官方网站或GitHub页面下载库文件。可以直接获取该文件并将其包含到项目中。虽然可能会遇到一些下载和使用上的小问题，但本质上这是一个非常简单和直接的库，适合快速集成使用。
    </p>
    <h2>
     <a id="_48">
     </a>
     使用库
    </h2>
    <p>
     使用
     <strong>
      stb_truetype
     </strong>
     库的方法其实非常简单，下载也很直接。如果你不是 GitHub 专家，可以点击 “raw” 按钮，然后选择 “另存为” 来保存文件。虽然这不是最推荐的下载方式，但对于一些不熟悉 GitHub 操作的人来说，这种方式仍然是可行的。
    </p>
    <p>
     下载之后，文件就保存到了本地。与其他库不同，
     <strong>
      stb_truetype
     </strong>
     库有一个非常显著的特点，就是它的设计非常简洁合理。它只包含一个文件，这使得它非常易于维护和集成到项目中。所有的代码都集中在一个文件内，不需要多个文件分散管理。这种简单的结构大大减少了整合和管理代码的复杂度。
    </p>
    <p>
     相比于很多其他库，
     <strong>
      stb_truetype
     </strong>
     库的设计思路更符合简洁、高效的编程原则。它的集成非常清晰，可以很容易地嵌入到项目中，且维护起来非常方便。这也是为什么这种库很适合用于个人项目，或者那些追求高效、简单实现的开发者。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1fe1f5cc4d77480c8561ea54e5eba233.png#pic_center"/>
    </p>
    <h2>
     <a id="_58">
     </a>
     库的集成，只有两行代码
    </h2>
    <p>
     如果要在项目中使用
     <strong>
      stb_truetype
     </strong>
     库，我们可以直接在代码中引入库文件，并开始渲染字体。首先，在代码中包含
     <code>
      stb_truetype.h
     </code>
     头文件，接着，我们需要在代码中通过
     <code>
      #define
     </code>
     来启用库的实现部分。通过定义一个宏，告诉编译器我们需要包含实现部分（而不仅仅是头文件），这时代码就会编译通过并且生效。
    </p>
    <p>
     这两行代码的操作非常简单，不需要额外下载大量文件，也不需要配置复杂的构建系统。只需下载一个文件并添加两行代码，便能直接在游戏中实现 TrueType 字体的渲染。相比于其他库需要配置复杂的依赖关系、链接设置以及处理大量编译选项，
     <strong>
      stb_truetype
     </strong>
     库的简洁性是非常突出的。
    </p>
    <p>
     这一点尤为重要，因为它避免了我们在整合库时遇到的麻烦，如链接多个文件或管理依赖项。只需要将一个文件下载到项目中，并进行简单配置，就能轻松使用
     <strong>
      TrueType
     </strong>
     字体渲染库。这种简化的流程非常适合快速开发和小型项目，也使得后续的维护变得更加方便，不必担心额外的复杂依赖或不必要的资源消耗。
    </p>
    <p>
     在接下来的工作中，可以将字体渲染的代码整合进
     <strong>
      asset processor
     </strong>
     （资产处理器）中，并最终生成字体资产文件。这样可以实现将字体数据转化为游戏中所需的格式。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/67595a3e75434dacb62486ed6d2c38b3.png#pic_center"/>
    </p>
    <h2>
     <a id="stb__70">
     </a>
     stb 库的文档
    </h2>
    <p>
     在查看
     <strong>
      stb_truetype
     </strong>
     库时，有一个非常棒的特点是，库的头文件（
     <code>
      .h
     </code>
     文件）中已经包含了使用文档和示例程序。这意味着即使不记得如何使用这个库，也没有关系，因为在头文件中已经详细列出了如何使用它。
    </p>
    <p>
     例如，头文件中提供了关于如何将字体数据转换为位图的示例代码。如果需要将字体渲染为适合游戏的位图，可以通过库中的函数直接进行。这些示例程序展示了如何将字体图形渲染为一个矩形区域，或者如何生成每个字形的单个位图。
    </p>
    <p>
     特别的是，库内置了一些有用的工具函数，可以帮助开发者简化操作。例如，提供了获取字体字符位图的函数，只需要传入一个字形的代码点和矩形区域，就能将该字形渲染为一个位图。这种封装大大减少了开发者需要编写的代码量，也让使用这个库变得更加简单和方便。
    </p>
    <p>
     因此，通过查看头文件和示例代码，开发者可以快速了解如何使用这个库，并且利用它提供的功能来实现自己的需求。整体而言，
     <strong>
      stb_truetype
     </strong>
     库的设计非常考虑开发者的使用便利，减少了很多不必要的复杂度。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/340fd56431cf4ca7a135b10e2e98834c.png#pic_center"/>
    </p>
    <h2>
     <a id="_81">
     </a>
     栅格化一个字母
    </h2>
    <p>
     这个函数的主要作用是生成给定 Unicode 代码点的位图。为了实现这一点，首先需要定义一个函数，这个函数会调用
     <code>
      stb_truetype
     </code>
     库中的某个方法，该方法可以根据指定的字体信息生成字体位图。
    </p>
    <p>
     函数内部会声明一个用于存储字体信息的结构体，这个结构体是通过传递地址来实现的。接下来，需要准备一个缓冲区，这个缓冲区用于存储从字体文件中读取的信息。字体文件的内容会被读入这个缓冲区中，之后会用来生成字体的位图。
    </p>
    <p>
     在实现时，程序已经具备了读取文件的功能，例如
     <code>
      game_platform
     </code>
     中的
     <code>
      debug_read_entire_file
     </code>
     方法，它可以帮助读取字体文件。通过这个方法，可以快速读取所需的字体文件并将内容存入内存缓冲区。
    </p>
    <p>
     更重要的是，
     <code>
      stb_truetype
     </code>
     库本身并没有强制要求传入文件句柄或文件名，而是允许传入一个已经准备好的内存缓冲区，这样就避免了不必要的依赖和额外的代码操作。它非常灵活，能根据使用者的需要进行操作，而不是强行要求使用特定的文件读取方式。这种设计方式减少了开发者的负担，使得操作更加直观和简便。
    </p>
    <p>
     举个例子，可以选择 Windows 系统中常见的字体文件（如 Arial 字体），然后通过
     <code>
      debug_read_entire_file
     </code>
     函数读取该文件。这样就可以将字体文件内容加载到内存中，之后便可以用来生成位图。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/33305e01fb044dcb998f30a2571125d4.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/972366a6f1c0453c8a2a78545f88a8e4.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0046ddc0c45c4d18b3c689540620ef0f.png#pic_center"/>
    </p>
    <h2>
     <a id="_stb_truetype_99">
     </a>
     将整个内容传递给 stb_truetype
    </h2>
    <p>
     在读取完字体文件之后，接下来会将整个字体文件内容传递给
     <code>
      stb_truetype
     </code>
     库，让它进行处理。具体来说，我们会调用相应的函数来处理字体文件内容，生成所需的位图。
    </p>
    <p>
     其中一个关键的操作是
     <code>
      stbtt_GetFontOffsetForIndex
     </code>
     函数，这个函数的作用是获取字体文件中的某个字体的偏移位置。如果字体文件中包含多个字体文件，这个函数就能根据指定的索引返回相应字体的偏移位置。该函数的作用是帮助从一个字体文件中获取指定索引的字体。
    </p>
    <p>
     当处理完这个步骤后，可以继续调用
     <code>
      stb_truetype
     </code>
     中的
     <code>
      stbtt_GetCodepointBitmap
     </code>
     函数来获取字体的位图。这里的“代码点”（codepoint）是一个唯一的数字标识符，用于表示特定的字形，比如字母 t、汉字“肉”等字符。
    </p>
    <p>
     在获取到字体文件后，程序会初始化相应的字体结构体，然后通过传递这个结构体给
     <code>
      stbtt_GetCodepointBitmap
     </code>
     函数来提取位图信息。这样，我们就能从字体文件中提取特定字符的位图数据，并将其用于图形渲染等后续操作。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/35921457f98b490f8355485b20e9903c.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1386d689a16941b79005eed9f310e0c0.png#pic_center"/>
    </p>
    <h2>
     <a id="_GetCodepointBitmap_112">
     </a>
     使用 GetCodepointBitmap
    </h2>
    <p>
     首先，关于如何获取字体的位图，程序会通过调用函数来获取相应的位图信息。这个过程实际上是基于已知的字体参数，例如
     <code>
      scale x
     </code>
     、
     <code>
      scale y
     </code>
     、
     <code>
      code point
     </code>
     、宽度和高度等。通过这些参数，程序能够生成一个与指定字符（代码点）相关的位图。
    </p>
    <p>
     该函数的返回值是位图数据，实际上就是一个单色位图（monochrome bitmap）。这与我们之前讨论的位图是一样的，唯一的区别是这个位图不包含颜色信息，而是以黑白形式呈现。这意味着它只是通过0和1来表示像素，其中0代表空白像素，1代表填充像素。而关于字体的抗锯齿处理，也通过这种方式在位图中表现出来。
    </p>
    <p>
     总的来说，获取的位图数据仅包含字体的形状轮廓，而不包含任何颜色信息，这是因为大多数客户端处理字体时都只需要黑白图像。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d28e4e2588fe49a5a48d1c55454afb46.png#pic_center"/>
    </p>
    <h2>
     <a id="_121">
     </a>
     字体缩放；点和像素
    </h2>
    <p>
     在获取字体位图时，首先需要传入一些参数，如代码点（code point）、缩放因子（scale x 和 scale y）。其中，
     <code>
      scale x
     </code>
     只是决定了水平的缩放比例，而
     <code>
      scale y
     </code>
     则稍微复杂一些。因为在 TrueType 字体文件中，
     <code>
      scale y
     </code>
     的单位通常是以点（points）为单位，而我们常常需要的是像素（pixels）。为了简化这一过程，库提供了一个实用函数
     <code>
      stbtt_ScaleForPixelHeight
     </code>
     ，这个函数可以根据给定的像素高度来计算出应该传递的正确缩放比例。这样，我们就能够方便地将字体缩放到所需的像素大小。
    </p>
    <p>
     例如，假设我们希望获取一个 128 像素高的字形，我们只需使用该函数来确定相应的缩放比例，然后传入
     <code>
      stb_codepoint_bitmap
     </code>
     函数，就可以获得我们想要的字体位图。这时，我们传入一个 Unicode 代码点（比如字符 ‘n’）来获取对应的位图。
    </p>
    <p>
     一旦获取到位图，返回的数据包括多个关键信息：位图的宽度（width）、高度（height）、X 偏移量（x offset）和 Y 偏移量（y offset）。其中，宽度和高度表示位图的尺寸，X 和 Y 偏移量则表示字符在位图中的位置偏移。
    </p>
    <p>
     这种方式为字体渲染提供了精确的控制，能够方便地获取和调整所需字符的位图信息。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a713ebfd2e5b484ba50bc4aece6318f0.png#pic_center"/>
    </p>
    <h2>
     <a id="_X__Y__132">
     </a>
     记录返回位图的大小以及 X 和 Y 偏移量
    </h2>
    <p>
     在获取位图时，返回的位图是一个紧凑的位图，即没有多余的空白区域。对于每个字形，位图会尽量紧密地包含该字符，不会有额外的空白区域围绕着它。因此，位图的尺寸通常会有所不同，取决于字符的形状和大小。
    </p>
    <p>
     位图的
     <code>
      XOffset
     </code>
     和
     <code>
      YOffset
     </code>
     参数用于调整位图的对齐方式。这些偏移量帮助在渲染多个字符时确保字符之间正确对齐。例如，字符“A”通常比字符“n”高，因此其位图可能需要在Y方向上进行偏移，以确保字符之间对齐。这些偏移量确保了字符能够在字体渲染时正确排列。
    </p>
    <p>
     此外，位图返回的可能是从上到下的排列方式，因此在处理时可能需要进行垂直翻转（上下反转），以适应不同的渲染需求。这种垂直翻转是因为位图通常是从顶部到底部绘制的，而不是从底部到顶部。
    </p>
    <p>
     关于内存管理，获取位图后，可能需要释放内存。虽然文档中没有明确指出是否需要释放，但通常情况下，像这样的位图数据可能需要显式地释放内存资源。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ee59f9b38f0c413cb8f94e5ee0c18787.png#pic_center"/>
    </p>
    <h2>
     <a id="_stb_truetype__143">
     </a>
     释放 stb_truetype 分配的内存
    </h2>
    <p>
     在获取位图后，我们会进行一些额外的处理，确保一切顺利。特别地，位图的内存管理非常重要。处理完位图之后，需要释放相关的内存资源，这时使用
     <code>
      free
     </code>
     函数来释放位图的内存。不过，
     <code>
      free
     </code>
     函数的参数并不是直接的位图，而是需要传递一些用户数据，例如传递一个内存管理区域（arena）来处理内存分配。这是因为位图可能涉及到更复杂的内存管理需求。
    </p>
    <p>
     至于编译，整个过程会经过编译阶段，确保代码能够顺利运行。在此过程中，可能会遇到一些与音频处理相关的代码，需要特别注意。这些步骤看似复杂，但通过合理的内存管理和按需编译，就能顺利完成字体渲染任务。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c3ddab34b96d48249b2cadaad6e4e1cf.png#pic_center"/>
    </p>
    <h2>
     <a id="_150">
     </a>
     欣赏完成得很好的工作
    </h2>
    <p>
     整个过程其实非常简单，基本上就是通过这个库来进行接口交互。这个库的设计非常好，使用起来非常直接且高效。只需要少量的代码，甚至无需处理复杂的依赖和配置，就可以在游戏中实现字体渲染功能。相比现代的大型API或者库，这种简洁的设计让人觉得很不一样，尤其是当看到一些现代的库需要成千上万行代码来完成一些基本的任务时，实在是显得不值一提。
    </p>
    <p>
     这个库的优势在于，它非常符合我们的需求——我们需要做的功能，只需要调用相应的函数，完成后就能直接获得所需的结果，不需要考虑复杂的设置或配置。它将复杂的任务简化为简单的调用，使得开发过程更加高效和流畅。
    </p>
    <p>
     如果所有库都能像这个库一样设计得如此简洁和易于集成，那么开发过程将会变得更加轻松。相比之下，很多现代的API和库往往包含大量的冗余代码和复杂的依赖，反而让开发者感到头疼。因此，这种库的设计理念和实现方式为开发者提供了极大的便利，也让整个开发体验变得更加愉快。
    </p>
    <h2>
     <a id="_157">
     </a>
     使用字符位图作为加载的位图
    </h2>
    <p>
     在这个过程中，我们首先创建了一个空的位图，并通过使用字体库加载并处理字形。具体来说，首先初始化了一个空的位图，然后通过给定的字体数据和参数（如宽度和高度），生成了一个字母“n”的位图。为了实现这一点，我们需要先通过字体库读取并获取字形数据，然后将其转换成32位的位图格式，每个像素占四个字节。
    </p>
    <p>
     这个转换过程实际上并不复杂。我们只是通过将从字体数据中读取到的每个像素值，转换为目标格式，然后填充位图内的每个像素。位图的转换是通过将字形中的每个像素值与其对应的透明度值（alpha值）进行混合来完成的。混合后的结果就是带有透明度的颜色值。
    </p>
    <p>
     接下来，我们通过一个简单的循环遍历每个像素，进行必要的位图数据转换，最终生成所需的位图。这里需要注意的是，位图的生成是逐行进行的，每一行的数据在内存中是连续存储的。
    </p>
    <p>
     当完成位图的转换后，我们还做了一些清理工作，确保一切正常进行。接下来，将生成的位图存储在合适的位置，并在游戏初始化时加载这个位图作为测试使用。然后，在游戏启动时，可以通过调用相应的代码来生成并显示该位图。
    </p>
    <p>
     如果没有错误，最终的结果应该是成功创建并显示字母“n”的位图。尽管在代码的实际运行中可能还需要做一些细节上的调整，例如确保正确显示图像，或者解决潜在的内存管理问题，但总体流程就是如此。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0705e7dfd823402fab1093c798c9cecd.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/745bcb3d772741ccbe382b5ef92ebfc5.png#pic_center"/>
    </p>
    <h2>
     <a id="_173">
     </a>
     显示位图
    </h2>
    <p>
     在这个过程中，首先决定将位图显示的代码放在头部渲染部分，这样可以避免将大量的“头部”文字直接显示到屏幕上。相反，选择通过显示测试字体来代替。测试字体的目的是验证位图渲染是否正常工作。
    </p>
    <p>
     在代码中，我们使用了一个名为“加载位图”的功能，这个功能要求传递一个内存地址。接着通过传入测试字体的相关数据，来加载并显示位图。为了进行正确的渲染，需要确保传递给加载位图的内存地址是正确的。
    </p>
    <p>
     在处理完这些准备工作之后，执行代码并运行测试，检查位图的显示是否如预期一样正确。如果没有出现错误，最终应该能够看到正确渲染出来的字体，而不是直接显示的“头部”文本。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7b0de925dc6e46de8effd34c6e721576.png#pic_center"/>
    </p>
    <h2>
     <a id="_183">
     </a>
     测试它
    </h2>
    <p>
     在这个过程中，出现了一个问题，测试字体并没有正确显示在屏幕上，导致感到很失望。为了找出原因，决定回到代码中，逐步排查问题。通过进入调试模式，可以查看之前调用的函数，进一步分析哪里出了问题。
    </p>
    <p>
     通过调试，可以看到调用的函数是“MakeNothingsTest”，然后逐步跟踪这段代码，查看每个步骤，确定是哪一部分没有正常执行，进而定位到问题所在。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fb66edebf59f43c1a9cd7bac04a61156.png#pic_center"/>
    </p>
    <h2>
     <a id="_MakeNothingsTest_190">
     </a>
     检查 MakeNothingsTest
    </h2>
    <p>
     在调试过程中，发现了一些问题。首先，检查了加载的字体文件，确认文件内容已经成功加载，并且包含了大量的字形信息。对于每个字形，宽度和高度的值看起来都合适，且没有异常。
    </p>
    <p>
     接着，检查了生成的位图。虽然某些字形的 alpha 值设置为 1，但在查看过程中发现有些地方存在问题。例如，某些 alpha 值为 70，显然表明在处理位图时出错了。通过调试逐步排查，发现可能是目标位图未正确扩展到 32 位，导致颜色或透明度处理出现问题。
    </p>
    <p>
     为了进一步确认是否有问题，检查了源代码中的数据，发现某些数据似乎没有按照预期方式工作。尽管设置了正确的 alpha 值，但位图的显示效果并未达到预期。通过进一步的调试，推测可能是位图在存储或渲染时未能正确应用 alpha 值，导致最终结果与预期不符。
    </p>
    <p>
     总的来说，问题在于某些渲染和位图处理上的细节，虽然数据看起来正常，但由于没有正确处理这些细节，最终效果未能正确显示。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/75223b1d77ec43b4b48444304d69ddd2.png#pic_center"/>
    </p>
    <h2>
     <a id="_201">
     </a>
     调试绘制代码
    </h2>
    <p>
     在调试过程中，发现了一个问题。查看了游戏的测试状态和内存，确认内存中确实存在数据。然而，尽管应该在屏幕上显示内容，但实际显示的结果并没有按预期出现。这让人感到困惑，因为从内存数据来看，一切似乎正常。
    </p>
    <p>
     目前，无法完全理解为什么没有看到任何渲染结果，感觉这个问题有些奇怪，可能遗漏了某些明显的细节或步骤。需要进一步分析和排查可能的问题，以确保渲染流程正常。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6b6535c175e44c0f91e6def3b562f491.png#pic_center"/>
    </p>
    <h2>
     <a id="MakeEmptyBitmap__208">
     </a>
     MakeEmptyBitmap 已过时，缺少一些初始化代码
    </h2>
    <p>
     问题出在没有更新
     <code>
      MakeEmptyBitmap
     </code>
     函数，使其遵循新的位图规则。原来的代码已经不适用了，需要根据新规则进行一些初始化工作，特别是要根据输入调整位图的宽度和高度。可以使用宽度或高度的比例来计算，确保适应新的要求。
    </p>
    <p>
     此外，不再关心像素的具体位置或中心等信息，只需要根据新的标准进行设置和调整。这些改动会帮助解决渲染问题，使位图能够正确显示。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1560b3e862b04225ab8baee3558fecb0.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4e935f17621849738d8b50fdf73ee3d9.png#pic_center"/>
    </p>
    <h2>
     <a id="_218">
     </a>
     再次测试
    </h2>
    <p>
     显示的不对
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b354e033093946ec96743eeb940ea841.png#pic_center"/>
    </p>
    <p>
     忘记跳到下一行
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/16db7ae310d34233a5475bea973a46a5.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e9c71d0e0c9349be96df7b9cfe072396.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d6767675a2664522aab8fe874f4be2eb.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2fbeee3bbac5491a922c0c467c7d0ffa.png#pic_center"/>
    </p>
    <p>
     问题出在位图的方向上。当前的位图是按照从上到下的方式排列的，而所使用的库默认假设位图是从上到下的（top-down），而我们的惯例是从下到上（bottom-up）。这就导致了显示的字符（如字母“n”）可能会显示反转或错位。
    </p>
    <p>
     为了修复这个问题，需要对加载的位图进行翻转，使其符合我们的惯例，即将位图从底部到顶部加载，这样字母就会正确显示。此时，字母的方向和排列应该正常，符合预期效果。
    </p>
    <p>
     这个问题可以通过在代码中添加位图翻转的步骤来解决，当前的代码已经处理了从单色到彩色的转换，接下来需要在此基础上增加对位图方向的调整。
    </p>
    <h2>
     <a id="_237">
     </a>
     将字母位图上下翻转
    </h2>
    <p>
     解决问题的方法非常简单。只需要对位图进行翻转操作，将位图的行反向排列。具体来说，可以通过调整位图的行指针，从最后一行开始逆向写入数据。这样就能使位图符合我们的惯例（即从下到上）。这一操作非常简单，并且能够解决显示问题。
    </p>
    <p>
     使用这个方法后，字母和字符应该会正确显示，不会出现倒置的情况。这是因为所使用的库默认采用的是自上而下的位图格式，而我们的程序需要底部到顶部的位图格式。因此，通过翻转位图，可以确保一切正常。
    </p>
    <p>
     总结来说，使用这个方法能够快速解决问题。谈到库的使用，尤其是图像处理库，stb库无疑是一个非常好的选择。它设计得非常简洁，易于使用，而且功能全面。stb库具有很好的架构设计，能够高效地完成大量工作，避免了其他库常见的复杂性和问题。因此，在大多数情况下，推荐使用stb库，而其他库的使用则相对较少。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a92f42cb6b91460baebc43d6bd5e9c09.png#pic_center"/>
    </p>
    <h2>
     <a id="_247">
     </a>
     将此代码移到资源构建器中
    </h2>
    <p>
     为了避免在实际的游戏代码中使用任何外部库，将所有的库功能移至资源构建器中是一个合理的选择。具体来说，处理字体的部分已经从游戏代码中剥离，并且移到了资源构建器中。通过这种方式，游戏本身仍然不依赖任何库，而资源构建器则可以使用外部库（如stb库）进行处理和加载。
    </p>
    <p>
     在资源构建器中，处理字体的逻辑已经被重新整理，这样就可以在构建资源时加载并处理字体等资源。当资源加载到游戏中时，我们将其转换为游戏能够使用的格式。虽然可以直接将这些资源存储到资产数组中，但接下来的步骤是需要扩展资源格式，加入额外的内容，例如字符映射表等，这些内容是我们需要在文件中存储的，以便在游戏加载时能够使用。
    </p>
    <p>
     目前，我们的目标是处理和加载这些资源，并将它们转化为游戏能使用的格式，这样游戏的运行过程中就可以通过这些格式化的资源正常渲染和显示了。这一过程中的关键是保持游戏代码的简洁和高效，避免直接在游戏本体中进行过多的资源处理。
    </p>
    <h2>
     <a id="_game_asset_type_idh__game_file_formatsh_254">
     </a>
     将 game_asset_type_id.h 合并到 game_file_formats.hβ
    </h2>
    <p>
     决定将资产标识符（game_asset_type_id）和文件格式（game_file_formats）合并在一起，这样的设计是为了简化代码结构，并消除不必要的冗余。通过这种方式，可以将两个看似不同的功能合并为一个统一的结构，从而提高代码的整洁性和可维护性。
    </p>
    <p>
     在具体操作上，原本分开的部分被统一处理，删除了一些多余的文件和类型定义，使得整体结构更加简化。对这些调整没有太多情感上的纠结，目标只是让代码更简洁、更高效。因此，尽管删除了一些以前的结构和实现，这种改变并不会带来太多遗憾，反而是为了更好地推进项目。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3382b7a83cc9470e8969989087c798a9.png#pic_center"/>
    </p>
    <h2>
     <a id="_261">
     </a>
     为每个字母添加一个位图到资源文件
    </h2>
    <p>
     在这里决定做一些非常不寻常的事情，尽管这看起来可能并不是最理想的做法，但既然有这个能力，就决定尝试一下。想要将一个资产（Asset）直接用于处理字体（font），这种方式明显有点过度使用了现有的资产系统。虽然并不建议这么做，但考虑到可以这样操作，就试试吧。
    </p>
    <p>
     具体实现上，首先定义一个新的资产类型
     <code>
      asset fonts
     </code>
     ，然后在资产构建器中进行处理。接下来，为了创建字符集，选择从字母 a 到 Z 生成并将其直接插入到资产系统中。每个字符都用一个
     <code>
      code point
     </code>
     标签标记，表示它的 Unicode 代码点。
    </p>
    <p>
     虽然这种做法在理论上是非常低效和不负责任的，但目前并不关心执行效率，因为这是在进行资产处理阶段。后期可以对这个过程进行优化，所以现在可以先不考虑速度问题，直接按照这种方式进行处理。这虽然是一种非常不负责任的做法，但考虑到目前的开发阶段，并不觉得这会造成太大的问题。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9aa031873c3a49c9b212794e34b691dd.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7d21d146d3794919908e985fd352a74c.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/363a13f7016245beb27bd3779f53fa89.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/24acf4627b864d33860b1fd44e1521d6.png#pic_center"/>
    </p>
    <h2>
     <a id="_Sean__276">
     </a>
     重新加载整个字体文件并让 Sean 解析它
    </h2>
    <p>
     计划重新加载整个字体文件，并每次解析一次，这虽然是很不高效的做法，但目前不在乎性能问题。决定使用
     <code>
      AddCharacterAsset
     </code>
     方法来实现字体的加载和处理。这个方法会接收一个资产结构、一个字体文件以及代码点。整个过程的思路是：首先使用已有的代码读取整个文件，传入字体文件后，通过某个函数来释放这个文件的内存。
    </p>
    <p>
     虽然这一做法显得有些混乱，但在目前阶段并不打算关注效率，目标是尽快实现功能。发现之前在处理文件时，我们已经做了一些内存管理的优化，尽管当时没有完全记得细节，但代码中确实有处理文件释放的部分。虽然这种做法非常简单粗暴，但也证明了开发中会逐步意识到内存管理的重要性，最终虽然简单，但也合理有效。
    </p>
    <h2>
     <a id="_281">
     </a>
     干得好
    </h2>
    <p>
     首先，决定读取整个字体文件并在使用后释放它，因为此时并不需要保持任何不必要的数据。不同于其他情况，这次不需要保留任何内容。接下来，打算检查
     <code>
      stb
     </code>
     库中的相关功能，确保在处理完字体文件后能够释放相应的内存。虽然没有详细检查过，但猜测
     <code>
      stb
     </code>
     库在加载字体时可能不会进行内存分配，或者是它自己管理内存，所以没有特别的释放操作。
    </p>
    <p>
     最终，发现字体数据处理并不需要额外的内存管理，它只会返回纯数据，不需要额外的操作来释放内存。于是，整个清理工作完成了。
    </p>
    <p>
     接下来，重点转移到处理与位图加载和释放相关的工作，这虽然看起来有些复杂，但也不难处理。这一过程让整体代码变得更加简化，也方便了后续的开发工作。
    </p>
    <h2>
     <a id="_288">
     </a>
     将字体栅格化测试代码调整为资源系统
    </h2>
    <p>
     在处理字体时，需要通过
     <code>
      AddCharacterAsset
     </code>
     函数获取合并后的位图。接下来，创建一个实际使用该资产的位图。首先需要确保在处理文件之前，检查字体文件是否加载成功，尽管在这个阶段，文件加载是离线的，不是必须的，但为了稳妥，还是做了这一检查。
    </p>
    <p>
     随后定义一个位图，并为其分配内存。此时，内存分配的大小应该基于位图的宽度和高度进行计算，因此需要申请足够的内存空间。在这里，使用
     <code>
      malloc
     </code>
     来分配空间，分配的内存大小是位图的宽度乘以高度，乘以每个像素所需的字节数。
    </p>
    <p>
     此外，还考虑到位图可能需要填充，因此需要处理
     <code>
      pitch
     </code>
     ，这代表了每行的字节数。由于可能存在填充的需求，因此在内存分配时需要考虑这一点，并在相关代码中加以处理。
    </p>
    <p>
     最终，完成了位图内存的分配和处理，为后续的位图加载和使用做好了准备。
    </p>
    <h2>
     <a id="_297">
     </a>
     将资源系统调整为新的资源类型
    </h2>
    <p>
     如果按照这种方式进行操作，就可以先计算所需的内存大小，具体来说就是
     <code>
      pitch
     </code>
     乘以
     <code>
      width
     </code>
     ，以确保分配足够的空间。这样，在后续处理完毕后，就可以直接释放这部分内存，而无需关注其他无关的内容。这部分代码的逻辑和之前的实现完全一致，因此可以直接复用。
    </p>
    <p>
     在完成内存分配和释放后，还需要处理加载的位图。查看
     <code>
      LoadBMP
     </code>
     发现，它返回的是一个
     <code>
      loaded_bitmap
     </code>
     结构，因此可以创建一个类似的
     <code>
      LoadGlyphBitmap
     </code>
     方法，使其与
     <code>
      LoadBMP
     </code>
     的行为一致。这样，就可以通过
     <code>
      LoadGlyphBitmap
     </code>
     加载特定的字符位图，而
     <code>
      LoadBMP
     </code>
     继续处理普通的位图。
    </p>
    <p>
     在
     <code>
      LoadGlyphBitmap
     </code>
     方法中，除了文件名之外，还需要传入字符的
     <code>
      CodePoint
     </code>
     。此外，还可能需要处理字体大小相关的逻辑，但暂时先不处理，后续可以在优化时补充更多的字符对齐等细节。等到后面有空时，比如明天或下周，再进一步优化字符对齐等问题。
    </p>
    <p>
     <code>
      AddCharacterAsset
     </code>
     的逻辑和
     <code>
      AddBitmapAsset
     </code>
     基本一致，唯一的区别在于加载
     <code>
      bitmap
     </code>
     的方式。因此，可以在
     <code>
      AddCharacterAsset
     </code>
     中直接复用
     <code>
      AddBitmapAsset
     </code>
     的代码，只是更改加载位图的方式。例如，之前
     <code>
      AddBitmapAsset
     </code>
     是在写入时加载位图，因此可以在
     <code>
      AddCharacterAsset
     </code>
     中创建一个类似的代码路径，专门用于字体位图的处理。
    </p>
    <p>
     接着，可以在
     <code>
      asset_type
     </code>
     中新增一个
     <code>
      font
     </code>
     类型，并让
     <code>
      AddCharacterAsset
     </code>
     走相同的逻辑路径。这样，在写入数据时，可以判断
     <code>
      Source-&gt;Type
     </code>
     是否为
     <code>
      asset_type font
     </code>
     ，然后调用对应的
     <code>
      LoadGlyphBitmap
     </code>
     方法，否则就继续走普通的
     <code>
      bitmap
     </code>
     处理逻辑。这样，代码路径就可以共享，避免重复实现。
    </p>
    <p>
     在
     <code>
      asset_type font
     </code>
     处理完毕后，还需要存储
     <code>
      Codepoint
     </code>
     ，可以直接使用
     <code>
      FirstSampleIndex
     </code>
     存储
     <code>
      Codepoint
     </code>
     ，确保后续能正确匹配字符数据。整体来看，整个逻辑非常基础，基本上是按照既有的系统进行扩展和适配。当前的目标只是按照系统既定规则实现功能，所以就只是按照现有模式继续推进。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f5e0c5c657154e6e908170ad92f85f6c.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9c341679476d408aa782b2b47adb24a4.png#pic_center"/>
    </p>
    <h2>
     <a id="AddCharacterAsset_314">
     </a>
     AddCharacterAsset
    </h2>
    <p>
     在当前的处理方式中，glyphic maps 仅仅是一种记录我们希望执行某个操作的方式。查看具体实现时，可以看到对于
     <code>
      add bitmap asset
     </code>
     ，可以使用完全相同的代码。然而，代码量似乎较多，这是一个值得关注的问题。因此，需要考虑是否可以对其进行某种压缩或合并处理，以优化整体结构。
    </p>
    <p>
     由于这是资产处理器，而当前的部分更像是一个示例，因此可能不会特别关注这个问题。但仍然让人有些犹豫，是否需要进行调整。代码中涉及
     <code>
      codepoint
     </code>
     相关的逻辑，其余部分基本保持原样，没有太大变化。至于
     <code>
      AlignPercentageX
     </code>
     ，目前在这里并不特别重要，因为无论如何，在处理字体对齐时仍然需要执行其他操作，因此可以暂时保持不变。
    </p>
    <p>
     在代码调试过程中，出现了一些错误。其中涉及
     <code>
      TTFFile
     </code>
     变量的使用，它实际上被命名为
     <code>
      entire file
     </code>
     。此外，还有
     <code>
      font file
     </code>
     、
     <code>
      file name
     </code>
     、
     <code>
      free
     </code>
     、
     <code>
      contents
     </code>
     等变量的引用，需要确保
     <code>
      contents
     </code>
     仍然有效。
     <code>
      results
     </code>
     变量是
     <code>
      results
     </code>
     ，而
     <code>
      add character assets
     </code>
     需要返回
     <code>
      get map id
     </code>
     ，应该是这个返回的内容。当前进度基本接近完成，只需进一步确认这些逻辑是否正确。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/67400f32bb164cd1ad68a6312d4e09a7.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a8b5c9eb07f54214869704d04f91c5d2.png#pic_center"/>
    </p>
    <h2>
     <a id="_325">
     </a>
     继续运行我们的生成器ζ
    </h2>
    <p>
     目前的情况有些类似于孤注一掷的尝试，因为手头只有一堆代码，但对其具体行为并没有清晰的了解。不过，既然已经到了这个阶段，不妨直接运行看看效果如何。毕竟，此时已经接近流程的尾声，理论上不会出现什么严重的问题。
    </p>
    <p>
     当然，从技术角度来看，仍然有很多可能出错的地方。但既然已经准备好了
     <code>
      test_assets_builder
     </code>
     ，就直接运行它来看看实际结果。然而，运行后的情况似乎不太理想，输出的结果显示出某些错误，需要进一步排查和修正。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6b39fa8fe1014a909a9109fefeb41ff0.png#pic_center"/>
    </p>
    <h2>
     <a id="_333">
     </a>
     调试一下
    </h2>
    <p>
     发现断点一直进不来
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5b54e4b878984481ac200db50f61ad52.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0c9a689b96f24a0b906372d29ebe20fd.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5422f62161644d43bbc4548d0c678e5a.png#pic_center"/>
    </p>
    <h3>
     <a id="hha_342">
     </a>
     从新生成hha
    </h3>
    <h2>
     <a id="_344">
     </a>
     尝试将头部改为字体ι
    </h2>
    <p>
     目前已经成功获取了
     <code>
      heads
     </code>
     ，接下来尝试将其更改为字体。在这一过程中，当设置
     <code>
      BitmapID
     </code>
     时，将从
     <code>
      GetRandomBitmapFrom
     </code>
     中随机获取一个位图，并观察其实际效果。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/211edbb7507e43e781ddf4dd525681b9.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e5337c0b42ca457ca414195dcb69c04a.png#pic_center"/>
    </p>
    <h2>
     <a id="_350">
     </a>
     筛选从喷泉中喷出的字母
    </h2>
    <p>
     如果想让实现变得更有趣一些，同时保持 “nothing” 这个主题，可以将所使用的字母限定在
     <code>
      N
     </code>
     ,
     <code>
      O
     </code>
     ,
     <code>
      T
     </code>
     ,
     <code>
      H
     </code>
     ,
     <code>
      I
     </code>
     ,
     <code>
      N
     </code>
     ,
     <code>
      G
     </code>
     ,
     <code>
      S
     </code>
     这几个字符内。为了做到这一点，可以利用资产标签匹配系统，从资产库中筛选出符合条件的标签。
    </p>
    <p>
     目前的代码并未针对资产标签匹配系统进行优化，因此这样使用可能会导致效率较低。如果要提高性能，最好预先构建匹配表，而不是在运行时强行筛选。不过，仍然可以使用
     <code>
      GetBestMatchBitmapFrom
     </code>
     来匹配最合适的资产。
    </p>
    <p>
     在调用该方法时，可以传入
     <code>
      TranState-&gt;Assets
     </code>
     ，并将
     <code>
      Asset_Font
     </code>
     作为
     <code>
      type id
     </code>
     。此外，还需要提供一个
     <code>
      asset vector
     </code>
     ，其中包含
     <code>
      MatchVector
     </code>
     和
     <code>
      WeightVector
     </code>
     。这两个向量内唯一的内容就是 Unicode 码点，例如，假设要匹配
     <code>
      N
     </code>
     ，并且使用的是大写字母，就可以按照这个逻辑进行筛选。
    </p>
    <p>
     具体实现上，可以简单地用随机选择的方法，从匹配到的字母集合中挑选一个。这里直接使用
     <code>
      random choice
     </code>
     来从
     <code>
      nothings
     </code>
     字母集中选取一个随机字母，并将其作为最终的选择结果。
    </p>
    <p>
     最终的输出结果展示了所选的
     <code>
      N
     </code>
     ，并且成功按照 “nothing” 主题筛选出了符合要求的字母。整体实现基本完成，逻辑已经跑通，效果也达到了预期。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b62ce822eb914911b6a4502b05616b07.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d2108e2464fb4918a49ea451d6ea2c50.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7459b3402e5d4952903136aee9165333.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/52bd466ce82d41b49fc2f75cc3ed1631.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/551683da8cd34024a882c59f6913d4e3.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ea91c606f4484972abb7d796cabfb52a.png#pic_center"/>
    </p>
    <h2>
     <a id="_375">
     </a>
     库成功！κ
    </h2>
    <p>
     使用库的成功秘诀在于选择合适的库。绝大多数情况下，最好的选择是使用由
     <code>
      Shah
     </code>
     设计的库，因为这些库通常遵循特定的风格，并且极具实用性。当然，也有其他开发者按照相同的风格编写了一些优秀的库，这些库也值得考虑。
    </p>
    <p>
     在选择库时，有几个重要的标准需要关注：
    </p>
    <ol>
     <li>
      <strong>
       单文件实现
      </strong>
      ：如果一个库只有一个文件，那通常是一个很好的信号，意味着它易于集成。
     </li>
     <li>
      <strong>
       API 直观易用
      </strong>
      ：例如，如果需要获取代码点位图，而库中正好提供了一个名为
      <code>
       gecko_pipe
      </code>
      的函数，能够直接返回所需的位图，那就是一个理想的选择。
     </li>
     <li>
      <strong>
       集成简单
      </strong>
      ：优秀的库应该不需要复杂的构建选项，理想情况下，只需要一两行代码即可完成集成，而无需额外配置。
     </li>
     <li>
      <strong>
       快速上手
      </strong>
      ：如果一个库可以立即投入使用，并且能够轻松整合到已有的资产处理流程中，那它就是一个优秀的库。
     </li>
    </ol>
    <p>
     在实际操作中，使用符合这些标准的库确实带来了极大的便利。例如，在本次实现过程中，能够快速集成所需功能，而如果使用其他方案，可能还需要花费大量时间去调试 Apple 的相关接口。
    </p>
    <p>
     这次实践清楚地展示了一个关键问题：如果要使用外部库，应该优先考虑那些结构清晰、简单易用的库。正因如此，当被问到 “如果使用库，会选择哪些库？” 时，答案始终是这些设计合理的库，而不是那些复杂难用的选项。
    </p>
    <h2>
     <a id="A__389">
     </a>
     ‘A’ 是最适合空字符终止符的
    </h2>
    <p>
     在当前实现中，
     <code>
      null terminator
     </code>
     的匹配存在一些问题。最优匹配方式需要进行调整，以避免
     <code>
      null terminator
     </code>
     被误算在内。
    </p>
    <p>
     目前的逻辑存在一个小错误：原本
     <code>
      array counts
     </code>
     应该是
     <code>
      recount - 1
     </code>
     ，因为
     <code>
      recount
     </code>
     计算时会包含末尾的
     <code>
      null terminator
     </code>
     ，但实际操作时并不希望它被计入。因此，更合理的做法是使用
     <code>
      recount nothings - 1
     </code>
     ，这样可以确保不会错误地将
     <code>
      null terminator
     </code>
     作为匹配项。
    </p>
    <p>
     这个调整可以使得逻辑更加严谨，避免
     <code>
      null terminator
     </code>
     影响最终结果，同时让匹配过程更加精准。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1044cb7b273b4457b78286ce4a91676f.png#pic_center"/>
    </p>
    <h2>
     <a id="_CMake__STB__CMake__399">
     </a>
     直到今晚，我才明白 CMake 的一个使用场景（就是用户编译程序时，能够找到库，这样你就不需要知道它们的安装位置）。但是现在……看起来 STB 方式是唯一合理的默认方式。我想在可预见的未来我已经不再使用 CMake 了
    </h2>
    <p>
     在最初的设想中，
     <code>
      CMake
     </code>
     似乎有一个合理的使用场景，即在用户编译程序时，它能够自动找到所需的库，而不需要手动指定它们的安装路径。然而，现在看来，标准的构建方式才是唯一合理的默认选项，因此不再考虑继续使用
     <code>
      CMake
     </code>
     。
    </p>
    <p>
     总体来说，
     <code>
      CMake
     </code>
     等构建工具之所以被使用，主要是因为许多库和程序的构建方式本身存在问题。如果代码组织合理，即便是一个庞大的代码库，也可以仅依靠单文件构建完成。当然，这并不意味着所有情况下都应该采用这种方式，而是说构建工具本质上是多余的。
    </p>
    <p>
     使用构建工具通常会导致一系列复杂的问题。例如，整个构建流程可能变得异常繁琐，开发过程中需要不断调试
     <code>
      Makefile
     </code>
     ，或者因为错误的
     <code>
      CMake
     </code>
     配置导致各种构建失败的问题。此外，还可能遇到诸如错误的
     <code>
      CMake
     </code>
     版本、错误的编译器选项等问题，导致调试过程极为痛苦。
    </p>
    <p>
     在实际项目中，
     <code>
      CMake
     </code>
     可能会带来很多麻烦。例如，在尝试静态链接
     <code>
      Clang
     </code>
     时，遇到了极大的困难，整个构建过程异常复杂，最终不得不将经验总结成文档，分享给其他开发者，以帮助他们避开类似的陷阱。这种复杂性表明，完全可以通过合理的代码结构和构建策略来避免
     <code>
      CMake
     </code>
     带来的问题。
    </p>
    <p>
     因此，在项目决策时，应该认真考虑是否真的需要
     <code>
      CMake
     </code>
     或其他类似的构建工具。对于许多项目来说，避免
     <code>
      CMake
     </code>
     可能会使整个开发流程更加清晰、高效，并减少不必要的构建调试工作。
    </p>
    <h2>
     <a id="mallocfree_Java__410">
     </a>
     外部库、malloc/free，接下来是 Java 虚拟机吗？
    </h2>
    <p>
     在外部库的使用上，如果涉及到
     <code>
      Java Virtual Machine (JVM)
     </code>
     ，那么对于资产处理器来说，完全可以自由选择是否使用
     <code>
      JVM
     </code>
     。
    </p>
    <p>
     资产处理器本身并不被视为游戏核心的一部分，而只是一个用于演示如何处理某些任务的工具。因此，在资产处理器的实现上，如果需要
     <code>
      JVM
     </code>
     ，那完全可以按照需求来决定是否引入。
    </p>
    <p>
     换句话说，在这种情况下，是否使用
     <code>
      JVM
     </code>
     完全取决于具体需求。如果觉得
     <code>
      JVM
     </code>
     适合资产处理器的工作流程，那就可以放心使用，不必过多纠结其对整体架构的影响。
    </p>
    <h2>
     <a id="_417">
     </a>
     你现在如何写调试信息？
    </h2>
    <p>
     如何编写调试信息，取决于你需要调试的内容。调试信息的目标是帮助开发者理解程序的运行状态，以便快速定位和修复问题。通常，调试信息应该包括关键的变量状态、函数调用的顺序、错误日志以及可能导致问题的其他上下文信息。
    </p>
    <p>
     编写调试信息时，可以通过以下几种方式来提高其有效性：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        明确的标签和时间戳
       </strong>
       ：在日志中添加标签（如
       <code>
        DEBUG
       </code>
       、
       <code>
        INFO
       </code>
       、
       <code>
        ERROR
       </code>
       ）和时间戳，帮助区分不同类型的消息并跟踪事件的发生时间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关键变量的输出
       </strong>
       ：输出关键变量的值，尤其是那些可能影响程序流程的变量，这样可以让调试者看到每一步的状态。
      </p>
     </li>
     <li>
      <p>
       <strong>
        错误信息和堆栈追踪
       </strong>
       ：对于异常情况，应该记录错误信息和堆栈追踪，以便定位问题发生的位置。
      </p>
     </li>
     <li>
      <p>
       <strong>
        函数调用和返回值
       </strong>
       ：在调试时，记录函数的调用顺序以及返回值，特别是那些可能导致程序状态改变的函数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        日志分级
       </strong>
       ：根据不同的严重程度分类日志信息，例如
       <code>
        INFO
       </code>
       用于常规操作信息，
       <code>
        DEBUG
       </code>
       用于详细的运行时信息，
       <code>
        ERROR
       </code>
       用于异常和错误信息。
      </p>
     </li>
    </ol>
    <p>
     总之，调试信息应当简洁且富有意义，帮助开发者理解代码的执行流程和状态，从而更有效地发现和解决问题。
    </p>
    <h2>
     <a id="_FPS__434">
     </a>
     换个说法：你如何输出句子来查看调试字符串，比如 FPS 或错误码？
    </h2>
    <p>
     如何生成调试字符串，例如 FPS 或错误代码，暂时还没有完全解决这个问题。可以先暂时把这个问题放在一边，因为这正是下周要讨论的内容。到时候会深入探讨如何处理和输出这些调试信息。所以，先记住这个问题，等到下周再一起解决。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f544d313639353634383136342f:61727469636c652f64657461696c732f313436323936383537" class_="artid" style="display:none">
 </p>
</div>


