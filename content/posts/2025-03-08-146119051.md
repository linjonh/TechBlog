---
layout: post
title: "字符串习题"
date: 2025-03-08 17:22:03 +0800
description: "本文介绍了字符串的两道习题通过阅读本文，你可以学会1）统计字符串中字母，单词个数的套路，以及大小写字母转化的方法2）应对高精度计算的方法。（加减乘除的原理类似）3）用字符串模拟竖式计算的方法和过程"
keywords: "字符串习题"
categories: ['未分类']
tags: ['开发语言', 'C']
artid: "146119051"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146119051
    alt: "字符串习题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146119051
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146119051
cover: https://bing.ee123.net/img/rand?artid=146119051
image: https://bing.ee123.net/img/rand?artid=146119051
img: https://bing.ee123.net/img/rand?artid=146119051
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     字符串习题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     单词个数统计
    </h3>
    <h4>
     原作：
    </h4>
    <p>
     输入： 一行字符串。仅有空格和英文字母构成。
    </p>
    <p>
     输出：
    </p>
    <p>
     英文字母个数letter_num
    </p>
    <p>
     单词个数word_num
    </p>
    <p>
     出现最多的字母max_letter
    </p>
    <p>
     出现最多的字母的出现次数max_letter_frequ
    </p>
    <p>
     处理：
    </p>
    <ol>
     <li>
      <p>
       统计并输出此句子英文字母的个数；
      </p>
     </li>
     <li>
      <p>
       统计并输出此句子中单词的个数；
      </p>
     </li>
     <li>
      <p>
       查找此句子中出现次数最多的字母（不区分大小写，大小写字母是相同的）及次数。
       <span style="color:#fe2c24">
        当出现最多的字母不止一个时，全部找到，并输出找到的所有字母及次数。（输出顺序按字母顺序，且输出时字母全部小写）
       </span>
      </p>
     </li>
    </ol>
    <pre><code class="language-cpp">int main() {
    //输入：一行字符串。仅有空格和英文字母构成。 
    char arr[1024];
    string s;
    fgets(arr, sizeof(arr), stdin);
    s = arr;
    //英文字母个数
    int letter_num = 0;
    //单词的个数
    int word_num = 0;
    map&lt;char,int&gt; myMap;
    //处理
    //统计并输出此句子英文字母的个数
    for (int i = 0; i &lt; s.size(); i++) {
        if (s[i] != ' ') {
            letter_num++;
            //将s[i]统一转成小写
            if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') {
                s[i] += 32;
            }
            myMap[s[i]]++;
            if (s[i] == ' ' &amp;&amp; s[i + 1] != ' ') {
                word_num++;
            }
        }
    }
    //输出：英文字母的个数
    printf("%d\n", letter_num);
    //输出：单词的个数
    printf("%d\n", word_num);
    //输出：出现次数最多的字母
    map&lt;char,int&gt;::iterator it;
​
    //找到字母出现的最多次数
    int max = 0;
    for (it=myMap.begin(); it != myMap.end(); it++) {
        if (it-&gt;second &gt; max) {
            max = it-&gt;second;
        }
    }
    //找到值为max的所有键
    vector&lt;char&gt;max_letters;
    for (it = myMap.begin(); it != myMap.end(); it++) {
        if (it-&gt;second == max) {
            max_letters.push_back(it-&gt;first);
        }
    }
   //打印输出max_letters数组中的值
    for (int i = 0; i &lt; max_letters.size(); i++) {
        printf("%d ", max_letters[i]);
    }
    printf("\n");
   
    return 0;
}</code></pre>
    <h4>
     代码分析
    </h4>
    <p>
     上述代码存在几处的错误，我们来解释一下：
    </p>
    <p>
     1.输入语句发生错误：
    </p>
    <pre><code class="language-cpp">scanf("%s", arr);</code></pre>
    <p>
     <span style="color:#fe2c24">
      <code>
       %s
      </code>
      读取遇到空格就结束了，所以无法读入整行句子。句子有空格的话，后面的内容根本读不到。
     </span>
    </p>
    <p>
     应改为：
    </p>
    <pre><code class="language-cpp">fgets(arr, sizeof(arr), stdin);</code></pre>
    <p>
     2.英文字母个数，单词个数统计错误：
    </p>
    <p>
     按照上面的写法， 会把非空格的字符都算进去，但
     <span style="color:#fe2c24">
      题目要求只统计
      <strong>
       英文字母
      </strong>
      个数
     </span>
     。 即 如果
     <code>
      s[i]
     </code>
     是换行符
     <code>
      \n
     </code>
     ，也会被统计进去。
    </p>
    <p>
     正确的改法应该是：
    </p>
    <pre><code class="language-cpp">if ( (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') || (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') ) {
    letter_num++;
}</code></pre>
    <p>
     <span style="color:#fe2c24">
      或者用
      <code>
       isalpha(s[i])
      </code>
      。 isalpha() 是标准C库函数，作用是判断字符是否为英文字母（A-Z，a-z）。
     </span>
    </p>
    <p>
     对于
     <span style="color:#fe2c24">
      统计单词个数
     </span>
     ：你要使用上述的这个语句来统计单词个数，得先去掉开头和结尾的空格。
    </p>
    <p>
     或者推荐使用下列的做法：
    </p>
    <pre><code class="language-cpp">bool in_word = false;
for (int i = 0; i &lt; s.size(); i++) {
    if (isalpha(s[i])) {
        if (!in_word) {
            word_num++;
            in_word = true;
        }
    } else if (s[i] == ' ') {
        in_word = false;
    }
}</code></pre>
    <pre>​</pre>
    <h4>
     正确代码
    </h4>
    <pre><code class="language-cpp">#define  _CRT_SECURE_NO_WARNINGS
#include&lt;cstdio&gt;
#include &lt;stdio.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
​
using namespace std;
​
int main() {
    //输入：一行字符串。仅有空格和英文字母构成。 
    char arr[1024];
    string s;
    fgets(arr, sizeof(arr), stdin);
    s = arr;
    //英文字母个数
    int letter_num = 0;
    //单词的个数
    int word_num = 0;
    map&lt;char,int&gt; myMap;
    //处理
    //统计并输出此句子英文字母，单词的个数
    bool in_word = false;//标记是否在单词中
    for (int i = 0; i &lt; s.size(); i++) {
        if (isalpha(s[i])) {
            letter_num++;
            //统一转成小写，再加入myMap
            char ch = tolower(s[i]);
            myMap[ch]++;
            //再统计单词
            if (!in_word) {
                word_num++;
                in_word = true;
            }
        }else if (s[i] == ' ') {
            in_word = false;//遇到空格说明单词结束
       }
    }
    //输出：英文字母的个数
    printf("%d\n", letter_num);
    //输出：单词的个数
    printf("%d\n", word_num);
    //输出：出现次数最多的字母
    map&lt;char,int&gt;::iterator it;
​
    //找到字母出现的最多次数
    int max = 0;
    for (it=myMap.begin(); it != myMap.end(); it++) {
        if (it-&gt;second &gt; max) {
            max = it-&gt;second;
        }
    }
    //找到值为max的所有键
    vector&lt;char&gt;max_letters;
    for (it = myMap.begin(); it != myMap.end(); it++) {
        if (it-&gt;second == max) {
            max_letters.push_back(it-&gt;first);
        }
    }
   //打印输出max_letters数组中的值
    for (int i = 0; i &lt; max_letters.size(); i++) {
        printf("%c ", max_letters[i]);
    }
    printf("\n");
   //打印输出出现最多的字母的出现次数
    printf("%d\n", max);
    return 0;
}</code></pre>
    <p>
    </p>
    <h3>
     <strong>
      浮点数加法
     </strong>
    </h3>
    <h4>
     原作：
    </h4>
    <p>
     输入：有2行，分别表示两个加数num1 num2
    </p>
    <p>
     输出： 一个小数部分不为0的浮点数
    </p>
    <p>
     处理： 求2个浮点数相加的和
    </p>
    <p>
     思路：
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       我们要运算的数已经超过了浮点数精度，称此类问题为高精度计算。
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       此题给的两个数都超过了float和double的精度，所以我们可以把他们表示为两个字符串，进行运算。
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      我们要做的实际上就是用字符串模拟小学时学的竖式计算。
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      1）对齐：把小数点的位置对齐
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      2）先计算右边的小数，即进行小数运算
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      3）再进行左边的整数，即进行整数运算
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      对于运算的过程：从右往左算，且计算的是a+b+进位（carry)%10
     </span>
    </p>
    <p>
     <span style="color:#956fe7">
      对于整数的运算，因为两个加数的位数可能不一样，所以我们要实现i,j分别指向两个加数，我们运算的结束条件是，a没访问完或者b没访问完或者carry==1（即可能存在两个都访问完了，但还有进位的情况，例如11+99，在11和99的岗位都访问完了，还要向前再加一位）
     </span>
    </p>
    <pre><code class="language-cpp">#define  _CRT_SECURE_NO_WARNINGS
#include&lt;cstdio&gt;
#include &lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;
/*
参数:一个字符串a
返回值：a的整数部分
处理：提取a的整数部分
*/
string GetInteger(string a) {
    return a.substr(0, a.find('.'));
}
//提取a的小数部分
string GetFraction(string a) {
    return a.substr(a.find('.') + 1);
}
​
/*
处理：获取小数计算的结果，已经最终的进位
因为返回值只能返回一个，我们要两个结果，故我们都使用引用进行传递。
*/
void FractionPlus(string&amp; res, int&amp; carry, string fa, string fb) {
​
    int size = max(fa.size(), fb.size());
    while (fa.size() &lt; fb.size()) {
        fa.push_back('0');
    }
    while (fb.size() &lt; fa.size()) {
        fb.push_back('0');
    }
    //开始运算
    res.resize(size);//给res申请内存空间
    carry = 0;
    for (int i = size - 1; i &gt;= 0; i--) {
        //'0'='0'
        //'3'='0'+'3'
        if (fa[i] + fb[i] + carry - '0' &gt; '9') {
            res[i] = fa[i] + fb[i] +carry- '0' - 10;
            carry = 1;
        }
        else {
            res[i] = fa[i] + fb[i] + carry - '0';
            carry = 0;
        }
    }
    return;
}
/*
进行整数运算，整数加法运算不需要修改进位值，只需要获取小数运算得到的
进位值
*/
void IntegerPlus(string&amp; res, int carry, string ia,string ib) {
    res.clear();
    for (int i = ia.size() - 1, j = ib.size() - 1; i &gt;= 0 || j &gt;= 0 || carry == 1; --i, --j) {
        //a,b都还没访问完
        if (i &gt;= 0 &amp;&amp; j &gt;= 0) {
            if (ia[i] + ib[j] + carry - '0' &gt; '9') {
                //结果要插入到上一个结果的前面
                res.insert(res.begin(), ia[i] + ib[j] + carry - '0' - 10);
                carry = 1;
            }
            else {
                res.insert(res.begin(), ia[i] + ib[j] + carry - '0');
                carry = 0;
            }
            //只有a的情况           
        }else if (i &gt;= 0 &amp;&amp;j &lt; 0) {
            if (ia[i] + carry &gt; '9') {
                //结果要插入到上一个结果的前面
                res.insert(res.begin(), ia[i] + carry - 10);
                carry = 1;
            }
            else {
                res.insert(res.begin(), ia[i] + carry);
                carry = 0;
            }
        }else if (i &lt; 0 &amp;&amp; j &gt;= 0) {//只有b的情况 
                        if (ib[j] + carry &gt; '9') {
                            //结果要插入到上一个结果的前面
                            res.insert(res.begin(), ib[j] + carry - 10);
                            carry = 1;
                        }else {
                            res.insert(res.begin(), ib[j] + carry);
                            carry = 0;
                         }
         }else { //只有进位
                            res.insert(res.begin(), '1');
                            carry = 0;
                    }
                }
            }
​
​
int main() {
    string a;
    string b;
    char arr1[1024];
    char arr2[1024];
    while (scanf("%s%s", arr1, arr2) != EOF) {
        a = arr1;
        b = arr2;
        string ia = GetInteger(a);
        string ib = GetInteger(b);
        string fa = GetFraction(a);
        string fb = GetFraction(b);
        string fres;
        int carry;
        FractionPlus(fres, carry, fa, fb);
        string ires;
        IntegerPlus(ires, carry, ia, ib);
        string result = ires + '.' + fres;
        printf("%s\n", result.c_str());
    }
    return 0;
}</code></pre>
    <h4>
     <img alt="" height="744" src="https://i-blog.csdnimg.cn/direct/aa0cc4b31ea8448abcbbe448e123e218.png" width="1562"/>
    </h4>
    <h4>
    </h4>
    <h4>
     代码分析
    </h4>
    <p>
     以上代码有一些语法值得我们再次复习。
    </p>
    <p>
     1.字符串操作
    </p>
    <pre><code class="language-cpp">a.find('.');//找到字符串中第一次出现 . 的位置，返回下标。如果找不到，返回 string::npos
a.substr(0, pos)//从下标 0 开始，截取 pos 长度的子串</code></pre>
    <p>
     <span style="color:#fe2c24">
      2.max() 是 C++ 标准库 &lt;algorithm &gt; 中的函数，用来返回两个值中的较大值。
     </span>
    </p>
    <h3>
     知识点
    </h3>
    <h4>
     将大写字母转为小写字母的方式
    </h4>
    <p>
     <span style="color:#fe2c24">
      用tolower() 或者使用ASCII码
     </span>
    </p>
    <p>
     <code>
      tolower()
     </code>
     是 C 标准库
     <code>
      里的函数
     </code>
    </p>
    <pre><code class="language-cpp">#include &lt;cctype&gt;
​
char lower = tolower('A'); // 结果是 'a'
​</code></pre>
    <p>
     在 ASCII 表中：
    </p>
    <ul>
     <li>
      <p>
       大写字母
       <code>
        'A'
       </code>
       到
       <code>
        'Z'
       </code>
       的值是
       <code>
        65 ~ 90
       </code>
      </p>
     </li>
     <li>
      <p>
       小写字母
       <code>
        'a'
       </code>
       到
       <code>
        'z'
       </code>
       的值是
       <code>
        97 ~ 122
       </code>
      </p>
     </li>
     <li>
      <p>
       <span style="color:#fe2c24">
        大小写之间的差值是
        <strong>
         32
        </strong>
       </span>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') {
    ch += 32;
}</code></pre>
    <h4>
     字符形式进行十进制运算的原理
    </h4>
    <p>
     现在我们想以字符形式进行十进制运算。
    </p>
    <p>
     字符
     <code>
      '0'
     </code>
     ~
     <code>
      '9'
     </code>
     在 ASCII 表中对应十进制数值 48~57。故 '3' + '6' = 51 + 54 = 105；在十进制运算中3 + 6 = 9；显然，9的ASCII码不是105，故我们不能简单的将两个字符相加来实现。那该怎么办？
    </p>
    <p>
     ==》因为字符和十进制数字的关系有字符 - '0' = 对应的十进制数字
    </p>
    <p>
     <span style="color:#fe2c24">
      如果你要对两个字符表示的数字相加（模拟竖式加法），你需要先把它们转换成数字再相加：
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      ('3' - '0') + ('6' - '0') = 3 + 6 = 9
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      在上面的案例中，你可以看作 fa[i] - '0' 得到数字，fb[i] - '0' 得到数字，
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      然后数字相加，最后 + '0' 变回字符存进 res[i]
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      所以我们可以直接合并表示为fa[i] + fb[i] + carry - '0'
     </span>
    </p>
    <p>
     另外为什么可以与'9'表示，因为fa[i] + fb[i] + carry - '0' 这个结果是字符形式的，而在字符表示下：最大个位数字是 '9'（ASCII 57），如果 这个结果大于'9'，也就对应了数字运算中的结果大于9，也就是竖式加法里的“要进位”条件。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35343934363038382f:61727469636c652f64657461696c732f313436313139303531" class_="artid" style="display:none">
 </p>
</div>


