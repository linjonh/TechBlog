---
layout: post
title: "JVM垃圾回收面试题及原理"
date: 2025-03-09 22:32:12 +0800
description: "介绍对象什么时候可以被垃圾器回收、垃圾回收算法、JVM中的分代回收、垃圾回收器、强引用、软引用、弱引用、虚引用的区别的原理及相关面试题"
keywords: "JVM垃圾回收面试题及原理"
categories: ['未分类']
tags: ['开发语言', 'Jvm', 'Java']
artid: "146140097"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146140097
    alt: "JVM垃圾回收面试题及原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146140097
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146140097
cover: https://bing.ee123.net/img/rand?artid=146140097
image: https://bing.ee123.net/img/rand?artid=146140097
img: https://bing.ee123.net/img/rand?artid=146140097
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM垃圾回收面试题及原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="1__0">
     </a>
     1. 对象什么时候可以被垃圾器回收
    </h2>
    <p>
     如果一个或多个对象没有
     <strong>
      任何的引用指向它
     </strong>
     了，那么这个对象现在就是
     <strong>
      垃圾
     </strong>
     ，如果定位了垃圾，则有可能会被
     <strong>
      垃圾回收器
     </strong>
     回收
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fe5f9dafdbce4e36bae6cb3599e66c76.png"/>
    </p>
    <p>
     如果要定位什么是垃圾，有两种方式来确定
    </p>
    <ul>
     <li>
      <strong>
       引用计数法
      </strong>
     </li>
     <li>
      <strong>
       可达性分析算法
      </strong>
     </li>
    </ul>
    <h3>
     <a id="11__7">
     </a>
     1.1 引用计数法
    </h3>
    <h4>
     <a id="111__8">
     </a>
     1.1.1 原理
    </h4>
    <pre><code class="prism language-java"><span class="token class-name">String</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/48d47f716e6c4b66a878c398c1bb7094.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token class-name">String</span> demo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3cf776c29fff4d3b9c8e1c07a060eb39.png"/>
    </p>
    <h4>
     <a id="112__19">
     </a>
     1.1.2 局限
    </h4>
    <p>
     创建实例，互相调用
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">Demo</span> instance<span class="token punctuation">;</span>
<span class="token class-name">String</span> name<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">(</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
｝
<span class="token class-name">Demo</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span>（<span class="token string">"a"</span>）；
<span class="token class-name">Demo</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span>（"b™）；
a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/15704c842503401ca2f0dbf4cf82c07e.png"/>
    </p>
    <p>
     设置a,b为null，互相引用导致ref=1，循环引用，会引发
     <strong>
      内存泄露
     </strong>
    </p>
    <pre><code class="prism language-java">a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/98e734c40ee6480ead7acb113e0293b1.png"/>
    </p>
    <h3>
     <a id="12__43">
     </a>
     1.2 可达性分析算法
    </h3>
    <p>
     现在的虚拟机
     <strong>
      采用的都是通过可达性分析算法
     </strong>
     来确定哪些内容是垃圾。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f02ea1fc5b424d438b2e6096f4d7beb5.png"/>
    </p>
    <p>
     X，Y这两个节点是可回收的
    </p>
    <ul>
     <li>
      Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
     </li>
     <li>
      扫描堆中的对象，看是否能够沿着GC Root 对象为起点的引用链找到该对象，找不到，表示可以回收
     </li>
    </ul>
    <h4>
     <a id="121_GC_Root_50">
     </a>
     1.2.1 哪些对象可以作为GC Root
    </h4>
    <ul>
     <li>
      虚以机栈（栈帧中的本地变量表）中引用的对象
     </li>
    </ul>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">Stringll</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">Demo</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
demo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
｝
</code></pre>
    <ul>
     <li>
      方法区中类静态属性引用的对象
     </li>
    </ul>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Demo</span> a<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">Stringl</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">Demo</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
｝
</code></pre>
    <ul>
     <li>
      方法区中常量引用的对象
     </li>
    </ul>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Demo</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">Demo</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">;</span>
demo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
｝
</code></pre>
    <ul>
     <li>
      本地方法栈中JNI（即一般说的Native 方法）引用的对象
     </li>
    </ul>
    <h2>
     <a id="2__77">
     </a>
     2. 垃圾回收算法
    </h2>
    <h3>
     <a id="21__78">
     </a>
     2.1 标记清除算法
    </h3>
    <h4>
     <a id="211__79">
     </a>
     2.1.1 原理
    </h4>
    <p>
     标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。
    </p>
    <ol>
     <li>
      根据可达性分析算法得出的垃圾进行标记
     </li>
     <li>
      对这些标记为可回收的内容进行垃圾回收
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f9b23c9b1ceb4462a9135f06152b85f8.png"/>
     </li>
    </ol>
    <h4>
     <a id="212__85">
     </a>
     2.1.2 局限
    </h4>
    <ul>
     <li>
      优点：标记和清除速度较快
     </li>
     <li>
      缺点：碎片化较为严重，内存不连贯的
      <br/>
      内存分配碎片化对数组存储不友好（数组占用连续的储存空间，难存储大数组）
     </li>
    </ul>
    <h3>
     <a id="22_%EF%BB%BF_89">
     </a>
     2.2 ﻿标记整理算法
    </h3>
    <p>
     优缺点同标记清除算法，
     <strong>
      解决了标记清除算法的碎片化
     </strong>
     的问题，同时，标记压缩算法多了一步，
     <strong>
      对象移动内存位置的步骤
     </strong>
     ，
     <strong>
      其效率也有有一定的影响
     </strong>
     。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/583583eb7ab84deea3cb5a8c46f668df.png"/>
    </p>
    <h3>
     <a id="23_%EF%BB%BF_93">
     </a>
     2.3 ﻿复制算法
    </h3>
    <ul>
     <li>
      优点：
      <ol>
       <li>
        在垃圾对象多的情况下，效率较高
       </li>
       <li>
        清理后，内存无碎片
       </li>
      </ol>
     </li>
     <li>
      缺点：
      <ol>
       <li>
        分配的2块内存空间，在同一个时刻，只能使用一半，
        <strong>
         内存使用率较低
        </strong>
        (一般
        <strong>
         新生代的垃圾回收器
        </strong>
        会用
        <strong>
         复制算法
        </strong>
        )
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4062faa985ca4902b19e7d5fb089a3bb.png"/>
       </li>
      </ol>
     </li>
    </ul>
    <h2>
     <a id="3_JVM_101">
     </a>
     3. JVM中的分代回收
    </h2>
    <p>
     在java8时，堆被分为了两份：新生代和老年代（数量1:2）
     <br/>
     对于新生代，内部又被分为了三个区域。
    </p>
    <ul>
     <li>
      伊甸园区Eden，新生的对象都分配到这里
     </li>
     <li>
      幸存者区survivor（分成from和to）
     </li>
     <li>
      Eden区, from区, to区（8: 1: 1）
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b6de853e7da94ed6a11af22c7dd89746.png"/>
     </li>
    </ul>
    <h3>
     <a id="31__109">
     </a>
     3.1 工作机制
    </h3>
    <ul>
     <li>
      新创建的对象，都会先分配到eden区
     </li>
     <li>
      当伊甸园内存不足，标记伊甸园与from（现阶段没有）的存活对象
     </li>
     <li>
      将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放
     </li>
     <li>
      经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区
     </li>
     <li>
      当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）
     </li>
    </ul>
    <h3>
     <a id="32_MinorGC_Mixed_GC_FullGC_115">
     </a>
     3.2 MinorGC、 Mixed GC、 FullGC的区别
    </h3>
    <p>
     <strong>
      STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成
     </strong>
    </p>
    <ul>
     <li>
      MinorGC【young GC】发生在
      <strong>
       新生代
      </strong>
      的垃圾回收，
      <strong>
       暂停时间短
      </strong>
      （STW）
     </li>
     <li>
      Mixed GC
      <strong>
       新生代+老年代部分
      </strong>
      区域的垃圾回收，G1 收集器特有
     </li>
     <li>
      FulIGC：
      <strong>
       新生代＋老年代完整
      </strong>
      垃圾回收，
      <strong>
       暂停时间长
      </strong>
      （STW），应尽力避免（只有新生代和老年代内存完全不足的时候）
     </li>
    </ul>
    <h2>
     <a id="4__120">
     </a>
     4. 垃圾回收器
    </h2>
    <p>
     在jvm中，实现了多种垃圾收集器，包括：
    </p>
    <ul>
     <li>
      串行垃圾收集器
     </li>
     <li>
      并行垃圾收集器
     </li>
     <li>
      CMS（并发）垃圾收集器
     </li>
     <li>
      G1垃圾收集器
     </li>
    </ul>
    <h3>
     <a id="41__126">
     </a>
     4.1 串行垃圾收集器
    </h3>
    <p>
     Serial和Serial Old串行垃圾收集器，是指使用
     <strong>
      单线程
     </strong>
     进行
     <strong>
      垃圾回收
     </strong>
     ，堆内存较小，适合
     <strong>
      个人电脑
     </strong>
    </p>
    <ul>
     <li>
      Serial 作用于新生代，采用
      <strong>
       复制算法
      </strong>
     </li>
     <li>
      Serial Old 作用于老年代，采用
      <strong>
       标记-整理算法
      </strong>
      <br/>
      垃圾回收时，
      <strong>
       只有一个线程在工作
      </strong>
      ，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c82dd324176542b1952e131a228b2078.png"/>
     </li>
    </ul>
    <h3>
     <a id="42__133">
     </a>
     4.2 并行垃圾收集器
    </h3>
    <p>
     Parallel New和Parallel Old是一个
     <strong>
      并行
     </strong>
     垃圾回收器，
     <strong>
      JDK8默认使用此垃圾回收器
     </strong>
    </p>
    <ul>
     <li>
      Parallel New作用于新生代，采用
      <strong>
       复制算法
      </strong>
     </li>
     <li>
      Parallel Old作用于老年代，采用
      <strong>
       标记-整理算法
      </strong>
      <br/>
      垃圾回收时，
      <strong>
       多个线程在工作
      </strong>
      ，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5fa3d0c40d6445d69eb630291ba944a9.png"/>
     </li>
    </ul>
    <h3>
     <a id="43_CMS_140">
     </a>
     4.3 CMS（并发）垃圾收集器
    </h3>
    <p>
     CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对
     <strong>
      老年代垃圾回收
     </strong>
     的，是一款以获取
     <strong>
      最短回收停顿时
     </strong>
     间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c3a87ea0a2d14b0ebc8567761c28f802.png"/>
    </p>
    <p>
     初始标记是GC Roots连接的，并发标记是下面所有的节点。
     <br/>
     重新标记（像检查是否有错题）是检测是否有新连接的或有新垃圾节点出现。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9b699032b5284730bafadf68a47e4f1f.png"/>
    </p>
    <h3>
     <a id="44_G1_149">
     </a>
     4.4 G1垃圾收集器
    </h3>
    <p>
     <strong>
      应用于新生代和老年代，在JDK9之后默认使用G1
     </strong>
    </p>
    <ul>
     <li>
      应用于新生代和老年代，在JDK9之后默认使用G1
     </li>
     <li>
      划分成多个区域，每个区域都可以充当 eden，survivor， old，humongous（其中 humongous 专为大对象准备）
     </li>
     <li>
      采用复制算法
     </li>
     <li>
      响应时间与吞吐量兼顾
     </li>
     <li>
      分成三个阶段：新生代回收、并发标记、混合收集
     </li>
     <li>
      如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0106c07cc7bf448fa9d11c0a353d52e3.png"/>
     </li>
    </ul>
    <h4>
     <a id="441_Young_Collection_159">
     </a>
     4.4.1 Young Collection（年轻代垃圾回收）
    </h4>
    <ul>
     <li>
      随着时间流逝，伊甸园的内存又有不足
     </li>
     <li>
      将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e98b6970ab584e5895c540aee56cbe43.png"/>
     </li>
    </ul>
    <h4>
     <a id="442_Young_Collection__Concurrent_Mark_164">
     </a>
     4.4.2 Young Collection + Concurrent Mark（年轻代垃圾回收+并发标记）
    </h4>
    <p>
     当老年代占用内存超过阈值（默认是45%）后，触发并发标记，这时无需暂停用户线程
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c754765ff8434105b4b1f38a78ab712e.png"/>
    </p>
    <ul>
     <li>
      并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。
     </li>
     <li>
      这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）
     </li>
    </ul>
    <h4>
     <a id="443_Mixed_Collection_170">
     </a>
     4.4.3 Mixed Collection（混合垃圾回收）
    </h4>
    <p>
     混合收集阶段中，参与复制的有 eden、survivor、old
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8de95d96a882488db019f9da73e8b706.png"/>
    </p>
    <p>
     复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集
    </p>
    <h2>
     <a id="5__175">
     </a>
     5. 强引用、软引用、弱引用、虚引用的区别
    </h2>
    <h3>
     <a id="51__176">
     </a>
     5.1 强引用
    </h3>
    <p>
     只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收
     <br/>
     内存溢出OOM也不会垃圾回收强引用的对象。
    </p>
    <pre><code class="prism language-java"><span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5120d4c4d8c04adc811cfe9a97d44136.png"/>
    </p>
    <h3>
     <a id="52__184">
     </a>
     5.2 软引用
    </h3>
    <p>
     仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收
    </p>
    <pre><code class="prism language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2d3561640ece43248d0444006a01f87f.png"/>
    </p>
    <h3>
     <a id="53__192">
     </a>
     5.3 弱引用
    </h3>
    <p>
     仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象
    </p>
    <pre><code class="prism language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/112385639e4942c4abff4529c038120e.png"/>
    </p>
    <h3>
     <a id="54__200">
     </a>
     5.4 虚引用
    </h3>
    <p>
     <strong>
      必须配合引用队列使用
     </strong>
     ，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存
    </p>
    <pre><code class="prism language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ReferenceQueue</span> referenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span> <span class="token punctuation">(</span>user<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/423db620d46643459dca21dd58b47275.png"/>
    </p>
    <p>
     除了释放user对象，还要释放虚引用对象所关联的一些外部资源——可能是一些外部资源（不是java占用的、也不是java内存，可能是直接内存等…），这些等java对象被回收掉后再释放。所以要把虚拟对象先记录在引用队列中，先记住被回收的对象，后面直接找队列就可以了（释放的时候有专门的线程：Reference Handler）
    </p>
    <ul>
     <li>
      软引用和弱引用也可以通过引用队列释放相关资源
     </li>
    </ul>
    <h3>
     <a id="55__211">
     </a>
     5.5 区别
    </h3>
    <ul>
     <li>
      强引用：只要所有 GC Roots 能找到，就不会被回收
     </li>
     <li>
      软引用：需要配合SofiReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象
     </li>
     <li>
      弱引用：需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收
     </li>
     <li>
      虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f38313035393631362f:61727469636c652f64657461696c732f313436313430303937" class_="artid" style="display:none">
 </p>
</div>


