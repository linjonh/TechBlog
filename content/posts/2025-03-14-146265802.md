---
layout: post
title: "日志Python安全之SSTIFlaskJinja2"
date: 2025-03-14 23:36:57 +0800
description: "ssti的概念和模板引擎介绍等基础知识前面已经学过了，接下来直接进入正题。"
keywords: "日志Python安全之SSTI——Flask/Jinja2"
categories: ['未分类']
tags: ['后端', 'Python', 'Flask']
artid: "146265802"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146265802
    alt: "日志Python安全之SSTIFlaskJinja2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146265802
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146265802
cover: https://bing.ee123.net/img/rand?artid=146265802
image: https://bing.ee123.net/img/rand?artid=146265802
img: https://bing.ee123.net/img/rand?artid=146265802
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     日志Python安全之SSTI——Flask/Jinja2
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     ssti的概念和模板引擎介绍等基础知识前面已经学过了，接下来直接进入正题
    </p>
    <h2>
     先了解flask/jinja2：
    </h2>
    <h3>
     flask：
    </h3>
    <p>
     用python编写的一个框架，集成 Jinja2 模板引擎（用于动态生成 HTML 内容）。
    </p>
    <p>
     Flask 的核心组件：
    </p>
    <p>
     （1）路由：路由是 Web 应用程序中的一个机制，用于
     <span style="background-color:#ff9900">
      将
     </span>
     HTTP请求如
     <code>
      GET
     </code>
     、
     <code>
      POST
     </code>
     等的
     <span style="background-color:#ff9900">
      URL 路径与
     </span>
     后端的处理逻辑（通常是
     <span style="background-color:#ff9900">
      Python 函数
     </span>
     ）
     <span style="background-color:#ff9900">
      关联起来
     </span>
     ,在 Flask 中，路由通过装饰器
     <code>
      @app.route()
     </code>
     来定义。找个代码解释：
    </p>
    <p>
     基本路由：
    </p>
    <pre><code>from flask import Flask

app = Flask(__name__)

# 定义路由
@app.route('/')
def home():
    return "Hello, World!"

@app.route('/about')
def about():
    return "This is the about page."</code></pre>
    <p>
     @app.route('/')：将‘/’目录，映射到home函数，也就是当用户访问：
     <code>
      http://localhost:5000/
     </code>
     时，Flask 会调用home函数，并返回"Hello, World!"。
    </p>
    <p>
     @app.route('/about')：同理
    </p>
    <p>
     动态路由：
    </p>
    <pre><code>@app.route('/user/&lt;username&gt;')
def show_user_profile(username):
    return f"User: {username}"</code></pre>
    <p>
     &lt;username&gt;：动态部分，可以匹配任意字符串。
    </p>
    <p>
     当用户访问
     <code>
      http://localhost:5000/user/john
     </code>
     时，username的值会是‘john’，Flask 会调用 show_user_profile 函数并返回“User:john”。
    </p>
    <p>
     指定 HTTP 方法：
    </p>
    <p>
     默认情况下，路由只响应
     <code>
      GET
     </code>
     请求。但是可以通过‘methods'参数指定路由支持的 HTTP 方法。
    </p>
    <pre><code>@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        return "Login submitted!"
    else:
        return "Show login form."</code></pre>
    <p>
     GET请求访问/login时，返回登录表单，post请求提交表单时，返回Login submitted!
    </p>
    <p>
     （2）请求和响应
    </p>
    <p>
     Flask 提供了 request 对象来访问 HTTP 请求数据，以及 make_response 函数来生成 HTTP 响应。
    </p>
    <p>
     request对象中常用的属性：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性/方法
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         request.method
        </code>
       </td>
       <td>
        获取 HTTP 请求方法（如
        <code>
         GET
        </code>
        、
        <code>
         POST
        </code>
        等）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.url
        </code>
       </td>
       <td>
        获取完整的请求 URL（如
        <code>
         http://example.com/path?query=value
        </code>
        ）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.path
        </code>
       </td>
       <td>
        获取 URL 的路径部分（如
        <code>
         /path
        </code>
        ）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.args
        </code>
       </td>
       <td>
        获取 URL 中的查询参数（
        <code>
         GET
        </code>
        请求的参数），返回一个字典。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.form
        </code>
       </td>
       <td>
        获取表单数据（
        <code>
         POST
        </code>
        请求的数据），返回一个字典。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.json
        </code>
       </td>
       <td>
        获取 JSON 格式的请求体（适用于
        <code>
         POST
        </code>
        或
        <code>
         PUT
        </code>
        请求）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.headers
        </code>
       </td>
       <td>
        获取请求的头部信息，返回一个字典。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.cookies
        </code>
       </td>
       <td>
        获取客户端发送的 Cookies，返回一个字典。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.files
        </code>
       </td>
       <td>
        获取上传的文件，返回一个字典。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         request.remote_addr
        </code>
       </td>
       <td>
        获取客户端的 IP 地址。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     默认情况下，视图函数返回的字符串会被 Flask 包装成一个 HTTP 响应，状态码为200 OK，内容类型为text/html
    </p>
    <p>
     使用
     <code>
      make_response
     </code>
     自定义响应
     <code>
      ，make_response
     </code>
     的第一个参数是响应内容，第二个参数是状态码，并且可以通过
     <code>
      response.headers
     </code>
     设置响应头部。找到一个常规代码参考：
    </p>
    <pre><code>from flask import Flask, request, make_response

app = Flask(__name__)

@app.route('/greet')
def greet():
    name = request.args.get('name', 'Guest')  # 获取 URL 参数
    response = make_response(f"Hello, {name}!")  # 生成响应
    response.set_cookie('username', name)  # 设置 Cookie
    return response</code></pre>
    <p>
     相应里还有一些设置cookie，返回文件啥的，看这个文章吧：
     <a class="link-info" href="https://blog.csdn.net/2401_88743143/article/details/146267602?sharetype=blogdetail&amp;sharerId=146267602&amp;sharerefer=PC&amp;sharesource=2401_88743143&amp;sharefrom=mp_from_link" title="https://blog.csdn.net/2401_88743143/article/details/146267602?sharetype=blogdetail&amp;sharerId=146267602&amp;sharerefer=PC&amp;sharesource=2401_88743143&amp;sharefrom=mp_from_link">
      https://blog.csdn.net/2401_88743143/article/details/146267602?sharetype=blogdetail&amp;sharerId=146267602&amp;sharerefer=PC&amp;sharesource=2401_88743143&amp;sharefrom=mp_from_link
     </a>
    </p>
    <p>
     （3）模板渲染
    </p>
    <p>
     Flask 默认使用 Jinja2 模板引擎来渲染 HTML 模板。通过
     <code>
      render_template
     </code>
     函数，可以将动态数据传递给模板并生成最终的 HTML。
    </p>
    <pre><code>from flask import Flask, render_template

app = Flask(__name__)

@app.route('/hello')
def hello():
    name = "World"
    return render_template('hello.html', name=name)</code></pre>
    <p>
     在
     <code>
      templates/hello.html
     </code>
     文件中：
    </p>
    <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello, {<!-- -->{ name }}!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
    <p>
    </p>
    <h3>
     Jinja2 模板引擎：
    </h3>
    <p>
    </p>
    <p>
     （1）Jinja2 的基本语法：
    </p>
    <ul>
     <li>
      <p>
       变量：
       <code>
        {
        <!-- -->
        { variable }}
       </code>
      </p>
     </li>
     <li>
      <p>
       控制结构：
       <code>
        {% ... %}
       </code>
       ，支持条件判断、循环等。
      </p>
     </li>
     <li>
      <p>
       过滤器：
       <code>
        {
        <!-- -->
        { variable|filter }}
       </code>
       ，用于对变量进行处理。
      </p>
     </li>
     <li>
      <p>
       注释：用
       <code>
        {# ... #}
       </code>
       表示，注释内容不会被渲染。
      </p>
     </li>
    </ul>
    <p>
     偷个代码方便分析：
    </p>
    <p>
     应用示例:
    </p>
    <pre><code>from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def home():
    # 定义上下文数据
    context = {
        'title': 'Home Page',
        'name': 'John',
        'is_student': True
    }
    # 渲染模板并返回响应
    return render_template('home.html', **context)

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
    <p>
     模板文件:在templates/home.html文件中：
    </p>
    <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{<!-- -->{ title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello, {<!-- -->{ name }}!&lt;/h1&gt;
    {% if is_student %}
        &lt;p&gt;You are a student.&lt;/p&gt;
    {% else %}
        &lt;p&gt;You are not a student.&lt;/p&gt;
    {% endif %}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
    <p>
     {
     <!-- -->
     { title }}会被替换为'Home Page'。{
     <!-- -->
     { name }}会被替换为'John'。根据is_student的值，显示不同的内容。
    </p>
    <h2>
     好了，继续深入了解一下吧：
    </h2>
    <h3>
     下面是一些基础的魔术方法：
    </h3>
    <ul>
     <li>
      <code>
       __class__：
      </code>
      返回对象所属的类。
     </li>
    </ul>
    <pre><code>s = "hello"
print(s.__class__)  # 输出: &lt;class 'str'&gt;</code></pre>
    <ul>
     <li>
      <code>
       __bases__：
      </code>
      以元组的形式返回一个类直接继承的父类。
     </li>
    </ul>
    <pre><code>class A:
    pass

class B(A):
    pass

print(B.__bases__)  # 输出: (&lt;class '__main__.A'&gt;,)</code></pre>
    <p>
     B继承自 A，所以B.__bases__返回(&lt;class '__main__.A'&gt;,)。
    </p>
    <ul>
     <li>
      <code>
       __mro__：
      </code>
      返回方法解析顺序（Method Resolution Order, MRO），即类继承的顺序。
     </li>
    </ul>
    <pre><code>class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(C.__mro__)
# 输出: (&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</code></pre>
    <p>
     C.__mro__返回从C到object的继承链。
    </p>
    <ul>
     <li>
      <code>
       __subclasses__()：
      </code>
      返回一个类的所有直接子类。
     </li>
    </ul>
    <pre><code>class A:
    pass

class B(A):
    pass

class C(A):
    pass

print(A.__subclasses__())
# 输出: [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;]</code></pre>
    <p>
     A.__subclasses__()返回
     <code>
      A
     </code>
     的所有直接子类
     <code>
      B
     </code>
     和
     <code>
      C
     </code>
     。
    </p>
    <ul>
     <li>
      <code>
       __init__
      </code>
      ：在创建类的对象时自动调用，即初始化对象时调用，用于设置对象的初始状态。
      <pre><code>class Person:
    def __init__(self, name):
        self.name = name

p = Person("John")
print(p.name)  # 输出: John</code></pre>
      <p>
       __init__方法在创建Person对象时被调用，用于初始化name属性。
      </p>
     </li>
    </ul>
    <blockquote>
     <p>
      代码解释：
     </p>
     <ul>
      <li>
       <p>
        <code>
         self
        </code>
        是一个指向当前对象的引用，用于访问对象的属性和方法。
       </p>
      </li>
      <li>
       <p>
        <code>
         name
        </code>
        是一个参数，表示创建对象时需要传递的名字。
       </p>
      </li>
      <li>
       <p>
        <code>
         self.name = name
        </code>
        将传递的
        <code>
         name
        </code>
        参数赋值给对象的
        <code>
         name
        </code>
        属性。
       </p>
      </li>
     </ul>
    </blockquote>
    <ul>
     <li>
      <code>
       __globals__
      </code>
      ：返回函数所在命名空间的全局变量字典。
     </li>
    </ul>
    <pre><code>x = 10

def foo():
    y = 20
    print(foo.__globals__)

foo()
# 输出: {'x': 10, ...（其他全局变量）}</code></pre>
    <p>
     <code>
      foo.__globals__
     </code>
     返回
     <code>
      foo
     </code>
     函数所在模块的全局变量字典。
    </p>
    <h3 id="dd45d1a3f275719b76208d37a6f2bd0a">
     注入思路|payload
    </h3>
    <p>
     感觉这个好麻烦ing
    </p>
    <p id="b9b7ab5aaa8252898ff289bdb524bdd6">
     注入思路：随便找一个内置类对象用
     <code>
      __class__
     </code>
     拿到他所对应的类，用
     <code>
      __bases__
     </code>
     拿到基类（
     <code>
      &lt;class 'object'&gt;
     </code>
     ），用
     <code>
      __subclasses__()
     </code>
     拿到子类列表，在子类列表中直接寻找可以利用的类getshell
    </p>
    <pre><code>''.__class__.__bases__[0].__subclasses__()
().__class__.__mro__[2].__subclasses__()
request.__class__.__mro__[1]</code></pre>
    <p>
     接下来只要找到能够利用的类（方法、函数）就好了：
    </p>
    <p id="bce3b3deedb5858e62349bfb01f4994d">
     找可利用的类（脚本）：
    </p>
    <pre><code>from flask import Flask,request
from jinja2 import Template
search = 'eval'   
num = -1
for i in ().__class__.__bases__[0].__subclasses__():
    num += 1
    try:
        if search in i.__init__.__globals__.keys():
            print(i, num)
    except:
        pass</code></pre>
    <p>
     这个里面大哥总结了许多python2、python3通用payload：
     <a href="https://xz.aliyun.com/news/7341?time__1311=YqfxgiDt5eq05DK5qCqGKK4Qwtxjh2u8bD&amp;u_atoken=9664eb0ebd7cdbb8b7bb128aec035d0f&amp;u_asig=1a0c399b17419533867796649e0111#toc-10" rel="nofollow" title="https://xz.aliyun.com/news/7341?time__1311=YqfxgiDt5eq05DK5qCqGKK4Qwtxjh2u8bD&amp;u_atoken=9664eb0ebd7cdbb8b7bb128aec035d0f&amp;u_asig=1a0c399b17419533867796649e0111#toc-10">
      https://xz.aliyun.com/news/7341?time__1311=YqfxgiDt5eq05DK5qCqGKK4Qwtxjh2u8bD&amp;u_atoken=9664eb0ebd7cdbb8b7bb128aec035d0f&amp;u_asig=1a0c399b17419533867796649e0111#toc-10
     </a>
    </p>
    <p>
     <a href="https://cloud.tencent.com/developer/article/1637529" rel="nofollow" title="Python安全之SSTI——Flask/Jinja2-腾讯云开发者社区-腾讯云">
      Python安全之SSTI——Flask/Jinja2-腾讯云开发者社区-腾讯云
     </a>
    </p>
    <h2>
     好吧做个例题巩固一下
    </h2>
    <h3>
     [WesternCTF2018]shrine
    </h3>
    <p>
     <img alt="" height="1097" src="https://i-blog.csdnimg.cn/direct/0ef3ed4d468a4bccaf4fc1a6f6f5be1a.png" width="2559"/>
    </p>
    <p>
     分析代码， app.config['FLAG'] = os.environ.pop('FLAG')这段代码将FLAG存储到 app.config里并且从环境变量里删除它，@app.route('/shrine/') def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self']，这是一个过滤，先将所有的（）替换成‘ ’，然后绕过直接出现'config', 'self'，所以需要间接访问，最后渲染，因为将FLAG放到了app.config中，所以需要访问config
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     构造payload：
    </p>
    <pre><code>/shrine/{<!-- -->{url_for.__globals__['current_app'].config['FLAG']}}</code></pre>
    <p>
     <span style="background-color:#ff9900">
      访问
     </span>
     <code>
      <span style="background-color:#ff9900">
       /shrine/
      </span>
     </code>
     <span style="background-color:#ff9900">
      路径时
     </span>
     ，Flask 会调用
     <code>
      shrine
     </code>
     函数来处理请求
     <code>
      ，shrine
     </code>
     函数会将用户输入作为模板字符串渲染，从而
     <span style="background-color:#ff9900">
      触发服务器端模板注入（SSTI）漏洞
     </span>
     。
    </p>
    <blockquote>
     <p>
      了解了一下payload的执行进程：
     </p>
     <p>
      <strong>
       <code>
        url_for
       </code>
      </strong>
      ：
     </p>
     <p>
      <code>
       url_for
      </code>
      是 Flask 的一个全局函数，用于生成 URL。
     </p>
     <p>
      <code>
       url_for.__globals__
      </code>
      返回
      <code>
       url_for
      </code>
      函数所在模块的全局变量字典。
     </p>
     <p>
     </p>
     <p>
      <strong>
       <code>
        url_for.__globals__['current_app']
       </code>
      </strong>
      ：
     </p>
     <p>
      <code>
       current_app
      </code>
      是 Flask 的一个全局变量，指向当前的 Flask 应用实例。
     </p>
     <p>
      通过
      <code>
       url_for.__globals__['current_app']
      </code>
      ，可以获取当前的 Flask 应用实例。
     </p>
     <p>
     </p>
     <p>
      <strong>
       <code>
        current_app.config['FLAG']
       </code>
      </strong>
      ：
     </p>
     <p>
      <code>
       current_app.config
      </code>
      是 Flask 应用的配置字典。
     </p>
     <p>
      <code>
       current_app.config['FLAG']
      </code>
      获取配置项
      <code>
       FLAG
      </code>
      的值。
     </p>
    </blockquote>
    <p>
     当时不理解payload里也有config为啥也能绕过，搜了一下知道了黑名单的局限性：
    </p>
    <p>
     黑名单机制只会将 直接出现的
     <code>
      config
     </code>
     替换为
     <code>
      None
     </code>
     。在这个 Payload 中，
     <code>
      config
     </code>
     并不是直接出现的，而是通过
     <code>
      url_for.__globals__['current_app'].config
     </code>
     访问的。黑名单机制无法检测到这种
     <span style="background-color:#ff9900">
      用全局函数间接访问
     </span>
     方式。
     <img alt="" height="1420" src="https://i-blog.csdnimg.cn/direct/ae51d88297e84928ac510d5e9c457da2.png" width="2139"/>
    </p>
    <p>
    </p>
    <p>
     最后得到flag
    </p>
    <p>
     看别人的wp还用了一种payload
    </p>
    <pre><code>/shrine/{<!-- -->{get_flashed_messages.__globals__['current_app'].config['FLAG']}}</code></pre>
    <blockquote>
     <p>
      <code>
       get_flashed_messages
      </code>
      是 Flask 的一个全局函数，用于获取闪现消息（flashed messages）。闪现消息是 Flask 中用于在请求之间传递消息的一种机制。
     </p>
     <p>
      通过
      <code>
       get_flashed_messages.__globals__
      </code>
      ，可以访问 Flask 应用的全局变量。
     </p>
     <p>
     </p>
    </blockquote>
    <p>
     自己写payload还是difficult滴，但是感觉没太用到上面的方法，还是得多做点题，多分析大佬们构造的payload
    </p>
    <p>
     其他：这个对有些模块的解释还是不错的
     <a href="https://blog.csdn.net/qq_35493457/article/details/119938852?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=119938852&amp;sharerefer=PC&amp;sharesource=2401_88743143&amp;sharefrom=from_link" title="CTF_Web：从0学习Flask模板注入（SSTI）_ctf flask-CSDN博客">
      CTF_Web：从0学习Flask模板注入（SSTI）_ctf flask-CSDN博客
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38383734333134332f:61727469636c652f64657461696c732f313436323635383032" class_="artid" style="display:none">
 </p>
</div>


