---
layout: post
title: "User类CRUD实现"
date: 2025-09-11T19:48:42+0800
description: "本文介绍了基于Spring Boot的MVC架构实现用户管理系统的技术要点。系统采用Lombok简化实体类开发，使用@Data、@EqualsAndHashCode等注解自动生成方法；通过MyBatis-Plus实现数据库操作，包括@TableName等注解映射。MVC架构分为User实体类、UserMapper接口、UserService服务层及UserController控制器。控制器提供完整的RESTful API，支持用户CRUD操作和状态变更，使用@PathVariable、@RequestBod"
keywords: "User类CRUD实现"
categories: ['未分类']
tags: ['笔记', '数据库', 'Spring', 'Mysql', 'Mybatis', 'Boot']
artid: "151587056"
arturl: "https://blog.csdn.net/WYyanyufei/article/details/151587056"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151587056
    alt: "User类CRUD实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151587056
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151587056
cover: https://bing.ee123.net/img/rand?artid=151587056
image: https://bing.ee123.net/img/rand?artid=151587056
img: https://bing.ee123.net/img/rand?artid=151587056
---



# User类CRUD实现

![](https://i-operation.csdnimg.cn/images/cf31225e169b4512917b2e77694eb0a2.png)Spring Boot实现User CRUD操作

代码：  
 [WYend/Myblog_springbook3: 我的第一个个人网站（后端版）](https://github.com/WYend/Myblog_springbook3)  
 随时更新

### 一、数据库的构建

交给ai

### 二、各类注解

##### Lombok注解

1. **@Data**：
   * 自动生成类的`getter`、`setter`、`toString()`、`equals()`、`hashCode()`方法
   * 适用于实体类（与数据库表映射的类）、数据传输对象（DTO）、值对象（VO）等纯数据载体类
2. @EqualsAndHashCode(callSuper = false)
   * 自动生成`equals()`和`hashCode()`方法，表示生成这两个方法时**不包含父类的属性**（仅比较当前类的字段）。
   * 实体类继承自基类，且`equals/hashCode`的判断只需要关注当前类的核心字段（如`id`、`username`），无需考虑父类属性时。
3. @Accessors(chain = true)
   * 修改`setter`方法的生成逻辑，`chain = true`让`setter`方法返回当前对象（而非`void`），支持**链式调用**。
   * 需要频繁设置多个属性时（如对象初始化、参数组装），尤其适合构建器模式（Builder）的简化替代
   * `user.setName("张三").setAge(20).setEmail("test@xxx.com")`

##### MyBatis-Plus 注解

1. @TableName(“user”)  
    [mybatis-plus CRUD扩展：雪花算法、自动填充策略、乐观锁-CSDN博客](https://blog.csdn.net/WYyanyufei/article/details/151433268?spm=1011.2124.3001.6209)

### 三、MVC架构

#### User实体类

对应数据库表

#### UserMapper

继承BaseMapper，并传入User实体

#### Service

##### UserService

1. 继承Iservice类，实现通用CRUD
2. 实现了：获取所有用户、获取用户、创建、删除、更新、改变用户状态的方法，通过传入id或DTO数据

##### UserServiceImpl

1. 通过baseMapper的查询方法和mybatis-plus的条件构造器（`QueryWrapper`）实现了`checkUsername`和`checkEmail`两个自定义查询方法
2. 整体使用baseMapper的CRUD方法

#### UserDTO

#### UserController

**用户管理RESTful API控制器**，主要负责处理前端发起的用户相关HTTP请求，调用服务层逻辑并返回标准化响应。以下是核心内容的解析：

#### 一、类的基本定位与注解

```java
@RestController  // 标记这是一个REST控制器，自动将返回值转为JSON/XML响应体
@RequestMapping("/api/users")  // 所有接口的基础路径，即接口URL都以/api/users开头
@Tag(name = "用户管理", description = "用于用户管理的所有接口集合")  // Swagger文档注解，标记接口组信息
public class UserController { ... }

```

* 核心作用：作为前端与服务层的中间层，接收用户请求（如查询、新增、修改用户），转发给`UserService`处理，最终返回HTTP响应。
* 遵循MVC模式：控制器（Controller）不处理业务逻辑，仅负责请求分发和响应封装，业务逻辑由`UserService`实现。

#### 二、核心依赖注入

```java
@Autowired  // Spring自动注入UserService实例，无需手动创建
private UserService userService;

```

* 通过依赖注入解耦控制器与服务层，控制器只需调用`userService`的方法即可完成业务处理，无需关心其具体实现。

#### 三、核心接口功能（RESTful API设计）

控制器定义了6个接口，对应用户管理的CRUD（增删改查）及状态修改操作，每个接口通过不同的注解指定HTTP方法和路径：

| 接口方法 | HTTP方法 | 路径 | 功能描述 |
| --- | --- | --- | --- |
| getAllUsers | GET | /api/users | 查询所有用户列表 |
| getUserById | GET | /api/users/{id} | 根据ID查询单个用户 |
| createUser | POST | /api/users | 新增用户 |
| updateUser | PUT | /api/users/{id} | 根据ID全量更新用户信息 |
| deleteUser | DELETE | /api/users/{id} | 根据ID删除用户 |
| changeUserStatus | PATCH | /api/users/{id}/status | 部分更新（仅修改用户状态） |

#### 四、关键技术细节

1. **请求参数处理**：

   * `@PathVariable Integer id`：获取URL路径中的参数（如`/api/users/1`中的`1`）。
   * `@RequestBody UserDTO userDTO`：接收HTTP请求体中的JSON数据，转为`UserDTO`对象（DTO用于数据传输，避免直接暴露实体类）。
   * `@RequestParam Integer status`：获取URL查询参数（如`/api/users/1/status?status=1`中的`1`）。
2. **响应处理**：

   * 使用`ResponseEntity`封装HTTP响应，包含状态码、响应体等信息：
     + `ResponseEntity.ok(...)`：返回200 OK状态，附带响应数据（如用户列表、单个用户）。
     + `ResponseEntity.notFound().build()`：返回404 Not Found（用户不存在时）。
     + `ResponseEntity.badRequest().body(...)`：返回400 Bad Request，附带错误信息（如操作失败原因）。
3. **API文档支持**：

   * `@Operation`：描述单个接口的功能（如`summary`为简要说明，`description`为详细描述）。
   * `@Parameter`：描述接口参数（如是否必填、示例值），用于自动生成Swagger文档，方便前端对接。
4. **异常处理**：

   * 对`createUser`、`updateUser`等方法添加`try-catch`，捕获服务层抛出的`RuntimeException`，将异常信息通过响应体返回给前端，避免接口直接报错崩溃。

总结：这个`UserController`是用户模块的入口，通过标准化的API接口对外提供用户管理功能，同时通过依赖注入、异常处理等机制保证了代码的灵活性和健壮性。



