---
layout: post
title: "windows-平台如何点击网页上的url-,会打开远程桌面连接服务器"
date: 2025-03-07 16:08:01 +0800
description: "网页上打开远程桌面的方法"
keywords: "windows 平台如何点击网页上的url ,会打开远程桌面连接服务器"
categories: ['未分类']
tags: ['运维', '服务器', 'Windows', 'Linux']
artid: "146098267"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146098267
    alt: "windows-平台如何点击网页上的url-,会打开远程桌面连接服务器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146098267
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146098267
cover: https://bing.ee123.net/img/rand?artid=146098267
image: https://bing.ee123.net/img/rand?artid=146098267
img: https://bing.ee123.net/img/rand?artid=146098267
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     windows 平台如何点击网页上的url ,会打开远程桌面连接服务器
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     你可以使用自定义协议方案（Protocol Scheme）实现网页上点击URL后自动启动远程桌面连接（mstsc），参考你提供的C++代码思路，如下实现：
    </p>
    <h4>
     第一步：注册自定义协议
    </h4>
    <p>
     使用类似
     <code>
      openmstsc://
     </code>
     协议。
    </p>
    <h5>
     注册示例 (
     <code>
      reg
     </code>
     文件形式)
    </h5>
    <pre><code>Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\openmstsc]
@="URL:openmstsc Protocol"
"URL Protocol"=""

[HKEY_CLASSES_ROOT\openmstsc\shell\open\command]
@="\"C:\\your-path\\open_mstsc.exe\" \"%1\""
</code></pre>
    <p>
     或通过你的C++代码自动完成注册（代码里已经包含该功能）。
    </p>
    <hr/>
    <h4>
     第二步：网页中调用协议URL
    </h4>
    <p>
     网页端代码（简单HTML）：
    </p>
    <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;远程桌面连接示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href="openmstsc://192.168.1.100:3389"&gt;连接远程桌面 192.168.1.100&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <p>
     注意：
    </p>
    <ul>
     <li>
      点击此链接时，浏览器会提示用户是否允许调用该协议（首次使用时会询问），确认即可。
     </li>
    </ul>
    <hr/>
    <h4>
     第三步：你的C++程序实现要点（已提供，以下强调注意点）
    </h4>
    <p>
     你的C++程序中关键实现点（你代码中已经包含了）：
    </p>
    <ul>
     <li>
      解析传入的URL，提取
      <code>
       IP:端口
      </code>
      。
     </li>
     <li>
      使用
      <code>
       ShellExecuteExW
      </code>
      调用
      <code>
       mstsc.exe
      </code>
      并传入
      <code>
       /v:IP:Port
      </code>
      参数。
     </li>
    </ul>
    <p>
     示例（摘录）：
    </p>
    <pre><code>void OpenWithMstsc(const std::wstring&amp; serverIP) {
    if (serverIP.empty()) return;

    std::wstring mstscArgs = L"/v:" + serverIP;

    SHELLEXECUTEINFOW sei = { sizeof(sei) };
    sei.lpFile = L"mstsc.exe";
    sei.lpParameters = mstscArgs.c_str();
    sei.nShow = SW_SHOWNORMAL;
    sei.fMask = SEE_MASK_NOASYNC;

    ShellExecuteExW(&amp;sei);
}
</code></pre>
    <hr/>
    <h4>
     完整流程说明
    </h4>
    <ol>
     <li>
      <strong>
       网页链接点击
      </strong>
      → 浏览器触发
      <code>
       openmstsc://IP:Port
      </code>
      。
     </li>
     <li>
      浏览器调用注册好的协议→ 执行
      <code>
       open_mstsc.exe
      </code>
      ，传入参数。
     </li>
     <li>
      程序解析URL → 调用
      <code>
       mstsc.exe
      </code>
      → 远程桌面客户端打开。
     </li>
    </ol>
    <p>
     这样即可实现点击网页上的链接自动打开远程桌面连接的功能。
    </p>
    <pre><code>// open_mstsc.cpp
// C++ 重写版本：实现与 C# 相同功能，包括注册自定义协议、解析 URL，并通过 WPS 打开文件，且不弹出控制台窗口。
//语言功能 "结构化绑定" 需要编译器标志 "/std:c++17"
//链接器-》系统-》子系统-》窗口模式
#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;urlmon.h&gt;
#include &lt;shellapi.h&gt;
#include &lt;algorithm&gt; // for std::transform
#pragma comment(lib, "Shlwapi.lib")
#pragma comment(lib, "urlmon.lib")
#include &lt;cctype&gt;
const std::wstring PROTOCOL_NAME = L"openMstsc";
#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;

bool IsRunAsAdmin() {
    BOOL isAdmin = FALSE;
    PSID adminGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (AllocateAndInitializeSid(&amp;NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0, &amp;adminGroup)) {
        CheckTokenMembership(NULL, adminGroup, &amp;isAdmin);
        FreeSid(adminGroup);
    }
    return isAdmin;
}

void RelaunchAsAdmin() {
    wchar_t exePath[MAX_PATH];
    GetModuleFileNameW(NULL, exePath, MAX_PATH);

    SHELLEXECUTEINFOW sei = { sizeof(sei) };
    sei.lpVerb = L"runas"; // 以管理员权限运行
    sei.lpFile = exePath;
    sei.nShow = SW_SHOWNORMAL;
    sei.fMask = SEE_MASK_NOASYNC;

    if (ShellExecuteExW(&amp;sei)) {
        ExitProcess(0); // 关闭当前进程
    }
}
// 替代 HttpUtility.UrlDecode 的简单实现
// 使用 UrlUnescapeW API 进行解码
static std::wstring UrlDecode(const std::wstring&amp; encoded) {
    if (encoded.empty()) return L"";

    // 预留缓冲区存放解码后的结果
    const size_t BUFFER_SIZE = 4096;
    wchar_t buffer[BUFFER_SIZE];
    wcsncpy_s(buffer, encoded.c_str(), BUFFER_SIZE);

    DWORD dwSize = (DWORD)BUFFER_SIZE;
    HRESULT hr = UrlUnescapeW(buffer, NULL, &amp;dwSize, URL_UNESCAPE_INPLACE);
    if (SUCCEEDED(hr)) {
        return std::wstring(buffer);
    }
    else {
        // 如果解码失败，可以根据需求返回空字符串或原始值
        return L"";
    }
}

 



static std::wstring ProcessServerIP(const std::wstring&amp; inputUrl, const std::wstring&amp; protocolName)
{
    // 1) 构造 "{protocol}://" 的小写形式
    std::wstring lowerProtocol = protocolName;
    std::transform(lowerProtocol.begin(), lowerProtocol.end(), lowerProtocol.begin(), ::towlower);
    std::wstring protocolPrefix = lowerProtocol + L"://";

    // 2) 转换 inputUrl 为小写进行查找
    std::wstring lowerInput = inputUrl;
    std::transform(lowerInput.begin(), lowerInput.end(), lowerInput.begin(), ::towlower);

    // 3) 移除 "protocol://"
    std::wstring url;
    size_t pos = lowerInput.find(protocolPrefix);
    if (pos != std::wstring::npos)
    {
        url = inputUrl.substr(pos + protocolPrefix.size());
    }
    else
    {
        url = inputUrl;  // 原始 URL
    }

    // 4) URL 解码（假设 UrlDecode 是可用函数）
    url = UrlDecode(url);

    // 5) 去除路径部分，仅保留 "host:port"
    size_t pathPos = url.find(L'/');
    if (pathPos != std::wstring::npos)
    {
        url = url.substr(0, pathPos);
    }

    return url;
}


//-----------------------------------------------------------
// 下面是原有的函数声明与实现
//-----------------------------------------------------------

void RegisterUrlScheme(const std::wstring&amp; protocol, const std::wstring&amp; exePath);
std::wstring GetRegisteredPath(const std::wstring&amp; protocol);

void OpenWithMstsc(const std::wstring&amp; fileUrl);
std::pair&lt;std::wstring, std::wstring&gt; GetWpsLauncherPath();
void EnsureUrlScheme(const std::wstring&amp; protocol);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
//int main(){

    if (!IsRunAsAdmin()) {
        RelaunchAsAdmin(); // 如果不是管理员权限，则重新以管理员权限运行
        return 0;
    }
    EnsureUrlScheme(PROTOCOL_NAME);

    int argc;
    LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &amp;argc);
    if (argv == NULL) return 0;

    if (argc &lt; 2) {
        //MessageBoxW(NULL, L"⚠️ 未检测到 URL 参数。", L"提示", MB_OK | MB_ICONWARNING);
        return 0;
    }
     

    // 调用新版 ProcessUrl
    std::wstring url = ProcessServerIP(argv[1], PROTOCOL_NAME);



    if (PathIsURLW(url.c_str())) {
        OpenWithMstsc(url);
    }
    else {
 
    }

    LocalFree(argv);
    return 0;
}

void EnsureUrlScheme(const std::wstring&amp; protocol) {
    wchar_t exePath[MAX_PATH];
    GetModuleFileNameW(NULL, exePath, MAX_PATH);
    std::wstring registeredPath = GetRegisteredPath(protocol);

    if (registeredPath.empty() || !_wcsicmp(registeredPath.c_str(), exePath) == 0) {
        RegisterUrlScheme(protocol, exePath);
    }
}

std::wstring GetRegisteredPath(const std::wstring&amp; protocol) {
    HKEY hKey;
    std::wstring regPath = L"";
    std::wstring keyPath = protocol + L"\\shell\\open\\command";
    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, keyPath.c_str(), 0, KEY_READ, &amp;hKey) == ERROR_SUCCESS) {
        wchar_t value[MAX_PATH];
        DWORD value_length = sizeof(value);
        if (RegQueryValueExW(hKey, NULL, NULL, NULL, (LPBYTE)value, &amp;value_length) == ERROR_SUCCESS) {
            std::wstring commandLine(value);
            size_t firstQuoteEnd = commandLine.find(L'"', 1);
            if (firstQuoteEnd != std::wstring::npos) {
                regPath = commandLine.substr(1, firstQuoteEnd - 1);
            }
        }
        RegCloseKey(hKey);
    }
    return regPath;
}

void RegisterUrlScheme(const std::wstring&amp; protocol, const std::wstring&amp; exePath) {
    HKEY hKey;
    std::wstring keyPath = protocol;
    if (RegCreateKeyExW(HKEY_CLASSES_ROOT, keyPath.c_str(), 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, NULL) == ERROR_SUCCESS) {
        RegSetValueExW(hKey, NULL, 0, REG_SZ, (const BYTE*)(L"URL:" + protocol + L" Protocol").c_str(),
            (DWORD)((protocol.size() + 10) * sizeof(wchar_t)));
        RegSetValueExW(hKey, L"URL Protocol", 0, REG_SZ, (const BYTE*)L"", sizeof(wchar_t));
        HKEY hCommandKey;
        if (RegCreateKeyExW(hKey, L"shell\\open\\command", 0, NULL, 0, KEY_WRITE, NULL, &amp;hCommandKey, NULL) == ERROR_SUCCESS) {
            std::wstring command = L"\"" + exePath + L"\" \"%1\"";
            RegSetValueExW(hCommandKey, NULL, 0, REG_SZ, (const BYTE*)command.c_str(), (DWORD)(command.size() * sizeof(wchar_t)));
            RegCloseKey(hCommandKey);
        }
        RegCloseKey(hKey);
        MessageBoxW(NULL, L"远程组件注册成功。", L"成功", MB_OK | MB_ICONINFORMATION);
    }
}
 
void OpenWithMstsc(const std::wstring&amp; serverIP) {
    if (serverIP.empty()) {
        // MessageBoxW(NULL, L"❌ 服务器 IP 不能为空。", L"错误", MB_OK | MB_ICONERROR);
        return;
    }

    // 远程桌面连接的完整命令行参数
    std::wstring mstscArgs = L"/v:" + serverIP;

    SHELLEXECUTEINFOW sei = { sizeof(sei) };
    sei.lpFile = L"mstsc.exe";  // 远程桌面客户端
    sei.lpParameters = mstscArgs.c_str();
    sei.nShow = SW_SHOWNORMAL;
    sei.fMask = SEE_MASK_NOASYNC;

    if (!ShellExecuteExW(&amp;sei)) {
        // MessageBoxW(NULL, L"❌ 无法启动远程桌面连接。", L"错误", MB_OK | MB_ICONERROR);
    }
}
</code></pre>
    <p>
     注意上面代码要以管理员权限运行才能正确写入注册表，否则失败
    </p>
    <p>
     下面将继续实现一下unbuntu上如何实现类似方法
    </p>
    <pre><code>sudo apt install freerdp2-x11  
xfreerdp /v:10.10.10.11:33389 /u:username /p:passwrod /cert-ignore /dynamic-resolution or( /w:1440 /h:900)</code></pre>
    <p>
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6261627974696765722f:61727469636c652f64657461696c732f313436303938323637" class_="artid" style="display:none">
 </p>
</div>


