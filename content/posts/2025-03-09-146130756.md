---
layout: post
title: "Python-Flask-使用不同的-HTTP-方法类型处理请求"
date: 2025-03-09 12:53:14 +0800
description: "这种访问资源的方案是流行的，因为它的简单。在 URL 中，查询字符串的数据是可见的，这意味着我们不能在查询字符串中发送敏感信息，比如用户名和密码。HTTP 是基于客户端和服务端的请求-回应模型的。客户端（例如，网页服务器）可以发送不同的动词，或更合适的，调用方法来区别对服务器请求的类型。在讨论这两个方法之前，理解 HTTP 的两个组件是非常重要的，也就是 HTTP 请求和 HTTP 回应。方法用来发送请求以获取特定资源，特定资源是在 URL 中标识出来的，并且可以选择将查询字符串添加为 URL 的一部分。"
keywords: "Python Flask 使用不同的 HTTP 方法类型处理请求"
categories: ['未分类']
tags: ['Python', 'Flask']
artid: "146130756"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146130756
    alt: "Python-Flask-使用不同的-HTTP-方法类型处理请求"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146130756
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146130756
cover: https://bing.ee123.net/img/rand?artid=146130756
image: https://bing.ee123.net/img/rand?artid=146130756
img: https://bing.ee123.net/img/rand?artid=146130756
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python Flask 使用不同的 HTTP 方法类型处理请求
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="Python_Flask__HTTP__2">
     </a>
     Python Flask 使用不同的 HTTP 方法类型处理请求
    </h2>
    <p>
     HTTP 是基于客户端和服务端的请求-回应模型的。客户端（例如，网页服务器）可以发送不同的动词，或更合适的，调用方法来区别对服务器请求的类型。这些方法包括
     <code>
      GET
     </code>
     、
     <code>
      POST
     </code>
     、
     <code>
      PUT
     </code>
     、
     <code>
      DELETE
     </code>
     、
     <code>
      HEAD
     </code>
     、
     <code>
      PATCH
     </code>
     ，以及
     <code>
      OPTIONS
     </code>
     。
     <code>
      GET
     </code>
     和
     <code>
      POST
     </code>
     是最常用的 HTTP 方法。接下来，我们仅仅使用这两个方法来讲解网页开发概念。
    </p>
    <p>
     在讨论这两个方法之前，理解 HTTP 的两个组件是非常重要的，也就是 HTTP 请求和 HTTP 回应。一个 HTTP 请求会被分成三部分：
    </p>
    <ul>
     <li>
      请求行（Request Line)：这一行包含了使用的方法，请求的
      <code>
       URI
      </code>
      ，和使用的 HTTP 协义的版本。
      <pre><code>GET /home HTTP/1.1
</code></pre>
     </li>
     <li>
      请求头字段（Header fields）：请求头是元数据，提供适用于请求的信息。每个头部都以关键字-值对的方式提供，用冒号（:）分隔；
     </li>
     <li>
      请求体（可选）：它是一个占位符，我们可以添加额外的数据。对于一个网页应用程序来说，我们可以随
      <code>
       POST
      </code>
      请求一起在请求体内部发送表单数据。对于一个 REST 应用接口，我们可以在请求体内给
      <code>
       PUT
      </code>
      或
      <code>
       POST
      </code>
      请求发送数据。
     </li>
    </ul>
    <p>
     当我们发送一个 HTTP 请求时，我们会得到一个
     <code>
      HTTP
     </code>
     回应，作为请求的结果。HTTP 回应和 HTTP 请求有相似的部分：
    </p>
    <ul>
     <li>
      状态行：这行指明了回应是成功的，还是失败的。错误代码会出现在状态行上：
      <pre><code class="prism language-python">HTTP<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> OK
</code></pre>
      <code>
       200
      </code>
      这个状态码，或在闭区间
      <code>
       [200,299]
      </code>
      之间的状态码，代表成功。错误码在闭区间
      <code>
       [400,499]
      </code>
      内，表示客户端错误，错误码在闭区间
      <code>
       [500,599]
      </code>
      之间表示服务端错误；
     </li>
     <li>
      回应头：回应头字段和 HTTP 请求头字段类似；
     </li>
     <li>
      回应体（可选）：虽然是可选的，但它是 HTTP 回应的关键部分。回应体里可以包含网页应用程序的 HTML 页面或其它任何格式的数据。
     </li>
    </ul>
    <p>
     <code>
      GET
     </code>
     方法用来发送请求以获取特定资源，特定资源是在 URL 中标识出来的，并且可以选择将查询字符串添加为 URL 的一部分。
     <code>
      ?
     </code>
     在 URL 中被用来分隔查询字符串和基础 URL。例如，如果我们用搜索工具 xx.com 搜
     <code>
      Python
     </code>
     ，我们会在浏览器地址栏里看到下的 URL：
    </p>
    <pre><code class="prism language-shell">https://www.xx.com/search?q<span class="token operator">=</span>Python
</code></pre>
    <p>
     在上面的
     <code>
      URL
     </code>
     中，
     <code>
      q=Python
     </code>
     是一个查询字符串。查询字符串用来携带
     <code>
      key=value
     </code>
     数据。这种访问资源的方案是流行的，因为它的简单。但是它是有缺陷的。在 URL 中，查询字符串的数据是可见的，这意味着我们不能在查询字符串中发送敏感信息，比如用户名和密码。查询字符串的长度不能超过 255 字符。然而，因为简单，搜索公司使用
     <code>
      GET
     </code>
     方法搜索网站。在
     <code>
      POST
     </code>
     方法中，数据通过 HTTP 请求体发送，这就消除了
     <code>
      GET
     </code>
     方法的限制。数据不会作为 URL 的一部分出现，发送到服务器的数据也没有数量的限制。同样，
     <code>
      POST
     </code>
     方法对数据的类型也没有限制。
    </p>
    <p>
     Flask 提供了好几个方便的方法用来区别一个请求是用
     <code>
      GET
     </code>
     或
     <code>
      POST
     </code>
     或任务其它方法发送的。在我们下面的例子中，我们演示了两个方案。第一个方案使用
     <code>
      route
     </code>
     装饰器，它带有一个精确的期望方法列表；第二个方案使用一个特定方法类型装饰器，比如
     <code>
      get
     </code>
     装饰器或
     <code>
      post
     </code>
     装饰器。下面是完整的代码：
    </p>
    <pre><code class="prism language-python"><span class="token comment"># 使用方法类型映射请求</span>

<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> request
app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">"/submit"</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"GET"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">req_with_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"接收到了一个 GET 请求。"</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>post</span><span class="token punctuation">(</span><span class="token string">'/submit'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">req_with_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"接收到了一个 POST 请求。"</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">"/submit2"</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">both_get_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">"GET"</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"接收到了一个 GET 请求 2。"</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"接收到了一个 POSt 请求 2。"</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     下面让我们逐一讨论我们的示例代码中的三个路由定义和相应的函数：
    </p>
    <ul>
     <li>
      在第一个路由定义（@app.route(“/submit”, methods=[“GET”])）中，我们使用
      <code>
       route
      </code>
      装饰器映射
      <code>
       URL
      </code>
      ，把
      <code>
       GET
      </code>
      类型的请求映射到一个 Python 函数。使用这个装饰设定，Python 函数将会处理
      <code>
       /submit
      </code>
      这个 URL 的
      <code>
       GET
      </code>
      请求；
     </li>
     <li>
      在第二个路由定义（@app.post(‘/submit’)）中，我们使用
      <code>
       post
      </code>
      装饰器，并且只指定请求 URL。这是把
      <code>
       POST
      </code>
      方法映射到 Python 函数的简单方法。这个新的设置方法和第一个方案是等价的。我们自可以使用
      <code>
       get
      </code>
      装饰器给
      <code>
       GET
      </code>
      定义处理器；
     </li>
     <li>
      在第三个路由定义（@app.route(“/submit2”, methods=[“GET”, “POST”])）中，我们把单个 URL 的
      <code>
       GET
      </code>
      和
      <code>
       POST
      </code>
      这两个请求上映射到同样一个方法上。这是一种简单的方案，用这种方案我们可以使用一个处理器处理任何类型的请求。在 Python 函数内部，使用请求对象的
      <code>
       method
      </code>
      属性来标识请求是
      <code>
       GET
      </code>
      还是
      <code>
       POST
      </code>
      。请注意，一旦我们将请求包导入到程序中，web服务器就会将请求对象提供给我们的Flask应用程序。这种方法为客户端提供了灵活性，可以使用相同的URL使用两种方法中的任何一种提交请求，作为开发人员，我们将它们映射到一个Python函数。
     </li>
    </ul>
    <p>
     我们可以通过
     <code>
      curl
     </code>
     实用程序更方便地测试此代码示例，因为在不定义
     <code>
      HTML
     </code>
     表单的情况下提交
     <code>
      POST
     </code>
     请求并不容易。以下
     <code>
      curl
     </code>
     命令可用于向我们的网页应用程序发送HTTP请求：
    </p>
    <pre><code>curl -X GET http://localhost:5000/submit
curl -X POST http://localhost:5000/submit
curl -X GET http://localhost:5000/submit2
curl -X POST http://localhost:5000/submit2
</code></pre>
    <p>
     &lt;完&gt;
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f646f7768696c6570726f6772616d6d696e672f:61727469636c652f64657461696c732f313436313330373536" class_="artid" style="display:none">
 </p>
</div>


