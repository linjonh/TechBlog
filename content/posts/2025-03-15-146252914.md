---
layout: post
title: "C之OOP"
date: 2025-03-15 13:28:34 +0800
description: "1、类是属性、行为的封装，将数据的表示和数据的处理集中到一起2、类内成员的访问权限为：public、protected、private3、类的相关成员函数的定义指向同一块内存4、this指针this指针指向类的实例化对象，是一个顶层const，即不可以修改指向，但是可以借助this指针来修改类内的成员5、静态数据成员6、虚函数指针和虚函数表当一个类中有一个或多个虚函数时，编译时会为其生成一张虚函数表(vftable)，在类的对象中，有一个虚函数指针(vfptr)，指向该虚函数表。"
keywords: "C++之OOP"
categories: ['Primer', 'C']
tags: ['开发语言', 'C']
artid: "146252914"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146252914
    alt: "C之OOP"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146252914
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146252914
cover: https://bing.ee123.net/img/rand?artid=146252914
image: https://bing.ee123.net/img/rand?artid=146252914
img: https://bing.ee123.net/img/rand?artid=146252914
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++之OOP
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     感谢哔哩哔哩UP“开发者LaoJ”，以下是学习记录~
    </p>
    <p>
     1、类是属性、行为的封装，将数据的表示和数据的处理集中到一起
    </p>
    <p>
     2、类内成员的访问权限为：public、protected、private
    </p>
    <ul>
     <li>
      public，可以被外界访问
     </li>
     <li>
      protected，不可被外界访问，可以被派生类访问
     </li>
     <li>
      private，不可以被外界访问，也不可以被派生类访问
     </li>
    </ul>
    <p>
     3、类的相关成员函数的定义
    </p>
    <pre><code class="language-cpp">/*类的相关成员函数的定义*/
//1、成员函数内联定义

//2、成员函数在类内声明，在类外定义

//3、构造函数，允许重载
//3.1使用默认构造函数(=default)
myclass() = default;
//3.2、带参数
myclass(int val) : data(val) {……}
//3.3、动态内存分配(会调用默认构造函数)
myclass *objptr = new myclass();
……
delete objptr;
//3.4、复制构造函数
myclass obj1;
myclass obj2 = obj1;

//4、析构函数
//没有参数，没有返回值，不可以重载
//自定义的析构函数，一般用来释放动态内存、关闭文件、释放资源等
//当对象超出作用域时，析构函数会被调用

//5、成员初始化列表
myclass(string str, int val) : name(str), data(val) {……}</code></pre>
    <blockquote>
     <p>
      浅拷贝：
     </p>
     <ul>
      <li>
       浅拷贝是默认的拷贝行为，它只是简单地复制对象的成员变量的值。如果对象中有指针成员，浅拷贝只会复制指针的值，而不会复制指针指向的内容
      </li>
      <li>
       浅拷贝会导致多个对象的指针成员
       <span style="background-color:#ffd900">
        指向同一块内存
       </span>
       。当其中一个对象释放了这块内存后，其他对象的指针就会变成悬空指针
      </li>
     </ul>
     <p>
      深拷贝：
     </p>
     <ul>
      <li>
       深拷贝会复制对象的所有成员变量，包括指针指向的内容。对于动态分配的资源，深拷贝会为新对象分配新的内存，并将原对象的内容复制到新内存中
      </li>
      <li>
       需要手动实现拷贝构造函数和赋值运算符重载，以确保深拷贝的正确性
      </li>
     </ul>
    </blockquote>
    <p>
     4、this指针
    </p>
    <p>
     this指针指向类的实例化对象，是一个顶层const，即不可以修改指向，但是可以借助this指针来修改类内的成员
    </p>
    <p>
     5、静态数据成员
    </p>
    <ul>
     <li>
      静态成员是类级别的，不是对象级别的，被类的所有对象共享
     </li>
     <li>
      静态成员变量在类内声明，类外定义(必须在类外定义)，在编译时，由编译器分配内存
     </li>
     <li>
      静态成员函数只能访问静态变量
     </li>
     <li>
      可以通过类名和类的对象访问静态成员
     </li>
    </ul>
    <p>
     6、虚函数指针和虚函数表
    </p>
    <p>
     当一个类中有一个或多个虚函数时，编译时会为其生成一张虚函数表(vftable)，在类的对象中，有一个虚函数指针(vfptr)，指向该虚函数表
    </p>
    <p>
     如果父类中有虚函数，无论子类是否有虚函数，均会有一张虚函数表
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

class Device {
public:
	virtual void fetchData() {
		cout &lt;&lt; "device fetchData" &lt;&lt; endl;
	}
	virtual void performAction() {
		cout &lt;&lt; "device performAction" &lt;&lt; endl;
	}
	virtual ~Device() = default;
};

class LightController : public Device {
public:
	void fetchData() override {
		cout &lt;&lt; "LightController fetchData" &lt;&lt; endl;
	}
	/*void performAction() {
	*	cout &lt;&lt; "LightController performAction" &lt;&lt; endl;
	}*/
};

int main(void)
{
	Device objD, objD2;
	LightController objL;
	objL.fetchData();
	objL.performAction();
	return 0;
}</code></pre>
    <p>
     <img alt="" height="426" src="https://i-blog.csdnimg.cn/direct/3e40715dc7024c068e040780423c7047.png" width="1981"/>
    </p>
    <p>
     根据上图可知：
    </p>
    <ul>
     <li>
      父类对象和子类对象的虚函数指针的指向不同。其中，因为子类的performAction函数没有实现，所以在虚函数表中，子类的performAction函数的地址与父类中同名函数的地址一样
     </li>
     <li>
      定义了两个基类的对象，对象内均有一个vfptr指针，指向的地址相同，说明一个基类的多个对象共享一份虚函数表
     </li>
    </ul>
    <h2 style="background-color:transparent">
     一、封装
    </h2>
    <p>
     封装简化了代码的复杂性，隐藏类的内部的实现细节，只是向外提供接口以供调用，起到了保护其内部成员的作用
    </p>
    <h2>
     二、继承
    </h2>
    <p>
     继承允许创建一个新的类，从一个或多个现有的类中继承属性和行为。新类称为派生类，被继承类称为基类
    </p>
    <p>
     一般而言，共性的东西会被设计在基类中，个性化的东西被设计在派生类中
    </p>
    <p>
     在构造派生类对象时，会先调用基类的构造函数，然后调用派生类的构造函数；在派生类对象作用域结束时，先调用派生类的析构函数，然后调用基类的析构函数
    </p>
    <h3>
     2.1、三种继承形式
    </h3>
    <blockquote>
     <p>
      继承的三种形式：public、protected和private
     </p>
     <ul>
      <li>
       public：
      </li>
     </ul>
     <p>
      类外：对于继承的成员，保持与父类的对外可见性一致
     </p>
     <p>
      类内：可以处理父类的public、protected成员，不可以处理父类的private成员
     </p>
     <ul>
      <li>
       protected：
      </li>
     </ul>
     <p>
      类外：对于继承的成员，除了private成员外，其它成员对外均为protected
     </p>
     <p>
      类内：可以处理父类的public、protected成员，不可以处理父类的private成员
     </p>
     <ul>
      <li>
       private：
      </li>
     </ul>
     <p>
      类外：对于继承的成员，对外均为private
     </p>
     <p>
      类内：可以处理父类的public、protected成员，不可以处理父类的private成员
     </p>
     <ul>
      <li>
       总结：
      </li>
     </ul>
     <p>
      派生类内是否可以访问父类的成员，需要看父类成员的
      <span style="background-color:#ffd900">
       访问权限
      </span>
      。类外是否可访问父类成员，需要看
      <span style="background-color:#ffd900">
       继承形式
      </span>
     </p>
    </blockquote>
    <p>
     不管什么继承方式，也不管父类成员本身的访问权限修饰符是什么，子类对象已完全继承父类的所有属性和行为，只是对外不一定可见，在类内不一定可以处理
    </p>
    <h3>
     2.2、同名问题
    </h3>
    <p>
     对于普通成员，只能通过类的对象进行访问
    </p>
    <p>
     对于静态成员，可以通过类的对象和类访问，静态成员属于类，类的所有对象共享静态变量。故而，静态变量必须在
     <span style="background-color:#ffd900">
      类内声明
     </span>
     ，
     <span style="background-color:#ffd900">
      类外定义
     </span>
    </p>
    <h4>
     2.2.1、子类与父类普通成员名称相同
    </h4>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class Base
{
public:
	int a = 0;
	void myfun() {
		cout &lt;&lt; "I am parent class's function" &lt;&lt; endl;
	}
};

class A : public Base
{
public:
	int a = 1;
	void myfun() {
		cout &lt;&lt; "I am child class's function" &lt;&lt; endl;
	}
};

int main(void)
{
	/*使用对象访问静态成员*/
	A obj;
	cout &lt;&lt; obj.a &lt;&lt; endl;
	cout &lt;&lt; obj.Base::a &lt;&lt; endl;
	obj.myfun();
	obj.Base::myfun();
}</code></pre>
    <h4>
     2.2.2、子类与父类静态成员名称相同
    </h4>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class Base 
{
	public:
		static int a;
		static void myfun() {
			cout &lt;&lt; "I am parent class's function" &lt;&lt; endl;
		}
};
int Base::a = 0;

class A : public Base
{
        public:
                static int a;
                static void myfun() {
                        cout &lt;&lt; "I am child class's function" &lt;&lt; endl;
                }       
};               
int A::a = 1; 

int main(void)
{
	/*使用对象访问静态成员*/
	A obj;
	cout &lt;&lt; obj.a &lt;&lt; endl;
	cout &lt;&lt; obj.Base::a &lt;&lt; endl;
	obj.myfun();
	obj.Base::myfun();

	/*使用类访问静态成员*/
	cout &lt;&lt; A::a &lt;&lt; endl;
	cout &lt;&lt; A::Base::a &lt;&lt; endl;
	A::myfun();
	A::Base::myfun();
	return 0;
}</code></pre>
    <h4>
     2.2.3、派生类的多个父类中有同名成员
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class parent1
{
public:
	int a = 6;
};

class parent2
{
public:
	int a = 9;
};

class child : public parent1, public parent2
{};

int main(void)
{
	child obj;
	//cout &lt;&lt; obj.a &lt;&lt; endl;            //错误，需要指明是哪个父类中的成员
    /*当多个父类中有同名成员时
     *需要指明该同名成员是来自哪个父类*/
	cout &lt;&lt; obj.parent1::a &lt;&lt; endl;
	cout &lt;&lt; obj.parent2::a &lt;&lt; endl;
}</code></pre>
    <h4>
     2.2.4、钻石继承问题--虚继承
    </h4>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class base
{
public:
	base() {
		cout &lt;&lt; "create base" &lt;&lt; endl;
		basea = 0;
	}
	~base() {
		cout &lt;&lt; "delete base" &lt;&lt; endl;
	}
	int basea;
};

class A : virtual public base
{
public:
	A() {
		cout &lt;&lt; "create A" &lt;&lt; endl;
		a = 1;
	}
	~A() {
		cout &lt;&lt; "delete A" &lt;&lt; endl;
	}
	int a;
};

class B : virtual public base
{
public:
	B() {
		cout &lt;&lt; "create B" &lt;&lt; endl;
		b = 2;
	}
	~B() {
		cout &lt;&lt; "delete B" &lt;&lt; endl;
	}
	int b;
};

class C : public A, public B
{
public:
	C() {
		cout &lt;&lt; "create	C" &lt;&lt; endl;
		c = 3;
	}
	~C() {
		cout &lt;&lt; "delete C" &lt;&lt; endl;
	}
	int c;
};

/*通过使用virtual，可以使得A和B中的basea指向同一块内存
 *如果没有使用该关键字，那么A和B会有basea各自的副本*/

int main(void)
{
	C c1;
	cout &lt;&lt; "通过C访问A类的a：" &lt;&lt; c1.a &lt;&lt; endl;
	cout &lt;&lt; "通过C访问B类的b：" &lt;&lt; c1.b &lt;&lt; endl;

	/*第一个问题：不明确的问题
	 *如果不使用virtual关键字，需要指明访问哪个父类的同名成员
	 *使用virtual关键字后，同名成员指向同一内存，不确定来源亦可
	 *以下三个语句均正确*/
	cout &lt;&lt; "通过C访问base类的basea：" &lt;&lt; c1.basea &lt;&lt; endl;
	cout &lt;&lt; "通过C访问base类的basea：" &lt;&lt; c1.A::basea &lt;&lt; endl;
	cout &lt;&lt; "通过C访问base类的basea：" &lt;&lt; c1.B::basea &lt;&lt; endl;

	/*第二个问题：多份同名，不同值的问题*/
	c1.A::basea = 5;
	c1.B::basea = 6;
	cout &lt;&lt; "c的basea的值：" &lt;&lt; c1.basea &lt;&lt; endl;
	cout &lt;&lt; "sizeof(C) is: " &lt;&lt; sizeof(C) &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     <img alt="" height="422" src="https://i-blog.csdnimg.cn/direct/ab0f878521ee48688f1aadbec4ed7767.png" width="889"/>
    </p>
    <h2>
     三、多态
    </h2>
    <p>
     多态允许一个类的对象被视为其他类的对象
    </p>
    <p>
     多态允许以一致的方式使用不同的类型的对象
    </p>
    <p>
     多态通过虚函数、指针/引用来实现
    </p>
    <p>
     多态分为
     <span style="background-color:#ffd900">
      静态多态
     </span>
     (函数重载、运算符重载)和
     <span style="background-color:#ffd900">
      动态多态
     </span>
     (虚函数、继承对象间的指针/引用)
    </p>
    <h3>
     3.1、静态多态
    </h3>
    <h4>
     3.1.1、函数重载
    </h4>
    <p>
     函数名必须相同，参数列表必须不同，返回值可以相同也可以不同
    </p>
    <h4>
     3.1.2、运算符重载
    </h4>
    <p>
     对于我们自定义的类，系统的内置运算符并不适用。因此需要重载运算符
    </p>
    <blockquote>
     <p>
      重载运算符：
     </p>
     <ul>
      <li>
       返回值类型 operator 运算符 (操作数列表) {相关操作}
      </li>
     </ul>
     <p>
      重载运算符的形式：
     </p>
     <ul>
      <li>
       使用内联函数：此时，函数为类的成员函数
      </li>
      <li>
       类内声明类外定义：此时，函数仅可以访问类的公有成员
      </li>
      <li>
       友元函数实现：此方式比较通用
      </li>
     </ul>
     <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class student {
public:
	/*使用成员函数实现 加号运算符 重载*/
	student&amp; operator+ (student&amp; st) {
		this-&gt;age += st.age;
		return *this;
	}
	/*使用友元函数实现 输出运算符 重载
	 *必须返回一个输出流对象的引用*/
	friend ostream&amp; operator&lt;&lt; (ostream&amp; os, student&amp; st);
	/*使用类内声明类外定义的方式实现 前置++和后置++运算符 重载
	 *此时，仅可访问类的公有成员*/
	student&amp; operator++ ();
	student operator++ (int);
	void print() {
		cout &lt;&lt; "age is: " &lt;&lt; age &lt;&lt; endl;
	}
	int score = 60;
private:
	string name = "lisi";
	int age = 23;
};
ostream&amp; operator&lt;&lt; (ostream&amp; os, student&amp; st) 
{
	os &lt;&lt; "name:" &lt;&lt; st.name &lt;&lt; " " &lt;&lt; "age:" &lt;&lt; st.age &lt;&lt; "score:" &lt;&lt; st.score &lt;&lt; endl;
	return os;
}

student&amp; student::operator++ ()
{
	++score;
	return *this;
}
student student::operator++ (int) 
{
	student tmp(*this);
	++score;
	return tmp;
}

int main(void)
{
	student st1, st2;
	st1.print();
	st1 + st2;
	st1.print();
	cout &lt;&lt; st1;
	st2 = st1++;
	cout &lt;&lt; st1.score &lt;&lt; endl;
	cout &lt;&lt; st2.score &lt;&lt; endl;
	cout &lt;&lt; st1 &lt;&lt; endl;
	cout &lt;&lt; st2 &lt;&lt; endl;
	return 0;
}</code></pre>
     <p>
     </p>
    </blockquote>
    <h3>
     3.2、动态多态
    </h3>
    <p>
     动态多态支持
     <span style="background-color:#ffd900">
      向上转型
     </span>
     而不支持向下转型。即一个派生类对象可以赋给一个基类的指针，但一个派生类指针不可以指向一个派生类对象
    </p>
    <p>
     重写是派生类重新实现(覆盖)基类中已有的虚函数(若不是虚函数，派生类无法覆盖基类的实现)，发生在继承关系中。重写会带来一定的内存开销和寻址延迟，但是相对于现在的计算机来说，并不是多大问题(虚函数本身是一个指针)
    </p>
    <p>
     当基类指针指向派生类对象时，如果基类的析构函数不是虚函数，编译器会根据指针的类型
     <span style="background-color:#ffd900">
      (基类)调用析构函数
     </span>
     ，而不会根据实际对象的类型
     <span style="background-color:#ffd900">
      (派生类)调用析构函数
     </span>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

/*fetchData和performAction是纯虚函数，所以Device是抽象类，该类不可以实例化对象
 *纯虚函数必须在派生类中实现
 *Device应该提供虚析构函数，否则，不会调用子类的析构函数*/
class Device {
public:
	virtual void fetchData() const = 0;
	virtual void performAction() const = 0;
	virtual ~Device() = default;
};

class TemperatureSensor : public Device {
public:
	void fetchData() const override {
		cout &lt;&lt; "Fetching temperature data." &lt;&lt; endl;
	}
	void performAction() const override {
	}
	~TemperatureSensor() {
		cout &lt;&lt; "delete T" &lt;&lt; endl;
	}
};

class LightController : public Device {
public:
	void fetchData() const override {
		cout &lt;&lt; "Fetching light data." &lt;&lt; endl;
	}
	void performAction() const override {
		cout &lt;&lt; "Adjusting light intensity" &lt;&lt; endl;
	}
	~LightController() {
		cout &lt;&lt; "delete L" &lt;&lt; endl;
	}
};

class SmartSocket : public Device {
public:
	void fetchData() const override {
		cout &lt;&lt; "Fetching power consumption data." &lt;&lt; endl;
	}
	void performAction() const override {
		cout &lt;&lt; "Turning on/off the smart socket" &lt;&lt; endl;
	}
	~SmartSocket() {
		cout &lt;&lt; "delete S" &lt;&lt; endl;
	}
};

int main(void)
{
	vector&lt;Device*&gt; devices;
	/*devices中有多个基类Device的指针，分别指向不同的派生类
	 *当使用基类的指针指向派生类时 并且基类中的函数使用virtual进行修饰时
	 *使用该指针调用函数时，派生类中的同名函数可以覆盖掉基类中的该函数*/
	devices.push_back(new TemperatureSensor());
	devices.push_back(new LightController());
	devices.push_back(new SmartSocket());

	for (const auto&amp; device : devices) {
		device-&gt;fetchData();
		device-&gt;performAction();
	}

	/*如果基类Device不定义虚析构函数，并且子类对象是通过new(动态申请内存)出来的
	 *清空Device类型的指针，并不会调用子类的析构函数
     *如果派生类中有动态分配的内存或其他资源(如文件句柄、网络连接等)，将会导致内存泄漏
     *此处，将调用deveces.size()次基类的析构函数*/
	for (const auto&amp; device : devices) {
		delete device;
	}
	return 0;
}</code></pre>
    <h2 style="background-color:transparent">
     四、友元
    </h2>
    <p>
     友元会破坏封装性，不能滥用
    </p>
    <p>
     友元不受类内访问权限的限制
    </p>
    <p>
     友元关系不具有传递性，并且是单向的。即，A是B的友元，B是C的友元，A不一定是C的友元，B不一定是A的友元
    </p>
    <h3>
     4.1、友元函数
    </h3>
    <p>
     友元函数通常声明在类中，定义在类外(也可以定义在类内，此时就是隐式的内联函数)
    </p>
    <p>
     友元函数不是类的成员函数，但是可以访问类的私有成员
    </p>
    <p>
     友元函数可以是全局函数，也可以是其他类的成员函数
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class MyClass {
private:
    int secretValue;

public:
    MyClass(int value) : secretValue(value) {}
    friend void showSecret(const MyClass&amp; obj);
};

void showSecret(const MyClass&amp; obj) {
    cout &lt;&lt; "Secret value: " &lt;&lt; obj.secretValue &lt;&lt; endl;
}

int main() {
    MyClass obj(42);
    showSecret(obj);
    return 0;
}</code></pre>
    <h3 style="background-color:transparent">
     4.2、友元类
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class MyClass {
private:
    int secretValue;

public:
    MyClass(int value) : secretValue(value) {}
    friend class FriendClass;
};

class FriendClass {
public:
    void showSecret(const MyClass&amp; obj) {
        cout &lt;&lt; "Secret value: " &lt;&lt; obj.secretValue &lt;&lt; endl;
    }
};

int main() {
    MyClass obj(42);
    FriendClass friendObj;
    friendObj.showSecret(obj);
    return 0;
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343634303031322f:61727469636c652f64657461696c732f313436323532393134" class_="artid" style="display:none">
 </p>
</div>


