---
layout: post
title: "六十天前端强化训练之第十五天React组件基础案例创建函数式组件展示用户信息第15-21天前端框架React"
date: 2025-03-10 23:07:50 +0800
description: "这篇博客讲解了React 核心组件，非常详细，有具体可运行代码，代码可以在GodePen上运行，还有具体案例供大家品尝，哈哈哈哈"
keywords: "六十天前端强化训练之第十五天React组件基础案例：创建函数式组件展示用户信息(第15-21天：前端框架（React）)"
categories: ['前端']
tags: ['前端框架', '前端', 'React', 'React']
artid: "146165428"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146165428
    alt: "六十天前端强化训练之第十五天React组件基础案例创建函数式组件展示用户信息第15-21天前端框架React"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146165428
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146165428
cover: https://bing.ee123.net/img/rand?artid=146165428
image: https://bing.ee123.net/img/rand?artid=146165428
img: https://bing.ee123.net/img/rand?artid=146165428
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     六十天前端强化训练之第十五天React组件基础案例：创建函数式组件展示用户信息(第15-21天：前端框架（React）)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p name="" style="text-align:center">
     <span style="background-color:#38d8f0">
      =====欢迎来到编程星辰海的博客讲解======
     </span>
    </p>
    <h6 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center">
     <a name="t0">
     </a>
     <a name="t0">
     </a>
     <a name="t0">
     </a>
     <img alt="" height="223" src="https://i-blog.csdnimg.cn/direct/2dd1d490b90e4ae3be835624605f4b3c.jpeg" width="493"/>
    </h6>
    <p>
     我们已经学了14天了，再坚持坚持，马上我们就可以变得更优秀了，加油，我相信大家，接下来的几天，我会给大家更新前端框架（React），看完可以给一个免费的三连吗，谢谢大佬！
    </p>
    <p>
     <span style="color:#fe2c24">
      代码都可以在godepen上运行的，大家可以复制代码试试
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <a class="link-info" href="https://codepen.io/accounts/signup/user/free/year?ownerId=null&amp;ownerType=null" rel="nofollow" title="https://codepen.io/accounts/signup/user/free/year?ownerId=null&amp;ownerType=null">
       https://codepen.io/accounts/signup/user/free/year?ownerId=null&amp;ownerType=null
      </a>
     </span>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f6178a047f364c94b693ff74bd11bc91.gif"/>
    </p>
    <hr/>
    <h4 id="%E4%B8%80%E3%80%81%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BD%93%E7%B3%BB" name="%E4%B8%80%E3%80%81%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BD%93%E7%B3%BB" style="background-color:transparent">
     一、组件核心概念体系
    </h4>
    <h5 id="1.1%20%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%93%B2%E5%AD%A6" name="1.1%20%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%93%B2%E5%AD%A6">
     <strong>
      1.1 组件化开发哲学
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       单一职责原则
      </strong>
      ：每个组件应专注于单一功能
     </li>
     <li>
      <strong>
       封装性
      </strong>
      ：内部实现细节对外隐藏，通过 Props 接口通信
     </li>
     <li>
      <strong>
       组合模式
      </strong>
      ：通过组件嵌套形成树形结构
     </li>
     <li>
      <strong>
       可重用性
      </strong>
      ：合理抽象提升组件复用率
     </li>
    </ul>
    <h5 id="1.2%20%E8%99%9A%E6%8B%9FDOM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" name="1.2%20%E8%99%9A%E6%8B%9FDOM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">
     1.2 虚拟DOM工作原理
    </h5>
    <p>
     JAVASCRIPT
    </p>
    <blockquote>
     <pre><code class="hljs">// 简化版虚拟DOM结构示例
const virtualNode = {
  type: 'div',
  props: {
    className: 'container',
    children: [
      { type: 'h1', props: { children: 'Hello World' } },
      { type: 'p', props: { children: 'React原理示例' } }
    ]
  }
};
</code></pre>
    </blockquote>
    <p>
     Diff 算法通过以下策略优化更新：
    </p>
    <ol>
     <li>
      同级比较策略
     </li>
     <li>
      Key 值优化列表比对
     </li>
     <li>
      组件类型判断（相同类型复用实例）
     </li>
    </ol>
    <hr/>
    <h4 id="%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90" name="%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90">
     二、函数式组件深度剖析
    </h4>
    <h5 id="2.1%20%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84" name="2.1%20%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84">
     <strong>
      2.1 基础结构
     </strong>
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">/**
 * 用户信息展示组件
 * @param {Object} props - 组件属性
 * @param {string} props.username - 用户名
 * @param {number} props.age - 用户年龄
 * @returns {JSX.Element} 用户信息卡片
 */
function UserInfo({ username, age }) {
  return (
    &lt;div className="user-card"&gt;
      &lt;h2&gt;{username}&lt;/h2&gt;
      &lt;p&gt;年龄: {age} 岁&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
    </blockquote>
    <h5 id="2.2%20Hooks%20%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F" name="2.2%20Hooks%20%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F">
     <strong>
      2.2 Hooks 生态系统
     </strong>
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">import React, { useState, useEffect, useMemo } from 'react';

const UserDashboard = () =&gt; {
  // 状态管理：用户数据
  const [users, setUsers] = useState([]);
  
  // 状态管理：加载状态
  const [loading, setLoading] = useState(false);
  
  // 状态管理：错误信息
  const [error, setError] = useState(null);

  // 计算属性：用户总数
  const userCount = useMemo(
    () =&gt; users.filter(user =&gt; user.isActive).length,
    [users]
  );

  // 副作用：数据获取
  useEffect(() =&gt; {
    const fetchUsers = async () =&gt; {
      setLoading(true);
      try {
        const response = await fetch('/api/users');
        if (!response.ok) throw new Error('数据获取失败');
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []); // 空依赖数组表示仅执行一次

  // 条件渲染处理
  if (loading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorDisplay message={error} /&gt;;

  return (
    &lt;div&gt;
      &lt;h3&gt;总用户数: {userCount}&lt;/h3&gt;
      &lt;div className="user-list"&gt;
        {users.map(user =&gt; (
          &lt;UserCard key={user.id} {...user} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h4 id="%E4%B8%89%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3" name="%E4%B8%89%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3">
     三、组件通信模式详解
    </h4>
    <h5 id="3.1%20%E7%88%B6%E2%86%92%E5%AD%90%E9%80%9A%E4%BF%A1%EF%BC%88Props%EF%BC%89" name="3.1%20%E7%88%B6%E2%86%92%E5%AD%90%E9%80%9A%E4%BF%A1%EF%BC%88Props%EF%BC%89">
     <strong>
      3.1 父→子通信（Props）
     </strong>
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">// 父组件
const UserManagement = () =&gt; {
  const [userList, setUserList] = useState(initialUsers);

  const handleUserUpdate = (updatedUser) =&gt; {
    setUserList(prev =&gt; 
      prev.map(user =&gt; 
        user.id === updatedUser.id ? updatedUser : user
      )
    );
  };

  return (
    &lt;div&gt;
      &lt;UserTable 
        users={userList} 
        onEdit={handleUserUpdate}
      /&gt;
    &lt;/div&gt;
  );
};

// 子组件
const UserTable = ({ users, onEdit }) =&gt; (
  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      {users.map(user =&gt; (
        &lt;tr key={user.id}&gt;
          &lt;td&gt;{user.name}&lt;/td&gt;
          &lt;td&gt;
            &lt;button onClick={() =&gt; onEdit(user)}&gt;
              编辑
            &lt;/button&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      ))}
    &lt;/tbody&gt;
  &lt;/table&gt;
);
</code></pre>
    </blockquote>
    <h5 id="3.2%20%E5%AD%90%E2%86%92%E7%88%B6%E9%80%9A%E4%BF%A1%EF%BC%88%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%89" name="3.2%20%E5%AD%90%E2%86%92%E7%88%B6%E9%80%9A%E4%BF%A1%EF%BC%88%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%89">
     <strong>
      3.2 子→父通信（回调函数）
     </strong>
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">const SearchBar = ({ onSearch }) =&gt; {
  const [query, setQuery] = useState('');

  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    onSearch(query.trim());
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="text"
        value={query}
        onChange={(e) =&gt; setQuery(e.target.value)}
        placeholder="输入搜索关键词..."
      /&gt;
      &lt;button type="submit"&gt;搜索&lt;/button&gt;
    &lt;/form&gt;
  );
};

// 父组件使用
&lt;SearchBar onSearch={(keyword) =&gt; filterData(keyword)} /&gt;
</code></pre>
    </blockquote>
    <h5 id="3.3%20Context%20%E8%B7%A8%E5%B1%82%E9%80%9A%E4%BF%A1" name="3.3%20Context%20%E8%B7%A8%E5%B1%82%E9%80%9A%E4%BF%A1">
     <strong>
      3.3 Context 跨层通信
     </strong>
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">// 创建 Context
const ThemeContext = React.createContext('light');

// 提供者组件
const App = () =&gt; {
  const [theme, setTheme] = useState('light');

  return (
    &lt;ThemeContext.Provider value={<!-- -->{ theme, setTheme }}&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
};

// 消费者组件
const ThemedButton = () =&gt; {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    &lt;button 
      style={<!-- -->{ 
        background: theme === 'dark' ? '#333' : '#fff',
        color: theme === 'dark' ? '#fff' : '#333'
      }}
      onClick={() =&gt; setTheme(theme === 'dark' ? 'light' : 'dark')}
    &gt;
      切换主题
    &lt;/button&gt;
  );
};
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h4 id="%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B8%A6%E4%BA%A4%E4%BA%92%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86" name="%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B8%A6%E4%BA%A4%E4%BA%92%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">
     实战案例：带交互的用户信息管理
    </h4>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">import React, { useState, useEffect } from 'react';

/**
 * 用户信息管理系统
 * 功能：
 * 1. 展示用户列表
 * 2. 支持新增用户
 * 3. 支持删除用户
 * 4. 实时搜索过滤
 */
const UserManager = () =&gt; {
  // 主数据状态
  const [users, setUsers] = useState([]);
  
  // 搜索关键词状态
  const [searchTerm, setSearchTerm] = useState('');
  
  // 新用户表单状态
  const [newUser, setNewUser] = useState({
    name: '',
    email: '',
    role: 'user'
  });

  // 模拟初始化数据
  useEffect(() =&gt; {
    const initialUsers = [
      { id: 1, name: '张三', email: 'zhang@example.com', role: 'admin' },
      { id: 2, name: '李四', email: 'li@example.com', role: 'user' }
    ];
    setUsers(initialUsers);
  }, []);

  // 处理表单输入
  const handleInputChange = (e) =&gt; {
    const { name, value } = e.target;
    setNewUser(prev =&gt; ({
      ...prev,
      [name]: value
    }));
  };

  // 提交新用户
  const handleAddUser = (e) =&gt; {
    e.preventDefault();
    if (!newUser.name || !newUser.email) return;

    const userToAdd = {
      ...newUser,
      id: Date.now() // 临时ID生成方式
    };

    setUsers(prev =&gt; [...prev, userToAdd]);
    setNewUser({ name: '', email: '', role: 'user' });
  };

  // 删除用户
  const handleDelete = (userId) =&gt; {
    setUsers(prev =&gt; prev.filter(user =&gt; user.id !== userId));
  };

  // 过滤用户列表
  const filteredUsers = users.filter(user =&gt;
    user.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    &lt;div className="user-manager"&gt;
      {/* 搜索栏 */}
      &lt;div className="search-section"&gt;
        &lt;input
          type="text"
          placeholder="搜索用户..."
          value={searchTerm}
          onChange={(e) =&gt; setSearchTerm(e.target.value)}
        /&gt;
      &lt;/div&gt;

      {/* 添加用户表单 */}
      &lt;form onSubmit={handleAddUser} className="add-form"&gt;
        &lt;input
          name="name"
          placeholder="姓名"
          value={newUser.name}
          onChange={handleInputChange}
          required
        /&gt;
        &lt;input
          name="email"
          type="email"
          placeholder="邮箱"
          value={newUser.email}
          onChange={handleInputChange}
          required
        /&gt;
        &lt;select
          name="role"
          value={newUser.role}
          onChange={handleInputChange}
        &gt;
          &lt;option value="user"&gt;普通用户&lt;/option&gt;
          &lt;option value="admin"&gt;管理员&lt;/option&gt;
        &lt;/select&gt;
        &lt;button type="submit"&gt;添加用户&lt;/button&gt;
      &lt;/form&gt;

      {/* 用户列表 */}
      &lt;div className="user-list"&gt;
        {filteredUsers.map(user =&gt; (
          &lt;div key={user.id} className="user-card"&gt;
            &lt;div className="user-info"&gt;
              &lt;h3&gt;{user.name}&lt;/h3&gt;
              &lt;p&gt;{user.email}&lt;/p&gt;
              &lt;span className={`role-tag ${user.role}`}&gt;
                {user.role === 'admin' ? '管理员' : '用户'}
              &lt;/span&gt;
            &lt;/div&gt;
            &lt;button 
              className="delete-btn"
              onClick={() =&gt; handleDelete(user.id)}
            &gt;
              删除
            &lt;/button&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default UserManager;
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h4 id="%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA" name="%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA" style="background-color:transparent">
     功能演示
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/608a33359e414cca9e0b62de11e8d745.png"/>
    </p>
    <ol>
     <li>
      实时搜索用户
     </li>
     <li>
      添加新用户表单验证
     </li>
     <li>
      用户角色标识
     </li>
     <li>
      删除确认操作
     </li>
     <li>
      响应式布局
     </li>
    </ol>
    <hr/>
    <h4 id="%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93" name="%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93" style="background-color:transparent">
     关键知识点总结
    </h4>
    <ol>
     <li>
      <h5 id="%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5" name="%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5">
       <strong>
        状态管理策略
       </strong>
      </h5>
      <ul>
       <li>
        使用
        <code>
         useState
        </code>
        管理组件内部状态
       </li>
       <li>
        状态提升：将共享状态移动到最近的共同祖先组件
       </li>
       <li>
        状态合并：使用扩展运算符保持状态不变性
       </li>
      </ul>
     </li>
     <li>
      <h5 id="%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" name="%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">
       <strong>
        列表渲染最佳实践
       </strong>
      </h5>
      <ul>
       <li>
        始终提供稳定的
        <code>
         key
        </code>
        属性
       </li>
       <li>
        复杂列表使用虚拟滚动优化性能
       </li>
       <li>
        分离列表项为独立子组件
       </li>
      </ul>
     </li>
     <li>
      <h5 id="%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F" name="%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F">
       <strong>
        表单处理模式
       </strong>
      </h5>
      <ul>
       <li>
        受控组件 vs 非受控组件
       </li>
       <li>
        表单验证实现方案
       </li>
       <li>
        使用
        <code>
         name
        </code>
        属性批量处理输入
       </li>
      </ul>
     </li>
     <li>
      <h5 id="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5" name="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">
       <strong>
        性能优化手段
       </strong>
      </h5>
      <ul>
       <li>
        <code>
         React.memo
        </code>
        记忆组件
       </li>
       <li>
        <code>
         useCallback
        </code>
        缓存函数引用
       </li>
       <li>
        <code>
         useMemo
        </code>
        避免重复计算
       </li>
       <li>
        按需加载组件 (
        <code>
         React.lazy
        </code>
        )
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        错误边界处理
       </strong>
      </p>
      <ul>
       <li>
        使用
        <code>
         try/catch
        </code>
        处理同步错误
       </li>
       <li>
        异步操作的错误处理
       </li>
       <li>
        全局错误边界组件
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4 id="%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84" name="%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84" style="background-color:transparent">
     扩展学习路径
    </h4>
    <ol>
     <li>
      <h5 id="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%B2%BE%E8%AF%BB" name="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%B2%BE%E8%AF%BB">
       <strong>
        官方文档精读
       </strong>
      </h5>
      <ul>
       <li>
        <a href="https://reactjs.org/docs/state-and-lifecycle.html" rel="nofollow" title="状态管理进阶">
         状态管理进阶
        </a>
       </li>
       <li>
        <a href="https://reactjs.org/docs/hooks-intro.html" rel="nofollow" title="Hooks 深度指南">
         Hooks 深度指南
        </a>
       </li>
       <li>
        <a href="https://reactjs.org/docs/context.html" rel="nofollow" title="上下文 API 最佳实践">
         上下文 API 最佳实践
        </a>
       </li>
      </ul>
     </li>
     <li>
      <h5 id="%E7%A4%BE%E5%8C%BA%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90" name="%E7%A4%BE%E5%8C%BA%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90">
       <strong>
        社区优质资源
       </strong>
      </h5>
      <ul>
       <li>
        <a href="https://reactpatterns.com/" rel="nofollow" title="React 模式大全">
         React 模式大全
        </a>
       </li>
       <li>
        <a href="https://usehooks.com/" rel="nofollow" title="Hooks 常见问题解答">
         Hooks 常见问题解答
        </a>
       </li>
       <li>
        <a href="https://github.com/GoogleChromeLabs/react-optimization-guide" title="React 性能优化手册">
         React 性能优化手册
        </a>
       </li>
      </ul>
     </li>
     <li>
      <h5 id="%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7%E9%93%BE" name="%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7%E9%93%BE">
       <strong>
        推荐工具链
       </strong>
      </h5>
      <ul>
       <li>
        状态管理：Redux Toolkit / Recoil
       </li>
       <li>
        路由管理：React Router v6
       </li>
       <li>
        样式方案：Styled-components / CSS Modules
       </li>
       <li>
        测试框架：Jest + React Testing Library
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4 id="%E8%BF%9B%E9%98%B6%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1" name="%E8%BF%9B%E9%98%B6%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1" style="background-color:transparent">
     进阶挑战任务
    </h4>
    <ol>
     <li>
      为删除操作添加确认对话框
     </li>
     <li>
      实现用户编辑功能
     </li>
     <li>
      添加本地存储持久化
     </li>
     <li>
      集成后端 API 接口
     </li>
     <li>
      添加分页加载功能
     </li>
     <li>
      实现角色权限控制
     </li>
    </ol>
    <h5 id="%E4%B8%80%E3%80%81%E4%B8%BA%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%B7%BB%E5%8A%A0%E7%A1%AE%E8%AE%A4%E5%AF%B9%E8%AF%9D%E6%A1%86" name="%E4%B8%80%E3%80%81%E4%B8%BA%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%B7%BB%E5%8A%A0%E7%A1%AE%E8%AE%A4%E5%AF%B9%E8%AF%9D%E6%A1%86">
     一、为删除操作添加确认对话框
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">const DeleteConfirmDialog = ({ onConfirm, onCancel }) =&gt; (
  &lt;div className="confirm-dialog"&gt;
    &lt;p&gt;确定要删除该用户吗？&lt;/p&gt;
    &lt;div className="dialog-actions"&gt;
      &lt;button onClick={onConfirm}&gt;确认删除&lt;/button&gt;
      &lt;button onClick={onCancel}&gt;取消&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

// 使用示例
const handleDelete = (userId) =&gt; {
  const confirm = window.confirm('确定要删除该用户吗？');
  if (confirm) {
    setUsers(prev =&gt; prev.filter(user =&gt; user.id !== userId));
  }
};
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h5 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD" name="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD" style="background-color:transparent">
     二、实现用户编辑功能
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">const UserEditor = ({ user, onSave, onCancel }) =&gt; {
  const [editData, setEditData] = useState(user);

  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    onSave(editData);
  };

  return (
    &lt;div className="edit-form"&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;input
          value={editData.name}
          onChange={(e) =&gt; setEditData({...editData, name: e.target.value})}
        /&gt;
        &lt;input
          value={editData.email}
          onChange={(e) =&gt; setEditData({...editData, email: e.target.value})}
        /&gt;
        &lt;div className="form-actions"&gt;
          &lt;button type="submit"&gt;保存&lt;/button&gt;
          &lt;button type="button" onClick={onCancel}&gt;取消&lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};

// 在用户卡片中添加：
{isEditing ? (
  &lt;UserEditor 
    user={user}
    onSave={(updated) =&gt; handleUpdateUser(updated)}
    onCancel={() =&gt; setEditingId(null)}
  /&gt;
) : (
  &lt;button onClick={() =&gt; setEditingId(user.id)}&gt;编辑&lt;/button&gt;
)}
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h5 id="%E4%B8%89%E3%80%81%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96" name="%E4%B8%89%E3%80%81%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96">
     三、添加本地存储持久化
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">// 自定义Hook
const useLocalStorage = (key, initialValue) =&gt; {
  const [value, setValue] = useState(() =&gt; {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() =&gt; {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
};

// 使用示例
const [users, setUsers] = useLocalStorage('users', []);
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h5 id="%E5%9B%9B%E3%80%81%E9%9B%86%E6%88%90%E5%90%8E%E7%AB%AFAPI%E6%8E%A5%E5%8F%A3" name="%E5%9B%9B%E3%80%81%E9%9B%86%E6%88%90%E5%90%8E%E7%AB%AFAPI%E6%8E%A5%E5%8F%A3">
     四、集成后端API接口
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">const api = {
  fetchUsers: async (page = 1) =&gt; {
    const response = await fetch(`/api/users?page=${page}`);
    return response.json();
  },
  
  createUser: async (user) =&gt; {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(user)
    });
    return response.json();
  }
};

// 在组件中使用
useEffect(() =&gt; {
  const loadData = async () =&gt; {
    setLoading(true);
    try {
      const data = await api.fetchUsers();
      setUsers(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  loadData();
}, []);
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h5 id="%E4%BA%94%E3%80%81%E6%B7%BB%E5%8A%A0%E5%88%86%E9%A1%B5%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD" name="%E4%BA%94%E3%80%81%E6%B7%BB%E5%8A%A0%E5%88%86%E9%A1%B5%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD">
     五、添加分页加载功能
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">const Pagination = ({ current, total, onChange }) =&gt; (
  &lt;div className="pagination"&gt;
    {Array.from({length: total}, (_, i) =&gt; (
      &lt;button
        key={i+1}
        className={current === i+1 ? 'active' : ''}
        onClick={() =&gt; onChange(i+1)}
      &gt;
        {i+1}
      &lt;/button&gt;
    ))}
  &lt;/div&gt;
);

// 使用示例
const [currentPage, setCurrentPage] = useState(1);
const [totalPages, setTotalPages] = useState(1);

useEffect(() =&gt; {
  const loadPage = async () =&gt; {
    const { data, total } = await api.fetchUsers(currentPage);
    setUsers(data);
    setTotalPages(total);
  };
  loadPage();
}, [currentPage]);
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h5 id="%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" name="%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">
     六、实现角色权限控制
    </h5>
    <p>
     JSX
    </p>
    <blockquote>
     <pre><code class="hljs">// 创建权限上下文
const AuthContext = React.createContext();

const AuthProvider = ({ children }) =&gt; {
  const [currentUser, setCurrentUser] = useState({
    role: 'admin' // 从登录获取实际值
  });

  const hasPermission = (requiredRole) =&gt; {
    return currentUser.role === requiredRole;
  };

  return (
    &lt;AuthContext.Provider value={<!-- -->{ hasPermission }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
};

// 在组件中使用
const { hasPermission } = useContext(AuthContext);

{hasPermission('admin') &amp;&amp; (
  &lt;button onClick={handleEdit}&gt;编辑&lt;/button&gt;
)}
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h5 id="%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA" name="%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA" style="background-color:transparent">
     <font face="monospace">
      功能演示
     </font>
    </h5>
    <p style="text-align:center">
     <font face="monospace">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/05de7c7724aa421e89e5e370b454f3b1.png"/>
     </font>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/1a9a3a3e768c4d3d80a82a734fed94d5.png"/>
    </p>
    <p>
     每个功能模块都可以独立实现并逐步集成，建议按以下顺序进行开发：
    </p>
    <ol>
     <li>
      添加本地存储持久化
     </li>
     <li>
      实现API集成
     </li>
     <li>
      添加分页功能
     </li>
     <li>
      实现编辑功能
     </li>
     <li>
      添加权限控制
     </li>
     <li>
      最后实现确认对话框
     </li>
    </ol>
    <p>
     通过本案例可以完整掌握 React 核心组件的开发流程，建议结合实际项目需求扩展功能模块。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f737065616b696e675f6d652f:61727469636c652f64657461696c732f313436313635343238" class_="artid" style="display:none">
 </p>
</div>


