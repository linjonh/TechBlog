---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f6378673139383730333133:2f61727469636c652f64657461696c732f3530353230323936"
layout: post
title: "openstack中虚拟机CPU与内存布局设计三"
date: 2024-04-15 15:50:40 +08:00
description: "接前文------------------------------分割线--------------"
keywords: "虚拟cpu拓扑可以通过元数据在镜像和"
categories: ['Openstack']
tags: ['操作系统', 'Thp', 'Socket', 'Openstack', 'Numa']
artid: "50520296"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=50520296
    alt: "openstack中虚拟机CPU与内存布局设计三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=50520296
featuredImagePreview: https://bing.ee123.net/img/rand?artid=50520296
---

# openstack中虚拟机CPU与内存布局设计(三)

接前文

------------------------------分割线-----------------------------------------

**设计**

**许可**

一般来说，运行的虚拟机无时无刻不在消耗着有限的资源，因此，云平台管理员必须对每一次的资源申请有绝对的控制。这反过来又意味着，大多数的配置工作将在主机级别进行(nova.conf等)。对于最终用户而言，只允许进行不影响超出主机类型允许的限制范围内的镜像级别的配置。 从这里可以看出，这个允许配置的镜像级别的参数应该与虚拟CPU拓扑相关，首先是一个遵守软件许可限制的机制，而对主机资源利用率的影响可以忽略不计。

**配置**

从背景知识我们能够清晰的认识到，为了最大化利用主机资源，好好利用NUMA与大页内存等工具显得尤为重要。及时使用默认配置，nova也能够做到NUMA布局的优化以及考虑到大页内存的使用。显式的配置只是为了满足性能优化或者虚拟机个性化需求，亦或者云平台提供商希望为不同的价格方案设置认为的设置。

**虚拟CPU拓扑**

• 终端用户可以通过配置他们的操作系统镜像，选择封装套件(socket)与处理单元(core)的设置

• 遵从操作系统许可需求，限制虚拟机使用的拓扑(例如max\_sockets==2)

• 云平台管理员可以通过配置虚拟机类型(flavor)，来配置虚拟CPU拓扑。

• 限制用户可以使用的拓扑，以防止用户使用非最优NUMA拓扑方案

• 设置默认的拓扑参数(例如max\_sockets==2)，以保证虚拟机操作系统镜像能够满足常规操作系统许可，而不必每一个用户都去设置镜像属性。

• 当用户镜像约束与云平台管理员的虚拟机类型约束冲突时，以虚拟机类型约束为准

如前文讨论，只有当虚拟机的虚拟CPU与主机的物理CPU一一绑定时，配置超线程参数(threads != 1)才有意义。这不是一个最终用户需要考虑的东西，但是云平台管理员希望能够通过设置虚拟机类型明确避免使用主机超线程。这可以通过使用主机聚合调度的方式实现。

由上可知，虚拟CPU拓扑遵循以下参数设置：

• 镜像设置

• sockets=N (实际希望使用的socket数量；如果不设置，则从其他设置计算得出)

• cores=N (实际希望使用的core数量；如果不设置，则从其他设置计算得出)

• max\_sockets=N (限制最大支持的socket数量；如果不设置，则不受限制)

• max\_cores=N (限制最大支持的core数量；如果不设置，则不受限制)

• 虚拟机类型设置

• sockets=N (默认使用的socket数量；如果不设置，则使用vcpu或者vcpus/cores的值)

• cores=N (默认使用的core数量；如果不设置，则使用vcpus/sockets的值)

• max\_sockets=N (限制最大支持的socket数量；如果不设置，则不限制)

• max\_cores=N (限制最大支持的core数量；如果不设置，则不受限制)

虚拟机烈性设置与镜像参数设置冲突时以虚拟机类型参数为准。

典型应用

• 默认设置

• N flavour vCPUs == N sockets

• 允许NUMA布局使用最大的灵活性

• 云平台管理员设置虚拟机类型参数sockets=2

• 处理单元(core)通过通过vcpu/socket得出，例如，6个vcpu，可以得到3个处理单元(core)和两个封装元件(socket)

• 这种情况下，Windows操作系统将不会受到许可限制

• 用户设置镜像参数
max\_sockets=2

• 当虚拟机类型参数中vCPU数量大于2时，将会使用core参数

• 遵循Windows操作系统许可限制

• 用户设置镜像参数cores=4

• 如果虚拟机类型中的max\_cores不小于4，虚拟机将一直使用4个处理单元(core)

• 如果虚拟机类型中有4个虚拟CPU，虚拟机会使用一个socket，同时也只能定义一个NUMA单元

**NUMA拓扑**

• 云平台管理员可以通过虚拟机类型(flavor)定义虚拟机NUMA单元

• 强制虚拟机内存作为多NUMA单元，从而允许在主机NUMA单元上使用更多有效的布局

• 云平台管理员声明vCPU拓扑以保证每个封装元件(socket)使用一个NUMA单元，例如设置两个NUMA单元时，应该至少设置min\_sockets=2

一个简单的方法是简单地指定所需NUMA单元的数量，内存(RAM)和封装元件(socket)p平均分配到每个单元中。这将最大程度的降低配置参数的复杂性。如果没有NUMA单元数的定义，管理程序可以在虚拟机上自由使用NUMA拓扑。可能会出现下面的情况，主机调度器会选择多种可行的NUMA配置，但是管理员可能希望限制使用NUMA单元的数量。

• 默认配置

• 虚拟化管理程序基于虚拟主机的提供的能力为虚拟机选择适合的NUMA单元以满足虚拟机内存与CPU分配

• 云平台管理员设置虚拟机类型参数numa\_nodes=1

• 虚拟化管理程序将不为虚拟机设置NUMA拓扑，即使虚拟机内存与CPU分配超出主机单个NUMA单元的能力。

• 云平台管理员设置虚拟机类型参数numa\_max\_nodes=2

• 虚拟化管理程序将会选择虚拟机最多使用两个NUMA单元的主机。所以，虚拟机可以布局在一个NUMAdna元上，也可以布局在两个NUMA单元上，但是绝对不能布局在4个NUMA单元上。

• 云平台管理员设置虚拟机类型参数numa\_nodes=2

• 虚拟化管理程序设置两个虚拟机NUMA单元，并且平均分配内存与CPU到这两个单元。It will not use a host where theguest fits in 1 NUMA node, nor 4 NUMA nodes.

• 云平台管理员设置虚拟机类型参数vcpus=6,numa\_nodes=2,vcpus.0=0,1,vcpus.1:2,3,4,5,mem.0=2,mem.1=4

• 虚拟化管理程序设置两个NUMAdna元，第一个NUMA单元分配虚拟CPU0/1，2GB内存，第二个单元分配虚拟CPU2/3/4/5，4GB内存。

注意，虚拟机如何在主机NUMA单元上布局，并不由管理员决定，而是由虚拟化管理程序基于虚拟机拓扑的配置决定。调度器能够提供选择主机的规则，使得主机的NUMA拓扑能够符合虚拟机类型的设置。

**大页内存**

• 云平台管理员可以通过虚拟机类型定义大页内存的使用策略

• 设置策略，使得虚拟机类型中使用1GB的大页内存，以确保高性能

• 设置虚拟机类型中关于使用或者不使用大页内存的策略

• 默认设置

• 虚拟化管理程序选择是否使用大页内存

• 云平台管理员设置虚拟机类型参数page\_sizes=large

• 只有当系统中有可用大页内存时，虚拟化程序才启动虚拟机。

• 云平台管理员设置虚拟机类型参数page\_sizes=any

• 虚拟化管理程序将会优先尝试大页内存，不可用时，使用小页内存启动虚拟机。

• 云平台管理员设置虚拟机类型参数
page\_sizes
=small

• 虚拟机程序将不选择大页内存启动虚拟机，即使大页内存可用。

• 云平台管理员设置虚拟机类型参数page\_sizes=1GB

• 只有当系统中有可用的1GB大页内存时，虚拟化管理程序才启动虚拟机，并且将不会使用2MB的大页内存。

**专用资源**

• 云平台管理员可以通过虚拟机类型定义专用物理CPU

• 使用定义了专用物理CPU的虚拟机类型，虚拟机可以避免其他虚拟机争用CPU

• 云平台管理员可以通过虚拟机类型定义独占的物理CPU

• 使虚拟机避免与其他虚拟机、系统服务或者内核线程争用物理CPU

基于此，可以配置以下场景：

• 默认配置

• 虚拟化管理程序将不配置专用资源

• 云平台管理员设置虚拟机类型参数

overcommit\_ram
=0

• 虚拟化管理程序将会为虚拟机分配专用内存，而不设置专用CPU

• 云平台管理员设置虚拟机类型参数
overcommit\_vcpus
=0

• 虚拟化管理程序将会为虚拟机分配专用CPU，而不设置专用内存

• 云平台管理员设置虚拟机类型参数overcommit\_ram=0,overcommit\_vcpus=0

• 虚拟化管理程序将会为虚拟机分配专用CPU与内存

**调度**

Libvirt与其他虚拟化驱动(Xenapi等)都可以获取CPU信息。对于libvirt，只有当发生虚拟机热迁移时，才会使用这些信息，用于校验源主机与目的主机的虚拟化管理程序之间的兼容性，其他情况下不会使用这些信息。CPU信息数据不包括任何NUMA信息以及使用情况。为保证调度可用，计算主机必须能够通过调度程序暴露必须的信息。

保存在数据库里的json格式的数据，应当被转化为虚拟化驱动能够处理的格式化数据。就性能而言，改变数据库存储数据的方式尤为必要，尤其对于调度过程。

云平台允许拥有专用资源的虚拟机运行，从此背景看，调度器至少应能够满足为虚拟机分配虚拟主机，而不管虚拟机是否需要专用专用资源。但是，并非所有的部署，都需要严格的区分专用资源与非专用资源，因为这样会丧失计算主机的使用效率与灵活性。因此，需要能够在一台计算主机上同时运行专用资源虚拟机与非专用资源虚拟机。 例如，如果一台计算主机拥有8GB内存，同时保留2GB大页内存，那么它可以运行需要2GB专用资源的虚拟机，并且同时也还有6GB内存共其他虚拟机使用。

**虚拟CPU拓扑**

Libvirt驱动可以获取物理CPU拓扑(例如sockets, cores, threads等信息)，但是不能提供CPU资源的利用信息。使用单个NUMA单元时，封装元件(socket)与处理单元(core)并没有显著的性能差别，调度程序不必关心host/guest与core/socket的匹配。一旦调度程序确定了NUMA单元数，core与socket的数量将由计算节点的虚拟化驱动决定。

如果虚拟机类型设置了线程非亲和特性，调度器将会避免将虚拟机布局在物理CPU开启了超线程的主机上。

**NUMA布局**

调度器使用虚拟机类型的参数numa\_nodes决定如何布置虚拟机。

如果没有设置numa\_nodes参数, 调度器将自由决定在哪里运行虚拟机，而不关心单个NUMA单元是否能够满足虚拟机类型中的内存设置，尽管仍然会优先考虑一个NUMA单元可以满足情况的主机。

如果参数numa\_nodes设置为1, 调度器 将会选择单个NUMA单元能够满足虚拟机类型中内存设置的主机。

如果参数numa\_nodes设置大于1,调度器将会选择NUMA单元数量与NUMA单元内内存能够满足虚拟机类型中numa\_nodes参数与内存设置的主机。

计算节点将会暴露他们的NUMA拓扑信息(例如，每个NUMA单元上有多少CPU和内存)，以及当前的资源利用率。设计中，需要将这些数据加入到计算节点的数据模型中。

**大页内存**

与NUMA不同，如果虚拟机类型中声明了大页内存，则需要主机能够进行预留该内存块。因为这些内存同时也作为该主机上的NUMA单元专用内存，所以必须提前显式声明。例如，如果主机配置了大页内存，也应该从NUMA单元中分配。

透明巨型页技术允许主机出现内存超配，并且调度程序可以使用该特性。

如果主机支持内存预分配，主机将会上报是否支持保留内存或者THP，甚至在严格条件下，可以上报剩余可用内存页数。

通过上述设计，如果虚拟机使用的主机类型中将huge\_pages参数设置为'strict'时，并且没有主机在单NUMA单元中拥有足够的大页内存可用，调度器将会返回失败。

**参考文献**

[1]
<http://specs.openstack.org/openstack/nova-specs/specs/juno/implemented/virt-driver-numa-placement.html>

[2]
<http://specs.openstack.org/openstack/nova-specs/specs/juno/implemented/virt-driver-vcpu-topology.html>

[3]
<http://specs.openstack.org/openstack/nova-specs/specs/juno/approved/virt-driver-cpu-pinning.html>

[4]
<http://specs.openstack.org/openstack/nova-specs/specs/juno/approved/virt-driver-large-pages.html>