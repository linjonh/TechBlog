---
layout: post
title: "Modbus通信协议详解"
date: 2022-07-29 11:54:51 +0800
description: "Modbus通信协议详解_modbus"
keywords: "modbus"
categories: ['物联网']
tags: ['网络']
artid: "126052423"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=126052423
    alt: "Modbus通信协议详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=126052423
featuredImagePreview: https://bing.ee123.net/img/rand?artid=126052423
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Modbus通信协议详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Modbus__0">
     </a>
     一、Modbus 协议简介
    </h2>
    <p>
     Modbus 协议是应用于电子控制器上的一种通用语言。通过此协议，控制器相互之间、控制器经由网络（例如以太网）和其它设备之间可以通信。它已经成为一通用工业标准。有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。
    </p>
    <p>
     此协议定义了一个控制器能认识使用的消息结构,而不管它们是经过何种网络进行通信的。它描述了一控制器请求访问其它设备的过程，如果回应来自其它设备的请求，以及怎样侦测错误并记录。它制定了消息域格局和内容的公共格式。
    </p>
    <p>
     当在一Modbus网络上通信时，此协议决定了每个控制器须要知道它们的设备地址，识别按地址发来的消息，决定要产生何种行动。如果需要回应，控制器将生成反馈信息并用Modbus协议发出。在其它网络上，包含了Modbus协议的消息转换为在此网络上使用的帧或包结构。这种转换也扩展了根据具体的网络解决节地址、路由路径及错误检测的方法。
    </p>
    <h3>
     <a id="1Modbus_8">
     </a>
     1、在Modbus网络上转输
    </h3>
    <p>
     标准的Modbus口是使用一RS-232C兼容串行接口，它定义了连接口的针脚、电缆、信号位、传输波特率、奇偶校验。控制器能直接或经由Modem组网。
    </p>
    <p>
     控制器通信使用主—从技术，即仅一设备（主设备）能初始化传输（查询）。其它设备（从设备）根据主设备查询提供的数据作出相应反应。典型的主设备：主机和可编程仪表。典型的从设备：可编程控制器。
    </p>
    <p>
     主设备可单独和从设备通信，也能以广播方式和所有从设备通信。如果单独通信，从设备返回一消息作为回应，如果是以广播方式查询的，则不作任何回应。Modbus协议建立了主设备查询的格式：设备（或广播）地址、功能代码、所有要发送的数据、一错误检测域。
    </p>
    <p>
     从设备回应消息也由Modbus协议构成，包括确认要行动的域、任何要返回的数据、和一错误检测域。如果在消息接收过程中发生一错误，或从设备不能执行其命令，从设备将建立一错误消息并把它作为回应发送出去。
    </p>
    <h3>
     <a id="2_20">
     </a>
     2、在其它类型网络上转输
    </h3>
    <p>
     在其它网络上，控制器使用对等技术通信，故任何控制都能初始和其它控制器的通信。这样在单独的通信过程中，控制器既可作为主设备也可作为从设备。提供的多个内部通道可允许同时发生的传输进程。
    </p>
    <p>
     在消息位，Modbus协议仍提供了主—从原则，尽管网络通信方法是“对等”。如果一控制器发送一消息，它只是作为主设备，并期望从从设备得到回应。同样，当控制器接收到一消息，它将建立一从设备回应格式并返回给发送的控制器。
    </p>
    <h3>
     <a id="3_26">
     </a>
     3、查询—回应周期
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/91a953dabc4da48197e46e9c36a9ee34.png"/>
    </p>
    <h4>
     <a id="1_28">
     </a>
     （1）查询
    </h4>
    <p>
     查询消息中的功能代码告之被选中的从设备要执行何种功能。数据段包含了从设备要执行功能的任何附加信息。例如功能代码03是要求从设备读保持寄存器并返回它们的内容。数据段必须包含要告之从设备的信息：从何寄存器开始读及要读的寄存器数量。错误检测域为从设备提供了一种验证消息内容是否正确的方法。
    </p>
    <h4>
     <a id="2_32">
     </a>
     （2）回应
    </h4>
    <p>
     如果从设备产生一正常的回应，在回应消息中的功能代码是在查询消息中的功能代码的回应。数据段包括了从设备收集的数据：象寄存器值或状态。如果有错误发生，功能代码将被修改以用于指出回应消息是错误的，同时数据段包含了描述此错误信息的代码。错误检测域允许主设备确认消息内容是否可用。
    </p>
    <h2>
     <a id="_37">
     </a>
     二、两种传输方式
    </h2>
    <p>
     控制器能设置为两种传输模式（ASCII或RTU）中的任何一种在标准的Modbus网络通信。用户选择想要的模式，包括串口通信参数（波特率、校验方式等），在配置每个控制器的时候，在一个Modbus网络上的所有设备都必须选择相同的传输模式和串口参数。
    </p>
    <blockquote>
     <p>
      ASCII模式
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d439e0ad5f2e4cfb030ccd5f28112e7a.png"/>
    </p>
    <blockquote>
     <p>
      RTU模式
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/942f4d0a6a5fbc62943d54474899f796.png"/>
     </p>
    </blockquote>
    <p>
     <strong>
      <code>
       所选的ASCII或RTU方式仅适用于标准的Modbus网络
      </code>
     </strong>
     ，它定义了在这些网络上连续传输的消息段的每一位，以及决定怎样将信息打包成消息域和如何解码。
    </p>
    <p>
     <strong>
      <code>
       在其它网络上
      </code>
     </strong>
     （象MAP和Modbus Plus）Modbus消息被转成与串行传输无关的帧。
    </p>
    <h3>
     <a id="1ASCII_52">
     </a>
     1、ASCII模式
    </h3>
    <p>
     当控制器设为在Modbus网络上以ASCII（美国标准信息交换代码）模式通信，在消息中的每个8Bit字节都作为两个ASCII字符发送。这种方式的主要优点是字符发送的时间间隔可达到1秒而不产生错误。
    </p>
    <p>
     <strong>
      代码系统
     </strong>
    </p>
    <ul>
     <li>
      <p>
       十六进制，ASCII字符0…9，A…F
      </p>
     </li>
     <li>
      <p>
       消息中的每个ASCII字符都是一个十六进制字符组成
      </p>
     </li>
     <li>
      <p>
       每个字节的位
      </p>
     </li>
     <li>
      <p>
       1个起始位
      </p>
     </li>
     <li>
      <p>
       7个数据位，最小的有效位先发送
      </p>
     </li>
     <li>
      <p>
       1个奇偶校验位，无校验则无
      </p>
     </li>
     <li>
      <p>
       1个停止位（有校验时），2个Bit（无校验时）
      </p>
     </li>
     <li>
     </li>
    </ul>
    <p>
     <strong>
      错误检测域
     </strong>
    </p>
    <ul>
     <li>
      LRC(纵向冗长检测)
     </li>
    </ul>
    <h3>
     <a id="2RTU_71">
     </a>
     2、RTU模式
    </h3>
    <p>
     当控制器设为在Modbus网络上以RTU（远程终端单元）模式通信，在消息中的每个8Bit字节包含两个4Bit的十六进制字符。这种方式的主要优点是：在同样的波特率下，可比ASCII方式传送更多的数据。
    </p>
    <p>
     <strong>
      代码系统
     </strong>
    </p>
    <ul>
     <li>
      8位二进制，十六进制数0…9，A…F
     </li>
     <li>
      消息中的每个8位域都是一个两个十六进制字符组成
     </li>
     <li>
      每个字节的位
     </li>
     <li>
      1个起始位
     </li>
     <li>
      8个数据位，最小的有效位先发送
     </li>
     <li>
      1个奇偶校验位，无校验则无
     </li>
     <li>
      1个停止位（有校验时），2个Bit（无校验时）
     </li>
     <li>
     </li>
    </ul>
    <p>
     <strong>
      错误检测域
     </strong>
    </p>
    <ul>
     <li>
      CRC(循环冗长检测)
     </li>
    </ul>
    <h2>
     <a id="Modbus_87">
     </a>
     三、Modbus消息帧
    </h2>
    <p>
     两种传输模式中（ASCII或RTU），传输设备以将Modbus消息转为有起点和终点的帧，这就允许接收的设备在消息起始处开始工作，读地址分配信息，判断哪一个设备被选中（广播方式则传给所有设备），判知何时信息已完成。部分的消息也能侦测到并且错误能设置为返回结果。
    </p>
    <h3>
     <a id="1ASCII_90">
     </a>
     1、ASCII帧
    </h3>
    <p>
     使用ASCII模式，
     <code>
      消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符
     </code>
     结束（ASCII码 0DH,0AH）。
    </p>
    <p>
     其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。
    </p>
    <p>
     <strong>
      <code>
       消息中字符间发送的时间间隔最长不能超过1秒，否则接收的设备将认为传输错误
      </code>
     </strong>
     。一个典型消息帧如下所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8679d95bda4a6deedeaf2b58d6459b61.png"/>
    </p>
    <h3>
     <a id="2RTU_99">
     </a>
     2、RTU帧
    </h3>
    <p>
     使用RTU模式，消息发送至少要以3.5个字符时间的停顿间隔开始。在网络波特率下多样的字符时间，这是最容易实现的(如下图的T1-T2-T3-T4所示)。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。
    </p>
    <p>
     整个消息帧必须作为一连续的流转输。如果在帧完成之前有超过1.5个字符时间的停顿时间，接收设备将刷新不完整的消息并假定下一字节是一个新消息的地址域。同样地，如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续。这将导致一个错误，因为在最后的CRC域的值不可能是正确的。一典型的消息帧如下所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d64b81706c13c97f8fe12018d5719784.png"/>
    </p>
    <h3>
     <a id="3_105">
     </a>
     3、地址域
    </h3>
    <p>
     消息帧的地址域包含两个字符（ASCII）或8Bit（RTU）。可能的从设备地址是0…247 (十进制)。单个设备的地址范围是1…247。主设备通过将要联络的从设备的地址放入消息中的地址域来选通从设备。当从设备发送回应消息时，它把自己的地址放入回应的地址域中，以便主设备知道是哪一个设备作出回应。
    </p>
    <p>
     地址0是用作广播地址，以使所有的从设备都能认识。当Modbus协议用于更高水准的网络，广播可能不允许或以其它方式代替。
    </p>
    <h3>
     <a id="4_112">
     </a>
     4、如何处理功能域
    </h3>
    <p>
     消息帧中的功能代码域包含了两个字符（ASCII）或8Bits（RTU）。可能的代码范围是十进制的1…255。当然，有些代码是适用于所有控制器，有此是应用于某种控制器，还有些保留以备后用。
    </p>
    <p>
     当消息从主设备发往从设备时，功能代码域将告之从设备需要执行哪些行为。例如去读取输入的开关状态，读一组寄存器的数据内容，读从设备的诊断状态，允许调入、记录、校验在从设备中的程序等。
    </p>
    <p>
     当从设备回应时，它使用功能代码域来指示是正常回应(无误)还是有某种错误发生（称作异议回应）。对正常回应，从设备仅回应相应的功能代码。对异议回应，从设备返回一等同于正常代码的代码，但最重要的位置为逻辑1。
    </p>
    <p>
     例如：一从主设备发往从设备的消息要求读一组保持寄存器，将产生如下功能代码：0 0 0 0 0 0 1 1 （十六进制03H）
    </p>
    <p>
     对正常回应，从设备仅回应同样的功能代码。对异议回应，它返回：1 0 0 0 0 0 1 1 （十六进制83H）
    </p>
    <p>
     除功能代码因异议错误作了修改外，从设备将一独特的代码放到回应消息的数据域中，这能告诉主设备发生了什么错误。
    </p>
    <p>
     主设备应用程序得到异议的回应后，典型的处理过程是重发消息，或者诊断发给从设备的消息并报告给操作员。
    </p>
    <h3>
     <a id="5_130">
     </a>
     5、数据域
    </h3>
    <p>
     数据域是由两个十六进制数集合构成的，范围00…FF。根据网络传输模式，这可以是由一对ASCII字符组成或由一RTU字符组成。
    </p>
    <p>
     从主设备发给从设备消息的数据域包含附加的信息：从设备必须用于进行执行由功能代码所定义的所为。这包括了象不连续的寄存器地址，要处理项的数目，域中实际数据字节数。
    </p>
    <p>
     例如，如果主设备需要从设备读取一组保持寄存器（功能代码03），数据域指定了起始寄存器以及要读的寄存器数量。如果主设备写一组从设备的寄存器（功能代码10十六进制），数据域则指明了要写的起始寄存器以及要写的寄存器数量，数据域的数据字节数，要写入寄存器的数据。
    </p>
    <p>
     如果没有错误发生，从从设备返回的数据域包含请求的数据。如果有错误发生，此域包含一异议代码，主设备应用程序可以用来判断采取下一步行动。
    </p>
    <p>
     在某种消息中数据域可以是不存在的（0长度）。例如，主设备要求从设备回应通信事件记录（功能代码0B十六进制），从设备不需任何附加的信息。
    </p>
    <h3>
     <a id="6_144">
     </a>
     6、错误检测域
    </h3>
    <p>
     标准的Modbus网络有两种错误检测方法。错误检测域的内容视所选的检测方法而定。
    </p>
    <blockquote>
     <p>
      ASCII
     </p>
    </blockquote>
    <p>
     当选用ASCII模式作字符帧，错误检测域包含两个ASCII字符。这是使用LRC（纵向冗长检测）方法对消息内容计算得出的，不包括开始的冒号符及回车换行符。LRC字符附加在回车换行符前面。
    </p>
    <blockquote>
     <p>
      RTU
     </p>
    </blockquote>
    <p>
     当选用RTU模式作字符帧，错误检测域包含一16Bits值(用两个8位的字符来实现)。错误检测域的内容是通过对消息内容进行循环冗长检测方法得出的。CRC域附加在消息的最后，添加时先是低字节然后是高字节。故CRC的高位字节是发送消息的最后一个字节。
    </p>
    <h2>
     <a id="_158">
     </a>
     四、错误检测方法
    </h2>
    <p>
     标准的Modbus串行网络采用两种错误检测方法。奇偶校验对每个字符都可用，帧检测（LRC或CRC）应用于整个消息。它们都是在消息发送前由主设备产生的，从设备在接收过程中检测每个字符和整个消息帧。
    </p>
    <p>
     用户要给主设备配置一预先定义的超时时间间隔，这个时间间隔要足够长，以使任何从设备都能作为正常反应。如果从设备测到一传输错误，消息将不会接收，也不会向主设备作出回应。这样超时事件将触发主设备来处理错误。发往不存在的从设备的地址也会产生超时。
    </p>
    <h3>
     <a id="1_165">
     </a>
     1、奇偶校验
    </h3>
    <p>
     用户可以配置控制器是奇或偶校验，或无校验。这将决定了每个字符中的奇偶校验位是如何设置的。
    </p>
    <p>
     如果指定了奇或偶校验，“1”的位数将算到每个字符的位数中（ASCII模式7个数据位，RTU中8个数据位）。例如RTU字符帧中包含以下8个数据位：1 1 0 0 0 1 0 1
    </p>
    <p>
     整个“1”的数目是4个。如果便用了偶校验，帧的奇偶校验位将是0，便得整个“1”的个数仍是4个。如果便用了奇校验，帧的奇偶校验位将是1，便得整个“1”的个数是5个。
    </p>
    <p>
     如果没有指定奇偶校验位，传输时就没有校验位，也不进行校验检测。代替一附加的停止位填充至要传输的字符帧中。
    </p>
    <h3>
     <a id="2LRC_177">
     </a>
     2、LRC检测
    </h3>
    <p>
     使用ASCII模式，消息包括了一基于LRC方法的错误检测域。LRC域检测了消息域中除开始的冒号及结束的回车换行号外的内容。
    </p>
    <p>
     LRC域是一个包含一个8位二进制值的字节。LRC值由传输设备来计算并放到消息帧中，接收设备在接收消息的过程中计算LRC，并将它和接收到消息中LRC域中的值比较，如果两值不等，说明有错误。
    </p>
    <p>
     LRC方法是将消息中的8Bit的字节连续累加，丢弃了进位。
    </p>
    <h3>
     <a id="3CRC_185">
     </a>
     3、CRC检测
    </h3>
    <p>
     使用RTU模式，消息包括了一基于CRC方法的错误检测域。CRC域检测了整个消息的内容。
    </p>
    <p>
     CRC域是两个字节，包含一16位的二进制值。它由传输设备计算后加入到消息中。接收设备重新计算收到消息的CRC，并与接收到的CRC域中的值比较，如果两值不同，则有误。
    </p>
    <p>
     CRC是先调入一值是全“1”的16位寄存器，然后调用一过程将消息中连续的8位字节各当前寄存器中的值进行处理。仅每个字符中的8Bit数据对CRC有效，起始位和停止位以及奇偶校验位均无效。
    </p>
    <p>
     CRC产生过程中，每个8位字符都单独和寄存器内容相或（OR），结果向最低有效位方向移动，最高有效位以0填充。LSB被提取出来检测，如果LSB为1，寄存器单独和预置的值或一下，如果LSB为0，则不进行。整个过程要重复8次。在最后一位（第8位）完成后，下一个8位字节又单独和寄存器的当前值相或。最终寄存器中的值，是消息中所有的字节都执行之后的CRC值。
    </p>
    <p>
     CRC添加到消息中时，低字节先加入，然后高字节。
    </p>
    <h2>
     <a id="MODBUS_198">
     </a>
     五、MODBUS通讯协议及编程
    </h2>
    <blockquote>
     <p>
      MODBUS通讯协议大致分为以下几种
     </p>
    </blockquote>
    <p>
     Modbus-RTU+Modbus-ASCII
     <br/>
     Modbus-TCP
     <br/>
     Modbus-Plus
    </p>
    <blockquote>
     <p>
      通讯过程:
     </p>
    </blockquote>
    <p>
     Modbus是主从方式通信,也就是说,不能同步进行通信,总线上每次只有一个数据进行传输,即主机发送,从机应答,主机不发送,总线上就没有数据通信.
    </p>
    <h3>
     <a id="1_ModbusRTU_210">
     </a>
     1. Modbus-RTU协议
    </h3>
    <p>
     这种协议是基于异步串行通信上,一般的介质有:RS-232,RS485,RS-422上,这也是工业上使用的最多的;
    </p>
    <h4>
     <a id="11__213">
     </a>
     1.1. 帧结构
    </h4>
    <p>
     <strong>
      <code>
       帧结构
      </code>
     </strong>
     = 地址 + 功能吗 + 数据 + 校验
    </p>
    <p>
     <strong>
      地址
     </strong>
     : 占用一个字节,范围0-255,其中有效范围是1-247,其他有特殊用途,比如255是广播地址(广播地址就是应答所有地址,正常的需要两个设备的地址一样才能进行查询和回复)
    </p>
    <p>
     <strong>
      功能码
     </strong>
     :" 占用一个字节,功能码的意义就是,知道这个指令是干啥的,比如你可以查询从机的数据,也可以修改数据,所以不同功能码对应不同功能.
    </p>
    <p>
     <strong>
      数据
     </strong>
     : 根据功能码不同,有不同结构,在后续的实例中有说明;
    </p>
    <p>
     <strong>
      校验
     </strong>
     : 为了保证数据不错误,增加这个,然后再把前面的数据进行计算看数据是否一致,如果一致,就说明这帧数据是正确的,我再回复;如果不一样,说明你这个数据在传输的时候出了问题,数据不对的,所以就抛弃了;
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fdcc9b6a8f9d212ab459746a12e37a16.png"/>
    </p>
    <h4>
     <a id="12_224">
     </a>
     1.2常用功能码
    </h4>
    <p>
     03-主机需要发送起始地址+寄存器数量，从机回复总字节数+数据；
     <br/>
     06-主机发送起始地址+数据内容（因为你只需要修改一个，所以起始地址就是所要修改的地址），从机返回起始地址+数据内容（发现居然一样！）
     <br/>
     10-主机发送起始地址+寄存器个数+总字节数+数据，从机返回起始地址+寄存器数量
    </p>
    <h4>
     <a id="13_229">
     </a>
     1.3常用功能码使用举例分析
    </h4>
    <h4>
     <a id="131_0x03_230">
     </a>
     1.3.1 功能码-0x03读保持寄存器
    </h4>
    <p>
     <strong>
      <code>
       测试功能描述
      </code>
      :
     </strong>
     <br/>
     现在我是主机,我要查询从机地址为1的数据
    </p>
    <pre><code class="prism language-bash">主机发送: 01 03 00 00 00 01 <span class="token number">84</span> 0A
从机回复: 01 03 02 <span class="token number">12</span> <span class="token number">34</span> B5 <span class="token number">33</span>
</code></pre>
    <p>
     <strong>
      <code>
       数据分析
      </code>
     </strong>
    </p>
    <pre><code class="prism language-bash">/*发送数据解析*/
01-地址
03-功能码,代表查询功能,其他功能后面再说
00 00-代表<span class="token punctuation">(</span>读地址<span class="token punctuation">)</span>查询的起始寄存器地址.说明从0x0000开始查询.
<span class="token punctuation">(</span>这里需要说明以下,Modbus把数据存放在寄存器中,通过查询寄存器来得到不同变量的值,一个寄存器地址对应2字节数据<span class="token punctuation">;</span><span class="token punctuation">)</span>
00 01-代表（读数据的长度）查询了一个寄存器.结合前面的00 00,意思就是查询从0开始的1个寄存器值<span class="token punctuation">;</span>
<span class="token number">84</span> 0A-循环冗余校验,是modbus的校验公式,从首个字节开始到84前面为止<span class="token punctuation">;</span>
<span class="token punctuation">(</span>这里新手可能不懂,这个校验就是保证数据传输过程没有错误的一种手段,不同的协议这种校验公式不一样,
只需了解这个就足够了,具体怎么求的,可以直接在输出数据得到结果,地址如下:
http://www.ip33.com/crc.html<span class="token punctuation">)</span>

/*回复解析*/
01-地址
03-功能码
02-代表<span class="token punctuation">(</span>被读取数据长度<span class="token punctuation">)</span>后面数据的字节数,因为上面说到,一个寄存器有2个字节,所以后面的字节数肯定是2*查询的寄存器个数<span class="token punctuation">;</span>
<span class="token number">12</span> <span class="token number">34</span>-<span class="token punctuation">(</span>被读取的具体数据<span class="token punctuation">)</span>寄存器的值是12 <span class="token number">34</span>,结合发送的数据看出,01这个寄存器的值为12 <span class="token number">34</span>
B5 <span class="token number">33</span>-循环冗余校验
</code></pre>
    <h4>
     <a id="132_0x06_258">
     </a>
     1.3.2 功能码-0x06写单个寄存器
    </h4>
    <p>
     <strong>
      <code>
       测试功能描述
      </code>
      :
     </strong>
     <br/>
     我要修改从机的数据
    </p>
    <pre><code class="prism language-bash">主机发送: 01 06 00 00 00 01 <span class="token number">48</span> 0A
从机回复: 01 06 00 00 00 01 <span class="token number">48</span> 0A
</code></pre>
    <p>
     <strong>
      <code>
       数据分析
      </code>
     </strong>
    </p>
    <pre><code class="prism language-bash">*发送数据解析*/
01-主机要查的地址
06-功能码,代表修改单个寄存器功能,修改有些不同,有修改一个寄存器和修改多个寄存器<span class="token punctuation">;</span>
00 00-代表修改的起始寄存器地址.说明从0x0000开始.
00 01-代表修改的值为00 01.结合前面的00 00,意思就是修改0号寄存器值为00 01<span class="token punctuation">;</span>
<span class="token number">48</span> 0A-循环冗余校验,是modbus的校验公式,从首个字节开始到48前面为止<span class="token punctuation">;</span>

/*回复解析*/
01-从机返回的地址,说明这就是主机查的从机
06-功能码,代表修改单个寄存器功能<span class="token punctuation">;</span>
00 00-代表修改的起始寄存器地址.说明是0x0000.
00 01-代表修改的值为00 01.结合前面的00 00,意思就是修改0号寄存器值为00 01<span class="token punctuation">;</span>
<span class="token number">48</span> 0A-循环冗余校验,是modbus的校验公式,从首个字节开始到48前面为止<span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      如果回复的一样,说明这个数据是修改成功的;如果功能码不是06,而是86,说明你发送的数据出错了;
     </strong>
    </p>
    <h4>
     <a id="133_0x10_285">
     </a>
     1.3.3 功能码-0x10写多个寄存器
    </h4>
    <p>
     <strong>
      <code>
       测试功能描述
      </code>
      :
     </strong>
     <br/>
     如果我要修改多个寄存器,难道用06发好几次,这样不会太傻了吗?所以,modbus RTU协议包含了修改连续多个寄存器的方法,就是功能码为0x10;
     <br/>
     下面先举例用0x10功能码进行一个字节的修改和0x06功能码有什么区别：
    </p>
    <pre><code class="prism language-bash">主机发送: 01 <span class="token number">10</span> 00 00 00 01 02 <span class="token number">11</span> <span class="token number">22</span> 2A <span class="token number">19</span>
从机回复: 01 <span class="token number">10</span> 00 00 00 01 01 C9
</code></pre>
    <p>
     <strong>
      <code>
       数据分析
      </code>
     </strong>
    </p>
    <pre><code class="prism language-bash">*发送数据解析*/
01-主机要查的地址
<span class="token number">10</span>-功能码,代表修改多个寄存器功能<span class="token punctuation">;</span>
00 00-代表修改的起始寄存器地址.说明从0x0000开始.
00 01-代表修改的寄存器数量，这里开始于0x06的修改不同<span class="token punctuation">;</span>
02 -表示修改的总字节数，由于只修改了1个寄存器，所以数据要有两个字节；
<span class="token number">11</span> <span class="token number">22</span>-表示修改的值，结合上面，就是从第0000寄存器开始修改一个寄存器值为11 <span class="token number">22</span>，就是把0000寄存器改为11 <span class="token number">22</span>；
2A <span class="token number">19</span>-循环冗余校验,是modbus的校验公式,从首个字节开始到22前面为止<span class="token punctuation">;</span>

/*回复解析*/
01-从机返回的地址,说明这就是主机查的从机
<span class="token number">10</span>-功能码
00 00-代表修改的起始寄存器地址.说明是0x0000.
00 01-代表修改的寄存器数量，只需要回复这么多久足够了，从机告诉主机，你修改了哪几个寄存器就足够了<span class="token punctuation">;</span>
01 C9-循环冗余校验<span class="token punctuation">;</span>
</code></pre>
    <p>
     现在，修改多个寄存器：
    </p>
    <pre><code class="prism language-bash">主机发送: 01 <span class="token number">10</span> 00 00 00 02 04 <span class="token number">11</span> <span class="token number">22</span> <span class="token number">33</span> <span class="token number">44</span> <span class="token number">42</span> 5A
从机回复: 01 <span class="token number">10</span> 00 00 00 02 <span class="token number">41</span> C8
</code></pre>
    <h3>
     <a id="2_ModbusACSII_317">
     </a>
     2. Modbus-ACSII
    </h3>
    <h4>
     <a id="21_ModbusACSII_318">
     </a>
     2.1 Modbus-ACSII简介
    </h4>
    <p>
     由于Modbus-RTU和modbus-ACSII都是基于232和485链路的，所以其通讯模式半双工，一般是主机和从机的模式。其差别就是其字节的格式不同，一个是16进制的数据，一个是acsii数据。
     <br/>
     <strong>
      Ascii多了帧头和帧尾，也就是说可以有用这个头尾判断一帧字节来判断是否结束；而RTU没有帧头和帧尾，所以协议里明确两帧之间要大于3.5个字节时间间隔，作为一帧结束的判断依据。
     </strong>
    </p>
    <p>
     对于RS485来说，总线上一般允许最大32个设备。
    </p>
    <p>
     在ASCII传输模式下，
     <strong>
      <code>
       消息帧以英文冒号”:”（3A）开始，以回车（0D）和换行（0A）结束
      </code>
     </strong>
     ，允许传输的字符集为十六进制的0-9和A~F。
    </p>
    <p>
     在ASCII模式下，
     <strong>
      每个8位的字节被拆分成两个ASCII字符进行发送
     </strong>
     ，比如十六进制0x28（0010 1000），会被分解成
     <br/>
     ASCII字符“2”（0011 0010）和”8”（0011 1000）进行发送。
    </p>
    <h4>
     <a id="22_328">
     </a>
     2.2.帧形式
    </h4>
    <p>
     对于RTU协议，比如RTU发送一个字节：0x12；
     <br/>
     ASCII协议则需要发送2个字节：一个字节代表1，一个代表2，即31和32，才能代表0x12.
     <br/>
     所以，acsii协议的效率比较低。
     <br/>
     <strong>
      1）主机查询
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/129a866bb882ab304fa84bc06c7130c2.png">
      <br/>
      如下为主机查询从机[地址01]的数据帧：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9ed2ebe2606c21fd198295f5ade7e798.png"/>
     </img>
    </p>
    <p>
     <strong>
      2）从机返回
     </strong>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/757045ae479f7dc1dc17ed3d114a72f2.png"/>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">make_lrc_2char</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> pBuf<span class="token punctuation">,</span> <span class="token keyword">int</span> iDataLen<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>pucLrcH<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>pucLrcL<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>pushMsg <span class="token operator">=</span> pBuf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>pushBuf<span class="token punctuation">[</span>MAX_BUF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//+1是因为报文头的0x3A是不参加LRC校验的</span>
    <span class="token class-name">uint8_t</span> ucIndex_Temp <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> ucIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> ucLrcH <span class="token operator">=</span> <span class="token number">0xff</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> ucLrcL <span class="token operator">=</span> <span class="token number">0xff</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> LrcCheck <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> iDataLen <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pushMsg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0x41</span><span class="token punctuation">)</span><span class="token comment">//'A'....</span>
        <span class="token punctuation">{<!-- --></span>
            pushBuf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>pushMsg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">0x41</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>  <span class="token comment">//'0...'</span>
        <span class="token punctuation">{<!-- --></span>
            pushBuf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pushMsg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">0x30</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ucIndex_Temp <span class="token operator">+=</span> pushBuf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ucIndex <span class="token operator">=</span><span class="token punctuation">(</span>HT_UCHAR<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>ucIndex_Temp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    LrcCheck <span class="token operator">=</span> <span class="token function">AsciitoHex</span><span class="token punctuation">(</span>ucIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>pucLrcH <span class="token operator">=</span> <span class="token punctuation">(</span>LrcCheck<span class="token operator">&amp;</span><span class="token number">0xFF00</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>pucLrcL <span class="token operator">=</span> LrcCheck<span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token class-name">uint32_t</span> <span class="token function">AsciitoHex</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> iFrame<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint32_t</span> iDecT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//hex&gt;&gt;ascii</span>
    <span class="token class-name">uint8_t</span> iFrameH <span class="token operator">=</span> <span class="token punctuation">(</span>iFrame<span class="token operator">&gt;&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xF</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> iFrameL <span class="token operator">=</span> iFrame<span class="token operator">&amp;</span><span class="token number">0xF</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>iFrameH <span class="token operator">&gt;</span> <span class="token number">9</span><span class="token punctuation">)</span> 
    	iFrameH <span class="token operator">=</span> iFrameH <span class="token operator">-</span><span class="token number">10</span> <span class="token operator">+</span><span class="token number">65</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> 
    	iFrameH <span class="token operator">=</span> iFrameH <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>iFrameL <span class="token operator">&gt;</span> <span class="token number">9</span><span class="token punctuation">)</span> 
    	iFrameL <span class="token operator">=</span> iFrameL <span class="token operator">-</span><span class="token number">10</span> <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> 
    	iFrameL <span class="token operator">=</span> iFrameL <span class="token operator">+</span><span class="token number">48</span><span class="token punctuation">;</span>
    iDecT <span class="token operator">=</span> <span class="token punctuation">(</span>iFrameH <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>iFrameL<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> iDecT<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-bash"><span class="token number">1</span>）比RTU多了起始段 :， 多个结束符CR，LF
<span class="token number">2</span>）地址和功能都变成了2个字节；
<span class="token number">3</span>）数据部分更加繁琐，但是更符合人们的查看；
</code></pre>
    <h3>
     <a id="3_ModbusTCP_395">
     </a>
     3. Modbus-TCP
    </h3>
    <p>
     以太网作为介质进行传输,
    </p>
    <h4>
     <a id="31_ModbusTCP_398">
     </a>
     3.1 Modbus-TCP帧形式
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/88f46515c89f9976523e080a4c9ccdf3.png"/>
     <br/>
     <strong>
      MBAP为报文头
     </strong>
     ，长度为7字节，组成如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/56c1f5fb6a7fe9c0ee413c44a53d64cb.png"/>
    </p>
    <p>
     根据对象的不同，
     <strong>
      Modbus的读功能码
     </strong>
     有：
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c47691e612eb6639981ba7d45ec2486a.png"/>
     <br/>
     <strong>
      写功能码
     </strong>
     如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/addff3da6a7058f91f6e8daf19873425.png"/>
    </p>
    <h4>
     <a id="32__ModbusTCP_408">
     </a>
     3.2. Modbus-TCP使用举例分析
    </h4>
    <h5>
     <a id="320__0x04_409">
     </a>
     3.2.0 0x04读输入寄存器
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e79a280a01e3b71fccdfdfc8652aa5e9.png"/>
     <br/>
     <strong>
      写DO板卡数据回应如下：
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e4a4f318f3933cb2f56beece3c2aac47.png"/>
    </p>
    <h5>
     <a id="320__0x01_413">
     </a>
     3.2.0 0x01读线圈
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/66acdfe981ce66c93875bfc15dc28633.png"/>
     <br/>
     <strong>
      使用实例如下：
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e1596902125c11e63814d5ece644cf2a.png"/>
    </p>
    <h5>
     <a id="321_0x03httpsimgblogcsdnimgcn258ee96d2bdb4760af3dc17c1f0ba73fpng_418">
     </a>
     3.2.1 0x03读单个寄存器
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/25c5400899d7bfd09bdff4f5de47c459.png"/>
    </h5>
    <p>
     <strong>
      使用实例如下
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8bcdcbc294c979d12d495494127c2789.png"/>
    </p>
    <h5>
     <a id="322_0x06_422">
     </a>
     3.2.2 0x06写单个寄存器
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6671682179140d05318895845126d35c.png"/>
     <br/>
     <strong>
      使用实例如下
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ab06784cdf12009919280facc05853a0.png"/>
    </p>
    <h5>
     <a id="323_0x10_427">
     </a>
     3.2.3 0x10写多个寄存器
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7f8e8fc4e6c8670f7a2c529ed0bb862c.png"/>
    </p>
    <p>
     <strong>
      使用实例如下：
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1a1aace1a9843cbf8aace5d53b2439db.png"/>
    </p>
    <h2>
     <a id="_432">
     </a>
     其它功能码
    </h2>
    <p>
     这篇
     <a href="https://blog.csdn.net/weixin_41542513/article/details/121974529?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165910214216782184690001%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165910214216782184690001&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-121974529-null-null.142%5Ev35%5Econtrol&amp;utm_term=modbus%20tcp%E5%AE%9E%E4%BE%8B&amp;spm=1018.2226.3001.4187">
      博客
     </a>
     介绍比较详细。
    </p>
    <h3>
     <a id="4_ModbusPLUS_434">
     </a>
     4. Modbus-PLUS
    </h3>
    <p>
     高速令牌传递网络
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33323334383838332f:61727469636c652f64657461696c732f313236303532343233" class_="artid" style="display:none">
 </p>
</div>


