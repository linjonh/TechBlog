---
layout: post
title: 操作系统原理
date: 2021-01-12 17:38:48 +08:00
categories: ['Linux']
tags: ['操作系统原理']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=100604985
    alt: 操作系统原理
artid: 100604985
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=100604985
featuredImagePreview: https://bing.ee123.net/img/rand?artid=100604985
---

# 操作系统原理

[原文链接：https://www.cnblogs.com/engine1984/category/155390.html](https://www.cnblogs.com/engine1984/category/155390.html)

**目录**

[目录](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%91%E2%80%94%E2%80%94%20%E6%A6%82%E5%BF%B5)

[>> 操作系统原理1 —— 概念](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%861%20%E2%80%94%E2%80%94%20%E6%A6%82%E5%BF%B5)

[>> 操作系统原理2 —— OS结构](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%862%C2%A0%E2%80%94%E2%80%94%C2%A0OS%E7%BB%93%E6%9E%84)

[>> 操作系统原理3 —— 多道程序](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%863%C2%A0%E2%80%94%E2%80%94%C2%A0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F)

[>> 操作系统原理4 —— 存储管理](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%864%C2%A0%E2%80%94%E2%80%94%C2%A0%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86)

[>> 操作系统原理5 —— 文件管理](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%865%C2%A0%E2%80%94%E2%80%94%C2%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86)

[>> 操作系统原理6 —— 设备管理](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%866%C2%A0%E2%80%94%E2%80%94%C2%A0%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86)

[>> 操作系统原理7 —— 作业管理](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%867%C2%A0%E2%80%94%E2%80%94%C2%A0%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86)

[>> 操作系统原理8 —— CPU管理，进程](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%868%C2%A0%E2%80%94%E2%80%94%C2%A0CPU%E7%AE%A1%E7%90%86%EF%BC%8C%E8%BF%9B%E7%A8%8B)

[>> 操作系统原理9 —— 死锁](#%3E%3E%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%869%C2%A0%E2%80%94%E2%80%94%C2%A0%E6%AD%BB%E9%94%81)

---

#### >> 操作系统原理1 —— 概念

学习操作系统，首先我们应该知道操作系统的概念。本章主要讲述了以下几个问题。

1. 什么是操作系统
2. 操作系统的形成
3. 操作系统的类型
4. 操作系统的功能

**一、什么是操作系统**

在回答这个问题之前，我们先来了解一下什么是计算机系统。计算机系统是按用户的要求接收和存储信息、自动进行数据处理并输出结果信息的系统。

计算机系统由硬件系统和软件系统组成。软硬件系统的组成部分就是计算机系统的资源，当不同的用户使用计算机时都要占用系统资源并且有不同的控制需求。

操作系统就是计算机系统的一种系统软件，由它统一管理计算机系统的资源和控制程序的执行。

操作系统的设计目标一是使计算机系统使用方便。二是使得计算机系统能高效地工作。

**二、操作系统的形成**

早期没有操作系统→原始汇编系统→管理程序→操作系统 可以看到，操作系统是随着计算机硬件的发展和应用需求的推动而形成的。

**三、操作系统的类型**

按照操作系统提供的服务，大致可以把操作系统分为以下几类：

批处理操作系统、分时操作系统、实时操作系统、网络操作系统和分布式操作系统。其中
**批处理操作系统**
、
**分时操作系统**
、
**实时操作系统**
是基本的操作系统。

1. 批处理操作系统
   按照用户预先规定好的步骤控制作业的执行
   ，实现计算机操作的自动化。又可分为批处理单道系统和批处理多道系统。单道系统每次只有一个作业装入计算机系统的主存储器运行，多个作业可自动、顺序地被装入运行。批处理多道系统则允许多个作业同时装入主存储器，中央处理器轮流地执行各个作业，各个作业可以同时使用各自所需的外围设备，这样可以充分利用计算机系统的资源，缩短作业时间，提高系统的吞吐率。
2. 分时操作系统，这种系统中，
   一个计算机系统与许多终端设备连接
   ，分时系统支持多个终端用户，同时以交互方式使用计算机系统，为用户在测试、修改和控制程序执行方面提供了灵活性。分时系统的主要特点是同时性、独立性、及时性和交互性。
3. 实时操作系统能使
   计算机系统接收到外部信号后及时进行处理
   ，并在严格的规定时间内完成处理，且给出反馈信号。它是较少有人为干预的监督和控制系统。实时系统对可靠性和安全性要求极高，不强求系统资源的利用率。
4. 网络操作系统可以把若干计算机联合起来，实现各台计算机之间的通信及网络中各种资源的共享，像我们现在使用的Windows ，UNIX和Linux等操作系统都是网络操作系统。
5. 分布式操作系统的网络中各台计算机没有主次之分，在任意两台计算机间的可进行信息交换和资源共享。这一点上分布式操作系统和网络操作系统差别不大，他们的本质区别在于：分布式操作系统能使系统中若干计算机相互协作完成一个共同的任务。这使得各台计算机组成一个完整的，功能强大的计算机系统。

**四、操作系统的功能**

从资源管理的观点出发，操作系统功能可分为五大部分：处理器管理、存储管理、文件管理、设备管理和作业管理。

---

#### >> 操作系统原理2 —— OS结构

计算机系统是由
**硬件系统**
和
**软件系统**
两部分组成，
**操作系统**
是
**软件系统**
的一个组成部分，它是直接在硬件系统的基础上工作的，所以在研究操作系统之前，先必须对计算机系统的结构有一个基本的了解，本章就是讲述计算机系统结构的基本知识。

本章的知识要点是：

1. 计算机系统的层次结构
2. 硬件环境
3. 操作系统结构

**一、计算机系统的层次结构**

现代的通用计算机系统是由硬件和软件组成的一种层次式结构，最内层是硬件系统，最外层是使用计算机系统的人，人与硬件系统之间是软件系统。

**二、 硬件环境**

（1）CPU和外设的并行工作

（2）I/O中断的作用

（3）存储结构

* **主存储器**
  是
  CPU能直接访问的唯一的存储空间，任何程序和数据都必须被装入主存储器之后，CPU才能对它进行操作
  。主存储器以“字节(BYTE)”为单位进行编址，若干字节组成一个“字(WORD)”。中央处理器可以按地址读出主存储器中的一个字节或一个字的内容。
* **辅助存储器**
  解决了主存储器容量不足，以及主存储器无法保存信息的问题。辅助存储器的优点是容量大且能永久保存信息，缺点是无法被中央处理器直接访问，必须通过主存储器才能访问。
* 中央处理器存储信息的速度依次为：
  **存取寄存器**
  中的信息速度最快；通过系统总线
  **存取主存储器**
  的速度居中；使用
  **辅助存储器**
  的信息速度最慢。

寄存器用来存放临时的工作信息和系统必须的控制信息。

主存储器中存放操作系统的核心部分，以及当前需执行的程序和数据。

辅助存储器是存放操作下的非核心部分和其他程序和数据。

磁盘的信息可随机存取，磁带上的信息只能顺序存取。

（4）硬件保护

在资源共享的计算机系统中，只有有了必要的保护措施，才能使个别的错误不致影响其他程序。

**三、操作系统结构**

层次结构的最大特点是把整体问题局部化。把一个大型复杂的操作系统分解成若干单向依赖的层次，由各层的正确性来保证整个操作系统的正确性。

采用层次结构，能使结构清晰，便于调试，有利于功能的增、删和修改，正确性容易得到保证，也提高了系统的可维护性和可移植性。

操作系统的一种层次结构如下图所示：

|  |
| --- |
| 作业管理 |
| 文件管理 |
| 设备管理 |
| 存储管理 |
| 处理器管理 |
| 硬件 |

---

#### >> 操作系统原理3 —— 多道程序

通过本章学习应该掌握多道程序设计是如何提高计算机系统效率的；进程与程序有什么区别；进程的基本状态以及状态变化；进程队列及进程调度策略；中断的作用。

**一、 进程**

1. 进程的定义：把一个程序在一个数据集上的一次执行称为一个“进程”。
2. 进程是由程序、数据集和进程控制块三部分组成。
   我们举一个例子，比如在有一个用户程序notepad.exe（记事本），当它存放在磁盘上时，就是一个程序，在windows操作系统下运行它时，就会在内存中建立一个记事本程序的进程，而我们在记事本中编辑的当前文字就是这个进程的数据集，操作系统会为当前的进程设置一个进程控制块。
   **如果我们再打开一个记事本程序的窗口，就会建立另一个进程，此时运行的是同一个程序，但存在两个进程，第二个窗口中的编辑内容就是第二个进程的数据集**
   。
3. 进程与程序 的区别及关系。程序是静止的，进程是动态的。进程包括程序和程序处理的对象（数据集），进程能得到程序处理的结果。进程和程序并非一一对应的，一个程序运行在不同的数据集上就构成了不同的进程。通常把进程分为“系统进程”和“用户进程”两大类，把完成操作系统功能的进程称为系统进程，而完成用户功能的进程则称为用户进程。

**二、 进程状态**

通常，根据进程执行过程中不同时刻的状态，可归纳为三种基本状态：

1. 等待态 ：等待某个事件的完成；
2. 就绪态 ：等待系统分配处理器以便运行；
3. 运行态 ：占有处理器正在运行。

进程的状态变化：

进程在执行中状态会不断地改变，每个进程在任何时刻总是处于上述三种基本状态的某一种基本状态，进程状态之间转换关系如下图所示：

运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。

等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。

运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。

就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。

**三、 进程队列**

1、 进程队列的链接。

在多道程序设计的系统中往往会同时创建多个进程。在单处理器的情况下，每次只能让一个进程运行，其他的进程处于就绪状态或等待状态。为了便于管理，经常把处于

**相同状态的进程**
**链接**

在一起，称“进程队列”，由于进程控制块能标志进程的存在和动态刻画进程的特性，因此，进程队列可以用进程控制块的连接来形成。链接的方式有两种：单向链接和双向链接。

2、 进程基本队列

就绪队列 ：
**由若干就绪进程按一定次序链接起来的队列。**

等待队列 ：

**把等待资源或等待某些事件的进程排列的队列。**

3、进程的入队和出队。

出队和入队 ：当发生的某个事件使一个进程的状态发生变化时，这个进程就要退出所在的某个队列而排入到另一个队列中去。

出队 ：一个进程从所在的队列退出的操作称为出队

入队 ：一个进程排入到一个指定的队列的操作称为入队。

系统中负责进程入队和出队的工作称为

**队列管理**

。

无论单向链接还是双向链接，解决入，出队问题，都是首先找到该队列的队首指针，沿链找出要入队的进程以及它要插入的位置，或找出要出队的进程，然后修改本进程指针（入队情况）和相邻进程的有关指针值即可。

**四、
中断优先级和中断屏蔽**

1、 中断优先级是硬件设计时确定的。中断装置按预定的顺序来响应同时出现的中断事件，这个预定的顺序称为“中断优先级”。中断优先级是按中断事件的重要性和紧迫程度来确定的 ，是由硬件设计时固定下来的。一般情况下，优先级的高低顺序依次为：

**硬件故障中断**

、
**自愿中断**

、

**程序性中断**


，

**外部中断**

和

**输入输出中断**

。

2、中断的嵌套处理

3、中断屏蔽的作用。中断优先级只是规定了中断装置响应同时出现的中断的次序，当中断装置响应了某个中断后中断处理程序在进行处理时，中断装置也可能去响应另一个中断事件。因此会出现优先级低的中断事件的处理打断优先级高的中断事件的处理，使得中断事件的处理顺序与响应顺序不一致，而且会形成多重嵌套处理，使多现场保护、程序返回等工作变的复杂。

中断屏蔽技术就是为了解决上述问题而提出的在一个中断处理没有结束之前不响应其他中断事件，或者只响应比当前级别高的中断事件。于是，当中断装置检查到有中断事件后，便去查看PSW中中断屏蔽标志，如果没有屏蔽就响应该中断；否则，暂时不响应该中断，待屏蔽标志消除后再响应。自愿中断是不能屏蔽的。

---

#### >> 操作系统原理4 —— 存储管理

本章考核知识点：1、重定位 2、固定分区存储管理 3、可变分区存储管理 4、页式存储管理 5、段式存储管理 6、虚拟存储器

操作系统的存储管理如同一个大地主，管着一个大庄园，当有农户需要租用田地时，地主就给分配一块地让他种（用户区分配）。等到地里长出了果实，结果出来后，地主还得来收回这块地（去配）。

为了管好这片田地，地主还要管好庄园的门，凡是要进去种地的，都得由地主根据他的需要让他到位置确定实际的田地上去干活。（把逻辑地址转换成物理地址）

庄园里还有一些大家共同可以使用的地方，比如地主的花园，工具房等，大家可以进去，也可以使用，但是不许改变任何现有的东东，还有，每个农户只能在自己的地里刨食吃，如果有人胆敢到别人地里或地主的花园里摘花偷食，可要当心他们养的狼狗跳出来哦。（共享和保护）

当然，再大的地也是不够多的，地主为了多赚些钱，当所有的地都租出去的时候，他想办法把有些种田人暂时不种的那块地里的东东连地皮一起挖出来放到仓库里先堆着。把地腾出来租给别人种（这一招可够绝的，不过地主说啦，这就是“虚拟存储”。）

**一、 页式存储管理**

1、如何分页和分块

页式存储管理中有两个名词：“ 页 ”和“ 块 ”，其中的
**“块”是针对硬件**
来说的，就是把存储器分成若干相等大小的区，每个区就称为一个块。对应的，
**在程序中，逻辑地址进行“分页”**
，其大小和每个块相一致。

事实上，页面的大小是由块的大小自然决定的。对于程序来说，其逻辑地址还是和原来一样采用连续的地址。只是 按照块的位数取其前面数位做为页号 .

分配空间时，根据作业长度可以确定它的页面数，根据这个页面数在主存中分配相应的块数，只要是空闲块就可以放入，即使不是相邻的。并把分配情况记在“页表”中，根据页表可以找到相对应的页号与块号，就得出绝对地址了。

2、采用页式管理，使主存空间充分利用，页不必为了得到连续空间而进行移动。 可以提高系统效率。

3、页表的构造与作用

每个被装入主存的作业都有一张 页表 ，指出该作业逻辑地址中的页号与所占用的主存块号之间的对应关系。页表的长度由作页拥有的页面数决定，行号对应为页号，行中记录的是主存中的块号。

页表是硬件进行地址转换的依据，每执行一条指令时按逻辑地址中的页号查找页表并转换成绝对地址。

在多道程序设计系统中，进入主存的每个作业都有一张页表，由一个硬件“页表控制寄存器”来记录每个作业的页表所在位置和长度以便作业转换时同时转换页表。

4、快表的构造与作用

快表 就是页表的一部分克隆，每行中有页号及其对应的块号，整个快表存放在一个小容量的高速缓存中，访问时快表和内存同时进行查找，因为快表速度很快，而常用的页都登记在快表中，因此可以大大加快执行速度。

5、采用页式管理的地址转换过程

（为什么不直接用块分配表来记录而要用位示图呢，因为主存块很多，这样可以节省空间，提高效率。位示图就是用一个位（0或1）来表示一个块的使用状态，一个字32位，可以表示32块。按顺序排列，只需一小段内存就可以记录主存中大量的块状态）

6、利用位示图实现页式存储空间的分配和回收

页式存储管理把主存空间分成大小固定的许多块，在装业作业时，如何知道主存中哪些块已使用，哪些还未用，可以用位示图来表示。

块号=字号×字长＋位号

字号=[i/字长]（即块号i除以字长取整）

位号=i mod 字长（即块号i除以字长取余）。

---

#### >> 操作系统原理5 —— 文件管理

文件和文件名 ：在计算机系统中，把逻辑上具有完整意义的信息集合称为“文件”，每个文件都要用一个名字作标识，称为“文件名”。

用户请求使用文件的操作步骤

1）读文件：打开文件→读文件→关闭文件

2）写文件：建立文件→写文件→关闭文件

3）删除文件：关闭文件→删除文件

---

#### >> 操作系统原理6 —— 设备管理

要求了解设备管理与文件管理的合作，文件管理实现文件存取的准备工作，而文件的物理存取由设备管理实现。理解怎样实现独占设备的分配和磁盘的驱动调度；怎样实现虚拟设备。

**一、 独占设备和共享设备**

独占设备好比是你家的抽水马桶，当你坐上去的时候，大家就是想用也得等你完事了站起来才可以用上。

共享设备呢，就像是我家的水龙头，我在洗手的时候，可以把手移开让我妈来打盆水。然后我又继续洗手。

1、 独占设备 是指每次只能供一个作业执行期间单独使用的设备。如输入机、磁带机、打印机等。

2、 共享设备 是指允许几个作业执行期间可同时使用的设备。

3、共享设备的“同时使用”的含义是指多个作业可以交替启动共享设备，当一个用业正在使用设备时其他作业暂不能使用，即每一时刻仍只有一个作业占用，但当一个作业正在使用设备时其他作业就可使用。

---

#### >> 操作系统原理7 —— 作业管理

理解计算机系统中把
**用户要求处理的一项工作**
称为一个作业，作业可分为批处理作业和交互式作业两大类；掌握操作系统是如何实现作业调度和控制作业执行的；理解作业高度与进程调度之间的关系以及各自的职责。

**一、 作业和作业步**

1、 作业 ：我们把用户要求计算机系统处理的一个问题称为一个“作业”

2、 作业步 ：任何一个作业都要经过若干加工步骤才能得到结果，我们把作业的每一个加工步聚称为一个“作业步”。

---

#### >> 操作系统原理8 —— CPU管理，进程

本章考核知识点 ：1、进程的顺序性与并发性 2、与时间有关的错误　3、相关临界区 4、进程的互斥 5、进程的同步 6、进程通信 7、线程的概念

理解“进程”是操作系统中的基本执行单位，在多道程序设计的系统中往往同时有许多进程存在，它们要轮流占用处理器。这些交叉执行的并发进程相互之间可能是无关，也可能是相关的。当并发进程竞争共享资源时会出现与时间有关的错误，因此，应采用进程同步与互斥手段使其合理使用共享资源，以保证系统安全。当进程间必须通过信息交换进行协作时，可用进程通信的方式达到目的。

**一、 进程的顺序性与并发性**

有人说，在程序中不是有跳转语句和重复语句，怎么就是顺序执行？注意，
**这里是指进程在处理器中的执行，因为处理器每次只能执行一个操作**
，因此每条指令必须按顺序进入CPU执行，假使有一条指令是跳转的，那么执行本指令后，会取出跳转目的地址的指令进入CPU运行，这个顺序是程序规定的。所以
**对CPU而言，进程总是按顺序执行**
。

进程是一个程序在一个数据集合上的一次执行，同一个程序和同一个数据集的运行结果必然是相同的。这就是可再现性。

同时执行并不是真的同时，因为任一时刻CPU中只能有一个进程运行。

1、进程的
**顺序性**
：任何进程在顺序的处理器上的执行是严格按照顺序进行的，这就是进程的顺序性。当一个进程独占处理器顺序执行时，具有两个特性： 一、封闭性 ；二、可再现性 。

2、进程的
**同时执行**
：在多道程序设计系统中，一个进程的工作没有全部完成之前，另一个进程就可以开始工作，它们的执行在时间上重迭的，我们把它们称为是“可同时执行的”。

3、进程的
**并发性**
：若系统中存在一组可同时执行的进程，则说该组进程具有并发性，并把可同时执行的进程称为“并发进程” 。

4、并发进程间的关系：并发进程相互之间可能是无关的，也可能是交往的。如果一个进程的执行不影响其他进程的执行，且与其他进程的进展情况无关，即它们是各自独立的，则这些并发进程相互之间是无关的。如果一个进程的执行依赖其他进程的执行，则这些并发进程之间是有交往的。

**二、 与时间有关的错误**

1、并发进程的执行速度取决于自身和进程调度策略。一个进程运行时会被中断，且断点是不固定的，一个进程被中断后，哪个进程可以运行，被中断的进程什么时候占用处理器，是与进程调度策略有关的。因此进程的执行速度不能由自己决定。

2、并发进程交替使用共享资源时会出现与时间有关的错误。 由于共享资源的原因，加上进程并发执行的随机性，一个进程对另一个进程的影响是不可预测的。造成不正确的因素与进程占用处理器的时间、执行的速度以及外界的影响有关。因此被称为与时间有关的错误。

**三、 相关临界区**

1、 临界区的定义：并发进程中与
**共享变量有关的程序段**
称为“临界区”

2、什么是相关临界区 ： 相关临界区是指并发进程中涉及到相同变量的那些程序段

3、对相关临界区的管理要求。

1） 一次最多让一个 进程在临界区执行，当有进程在临界区时其他想进入临界区执行的进程必须等待。

2）任何一个进入临界区执行的进程必须在有限的时间内退出临界区，即任何一个进程都不应该无限地逗留在自己的临界区。

3）不能强迫一个进程无限地等待进入它的临界区，即有进程退出时应让一个等待进入临界区的进程进入它的临界区。

**四、 进程的互斥**

1） 进程互斥的含义：进程的互斥是指
**当有若干进程都要使用某一共享资源**
时，
**任何时刻最多只允许一个进程去使用**
，其他要使用该资源的进程必须等待，直到占用资源者释放了该资源。

PV操作是两个过程，由他们两个来控制一个信号S，假设S是红灯的个数。

每个进程
**进入临界区前**
都要先
**执行P操作**
。
**退出临界区**
时
**执行V操作**
。用下面的比喻很容易理解：

临界区门前有棵树（S）

用来挂红灯

进程想进CPU的门

先得上树取盏灯（调用一次P操作）

取下一个去敲门（S=S-1）

如果树上没灯取（S≤0）

树说欠你一盏灯（S为负时）

没辙只好外边排队等（ W ait （S））

得灯进程续运行

运行完了要出门（调用一次V操作）

马上还回一盏灯（S=S+1）

若有进程在催债（S≤0）

放个进去事完成（ Release （S））

2） 实现进程互斥的工具——PV操作。

PV操作是由两个操作，即P操作和V操作组成。P操作和V操作是两个在信号量上进行操作的过程。假定用S表示信号量则把这两个过程记作P（S）和V（S），它们的定义如下：

```cs
Procedue P（Var S: Semaphore）;
begin S:=S-1;
if S<0 
then W（S） 
end;
{P} 

Procedue V（Var S: Semaphore）;
begin S:=S+1;
if S<=0 
then R（S） 
end;
{V}
```

为了确保PV操作自身的正确执行，因此P（S）和V（S）操作中不可中断，这种 不可被中断的过程称为“原语 ”。

3） 用PV操作管理相关临界区的一般形式

**一个信号量与一组涉及共享变量的相关临界区联系起来**
，信号量的初值定为“1”。

任何一个进程要进入临界区前先调用P操作，执行临界区的操作后，退出临界区时调用V操作。

由于信号量的初值为“1”，P操作起到了限制一次只有一个进程进入临界区的作用，其余进程欲进入临界区必须符合对临界区管理的第一个要求，即一次最多让一个进程在临界区执行。进程退出后执行V操作，若有进程在等待则释放一个进程，这样就达到了对临界区管理的第二个和第三个要求（即不能无限逗留也不能无限等待）。

---

#### >> 操作系统原理9 —— 死锁

本章考核知识点 ：1、死锁的产生 2、死锁的防止 3、死锁的避免4、死锁的检测

**一、 死锁的产生**

话说狼GG和狼MM面对面走上一根独木桥。

狼GG说：呵呵，小MM，我已经占领了这座桥的一半，你不如退出去让我先过去吧。

狼MM说，哼哼，老兄，我也占了这座桥的一半，你咋不让给我？

狼GG和狼MM互不相让，都在等对方先让步。结果两个都过不了河。等着猎人来处理后事了。

1、什么叫死锁 ： 若系统中存在一组进程（两个或多个进程），它们中的每一个进程都占用了某种资源而又都在等待其中另一个进程所占用的资源，这种等待永远不能结束，则说系统出现了“死锁”。或说这组进程处于“死锁”状态。

2、引起死锁的因素：死锁的出现除了与资源的分配策略有关外，也与并发进程的执行速度有关，即操作系统对资源管理不得当或没有顾及进程并发执行时可能出现的情况，则就可能形成死锁。

**二、 死锁的防止**

我们把桥的一半看作一个资源的话，那么，当狼MM占用了其中一个资源后，狼GG就只好等待了。

狼GG狼MM各自占有了一段资源又在等另外的资源，又不肯放弃自己占有的资源。

他们又不能把对方踢下河去，把另一段资源抢过来自己用。

只好互相等待了。

这4个条件是必要条件而不是充分条件，意思是，只要发生死锁，那么这四个条件必然都成立。反之则不然，有时候即使四个条件都满足，那也不一定发生死锁。（从资源分配图中可以分析得到，即使形成循环等待资源，也不一定形成死锁。）

1、系统出现死锁必然同时保持的四个必要条件：

1）互斥使用资源

2）占有并等待资源

3）不可抢夺资源

4）循环等待资源

2、死锁的防止策略 ：要防止死锁形成，只要采用的资源分配策略能使上述4个条件中有一个条件不成立就可以了。

1）破坏互斥使用资源的条件经常是行不通的。因为
**资源本身特性就是互斥使用的**
。

2）要破坏“占有并等待条件”则可以采取两种办法： 静态分配 和 释放已占资源 .

静态分配 也称为 预分配资源 ，要求每一个进程在开始执行前就申请它所需要的全部资源，仅当系统能满足进程的资源申请要求且把资源分配给进程后，该进程才能开始执行。

释放已占资源 就是指进程申请资源时必须没有占用资源，如果已经占用了资源就要先归还所占的资源再申请。

3）实现 可抢夺式分配 ：如果一个进程已经占有了某些资源又要申请新资源，而新资源不能满足（已被其它进程占用）必须等待时，系统可以抢夺该进程已占有的资源。

4）实现 按序分配 ：把系统中所有资源排一个顺序，对每一个资源给一个确定的编号，规定任何一个进程申请两个以上的资源时，总是先申请编号小的资源，再申请编号大的资源。

**三、 死锁的避免**

死锁的避免不同于死锁的防止，死锁的防止是采用某种分配策略后，系统就不会产生死锁，这好比是你打过了某种预防针，再也不会得那种病。
**而死锁的避免是没有打预防针，但是通过其他办法，避免得病**
。因此有“安全状态”的说法，对应的，当然也有不安全状态。就像人都有得病的可能，不必任何病都打预防针。只要注意防病，仍然可以安全健康的生活。

1、 安全状态 ：如果操作系统能保证所有的进程在 有限的时间 内得到需要的 全部资源 ，则称系统处于“安全状态”。

2、区分死锁的 避免 与死锁的 防止 ：当采用了防止死锁的资源分配策略后，系统中就不会形成死锁。但是可以防止死锁的资源分配策略中，有的只适用于对某些资源的分配，有的会影响资源的使用效率。这时可用使用死锁的避免。

死锁的避免是解决死锁的另一种方法，它不同于死锁的防止。在系统中不采用防止死锁的资源分配策略，而是估计到可能有死锁发生时避免死锁的发生。

3、银行算法是怎样避免死锁的：

**银行家算法是这样的**
：

1）当一个用户对资金的最大的需求量不超过银行家现有的资金时就可以接纳该用户。

2）用户可以分期贷款，但贷款的总数不能超过最大需求量。

3）当银行家现有的资金不能满足用户的尚需贷款时，对用户的贷款可推迟支付，但总能使用户在有限的时间里得到贷款。

4）当用户得到所需的全部资金后，一定能在有限的时间里归还所有资金。

我们把操作系统看作是银行家，操作系统管理的资源相当于是银行家管理的资金，则银行家算法就是：

1）当一个进程首次申请资源时，测试该进程对资源的最大的需求量，如果不超过系统现存资源时就可以按他的当前申请量为其分配资源。 否则推迟分配。

2）进程执行中继续申请资源时，测试该进程占用资源和本次申请资源总数有没有超过最大需求量。超过就不分配，没超过则再测试现存资源是否满足进程还需要的最大资源量，满足则按当前申请量分配，否则也推迟分配。

总之，银行家算法要保证分配资源时
**系统现存资源**
一定能满足至少
**一个进程所需的全部资源**
。这样就可以保证所有进程都能在有限时间内得到需要的全部资源。这就是安全状态。

**四、 死锁的检测**

就是既不打预防针，也不去避免得病，而是经常去体检，如果发现有病了就治疗。这是一种事后解决的办法，也算是解决死锁问题的一条途径。但这毕竟要付出较大代价。

1、什么是 死锁的检测 ：对资源的申请和分配不加限制，只要有剩余的资源就可把资源分配给申请者。这样可能会出现死锁，系统定时运行一个“死锁检测程序”，如果检测到死锁发生，则必须先解除死锁再继续工作。

2、怎样实现死锁的检测：1、每个资源当用中只有一个资源 2、资源类中含有若干个资源。

3、 死锁的解除 ：一般采用两种方式来解除死锁，一种是终止一个或几个进程的执行以破坏循环等待；另一种是从涉及死锁的进程中抢夺资源。

检测死锁和解除死锁都要付出很大代价。所以用死锁检测的方法解决死锁问题只适用于 不经常发生死锁 的系统中。