---
layout: post
title: "Linuxhttp-协议"
date: 2025-03-05 23:38:22 +0800
description: "实际 http 协议本身无需用户关注序列化和反序列化，直接发送即可，而对于正文部分，如果有需要用户可以自定义序列化和反序列化方案。当用户首次登录时，浏览器会将用户的账号和密码保存在cookie文件里，当用户近期再次访问该网站或在网站内进行跳转时，浏览器会自动将cookie文件里的数据推送给服务器，从而不需要用户再次登录。我们可以看到当我们搜索 C++ 时， URL中不是显式的C++，而是 C%2B%2B 的形式，这是因为在http协议对于URL中的特殊字符，必须将其进行转义。URL即我们平时常称的网址。"
keywords: "【Linux】http 协议"
categories: ['未分类']
tags: ['网络协议', '网络', 'Http']
artid: "146050509"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146050509
    alt: "Linuxhttp-协议"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146050509
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146050509
cover: https://bing.ee123.net/img/rand?artid=146050509
image: https://bing.ee123.net/img/rand?artid=146050509
img: https://bing.ee123.net/img/rand?artid=146050509
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Linux】http 协议
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81http%E5%8D%8F%E8%AE%AE" name="%E4%B8%80%E3%80%81http%E5%8D%8F%E8%AE%AE">
     一、http协议
    </h2>
    <h3 id="%EF%BC%88%E4%B8%80%EF%BC%89http%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E5%BF%B5" name="%EF%BC%88%E4%B8%80%EF%BC%89http%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E5%BF%B5">
     （一）http 协议的概念
    </h3>
    <p>
     上节我们提到可以自定协议，但是面对一些复杂的场景单靠自定协议是很难满足需求的。实际上已经有一些现成且好用的应用层协议，http 超文本传输协议就是其中之一。
    </p>
    <h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89URL%E7%9A%84%E7%BB%84%E6%88%90" name="%EF%BC%88%E4%BA%8C%EF%BC%89URL%E7%9A%84%E7%BB%84%E6%88%90">
     （二）URL的组成
    </h3>
    <p>
     URL即我们平时常称的网址。
    </p>
    <p style="text-align:center">
     <img alt="" height="165" src="https://i-blog.csdnimg.cn/direct/39bcf678d24f4abab07c654e9de43586.png" width="388"/>
    </p>
    <p>
     ip会标识一台网络主机，我们通过在浏览器中输入网址就可以访问该服务器，从指定的文件路径下找到用户请求的文件返回给用户。
    </p>
    <h3 id="%EF%BC%88%E4%B8%89%EF%BC%89urlencode%20%E5%92%8C%20urldecode" name="%EF%BC%88%E4%B8%89%EF%BC%89urlencode%20%E5%92%8C%20urldecode">
     （三）urlencode 和 urldecode
    </h3>
    <p>
     对于URL而言，在浏览器中其并不是完全明文显式的，例如：
    </p>
    <p style="text-align:center">
     <img alt="" height="147" src="https://i-blog.csdnimg.cn/direct/56eb4146c4e7408e8ab9b180bc3d7de3.png" width="621"/>
    </p>
    <p>
     我们可以看到当我们搜索 C++ 时， URL中不是显式的C++，而是 C%2B%2B 的形式，这是因为在http协议对于URL中的特殊字符，必须将其进行转义。
    </p>
    <blockquote>
     <p>
      转义规则：
     </p>
     <p>
      一个字节是八个比特位，从中间划分左右各4位（不足4位直接处理），将左右4位分别转为16进制，将两位组合在一起后前面加上%便编码成%XY格式。
     </p>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81http%20%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F" name="%E4%BA%8C%E3%80%81http%20%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F">
     二、http 的协议格式
    </h2>
    <h3 id="%EF%BC%88%E4%B8%80%EF%BC%89http%20%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95" name="%EF%BC%88%E4%B8%80%EF%BC%89http%20%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">
     （一）http 请求方法
    </h3>
    <p>
     本文只介绍两种常用的请求方法：GET和POST。
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td style="text-align:center">
        方法
       </td>
       <td style="text-align:center">
        说明
       </td>
       <td style="text-align:center">
        支持的HTTP协议版本
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        GET
       </td>
       <td style="text-align:center">
        获得资源
       </td>
       <td style="text-align:center">
        1.0、1.1
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        POST
       </td>
       <td style="text-align:center">
        传输实体主题
       </td>
       <td style="text-align:center">
        1.0、1.1
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     虽然它们都是客户端向服务器发出的请求方法，但是二则略有不同。
    </p>
    <p>
     <img alt="" height="258" src="https://i-blog.csdnimg.cn/direct/dc87c35d4cba40148cdd1a9c7e4663ff.png" width="1428"/>
    </p>
    <p>
     针对同一份前端表单form，当不同的请求方法时，浏览器会将执行不同的动作：
    </p>
    <blockquote>
     <p>
      1、GET方法通过URL传递参数。例如上例中，当我们使用GET方法处理表单时，浏览器会将我们的表单内容拼接为URL发送给服务器，http://ip::port/XXX?key=value。使用URL进行传参注定了参数不能过大，当传输数据过大时使用GET方法请求就不合适了；
     </p>
     <p>
      2、 POST方法则是通过http请求正文传递参数的，对于正文数据大小没有限制，适合传递一些大型文件。
     </p>
     <p>
      3、POST方法相较于GET方法更加私密，GET方法通过URL传递参数，所以传递的数据可以被直接看到。虽然POST方法比GET方法更私密，但二者实际都是不安全的，如果需要加密安全的话得使用https协议。
     </p>
    </blockquote>
    <h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89http%20%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81" name="%EF%BC%88%E4%BA%8C%EF%BC%89http%20%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">
     （二）http 响应状态码
    </h3>
    <p>
     https协议的状态码：
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:800px">
     <tbody>
      <tr>
       <td>
       </td>
       <td>
        类别
       </td>
       <td>
        原因短语
       </td>
      </tr>
      <tr>
       <td>
        1XX
       </td>
       <td>
        Informational（信息状态码）
       </td>
       <td>
        <p>
         接收的请求正在处理
        </p>
       </td>
      </tr>
      <tr>
       <td>
        2XX
       </td>
       <td>
        Success（成功状态码）
       </td>
       <td>
        请求正常处理完毕
       </td>
      </tr>
      <tr>
       <td>
        3XX
       </td>
       <td>
        Redirection（重定向状态码）
       </td>
       <td>
        需要进行附加操作以完成请求
       </td>
      </tr>
      <tr>
       <td>
        4XX
       </td>
       <td>
        Client Error（客户端错误状态码）
       </td>
       <td>
        服务器无法处理请求
       </td>
      </tr>
      <tr>
       <td>
        5XX
       </td>
       <td>
        Server Error（服务器错误状态码）
       </td>
       <td>
        服务器处理请求出错
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     常见错误码：
    </p>
    <blockquote>
     <p>
      2XX：
     </p>
     <ul>
      <li>
       200 OK：请求成功
      </li>
      <li>
       201 Created：请求已经被实现，资源已经被创建。
      </li>
      <li>
       204 No Content：请求成功，但响应报文不含实体的主体部分。
      </li>
     </ul>
     <p>
      3XX：
     </p>
     <ul>
      <li>
       301 Moved Permanently：永久性重定向
      </li>
      <li>
       302 Found：临时性重定向
      </li>
      <li>
       307 Temporary Redirect：临时性重定向
      </li>
     </ul>
     <p>
      4XX：
     </p>
     <ul>
      <li>
       400 Bad Request：请求报文存在语法错误
      </li>
      <li>
       401 Unauthorized：未经授权，需要身份验证
      </li>
      <li>
       403 Forbidden：服务器拒绝请求
      </li>
      <li>
       404 Not Found：服务器无法找到请求的资源
      </li>
     </ul>
     <p>
      5XX：
     </p>
     <ul>
      <li id="u8fa76815">
       500 Internal Server Error：服务器内部错误
      </li>
      <li id="udf424929">
       502 Bad Gateway：网关错误
      </li>
      <li id="u4a9ca1c9">
       503 Service Unavailable：服务器暂时无法处理请求
      </li>
      <li id="u401f5a98">
       504 Gateway Timeout：网关超时
      </li>
     </ul>
    </blockquote>
    <h3 id="%EF%BC%88%E4%B8%89%EF%BC%89http%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4" name="%EF%BC%88%E4%B8%89%EF%BC%89http%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4">
     （三）http 常见的响应报头
    </h3>
    <blockquote>
     <ul>
      <li>
       Content-Type：指定响应体的MIME类型，例如text/html表示HTML文本，image/jpeg表示JPEG图片等。
      </li>
      <li>
       Content-Length：指定响应体的长度，单位为字节
      </li>
      <li>
       Host：客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上
      </li>
      <li>
       User-Agent：声明用户的操作系统和浏览器版本信息
      </li>
      <li>
       referer：当前页面是从哪个页面跳转过来的
      </li>
      <li>
       location：搭配3xx状态码使用, 告诉客户端接下来要去哪里访问
      </li>
      <li>
       cookie：用于在客户端存储少量信息. 通常用于实现会话的功能
      </li>
     </ul>
    </blockquote>
    <h2 id="%E4%B8%89%E3%80%81http%20%E5%8D%8F%E8%AE%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B" name="%E4%B8%89%E3%80%81http%20%E5%8D%8F%E8%AE%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B">
     三、http 协议客户端和服务器通信过程
    </h2>
    <p>
     <img alt="" height="567" src="https://i-blog.csdnimg.cn/direct/3e04acf16b134aaea5971aac6358c31e.png" width="1365"/>
    </p>
    <h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B0%86%E8%AF%B7%E6%B1%82%E6%88%96%E5%93%8D%E5%BA%94%E5%AE%8C%E6%95%B4%E8%AF%BB%E5%8F%96%E5%AE%8C%E4%BA%86%EF%BC%9F" name="%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B0%86%E8%AF%B7%E6%B1%82%E6%88%96%E5%93%8D%E5%BA%94%E5%AE%8C%E6%95%B4%E8%AF%BB%E5%8F%96%E5%AE%8C%E4%BA%86%EF%BC%9F">
     （一）应用层如何保证将请求或响应完整读取完了？
    </h3>
    <p>
     首先对于请求行、请求报头、状态行和响应报头都是按照 \r\n 为行分隔符，因此可以读取完整的一行。而报头与正文之间也存在着一个分隔符，因此可以区分请求报头是否读取完整。而请求报头中存在着 Content-Length 字段，其记录了正文的长度，因此应用层可以完整地读取请求正文或响应正文，从而保证了应用层可以完整地读取一个完整的请求或响应。
    </p>
    <h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89http%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" name="%EF%BC%88%E4%BA%8C%EF%BC%89http%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">
     （二）http如何进行序列化和反序列化
    </h3>
    <p>
     上节我们自定义协议的时候是需要对请求和响应进行序列化和反序列化的，那么 http 协议是如何进行需要序列化和反序列化呢？实际 http 协议本身无需用户关注序列化和反序列化，直接发送即可，而对于正文部分，如果有需要用户可以自定义序列化和反序列化方案。
    </p>
    <h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E4%BF%A1%E5%85%A8%E8%BF%87%E7%A8%8B" name="%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E4%BF%A1%E5%85%A8%E8%BF%87%E7%A8%8B">
     （三）通信全过程
    </h3>
    <h4 id="1%E3%80%81%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" name="1%E3%80%81%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">
     1、启动服务器
    </h4>
    <pre><code class="language-cpp">    void httpHandler(int fd, func_t func)
    {
        // 读取数据
        char buffer[1024];
        ssize_t n = recv(fd, buffer, sizeof(buffer) - 1, 0);
        if (n &gt;= 0)
        {
            buffer[n] = 0;
            Request req;
            Response resp;
            req.parse(buffer);
            func(req, resp);
            send(fd, resp.outbuffer.c_str(), resp.outbuffer.size(), 0);
        }
    }
    void start(func_t func)
    {
        while (1)
        {
            signal(SIGCHLD, SIG_IGN);
            sockaddr_in addr;
            socklen_t len = sizeof(addr);
            int socket = accept(_fd, (struct sockaddr *)&amp;addr, &amp;len);
            if (socket == -1)
            {
                cerr &lt;&lt; "accept failure : " &lt;&lt; strerror(errno) &lt;&lt; endl;
                continue;
            }

            pid_t pid = fork();
            if (pid == 0)
            {
                close(_fd);
                httpHandler(socket, func);
                close(socket);
                exit(0);
            }
            close(socket);
        }
    }</code></pre>
    <h4 id="2%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB" name="2%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB">
     2、工具类
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
using namespace std;
class Util
{
public:
    static string getLine(string &amp;buffer, const string &amp;sep)
    {
        auto index = buffer.find(sep);
        if (index == string::npos)
            return "";
        string ret = buffer.substr(0, index);
        buffer.erase(0, index);
        return ret;
    }
    static bool readFile(const string &amp;text, char *buffer, int size)
    {
        fstream in(text, ios_base::binary | ios_base::in);
        if (!in.is_open())
            return false;
        in.read(buffer, size);
        in.close();
        return true;
    }
};</code></pre>
    <h4 id="2%E3%80%81%E5%88%86%E6%9E%90%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87" name="2%E3%80%81%E5%88%86%E6%9E%90%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">
     2、分析请求报文
    </h4>
    <pre><code class="language-cpp">class Request
{
public:
    Request() {}
    ~Request() {}

    void parse(const string &amp;in)
    {
        inbuffer = in;
        string firstLine = Util::getLine(inbuffer, SEP);
        stringstream s(firstLine);
        s &gt;&gt; method &gt;&gt; url &gt;&gt; httpversion;

        path = DEFAULT_PATH;
        path += url;
        if (path[path.size() - 1] == '/')
            path += HOME_PAGE;
        else
            path += ".html";
        struct stat st;
        int ret = stat(path.c_str(), &amp;st);
        if (ret == 0)
            size = st.st_size;
        else
            size = -1;
    }

public:
    string inbuffer;
    string method;
    string url;
    string path;
    string httpversion;
    string suffix;
    string parm;
    int size;
};</code></pre>
    <h4 id="3%E3%80%81%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87" name="3%E3%80%81%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">
     3、发送响应报文
    </h4>
    <pre><code class="language-cpp">void Get(const Request &amp;req, Response &amp;resp)
{
    cout &lt;&lt; "----------------------http recv start---------------------------" &lt;&lt; endl;
    cout &lt;&lt; req.inbuffer &lt;&lt; std::endl;
    std::cout &lt;&lt; "method: " &lt;&lt; req.method &lt;&lt; std::endl;
    std::cout &lt;&lt; "url: " &lt;&lt; req.url &lt;&lt; std::endl;
    std::cout &lt;&lt; "httpversion: " &lt;&lt; req.httpversion &lt;&lt; std::endl;
    std::cout &lt;&lt; "path: " &lt;&lt; req.path &lt;&lt; std::endl;
    cout &lt;&lt; "----------------------http recv end---------------------------" &lt;&lt; endl;

    cout &lt;&lt; "----------------------http send start---------------------------" &lt;&lt; endl;
    resp.outbuffer += "HTTP/1.1 200 OK\r\n";
    // resp.outbuffer += "HTTP/1.1 302 Found\r\n";
    resp.outbuffer += "Content-Type: text/html\r\n";
    // resp.outbuffer += "Location:https://blog.csdn.net/Sweet_0115?spm=1000.2115.3001.5343\r\n";
    resp.outbuffer += "\r\n";
    string body;
    body.resize(req.size + 1);
    if (!Util::readFile(req.path, (char *)body.c_str(), body.size()))
        !Util::readFile("./wwwroot/404.html", (char *)body.c_str(), body.size());
    cout &lt;&lt; "test : -----------" &lt;&lt; req.path &lt;&lt; endl;
    // cout &lt;&lt; body &lt;&lt; endl;
    resp.outbuffer += body;
    cout &lt;&lt; resp.outbuffer &lt;&lt; endl;
    cout &lt;&lt; "----------------------http send end---------------------------" &lt;&lt; endl;
}</code></pre>
    <h2 id="%E5%9B%9B%E3%80%81http%20%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81" name="%E5%9B%9B%E3%80%81http%20%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81">
     四、http 会话保持
    </h2>
    <p>
     当我们打开CSDN登录后，即使我们关闭了浏览器，短期内我们再打开CSDN仍然不需要重复登录。同样的，我们在CSDN内进行网页跳转时，也不需要再重复登录。http 协议是无状态的，那么浏览器是怎么做到网页跳转时用户不需要重复登录呢？
    </p>
    <p>
     <strong>
      这实际就是会话保持，http请求是无状态的，也就是以上功能并不是 http 提供的，而是session和cookie提供的。
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     当用户首次登录时，浏览器会将用户的账号和密码保存在cookie文件里，当用户近期再次访问该网站或在网站内进行跳转时，浏览器会自动将cookie文件里的数据推送给服务器，从而不需要用户再次登录。例如当我们使用软件观看一些会员视频时，利用以上机制可以鉴权进行身份判断。
    </p>
    <p>
     但以上方式实际很不安全，例如一些不法分子可以通过劫持 http请求 从而获取到用户的账号和密码，所以以上机制是很危险的。
    </p>
    <p>
     <strong>
      实际当用户登录后，服务器会为用户建立会话（session），其会保存用户的信息，同时会返回给浏览器 session id。当用户近期再次访问网站或再网站内进行跳转时，浏览器则向服务器发送 session id，而服务器则通过该 session id 进行身份鉴权判断。
     </strong>
    </p>
    <p style="text-align:center">
     <img alt="" height="368" src="https://i-blog.csdnimg.cn/direct/c7c62d08e7434bd7a5e46039309879af.png" width="559"/>
    </p>
    <p>
     <strong>
     </strong>
     但实际以上机制仍存在风险，不法分子仍然可以通过劫持 http 请求获取 session id，通过该id仍然可以向服务器伪造请求，但相比于第一种方案，至少用户的账户密码信息没有丢失。上述方案也可以配合别的机制，例如短信验证或人脸识别保障信息安全，例如当账号突然被异地登录（用户信息泄漏），服务器检测后使 session id 失效并令用户重新进行验证登录，一定程度上保护了用户的信息安全。
    </p>
    <p>
     http请求并不安全，如果有安全防护需求必须得使用https协议。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f53776565745f303131352f:61727469636c652f64657461696c732f313436303530353039" class_="artid" style="display:none">
 </p>
</div>


