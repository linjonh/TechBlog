---
layout: post
title: "C-建造者模式Builder-Pattern详细讲解"
date: 2025-03-15 22:26:32 +0800
description: "建造者模式（Builder Pattern）是一种创建型设计模式，它通过将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。这个模式主要应用于那些构建过程复杂且涉及多个步骤的场景，特别适合于需要灵活配置且逐步构建的对象。Car在本例中，我们要构建的产品是一个复杂的Car类。该类有多个部件和属性，包括引擎类型、车轮数量、是否有 GPS、是否有天窗等。set;set;set;set;CarEngine（引擎类型），Wheels（车轮数），HasGPS（是否有 GPS），"
keywords: "C# 建造者模式（Builder Pattern）详细讲解"
categories: ['设计模式', 'C']
tags: ['数据库', '开发语言', 'Net', 'Javascript', 'Java', 'C', '.Netcore']
artid: "146286754"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146286754
    alt: "C-建造者模式Builder-Pattern详细讲解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146286754
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146286754
cover: https://bing.ee123.net/img/rand?artid=146286754
image: https://bing.ee123.net/img/rand?artid=146286754
img: https://bing.ee123.net/img/rand?artid=146286754
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# 建造者模式（Builder Pattern）详细讲解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
    </h2>
    <h3>
     一、什么是建造者模式？
    </h3>
    <p>
     建造者模式（Builder Pattern）是一种创建型设计模式，它通过将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。这个模式主要应用于那些构建过程复杂且涉及多个步骤的场景，特别适合于需要灵活配置且逐步构建的对象。
    </p>
    <h4>
     1.1. 设计模式分类
    </h4>
    <p>
     设计模式（Design Patterns）分为三大类：
    </p>
    <ul>
     <li>
      <strong>
       创建型模式
      </strong>
      （Creational Patterns）：关注如何创建对象的设计模式。
     </li>
     <li>
      <strong>
       结构型模式
      </strong>
      （Structural Patterns）：关注如何通过组合对象来构建更大的结构。
     </li>
     <li>
      <strong>
       行为型模式
      </strong>
      （Behavioral Patterns）：关注对象之间如何进行交互和职责分配。
     </li>
    </ul>
    <p>
     建造者模式属于
     <strong>
      创建型模式
     </strong>
     ，它的目的是通过分步构建，避免构造复杂对象时需要过多的参数或复杂的配置。
    </p>
    <h4>
     1.2. 为什么使用建造者模式？
    </h4>
    <p>
     在许多情况下，我们会遇到这样的问题：某些对象非常复杂，构建它们时需要多个步骤，这些步骤又可能是可选的，或者需要根据不同的需求使用不同的配置。直接通过构造函数来构建这样复杂的对象，不仅代码重复，而且不易扩展。建造者模式通过将构建过程分解成多个步骤，使得对象的创建过程更具灵活性，且客户端代码更加简洁。
    </p>
    <h3>
     二、建造者模式的结构
    </h3>
    <p>
     建造者模式的核心思想是
     <strong>
      将对象的创建过程分成多个步骤，而这些步骤可以独立进行组合。
     </strong>
     建造者模式一般包含以下几个组成部分：
    </p>
    <h4>
     2.1. 组成部分
    </h4>
    <ol>
     <li>
      <strong>
       产品类（Product）
      </strong>
      ：
      <ul>
       <li>
        产品类是最终构建出来的对象，它通常是一个复杂对象，包含多个部件和属性。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       抽象建造者（Builder）
      </strong>
      ：
      <ul>
       <li>
        抽象建造者声明了构建产品的各个步骤，例如设置不同的部件，获取最终的产品等。通常是一个接口或者抽象类，提供一组构建方法。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       具体建造者（Concrete Builder）
      </strong>
      ：
      <ul>
       <li>
        具体建造者实现了抽象建造者的方法，并为构建产品的每一步提供具体的实现。它管理着产品的组成部分，并在最后生成产品。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       指挥者（Director）
      </strong>
      ：
      <ul>
       <li>
        指挥者负责定义构建过程的顺序，调用具体建造者的方法来完成复杂对象的构建。指挥者并不关心产品的具体细节，而是将构建过程委托给建造者来完成。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     三、建造者模式的工作流程
    </h3>
    <p>
     建造者模式的工作流程通常如下：
    </p>
    <ol>
     <li>
      <strong>
       客户
      </strong>
      创建一个指挥者对象，并通过它指定所需的建造者（通常是某个具体的建造者类）。
     </li>
     <li>
      <strong>
       指挥者
      </strong>
      会按照顺序调用建造者中的各个方法，逐步构建产品。
     </li>
     <li>
      <strong>
       具体建造者
      </strong>
      负责逐步构建产品的各个部分（如设置不同的部件或配置）。
     </li>
     <li>
      <strong>
       最终产品
      </strong>
      在构建完成后返回给客户，客户可以根据需求使用该产品。
     </li>
    </ol>
    <h3>
     四、示例：构建一个复杂的汽车对象
    </h3>
    <h4>
     4.1. 定义产品类：
     <code>
      Car
     </code>
    </h4>
    <p>
     在本例中，我们要构建的产品是一个复杂的
     <code>
      Car
     </code>
     类。该类有多个部件和属性，包括引擎类型、车轮数量、是否有 GPS、是否有天窗等。
    </p>
    <pre><code>public class Car
{
    public string Engine { get; set; }
    public int Wheels { get; set; }
    public bool HasGPS { get; set; }
    public bool HasSunroof { get; set; }

    public override string ToString()
    {
        return $"Car [Engine: {Engine}, Wheels: {Wheels}, GPS: {HasGPS}, Sunroof: {HasSunroof}]";
    }
}
</code></pre>
    <p>
     <code>
      Car
     </code>
     类有四个主要属性，分别是：
     <code>
      Engine
     </code>
     （引擎类型），
     <code>
      Wheels
     </code>
     （车轮数），
     <code>
      HasGPS
     </code>
     （是否有 GPS），
     <code>
      HasSunroof
     </code>
     （是否有天窗）。这些属性是构成汽车的基本部分。
    </p>
    <h4>
     4.2. 创建抽象建造者：
     <code>
      ICarBuilder
     </code>
    </h4>
    <p>
     <code>
      ICarBuilder
     </code>
     是一个接口，定义了构建汽车的步骤（例如构建引擎、车轮、GPS 和天窗等）：
    </p>
    <pre><code>public interface ICarBuilder
{
    void BuildEngine();
    void BuildWheels();
    void BuildGPS();
    void BuildSunroof();
    Car GetResult();
}
</code></pre>
    <p>
     <code>
      ICarBuilder
     </code>
     接口提供了五个方法：
    </p>
    <ul>
     <li>
      <code>
       BuildEngine()
      </code>
      ：构建引擎。
     </li>
     <li>
      <code>
       BuildWheels()
      </code>
      ：构建车轮。
     </li>
     <li>
      <code>
       BuildGPS()
      </code>
      ：构建 GPS。
     </li>
     <li>
      <code>
       BuildSunroof()
      </code>
      ：构建天窗。
     </li>
     <li>
      <code>
       GetResult()
      </code>
      ：返回最终构建好的产品
      <code>
       Car
      </code>
      对象。
     </li>
    </ul>
    <h4>
     4.3. 创建具体建造者：
     <code>
      SportsCarBuilder
     </code>
    </h4>
    <p>
     <code>
      SportsCarBuilder
     </code>
     类是一个具体的建造者，它实现了
     <code>
      ICarBuilder
     </code>
     接口，负责具体构建一个运动型汽车：
    </p>
    <pre><code>public class SportsCarBuilder : ICarBuilder
{
    private Car _car = new Car();

    public void BuildEngine()
    {
        _car.Engine = "V8 Engine"; // 运动型车的引擎
    }

    public void BuildWheels()
    {
        _car.Wheels = 4; // 标准运动型车有4个轮子
    }

    public void BuildGPS()
    {
        _car.HasGPS = true; // 运动型车需要 GPS
    }

    public void BuildSunroof()
    {
        _car.HasSunroof = true; // 运动型车有天窗
    }

    public Car GetResult()
    {
        return _car; // 返回构建好的汽车
    }
}
</code></pre>
    <p>
     在
     <code>
      SportsCarBuilder
     </code>
     中，每个方法实现了具体的构建步骤，逐步设置汽车的属性。最后，
     <code>
      GetResult()
     </code>
     方法返回构建完成的
     <code>
      Car
     </code>
     对象。
    </p>
    <h4>
     4.4. 创建指挥者：
     <code>
      CarDirector
     </code>
    </h4>
    <p>
     指挥者类
     <code>
      CarDirector
     </code>
     负责按照一定顺序调用建造者的方法来构建汽车：
    </p>
    <pre><code>public class CarDirector
{
    private ICarBuilder _carBuilder;

    public CarDirector(ICarBuilder carBuilder)
    {
        _carBuilder = carBuilder;
    }

    public Car ConstructCar()
    {
        _carBuilder.BuildEngine();
        _carBuilder.BuildWheels();
        _carBuilder.BuildGPS();
        _carBuilder.BuildSunroof();
        return _carBuilder.GetResult();
    }
}
</code></pre>
    <p>
     <code>
      CarDirector
     </code>
     类使用
     <code>
      ICarBuilder
     </code>
     来完成汽车的构建过程。
     <code>
      ConstructCar()
     </code>
     方法按照固定的顺序调用建造者的构建方法，最后返回构建好的汽车。
    </p>
    <h4>
     4.5. 客户端代码：如何使用建造者模式
    </h4>
    <p>
     客户端代码通过创建一个具体的建造者（如
     <code>
      SportsCarBuilder
     </code>
     ），然后将它传递给指挥者
     <code>
      CarDirector
     </code>
     ，最终得到一个构建好的汽车。
    </p>
    <pre><code>class Program
{
    static void Main(string[] args)
    {
        // 创建具体的建造者
        ICarBuilder carBuilder = new SportsCarBuilder();

        // 创建指挥者
        CarDirector director = new CarDirector(carBuilder);

        // 指挥者构建汽车
        Car car = director.ConstructCar();

        // 输出结果
        Console.WriteLine(car);
    }
}
</code></pre>
    <h4>
     输出：
    </h4>
    <pre><code>Car [Engine: V8 Engine, Wheels: 4, GPS: True, Sunroof: True]
</code></pre>
    <p>
     在客户端中，我们通过
     <code>
      CarDirector
     </code>
     来构建一个带有 V8 引擎、4 个轮子、GPS 和天窗的运动型车。
    </p>
    <h3>
     五、建造者模式的优点与缺点
    </h3>
    <h4>
     5.1. 优点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        解耦产品的构建与表示
       </strong>
       ：
      </p>
      <ul>
       <li>
        建造者模式将对象的构建过程与最终的表示（对象的不同状态）分开，允许你独立于对象的具体表示方式构建复杂对象。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        构建过程灵活
       </strong>
       ：
      </p>
      <ul>
       <li>
        同一个构建过程可以生成不同的产品。例如，你可以使用不同的建造者（如
        <code>
         SportsCarBuilder
        </code>
        和
        <code>
         SUVCarBuilder
        </code>
        ）来构建不同类型的汽车。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        代码清晰、可维护
       </strong>
       ：
      </p>
      <ul>
       <li>
        每个具体建造者只负责构建特定类型的产品，避免了复杂的构造函数或多个参数的使用，使得代码结构更加清晰。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        适合复杂产品的创建
       </strong>
       ：
      </p>
      <ul>
       <li>
        当对象的构建过程复杂，且各个部件之间有多种组合方式时，建造者模式非常适合。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     5.2. 缺点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        需要更多的类
       </strong>
       ：
      </p>
      <ul>
       <li>
        由于每个不同的建造者需要实现一个接口，并为每个产品提供具体实现，因此在产品种类很多时，可能会创建多个建造者类，导致类的数量增加。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        不能直接使用“简单对象”
       </strong>
       ：
      </p>
      <ul>
       <li>
        对于一些简单的对象，使用建造者模式可能会显得有些“过度设计”，特别是当对象没有复杂的构建步骤时，简单的构造函数可能更为直接。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     六、总结
    </h3>
    <p>
     建造者模式是一种非常有效的设计模式，它提供了一种灵活的方式来构建复杂对象。通过分解构建过程并将其与具体的表示分离，建造者模式能够创建不同类型的对象，同时保持代码的清晰性和可维护性。在 C# 中，建造者模式适用于复杂对象的构建、逐步配置以及需要灵活控制构建过程的场景。
    </p>
    <h4>
     总结关键点：
    </h4>
    <ul>
     <li>
      <strong>
       产品类
      </strong>
      ：定义最终构建出来的复杂对象。
     </li>
     <li>
      <strong>
       建造者接口
      </strong>
      ：定义构建对象的步骤。
     </li>
     <li>
      <strong>
       具体建造者
      </strong>
      ：负责实现建造步骤并返回产品。
     </li>
     <li>
      <strong>
       指挥者
      </strong>
      ：负责控制构建过程的顺序，调用建造者进行具体操作。
     </li>
    </ul>
    <p>
     如果你需要在 C# 中处理复杂对象的创建，并且对象的构建步骤可能变化，或者存在多个变种，建造者模式将是一个非常好的选择。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34383931363134342f:61727469636c652f64657461696c732f313436323836373534" class_="artid" style="display:none">
 </p>
</div>


