---
layout: post
title: "Linux-中的管道进程间数据传输的利器"
date: 2025-03-12 08:44:23 +0800
description: "linux命名管道匿名管道"
keywords: "Linux 中的管道：进程间数据传输的利器"
categories: ['未分类']
tags: ['Redis', 'Linux', 'Java']
artid: "146195233"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146195233
    alt: "Linux-中的管道进程间数据传输的利器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146195233
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146195233
cover: https://bing.ee123.net/img/rand?artid=146195233
image: https://bing.ee123.net/img/rand?artid=146195233
img: https://bing.ee123.net/img/rand?artid=146195233
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux 中的管道：进程间数据传输的利器
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="chianoceanhttpsblogcsdnnetCayyyytypeblog_0">
     </a>
     <a href="https://blog.csdn.net/Cayyyy?type=blog">
      个人主页：chian-ocean
     </a>
    </h3>
    <h3>
     <a id="Linuxhttpsblogcsdnnetcayyyycategory_12826854html_2">
     </a>
     <a href="https://blog.csdn.net/cayyyy/category_12826854.html">
      文章专栏-Linux
     </a>
    </h3>
    <h2>
     <a id="_3">
     </a>
     前言
    </h2>
    <blockquote>
     <p>
      **进程间通信（Inter-Process Communication, IPC）**是指在操作系统中，不同进程之间交换数据或信息的方式。由于每个进程都有自己的地址空间，直接访问另一个进程的数据是不被允许的，因此需要使用IPC机制来实现进程间的通信
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ea62de0066bc4325a3263af91154cc6f.png"/>
    </p>
    <h2>
     <a id="_10">
     </a>
     进程间通信
    </h2>
    <h3>
     <a id="_12">
     </a>
     进程间通信的目的
    </h3>
    <p>
     进程间通信（IPC）的主要目的是让不同进程能够交换数据、协作工作和同步执行。由于每个进程有独立的内存空间，IPC提供了一种安全的方式让进程之间共享信息和资源。它的作用包括：
    </p>
    <ul>
     <li>
      <strong>
       数据共享
      </strong>
      ：让多个进程能够共享数据。
     </li>
     <li>
      <strong>
       进程同步
      </strong>
      ：协调进程的执行顺序，避免资源冲突。
     </li>
     <li>
      <strong>
       控制与协作
      </strong>
      ：让进程之间进行协作或控制执行。
     </li>
     <li>
      <strong>
       高效并发
      </strong>
      ：提高系统的处理能力和资源利用率。
     </li>
     <li>
      <strong>
       模块化设计
      </strong>
      ：简化系统设计，通过独立的进程模块进行工作。
     </li>
    </ul>
    <h3>
     <a id="_22">
     </a>
     进程间通信的分类
    </h3>
    <p>
     Linux 提供了多种进程间通信机制，以适应不同的应用场景：
    </p>
    <ul>
     <li>
      <strong>
       管道、消息队列、共享内存
      </strong>
      ：适用于同一系统内的进程间通信。
     </li>
     <li>
      <strong>
       信号量、套接字
      </strong>
      ：用于进程同步与资源访问控制。
     </li>
     <li>
      <strong>
       信号和D-Bus
      </strong>
      ：用于事件通知和消息传递。
     </li>
     <li>
      <strong>
       内存映射文件
      </strong>
      ：用于高效的大数据交换。
     </li>
    </ul>
    <h2>
     <a id="_31">
     </a>
     管道
    </h2>
    <p>
     管道（Pipe）是一种常见的进程间通信（IPC）机制，用于不同进程之间传递数据。它本质上是一个数据缓冲区，允许一个进程将数据写入其中，另一个进程从管道中读取数据。管道是一种单向通信的方式，但可以通过创建多个管道来实现双向通信。
    </p>
    <h3>
     <a id="_35">
     </a>
     管道的类型：
    </h3>
    <ol>
     <li>
      <strong>
       匿名管道（Anonymous Pipe）
      </strong>
      ：
      <ul>
       <li>
        匿名管道是无名的、临时的，通常用于父子进程之间的通信。
       </li>
       <li>
        由于匿名管道没有文件名，它们只能在创建它们的进程间使用。
       </li>
       <li>
        通过
        <code>
         pipe()
        </code>
        系统调用可以创建匿名管道，常用于同一系统内的进程间通信。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       命名管道（Named Pipe，FIFO）
      </strong>
      ：
      <ul>
       <li>
        命名管道是带有名字的管道，可以跨进程甚至跨系统使用。
       </li>
       <li>
        命名管道在文件系统中有一个路径，进程可以通过路径访问该管道。
       </li>
       <li>
        通过
        <code>
         mkfifo()
        </code>
        系统调用创建命名管道，适用于没有父子关系的进程间通信。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_46">
     </a>
     管道原理
    </h3>
    <div class="mermaid">
     <svg class="mermaid-svg" height="62" id="mermaid-svg-8uZTc5iXrvADqB30" viewbox="0 0 432 62" width="432" xmlns="http://www.w3.org/2000/svg">
      <style>
       #mermaid-svg-8uZTc5iXrvADqB30 {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-8uZTc5iXrvADqB30 .error-icon{fill:#552222;}#mermaid-svg-8uZTc5iXrvADqB30 .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-8uZTc5iXrvADqB30 .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-8uZTc5iXrvADqB30 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-8uZTc5iXrvADqB30 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-8uZTc5iXrvADqB30 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-8uZTc5iXrvADqB30 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-8uZTc5iXrvADqB30 .marker{fill:#333333;stroke:#333333;}#mermaid-svg-8uZTc5iXrvADqB30 .marker.cross{stroke:#333333;}#mermaid-svg-8uZTc5iXrvADqB30 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-8uZTc5iXrvADqB30 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-8uZTc5iXrvADqB30 .cluster-label text{fill:#333;}#mermaid-svg-8uZTc5iXrvADqB30 .cluster-label span{color:#333;}#mermaid-svg-8uZTc5iXrvADqB30 .label text,#mermaid-svg-8uZTc5iXrvADqB30 span{fill:#333;color:#333;}#mermaid-svg-8uZTc5iXrvADqB30 .node rect,#mermaid-svg-8uZTc5iXrvADqB30 .node circle,#mermaid-svg-8uZTc5iXrvADqB30 .node ellipse,#mermaid-svg-8uZTc5iXrvADqB30 .node polygon,#mermaid-svg-8uZTc5iXrvADqB30 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-8uZTc5iXrvADqB30 .node .label{text-align:center;}#mermaid-svg-8uZTc5iXrvADqB30 .node.clickable{cursor:pointer;}#mermaid-svg-8uZTc5iXrvADqB30 .arrowheadPath{fill:#333333;}#mermaid-svg-8uZTc5iXrvADqB30 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-8uZTc5iXrvADqB30 .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-8uZTc5iXrvADqB30 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-8uZTc5iXrvADqB30 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-8uZTc5iXrvADqB30 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-8uZTc5iXrvADqB30 .cluster text{fill:#333;}#mermaid-svg-8uZTc5iXrvADqB30 .cluster span{color:#333;}#mermaid-svg-8uZTc5iXrvADqB30 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-8uZTc5iXrvADqB30 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}
      </style>
      <g>
       <g class="output">
        <g class="clusters">
        </g>
        <g class="edgePaths">
         <g class="edgePath LS-A LE-B" id="L-A-B" style="opacity: 1;">
          <path class="path" d="M76,31L85.5,31C95,31,114,31,133,31C152,31,171,31,180.5,31L190,31" marker-end="url(#arrowhead74)" style="fill:none">
          </path>
          <defs>
           <marker id="arrowhead74" markerheight="6" markerunits="strokeWidth" markerwidth="8" orient="auto" refx="9" refy="5" viewbox="0 0 10 10">
            <path class="arrowheadPath" d="M 0 0 L 10 5 L 0 10 z" style="stroke-width: 1; stroke-dasharray: 1, 0;">
            </path>
           </marker>
          </defs>
         </g>
         <g class="edgePath LS-B LE-C" id="L-B-C" style="opacity: 1;">
          <path class="path" d="M242,31L251.5,31C261,31,280,31,299,31C318,31,337,31,346.5,31L356,31" marker-end="url(#arrowhead75)" style="fill:none">
          </path>
          <defs>
           <marker id="arrowhead75" markerheight="6" markerunits="strokeWidth" markerwidth="8" orient="auto" refx="9" refy="5" viewbox="0 0 10 10">
            <path class="arrowheadPath" d="M 0 0 L 10 5 L 0 10 z" style="stroke-width: 1; stroke-dasharray: 1, 0;">
            </path>
           </marker>
          </defs>
         </g>
        </g>
        <g class="edgeLabels">
         <g class="edgeLabel" style="opacity: 1;" transform="translate(133,31)">
          <g class="label" transform="translate(-32,-13)">
           <rect height="26" rx="0" ry="0" width="64">
           </rect>
           <foreignobject height="26" width="64">
            <div style="display: inline-block; white-space: nowrap;">
             <span class="edgeLabel L-LS-A' L-LE-B" id="L-L-A-B">
              写入数据
             </span>
            </div>
           </foreignobject>
          </g>
         </g>
         <g class="edgeLabel" style="opacity: 1;" transform="translate(299,31)">
          <g class="label" transform="translate(-32,-13)">
           <rect height="26" rx="0" ry="0" width="64">
           </rect>
           <foreignobject height="26" width="64">
            <div style="display: inline-block; white-space: nowrap;">
             <span class="edgeLabel L-LS-B' L-LE-C" id="L-L-B-C">
              读取数据
             </span>
            </div>
           </foreignobject>
          </g>
         </g>
        </g>
        <g class="nodes">
         <g class="node default" id="flowchart-A-36" style="opacity: 1;" transform="translate(42,31)">
          <rect class="label-container" height="46" rx="0" ry="0" width="68" x="-34" y="-23">
          </rect>
          <g class="label" transform="translate(0,0)">
           <g transform="translate(-24,-13)">
            <foreignobject height="26" width="48">
             <div style="display: inline-block; white-space: nowrap;">
              父进程
             </div>
            </foreignobject>
           </g>
          </g>
         </g>
         <g class="node default" id="flowchart-B-37" style="opacity: 1;" transform="translate(216,31)">
          <rect class="label-container" height="46" rx="0" ry="0" width="52" x="-26" y="-23">
          </rect>
          <g class="label" transform="translate(0,0)">
           <g transform="translate(-16,-13)">
            <foreignobject height="26" width="32">
             <div style="display: inline-block; white-space: nowrap;">
              管道
             </div>
            </foreignobject>
           </g>
          </g>
         </g>
         <g class="node default" id="flowchart-C-39" style="opacity: 1;" transform="translate(390,31)">
          <rect class="label-container" height="46" rx="0" ry="0" width="68" x="-34" y="-23">
          </rect>
          <g class="label" transform="translate(0,0)">
           <g transform="translate(-24,-13)">
            <foreignobject height="26" width="48">
             <div style="display: inline-block; white-space: nowrap;">
              子进程
             </div>
            </foreignobject>
           </g>
          </g>
         </g>
        </g>
       </g>
      </g>
     </svg>
    </div>
    <p>
     管道用于进程间的通信，特别是用于
     <strong>
      父子进程之间
     </strong>
     的简单数据传输。父进程创建管道，并通过管道的写端向管道写入数据；子进程从管道的读端读取数据。由于管道的特性，父子进程共享这对文件描述符，因此它们可以通过该管道进行通信。
    </p>
    <ol>
     <li>
      <strong>
       父进程创建管道
      </strong>
      ：父进程通过
      <code>
       pipe()
      </code>
      创建管道，得到一对文件描述符。
     </li>
     <li>
      <strong>
       创建子进程
      </strong>
      ：父进程调用
      <code>
       fork()
      </code>
      创建子进程，子进程会继承父进程的文件描述符。
     </li>
     <li>
      父子进程通信：
      <ul>
       <li>
        父进程通过写端写入数据到管道。
       </li>
       <li>
        子进程通过读端读取管道中的数据。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       关闭管道
      </strong>
      ：在数据传输完毕后，父子进程都应关闭管道的文件描述符，防止资源泄露。
     </li>
    </ol>
    <h2>
     <a id="_64">
     </a>
     匿名管道
    </h2>
    <p>
     <strong>
      匿名管道（Anonymous Pipe）
     </strong>
     是一种用于父子进程间进行通信的机制，它允许数据在两个进程之间传输，而无需显式的文件名或路径。匿名管道的特点是它没有名字，并且通常只能用于具有亲缘关系的进程（即父进程与子进程）
    </p>
    <h3>
     <a id="_68">
     </a>
     匿名管道的特性
    </h3>
    <ol>
     <li>
      具有血缘关系的进程可以进行匿名管道通信。
     </li>
     <li>
      管道只能进行单向通信。
     </li>
     <li>
      **父子进程会进行协同：**父进程和子进程之间的协同工作不仅可以在数据处理上进行配合，还可以在任务执行上互相协作。
     </li>
     <li>
      **管道是面向字节流的：**这意味着管道在传输数据时并不会关心数据的具体类型，而是以字节流的方式进行传输。
     </li>
     <li>
      管道是基于文件，文件基于进程的生命周期。
     </li>
    </ol>
    <h3>
     <a id="SysCall_76">
     </a>
     匿名管道的
     <code>
      SysCall
     </code>
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6c5806b8a0fb45d1a9adf1a92df9eba3.png"/>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="_85">
     </a>
     参数：
    </h4>
    <ul>
     <li>
      <strong>
       pipefd[2]
      </strong>
      ：一个整数数组，长度为 2。
      <code>
       pipefd[0]
      </code>
      用于读取数据（读端），
      <code>
       pipefd[1]
      </code>
      用于写入数据（写端）。
     </li>
    </ul>
    <h4>
     <a id="_89">
     </a>
     返回值：
    </h4>
    <ul>
     <li>
      <strong>
       成功
      </strong>
      ：返回
      <code>
       0
      </code>
      。
     </li>
     <li>
      <strong>
       失败
      </strong>
      ：返回
      <code>
       -1
      </code>
      ，并设置
      <code>
       errno
      </code>
      以指示错误原因。
     </li>
    </ul>
    <h4>
     <a id="_94">
     </a>
     功能：
    </h4>
    <p>
     <code>
      pipe()创建
     </code>
     一个管道并将两个文件描述符放入
     <code>
      pipefd
     </code>
     数组中：
    </p>
    <ul>
     <li>
      <code>
       pipefd[0]
      </code>
      是管道的读端，用于从管道中读取数据。
     </li>
     <li>
      <code>
       pipefd[1]
      </code>
      是管道的写端，用于向管道中写入数据。
     </li>
    </ul>
    <p>
     这些
     <code>
      文件描述符
     </code>
     可以用于与其他进程或线程进行数据通信。
    </p>
    <h3>
     <a id="_103">
     </a>
     匿名管道示例
    </h3>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cassert&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM</span> <span class="token expression"><span class="token number">2</span>  </span><span class="token comment">// 定义管道数组的大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">1024</span>  </span><span class="token comment">// 定义缓冲区大小</span></span>

<span class="token comment">// Reader函数：读取管道中的数据并打印出来</span>
<span class="token keyword">void</span> <span class="token function">Reader</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 缓冲区用于存储读取的数据</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        buffer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 清空缓冲区的第一个字节</span>

        <span class="token comment">// 从管道读取数据</span>
        ssize_t n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 添加字符串结束符</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"father say:["</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"PID : "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"]: "</span> <span class="token operator">&lt;&lt;</span> buffer <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 可以通过 sleep(1) 暂停 1 秒，避免 CPU 过度使用（目前注释掉）</span>
        <span class="token comment">//sleep(1);</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Writer函数：向管道中写数据</span>
<span class="token keyword">void</span> <span class="token function">Writer</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 缓冲区用于存储要写入的数据</span>
    std<span class="token double-colon punctuation">::</span>string msg <span class="token operator">=</span> <span class="token string">"hello I am child"</span><span class="token punctuation">;</span>  <span class="token comment">// 子进程发送的消息</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 用于编号消息</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        buffer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 清空缓冲区的第一个字节</span>
        <span class="token function">snprintf</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"child-PID: %d-%s-%d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 格式化消息</span>
        num<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 自增消息编号</span>

        <span class="token comment">// 写入管道</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每次写入后暂停 1 秒</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span>NUM<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 创建一个管道文件描述符数组</span>

    <span class="token comment">// 创建管道</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 如果创建管道失败，返回 -1</span>

    <span class="token comment">// 创建子进程</span>
    pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 如果创建子进程失败，返回 -2</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 子进程部分</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 关闭读端，因为子进程只需要写入数据</span>

        <span class="token comment">// 调用 Writer 函数向管道中写数据</span>
        <span class="token function">Writer</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 子进程结束</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 父进程部分</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 关闭写端，因为父进程只需要读取数据</span>

    <span class="token comment">// 调用 Reader 函数从管道中读取数据</span>
    <span class="token function">Reader</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 等待子进程结束</span>
    pid_t ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"success return"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 子进程正常退出</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_197">
     </a>
     代码流程：
    </h4>
    <ol>
     <li>
      <strong>
       创建管道
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         pipe()
        </code>
        创建一个管道，并通过
        <code>
         pipefd[0]
        </code>
        和
        <code>
         pipefd[1]
        </code>
        分别访问读端和写端。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       创建子进程
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         fork()
        </code>
        创建子进程。
       </li>
       <li>
        在子进程中，关闭管道的读端，调用
        <code>
         Writer()
        </code>
        函数向管道写数据。
       </li>
       <li>
        在父进程中，关闭管道的写端，调用
        <code>
         Reader()
        </code>
        函数从管道读取数据。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       管道通信
      </strong>
      ：
      <ul>
       <li>
        子进程通过写端 (
        <code>
         pipefd[1]
        </code>
        ) 向管道写数据。
       </li>
       <li>
        父进程通过读端 (
        <code>
         pipefd[0]
        </code>
        ) 从管道读取数据并打印。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       进程同步
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         waitpid()
        </code>
        等待子进程的结束。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_211">
     </a>
     主要功能：
    </h4>
    <ul>
     <li>
      <strong>
       父子进程的管道通信
      </strong>
      ：父进程读取子进程写入管道的数据并输出。
     </li>
     <li>
      <strong>
       无限循环的读写操作
      </strong>
      ：子进程不断向管道写入数据，而父进程不断从管道读取数据。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/cc2c96577c6e452ebc79bb2d3c3f600c.png"/>
    </p>
    <h3>
     <a id="4_219">
     </a>
     管道的4种情况（用代码自己验证）
    </h3>
    <ol>
     <li>
      读端正常，写端关闭：读端会挂起阻塞。
     </li>
     <li>
      读端正常，写端写满：写端会阻塞。
     </li>
     <li>
      读端正常，写端关闭：读端就会读到0（表示读到了尽头）
     </li>
     <li>
      写端正常，读端关闭：OS会通过操作系统杀掉写端。（13号信号：管道信号）；
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ad9781eea8a944ffb1d490916e4a5c88.png"/>
    </p>
    <h2>
     <a id="_229">
     </a>
     命名管道
    </h2>
    <p>
     Linux 中的命名管道（Named Pipe，通常称为 FIFO）是一种特殊类型的文件，它用于在不同进程之间进行数据交换。它与匿名管道（Anonymous Pipe）相比，具有一些独特的特性。
    </p>
    <h3>
     <a id="_233">
     </a>
     命名管道的特性
    </h3>
    <ul>
     <li>
      <strong>
       跨进程通信
      </strong>
      ：命名管道不仅限于父子进程之间的通信，它可以用于任何两个在系统中运行的进程之间，甚至是属于不同用户的进程。
     </li>
     <li>
      <strong>
       阻塞行为
      </strong>
      ：(这一点类似于匿名管道)
      <ol>
       <li>
        写操作阻塞：如果管道的缓冲区已满，写入数据的进程会被阻塞，直到有进程从管道中读取数据释放出空间。
       </li>
       <li>
        读操作阻塞：如果管道为空，读取数据的进程会被阻塞，直到有进程写入数据。
       </li>
      </ol>
     </li>
    </ul>
    <h3>
     <a id="_240">
     </a>
     命名管道的创建和销毁
    </h3>
    <h4>
     <a id="_242">
     </a>
     创建
    </h4>
    <h5>
     <a id="bash_244">
     </a>
     bash下
    </h5>
    <pre><code class="prism language-bash"><span class="token function">mkfifo</span> name
</code></pre>
    <ul>
     <li>
      <code>
       p
      </code>
      开头的是管道文件。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4ac8bc577b1747549e4e473c5bf5f9c9.png"/>
    </p>
    <h5>
     <a id="C_255">
     </a>
     C++代码中
    </h5>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <p>
       <code>
        pathname
       </code>
       ：指定要创建的FIFO文件的路径。
      </p>
     </li>
     <li>
      <p>
       <code>
        mode
       </code>
       ：设置FIFO文件的权限，通常使用标准的文件权限值（例如
       <code>
        0664
       </code>
       ）。
      </p>
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/00366e58c7c8478b8113361d2f747560.png"/>
    </p>
    <h4>
     <a id="_268">
     </a>
     销毁
    </h4>
    <h5>
     <a id="bash_270">
     </a>
     bash
    </h5>
    <pre><code class="prism language-bash">unlink name
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a413117def4d478db80a002a5f1059d3.png"/>
    </p>
    <p>
     C++代码下
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <code>
       pathname
      </code>
      ：要删除的文件路径。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/627ecae4b9584c399c26221cea29f06b.png"/>
    </p>
    <h3>
     <a id="_290">
     </a>
     命名管道的示例
    </h3>
    <ul>
     <li>
      提供
      <code>
       server
      </code>
      端进行读取管道。
     </li>
     <li>
      提供
      <code>
       client
      </code>
      端进行写入管道。
     </li>
    </ul>
    <h4>
     <a id="server_295">
     </a>
     <code>
      server
     </code>
     端
    </h4>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"piped.hpp"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建命名管道（FIFO文件），进行进程间通信</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span>FIFO_FILE<span class="token punctuation">,</span> MODE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 mkfifo 系统调用创建命名管道，FIFO_FILE 为管道文件路径，MODE 为权限模式</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mkfifo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果创建管道失败，打印错误信息</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>FIFO_CREAT_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 退出程序并返回自定义的错误码 FIFO_CREAT_ERR</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 打开命名管道，进行读取操作</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO_FILE<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 open 系统调用打开管道文件进行只读操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> FIFO_OPEN_ERR<span class="token punctuation">;</span>  <span class="token comment">// 如果打开管道失败，返回自定义的错误码 FIFO_OPEN_ERR</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 不断读取管道中的数据</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 创建一个字符数组 buffer 来存放从管道读取的数据</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 read 系统调用从管道读取数据，读取的最大字节数为 buffer 的大小</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果读取数据失败，打印错误信息</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>FIFO_READ_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 退出程序并返回自定义的错误码 FIFO_READ_ERR</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 确保读取的数据是以 null 字符 '\0' 结束的，以方便处理为字符串</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"PID :"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" client said # "</span> <span class="token operator">&lt;&lt;</span> buffer <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 打印读取的数据以及进程的 PID</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 如果没有数据可读，退出循环</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 关闭管道文件描述符</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 程序正常结束</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_338">
     </a>
     代码解释
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        创建命名管道：
       </strong>
       <br/>
       使用
       <code>
        mkfifo()
       </code>
       创建一个命名管道，该管道的路径为
       <code>
        FIFO_FILE
       </code>
       ，其权限由
       <code>
        MODE
       </code>
       定义。如果创建失败，则通过
       <code>
        perror()
       </code>
       输出错误信息并退出。
      </p>
     </li>
     <li>
      <p>
       <strong>
        打开命名管道：
       </strong>
       <br/>
       使用
       <code>
        open()
       </code>
       打开刚刚创建的命名管道文件，使用只读模式 (
       <code>
        O_RDONLY
       </code>
       )。如果管道打开失败，则退出并返回错误码。
      </p>
     </li>
     <li>
      <p>
       <strong>
        读取数据：
       </strong>
       <br/>
       程序通过
       <code>
        read()
       </code>
       从管道中读取数据，每次读取的数据存放到
       <code>
        buffer
       </code>
       中，并且确保数据以 null 字符结束。读取到的数据会被打印出来，显示发送数据的客户端信息。
      </p>
     </li>
     <li>
      <p>
       <strong>
        处理管道读取：
       </strong>
       <br/>
       如果读取操作成功且有数据，程序会打印客户端的消息。如果读取操作返回
       <code>
        0
       </code>
       （表示管道关闭），则退出循环。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关闭文件描述符：
       </strong>
       <br/>
       当管道的数据读取完毕后，程序会通过
       <code>
        close()
       </code>
       关闭管道文件描述符。
      </p>
     </li>
    </ol>
    <h4>
     <a id="cilent_355">
     </a>
     <code>
      cilent
     </code>
     端
    </h4>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"piped.hpp"</span>  </span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 打开命名管道文件（FIFO），以写模式打开</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO_FILE<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 open 系统调用以写模式打开管道文件 FIFO_FILE</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果打开失败，打印错误信息</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>FIFO_OPEN_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 退出程序并返回自定义的错误码 FIFO_OPEN_ERR</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"client open file done"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 输出确认消息，表示管道文件已成功打开</span>
    
    <span class="token comment">// 不断读取用户输入并将其写入管道</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>  <span class="token comment">// 定义一个字符串来存储用户输入</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please Enter@"</span><span class="token punctuation">;</span>  <span class="token comment">// 提示用户输入</span>
        <span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从标准输入读取一行数据并存储到 str 中</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 打印用户输入的内容</span>
        
        <span class="token comment">// 将输入的字符串写入管道</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 write 系统调用将输入字符串写入管道</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果写入失败，打印错误信息</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>FIFO_WRITE_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 退出程序并返回自定义的错误码 FIFO_WRITE_ERR</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 关闭管道文件描述符</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 程序正常结束</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_391">
     </a>
     代码解释：
    </h5>
    <ol>
     <li>
      <strong>
       打开管道文件：
      </strong>
      <ul>
       <li>
        使用
        <code>
         open()
        </code>
        函数以写模式（
        <code>
         O_WRONLY
        </code>
        ）打开命名管道文件
        <code>
         FIFO_FILE
        </code>
        。如果管道文件打开失败，程序会打印错误信息并退出。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       用户输入并写入管道：
      </strong>
      <ul>
       <li>
        程序通过
        <code>
         std::getline(std::cin, str)
        </code>
        获取用户的输入，并将其存储在
        <code>
         str
        </code>
        变量中。
       </li>
       <li>
        输入的字符串会被通过
        <code>
         write()
        </code>
        系统调用写入管道，写入的数据是通过
        <code>
         str.c_str()
        </code>
        获取的字符串指针，
        <code>
         str.size()
        </code>
        获取的字符串大小。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       错误处理：
      </strong>
      <ul>
       <li>
        如果
        <code>
         write()
        </code>
        函数返回错误（即返回
        <code>
         -1
        </code>
        ），程序会打印出错误信息，并退出，返回错误码
        <code>
         FIFO_WRITE_ERR
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       关闭管道文件：
      </strong>
      <ul>
       <li>
        在写入完成后，程序会通过
        <code>
         close()
        </code>
        关闭管道文件描述符。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="hpp_403">
     </a>
     头文件包含以及宏定义
     <code>
      hpp
     </code>
    </h4>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_FILE</span> <span class="token string">"./mypiped"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MODE</span> <span class="token expression"><span class="token number">0664</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">enum</span> 
<span class="token punctuation">{<!-- --></span>
    FIFO_CREAT_ERR <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">,</span>
    FIFO_OPEN_ERR      <span class="token punctuation">,</span>
    FIFO_READ_ERR      <span class="token punctuation">,</span>
    FIFO_WRITE_ERR
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     管道文件描述符。
    </p>
    <h4>
     <a id="hpp_432">
     </a>
     头文件包含以及宏定义
     <code>
      hpp
     </code>
    </h4>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_FILE</span> <span class="token string">"./mypiped"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MODE</span> <span class="token expression"><span class="token number">0664</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">enum</span> 
<span class="token punctuation">{<!-- --></span>
    FIFO_CREAT_ERR <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">,</span>
    FIFO_OPEN_ERR      <span class="token punctuation">,</span>
    FIFO_READ_ERR      <span class="token punctuation">,</span>
    FIFO_WRITE_ERR
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f4361797979792f:61727469636c652f64657461696c732f313436313935323333" class_="artid" style="display:none">
 </p>
</div>


