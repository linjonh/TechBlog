---
layout: post
title: "蓝桥杯学习笔记08-回溯"
date: 2025-03-13 20:08:30 +0800
description: "c++中的queue数据结构q.empty()判断队列是否为空q.front()访问队头元素q.pop()删除队头元素q.push(1)添加元素。"
keywords: "蓝桥杯学习笔记08-回溯"
categories: ['未分类']
tags: ['蓝桥杯', '笔记', '学习']
artid: "146137680"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146137680
    alt: "蓝桥杯学习笔记08-回溯"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146137680
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146137680
cover: https://bing.ee123.net/img/rand?artid=146137680
image: https://bing.ee123.net/img/rand?artid=146137680
img: https://bing.ee123.net/img/rand?artid=146137680
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥杯学习笔记08-回溯
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     c++中的queue数据结构
    </p>
    <p>
     q.empty()判断队列是否为空
    </p>
    <p>
     q.front()访问队头元素
    </p>
    <p>
     q.pop()删除队头元素
    </p>
    <p>
     q.push(1)添加元素
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        if(root == nullptr) return {};

        q.push(root);
        while(!q.empty()){
            vector&lt;int&gt; tem;
            int size = q.size();
            for(int i=0;i&lt;size;i++){
                TreeNode* head = q.front(); //访问队头元素
                tem.push_back(head-&gt;val);
                q.pop();    //删除队头元素
                if(head-&gt;left!=nullptr) q.push(head-&gt;left);
                if(head-&gt;right != nullptr) q.push(head-&gt;right);
            }
            res.push_back(tem);
        }
        return res;
    }
};</code></pre>
    <p>
    </p>
    <h2>
     回溯篇
    </h2>
    <p>
     <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/" rel="nofollow" title="17. 电话号码的字母组合 - 力扣（LeetCode）">
      17. 电话号码的字母组合 - 力扣（LeetCode）
     </a>
    </p>
    <p>
    </p>
    <h3>
     匹配相关的题目
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/" rel="nofollow" title="2850. 将石头分散到网格图的最少移动次数 - 力扣（LeetCode）">
      2850. 将石头分散到网格图的最少移动次数 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     <img alt="" height="577" src="https://i-blog.csdnimg.cn/direct/3429ba03aa314226a42006c56bc70c64.png" width="1106"/>
    </p>
    <p>
     vector里面可以嵌pair，然后是用emplace_back插入
    </p>
    <pre><code class="language-cpp">vector&lt;pair&lt;int,int&gt;&gt; from,to;

    int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        for(int i=0;i&lt;grid.size();i++){
            for(int j=0;j&lt;grid[i].size();j++){
                if(grid[i][j]){
                    for(int k=1;k&lt;grid[j][j]){
                        from.emplace_back(i,j);
                    }
                }else{
                    to.emplace_back(i,j);
                }
            }
        }    
    }</code></pre>
    <p>
    </p>
    <p>
     <a href="https://leetcode.cn/problems/maximum-compatibility-score-sum/submissions/610168728/" rel="nofollow" title="1947. 最大兼容性评分和 - 力扣（LeetCode）">
      1947. 最大兼容性评分和 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     next_permutation的使用，不能对二维数组
    </p>
    <h4>
     1.
     <strong>
      <code>
       next_permutation
      </code>
      的使用问题
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <code>
        next_permutation
       </code>
       函数的作用是生成下一个字典序更大的排列。在你的代码中，
       <code>
        students
       </code>
       是一个二维数组，
       <code>
        next_permutation
       </code>
       不能直接对二维数组进行操作。
      </p>
     </li>
     <li>
      <p>
       如果你想通过排列来尝试所有可能的组合，可以尝试对
       <code>
        mentors
       </code>
       的索引进行排列，而不是直接对
       <code>
        students
       </code>
       进行排列。
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    int ans = 0;
    int maxCompatibilitySum(vector&lt;vector&lt;int&gt;&gt;&amp; students, vector&lt;vector&lt;int&gt;&gt;&amp; mentors) {
        int len = students.size();
        //初始化导师的索引数组
        vector&lt;int&gt; Index;
        for(int i=0;i&lt;len;i++){
            Index.push_back(i);
        }
        do{
            int total = 0;
            for(int i=0;i&lt;len;i++){
                for(int j=0;j&lt;students[i].size();j++){
                    if((students[i][j] == mentors[Index[i]][j])){
                        total += 1;
                    }
                }
            }
            ans = max(ans,total);
        }while(next_permutation(Index.begin(),Index.end()));
        
        return ans;
    }
};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333232313032302f:61727469636c652f64657461696c732f313436313337363830" class_="artid" style="display:none">
 </p>
</div>


