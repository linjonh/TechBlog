---
layout: post
title: "C语言实现队列数据结构思路与代码详解"
date: 2025-03-12 20:25:46 +0800
description: "c_CRT_SECURE_NO_WARNINGS 宏定义用于关闭Visual Studio中一些函数的安全警告。后面依次包含了标准输入输出库、标准库、布尔类型库和断言库，为后续代码提供必要的功能支持。c}QNode;int size;}Queue;-  QDatatype  定义为  int  类型，表示队列中存储的数据类型，这里是整型，也可以根据实际需求改为其他类型。"
keywords: "C语言实现队列数据结构：思路与代码详解"
categories: ['数据结构', 'C']
tags: ['数据结构', '开发语言', 'C']
artid: "146213703"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146213703
    alt: "C语言实现队列数据结构思路与代码详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146213703
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146213703
cover: https://bing.ee123.net/img/rand?artid=146213703
image: https://bing.ee123.net/img/rand?artid=146213703
img: https://bing.ee123.net/img/rand?artid=146213703
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言实现队列数据结构：思路与代码详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
     <span style="color:#ff9900">
      <strong>
       作者主页：
      </strong>
     </span>
     <a href="https://blog.csdn.net/nplplus?spm=1011.2266.3001.5343" title="共享家9527-CSDN博客">
      共享家9527-CSDN博客
     </a>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/500064b7bfe7444f86ca14685c94195c.jpeg"/>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80%C2%A0" name="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80%C2%A0">
     一、引言
     <br/>
    </h2>
    <blockquote>
     <p>
      <br/>
      <span style="color:#fe2c24">
       <strong>
        <span style="background-color:#edf6e8">
         队列
        </span>
       </strong>
      </span>
      <span style="background-color:#edf6e8">
       是一种重要的
      </span>
      <u>
       <span style="background-color:#edf6e8">
        数据结构
       </span>
      </u>
      <span style="background-color:#edf6e8">
       ，遵循
      </span>
      <span style="color:#be191c">
       <strong>
        <span style="background-color:#edf6e8">
         先进先出
        </span>
       </strong>
      </span>
      <span style="background-color:#edf6e8">
       （FIFO）的原则。在C语言中，我们可以通过自定义结构体和一系列操作函数来实现一个队列。
      </span>
      <u>
       <span style="background-color:#edf6e8">
        本文将详细介绍如何实现一个简单的队列，并对代码的各个部分进行深入分析。
       </span>
      </u>
      <br/>
     </p>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%C2%A0" name="%E4%BA%8C%E3%80%81%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%C2%A0">
     <br/>
     二、整体思路
     <br/>
    </h2>
    <p>
     <br/>
     队列的实现主要涉及队列节点的定义、队列结构体的定义以及对队列的各种操作，如初始化、入队、出队、获取队头和队尾元素、判断队列是否为空和获取队列大小等。我们将这些操作模块化，每个函数负责一个特定的功能，使得代码结构清晰，易于维护和扩展。
     <br/>
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%C2%A0" name="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%C2%A0">
     <br/>
     三、代码模块分析
     <br/>
    </h2>
    <h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89%C2%A0" name="%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89%C2%A0">
     <br/>
     （一）头文件包含与宏定义
     <br/>
    </h3>
    <pre><code class="language-cpp">
c
  
#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
 </code></pre>
    <p>
     <br/>
     <br/>
     <span style="color:#1c7331">
      _CRT_SECURE_NO_WARNINGS
     </span>
     宏定义用于
     <strong>
      <span style="color:#fe2c24">
       关闭Visual Studio中一些函数的安全警告。
      </span>
     </strong>
     后面依次包含了标准输入输出库、标准库、布尔类型库和断言库，为后续代码
     <u>
      提供必要的功能支持。
     </u>
     <br/>
    </p>
    <h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%C2%A0" name="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%C2%A0">
     <br/>
     （二）数据类型定义
     <br/>
    </h3>
    <pre><code class="language-cpp">
c
  
typedef int QDatatype;
typedef struct QueueNode
{
    struct QueueNode* next;
    QDatatype data;
}QNode;

typedef struct Queue
{
    QNode* head;
    QNode* tail;
    int size;
}Queue;
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      -  QDatatype
     </strong>
     定义为  int  类型，表示队列中存储的数据类型，这里是整型，
     <span style="color:#fe2c24">
      <strong>
       也可以根据实际需求改为其他类型。
      </strong>
     </span>
     <br/>
     <br/>
     <strong>
      -  QueueNode  结构体
     </strong>
     定义了队列节点，包含一个指向下一个节点的指针  next  和存储数据的  data  成员。
     <br/>
     <br/>
     <span style="color:#be191c">
      <strong>
       -  Queue  结构体表示整个队列，包含指向队头的指针  head 、指向队尾的指针  tail  和记录队列元素个数的  size 。
      </strong>
     </span>
     <br/>
    </p>
    <h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%C2%A0" name="%EF%BC%88%E4%B8%89%EF%BC%89%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%C2%A0">
     <br/>
     （三）队列操作函数
     <br/>
    </h3>
    <h4 id="1.%20%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" name="1.%20%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">
     <br/>
     <span style="color:#511b78">
      1. 队列初始化
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
void QueueInit(Queue* pq)
{
    pq-&gt;head = pq-&gt;tail = NULL;
    pq-&gt;size = 0;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      QueueInit  函数
     </strong>
     用于
     <span style="color:#fe2c24">
      <strong>
       初始化一个队列
      </strong>
     </span>
     ，将队头和队尾指针设为  NULL ，队列大小设为  0 。
     <br/>
    </p>
    <h4 id="2.%20%E9%98%9F%E5%88%97%E9%94%80%E6%AF%81%C2%A0" name="2.%20%E9%98%9F%E5%88%97%E9%94%80%E6%AF%81%C2%A0">
     <br/>
     <span style="color:#511b78">
      2. 队列销毁
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
void QueueDestroy(Queue* pq)
{
    assert(pq);
    Queue* cur = pq-&gt;head;
    while (cur)
    {
        pq-&gt;head = pq-&gt;head-&gt;next;
        free(cur);
        cur = pq-&gt;head;
    }
    pq-&gt;head = pq-&gt;tail = NULL;
    pq-&gt;size = 0;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      QueueDestroy  函数
     </strong>
     用于释放队列占用的内存空间。
     <u>
      通过遍历队列，逐个释放每个节点，最后将队头、队尾指针设为  NULL ，队列大小设为  0 。
     </u>
     <br/>
    </p>
    <h4 id="3.%20%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%C2%A0" name="3.%20%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%C2%A0">
     <br/>
     <span style="color:#511b78">
      3. 入队操作
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
void QueuePush(Queue* pq, QDatatype x)
{
    QNode* newnode = (QNode*)malloc(sizeof(QNode));
    if (newnode == NULL)
    {
        perror("malloc fail");
        return;
    }
    newnode-&gt;data = x;
    newnode-&gt;next = NULL;

    if (pq-&gt;head == NULL)
    {
        pq-&gt;head = pq-&gt;tail = newnode;
    }
    else
    {
        pq-&gt;tail-&gt;next = newnode;
        pq-&gt;tail = newnode;
    }
    pq-&gt;size++;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      QueuePush  函数
     </strong>
     用于将一个元素入队。首先
     <strong>
      <span style="color:#fe2c24">
       分配一个新节点的内存空间
      </span>
     </strong>
     ，若分配失败则打印错误信息并返回。然后将新节点的数据设为传入的元素值， next  指针设为  NULL 。如果队列为空，则新节点既是队头也是队尾；否则将新节点连接到队尾，并更新队尾指针。最后队列大小加  1 。
     <br/>
    </p>
    <h4 id="4.%20%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%C2%A0" name="4.%20%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%C2%A0">
     <br/>
     <span style="color:#511b78">
      4. 出队操作
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
void QueuePop(Queue* pq)
{
    assert(pq);
    assert(pq-&gt;head != NULL);

    if (pq-&gt;head-&gt;next == NULL)
    {
        free(pq-&gt;head);
        pq-&gt;head = pq-&gt;tail = NULL;
    }
    else
    {
        QNode* next = pq-&gt;head-&gt;next;
        free(pq-&gt;head);
        pq-&gt;head = next;
    }
    pq-&gt;size--;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      QueuePop  函数
     </strong>
     <u>
      用于将队头元素出队
     </u>
     。首先进行
     <strong>
      <span style="color:#fe2c24">
       断言，确保队列指针有效且队列不为空
      </span>
     </strong>
     。
     <u>
      如果队列只有一个元素，释放队头节点并将队头、队尾指针设为  NULL ；否则保存队头节点的下一个节点，释放队头节点，然后将队头指针指向下一个节点。最后队列大小减  1 。
     </u>
     <br/>
    </p>
    <h4 id="5.%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%C2%A0" name="5.%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0%C2%A0">
     <br/>
     <span style="color:#511b78">
      5. 获取队头元素
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
QDatatype QueueFront(Queue* pq)
{
    assert(pq);
    assert(!QueueEmpty(pq));
    return pq-&gt;head-&gt;data;
}</code></pre>
    <p>
     <br/>
     <br/>
     <br/>
     <strong>
      QueueFront  函数
     </strong>
     用于获取队头元素的值。先进行断言确保队列有效且不为空，然后返回队头节点的数据。
     <br/>
    </p>
    <h4 id="6.%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%C2%A0" name="6.%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%C2%A0">
     <br/>
     <span style="color:#511b78">
      6. 获取队尾元素
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
QDatatype QueueBack(Queue* pq)
{
    assert(pq);
    assert(!QueueEmpty(pq));
    return pq-&gt;tail-&gt;data;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      QueueBack  函数
     </strong>
     用于获取队尾元素的值。同样先进行断言确保队列有效且不为空，然后返回队尾节点的数据。
     <br/>
    </p>
    <h4 id="7.%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F%C2%A0" name="7.%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F%C2%A0">
     <br/>
     <span style="color:#511b78">
      7. 获取队列大小
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
int QueueSize(Queue* pq)
{
    return pq-&gt;size;
}
 
 
 QueueSize  函数直接返回队列结构体中记录的元素个数。
 </code></pre>
    <h4 id="8.%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%C2%A0" name="8.%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%C2%A0">
     <br/>
     <span style="color:#511b78">
      8. 判断队列是否为空
     </span>
     <br/>
    </h4>
    <pre><code class="language-cpp">
c
  
bool QueueEmpty(Queue* pq)
{
    assert(pq);
    return pq-&gt;head == NULL;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      QueueEmpty  函数
     </strong>
     通过判断队头指针是否为  NULL  来确定队列是否为空，为空则返回  true ，否则返回  false 。
     <br/>
    </p>
    <h3 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95%C2%A0" name="%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95%C2%A0">
     <br/>
     （四）主函数测试
     <br/>
    </h3>
    <pre><code class="language-cpp">
c
  
int main()
{
    Queue Q;
    QueueInit(&amp;Q);
    QueuePush(&amp;Q, 1);
    QueuePush(&amp;Q, 2);
    QueuePush(&amp;Q, 3);
    QueuePush(&amp;Q, 4);
    QueuePush(&amp;Q, 5);
    while (!QueueEmpty(&amp;Q))
    {
        printf("%d ", QueueFront(&amp;Q));
        QueuePop(&amp;Q);
    }
    printf("\n");
    QueueDestroy(&amp;Q);
    return 0;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     在
     <strong>
      main  函数
     </strong>
     中，我们对实现的队列进行了测试。首先初始化一个队列，然后依次将  1  到  5  这五个元素入队，接着通过循环不断获取队头元素并打印，同时将其出队，直到队列为空。最后销毁队列，释放内存。
     <br/>
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%C2%A0" name="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%C2%A0" style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f0ad843d7610421dadcf24704806b58b.jpeg">
      <br/>
      四、总结
      <br/>
     </img>
    </h2>
    <blockquote>
     <p>
      <br/>
      <span style="background-color:#edf6e8">
       通过以上模块化的代码实现，我们完成了一个基本的
       <span style="color:#fe2c24">
        队列数据结构
       </span>
       。每个函数都有明确的功能，使得代码逻辑清晰，易于理解和维护。在实际应用中，可以根据具体需求对队列进行进一步的扩展和优化，如添加更多的操作函数或者改变数据存储类型等。
      </span>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6e706c706c75732f:61727469636c652f64657461696c732f313436323133373033" class_="artid" style="display:none">
 </p>
</div>


