---
layout: post
title: "RabittMQ保证消息不丢失的几种手段"
date: 2025-03-07 22:14:47 +0800
description: "注意：消费者ACK的时机要注意一下，因为RabbitMQ投递消息给消费者，消费者获取消息后，如果立即ACK给RabbitMQ，此时RabbbitMQ删除消息，如果消费者在消费过程中宕机了，消息还未处理完成，这样，消息就丢失了，因此消费者返回ACK的时机非常重要。此方式类似事务机制，出现异常时返回NACK，消息回滚到MQ，没有异常，返回ACK。开启消费确认机制后，如果消费者出现异常，无法ACK，消费会不断requeue（重入列）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环。"
keywords: "RabittMQ保证消息不丢失的几种手段"
categories: ['消息中间件Mq学习记录']
tags: ['Rabbitmq']
artid: "145774992"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145774992
    alt: "RabittMQ保证消息不丢失的几种手段"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145774992
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145774992
cover: https://bing.ee123.net/img/rand?artid=145774992
image: https://bing.ee123.net/img/rand?artid=145774992
img: https://bing.ee123.net/img/rand?artid=145774992
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabittMQ保证消息不丢失的几种手段
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="1RabbitMQ_1">
     </a>
     1、RabbitMQ消息丢失的三种情况
    </h3>
    <p>
     消息从生产者（publisher）发送，到消费者（consumer）接收消费，会经历多个过程，其中每一个过程都可能导致MQ消息的丢失，常见的丢失消息的情况有三种
    </p>
    <p>
     第一种：发送时丢失（publisher）。
    </p>
    <ul>
     <li>
      即生产者将消息发送到Exchange的过程中丢失，例如在发送过程中因为网络原因发送失败或者是因为发送到了一个不存在的Exchange。
     </li>
    </ul>
    <p>
     第二种：路由失败（Exchange）。
    </p>
    <ul>
     <li>
      即消息已经发送到Exchange了，但是Exchange将消息根据RoutingKey路由到对应的Queue时失败，例如这个RoutingKey根本就没有绑定Queue，MQ服务宕机等。
     </li>
    </ul>
    <p>
     第三种：消费者在处理消息时失败（Consumer）。
    </p>
    <ul>
     <li>
      即消费者已经获取了消息，但是在处理消息过程中出现了异常，例如消费者在消费过程中重启，或者消费中在消费过程中出现异常等。
     </li>
    </ul>
    <h3>
     <a id="2RabbitMQ_13">
     </a>
     2、RabbitMQ解决消息丢失解决方案
    </h3>
    <h4>
     <a id="_14">
     </a>
     消息确认机制
    </h4>
    <p>
     指的是在消息传递过程中，发送方发送消息后，接收方需要对消息进行确认，以确保消息被正确地接收和处理，RabbitMQ的消息确认机制分为两种：
    </p>
    <ul>
     <li>
      <p>
       生产者确认机制：是Exchange 给生产者的一种反馈机制，让生产者知道消息是否成功发送到了Exchange，确保消息从生产者到Exchange的可靠性传输。如果生成着从未收到确认，可认为消息发送失败，可以重发消息保证消息不会丢失。
      </p>
     </li>
     <li>
      <p>
       消费者确认机制：是消费者给Exchange的一个反馈，告知Exchange消息已被正确接收和处理，确保消息从Exchange到消费着的可靠性传输。如果Exchange收到消费着确认后，才会从消息对列中删除消息，否则认为消息未被正确处理，将重新投递确保消息不会丢失。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_21">
     </a>
     持久化
    </h4>
    <p>
     RabbitMQ的持久化机制是一种确保数据在RabbitMQ服务重启或异常情况下不会丢失的重要特性，主要包括以下三个方面：交换器的持久化、队列的持久化、消息的持久化。
    </p>
    <ul>
     <li>
      <p>
       交换器的持久化：可以保证在RabbitMQ服务器重启后交换器依然存在。在声明交换器时将 durable 参数设置为 true，即可使其持久化。
      </p>
     </li>
     <li>
      <p>
       队列持久化：可以保证RabitMQ服务器重启后队列依然存在。在声明队列时将 durable 参数设为 true，即使其持久化 。
      </p>
     </li>
     <li>
      <p>
       息本身持久化：可以保证RabitMQ服务重启后消息不会丢失，在发布消息时设置 delivery_mode 属性为 2。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_30">
     </a>
     失败重试机制
    </h4>
    <p>
     开启消费确认机制后，如果消费者出现异常，无法ACK，消费会不断requeue（重入列）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环。
    </p>
    <ul>
     <li>
      好处：避免消息丢失
     </li>
     <li>
      坏处：导致mq的消息处理飙升，带来不必要的压力。
     </li>
    </ul>
    <h3>
     <a id="3_34">
     </a>
     3、生产者消息确认
    </h3>
    <p>
     RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失，消息发送到MQ之后，会返回一个结果给发送者，表示消息是否处理成功，返回结果的方式有两种：
    </p>
    <ul>
     <li>
      pulisher-confirm（发送者确认）
     </li>
     <li>
      publisher-return（发送者回执）
     </li>
    </ul>
    <p>
     注意：确认机制发送消息时，必须给每个消息设置一个全局唯一ID，以区分ACK冲突。
    </p>
    <h4>
     <a id="pulisherconfirm_40">
     </a>
     pulisher-confirm
    </h4>
    <p>
     pulisher-confirm（发送者确认 ConfirmCallback）：
    </p>
    <ul>
     <li>
      ConfirmCallback是一个回调函数，用于在消息被确认时进行回调，以确保消息已经被正确地发送到RabbitMQ Broker并被处理。
     </li>
     <li>
      消息成功投递到交换机，返回ACK
     </li>
     <li>
      消息未投递到交换机，返回NACK
     </li>
    </ul>
    <p>
     开启方式：在spring项目中添加配置
    </p>
    <pre><code class="prism language-yaml"><span class="token comment"># 开启publisher-confirm, 这里支持两种类型</span>
<span class="token comment"># 1.simple:同步等待confirm结果，直到超时</span>
<span class="token comment"># 2.correlated:异步回调, 定义ConfirmCallback, MQ返回结果时会回调这个ConfirmCallBack</span>
spring.rabbitmq.publisher<span class="token punctuation">-</span>confirm<span class="token punctuation">-</span>type=correlated
</code></pre>
    <p>
     ConfirmCallback 示例代码：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testConfirmCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1.消息体</span>
    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.全局唯一的消息ID，需要封装到CorrelationData中</span>
    <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.添加callback</span>
    correlationData<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>
            result <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
              <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 3.1.ack，消息成功</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送成功, ID: "</span> <span class="token operator">+</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 3.2.nack，消息失败</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送失败, ID: "</span> <span class="token operator">+</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 原因: "</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">getReason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            ex <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送异常, ID: "</span> <span class="token operator">+</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 原因: "</span> <span class="token operator">+</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.发送消息</span>
    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"exchangeName"</span><span class="token punctuation">,</span> <span class="token string">"routingKey"</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
    <p>
     运行结果分析：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// 消息投递成功打印结果</span>
消息发送成功<span class="token punctuation">,</span> <span class="token constant">ID</span><span class="token operator">:</span> <span class="token number">4438</span>bf85<span class="token operator">-</span><span class="token number">450</span>b<span class="token operator">-</span><span class="token number">4</span>b50<span class="token operator">-</span>b3c8<span class="token operator">-</span>f59a590cfd03

<span class="token comment">// 消息投递失败的打印结果</span>
消息发送失败<span class="token punctuation">,</span> <span class="token constant">ID</span><span class="token operator">:</span> dd010760<span class="token operator">-</span>a255<span class="token operator">-</span><span class="token number">4131</span><span class="token operator">-</span>a978<span class="token operator">-</span><span class="token number">6f</span>cc1a17f38a 原因<span class="token operator">:</span> channel error<span class="token punctuation">;</span> protocol method<span class="token operator">:</span> #method<span class="token generics"><span class="token punctuation">&lt;</span>channel<span class="token punctuation">.</span>close<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>reply<span class="token operator">-</span>code<span class="token operator">=</span><span class="token number">404</span><span class="token punctuation">,</span> reply<span class="token operator">-</span>text<span class="token operator">=</span><span class="token constant">NOT_FOUND</span> <span class="token operator">-</span> no exchange 'task<span class="token punctuation">.</span>direct' in vhost <span class="token char">'/'</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">,</span> method<span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="publisherreturn_88">
     </a>
     publisher-return
    </h4>
    <p>
     publisher-return（发送者回执 ReturnCallback ）：
    </p>
    <ul>
     <li>
      消息投递到交换机了，但是没有路由到队列，返回ACK及路由失败原因
     </li>
    </ul>
    <p>
     开启方式：在spring项目中添加配置
    </p>
    <pre><code class="prism language-yaml"><span class="token comment"># 开启publisher-return, 同样是异步回调，不过是定义ReturnCallback</span>
spring.rabbitmq.publisher<span class="token punctuation">-</span>returns=true
<span class="token comment"># 定义消息路由失败时的策略, ture: 调用ReturnCallback false:则直接丢弃消息</span>
spring.rabbitmq.template.mandatory=true
</code></pre>
    <p>
     ReturnCallback 示例代码：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// 每个RabbitTemplate只能添加一个ReturnCallback，因此需要在项目加载时配置，使用任意一种spring加载bean的方式配都可以</span>
<span class="token comment">// 添加处理发送到Queue失败的回调处理</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取RabbitTemplate</span>
        <span class="token class-name">RabbitTemplate</span> rabbitTemplate <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置ReturnCallback</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 投递失败，记录日志</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送失败，应答码: "</span> <span class="token operator">+</span> replyCode <span class="token operator">+</span> <span class="token string">" 原因: "</span> <span class="token operator">+</span> replyText <span class="token operator">+</span> <span class="token string">" 交换机: "</span> <span class="token operator">+</span> exchange <span class="token operator">+</span> <span class="token string">" 路由键: "</span> <span class="token operator">+</span> routingKey <span class="token operator">+</span> <span class="token string">" 消息: "</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果有业务需要，可以重发消息</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"如果有业务需要，可以重发消息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     运行结果分析：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// 路由成功没有就不会调用ReturnCallback了</span>

<span class="token comment">// 路由失败找不到绑定的queue打印结果</span>
消息发送失败，应答码<span class="token operator">:</span> <span class="token number">312</span> 原因<span class="token operator">:</span> <span class="token constant">NO_ROUTE</span> 交换机<span class="token operator">:</span> reward<span class="token punctuation">.</span>exchange 路由键<span class="token operator">:</span> testRoutingKey 消息<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">Body</span><span class="token operator">:</span>'hello<span class="token punctuation">,</span> spring amqp<span class="token operator">!</span>' <span class="token class-name">MessageProperties</span> <span class="token punctuation">[</span>headers<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>spring_returned_message_correlation<span class="token operator">=</span><span class="token number">8d</span><span class="token number">63</span>cdb9<span class="token operator">-</span><span class="token number">228e-4</span>a8d<span class="token operator">-</span>bd54<span class="token operator">-</span><span class="token number">1e565</span>ca31ef2<span class="token punctuation">}</span><span class="token punctuation">,</span> contentType<span class="token operator">=</span>text<span class="token operator">/</span>plain<span class="token punctuation">,</span> contentEncoding<span class="token operator">=</span><span class="token constant">UTF</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span> contentLength<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> receivedDeliveryMode<span class="token operator">=</span><span class="token constant">PERSISTENT</span><span class="token punctuation">,</span> priority<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> deliveryTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
    <h3>
     <a id="4_130">
     </a>
     4、持久化
    </h3>
    <p>
     RabbitMQ的持久化机制是一种确保数据在RabbitMQ服务重启或异常情况下不会丢失的重要特性，主要包括以下三个方面：交换器的持久化、队列的持久化、消息的持久化。
    </p>
    <h4>
     <a id="_132">
     </a>
     交换机持久化
    </h4>
    <p>
     RabbitMQ中交换机默认是非持久化的，mq重启后就会丢失，Spring提供的AMQP包中可以通过代码指定交换机持久化：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// durable 参数为true 时 就是将指定的交换机初始化</span>
<span class="token keyword">public</span> <span class="token class-name">TopicExchange</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoDelete<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> autoDelete<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     Spring提供的AMQP包中默认的方式就是持久化方式：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">TopicExchange</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">AbstractExchange</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     也可以在RabbitMQ控制台查看，持久化的交换机的Features属性标记是 D。
    </p>
    <h4>
     <a id="_155">
     </a>
     队列持久化
    </h4>
    <p>
     RabbitMQ中队列默认是非持久化的，MQ重启后就丢失，Spring提供的AMQP包中可以通过代码指定队列持久化：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Spring提供的AMQP包中默认的方式就是持久化方式</span>
	<span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// durable 参数为true 时 就是将指定的队列初始化</span>
<span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> exclusive<span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoDelete<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> exclusive<span class="token punctuation">,</span> autoDelete<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     也可以在RabbitMQ控制台查看，持久化的队列的Features属性标记是 D。
    </p>
    <h4>
     <a id="_173">
     </a>
     消息持久化
    </h4>
    <p>
     利用Spring提供的AMQP包中的方法发送消息时，可以设置消息的属性（MessageProoerties），指定 delivery-mode：
    </p>
    <ul>
     <li>
      持久化：
      <code>
       MessageDeliveryMode.PERSISTENT
      </code>
     </li>
     <li>
      非持久化：
      <code>
       MessageDeliveryMode.NON_PERSISTENT
      </code>
     </li>
    </ul>
    <p>
     默认情况下，Spring提供的AMQP包发出的任何消息都是持久化的，不用特意指定：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// 获取 DEFAULT_DELIVERY_MODE</span>
<span class="token keyword">private</span> <span class="token class-name">MessageDeliveryMode</span> deliveryMode <span class="token operator">=</span> <span class="token constant">DEFAULT_DELIVERY_MODE</span><span class="token punctuation">;</span>
<span class="token comment">// 默认值为 MessageDeliveryMode.PERSISTENT</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">MessageDeliveryMode</span> <span class="token constant">DEFAULT_DELIVERY_MODE</span> <span class="token operator">=</span> <span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="5_186">
     </a>
     5、消费者消息确认
    </h3>
    <p>
     RabbitMQ如果开启了消费者消息确认配置，则确认消息被消费者消费后才会删除消息。消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。
    </p>
    <p>
     注意：消费者ACK的时机要注意一下，因为RabbitMQ投递消息给消费者，消费者获取消息后，如果立即ACK给RabbitMQ，此时RabbbitMQ删除消息，如果消费者在消费过程中宕机了，消息还未处理完成，这样，消息就丢失了，因此消费者返回ACK的时机非常重要。
    </p>
    <p>
     而Spring提供的AMQP允许配置三种确认模式：
    </p>
    <ul>
     <li>
      <p>
       manual：手动ack，需要在业务代码结束后，调用api发送ACK。此方式是自己根据业务情况，判断什么时候返回ACK
      </p>
     </li>
     <li>
      <p>
       auto（一般默认）：自动ack，由spring监测listener代码是否出现了异常，没有异常则返回ACK，抛出异常则返回NACK。此方式类似事务机制，出现异常时返回NACK，消息回滚到MQ，没有异常，返回ACK。
      </p>
     </li>
     <li>
      <p>
       none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后会立即删除。此方式消息投递是不可靠的，可能会丢失。
      </p>
     </li>
    </ul>
    <p>
     开启方式：在spring项目中添加配置
    </p>
    <pre><code class="prism language-yaml"><span class="token comment"># manual: 手动ack</span>
<span class="token comment"># auto（一般默认）: 自动ack</span>
<span class="token comment"># none: 关闭ack</span>
<span class="token key atrule">spring.rabbitmq.listener.simple.acknowledge-mode</span><span class="token punctuation">:</span> none 
</code></pre>
    <h3>
     <a id="6_208">
     </a>
     6、失败重试机制
    </h3>
    <p>
     开启消费确认机制后，如果消费者出现异常，无法ACK，消费会不断requeue（重入列）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环。
    </p>
    <ul>
     <li>
      好处：避免消息丢失
     </li>
     <li>
      坏处：导致mq的消息处理飙升，带来不必要的压力。
     </li>
    </ul>
    <p>
     可以利用Spring的retry机制，在消费者出现异常时利用本地重试机制，而不是无限制requeue到mq队列
    </p>
    <p>
     开启方式：在spring项目中添加配置，consumer服务
    </p>
    <pre><code class="prism language-yaml"><span class="token comment"># 开启消费者失败重试</span>
spring.rabbitmq.listener.simple.retry.enabled=true 
<span class="token comment"># 初识的失败等待时长为1秒</span>
spring.rabbitmq.listener.simple.retry.initial<span class="token punctuation">-</span>interval=1000 
<span class="token comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span>
spring.rabbitmq.listener.simple.retry.multiplier=1 
<span class="token comment"># 最大重试次数</span>
spring.rabbitmq.listener.simple.retry.max<span class="token punctuation">-</span>attempts=3 
<span class="token comment"># true无状态, false有状态。如果业务中包含事务，这里改为false</span>
spring.rabbitmq.listener.simple.retry.stateless=true 
</code></pre>
    <p>
     上述配置分析：
    </p>
    <ul>
     <li>
      在重试3次后，Spring会抛出异常AmqpRejectAndDontRequeueException，说明本地重试触发了。
     </li>
     <li>
      查看RabbitMQ控制台，发现消息被删除了，说明最后consumer返回的是ack，MQ删除消息了。
     </li>
    </ul>
    <p>
     结论：
    </p>
    <ul>
     <li>
      开启本地重试之后，重试达到最大次数，spring会返回ACK给MQ服务器，然后MQ服务器会删除该消息，不会requeue到队列中。
     </li>
     <li>
      然后在消费者本地进行重试。
     </li>
    </ul>
    <p>
     失败策略
    </p>
    <ul>
     <li>
      当失败次数达到最大重试次数之后，消息会被丢弃，这是由spring内部机制决定的。
     </li>
     <li>
      在开启重试模式之后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同是实现
      <ul>
       <li>
        RejectAndDontRequeueRecoverer：重试耗尽之后，直接reject，丢弃消息，默认就是这种方式
       </li>
       <li>
        ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入列
       </li>
       <li>
        RepublishMessageRecoverer：重试耗尽之后，将失败消息投递到指定的交换机。该方案也是最常用的，失败后将消息投递到一个指定的，专门存放异常消息的队列中，后续由人工集中处理。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     代码示例：
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ErrorMessageConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 定义处理异常信息的交换机</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"error.direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 定义处理异常信息的队列</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"error.queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 绑定交换机，路由键，队列</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">errorBinding</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> errorQueue<span class="token punctuation">,</span> <span class="token class-name">DirectExchange</span> errorMessageExchange<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>errorQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>errorMessageExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 定义 失败策略 </span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">MessageRecoverer</span> <span class="token function">republishMessageRecoverer</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RepublishMessageRecoverer</span><span class="token punctuation">(</span>rabbitTemplate<span class="token punctuation">,</span> <span class="token string">"error.direct"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="7_273">
     </a>
     7、小结
    </h3>
    <ul>
     <li>
      <p>
       开启生产者确认机制，确保生产者的消息能到达队列。
      </p>
     </li>
     <li>
      <p>
       开启持久化功能，确保消息未消费前在队列中不会丢失
      </p>
     </li>
     <li>
      <p>
       开启消费者确认机制为auto，由spring确认消息处理成功后完成ack
      </p>
     </li>
     <li>
      <p>
       开启消费者失败重试机制，并设置MessageRecover，多次重试失败后将消息投递到异常交换机，交给人工处理。
      </p>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353538333330332f:61727469636c652f64657461696c732f313435373734393932" class_="artid" style="display:none">
 </p>
</div>


