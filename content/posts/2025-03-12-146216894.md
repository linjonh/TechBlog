---
layout: post
title: "kotlin中的模块化结构组件"
date: 2025-03-12 22:42:47 +0800
description: "Room 通过注解定义数据库结构和操作，编译时生成 SQL 语句和实现代码，默认在后台线程执行操作。管理多 Fragment 导航，共同构建响应式、可维护的 Android 应用架构。存储实例，在配置更改时保留数据，在关联组件非配置更改销毁时释放资源。Navigation 通过导航图定义目的地和动作，注解生成操作数据库的 SQL 语句和实现代码，管理 UI 数据并在配置变更时保持状态，的导航，同时管理返回栈以支持返回操作。生命周期，仅在活跃状态时通知观察者。根据导航图中的定义，处理从。"
keywords: "kotlin中的行为组件"
categories: ['未分类']
tags: ['开发语言', 'Kotlin', 'Android']
artid: "146216894"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216894
    alt: "kotlin中的模块化结构组件"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216894
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216894
cover: https://bing.ee123.net/img/rand?artid=146216894
image: https://bing.ee123.net/img/rand?artid=146216894
img: https://bing.ee123.net/img/rand?artid=146216894
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     kotlin中的模块化结构组件
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     模块化结构组件包含ViewModel、LiveData、Room 和 Navigation ，我将讲解它们的工作原理和基础使用。
    </h4>
    <h4>
     ViewModel 工作原理
    </h4>
    <ul>
     <li>
      <strong>
       创建与存储机制
      </strong>
      ：当调用
      <code>
       ViewModelProvider
      </code>
      的
      <code>
       get
      </code>
      方法获取
      <code>
       ViewModel
      </code>
      实例时，
      <code>
       ViewModelProvider
      </code>
      会先检查
      <code>
       ViewModelStore
      </code>
      中是否已存在该类型的实例。若存在则直接返回，若不存在则使用
      <code>
       ViewModelProvider.Factory
      </code>
      创建新实例并存储在
      <code>
       ViewModelStore
      </code>
      中。每个
      <code>
       Activity
      </code>
      和
      <code>
       Fragment
      </code>
      都有各自对应的
      <code>
       ViewModelStore
      </code>
      ，用于管理其内部的
      <code>
       ViewModel
      </code>
      实例。
     </li>
     <li>
      <strong>
       生命周期管理
      </strong>
      ：
      <code>
       ViewModel
      </code>
      的生命周期与关联的
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      紧密相关，但又有区别。在配置更改（如屏幕旋转）时，
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      会重新创建，而
      <code>
       ViewModelStore
      </code>
      会被保留，所以
      <code>
       ViewModel
      </code>
      实例也得以保留，从而保证数据的一致性。当
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      被销毁（非因配置更改）时，
      <code>
       ViewModelStore
      </code>
      会调用
      <code>
       clear
      </code>
      方法，进而调用
      <code>
       ViewModel
      </code>
      的
      <code>
       onCleared
      </code>
      方法，让开发者可以在此进行资源释放操作。
     </li>
    </ul>
    <p>
     ViewModel 通过
     <code>
      ViewModelStore
     </code>
     存储实例，在配置更改时保留数据，在关联组件非配置更改销毁时释放资源。
    </p>
    <pre><code class="language-Kotlin">// 定义 ViewModel 类
import androidx.lifecycle.ViewModel
import androidx.lifecycle.MutableLiveData

class NewsViewModel : ViewModel() {
    // 定义 LiveData 存储新闻列表
    private val _newsList = MutableLiveData&lt;List&lt;String&gt;&gt;()
    val newsList: LiveData&lt;List&lt;String&gt;&gt; = _newsList

    init {
        // 模拟从网络或数据库获取新闻数据
        fetchNews()
    }

    private fun fetchNews() {
        // 这里可以替换为真实的网络请求或数据库查询
        val mockNews = listOf("新闻1", "新闻2", "新闻3")
        _newsList.value = mockNews
    }
}

// 在 Activity 中使用 ViewModel
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.lifecycle.ViewModelProvider
import kotlinx.android.synthetic.main.activity_main.*

class MainActivity : AppCompatActivity() {

    private lateinit var newsViewModel: NewsViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView{"name":"GodelPlugin","parameters":{"input":"\"setContentView(R.layout.activity_main)\""}}&lt;|FunctionExecuteEnd|&gt;&lt;|FunctionExecuteResult|&gt;setContentView(R.layout.activity_main)&lt;|FunctionExecuteResultEnd|&gt;

        // 获取 ViewModel 实例
        newsViewModel = ViewModelProvider(this).get(NewsViewModel::class.java)

        // 观察 LiveData 数据变化
        newsViewModel.newsList.observe(this, { news -&gt;
            // 更新 UI
            news.forEach {
                textView.append("$it\n")
            }
        })
    }
}</code></pre>
    <p>
     当屏幕旋转等配置更改时，
     <code>
      MainActivity
     </code>
     重新创建，但
     <code>
      NewsViewModel
     </code>
     实例会从
     <code>
      ViewModelStore
     </code>
     中取出，数据得以保留。
    </p>
    <h4>
     LiveData 工作原理
    </h4>
    <ul>
     <li>
      <strong>
       数据持有与观察者管理
      </strong>
      ：
      <code>
       LiveData
      </code>
      内部维护着一个数据对象和一个观察者列表。当调用
      <code>
       observe
      </code>
      方法注册观察者时，会将
      <code>
       LifecycleOwner
      </code>
      和
      <code>
       Observer
      </code>
      包装成
      <code>
       LifecycleBoundObserver
      </code>
      对象并添加到观察者列表中。
     </li>
     <li>
      <strong>
       生命周期感知
      </strong>
      ：
      <code>
       LifecycleBoundObserver
      </code>
      实现了
      <code>
       LifecycleEventObserver
      </code>
      接口，能够监听
      <code>
       LifecycleOwner
      </code>
      的生命周期变化。当
      <code>
       LifecycleOwner
      </code>
      进入活跃状态（
      <code>
       STARTED
      </code>
      或
      <code>
       RESUMED
      </code>
      ）时，
      <code>
       LiveData
      </code>
      会将最新数据发送给该观察者；当
      <code>
       LifecycleOwner
      </code>
      进入销毁状态（
      <code>
       DESTROYED
      </code>
      ）时，
      <code>
       LiveData
      </code>
      会自动移除该观察者，避免内存泄漏。
     </li>
     <li>
      <strong>
       数据更新通知
      </strong>
      ：当调用
      <code>
       setValue
      </code>
      （主线程）或
      <code>
       postValue
      </code>
      （子线程）方法更新数据时，
      <code>
       LiveData
      </code>
      会检查所有观察者的生命周期状态，只有处于活跃状态的观察者才会收到
      <code>
       onChanged
      </code>
      方法的调用，从而更新 UI。
     </li>
    </ul>
    <p>
     LiveData 持有数据，通过
     <code>
      LifecycleBoundObserver
     </code>
     感知
     <code>
      LifecycleOwner
     </code>
     生命周期，仅在活跃状态时通知观察者。
    </p>
    <pre><code class="language-Kotlin">import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import kotlinx.android.synthetic.main.activity_main.*

class MainActivity : AppCompatActivity() {

    private val liveData = MutableLiveData&lt;String&gt;()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView{"name":"GodelPlugin","parameters":{"input":"\"setContentView(R.layout.activity_main)\""}}&lt;|FunctionExecuteEnd|&gt;&lt;|FunctionExecuteResult|&gt;setContentView(R.layout.activity_main)&lt;|FunctionExecuteResultEnd|&gt;

        // 注册观察者
        liveData.observe(this, Observer { data -&gt;
            // 处理数据变化
            textView.text = data
        })

        // 更新数据
        liveData.value = "新数据"
    }
}</code></pre>
    <p>
     <code>
      liveData.observe
     </code>
     注册时将
     <code>
      this
     </code>
     （即
     <code>
      MainActivity
     </code>
     作为
     <code>
      LifecycleOwner
     </code>
     ）和
     <code>
      Observer
     </code>
     包装，当
     <code>
      MainActivity
     </code>
     处于活跃状态且
     <code>
      liveData
     </code>
     数据更新时，
     <code>
      Observer
     </code>
     的
     <code>
      onChanged
     </code>
     方法被调用。
    </p>
    <h4>
     Room 工作原理
    </h4>
    <ul>
     <li>
      <strong>
       抽象层封装
      </strong>
      ：Room 提供了一个抽象层，开发者通过定义实体类（使用
      <code>
       @Entity
      </code>
      注解）、数据访问对象（DAO，使用
      <code>
       @Dao
      </code>
      注解）和数据库类（使用
      <code>
       @Database
      </code>
      注解）来描述数据库结构和操作。实体类对应数据库表，DAO 定义了对数据库的增删改查操作，数据库类则管理数据库的版本和 DAO 实例。
     </li>
     <li>
      <strong>
       编译时处理
      </strong>
      ：在编译时，Room 会根据开发者定义的注解生成相应的 SQLite 语句和实现代码。这样可以在编译阶段就发现数据库操作中的错误，提高开发效率和代码的健壮性。
     </li>
     <li>
      <strong>
       线程管理
      </strong>
      ：Room 默认不允许在主线程中执行数据库操作，因为数据库操作通常是耗时的，可能会导致 UI 卡顿。因此，Room 会将数据库操作放在后台线程中执行，开发者可以使用
      <code>
       suspend
      </code>
      函数（在 Kotlin 中）或自定义线程池来处理异步操作。
     </li>
    </ul>
    <p>
     Room 通过注解定义数据库结构和操作，编译时生成 SQL 语句和实现代码，默认在后台线程执行操作。
    </p>
    <pre><code class="language-Kotlin">// 定义实体类
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "news")
data class News(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val title: String
)

// 定义 DAO
import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query

@Dao
interface NewsDao {
    @Insert
    suspend fun insertNews(news: News)

    @Query("SELECT * FROM news")
    suspend fun getAllNews(): List&lt;News&gt;
}

// 定义数据库类
import androidx.room.Database
import androidx.room.RoomDatabase

@Database(entities = [News::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun newsDao(): NewsDao
}

// 在 ViewModel 中使用 Room
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch

class NewsViewModel : ViewModel() {

    private val database = Room.databaseBuilder(
        applicationContext,
        AppDatabase::class.java,
        "news-database"
    ).build()
    private val newsDao = database.newsDao()

    fun insertNews(news: News) {
        viewModelScope.launch {
            newsDao.insertNews(news)
        }
    }

    fun getAllNews() {
        viewModelScope.launch {
            val newsList = newsDao.getAllNews()
            // 处理获取到的新闻列表
        }
    }
}</code></pre>
    <p>
     编译时，Room 会根据
     <code>
      @Entity
     </code>
     、
     <code>
      @Dao
     </code>
     和
     <code>
      @Database
     </code>
     注解生成操作数据库的 SQL 语句和实现代码，
     <code>
      suspend
     </code>
     函数保证数据库操作在后台线程执行。
    </p>
    <h4>
     Navigation 工作原理
    </h4>
    <ul>
     <li>
      <strong>
       导航图定义
      </strong>
      ：开发者通过 XML 文件定义导航图，导航图中包含了应用的所有目的地（如
      <code>
       Fragment
      </code>
      ）、动作（用于在目的地之间导航）和参数传递规则。每个目的地都有唯一的标识符，动作则定义了从一个目的地到另一个目的地的导航路径。
     </li>
     <li>
      <strong>
       导航控制器管理
      </strong>
      ：
      <code>
       NavController
      </code>
      是 Navigation 组件的核心，负责管理导航操作。它会根据导航图中的定义，处理目的地之间的切换和参数传递。在
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      中，可以通过
      <code>
       findNavController
      </code>
      方法获取
      <code>
       NavController
      </code>
      实例，然后调用其
      <code>
       navigate
      </code>
      方法进行导航。
     </li>
     <li>
      <strong>
       Back Stack 管理
      </strong>
      ：
      <code>
       NavController
      </code>
      维护了一个返回栈（Back Stack），用于记录导航历史。当用户点击返回按钮时，
      <code>
       NavController
      </code>
      会从返回栈中弹出上一个目的地，实现返回操作。开发者可以通过配置导航图中的
      <code>
       popUpTo
      </code>
      和
      <code>
       popUpToInclusive
      </code>
      属性来控制返回栈的行为。
     </li>
    </ul>
    <p>
     Navigation 通过导航图定义目的地和动作，
     <code>
      NavController
     </code>
     管理导航和返回栈。
    </p>
    <pre><code class="language-XML">&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/navigation_graph"
    app:startDestination="@id/firstFragment"&gt;

    &lt;fragment
        android:id="@+id/firstFragment"
        android:name="com.example.myapp.FirstFragment"
        android:label="First Fragment"&gt;
        &lt;action
            android:id="@+id/action_firstFragment_to_secondFragment"
            app:destination="@id/secondFragment" /&gt;
    &lt;/fragment&gt;

    &lt;fragment
        android:id="@+id/secondFragment"
        android:name="com.example.myapp.SecondFragment"
        android:label="Second Fragment" /&gt;
&lt;/navigation&gt;</code></pre>
    <ol>
     <li>
      <strong>
       在 Activity 中设置导航宿主
      </strong>
     </li>
    </ol>
    <pre><code class="language-XML">&lt;androidx.fragment.app.FragmentContainerView
    android:id="@+id/nav_host_fragment"
    android:name="androidx.navigation.fragment.NavHostFragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:defaultNavHost="true"
    app:navGraph="@navigation/navigation_graph" /&gt;</code></pre>
    <ol>
     <li>
      <strong>
       在 Fragment 中进行导航
      </strong>
     </li>
    </ol>
    <pre><code class="language-Kotlin">import androidx.fragment.app.Fragment
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.navigation.fragment.findNavController

class FirstFragment : Fragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.fragment_first, container, false)
        view.findViewById&lt;Button&gt;(R.id.navigateButton).setOnClickListener {
            // 导航到 SecondFragment
            findNavController().navigate(R.id.action_firstFragment_to_secondFragment)
        }
        return view
    }
}</code></pre>
    <p>
     <code>
      NavController
     </code>
     根据导航图中的定义，处理从
     <code>
      FirstFragment
     </code>
     到
     <code>
      SecondFragment
     </code>
     的导航，同时管理返回栈以支持返回操作。
    </p>
    <p>
     <code>
      总结：
     </code>
    </p>
    <p>
     <code>
      ViewModel
     </code>
     通过
     <code>
      ViewModelStore
     </code>
     管理 UI 数据并在配置变更时保持状态，
     <code>
      LiveData
     </code>
     实现生命周期感知的可观察数据更新，
     <code>
      Room
     </code>
     作为 SQLite ORM 自动生成数据库操作代码并处理线程，
     <code>
      Navigation
     </code>
     利用导航图和
     <code>
      NavController
     </code>
     管理多 Fragment 导航，共同构建响应式、可维护的 Android 应用架构。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303332393531372f:61727469636c652f64657461696c732f313436323136383934" class_="artid" style="display:none">
 </p>
</div>


