---
layout: post
title: "C学习内存管理"
date: 2025-03-16 22:50:53 +0800
description: "当new和delete对自定义类型进行操作时，会自动调用构造函数和析构函数。"
keywords: "C++学习内存管理"
categories: ['C']
tags: ['学习']
artid: "146300437"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146300437
    alt: "C学习内存管理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146300437
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146300437
cover: https://bing.ee123.net/img/rand?artid=146300437
image: https://bing.ee123.net/img/rand?artid=146300437
img: https://bing.ee123.net/img/rand?artid=146300437
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++学习内存管理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.概念的介绍
    </h2>
    <p>
     总括：
    </p>
    <p>
     <img alt="" height="516" src="https://i-blog.csdnimg.cn/direct/648a926f8f2d47de9d78ebae5fc1b5d2.png" width="1149"/>
    </p>
    <h3>
     1. 栈（Stack）
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        存储内容
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         局部变量（包括函数参数、非静态局部变量）。
        </p>
       </li>
       <li>
        <p>
         函数调用的上下文信息（如返回地址、寄存器状态等）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          特点
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           内存由编译器自动分配和释放。
          </p>
         </li>
         <li>
          <p>
           生命周期与函数调用相关，函数结束时自动释放。
          </p>
         </li>
         <li>
          <p>
           大小有限，通常较小（几MB）。
          </p>
         </li>
         <li>
          <p>
           访问速度快。
          </p>
         </li>
         <li>
          <p>
           <img alt="" height="215" src="https://i-blog.csdnimg.cn/direct/160592a593f440068fc574f715d5aac2.png" width="1050"/>
          </p>
         </li>
         <li>
          <h3>
           2.堆区
          </h3>
         </li>
         <li>
          <p>
           <strong>
            存储内容
           </strong>
           ：
          </p>
          <ul>
           <li>
            <p>
             动态分配的内存（通过
             <code>
              new
             </code>
             、
             <code>
              malloc
             </code>
             等分配的内存）。
            </p>
           </li>
           <li>
            <p>
             需要手动管理内存的分配和释放。
            </p>
           </li>
          </ul>
         </li>
         <li>
          <p>
           <strong>
            特点
           </strong>
           ：
          </p>
          <ul>
           <li>
            <p>
             内存由程序员手动管理（使用
             <code>
              new
             </code>
             /
             <code>
              delete
             </code>
             或
             <code>
              malloc
             </code>
             /
             <code>
              free
             </code>
             ）。
            </p>
           </li>
           <li>
            <p>
             生命周期由程序员控制，直到显式释放。
            </p>
           </li>
           <li>
            <p>
             大小较大，受系统内存限制。
            </p>
           </li>
           <li>
            <p>
             访问速度较慢。
            </p>
           </li>
           <li>
            <p>
             void bar() {
             <!-- -->
             <br/>
             int* ptr = new int(20); // ptr 指向堆区分配的内存
             <br/>
             delete ptr; // 手动释放堆区内存
             <br/>
             }
            </p>
           </li>
           <li>
            <h3>
             3.
             <strong>
              静态区（Static/Global Area）
             </strong>
            </h3>
           </li>
           <li>
            <p>
             <strong>
              存储内容
             </strong>
             ：
            </p>
            <ul>
             <li>
              <p>
               全局变量。
              </p>
             </li>
             <li>
              <p>
               静态变量（包括静态局部变量和静态成员变量）。
              </p>
             </li>
             <li>
              <p>
               <strong>
                特点
               </strong>
               ：
              </p>
              <ul>
               <li>
                <p>
                 内存分配在程序启动时完成，程序结束时释放。
                </p>
               </li>
               <li>
                <p>
                 生命周期贯穿整个程序运行期间。
                </p>
               </li>
               <li>
                <p>
                 访问速度较快。
                </p>
               </li>
               <li>
                <p>
                 int globalVar = 30; // 全局变量，存储在静态区
                </p>
                <p>
                 void baz() {
                 <!-- -->
                 <br/>
                 static int staticVar = 40; // 静态局部变量，存储在静态区
                 <br/>
                 }
                </p>
               </li>
               <li>
                <h3>
                 4.
                 <strong>
                  常量区（Constant Area）
                 </strong>
                </h3>
               </li>
               <li>
                <p>
                 <strong>
                  存储内容
                 </strong>
                 ：
                </p>
                <ul>
                 <li>
                  <p>
                   常量数据（如字符串常量、
                   <code>
                    const
                   </code>
                   修饰的常量变量）。
                  </p>
                 </li>
                 <li>
                  <p>
                   只读数据。
                  </p>
                 </li>
                </ul>
               </li>
               <li>
                <p>
                 <strong>
                  特点
                 </strong>
                 ：
                </p>
                <ul>
                 <li>
                  <p>
                   内存分配在程序启动时完成，程序结束时释放。
                  </p>
                 </li>
                 <li>
                  <p>
                   数据不可修改。
                  </p>
                 </li>
                 <li>
                  <p>
                   访问速度较快。
                  </p>
                 </li>
                 <li>
                  <p>
                   const int constVar = 50; // 常量变量，存储在常量区
                   <br/>
                   const char* str = "Hello, World!"; // 字符串常量，存储在常量区
                  </p>
                  <ul>
                   <li>
                    <p>
                    </p>
                    <p>
                    </p>
                    <p>
                     <img alt="" height="386" src="https://i-blog.csdnimg.cn/direct/71f39920cd374d328c4be6d6e92ec4ce.png" width="1086"/>
                    </p>
                    <h2>
                     2.new和delete
                    </h2>
                    <h3>
                     1.new
                    </h3>
                    <p>
                     1.int *ptr1=new int;创建一个Int类型的变量
                    </p>
                    <p>
                     2.int*ptr2=new int[10];创建10个int类型的变量。
                    </p>
                    <p>
                     3.int*pt3r=new int[10]{1,2,3,4};这里意思是创建10个int类型的空间，然后将前四个分别初始化为1,2,3,4，然后后面的都初始化为0。
                    </p>
                    <p>
                     4.当int变为自定义类类型的时候，会自动调用构造函数。
                    </p>
                    <h3>
                     2.delete
                    </h3>
                    <p>
                     1.上面三个地址删除时调用delete，写法分别是,delete ptr1,
                    </p>
                    <p>
                     delete []ptr2,delete[]ptr3;
                    </p>
                    <p>
                     申请连续空间用new[],删除连续的空间delete[]。
                    </p>
                    <h3>
                     3.new和delete操作自定义类型
                    </h3>
                    <p>
                     当new和delete对自定义类型进行操作时，会自动调用构造函数和析构函数。
                    </p>
                    <h3>
                     4.operator new和operator delete
                    </h3>
                    <p>
                     new和delete在底层会调用operator new和operator delete进行动态内存空间管理。operator new operator delete它们两个是系统提供的全局函数，new调用opreator new，delete调用operator delete来释放和申请空间。
                    </p>
                    <h3>
                     <img alt="" height="122" src="https://i-blog.csdnimg.cn/direct/ef6369b4cbd9408b91c4ac0e41ca0d60.png" width="706">
                      <img alt="" height="89" src="https://i-blog.csdnimg.cn/direct/e9be4654d94c4ed690a013a198b45773.png" width="542">
                       <strong>
                        5.new和delete的实现原理
                       </strong>
                      </img>
                     </img>
                    </h3>
                    <h3>
                     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/a494eab375174e5bb15afa6eea03053d.png" width="719">
                      <img alt="" height="157" src="https://i-blog.csdnimg.cn/direct/d7f972bc2c7e443b8807467f6b5ee787.png" width="640">
                       <img alt="" height="320" src="https://i-blog.csdnimg.cn/direct/3a51ff19ef3f4f6583631ecf50fe7429.png" width="752">
                        <strong>
                         6.定位new
                        </strong>
                       </img>
                      </img>
                     </img>
                    </h3>
                    <p>
                     定位new是在已分配空间的部分调用构造函数初始化对象  ，一般配合内存池使用，因为一般内存池中的类对象是没有初始化的。
                    </p>
                    <p>
                     <img alt="" height="532" src="https://i-blog.csdnimg.cn/direct/a94d9cbbbf9b4f089f0bf65e2d6c79fd.png" width="700"/>
                    </p>
                    <h3>
                     7.malloc和new的区别
                    </h3>
                    <p>
                     1.malloc是函数,new是操作符。
                    </p>
                    <p>
                     2.malloc不会初始化，new会初始化。
                    </p>
                    <p>
                     3.malloc申请空间需要手动计算空间的大小，new可以不同后面直接跟类型（有内置类型int,char等，也有自定义类型date等），如果是多个对象直接在[]里面跟上创建对象的个数即可。
                    </p>
                    <p>
                     4.malloc创建的空间返回的指针是void*，必须强制转换，new可以不用，因为new在使用的时候后面跟了类型。
                    </p>
                    <p>
                     5.malloc开辟空间失败时返回NULL，但是new不会，它会抛出异常。需要来接收。
                    </p>
                    <p>
                     6.申请自定义类型对象时，new会调用构造函数，delete在释放空间前会调用析构函数释放自定义对象的资源，但是malloc和free不会。
                    </p>
                    <p>
                    </p>
                    <p>
                    </p>
                    <p>
                    </p>
                   </li>
                  </ul>
                 </li>
                </ul>
               </li>
              </ul>
             </li>
            </ul>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38373135313036342f:61727469636c652f64657461696c732f313436333030343337" class_="artid" style="display:none">
 </p>
</div>


