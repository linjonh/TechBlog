---
layout: post
title: "旋转位置编码-2"
date: 2025-03-05 21:47:47 +08:00
description: "这些代码片段展示了 PyTorch 中常用的张量操作，包括形状变换、数据类型转换以及复数张量的处理。"
keywords: "旋转位置编码 （2）"
categories: ['深度学习模块']
tags: ['深度学习', 'Pytorch', 'Python']
artid: "146054077"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146054077
    alt: "旋转位置编码-2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146054077
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146054077
cover: https://bing.ee123.net/img/rand?artid=146054077
image: https://bing.ee123.net/img/rand?artid=146054077
img: https://bing.ee123.net/img/rand?artid=146054077
---

# 旋转位置编码 （2）
### 旋转位置编码常见的torch函数
# 导入必要的库
import torch
# 定义一个简单的函数来演示torch.view\_as\_complex和torch.view\_as\_real
def demo\_view\_as\_complex\_real():
# 创建一个形状为 (2, 3, 4, 2) 的张量，最后一个维度表示复数的实部和虚部
x = torch.randn(2, 3, 4, 2)
# 使用torch.view\_as\_complex将最后两个维度转换为复数
x\_complex = torch.view\_as\_complex(x)
print("Original tensor shape:", x.shape)
print("After view\_as\_complex shape:", x\_complex.shape)
# 使用torch.view\_as\_real将复数张量转换回实部和虚部
x\_real = torch.view\_as\_real(x\_complex)
print("After view\_as\_real shape:", x\_real.shape)
# 检查转换是否可逆
print("Are the original and reconstructed tensors equal?", torch.allclose(x, x\_real))
demo\_view\_as\_complex\_real()
Original tensor shape: torch.Size([2, 3, 4, 2])
After view\_as\_complex shape: torch.Size([2, 3, 4])
After view\_as\_real shape: torch.Size([2, 3, 4, 2])
Are the original and reconstructed tensors equal? True
# 定义一个简单的函数来演示torch.reshape和torch.flatten
def demo\_reshape\_flatten():
# 创建一个形状为 (2, 3, 4) 的张量
x = torch.randn(2, 3, 4)
# 使用torch.reshape改变张量的形状
x\_reshaped = x.reshape(2, -1) # 将最后两个维度展平
print("Original tensor shape:", x.shape)
print("After reshape shape:", x\_reshaped.shape)
# 使用torch.flatten展平张量
x\_flattened = x.flatten(start\_dim=1) # 从第1维度开始展平
print("After flatten shape:", x\_flattened.shape)
demo\_reshape\_flatten()
Original tensor shape: torch.Size([2, 3, 4])
After reshape shape: torch.Size([2, 12])
After flatten shape: torch.Size([2, 12])
xq = torch.randint(0, 10, (3, 4, 6)) # 创建一个形状为 (3, 4, 6) 的张量
print("原始形状:", xq.shape)
# 执行操作
result = xq.float().reshape(\*xq.shape[:-1], -1, 2) # 转换为 float 并重塑形状
print("转换后的形状:", result.shape)
原始形状: torch.Size([3, 4, 6])
转换后的形状: torch.Size([3, 4, 3, 2])
# 定义一个简单的函数来演示torch.view
def demo\_view():
# 创建一个形状为 (2, 3, 4) 的张量
x = torch.randn(2, 3, 4, 4)
# 使用torch.view改变张量的形状
x\_viewed = x.view(2, -1) # 将最后两个维度展平
print("Original tensor shape:", x.shape)
print("After view shape:", x\_viewed.shape)
demo\_view()
Original tensor shape: torch.Size([2, 3, 4, 4])
After view shape: torch.Size([2, 48])
# 定义一个简单的函数来演示torch.type\_as
def demo\_type\_as():
# 创建两个不同类型的张量
x = torch.randn(2, 3, dtype=torch.float32)
y = torch.randn(2, 3, dtype=torch.float64)
# 使用torch.type\_as将x的类型转换为与y相同
x\_converted = x.type\_as(y)
print("Original x dtype:", x.dtype)
print("After type\_as dtype:", x\_converted.dtype)
demo\_type\_as()
Original x dtype: torch.float32
After type\_as dtype: torch.float64
import torch
def unite\_shape(pos\_cis, x):
print(f"输入 x 的形状: {x.shape}")
print(f"输入 pos\_cis 的形状: {pos\_cis.shape}")
ndim = x.ndim # 获取输入张量 x 的维度数
print(f"x 的维度数 (ndim): {ndim}")
assert 0 <= 1 < ndim # 确保 x 至少有两个维度
print("断言 0 <= 1 < ndim 通过")
assert pos\_cis.shape == (x.shape[1], x.shape[-1]) # 检查 pos\_cis 的形状是否匹配
print("断言 pos\_cis.shape == (x.shape[1], x.shape[-1]) 通过")
shape = [d if i == 1 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)] # 构建新的形状
print(f"构建的新形状 (shape): {shape}")
result = pos\_cis.view(\*shape) # 将 pos\_cis 重塑为新的形状
print(f"重塑后的 pos\_cis 形状: {result.shape}")
return result
# 示例数据
x = torch.randn(10, 20, 30) # 创建一个形状为 (10, 20, 30) 的张量
pos\_cis = torch.randn(20, 30) # 创建一个形状为 (20, 30) 的张量
# 调用函数
output = unite\_shape(pos\_cis, x)
输入 x 的形状: torch.Size([10, 20, 30])
输入 pos\_cis 的形状: torch.Size([20, 30])
x 的维度数 (ndim): 3
断言 0 <= 1 < ndim 通过
断言 pos\_cis.shape == (x.shape[1], x.shape[-1]) 通过
构建的新形状 (shape): [1, 20, 30]
重塑后的 pos\_cis 形状: torch.Size([1, 20, 30])
### 代码解释
1. \*\*`demo\_view\_as\_complex\_real` 函数\*\*：
\* 该函数展示了如何使用 `torch.view\_as\_complex` 将张量的最后两个维度转换为复数，并使用 `torch.view\_as\_real` 将其转换回实部和虚部。
\* 通过 `torch.allclose` 检查转换是否可逆。
2. \*\*`demo\_reshape\_flatten` 函数\*\*：
\* 该函数展示了如何使用 `torch.reshape` 和 `torch.flatten` 来改变张量的形状。
\* `reshape` 可以将张量重新调整为指定的形状，而 `flatten` 则将张量展平为指定的维度。
3. \*\*`xq` 张量的操作\*\*：
\* 该部分代码展示了如何将一个形状为 `(3, 4, 6)` 的张量转换为 `float` 类型，并重塑为 `(3, 4, 3, 2)` 的形状。
4. \*\*`demo\_view` 函数\*\*：
\* 该函数展示了如何使用 `torch.view` 来改变张量的形状。`view` 类似于 `reshape`，但它要求张量在内存中是连续的。
5. \*\*`demo\_type\_as` 函数\*\*：
\* 该函数展示了如何使用 `torch.type\_as` 将一个张量的数据类型转换为与另一个张量相同。
6. \*\*`unite\_shape` 函数\*\*：
\* 该函数展示了如何根据输入张量 `x` 的形状来重塑 `pos\_cis` 张量。
\* 通过 `assert` 语句确保输入张量的形状符合预期，并使用 `view` 方法重塑 `pos\_cis` 的形状。
这些代码片段展示了 PyTorch 中常用的张量操作，包括形状变换、数据类型转换以及复数张量的处理。