---
layout: post
title: "第十五届蓝桥杯CC-C-组全部题目详细题解"
date: 2025-03-13 18:03:52 +0800
description: "​本文为第十五届蓝桥杯C/C++ C 组全部题目的详细题解，题目均来自于蓝桥杯官网。觉的有帮助或者写的不错可以点个赞，如果我题解写的有问题也欢迎评论指出，欢迎友好讨论​"
keywords: "第十五届蓝桥杯C/C++ C 组全部题目详细题解"
categories: ['未分类']
tags: ['蓝桥杯', '算法竞赛', '算法', '开发语言', 'C', 'C']
artid: "146000642"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146000642
    alt: "第十五届蓝桥杯CC-C-组全部题目详细题解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146000642
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146000642
cover: https://bing.ee123.net/img/rand?artid=146000642
image: https://bing.ee123.net/img/rand?artid=146000642
img: https://bing.ee123.net/img/rand?artid=146000642
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     第十五届蓝桥杯C/C++ C 组全部题目详细题解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-c4beb5, #c8c1b9); color:#c4beb5">
      本文为
      <span style="--darkreader-inline-color:var(--darkreader-text-c4beb5, #c8c1b9); color:#c4beb5">
       第十五届蓝桥杯C/C++ C 组全部题目的详细题解，题目均来自于蓝桥杯官网，真题链接：
      </span>
     </span>
    </p>
    <p>
     <a href="https://www.lanqiao.cn/paper/" rel="nofollow" title="蓝桥杯真题卷 - 蓝桥云课">
      蓝桥杯真题卷 - 蓝桥云课
     </a>
     <br/>
     觉的有帮助或者写的不错可以点个赞，如果我题解写的有问题也欢迎评论指出，欢迎友好讨论
    </p>
    <p>
     <br/>
     <strong>
      目录
     </strong>
    </p>
    <p>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E9%A2%98%E4%B8%80%3A%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2%20-%20%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6" name="%E9%A2%98%E4%B8%80%3A%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2%20-%20%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6">
     题一:拼正方形 - 简单数学
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19696/learning/" rel="nofollow" title="0拼正方形 - 蓝桥云课">
      0拼正方形 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     给你一些2 * 2的正方形和一些1 * 1的正方形
     <br/>
     2 * 2的正方形个数为7385137888721，1 * 1的正方形个数为10470245
     <br/>
     请问这些正方形能拼出的最大正方形边长为多少?
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      可以看出2 * 2的正方形个数是远大于1 * 1的正方形个数的。
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      那么我们可以这么做，先用2*2的正方形全部用来拼一个正方形。
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      可以拼的数目为
     </span>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      7385137888721 ^（1/2）的整数部分
     </span>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      ，我们可以用计算器算出来为2717561，也就是用掉2717561个2 * 2的正方形。
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      这个正方形的边长为2717561 * 2 = 5435122。需要用掉5435122 * 2 + 1= 10870245个1*1的正方形才能使得这个正方形的边长加1。
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      这个数量是大于已有的1*1的正方形个数，所以1 * 1的正方形是用不上的，最后的边长为5435122
     </span>
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    std::cout &lt;&lt; 5435122;
}</code></pre>
    <h2 id="%E9%A2%98%E4%BA%8C%3A%E5%8A%B2%E8%88%9E%E5%9B%A2%20-%20%E6%A8%A1%E6%8B%9F" name="%E9%A2%98%E4%BA%8C%3A%E5%8A%B2%E8%88%9E%E5%9B%A2%20-%20%E6%A8%A1%E6%8B%9F">
     题二:劲舞团 - 模拟
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19697/learning/" rel="nofollow" title="0劲舞团 - 蓝桥云课">
      0劲舞团 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     <span style="color:null">
      给你一些敲击记录，每一条敲击记录包含三个数据，分别是正确的字符，敲出的字符，毫秒时间戳。(其中时间戳保证从小到大排序)
     </span>
    </p>
    <p>
     <span style="color:null">
      现在定义一个K最大连击：在连续的K次敲击中，都不准有错误，并且每一个相邻的两次敲击时间小于等于1s。
     </span>
    </p>
    <p>
     <span style="color:null">
      请你找出这些敲击记录中K最大连击这个K的最大值
     </span>
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      模拟题，可以直接看代码理解
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      我们用一个cur来判断当前的连击次数，last 存上一个时间
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      首先判断此时是否是正确答案，也就是t == s
      <br/>
      如果是正确答案，我们就看上一个是否也是正确答案（我这里用last来判断）, 来更新cur
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      更新完后把last设置成此时的time
      <br/>
      <br/>
      如果不是正确答案，把last 变成-1
      <br/>
      <br/>
      每次判断完后更新cur的最大值即可
     </span>
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using i64 = long long;

int main() {
    char t, s;
    i64 time, last;
    
    int ans = 0, cur;
    
    while (std::cin &gt;&gt; t &gt;&gt; s &gt;&gt; time) {
        if (t == s) {
            if (last == -1) {
                last = time;
                cur = 1;
            } else {
                if (time - last &lt;= 1000) {
                    cur++;
                } else {
                    cur = 1;
                }
            }
            last = time;
        } else {
            last = -1;
        }
        ans = std::max(ans, cur);
    }

    std::cout &lt;&lt; ans;
}</code></pre>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-be191c, #f45154); color:#be191c">
      把log.txt的数据输出进去算出的是9然后输出9即为正确答案
     </span>
    </p>
    <h2 id="%E9%A2%98%E4%B8%89%3A%E6%95%B0%E5%AD%97%E8%AF%97%E6%84%8F%20-%20%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E" name="%E9%A2%98%E4%B8%89%3A%E6%95%B0%E5%AD%97%E8%AF%97%E6%84%8F%20-%20%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E" style="--darkreader-inline-bgcolor:transparent; background-color:transparent">
     题三:数字诗意 - 找规律，简单数学证明
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19714/learning/" rel="nofollow" title="0数字诗意 - 蓝桥云课">
      0数字诗意 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     定义一个数字：
     <br/>
     可以表示成
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      连续的(至少两个)正整数
     </span>
     相加，那么这个数字就是有诗意的
    </p>
    <p>
     例如：
    </p>
    <p>
     3 = 1 + 2
    </p>
    <p>
     5 = 2 + 3
    </p>
    <p>
     6 = 1 + 2 + 3
    </p>
    <p>
     7 = 3 + 4
    </p>
    <p>
     ....
    </p>
    <p>
     现在给你一n个数字，你需要删除其中的一些数字(可以为0)，使得剩下的数字全部是有诗意的
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      结论: 为2的若干幂次的数字没有诗意，1也没有诗意
     </span>
    </p>
    <p>
     <span style="color:null">
      直接列举可以猜出这个结论
     </span>
    </p>
    <p>
     <span style="color:null">
      严格证明的话，主要就是从等差数列求和公式出发证明
     </span>
    </p>
    <p>
     <span style="color:null">
      题解区有详细证明，这里就不写了（
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      然后问题就变成了，怎么判断一个数字是否是2的幂次
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      可以发现，如果一个数字是2的幂次，那么它一定可以一直除以2，直到为1
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      我们可以一直判断这个数字是否是偶数，如果是偶数，那么就除以2，最后判断是不是1就行
     </span>
    </p>
    <p>
     时间复杂度为O(n * log n)
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using i64 = long long;

bool check(i64 x) { //这里也要开long long
    while (x &gt; 0) {
        if (x % 2 == 0) {
            x /= 2;
        } else {
            break;
        }
    }
    return x == 1;
}

int main() {
    int n;
    std::cin &gt;&gt; n;

    int ans = 0;
    for (int i = 0; i &lt; n; i++) {
        i64 x; //注意题目范围得开long long
        std::cin &gt;&gt; x;
        if (check(x)) {
            ans++;
        }
    }
    
    std::cout &lt;&lt; ans;
}</code></pre>
    <h2 id="%E9%A2%98%E5%9B%9B%3A%E5%B0%81%E9%97%AD%E5%9B%BE%E5%BD%A2%E4%B8%AA%E6%95%B0%20-%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%20%2B%20%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F" name="%E9%A2%98%E5%9B%9B%3A%E5%B0%81%E9%97%AD%E5%9B%BE%E5%BD%A2%E4%B8%AA%E6%95%B0%20-%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%20%2B%20%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F">
     题四:封闭图形个数 - 自定义排序 + 简单模拟
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19733/learning/" rel="nofollow" title="0封闭图形个数 - 蓝桥云课">
      0封闭图形个数 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     题目定义4, 6, 9, 0分别有一个封闭图形 ， 8有两个封闭图形
    </p>
    <p>
     现在给你一个数组，你需要对数组里面的元素进行排序，一个数字所含的封闭图形总数小的排在前面，如果封闭图形个数相同，那么数字本身小的在前面
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
     我们先定义一个函数求出一个数字的封闭图形个数
    </p>
    <p>
     然后用自定义排序函数，根据题目意思模拟就行
    </p>
    <p>
     具体看代码
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;


int cal(int x) {
    int res = 0;
    while (x &gt; 0) {
        int cur = x % 10;
        if (cur == 8) {
            res += 2;
        }
        if (cur == 4 || cur == 6 || cur == 9 || cur == 0) {
            res++;
        }
        x /= 10;
    }
    return res;
}

int main() {
    int n;
    std::cin &gt;&gt; n;

    std::vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
        std::cin &gt;&gt; a[i];
    }

    std::sort(a.begin(), a.end(), [&amp;](int i, int j) {
        if (cal(i) == cal(j)) {
            return i &lt; j;
        }
        return cal(i) &lt; cal(j);
    });

    for (int i = 0; i &lt; n; i++) {
        std::cout &lt;&lt; a[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";
}</code></pre>
    <h2 id="%E9%A2%98%E4%BA%94%3A%20%E5%9B%9E%E6%96%87%E6%95%B0%E7%BB%84%20-%20%E8%B4%AA%E5%BF%83" name="%E9%A2%98%E4%BA%94%3A%20%E5%9B%9E%E6%96%87%E6%95%B0%E7%BB%84%20-%20%E8%B4%AA%E5%BF%83">
     题五: 回文数组 - 贪心
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19715/learning/" rel="nofollow" title="0回文数组 - 蓝桥云课">
      0回文数组 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     给你一个长度为n的数组，你需要让数组变成回文数组:
    </p>
    <p>
     每次操作，你可以从以下两个操作中选择一个进行：
    </p>
    <p>
     1.选择一个数字，让它加一或者减一
    </p>
    <p>
     2.选择两个相邻的数字，同时让他们加一或者减一
    </p>
    <p>
     现在请你输出把数组变成回文数组所需要的最小操作次数
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      关键点1：要使得数组为回文数组，我们只需要操作数组的左边边让其等于右半边即可
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      为了方便理解和计算，我们可以建立一个长度为n / 2的数组b，其中b[i] = a[i] - a[n - i - 1]
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      也就是原来数组与对称的一边的元素的差值
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      然后现在就变成了：我们需要通过操作使得这个数组b的所有值为0
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      贪心的想，要使得操作次数最小，我们需要进行更多的操作2，也就是对b数组中”同号“且”相邻“的元素进行操作
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      我们可以这样模拟这个操作过程：(具体可以看代码理解)
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      遍历数组b，不断检查相邻的两个元素
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      如果同号，那么就让绝对值小的那个为0，答案加上这个绝对值小的值，绝对值大的减去绝对值小的 （操作二）
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      如果不同号，那么就只把当前这个变成0即可 (操作一)
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      最后再遍历检查一遍，加上每个元素的绝对值 (也就是使用操作一)
     </span>
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using i64 = long long;

int main() {
    int n;
    std::cin &gt;&gt; n;

    std::vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
        std::cin &gt;&gt; a[i];
    }

    std::vector&lt;i64&gt; b(n / 2);
    for (int i = 0; i &lt; n / 2; i++) {
        b[i] = a[i] - a[n - i - 1];
    }

    i64 ans = 0;
    for (int i = 0; i &lt; n / 2 - 1; i++) {
        if (b[i] * b[i + 1] &gt; 0) {
            ans += std::min(abs(b[i]), abs(b[i + 1]));
            if (abs(b[i]) &lt; abs(b[i + 1])) {
                b[i + 1] -= b[i];
                b[i] = 0;
            } else {
                b[i] -= b[i + 1];
                b[i + 1] = 0;
            }
        } else {
            ans += abs(b[i]);
            b[i] = 0;
        }
    }

    for (int x : b) {
        ans += abs(x);
    }

    std::cout &lt;&lt; ans;
}</code></pre>
    <h2 id="%E9%A2%98%E5%85%AD%3A%E5%95%86%E5%93%81%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%20-%20%E5%B7%AE%E5%88%86" name="%E9%A2%98%E5%85%AD%3A%E5%95%86%E5%93%81%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%20-%20%E5%B7%AE%E5%88%86">
     题六:商品库存管理 - 差分 + 前缀和
    </h2>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      此题蓝桥官网的数据有问题，暴力O(n ^ m)也能过，这里讲差分写法
     </span>
    </p>
    <p>
     <a href="https://www.lanqiao.cn/problems/19716/learning/" rel="nofollow" title="0商品库存管理 - 蓝桥云课">
      0商品库存管理 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     题目可以这么理解：
    </p>
    <p>
     给你一个长度为n的数组，起初数组里面元素都为0, 再给你m个操作，每个操作为一个区间 [L, R]
    </p>
    <p>
     表示把这个区间内所有的元素都加1
    </p>
    <p>
     现在你需要做的是，对面m个操作中的每一个操作，如果不进行这个操作，那么最后数组中有多少个数字为0
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
     差分的原理可以参考：
     <br/>
     <a href="https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra/" rel="nofollow" title="1094. 拼车 - 力扣（LeetCode）">
      1094. 拼车 - 力扣（LeetCode）
     </a>
     <br/>
     <br/>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      关键点：我们先把所有的操作完成(可以用差分)，得到最终的数组，然后，其中一个操作不做表示把一段区间全部-1，我们只需要统计每段区间1的个数即可
     </span>
    </p>
    <p>
     可以用前缀和思想，快速的计算一段区间的1的个数
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; d(n + 1, 0); //差分数组,具体可以看链接的原理

    std::vector&lt;int&gt; l(m), r(m);
    for (int i = 0; i &lt; m; i++) {
        std::cin &gt;&gt; l[i] &gt;&gt; r[i];
        l[i]--;
        d[l[i]]++;
        d[r[i]]--;
    }

    std::vector&lt;int&gt; a(n, 0); //所有操作完后的数组
    a[0] = d[0];

    int tot = (a[0] == 0); //统计所有操作完还为0的个数
    for (int i = 1; i &lt; n; i++) {
        a[i] = a[i - 1] + d[i];//根据差分数组还原
        if (a[i] == 0) {
            tot++;
        }
    }

    std::vector&lt;int&gt; pref(n + 1, 0); //前缀和数组
    for (int i = 0; i &lt; n; i++) {
        pref[i + 1] = pref[i] + (a[i] == 1);
    }

    for (int i = 0; i &lt; m; i++) {
        std::cout &lt;&lt; pref[r[i]] - pref[l[i]] + tot &lt;&lt; "\n";
    }
}</code></pre>
    <p>
    </p>
    <h2 id="%E9%A2%98%E4%B8%83%3A%E6%8C%96%E7%9F%BF%20-%20%E6%8E%92%E5%BA%8F%20%2B%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20%2F%20%E5%89%8D%E7%BC%80%E5%92%8C" name="%E9%A2%98%E4%B8%83%3A%E6%8C%96%E7%9F%BF%20-%20%E6%8E%92%E5%BA%8F%20%2B%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20%2F%20%E5%89%8D%E7%BC%80%E5%92%8C">
     题七:挖矿 - 排序 + 二分查找 / 前缀和
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19717/learning/" rel="nofollow" title="0挖矿 - 蓝桥云课">
      0挖矿 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     现在有一条x轴，你位于坐标原点，现在有n个矿物都在x轴上，给出这n个矿物的横坐标，
    </p>
    <p>
     你现在最多可以移动m次，请问你在最多m次移动的情况下，能获得最多多少矿物
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <h3 id="%E6%96%B9%E6%B3%95%E4%B8%80%3A%20%E6%9E%9A%E4%B8%BE%E4%B8%80%E8%BE%B9%E9%80%89%E7%9A%84%E4%B8%AA%E6%95%B0%20%2B%20%E6%8E%92%E5%BA%8F%20%2B%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" name="%E6%96%B9%E6%B3%95%E4%B8%80%3A%20%E6%9E%9A%E4%B8%BE%E4%B8%80%E8%BE%B9%E9%80%89%E7%9A%84%E4%B8%AA%E6%95%B0%20%2B%20%E6%8E%92%E5%BA%8F%20%2B%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">
     方法一: 枚举一边选的个数 + 排序 + 二分查找
    </h3>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      我们把在右边的放在一个数组，把在左边的放在另一个数组，并且取绝对值
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      然后呢，
     </span>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      <strong>
       枚举选的个数
      </strong>
     </span>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      ：
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      左边选0个
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      左边选一个，然后剩下的选右边
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      左边选两个，然后剩下的选右边
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      ....
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      枚举完左边的，我们再枚举选右边的
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      右边选0个，剩下选左边的
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      右边选1个，剩下选右边的
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      ...
     </span>
     <br/>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      可以使用排序后，用二分查找快速查找
      <strong>
       剩下可以选择的个数
      </strong>
      <br/>
      具体过程可以看代码
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-8ceca4, #8af6a5); color:#8ceca4">
      时间复杂度，排序为O (n log n) , 枚举过程有二分，时间复杂度为O (n log n )
      <br/>
      总体的时间复杂度为O (n log n)
     </span>
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; a, b;
    for (int i = 0; i &lt; n; i++) {
        int v;
        std::cin &gt;&gt; v;
        if (v &gt; 0) {
            a.push_back(v);
        } else {
            b.push_back(abs(v));
        }
    }

    std::sort(a.begin(), a.end());
    std::sort(b.begin(), b.end());
    
    int ans = 0;
    for (int r = 0; r &lt;= a.size(); r++) {
        int cost;
        if (r == 0) {
            cost = 0;
        } else {
            cost = 2 * a[r - 1];
        }
        if (cost &gt; m) {
            break;
        }
        int l = std::upper_bound(b.begin(), b.end(), m - cost) - b.begin();
        ans = std::max(ans, l + r);
    }

    for (int l = 0; l &lt;= b.size(); l++) {
        int cost;
        if (l == 0) {
            cost = 0;
        } else {
            cost = 2 * b[l - 1];
        }
        if (cost &gt; m) {
            break;
        }
        int r = std::upper_bound(a.begin(), a.end(), m - cost) - a.begin();
        ans = std::max(ans, l + r);
    }

    std::cout &lt;&lt; ans;

}</code></pre>
    <h3 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%A7%BB%E5%8A%A8%E8%B7%9D%E7%A6%BB%C2%A0-%20%E5%89%8D%E7%BC%80%E5%92%8C" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%A7%BB%E5%8A%A8%E8%B7%9D%E7%A6%BB%C2%A0-%20%E5%89%8D%E7%BC%80%E5%92%8C">
     方法二：枚举移动距离 - 前缀和
    </h3>
    <p>
     此方法参考评论区题解
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      既然最大只能走m次，那么我们可以建立两个数组a, b，长度分别设置为(m + 1)，分别储存大于0和小于0的
      <strong>
       每个位置所包含的矿物数量
      </strong>
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      然后
     </span>
     <span style="--darkreader-inline-color:var(--darkreader-text-fe2c24, #ff3d36); color:#fe2c24">
      枚举移动距离
     </span>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      ：
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      左边走0步，剩下的走右边
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      左边走1步，剩下的走右边
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      ..
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      那么怎么快速判断这个步数下能获得的矿物数目呢？
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      前缀和数组 （代码中，直接把原数组变成前缀和数组了）
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      具体过程看代码
     </span>
    </p>
    <p>
     <span style="--darkreader-inline-color:var(--darkreader-text-1c7331, #8ceca4); color:#1c7331">
      时间复杂度o(n)
     </span>
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

int main() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    std::vector&lt;int&gt; a(m + 1), b(m + 1);

    for (int i = 0; i &lt; n; i++) {
        int v;
        std::cin &gt;&gt; v;
        if (abs(v) &lt;= m) {
            if (v &gt; 0) {
                a[v]++;
            } else {
                b[abs(v)]++;
            }
        }
    }

    for (int i = 1; i &lt; m + 1; i++) {
        a[i] += a[i - 1];
        b[i] += b[i - 1];
    }
    int ans = 0;
    for (int i = 0; i &lt; m; i++) {
        if (m - 2 * i &lt; 0) {
            break;
        }
        int mx = std::max(a[i] + b[m - 2 * i], b[i] + a[m - 2 * i]);
        ans = std::max(ans, mx);
    }
    
    std::cout &lt;&lt; ans;
}</code></pre>
    <h2 id="%E9%A2%98%E5%85%AB%3A%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20-%20%E5%8F%8C%E6%8C%87%E9%92%88" name="%E9%A2%98%E5%85%AB%3A%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20-%20%E5%8F%8C%E6%8C%87%E9%92%88">
     题八:回文字符串 - 双指针
    </h2>
    <p>
     <a href="https://www.lanqiao.cn/problems/19718/learning/" rel="nofollow" title="0回文字符串 - 蓝桥云课">
      0回文字符串 - 蓝桥云课
     </a>
    </p>
    <h3 id="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A" name="%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%3A">
     题目大意:
    </h3>
    <p>
     给你一个字符串，你可以往字符串开头添加任意数量的”l“, "g", "b"
    </p>
    <p>
     请问你是否可以使得字符串变成回文字符串
    </p>
    <h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" name="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">
     解题思路:
    </h3>
    <p>
    </p>
    <h3 id="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A" name="%E4%BB%A3%E7%A0%81(C%2B%2B)%3A">
     代码(C++):
    </h3>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333636393831332f:61727469636c652f64657461696c732f313436303030363432" class_="artid" style="display:none">
 </p>
</div>


