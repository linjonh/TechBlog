---
layout: post
title: "springboot知识点以及源码解析2"
date: 2025-03-08 01:39:33 +0800
description: "springboot对静态资源的映射规则：在类路径下面定义目录static或public或resources或者META-INF/resources，访问时项目根目录+静态资源的名称在springboot中，如果项目中存在同名的静态资源和同名的动态资源。那么我们会优先去访问动态资源，如果动态资源不存在，然后再去访问对应的静态资源，如果静态资源也找不到，那么就报404 的异常 ，为了解决这个问题。"
keywords: "springboot知识点以及源码解析（2）"
categories: ['Javaee']
tags: ['Spring', 'Spring', 'Java', 'Boot']
artid: "146101687"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146101687
    alt: "springboot知识点以及源码解析2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146101687
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146101687
cover: https://bing.ee123.net/img/rand?artid=146101687
image: https://bing.ee123.net/img/rand?artid=146101687
img: https://bing.ee123.net/img/rand?artid=146101687
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     springboot知识点以及源码解析（2）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     web开发--静态规则与定制化
    </h2>
    <p>
     springboot对静态资源的映射规则：在类路径下面定义目录static或public或resources或者META-INF/resources，访问时项目根目录+静态资源的名称
    </p>
    <p>
     <img alt="" height="199" src="https://i-blog.csdnimg.cn/direct/c961cf1cb99d4866941234cf3c3ef042.png" width="672"/>
    </p>
    <p>
     在springboot中，如果项目中存在同名的静态资源和同名的动态资源。那么我们会优先去访问动态资源，如果动态资源不存在，然后再去访问对应的静态资源，如果静态资源也找不到，那么就报404 的异常 ，为了解决这个问题。
    </p>
    <ol>
     <li>
      可以在配置文件中自定义静态资源的映射规则，例如：spring.mvc.static-path-pattern=/resources/**，那么访问静态资源时根目录+resources+静态资源名称。
     </li>
     <li>
      也可以给静态资源设置自定义的存放目录:例如spring:web:resourcesstatic-locations:[classpath:/hello/]，那么在资源下创建hello这个文件夹，下面放静态资源
     </li>
     <li>
      我们也可以访问webjars的资源(webjars 就是将静态资源打成jar包。)
      <br/>
      1、引入相关静态资源的jar包(依赖)
      <br/>
      &lt;dependency&gt;
      <br/>
      &lt;groupId&gt;org.webjars&lt;/groupId&gt;
      <br/>
      &lt;artifactId&gt;jquery&lt;/artifactId)
      <br/>
      &lt;version&gt;3.5.1&lt;/version&gt;
      <br/>
      &lt;/dependency&gt;
      <br/>
      2、通过官方给定的访问路径去访问里面的资源
      <br/>
      http://localhost:8082/webjars/jquery/3.5.1/jquery.js
     </li>
    </ol>
    <hr/>
    <h2>
     静态资源和首页映射规则底层原理
    </h2>
    <h3>
     源码
    </h3>
    <p>
     webMvcAutoConfiguration底层是如何进行装配的。在org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration中的注解
    </p>
    <p>
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/direct/86cc84cc931e4733a439cb85995c2396.png" width="1113"/>
    </p>
    <p>
     在这个类中，主要看WebMvcAutoConfigurationAdapter，是WebMvc自动配置的适配器，
     <br/>
     <img alt="" height="480" src="https://i-blog.csdnimg.cn/direct/7f6391f6bc3e4948b1684fa82ff25430.png" width="1105"/>
    </p>
    <p>
     看下面的这个方法 WebMvcAutoConfigurationAdapter，它是一个构造方法，参数从哪里来？
    </p>
    <pre><code class="language-java">public WebMvcAutoConfigurationAdapter(WebProperties webProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) {
            this.resourceProperties = webProperties.getResources();
            this.mvcProperties = mvcProperties;
            this.beanFactory = beanFactory;
            this.messageConvertersProvider = messageConvertersProvider;
            this.resourceHandlerRegistrationCustomizer = (ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
            this.dispatcherServletPath = dispatcherServletPath;
            this.servletRegistrations = servletRegistrations;
        }</code></pre>
    <ul>
     <li>
      <strong>
       WebProperties 和 WebMvcProperties：
      </strong>
      被SpringBoot自动创建并填充到配置文件中，通过@EnableConfigurationProperties注解进行引入，上面图片可以看到
     </li>
     <li>
      <p>
       <strong>
        ListableBeanFactory
       </strong>
       : 代表了一个可以列出所有已注册bean定义的bean工厂。它是Spring IoC容器的一部分，不需要特别指定，Spring会
       <strong>
        自动
       </strong>
       将其传递给需要它的bean。
      </p>
     </li>
     <li>
      <p>
       <strong>
        ObjectProvider&lt;HttpMessageConverters&gt; 和 ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt;
       </strong>
       : 这两个
       <code>
        ObjectProvider
       </code>
       是用来延迟加载特定类型的bean的。如果Spring上下文中存在类型为
       <code>
        HttpMessageConverters
       </code>
       或
       <code>
        ResourceHandlerRegistrationCustomizer
       </code>
       的bean，那么它们就会被注入到这里。如果没有找到匹配的bean，也不会导致错误，因为
       <code>
        ObjectProvider
       </code>
       支持可选的依赖项
      </p>
     </li>
     <li>
      <p>
       <strong>
        ObjectProvider&lt;DispatcherServletPath&gt; 和 ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt;
       </strong>
       : 类似地，这两个也是
       <code>
        ObjectProvider
       </code>
       实例，用于提供对
       <code>
        DispatcherServlet
       </code>
       路径和
       <code>
        ServletRegistrationBean
       </code>
       的访问。如果有相应的bean存在于上下文中，它们将会被注入。
      </p>
     </li>
    </ul>
    <p>
     那么适配器初始化这些信息后，那么静态资源是如何生效的？
    </p>
    <h3>
     静态资源是如何生效的
    </h3>
    <p>
     在这个类（
    </p>
    <pre>public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware 
</pre>
    <p>
     ）下，有一个addResourceHandlers方法,下面进行图解。
     <br/>
     <img alt="" height="841" src="https://i-blog.csdnimg.cn/direct/e668761492264733aa0063802fa046d4.png" width="1645"/>
    </p>
    <p>
     也可以点进去，可以得到
    </p>
    <h3>
     <img alt="" height="384" src="https://i-blog.csdnimg.cn/direct/24c0a940a11e4ceabe9a7e4e213f0b83.png" width="1297">
      欢迎页
     </img>
    </h3>
    <p>
     在WelcomePageHandlerMapping类下的WelcomePageHandlerMapping方法中
    </p>
    <pre><code class="language-java">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Resource indexHtmlResource, String staticPathPattern) {
    this.setOrder(2); // 优先级为 2。
    // 确定是否有可用的欢迎页面
    WelcomePage welcomePage = WelcomePage.resolve(templateAvailabilityProviders, applicationContext, indexHtmlResource, staticPathPattern);

    if (welcomePage != WelcomePage.UNRESOLVED) { // 如果找到了欢迎页面
        // 根据欢迎页面是否为模板，记录日志
        logger.info(LogMessage.of(() -&gt; {
            return !welcomePage.isTemplated() ? "Adding welcome page: " + String.valueOf(indexHtmlResource) : "Adding welcome page template: index";
        }));
        
        // 创建一个新的实例，可以指定视图名称
        ParameterizableViewController controller = new ParameterizableViewController();
        
        // 设置控制器的视图名称为欢迎页面的视图名称
        controller.setViewName(welcomePage.getViewName());
        
        // 将创建的控制器设置为此 HandlerMapping 的根处理器
        this.setRootHandler(controller);
    }
}</code></pre>
    <h2>
     springboot中rest请求处理原理
    </h2>
    <pre><code class="language-java">@RestController
public class HelloController {

    @RequestMapping(value = "/hello",method = RequestMethod.GET)
    public String sayHello(){
        return "Hello World!";
    }
}</code></pre>
    <p>
     在非 REST 风格的传统代码中，为了执行数据的增删改查操作，通常需要将每个操作映射到不同的路径上。然而，采用 REST 风格后，可以使用相同的路径来表示同一个资源，并通过不同的 HTTP 方法（如
     <code>
      POST
     </code>
     用于创建，
     <code>
      GET
     </code>
     用于查询，
     <code>
      PUT
     </code>
     或
     <code>
      PATCH
     </code>
     用于更新，以及
     <code>
      DELETE
     </code>
     用于删除）来区分这些操作。这样，我们就可以通过单一的端点路径结合适当的请求方法来管理资源，从而提高 API 的清晰度和可维护性。例如，在 Spring MVC 中，你可以通过
     <code>
      @RequestMapping
     </code>
     注解的
     <code>
      method
     </code>
     属性指定支持的 HTTP 方法类型，或者直接使用简化的组合注解如
     <code>
      @GetMapping
     </code>
     ,
     <code>
      @PostMapping
     </code>
     ,
     <code>
      @PutMapping
     </code>
     , 和
     <code>
      @DeleteMapping
     </code>
     来实现这一点。同时，
     <code>
      @RequestMapping
     </code>
     注解中的
     <code>
      path
     </code>
     和
     <code>
      value
     </code>
     属性互为别名，都可以用来指定请求路径。这样的设计有助于构建更加简洁、一致的服务接口。
    </p>
    <pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping(value = "user",method = RequestMethod.GET)
    public String get(){
        return "Hello User Get!";
    }

    @RequestMapping(value = "user",method = RequestMethod.POST)
    public String post(){
        return "Hello User Post!";
    }

    @RequestMapping(value = "user",method = RequestMethod.PUT)
    public String put(){
        return "Hello User Put!";
    }

    @RequestMapping(value = "user",method = RequestMethod.DELETE)
    public String delete(){
        return "Hello User Delete!";
    }
}

// demo1.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action="/user" method="get"&gt;
        &lt;input value="GET提交" type="submit"&gt;
    &lt;/form&gt;

    &lt;form action="/user" method="post"&gt;
        &lt;input value="Post提交" type="submit"&gt;
    &lt;/form&gt;

    &lt;form action="/user" method="post"&gt;
        &lt;input value="Put提交" type="submit"&gt;
    &lt;/form&gt;

    &lt;form action="/user" method="post"&gt;
        &lt;input value="Delete提交" type="submit"&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
    <p>
     由于表单中只能由get和post，没有put和delete,因此它们用post进行代替。设想点击不同的按钮进入不同的表单页，显示不同的值，是这样吗？来看下结果，结果显示：对于get和post提交是正常的，但是对于put和delete提交显示的是Hello User Post！这是由于表单中只能由get和post，为了弄清楚它，回到D:\java\mvn_repository\org\springframework\boot\spring-boot-autoconfigure\3.4.3\spring-boot-autoconfigure-3.4.3.jar!\org\springframework\boot\autoconfigure\web\servlet\这个路径下的WebMvcAutoConfiguration.class类中。过滤器默认不开启，开启需要添加配置文件
    </p>
    <p>
     <img alt="" height="613" src="https://i-blog.csdnimg.cn/direct/2ecfc4e221d44e72bb89b3ec3df8134e.png" width="1203"/>
    </p>
    <p>
     在HiddenHttpMethodFilter中，有一个doFilterInternal方法，
    </p>
    <p>
     进行debug，先发送get请求，进不到if,执行filterChain.doFilter((ServletRequest)requestToUse, response);进行放行
     <img alt="" height="533" src="https://i-blog.csdnimg.cn/direct/f8c2ce38e90b40ed972bf459f54cc012.png" width="1343"/>
    </p>
    <p>
     <img alt="" height="176" src="https://i-blog.csdnimg.cn/direct/d87267460fff421796e4f3921e94f9ea.png" width="948">
      下面看下post请求，其中this.methodParam是一个_method参数，需要在html文件中进行配置
     </img>
    </p>
    <p>
     <img alt="" height="573" src="https://i-blog.csdnimg.cn/direct/8efbaf98e9dd48b79be10a7b22466f0c.png" width="1661"/>
    </p>
    <p>
     下面看下加上_method的put请求，delete同理
    </p>
    <p>
     <img alt="" height="614" src="https://i-blog.csdnimg.cn/direct/7101d13123ca429592ea942b655c847f.png" width="1427"/>
     注意：下面两者等价
    </p>
    <pre>@RequestMapping(value = "user",method = RequestMethod.GET)
@GetMapping("user")</pre>
    <h2>
     springboot处理器映射器工作原理
    </h2>
    <p>
     在SpringMVC中有一个组件DispatcherServlet，在DispatcherServlet.class这个类下，它是用于处理前端用户的请求。体系结构如下：
    </p>
    <p>
     <img alt="" height="278" src="https://i-blog.csdnimg.cn/direct/1e5f642b2aa4498789a81c3e2a49c0cd.png" width="707"/>
    </p>
    <p>
     进入FrameworkServlet中，有doGet，doPost，doPut和doDelete，它们四个处理Http请求,这四个方法都调用了processRequest方法，在processRequest方法中，首先进行一些初始化，然后在doService方法中提供服务，doService方法中又有doDispatch方法，这个方法中关注这句话：mappedHandler = this.getHandler(processedRequest);
    </p>
    <p>
     <img alt="" height="633" src="https://i-blog.csdnimg.cn/direct/ed120af094a440e19a0d162d83cdb68e.png" width="1131"/>
    </p>
    <p>
     <img alt="" height="600" src="https://i-blog.csdnimg.cn/direct/fa14c8f694714aae9525c14996ab8c15.png" width="1739"/>
     <img alt="" height="771" src="https://i-blog.csdnimg.cn/direct/d982e513d5de45b2a63ba79b58b0e825.png" width="963"/>
    </p>
    <p>
     <img alt="" height="530" src="https://i-blog.csdnimg.cn/direct/4a560098a72e412d872e3d7372e3a40b.png" width="1461"/>
    </p>
    <p>
     如果是不大于1的话：
    </p>
    <p>
     <img alt="" height="167" src="https://i-blog.csdnimg.cn/direct/979c8b023a384b01a57bb53b328f4002.png" width="1167"/>
    </p>
    <p>
     总结：用户的请求交给DispatcherServlet前端控制器中的doDispatch方法进行处理，其中被doDispath方法中的getHandler获取想要的handler对象，这个handler对象被包装到HandlerExecutionChain里面。那么handler如何被获取？mappedHandler=this.getHandler(processedRequest)方法帮助处理，this.getHandler内部，有5个映射器，RequestMappingHandlerMapping处理被@RequestMapping注解修饰的处理器方法，返回一个handler。这个handler最终交给处理器适配器进行处理。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393938353735302f:61727469636c652f64657461696c732f313436313031363837" class_="artid" style="display:none">
 </p>
</div>


