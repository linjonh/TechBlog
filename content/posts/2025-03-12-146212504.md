---
layout: post
title: "FPGA初级项目9基于SPI的ADC芯片进行模数转换"
date: 2025-03-12 19:46:06 +0800
description: "利用基于SPI的ADC芯片进行模数转换，使用Verilog撰写其驱动电路代码，附有关于ADC芯片，SPI，以及编写原理的详细讲解与源代码！！"
keywords: "spi接口外部adc芯片怎么用"
categories: ['未分类']
tags: ['经验分享', '嵌入式硬件', '学习', 'Fpga', 'Fpga']
artid: "146212504"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146212504
    alt: "FPGA初级项目9基于SPI的ADC芯片进行模数转换"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146212504
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146212504
cover: https://bing.ee123.net/img/rand?artid=146212504
image: https://bing.ee123.net/img/rand?artid=146212504
img: https://bing.ee123.net/img/rand?artid=146212504
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     FPGA初级项目9——基于SPI的ADC芯片进行模数转换
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="text-align:center">
     FPGA初级项目9——基于SPI的ADC芯片进行模数转换
    </h2>
    <p>
    </p>
    <h3>
     ADC芯片介绍
    </h3>
    <p>
     <br/>
     ADC（Analog-to-Digital Converter）芯片是一种
     <strong>
      将连续变化的模拟信号转换为离散数字信号
     </strong>
     的电子器件，广泛应用于电子系统中，是连接现实世界与数字世界的桥梁。可将电压、电流等模拟量转换为二进制数字信号，供计算机、微控制器等数字设备处理。
    </p>
    <h4>
     关键参数
    </h4>
    <p>
     <br/>
     <strong>
      分辨率：
     </strong>
     以位数表示（如 12 位、16 位）
     <strong>
      表示将一个模拟量转换为多少位的数字量
     </strong>
     ，例如8位分辨率可表示的范围为0~255（十进制）。
     <br/>
     <strong>
      采样率：
     </strong>
     每秒转换的样本数（单位 Hz），需满足 Nyquist 定理（至少 2 倍信号最高频率）。
     <br/>
     <strong>
      转换精度：
     </strong>
     实际输出与理论值的偏差，受噪声、非线性等因素影响。
     <br/>
     <strong>
      输入范围：
     </strong>
     可转换的模拟信号电压范围（如 0~5V、±10V）。
     <br/>
     <strong>
      功耗：
     </strong>
     低功耗设计适用于电池供电设备
     <br/>
    </p>
    <p class="img-center">
     <img alt="" height="216" src="https://i-blog.csdnimg.cn/direct/91cab086b1a1437baa7ae801cee915f7.png" width="332"/>
    </p>
    <p>
    </p>
    <hr/>
    <h3>
     SPI 协议基础
    </h3>
    <p>
     <br/>
     SPI（Serial Peripheral Interface，串行外设接口）是一种高速、全双工、同步的
     <strong>
      通信协议
     </strong>
     （是一种规则），广泛用于微控制器（如 Arduino、STM32）与外设（如 ADC、传感器、存储器）之间的短距离通信。
    </p>
    <p class="img-center">
     <img alt="" height="329" src="https://i-blog.csdnimg.cn/direct/5a4f3357ae9a4c248e819c59f5a049c7.png" width="543"/>
    </p>
    <h4>
     <br/>
     SPI由来
    </h4>
    <p>
     SPI最初由摩托罗拉（现 NXP）于 1980 年代开发，并未通过 ISO、IEEE 等国际组织的正式认证。但由于其简单高效，
     <strong>
      逐渐成为事实上的工业标准，被全球半导体厂商（如 ADI、TI、Microchip）广泛支持
     </strong>
     。
     <strong>
      主流 MCU（如 Arduino、STM32、ESP32）均内置硬件 SPI 控制器，且 ADC、传感器等外设芯片的 SPI 接口严格遵循摩托罗拉定义的时序规则。
     </strong>
     这种生态共识使 SPI 成为嵌入式领域的 “通用语言”。
    </p>
    <h4>
     SPI参数
    </h4>
    <p>
     <strong>
      主从架构
     </strong>
     ：一个主设备（如 MCU或FPGA）控制多个从设备（如 ADC 芯片）。
     <br/>
     <strong>
      四线通信
     </strong>
     ：
     <br/>
     SCK（时钟线）：主设备发送时钟信号，同步数据传输。
     <br/>
     MOSI（主出从入）：主设备向从设备发送数据。
     <br/>
     MISO（主入从出）：从设备向主设备返回数据。
     <br/>
     CS（片选线）：主设备通过拉低特定从设备的 CS 线选择目标。
     <br/>
     <strong>
      高速传输
     </strong>
     ：支持兆赫兹级速率（如 STM32 可达 42MHz），适合高频数据场景。
     <br/>
     <strong>
      全双工
     </strong>
     ：数据可同时双向传输。
    </p>
    <h4>
     SPI规则
    </h4>
    <p>
     <br/>
     <img alt="" height="629" src="https://i-blog.csdnimg.cn/direct/39e8a6df39be402ba32624445c81a019.png" width="1054"/>
    </p>
    <p>
    </p>
    <h4>
     SPI怎么用，需要自己编写吗？
    </h4>
    <p>
     <strong>
      需要强调的是：是否需要自己编写 SPI 逻辑代码，取决于你使用的开发环境、硬件平台以及具体需求。
     </strong>
     <br/>
     1. 有些较为基础、低成本的微控制器可能没有内置 SPI 硬件模块，例如一些简单的 8 位单片机。在这种情况下，你只能通过软件来模拟 SPI 的通信逻辑，也就是自己编写代码来控制通用输入输出引脚（GPIO），模拟时钟信号（SCK）、数据传输（MOSI 和 MISO）以及片选信号（CS）的时序。
     <br/>
     2. 当
     <span style="color:#e6b223">
      你有特殊的通信需求，比如需要修改 SPI 的通信时序、协议格式，或者实现一些自定义的通信规则时，就可能需要自己编写 SPI 逻辑代码。
     </span>
     例如，你可能需要调整时钟极性（CPOL）和时钟相位（CPHA）来满足特定 ADC 芯片的通信要求。
     <br/>
     3. 大多数现代微控制器，如常见的 STM32 系列、Arduino 的部分型号等，都内置了 SPI 硬件外设。这些硬件外设可以直接配置和使用，芯片厂商通常会提供相应的库函数来简化 SPI 通信的操作。
    </p>
    <hr/>
    <h3>
     <br/>
     工作原理
    </h3>
    <p>
     <br/>
     ADC 芯片通过 SPI 接口接收主设备的控制指令（如启动转换、配置参数），并将转换后的数字信号通过 SPI 返回给主设备。
     <strong>
      我们需要完成的任务即ADC芯片的驱动逻辑，依照芯片手册实现其逻辑代码编写（严格遵循SPI协议）。
     </strong>
    </p>
    <p>
    </p>
    <h3>
     问题分析
    </h3>
    <p>
     <br/>
     <strong>
      1.
     </strong>
     我们需要编写的是芯片ADC128S102的驱动逻辑，有
     <strong>
      4个主要端口：
     </strong>
     cs_n(片选端); sclk(ADC芯片时钟); DIN(模拟量输入端口); DOUT(数字量输出端口); 根据芯片手册要满足其时序要求。其中SCLK频率为12.5HZ。
     <br/>
     <img alt="" height="1006" src="https://i-blog.csdnimg.cn/direct/e7df81e810ee4880b93173af60c2bc9d.png" width="2311"/>
    </p>
    <p>
     <br/>
    </p>
    <p>
     <strong>
      2.
     </strong>
     我们依旧使用
     <strong>
      线性序列机（LSM）
     </strong>
     的思想来定义每个时刻该做的事情。
     <strong>
      以SCLK半个周期为最小时间单元。
     </strong>
     DOUT端口靠ADC芯片来驱动，FPGA端来接收。每个输出的数据信号在SCLK下降沿改变，同时FPGA在SCLK上升沿读取（此时信号已稳定）；而DIN信号决定ADC芯片的哪个通道输入，在SCLK下降沿FPGA将信号输入到ADC芯片。
     <strong>
      详细参数可参照文末代码！
     </strong>
     <br/>
     <img alt="" height="706" src="https://i-blog.csdnimg.cn/direct/e68eac160fd14bacaf4b054dc58f75b1.png" width="2113"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      3.
     </strong>
     同时还有一些额外的端口需要设置，例如用户的通道选择输入端口[2:0]addr（因ADC芯片有8个选择输入端口，所以需要3位来表示）；数字数据输出端口[11:0](因芯片为12位分辨率)；采样信号（决定什么时候采样）与采样完成信号端口的设置等。
     <br/>
     <img alt="" height="378" src="https://i-blog.csdnimg.cn/direct/987884069b454428b69142a3fbf4fe96.png" width="1065"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      4.
     </strong>
     根据芯片时序手册，处理完一轮数据周期需要35个时钟，所以counter1的计数最大值为35，即需要6位二进制数来表示，所以为[5:0]counter1。ADC芯片的电路结构如下所示可作为了解，
     <strong>
      但是我们需要再次强调我们所写的是该芯片的驱动电路！！！
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="293" src="https://i-blog.csdnimg.cn/direct/6e59b2d7c0c5432c9a15767547d7a42c.png" width="449"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      <span style="color:#f9eda6">
       好的分析完上述问题，我们上代码
      </span>
     </strong>
    </p>
    <hr/>
    <h3>
     代码展示
    </h3>
    <p>
    </p>
    <pre><code class="hljs">//定义输入输出端口
module ADC_driver(
        clk,
        reset_n,
        conv_go,//采样请求信号
        addr,//用户输入选择通道端口
        conv_done,//采样完成信号
        data,//已经转换完成的数字信号
        
        sclk,
        cs_n,
        DOUT,
        DIN
    );
        input clk;
        input reset_n;
        input conv_go;
        input [2:0]addr;
        output reg conv_done;
        output reg [11:0]data;
        
        output reg sclk;
        output reg cs_n;
        output reg DIN;
        input DOUT;
        
 //定义相关时钟参数
        parameter clock_freq = 50_000_000;
        parameter sclk_freq = 12_500_000;//ADC芯片SCLK频率
        parameter mcnt = clock_freq / (sclk_freq * 2) - 1;
     
       
        
//定义最小时间单元counter0
        reg en_counter0;
        reg [7:0]counter0;
always@(posedge clk or negedge reset_n)
if(!reset_n)
        counter0 &lt;= 0;
else if(en_counter0) begin
        if(counter0 == mcnt)
        counter0 &lt;= 0;
        else 
        counter0 &lt;= counter0 +1'd1;
        end
else
        counter0 &lt;= 0;
        
        
//定义位计数器counter1
        reg [5:0]counter1;
always@(posedge clk or negedge reset_n)
if(!reset_n)
        counter1 &lt;= 6'd0;
else if(counter0 == mcnt) begin
        if(counter1 == 6'd34)//处理完一轮数据需要35个周期时钟
        counter1 &lt;= 6'd0;
        else
        counter1 &lt;= counter1 + 1'd1;
        end
else
        counter1 &lt;= counter1;
        
 
 //定义存储器，防止数据发生变化
        reg [2:0]r_addr;
always@(posedge clk)
if(conv_go)
        r_addr &lt;= addr;
else
        r_addr &lt;= r_addr;
        
 
 //定义数据处理完成信号与处理后的数据存贮
        reg [11:0]data_r;
always@(posedge clk or negedge reset_n)
if(!reset_n) begin
        data &lt;= 12'd0;
        conv_done &lt;= 0;
        end
else if((counter1 == 34)&amp;&amp;(counter0 == mcnt)) begin
        data &lt;= data_r;
        conv_done &lt;= 1'd1;
        end
else begin
        data &lt;= data;
        conv_done &lt;= 0;
        end
       
        
//定义使能信号en_counter0
always@(posedge clk or negedge reset_n)
if(!reset_n) 
        en_counter0 &lt;= 1'd0;
else if(conv_go)
        en_counter0 &lt;= 1'd1;
else if((counter1 == 34)&amp;&amp;(counter0 == mcnt))
        en_counter0 &lt;= 1'd0;
else
        en_counter0 &lt;= en_counter0;               
        

        
//定义每个时间点的操作,按照时序图来填表即可
always@(posedge clk or negedge reset_n)
if(!reset_n)begin
   data_r &lt;= 12'd0;
   sclk &lt;= 1'd1;
   DIN &lt;= 1'd1;
   cs_n &lt;= 1'd1;
   end
else if(counter0 == mcnt)begin
  case(counter1)
  0:begin cs_n &lt;= 1'd1; sclk &lt;= 1'd1; end
  1:begin sclk &lt;= 1'd0; end
  2:begin sclk &lt;= 1'd0; end
  3:begin sclk &lt;= 1'd1; end
  4:begin sclk &lt;= 1'd0; end
  5:begin sclk &lt;= 1'd1; end
  6:begin sclk &lt;= 1'd0; DIN &lt;= r_addr[2];end
  7:begin sclk &lt;= 1'd1; end
  8:begin sclk &lt;= 1'd0; DIN &lt;= r_addr[21];end
  9:begin sclk &lt;= 1'd1; end
  10:begin sclk &lt;= 1'd0; DIN &lt;= r_addr[0];end
  11:begin sclk &lt;= 1'd1; data_r[11] &lt;= DOUT;end
  12:begin sclk &lt;= 1'd0; end
  13:begin sclk &lt;= 1'd1; data_r[10] &lt;= DOUT;end
  14:begin sclk &lt;= 1'd0; end
  15:begin sclk &lt;= 1'd1; data_r[9] &lt;= DOUT;end
  16:begin sclk &lt;= 1'd0; end
  17:begin sclk &lt;= 1'd1; data_r[8] &lt;= DOUT;end
  18:begin sclk &lt;= 1'd0; end
  19:begin sclk &lt;= 1'd1; data_r[7] &lt;= DOUT;end
  20:begin sclk &lt;= 1'd0; end
  21:begin sclk &lt;= 1'd1; data_r[6] &lt;= DOUT;end
  22:begin sclk &lt;= 1'd0; end
  23:begin sclk &lt;= 1'd1; data_r[5] &lt;= DOUT;end
  24:begin sclk &lt;= 1'd0; end
  25:begin sclk &lt;= 1'd1; data_r[4] &lt;= DOUT;end
  26:begin sclk &lt;= 1'd0; end
  27:begin sclk &lt;= 1'd1; data_r[3] &lt;= DOUT;end
  28:begin sclk &lt;= 1'd0; end
  29:begin sclk &lt;= 1'd1; data_r[2] &lt;= DOUT;end
  30:begin sclk &lt;= 1'd0; end
  31:begin sclk &lt;= 1'd1; data_r[1] &lt;= DOUT;end
  32:begin sclk &lt;= 1'd0; end
  33:begin sclk &lt;= 1'd1; data_r[0] &lt;= DOUT;end
  34:begin sclk &lt;= 1'd0; end
  default: cs_n &lt;= 1'd1;
  endcase
end

        
endmodule
</code></pre>
    <p>
     <br/>
     <strong>
      综合出来的底层系统逻辑图schematic如下：
     </strong>
     <br/>
    </p>
    <p>
     <img alt="" height="427" src="https://i-blog.csdnimg.cn/direct/e0495de2567f4589a0dd27e073e4a164.png" width="1224"/>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36373430303137362f:61727469636c652f64657461696c732f313436323132353034" class_="artid" style="display:none">
 </p>
</div>


