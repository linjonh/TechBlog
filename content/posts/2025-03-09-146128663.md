---
layout: post
title: "解决-Linux-Bash-终端卡顿问题PROMPT_COMMAND-与日志记录的性能优化"
date: 2025-03-09 11:14:46 +0800
description: "通过以上步骤，可以彻底解决因 `PROMPT_COMMAND` 日志记录导致的终端卡顿问题，并确保配置在重新登录后依然生效。如果你有其他问题或更好的解决方案，欢迎在评论区分享！"
keywords: "解决 Linux Bash 终端卡顿问题：`PROMPT_COMMAND` 与日志记录的性能优化"
categories: ['未分类']
tags: ['性能优化', 'Ssh', 'Linux']
artid: "146128663"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146128663
    alt: "解决-Linux-Bash-终端卡顿问题PROMPT_COMMAND-与日志记录的性能优化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146128663
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146128663
cover: https://bing.ee123.net/img/rand?artid=146128663
image: https://bing.ee123.net/img/rand?artid=146128663
img: https://bing.ee123.net/img/rand?artid=146128663
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     解决 Linux Bash 终端卡顿问题：`PROMPT_COMMAND` 与日志记录的性能优化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     在使用 Linux 系统时，你是否遇到过以下问题？
    </h2>
    <p>
     - 在 Bash 终端中输入内容时，字符不显示。
     <br/>
     - 按下回车键后，光标不换行。
     <br/>
     - 终端响应卡顿，输入命令后需要等待较长时间才能看到结果。
    </p>
    <p>
     这些问题通常与终端的配置或系统日志记录有关。本文将详细分析问题的原因，并提供一步步的解决方案。
    </p>
    <p>
     ---
    </p>
    <h2>
     问题原因
    </h2>
    <p>
     通过排查，我们发现问题的根源是 `PROMPT_COMMAND` 环境变量的配置。`PROMPT_COMMAND` 用于在每次命令执行后执行特定的操作。在某些系统中，`PROMPT_COMMAND` 被配置为使用 `logger` 命令将每条命令记录到系统日志中。例如：
    </p>
    <pre><code class="language-bash">
export PROMPT_COMMAND='{ command=$(history 1 | { read x y; echo $y; }); logger -p local1.notice -t bash -i "user=$USER,ppid=$PPID,from=$SSH_CLIENT,pwd=$PWD,command:$command"; }'
</code></pre>
    <p>
     这种配置会导致以下问题：
     <br/>
     1. **性能瓶颈**：每次执行命令时都会调用 `logger`，如果日志服务（如 `rsyslog`）性能较差，会导致终端卡顿。
     <br/>
     2. **网络延迟**：如果通过 SSH 连接远程服务器，且日志记录到远程日志服务器，网络延迟会进一步加剧卡顿。
     <br/>
     3. **日志轮转问题**：如果日志文件过大或日志轮转配置不当，也会影响性能。
    </p>
    <p>
     ---
    </p>
    <h2>
     排查思路
    </h2>
    <p>
     ### **1. 检查终端状态**
     <br/>
     - **现象**：输入不显示、回车不换行。
     <br/>
     - **可能原因**：终端状态被某些程序修改（如回显关闭、换行处理异常）。
     <br/>
     - **排查方法**：
    </p>
    <h3>
     <br/>
     <strong>
      1. 使用 `stty -a` 检查终端设置：
     </strong>
     <br/>
    </h3>
    <pre><code class="language-bash">  stty -a</code></pre>
    <p>
     关注以下关键设置：
     <br/>
     - `echo`：输入是否回显。
     <br/>
     - `icrnl`：回车是否转换为换行。
     <br/>
     - `icanon`：是否启用规范模式。
     <br/>
     2. 重置终端状态：
    </p>
    <pre><code class="language-bash">      stty sane</code></pre>
    <h3>
     2. 检查 `PROMPT_COMMAND` 配置
    </h3>
    <p>
     - **现象**：终端卡顿，尤其是输入命令后。
     <br/>
     - **可能原因**：`PROMPT_COMMAND` 配置中使用了 `logger` 命令记录日志，导致性能问题。
     <br/>
     - **排查方法**：
     <br/>
     1. 查找 `PROMPT_COMMAND` 的配置来源：
    </p>
    <pre><code class="language-bash">grep -r "PROMPT_COMMAND" /etc/profile /etc/bashrc /etc/profile.d/ ~/.bashrc ~/.bash_profile ~/.profile</code></pre>
    <p>
     2. 检查配置内容，确认是否包含 `logger` 命令。
    </p>
    <h3>
     3. 测试 `logger` 性能
    </h3>
    <p>
     - **现象**：`logger` 执行缓慢，导致终端卡顿。
     <br/>
     - **可能原因**：日志服务（如 `rsyslog`）性能问题或网络延迟。
     <br/>
     - **排查方法**：
     <br/>
     1. 测试 `logger` 执行时间：
     <br/>
    </p>
    <pre><code class="language-bash"> time logger "test log message"</code></pre>
    <p>
     2. 对比正常主机的执行时间，确认是否存在延迟。
    </p>
    <p>
    </p>
    <h3>
     4. 检查日志服务状态
    </h3>
    <p>
     <br/>
     - **现象**：日志服务异常，导致 `logger` 执行缓慢。
     <br/>
     - **可能原因**：日志服务未运行、配置错误或存储路径性能问题。
     <br/>
     - **排查方法**：
     <br/>
     1. 检查日志服务状态：
     <br/>
    </p>
    <pre><code class="language-bash">  systemctl status rsyslog</code></pre>
    <p>
     <br/>
     2. 检查日志存储路径的 I/O 性能：
     <br/>
    </p>
    <pre><code class="language-bash">iostat -x 2</code></pre>
    <p>
     <br/>
     3. 检查日志轮转配置：
     <br/>
    </p>
    <pre><code class="language-bash"> cat /etc/logrotate.d/syslog</code></pre>
    <h3>
    </h3>
    <h3>
     5. 检查系统资源占用**
    </h3>
    <p>
     <br/>
     - **现象**：系统资源（CPU、内存、I/O）占用过高，导致终端卡顿。
     <br/>
     - **可能原因**：系统负载过高，影响终端响应。
     <br/>
     - **排查方法**：
     <br/>
     1. 查看实时资源占用：
     <br/>
    </p>
    <pre><code class="language-bash">top</code></pre>
    <p>
     <br/>
     2. 检查磁盘 I/O 延迟：
    </p>
    <pre><code class="language-bash"> iostat -x 2</code></pre>
    <h2>
     解决方案
    </h2>
    <h3>
     ### **步骤 1：临时禁用 `PROMPT_COMMAND`**
    </h3>
    <p>
     <br/>
     1. 在终端中运行以下命令，临时禁用 `PROMPT_COMMAND`：
    </p>
    <pre><code class="language-bash">unset PROMPT_COMMAND</code></pre>
    <p>
     <br/>
     2. 测试终端响应速度是否恢复正常。
    </p>
    <h3>
     ### **步骤 2：定位 `PROMPT_COMMAND` 配置来源**
    </h3>
    <p>
     <br/>
     1. 使用 `grep` 查找 `PROMPT_COMMAND` 的配置来源：
    </p>
    <pre><code class="language-bash">grep -r "PROMPT_COMMAND" /etc/profile /etc/bashrc /etc/profile.d/ ~/.bashrc ~/.bash_profile ~/.profile</code></pre>
    <p>
     <br/>
     2. 确认输出结果，找到定义 `PROMPT_COMMAND` 的文件（通常是 `/etc/bashrc` 或 `~/.bashrc`）。
    </p>
    <h3>
     ### **步骤 3：修改配置文件**
    </h3>
    <p>
     <br/>
     1. 备份配置文件：
     <br/>
    </p>
    <pre><code class="language-bash">sudo cp /etc/bashrc /etc/bashrc.bak
</code></pre>
    <p>
     <br/>
     2. 编辑配置文件（以 `/etc/bashrc` 为例）：
     <br/>
    </p>
    <pre><code class="language-bash"> sudo vi /etc/bashrc</code></pre>
    <p>
     <br/>
     3. 找到 `PROMPT_COMMAND` 的配置行，通常是：
     <br/>
    </p>
    <pre><code class="language-bash">export PROMPT_COMMAND='{ command=$(history 1 | { read x y; echo $y; }); logger -p local1.notice -t bash -i "user=$USER,ppid=$PPID,from=$SSH_CLIENT,pwd=$PWD,command:$command"; }'</code></pre>
    <p>
     <br/>
     4. 选择以下一种修改方式：
     <br/>
     - **完全禁用日志记录**（推荐）：
     <br/>
    </p>
    <pre><code class="language-bash"># 注释掉原有配置
# export PROMPT_COMMAND='{ command=$(history 1 | { read x y; echo $y; }); logger -p local1.notice -t bash -i "user=$USER,ppid=$PPID,from=$SSH_CLIENT,pwd=$PWD,command:$command"; }'
     ```
#优化日志记录逻辑**：
 export PROMPT_COMMAND='{ command=$(history 1 | sed "s/^[ ]*[0-9]*[ ]*//"); (logger -p local1.notice -t bash "user=$USER,command:$command" &amp;) }'</code></pre>
    <p>
     <br/>
     5. 保存并退出编辑器（在 `vi` 中按 `Esc`，输入 `:wq`）。
    </p>
    <h3>
     ### **步骤 4：重新加载配置**
    </h3>
    <p>
     <br/>
     1. 重新加载配置文件：
    </p>
    <pre><code class="language-bash">   source /etc/bashrc</code></pre>
    <p>
     <br/>
     2. 验证修改是否生效：
     <br/>
    </p>
    <pre><code class="language-bash">echo $PROMPT_COMMAND</code></pre>
    <p>
     <br/>
     - 如果输出为空或新配置的简化命令，说明修改成功。
    </p>
    <h3>
     ### **步骤 5：测试终端响应**
    </h3>
    <p>
     <br/>
     1. 输入命令测试终端响应速度是否恢复正常。
     <br/>
     2. 检查系统日志（可选）：
     <br/>
    </p>
    <pre><code class="language-bash">  tail -f /var/log/messages</code></pre>
    <p>
     <br/>
     - 确认命令是否按预期记录（如果未禁用日志）。
    </p>
    <h3>
     ### **步骤 6：排查日志服务性能（可选）**
    </h3>
    <p>
     <br/>
     如果问题仍未解决，进一步检查日志服务性能：
     <br/>
     1. 测试 `logger` 执行时间：
     <br/>
    </p>
    <pre><code class="language-bash">time logger "test log message"</code></pre>
    <p>
     <br/>
     2. 检查日志服务状态：
    </p>
    <pre><code class="language-bash">systemctl status rsyslog
</code></pre>
    <p>
     <br/>
     3. 检查日志轮转配置：
    </p>
    <pre><code class="language-bash"> cat /etc/logrotate.d/syslog</code></pre>
    <p>
     <br/>
     4. 手动触发日志轮转测试：
     <br/>
    </p>
    <pre><code class="language-bash">sudo logrotate -vf /etc/logrotate.conf</code></pre>
    <h2>
     ## **总结**
    </h2>
    <p>
     通过以上步骤，可以彻底解决因 `PROMPT_COMMAND` 日志记录导致的终端卡顿问题，并确保配置在重新登录后依然生效。如果你有其他问题或更好的解决方案，欢迎在评论区分享！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f4d656e696d656b792f:61727469636c652f64657461696c732f313436313238363633" class_="artid" style="display:none">
 </p>
</div>


