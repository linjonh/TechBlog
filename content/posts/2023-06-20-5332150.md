---
arturl_encode: "68747470:733a2f2f626c6f672e6373646e2e6e65742f636c6561727665:722f61727469636c652f64657461696c732f35333332313530"
layout: post
title: "工具和网络游戏封包基础-"
date: 2023-06-20 06:44:44 +0800
description: "　截包工具:　　http://free.ys168.com/?shoooo　　WPRO.rar   "
keywords: "ollydbg可以改封包"
categories: ['未分类']
tags: ['网络游戏', '游戏', '服务器', '工具', '单机游戏', 'Socket']
artid: "5332150"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=5332150
  alt: "工具和网络游戏封包基础-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=5332150
featuredImagePreview: https://bing.ee123.net/img/rand?artid=5332150
---

# 工具和网络游戏封包基础

截包工具:

<http://free.ys168.com/?shoooo>

WPRO.rar      MD5: 2E1E8E48FCC78972905E4F40081B608C

IRIS.rar         MD5: 6B919165C60D83379C1F825245100545

WPE 是通过注入dll的方式hook send, recv, WSASend, WSARecv等函数来截取封包, 如果进程有anti wpe , 有可能截不到数据包

Iris 是sniffer工具, 对网卡进行截包, 需要适当设置IP,port过滤条件, 不可能漏包

调试工具:

flyOdbg 1.1

<http://download.winzheng.com/SoftView/SoftView_30342.htm>

fly修改的ollydbg汉化第二版, 很棒的调试工具, 你能在bbs.pediy.com (看雪论坛)找到很多教程

分析工具:

IDA 4.8

<http://www.crsky.com/soft/1604.html>

16进制编辑工具:

UE 11.0

<http://www.ultraedit.com/index.php?name=Downloads&;d_op=getit&lid=1>

<http://bbs.pediy.com/upload/2005/10/files/UltraEdit.v11.00.Keymaker.zip>

要想在修改游戏中做到百战百胜，是需要相当丰富的计算机知识的。有很多计算机高手就是从玩游戏，修改游戏中，逐步

对计算机产生浓厚的兴趣，逐步成长起来的。不要在羡慕别人能够做到的，因为别人能够做的你也能够！我相信你们看了

本教程后，会对游戏有一个全新的认识，呵呵，因为我是个好老师！（别拿鸡蛋砸我呀，救命啊！#￥%……\*） 　　不过

要想从修改游戏中学到知识，增加自己的计算机水平，可不能只是靠修改游戏呀！ 要知道，修改游戏只是一个验证你对

你所了解的某些计算机知识的理解程度的场所，只能给你一些发现问题、解决问题的机会，只能起到帮助你提高学习计算

机的兴趣的作用，而决不是学习计算机的捷径。

一：什么叫外挂？

现在的网络游戏多是基于Internet上客户／服务器模式，服务端程序运行在游戏服务器上，游戏的设计者在其中创造

一个庞大的游戏空间，各地的玩家可以通过运行客户端程序同时登录到游戏中。简单地说，网络游戏实际上就是由游戏开

发商提供一个游戏环境，而玩家们就是在这个环境中相对自由和开放地进行游戏操作。那么既然在网络游戏中有了服务器

这个概念，我们以前传统的修改游戏方法就显得无能为力了。记得我们在单机版的游戏中，随心所欲地通过内存搜索来修

改角色的各种属性，这在网络游戏中就没有任何用处了。因为我们在网络游戏中所扮演角色的各种属性及各种重要资料都

存放在服务器上，在我们自己机器上（客户端）只是显示角色的状态，所以通过修改客户端内存里有关角色的各种属性是

不切实际的。那么是否我们就没有办法在网络游戏中达到我们修改的目的？回答是"否"。

我们知道Internet客户／服务器模式的通讯一般采用TCP/IP通信协议，数据交换是通过IP数据包的传输来实现的，一

般来说我们客户端向服务器发出某些请求，比如移动、战斗等指令都是通过封包的形式和服务器交换数据。那么我们把本

地发出消息称为SEND，意思就是发送数据，服务器收到我们SEND的消息后，会按照既定的程序把有关的信息反馈给客户端

，比如，移动的坐标，战斗的类型。那么我们把客户端收到服务器发来的有关消息称为RECV。知道了这个道理，接下来我

们要做的工作就是分析客户端和服务器之间往来的数据（也就是封包），这样我们就可以提取到对我们有用的数据进行修

改，然后模拟服务器发给客户端，或者模拟客户端发送给服务器，这样就可以实现我们修改游戏的目的了。

目前除了修改游戏封包来实现修改游戏的目的，我们也可以修改客户端的有关程序来达到我们的要求。我们知道目前

各个服务器的运算能力是有限的，特别在游戏中，游戏服务器要计算游戏中所有玩家的状况几乎是不可能的，所以有一些

运算还是要依靠我们客户端来完成，这样又给了我们修改游戏提供了一些便利。比如我们可以通过将客户端程序脱壳来发

现一些程序的判断分支，通过跟踪调试我们可以把一些对我们不利的判断去掉，以此来满足我们修改游戏的需求。 在下

几个章节中，我们将给大家讲述封包的概念，和修改跟踪客户端的有关知识。大家准备好了吗？

游戏数据格式和存储：

在进行我们的工作之前，我们需要掌握一些关于计算机中储存数据方式的知识和游戏中储存数据的特点。本章节是提

供给菜鸟级的玩家看的，如果你是高手就可以跳过了，如果，你想成为无坚不摧的剑客，那么，这些东西就会花掉你一些

时间；如果，你只想作个江湖的游客的话，那么这些东西，了解与否无关紧要。是作剑客，还是作游客，你选择吧！

现在我们开始！首先，你要知道游戏中储存数据的几种格式，这几种格式是：字节(BYTE)、字(WORD)和双字(DOUBLE

WORD)，或者说是8位、16位和32位储存方式。字节也就是8位方式能储存0~255的数字；字或说是16位储存方式能储存

0~65535的数；双字即32位方式能储存0~4294967295的数。

为何要了解这些知识呢？在游戏中各种参数的最大值是不同的，有些可能100左右就够了，比如，金庸群侠传中的角

色的等级、随机遇敌个数等等。而有些却需要大于255甚至大于65535，象金庸群侠传中角色的金钱值可达到数百万。所以

，在游戏中各种不同的数据的类型是不一样的。在我们修改游戏时需要寻找准备修改的数据的封包，在这种时候，正确判

断数据的类型是迅速找到正确地址的重要条件。

在计算机中数据以字节为基本的储存单位，每个字节被赋予一个编号，以确定各自的位置。这个编号我们就称为地址

。

在需要用到字或双字时，计算机用连续的两个字节来组成一个字，连续的两个字组成一个双字。而一个字或双字的地

址就是它们的低位字节的地址。 现在我们常用的Windows 9x操作系统中，地址是用一个32位的二进制数表示的。而在平

时我们用到内存地址时，总是用一个8位的16进制数来表示它。

二进制和十六进制又是怎样一回事呢？

简单说来，二进制数就是一种只有0和1两个数码，每满2则进一位的计数进位法。同样，16进制就是每满十六就进一

位的计数进位法。16进制有0--F十六个数字，它为表示十到十五的数字采用了A、B、C、D、E、F六个数字，它们和十进制

的对应关系是：A对应于10，B对应于11，C对应于12，D对应于13，E对应于14，F对应于15。而且，16进制数和二进制数间

有一个简单的对应关系，那就是；四位二进制数相当于一位16进制数。比如，一个四位的二进制数1111就相当于16进制的

F，1010就相当于A。

了解这些基础知识对修改游戏有着很大的帮助，下面我就要谈到这个问题。由于在计算机中数据是以二进制的方式储

存的，同时16进制数和二进制间的转换关系十分简单，所以大部分的修改工具在显示计算机中的数据时会显示16进制的代

码，而且在你修改时也需要输入16进制的数字。你清楚了吧？

在游戏中看到的数据可都是十进制的，在要寻找并修改参数的值时，可以使用Windows提供的计算器来进行十进制和

16进制的换算，我们可以在开始菜单里的程序组中的附件中找到它。

现在要了解的知识也差不多了！不过，有个问题在游戏修改中是需要注意的。在计算机中数据的储存方式一般是低位

数储存在低位字节，高位数储存在高位字节。比如，十进制数41715转换为16进制的数为A2F3，但在计算机中这个数被存

为F3A2。

看了以上内容大家对数据的存贮和数据的对应关系都了解了吗？ 好了，接下来我们要告诉大家在游戏中，封包到底

是怎么一回事了，来！大家把袖口卷起来，让我们来干活吧！

二：什么是封包？

怎么截获一个游戏的封包？怎么去检查游戏服务器的ip地址和端口号？ Internet用户使用的各种信息服务，其通讯

的信息最终均可以归结为以IP包为单位的信息传送，IP包除了包括要传送的数据信息外，还包含有信息要发送到的目的IP

地址、信息发送的源IP地址、以及一些相关的控制信息。当一台路由器收到一个IP数据包时，它将根据数据包中的目的IP

地址项查找路由表，根据查找的结果将此IP数据包送往对应端口。下一台IP路由器收到此数据包后继续转发，直至发到目

的地。路由器之间可以通过路由协议来进行路由信息的交换，从而更新路由表。

那么我们所关心的内容只是IP包中的数据信息，我们可以使用许多监听网络的工具来截获客户端与服务器之间的交换

数据，下面就向你介绍其中的一种工具：WPE。

WPE使用方法：执行WPE会有下列几项功能可选择：

SELECT GAME选择目前在记忆体中您想拦截的程式，您只需双击该程式名称即可。

TRACE追踪功能。用来追踪撷取程式送收的封包。WPE必须先完成点选欲追踪的程式名称，才可以使用此项目。 按下

Play键开始撷取程式收送的封包。您可以随时按下 | | 暂停追踪，想继续时请再按下 | | 。按下正方形可以停止撷取封

包并且显示所有已撷取封包内容。若您没按下正方形停止键，追踪的动作将依照OPTION里的设定值自动停止。如果您没有

撷取到资料，试试将OPTION里调整为Winsock Version 2。WPE 及 Trainers 是设定在显示至少16 bits 颜色下才可执行

。

FILTER过滤功能。用来分析所撷取到的封包，并且予以修改。

SEND PACKET送出封包功能。能够让您送出假造的封包。

TRAINER MAKER制作修改器。

OPTIONS设定功能。让您调整WPE的一些设定值。

FILTER的详细教学

- 当FILTER在启动状态时 ，ON的按钮会呈现红色。- 当您启动FILTER时，您随时可以关闭这个视窗。FILTER将会保

留在原来的状态，直到您再按一次 on / off 钮。- 只有FILTER启用钮在OFF的状态下，才可以勾选Filter前的方框来编

辑修改。- 当您想编辑某个Filter，只要双击该Filter的名字即可。

NORMAL MODE：

范例：

当您在 Street Fighter Online ﹝快打旋风线上版﹞游戏中，您使用了两次火球而且击中了对方，这时您会撷取到

以下的封包：SEND-> 0000 08 14 21 06 01 04 SEND-> 0000 02 09 87 00 67 FF A4 AA 11 22 00 00 00 00 SEND->

0000 03 84 11 09 11 09 SEND-> 0000 0A 09 C1 10 00 00 FF 52 44 SEND-> 0000 0A 09 C1 10 00 00 66 52 44

您的第一个火球让对方减了16滴﹝16 = 10h﹞的生命值，而您观察到第4跟第5个封包的位置4有10h的值出现，应该就

是这里了。

您观察10h前的0A 09 C1在两个封包中都没改变，可见得这3个数值是发出火球的关键。

因此您将0A 09 C1 10填在搜寻列﹝SEARCH﹞，然后在修改列﹝MODIFY﹞的位置4填上FF。如此一来，当您再度发出火

球时，FF会取代之前的10，也就是攻击力为255的火球了！

ADVANCED MODE：

范例： 当您在一个游戏中，您不想要用真实姓名，您想用修改过的假名传送给对方。在您使用TRACE后，您会发现有

些封包里面有您的名字出现。假设您的名字是Shadow，换算成16进位则是﹝53 68 61 64 6F 77﹞；而您打算用moon﹝6D

6F 6F 6E 20 20﹞来取代他。1) SEND-> 0000 08 14 21 06 01 042) SEND-> 0000 01 06 99 53 68 61 64 6F 77 00 01

05 3) SEND-> 0000 03 84 11 09 11 094) SEND-> 0000 0A 09 C1 10 00 53 68 61 64 6F 77 00 11 5) SEND-> 0000 0A

09 C1 10 00 00 66 52 44

但是您仔细看，您的名字在每个封包中并不是出现在相同的位置上

- 在第2个封包里，名字是出现在第4个位置上- 在第4个封包里，名字是出现在第6个位置上

在这种情况下，您就需要使用ADVANCED MODE- 您在搜寻列﹝SEARCH﹞填上：53 68 61 64 6F 77 ﹝请务必从位置1开

始填﹞- 您想要从原来名字Shadow的第一个字母开始置换新名字，因此您要选择从数值被发现的位置开始替代连续数值﹝

from the position of the chain found﹞。- 现在，在修改列﹝MODIFY﹞000的位置填上：6D 6F 6F 6E 20 20 ﹝此为

相对应位置，也就是从原来搜寻栏的+001位置开始递换﹞- 如果您想从封包的第一个位置就修改数值，请选择﹝from the

beginning of the packet﹞

了解一点TCP/IP协议常识的人都知道，互联网是将信息数据打包之后再传送出去的。每个数据包分为头部信息和数据

信息两部分。头部信息包括数据包的发送地址和到达地址等。数据信息包括我们在游戏中相关操作的各项信息。那么在做

截获封包的过程之前我们先要知道游戏服务器的IP地址和端口号等各种信息，实际上最简单的是看看我们游戏目录下，是

否有一个SERVER.INI的配置文件，这个文件里你可以查看到个游戏服务器的IP地址，比如金庸群侠传就是如此，那么除了

这个我们还可以在DOS下使用NETSTAT这个命令，

NETSTAT命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。或

者你可以使用木马客星等工具来查看网络连接。工具是很多的，看你喜欢用哪一种了。

NETSTAT命令的一般格式为：NETSTAT [选项]

命令中各选项的含义如下：-a 显示所有socket，包括正在监听的。-c 每隔1秒就重新显示一遍，直到用户中断它。

-i 显示所有网络接口的信息。-n 以网络IP地址代替名称，显示出网络连接情形。-r 显示核心路由表，格式同"route -

e"。-t 显示TCP协议的连接情况。-u 显示UDP协议的连接情况。-v 显示正在进行的工作。

三：怎么来分析我们截获的封包？

首先我们将WPE截获的封包保存为文本文件，然后打开它，这时会看到如下的数据（这里我们以金庸群侠传里PK店小

二客户端发送的数据为例来讲解）：

第一个文件：SEND-> 0000 E6 56 0D 22 7E 6B E4 17 13 13 12 13 12 13 67 1BSEND-> 0010 17 12 DD 34 12 12

12 12 17 12 0E 12 12 12 9BSEND-> 0000 E6 56 1E F1 29 06 17 12 3B 0E 17 1ASEND-> 0000 E6 56 1B C0 68 12 12

12 5ASEND-> 0000 E6 56 02 C8 13 C9 7E 6B E4 17 10 35 27 13 12 12SEND-> 0000 E6 56 17 C9 12

第二个文件：SEND-> 0000 83 33 68 47 1B 0E 81 72 76 76 77 76 77 76 02 7ESEND-> 0010 72 77 07 1C 77 77

77 77 72 77 72 77 77 77 6DSEND-> 0000 83 33 7B 94 4C 63 72 77 5E 6B 72 F3SEND-> 0000 83 33 7E A5 21 77 77

77 3FSEND-> 0000 83 33 67 AD 76 CF 1B 0E 81 72 75 50 42 76 77 77SEND-> 0000 83 33 72 AC 77

我们发现两次PK店小二的数据格式一样，但是内容却不相同，我们是PK的同一个NPC，为什么会不同呢？ 原来金庸群

侠传的封包是经过了加密运算才在网路上传输的，那么我们面临的问题就是如何将密文解密成明文再分析了。

因为一般的数据包加密都是异或运算，所以这里先讲一下什么是异或。 简单的说，异或就是"相同为0，不同为1"（

这是针对二进制按位来讲的），举个例子，0001和0010异或，我们按位对比，得到异或结果是0011，计算的方法是：0001

的第4位为0，0010的第4位为0，它们相同，则异或结果的第4位按照"相同为0，不同为1"的原则得到0，0001的第3位为0，

0010的第3位为0，则异或结果的第3位得到0，0001的第2位为0，0010的第2位为1，则异或结果的第2位得到1，0001的第1

位为1，0010的第1位为0，则异或结果的第1位得到1，组合起来就是0011。异或运算今后会遇到很多，大家可以先熟悉熟

悉，熟练了对分析很有帮助的。

下面我们继续看看上面的两个文件，按照常理，数据包的数据不会全部都有值的，游戏开发时会预留一些字节空间来

便于日后的扩充，也就是说数据包里会存在一些"00"的字节，观察上面的文件，我们会发现文件一里很多"12"，文件二里

很多"77"，那么这是不是代表我们说的"00"呢？推理到这里，我们就开始行动吧！

我们把文件一与"12"异或，文件二与"77"异或，当然用手算很费事，我们使用"M2M 1.0 加密封包分析工具"来计算就

方便多了。得到下面的结果：

第一个文件：1 SEND-> 0000 F4 44 1F 30 6C 79 F6 05 01 01 00 01 00 01 75 09SEND-> 0010 05 00 CF 26 00 00

00 00 05 00 1C 00 00 00 892 SEND-> 0000 F4 44 0C E3 3B 13 05 00 29 1C 05 083 SEND-> 0000 F4 44 09 D2 7A 00

00 00 484 SEND-> 0000 F4 44 10 DA 01 DB 6C 79 F6 05 02 27 35 01 00 005 SEND-> 0000 F4 44 05 DB 00

第二个文件：1 SEND-> 0000 F4 44 1F 30 6C 79 F6 05 01 01 00 01 00 01 75 09SEND-> 0010 05 00 70 6B 00 00

00 00 05 00 05 00 00 00 1A2 SEND-> 0000 F4 44 0C E3 3B 13 05 00 29 1C 05 843 SEND-> 0000 F4 44 09 D2 56 00

00 00 484 SEND-> 0000 F4 44 10 DA 01 B8 6C 79 F6 05 02 27 35 01 00 005 SEND-> 0000 F4 44 05 DB 00

哈，这一下两个文件大部分都一样啦，说明我们的推理是正确的，上面就是我们需要的明文！

接下来就是搞清楚一些关键的字节所代表的含义，这就需要截获大量的数据来分析。

首先我们会发现每个数据包都是"F4 44"开头，第3个字节是变化的，但是变化很有规律。我们来看看各个包的长度，

发现什么没有？对了，第3个字节就是包的长度！ 通过截获大量的数据包，我们判断第4个字节代表指令，也就是说客户

端告诉服务器进行的是什么操作。例如向服务器请求战斗指令为"30"，战斗中移动指令为"D4"等。 接下来，我们就需要

分析一下上面第一个包"F4 44 1F 30 6C 79 F6 05 01 01 00 01 00 01 75 09 05 00 CF 26 00 00 00 00 05 00 1C 00

00 00 89"，在这个包里包含什么信息呢？应该有通知服务器你PK的哪个NPC吧，我们就先来找找这个店小二的代码在什么

地方。 我们再PK一个小喽罗（就是大理客栈外的那个咯）：SEND-> 0000 F4 44 1F 30 D4 75 F6 05 01 01 00 01 00 01

75 09SEND-> 0010 05 00 8A 19 00 00 00 00 11 00 02 00 00 00 C0 我们根据常理分析，游戏里的NPC种类虽然不会超

过65535（FFFF），但开发时不会把自己限制在字的范围，那样不利于游戏的扩充，所以我们在双字里看看。通过"店小二

"和"小喽罗"两个包的对比，我们把目标放在"6C 79 F6 05"和"CF 26 00 00"上。（对比一下很容易的，但你不能太迟钝

咯，呵呵）我们再看看后面的包，在后面的包里应该还会出现NPC的代码，比如移动的包，游戏允许观战，服务器必然需

要知道NPC的移动坐标，再广播给观战的其他玩家。在后面第4个包"SEND-> 0000 F4 44 10 DA 01 DB 6C 79 F6 05 02 27

35 01 00 00"里我们又看到了"6C 79 F6 05"，初步断定店小二的代码就是它了！（这分析里边包含了很多工作的，大家

可以用WPE截下数据来自己分析分析）

第一个包的分析暂时就到这里（里面还有的信息我们暂时不需要完全清楚了）

我们看看第4个包"SEND-> 0000 F4 44 10 DA 01 DB 6C 79 F6 05 02 27 35 01 00 00"，再截获PK黄狗的包，（狗会

出来2只哦）看看包的格式：SEND-> 0000 F4 44 1A DA 02 0B 4B 7D F6 05 02 27 35 01 00 00SEND-> 0010 EB 03 F8

05 02 27 36 01 00 00

根据上面的分析，黄狗的代码为"4B 7D F6 05"（100040011），不过两只黄狗服务器怎样分辨呢？看看"EB 03 F8

05"（100140011），是上一个代码加上100000，呵呵，这样服务器就可以认出两只黄狗了。我们再通过野外遇敌截获的数

据包来证实，果然如此。

那么，这个包的格式应该比较清楚了：第3个字节为包的长度，"DA"为指令，第5个字节为NPC个数，从第7个字节开始

的10个字节代表一个NPC的信息，多一个NPC就多10个字节来表示。

大家如果玩过网金，必然知道随机遇敌有时会出现增援，我们就利用游戏这个增援来让每次战斗都会出现增援的NPC

吧。

通过在战斗中出现增援截获的数据包，我们会发现服务器端发送了这样一个包：F4 44 12 E9 EB 03 F8 05 02 00 00

03 00 00 00 00 00 00 第5-第8个字节为增援NPC的代码（这里我们就简单的以黄狗的代码来举例）。 那么，我们就利用

单机代理技术来同时欺骗客户端和服务器吧！

好了，呼叫NPC的工作到这里算是完成了一小半，接下来的事情，怎样修改封包和发送封包，我们下节继续讲解吧。

四：怎么冒充"客户端"向"服务器"发我们需要的封包？

这里我们需要使用一个工具，它位于客户端和服务器端之间，它的工作就是进行数据包的接收和转发，这个工具我们

称为代理。如果代理的工作单纯就是接收和转发的话，这就毫无意义了，但是请注意：所有的数据包都要通过它来传输，

这里的意义就重大了。我们可以分析接收到的数据包，或者直接转发，或者修改后转发，或者压住不转发，甚至伪造我们

需要的封包来发送。

下面我们继续讲怎样来同时欺骗服务器和客户端，也就是修改封包和伪造封包。 通过我们上节的分析，我们已经知

道了打多个NPC的封包格式，那么我们就动手吧！

首先我们要查找客户端发送的包，找到战斗的特征，就是请求战斗的第1个包，我们找"F4 44 1F 30"这个特征，这是

不会改变的，当然是要解密后来查找哦。 找到后，表示客户端在向服务器请求战斗，我们不动这个包，转发。 继续向下

查找，这时需要查找的特征码不太好办，我们先查找"DA"，这是客户端发送NPC信息的数据包的指令，那么可能其他包也

有"DA"，没关系，我们看前3个字节有没有"F4 44"就行了。找到后，我们的工作就开始了！

我们确定要打的NPC数量。这个数量不能很大，原因在于网金的封包长度用一个字节表示，那么一个包可以有255个字

节，我们上面分析过，增加一个NPC要增加10个字节，所以大家算算就知道，打20个NPC比较合适。

然后我们要把客户端原来的NPC代码分析计算出来，因为增加的NPC代码要加上100000哦。再把我们增加的NPC代码计

算出来，并且组合成新的封包，注意代表包长度的字节要修改啊，然后转发到服务器，这一步在编写程序的时候要注意算

法，不要造成较大延迟。

上面我们欺骗服务器端完成了，欺骗客户端就简单了。

发送了上面的封包后，我们根据新增NPC代码构造封包马上发给客户端，格式就是"F4 44 12 E9 NPC代码 02 00 00

03 00 00 00 00 00 00",把每个新增的NPC都构造这样一个包，按顺序连在一起发送给客户端，客户端也就被我们骗过了

，很简单吧。

以后战斗中其他的事我们就不管了，尽情地开打吧。

[本日志由 looo 于 2005-02-10 01:21 PM 编辑]

looo 于 2005-02-10 01:16 PM 发表评论：

游戏外挂基本原理及实现

解释游戏外挂的基本原理和实现方法

游戏外挂已经深深地影响着众多网络游戏玩家,今天在网上看到了一些关于游戏外挂编写的技术,于是转载上供大家参考

1、游戏外挂的原理

外挂现在分为好多种，比如模拟键盘的，鼠标的，修改数据包的，还有修改本地内存的，但好像没有修改服务器内存

的哦，呵呵。其实修改服务器也是有办法的，只是技术太高一般人没有办法入手而已。（比如请GM去夜总会、送礼、收黑

钱等等办法都可以修改服务器数据，哈哈）

修改游戏无非是修改一下本地内存的数据，或者截获API函数等等。这里我把所能想到的方法都作一个介绍，希望大

家能做出很好的外挂来使游戏厂商更好的完善自己的技术。我见到一篇文章是讲魔力宝贝的理论分析，写得不错，大概是

那个样子。下来我就讲解一下技术方面的东西，以作引玉之用。

2 技术分析部分

2.1 模拟键盘或鼠标的响应

我们一般使用：

UINT SendInput(

UINT nInputs,　　 // count of input events

PINPUT pInputs,　// array of input events

int cbSize　　　　// size of structure

);

API函数。第一个参数是说明第二个参数的矩阵的维数的，第二个参数包含了响应事件，这个自己填充就可以，最后

是这个结构的大小，非常简单，这是最简单的方法模拟键盘鼠标了，呵呵。注意，这个函数还有个替代函数：

VOID keybd\_event(

BYTE bVk,　　　　　　　// 虚拟键码

BYTE bScan,　　　　　　// 扫描码

DWORD dwFlags,

ULONG\_PTR dwExtraInfo　// 附加键状态

);

与

VOID mouse\_event(

DWORD dwFlags,　　　　　 // motion and click options

DWORD dx,　　　　 　　　 // horizontal position or change

DWORD dy,　　　　　　　　// vertical position or change

DWORD dwData,　　　　　　// wheel movement

ULONG\_PTR dwExtraInfo　　// application-defined information

);

这两个函数非常简单了，我想那些按键精灵就是用的这个吧。上面的是模拟键盘，下面的是模拟鼠标的。这个仅仅是

模拟部分，要和游戏联系起来我们还需要找到游戏的窗口才行，或者包含快捷键，就象按键精灵的那个激活键一样，我们

可以用GetWindow函数来枚举窗口，也可以用Findwindow函数来查找制定的窗口（注意，还有一个FindWindowEx），

FindwindowEx可以找到窗口的子窗口，比如按钮，等什么东西。当游戏切换场景的时候我们可以用FindWindowEx来确定一

些当前窗口的特征，从而判断是否还在这个场景，方法很多了，比如可以GetWindowInfo来确定一些东西，比如当查找不

到某个按钮的时候就说明游戏场景已经切换了，等等办法。有的游戏没有控件在里面，这是对图像做坐标变换的话，这种

方法就要受到限制了。这就需要我们用别的办法来辅助分析了。

至于快捷键我们要用动态连接库实现了，里面要用到hook技术了，这个也非常简单。大家可能都会了，其实就是一个

全局的hook对象然后SetWindowHook就可以了，回调函数都是现成的，而且现在网上的例子多如牛毛。这个实现在外挂中

已经很普遍了。如果还有谁不明白，那就去看看MSDN查找SetWindowHook就可以了。

不要低估了这个动态连接库的作用，它可以切入所有的进程空间，也就是可以加载到所有的游戏里面哦，只要用对,

你会发现很有用途的。这个需要你复习一下Win32编程的基础知识了。呵呵，赶快去看书吧。

2.2 截获消息

有些游戏的响应机制比较简单，是基于消息的，或者用什么定时器的东西。这个时候你就可以用拦截消息来实现一些

有趣的功能了。

我们拦截消息使用的也是hook技术，里面包括了键盘消息，鼠标消息，系统消息，日志等，别的对我们没有什么大的

用处，我们只用拦截消息的回调函数就可以了，这个不会让我写例子吧。其实这个和上面的一样，都是用SetWindowHook

来写的，看看就明白了很简单的。

至于拦截了以后做什么就是你的事情了，比如在每个定时器消息里面处理一些我们的数据判断，或者在定时器里面在

模拟一次定时器，那么有些数据就会处理两次，呵呵。后果嘛，不一定是好事情哦，呵呵，不过如果数据计算放在客户端

的游戏就可以真的改变数据了，呵呵，试试看吧。用途还有很多，自己想也可以想出来的，呵呵。

2.3 拦截Socket包

这个技术难度要比原来的高很多。

首先我们要替换WinSock.DLL或者WinSock32.DLL，我们写的替换函数要和原来的函数一致才行，就是说它的函数输出

什么样的，我们也要输出什么样子的函数，而且参数，参数顺序都要一样才行，然后在我们的函数里面调用真正的

WinSock32.DLL里面的函数就可以了。

首先：我们可以替换动态库到系统路径。

其次：我们应用程序启动的时候可以加载原有的动态库，用这个函数LoadLibary然后定位函数入口用GetProcAddress

函数获得每个真正Socket函数的入口地址。

当游戏进行的时候它会调用我们的动态库，然后从我们的动态库中处理完毕后才跳转到真正动态库的函数地址，这样

我们就可以在里面处理自己的数据了，应该是一切数据。呵呵，兴奋吧，拦截了数据包我们还要分析之后才能进行正确的

应答，不要以为这样工作就完成了，还早呢。等分析完毕以后我们还要仿真应答机制来和服务器通信，一个不小心就会被

封号。

分析数据才是工作量的来源呢，游戏每次升级有可能加密方式会有所改变，因此我们写外挂的人都是亡命之徒啊，被

人愚弄了还不知道。

2.4 截获API

上面的技术如果可以灵活运用的话我们就不用截获API函数了，其实这种技术是一种补充技术。比如我们需要截获

Socket以外的函数作为我们的用途，我们就要用这个技术了，其实我们也可以用它直接拦截在Socket中的函数，这样更直

接。

现在拦截API的教程到处都是，我就不列举了，我用的比较习惯的方法是根据输入节进行拦截的，这个方法可以用到

任何一种操作系统上，比如Windows 98/2000等，有些方法不是跨平台的，我不建议使用。这个技术大家可以参考

《Windows核心编程》里面的545页开始的内容来学习，如果是Win98系统可以用“Windows系统奥秘”那个最后一章来学习

。

网络游戏通讯模型初探

[文章导读]

本文就将围绕三个主题来给大家讲述一下网络游戏的网络互连实现方法

序言

网络游戏，作为游戏与网络有机结合的产物，把玩家带入了新的娱乐领域。网络游戏在中国开始发展至今也仅有3，4

年的历史，跟已经拥有几十年开发历史的单机游戏相比，网络游戏还是非常年轻的。当然，它的形成也是根据历史变化而

产生的可以说没有互联网的兴起，也就没有网络游戏的诞生。作为新兴产物，网络游戏的开发对广大开发者来说更加神秘

，对于一个未知领域，开发者可能更需要了解的是网络游戏与普通单机游戏有何区别，网络游戏如何将玩家们连接起来，

以及如何为玩家提供一个互动的娱乐环境。本文就将围绕这三个主题来给大家讲述一下网络游戏的网络互连实现方法。

网络游戏与单机游戏

说到网络游戏，不得不让人联想到单机游戏，实际上网络游戏的实质脱离不了单机游戏的制作思想，网络游戏和单机

游戏的差别大家可以很直接的想到：不就是可以多人连线吗？没错，但如何实现这些功能，如何把网络连线合理的融合进

单机游戏，就是我们下面要讨论的内容。在了解网络互连具体实现之前，我们先来了解一下单机与网络游戏它们各自的运

行流程，只有了解这些，你才能深入网络游戏开发的核心。

现在先让我们来看一下普通单机游戏的简化执行流程：

Initialize() // 初始化模块

{

初始化游戏数据;

}

Game() // 游戏循环部分

{

绘制游戏场景、人物以及其它元素;

获取用户操作输入;

switch( 用户输入数据)

{

case 移动:

{

处理人物移动;

}

break;

case 攻击:

{

处理攻击逻辑:

}

break;

...

其它处理响应;

...

default:

break;

}

游戏的NPC等逻辑AI处理;

}

Exit() // 游戏结束

{

释放游戏数据;

离开游戏;

}

我们来说明一下上面单机游戏的流程。首先，不管是游戏软件还是其他应用软件，初始化部分必不可少，这里需要对

游戏的数据进行初始化，包括图像、声音以及一些必备的数据。接下来，我们的游戏对场景、人物以及其他元素进行循环

绘制，把游戏世界展现给玩家，同时接收玩家的输入操作，并根据操作来做出响应，此外，游戏还需要对NPC以及一些逻

辑AI进行处理。最后，游戏数据被释放，游戏结束。

网络游戏与单机游戏有一个很显着的差别，就是网络游戏除了一个供操作游戏的用户界面平台（如单机游戏）外，还需

要一个用于连接所有用户，并为所有用户提供数据服务的服务器，从某些角度来看，游戏服务器就像一个大型的数据库，

提供数据以及数据逻辑交互的功能。让我们来看看一个简单的网络游戏模型执行流程：

客户机：

Login()// 登入模块

{

初始化游戏数据;

获取用户输入的用户和密码;

与服务器创建网络连接;

发送至服务器进行用户验证;

...

等待服务器确认消息;

...

获得服务器反馈的登入消息;

if( 成立 )

进入游戏;

else

提示用户登入错误并重新接受用户登入;

}

Game()// 游戏循环部分

{

绘制游戏场景、人物以及其它元素;

获取用户操作输入;

将用户的操作发送至服务器;

...

等待服务器的消息;

...

接收服务器的反馈信息;

switch( 服务器反馈的消息数据 )

{

case 本地玩家移动的消息:

{

if( 允许本地玩家移动 )

客户机处理人物移动;

else

客户机保持原有状态;

}

break;

case 其他玩家/NPC的移动消息:

{

根据服务器的反馈信息进行其他玩家或者NPC的移动处理;

}

break;

case 新玩家加入游戏:

{

在客户机中添加显示此玩家;

}

break;

case 玩家离开游戏:

{

在客户机中销毁此玩家数据;

}

break;

...

其它消息类型处理;

...

default:

break;

}

}

Exit()// 游戏结束

{

发送离开消息给服务器;

...

等待服务器确认;

...

得到服务器确认消息;

与服务器断开连接;

释放游戏数据;

离开游戏;

}

服务器：

Listen()　　// 游戏服务器等待玩家连接模块

{

...

等待用户的登入信息;

...

接收到用户登入信息;

分析用户名和密码是否符合;

if( 符合 )

{

发送确认允许进入游戏消息给客户机;

把此玩家进入游戏的消息发布给场景中所有玩家;

把此玩家添加到服务器场景中;

}

else

{

断开与客户机的连接;

}

}

Game()　// 游戏服务器循环部分

{

...

等待场景中玩家的操作输入;

...

接收到某玩家的移动输入或NPC的移动逻辑输入;

// 此处只以移动为例

进行此玩家/NPC在地图场景是否可移动的逻辑判断;

if( 可移动 )

{

对此玩家/NPC进行服务器移动处理;

发送移动消息给客户机;

发送此玩家的移动消息给场景上所有玩家;

}

else

发送不可移动消息给客户机;

}

Exit()　　// 游戏服务＝器结束

{

接收到玩家离开消息;

将此消息发送给场景中所有玩家;

发送允许离开的信息;

将玩家数据存入数据库;

注销此玩家在服务器内存中的数据;

}

}

让我们来说明一下上面简单网络游戏模型的运行机制。先来讲讲服务器端，这里服务器端分为三个部分（实际上一个

完整的网络游戏远不止这些）：登入模块、游戏模块和登出模块。登入模块用于监听网络游戏客户端发送过来的网络连接

消息，并且验证其合法性，然后在服务器中创建这个玩家并且把玩家带领到游戏模块中； 游戏模块则提供给玩家用户实

际的应用服务，我们在后面会详细介绍这个部分； 在得到玩家要离开游戏的消息后，登出模块则会把玩家从服务器中删

除，并且把玩家的属性数据保存到服务器数据库中，如： 经验值、等级、生命值等。

接下来让我们看看网络游戏的客户端。这时候，客户端不再像单机游戏一样，初始化数据后直接进入游戏，而是在与

服务器创建连接，并且获得许可的前提下才进入游戏。除此之外，网络游戏的客户端游戏进程需要不断与服务器进行通讯

，通过与服务器交换数据来确定当前游戏的状态，例如其他玩家的位置变化、物品掉落情况。同样，在离开游戏时，客户

端会向服务器告知此玩家用户离开，以便于服务器做出相应处理。

以上用简单的伪代码给大家阐述了单机游戏与网络游戏的执行流程，大家应该可以清楚看出两者的差别，以及两者间相互

的关系。我们可以换个角度考虑，网络游戏就是把单机游戏的逻辑运算部分搬移到游戏服务器中进行处理，然后把处理结

果(包括其他玩家数据)通过游戏服务器返回给连接的玩家。

网络互连

在了解了网络游戏基本形态之后，让我们进入真正的实际应用部分。首先，作为网络游戏，除了常规的单机游戏所必

需的东西之外，我们还需要增加一个网络通讯模块，当然，这也是网络游戏较为主要的部分，我们来讨论一下如何实现网

络的通讯模块。

一个完善的网络通讯模块涉及面相当广，本文仅对较为基本的处理方式进行讨论。网络游戏是由客户端和服务器组成

，相应也需要两种不同的网络通讯处理方式，不过也有相同之处，我们先就它们的共同点来进行介绍。我们这里以

Microsoft Windows 2000 [2000 Server]作为开发平台，并且使用Winsock作为网络接口（可能一些朋友会考虑使用

DirectPlay来进行网络通讯，不过对于当前在线游戏，DirectPlay并不适合，具体原因这里就不做讨论了）。

确定好平台与接口后，我们开始进行网络连接创建之前的一些必要的初始化工作，这部分无论是客户端或者服务器都

需要进行。让我们看看下面的代码片段：

WORD wVersionRequested;

WSADATAwsaData;

wVersionRequested MAKEWORD(1, 1);

if( WSAStartup( wVersionRequested, &wsaData ) !0 )

{

Failed( WinSock Version Error!" );

}

上面通过调用Windows的socket API函数来初始化网络设备，接下来进行网络Socket的创建，代码片段如下：

SOCKET sSocket socket( AF\_INET, m\_lProtocol, 0 );

if( sSocket == INVALID\_SOCKET )

{

Failed( "WinSocket Create Error!" );

}

这里需要说明，客户端和服务端所需要的Socket连接数量是不同的，客户端只需要一个Socket连接足以满足游戏的需

要，而服务端必须为每个玩家用户创建一个用于通讯的Socket连接。当然，并不是说如果服务器上没有玩家那就不需要创

建Socket连接，服务器端在启动之时会生成一个特殊的Socket用来对玩家创建与服务器连接的请求进行响应，等介绍网络

监听部分后会有更详细说明。

有初始化与创建必然就有释放与删除，让我们看看下面的释放部分：

if( sSocket != INVALID\_SOCKET )

{

closesocket( sSocket );

}

if( WSACleanup() != 0 )

{

Warning( "Can't release Winsocket" );

}

这里两个步骤分别对前面所作的创建初始化进行了相应释放。

接下来看看服务器端的一个网络执行处理，这里我们假设服务器端已经创建好一个Socket供使用，我们要做的就是让

这个Socket变成监听网络连接请求的专用接口，看看下面代码片段：

SOCKADDR\_IN addr;

memset( &addr, 0, sizeof(addr) );

addr.sin\_family = AF\_INET;

addr.sin\_addr.s\_addr = htonl( INADDR\_ANY );

addr.sin\_port = htons( Port ); 　// Port为要监听的端口号

// 绑定socket

if( bind( sSocket, (SOCKADDR\*)&addr, sizeof(addr) ) == SOCKET\_ERROR )

{

Failed( "WinSocket Bind Error!");

}

// 进行监听

if( listen( sSocket, SOMAXCONN ) == SOCKET\_ERROR )

{

Failed( "WinSocket Listen Error!");

}

这里使用的是阻塞式通讯处理，此时程序将处于等待玩家用户连接的状态，倘若这时候有客户端连接进来，则通过

accept()来创建针对此玩家用户的Socket连接，代码片段如下：

sockaddraddrServer;

int nLen sizeof( addrServer );

SOCKET sPlayerSocket accept( sSocket, &addrServer, &nLen );

if( sPlayerSocket == INVALID\_SOCKET )

{

Failed( WinSocket Accept Error!");

}

这里我们创建了sPlayerSocket连接，此后游戏服务器与这个玩家用户的通讯全部通过此Socket进行，到这里为止，

我们服务器已经有了接受玩家用户连接的功能，现在让我们来看看游戏客户端是如何连接到游戏服务器上，代码片段如下

：

SOCKADDR\_IN addr;

memset( &addr, 0, sizeof(addr) );

addr.sin\_family = AF\_INET;// 要连接的游戏服务器端口号

addr.sin\_addr.s\_addr = inet\_addr( IP );// 要连接的游戏服务器IP地址，

addr.sin\_port = htons( Port );//到此，客户端和服务器已经有了通讯的桥梁，

//接下来就是进行数据的发送和接收：

connect( sSocket, (SOCKADDR\*)&addr, sizeof(addr) );

if( send( sSocket, pBuffer, lLength, 0 ) == SOCKET\_ERROR )

{

Failed( "WinSocket Send Error!");

}

这里的pBuffer为要发送的数据缓冲指针，lLength为需要发送的数据长度，通过这支Socket API函数，我们无论在客

户端或者服务端都可以进行数据的发送工作，同时，我们可以通过recv()这支Socket API函数来进行数据接收：

if( recv( sSocket, pBuffer, lLength, 0 ) == SOCKET\_ERROR )

{

Failed( "WinSocket Recv Error!");

}

其中pBuffer用来存储获取的网络数据缓冲，lLength则为需要获取的数据长度。

现在，我们已经了解了一些网络互连的基本知识，但作为网络游戏，如此简单的连接方式是无法满足网络游戏中百人

千人同时在线的，我们需要更合理容错性更强的网络通讯处理方式，当然，我们需要先了解一下网络游戏对网络通讯的需

求是怎样的。

大家知道，游戏需要不断循环处理游戏中的逻辑并进行游戏世界的绘制，上面所介绍的Winsock处理方式均是以阻塞

方式进行，这样就违背了游戏的执行本质，可以想象，在客户端连接到服务器的过程中，你的游戏不能得到控制，这时如

果玩家想取消连接或者做其他处理，甚至显示一个最基本的动态连接提示都不行。

所以我们需要用其他方式来处理网络通讯，使其不会与游戏主线相冲突，可能大家都会想到： 创建一个网络线程来

处理不就可以了？没错，我们可以创建一个专门用于网络通讯的子线程来解决这个问题。当然，我们游戏中多了一个线程

，我们就需要做更多的考虑，让我们来看看如何创建网络通讯线程。

在Windows系统中，我们可以通过CreateThread()函数来进行线程的创建，看看下面的代码片段：

DWORD dwThreadID;

HANDLE hThread = CreateThread( NULL, 0, NetThread/\*网络线程函式\*/, sSocket, 0, &dwThreadID );

if( hThread == NULL )

{

Failed( "WinSocket Thread Create Error!");

}

这里我们创建了一个线程，同时将我们的Socket传入线程函数：

DWORD WINAPINetThread(LPVOID lParam)

{

SOCKET sSocket (SOCKET)lParam;

...

return 0;

}

NetThread就是我们将来用于处理网络通讯的网络线程。那么，我们又如何把Socket的处理引入线程中？

看看下面的代码片段：

HANDLE hEvent;

hEvent = CreateEvent(NULL,0,0,0);

// 设置异步通讯

if( WSAEventSelect( sSocket, hEvent,

FD\_ACCEPT|FD\_CONNECT|FD\_READ|FD\_WRITE|FD\_CLOSE ) ==SOCKET\_ERROR )

{

Failed( "WinSocket EventSelect Error!");

}

通过上面的设置之后，WinSock API函数均会以非阻塞方式运行，也就是函数执行后会立即返回，这时网络通讯会以

事件方式存储于hEvent，而不会停顿整支程式。

完成了上面的步骤之后，我们需要对事件进行响应与处理，让我们看看如何在网络线程中获得网络通讯所产生的事件

消息：

WSAEnumNetworkEvents( sSocket, hEvent, &SocketEvents );

if( SocketEvents.lNetworkEvents != 0 )

{

switch( SocketEvents.lNetworkEvents )

{

case FD\_ACCEPT:

WSANETWORKEVENTS SocketEvents;

break;

case FD\_CONNECT:

{

if( SocketEvents.iErrorCode[FD\_CONNECT\_BIT] == 0)

// 连接成功

{

// 连接成功后通知主线程（游戏线程）进行处理

}

}

break;

case FD\_READ:

// 获取网络数据

{

if( recv( sSocket, pBuffer, lLength, 0) == SOCKET\_ERROR )

{

Failed( "WinSocket Recv Error!");

}

}

break;

case FD\_WRITE:

break;

case FD\_CLOSE:

// 通知主线程（游戏线程）， 网络已经断开

break;

default:

break;

}

}

这里仅对网络连接(FD\_CONNECT) 和读取数据(FD\_READ) 进行了简单模拟操作，但实际中网络线程接收到事件消息后

，会对数据进行组织整理，然后再将数据回传给我们的游戏主线程使用，游戏主线程再将处理过的数据发送出去，这样一

个往返就构成了我们网络游戏中的数据通讯，是让网络游戏动起来的最基本要素。

最后，我们来谈谈关于网络数据包（数据封包）的组织，网络游戏的数据包是游戏数据通讯的最基本单位，网络游戏

一般不会用字节流的方式来进行数据传输，一个数据封包也可以看作是一条消息指令，在游戏进行中，服务器和客户端会

不停的发送和接收这些消息包，然后将消息包解析转换为真正所要表达的指令意义并执行。

互动与管理

说到互动，对于玩家来说是与其他玩家的交流，但对于计算机而言，实现互动也就是实现数据消息的相互传递。前面

我们已经了解过网络通讯的基本概念，它构成了互动的最基本条件，接下来我们需要在这个网络层面上进行数据的通讯。

遗憾的是，计算机并不懂得如何表达玩家之间的交流，因此我们需要提供一套可让计算机了解的指令组织和解析机制，也

就是对我们上面简单提到的网络数据包（数据封包）的处理机制。

为了能够更简单的给大家阐述网络数据包的组织形式，我们以一个聊天处理模块来进行讨论，看看下面的代码结构：

struct tagMessage{

long lType;

long lPlayerID;

};

// 消息指令

// 指令相关的玩家标识

char strTalk[256]; // 消息内容

上面是抽象出来的一个极为简单的消息包结构，我们先来谈谈其各个数据域的用途：

首先，lType 是消息指令的类型，这是最为基本的消息标识，这个标识用来告诉服务器或客户端这条指令的具体用途

，以便于服务器或客户端做出相应处理。lPlayerID 被作为玩家的标识。大家知道，一个玩家在机器内部实际上也就是一

堆数据，特别是在游戏服务器中，可能有成千上万个玩家，这时候我们需要一个标记来区分玩家，这样就可以迅速找到特

定玩家，并将通讯数据应用于其上。

strTalk 是我们要传递的聊天数据，这部分才是真正的数据实体，前面的参数只是数据实体应用范围的限定。

在组织完数据之后，紧接着就是把这个结构体数据通过Socket 连接发送出去和接收进来。这里我们要了解，网络在

进行数据传输过程中，它并不关心数据采用的数据结构，这就需要我们把数据结构转换为二进制数据码进行发送，在接收

方，我们再将这些二进制数据码转换回程序使用的相应数据结构。让我们来看看如何实现：

tagMessageMsg;

Msg.lTypeMSG\_CHAT;

Msg.lPlayerID 1000;

strcpy( &Msg.strTalk, "聊天信息" );

首先，我们假设已经组织好一个数据包，这里MSG\_CHAT 是我们自行定义的标识符，当然，这个标识符在服务器和客

户端要统一。玩家的ID 则根据游戏需要来进行设置，这里1000 只作为假设，现在继续：

char\* p = (char\*)&Msg;

long lLength = sizeof( tagMessage );

send( sSocket, p, lLength );

// 获取数据结构的长度

我们通过强行转换把结构体转变为char 类型的数据指针，这样就可以通过这个指针来进行流式数据处理，这里通过

sizeof() 获得结构体长度，然后用WinSock 的Send() 函数将数据发送出去。

接下来看看如何接收数据：

long lLength = sizeof( tagMessage );

char\* Buffer = new char[lLength];

recv( sSocket, Buffer, lLength );

tagMessage\* p = (tagMessage\*)Buffer;

// 获取数据

在通过WinSock 的recv() 函数获取网络数据之后，我们同样通过强行转换把获取出来的缓冲数据转换为相应结构体

，这样就可以方便地对数据进行访问。（注：强行转换仅仅作为数据转换的一种手段，实际应用中有更多可选方式，这里

只为简洁地说明逻辑）谈到此处，不得不提到服务器/ 客户端如何去筛选处理各种消息以及如何对通讯数据包进行管理。

无论是服务器还是客户端，在收到网络消息的时候，通过上面的数据解析之后，还必须对消息类型进行一次筛选和派分，

简单来说就是类似Windows 的消息循环，不同消息进行不同处理。这可以通过一个switch 语句（熟悉Windows 消息循环

的朋友相信已经明白此意），基于消

息封包里的lType 信息，对消息进行区分处理，考虑如下代码片段：

switch( p->lType ) // 这里的p->lType为我们解析出来的消息类型标识

{

case MSG\_CHAT: // 聊天消息

break;

case MSG\_MOVE: // 玩家移动消息

break;

case MSG\_EXIT: // 玩家离开消息

break;

default:

break;

}

上面片段中的MSG\_MOVE 和MSG\_EXIT 都是我们虚拟的消息标识（一个真实游戏中的标识可能会有上百个，这就需要考

虑优化和优先消息处理问题）。此外，一个网络游戏服务器面对的是成百上千的连接用户，我们还需要一些合理的数据组

织管理方式来进行相关处理。普通的单体游戏服务器，可能会因为当机或者用户过多而导致整个游戏网络瘫痪，而这也就

引入分组服务器机制，我们把服务器分开进行数据的分布式处理。

我们把每个模块提取出来，做成专用的服务器系统，然后建立一个连接所有服务器的数据中心来进行数据交互，这里

每个模块均与数据中心创建了连接，保证了每个模块的相关性，同时玩家转变为与当前提供服务的服务器进行连接通讯，

这样就可以缓解单独一台服务器所承受的负担，把压力分散到多台服务器上，同时保证了数据的统一，而且就算某台服务

器因为异常而当机也不会影响其他模块的游戏玩家，从而提高了整体稳定性。

分组式服务器缓解了服务器的压力，但也带来了服务器调度问题，分组式服务器需要对服务器跳转进行处理，就以一

个玩家进行游戏场景跳转作为讨论基础：假设有一玩家处于游戏场景A，他想从场景A 跳转到场景B，在游戏中，我们称之

场景切换，这时玩家就会触发跳转需求，比如走到了场景中的切换点，这样服务器就把玩家数据从"游戏场景A 服务器"删

除，同时在"游戏场景B 服务器"中把玩家建立起来。

这里描述了场景切换的简单模型，当中处理还有很多步骤，不过通过这样的思考相信大家可以派生出很多应用技巧。

不过需要注意的是，在场景切换或者说模块间切换的时候，需要切实考虑好数据的传输安全以及逻辑合理性，否则切换很

可能会成为将来玩家复制物品的桥梁。

总结

本篇讲述的都是通过一些简单的过程来进行网络游戏通讯，提供了一个制作的思路，虽然具体实现起来还有许多要做

，但只要顺着这个思路去扩展、去完善，相信大家很快就能够编写出自己的网络通讯模块。由于时间仓促，本文在很多细

节方面都有省略，文中若有错误之处也望大家见谅。