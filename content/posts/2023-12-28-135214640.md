---
title: 2023-12-28-操作系统原理复习1.2万字,全面覆盖
date: 2023-12-28 20:23:50 +08:00
categories: ['未分类']
tags: ['Linux', 'Windows', '笔记']
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=135214640
  alt: 操作系统原理复习1.2万字,全面覆盖
artid: 135214640
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=135214640
featuredImagePreview: https://bing.ee123.net/img/rand?artid=135214640
---

# 操作系统原理复习（1.2万字，全面覆盖）

## 第一章、操作系统概述

* **操作系统的特性**
  ：
  **并发性**
  （
  同时处理多个任务的能力
  ），
  **共享性**
  （为多个并发任务提供资源共享），
  **不确定性**
  （具有处理随机事件的能力）。
* **操作系统功能**
  ：

1. 进程管理
   **：**
   处理机分配，处理机管理，CPU管理。具体为进程控制（
   创建，暂停，唤醒，撤销
   ），进程调度（调度策略，优先级），进程通信（进程间通信）。
2. 存储管理/内存管理
   ：
   为应用程序运行分配和管理所需的内存，支持多道程序设计。具体为内存分配，内存共享，内存保护，内存扩充，虚拟内存。
3. 设备管理
   ：设备的分配和回收，设备的驱动机制/传输机制，为应用提供统一接口访问设备，高效存取/设备缓冲机制。
4. 文件管理
   ：为用户提供统一的文件存取接口，高效组织存储空间，提高存取效率，实现信息共享和存取控制。具体为文件用户接口，存储空间管理，文件的操作，目录的操作，存取权限管理。
   **文件是设备的抽象**
   。

* **操作系统性能/评价指标**
  ：

1. 吞吐率
   ：在单位时间内处理信息的能力。
2. 资源利用率
   ：设备（CPU）使用的频度。
3. 响应能力
   ：从接受数据到输出结果的时间间隔。
4. 可移植性
   ：改变硬件环境仍能正常工作的能力，即代码修改量。
5. 可靠性
   ：发现、诊断和恢复系统故障的能力。

* **操作系统发展的四个典型阶段**
  ：

1. 手工操作系统（40年代-50年代初）
2. 单道批处理系统（50年代）
3. 多道批处理系统（60年代初）
4. 分时操作系统（60年代-至今）

* [操作系统：操作系统引论](https://blog.csdn.net/qq_42192693/article/details/111083732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170355897416800192280132%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170355897416800192280132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111083732-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=%E5%A4%9A%E6%89%B9%E9%81%93%E5%A4%84%E7%90%86&spm=1018.2226.3001.4187 "操作系统：操作系统引论")
  详细讲述了单道批处理系统，多道批处理系统和分时操作系统。
* [单道批处理系统，多道批处理系统，分时系统比较](https://blog.csdn.net/qq_43606914/article/details/105836815 "单道批处理系统，多道批处理系统，分时系统比较")
* **多道批处理系统和分时系统的比较**

![](https://i-blog.csdnimg.cn/blog_migrate/d34bb59efc250751018496c5f9f589b6.png)

* 茶余饭后：
  [计算机与云计算发展编年史 1725-2023](https://zhuanlan.zhihu.com/p/624171208 "计算机与云计算发展编年史 1725-2023")
* **操作系统的逻辑结构**
  （OS的设计和实现思路）

1. 整体式结构
   (

   单体式结构，宏内核结构)：以

   模块

   为基本单位构建，每个模块具有特定的功能
   ![](https://i-blog.csdnimg.cn/blog_migrate/943ff966a5f181f7f5eaa09957d18ef2.png)
2. 层次式结构：
   功能模块按

   调用次序

   排若干层，各层

   单向

   依赖或

   单向

   调用。
   ![](https://i-blog.csdnimg.cn/blog_migrate/156b6dd5cc4fe14e1ae6a7649b01799e.png)
3. 微内核结构（客户/服务器结构）：操作系统=微内核+核外服务器
4. ![](https://i-blog.csdnimg.cn/blog_migrate/a96effcd882746ea2b8a3e48c2007e4c.png)

   ![](https://i-blog.csdnimg.cn/blog_migrate/3598146c6e6c7e0dcff268ad3902ef01.png)

   ![](https://i-blog.csdnimg.cn/blog_migrate/84cecdaa4c2878cbf1a2f6ce1fa6cd6e.png)

## 第二章、 操作系统依赖的基础硬件

* **计算机主要部件**
  ：CPU，内设，外设
* **三总线**
  ：地址总线，数据总线，控制总线
* **CPU结构**
  ：控制单元，运算单元，寄存器组

![](https://i-blog.csdnimg.cn/blog_migrate/8e345f70590da296cdf83d5c3dd3af4d.png)

* **CPU的态**
  （CPU的工作模式，
  对资源和指令使用权限的描述
  ）：

1. 核态

   (Kernel mode)：能够访问所有资源和执行指令，管理程序/OS内核
2. 用户态

   (User mode,

   目态

   )：仅能访问部分资源，其他资源受限
3. 管态

   (Supervisor mode)：介于核态和用户态之间

![](https://i-blog.csdnimg.cn/blog_migrate/b7a5b3d4404c5c5d8c288e2965a6fc57.png)

* **操作系统依赖的最基本硬件**
  ：CPU，内存，中断，时钟。
* **存储体系**
  ：寄存器，高速缓存（cashe），主存，磁盘。
  ![](https://i-blog.csdnimg.cn/blog_migrate/f3553a08f5cc1e78bd92a77e580937b1.png)
* **中断基本概念：**

1. 中断定义
   ：
   指CPU对突发的外部事件的反应过程或机制。
   CPU收到
   外部信号
   （中断信号）后，停止当前工作，转去处理该
   外部事件
   ，处理完毕后回到原来工作的
   中断处
   （断点）继续原来的工作。
   ![](https://i-blog.csdnimg.cn/blog_migrate/6e4b10e9b5db291f75bb4594d12885e6.png)
2. 中断源

   ：引起系统中断的事件
3. 中断类型
   ：
   ![](https://i-blog.csdnimg.cn/blog_migrate/78077c9dd72a28c0291cbdf90abe7762.png)
4. 断点
   ：
   程序中断的地方（将要执行的下一条指令的地址）
5. 现场
   ：
   程序正确运行所依赖的信息集合。（PSW

   （

   程序状态字

   ）、相关寄存器、

   断点

   ）
6. 现场的处理

   ：现场保护（进入

   中断服务程序

   之前：

   CPU→

   栈

   ），现场恢复（退出

   中断服务程序

   之后：

   栈

   →CPU）
7. 中断响应过程
   ：识别中断源--保护断点--保护现场--进入中断服务程序--恢复现场--中断返回

* [（操作系统）中断机制](https://blog.csdn.net/weixin_51756720/article/details/122550393?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170357356316800227412076%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170357356316800227412076&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-122550393-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187 "（操作系统）中断机制")
* **基本输入输出系统**
  （
  **BIOS**
  ）。

![](https://i-blog.csdnimg.cn/blog_migrate/f330a6854cf5119e1186f26e81a7b50c.png)

* **实模式和保护模式**

![](https://i-blog.csdnimg.cn/blog_migrate/72d7f637bf34c5bac5093fbe430e5a4e.png)

* **操作系统的启动**
  ：

1. 初始引导
   ：把
   OS内核
   装入内存并使之开始工作接管计算机系统，引导程序为MBR（Master Boot Record）
2. 核心初始化
   ：
   OS内核初始化系统的核心数据。比如：各种寄存器的初始化，存储系统和页表初始化，核心进程构建。
3. 系统初始化

   ：为用户使用系统作准备，使系统处于

   待命状态

   。主要工作：初始化文件系统，初始化网络系统，初始化控制台，初始化图形界面。

* **MBR（主启动扇区）**
  ，

1. 存放引导代码。
2. 占用512个字节（510字节+AA55h），最后两个字节是MBR结束标志。
3. 提供BootLoader或启动管理。

* **PBR**
  ：分区/次引导记录
* **Linux操作系统的生成**
  ：获取内核源码--配置内核--重新编译新内核--编译和安装模块--配置启动选项

## 第三章、用户界面

* [操作系统——操作系统用户界面](https://blog.csdn.net/weixin_59913110/article/details/130451383?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170357564416800184136754%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170357564416800184136754&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130451383-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2&spm=1018.2226.3001.4187 "操作系统——操作系统用户界面")
* **用户界面定义**
  ：
  操作系统提供给用户控制计算机的机制

  (用户接口)
* **用户界面类型**
  ：操作界面和系统调用
  (System Call，系统功能调用,

  程序界面

  )
* **操作界面**
  ：分为图形用户接口，操作命令，批处理与脚本程序
* **批处理与脚本程序**
  ：
  在控制台环境下自动处理一批

  命令。

  Windows：批处理程序（bat/PowerShell）。Linux：Shell脚本程序。
  ![](https://i-blog.csdnimg.cn/blog_migrate/2f25310caad0f248f240cf3ffeb36a36.png)
  ![](https://i-blog.csdnimg.cn/blog_migrate/a7648e4f9c8073b9ac623ef98a40f87f.png)
  ![](https://i-blog.csdnimg.cn/blog_migrate/aec35665e0287a49ed85f28f25facd9d.png)
* Bash主要功能之
  **重定向：**
  主要是标准输入/输出的重定向，在linux虚拟机上实践一下会好很多
  ![](https://i-blog.csdnimg.cn/blog_migrate/55675bbbbd2d27c17912c3d29ae0c708.png)
  ![](https://i-blog.csdnimg.cn/blog_migrate/5b584866739666fd00c7cd3145b0d1bb.png)
* Bash主要功能之
  **管道：**
  ![](https://i-blog.csdnimg.cn/blog_migrate/3cb7ae69e0356b47baf6adfcbe7ae13c.png)

在虚拟机里实践一下

![](https://i-blog.csdnimg.cn/blog_migrate/651baad1a88c522f4142e19f2f849bc4.png)
因为这个学期第一次os实验有4个，第二次os实验有7个

* **系统调用**

  **(**

  **System Call，System Service Call)：**
  操作系统

  内核

  为应用程序提供的

  服务/函数

  。
  特点：内核实现，存取核心资源或硬件，调用过程产生中断

![](https://i-blog.csdnimg.cn/blog_migrate/cf721a4e9c135173b70f64f8167b42cb.png)

![](https://i-blog.csdnimg.cn/blog_migrate/a0272f902cc15a30033cadc10c2ac1d0.png)

* [操作系统学习之系统调用](https://blog.csdn.net/IT_Financial/article/details/105084726?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105084726.142%5Ev98%5Epc_search_result_base2&spm=1018.2226.3001.4187 "操作系统学习之系统调用")

## 第四章、进程管理

* [操作系统——进程管理](https://blog.csdn.net/weixin_43765321/article/details/123279800?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170358053116800213089699%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170358053116800213089699&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123279800-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86&spm=1018.2226.3001.4187 "操作系统——进程管理")
* **进程定义**
  ：
  进程是程序在某个

  数据集合

  上的

  **一次**

  运行

  **活动**

  。
* 进程是系统中
  **共享CPU的最小的并发单位**
  ，是
  **资源分配的基本单位。**
* **进程的特征**
  ：

1. 动态性：进程是程序的一次执行过程，动态产生/消亡
2. 并发性：
   进程可以同其他进程一起向前推进
3. 异步性：

   进程按各自速度向前推进
4. 独立性：进程是系统分配资源和调度CPU的单位

* **进程与程序的区别**
  ：

1. 动态与静态。
   进程是动态的：程序的一次执行过程；程序是静态的：一组指令的有序集合
2. 暂存与长存。进程是暂存的：在内存驻留。程序是长存的：在介质上长期保存。
3. 程序和进程的对应。一个程序可能有多个进程。

* **进程的状态**
  ：

1. 运行状态（Running）。进程已经占有CPU，在CPU上运行。
2. 就绪状态
   （Ready）。具备运行条件但由于无CPU，暂时不能运行
3. 阻塞状态（Block）。
   因为等待某项

   服务

   完成或

   信号

   来到而不能运行的状态。例如等待：系统调用，I/O操作，合作进程的服务或信号…
   ![](https://i-blog.csdnimg.cn/blog_migrate/45344b086df1f12049e276198270cb7e.png)

![](https://i-blog.csdnimg.cn/blog_migrate/289c1d970dff4f050d5df4d54c06b766.png)

* **Linux进程状态**
  ：可运行，睡眠，僵死，暂停。

![](https://i-blog.csdnimg.cn/blog_migrate/a80caff6347aed76b8a6b45b53571d38.png)

![](https://i-blog.csdnimg.cn/blog_migrate/ca07af8540d36be9bba517a578babb85.png)

* **进程控制块**

  **(Process Control Block，PCB)**
  ：
  描述进程的状态、资源、和相关进程的关系。

PCB是进程的标志，创建进程时创建PCB，进程撤销后PCB同时撤销。

![](https://i-blog.csdnimg.cn/blog_migrate/71ff1afa099a7fec356e92b8957d4dd9.png)

![](https://i-blog.csdnimg.cn/blog_migrate/c9399b143491e11e418e2fd6d530c6b1.png)

* **task_struct**
  ：Linux 内核中表示进程和线程的关键数据结构，包含了各种信息，如状态、调度信息、文件描述符等。
  ![](https://i-blog.csdnimg.cn/blog_migrate/3ca76cfcb6d9c57c413587f7d8acd0b0.png)
* **进程控制**
  ：在进程生存期间，对其全部行为的控制。有以下四个典型的进程控制。

1. 进程创建：
   创建一个具有指定标识（ID）的进程。
   ![](https://i-blog.csdnimg.cn/blog_migrate/a9846abdfa47c757825aa7375190848f.png)
   ![](https://i-blog.csdnimg.cn/blog_migrate/a56bc90e572e28995201e1ecc0a22cce.png)
2. 进程撤销：
   撤销一个指定的进程，收回进程所占有的资源，撤销该进程的

   PCB。
   进程撤销的时机/事件：正常结束，异常结束，外界干预。
   ![](https://i-blog.csdnimg.cn/blog_migrate/72e7849b6a30ad03b49677d25ef7df50.png)
3. 进程阻塞：
   停止进程执行，变为阻塞。
   阻塞进程的时机/事件：请求系统服务，启动某种操作，新数据尚未到达，无新工作可做。
   ![](https://i-blog.csdnimg.cn/blog_migrate/c5842c3d9d65aa7abc1437abd5533a6b.png)
4. 进程唤醒：
   唤醒处于阻塞队列当中的某个进程。引起唤醒的时机/事件：系统服务由不满足到满足，I/O完成，新数据到达，提出新请求。

* **原语**
  ：
  由若干指令构成的具有特定功能的函数。具有原子性，其操作不可分割。
* **Linux进程控制**
  ：

1. 创建进程--fork（）
   [linux--fork()详解](https://blog.csdn.net/Artisan_w/article/details/132334752?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170365509216800222885346%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170365509216800222885346&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-132334752-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=linux%20fork&spm=1018.2226.3001.4187 "linux--fork()详解")
   ![](https://i-blog.csdnimg.cn/blog_migrate/49fa1e2fa01033fc2cceb27b70818925.png)

关于fork的返回值：pid = 0（在子进程中），pid>0（在父进程中，为子进程id），pid= -1（出错）

[fork之后，父子进程的先后执行顺序如何反映？](https://www.zhihu.com/question/59296096/answer/1707711827 "fork之后，父子进程的先后执行顺序如何反映？")

[linux中fork函数及子进程父进程执行顺序](https://blog.csdn.net/qq_41687938/article/details/120478430 "linux中fork函数及子进程父进程执行顺序")

在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。可以通过fork返回的值来判断当前进程是子进程还是父进程。

![](https://i-blog.csdnimg.cn/blog_migrate/f222b8dfc7569329c39d8153b15fdd29.png)

![](https://i-blog.csdnimg.cn/blog_migrate/0133d1fcdecdb959ec8f8d2ef89f789d.png)

2. exec函数族：

1. 功能：在子进程空间运行指定的“

   可执行程序

   ”
2. 步骤：根据

   文件名

   找到相应的

   可执行程序，

   可执行程序的内容填入子进程的地址空间。
3. 返回：exec调用成功：进入新进程且不再返回。exec调用失败：继续从调用点向下执行。

3. 进程的阻塞--wait（int &status）函数
[Linux中wait()函数](https://blog.csdn.net/qq_33300585/article/details/128472278?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170365614616800215024965%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170365614616800215024965&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128472278-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=linux%20wait%EF%BC%88%EF%BC%89&spm=1018.2226.3001.4187 "Linux中wait()函数")
![](https://i-blog.csdnimg.cn/blog_migrate/20a7b9b21ade4acb742d7684791f7e48.png)

4. 进程的终结--exit（int &status）函数
[Linux -- exit()函数、_exit()函数、return的说明与使用](https://blog.csdn.net/songshuai0223/article/details/120850739?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170365639516800188547321%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170365639516800188547321&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120850739-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=linux%20exit&spm=1018.2226.3001.4187 "Linux -- exit()函数、_exit()函数、return的说明与使用")
![](https://i-blog.csdnimg.cn/blog_migrate/ae507de59772e207c17c78151a7e2c51.png)

5. 进程的休眠--sleep（int nSecond）
![](https://i-blog.csdnimg.cn/blog_migrate/f6805a2ee03b5e1a159c66c63750513f.png)

* **线程的定义**
  ：线程是进程内创建的
  可运行模块

  /

  指令
  序列，能执行
  指定的任务
  。

进程内可以定义多个线程，线程和进程可以并发运行。

线程是
**CPU调度和派发的基本单位。**

* **线程的意义**
  ：

1. 线程提高了系统的并发性能。线程的并发粒度比进程更细，更充分地发挥

   CPU

   的性能。
2. 线程的应用成本更低，更灵活 。进程为

   线程

   提供

   资源

   和

   地址空间

   。线程的创建，撤销和管理

   成本更低；

   线程间通信

   更容易，更灵活。
3. 大多数操作系统都采用了线程技术。Windows/Linux/

   鸿蒙

   /

   麒麟

   /…

* **创建线程--CreateThread(TaskFunction)**
  函数
  ![](https://i-blog.csdnimg.cn/blog_migrate/69d72d4a7c8f0c6693717b66cc76e3e6.png)
* **线程的应用场景**
  ：

多个功能需要并发的地方

需要改善窗口交互性的地方

需要改善程序结构的地方

多核

CPU

上的应用，充分发挥多核性能

* **现代操作系统线程模型：**

进程

=

资源集 + 线程组：
![](https://i-blog.csdnimg.cn/blog_migrate/6f243b275bfd6ceacf1df4e39bbbba2a.png)

线程的状态变迁：

![](https://i-blog.csdnimg.cn/blog_migrate/1a2f3266dbb416582dffdd93a2ff9e52.png)

* **Linux线程和分类**

1. 内核线程/Kernel Thread
   ![](https://i-blog.csdnimg.cn/blog_migrate/47df731020c58de1451e08153954d063.png)
2. 用户线程/User Thread
   ![](https://i-blog.csdnimg.cn/blog_migrate/10627b0e0c5d787a3f679360805784c8.png)

* 进程VS线程
  ![](https://i-blog.csdnimg.cn/blog_migrate/d4079c0d14b8613f0b2af167ad8d1cff.png)
* **进程互斥的定义：**
  多哥进程共享具有独占性的资源时，必须确保各进程互斥地存取资源，即确保没有任何两个进程同时存取资源。进程内设定特定区域，所有进程互斥地访问这些区域。

![](https://i-blog.csdnimg.cn/blog_migrate/1d6b105a08a9c738519730c84219e3fe.png)

* **临界资源**
  ：一次只允许一个进程独占访问（使用）的资源。比如上面的共享变量i
* **临界区：**
  进程中访问临界资源的程序段。
* 进程的同步关系：
  [操作系统进程同步](https://blog.csdn.net/weixin_45863060/article/details/128730280?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128730280.142%5Ev98%5Epc_search_result_base2&spm=1018.2226.3001.4187 "操作系统进程同步")
  ![](https://i-blog.csdnimg.cn/blog_migrate/1ecfe4863def85286fbe94d270269b10.png)
  ‘’‘’

![](https://i-blog.csdnimg.cn/blog_migrate/ca8ccf1023f36c3387a0b4824951db5c.png)

* **临界区和临界资源的共享特点**
  :
  临界资源的访问具有排他性，并发进程不能同时进入“临界区”
* 访问临界区的方法：

1. 硬件方法：
   [硬件同步机制](https://blog.csdn.net/weixin_45863060/article/details/128730280?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128730280.142%5Ev98%5Epc_search_result_base2&spm=1018.2226.3001.4187#t6 "硬件同步机制")
2. 软件方法：锁机制和信号量机制。
   ![](https://i-blog.csdnimg.cn/blog_migrate/496199c5192fc2050ce4e8cc2c821a00.png)
   ![](https://i-blog.csdnimg.cn/blog_migrate/e28a13022faef923013d239d87fde71e.png)

* **临界区访问的四个原则**
  ：

1. 空闲让进
   ：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立刻进入自己的临界区，以有效利用临界资源。
2. 忙则等待
   ：当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。
3. 有限等待
   ：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入”死等“状态。
4. 让权等待
   ：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入”忙等“状态。

* **信号灯机制**
  ：

![](https://i-blog.csdnimg.cn/blog_migrate/3b55e890d96c2a6600e3f8847ce30d34.png)

1. P操作（
   荷兰语：

   P

   asseren

   通过
   ）原理：
   ![](https://i-blog.csdnimg.cn/blog_migrate/30f2d72215922b8e40abc23192c8119e.png)
2. V操作（荷兰语：
   V

   rijgeven

   释放
   ）
   ![](https://i-blog.csdnimg.cn/blog_migrate/4533f91dc63c5096764556ea0b664f07.png)

* [PV机制及应用/例题](https://blog.csdn.net/weixin_51995229/article/details/125130678?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170366221216800211592230%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170366221216800211592230&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125130678-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187 "PV机制及应用/例题")
* [PV机制经典同步问题](https://blog.csdn.net/qq_28409193/article/details/125970401?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170366248316800192269501%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170366248316800192269501&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125970401-null-null.142%5Ev98%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E6%9C%BA%E5%88%B6%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98&spm=1018.2226.3001.4187 "PV机制经典同步问题")
* Windows同步机制：
  ![](https://i-blog.csdnimg.cn/blog_migrate/1a51d2fe1eb9f5658607a5a762ada3a0.png)

## 第五章、 资源分配与调度（ 死锁 ）

* **死锁的定义**
  ：
  两个或多个进程

  无限期地

  等待永远不会发生的条件的一种系统

  状态。

  每个进程都永远阻塞。
* **死锁的另一个定义**
  ：
  在两个或多个进程中，

  **每个**

  进程都

  已持有

  某种资源，但又

  继续申请

  其它进程

  已持有的某种资源

  。
* [操作系统学习（九）死锁](https://blog.csdn.net/m0_58153897/article/details/128094990?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170366837616800180683561%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170366837616800180683561&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-128094990-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E7%9A%84%E7%BB%93%E8%AE%BA&spm=1018.2226.3001.4187 "操作系统学习（九）死锁")
* **死锁的起因**
  ：

1. 系统资源有限。资源数目不足以满足所有进程的需要，引起进程对资源的竞争而产生死锁。
2. 并发进程的推进顺序不当。进程在运行过程中，请求和释放资源的顺序不当，导致进程产生死锁。

* **关于死锁的一些结论**
  ：

1. 陷入死锁的进程至少是2个（反证：若仅有一个进程死锁）
2. 参与死锁的进程至少有2个已经占有资源。
3. 参与死锁的所有进程都在等待资源
4. 参与死锁的进程是当前系统中所有进程的子集
5. 死锁会浪费大量系统资源，甚至导致系统崩溃。

* **死锁的必要条件**
  ：

1. 互斥条件：
   资源具有独占性，进程

   互斥

   使用资源。
2. 不剥夺条件：
   资源被访问完之前

   (

   即在

   释放

   前

   )

   不能被其他进程

   剥夺

   。
3. 部分分配条件：
   进程所需资源逐步分配，需要时临时申请（

   等待分配

   ）。
4. 环路条件：
   多个进程构成环路：环中
   每个进程

   已占用的资源
   被
   前一进
   程申请，而自己所需
   新资源
   又被环中
   后一进程
   所占用。对于哲学家就餐问题来说，限定最多四个人同时吃饭，就是破坏环路条件。

* **解决死锁的策略**
  ：

1. 预防死锁：通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁。
   ![](https://i-blog.csdnimg.cn/blog_migrate/92411c665978bea5d44bc4a8b0f23f72.png)
2. 避免死锁：
   在资源的分配过程中，用某种方法分析该次分配是否可能导致死锁？若会则不分配；若不会就分配。
3. 检测和恢复死锁：
   允许死锁发生，但可通过

   检测机制

   及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁

   清除

   ，将进程从死锁状态解脱出来。
   ![](https://i-blog.csdnimg.cn/blog_migrate/f3b037f107745bc06d8b3fecaa797162.png)
4. 预先静态分配法：
   进程运行前将所需全部资源

   一次性

   分配给它。因此进程在运行过程中不再提出资源请求，从而避免出现阻塞或者死锁。破坏了

   部分分配条件

   。
   ![](https://i-blog.csdnimg.cn/blog_migrate/6bb7f0323d950a8c88f3ee60abfd43c1.png)
5. 有序资源分配法：
   ![](https://i-blog.csdnimg.cn/blog_migrate/86e1f3cabbef1a9dbef4f052025b9c3f.png)

* [鸵鸟策略、死锁检测与死锁恢复、死锁预防、死锁避免](https://blog.csdn.net/I_r_o_n_M_a_n/article/details/125802465?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170367008016800211578260%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170367008016800211578260&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125802465-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5&spm=1018.2226.3001.4187 "鸵鸟策略、死锁检测与死锁恢复、死锁预防、死锁避免")
* [银行家算法( 详解 )](https://blog.csdn.net/Dustinthewine/article/details/125924551?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170391592916800226544442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170391592916800226544442&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125924551-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187 "银行家算法( 详解 )")

## 第六章、 处理机调度（进程调度）

* **调度定义：**
  在队列中按

  某种策略

  选择

  最合适的

  对象(执行相应操作）
* [《操作系统》—— 处理机调度算法](https://blog.csdn.net/m0_56069910/article/details/131006608?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170368188016800213013039%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170368188016800213013039&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131006608-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B8%E5%9E%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187 "《操作系统》—— 处理机调度算法")
  讲的非常详细。
* **调度分类**
  ：

1. 长程调度（宏观调度

   /

   作业调度）。作业：磁盘-->内存。
2. 中程调度（交换调度）。进程：就绪（内存）-->交换空间。
3. 短程调度（进程调度）。进程：就绪（内存）-->CPU。
4. I/O调度（设备调度）。进程：阻塞（设备）-->就绪。

![](https://i-blog.csdnimg.cn/blog_migrate/92a665561d8b70fbadc66a706be8fefe.png)

* 进程调度的目标（两个量化的衡量指标）：

1. 周转时间

   /

   平均周转时间
2. 带权周转时间

   /

   平均带权周转时间

![](https://i-blog.csdnimg.cn/blog_migrate/04cb363f291fd4b6ad28331e0fedb0a2.png)
![](https://i-blog.csdnimg.cn/blog_migrate/620d904bd525190aceeb37f9cd1cc849.png)

* [典型的调度算法](https://blog.csdn.net/m0_56069910/article/details/131006608?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170368188016800213013039%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170368188016800213013039&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131006608-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B8%E5%9E%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187#t12 "典型的调度算法")

1.
先来先服务调度

（First Come First Serve）：按照作业进入系统的时间先后次序来挑选作业。先进入系统的作业优先被运行。

特点：只考虑作业

**等候时间**

，不考虑

作业大小(

**运行时间)**

。晚来的作业会等待较长时间，

不利于晚来但是很短的作业。

2.
短作业优先调度算法

（

Short Job First）：参考

**运行时间**

，选取

时间最短

的作业投入运行。

特点：忽视了作业等待时间，早来的长作业会长时间等待(资源“饥饿”)。

3.

响应比高者优先调度算法

：调度作业时计算

作业列表

中每个作业的

响应比

，选择

响应比最高的作业

优先投入运行。

特点：

响应比

= 1 +

等待时间

/

运行时间，

有利于短作业，有利于等候已久的作业，兼顾长作业。每次调度时重新计算和比较剩余作业的响应比。

4.

优先数调度算法

：

根据进程优先数，把

CPU

分配给最高的进程。

进程优先数

=

静态优先数

+

动态优先数。

静态优先数：
进程创建时确定，在整个进程运行期间不再改变。

动态优先数：动态优先数在进程运行期间可以改变。

![](https://i-blog.csdnimg.cn/blog_migrate/ed207bc6df186091b36c434b7cd9112b.png)

5.
循环轮转调度法

（ROUND-ROBIN）：
把所有就绪进程按
先进先出
的原则排成队列。
新来

进程
加到队列
末尾
。进程以
时间片
q为单位轮流使用CPU。刚刚运行了一个
时间片
的进程排到队列
末尾
，等候下一轮调度。
队列逻辑上是环形的。

![](https://i-blog.csdnimg.cn/blog_migrate/cd59d1e2e0f1c9a10a07e86418bf97cd.png)

![](https://i-blog.csdnimg.cn/blog_migrate/443dbc998e58c09d50bd79b41078f2c1.png)

* **调度方式：**

  当一进程正在

  CPU

  上运行时，若有

  更高优先级的进程

  进入

  就绪

  ，系统如何对待新进程（分配

  CPU

  ）？

1. 非抢占方式：让正在运行的进程

   继续运行

   ，直到该进程完成或发生某事件而进入“完成”或“阻塞”状态时，才把CPU

   分配给新来的更高优先级的进程。
2. 抢占方式：
   让正在运行的进程

   立即暂停

   ，立即把

   CPU分配给新来的优先级更高的进程。

二者对比：
![](https://i-blog.csdnimg.cn/blog_migrate/361e0735b731c12433af8eb4d537b3d7.png)

* Linux进程优先级

![](https://i-blog.csdnimg.cn/blog_migrate/ac8265ed1d3dd2f767dfec1690d961bb.png)

* **task_struct->
  counter**
  ：
  进程在

  当前一轮调度

  中还能连续运行的时间片数量。counter越大，优先级越高，可获得越多CPU时间

新一轮调度开始时：counter = priority

时钟中断服务程序：counter - -

特定情形：counter = counter

+ △

所有进程的counter都减到0后：重新开始新一轮调度

![](https://i-blog.csdnimg.cn/blog_migrate/c3d0c39e5e2400bd6b378be1b1aa3833.png)

* **task_struct->rt_priority：**

  实时进程特有的优先级: rt_priority+1000
* **task_struct->policy：**

  进程的调度策略，用来区分实时进程和普通进程SCHED_OTHER(

  0

  )

  **||**

  SCHED_FIFO(

  1

  )

  **||**

  SCHED_RR(

  2

  )
* **schedule( )函数：**
  在

  可运行队列中

  查找

  最高优先数进程并把

  CPU

  切换

  给它。

## 第七章、主存管理

* **存储器功能需求**
  ：
  容量足够大，速度足够快，信息永久保存
* **三级存储体系**
  ：内存--辅存--cache
  。用辅存支援内存，提高容量。用cache支援内存，提升效率。
  ![](https://i-blog.csdnimg.cn/blog_migrate/87a6f22e3a19b22c2826d4d9dea917ac.png)
* **地址映射**
  （地址重定位，地址重映射）：把程序中的地址

  （

  虚拟地址

  ,

  虚地址

  ,

  逻辑地址

  ,

  相对地址

  ）

  变换成真实的内存地址

  （实地址

  ,

  物理地址

  ,

  绝对地址

  ）

  的过程。
* [内存管理：物理地址、虚拟地址、逻辑地址](https://blog.csdn.net/weixin_48524215/article/details/125589384 "内存管理：物理地址、虚拟地址、逻辑地址")
* **固定地址映射**
  ：
  编程或编译时

  确定逻辑地址和物理地址映射关系。

特点：程序加载时必须加载到指定的内存区域。容易产生地址冲突，运行失败。

不能适应多道程序环境

* **静态地址映射**
  ：程序
  装入时
  由操作系统完成逻辑地址到物理地址的映射。保证程序在
  运行之前

  所有地址都绑定到主存。

映射方式：物理地址（MA）= 装入地址（BA）+ 虚拟地址（VA）

特点：
程序运行之前确定映射关系。程序占用

连续的

内存空间。程序装入后

不能移动，

如果移动必须放回原来位置。

* **动态地址映射**
  ：在程序

  执行过程中

  把逻辑地址转换为物理地址。

映射方式：物理地址

MA =

装入基址

BA +

虚拟地址

VA

装入基址：基址寄存器

BAR

**实现动态地址映射的思路：**
![](https://i-blog.csdnimg.cn/blog_migrate/679fc70e46a77fc371d6c16a0e4ab7a5.png)

![](https://i-blog.csdnimg.cn/blog_migrate/2235c1dc32bcc0ff57a12d51de83883b.png)

特点：
程序占用的内存空间可动态变化（若程序移动及时更新

基址

BA

）

程序不要求占用连续的内存空间（需要记录每段放置的

基址

BA

）

便于多个进程共享代码（共享代码作为

独立的一段

存放）

缺点：
硬件支持（

MMU

：内存管理单元）。软件复杂。

* **存储扩充：**

  借助辅存在逻辑上扩充内存，解决内存不足
  ![](https://i-blog.csdnimg.cn/blog_migrate/d0e6725a39d70c53c1c20f96a41e583d.png)
  ![](https://i-blog.csdnimg.cn/blog_migrate/265acc337791f81aab0d74712a46e916.png)
* **存储保护**
  ：
  保证内存中的多道程序只能在给定区域活动，并且互不干扰。防止访问越界，防止访问越权。
  ![](https://i-blog.csdnimg.cn/blog_migrate/c36b02cff43d70d32539564a53481813.png)
* **单一存储管理**
  ：用户区

  不分区

  ，完全被一个程序占用。
  ![](https://i-blog.csdnimg.cn/blog_migrate/1994d55fbe4e051beb2d89f43dd2bb0a.png)
* **分区存储管理**
  ：
  把

  用户区

  分为

  若干

  大小不等的

  分区

  ，供不同程序使用。

有

固定分区

（系统初始化时分区）和

动态分区

（程序装入时临时分区）两种。

* **固定分区**
  ：

特点：运行时分区的

大小

和

位置

不变，分区大小不同，适应不同程序需求。

![](https://i-blog.csdnimg.cn/blog_migrate/3622fde94d41c49a8348961178d221ba.png)

![](https://i-blog.csdnimg.cn/blog_migrate/5d1ec32076ce5c3c9c325a3865d4aec9.png)

缺点：
浪费内存，大程序可能无法运行，程序过多无法运行。

因此 程序的

装入数量和顺序要与

分区的数量、大小顺序尽量保持一致。

* **动态分区：**
* ![](https://i-blog.csdnimg.cn/blog_migrate/159eec39db080d710c0b84f2f9f4e1bb.png)

  ![](https://i-blog.csdnimg.cn/blog_migrate/4f06d549f41412f19064a24afaac6300.png)

  ![](https://i-blog.csdnimg.cn/blog_migrate/beb9c0c3e3e935c0fe724eef365e2443.png)
* **分区的选择（放置策略）**

空闲区表：
描述内存

空闲区

的位置和大小的数据结构

1. 首次适应法
   ：

   空闲区表

   按

   首址递增

   排序，尽可能先利用

   低地址空间

   ![](https://i-blog.csdnimg.cn/blog_migrate/8fe2aff77007eda44d337723e5c62d52.png)
2. 最佳适应法
   ：
   空闲区表

   按

   大小递增

   排序，尽量先选中满足要求的

   最小

   空闲区

   ![](https://i-blog.csdnimg.cn/blog_migrate/75b440a6cfdcf9db2f60e58003ee3fce.png)
3. 最坏适应法
   ：
   空闲区表

   按

   大小递减

   排序，尽量先使用

   最大的

   空闲区，仅作

   一次查找

   就可找到所要分区。

   ![](https://i-blog.csdnimg.cn/blog_migrate/dcc8fce6e0af4c70cd7cd709cdf5201c.png)

* **碎片问题**
  ：
  ![](https://i-blog.csdnimg.cn/blog_migrate/84ad38917fb3a6cb31416931af597902.png)

![](https://i-blog.csdnimg.cn/blog_migrate/c2bfd9c58d652858f10a1314e9adba0f.png)

* **覆盖技术（overlay）**

目的：
在

较小

的内存空间中运行

较大

的程序

![](https://i-blog.csdnimg.cn/blog_migrate/71ca81fed6e7c0ffd191da83990861a0.png)

![](https://i-blog.csdnimg.cn/blog_migrate/ae1a7e3da203ced2520e0ed055c73dc6.png)

![](https://i-blog.csdnimg.cn/blog_migrate/196ef1bf4568748d6afe29cf76c7ff5d.png)

覆盖的缺点：编程复杂（程序员划分程序模块并确定关系），程序执行时间长（从外存装入内存耗时）

* **对换技术（Swapping）**

原理：
内存不够时把进程写到磁盘（

换出

/

**Swap Out**

）。

当进程要运行时重新写回内存（

换入

/

**Swap In**

）。

优点：
增加进程并发数；不考虑程序结构。

缺点：
换入和换出增加

CPU开销；对换单位太大（整个进程）

需要考虑的问题：程序换入时的地址重定位，减少对换传送的信息量，外存对换空间的管理方法

采用交换技术的OS：UNIX，Linux，Windows

* 页式内存管理，不罗列了，ppt没讲清，不如看
  [基本分页存储管理方式](https://blog.csdn.net/pipihan21/article/details/129809005?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170373054716800211545152%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170373054716800211545152&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-129809005-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86&spm=1018.2226.3001.4187#t6 "基本分页存储管理方式")

关键摘要：
![](https://i-blog.csdnimg.cn/blog_migrate/151329f85262bf194ff449dd79db0cfb.png)

![](https://i-blog.csdnimg.cn/blog_migrate/afc9a070d3e7f37e34488b20b2e907a7.png)

* **地址映射**
  ：
  虚拟地址（页式地址）

  →

  物理地址
  ![](https://i-blog.csdnimg.cn/blog_migrate/16f0db43ff5651bff656f725b8223c26.png)
* 页表的建立：
  ![](https://i-blog.csdnimg.cn/blog_migrate/d95c7b74ca0ed6cc0131f0d1f16a948f.png)
* **缺页中断**
  ：
  当程序要访问的

  目标页面

  不在内存时，程序将被迫

  临时中断。

缺页中断的处理：

立即将所缺

页面

装入内存。页面从

硬盘

拷贝到内存，其中的I/O操作耗时较长。

因此，缺页中断降低了程序实时性。

![](https://i-blog.csdnimg.cn/blog_migrate/c94c3d78c303faac33a90a3f11a4ddf6.png)
![](https://i-blog.csdnimg.cn/blog_migrate/e23fad22f6c9d3324fa66771f3ad623e.png)

修改位即所谓的“
**脏位**
”。

![](https://i-blog.csdnimg.cn/blog_migrate/fde12751b6a65bfa5c0a5fdbc07ed4e8.png)

访问指令的执行过程：

![](https://i-blog.csdnimg.cn/blog_migrate/3c2e0e45337b51ad775e658c15078719.png)

* **缺页（中断）率f =**

  缺页次数

  /

  访问页面总次数
* **命中率 = 1 - f**
* [操作系统复习：12.缺页中断以及内存页面置换算法](https://blog.csdn.net/weixin_52008431/article/details/123919301?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170375490216800192292024%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170375490216800192292024&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123919301-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD&spm=1018.2226.3001.4187 "操作系统复习：12.缺页中断以及内存页面置换算法")
* **页面抖动**
  ：
  页面在内存和辅存间频繁交换的现象。“抖动”会导致系统效率下降。
* **淘汰策略**
  ：

一个好的淘汰策略，
页面抖动较少，具有较低的缺页率（高命中率）

1. 最佳算法（OPT算法，Optimal）:
淘汰

不再需要

或

最远将来

才会用到的页面。

特点：理论上最佳，实践中该算法

无法实现

。
![](https://i-blog.csdnimg.cn/blog_migrate/b7a16e0f2e12600fa577092b4d58a0d2.png)

2. 先进先出淘汰算法（FIFO算法）:淘汰在内存中

停留时间最长

的页面

优点：
实现简单：页面按进入内存的时间排序，淘汰队头页面。同时，进程按

顺序访问

地址空间时

抖动较少，缺页率较低

。
![](https://i-blog.csdnimg.cn/blog_migrate/6f5af5371167833bbae474f8b98db7dd.png)

异常现象：对于一些特定的访问序列，分配页框越多，缺页率越高！
![](https://i-blog.csdnimg.cn/blog_migrate/754880e8e40f06723eecda6768680d0c.png)

3. 最久未使用淘汰算法（LRU，Least Recently Used）：
淘汰

最长时间未被使用

的页面。
![](https://i-blog.csdnimg.cn/blog_migrate/09a6d50ab159a1c368b6775601ea7a42.png)
![](https://i-blog.csdnimg.cn/blog_migrate/def99993fe74f63f48c08b8ba3ceb33b.png)

4. 最不经常使用算法（LFU，Least Frequently Used）：
选择到当前时间为止

被访问次数最少

的页面，
每页设置
访问计数器
，每当页面被访问时，该页面的访问计数器加1；
发生缺页中断时，淘汰计数值最小的页面

，并将所有计数清零。

实现方式
**：**
对每个⻚⾯设置⼀个访问计数器，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就 累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯

![](https://i-blog.csdnimg.cn/blog_migrate/7c43432f792a12f6ae5d7fbbf0103fcb.png)

* **影响缺页次数的因素：**

1. 淘汰算法
2. 分配给进程的页框数：页框越少，越容易缺页
3. 页本身的大小：页面越小，越容易缺页
4. 程序的编制方法：程序的局部性

* 页面的大小选择：

  ![](https://i-blog.csdnimg.cn/blog_migrate/314e9546ccbebb4a03c6154f918e0367.png)
* **快表机制（cache，联想存储器，TLB）**

特点：
快表是普通页表（慢表）的

部分内容

的

复制

地址映射时

优先

访问快表，若在快表中找到所需数据，则称为“

命中

” 没有命中时，需要访问慢表，同时

**更新**

快表

合理的页面调度策略能使快表具有

**较高**

命中率

![](https://i-blog.csdnimg.cn/blog_migrate/d2b5f9fe90c18b0a2328371c0d75ea65.png)

* **二级页表**
  ，ppt讲的不够好，看
  [两级页表](https://blog.csdn.net/qq_41899026/article/details/117330742?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170375670916800211563204%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170375670916800211563204&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-117330742-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187 "两级页表")

关键摘要：

![](https://i-blog.csdnimg.cn/blog_migrate/5955966759454c1478ca81f605de5bbb.png)

![](https://i-blog.csdnimg.cn/blog_migrate/9d29dd6ae5e336cbaff7cff5929e99d4.png)

* **段式存储管理**
  ：把进程按
  逻辑意义
  划分为多个
  段
  ，每段有
  段名
  ，长度不定。进程由
  多段
  组成
* **段表**
  （SMT，Segment Memory Table）：记录每段在内存中映射的位置
  ![](https://i-blog.csdnimg.cn/blog_migrate/d387aa750f325005e0dbce165dfcfa32.png)
* **段式系统的虚拟地址**
  ：
  段式虚拟地址

  VA

  包含

  段号

  S

  和

  段内偏移W
  ![](https://i-blog.csdnimg.cn/blog_migrate/8221d0cfc43efd01e419105a2a3dc699.png)
* **段式地址映射过程：**

1. 逻辑地址

   VA

   分离出

   (

   S

   ,

   W

   );
2. 以

   S为索引查询段表，检索段号

   S

   ，查询该段

   基地址

   B

   和

   长度

   L

   。
3. 物理地址MA = B + W

![](https://i-blog.csdnimg.cn/blog_migrate/0ed8fe254d9aefa0ae98281217269cb1.png)
![](https://i-blog.csdnimg.cn/blog_migrate/e4b2ba0fafc2d4389c61bbca7a5bfe66.png)

* **段式管理与页式管理的对比**
  ：
  ![](https://i-blog.csdnimg.cn/blog_migrate/f2972d0effd705f38b6887c76254d95a.png)
* **段页式存储管理：**
  在段式存储管理中结合页式存储管理技术
* **段页式地址**
  ：
  段号

  S

  、页号

  P

  和页内位移

  W
  ![](https://i-blog.csdnimg.cn/blog_migrate/d5cf5dd95956bd83764d874f332d2254.png)
* **段页式地址的映射机构：**
  同时采用

  段表

  和

  页表

  实现地址映射

系统为每个进程建立一个

段表

,  每个段建立一个

页表

；

段表给出每段的

页表基地址

及

页表长度

，

页表给出段内每页对应的

页框

。

![](https://i-blog.csdnimg.cn/blog_migrate/4951761e510bc318ba4f40979aa9c62b.png)

* **实模式阶段：**
  计算机加电前一段时间处于实模式。
* **实模式内存空间：**
  20位物理地址，1MB内存空间。分段机制：段地址(16位) ：偏移地址(16位)

![](https://i-blog.csdnimg.cn/blog_migrate/e9f0ce9103ee6ec2ff9d6f9a31d33729.png)

* [X86实模式与保护模式简介](https://blog.csdn.net/qq_45577173/article/details/127430424?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170376552716800182798049%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170376552716800182798049&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-127430424-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%9E%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187 "X86实模式与保护模式简介")
* [操作系统中的描述符和GDT](https://blog.csdn.net/ggh19/article/details/113705230?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170377095616800222822942%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170377095616800222822942&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-113705230-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E7%AC%A6&spm=1018.2226.3001.4187 "操作系统中的描述符和GDT")

## 第八章、设备管理（输入/输出管理）

* **设备类型和特征**

按交互对象分类

1. 人机交互：显示设备、键盘、鼠标、打印机
2. 与

   CPU

   交互：磁盘、磁带、传感器、控制器
3. 计算机间交互：网卡、调制解调器

按交互方向分类

1. 输入设备：键盘、扫描仪
2. 输出设备：显示设备、打印机
3. 双向设备：输入

   /

   输出：硬盘、软盘、网卡

按外设特性分类

1. 使用特征：存储设备、输入设备、输出设备
2. 数据传输率：低速

   (

   键盘

   )

   、中速

   (

   打印机

   )

   、高速

   (

   网卡、磁盘

   )

按信息组织特征分类

1. 字符设备：传输的基本单位是

   字符

   。例：键盘、串口
2. 块设备：
   传输的基本单位是

   块

   。例：硬盘，磁盘
3. 网络设备：采用

   socket套接字接口访问，在全局空间有唯一名字，如

   eth0

   、

   eth1

* 设备管理功能

1. 状态追踪：记录设备的基本属性
   ![](https://i-blog.csdnimg.cn/blog_migrate/9285a4b64d458cb4ff0aace4a7c98e87.png)
2. 设备分配：
   按一定策略安全地分配和管理各种设备。
   ![](https://i-blog.csdnimg.cn/blog_migrate/10529fbe8f4ad476ced2e34599f087e1.png)
3. 设备映射：
   逻辑设备到物理设备的转换（逻辑名到物理名的转换）
   ![](https://i-blog.csdnimg.cn/blog_migrate/f97dcd4d0050d84d908c2776a165bf3d.png)
   ![](https://i-blog.csdnimg.cn/blog_migrate/20b1133516d96fcd7336a6aae5cc1c9b.png)
4. I/O缓冲区管理：
   开辟和管理

   I/O

   缓冲区，提高读写效率。
5. 设备驱动：对物理设备进行I/O操作，
   把应用对设备的读/写请求转换为对设备I/O操作。

   ![](https://i-blog.csdnimg.cn/blog_migrate/63b7546eaaedcb3c1bca252d0ae4c68d.png)

* **缓冲技术作用**

1. 连接不同数据传输速度的设备

   。如CPU（设备驱动）与设备（控制器）之间传输数据，

   改进：内存中增加缓冲区
   ![](https://i-blog.csdnimg.cn/blog_migrate/d2ebf03916d2bd32ed0ef28f49858c20.png)
2. 协调数据记录大小的不一致。

   进程之间

   或

   CPU与设备之间

   的数据记录大小不一致
   ![](https://i-blog.csdnimg.cn/blog_migrate/a068471461bafede3b9ee4f0e9167692.png)
   ![](https://i-blog.csdnimg.cn/blog_migrate/a6ff14926949fe52792f2509b6abdd26.png)
3. 正确执行应用程序的语义拷贝。

* Linux缓冲机制应用：

![](https://i-blog.csdnimg.cn/blog_migrate/635b888e808bb540a659cffb037cb77d.png)

1. 提前读：进程读时，其所需数据已被

   提前读

   到了

   缓冲区

   中，不需要启动外设去执行读操作。
2. 延后写：进程写时，数据先存在缓冲区，等到

   特定事件发生

   或

   足够时间

   后（

   已延迟

   ），再启动外设完成写入。

![](https://i-blog.csdnimg.cn/blog_migrate/5c41d854f262b53c98ed5f1a8fe03b49.png)

* **缓冲的组成**
  ：

1. Cache：
   高速缓冲寄存器

   【

   CPU ↔

   内存】
2. 设备内部缓冲区：外设或

   I/O

   接口的内部缓冲区

   【端口】
3. 内存缓冲区：应用广泛，

   使用灵活

   【

   CPU ↔

   接口

   /外设】，

   应用开辟

   |

   内核开辟
4. 辅存缓冲区：

   开辟在辅存上

   【 暂存内存数据，

   SWAP

   】

* 缓冲的实现

1. 单缓冲：缓冲区仅有1个单元
   ![](https://i-blog.csdnimg.cn/blog_migrate/0e930ce200fa0fccf747b1a65acb5819.png)
2. 双缓冲：缓冲区有2个单元
   ![](https://i-blog.csdnimg.cn/blog_migrate/e587b24d567e5d25904a0c50d1d872f5.png)
3. 环形缓冲：
   在双缓冲的基础上增加了更多的单元，并让首尾两个单元在逻辑上相连。
   ![](https://i-blog.csdnimg.cn/blog_migrate/f618a2d5414dadfdc49614c9473a40ea.png)
4. 缓冲池：
   多个缓冲区，可供若干个进程共享，可以支持输入，也可以支持输出，

   提高缓冲区利用率，减少内存浪费

* [浅谈设备驱动的作用与本质，有无操作系统Linux设备驱动的区别](https://blog.csdn.net/ChenGuiGan/article/details/84305576?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170385437816800180624019%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170385437816800180624019&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-84305576-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FLinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8&spm=1018.2226.3001.4187 "浅谈设备驱动的作用与本质，有无操作系统Linux设备驱动的区别")
* 设备文件：
  硬件设备作为

  文件

  看待，使用

  文件操作接口

  来完成设备的打开、关闭、读写和

  I/O控制等操作。仅字符设备和块设备通过

  设备文件

  访问，创建设备文件：

  mknod。
* **主设备号：**

  标识该设备种类，标识驱动程序主，设备号的范围：

  1-255，

  Linux

  内核支持

  动态分配主设备号
* **次设备号**
  ：

  标识同一设备驱动程序的不同硬件设备
* **设备分类：**

1. 独占设备：
   不可抢占设备

   （普通外设或资源），

   使用时

   独占

   ，

   释放后

   才能被其它进程申请到。先申请，后使用

   （主动）
2. 共享设备：
   可抢占设备

   （

   CPU，内存，硬盘），

   允许多个作业或进程

   同时

   使用。不申请，直接用

   （被动

   +

   主动）
3. 虚拟设备：
   借助虚拟技术，在共享设备上模拟独占设备。

* **设备分配方法**
  ：

1. 独享分配：
   针对独占设备。

   ![](https://i-blog.csdnimg.cn/blog_migrate/40a958b2786fe3272e0b2aba433b0c43.png)
2. 共享分配：针对共享设备，
   典型共享设备：硬盘。

   ![](https://i-blog.csdnimg.cn/blog_migrate/e2f14a0daf8e2a054777dd66d50b5e8d.png)
3. 虚拟分配：

虚拟技术：
在一类物理设备上模拟另一类物理设备的技术，通常借助

辅存部分区域

模拟独占设备，将独占设备转化为共享设备。

虚拟设备：
用来模拟独占设备的

辅存区域

称为

虚拟设备，

具有独占设备的逻辑特点

输入井：
模拟输入设备的辅存区域

输出井：模拟输出设备的辅存区域

![](https://i-blog.csdnimg.cn/blog_migrate/1da4f351bea01be42fc6cebcc4c2a708.png)

* **SPOOLing**

  **系统：**

![](https://i-blog.csdnimg.cn/blog_migrate/6125d25493e579e19dfea49bc1eb3334.png)

1. 预输入程序：
   控制信息从独占设备输入到辅存，模拟脱机输入的卫星机。
2. 输入表：
   独占设备

   ↔

   虚拟设备
3. 缓输出程序：
   控制信息从辅存输出到独占设备，模拟脱机输出的卫星机；
4. 输出表：
   独占设备

   ↔

   虚拟设备
5. 井管理程序：
   控制用户程序和辅存之间的信息交换
   ![](https://i-blog.csdnimg.cn/blog_migrate/34048d13b7be87e3c989b2cdf94db8f0.png)

## 第九章、文件系统

* **文件**
  ：文件是计算机系统存放信息的一种形式，由若干信息项有序构成。文件具有唯一的文件名，用户
  通过

  读写指针

  来存取文件的信息项。
  ![](https://i-blog.csdnimg.cn/blog_migrate/3e0c9dab3d0755e6a9ece88a3cf1ca05.png)
* **文件分类：**

1. 按文件的用途：系统文件，库文件，用户文件。
2. 按文件的操作权限：只读文件，只写文件，可执行文件，可读可写文件，不保护文件
3. 按文件的存储时间：临时文件，永久文件

* **文件系统**
  ：管理文件的机构。

实现文件的创建、撤消、读写、修改、复制和存取控制等，方便用户以

文件名

存取文件

管理文件

存储设备

的空间和存取。高效利用存储空间和高效存取文件

* **文件的逻辑结构**
  ：

1.
记录式文件：信息项是

记录

，记录包含若干成员。例如：学生花名册

.txt，记录姓名，学号，性别，成绩。

特点：
文件头部保存

记录长

和

记录数

信息，浪费存储空间

分类：定长记录文件，不定长文件

2. 流式文件：信息项是字节

特点：
文件长度就是字节的数量，文件无需额外说明信息或控制信息

* **文件的存取方法**
  ：

1. 顺序存取：
   按从前到后的顺序

   依次

   对文件

   信息项

   进行读

   /写，直到定位到目标信息项为止。
2. 随机存取

   /直接访问：直接

   定位

   到文件目标信息项进行读

   /写。适合

   流式文件

   或

   定长记录文件

   。

* 文件的物理结构：
  文件在存储设备上的存储结构，

  强调合理利用储存空间，缩短I/O时间

1.
连续文件：
指文件存放在

连续的存储块

中。文件的存储块顺序与逻辑块顺序一致且连续。

文件目录记录

文件长度

(

块数

)

和

首个存储块号

![](https://i-blog.csdnimg.cn/blog_migrate/1184dc67b19f20aa83f291073f219efb.png)

特点：
文件建立时给出文件

最大长度

和

文件起始位置

。支持顺序存取和随机存取。其中顺序存取速度快

(

寻道次数和寻道时间最少

)

缺点：文件不易动态增长，预留空间容易造成浪费，造成外部碎片问题

2. 串联文件：存放在

离散的存储块

中，每个存储块包含一个

链接指针

记录下一个存储块位置。文件目录记录文件

首个存储块号
![](https://i-blog.csdnimg.cn/blog_migrate/1f7abe787eea96a369881c570d71dedb.png)

特点：串联文件可以显著消除存储碎片，创建文件时无需知道文件长度，文件动态增长时可动态分配存储块，
支持文件增、删、改等操作。

缺点：
随机访问效率极低

(仅适合顺序访问方式），并且如果某个

链接指针损坏

，文件后面将无法访问。
![](https://i-blog.csdnimg.cn/blog_migrate/be42ea216f7c6c442bfe509bce4ee1a0.png)

**FAT文件系统：**

![](https://i-blog.csdnimg.cn/blog_migrate/5f80ed2af19164f4842f0577b2bbcbeb.png)

![](https://i-blog.csdnimg.cn/blog_migrate/24372e0522c0c53ef2d2d68053e6beb5.png)

3. 索引文件：文件存放在不连续的存储块中，系统建立
索引表

记录文件

逻辑块
和
存储块
的对应关系。
索引文件 = 索引表 + 数据区
![](https://i-blog.csdnimg.cn/blog_migrate/fb1afdd5ca36f9db24797aaed32cc6e4.png)

特点：
读取索引文件时应先读取

索引表，

索引表本身占据额外的存储区域

/缺点，

支持顺序和随机存取，支持文件动态增长、插入、删除等。实例：

ext

系列文件系统

(

inode

索引节点文件

)

* **磁盘空闲存储块管理方法：**

1. 空闲文件目录：

空闲文件：
连续的空闲存储块

组成的特殊文件。存储设备上所有的空闲文件就代表了存储设备上的全部空闲空间。

空闲文件目录：为所有空闲文件建立的目录，记录空闲文件的首块号和存储块数

(

或其他方式

)
![](https://i-blog.csdnimg.cn/blog_migrate/270ce9a37e60592b39a7aaf122941128.png)

2. 空闲块链：
把所有空闲存储块用

链表

链接在一起。

当

申请

空闲块时，从链表

头部

摘取空闲块。

当

回收

存储块时，把空闲块加在链表

尾部。
![](https://i-blog.csdnimg.cn/blog_migrate/a204ccb0d369d1630d532fd0f5020d70.png)

3. 位示图：
一块特殊内存区域，

每一位

(bit)

对应一个

存储块

，值1

表示存储块

空闲

，

0

表示

已占用。
![](https://i-blog.csdnimg.cn/blog_migrate/a0b9bf5c84f37e91e4380df6c655069f.png)

* **文件目录：**

文件目录功能：
实现“

按名存取

” ：系统根据文件名能找到指定文件。文件目录记录文件的

文件名

、

存放地址

以及

属性。

目录文件：

目录文件是文件目录的实现，由

文件目录项

构成

文件目录项
（

directory entry）：描述文件基本信息、使用信息和存取控制信息等。

基本信息：文件名、存储位置

(

存储块号

)

等

使用信息：属性、大小、建立时间、修改时间等

存取控制信息：文件存取权限

![](https://i-blog.csdnimg.cn/blog_migrate/08cab551ec788f0783eae7a0937a7d2f.png)

![](https://i-blog.csdnimg.cn/blog_migrate/a8f416fdb821260b38eb04d848d080ec.png)

* **目录结构**
  ：

1. 单机目录：
最简单的目录结构，全部文件都登记在同一目录中。

特点：简单、易于理解和实现

缺点：查找速度慢，不允许重名，不便于文件共享
![](https://i-blog.csdnimg.cn/blog_migrate/4bdce09b96dedf5bead23f477bd102f0.png)

2. 二级目录：
第一级称为主目录

(MFD)

，第二级称为子目录或用户目

(UFD)。每个用户有一个子目录

(

用户目录

)

优点：解决文件重名的问题，不同用户可以使用相同的名字

![](https://i-blog.csdnimg.cn/blog_migrate/b7d29438eed4093bfdb13e314fb2c9e5.png)

![](https://i-blog.csdnimg.cn/blog_migrate/74d934753a866e22abec163f78a6fbb3.png)

3. 树形目录：
多级目录结构，二级目录结构的扩充，目录结构如同倒置的树，树根是主目录

(根目录)，枝结点是子目录，树叶描述文件。

![](https://i-blog.csdnimg.cn/blog_migrate/dd8cf356c884f7f5d0caaebd06cd68f0.png)

![](https://i-blog.csdnimg.cn/blog_migrate/90e4d0375a93fec5d86ac5d406ede66a.png)

* **文件全名**
  ：
  从根目录到文件为止整个通路上所有目录、子目录和文件的名字用

  ”/”

  顺序连接构成的字符串称为

  文件全名。
* **路径名**
  ：文件全名中由目录和子目录组成的部分。每个文件都有唯一的路径名

绝对路径名：
从

根目录

直到文件的路径

相对路径名：从

指定目录

到文件的路径

* 文件属性：
  指定文件的类型、操作特性和存取保护等信息，一般存放在文件的（

  目录 /文件

  ）中。比如
  MS-DOS的文件目录项，
  文件属性

  （特指读
  写/隐藏等属性）占1个字节

### 其他资料：

* [【爆肝四万字！操作系统原理95+】期末考试知识点超超全总结](https://blog.csdn.net/m0_63222058/article/details/131341305?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-131341305.142%5Ev96%5Epc_search_result_base2&spm=1018.2226.3001.4187 "【爆肝四万字！操作系统原理95+】期末考试知识点超超全总结")
* [操作系统期末考试重点总结【全】](https://blog.csdn.net/qq_44622401/article/details/119718780?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170355871616800215056326%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170355871616800215056326&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-119718780-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&spm=1018.2226.3001.4187 "操作系统期末考试重点总结【全】")
* [操作系统期末考试重点知识](https://blog.csdn.net/guoxuying/article/details/112505662?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170355871616800215056326%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170355871616800215056326&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112505662-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&spm=1018.2226.3001.4187 "操作系统期末考试重点知识")
* [华中科技大学操作系统慕课答案-单元作业+第1~2章开放性思考题](https://blog.csdn.net/qq_46106285/article/details/121588990 "华中科技大学操作系统慕课答案-单元作业+第1~2章开放性思考题")
* [华中科技大学操作系统慕课答案-第1~3章单元测试](https://blog.csdn.net/qq_46106285/article/details/121127950 "华中科技大学操作系统慕课答案-第1~3章单元测试")
* [华中科技大学操作系统慕课答案-第4~6章+第7章单元测试](https://blog.csdn.net/qq_46106285/article/details/121599790?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170202524516800185852116%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170202524516800185852116&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-121599790-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=%E5%8D%8E%E4%B8%AD%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE&spm=1018.2226.3001.4187 "华中科技大学操作系统慕课答案-第4~6章+第7章单元测试")
* [第五、六、七章、线程+进程调度+存储管理](https://blog.csdn.net/qq_44861675/article/details/111609000?utm_source=app&app_version=4.21.0&code=app_1562916241&uLinkId=usr1mkqgl919blen "第五、六、七章、线程+进程调度+存储管理")
* [华中科技大学操作系统慕课答案-期末测试题](https://blog.csdn.net/qq_46106285/article/details/121954487 "华中科技大学操作系统慕课答案-期末测试题")

68747470:733a2f2f626c6f672e6373646e2e6e65742f6b6a6e7364672f:61727469636c652f64657461696c732f313335323134363430