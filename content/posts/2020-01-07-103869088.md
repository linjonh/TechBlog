---
layout: post
title: 申丰山-操作系统名词解释与简答
date: 2020-01-07 22:57:55 +0800
categories: ['基础知识']
tags: ['无标签']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=103869088
    alt: 申丰山-操作系统名词解释与简答
artid: 103869088
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=103869088
featuredImagePreview: https://bing.ee123.net/img/rand?artid=103869088
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     申丰山  操作系统（名词解释与简答）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <ul>
        <li>
         <a href="#_1" rel="nofollow">
          第一章
         </a>
        </li>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <ul>
              <li>
               <a href="#_11" rel="nofollow">
                操作系统特征
               </a>
              </li>
              <li>
               <a href="#_20" rel="nofollow">
                操作系统分类
               </a>
              </li>
              <li>
               <a href="#_29" rel="nofollow">
                用户接口
               </a>
              </li>
              <li>
               <a href="#_39" rel="nofollow">
                操作系统构件
               </a>
              </li>
              <li>
               <a href="#_48" rel="nofollow">
                操作系统的结构
               </a>
              </li>
              <li>
               <a href="#_55" rel="nofollow">
                操作系统运行模式
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_60" rel="nofollow">
          第二章
         </a>
        </li>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <ul>
              <li>
               <a href="#_63" rel="nofollow">
                中断源分类
               </a>
              </li>
              <li>
               <a href="#_79" rel="nofollow">
                进程
               </a>
              </li>
              <li>
               <a href="#_104" rel="nofollow">
                线程
               </a>
              </li>
              <li>
               <a href="#_120" rel="nofollow">
                线程的实现方法
               </a>
              </li>
              <li>
               <a href="#_129" rel="nofollow">
                处理器调度
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_146" rel="nofollow">
          第三章
         </a>
        </li>
        <li>
         <a href="#_190" rel="nofollow">
          第四章
         </a>
        </li>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <ul>
              <li>
               <a href="#_191" rel="nofollow">
                逻辑地址与物理地址
               </a>
              </li>
              <li>
               <a href="#_205" rel="nofollow">
                静态重定位和动态重定位
               </a>
              </li>
              <li>
               <a href="#_210" rel="nofollow">
                分页存储管理
               </a>
              </li>
              <li>
               <a href="#_219" rel="nofollow">
                虚拟存储器
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_258" rel="nofollow">
          第五章
         </a>
        </li>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <ul>
              <li>
               <a href="#_259" rel="nofollow">
                设备类别
               </a>
              </li>
              <li>
               <a href="#IO_271" rel="nofollow">
                I/O控制方式
               </a>
              </li>
              <li>
               <a href="#IO_282" rel="nofollow">
                IO软件系统
               </a>
              </li>
              <li>
               <a href="#_291" rel="nofollow">
                磁盘调度算法
               </a>
              </li>
              <li>
               <a href="#Linux_305" rel="nofollow">
                Linux磁盘调度算法
               </a>
              </li>
              <li>
               <a href="#_314" rel="nofollow">
                虚拟设备
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_319" rel="nofollow">
          第六章
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h3>
     <a id="_1">
     </a>
     第一章
    </h3>
    <p>
     <strong>
      操作系统
     </strong>
     （Operating System，简称OS）是管理系统资源、控制程序执行、改善人机界面、提供各种服务、合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的一种系统软件。
     <br/>
     操作系统管理技术
     <br/>
     <strong>
      1、资源复用
     </strong>
     <br/>
     是指多个进程共享物理资源，包括分割资源为较多更小单位的空分复用和分时轮流使用资源的时分复用。
     <br/>
     进程是有资格获得系统资源的独立主体。
     <br/>
     <strong>
      2、资源虚化
     </strong>
     <br/>
     利用一类事物模拟另外一类事物，造成另外一类事物数量更多或容量更大的假象。
     <br/>
     <strong>
      3、资源抽象
     </strong>
     <br/>
     是利用软件封装复杂的硬件或软件设施，简化资源应用接口的一种资源管理技术。
    </p>
    <h6>
     <a id="_11">
     </a>
     操作系统特征
    </h6>
    <p>
     <strong>
      1、并发性
     </strong>
     <br/>
     是指计算机系统中同时存在若干个运行着的程序，这些程序交替、穿插地执行。
     <br/>
     <strong>
      2、共享
     </strong>
     <br/>
     是指操作系统中的资源可被多个并发执行的进程共同使用，而不是被其中某一个程序所独占。
     <br/>
     <strong>
      3、异步性
     </strong>
     <br/>
     也称随机性，在多道程序环境中，程序的执行不是一贯到底，而是“走走停停”，何时“走”，何时“停”是不可预知的。
     <br/>
     <strong>
      4、虚拟性
     </strong>
     <br/>
     将物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物。
    </p>
    <h6>
     <a id="_20">
     </a>
     操作系统分类
    </h6>
    <p>
     <strong>
      1、批处理操作系统
     </strong>
     <br/>
     用户把要计算的应用问题编成程序，连同数据和作业说明书一起交给操作员，操作员集中一批作业，输入到计算机中。然后，由操作系统来调度和控制作业的执行。这种批量化处理作业的操作系统称为批处理操作系统。
     <br/>
     <strong>
      2、分时操作系统
     </strong>
     <br/>
     允许多个联机用户同时使用一台计算机系统进行计算的操作系统称为分时操作系统。
     <br/>
     <strong>
      3、实时操作系统
     </strong>
     <br/>
     当外界事件或数据产生时，能接收并以足够快的速度予以处理，处理的结果又能在规定时间内来控制监控的生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的操作系统。
     <br/>
     <strong>
      4、通用操作系统
     </strong>
     <br/>
     如果一个操作系统兼有批处理、分时和实时处理的全部或两种功能，则该操作系统称为通用操作系统。
    </p>
    <h6>
     <a id="_29">
     </a>
     用户接口
    </h6>
    <p>
     <strong>
      1、程序接口
     </strong>
     <br/>
     程序接口又称为应用编程接口API（Application Programming Interface），供程序员在编制程序时以程序语句或指令的形式调用操作系统的服务和功能。
     <br/>
     程序接口由一组系统调用（System Call）组成， 系统调用是操作系统的组成部分，用于管理和控制系统中软硬件资源的共享使用。
     <br/>
     <strong>
      2、系统调用
     </strong>
     <br/>
     扩充机器功能、增强系统能力、方便用户使用而在内核中建立的函数，它是用户程序或其它系统程序获得操作系统服务的唯一途径，系统调用也称为广义指令。
     <br/>
     <strong>
      3、操作接口
     </strong>
     <br/>
     操作接口又称作业级接口，是操作系统为用户提供的操作控制计算机工作和提供服务手段的集合。
     <br/>
     操作接口是非编译即可使用的；
     <br/>
     程序接口需要经过编译方可使用；
    </p>
    <h6>
     <a id="_39">
     </a>
     操作系统构件
    </h6>
    <p>
     <strong>
      1、内核
     </strong>
     <br/>
     操作系统内核是对硬件进行首次抽象的一层软件，也称为硬件抽象层，用于隐藏硬件复杂性，为上层软件提供简洁、统一的硬件无关的接口。
     <br/>
     <strong>
      2、进程
     </strong>
     <br/>
     进程是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。
     <br/>
     <strong>
      3、线程
     </strong>
     <br/>
     线程是进程内可并发执行的一个独立的程序模块。是操作系统进行处理器调度和分派的基本单位。
     <br/>
     <strong>
      4、管程
     </strong>
     <br/>
     管程是用来管理共享资源的一种对象。管程封装了对共享资源进行同步、互斥操作的数据结构和一组过程。
    </p>
    <h6>
     <a id="_48">
     </a>
     操作系统的结构
    </h6>
    <p>
     <strong>
      1、单体式结构
     </strong>
     <br/>
     操作系统由过程集合构成，链接成一个大型可执行二进制程序。
     <br/>
     <strong>
      2、层次式结构
     </strong>
     <br/>
     层次式结构是把操作系统划分为内核和若干模块（或进程），这些模块（或进程）按功能的调用次序排列成若干层次，各层之间只能是单向依赖或单向调用关系，即低层为高层服务，高层可以调用低层的功能。
     <br/>
     <strong>
      3、客户机/服务器与微内核结构
     </strong>
     <br/>
     客户机/服务器与微内核结构将操作系统分成两大部分，一部分是运行在用户态并以客户机/服务器方式活动的进程；另一部分是运行在核心态的内核。除内核部分外，操作系统的其他部分被分成若干个相对独立的进程。
    </p>
    <h6>
     <a id="_55">
     </a>
     操作系统运行模式
    </h6>
    <p>
     <strong>
      1、非进程模式（内核模块调用模式）
     </strong>
     <br/>
     以非进程模式运行的操作系统，其功能组织成一组例行程序，操作系统服务例程以系统调用的形式与用户进程代码结合在一起执行，构成形式上的单一进程。这种模式也称为内核模块调用模式或系统调用模式。
     <br/>
     <strong>
      2、进程模式
     </strong>
     <br/>
     进程模式将操作系统组织成一组系统进程，即操作系统功能是这些系统进程集合运行的结果，这些系统进程也称为服务器或服务器进程，它们与用户进程或其他服务器进程之间构成了客户机/服务器关系。
    </p>
    <h3>
     <a id="_60">
     </a>
     第二章
    </h3>
    <p>
     <strong>
      中断
     </strong>
     <br/>
     中断是指程序执行过程中，当发生某个事件时，中止CPU上现行程序的运行，引出处理该事件的程序执行的过程。
    </p>
    <h6>
     <a id="_63">
     </a>
     中断源分类
    </h6>
    <p>
     <strong>
      1、强迫性中断事件
     </strong>
     <br/>
     强迫性中断事件不是正在运行的程序所期待的，而是由于随机发生的某种事故或外部请求信号所引起的。
     <br/>
     正在运行的程序不可预知强迫性中断事件发生的时机。
     <br/>
     <strong>
      2、自愿性中断事件
     </strong>
     <br/>
     自愿性中断事件是正在运行的程序所期待的事件。
     <br/>
     这种事件由程序执行访管指令而引发，表示用户进程请求操作系统服务。
     <br/>
     <strong>
      3、外中断
     </strong>
     <br/>
     外中断是指来自处理器和主存之外的中断
     <br/>
     <strong>
      4、内中断
     </strong>
     <br/>
     内中断是指来自处理器和主存内部的中断
     <br/>
     <strong>
      软件中断处理程序
     </strong>
     <br/>
     ①保护硬件未保护的处理器状态
     <br/>
     ②识别各个中断源，分析中断原因
     <br/>
     ③处理发生的中断事件
     <br/>
     ④中断返回
    </p>
    <h6>
     <a id="_79">
     </a>
     进程
    </h6>
    <p>
     <strong>
      1、进程的概念
     </strong>
     <br/>
     进程是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。
     <br/>
     <strong>
      2、七态模型
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d5fa86b42d80718b37f2a6bc1ccbe3e4.png">
      <br/>
      <strong>
       3、进程实体
      </strong>
      <br/>
      <strong>
       进程控制块（PCB）
      </strong>
      <br/>
      每一个进程都捆绑一个进程控制块
      <br/>
      <strong>
       进程程序块
      </strong>
      <br/>
      即被执行的程序，规定了进程一次运行应完成的功能。
      <br/>
      程序块通常是纯代码，可被多个进程共享。
      <br/>
      <strong>
       进程数据块
      </strong>
      <br/>
      进程数据块是进程的私有地址空间，是程序运行时加工处理的对象。
      <br/>
      <strong>
       进程核心栈
      </strong>
      <br/>
      每一个进程都将捆绑一个核心栈，进程在核心态工作时使用。
      <br/>
      <strong>
       4、进程映像
      </strong>
      <br/>
      进程实体的内容随着进程的执行不断发生变化，某时刻进程实体的内容及其状态集合称为进程映像。
      <br/>
      <strong>
       5、进程上下文
      </strong>
      <br/>
      进程物理实体和支持进程运行的环境合称为进程上下文。
      <br/>
      进程物理实体：进程控制块、程序块、数据块。
      <br/>
      进程运行环境：核心栈、用户栈、寄存器。
      <br/>
      <strong>
       6、进程切换
      </strong>
      <br/>
      进程切换即中断一个进程的执行转而执行另一个进程。
      <br/>
      <strong>
       模式切换
      </strong>
      <br/>
      CPU模式切换即处理器管态（核心态）与目态（用户态）之间的切换。
     </img>
    </p>
    <h6>
     <a id="_104">
     </a>
     线程
    </h6>
    <p>
     <strong>
      1、传统进程的特征
     </strong>
     <br/>
     传统进程中只有一个执行流，属于单线程进程，进程所代表的任务仅由一个执行流承担。
     <br/>
     在单线程进程中，进程既是系统进行资源分配的基本单位，也是处理器调度的基本单位，两者合二为一。
     <br/>
     <strong>
      2、多线程环境中的进程
     </strong>
     <br/>
     在多线程环境中，进程被定义为资源分配和保护的单位，多线程进程不再作为处理器调度和分派的基本单位，线程不是资源分配和保护的基本单位，而是处理器调度和分派的单位。
     <br/>
     <strong>
      3、线程的概念
     </strong>
     <br/>
     线程是进程内可并发执行的一个独立的程序模块。是操作系统进行处理器调度和分派的基本单位。
     <br/>
     <strong>
      4、线程实体包括：
     </strong>
     <br/>
     线程控制块（TCB）、私有存储区（包含局部变量，用户栈等）、核心栈
     <br/>
     <strong>
      5、线程的关键状态有：
     </strong>
     <br/>
     运行、就绪、阻塞
     <br/>
     挂起是进程级状态。
     <br/>
     <strong>
      6、线程的控制
     </strong>
     <br/>
     创建：进程创建时系统会缺省创建并启动一个线程，已经启动的线程可以再创建和启动同一进程中的其它线程。
     <br/>
     阻塞、恢复、结束
    </p>
    <h6>
     <a id="_120">
     </a>
     线程的实现方法
    </h6>
    <p>
     <strong>
      1、用户级线程
     </strong>
     <br/>
     用户级线程是在一个进程内部实现了类似进程调度、进程切换功能的一层进程内多任务应用支持软件。
     <br/>
     用户级线程不是由操作系统提供的，因而，操作系统不参与用户级线程的调度。
     <br/>
     <strong>
      2、内核级线程
     </strong>
     <br/>
     内核级线程是在操作系统内核层对进程实现的多线程功能，操作系统以线程作为处理器调度和分派的基本单位
     <br/>
     <strong>
      3、混合式线程
     </strong>
     <br/>
     某些操作系统提供了同时支持用户级线程与内核级线程的混合式线程设施，线程的创建、调度和同步在用户空间进行。
     <br/>
     一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。
    </p>
    <h6>
     <a id="_129">
     </a>
     处理器调度
    </h6>
    <p>
     <strong>
      1、三级调度
     </strong>
     <br/>
     从系统接收到运行结束退出系统为止，作业可能要经历三级调度过程，即：高级调度、中级调度、低级调度。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/27b0829f7dc9797d1da1aead7c3581e2.png">
      <br/>
      高级调度从磁盘后备作业队列中挑选若干作业进入内存，为其分配资源，创建进程；作业完成后还要做善后处理工作。
      <br/>
      中级调度起到平滑和调整系统负荷的作用，提高主存利用率和系统吐吞率。
      <br/>
      低级调度的主要功能是按照某种原则决定就绪队列中的哪个进程或内核级线程获得处理器，并将处理器出让给它进行工作。中断是执行低级调度的时机
      <br/>
      低级调度是各类操作系统必须具有的功能；
      <br/>
      在纯粹的分时或实时操作系统中，通常不需要配备高级调度，而仅配置低级调度；
      <br/>
      一般的操作系统都配置高级调度和低级调度；
      <br/>
      <strong>
       2、低级调度的基本类型
      </strong>
      <br/>
      剥夺方式：高优先级剥夺原则和时间片剥夺原则
      <br/>
      非剥夺方式：一旦某个进程或线程开始执行便不再出让处理器，除非该进程或线程运行结束或发生了某个事件不能继续执行。
      <br/>
      <strong>
       3、剥夺调度与非剥夺调度和中断的关系
      </strong>
      <br/>
      （1）剥夺调度：在进程自身未出现等待事件的情况下，由于时间片用完或者出现了优先级更高的进程而被迫让出处理器。
      <br/>
      （2）非剥夺调度：一旦获得处理器，只有进程自身出现等待事件时才会让出处理器。
      <br/>
      （3）无论剥夺调度还是非剥夺调度，进程都有可能出现等待事件而中断，让出处理器。
     </img>
    </p>
    <h3>
     <a id="_146">
     </a>
     第三章
    </h3>
    <p>
     <strong>
      1、进程的并发性
     </strong>
     <br/>
     进程的并发性是指一组进程的执行在时间上是重叠的，即一个进程执行的第一条指令是在另一个进程执行的最后一条指令完成之前开始的。
     <br/>
     <strong>
      2、并发进程之间的竞争关系
     </strong>
     <br/>
     并发进程之间的竞争关系是由于并发进程共用一套计算机系统资源引起的，一个进程的执行可能影响与其竞争资源的其它进程。
     <br/>
     资源竞争产生两个问题：
     <br/>
     (1)、死锁问题：进程直接或间接互相等待对方的资源
     <br/>
     (2)、饥饿问题：一些进程总是优先于另一些进程
     <br/>
     <strong>
      进程互斥
     </strong>
     <br/>
     进程互斥是指若干进程要使用同一共享资源时，任何时刻最多允许一个进程使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。
     <br/>
     <strong>
      3、并发进程之间的协作关系
     </strong>
     <br/>
     某些并发进程为完成同一任务而共享某些数据，形成协作关系
     <br/>
     <strong>
      进程同步
     </strong>
     <br/>
     进程同步是指两个以上进程基于某个条件协调彼此的活动，一个进程的执行依赖于协作进程的消息或信号，当一个进程没有得到来自于协作进程的消息或信号时需等待，直到消息或信号到达才被唤醒。
     <br/>
     <strong>
      4、进程互斥与同步的区别
     </strong>
     <br/>
     相交进程之间的关系主要有两种，同步与互斥。
     <br/>
     所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。
     <br/>
     <strong>
      5、互斥
     </strong>
     ：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
     <br/>
     <strong>
      6、同步
     </strong>
     ：是指在互斥的基础上（大多数情况）通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
     <br/>
     <strong>
      7、临界区与临界资源
     </strong>
     <br/>
     并发进程中与共享变量有关的程序段叫做临界区，共享变量代表的资源叫做临界资源。
     <br/>
     <strong>
      8、管程
     </strong>
     <br/>
     管程是用来管理共享资源的一种对象。管程封装了对共享资源进行同步、互斥操作的数据结构和一组过程。
     <br/>
     <strong>
      9、管道
     </strong>
     <br/>
     管道是连接读写进程的一个共享文件，允许进程以先进先出方式写入和读出数据，并对读写操作进行同步。发送进程以字符流形式把大量数据送入管道尾部，接收进程从管道头部接收数据。
     <br/>
     <strong>
      10、共享内存
     </strong>
     <br/>
     共享内存是允许两个或多个进程共同访问的物理内存区域，是实现进程通信的一种手段。
     <br/>
     <strong>
      11、消息
     </strong>
     <br/>
     消息是格式化的数据，在计算机网络中称报文。
     <br/>
     消息由消息头和消息体组成。
     <br/>
     <strong>
      12、套接字
     </strong>
     <br/>
     套接字通信允许互联的位于不同计算机上的进程之间实现通信功能。
     <br/>
     套接字用于标识和定位特定计算机上特定进程的地址，以便数据准确传输给目标进程。
     <br/>
     <strong>
      13、死锁
     </strong>
     <br/>
     如果在一个进程集合中的每个进程都在等待只能由该集合中的其它进程才能引发的事件，而无限期陷入僵持的局面称为死锁。
     <br/>
     <strong>
      14、产生死锁的必要条件
     </strong>
     <br/>
     （1）互斥
     <br/>
     进程互斥使用资源，一旦某个资源被占用，欲使用该资源的进程必须等待
     <br/>
     （2）占有和等待
     <br/>
     进程申请新资源得不到满足而等待时，不释放已占有资源
     <br/>
     （3）不剥夺
     <br/>
     一个进程不能抢夺其它进程占有的资源
     <br/>
     （4）循环等待
     <br/>
     存在一组进程循环等待资源的现象
    </p>
    <h3>
     <a id="_190">
     </a>
     第四章
    </h3>
    <h6>
     <a id="_191">
     </a>
     逻辑地址与物理地址
    </h6>
    <p>
     <strong>
      1、地址重定位或地址变换
     </strong>
     <br/>
     在执行程序时，将其中的逻辑地址转变为物理地址的过程。
     <br/>
     <strong>
      2、逻辑地址
     </strong>
     <br/>
     逻辑地址是与程序在内存中的物理位置无关的访问地址。
     <br/>
     <strong>
      3、物理地址（或绝对地址）
     </strong>
     <br/>
     物理地址是程序运行时中央处理器实际访问的内存单元地址。
     <br/>
     <strong>
      4、相对地址
     </strong>
     <br/>
     相对地址是逻辑地址的一个特例，是相对于已知点（通常是程序的开始处）的存储单元的地址。
     <br/>
     逻辑地址或相对地址也称为虚拟内存地址。
     <br/>
     <strong>
      逻辑地址空间
     </strong>
     <br/>
     一个用户作业的目标程序的逻辑地址集合称为该作业的逻辑地址空间。
     <br/>
     <strong>
      物理地址空间
     </strong>
     <br/>
     主存中实际存储单元的物理地址的总体构成用户程序实际运行的物理地址空间。
    </p>
    <h6>
     <a id="_205">
     </a>
     静态重定位和动态重定位
    </h6>
    <p>
     <strong>
      1、静态重定位
     </strong>
     <br/>
     在逻辑地址转换为物理地址的过程中，地址变换是在进程装入时一次完成的，以后不再改变。
     <br/>
     <strong>
      2、动态重定位
     </strong>
     <br/>
     地址转换工作穿插在指令执行的过程中，每执行一条指令，CPU对指令中涉及的逻辑地址进行转换，这种重定位方式称为动态重定位。
    </p>
    <h6>
     <a id="_210">
     </a>
     分页存储管理
    </h6>
    <p>
     <strong>
      1、物理块或页框
     </strong>
     <br/>
     分页存储管理将全部内存划分为长度相等的若干份，每一份称为一个物理块或页框。
     <br/>
     <strong>
      2、页或页面
     </strong>
     <br/>
     作业自动被分页系统划分为与每个物理块相等的若干等份，每一份称为一页或一个页面。
     <br/>
     <strong>
      3、页表
     </strong>
     <br/>
     页表用于实现地址变换，页表记载了逻辑地址到物理地址的对应关系，操作系统需为每个作业建立一张页表，系统通过页表可以准确访问内存中属于一个作业的所有页面。
     <br/>
     <strong>
      4、快表
     </strong>
     <br/>
     为了减少分页存储管理系统中的内存访问速度下降一倍问题，在存储管理部件中增设一个专用的高速缓冲存储器，用来存放最近访问过的部分页表项，这种高速缓冲存储器称为快表或联想存储器。
    </p>
    <h6>
     <a id="_219">
     </a>
     虚拟存储器
    </h6>
    <p>
     <strong>
      1、虚拟存储器的定义
     </strong>
     <br/>
     在具有层次结构存储器的计算机系统中，采用自动实现部分装入和部分对换功能，为用户提供一个比物理主存容量大得多的，可寻址的一种“主存储器”称为虚拟存储器。
     <br/>
     <strong>
      2、程序执行的局部性
     </strong>
     <br/>
     在一段时间内，程序访问的存储空间仅限于某个区域（这称为空间局部性），或者最近访问过的程序代码和数据很快会再次被访问（这称为时间局部性）。
     <br/>
     <strong>
      3、请求分页虚拟存储系统基本原理
     </strong>
     <br/>
     在进程开始运行之前，装入全部页面集合中的一个或几个页面，进程运行过程中，访问的页面不在内存时，再装入所需页面；
     <br/>
     若内存空间已满，而又需要装入新的页面时，则根据某种算法淘汰某个页面，以便装入新的页面。
     <br/>
     <strong>
      4、请求分页系统的页表结构
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/51a49b085dcd9408fded2c98ff7d4ef7.png">
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8d625a2d9c6ea40416b935ed630f2789.png">
       <br/>
       <strong>
        5、请求分页的地址变换过程
       </strong>
       <br/>
       进程开始执行并要访问某个虚拟地址时，内存管理部件MMU的工作如下
       <br/>
       ①MMU接受CPU传送过来的虚地址并分解为两部分：页号和页内地址
       <br/>
       ②以页号为索引搜索快表
       <br/>
       ③如果命中快表，则立即送出物理块号（页框号），并与页内地址拼接形成物理地址，然后访问相应内存单元
       <br/>
       ④如果不命中快表，则以页号为索引搜索内存页表
       <br/>
       ⑤在页表中查找相应表项，如果其状态位指示该页已在内存，则送出物理块号与页内地址拼接形成物理地址访问相应内存单元，同时要将该表项装入快表
       <br/>
       ⑥如果在页表中找到的相应表项，其状态位指示该页不在内存，则发出缺页中断，请求操作系统处理
       <br/>
       ⑦存储管理软件将所缺页面调入内存，修改页表
       <br/>
       <strong>
        6、缺页中断处理过程
       </strong>
       <br/>
       ①挂起请求缺页的进程，根据页号查外页表，找到该页存放的磁盘物理地址
       <br/>
       ②查看内存是否有空闲物理块，如有则装入页面到空闲物理块，同时修改页表相应项以及内存分配表
       <br/>
       ③如果内存中没有空闲物理块，则按替换算法选择一个页面淘汰，若该页面被写过或修改过，则写回外存；
       <br/>
       否则只简单淘汰该页面。淘汰页面之后要修改页表相应项，然后调入页面到淘汰页面释放的物理块中
       <br/>
       <strong>
        7、页框分配策略
       </strong>
       <br/>
       决定系统为每个进程分配多少个页框用于装载页面
       <br/>
       页框分配策略主要有两种：
       <br/>
       固定分配：固定分配使进程在生命周期中保持固定数目的页框（即物理块）。
       <br/>
       可变分配：进程分得的页框数可变
       <br/>
       <strong>
        8、页面替换策略
       </strong>
       <br/>
       为装入待访问的外存页面而选择某一内存页面用以置换的策略
       <br/>
       主要有两种
       <br/>
       局部替换：进程发生缺页时仅从该进程的页框中淘汰页面，以调入所缺页面
       <br/>
       全局替换：进程发生缺页时从系统中任一进程的页框中淘汰页面
       <br/>
       <strong>
        9、缺页中断率影响因素
       </strong>
       <br/>
       ①进程分得的主存页框数
       <br/>
       ②页面大小
       <br/>
       ③页面替换算法的优劣决定缺页率
       <br/>
       ④程序特性
      </img>
     </img>
    </p>
    <h3>
     <a id="_258">
     </a>
     第五章
    </h3>
    <h6>
     <a id="_259">
     </a>
     设备类别
    </h6>
    <p>
     <strong>
      1、块设备
     </strong>
     <br/>
     块设备将信息存储在固定大小的块中，并且每个块都有地址，因此可独立寻址。
     <br/>
     所有传输以一个或多个完整的块为单位。
     <br/>
     硬盘、CD-ROM和USB盘是最常见的块设备。
     <br/>
     <strong>
      2、字符设备
     </strong>
     <br/>
     字符设备以字节为单位发送或接收一个字符流，且不可寻址。
     <br/>
     键盘、打印机、鼠标、网络接口，以及大多数与磁盘不同的设备都可以看做字符设备。
     <br/>
     <strong>
      3、顺序设备
     </strong>
     <br/>
     顺序设备上数据的逻辑顺序与物理存储顺序保持一致。
     <br/>
     <strong>
      4、随机设备
     </strong>
     <br/>
     随机设备上数据的逻辑顺序与物理存储顺序可以不一致。
    </p>
    <h6>
     <a id="IO_271">
     </a>
     I/O控制方式
    </h6>
    <p>
     主机通过控制器对设备输入、输出进行控制的方式有四种
     <br/>
     <strong>
      1、轮询
     </strong>
     <br/>
     轮询也称为忙等待，CPU向设备下达操作命令后，不断查询设备操作完成状态。
     <br/>
     <strong>
      2、中断控制
     </strong>
     <br/>
     在中断控制方式下，CPU向设备发出读写命令后，不再查询设备执行状态，转而执行其它计算任务。设备控制器完成读写操作后以中断的方式主动向CPU报告完成情况。CPU响应中断执行一个中断处理程序，将设备从外界获得的数据取走放到内存或者相反。
     <br/>
     <strong>
      3、直接存储器访问（DMA）
     </strong>
     <br/>
     DMA（直接存储器访问）方式允许I/O设备与内存之间直接交换一个连续的信息块，在传输期间无需CPU的干预，而是由专用处理器 DMA控制器完成具体传输控制操作。
     <br/>
     <strong>
      4、通道方式
     </strong>
     <br/>
     通道也叫输入输出处理器，是独立于CPU专门负责数据输入/输出传输工作的处理机，能执行自己的指令程序，代替CPU完成复杂的输入/输出操作，完成主存和外围设备间的信息传送，与CPU并行操作。
     <br/>
     在通道方式下，当进程需要执行I/O操作时，CPU只需启动通道，即可返回执行其它进程，通道则执行通道程序，对I/O操作进行控制。
    </p>
    <h6>
     <a id="IO_282">
     </a>
     IO软件系统
    </h6>
    <p>
     <strong>
      1、I/O软件总体设计目标
     </strong>
     <br/>
     高效率：确保I/O设备和CPU并行执行，提高资源利用率
     <br/>
     通用性：提供简单抽象、清晰统一的接口，采用统一标准的方法管理所有的设备和I/O操作
     <br/>
     <strong>
      2、I/O软件的四个层次
     </strong>
     <br/>
     （1）I/O中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断的进程。
     <br/>
     （2）设备驱动程序：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。
     <br/>
     （3）独立于设备的I/O软件：设备无关I/O软件的基本功能是执行所有设备公共的I/O功能，并向用户层软件提供统一的接口。
     <br/>
     （4）用户空间的I/O软件：实现与用户交互的接口，用户可直接调用该层所提供的、与IO操作有关的库函数对设备进行操作。
    </p>
    <h6>
     <a id="_291">
     </a>
     磁盘调度算法
    </h6>
    <p>
     <strong>
      1、先来先服务算法（FCFS）
     </strong>
     <br/>
     先来先服务算法根据磁道访问请求到来的先后顺序完成请求。
     <br/>
     假如系统先后到来对柱面12，80，5，60，95，20，86，35，72，55的访问请求，按照FCFS调度算法处理该请求序列。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6f702b13c7186fa9231c6749319e375e.png">
      <br/>
      <strong>
       2、最短寻道时间优先算法（SSTF）
      </strong>
      <br/>
      最短寻道时间优先算法总是优先满足距离磁头当前位置最近的访问请求。
      <br/>
      柱面访问请求到来顺序为：12，80，5，60，95，20，86，35，72，55，假定磁头位置当前在60号柱面。按照SSTF调度算法处理该请求序列。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8786ef7afc962ce5a2f50cf039b82657.png">
       <br/>
       <strong>
        3、电梯调度算法
       </strong>
       <br/>
       对于先后到达的磁盘访问请求，电梯调度算法首先选择移臂方向，磁臂在该方向上移动的过程中依次处理途经的各个访问请求，直到该方向上再无请求时，改变移臂方向，依次处理相反方向上遇到的各个请求。
       <br/>
       如果同一柱面上有多个请求，还需进行旋转优化。
       <br/>
       柱面访问请求到来顺序为：12，80，5，60，95，20，86，35，72，55，假定磁头正从60号磁道开始，向磁道号增加方向移动。按照电梯调度算法处理该请求序列。
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9b9b9ace17cf7df170ce6fd34e55751c.png"/>
      </img>
     </img>
    </p>
    <h6>
     <a id="Linux_305">
     </a>
     Linux磁盘调度算法
    </h6>
    <p>
     <strong>
      （1）电梯调度算法
     </strong>
     <br/>
     ①如果新请求与队列中等待请求的数据处于同一磁盘扇区或者相邻扇区，则两者合并成一个请求；
     <br/>
     ②如果队列中的请求已经存在很长时间，则新请求将被插入到队列尾部；
     <br/>
     ③如果存在合适的位置，则新请求将按顺序插入到队列中；如果没有合适的位置，则新的请求将被插入到队列尾部。
     <br/>
     <strong>
      （2）时限调度算法
     </strong>
     <br/>
     在电梯调度的基础上考虑请求为读还是写，异步还是同步，请求等待的时间长短，根据这些因素修正I/O请求的调度次序，避免饥饿。
     <br/>
     <strong>
      （3）预期调度算法
     </strong>
     <br/>
     对时限调度算法的补充，它预测已经发出读请求的进程很可能会在将来不久再次发出访问上次所读磁道附近的请求，于是不急于执行下一个请求，而是延迟若干毫秒，在延期内若有符合预测的新请求则满足之，没有再执行下一个请求。
    </p>
    <h6>
     <a id="_314">
     </a>
     虚拟设备
    </h6>
    <p>
     <strong>
      1、虚拟设备
     </strong>
     <br/>
     为了提高设备利用率，尤其是提高独占设备的利用率，减少作业周转时间，系统利用共享设备模拟独占设备的功能，使得独占设备成为能够共享的设备，这就是设备虚拟。
     <br/>
     <strong>
      2、SPOOLing系统的基本原理
     </strong>
     <br/>
     SPOOLing系统即假脱机系统。将原来以联机方式使用的独占设备改造成为脱机使用的虚拟共享设备。在联机方式下，每个需要设备I/O的进程排队等待向设备提交输入输出作业。
    </p>
    <h3>
     <a id="_319">
     </a>
     第六章
    </h3>
    <p>
     <strong>
      1、文件
     </strong>
     <br/>
     文件是记录在外存上具有名称的相关信息的集合。
     <br/>
     <strong>
      2、文件访问方式
     </strong>
     <br/>
     （1）顺序访问
     <br/>
     顺序访问从文件开头顺序读取文件的全部字节或记录，不能跳过某一些内容，文件后面的内容不能先于文件前面部分的内容读取出来。写入与此类似。
     <br/>
     后面的访问起点依赖于前面访问后确定的文件指针位置。
     <br/>
     （2）随机访问（直接访问）
     <br/>
     能够以任意次序读取其中字节或记录的文件称为随机存取文件或直接访问文件。直接访问文件可以立即访问需要的那部分信息，而不必涉及不需要的信息部分。
     <br/>
     （3）索引访问
     <br/>
     索引访问建立在直接访问方式上。
     <br/>
     索引访问需要为文件创建索引，这样的文件称为索引文件。
     <br/>
     <strong>
      3、文件操作
     </strong>
     <br/>
     1、创建文件（create）
     <br/>
     创建不包含任何数据的文件。
     <br/>
     在目录中为新文件创建目录条目，设置文件属性信息，如文件名等。
     <br/>
     2、打开文件（open）
     <br/>
     在使用文件之前，必须先打开文件。
     <br/>
     open调用将文件属性和磁盘地址表装入内存，便于后续操作访问。
     <br/>
     3、写文件（write）
     <br/>
     write调用针对已经打开的文件执行写操作。
     <br/>
     一般从当前位置开始写入信息。
     <br/>
     如果当前位置是文件末尾，则文件长度增加。
     <br/>
     如果当前位置在文件中间，则现有数据被覆盖。
     <br/>
     4、读文件（read）
     <br/>
     read调用针对已经打开的文件执行读操作。
     <br/>
     读出的数据一般来自文件当前位置。
     <br/>
     调用者需要指定读取的数据量和数据存放的缓冲区。
     <br/>
     5、调整读写指针（seek）
     <br/>
     seek调用调整读写指针的位置。
     <br/>
     6、关闭文件（close）
     <br/>
     文件访问结束时，关闭文件以释放文件属性及磁盘地址等不再需要的管理数据所占内存空间，同时写入文件的最后一块。
     <br/>
     7、删除文件（delete）
     <br/>
     删除不需要的文件，释放其所占外存空间。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


