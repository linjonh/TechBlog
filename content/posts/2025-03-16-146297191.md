---
layout: post
title: "Wireshark在-显示过滤器中加入条件过滤后,出现其他类型的数据包,为什么"
date: 2025-03-16 16:36:00 +0800
description: "在Wireshark中使用tcp。"
keywords: "Wireshark：在 显示过滤器中“加入条件”过滤后，出现其他类型的数据包，为什么？"
categories: ['计算机网络']
tags: ['网络']
artid: "146297191"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146297191
    alt: "Wireshark在-显示过滤器中加入条件过滤后,出现其他类型的数据包,为什么"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146297191
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146297191
cover: https://bing.ee123.net/img/rand?artid=146297191
image: https://bing.ee123.net/img/rand?artid=146297191
img: https://bing.ee123.net/img/rand?artid=146297191
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Wireshark：在 显示过滤器中“加入条件”过滤后，出现其他类型的数据包，为什么？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、
    </h2>
    <p>
     在Wireshark中使用
     <code>
      “tcp协议”
     </code>
     过滤后，仍出现TLSv1.2协议的数据包，原因如下：
    </p>
    <p>
     <img alt="" height="210" src="https://i-blog.csdnimg.cn/direct/e66b2cb8401641709f344854d9100544.png" width="741"/>
    </p>
    <h4>
     1. ‌
     <strong>
      协议层次关系
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      ‌
      <strong>
       TCP是传输层协议
      </strong>
      ‌，而‌
      <strong>
       TLS属于应用层协议
      </strong>
      ‌，后者直接运行于TCP之上‌28。因此，所有TLS流量（如HTTPS通信）均会通过TCP传输。当过滤TCP协议时，实际上会显示所有基于TCP的应用层协议流量，包括TLS‌。（如：HTTP等基于TCP的应用层协议）
     </li>
    </ul>
    <h4>
     2. ‌
     <strong>
      显示过滤器的逻辑
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      <code>
       tcp
      </code>
      过滤器仅筛选传输层协议为TCP的数据包，但‌
      <strong>
       不会排除TCP上层承载的具体应用协议
      </strong>
      ‌。例如，TLS握手过程（如ClientHello、ServerHello）均通过TCP报文传输，因此会被
      <code>
       tcp
      </code>
      过滤器命中‌。
     </li>
    </ul>
    <h4>
     3. ‌
     <strong>
      解决方案
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      ‌
      <strong>
       排除TLS流量
      </strong>
      ‌：通过组合过滤器
      <code>
       tcp and not tls
      </code>
      ，可仅显示非TLS的TCP流量‌37。
     </li>
     <li>
      ‌
      <strong>
       明确过滤目标
      </strong>
      ‌：若需分析纯TCP行为（如连接建立、流量控制等），需手动排除应用层协议干扰；若需分析TLS，可直接使用
      <code>
       tls
      </code>
      过滤器‌。
     </li>
    </ul>
    <h4>
     4. ‌
     <strong>
      示例场景
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      ‌
      <strong>
       HTTP与HTTPS对比
      </strong>
      ‌：HTTP直接基于TCP，而HTTPS需先完成TLS握手。因此，过滤
      <code>
       tcp
      </code>
      时会同时显示两者，但过滤
      <code>
       http
      </code>
      则仅显示HTTP流量‌。
     </li>
    </ul>
    <hr/>
    <p>
     总结：TCP过滤器的设计是捕获所有基于TCP的流量（含TLS）。若需精确分离TCP与TLS，需通过逻辑运算符组合过滤条件‌。
    </p>
    <p>
    </p>
    <h2>
     二、
    </h2>
    <p>
     在Wireshark中使用
     <code>
      tcp.port
     </code>
     过滤后，仍出现其他端口的数据包，原因及解决方案如下：
    </p>
    <p>
     <img alt="" height="187" src="https://i-blog.csdnimg.cn/direct/9afcb854b4c248e3a39c147948ab1813.png" width="763"/>
    </p>
    <hr/>
    <h4>
     1、核心原因
    </h4>
    <ol>
     <li>
      <p>
       ‌
       <strong>
        <code>
         tcp.port
        </code>
        的过滤逻辑问题
       </strong>
       ‌
      </p>
      <ul>
       <li>
        <code>
         tcp.port
        </code>
        仅匹配‌
        <strong>
         源端口或目标端口包含指定值的TCP数据包
        </strong>
        ‌，但‌
        <strong>
         不会排除其他传输层或应用层协议的流量
        </strong>
        ‌‌。例如，若过滤
        <code>
         tcp.port == 80
        </code>
        ，可能同时显示HTTP协议（端口80）和复用该端口的其他TCP应用协议数据包‌。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ‌
       <strong>
        协议层次嵌套
       </strong>
       ‌
      </p>
      <ul>
       <li>
        TCP为传输层协议，应用层协议（如HTTP、TLS、FTP等）均通过TCP端口传输。过滤
        <code>
         tcp.port
        </code>
        会显示‌
        <strong>
         所有基于该端口的应用层协议流量
        </strong>
        ‌（如HTTPS/TLSv1.2流量使用TCP 443端口）‌。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ‌
       <strong>
        多协议复用同一端口
       </strong>
       ‌
      </p>
      <ul>
       <li>
        某些场景下，同一端口可能承载多种协议（如SSH和自定义TCP服务复用22端口）。此时仅过滤端口无法区分具体协议‌。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     2、解决方案
    </h4>
    <ol>
     <li>
      <p>
       ‌
       <strong>
        精确过滤端口方向
       </strong>
       ‌
      </p>
      <ul>
       <li>
        使用
        <code>
         tcp.srcport
        </code>
        或
        <code>
         tcp.dstport
        </code>
        明确区分源/目标端口，避免因双向端口匹配引入干扰流量‌68。
       </li>
       <li>
        示例：
        <code>
         tcp.dstport == 80
        </code>
        （仅显示目标端口80的TCP数据包）
        <img alt="" height="156" src="https://i-blog.csdnimg.cn/direct/062975e1c06341328a30eeacfe9aebab.png" width="768"/>
       </li>
      </ul>
     </li>
     <li>
      <p>
       ‌
       <strong>
        结合应用层协议过滤
       </strong>
       ‌
      </p>
      <ul>
       <li>
        若需排除特定应用协议（如TLS），需添加
        <code>
         and not
        </code>
        条件。
       </li>
       <li>
        示例：
        <code>
         tcp.port == 443 and not tls
        </code>
        （过滤443端口但排除TLS协议）
       </li>
      </ul>
     </li>
     <li>
      <p>
       ‌
       <strong>
        检查过滤语法有效性
       </strong>
       ‌
      </p>
      <ul>
       <li>
        确认过滤器输入框显示为绿色（语法正确）。若为红色，需修正语法错误（如多余空格、运算符错误）‌。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ‌
       <strong>
        验证协议实际使用端口
       </strong>
       ‌
      </p>
      <ul>
       <li>
        通过
        <code>
         Statistics &gt; Protocol Hierarchy
        </code>
        查看各协议的真实端口分布，避免因端口复用导致误判‌。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     3、示例场景
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        需求
       </th>
       <th>
        过滤器
       </th>
       <th>
        效果
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        仅分析目标端口80的HTTP流量
       </td>
       <td>
        <code>
         tcp.dstport == 80 and http
        </code>
       </td>
       <td>
        排除非HTTP协议及源端口80的干扰
       </td>
      </tr>
      <tr>
       <td>
        抓取443端口但排除TLSv1.3
       </td>
       <td>
        <code>
         tcp.port == 443 and tls.handshake.version != 0x0304
        </code>
       </td>
       <td>
        精确过滤TLS版本
       </td>
      </tr>
      <tr>
       <td>
        分离SSH与自定义TCP服务（复用22端口）
       </td>
       <td>
        <code>
         tcp.port == 22 and (ssh or tcp.payload contains "CUSTOM_HEADER")
        </code>
       </td>
       <td>
        通过负载特征区分协议
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     4、总结
    </h4>
    <p>
     <code>
      tcp.port
     </code>
     仅作用于传输层端口，无法自动隔离应用层协议。需通过‌
     <strong>
      组合过滤条件
     </strong>
     ‌（端口+协议）或‌
     <strong>
      细化端口方向
     </strong>
     ‌实现精准过滤‌。对复杂场景，建议结合统计工具验证流量分布‌。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7a78663334373038353432302f:61727469636c652f64657461696c732f313436323937313931" class_="artid" style="display:none">
 </p>
</div>


