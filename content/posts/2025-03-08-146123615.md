---
layout: post
title: "leetcode-数组-双指针"
date: 2025-03-08 22:33:12 +0800
description: "处理最高位进位 ：如果最高位也需要进位（例如 [9,9] 加一后变为 [1,0,0] ），则需要在数组的最前面插入 1。== val ，则将 nums[j] 放到 nums[i] 的位置，并移动慢指针 i。这道题的目标是对一个用数组表示的非负整数加一，并返回结果数组。数组的每个元素表示数字的一位，最高位在数组的首位。你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。// 长度正确的预期答案。// 排序 nums 的前 k 个元素。"
keywords: "leetcode-数组-双指针"
categories: ['Leetcode']
tags: ['算法', '数据结构', 'Java']
artid: "146123615"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123615
    alt: "leetcode-数组-双指针"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123615
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123615
cover: https://bing.ee123.net/img/rand?artid=146123615
image: https://bing.ee123.net/img/rand?artid=146123615
img: https://bing.ee123.net/img/rand?artid=146123615
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     leetcode-数组-双指针
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     主要分为两种情况（1）快慢指针（2）背向、对向指针-&gt; &lt;-
    </p>
    <p>
    </p>
    <h2>
     126.删除有序数组中的重复项
    </h2>
    <p>
     相关标签
    </p>
    <p>
     相关企业
    </p>
    <p>
     提示
    </p>
    <p>
     给你一个
     <strong>
      非严格递增排列
     </strong>
     的数组
     <code>
      nums
     </code>
     ，请你
     <strong>
      <a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow" title=" 原地">
       原地
      </a>
     </strong>
     删除重复出现的元素，使每个元素
     <strong>
      只出现一次
     </strong>
     ，返回删除后数组的新长度。元素的
     <strong>
      相对顺序
     </strong>
     应该保持
     <strong>
      一致
     </strong>
     。然后返回
     <code>
      nums
     </code>
     中唯一元素的个数。
    </p>
    <p>
     考虑
     <code>
      nums
     </code>
     的唯一元素的数量为
     <code>
      k
     </code>
     ，你需要做以下事情确保你的题解可以被通过：
    </p>
    <ul>
     <li>
      更改数组
      <code>
       nums
      </code>
      ，使
      <code>
       nums
      </code>
      的前
      <code>
       k
      </code>
      个元素包含唯一元素，并按照它们最初在
      <code>
       nums
      </code>
      中出现的顺序排列。
      <code>
       nums
      </code>
      的其余元素与
      <code>
       nums
      </code>
      的大小不重要。
     </li>
     <li>
      返回
      <code>
       k
      </code>
      。
     </li>
    </ul>
    <p>
     <strong>
      判题标准:
     </strong>
    </p>
    <p>
     系统会用下面的代码来测试你的题解:
    </p>
    <pre>int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}</pre>
    <p>
     如果所有断言都通过，那么您的题解将被
     <strong>
      通过
     </strong>
     。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [1,1,2]
<strong>输出：</strong>2, nums = [1,2,_]</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,0,1,1,1,2,2,3,3,4]
<strong>输出：</strong>5, nums = [0,1,2,3,4]</pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= nums.length &lt;= 3 * 104
      </code>
     </li>
     <li>
      <code>
       -104 &lt;= nums[i] &lt;= 104
      </code>
     </li>
     <li>
      <code>
       nums
      </code>
      已按
      <strong>
       非严格递增
      </strong>
      排列
     </li>
    </ul>
    <p>
     解题思路
    </p>
    <p>
     使用
     <strong>
      双指针法
     </strong>
     ，慢指针
     <code>
      i
     </code>
     用于记录无重复元素的位置，快指针
     <code>
      j
     </code>
     遍历整个数组。
    </p>
    <p>
     代码实现
    </p>
    <pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if (nums.length === 0) return nums; // 如果数组为空，直接返回

    let i = 0; // 慢指针，指向当前唯一元素的位置
    for (let j = 1; j &lt; nums.length; j++) { // 快指针，遍历数组
        if (nums[j] !== nums[i]) { // 如果发现新元素
            i++; // 慢指针右移
            nums[i]=nums[j];     
        }
    }
    return i+1; // 返回修改后的数组
};</code></pre>
    <p>
     <a href="https://leetcode.cn/problems/remove-element/" rel="nofollow" title="27. 移除元素">
      27. 移除元素
     </a>
    </p>
    <h2>
     27.移除元素
    </h2>
    <p>
     相关标签
    </p>
    <p>
     相关企业
    </p>
    <p>
     提示
    </p>
    <p>
     给你一个数组
     <code>
      nums
     </code>
     <em>
     </em>
     和一个值
     <code>
      val
     </code>
     ，你需要
     <strong>
      <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" rel="nofollow" title="原地">
       原地
      </a>
     </strong>
     移除所有数值等于
     <code>
      val
     </code>
     <em>
     </em>
     的元素。元素的顺序可能发生改变。然后返回
     <code>
      nums
     </code>
     中与
     <code>
      val
     </code>
     不同的元素的数量。
    </p>
    <p>
     假设
     <code>
      nums
     </code>
     中不等于
     <code>
      val
     </code>
     的元素数量为
     <code>
      k
     </code>
     ，要通过此题，您需要执行以下操作：
    </p>
    <ul>
     <li>
      更改
      <code>
       nums
      </code>
      数组，使
      <code>
       nums
      </code>
      的前
      <code>
       k
      </code>
      个元素包含不等于
      <code>
       val
      </code>
      的元素。
      <code>
       nums
      </code>
      的其余元素和
      <code>
       nums
      </code>
      的大小并不重要。
     </li>
     <li>
      返回
      <code>
       k
      </code>
      。
     </li>
    </ul>
    <p>
     <strong>
      用户评测：
     </strong>
    </p>
    <p>
     评测机将使用以下代码测试您的解决方案：
    </p>
    <pre>int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i &lt; actualLength; i++) {
    assert nums[i] == expectedNums[i];
}</pre>
    <p>
     如果所有的断言都通过，你的解决方案将会
     <strong>
      通过
     </strong>
     。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [3,2,2,3], val = 3
<strong>输出：</strong>2, nums = [2,2,_,_]
<strong>解释：</strong>你的函数函数应该返回 k = 2, 并且 nums<em> </em>中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,1,2,2,3,0,4,2], val = 2
<strong>输出：</strong>5, nums = [0,1,4,0,3,_,_,_]
<strong>解释：</strong>你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       0 &lt;= nums.length &lt;= 100
      </code>
     </li>
     <li>
      <code>
       0 &lt;= nums[i] &lt;= 50
      </code>
     </li>
     <li>
      <code>
       0 &lt;= val &lt;= 100
      </code>
     </li>
    </ul>
    <p>
     解题思路
    </p>
    <p>
     慢指针 i ：指向当前可以放置不等于 val 的元素的位置。
    </p>
    <p>
     快指针 j ：遍历数组，检查每个元素是否等于 val 。
    </p>
    <p>
     移动元素 ：如果 nums[j] !== val ，则将 nums[j] 放到 nums[i] 的位置，并移动慢指针 i 。
    </p>
    <p>
     返回结果 ：最终 i 的值就是不等于 val 的元素数量。
    </p>
    <p>
     代码实现
    </p>
    <pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let i=0;//慢指针
    for(let j=0;j&lt;nums.length;j++){//快指针
        if(nums[j]!==val){
            nums[i]=nums[j];
            i++;//指针右移
        }
    }
    return i;//返回不等于val的元素数量
};</code></pre>
    <p>
     <a href="https://leetcode.cn/problems/plus-one/" rel="nofollow" title="66. 加一">
      66. 加一
     </a>
    </p>
    <h2>
     66.加一
    </h2>
    <p>
     给定一个由
     <strong>
      整数
     </strong>
     组成的
     <strong>
      非空
     </strong>
     数组所表示的非负整数，在该数的基础上加一。
    </p>
    <p>
    </p>
    <p>
     最高位数字存放在数组的首位， 数组中每个元素只存储
     <strong>
      单个
     </strong>
     数字。
    </p>
    <p>
     你可以假设除了整数 0 之外，这个整数不会以零开头。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>digits = [1,2,3]
<strong>输出：</strong>[1,2,4]
<strong>解释：</strong>输入数组表示数字 123。
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>digits = [4,3,2,1]
<strong>输出：</strong>[4,3,2,2]
<strong>解释：</strong>输入数组表示数字 4321。
</pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><strong>输入：</strong>digits = [9]
<strong>输出：</strong>[1,0]
<strong>解释：</strong>输入数组表示数字 9。
加 1 得到了 9 + 1 = 10。
因此，结果应该是 [1,0]。
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= digits.length &lt;= 100
      </code>
     </li>
     <li>
      <code>
       0 &lt;= digits[i] &lt;= 9
      </code>
     </li>
    </ul>
    <p>
     解题思路
    </p>
    <p>
     这是模拟加法的过程，和数组无关。
    </p>
    <p>
     这道题的目标是对一个用数组表示的非负整数加一，并返回结果数组。数组的每个元素表示数字的一位，最高位在数组的首位。
    </p>
    <p>
     思路： 从最低位开始加一 ：从数组的最后一个元素（最低位）开始，逐位加一。 处理进位 ：如果某一位加一后变为 10 ，则需要将这一位置为 0 ，并向高位进位。 处理最高位进位 ：如果最高位也需要进位（例如 [9,9] 加一后变为 [1,0,0] ），则需要在数组的最前面插入 1
    </p>
    <p>
     代码实现
    </p>
    <pre><code class="language-javascript">/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    for(let i=digits.length-1;i&gt;=0;i--){
        if(digits[i]&lt;9) {
            digits[i]++;
            return digits
        }else{
            digits[i]=0;
        }
    }
    digits.unshift(1);
    return digits;
};</code></pre>
    <h2>
     283.移动零
    </h2>
    <p>
     <a href="https://leetcode.cn/problems/move-zeroes/" rel="nofollow" title="283. 移动零">
      283. 移动零
     </a>
    </p>
    <p>
     给定一个数组
     <code>
      nums
     </code>
     ，编写一个函数将所有
     <code>
      0
     </code>
     移动到数组的末尾，同时保持非零元素的相对顺序。
    </p>
    <p>
     <strong>
      请注意
     </strong>
     ，必须在不复制数组的情况下原地对数组进行操作。
    </p>
    <p>
     <strong>
      示例 1:
     </strong>
    </p>
    <pre><strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>
<strong>输出:</strong> <code>[1,3,12,0,0]</code>
</pre>
    <p>
     <strong>
      示例 2:
     </strong>
    </p>
    <pre><strong>输入:</strong> nums = <code>[0]</code>
<strong>输出:</strong> <code>[0]</code></pre>
    <p>
    </p>
    <p>
     <strong>
      提示
     </strong>
     :
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= nums.length &lt;= 104
      </code>
     </li>
     <li>
      <code>
       -231 &lt;= nums[i] &lt;= 231 - 1
      </code>
     </li>
    </ul>
    <p>
    </p>
    <p>
     <strong>
      进阶：
     </strong>
     你能尽量减少完成的操作次数吗？
    </p>
    <p>
     实现思路
    </p>
    <p>
     使用 双指针法 ：
    </p>
    <p>
     快慢指针 ： 使用一个慢指针 slow 指向当前非零元素的位置。 使用一个快指针 fast 遍历数组。 当 nums[fast] 不为零时，将其赋值给 nums[slow] ，然后 slow++ 。
    </p>
    <p>
     填充零 ： 遍历结束后，将 slow 之后的所有位置填充为零。 这种方法的时间复杂度为 O(n) ，空间复杂度为 O(1) 。
    </p>
    <p>
     代码实现
    </p>
    <pre><code class="language-javascript">var moveZeroes = function(nums) {
    let slow=0;
    // 将非零元素移到前面
    for(let fast=0;fast&lt;nums.length;fast++){
        if(nums[fast]!==0){
            nums[slow]=nums[fast]
            slow++
        }
    }
    // 剩余位置填充为0
    for(let i=slow ;i&lt;nums.length;i++){
        nums[i]=0
    }

};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35363130313638382f:61727469636c652f64657461696c732f313436313233363135" class_="artid" style="display:none">
 </p>
</div>


