---
layout: post
title: "C项目实战校园公告搜索引擎完整实现与优化指南"
date: 2025-03-14 05:21:43 +0800
description: "杭州师范大学教务处官网是学校发布公告的重要平台，旨在为校内师生提供及时的信息服务。然而，目前官网存在以下问题：① 更新滞后：主页展示的公告多为旧信息，用户难以快速获取最新动态，增加了时间成本。② 搜索功能不足：官网搜索引擎缺乏按时间排序的功能，这显然满足不了用户的核心需求，因为公告具有时效性。③ 界面设计欠佳：搜索界面不够美观，用户体验较差。基于以上问题，我决定开发一个教务处官网公告的搜索引擎，旨在为校内师生提供一个更高效、更直观的信息检索工具，帮助用户快速获取最新公告信息，提升使用体验。 "
keywords: "【C++项目实战】校园公告搜索引擎：完整实现与优化指南"
categories: ['C']
tags: ['网络', '服务器', '搜索引擎', 'C']
artid: "146230928"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146230928
    alt: "C项目实战校园公告搜索引擎完整实现与优化指南"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146230928
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146230928
cover: https://bing.ee123.net/img/rand?artid=146230928
image: https://bing.ee123.net/img/rand?artid=146230928
img: https://bing.ee123.net/img/rand?artid=146230928
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【C++项目实战】校园公告搜索引擎：完整实现与优化指南
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="52bc67966cad45eda96494d9b411954d.png" height="91" src="https://i-blog.csdnimg.cn/direct/52bc67966cad45eda96494d9b411954d.png" width="91"/>
    </p>
    <p>
     <strong>
      🎬 个人主页：
      <strong>
       <strong>
        <strong>
         <strong>
          <strong>
           <strong>
            <strong>
             <strong>
              <strong>
               <strong>
                <strong>
                 <strong>
                  <strong>
                   <strong>
                    <strong>
                     <a href="https://blog.csdn.net/dhgiuyawhiudwqha?type=blog" title="谁在夜里看海.">
                      谁在夜里看海.
                     </a>
                    </strong>
                   </strong>
                  </strong>
                 </strong>
                </strong>
               </strong>
              </strong>
             </strong>
            </strong>
           </strong>
          </strong>
         </strong>
        </strong>
       </strong>
      </strong>
     </strong>
    </p>
    <p>
     📖
     <strong>
      个人专栏：
      <strong>
       <strong>
        <strong>
         <strong>
          <strong>
           <strong>
            <strong>
             <strong>
              <strong>
               <strong>
                <strong>
                 <strong>
                  <strong>
                   <strong>
                    <strong>
                     <a href="https://blog.csdn.net/dhgiuyawhiudwqha/category_12317119.html?spm=1001.2014.3001.5482" title="《C++系列》">
                      《C++系列》
                     </a>
                    </strong>
                   </strong>
                  </strong>
                 </strong>
                </strong>
               </strong>
              </strong>
             </strong>
            </strong>
           </strong>
          </strong>
         </strong>
        </strong>
       </strong>
      </strong>
      <strong>
       <strong>
        <strong>
         <strong>
          <strong>
           <strong>
            <strong>
             <strong>
              <strong>
               <strong>
                <strong>
                 <strong>
                  <strong>
                   <strong>
                    <strong>
                     <a href="https://blog.csdn.net/dhgiuyawhiudwqha/category_12291688.html?spm=1001.2014.3001.5482" title="《Linux系列》">
                      《Linux系列》
                     </a>
                     <a href="https://blog.csdn.net/dhgiuyawhiudwqha/category_12832406.html" title="《算法系列》">
                      《算法系列》
                     </a>
                    </strong>
                   </strong>
                  </strong>
                 </strong>
                </strong>
               </strong>
              </strong>
             </strong>
            </strong>
           </strong>
          </strong>
         </strong>
        </strong>
       </strong>
      </strong>
     </strong>
    </p>
    <p>
     ⛰️
     <strong>
      道阻且长，行则将至
     </strong>
    </p>
    <p>
     <img alt="" height="1600" src="https://i-blog.csdnimg.cn/direct/fc2b77a8d9c3456ea21d7e871906f5b0.jpeg" width="2560"/>
    </p>
    <hr/>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="%F0%9F%93%9A%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0" name="%F0%9F%93%9A%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0">
     📚一、项目概述
    </h3>
    <h4 id="%F0%9F%93%961.%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" name="%F0%9F%93%961.%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">
     📖1.项目背景
    </h4>
    <p>
     杭州师范大学教务处官网是学校发布公告的重要平台，旨在为校内师生提供及时的信息服务。然而，目前官网存在以下问题：
    </p>
    <p>
     <strong>
      ① 更新滞后
     </strong>
     ：主页展示的公告多为旧信息，用户难以快速获取最新动态，增加了时间成本。
    </p>
    <p>
     <strong>
      ② 搜索功能不足
     </strong>
     ：官网搜索引擎缺乏按时间排序的功能，这显然满足不了用户的核心需求，因为公告具有时效性。
    </p>
    <p>
     <strong>
      ③ 界面设计欠佳
     </strong>
     ：搜索界面不够美观，用户体验较差。
    </p>
    <p>
     基于以上问题，我决定开发一个
     <strong>
      教务处官网公告的搜索引擎
     </strong>
     ，旨在为校内师生提供一个更高效、更直观的信息检索工具，帮助用户快速获取最新公告信息，提升使用体验。
    </p>
    <p>
     <img alt="" height="927" src="https://i-blog.csdnimg.cn/direct/9026e65d5bd4424494a09d3090bb3cb4.png" width="1918"/>
    </p>
    <h4 id="%F0%9F%93%962.%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" name="%F0%9F%93%962.%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">
     📖2.主要功能
    </h4>
    <p>
     校园公告搜索引擎是一个专门服务于本校师生的信息检索平台，其核心功能是基于教务处官网的公告公文提供
     <strong>
      关键字搜索
     </strong>
     服务。用户可以通过在搜索框中输入关键字，快速浏览相关公告的摘要信息，并直接点击链接跳转至学校官网查看完整内容，实现高效便捷的信息获取。下面是项目的界面展示：
    </p>
    <h4 id="%F0%9F%93%963.%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA" name="%F0%9F%93%963.%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA">
     📖3.界面展示
    </h4>
    <p>
     界面设计简洁直观，包含以下内容：
    </p>
    <p>
     <strong>
      ① 搜索框：
     </strong>
     位于页面顶部显著位置，支持用户输入关键字进行公告检索；
    </p>
    <p>
     <strong>
      ② 按时间排序选项：
     </strong>
     位于搜索框侧边，提供将搜索结果按发布时间排序的功能。考虑到官网公告的时效性，这个功能是很必要的。
    </p>
    <p>
     <strong>
      ③ 翻页按钮：
     </strong>
     位于页面底部，方便用户在搜索结果较多时进行分页浏览。
    </p>
    <p>
     学校官网也有自己的搜索引擎，但是不具备时间排序的功能，这就有一个问题：
     <span style="color:#ed7976">
      用户想通过关键词搜索到最新的公告，但是服务器返回的结果是默认按照关键词权重（关键词在文章0出现的频率）进行排序的，用户并不能立刻得到想要的结果：
     </span>
    </p>
    <p>
     <em>
      这是学校官网的搜索结果：
     </em>
    </p>
    <p>
     <img alt="" height="928" src="https://i-blog.csdnimg.cn/direct/2dc4a3a6826b4bf49d98e37a162305e9.png" width="1265"/>
    </p>
    <p>
     <em>
      这是个人引擎的搜索结果：
     </em>
    </p>
    <p>
     <img alt="" height="925" src="https://i-blog.csdnimg.cn/direct/86efac1b44444cb9a41baebfa6ca9f50.png" width="1896"/>
    </p>
    <p>
     由于引擎搜索数据来源全部来自学校官网，数据量其实并不大（从教务处官网爬下来的公告，总共也就两千多条），所以关键字的覆盖范围有限，如果用户输入了一个不存在的关键字，系统会贴心地给出提示，并给出以下选项：
    </p>
    <p>
     <strong>
      ①
     </strong>
     <strong>
      跳转学校官网：
     </strong>
     可以直接去学校官网查看最新公告（目前项目还有瑕疵，尚未实现在线更新功能，有待后续开发）；
    </p>
    <p>
     <strong>
      ② 访问博主个人博客：
     </strong>
     相当于打个广告吧hh；
    </p>
    <p>
     <strong>
      ③
     </strong>
     <strong>
      查看项目源码：
     </strong>
     如果对这个项目感兴趣，也可以跳转查看源码。
    </p>
    <p>
     <img alt="" height="932" src="https://i-blog.csdnimg.cn/direct/d7bc6954a9574c65aef2a0008a7ff62d.png" width="1919"/>
    </p>
    <h3 id="%F0%9F%93%9A%E4%BA%8C%E3%80%81%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF" name="%F0%9F%93%9A%E4%BA%8C%E3%80%81%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF">
     📚二、技术背景
    </h3>
    <h4 id="%F0%9F%93%961.%E6%8A%80%E6%9C%AF%E6%A0%88" name="%F0%9F%93%961.%E6%8A%80%E6%9C%AF%E6%A0%88">
     📖1.技术栈
    </h4>
    <p>
     本项目采用以下技术栈：
    </p>
    <p>
     <strong>
      Boost
     </strong>
     准标准库：用于高效的
     <span style="color:#ff9900">
      文件操作
     </span>
     和字符串处理。
    </p>
    <p>
     <strong>
      cppjieba
     </strong>
     分词库：实现
     <span style="color:#ff9900">
      中文关键字的分词
     </span>
     功能，提升搜索准确性。
    </p>
    <p>
     <strong>
      jsoncpp
     </strong>
     序列化工具：将搜索结果
     <span style="color:#ff9900">
      序列化为JSON格式
     </span>
     ，便于前后端交互。
    </p>
    <p>
     <strong>
      httplib
     </strong>
     服务器库：快速搭建
     <span style="color:#ff9900">
      轻量级HTTP服务器
     </span>
     ，处理搜索请求与响应。
    </p>
    <p>
     接下来，详细介绍项目的具体实现过程。
    </p>
    <h4 id="%F0%9F%93%962.%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91" name="%F0%9F%93%962.%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91">
     📖2.核心逻辑
    </h4>
    <p>
     首先我们需要了解搜索引擎的核心逻辑：客户端发送搜索关键字，服务端根据关键字检索匹配对应的结果，并将结果返回给客户端。搜索结果通常由三部分组成：
    </p>
    <p>
     ① 文档标题：简明扼要地概括文档内容；
    </p>
    <p>
     ②
     <strong>
     </strong>
     文档摘要：包含关键字的部分内容，帮助用户快速了解文档相关性；
    </p>
    <p>
     ③ 文档URL：提供跳转链接，方便用户查看完整内容。
    </p>
    <p>
     所以实现搜索返回结果，最关键的是：
     <span style="color:#ff9900">
      如何根据关键字匹配返回内容？返回内容从何而来？
     </span>
     我们不能简单地将客户端的关键字转发给其他搜索引擎，因为返回结果必须来自本地服务器。因此，我们需要在本地构建一个数据库，存储文档的基本数据单元，即：
     <strong>
      文档标题、文档摘要、文档URL。
     </strong>
    </p>
    <p>
     文档内容又从何而来，市面上主流的搜索引擎（如Google、百度）通过
     <strong>
      网络爬虫
     </strong>
     不断从互联网上抓取网页内容， 将其转换为数据单元并存储在本地数据库中，从而实现全网搜索。
    </p>
    <p>
     构建一个全网搜索引擎的成本和资源需求极高，尤其是对于个人开发者来说，无论是数据存储、计算能力还是网络带宽，都远远超出了博主现有云服务器的承载能力。然而，实现一个
     <strong>
      校园网站公告的搜索引擎
     </strong>
     则是一个更加实际和可行的选择。
     <span style="color:#a2e043">
      校园公告的数据量相对较小，存储和检索的开销也相对较低，完全可以在云服务器的能力范围内高效运行
     </span>
     。这种小而精的项目不仅降低了技术门槛，还能为校园用户提供切实的便利，是一个理想的学习和实践目标。
    </p>
    <h3 id="%F0%9F%93%9A%E4%B8%89%E3%80%81%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0" name="%F0%9F%93%9A%E4%B8%89%E3%80%81%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0">
     📚三、后端实现
    </h3>
    <p>
     在掌握了搜索引擎的基本原理和数据结构后，我们开始着手实现后端部分。以下是具体的设计与实现过程：
    </p>
    <h4 id="%F0%9F%93%961.%E6%9E%84%E5%BB%BA%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93" name="%F0%9F%93%961.%E6%9E%84%E5%BB%BA%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93">
     📖1.构建
     <strong>
      原生数据库
     </strong>
    </h4>
    <h5 id="%F0%9F%94%96%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96" name="%F0%9F%94%96%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96">
     🔖
     <strong>
      网页爬取
     </strong>
    </h5>
    <p>
     首选，我们需要从教务处官网爬取内容，将结果保存为本地.html文件，这些文件是后续处理的基础数据源。这里我们使用wget工具进行网页爬取：
    </p>
    <p>
     <strong>
      <code>
       wget
      </code>
     </strong>
     是一个强大的命令行工具，用于从网络上下载文件，具有递归下载、断点续传、限速等特性，非常适合用于批量下载文件或爬取网站内容。我们在云服务终端输入以下命令：
    </p>
    <blockquote>
     <p>
      wget --recursive --no-clobber --no-parent --convert-links --domains jwc.hznu.edu.cn --directory-prefix=data/source_html -A .shtml https://jwc.hznu.edu.cn/
     </p>
    </blockquote>
    <p>
     <strong>
      参数说明：
     </strong>
    </p>
    <p>
     --recursive：递归下载整个网站的内容；
    </p>
    <p>
     --no-clobber：如果文件已存在，则不会重复下载（避免覆盖）；
    </p>
    <p>
     --no-parent：不下载父目录中的内容，仅限当前目录及子目录；
    </p>
    <p>
     --convert-links：将下载的文件中的链接转换为本地链接，方便本地查看；
    </p>
    <p>
     --domains jwc.hznu.edu.cn：限制只下载指定域名下的内容
    </p>
    <p>
     --directory-prefix=data/source_html：将下载的内容保存到
     <code>
      data/source_html
     </code>
     目录下；
    </p>
    <p>
     -A .shtml：仅下载
     <code>
      .shtml
     </code>
     文件。
    </p>
    <p>
     <img alt="" height="288" src="https://i-blog.csdnimg.cn/direct/e602d32fb6e7445184849afcf9d3791a.png" width="1015">
      官网的文件就是shtml格式的，这样我们就能准确地将所有公告文件爬取到本地，忽略不需要的文件。由于官网中公告文件都保存在“/c”目录下，我们通过wget工具爬取到本地后转换成本地链接，也是保存在/c目录下面：
     </img>
    </p>
    <p>
     <img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/ea06f2aea1774833af6594245c283874.png" width="206"/>
    </p>
    <p>
     我们可以看到，公告文件是按照时间进行分目有序存储，我们可以通过find指令查看总文件数：
    </p>
    <p>
     <img alt="" height="68" src="https://i-blog.csdnimg.cn/direct/db0661408fea4233b782a3daca01297d.png" width="785"/>
    </p>
    <p>
     接下来的步骤，就是把下载下来的2064个shtml文件整理到一起：
    </p>
    <h5 id="%F0%9F%94%96%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86" name="%F0%9F%94%96%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86">
     🔖
     <strong>
      数据整理
     </strong>
    </h5>
    <p>
     爬取到的
     <code>
      .html
     </code>
     文件内容较为杂乱，需要进一步整理并提取关键信息。为了实现这一目标，首先需要递归地遍历
     <code>
      /c
     </code>
     目录，获取全部的
     <code>
      .shtml
     </code>
     文件。虽然可以通过
     <code>
      open
     </code>
     打开文件读取数据，但递归访问目录是一个需要解决的问题。这里，我们可以使用
     <span style="color:#ff9900">
      <code>
       Boost.Filesystem
      </code>
      库
     </span>
     来实现这一功能。
    </p>
    <p>
     <code>
      Boost.Filesystem
     </code>
     是一个强大的文件系统操作库，提供了跨平台的目录遍历、文件操作等功能。然而，
     <span style="color:#ed7976">
      <code>
       Boost
      </code>
      并不是 C++ 官方标准库
     </span>
     ，因此需要先下载并安装到本地才能使用。
    </p>
    <p>
     下面是Boost::filesystem库的具体使用过程：
    </p>
    <pre><code class="language-cpp">// 借助 Boost 库递归遍历目录，汇总 .html 文件
bool Enumfile(const string &amp;src_path, vector&lt;string&gt; *files_list)
{
    namespace fs = boost::filesystem; // 命名空间别名，简化代码
    fs::path root_path(src_path);    // 将字符串路径转换为 boost::filesystem::path 对象

    // 判断路径是否存在
    if (!fs::exists(root_path))
    {
        cerr &lt;&lt; src_path &lt;&lt; " not exists!" &lt;&lt; endl;
        return false;
    }

    // 设置一个空的迭代器，作为结束标志
    fs::recursive_directory_iterator end;

    // 递归遍历目录
    for (fs::recursive_directory_iterator it(root_path); it != end; ++it)
    {
        // 如果当前文件不是普通文件，则跳过
        if (!fs::is_regular_file(*it))
            continue;

        // 如果当前文件后缀不是 .html，则跳过
        if (it-&gt;path().extension() != ".html")
            continue;

        // 将文件名以字符串形式插入列表
        files_list-&gt;push_back(it-&gt;path().string());
    }

    return true;
}</code></pre>
    <p>
     如此一来，我们所有的shtml文件内容就以一个个字符串的形式保存在了vector数组中。
    </p>
    <h5 id="%F0%9F%94%96%E6%A0%87%E7%AD%BE%E6%B8%85%E6%B4%97" name="%F0%9F%94%96%E6%A0%87%E7%AD%BE%E6%B8%85%E6%B4%97">
     🔖标签清洗
    </h5>
    <p>
     shtml文件中包含了关于整个网页的内容，但是我们只需要三部分内容：
     <strong>
      文档标题、文档摘要、文档URL
     </strong>
     。所以下一步，我们要从shtml源文件中提取出这三要素作为一个数据单元进行存储，这个步骤就是
     <span style="color:#ff9900">
      标签清洗
     </span>
     的过程。
    </p>
    <p>
     <span style="color:#38d8f0">
      <strong>
       ①文档标题
      </strong>
     </span>
    </p>
    <p>
     在html中，&lt;title&gt;定义网页的标题，但是在官网公告中
    </p>
    <p>
     <img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/173a4fe6800d4469aa4494684cfc80ee.png" width="1255"/>
    </p>
    <p>
     将“杭州师范大学教务处”作为网页的标题，而并不是公告的标题，所以我们需要找到公告标题对应的标签是什么。在网页中，我们选中公告标题，选择网页检查，就可以看到源码中的位置：
    </p>
    <p>
     <img alt="" height="365" src="https://i-blog.csdnimg.cn/direct/178ec1a8438d4a308c28c32ba078935c.png" width="1290"/>
    </p>
    <p>
     原来标题被定义为了&lt;h1&gt;标签，也就是一级标题，所以我们在源文件中，只需要定位到&lt;h1&gt;标签就可以找到文档标题了。
    </p>
    <p>
     <strong>
      <span style="color:#38d8f0">
       ②文档正文
      </span>
     </strong>
    </p>
    <p>
     文档正文内容位于标签&lt;div class=\"sp-content\"&gt;下，我们同样定位到该标签处，将后续标签清洗，保留正文部分。
    </p>
    <p>
     <img alt="" height="486" src="https://i-blog.csdnimg.cn/direct/934fbf635db84cb59b7c935076c4f634.png" width="1475"/>
    </p>
    <p>
     标签清洗的核心逻辑是：在遍历 HTML 内容时，忽略掉所有被
     <code>
      &lt;
     </code>
     和
     <code>
      &gt;
     </code>
     包围的部分（即标签），而保留未被
     <code>
      &lt;
     </code>
     和
     <code>
      &gt;
     </code>
     包围的部分（即正文内容）。为了实现这一逻辑，我们可以通过定义一个状态机来实现。
    </p>
    <p>
     状态机的设计如下：
    </p>
    <p>
     ①
     <strong>
      初始状态为
      <code>
       TAG
      </code>
     </strong>
     ，因为遍历通常从
     <code>
      &lt;
     </code>
     开始；
    </p>
    <p>
     ② 当遇到
     <code>
      &gt;
     </code>
     时，状态
     <strong>
      从
      <code>
       TAG
      </code>
      切换到
      <code>
       CONTENT
      </code>
     </strong>
     ，表示接下来是正文部分；
    </p>
    <p>
     ③ 当再次遇到
     <code>
      &lt;
     </code>
     时，状态
     <strong>
      从
      <code>
       CONTENT
      </code>
      切换回
      <code>
       TAG
      </code>
     </strong>
     ，表示接下来的内容是标签；
    </p>
    <p>
     ④ 重复上述过程，直到遍历完整个 HTML 内容。
    </p>
    <pre><code class="language-cpp">static bool ParseContent(const string &amp;file, string *content)
{
    size_t begin = file.find("&lt;div class=\"sp-content\"&gt;");
    if(begin == string::npos){
        return false;
    }
    begin += string("&lt;div class=\"sp-content\"&gt;").size();
    size_t end = file.find("&lt;div class=\"foter\"&gt;");
    if(end == string::npos){
        return false;
    }
    // 使用状态机，去除标签
    enum status{
        LABLE,
        CONTENT
    };
    enum status s = LABLE;
    for(size_t i = begin; i &lt; end; ++i){
        // cout &lt;&lt; "curent status: " &lt;&lt; s &lt;&lt; endl;
        switch(s){
            case LABLE:
                if(file[i] == '&gt;'){
                    s = CONTENT;
                }
                break;
            case CONTENT:
                if(file[i] == '&lt;'){
                    s = LABLE;
                }
                else{
                    char tmp = file[i];
                    if(tmp == '\n') tmp = ' ';
                    content-&gt;push_back(tmp);
                }
                break;
            default:
                break;
        }
    }

    return true;
}</code></pre>
    <p>
     <span style="color:#38d8f0">
      <strong>
       ③文档URL
      </strong>
     </span>
    </p>
    <p>
     在 HTML 源码中，通常不会直接包含网页的完整 URL 信息，因此我们需要通过其他方式推断出 URL。
     <span style="color:#ff9900">
      网页在网站中的存储通常遵循一定的路径规则
     </span>
     。以教务处官网为例，所有公告网页都存储在
     <code>
      /c
     </code>
     目录下。当我们使用
     <code>
      wget
     </code>
     工具将这些网页下载到本地时，文件的路径结构与官网保持一致，即在本地也保留了
     <code>
      /c
     </code>
     目录下的相对路径。基于这一特性，我们可以通过以下步骤获取网页的完整 URL：即
     <span style="color:#a2e043">
      将官网的基础路径与本地文件的相对路径拼接，就得到了完整的URL
     </span>
     。
    </p>
    <p>
     <img alt="" height="275" src="https://i-blog.csdnimg.cn/direct/5ee3efcbdb334c34ad0ad6688628e879.png" width="896"/>
    </p>
    <h5 id="%F0%9F%94%96%E4%BF%9D%E5%AD%98%E4%BF%A1%E6%81%AF" name="%F0%9F%94%96%E4%BF%9D%E5%AD%98%E4%BF%A1%E6%81%AF">
     🔖保存信息
    </h5>
    <p>
     我们将提取出的
     <strong>
      文档标题
     </strong>
     、
     <strong>
      文档摘要
     </strong>
     和
     <strong>
      文档URL
     </strong>
     这三个关键信息存储在一个
     <code>
      DocInfo
     </code>
     结构体中，作为基本的数据单元，然后将这些数据单元按行写入到一个文本文件（
     <code>
      raw.txt
     </code>
     ）中，其中每个数据单元内部的字段之间用特殊分隔符（如
     <code>
      \3
     </code>
     ）分隔，不同数据单元之间用换行符
     <code>
      \n
     </code>
     分隔。这个
     <code>
      raw.txt
     </code>
     文件不仅实现了
     <span style="color:#a2e043">
      数据的持久化存储
     </span>
     ，还为后续索引构建和搜索功能提供
     <span style="color:#a2e043">
      基础数据源
     </span>
     。
    </p>
    <p>
     <strong>
      下面是构建原生数据库的核心代码片段：
     </strong>
    </p>
    <pre><code class="language-cpp">const string src_path = "data/source_html/test";
const string output = "data/raw_data/test.txt";

typedef struct DocInfo{
    string title;   // 文档标题
    string content; // 文档的内容
    string url;     // 文档的url
}DocInfo_t;

// const &amp; 输入
//       * 输出
//       &amp; 输入输出
bool Enumfile (const string &amp;src_path, vector&lt;string&gt; *files_list);
bool ParseHtml (const vector&lt;string&gt; &amp;files_list, vector&lt;DocInfo_t&gt; *results);
bool SaveHtml (const vector&lt;DocInfo_t&gt; &amp;results, const string &amp;output);

int main()
{
    // 1.遍历指定目录，将html文件汇总在列表里
    vector&lt;string&gt; files_list;
    if(!Enumfile(src_path, &amp;files_list))
    {
        cerr &lt;&lt; "Enum file name error!" &lt;&lt; endl;
        return 1;
    }

    // 2.将列表中的每个文件进行解析，提取关键数据
    vector&lt;DocInfo_t&gt; results;
    if(!ParseHtml(files_list, &amp;results))
    {
        cerr &lt;&lt; "Parse html error!" &lt;&lt; endl;
        return 2;
    }

    // 3.将解析后的数据保存到指定文件中
    if(!SaveHtml(results, output))
    {
        cerr &lt;&lt; "Save html error!" &lt;&lt; endl;
        return 3;
    }
    
    return 0;
}</code></pre>
    <h4 id="%F0%9F%93%962.%E6%9E%84%E5%BB%BA%E7%B4%A2%E5%BC%95" name="%F0%9F%93%962.%E6%9E%84%E5%BB%BA%E7%B4%A2%E5%BC%95">
     📖2.构建索引
    </h4>
    <p>
     在数据库建立完成后，我们可以编写程序处理搜索关键字并返回相关内容：首先
     <span style="color:#a2e043">
      接收用户输入的关键字，然后在数据库中检索
      <code>
       title
      </code>
      和
      <code>
       content
      </code>
      字段包含该关键字的文档
     </span>
     ；由于一个关键字可能匹配多个文档，而数据库未对结果排序，我们需要将这些文档提取到
     <code>
      vector
     </code>
     容器中，按相关性或其他规则进行排序，最后将排序后的文档作为搜索结果返回给用户。
    </p>
    <p>
     所以第一步我们需要建立的是通过文档ID索引文档信息的
     <span style="color:#ff9900">
      正排索引
     </span>
     。
    </p>
    <h5 id="%F0%9F%94%96%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95" name="%F0%9F%94%96%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95">
     🔖正排索引
    </h5>
    <pre><code class="language-cpp">    // 正排索引数据节点
    struct DocInfo{
        string title;    // 文档标题
        string content;  // 文档去标签后的内容
        string url;      // 官网的网址
        string time;     // 文档时间
        uint64_t doc_id; // 文档ID
    };

    // 正排索引通过数组实现，下标天然为文档ID
    vector&lt;DocInfo&gt; forward_index;</code></pre>
    <p>
     构建正排索引的过程是
     <strong>
      通过文档 ID 索引文档信息
     </strong>
     。在
     <code>
      vector
     </code>
     容器中，下标天然可以作为文档 ID，而文档信息结构包括【title、content、URL、ID】。我们可以使用
     <code>
      std::ifstream
     </code>
     创建一个读取流，将文档内容写入流中，并通过
     <code>
      std::getline
     </code>
     方法循环读取，每次读取的恰好是一个文档（文档之间用
     <code>
      \n
     </code>
     分隔）。
    </p>
    <p>
     读取到的文档是一个字符串，信息段之间用
     <code>
      \3
     </code>
     分隔，因此需要对字符串进行分割。我们可以手动编写分割代码（遍历字符串，遇到
     <code>
      \3
     </code>
     时分割），也可以使用
     <strong>
      <code>
       boost::split
      </code>
     </strong>
     方法，它能够根据指定字符分割字符串，并将结果存储到
     <code>
      vector
     </code>
     数组中。分割完成后，将数据段组合成
     <code>
      DocInfo
     </code>
     结构，并存储到正排索引的
     <code>
      vector
     </code>
     容器中。
    </p>
    <p>
     <strong>
      下面是构建正排索引的代码实现：
     </strong>
    </p>
    <pre><code class="language-cpp">        // 创建正排索引
        DocInfo *BuildForwardInfo(const string &amp;line)
        {
            // 1.对字符串进行切分：title、content、url
            vector&lt;string&gt; results;
            const string sep = "\3";
            ns_util::StringUtil::CutString(line, &amp;results, sep);
            if(results.size() &lt; 3){
                return nullptr;
            }
            // 2.字符串填充到DocInfo结构中
            DocInfo doc;
            doc.title = results[0];
            doc.content = results[1];
            doc.url = results[2];
            doc.doc_id = forward_index.size();
            
            // 从URL中提取时间
            doc.time = ExtractTimeFromUrl(doc.url);
            
            // 3.插入到正排索引的vector中
            forward_index.push_back(move(doc));
            
            return &amp;forward_index.back();
        }</code></pre>
    <h5 id="%F0%9F%94%96%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" name="%F0%9F%94%96%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">
     🔖倒排索引
    </h5>
    <pre><code class="language-cpp">    // 倒排索引数据节点
    struct InvertedElem{
        uint64_t doc_id; // 文档ID
        string word;     // 关键字
        int weight;      // 关键字的权重
    };
    
    // 倒排索引通过键值对实现，一个关键字映射一个/多个倒排拉链结构
    unordered_map&lt;string, InvertedList&gt; inverted_index;</code></pre>
    <p>
     为了通过关键字获取文档信息，我们需要构建倒排索引。倒排索引是一种映射关系，通过关键字映射到文档信息，文档信息结构包括【ID、word关键字、weight权重】。其中，
     <span style="color:#ff9900">
      文档 ID 用于索引正排容器以获取更详细的文档信息，而 weight 权重则用于文档的排序
     </span>
     。由于关键字在每个文档中出现的频率不同，我们需要将检索到的文档按照关键字出现频率
     <strong>
      从高到低排列返回
     </strong>
     。
    </p>
    <p>
     因此，我们需要构建倒排索引结构，这就要求我们将所有关键字列举出来。关键字是从文档的
     <code>
      title
     </code>
     和
     <code>
      content
     </code>
     中提取的，因此
     <span style="color:#a2e043">
      在构建每一个正排索引时，可以同时构建该文档的所有关键字的倒排索引
     </span>
     。那么，关键字的提取规则是什么呢？
    </p>
    <p>
     我们可以使用
     <strong>
      <code>
       cppjieba
      </code>
      分词工具
     </strong>
     ，其中的
     <strong>
      <code>
       jieba::for_search
      </code>
     </strong>
     方法专门用于搜索关键字的分词。由于关键字在
     <code>
      title
     </code>
     和
     <code>
      content
     </code>
     中出现的权重不同，我们需要定义两个
     <code>
      vector
     </code>
     容器，分别存储
     <code>
      title
     </code>
     和
     <code>
      content
     </code>
     的关键字分词结果，并分别统计关键字出现的次数。最后，按照特定算法计算关键字的权重，从而完成倒排索引的构建。
    </p>
    <p>
     <strong>
      下面是构建倒排索引的代码实现：
     </strong>
    </p>
    <pre><code class="language-cpp">        // 创建倒排索引
        bool BuildInvertedIndex(const DocInfo &amp;doc)
        {
            struct word_cnt{
                int title_cnt;
                int content_cnt;

                word_cnt(): title_cnt(0), content_cnt(0) {};
            };
            unordered_map&lt;string, word_cnt&gt; word_map;

            // 对标题进行分词
            vector&lt;string&gt; title_words;
            ns_util::JiebaUtil::CutString(doc.title, &amp;title_words);
            
            // 统计标题中关键字的频次
            for(auto &amp;it : title_words){
                word_map[it].title_cnt++;
            }
            
            // 对正文进行分词
            vector&lt;string&gt; content_words;
            ns_util::JiebaUtil::CutString(doc.content, &amp;content_words);

            // 统计正文中关键字的频次
            for(auto &amp;it : content_words){
                word_map[it].content_cnt++;
            }

            constexpr int X = 10;  // 定义常量 X
            constexpr int Y = 1;   // 定义常量 Y
            // 统计关键字及其权重，插入InvertedList倒排拉链中
            for(auto &amp;it : word_map)
            {
                InvertedElem word_elem;
                word_elem.doc_id = doc.doc_id; // 文档ID
                word_elem.word = it.first; // 关键字
                word_elem.weight = it.second.title_cnt * X + it.second.content_cnt * Y; // 计算权重（简易版）
                
                InvertedList &amp;inverted_list = inverted_index[it.first];
                inverted_list.push_back(move(word_elem));
            }

            return true;
        }</code></pre>
    <p>
     因此，构建索引的步骤如下：
     <span style="color:#ed7976">
      循环读取数据库，提取每个文档并构建对应的正排索引，然后根据正排索引中的
      <code>
       title
      </code>
      和
      <code>
       content
      </code>
      提取全部关键字，构建倒排索引
     </span>
     。
    </p>
    <p>
     至此，我们已经可以正式编写执行查询流程的程序了。
    </p>
    <h4 id="%F0%9F%93%963.%20%E7%BC%96%E5%86%99%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F" name="%F0%9F%93%963.%20%E7%BC%96%E5%86%99%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F">
     📖3. 编写查询程序
    </h4>
    <h5 id="%F0%9F%94%96%E5%AF%B9%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E8%AF%8D" name="%F0%9F%94%96%E5%AF%B9%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E8%AF%8D">
     🔖对搜索关键字分词
    </h5>
    <p>
     <span style="color:#ff9900">
      用户输入的关键字并不能直接用于索引搜索，而是需要先进行分词处理
     </span>
     。我们可以使用
     <code>
      jieba
     </code>
     分词工具对关键字进行切分，然后将分词结果放入倒排索引中进行检索。
    </p>
    <p>
     这里存在一个问题：同一个文档可能会被多次返回。例如，文档内容为“小明来了北京”，用户搜索的关键字也是“小明来了北京”，分词结果为“小明/来了/北京”，这三个词可能分别检索到同一个文档。如果不对这种情况进行去重处理，搜索结果中就会出现重复的文档。
    </p>
    <p>
     我们通过
     <code>
      JiebaUtil::CutString
     </code>
     方法对
     <code>
      query
     </code>
     进行分词，并将分词结果存储在
     <code>
      words
     </code>
     中：
    </p>
    <pre><code class="language-cpp">    class StringUtil{
    public:
        static void CutString(const string &amp;target, vector&lt;string&gt; *out, const string &amp;sep)
        {
            boost::split(*out, target, boost::is_any_of(sep), boost::token_compress_on); // 压缩重复字符
        }
    };</code></pre>
    <h5 id="%F0%9F%94%96%E5%AF%B9%E6%A3%80%E7%B4%A2%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%8E%BB%E9%87%8D" name="%F0%9F%94%96%E5%AF%B9%E6%A3%80%E7%B4%A2%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%8E%BB%E9%87%8D">
     🔖对检索结果进行去重
    </h5>
    <p>
     为了解决重复文档的问题，我们使用哈希表
     <code>
      inverted_map
     </code>
     ，通过文档 ID 映射倒排索引的方式完成去重操作。对于检索到的重复文档，将其权重累加起来。
     <span style="color:#faa572">
      由于这些文档是由不同关键字检索到的，还需要将这些关键字保存起来
     </span>
     。为此，我们定义了
     <code>
      InvertedElemPrint
     </code>
     结构，用于存储文档 ID、关键字列表和权重。
    </p>
    <p>
     我们遍历每个分词结果，从倒排索引中获取相关文档，并将其合并到
     <code>
      inverted_map
     </code>
     中：
    </p>
    <pre><code class="language-cpp">unordered_map&lt;uint64_t, InvertedElemPrint&gt; inverted_map;
for(string word : words) {
    boost::to_lower(word);
    ns_index::InvertedList *word_list = index-&gt;GetInvertedIndex(word);
    if(nullptr == word_list) continue;
    for(const auto &amp;elem: *word_list) {
        auto &amp;item = inverted_map[elem.doc_id];
        item.doc_id = elem.doc_id;
        item.words.push_back(elem.word);
        item.weight += elem.weight;
    }
}</code></pre>
    <h5 id="%F0%9F%94%96%E5%AF%B9%E6%A3%80%E7%B4%A2%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F" name="%F0%9F%94%96%E5%AF%B9%E6%A3%80%E7%B4%A2%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F">
     🔖对检索结果排序
    </h5>
    <p>
     在得到去重后的倒排索引集合后，需要按照权重
     <code>
      weight
     </code>
     对结果进行降序排列。我们使用
     <code>
      std::sort
     </code>
     函数实现这一排序操作，确保最相关的文档排在前面。
    </p>
    <p>
     我们将
     <code>
      inverted_map
     </code>
     中的数据移动到
     <code>
      gather
     </code>
     中，
     <strong>
      并按权重排序
     </strong>
     ：
    </p>
    <pre><code class="language-cpp">vector&lt;InvertedElemPrint&gt; gather;
for(const auto &amp;item : inverted_map) {
    gather.push_back(move(item.second));
}
sort(gather.begin(), gather.end(), [](const InvertedElemPrint &amp;e1, const InvertedElemPrint &amp;e2) {
    return e1.weight &gt; e2.weight;
});</code></pre>
    <h5 id="%F0%9F%94%96%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E6%91%98%E8%A6%81%E7%94%9F%E6%88%90" name="%F0%9F%94%96%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E6%91%98%E8%A6%81%E7%94%9F%E6%88%90">
     🔖序列化与摘要生成
    </h5>
    <p>
     整理后的索引结果
     <span style="color:#ed7976">
      无法直接通过网络传输，需要以序列化和反序列化的方式进行处理
     </span>
     。我们使用
     <code>
      Json
     </code>
     作为通用的序列化工具，构建
     <code>
      json
     </code>
     字符串返回给用户。但还有一个问题：索引中提取的是文档的全部正文内容，如果直接将全部内容返回并显示在用户的搜索界面上，显然不够友好。因此，我们需要对正文部分
     <strong>
      生成摘要
     </strong>
     ，便于用户快速了解文档内容并决定是否跳转查看详情。
    </p>
    <p>
     摘要内容最好包含用户搜索的关键字。我们通过
     <code>
      GetDigest
     </code>
     方法生成摘要：在
     <code>
      content
     </code>
     中查找第一个关键字的位置，然后取关键字前 50 字节和后 100 字节作为摘要内容。
    </p>
    <pre><code class="language-cpp">string GetDigest(const string &amp;content, const string &amp;key) {
    const int prev_chars = 50;
    const int next_chars = 100;
    auto itea = search(content.begin(), content.end(), key.begin(), key.end(), [](char a, char b) {
        return (tolower(a) == tolower(b));
    });
    if(content.end() == itea) return "未找到关键词";
    
    // 计算字符位置并生成摘要
    string utf8_content = content;
    vector&lt;size_t&gt; char_positions;
    size_t byte_pos = 0;
    while (byte_pos &lt; utf8_content.size()) {
        char_positions.push_back(byte_pos);
        unsigned char c = utf8_content[byte_pos];
        if (c &lt; 0x80) byte_pos += 1;
        else if (c &lt; 0xE0) byte_pos += 2;
        else if (c &lt; 0xF0) byte_pos += 3;
        else byte_pos += 4;
    }
    
    int char_pos = distance(content.begin(), itea);
    int char_index = 0;
    for (size_t i = 0; i &lt; char_positions.size(); i++) {
        if (char_positions[i] &gt;= (size_t)char_pos) {
            char_index = i;
            break;
        }
    }
    
    int start_char = max(0, char_index - prev_chars);
    int end_char = min((int)char_positions.size() - 1, char_index + next_chars);
    size_t start_byte = char_positions[start_char];
    size_t end_byte = (end_char + 1 &lt; char_positions.size()) ? char_positions[end_char + 1] : utf8_content.size();
    
    string digest = utf8_content.substr(start_byte, end_byte - start_byte);
    bool has_more_at_start = (start_char &gt; 0);
    bool has_more_at_end = (end_char &lt; (int)char_positions.size() - 1);
    if (has_more_at_start) digest = "..." + digest;
    if (has_more_at_end) digest = digest + "...";
    
    return digest;
}</code></pre>
    <h5 id="%F0%9F%94%96%E6%9E%84%E5%BB%BAJSON%E7%BB%93%E6%9E%9C" name="%F0%9F%94%96%E6%9E%84%E5%BB%BAJSON%E7%BB%93%E6%9E%9C">
     🔖构建JSON结果
    </h5>
    <p>
     最后，我们将排序后的结果构建为
     <code>
      json
     </code>
     字符串返回给用户。
    </p>
    <pre><code class="language-cpp">void BuildJsonResult(const vector&lt;InvertedElemPrint&gt; &amp;gather, string *json_string) {
    Json::Value root;
    for(auto &amp;item : gather) {
        ns_index::DocInfo *doc = index-&gt;GetForwardIndex(item.doc_id);
        if(nullptr == doc) continue;
        Json::Value elem;
        elem["title"] = doc-&gt;title;
        elem["digest"] = GetDigest(doc-&gt;content, item.words[0]);
        elem["url"] = doc-&gt;url;
        elem["id"] = doc-&gt;doc_id;
        elem["weight"] = item.weight;
        elem["time"] = doc-&gt;time;
        root.append(elem);
    }
    Json::StyledWriter writer;
    *json_string = writer.write(root);
}</code></pre>
    <h4 id="%F0%9F%93%964.%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E7%A8%8B%E5%BA%8F" name="%F0%9F%93%964.%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E7%A8%8B%E5%BA%8F">
     📖4.编写服务器主程序
    </h4>
    <p>
     我们使用
     <code>
      httplib
     </code>
     库实现了一个简单的 HTTP 服务器，用于处理用户的搜索请求并返回结果。
     <code>
      httplib
     </code>
     是一个轻量级的 C++ HTTP 库，易于集成和使用。
    </p>
    <h5 id="%F0%9F%94%96%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B4%A2%E5%BC%95" name="%F0%9F%94%96%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B4%A2%E5%BC%95">
     🔖初始化索引
    </h5>
    <p>
     在程序启动时，我们首先需要
     <span style="color:#ed7976">
      初始化搜索引擎的索引
     </span>
     。通过调用
     <code>
      ns_sercher::Sercher
     </code>
     类的
     <code>
      InitIndex
     </code>
     方法，从指定的数据文件
     <code>
      data/raw_data/raw.txt
     </code>
     中加载数据并构建正排索引和倒排索引。
    </p>
    <pre><code class="language-cpp">ns_sercher::Sercher serch;
serch.InitIndex(input);</code></pre>
    <h5 id="%F0%9F%94%96%E8%AE%BE%E7%BD%AEHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8" name="%F0%9F%94%96%E8%AE%BE%E7%BD%AEHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8">
     🔖设置HTTP服务器
    </h5>
    <p>
     我们使用
     <strong>
      <code>
       httplib
      </code>
      库
     </strong>
     创建一个 HTTP 服务器，并设置服务器的根目录为
     <code>
      ./wwwroot
     </code>
     。该目录用于存放静态资源文件（如 HTML、CSS、JavaScript 等），供客户端访问。
    </p>
    <pre><code class="language-cpp">httplib::Server svr;
svr.set_base_dir(root_path.c_str());</code></pre>
    <h5 id="%F0%9F%94%96%E5%A4%84%E7%90%86%E6%90%9C%E7%B4%A2%E8%AF%B7%E6%B1%82" name="%F0%9F%94%96%E5%A4%84%E7%90%86%E6%90%9C%E7%B4%A2%E8%AF%B7%E6%B1%82">
     🔖处理搜索请求
    </h5>
    <p>
     我们为服务器定义了一个
     <code>
      /search
     </code>
     路由，用于处理用户的搜索请求。该路由通过
     <code>
      GET
     </code>
     方法接收用户输入的关键字，并根据请求参数执行不同的搜索逻辑。
    </p>
    <p>
     根据请求参数
     <code>
      time_priority
     </code>
     的值，决定是
     <span style="color:#ff9900">
      按时间排序还是按权重排序
     </span>
     ：
    </p>
    <pre><code class="language-cpp">if (time_priority){
    cout &lt;&lt; "按时间排序" &lt;&lt; endl;
    serch.TimePrioritySerch(word, &amp;json_string);
} else {
    cout &lt;&lt; "按权重排序" &lt;&lt; endl;
    serch.CommonSerch(word, &amp;json_string);
}</code></pre>
    <p>
     如果搜索关键词为空，返回全部文档的时间排序结果（便于浏览最新公告）：
    </p>
    <pre><code class="language-cpp">// 检查输入是否为空或仅包含空格
if (word.empty() || word.find_first_not_of(' ') == string::npos) {
    cout &lt;&lt; "返回所有文档信息" &lt;&lt; endl;
    serch.GetAllDocuments(&amp;json_string);
    resp.set_content(json_string, "application/json; charset=utf-8");
    return;
}</code></pre>
    <p>
     如果搜索关键字不存在，则返回空结果和广告信息：
    </p>
    <pre><code class="language-cpp">if (json_string.empty()) {
    json_string = R"({"results": [], "ads": [
        {"text": "进入校园官网：", "url": "https://jwc.hznu.edu.cn/", "linkText": "杭州师范大学教务处"},
        {"text": "分享学习笔记，记录生活点滴，欢迎访问我的博客：", "url": "https://kanhai-night.blog.csdn.net", "linkText": "Kanhai's 技术博客"},
        {"text": "本项目已开源：", "url": "https://gitee.com/HZNUYuwen/Linux_gitee/tree/master/HZNUSercher", "linkText": "查看项目源码"}
    ]})";
}</code></pre>
    <h3 id="%F0%9F%93%9A%E5%9B%9B%E3%80%81%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0" name="%F0%9F%93%9A%E5%9B%9B%E3%80%81%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0">
     📚四、前端实现
    </h3>
    <p>
     前端页面实现了搜索功能的核心交互逻辑，包括关键字输入、搜索请求、结果展示和分页浏览。以下是对主要功能的介绍：
    </p>
    <h4 id="%F0%9F%93%961.%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84" name="%F0%9F%93%961.%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84">
     📖1.页面结构
    </h4>
    <p>
     页面分为以下几个部分：
    </p>
    <p>
     <strong>
      ① 搜索框
     </strong>
     ：用户输入关键字，并选择是否按时间排序。
    </p>
    <p>
     <strong>
      ② 搜索结果区域
     </strong>
     ：动态展示搜索结果的标题、摘要和链接。
    </p>
    <p>
     <strong>
      ③ 分页控件
     </strong>
     ：支持上一页和下一页的翻页操作。
    </p>
    <pre><code class="language-html">&lt;div class="container initial-state"&gt;
    &lt;div class="search"&gt;
        &lt;input type="text" value="请输入搜索关键字"&gt;
        &lt;div class="search-options"&gt;
            &lt;label&gt;
                &lt;input type="checkbox" id="time-priority"&gt; 按时间先后
            &lt;/label&gt;
        &lt;/div&gt;
        &lt;button onclick="Search()"&gt;搜索一下&lt;/button&gt;
    &lt;/div&gt;
    &lt;div class="result hidden"&gt;
        &lt;!-- 动态生成网页内容 --&gt;
    &lt;/div&gt;
    &lt;div class="pagination hidden"&gt;
        &lt;button onclick="prevPage()"&gt;上一页&lt;/button&gt;
        &lt;span id="page-info"&gt;&lt;/span&gt;
        &lt;button onclick="nextPage()"&gt;下一页&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
    <h4 id="%F0%9F%93%962.%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD" name="%F0%9F%93%962.%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD">
     📖2.搜索功能
    </h4>
    <p>
     通过
     <code>
      Search
     </code>
     函数发起搜索请求，将用户输入的关键字发送到后端，并动态更新搜索结果：
    </p>
    <pre><code class="language-javascript">function Search() {
    currentQuery = $(".container .search input").val().trim(); // 获取关键字
    let timePriority = $("#time-priority").is(":checked"); // 是否按时间排序
    $.ajax({
        type: "GET",
        url: "/search?word=" + currentQuery + "&amp;time_priority=" + timePriority,
        success: function(data) {
            searchResults = data; // 保存搜索结果
            currentPage = 0; // 重置页码
            BuildHtml(); // 渲染结果
            setResultState(); // 切换到结果状态
        }
    });
}</code></pre>
    <h4 id="%F0%9F%93%963.%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA" name="%F0%9F%93%963.%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA">
     📖3.结果展示
    </h4>
    <p>
     通过
     <code>
      BuildHtml
     </code>
     函数动态生成搜索结果，并支持关键字高亮显示：
    </p>
    <pre><code class="language-javascript">function BuildHtml() {
    let result_lable = $(".container .result");
    result_lable.empty(); // 清空之前的结果
    let start = currentPage * resultsPerPage;
    let end = start + resultsPerPage;
    let pageResults = searchResults.slice(start, end); // 获取当前页结果

    for (let elem of pageResults) {
        let highlightedTitle = highlightKeyword(elem.title, currentQuery); // 高亮标题
        let highlightedDigest = highlightKeyword(elem.digest, currentQuery); // 高亮摘要
        result_lable.append(`
            &lt;div class="item"&gt;
                &lt;a href="${elem.url}" target="_blank"&gt;${highlightedTitle}&lt;/a&gt;
                &lt;p&gt;${highlightedDigest}&lt;/p&gt;
                &lt;i&gt;${elem.url}&lt;/i&gt;
                &lt;span style="display: block; color: #888; font-size: 12px; margin-top: 5px;"&gt;
                    ${elem.time ? "发布时间: " + elem.time : ""}
                &lt;/span&gt;
            &lt;/div&gt;
        `);
    }
}</code></pre>
    <h4 id="%F0%9F%93%964.%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD" name="%F0%9F%93%964.%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD">
     📖4.分页功能
    </h4>
    <p>
     通过
     <code>
      prevPage
     </code>
     和
     <code>
      nextPage
     </code>
     函数实现分页浏览：
    </p>
    <pre><code class="language-javascript">function prevPage() {
    if (currentPage &gt; 0) {
        currentPage--;
        BuildHtml(); // 更新结果
    }
}

function nextPage() {
    if ((currentPage + 1) * resultsPerPage &lt; searchResults.length) {
        currentPage++;
        BuildHtml(); // 更新结果
    }
}</code></pre>
    <h3 id="%F0%9F%93%9A%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E6%BC%94%E7%A4%BA" name="%F0%9F%93%9A%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E6%BC%94%E7%A4%BA">
     📚五、完整演示
    </h3>
    <p>
     下面是
     <strong>
      《校园公告搜索引擎》
     </strong>
     项目功能的完整演示：
    </p>
    <h4 id="%F0%9F%93%961.%E5%88%9D%E5%A7%8B%E7%95%8C%E9%9D%A2" name="%F0%9F%93%961.%E5%88%9D%E5%A7%8B%E7%95%8C%E9%9D%A2">
     📖1.初始界面
    </h4>
    <p>
     <img alt="" height="930" src="https://i-blog.csdnimg.cn/direct/455f1718fddd4d9abd9b4c0250475d60.png" width="1919"/>
    </p>
    <h4 id="%F0%9F%93%962.%E6%97%A0%E5%85%B3%E9%94%AE%E5%AD%97%E8%BE%93%E5%85%A5" name="%F0%9F%93%962.%E6%97%A0%E5%85%B3%E9%94%AE%E5%AD%97%E8%BE%93%E5%85%A5">
     📖2.无关键字输入
    </h4>
    <p>
     当无关键字输入时，返回用户的结果是经过时间排序的全部文档内容
    </p>
    <p>
     <img alt="" height="934" src="https://i-blog.csdnimg.cn/direct/6257a71f4111442abec60358db4b57e6.png" width="1919"/>
    </p>
    <h4 id="%F0%9F%93%963.%E8%BE%93%E5%85%A5%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%97%A0%E8%BF%94%E5%9B%9E%EF%BC%89" name="%F0%9F%93%963.%E8%BE%93%E5%85%A5%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%97%A0%E8%BF%94%E5%9B%9E%EF%BC%89">
     📖3.输入关键字（无返回）
    </h4>
    <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="934" src="https://i-blog.csdnimg.cn/direct/7372ab2e4bbd49c5a68ee33838b54de6.png" width="1919"/>
    </h4>
    <h4 id="%F0%9F%93%964.%E8%BE%93%E5%85%A5%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%9C%89%E8%BF%94%E5%9B%9E%EF%BC%89%C2%A0" name="%F0%9F%93%964.%E8%BE%93%E5%85%A5%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%9C%89%E8%BF%94%E5%9B%9E%EF%BC%89%C2%A0">
     📖4.输入关键字（有返回）
    </h4>
    <h5 id="%F0%9F%94%96%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91" name="%F0%9F%94%96%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91">
     🔖默认排序
     <img alt="" height="935" src="https://i-blog.csdnimg.cn/direct/696a17bbcf35415e9f84623c1513bead.png" width="1919"/>
    </h5>
    <h5 id="%F0%9F%94%96%E6%8C%89%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F" name="%F0%9F%94%96%E6%8C%89%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F">
     🔖按时间排序
    </h5>
    <p>
     <img alt="" height="934" src="https://i-blog.csdnimg.cn/direct/4c7978e22e154028b0b6b9e536dc2681.png" width="1919"/>
    </p>
    <h3 id="%F0%9F%93%9A%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" name="%F0%9F%93%9A%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93">
     📚六、总结
    </h3>
    <p>
     在这里就不对项目本身过多赘述了，下面说一下项目的不足与优化方向：
    </p>
    <h4 id="%F0%9F%93%961.%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91" name="%F0%9F%93%961.%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91">
     📖1.优化方向
    </h4>
    <p>
     <strong>
      ① 在线更新：
     </strong>
     目前项目尚未实现在线更新功能，获取的官网公告数据截至
     <strong>
     </strong>
     2025年3月14日，最新的官网公告未能同步到搜索引擎。未来可以引入定时任务或实时爬虫机制，确保数据及时更新。
    </p>
    <p>
     <strong>
      ② 热词统计：
     </strong>
     在搜索时，如果能智能显示热门搜索关键词，可以进一步提升用户体验。
    </p>
    <p>
     <strong>
      ③ 登录系统：
     </strong>
     由于该搜索引擎主要服务于本校师生，可以增加登录认证功能。
    </p>
    <p>
     <strong>
      ④ 响应速度：
     </strong>
     目前服务器的响应速度还有提升空间。可以通过优化索引结构、引入缓存机制等。
    </p>
    <p>
     <strong>
      ⑤ 扩大搜索范围：
     </strong>
     除了教务处官网，未来可以引入其他学校官网（如学院、图书馆、招生办等）的数据作为搜索对象。
    </p>
    <p>
     <strong>
      ⑥ 引入域名：
     </strong>
     目前项目通过 IP 地址和端口号访问服务器，这种方式不够直观且不利于记忆。
    </p>
    <h4 id="%F0%9F%93%962.%E6%BA%90%E7%A0%81%E5%8F%8A%E7%BD%91%E5%9D%80" name="%F0%9F%93%962.%E6%BA%90%E7%A0%81%E5%8F%8A%E7%BD%91%E5%9D%80">
     📖2.源码及网址
    </h4>
    <p>
     这里给出项目源码以及访问网址：
    </p>
    <p>
     <a class="link-info" href="https://gitee.com/HZNUYuwen/Linux_gitee/tree/master/HZNUSercher" rel="nofollow" title="项目源码">
      项目源码
     </a>
    </p>
    <p>
     <a href="http://60.204.207.161:8081/" rel="nofollow" title="校园公告搜索引擎">
      校园公告搜索引擎
     </a>
    </p>
    <hr/>
    <p>
     以上就是【校园公告搜索引擎】的全部内容，欢迎指正~
    </p>
    <p>
     <strong>
      码文不易，还请多多关注支持，这是我持续创作的最大动力！
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f646867697579617768697564777168612f:61727469636c652f64657461696c732f313436323330393238" class_="artid" style="display:none">
 </p>
</div>


