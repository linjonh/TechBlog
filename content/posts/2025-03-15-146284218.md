---
layout: post
title: "SSLTLS-1.2过程Client端如何验证服务端证书"
date: 2025-03-15 22:33:18 +0800
description: "TLS认证过程。客户端验证服务端证书。"
keywords: "SSL/TLS 1.2过程：Client端如何验证服务端证书？"
categories: ['计算机网络', '加密', 'Tls']
tags: ['安全', 'Ssl', 'Https']
artid: "146284218"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146284218
    alt: "SSLTLS-1.2过程Client端如何验证服务端证书"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146284218
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146284218
cover: https://bing.ee123.net/img/rand?artid=146284218
image: https://bing.ee123.net/img/rand?artid=146284218
img: https://bing.ee123.net/img/rand?artid=146284218
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SSL/TLS 1.2过程：Client端如何验证服务端证书？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     快速回顾非对称加密和对称加密
    </h2>
    <p>
     首先快速说一下非对称加密和对称加密。非对称加密，就是有一个公钥和私钥(成对存在)。
     <br/>
     公钥对一段文本A加密得到文本B，只有对应的私钥能对B解密得到A。
     <br/>
     私钥对一段文本C加密得到文本D，只有对应的公钥能对D解密得到C。
     <br/>
     也就是一个密钥加密，只能用另一个密钥解密。不能用本身或者其他任何密钥解密。
    </p>
    <p>
     对称加密则是另一种方式，一个密钥M对一段文本E加密得到文本F，只能由这个密钥M对文本F解密得到E。
    </p>
    <h2>
     <a id="https_8">
     </a>
     快速回顾https
    </h2>
    <p>
     然后 https = http + SSL/TLS
     <br/>
     SSL/TLS就是保证安全性，保证发送请求的时候不被第三方攻击。
    </p>
    <h2>
     <a id="_12">
     </a>
     前置知识
    </h2>
    <p>
     1、TLS主要是验证服务端是安全的
     <br/>
     2、TLS证书安装在服务端，服务端有一对公钥和私钥
     <br/>
     3、公钥全部人可见，私钥只有自己可见
     <br/>
     4、除非双向认证，否则只有客户端验证服务端的身份
    </p>
    <h2>
     <a id="SSLTLS_12_17">
     </a>
     SSL/TLS 1.2过程
    </h2>
    <h3>
     <a id="TLSSSL_18">
     </a>
     TLS/SSL过程：
    </h3>
    <p>
     1、客户端发送 ClientHello
     <br/>
     2、服务端响应 ServerHello
     <br/>
     3、服务端主动发送证书 (SSL证书，安装于服务端)
     <br/>
     4、服务端发送ServerHelloDone
     <br/>
     5、客户端验证服务端的SSL证书
     <br/>
     (验证证书是重要的一步，后续会主要讲这个。主要目的就是为了
     <strong>
      验证服务端是经过CA机构认证的
     </strong>
     ，并且
     <strong>
      正确
     </strong>
     拿到
     <strong>
      服务端的公钥
     </strong>
     )。
     <br/>
     6、客户端生成一个密钥M，拿到服务端证书里带的服务端的公钥，加密M得到M1
     <br/>
     7、客户端发送 ClientKeyExchange: 就是把M1发给服务端
     <br/>
     8、服务端拿到M1，用服务端的私钥解密M1得到M：只有服务端能拿到这个M1
     <br/>
     9、双方根据M生成主密钥S1和会话密钥S2：注意此时只有客户端和服务端知道S1和S2，其他人都不知道
     <br/>
     10、客户端发送 ChangeCipherSpec 和 Finished
     <br/>
     11、服务器响应 ChangeCipherSpec 和 Finished
     <br/>
     12、确认完毕，后面都用S2对称加密文本。发的时候S2加密，解的时候S2解密。
    </p>
    <h3>
     <a id="_33">
     </a>
     这样为什么安全？
    </h3>
    <p>
     因为第5步，客户端正确拿到了服务端的公钥；公钥就是明文的，所有人都能拿到。
     <br/>
     服务端的公钥加密的文本只能被服务端解密(只有服务端有对应私钥)，所以可以发送一些信息给服务端。比如第8步的M1。
    </p>
    <h3>
     <a id="_36">
     </a>
     证书长啥样？
    </h3>
    <p>
     服务端证书:
    </p>
    <pre><code>-----BEGIN CERTIFICATE-----
*PS：以下信息都会被base64编码*
**服务端公钥**：C11
**数字签名**：xxx
**其他信息**：这里可以一笔带过，比如服务端名称，域名，颁发机构等
-----END CERTIFICATE-----
</code></pre>
    <p>
     公钥：重要，一定要正确。
     <br/>
     数字签名：重要，这个数字签名能保证这个证书是被CA机构认证过的，公钥是真的。
     <br/>
     不然不法分子伪造一个证书，然后你拿到一个假的公钥，那么后续的发送消息都要被不法分子盗了。
    </p>
    <h3>
     <a id="CA_49">
     </a>
     CA机构
    </h3>
    <p>
     简单理解就是一些很权威的机构，能够给别人的证书加上
     <strong>
      数字签名
     </strong>
     。证书有了这个数字签名，这个证书就是被认证的证书，那么服务端就是被信任的。
    </p>
    <h3>
     <a id="CA_52">
     </a>
     CA机构怎么给别人的证书加上数字签名
    </h3>
    <p>
     CA机构也有证书。其中有一个是
     <strong>
      根证书，是被信任的证书，它被安装在操作系统中
     </strong>
     。大概操作系统开发者实地走访找到CA机构，并且拿到了根证书。
    </p>
    <p>
     如上所述，根证书上有CA的C1，和它的数字签名。
     <br/>
     根证书这个数字签名是它自己给自己签名的，叫做自签名证书。
    </p>
    <p>
     CA机构有一个私钥C0，只有CA机构自己知道。
     <br/>
     给某个证书签名步骤：
     <br/>
     1、拿到这个证书的公钥C11和其他信息
     <br/>
     2、计算 Hash (公钥C11 + 其他信息) = 一串hash后的结果A
     <br/>
     3、用C0给A加密，得到A1。A1就是这个数字签名
    </p>
    <p>
     为啥说有了签名就能验证服务端的确是被真正的CA机构认证过的呢？
     <br/>
     看下一个
    </p>
    <h3>
     <a id="SSL_66">
     </a>
     客户端如何验证服务端的SSL证书
    </h3>
    <p>
     上面说到，A1就是数字签名。客户端也安装了CA机构的证书，根证书，所以也有CA机构的公钥C0。
     <br/>
     客户端验证服务端证书步骤：
     <br/>
     1、客户端拿到证书，并且拿到里面的服务端公钥C11和数字签名A1，以及其他信息
     <br/>
     2、客户端用C1给A1解密，会得到A
     <br/>
     3、客户端计算 Hash (公钥C11 + 其他信息) = 一串hash后的结果B
     <br/>
     4、验证A == B，一旦A和B相等，说明了 服务端公钥C11 + 其他信息 都是正确的
     <br/>
     验证没问题后，说明C11正确。这也是TLS认证的第5步，主要目的是拿到正确的服务端公钥。拿到后就能开始按照上面第6步以后通信了。
    </p>
    <h3>
     <a id="CA_75">
     </a>
     什么是中间CA
    </h3>
    <p>
     CA机构有一个权威的根证书。用这个根证书给某个CA1证书签名。那么这个CA1证书也是可信赖的了。然后CA1也可以用上面的方法给服务端签名，当然也可以给CA2签名。
     <br/>
     CA1，CA2都是中间CA。根CA给CA1签名，CA1给CA2签名，CA2给CA3签名，等等。最后一个CAn给服务端签名。CA1，CA2… CAn都是中间证书。
     <br/>
     验证步骤就变成了，先用CAn验证服务端有没有问题，再用CA(N-1)验证CAn对不对，最后用根CA验证CA1是不是对的。一步步往上回溯。
     <br/>
     最顶层的就是之前说的根证书。中间的都是中间CA证书。最底层的是服务端证书，也就是叶证书。
     <br/>
     只要能回溯到根证书，那么这个验证就是通过的。
     <br/>
     有了中间CA，一般的证书长这样：
    </p>
    <pre><code>-----BEGIN CERTIFICATE-----
&lt;base64加密后的叶证书内容&gt;
叶证书公钥：xx
叶证书数字签名：xxxx
其他信息:xxxxx
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
&lt;中间证书内容&gt;
-----END CERTIFICATE-----
</code></pre>
    <h3>
     <a id="_95">
     </a>
     可信任证书
    </h3>
    <p>
     上面说到根证书是被信任的。其实也可以把中间CA证书放入电脑的信任列表里。这样回溯到这个中间CA就可以了。也就是能根据叶证书，中间证书慢慢回溯到某一个被信任的证书就可以了。
    </p>
    <p>
     所以，对于内部系统，其实可以自己给自己的服务端生成一个证书(主要就是公钥和私钥)，然后把它放入信任列表里。或者自己生成一个CA证书，把它放入信任列表里。
    </p>
    <p>
     因为根CA是自签名证书。
     <strong>
      所以可以自己内部也生成一个自签名证书，把它放入信任列表里，充当CA根证书，并且用这个CA根证书给自己内部的服务都加上签名
     </strong>
     ，就不会有SSL问题。其实也是安全的，因为这个根证书是自己造的，那么公钥肯定是可信任的。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f58756557616e67312f:61727469636c652f64657461696c732f313436323834323138" class_="artid" style="display:none">
 </p>
</div>


