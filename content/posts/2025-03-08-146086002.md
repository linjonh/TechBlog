---
layout: post
title: "MySQL面试篇性能优化"
date: 2025-03-08 20:32:01 +0800
description: "索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。"
keywords: "mysql 中select 前面加什么才能知道是否慢查询"
categories: ['Mysql']
tags: ['面试', '数据库', '性能优化', 'Mysql', 'Java']
artid: "146086002"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146086002
    alt: "MySQL面试篇性能优化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146086002
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146086002
cover: https://bing.ee123.net/img/rand?artid=146086002
image: https://bing.ee123.net/img/rand?artid=146086002
img: https://bing.ee123.net/img/rand?artid=146086002
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL面试篇——性能优化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     MySQL性能优化
    </h2>
    <p>
     <img alt="" height="589" src="https://i-blog.csdnimg.cn/direct/de8027e3b9324e14bbee091a4b68d4c2.png" width="1195"/>
    </p>
    <h3>
     在MySQL中，如何定位慢查询
    </h3>
    <p>
     慢查询表象：页面加载过慢、接口压测响应时间过长（超过1s）。造成慢查询的原因通常有：
     <strong>
      <span style="background-color:#ffd900">
       聚合查询、多表查询、表数据量过大查询、深度分页查询
      </span>
     </strong>
    </p>
    <p>
     方案一：开源工具 调试工具：Arthas 运维工具：Prometheus 、
     <strong>
      Skywalking
     </strong>
     。工具报表展示中可以看到哪个接口慢，并且能分析出接口中哪部分耗时较多，包括具体的SQL执行时间，这样就能定位到出现问题的SQL。
    </p>
    <p>
     方案二：
     <strong>
      MySQL自带慢日志
     </strong>
     慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志 如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：
    </p>
    <pre><code># 开启MySQL慢日志查询开关slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2
</code></pre>
    <p>
     配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log。
    </p>
    <p>
     <img alt="" height="206" src="https://i-blog.csdnimg.cn/direct/278c807554554ceb9a8d3b271d8936bf.png" width="1504"/>
    </p>
    <h3>
     <strong>
      SQL语句执行很慢，如何优化
     </strong>
    </h3>
    <p>
     可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息
    </p>
    <blockquote>
     <p>
      语法：
     </p>
     <p>
      - 直接在select语句之前加上关键字 explain / desc
     </p>
     <p>
      EXPLAIN   SELECT   字段列表   FROM   表名   WHERE  条件 ;
     </p>
    </blockquote>
    <p>
     <img alt="" height="169" src="https://i-blog.csdnimg.cn/direct/8075a110dbda4b92afd945eb1f6e682d.png" width="1401"/>
    </p>
    <ul>
     <li>
      possible_key  当前sql可能会使用到的索引
     </li>
     <li>
      key 当前sql实际命中的索引
     </li>
     <li>
      key_len 索引占用的大小 Extra 额外的优化建议
     </li>
    </ul>
    <p>
     通过key和key_len两个查看是否可能会命中索引。
    </p>
    <p>
     <img alt="" height="172" src="https://i-blog.csdnimg.cn/direct/67ae6cfe09e14efebeb32a55163ecfb7.png" width="1564"/>
    </p>
    <p>
     type 这条sql的连接的类型，性能由好到差为NULL、system、const、eq_ref、ref、range、 index、all
    </p>
    <ul>
     <li>
      system：查询系统中的表
     </li>
     <li>
      const：根据主键查询
     </li>
     <li>
      eq_ref：主键索引查询或唯一索引查询
     </li>
     <li>
      ref：索引查询
     </li>
     <li>
      range：范围查询
     </li>
     <li>
      index：索引树扫描
     </li>
     <li>
      all：全盘扫描
     </li>
    </ul>
    <p>
     总结：使用MySQL的
     <code>
      EXPLAIN
     </code>
     命令来分析这条SQL的执行情况。通过
     <code>
      key
     </code>
     和
     <code>
      key_len
     </code>
     可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过
     <code>
      type
     </code>
     字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过
     <code>
      extra
     </code>
     建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化。
    </p>
    <h3>
     MYSQL支持的存储引擎有哪些, 有什么区别
    </h3>
    <p>
     在mysql中提供了很多的存储引擎，比较常见有InnoDB、MyISAM、Memory
    </p>
    <ul>
     <li>
      InnoDB存储引擎是mysql5.5之后是默认的引擎，它支持事务、外键、表级锁和行级锁
     </li>
     <li>
      MyISAM是早期的引擎，它不支持事务、只有表级锁、也没有外键，用的不多
     </li>
     <li>
      Memory主要把数据存储在内存，支持表级锁，没有外键和事务，用的也不多
     </li>
    </ul>
    <h3>
     什么是索引
    </h3>
    <p>
     索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
    </p>
    <h4>
     索引的底层数据结构
    </h4>
    <h4>
     <img alt="" height="345" src="https://i-blog.csdnimg.cn/direct/dc4dac57d72c4f83a598e2fa98207a9e.png" width="322"/>
    </h4>
    <p>
     MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。选择B+树的原因包括：节点可以有更多子节点，路径更短；磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。
    </p>
    <h4>
     聚簇索和非聚簇索引
    </h4>
    <p>
     聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。
    </p>
    <p>
     非聚簇索引则是数据与索引分开存储，B+树的叶子节点保存的是主键值，可以有多个非聚簇索引，通常我们自定义的索引都是非聚簇索引。
    </p>
    <p>
     聚集索引选取规则:
    </p>
    <ul>
     <li>
      如果存在主键，主键索引就是聚集索引。
     </li>
     <li>
      如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
     </li>
     <li>
      如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。
     </li>
    </ul>
    <p>
     <img alt="" height="245" src="https://i-blog.csdnimg.cn/direct/7e02bb6a038540379cc6626c2660f18a.png" width="547"/>
    </p>
    <h4>
     回表查询
    </h4>
    <p>
     <strong>
      通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表
     </strong>
    </p>
    <h4>
     <strong>
      覆盖索引
     </strong>
    </h4>
    <p>
     覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。
    </p>
    <p>
     <img alt="" height="564" src="https://i-blog.csdnimg.cn/direct/8c8f57d3dddf47a693fb6f7b9d5662f0.png" width="1249"/>
    </p>
    <h4>
     MYSQL超大分页怎么处理
    </h4>
    <p>
     超大分页通常发生在数据量大的情况下，使用
     <code>
      LIMIT
     </code>
     分页查询且需要排序时效率较低。可以通过
     <strong>
      覆盖索引
     </strong>
     和
     <strong>
      子查询
     </strong>
     来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升。
    </p>
    <h4>
     索引创建原则有哪些？
    </h4>
    <p>
     1). 针对于
     <strong>
      数据量较大
     </strong>
     ，且查询比较频繁的表
     <strong>
      建立索引
     </strong>
     。
    </p>
    <p>
     2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
    </p>
    <p>
     3). 尽量
     <strong>
      选择区分度高
     </strong>
     的列作为索引，尽量
     <strong>
      建立唯一索引
     </strong>
     ，区分度越高，使用索引的效率越高。
    </p>
    <p>
     4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立
     <strong>
      前缀索引
     </strong>
     。
    </p>
    <p>
     5). 尽量
     <strong>
      使用联合索引
     </strong>
     ，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
    </p>
    <p>
     6). 要
     <strong>
      控制索引的数量
     </strong>
     ，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
    </p>
    <p>
     7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。
    </p>
    <h4>
     索引失效
    </h4>
    <p>
     1). 违反最左前缀法则 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：
    </p>
    <p>
     <img alt="" height="523" src="https://i-blog.csdnimg.cn/direct/1c0c959627e44f25aa72034960a2f629.png" width="1551"/>
    </p>
    <p>
     2). 范围查询右边的列，不能使用索引
    </p>
    <p>
     <img alt="" height="374" src="https://i-blog.csdnimg.cn/direct/5b3f3d781a724e8d8404e288d122d034.png" width="1692"/>
    </p>
    <p>
     根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。
    </p>
    <p>
     3). 不要在索引列上进行运算操作， 索引将失效。
    </p>
    <p>
     4). 字符串不加单引号，造成索引失效。
    </p>
    <p>
     <img alt="" height="380" src="https://i-blog.csdnimg.cn/direct/43a7a573bcb74011beeb8976f807dfeb.png" width="1724"/>
    </p>
    <p>
     由于，在查询是，没有对字符串加单引号， MySQL的查询优化器，会自动的进行类型转换，造成索引失效。
    </p>
    <p>
     5).以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。
    </p>
    <blockquote>
     <p>
      MySQl八股：
      <a href="https://heuqqdmbyk.feishu.cn/wiki/O4vwwWkEXiYEPyk8EpFcqvmLnth" rel="nofollow" title="Docs">
       Docs
      </a>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343139373639352f:61727469636c652f64657461696c732f313436303836303032" class_="artid" style="display:none">
 </p>
</div>


