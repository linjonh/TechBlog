---
arturl_encode: "6874747073:3a2f2f626c6f672e6373646e2e6e65742f7a7a685f5a616f2f:61727469636c652f64657461696c732f313436313934383138"
layout: post
title: "c之STL库"
date: 2025-03-13 21:05:48 +08:00
description: "在C++的世界里，标准模板库（STL）是一个强大而灵活的工具，它极大地简化了编程任务，提高了代码的可读性和复用性。无论你是初学者还是经验丰富的开发者，掌握STL都是提升编程技能的关键一步。本文将带你深入了解STL的核心概念、主要组件以及如何在实际开发中高效使用它。"
keywords: "c++之STL库"
categories: ['C']
tags: ['C']
artid: "146194818"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146194818
    alt: "c之STL库"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146194818
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146194818
cover: https://bing.ee123.net/img/rand?artid=146194818
image: https://bing.ee123.net/img/rand?artid=146194818
img: https://bing.ee123.net/img/rand?artid=146194818
---

# c++之STL库

在C++的世界里，标准模板库（STL）是一个强大而灵活的工具，它极大地简化了编程任务，提高了代码的可读性和复用性。无论你是初学者还是经验丰富的开发者，掌握STL都是提升编程技能的关键一步。本文将带你深入了解STL的核心概念、主要组件以及如何在实际开发中高效使用它。

## 基本概念

C++标准模板库（Standard Template Library，简称STL）是C++语言中非常重要的一个组成部分，它是一个高效的通用模板库，提供了丰富的数据结构和算法，极大地简化了C++程序的开发，提高了代码的复用性和可维护性。

主要包含六大组件：容器（Containers）、算法（Algorithms）、迭代器（Iterators）

## 一.容器（Containers）

### 1.序列容器（Sequence Containers）：

**每个元素都有固定位置——取决于插入时机和地点，和元素值无关。**

std::vector：动态数组，支持快速随机访问，但插入和删除操作较慢。
  
std::list：双向链表，支持快速插入和删除操作，但不支持随机访问。
  
std::deque：双端队列，支持在两端快速插入和删除操作。
  
std::array：固定大小的数组，类似于C语言中的数组，但更安全。
  
std::string：用于存储字符串的容器，本质上是一个字符序列。

### 2.关联容器（Associative Containers）：

**元素的位置取决于特定的排列准则，和插入顺序无关。**

std::set：由节点组成的红黑树，存储
**唯一元素**
的有序集合，自动排序。
  
std::multiset：允许存储
**重复元素**
的有序集合。
  
std::map：键值对的有序映射，键唯一。
  
std::multimap：键值对的有序映射，允许键重复。

### 3.无序容器（Unordered Containers）：

std::unordered\_set：基于哈希表的集合，存储唯一元素，不自动排序。
  
std::unordered\_multiset：基于哈希表的集合，允许存储重复元素。
  
std::unordered\_map：基于哈希表的键值对映射，键唯一。
  
std::unordered\_multimap：基于哈希表的键值对映射，允许键重复。

## 二.迭代器（Iterators）

迭代器是用于访问容器中元素的对象，类似于指针。STL定义了多种迭代器类型，包括：
  
输入迭代器（Input Iterator）：只能向前移动，用于读取数据。
  
输出迭代器（Output Iterator）：只能向前移动，用于写入数据。
  
前向迭代器（Forward Iterator）：可以向前移动，支持读写操作。
  
双向迭代器（Bidirectional Iterator）：可以向前和向后移动。
  
随机访问迭代器（Random Access Iterator）：支持随机访问，可以像指针一样进行加减操作。

## 三.算法（Algorithms）

STL提供了大量通用算法，这些算法独立于容器，可以对任何支持迭代器的容器进行操作。常见的算法包括：
  
排序算法：std::sort、std::stable\_sort、std::partial\_sort。
  
搜索算法：std::find、std::binary\_search。
  
数值算法：std::accumulate、std::inner\_product。
  
修改算法：std::copy、std::reverse、std::transform。
  
非修改算法：std::count、std::max\_element、std::min\_element。

## 四.函数对象（Function Objects）

函数对象是重载了函数调用运算符（operator()）的对象。它们可以像函数一样被调用，但可以携带状态信息。STL提供了多种预定义的函数对象，如：
  
比较函数对象：std::less、std::greater。
  
算术函数对象：std::plus、std::minus。
  
逻辑函数对象：std::logical\_and、std::logical\_or。

## STL的优点

通用性：STL的容器和算法是基于模板实现的，可以适用于任何数据类型。
  
高效性：STL的实现经过优化，性能优异。
  
可复用性：STL提供了大量现成的容器和算法，可以直接使用，减少了重复开发的工作量。
  
安全性：STL的容器提供了边界检查等安全机制，减少了错误的发生。

## STL的局限性

尽管STL非常强大，但它也有一些局限性：
  
性能问题：某些操作（如频繁的插入和删除）可能会导致性能下降，特别是在使用某些容器时。
  
内存消耗：某些容器（如std::vector）可能会分配额外的内存以支持动态扩展。
  
学习曲线：STL的复杂性和灵活性可能会让初学者感到困惑。

1. 向量 (vector)
     
   特点：连续存储元素，支持快速随机访问（通过下标访问元素时间复杂度为 O (1)）。在尾部插入和删除元素平均时间复杂度为 O (1) ，但在中间插入和删除元素时间复杂度为 O (n)，因为需要移动其他元素。
     
   应用场景：适用于需要频繁随机访问元素，以及在尾部进行插入和删除操作的场景，如数组模拟等。
2. 列表 (list)
     
   特点：双向链表结构，每个节点包含一个元素，支持双向遍历。在任意位置插入和删除元素的时间复杂度为 O (1)，但不支持随机访问，访问元素需要从链表头或尾开始遍历。
     
   应用场景：适合需要频繁插入和删除元素的场景，如实现一些动态数据结构、缓存淘汰算法等。
3. 双队列 (deque)
     
   特点：连续存储指向不同元素的指针组成的数组结构，它允许在两端进行快速插入和删除操作（时间复杂度为 O (1)），也支持随机访问（通过下标访问元素时间复杂度为 O (1)） ，但性能上可能略逊于 vector。
     
   应用场景：适用于需要在两端频繁插入和删除元素，同时也需要随机访问的场景，如实现滑动窗口等。
4. 集合 (set)
     
   特点：基于红黑树实现，每个节点包含一个元素，元素具有唯一性（不允许重复元素），并且元素按照特定的比较规则（谓词）进行排序。插入、删除和查找元素的时间复杂度平均为 O (log n)。
     
   应用场景：用于需要快速查找元素是否存在，以及对元素进行自动排序，并且不允许重复元素的场景，如去重操作、判断元素是否在集合中等。
5. 多重集合 (multiset)
     
   特点：同样基于红黑树实现，与 set 的区别在于它允许存在相等的元素，插入、删除和查找元素的时间复杂度平均为 O (log n)。
     
   应用场景：适用于需要统计元素出现次数，或者需要存储重复元素且要求元素有序的场景。
6. 栈 (stack)
     
   特点：后进先出（LIFO）的数据结构，底层通常基于 vector 或 deque 实现。主要操作有 push（压栈）、pop（弹栈）和 top（获取栈顶元素），时间复杂度均为 O (1)。
     
   应用场景：用于实现函数调用栈、表达式求值（如后缀表达式计算）、回溯算法等。
7. 队列 (queue)
     
   特点：先进先出（FIFO）的数据结构，底层通常基于 deque 实现。主要操作有 push（入队）、pop（出队）和 front（获取队头元素），时间复杂度均为 O (1)。
     
   应用场景：用于处理任务调度、广度优先搜索（BFS）算法等。
8. 优先队列 (priority\_queue)
     
   特点：元素按照特定的谓词（比较规则）进行排序，每次取出的元素是优先级最高（或最低，取决于比较规则）的元素。底层通常基于 vector 实现的堆结构，插入和删除元素的时间复杂度平均为 O (log n)，获取优先级最高的元素时间复杂度为 O (1)。
     
   应用场景：用于实现任务调度（根据任务优先级执行）、寻找最小生成树（Prim 算法）、最短路径算法（Dijkstra 算法）等。
9. 映射 (map)
     
   特点：由键值对组成，基于红黑树实现，键具有唯一性，元素按照键的比较规则进行排序。插入、删除和查找元素的时间复杂度平均为 O (log n)。
     
   应用场景：用于需要通过键快速查找对应值的场景，如统计单词出现次数、实现字典等。
10. 多重映射 (multimap)
      
    特点：与 map 类似，也是由键值对组成，但允许键重复，同样基于红黑树实现，插入、删除和查找元素的时间复杂度平均为 O (log n)。
      
    应用场景：适用于需要存储多个相同键对应不同值的场景，如存储学生的多次考试成绩（以学生 ID 为键）。
      
    这些数据结构在 C++ 标准模板库中提供了丰富的功能，在实际编程中，根据不同的需求选择合适的数据结构可以提高程序的效率和可读性