---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37373432363533332f:61727469636c652f64657461696c732f313436303738373234"
layout: post
title: "JVM学习-类文件结构-类加载"
date: 2025-03-11 08:00:00 +0800
description: "使用场景想加载非 classpath 随意路径中的类文件通过接口来使用实现，希望解耦时，常用在框架设计这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器步骤继承 ClassLoader 父类要遵从双亲委派机制，重写 ﬁndClass 方法不是重写 loadClass 方法，否则不会走双亲委派机制读取类文件的字节码调用父类的 deﬁneClass 方法来加载类使用者调用该类加载器的 loadClass 方法破坏双亲委派模式。"
keywords: "JVM学习-类文件结构 类加载"
categories: ['未分类']
tags: ['学习', '后端', 'Jvm', 'Java']
artid: "146078724"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146078724
    alt: "JVM学习-类文件结构-类加载"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146078724
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146078724
cover: https://bing.ee123.net/img/rand?artid=146078724
image: https://bing.ee123.net/img/rand?artid=146078724
img: https://bing.ee123.net/img/rand?artid=146078724
---

# JVM学习-类文件结构 类加载

类加载和字节码技术

![](https://i-blog.csdnimg.cn/direct/4f39eba4bf23446aa0152db3f139de90.png)

## 一.类文件结构

#### 示例:

一个简单的 HelloWorld.java

`package cn.itcast.jvm.t5;

// HelloWorld 示例

public class HelloWorld {

public static void main(String[] args) {

System.out.println("hello world");

}

}`

* 执行 javac -parameters -d . HellowWorld.java（加上 -parameters 会保留方法中的名称信息）

#### 编译为 HelloWorld.class 后是这个样子的

`[root@localhost ~]# od -t xC HelloWorld.class

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07

0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29

0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e

0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63

0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01

0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63

0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f

0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16

0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72

0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13

0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69

0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61

0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46

0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64

0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e

0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64

0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74

0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c

0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61

0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61

0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f

0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72

0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76

0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d

0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a

0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b

0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01

0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01

0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00

0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00

0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00

0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00

0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a

0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b

0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00

0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00

0001120 00 00 02 00 14`

* ### 根据 JVM 规范，类文件结构如下

  `ClassFile {

  u4 magic; //（魔术）

  u2 minor\_version;//(小版本号)

  u2 major\_version;//(主版本号)

  u2 constant\_pool\_count;

  cp\_info constant\_pool[constant\_pool\_count-1];

  u2 access\_flags;//(访问修饰)

  u2 this\_class;

  u2 super\_class;//(父类信息)

  u2 interfaces\_count;

  u2 interfaces[interfaces\_count];//(接口信息)

  u2 fields\_count;

  field\_info fields[fields\_count];//(类中变量)

  u2 methods\_count;

  method\_info methods[methods\_count];//(类的方法信息)

  u2 attributes\_count;

  attribute\_info attributes[attributes\_count];//(类的附加属性信息)

  }`

  解释：前面的u4、u2代表的是字节数

### 1）魔术（所有文件都有一个自己的特定类型类型）

0~3 字节，表示它是否是【class】类型的文件

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

### 2）版本

4~7 字节，表示类的版本 00 34（52） 表示是 Java 8

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

### 3） **常量池**

| **Constant Type** | **Value** |
| --- | --- |
| CONSTANT\_Class | 7 |
| CONSTANT\_Fieldref | 9 |
| CONSTANT\_Methodref（方法引用的信息） | 10 |
| CONSTANT\_InterfaceMethodref | 11 |
| CONSTANT\_String | 8 |
| CONSTANT\_Integer | 3 |
| CONSTANT\_Float | 4 |
| CONSTANT\_Long | 5 |
| CONSTANT\_Double | 6 |
| CONSTANT\_NameAndType | 12 |
| CONSTANT\_Utf8 | 1 |
| CONSTANT\_MethodHandle | 15 |
| CONSTANT\_MethodType | 16 |
| CONSTANT\_InvokeDynamic | 18 |

8~9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1~#34项，注意 #0 项不计入，也没有值

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

第#1项 0a（16进制表示10进制的10） 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得

这个方法的【所属类】和【方法名】

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项

来获得这个成员变量的【所属类】和【成员变量名】

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07

第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07

第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26

项来获得这个方法的【所属类】和【方法名】

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07

第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07

0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29

第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 <init> （构造方法）】

0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29

第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值

0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29

0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e

第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】

0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e

第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65

是【LineNumberTable】

0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e

0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63

第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61

62 6c 65是【LocalVariableTable】

0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63

0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01

第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】

0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01

0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63

第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】

0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63

0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16

第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】

0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16

第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为

字符串数组，无返回值

0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16

0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72

0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13

第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】

0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13

第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】

0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13

0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69

0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61

第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】

0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61

0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46

第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】

0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46

0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64

第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】

0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64

0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e

第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项

0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e

第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项

0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项

0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e

0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64

第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】

0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64

第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项

0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74

第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项

0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74

第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】

0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74

0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c

0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61

第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】

0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61

0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61

第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】

0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61

0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f

第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】

0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f

0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72

第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】

0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72

0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76
**Flag Name**

**Value**

**Interpretation**

ACC\_PUBLIC

0x0001

Declared public ; may be accessed from outside its

package.

ACC\_FINAL

0x0010

Declared final ; no subclasses allowed.

ACC\_SUPER

0x0020

Treat superclass methods specially when invoked by the

*invokespecial*
instruction.

ACC\_INTERFACE

0x0200

Is an interface, not a class.

ACC\_ABSTRACT

0x0400

Declared abstract ; must not be instantiated.

ACC\_SYNTHETIC

0x1000

Declared synthetic; not present in the source code.

ACC\_ANNOTATION

0x2000

Declared as an annotation type.

ACC\_ENUM

0x4000

Declared as an enum type.

第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】

0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76

0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d

第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】

0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a

第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】

0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a

0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b

0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01

### 4）访问标识与继承信息

21 表示该 class 是一个类，公共的

0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01

05 表示根据常量池中 #5 找到本类全限定名

0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01

06 表示根据常量池中 #6 找到父类全限定名

0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01

表示接口的数量，本类为 0

0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01

## 二、字节码指令

### 1.javap工具

java 中提供了 javap 工具来反编译 class 文件

```
javap -v D:Demo.class
```

### 2.图解法执行流程

#### 1）源java代码

`package cn.itcast.jvm.t3.bytecode;

/\*\*

\* 演示 字节码指令 和 操作数栈、常量池的关系

\*/

public class Demo3\_1 {

public static void main(String[] args) {

int a = 10;

int b = Short.MAX\_VALUE + 1;

int c = a + b;

System.out.println(c);

}

}`

#### 2）逐步分析 -案例一

###### ①常量池载入运行时常量池

![](https://i-blog.csdnimg.cn/direct/f826fd4a1a844fb696215383e927916c.png)

###### ② **方法字节码载入方法区**

![](https://i-blog.csdnimg.cn/direct/ad4e9f3bb5a44909afde6d3d11ccfcae.png)

###### ③ **main** **线程开始运行，分配栈帧内存**

（操作数栈的宽度是四个字节）

（stack=2，locals=4） 对应操作数栈有 2 个空间（每个空间 4 个字节），局部变量表中有 4 个槽位。

![](https://i-blog.csdnimg.cn/direct/5bd0b9eed42448f281c8a0a405335cc3.png)

###### ④ **执行引擎开始执行字节码**

然后执行引擎开始一行行读取方法区的代码，执行

1.第一行
**bipush 10**

将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有

sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）

ldc 将一个 int 压入操作数栈

ldc2\_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）

这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池

![](https://i-blog.csdnimg.cn/direct/53eedc73ada9415d8d7897e757675ff4.png)

2.执行第二行
**istore\_1**

将操作数栈顶数据弹出，存入局部变量表的 slot 1

![](https://i-blog.csdnimg.cn/direct/240a705dfd7f4581b2385b89c0ec4c18.png)

3.
**ldc #3**

从常量池加载 #3 数据到操作数栈

**注意**
Short.MAX\_VALUE 是 32767，所以 32768 = Short.MAX\_VALUE + 1 实际是在编译期间计算

好的

![](https://i-blog.csdnimg.cn/direct/fecf16a7d4554ed2a87765cdbf6dbf14.png)

4.
**istore\_2**

![](https://i-blog.csdnimg.cn/direct/1c220826859a4916b7377d92989003f8.png)

5.
**iload\_1**

![](https://i-blog.csdnimg.cn/direct/9ccecce2aa3a4419ac9c358d1602acbd.png)

6、
**iload\_2**

![](https://i-blog.csdnimg.cn/direct/0bef500411e846deb83938a33c58ef31.png)

7.
**iadd**

![](https://i-blog.csdnimg.cn/direct/2722d6d2d48249c2941af94bc6a8cb18.png)

8.
**istore\_3**

![](https://i-blog.csdnimg.cn/direct/0e7b82a9e060439c8846b6232c7242c7.png)

9、
**getstatic #4**

![](https://i-blog.csdnimg.cn/direct/21dbf9a903164229b05f78b7321f5e2e.png)

![](https://i-blog.csdnimg.cn/direct/e17d4895fb1e4f45a579145785f409b2.png)

10、
**iload\_3**

![](https://i-blog.csdnimg.cn/direct/a97181ae96004c1195c2f6ae7b7940a7.png)

11.
**invokevirtual #5**

找到常量池 #5 项

定位到方法区 java/io/PrintStream.println:(I)V 方法

生成新的栈帧（分配 locals、stack等）

传递参数，执行新栈帧中的字节码

![](https://i-blog.csdnimg.cn/direct/2a47a51ba4f84a2792508dc3e39ba3c3.png)

#### 3）逐步分析 -案例二

java源代码

`package cn.itcast.jvm.t3.bytecode;

/\*\*

\* 从字节码角度分析 a++ 相关题目

\*/

public class Demo3\_2 {

public static void main(String[] args) {

int a = 10;

int b = a++ + ++a + a--;

System.out.println(a);

System.out.println(b);

}

}`

分析：

注意 iinc 指令（代码中的++）是直接在局部变量 slot 上进行运算（即直接在局部变量表中执行的没有进栈）

a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc

1.bipush 10 把10先放入操作数栈中

![](https://i-blog.csdnimg.cn/direct/3817a428490449009decafd0bf53499d.png)

2.istore 1 把10弹出来 放入1号

然后开始执行i++ ,要先iload 再自增

iload先把值读入操作数栈中

![](https://i-blog.csdnimg.cn/direct/ae4a0a0254d9499a9d6038f91c2c4718.png)

执行自增 iinc ，此命令有两个参数第一个是对那个槽位操作第二个表示自增几

![](https://i-blog.csdnimg.cn/direct/0ef1dfda453e417f83c005a7782db75d.png)

iadd命令做加法，把栈中的两个数弹出 相加后 结果再压入占中

![](https://i-blog.csdnimg.cn/direct/ac5cd956361041e7bb988bb7f1ccddf2.png)

![](https://i-blog.csdnimg.cn/direct/0d203dd2471e41159efdbfab5cb3ac65.png)

![](https://i-blog.csdnimg.cn/direct/a4d275ff1b814b1eb1f7fb62c467b900.png)

### 3.条件判断指令

![](https://i-blog.csdnimg.cn/direct/fb5f2ea953e9477f8a6bc0fbb2996c1c.png)

几点说明：

byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节

goto 用来进行跳转到指定行号的字节码

例子：

源码：`public class Demo3\_3 {

public static void main(String[] args) {

int a = 0;

if(a == 0) {

a = 10;

} else {

a = 20;

}

}

}`

字节码：

`0: iconst\_0

1: istore\_1

2: iload\_1

3: ifne 12

6: bipush 10

8: istore\_1

9: goto 15

12: bipush 20

14: istore\_1

15: return`

### 4.循环控制指令

##### 1）while循环

例：`public class Demo3\_4 {

public static void main(String[] args) {

int a = 0;

while (a < 10) {

a++;

}

}

}`

字节码：`0: iconst\_0

1: istore\_1

2: iload\_1

3: bipush 10

5: if\_icmpge 14

8: iinc 1, 1

11: goto 2

14: return`

##### 2）do-while循环

`public class Demo3\_5 {

public static void main(String[] args) {

int a = 0;

do {

a++;

} while (a < 10);

}

}`

字节码：`0: iconst\_0

1: istore\_1

2: iinc 1, 1

5: iload\_1

6: bipush 10

8: if\_icmplt 2

11: return`

##### 3）for循环

`public class Demo3\_6 {

public static void main(String[] args) {

for (int i = 0; i < 10; i++) {

}

}

}`

字节码：

`0: iconst\_0

1: istore\_1

2: iload\_1

3: bipush 10

5: if\_icmpge 14

8: iinc 1, 1

11: goto 2

14: return`

注：while和for循环的字节码一样的

##### *\* 练习* \*

请从字节码角度分析，下列代码运行的结果：

`public class Demo3\_6\_1 {

public static void main(String[] args) {

int i = 0;

int x = 0;

while (i < 10) {

x = x++;

i++;

}

System.out.println(x);
**// 结果是 0**

}

}`

### 5.构造方法

#### 1）cinit

<cinit>()V

代码：

`public class Demo3\_8\_1 {

static int i = 10;

static {

i = 20;

}

static {

i = 30;

}

}`

编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方

法 <cinit>()V ：

`0: bipush 10

2: putstatic #2 // Field i:I

5: bipush 20

7: putstatic #2 // Field i:I

10: bipush 30

12: putstatic #2 // Field i:I

15: return`

<cinit>()V 方法会在类加载的初始化阶段被调用

#### 2）init

<init>()V

代码：

`public class Demo3\_8\_2 {

private String a = "s1";

{

b = 20;

}

private int b = 10;

{

a = "s2";

}

public Demo3\_8\_2(String a, int b) {

this.a = a;

this.b = b;

}

public static void main(String[] args) {

Demo3\_8\_2 d = new Demo3\_8\_2("s3", 30);

System.out.println(d.a);

System.out.println(d.b);

}

}`

编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构

造方法内的代码总是在最后

`public cn.itcast.jvm.t3.bytecode.Demo3\_8\_2(java.lang.String, int);

descriptor: (Ljava/lang/String;I)V

flags: ACC\_PUBLIC

Code:

stack=2, locals=3, args\_size=3

0: aload\_0

1: invokespecial #1 // super.<init>()V

4: aload\_0

5: ldc #2 // <- "s1"

7: putfield #3 // -> this.a

10: aload\_0

11: bipush 20 // <- 20

13: putfield #4 // -> this.b

16: aload\_0

17: bipush 10 // <- 10

19: putfield #4 // -> this.b

22: aload\_0

23: ldc #5 // <- "s2"

25: putfield #3 // -> this.a

28: aload\_0 // ------------------------------

29: aload\_1 // <- slot 1(a) "s3" |

30: putfield #3 // -> this.a |

33: aload\_0 |

34: iload\_2 // <- slot 2(b) 30 |

35: putfield #4 // -> this.b --------------------

38: return

LineNumberTable: ...

LocalVariableTable:

Start Length Slot Name Signature

0 39 0 this Lcn/itcast/jvm/t3/bytecode/Demo3\_8\_2;

0 39 1 a Ljava/lang/String;

0 39 2 b I

MethodParameters: ...`

### 6.方法调用

示例代码：

`public class Demo3\_9 {

public Demo3\_9() { }

private void test1() { }

private final void test2() { }

public void test3() { }

public static void test4() { }

public static void main(String[] args) {

Demo3\_9 d = new Demo3\_9();

d.test1();

d.test2();

d.test3();

d.test4();

Demo3\_9.test4();

}

}`

对应的字节码：

`0: new #2 // class cn/itcast/jvm/t3/bytecode/Demo3\_9

3: dup

4: invokespecial #3 // Method "<init>":()V

7: astore\_1

8: aload\_1

9: invokespecial #4 // Method test1:()V

12: aload\_1

13: invokespecial #5 // Method test2:()V

16: aload\_1

17: invokevirtual #6 // Method test3:()V

20: aload\_1

21: pop

22: invokestatic #7 // Method test4:()V

25: invokestatic #7 // Method test4:()V

28: return`

解释：不同方法在调用时，对应的虚拟机指令有所区别

* 私有、构造、被 final 修饰的方法，在调用时都使用 invokespecial 指令
* 普通成员方法在调用时，使用 invokevirtual 指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定
* 静态方法在调用时使用 invokestatic 指令
* new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数
* dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配
* 合 invokespecial 调用该对象的构造方法 "<init>":()V （会消耗掉栈顶一个引用），另一个要
* 配合 astore\_1 赋值给局部变量
* 最终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静
* 态绑定
* 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态
* 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】
* 比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用
* invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了😂
* 还有一个执行 invokespecial 的情况是通过 super 调用父类方

### 7.多态的原理

因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用 invokevirtual 指令 在执行 invokevirtual 指令时，经历了以下几个步骤

先通过栈帧中对象的引用找到对象 ​ 分析对象头，找到对象实际的 Class ​ Class 结构中有 vtable ​ 查询 vtable 找到方法的具体地址 ​ 执行方法的字节码

操作：

**1\***
\*）运行代码\*\*

停在 System.in.read() 方法上，这时运行 jps 获取进程 id

**2\***
\*）运行\*\*
**HSDB**
**工具**

进入 JDK 安装目录，执行

java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB

进入图形界面 attach 进程 id

### 8.异常处理

#### 1） **try-catch**

代码：

`public class Demo3\_11\_1 {

public static void main(String[] args) {

int i = 0;

try {

i = 10;

} catch (Exception e) {

i = 20;

}

}

}`

字节码：

`public static void main(java.lang.String[]);

descriptor: ([Ljava/lang/String;)V

flags: ACC\_PUBLIC, ACC\_STATIC

Code:

stack=1, locals=3, args\_size=1

0: iconst\_0

1: istore\_1

2: bipush 10

4: istore\_1

5: goto 12

8: astore\_2

9: bipush 20

11: istore\_1

12: return

Exception table:

from to target type

2 5 8 Class java/lang/Exception

LineNumberTable: ...

LocalVariableTable:

Start Length Slot Name Signature

9 3 2 e Ljava/lang/Exception;

0 13 0 args [Ljava/lang/String;

2 11 1 i I

StackMapTable: ...

MethodParameters: ...

}`

可以看出多出了一个个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号

8 行的字节码指令 astore\_2 是将异常对象引用存入局部变量表的 slot 2 位置

#### 2） **多个** **single-catch** **块**

代码：

`public class Demo3\_11\_2 {

public static void main(String[] args) {

int i = 0;

try {因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用

**multi-catch**
**的情况**

i = 10;

} catch (ArithmeticException e) {

i = 30;

} catch (NullPointerException e) {

i = 40;

} catch (Exception e) {

i = 50;

}

}

}`

字节码：

`public static void main(java.lang.String[]);

descriptor: ([Ljava/lang/String;)V

flags: ACC\_PUBLIC, ACC\_STATIC

Code:

stack=1, locals=3, args\_size=1

0: iconst\_0

1: istore\_1

2: bipush 10

4: istore\_1

5: goto 26

8: astore\_2

9: bipush 30

11: istore\_1

12: goto 26

15: astore\_2

16: bipush 40

18: istore\_1

19: goto 26

22: astore\_2

23: bipush 50

25: istore\_1

26: return

Exception table:

from to target type

2 5 8 Class java/lang/ArithmeticException

2 5 15 Class java/lang/NullPointerException

2 5 22 Class java/lang/Exception

LineNumberTable: ...

LocalVariableTable:

Start Length Slot Name Signature

9 3 2 e Ljava/lang/ArithmeticException;

16 3 2 e Ljava/lang/NullPointerException;

23 3 2 e Ljava/lang/Exception;

0 27 0 args [Ljava/lang/String;

2 25 1 i I

StackMapTable: ...

MethodParameters: ...`

因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用

#### 3）finally

代码：

`public class Demo3\_11\_4 {

public static void main(String[] args) {

int i = 0;

try {

i = 10;

} catch (Exception e) {

i = 20;

} finally {

i = 30;

}

}

}`

对应字节码：

`public static void main(java.lang.String[]);

descriptor: ([Ljava/lang/String;)V

flags: ACC\_PUBLIC, ACC\_STATIC

Code:

stack=1, locals=4, args\_size=1

0: iconst\_0

1: istore\_1 // 0 -> i

2: bipush 10 // try --------------------------------------

4: istore\_1 // 10 -> i |

5: bipush 30 // finally |

7: istore\_1 // 30 -> i |

8: goto 27 // return -----------------------------------

11: astore\_2 // catch Exceptin -> e ----------------------

12: bipush 20 // |

14: istore\_1 // 20 -> i |

15: bipush 30 // finally |

17: istore\_1 // 30 -> i |

18: goto 27 // return -----------------------------------

21: astore\_3 // catch any -> slot 3 ----------------------

22: bipush 30 // finally |

24: istore\_1 // 30 -> i |

25: aload\_3 // <- slot 3 |

26: athrow // throw ------------------------------------

27: return

Exception table:

from to target type

2 5 11 Class java/lang/Exception

2 5 21 any // 剩余的异常类型，比如 Error

11 15 21 any // 剩余的异常类型，比如 Error

LineNumberTable: ...

LocalVariableTable:

Start Length Slot Name Signature

12 3 2 e Ljava/lang/Exception;

0 28 0 args [Ljava/lang/String;

2 26 1 i I

StackMapTable: ...

MethodParameters: ...`

每个分支都是一个，都会执行finally中的代码，跟分支结构类似。try catch 还有本身

可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流

程

##### finally面试题1

题目：下面的题目输出什么？

`public class Demo3\_12\_2 {

public static void main(String[] args) {

int result = test();

System.out.println(result);

}

public static int test() {

try {

return 10;

} finally {

return 20;

}

}

}`

答案 20；

解释：对应的字节码如下

`public static int test();

descriptor: ()I

flags: ACC\_PUBLIC, ACC\_STATIC

Code:

stack=1, locals=2, args\_size=0

0: bipush 10 // <- 10 放入栈顶

2: istore\_0 // 10 -> slot 0 (从栈顶移除了)

3: bipush 20 // <- 20 放入栈顶

5: ireturn // 返回栈顶 int(20)

6: astore\_1 // catch any -> slot 1

7: bipush 20 // <- 20 放入栈顶

9: ireturn // 返回栈顶 int(20)

Exception table:

from to target type

0 3 6 any

LineNumberTable: ...

StackMapTable: ...`

* 由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准
* 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子
* 跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常😱😱😱，可以试一下下面的代码：

  `public class Demo3\_12\_1 {

  public static void main(String[] args) {

  int result = test();

  System.out.println(result);

  }

  public static int test() {

  try {int i = 1/0;

  return 10;

  } finally {

  return 20;

  }

  }

  }`

  执行是不会出现任何异常的

##### finally面试题1

题目：下面的题目输出什么？

`public class Demo3\_12\_2 {

public static void main(String[] args) {

int result = test();

System.out.println(result);

}

public static int test() {

int i = 10;

try {

return i;

} finally {

i = 20;

}

}

}`

答案输出10

解析：对应的字节码: `public static int test();

descriptor: ()I

flags: ACC\_PUBLIC, ACC\_STATIC

Code:

stack=1, locals=3, args\_size=0

0: bipush 10 // <- 10 放入栈顶

2: istore\_0 // 10 -> i

3: iload\_0 // <- i(10)

4: istore\_1 // 10 -> slot 1，暂存至 slot 1，目的是为了固定返回值

5: bipush 20 // <- 20 放入栈顶

7: istore\_0 // 20 -> i

8: iload\_1 // <- slot 1(10) 载入 slot 1 暂存的值

9: ireturn // 返回栈顶的 int(10)

10: astore\_2

11: bipush 20

13: istore\_0

14: aload\_2

15: athrow

Exception table:

from to target type

3 5 10 any

LineNumberTable: ...

LocalVariableTable:

Start Length Slot Name Signature

3 13 0 i I

StackMapTable: ...`

### 9.synchronized

public class Demo3\_13 {

public static void main(String[] args) {

Object lock = new Object();

synchronized (lock) {

System.out.println("ok");

}

}

}

对应字节码：

`public static void main(java.lang.String[]);

descriptor: ([Ljava/lang/String;)V

flags: ACC\_PUBLIC, ACC\_STATIC

Code:

stack=2, locals=4, args\_size=1

0: new #2 // new Object

3: dup

4: invokespecial #1 // invokespecial <init>:()V

7: astore\_1 // lock引用 -> lock

8: aload\_1 // <- lock （synchronized开始）

9: dup

10: astore\_2 // lock引用 -> slot 2

11: monitorenter // monitorenter(lock引用)

12: getstatic #3 // <- System.out

15: ldc #4 // <- "ok"

17: invokevirtual #5 // invokevirtual println:

(Ljava/lang/String;)V

20: aload\_2 // <- slot 2(lock引用)

21: monitorexit // monitorexit(lock引用)

22: goto 30

25: astore\_3 // any -> slot 3

26: aload\_2 // <- slot 2(lock引用)

27: monitorexit // monitorexit(lock引用)

28: aload\_3

29: athrow

30: return

Exception table:

from to target type

12 22 25 any

25 28 25 any

LineNumberTable: ...

LocalVariableTable:

Start Length Slot Name Signature

0 31 0 args [Ljava/lang/String;

8 23 1 lock Ljava/lang/Object;

StackMapTable: ...

MethodParameters: ...`

方法级别的 synchronized 不会在字节码指令中有所体现

## 三、编译期预处理

所谓的 语法糖 ，其实就是指 java 编译器把 \*.java 源码编译为 \*.class 字节码的过程中，自动生成

和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃

嘛）

注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，

编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并

不是编译器还会转换出中间的 java 源码，切记。

### 1. **默认构造器**

public class Candy1 {

}

编译成class后的代码：

public class Candy1 {

// 这个无参构造是编译器帮助我们加上的

public Candy1() {

super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."

<init>":()V

}

}

### **2** . **自动拆装箱**

这个特性是 JDK 5 开始加入的， 代码片段1 ：

`public class Candy2 {

public static void main(String[] args) {

Integer x = 1;

int y = x;

}

}`

这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 :

`public class Candy2 {

public static void main(String[] args) {

Integer x = Integer.valueOf(1);

int y = x.intValue();

}

}`

### **3.** **泛型集合取值**

泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息

在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：

![](https://i-blog.csdnimg.cn/direct/c7259a8201404c36acae465876d91e2f.png)

![](https://i-blog.csdnimg.cn/direct/4bbe001fe92847a3a4d5c6aa4e80db1c.png)

### **4.** **可变参数**

可变参数也是 JDK 5 开始加入的新特性：

`public class Candy4 {

public static void foo(String... args) {

String[] array = args; // 直接赋值

System.out.println(array);

}

public static void main(String[] args) {

foo("hello", "world");

}

}`

可变参数 String... args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。

同样 java 编译器会在编译期间将上述代码变换为：

`public class Candy4 {

public static void foo(String[] args) {

String[] array = args; // 直接赋值

System.out.println(array);

}

public static void main(String[] args) {

foo(new String[]{"hello", "world"});

}

}`

**注意**

如果调用了 foo() 则等价代码为 foo(new String[]{}) ，创建了一个空的数组，而不会传递

null 进去

### 5. **foreach** **循环**

仍是 JDK 5 开始引入的语法糖，数组的循环：

`public class Candy5\_1 {

public static void main(String[] args) {

int[] array = {1, 2, 3, 4, 5}; // 数组赋初值的简化写法也是语法糖哦

for (int e : array) {

System.out.println(e);

}

}

}`

会被编译器转换为：

`public class Candy5\_1 {

public Candy5\_1() {

}

public static void main(String[] args) {

int[] array = new int[]{1, 2, 3, 4, 5};

for(int i = 0; i < array.length; ++i) {

int e = array[i];

System.out.println(e);

}

}

}`

而集合的循环：

`public class Candy5\_2 {

public static void main(String[] args) {

List<Integer> list = Arrays.asList(1,2,3,4,5);

for (Integer i : list) {

System.out.println(i);

}

}

}`

实际被编译器转换为对迭代器的调用：

`public class Candy5\_2 {

public Candy5\_2() {

}

public static void main(String[] args) {

List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);

Iterator iter = list.iterator();

while(iter.hasNext()) {

Integer e = (Integer)iter.next();

System.out.println(e);

}

}

}`

**注意**

foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其中

Iterable 用来获取集合的迭代器（ Iterator ）

### 6. **switch** - **字符串**

从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：

`public class Candy6\_1 {

public static void choose(String str) {

switch (str) {

case "hello": {

System.out.println("h");

break;

}

case "world": {

System.out.println("w");

break;

}

}

}

}`

**注意**

switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清

楚

会被编译器转换为：

`public class Candy6\_1 {

public Candy6\_1() {

}

public static void choose(String str) {

byte x = -1;

switch(str.hashCode()) {

case 99162322: // hello 的 hashCode

if (str.equals("hello")) {x = 0;

}

break;

case 113318802: // world 的 hashCode

if (str.equals("world")) {

x = 1;

}

}

switch(x) {

case 0:

System.out.println("h");

break;

case 1:

System.out.println("w");

}

}

}`

可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应

byte 类型，第二遍才是利用 byte 执行进行比较。

为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可

能的比较；而 equals 是为了防止 hashCode 冲突(两个字符串的hashcode可能一样，在进入用equals进行比较)，例如 BM 和 C. 这两个字符串的hashCode值都是2123 .

### 7. **switch** - **枚举**

`enum Sex {

MALE, FEMALE

}`

`public class Candy7 {

public static void foo(Sex sex) {

switch (sex) {

case MALE:

System.out.println("男"); break;

case FEMALE:

System.out.println("女"); break;

}

}

}`

转换后代码：

`public class Candy7 {

/\*\*

\* 定义一个合成类（仅 jvm 使用，对我们不可见）

\* 用来映射枚举的 ordinal 与数组元素的关系

\* 枚举的 ordinal 表示枚举对象的序号，从 0 开始

\* 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1

\*/

static class $MAP {

// 数组大小即为枚举元素个数，里面存储case用来对比的数字

static int[] map = new int[2];

static {

map[Sex.MALE.ordinal()] = 1;

map[Sex.FEMALE.ordinal()] = 2;

}

}

public static void foo(Sex sex) {

int x = $MAP.map[sex.ordinal()];

switch (x) {

case 1:

System.out.println("男");

break;

case 2:

System.out.println("女");

break;

}

}

}`

### 8. **枚举类**

JDK 7 新增了枚举类，以前面的性别枚举为例：

`enum Sex {

MALE, FEMALE

}`

转换后代码：

`public final class Sex extends Enum<Sex> {

public static final Sex MALE;

public static final Sex FEMALE;

private static final Sex[] $VALUES;

static {

MALE = new Sex("MALE", 0);

FEMALE = new Sex("FEMALE", 1);

$VALUES = new Sex[]{MALE, FEMALE};

}

/\*\*

\* Sole constructor. Programmers cannot invoke this constructor.

\* It is for use by code emitted by the compiler in response to

\* enum type declarations.

\*

\* @param name - The name of this enum constant, which is the identifier

\* used to declare it.

\* @param ordinal - The ordinal of this enumeration constant (its position

\* in the enum declaration, where the initial constant is

assigned

\*/

private Sex(String name, int ordinal) {

super(name, ordinal);

}

public static Sex[] values() {

return $VALUES.clone();

}

public static Sex valueOf(String name) {

return Enum.valueOf(Sex.class, name);

}

}`

### 9. **try-with-resources**

JDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources`：

`try(资源变量 = 创建资源对象){

} catch( ) {

}`

其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、

Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-with

resources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：

`public class Candy9 {

public static void main(String[] args) {

try(InputStream is = new FileInputStream("d:\1.txt")) {

System.out.println(is);

} catch (IOException e) {

e.printStackTrace();

}

}

}`

会被转换为：

`public class Candy9 {

public Candy9() {

}

public static void main(String[] args) {

try {

InputStream is = new FileInputStream("d:\1.txt");

Throwable t = null;

try {

System.out.println(is);

} catch (Throwable e1) {

// t 是我们代码出现的异常

t = e1;

throw e1;

} finally {

// 判断了资源不为空

if (is != null) {

// 如果我们代码有异常

if (t != null) {

try {

is.close();

} catch (Throwable e2) {

// 如果 close 出现异常，作为被压制异常添加

t.addSuppressed(e2);

}

} else {

// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e

is.close();

}

}

}

} catch (IOException e) {

e.printStackTrace();

}

}

}`

会帮我们进行资源的释放，而且释放更规范，不会丢失异常信息

### **10** . **方法重写时的桥接方法**

我们都知道，方法重写时对返回值分两种情况：

* 父子类的返回值完全一致
* 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）

`class A { public Number m() { return 1; } } class B extends A { @Override // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 public Integer m() { return 2; } }`

对于子类，java 编译器会做如下处理：

`class B extends A { public Integer m() { return 2; } // 此方法才是真正重写了父类 public Number m() 方法 public synthetic bridge Number m() { // 调用 public Integer m() return m(); } }`

其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以 用下面反射代码来验证：

`public static void main(String[] args) { for(Method m : B.class.getDeclaredMethods()) { System.out.println(m); } }`

结果：

`public java.lang.Integer cn.ali.jvm.test.B.m() public java.lang.Number cn.ali.jvm.test.B.m()`

### 11. **匿名内部类**

源代码：

`public class Candy11 {

public static void main(String[] args) {

Runnable runnable = new Runnable() {

@Override

public void run() {

System.out.println("ok");

}

};

}

}`

转换后代码：

`// 额外生成的类

final class Candy11$1 implements Runnable {

Candy11$1() {

}

public void run() {

System.out.println("ok");

}

}`

`public class Candy11 {

public static void main(String[] args) {

Runnable runnable = new Candy11$1();

}

}`

引用局部变量的匿名内部类，源代码：

![](https://i-blog.csdnimg.cn/direct/bbef956677fd428b83d1da351ddf9a8d.png)

**注意**

这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建

Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性，所以 x 不应该再发生变

化了，如果变化，那么 val$x 属性没有机会再跟着一起变化

## 四、类加载

### 1）加载

将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：

* \_java\_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用
* \_super 即父类
* \_ﬁelds 即成员变量
* \_methods 即方法
* \_constants 即常量池
* \_class\_loader 即类加载器
* \_vtable 虚方法表
* \_itable 接口方法

如果这个类还有父类没有加载，先加载父类 加载和链接可能是交替运行的

![](https://i-blog.csdnimg.cn/direct/ca5f5c14fda346e1a2ddf95819c4c3a6.png)

* instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中
* \_java\_mirror则是保存在堆内存中
* InstanceKlass和\*.class(JAVA镜像类)互相保存了对方的地址
* 类的对象在对象头中保存了\*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息

  **注意**

  instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 \_java\_mirror

  是存储在堆中

  可以通过前面介绍的 HSDB 工具查看

### 2）连接

#### 2.1验证

验证类是否符合 JVM规范，安全性检查 用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行

#### 2.2准备

为 static 变量分配空间，设置默认值

* static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 \_java\_mirror 末尾
* static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成
* 如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成
* 如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用

`public class Code\_22\_AnalysisTest {

```
public static void main(String[] args) throws ClassNotFoundException, IOException {
    ClassLoader classLoader = Code_22_AnalysisTest.class.getClassLoader();
    Class<?> c = classLoader.loadClass("cn.ali.jvm.test.C");
​
    // new C();
    System.in.read();
}
```

}

class C { D d = new D(); }

class D {

}`

#### 2.3 **解析**

将常量池中的符号引用解析为直接引用

`package cn.xxxde.jvm.load;

/\*\*

\* 解析的含义

\*/

public class Load2 {

public static void main(String[] args) throws ClassNotFoundException,

IOException {

ClassLoader classloader = Load2.class.getClassLoader();

// loadClass 方法不会导致类的解析和初始化

Class<?> c = classloader.loadClass("cn.itcast.jvm.t3.load.C");

// new C();

System.in.read();

}

}

class C {

D d = new D();

}

class D {

}`

### 3）初始化

<cinit>()v 方法 初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全

发生的时机 概括得说，类初始化是【懒惰的】

* main 方法所在的类，总会被首先初始化
* 首次访问这个类的静态变量或静态方法时
* 子类初始化，如果父类还没初始化，会引发
* 子类访问父类的静态变量，只会触发父类的初始化
* Class.forName
* new 会导致初始化

不会导致类初始化的情况

* 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化
* 类对象.class 不会触发初始化
* 创建该类的数组不会触发初始化

`public class Load1 { static { System.out.println("main init"); } public static void main(String[] args) throws ClassNotFoundException { // 1. 静态常量（基本类型和字符串）不会触发初始化 // System.out.println(B.b); // 2. 类对象.class 不会触发初始化 // System.out.println(B.class); // 3. 创建该类的数组不会触发初始化 // System.out.println(new B[0]); // 4. 不会初始化类 B，但会加载 B、A // ClassLoader cl = Thread.currentThread().getContextClassLoader(); // cl.loadClass("cn.ali.jvm.test.classload.B"); // 5. 不会初始化类 B，但会加载 B、A // ClassLoader c2 = Thread.currentThread().getContextClassLoader(); // Class.forName("cn.ali.jvm.test.classload.B", false, c2);

```
    // 1. 首次访问这个类的静态变量或静态方法时
```

// System.out.println(A.a); // 2. 子类初始化，如果父类还没初始化，会引发 // System.out.println(B.c); // 3. 子类访问父类静态变量，只触发父类初始化 // System.out.println(B.a); // 4. 会初始化类 B，并先初始化类 A // Class.forName("cn.ali.jvm.test.classload.B"); }

}

class A { static int a = 0; static { System.out.println("a init"); } } class B extends A { final static double b = 5.0; static boolean c = false; static { System.out.println("b init"); } }`

### 4）练习

![](https://i-blog.csdnimg.cn/direct/78d43908db404b2dad8bd89010fa4a4b.png)

## 五、类加载器（ *xxxde* e）

![](https://i-blog.csdnimg.cn/direct/4cd0e84d42fb4600b21396144f0f7389.png)

从下往上询问，从上往下加载

### 1. **启动类加载器**

用 Bootstrap 类加载器加载类并执行：

`package com.xxxde.jvm.t3.load;

public class F {

static {

System.out.println("bootstrap F init");

}

}`

`package com.xxxde.jvm.t3.load;

public class Load5\_1 {

public static void main(String[] args) throws ClassNotFoundException {

Class<?> aClass = Class.forName("cn.itcast.jvm.t3.load.F");

System.out.println(aClass.getClassLoader());

}

}`

输出

`D:\jvm>java -Xbootclasspath/a:. com.xxxde.jvm.t3.load.Load5

bootstrap F init

null`

解释：

* -Xbootclasspath 表示设置 bootclasspath
* 其中 /a:. 表示将当前目录追加至 bootclasspath 之后
* 可以用这个办法替换核心类

  + java -Xbootclasspath:<new bootclasspath>
  + java -Xbootclasspath/a:<追加路径>
  + java -Xbootclasspath/p:<追加路径>

### **2** **扩展类加载器**

如果 classpath 和 JAVA\_HOME/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。

### 3.双亲委派模式

双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则。

**注意**

这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系

loadClass源码：

`protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先查找该类是否已经被该类加载器加载过了 Class<?> c = findLoadedClass(name); // 如果没有被加载过 if (c == null) { long t0 = System.nanoTime(); try { // 看是否被它的上级加载器加载过了 Extension 的上级是Bootstarp，但它显示为null if (parent != null) { c = parent.loadClass(name, false); } else { // 看是否被启动类加载器加载过 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader //捕获异常，但不做任何处理 }

```
        if (c == null) {
            // 如果还是没有找到，先让拓展类加载器调用 findClass 方法去找到该类，如果还是没找到，就抛出异常
            // 然后让应用类加载器去找 classpath 下找该类
            long t1 = System.nanoTime();
            c = findClass(name);
​
            // 记录时间
            sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
            sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
            sun.misc.PerfCounter.getFindClasses().increment();
        }
    }
    if (resolve) {
        resolveClass(c);
    }
    return c;
}
```

}`

### 4.自定义类加载器

**使用场景**

* 想加载非 classpath 随意路径中的类文件
* 通过接口来使用实现，希望解耦时，常用在框架设计
* 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器

**步骤**

* 继承 ClassLoader 父类
* 要遵从双亲委派机制，重写 ﬁndClass 方法
* 不是重写 loadClass 方法，否则不会走双亲委派机制
* 读取类文件的字节码
* 调用父类的 deﬁneClass 方法来加载类
* 使用者调用该类加载器的 loadClass 方法

**破坏双亲委派模式**

* 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代

  + 建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法
* 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的

  + 如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式
* 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的

  + 这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等

## 六、运行期优化

### 1. **即时编译**

#### 1.1 **分层编译**

示例代码：

`public class JIT1 {

public static void main(String[] args) {

for (int i = 0; i < 200; i++) {

long start = System.nanoTime();

for (int j = 0; j < 1000; j++) {

new Object();

}

long end = System.nanoTime();

System.out.printf("%d\t%d\n",i,(end - start));

}

}

}`

结果是：刚开始是5位数基本上都大于50000，后面慢慢变成以一开头的大概50左右，在130多次时变为三位数

解释：

**JVM 将执行状态分成了 5 个层次：**

* 0 层，解释执行（Interpreter）
* 1 层，使用 C1 即时编译器编译执行（不带 profiling）
* 2 层，使用 C1 即时编译器编译执行（带基本的 profiling）
* 3 层，使用 C1 即时编译器编译执行（带完全的 profiling）
* 4 层，使用 C2 即时编译器编译执行

profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的

回边次数】等

**即时编译器（JIT）与解释器的区别**

* 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
* JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需
* 再编译
* 解释器是将字节码解释为针对所有平台都通用的机器码
* JIT 会根据平台类型，生成平台特定的机器码

总：对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运

行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速

度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由

来），优化之

刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:-

DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果

---

**逃逸分析**
逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术

**逃逸分析的 JVM 参数如下：**

* 开启逃逸分析：-XX:+DoEscapeAnalysis
* 关闭逃逸分析：-XX:-DoEscapeAnalysis
* 显示分析结果：-XX:+PrintEscapeAnalysis
* 逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数

**对象逃逸状态**

**全局逃逸（GlobalEscape）**

* 即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：

  + 对象是一个静态变量
  + 对象是一个已经发生逃逸的对象
  + 对象作为当前方法的返回值

**参数逃逸（ArgEscape）**

* 即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的

**没有逃逸**

* 即方法中的对象没有发生逃逸

**逃逸分析优化**

* 针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化

**锁消除**
我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁 例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作 锁消除的 JVM 参数如下：

* 开启锁消除：-XX:+EliminateLocks
* 关闭锁消除：-XX:-EliminateLocks

锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上

**标量替换**
首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象 对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能 标量替换的 JVM 参数如下：

* 开启标量替换：-XX:+EliminateAllocations
* 关闭标量替换：-XX:-EliminateAllocations
* 显示标量替换详情：-XX:+PrintEliminateAllocations

标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上

**栈上分配**
当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能

#### 1.2方法内联

如果发现某段是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、

粘贴到调用者的位置还能够进行常量折叠（constant folding）的优化。

例如：

![](https://i-blog.csdnimg.cn/direct/162c9e47f15c4dde8a55555650fb99e9.png)

在执行200左右后 时间会为0

#### 1.3 **字段优化**

### 2.反射优化

```
public class Reflect1 {
   public static void foo() {
      System.out.println("foo...");
   }
​
   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
      Method foo = Demo3.class.getMethod("foo");
      for(int i = 0; i<=16; i++) {
         foo.invoke(null);
      }
   }
}
​
```

foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现 invoke 方法源码

```
@CallerSensitive
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException, IllegalArgumentException,
       InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, obj, modifiers);
        }
    }
    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类
    MethodAccessor ma = methodAccessor;             // read volatile
    if (ma == null) {
        ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
}
​
```

![](https://i-blog.csdnimg.cn/direct/e1aea882eb0749718f2dd1a4187befd5.png)

会由 DelegatingMehodAccessorImpl 去调用 NativeMethodAccessorImpl NativeMethodAccessorImpl 源码

```
class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private final Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;
​
    NativeMethodAccessorImpl(Method var1) {
        this.method = var1;
    }
    
    //每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一
    //如果numInvocation>ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法
    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {
        if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {
            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());
            this.parent.setDelegate(var3);
        }
​
        return invoke0(this.method, var1, var2);
    }
​
    void setParent(DelegatingMethodAccessorImpl var1) {
        this.parent = var1;
    }
​
    private static native Object invoke0(Method var0, Object var1, Object[] var2);
}
​
```

```
//ReflectionFactory.inflationThreshold()方法的返回值
private static int inflationThreshold = 15;
​
```

* 一开始if条件不满足，就会调用本地方法 invoke0
* 随着 numInvocation 的增大，当它大于 ReflectionFactory.inflationThreshold 的值 16 时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率

  + 这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()

    ![](https://i-blog.csdnimg.cn/direct/ebefdc8c03d645088b3e06aef405f8fa.png)

工具：
[GitCode - 全球开发者的开源社区,开源代码托管平台](https://gitcode.com/gh_mirrors/ar/arthas?utm_source=highlight_word_gitcode&word=arthas&isLogin=1 "GitCode - 全球开发者的开源社区,开源代码托管平台")