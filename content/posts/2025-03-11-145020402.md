---
layout: post
title: "数据结构2算法及分析"
date: 2025-03-11 12:52:32 +0800
description: "本文旨在为求1+（1+2）+（1+3）+（1+2+4）+（1+3+5）+....+（1+2+...+2n)+（1+3+5+...+2n-1)的和,设计算法，并分别使用自然语言、N-S图，伪代码来表示。分析算法的时间和空间效率, 和评价算法，然后使用java 完成算法的实现。"
keywords: "【数据结构】2算法及分析"
categories: ['二上']
tags: ['数据结构']
artid: "145020402"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145020402
    alt: "数据结构2算法及分析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145020402
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145020402
cover: https://bing.ee123.net/img/rand?artid=145020402
image: https://bing.ee123.net/img/rand?artid=145020402
img: https://bing.ee123.net/img/rand?artid=145020402
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【数据结构】2算法及分析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     0
    </h2>
    <blockquote>
     <h4>
      章节
     </h4>
     <p style="margin-left:.0001pt; text-align:justify">
      １．４到1．５小节。
     </p>
     <p style="margin-left:.0001pt; text-align:justify">
      掌握算法概念、特性、描述、算法性能时间复杂度和空间复杂度；
     </p>
     <p style="margin-left:.0001pt; text-align:justify">
      理解递归含义？
     </p>
     <p style="margin-left:.0001pt; text-align:justify">
      掌握实现递归的条件和时机；
     </p>
     <p style="margin-left:.0001pt; text-align:justify">
      应用简单递归问题的算法设计；
     </p>
     <h4>
      重点
     </h4>
     <p>
      算法概念与特征，算法表示；
     </p>
     <h4>
      难点
     </h4>
     <p style="margin-left:.0001pt; text-align:left">
      算法的分析与算法设计；
     </p>
     <p style="margin-left:.0001pt; text-align:justify">
      递归算法的理解与使用；
     </p>
     <h4>
      作业或思考题
     </h4>
     <p>
      作业2：算法设计与表达
     </p>
     <p>
      内容达成以下标准(考核点)：
     </p>
     <p style="margin-left:.0001pt; text-align:left">
      理解与陈述算法概念；
     </p>
     <p style="margin-left:.0001pt; text-align:left">
      理解并设计与表达算法：设计算法，使用工具表达，分析算法
     </p>
    </blockquote>
    <h2 style="margin-left:0.0001pt; margin-right:0px; text-align:center">
     <strong>
      <strong>
       算法设计与实现作业
      </strong>
     </strong>
    </h2>
    <p style="text-align:left">
     <strong>
      摘要:
     </strong>
     本文旨在为求1+（1+2）+（1+3）+（1+2+4）+（1+3+5）+....+（1+2+...+2n)+（1+3+5+...+2n-1)的和,设计算法，并分别使用自然语言、N-S图，伪代码来表示。分析算法的时间和空间效率, 和评价算法，然后使用java 完成算法的实现。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <strong>
      关键词：
     </strong>
     算法设计；评价；Java实现；
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <p style="text-align:left">
     <strong>
      <strong>
       <strong>
        abstract
       </strong>
      </strong>
     </strong>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     The purpose of this article is to design an algorithm to calculate the sum of the series 1 + (1+2) + (1+3) + (1+2+4) + (1+3+5) + ... + (1+2+...+2n) + (1+3+5+...+2n-1). The algorithm will be represented using natural language, an N-S diagram, and pseudo code. The time and space efficiency of the algorithm will be analyzed, and the algorithm will be evaluated. Finally, the algorithm will be implemented in Java.
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <strong>
      <strong>
       Keywords:
      </strong>
     </strong>
     Algorithm Design; Evaluation; Java Implementation
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h2 style="text-align:justify">
     <strong>
      <strong>
       <strong>
        1 实现方法一
       </strong>
      </strong>
     </strong>
    </h2>
    <h3 style="text-align:justify">
     <strong>
      <strong>
       <strong>
        1.1
       </strong>
      </strong>
      <strong>
       <strong>
        算法表示
       </strong>
      </strong>
     </strong>
    </h3>
    <h4 style="text-align:justify">
     <strong>
      1.1.1自然语言表示
     </strong>
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     1．创建一个变量sum并将其初始化为0，用于保存总和。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     2．使用for循环从1迭代到n，迭代变量i表示当前迭代的数字。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     3．在每次迭代开始时，创建两个临时变量s1和s2，分别用于保存奇数项和偶数项的和，并将它们初始化为0。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     4．判断i是否大于1，如果是，则计算s1的值为(i-1) * (i-1) + i，表示从1到2n-1的所有奇数的和，如果不是，则s1保持为0。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     5．计算s2的值为i * i，表示从1到2n的所有偶数的和。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     6．将s1和s2分别累加到总和sum中。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     7．循环结束后，返回总和sum作为最终结果。
    </p>
    <h4 style="margin-left:.0001pt; margin-right:0; text-align:left">
     1.1.2 N-S图表示
    </h4>
    <p>
     <img alt="" height="555" src="https://i-blog.csdnimg.cn/direct/7475fa89f2fb47c5be37333e769bc8e3.png" width="326"/>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h4 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     1.1.3伪代码表示
    </h4>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      输入：n
     </p>
     <p style="margin-left:0.0001pt; margin-right:0px">
      输出：sum // 1+（1+2）+（1+3）+（1+2+4）+（1+3+5）+....+（1+2+...+2n)+（1+3+5+...+2n-1)的和
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      function calculateSum(n):
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      sum = 0
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      for i from 1 to n:
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s1 = 0
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s2 = 0
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      if i &gt; 1:
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s1 = (i-1)^2 + i
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s2 = i^2
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      sum += s1 + s2
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      return sum
     </p>
    </blockquote>
    <h3 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     <strong>
      <strong>
       <strong>
        1.2
       </strong>
      </strong>
      <strong>
       <strong>
        算法分析
       </strong>
      </strong>
     </strong>
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     时间复杂度分析：外层循环迭代n次，所以时间复杂度为O(n)。内部计算s1和s2的操作是常数时间的，不会随输入规模变化，因此对时间复杂度没有影响。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     空间复杂度分析：算法使用了常数个变量来保存中间结果，所以空间复杂度为O(1)，即为常数级别。不会随输入规模变化。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h3 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     <strong>
      <strong>
       1.3
      </strong>
     </strong>
     <strong>
      <strong>
       算法实现
      </strong>
     </strong>
    </h3>
    <pre><code class="language-java">public class Algorithm {
   public static int calculateSum(int n) {
       int sum = 0;
       for (int i = 1; i &lt;= n; i++) {
           int s1 = 0;
           int s2 = 0;
           if (i &gt; 1){
               s1 = (i-1) * (i-1)  + i;//单独的和, 偶数项
           }
           s2 = i * i;//单独的和, 奇数项
           sum += s1 + s2;
       }
       return sum;
   }
   public static void main(String[] args) {
       int n = 4;
       int result = calculateSum(n);
       System.out.println("当n=" + n + "时，sum=" + result);
   }
}</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h4 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     <strong>
      <strong>
       1.4
      </strong>
     </strong>
     <strong>
      <strong>
       算法总结
      </strong>
     </strong>
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     该算法是一个简单直观的解决方案，它通过循环迭代计算每一项的和，并将其累加到总和中。由于只有一个循环，算法的时间复杂度是线性的，具有较好的效率。同时，算法的空间复杂度也是常数级别的，节省了内存的使用。总体而言，这个算法是一个有效且可行的解决方案。
    </p>
    <h2 style="text-align:left">
    </h2>
    <h2 style="text-align:justify">
     <strong>
      <strong>
       <strong>
        2实现方法二
       </strong>
      </strong>
     </strong>
    </h2>
    <h3 style="text-align:justify">
     <strong>
      <strong>
       <strong>
        2.1
       </strong>
      </strong>
      <strong>
       <strong>
        算法表示
       </strong>
      </strong>
     </strong>
    </h3>
    <h4 style="margin-left:.0001pt; margin-right:0; text-align:left">
     2.1.1自然语言表示
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     1．初始化两个数组s1和s2，长度为n。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     2．对于从1到n的每个数i：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     如果i大于1，计算s1[i-1]的值为 (i-1) * (i-1) + i。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     计算s2[i-1]的值为 i * i。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     3．定义变量sum并初始化为0。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     4．对于数组s1和s2的每个索引i：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     将s1[i]和s2[i]的值累加到sum上。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     5．返回sum作为结果。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h4 style="margin-left:.0001pt; margin-right:0; text-align:left">
     2.1.2N-S图表示
    </h4>
    <p>
     <img alt="" height="555" src="https://i-blog.csdnimg.cn/direct/999d59bad1dd43b69f4d880bd7e0096f.png" width="307"/>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h4 style="margin-left:.0001pt; margin-right:0; text-align:left">
     2.1.3伪代码表示
    </h4>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      输入：n
     </p>
     <p style="margin-left:0.0001pt; margin-right:0px">
      输出：sum // 1+（1+2）+（1+3）+（1+2+4）+（1+3+5）+....+（1+2+...+2n)+（1+3+5+...+2n-1)的和
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      function calculateSum(n):
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s1 = new int[n]
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s2 = new int[n]
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      for i = 1 to n:
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      if i &gt; 1:
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s1[i-1] = (i-1) * (i-1) + i
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      s2[i-1] = i * i
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      sum = 0
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      for i = 0 to n-1:
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      sum += s1[i]
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      sum += s2[i]
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      return sum
     </p>
    </blockquote>
    <h3 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     <strong>
      <strong>
       <strong>
        2.2
       </strong>
      </strong>
      <strong>
       <strong>
        算法分析
       </strong>
      </strong>
     </strong>
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     时间复杂度分析：该算法的时间复杂度为O(n)，其中n是输入的参数。因为算法包含两个for循环，两个循环的迭代次数都是n。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     空间复杂度分析：该算法的空间复杂度为O(n)，其中n是输入的参数。因为算法使用了两个长度为n的数组s1和s2来存储中间结果。此外，还有几个整型变量用于计算和累加过程，它们的空间占用可以忽略不计。
    </p>
    <h3 style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     <strong>
      <strong>
       <strong>
        2.3
       </strong>
      </strong>
      <strong>
       <strong>
        算法实现
       </strong>
      </strong>
     </strong>
    </h3>
    <pre><code class="language-java">public class Algorithm {
   public static int calculateSum(int n) {
       int[] s1 = new int[n];
       int[] s2 = new int[n];
       for (int i = 1; i &lt;= n; i++) {
           if (i &gt; 1){
               s1[i-1] = (i-1) * (i-1) + i; // 计算s1的值
           }
           s2[i-1] = i * i; // 计算s2的值
       }
       int sum = 0;
       for (int i = 0; i &lt; n; i++) {
           sum += s1[i] + s2[i]; // 累加s1和s2的值
       }
       return sum;
   }
   public static void main(String[] args) {
       int n = 4;
       int result = calculateSum(n);
       System.out.println("当n=" + n + "时，sum=" + result);
   }
}</code></pre>
    <h3>
     <strong>
      <strong>
       <strong>
        2.4
       </strong>
      </strong>
      <strong>
       <strong>
        算法总结
       </strong>
      </strong>
     </strong>
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     算法优点： 这个算法有效地解决了问题，具有线性时间复杂度，适用于大多数输入规模。它的实现相对简单，易于理解。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     算法缺点： 该算法使用了额外的空间来存储两个数组s1和s2，这可能会在输入规模很大的情况下导致内存消耗较大。如果对空间效率有更高的要求，可以考虑在计算过程中动态生成s1和s2的值而不存储它们。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     总的来说，这个算法是一个有效的解决方案，适用于大多数情况，但在某些特定情况下，可能需要优化空间复杂度。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h2 style="text-align:left">
     <strong>
      <strong>
       <strong>
        总结性分析:
       </strong>
      </strong>
     </strong>
    </h2>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     第二个算法的优点在于将括号内部的和分别存放在两个数组中，方便计算和累加。但是它的缺点在于需要占用较多的空间，且计算s1的时候会产生一定的重复计算。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     而第一个算法则没有使用数组，而是在每次循环的过程中直接计算出s1和s2并进行累加，避免了数组带来的空间占用和计算重复的问题。但是其缺点在于代码可读性不如第一个算法。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h2 style="text-align:left">
     <strong>
      <strong>
       <strong>
        参考文献
       </strong>
      </strong>
     </strong>
    </h2>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     [1] 王红梅, 党源源, 刘冰. 数据结构--从概念到Java实现[M]. 清华大学出版社, 2019.
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333937323936322f:61727469636c652f64657461696c732f313435303230343032" class_="artid" style="display:none">
 </p>
</div>


