---
layout: post
title: "java-8新特性Lambda表达式,以及其和匿名内部类的比较"
date: 2025-03-07 13:06:47 +0800
description: "Lambda 表达式的核心是上下文推断，它根据你使用 Lambda 的场景（比如传递给Thread的构造函数）自动推断出你希望实现哪个接口的方法。虽然 Lambda 表达式看起来很简洁，但它实际上遵循了接口类型的约定，自动识别并实现了接口的抽象方法。你不需要显式地写出方法签名，Lambda 会根据目标类型和上下文自动匹配接口方法。"
keywords: "java 8新特性——Lambda表达式，以及其和匿名内部类的比较"
categories: ['未分类']
tags: ['开发语言', '前端', 'Java']
artid: "146089568"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146089568
    alt: "java-8新特性Lambda表达式,以及其和匿名内部类的比较"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146089568
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146089568
cover: https://bing.ee123.net/img/rand?artid=146089568
image: https://bing.ee123.net/img/rand?artid=146089568
img: https://bing.ee123.net/img/rand?artid=146089568
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java 8新特性——Lambda表达式，以及其和匿名内部类的比较
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.Lambda表达式
    </h2>
    <p>
     Lambda 表达式是 Java 8 最具革命性的新特性之一，它允许你用
     <strong>
      更简洁的方式表示函数式接口
     </strong>
     （Functional Interface）。通过
     <strong>
      Lambda 表达式，我们可以避免冗长的匿名内部类代码
     </strong>
     ，使代码更加简洁。
    </p>
    <p>
     Lambda表达式基本语法：
    </p>
    <pre><code class="language-java">(parameters) -&gt; expression
or
(parameters) -&gt; { statements; }
</code></pre>
    <pre><code class="language-java">List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
//name -&gt; System.out.println(name) 是一个 Lambda 表达式，用来替代传统的匿名内部类。
names.forEach(name -&gt; System.out.println(name));
</code></pre>
    <ol>
     <li>
      <p>
       paramaters：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断。另外
       <strong>
        当只有一个推断类型时可以省略掉圆括号。
       </strong>
      </p>
     </li>
     <li>
      <p>
       -&gt;：可理解为“被用于”的意思
      </p>
     </li>
     <li>
      <p>
       方法体：可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不返回，这里的代码块块等同于方法的方法体。表达式也是一样，可以返回值或者不返回。
      </p>
     </li>
    </ol>
    <h2>
     2. 匿名内部类
    </h2>
    <p>
     匿名内部类是一种没有名称的类，通常用于实现接口或继承类。它可以在代码中定义并实例化，同时可以访问外部类的成员变量。
    </p>
    <p>
     匿名类基本语法如下：
    </p>
    <pre><code class="language-java">new InterfaceName() {
    // 实现接口方法
    @Override
    public void method() {
        // 实现内容
    }
};
</code></pre>
    <h2>
     <strong>
      3. 两者之间的关系
     </strong>
    </h2>
    <p>
     通过线程代码举例：使用Runnable接口实现
    </p>
    <pre><code class="language-java">public class MyClass {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread is running...");
            }
        });
        thread.start();
    }
}
</code></pre>
    <p>
     在该例子中，Runnable的实现就是通过匿名内部类的方式。
    </p>
    <p>
     使用Lambda表达式：
    </p>
    <pre><code class="language-java">public class MyClass {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&gt; System.out.println("Thread is running..."));
        thread.start();
    }
}
</code></pre>
    <p>
     我们能够看到这个代码的实现十分简洁，但是有一个疑问——
     <strong>
      为什么这个Lambda表达式甚至连需要的类是哪一个，要实现的方法是哪一个都没有声明，就直接能够实现和匿名内部类等效的效果
     </strong>
     ？
    </p>
    <p>
     答案就在Lambda 表达式的推断和省略。
    </p>
    <p>
     <strong>
      3.1接口的类型推断
     </strong>
    </p>
    <p>
     在调用Tread构造函数的时候，他接受的是一个Runnable类型的对象：
    </p>
    <p>
     <img alt="" height="225" src="https://i-blog.csdnimg.cn/direct/2d15c45f27c54f08bf43e01b42f5abac.png" width="1021"/>
    </p>
    <p>
     因此，编译器知道我们传入的是一个Runnable类型的实例，并自动推断出 Lambda 表达式实现了Runnable接口的run方法。
    </p>
    <p>
     <strong>
      3.2 run方法的推断
     </strong>
    </p>
    <p>
     Runnable接口只有一个抽象方法run()，Lambda 表达式
     <code>
      () -&gt; System.out.println("Thread is running...")
     </code>
     自动映射为对
     <code>
      run
     </code>
     方法的实现。换句话说，Lambda 表达式的
     <code>
      ()
     </code>
     表示
     <code>
      run
     </code>
     方法的参数（没有参数），而
     <code>
      System.out.println("Thread is running...")
     </code>
     则是
     <code>
      run()
     </code>
     方法的实现体。
    </p>
    <h3>
     省略的内容
    </h3>
    <ul>
     <li>
      <strong>
       方法签名
      </strong>
      ：Lambda 表达式省略了方法签名。在传统的匿名内部类中，你需要显式地实现接口的
      <code>
       run
      </code>
      方法，而在 Lambda 表达式中
      <strong>
       ，编译器会根据接口类型推断出方法签名
      </strong>
      。
     </li>
    </ul>
    <p>
     例如，匿名内部类的形式是：
    </p>
    <pre><code class="language-java">new Runnable() {
    @Override
    public void run() {
        System.out.println("Thread is running...");
    }
}
</code></pre>
    <p>
     在这里，
     <code>
      Runnable
     </code>
     接口的
     <code>
      run
     </code>
     方法需要明确被覆写，而 Lambda 表达式则通过上下文推断来完成这一步。
    </p>
    <ul>
     <li>
      <strong>
       类声明
      </strong>
      ：Lambda 表达式省略了内部类的声明部分。匿名内部类需要显式地使用
      <code>
       new Runnable()
      </code>
      来创建一个对象，并通过
      <code>
       @Override
      </code>
      明确地实现
      <code>
       run
      </code>
      方法。而 Lambda 通过简洁的语法直接表示了这个函数式接口的实现。
     </li>
    </ul>
    <h3 style="background-color:transparent">
     <strong>
      如何知道 Lambda 表达式实现了
      <code>
       Runnable
      </code>
      的
      <code>
       run
      </code>
      方法？
     </strong>
    </h3>
    <p>
     实际上，Lambda 表达式并不需要明确声明自己实现了哪个接口。编译器根据上下文的类型推断，知道传递给
     <code>
      Thread
     </code>
     构造器的 Lambda 表达式应该对应
     <code>
      Runnable
     </code>
     接口。编译器会将 Lambda 表达式转换成一个
     <code>
      Runnable
     </code>
     类型的对象，它自动调用
     <code>
      Runnable
     </code>
     接口的
     <code>
      run
     </code>
     方法。
    </p>
    <ul>
     <li>
      <p>
       如果你将 Lambda 表达式赋值给一个变量，编译器也会通过目标类型推断来确定应该实现哪个方法。
      </p>
      <p>
       例如：
      </p>
     </li>
    </ul>
    <pre><code class="language-java">Runnable task = () -&gt; System.out.println("Thread is running...");
task.run();  // 调用 run 方法
</code></pre>
    <p>
     这里，Lambda 表达式会被视为
     <code>
      Runnable
     </code>
     接口的一个实现，因此它的
     <code>
      run
     </code>
     方法会被调用。
    </p>
    <h2>
     4. Lambda表达式的返回值
    </h2>
    <p>
     在 Lambda 表达式中，
     <code>
      expression
     </code>
     或
     <code>
      statements
     </code>
     是否有返回值，取决于你所实现的接口方法的返回类型。Lambda 表达式的返回类型是由接口的方法签名（即该方法的返回类型）决定的。
    </p>
    <h3>
     4.1.
     <strong>
      无返回值的 Lambda 表达式（函数式接口的
      <code>
       void
      </code>
      方法）
     </strong>
    </h3>
    <pre><code class="language-java">//names是一个String类型的List
names.forEach(name -&gt; System.out.println(name));

//等价于
names.forEach(new Consumer&lt;String&gt;() {
    @Override
    public void accept(String name) {
        System.out.println(name);
    }
});
</code></pre>
    <ul>
     <li>
      <code>
       names.forEach(...)
      </code>
      ：
      <code>
       forEach
      </code>
      是
      <code>
       Iterable
      </code>
      接口中的一个默认方法，它接受一个
      <code>
       Consumer
      </code>
      类型的参数。
      <code>
       Consumer
      </code>
      是一个函数式接口，它有一个抽象方法
      <code>
       accept(T t)
      </code>
      ，用于对传入的参数执行某个操作。
     </li>
     <li>
      <code>
       name -&gt; System.out.println(name)
      </code>
      ：这是 Lambda 表达式，它表示了
      <code>
       Consumer.accept
      </code>
      方法的实现。对于每个元素
      <code>
       name
      </code>
      ，执行
      <code>
       System.out.println(name)
      </code>
      。
     </li>
    </ul>
    <p>
     这里
     <code>
      ，Consumer.accept()
     </code>
     方法的返回类型是
     <code>
      void
     </code>
     ，所以 Lambda 表达式中的
     <code>
      System.out.println(name)
     </code>
     语句没有返回值，直接执行操作。
    </p>
    <h3>
     4.2.
     <strong>
      有返回值的 Lambda 表达式（函数式接口的返回类型不是
      <code>
       void
      </code>
      ）
     </strong>
    </h3>
    <p>
     如果接口的方法返回一个具体的值，那么 Lambda 表达式中必须使用
     <code>
      return
     </code>
     语句来返回一个值，且返回类型必须和接口方法的返回类型匹配。
    </p>
    <p>
     <strong>
      示例：
     </strong>
     假设我们有一个函数式接口
     <code>
      Function
     </code>
     ，它的
     <code>
      apply
     </code>
     方法有返回值：
    </p>
    <pre><code class="language-java">@FunctionalInterface
public interface Function&lt;T, R&gt; {
    R apply(T t);
}
</code></pre>
    <p>
     我们可以通过 Lambda 表达式实现
     <code>
      apply
     </code>
     方法并返回一个值：
    </p>
    <pre><code class="language-java">Function&lt;Integer, String&gt; convert = num -&gt; "Number is " + num;
System.out.println(convert.apply(5));  // 输出 "Number is 5"
</code></pre>
    <p>
     在这个例子中，
     <code>
      Function.apply()
     </code>
     方法的返回类型是
     <code>
      String
     </code>
     ，因此 Lambda 表达式中
     <code>
      num -&gt; "Number is " + num
     </code>
     必须返回一个
     <code>
      String
     </code>
     类型的值。
    </p>
    <p>
     <strong>
      等价的匿名内部类
     </strong>
    </p>
    <pre><code class="language-java">Function&lt;Integer, String&gt; convert = new Function&lt;Integer, String&gt;() {
    @Override
    public String apply(Integer num) {
        return "Number is " + num;
    }
};
</code></pre>
    <p>
     总而言之：
    </p>
    <ul>
     <li>
      <strong>
       没有返回值的 Lambda 表达式
      </strong>
      ：适用于那些方法返回类型是
      <code>
       void
      </code>
      的接口，例如
      <code>
       Consumer
      </code>
      接口。
     </li>
     <li>
      <strong>
       有返回值的 Lambda 表达式
      </strong>
      ：适用于那些方法返回类型不是
      <code>
       void
      </code>
      的接口，例如
      <code>
       Function
      </code>
      接口。在这种情况下，Lambda 表达式需要返回一个值，且返回类型必须与接口方法的签名一致。
     </li>
     <li>
      <strong>
       单一表达式
      </strong>
      ：如果 Lambda 表达式仅包含一个表达式（没有大括号{}），则该表达式的结果会自动作为返回值。
     </li>
     <li>
      <strong>
       多语句的 Lambda 表达式
      </strong>
      ：如果 Lambda 表达式包含多行语句(使用到{})，需要使用
      <code>
       return
      </code>
      语句显式返回结果。
     </li>
    </ul>
    <p>
     expression（表达式）与statement（语句）的区别：
    </p>
    <p>
     前者是能够返回一个值（或者说是计算出一个结果），后者是执行某种操作或控制流程的代码。有时表达式可以作为语句的一部分，构成更大的代码块。
    </p>
    <pre><code class="language-java">int result = 5 + 3; // 这是一个语句，但包含了表达式 5 + 3。
</code></pre>
    <h2>
     5.总结
    </h2>
    <p>
     Lambda 表达式的核心是
     <strong>
      上下文推断
     </strong>
     ，它根据你使用 Lambda 的场景（比如传递给
     <code>
      Thread
     </code>
     的构造函数）自动推断出你希望实现哪个接口的方法。虽然 Lambda 表达式看起来很简洁，但它实际上遵循了接口类型的约定，自动识别并实现了接口的抽象方法。你不需要显式地写出方法签名，Lambda 会根据目标类型和上下文自动匹配接口方法。
    </p>
    <h2>
     参考
    </h2>
    <p>
     <a href="https://blog.csdn.net/LHY537200/article/details/136889277" title="https://blog.csdn.net/LHY537200/article/details/136889277">
      https://blog.csdn.net/LHY537200/article/details/136889277
     </a>
    </p>
    <p>
     ......
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34363237343931312f:61727469636c652f64657461696c732f313436303839353638" class_="artid" style="display:none">
 </p>
</div>


