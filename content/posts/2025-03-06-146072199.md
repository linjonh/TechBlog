---
layout: post
title: "Java数据结构前K个高频单词"
date: 2025-03-06 23:50:00 +0800
description: "前K个高频单词"
keywords: "【Java数据结构】前K个高频单词"
categories: ['未分类']
tags: ['算法', '数据结构', 'Java']
artid: "146072199"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146072199
    alt: "Java数据结构前K个高频单词"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146072199
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146072199
cover: https://bing.ee123.net/img/rand?artid=146072199
image: https://bing.ee123.net/img/rand?artid=146072199
img: https://bing.ee123.net/img/rand?artid=146072199
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Java数据结构】前K个高频单词
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     前K个高频单词
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/top-k-frequent-words/description/" rel="nofollow" title="692. 前K个高频单词 - 力扣（LeetCode）">
      692. 前K个高频单词 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     <img alt="" height="842" src="https://i-blog.csdnimg.cn/direct/fed3054efa1746eeb6f8367045711b01.png" width="1644"/>
    </p>
    <blockquote>
     <p>
      解决这个问题我们先得知道每个单词出现的次数，用map存储下来，然后将出现次数最多的通过建立小根堆解决top-K问题 ，重点是top-K的求取。
     </p>
    </blockquote>
    <h4>
     1.建立map
    </h4>
    <p>
     首先我们可以先将这些单词的出现次数都通过map中的key和value记录下来。第一步先创建一个map
    </p>
    <pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</code></pre>
    <h4>
     2.将单词以及单词出现的次数存储到map中
    </h4>
    <p>
     在这里需要注意第一次出现的单词，第一次出现的单词没有对应的value值就会返回一个空指针null，往后再出现就直接在value中加1即可。
    </p>
    <pre><code>       for (String word : words){
            //为什么不直接在map的基础上加1呢？原因在于第一次记录某一个单词时get(word)会返回null（Integer类型的默认值就是null），如果为空就不能进行加1的操作并且报空指针异常
            //map.put(word, map.get(word)+1);

            //方法1，可以通过map中getOrDefault方法设置它的第一次出现
            //map.put(word, map.getOrDefault(word,0)+1);

            //方法2，通过if-else，当出现为空时，那就更新value值；不为空时就加1
            if (map.get(word) == null){//如果这个单词在之前遍历时没有出现过，那就
                map.put(word, 1);
            }else{
                map.put(word, map.get(word)+1);
            }
        }</code></pre>
    <h4>
     3.建立小根堆
    </h4>
    <p>
     要得到单词次数最多的前K个，就需要建立小根堆（在之前的优先级对列中已经讲过），会用到PriorityQueue。 建立小根堆需要上传一个比较器，这个比较器是将
    </p>
    <pre><code class="hljs">    //建立小根堆
    PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
        @Override
        public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
            return o1.getValue() - o2.getValue();
        }
    });</code></pre>
    <h4>
     4.遍历map，依次加入堆中
    </h4>
    <p>
     现在我们想想，要将单词加入堆中，可能会出现k大于words中所有单词的个数，这样就可以直接把所有单词都加入堆中；
    </p>
    <pre><code class="hljs">if (minHeap.size() &lt; k){
    minHeap.offer(entry);
}</code></pre>
    <p>
     剩下一种可能就是k&lt;=words.length()，对于这个情况来说每次加入一个单词都需要进行比较，比较的情况也很多种。下面仔细的讲一下如果比较，首先我们需要知道在这个堆中的堆顶元素top，当
     <strong>
      加入的单词频率与top相同
     </strong>
     时，需要把top出队，然后让字母小的进来；还有就是可能会
     <strong>
      出现频率比top的大
     </strong>
     的情况，这种情况也需要先出队然后再进队。
    </p>
    <pre><code class="hljs">        else{
        Map.Entry&lt;String, Integer&gt; top = minHeap.peek();
        //频率相同时，也就是出现次数相同时
         if (top.getValue().compareTo(entry.getValue()) == 0){
             //字母小的先进来
             if(top.getKey().compareTo(entry.getKey()) &gt; 0){
                //top的单词比进来的要大，所以top要出队,entry要进队
                 minHeap.poll();
                 minHeap.offer(entry);
             }
         }else{
             //
             if(top.getValue().compareTo(entry.getValue())&lt;0){
                 minHeap.poll();
                 minHeap.offer(entry);
             }
         }</code></pre>
    <h4>
     5.依次讲堆中的单词放进List&lt;String&gt;类型中
    </h4>
    <p>
     List&lt;String&gt;类型，所以我们需要创建一个ArrayList类型的集合用于存放堆中单词，但是题目需要的是从大到小的单词频率，从堆中拿出来的是从小到大的，所以最后还需要逆序一遍顺序表。
    </p>
    <pre><code class="hljs">    List&lt;String&gt; ret = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; k; i++){
        Map.Entry&lt;String, Integer&gt; top = minHeap.poll();
        ret.add(top.getKey());
    }
    Collections.reverse(ret);
    return ret;</code></pre>
    <h4>
     6.改进比较器
    </h4>
    <p>
     如果把以上全部代码放到在线OJ题中，会发现总有一个结过时不通过的。那为什么呢？主要在于如果k&gt;所有单词的个数，那么在堆中就没有相同频率的比较，所以我们还需要在比较器中添加频率相同时需要建立一个大根堆。
    </p>
    <pre><code class="hljs">    PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
        @Override
        public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
            //当字母频率相同时，按照字母建立大根堆
            if (o1.getValue().compareTo(o2.getValue()) == 0){
                return o2.getKey().compareTo(o1.getKey());
            }
            return o1.getValue() - o2.getValue();
        }
    });</code></pre>
    <p>
     以下是全部代码，大家可以参考一下哦~
    </p>
    <pre><code class="hljs">public static List&lt;String&gt; topKFrequent(String[] words, int k) {//
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for (String word : words){
            //为什么不直接在map的基础上加1呢？原因在于第一次记录某一个单词时get(word)会返回null（Integer类型的默认值就是null），
            //如果为空就不能进行加1的操作并且报空指针异常
            //map.put(word, map.get(word)+1);

            //方法1，可以通过map中getOrDefault方法设置它的第一次出现
            //map.put(word, map.getOrDefault(word,0)+1);

            //方法2，通过if-else，当出现为空时，那就更新value值；不为空时就加1
            if (map.get(word) == null){//如果这个单词在之前遍历时没有出现过，那就
                map.put(word, 1);
            }else{
                map.put(word, map.get(word)+1);
            }
        }
    //建立小根堆
    PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
        @Override
        public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
            //当字母频率相同时，按照字母建立大根堆
            if (o1.getValue().compareTo(o2.getValue()) == 0){
                return o2.getKey().compareTo(o1.getKey());
            }
            return o1.getValue() - o2.getValue();
        }
    });
        //遍历map，调整优先级队列
        for(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()){
            if (minHeap.size() &lt; k){
                minHeap.offer(entry);
        }
        else{
        Map.Entry&lt;String, Integer&gt; top = minHeap.peek();
        //频率相同时，也就是出现次数相同时
         if (top.getValue().compareTo(entry.getValue()) == 0){
             //字母小的先进来
             if(top.getKey().compareTo(entry.getKey()) &gt; 0){
                //top的单词比进来的要大，所以top要出队,entry要进队
                 minHeap.poll();
                 minHeap.offer(entry);
             }
         }else{
             //
             if(top.getValue().compareTo(entry.getValue())&lt;0){
                 minHeap.poll();
                 minHeap.offer(entry);
             }
         }
        }
        }

    List&lt;String&gt; ret = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; k; i++){
        Map.Entry&lt;String, Integer&gt; top = minHeap.poll();
        ret.add(top.getKey());
    }
    Collections.reverse(ret);
    return ret;
    }</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38343831353231382f:61727469636c652f64657461696c732f313436303732313939" class_="artid" style="display:none">
 </p>
</div>


