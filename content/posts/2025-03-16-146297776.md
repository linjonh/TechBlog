---
layout: post
title: "单例模式Singleton-Pattern详解确保类的唯一性"
date: 2025-03-16 17:08:38 +0800
description: "单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点来访问该实例。确保类只有一个实例。提供一个全局访问点，允许任何地方访问该唯一实例。"
keywords: "单例模式（Singleton Pattern）详解：确保类的唯一性"
categories: ['未分类']
tags: ['单例模式']
artid: "146297776"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146297776
    alt: "单例模式Singleton-Pattern详解确保类的唯一性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146297776
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146297776
cover: https://bing.ee123.net/img/rand?artid=146297776
image: https://bing.ee123.net/img/rand?artid=146297776
img: https://bing.ee123.net/img/rand?artid=146297776
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     单例模式（Singleton Pattern）详解：确保类的唯一性
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="Singleton_Pattern_1">
     </a>
     单例模式（Singleton Pattern）详解：确保类的唯一性
    </h2>
    <p>
     在软件设计中，
     <strong>
      单例模式
     </strong>
     （Singleton Pattern）是一种常见的设计模式，用于确保某个类只有一个实例，并提供一个全局访问点。这种设计模式尤其适用于一些全局共享的资源，比如配置管理器、日志管理器、数据库连接等，它能确保系统中只存在一个实例，避免了不必要的资源浪费或复杂的对象管理。
    </p>
    <p>
     在本文中，我们将详细讲解单例模式的定义、应用场景、实现方式，并通过实例代码进行演示，帮助你深入理解这个设计模式。
    </p>
    <h3>
     <a id="1__7">
     </a>
     1. 单例模式的定义
    </h3>
    <p>
     单例模式是一种
     <strong>
      创建型设计模式
     </strong>
     ，它保证一个类只有一个实例，并提供一个全局访问点来访问该实例。
    </p>
    <p>
     简单来说，单例模式的目标是：
    </p>
    <ul>
     <li>
      确保类只有一个实例。
     </li>
     <li>
      提供一个全局访问点，允许任何地方访问该唯一实例。
     </li>
    </ul>
    <h4>
     <a id="_15">
     </a>
     单例模式的核心思想
    </h4>
    <ul>
     <li>
      <strong>
       私有化构造函数
      </strong>
      ：将类的构造函数私有化，防止外部直接通过构造函数创建多个实例。
     </li>
     <li>
      <strong>
       静态实例
      </strong>
      ：类内部维护一个静态的实例，并提供一个公共的静态方法来访问这个实例。
     </li>
     <li>
      <strong>
       延迟实例化
      </strong>
      ：通常情况下，单例实例是在第一次调用时才被创建，避免了不必要的资源浪费。
     </li>
    </ul>
    <h3>
     <a id="2__20">
     </a>
     2. 单例模式的应用场景
    </h3>
    <p>
     单例模式通常适用于以下场景：
    </p>
    <ul>
     <li>
      <strong>
       全局配置管理
      </strong>
      ：程序中可能有多个地方需要访问相同的配置信息，使用单例模式可以确保只有一个配置实例。
     </li>
     <li>
      <strong>
       日志管理
      </strong>
      ：多个模块可能需要记录日志，日志系统通常是共享的，因此适合使用单例模式来确保日志系统只有一个实例。
     </li>
     <li>
      <strong>
       数据库连接
      </strong>
      ：对于数据库连接池或数据库连接类，使用单例模式可以确保整个应用程序只有一个数据库连接实例，避免重复创建连接。
     </li>
     <li>
      <strong>
       缓存管理
      </strong>
      ：在许多应用中，缓存是一项全局共享的资源，使用单例模式可以保证缓存数据的唯一性。
     </li>
    </ul>
    <h3>
     <a id="3__28">
     </a>
     3. 单例模式的实现方式
    </h3>
    <h4>
     <a id="31__30">
     </a>
     3.1. 基本的单例模式实现
    </h4>
    <p>
     最简单的单例模式实现方法是使用静态成员变量来保存实例。每次访问单例实例时，我们会检查实例是否已经创建，如果没有创建，就初始化一个新的实例。
    </p>
    <h5>
     <a id="_34">
     </a>
     示例代码：
    </h5>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 获取单例实例的静态方法</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果实例还没有被创建，就创建一个</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance_ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
            instance_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> instance_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from Singleton!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">// 私有构造函数，禁止外部直接创建实例</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">// 静态指针保存唯一实例</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> instance_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化静态成员变量</span>
Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>instance_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取单例实例，并调用方法</span>
    <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      解释
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        instance()
       </code>
       方法
      </strong>
      ：第一次访问时会创建
      <code>
       Singleton
      </code>
      的实例。之后每次访问
      <code>
       instance()
      </code>
      方法，都会返回相同的实例。
     </li>
     <li>
      <strong>
       线程不安全问题
      </strong>
      ：在多线程环境下，如果两个线程同时调用
      <code>
       instance()
      </code>
      ，可能会创建两个
      <code>
       Singleton
      </code>
      实例。为了确保线程安全，需要使用互斥锁（
      <code>
       std::mutex
      </code>
      ）来同步。
     </li>
    </ul>
    <h5>
     <a id="_73">
     </a>
     示例代码：懒汉模式（线程安全）
    </h5>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 获取单例实例的静态方法</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance_ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            instance_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from Singleton!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 私有构造函数，防止外部直接创建实例</span>

    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> instance_<span class="token punctuation">;</span>  <span class="token comment">// 静态成员变量保存实例</span>
    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">// 互斥锁，确保线程安全</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化静态成员变量</span>
Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>instance_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex Singleton<span class="token double-colon punctuation">::</span>mutex_<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问单例</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      解释
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        std::mutex
       </code>
      </strong>
      ：通过在
      <code>
       instance()
      </code>
      方法中添加
      <code>
       std::lock_guard&lt;std::mutex&gt;
      </code>
      ，我们确保每次访问单例实例时，只有一个线程可以执行实例化操作，从而避免了线程不安全的问题。
     </li>
    </ul>
    <h4>
     <a id="32_Eager_Initialization_114">
     </a>
     3.2. 饿汉模式（Eager Initialization）
    </h4>
    <p>
     <strong>
      饿汉模式
     </strong>
     的特点是：在程序启动时就会创建单例类的实例，通常是通过静态成员变量来实现。这种方式也叫做
     <strong>
      立即加载
     </strong>
     ，即在程序启动时就创建实例，不管是否需要使用。
    </p>
    <h5>
     <a id="_118">
     </a>
     优点：
    </h5>
    <ul>
     <li>
      <strong>
       线程安全
      </strong>
      ：饿汉模式由于实例是在程序启动时就被创建的，因此不存在多个线程竞争创建实例的问题。它是线程安全的。
     </li>
     <li>
      <strong>
       实现简单
      </strong>
      ：不需要额外的锁机制，创建实例的过程是非常直接的。
     </li>
    </ul>
    <h5>
     <a id="_122">
     </a>
     缺点：
    </h5>
    <ul>
     <li>
      <strong>
       可能浪费资源
      </strong>
      ：即使实例没有被使用，也会在程序启动时就创建，占用内存资源。
     </li>
    </ul>
    <h5>
     <a id="_125">
     </a>
     示例代码：饿汉模式
    </h5>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>theInstance<span class="token punctuation">;</span>  <span class="token comment">// 直接返回实例</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from Singleton!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 私有构造函数，防止外部直接创建实例</span>

    <span class="token keyword">static</span> Singleton theInstance<span class="token punctuation">;</span>  <span class="token comment">// 静态成员变量保存实例</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化静态成员变量</span>
Singleton Singleton<span class="token double-colon punctuation">::</span>theInstance<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问单例</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      解释
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        theInstance
       </code>
      </strong>
      ：在程序启动时，
      <code>
       theInstance
      </code>
      就被初始化了。由于实例在静态成员变量中，只有一个
      <code>
       Singleton
      </code>
      对象存在。
     </li>
     <li>
      <strong>
       线程安全
      </strong>
      ：由于
      <code>
       theInstance
      </code>
      在程序启动时就创建，因此在多线程环境下不需要额外的同步措施。
     </li>
    </ul>
    <h4>
     <a id="33__vs__157">
     </a>
     3.3. 懒汉模式 vs 饿汉模式
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        懒汉模式（Lazy Initialization）
       </th>
       <th>
        饿汉模式（Eager Initialization）
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         实例化时机
        </strong>
       </td>
       <td>
        在第一次访问时创建实例，延迟加载
       </td>
       <td>
        在程序启动时就创建实例
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         线程安全
        </strong>
       </td>
       <td>
        如果没有加锁，线程不安全
       </td>
       <td>
        线程安全（因为实例化在程序启动时就完成）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         资源占用
        </strong>
       </td>
       <td>
        只有在需要时才创建实例，节省资源
       </td>
       <td>
        不管是否需要，都会在程序启动时创建实例，可能会浪费资源
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         实现复杂度
        </strong>
       </td>
       <td>
        需要额外的同步机制（例如
        <code>
         std::mutex
        </code>
        ）来保证线程安全
       </td>
       <td>
        实现简单，通常只需要静态成员变量即可实现
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="4__166">
     </a>
     4. 单例模式的优缺点
    </h3>
    <h4>
     <a id="_168">
     </a>
     优点：
    </h4>
    <ul>
     <li>
      <strong>
       全局唯一
      </strong>
      ：单例模式确保了类只有一个实例，方便全局访问。
     </li>
     <li>
      <strong>
       节省资源
      </strong>
      ：通过延迟实例化（懒汉模式），避免了不必要的资源浪费。
     </li>
     <li>
      <strong>
       全局访问点
      </strong>
      ：提供一个全局的访问点，方便其他模块或类访问单例实例。
     </li>
    </ul>
    <h4>
     <a id="_173">
     </a>
     缺点：
    </h4>
    <ul>
     <li>
      <strong>
       难以测试
      </strong>
      ：单例模式引入了全局状态，这使得单元测试变得更加困难。
     </li>
     <li>
      <strong>
       隐藏依赖
      </strong>
      ：通过单例模式，很多类会依赖于单例实例，增加了耦合性，降低了系统的可扩展性。
     </li>
     <li>
      <strong>
       不易扩展
      </strong>
      ：单例模式不适合扩展成多个实例的场景。
     </li>
    </ul>
    <h3>
     <a id="5__178">
     </a>
     5.
     <strong>
      什么时候使用单例模式
     </strong>
    </h3>
    <p>
     单例模式通常适用于以下情况：
    </p>
    <ul>
     <li>
      <strong>
       共享资源
      </strong>
      ：需要全局唯一实例管理的资源，如日志管理器、数据库连接池等。
     </li>
     <li>
      <strong>
       配置管理
      </strong>
      ：需要全局唯一配置实例的情况。
     </li>
     <li>
      <strong>
       系统中只能有一个实例的场景
      </strong>
      ：例如操作系统中的打印机管理器，系统级别的任务调度器等。
     </li>
    </ul>
    <h3>
     <a id="6__185">
     </a>
     6.
     <strong>
      总结
     </strong>
    </h3>
    <p>
     单例模式（Singleton Pattern）是一种确保类只有一个实例，并提供全局访问点的设计模式。我们通常有两种实现方式：懒汉模式（延迟加载）和饿汉模式（立即加载）。懒汉模式在第一次访问时创建实例，适合需要延迟加载的场景，而饿汉模式在程序启动时就创建实例，适合线程安全且实例始终需要的场景。
    </p>
    <p>
     每种实现方式有其适用的场景和优缺点，选择合适的单例模式实现方式可以提高程序的效率和可维护性。在使用单例模式时，我们需要小心避免全局状态带来的问题，合理使用并确保代码的可扩展性和可测试性。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33353830333431322f:61727469636c652f64657461696c732f313436323937373736" class_="artid" style="display:none">
 </p>
</div>


