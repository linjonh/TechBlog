---
layout: post
title: "串口通讯基础"
date: 2025-03-04 23:26:43 +0800
description: "当上位机给串口发送(0x55)数据时，MCU的RX引脚接受到（0x55）数据，数据(0x55)首先进入移位寄存器。数据全部进入移位寄存器后，一次将（0x55）全部搬运到接收数据寄存器（RDR），并且触发串口接收非空中断（RXNE）标志位【前提是使能了RXNE中断】，该标志位置位表示可以向串口输入移位寄存器写数据了。当串口给上位机发送(0xAA)数据时，MCU的发送数据寄存器（TDR）先存储数据，硬件检测发送移位寄存器是否为空。"
keywords: "串口通讯基础"
categories: ['未分类']
tags: ['嵌入式硬件', '单片机']
artid: "146026901"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146026901
    alt: "串口通讯基础"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146026901
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146026901
cover: https://bing.ee123.net/img/rand?artid=146026901
image: https://bing.ee123.net/img/rand?artid=146026901
img: https://bing.ee123.net/img/rand?artid=146026901
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     串口通讯基础
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     第1章 串口的发送和接收过程
    </h2>
    <p>
     <img alt="" height="424" src="https://i-blog.csdnimg.cn/direct/adbe8954aef8472d8656a4e53c50763f.png" width="889"/>
    </p>
    <h3>
     1.1 串口接收过程
    </h3>
    <p>
     当上位机给串口发送(0x55)数据时，MCU的RX引脚接受到（0x55）数据，数据(0x55)首先进入移位寄存器。数据全部进入移位寄存器后，一次将（0x55）全部搬运到接收数据寄存器（RDR），并且触发串口接收非空中断（RXNE）标志位【前提是使能了RXNE中断】，该标志位置位表示可以向串口输入移位寄存器写数据了。
    </p>
    <p>
     当串口给上位机发送(0xAA)数据时，MCU的发送数据寄存器（TDR）先存储数据，硬件检测发送移位寄存器是否为空。硬件检测发送移位寄存器为空后，直接将TDR中的数据搬运到发送移位寄存器，并且触发串口发送数据寄存器为空的标志位（TXE）【前提是使能TXE中断】，该标志位置位表示可以向发送数据寄存器再次写如数据了。
    </p>
    <h2>
     第2章 串口框图
    </h2>
    <p>
     <img alt="" height="673" src="https://i-blog.csdnimg.cn/direct/3b3645a4cc964713ab36ec263466b609.png" width="1132"/>
    </p>
    <p>
    </p>
    <h2>
     第3章 串口中断
    </h2>
    <p>
     <img alt="" height="435" src="https://i-blog.csdnimg.cn/direct/b47211ea0e2740fd8ea168887ae5bc8e.png" width="514"/>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        发送完成中断 (Transmission Complete Interrupt)
       </strong>
       ：当整个待发送字符的数据帧都已从移位寄存器发送出去时触发。这通常用于确认数据完全发送完毕。
      </p>
     </li>
     <li>
      <p>
       <strong>
        发送数据寄存器为空中断 (TXE Interrupt)
       </strong>
       ：当下一个数据可以被写入USART数据寄存器以便发送时触发。这意味着数据寄存器已经为空，准备接收新的数据进行发送。
      </p>
     </li>
     <li>
      <p>
       <strong>
        接收数据寄存器非空中断 (RXNE Interrupt)
       </strong>
       ：当接收到的数据已经被转移到接收数据寄存器中，可以被读取时触发。这是为了通知系统有新数据到达，可以进行处理了。
      </p>
     </li>
    </ol>
    <h2>
     第4章 实验
    </h2>
    <h3>
     4.1 数据发送实验
    </h3>
    <p>
     <img alt="" height="666" src="https://i-blog.csdnimg.cn/direct/5356694714054e758b862bf83b96369a.png" width="994"/>
    </p>
    <h3>
     4.2 软件实现
    </h3>
    <pre><code class="language-cpp">void Serial_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
	
	USART_InitTypeDef USART_InitStructure;
	USART_InitStructure.USART_BaudRate = 9600;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_Init(USART1, &amp;USART_InitStructure);
	
	USART_Cmd(USART1, ENABLE);
}

void Serial_SendByte(uint8_t Byte)
{
	/* 发送数据函数，默认会将TXE标志位清零 */
	USART_SendData(USART1, Byte);
	
	/* 查询TXE标志位，如果是SET表示发送数据寄存器的数据已经搬运到移位寄存器，可以再次发送数据了
	 * 如果是RESET表示发送数据寄存器的数据未搬运到移位寄存器，不能再发送数据了，需要等待
	*/
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}</code></pre>
    <p>
     注意：
    </p>
    <p>
     <strong>
      发送数据函数有清除USART_FLAG_TXE中断标志位的功能。至此不需要软件中写函数清除。（数据手册可知）
     </strong>
    </p>
    <blockquote>
     <p>
      USART_SendData(USART1, Byte);
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313930343035342f:61727469636c652f64657461696c732f313436303236393031" class_="artid" style="display:none">
 </p>
</div>


