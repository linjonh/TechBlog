---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37343436313236332f:61727469636c652f64657461696c732f313436313738333535"
layout: post
title: "杂学笔记-TCP和UDP的区别,对http接口解释-,-Cookie和Session的区别-,http和https的区别-,-智能指针-,断点续传"
date: 2025-03-11 16:53:46 +0800
description: "更细一点就是 ： 在双方操作系统中，发数据并不是把数据发送给对方，也不是发送到网络，而是拷贝到操作系统底层的tcp发送缓冲区，所以tcp传输控制的时候就可以根据流量控制，拥塞控制，捎带应答，快重传，各种可靠性策略，效率策略把数据发送给对方，再往下谈，滑动窗口，每一次对应的数据段也不直接发送给对方，而是交给了ip报文，在这里也添加了自己的ip报头，这里也有分片和组装的问题…而udp是无连接的，不可靠。3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。"
keywords: "[杂学笔记] TCP和UDP的区别，对http接口解释 ， Cookie和Session的区别 ，http和https的区别 ， 智能指针 ，断点续传"
categories: ['杂学笔记']
tags: ['笔记', 'Tcp', 'Http']
artid: "146178355"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146178355
    alt: "杂学笔记-TCP和UDP的区别,对http接口解释-,-Cookie和Session的区别-,http和https的区别-,-智能指针-,断点续传"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146178355
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146178355
cover: https://bing.ee123.net/img/rand?artid=146178355
image: https://bing.ee123.net/img/rand?artid=146178355
img: https://bing.ee123.net/img/rand?artid=146178355
---

# [杂学笔记] TCP和UDP的区别，对http接口解释 ， Cookie和Session的区别 ，http和https的区别 ， 智能指针 ，断点续传

#### 1. TCP和UDP的区别

* tcp的特点： 面向连接，可靠性高，全双工，面向字节流
* udp特点：无连接，不可靠（但是对实时性要求高），头部开销少，

主要区别：连接性与可靠性 ： tcp是面向连接的协议，提供可靠的数据传输服务； 而udp是无连接的，不可靠
  
头部开销与传输效率 ： tcp的头部开销大，包含更多控制信息，传输效率低 ； udp的头部开销少，传输效率高
  
应用场景 ： tcp适用于可靠性的场景，文件传输，电子邮件等； udp适用于实时传输，视频流，Voip（VoIP（互联网电话协议）是一种电话技术，允许您使用互联网而不是传统电话线拨打和接听电话。）等

> 视频音频适用于UDP协议

* 实时性，对数据丢失不敏感，避免TCP的拥塞控制对实时性的影响。
* 视频音频对于实时性的要求很高，UDP的报头只有8个字节，比TCP少了12个字节，这使得UDP在传输数据时的开销小，效率高，还不用建立连接。 如果因为建立连接，重传等操作导致延迟过大，会影响用户体验
* 视频中的一帧画面的画面丢失，音频的短暂杂音，影响体验很小，TCP拥有拥塞控制机制，当网络拥塞的时候，会降低发送报文的频率，这样会影响实时性。让TCP去参与网络疏导

#### 2. 对http接口解释

> HTTP工作原理

* HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。
* 客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

以下是 HTTP 请求/响应的步骤：

1. 客户端连接到Web服务器
     
   一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。
     
   例如，http://www.baidu.com。
2. 发送HTTP请求
     
   通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
3. 服务器接受请求并返回HTTP响应
     
   Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
4. 释放连接TCP连接
     
   若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
5. 客户端浏览器解析HTML内容
     
   客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1. 域名解析得到目标服务器的ip地址，ip地址底层基于tcp，要先三次握手建立连接，在套接字就是connect，获取成功后在应用层由浏览器构建request，http请求构建http请求行，请求报头，空行，必要时有正文，
2. 然后把http请求通过系统调用接口发送给对方，对方收到了http请求后，会对http请求进行 比如面向字节流以及粘包问题，把报文解出来，然后做序列化得到http相关字段以及请求url，然后读取url所对应的资源，都有就构建响应报头，状态行，正文，然后把整个信息构建成一个response， response通过系统调用发送给客户端，
3. 客户端在对response解决粘包问题把报文和报文之间分开，通过反序列化提取正文，正文可以是网页或者图片，由网页或图片被浏览器解释渲染

更细一点就是 ： 在双方操作系统中，发数据并不是把数据发送给对方，也不是发送到网络，而是拷贝到操作系统底层的tcp发送缓冲区，所以tcp传输控制的时候就可以根据流量控制，拥塞控制，捎带应答，快重传，各种可靠性策略，效率策略把数据发送给对方，再往下谈，滑动窗口，每一次对应的数据段也不直接发送给对方，而是交给了ip报文，在这里也添加了自己的ip报头，这里也有分片和组装的问题…

> HTTP请求方法

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0e3e3f7c08d94278a4a0b22bcac1b0ee.png)

> HTTP状态码

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/eae1f19baf2a4d04a40f9e04e8290ba5.png)

#### 3. Cookie和Session的区别

1. cookie常存储在浏览器或者本地，session只能在服务器
2. cookie只能存储string对象，session可以存储任意的jave对象
3. session更安全，但是session过多的话，会造成服务器压力问题
4. 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，Session是没有大小限制和服务器的内存大小有关。
5. 更详细看这篇文章
   [彻底了解Cookie和Session的区别（面试）](https://blog.csdn.net/weixin_45393094/article/details/104747360)

#### 4. http和https的区别

* http的post和get都是没有加密的，都可以被抓包软件抓到
* https就是在应用层和传输层进行加密（SSL&TLS，SSL/TLS是用于在计算机网络上进行安全通信的协议。）

1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

TLS握手过程 ： 1. 客户端和服务器商定通信所使用的TLS版本（双发互发信息，密码组合，证书） 2. 确定双方要使用的密码组合 3.客户端通过服务器的公钥和证书验证服务器身份 4. 生成会话密钥用于结束后的对称加密（双方互发加密的finished信号）

#### 5. 智能指针

原理：

1. 在对象构造时获取资源，在对象析构的时候释放资源，利用对象的生命周期来控制程序资源，即RALL特性
2. \*和 ->进行重载，使得该对象具有像指针一样的行为
3. 智能指针的拷贝问题 ， 为什么要解决 ： SmartPtr sp1(new int); SmartPtr sp2(sp1); //拷贝构造 对内置类型浅拷贝，构造sp2后会让两者管理同一片空间，析构会导致空间被释放两次（赋值构造也是如此）

* auto\_ptr ： 最早的智能指针，他只会允许统一时间只有一个智能指针指向同一个对象，当发生赋值或者拷贝的话，所有权就会转移，就相当于该指针不在管理对象了。
    
  所有权转移的实现是在析构和赋值构造中释放自己管理的对象，然后将管理权赋值给接管自己的对象
* unique\_ptr（防拷贝 = delete） ： 和auto\_ptr一样，但是他不允许赋值和拷贝操作。会将拷贝构造函数和赋值重载函数禁用。
* shared\_ptr ： 是共享所有权的一个指针，他允许多个智能指针指向同一个对象，他内部使用引用计数来记录个数，当引用计数为0的时候，才会去释放指向的对象资源。

  ```
  增加一个内部成员变量int* _pcount;，表明引用计数个数 ，不能被定义为int类型是因为不能让每个shared_ptr对象有一个自己的count的成员变量， 不能为静态，不能让所有对象拥有同一个count成员变量

  ```

注意 ：

1. 存在线程安全问题：多个线程可能会对同一个引用进行自增或自减操作，而自增或自减操作都不是原子操作，需要加锁进行保护。
2. 存在循环引用问题 ： 有两个结点 ：node1->\_next = node2; node2->\_prev = node1; node1的释放取决于node2中的prev成员，node2的释放取决于node1的next成员。
     
   解决方法 ： 将ListNode中的成员变量std::shared\_ptr \_next; 变为 std::weak\_ptr \_next;

* weak\_ptr ： 大多数是用来配合shared\_ptr进行使用的，解决了shared\_ptr的循环引用的问题，他没有对象的管理权，不参与引用计数的增减。

#### 6.断点续传

> 什么是断点续传

断点续传技术（Resumable Downloads 或 Resume Downloads）是一种在网络文件传输中常用的技术，它允许在文件传输过程中，如果因为某种原因（如网络中断、设备故障、用户暂停等）导致传输中断，之后可以从上次中断的地方继续传输文件，而不是从头开始重新传输整个文件。这种技术可以显著提高文件传输的效率和用户体验，特别是在传输大文件或在网络条件不稳定的环境中。

断点续传技术的实现通常依赖于客户端和服务器之间的协议支持，
**如HTTP/1.1中的Range和Content-Range头部字段。客户端会记录已经成功传输的文件部分（通常是字节范围），并在中断后重新发送带有Range头部的请求，指定从上次中断的点开始传输。服务器则根据这个请求返回文件剩余部分的数据，并在响应中包含Content-Range头部以告知客户端实际返回的数据范围。**

> 应用场景及原理

大文件下载； 视频播放；在线更新；远程备份；.文件上传

综上所述，断点续传技术广泛应用于需要高效、可靠文件传输的各种场景，特别是在网络条件不稳定或文件大小较大的情况下。通过断点续传技术，用户可以更好地利用网络资源，提高文件传输的效率和用户体验。

1. 关于 Range头部字段：

* 作用：Range头部字段用于HTTP请求中，指定服务器应该返回文件的哪一部分。这使得客户端能够请求文件的特定片段，而不是整个文件。
* 格式：Range: bytes=start-end，其中start是请求的第一个字节的偏移量（从0开始），end是请求的最后一个字节的偏移量。如果end被省略，则表示请求从start开始到文件末尾的所有字节。
* 使用场景：当客户端希望继续之前中断的下载时，它会发送一个带有Range头部的请求，指定从上次中断的点开始请求数据。

2. Content-Range头部字段

* 作用：Content-Range头部字段用于HTTP响应中，告知客户端实际返回的字节范围以及整个实体的总长度。
* 格式：Content-Range: bytes start-end/total，其中start是返回的第一个字节的偏移量，end是返回的最后一个字节的偏移量，total是整个实体的总长度（字节数）。
* 使用场景：服务器在响应带有Range头部的请求时，会使用Content-Range头部来告知客户端返回的数据范围以及整个文件的大小。