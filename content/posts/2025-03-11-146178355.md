---
layout: post
title: "杂学笔记-TCP和UDP的区别,对http接口解释-,-Cookie和Session的区别-,http和https的区别-,-智能指针-,断点续传"
date: 2025-03-11 16:53:46 +0800
description: "更细一点就是 ： 在双方操作系统中，发数据并不是把数据发送给对方，也不是发送到网络，而是拷贝到操作系统底层的tcp发送缓冲区，所以tcp传输控制的时候就可以根据流量控制，拥塞控制，捎带应答，快重传，各种可靠性策略，效率策略把数据发送给对方，再往下谈，滑动窗口，每一次对应的数据段也不直接发送给对方，而是交给了ip报文，在这里也添加了自己的ip报头，这里也有分片和组装的问题…而udp是无连接的，不可靠。3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。"
keywords: "[杂学笔记] TCP和UDP的区别，对http接口解释 ， Cookie和Session的区别 ，http和https的区别 ， 智能指针 ，断点续传"
categories: ['杂学笔记']
tags: ['笔记', 'Tcp', 'Http']
artid: "146178355"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146178355
    alt: "杂学笔记-TCP和UDP的区别,对http接口解释-,-Cookie和Session的区别-,http和https的区别-,-智能指针-,断点续传"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146178355
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146178355
cover: https://bing.ee123.net/img/rand?artid=146178355
image: https://bing.ee123.net/img/rand?artid=146178355
img: https://bing.ee123.net/img/rand?artid=146178355
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [杂学笔记] TCP和UDP的区别，对http接口解释 ， Cookie和Session的区别 ，http和https的区别 ， 智能指针 ，断点续传
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h4>
     <a id="1_TCPUDP_3">
     </a>
     1. TCP和UDP的区别
    </h4>
    <ul>
     <li>
      tcp的特点： 面向连接，可靠性高，全双工，面向字节流
     </li>
     <li>
      udp特点：无连接，不可靠（但是对实时性要求高），头部开销少，
     </li>
    </ul>
    <p>
     主要区别：连接性与可靠性 ： tcp是面向连接的协议，提供可靠的数据传输服务； 而udp是无连接的，不可靠
     <br/>
     头部开销与传输效率 ： tcp的头部开销大，包含更多控制信息，传输效率低 ； udp的头部开销少，传输效率高
     <br/>
     应用场景 ： tcp适用于可靠性的场景，文件传输，电子邮件等； udp适用于实时传输，视频流，Voip（VoIP（互联网电话协议）是一种电话技术，允许您使用互联网而不是传统电话线拨打和接听电话。）等
    </p>
    <blockquote>
     <p>
      视频音频适用于UDP协议
     </p>
    </blockquote>
    <ul>
     <li>
      实时性，对数据丢失不敏感，避免TCP的拥塞控制对实时性的影响。
     </li>
     <li>
      视频音频对于实时性的要求很高，UDP的报头只有8个字节，比TCP少了12个字节，这使得UDP在传输数据时的开销小，效率高，还不用建立连接。 如果因为建立连接，重传等操作导致延迟过大，会影响用户体验
     </li>
     <li>
      视频中的一帧画面的画面丢失，音频的短暂杂音，影响体验很小，TCP拥有拥塞控制机制，当网络拥塞的时候，会降低发送报文的频率，这样会影响实时性。让TCP去参与网络疏导
     </li>
    </ul>
    <h4>
     <a id="2_http_18">
     </a>
     2. 对http接口解释
    </h4>
    <blockquote>
     <p>
      HTTP工作原理
     </p>
    </blockquote>
    <ul>
     <li>
      HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。
     </li>
     <li>
      客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。
     </li>
    </ul>
    <p>
     以下是 HTTP 请求/响应的步骤：
    </p>
    <ol>
     <li>
      <p>
       客户端连接到Web服务器
       <br/>
       一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。
       <br/>
       例如，http://www.baidu.com。
      </p>
     </li>
     <li>
      <p>
       发送HTTP请求
       <br/>
       通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
      </p>
     </li>
     <li>
      <p>
       服务器接受请求并返回HTTP响应
       <br/>
       Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
      </p>
     </li>
     <li>
      <p>
       释放连接TCP连接
       <br/>
       若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
      </p>
     </li>
     <li>
      <p>
       客户端浏览器解析HTML内容
       <br/>
       客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。
      </p>
     </li>
    </ol>
    <p>
     例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：
    </p>
    <ol>
     <li>
      域名解析得到目标服务器的ip地址，ip地址底层基于tcp，要先三次握手建立连接，在套接字就是connect，获取成功后在应用层由浏览器构建request，http请求构建http请求行，请求报头，空行，必要时有正文，
     </li>
     <li>
      然后把http请求通过系统调用接口发送给对方，对方收到了http请求后，会对http请求进行 比如面向字节流以及粘包问题，把报文解出来，然后做序列化得到http相关字段以及请求url，然后读取url所对应的资源，都有就构建响应报头，状态行，正文，然后把整个信息构建成一个response， response通过系统调用发送给客户端，
     </li>
     <li>
      客户端在对response解决粘包问题把报文和报文之间分开，通过反序列化提取正文，正文可以是网页或者图片，由网页或图片被浏览器解释渲染
     </li>
    </ol>
    <p>
     更细一点就是 ： 在双方操作系统中，发数据并不是把数据发送给对方，也不是发送到网络，而是拷贝到操作系统底层的tcp发送缓冲区，所以tcp传输控制的时候就可以根据流量控制，拥塞控制，捎带应答，快重传，各种可靠性策略，效率策略把数据发送给对方，再往下谈，滑动窗口，每一次对应的数据段也不直接发送给对方，而是交给了ip报文，在这里也添加了自己的ip报头，这里也有分片和组装的问题…
    </p>
    <blockquote>
     <p>
      HTTP请求方法
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0e3e3f7c08d94278a4a0b22bcac1b0ee.png"/>
    </p>
    <blockquote>
     <p>
      HTTP状态码
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/eae1f19baf2a4d04a40f9e04e8290ba5.png"/>
    </p>
    <h4>
     <a id="3_CookieSession_65">
     </a>
     3. Cookie和Session的区别
    </h4>
    <ol>
     <li>
      cookie常存储在浏览器或者本地，session只能在服务器
     </li>
     <li>
      cookie只能存储string对象，session可以存储任意的jave对象
     </li>
     <li>
      session更安全，但是session过多的话，会造成服务器压力问题
     </li>
     <li>
      单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，Session是没有大小限制和服务器的内存大小有关。
     </li>
     <li>
      更详细看这篇文章
      <a href="https://blog.csdn.net/weixin_45393094/article/details/104747360">
       彻底了解Cookie和Session的区别（面试）
      </a>
     </li>
    </ol>
    <h4>
     <a id="4_httphttps_74">
     </a>
     4. http和https的区别
    </h4>
    <ul>
     <li>
      http的post和get都是没有加密的，都可以被抓包软件抓到
     </li>
     <li>
      https就是在应用层和传输层进行加密（SSL&amp;TLS，SSL/TLS是用于在计算机网络上进行安全通信的协议。）
     </li>
    </ul>
    <p>
     1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)
    </p>
    <p>
     2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
    </p>
    <p>
     3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    </p>
    <p>
     4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)
    </p>
    <p>
     TLS握手过程 ： 1. 客户端和服务器商定通信所使用的TLS版本（双发互发信息，密码组合，证书） 2. 确定双方要使用的密码组合 3.客户端通过服务器的公钥和证书验证服务器身份 4. 生成会话密钥用于结束后的对称加密（双方互发加密的finished信号）
    </p>
    <h4>
     <a id="5__91">
     </a>
     5. 智能指针
    </h4>
    <p>
     原理：
    </p>
    <ol>
     <li>
      在对象构造时获取资源，在对象析构的时候释放资源，利用对象的生命周期来控制程序资源，即RALL特性
     </li>
     <li>
      *和 -&gt;进行重载，使得该对象具有像指针一样的行为
     </li>
     <li>
      智能指针的拷贝问题 ， 为什么要解决 ： SmartPtr sp1(new int); SmartPtr sp2(sp1); //拷贝构造 对内置类型浅拷贝，构造sp2后会让两者管理同一片空间，析构会导致空间被释放两次（赋值构造也是如此）
     </li>
    </ol>
    <ul>
     <li>
      <p>
       auto_ptr ： 最早的智能指针，他只会允许统一时间只有一个智能指针指向同一个对象，当发生赋值或者拷贝的话，所有权就会转移，就相当于该指针不在管理对象了。
       <br/>
       所有权转移的实现是在析构和赋值构造中释放自己管理的对象，然后将管理权赋值给接管自己的对象
      </p>
     </li>
     <li>
      <p>
       unique_ptr（防拷贝 = delete） ： 和auto_ptr一样，但是他不允许赋值和拷贝操作。会将拷贝构造函数和赋值重载函数禁用。
      </p>
     </li>
     <li>
      <p>
       shared_ptr ： 是共享所有权的一个指针，他允许多个智能指针指向同一个对象，他内部使用引用计数来记录个数，当引用计数为0的时候，才会去释放指向的对象资源。
      </p>
      <pre><code>增加一个内部成员变量int* _pcount;，表明引用计数个数 ，不能被定义为int类型是因为不能让每个shared_ptr对象有一个自己的count的成员变量， 不能为静态，不能让所有对象拥有同一个count成员变量
</code></pre>
     </li>
    </ul>
    <p>
     注意 ：
    </p>
    <ol>
     <li>
      存在线程安全问题：多个线程可能会对同一个引用进行自增或自减操作，而自增或自减操作都不是原子操作，需要加锁进行保护。
     </li>
     <li>
      存在循环引用问题 ： 有两个结点 ：node1-&gt;_next = node2; node2-&gt;_prev = node1; node1的释放取决于node2中的prev成员，node2的释放取决于node1的next成员。
      <br/>
      解决方法 ： 将ListNode中的成员变量std::shared_ptr _next; 变为 std::weak_ptr _next;
     </li>
    </ol>
    <ul>
     <li>
      weak_ptr ： 大多数是用来配合shared_ptr进行使用的，解决了shared_ptr的循环引用的问题，他没有对象的管理权，不参与引用计数的增减。
     </li>
    </ul>
    <h4>
     <a id="6_117">
     </a>
     6.断点续传
    </h4>
    <blockquote>
     <p>
      什么是断点续传
     </p>
    </blockquote>
    <p>
     断点续传技术（Resumable Downloads 或 Resume Downloads）是一种在网络文件传输中常用的技术，它允许在文件传输过程中，如果因为某种原因（如网络中断、设备故障、用户暂停等）导致传输中断，之后可以从上次中断的地方继续传输文件，而不是从头开始重新传输整个文件。这种技术可以显著提高文件传输的效率和用户体验，特别是在传输大文件或在网络条件不稳定的环境中。
    </p>
    <p>
     断点续传技术的实现通常依赖于客户端和服务器之间的协议支持，
     <strong>
      如HTTP/1.1中的Range和Content-Range头部字段。客户端会记录已经成功传输的文件部分（通常是字节范围），并在中断后重新发送带有Range头部的请求，指定从上次中断的点开始传输。服务器则根据这个请求返回文件剩余部分的数据，并在响应中包含Content-Range头部以告知客户端实际返回的数据范围。
     </strong>
    </p>
    <blockquote>
     <p>
      应用场景及原理
     </p>
    </blockquote>
    <p>
     大文件下载； 视频播放；在线更新；远程备份；.文件上传
    </p>
    <p>
     综上所述，断点续传技术广泛应用于需要高效、可靠文件传输的各种场景，特别是在网络条件不稳定或文件大小较大的情况下。通过断点续传技术，用户可以更好地利用网络资源，提高文件传输的效率和用户体验。
    </p>
    <ol>
     <li>
      关于 Range头部字段：
     </li>
    </ol>
    <ul>
     <li>
      作用：Range头部字段用于HTTP请求中，指定服务器应该返回文件的哪一部分。这使得客户端能够请求文件的特定片段，而不是整个文件。
     </li>
     <li>
      格式：Range: bytes=start-end，其中start是请求的第一个字节的偏移量（从0开始），end是请求的最后一个字节的偏移量。如果end被省略，则表示请求从start开始到文件末尾的所有字节。
     </li>
     <li>
      使用场景：当客户端希望继续之前中断的下载时，它会发送一个带有Range头部的请求，指定从上次中断的点开始请求数据。
     </li>
    </ul>
    <ol start="2">
     <li>
      Content-Range头部字段
     </li>
    </ol>
    <ul>
     <li>
      作用：Content-Range头部字段用于HTTP响应中，告知客户端实际返回的字节范围以及整个实体的总长度。
     </li>
     <li>
      格式：Content-Range: bytes start-end/total，其中start是返回的第一个字节的偏移量，end是返回的最后一个字节的偏移量，total是整个实体的总长度（字节数）。
     </li>
     <li>
      使用场景：服务器在响应带有Range头部的请求时，会使用Content-Range头部来告知客户端返回的数据范围以及整个文件的大小。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37343436313236332f:61727469636c652f64657461696c732f313436313738333535" class_="artid" style="display:none">
 </p>
</div>


