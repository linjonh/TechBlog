---
layout: post
title: "优选算法系列1.-双指针_上"
date: 2025-03-10 23:19:45 +0800
description: "双指针常见的双指针有两种形式，⼀种是对撞指针，⼀种是左右指针。⼀般⽤于顺序结构中，也称左右指针。对撞指针从两端向中间移动。⼀个指针从最左端开始，另⼀个从最右端开始，然后逐渐往中间逼近。对撞指针的终⽌条件⼀般是两个指针相遇或者错开（也可能在循环内部找到结果直接跳出循环），也就是：（两个指针指向同⼀个位置）（两个指针错开）⼜称为⻳兔赛跑算法，其基本思想就是使⽤两个移动速度不同的指针在数组或链表等序列结构上移动。这种⽅法对于处理环形链表或数组⾮常有⽤。"
keywords: "优选算法系列（1. 双指针_上）"
categories: ['未分类']
tags: ['算法', 'C']
artid: "146161922"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146161922
    alt: "优选算法系列1.-双指针_上"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146161922
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146161922
cover: https://bing.ee123.net/img/rand?artid=146161922
image: https://bing.ee123.net/img/rand?artid=146161922
img: https://bing.ee123.net/img/rand?artid=146161922
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     优选算法系列（1. 双指针_上）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="%E5%8F%8C%E6%8C%87%E9%92%88" name="%E5%8F%8C%E6%8C%87%E9%92%88">
     <span style="color:#1f2329">
      双指针
     </span>
    </h3>
    <div>
     <span style="color:#646a73">
      常见的双指针有两种形式，⼀种是对撞指针，⼀种是左右指针。
     </span>
    </div>
    <div>
     <span style="color:#0d0016">
      <strong>
       对撞指针：
      </strong>
     </span>
     <span style="color:#646a73">
      ⼀般⽤于顺序结构中，也称左右指针。
     </span>
    </div>
    <div>
    </div>
    <ul>
     <li>
      <span style="color:#646a73">
       对撞指针从两端向中间移动。⼀个指针从最左端开始，另⼀个从最右端开始，然后逐渐往中间逼
      </span>
      <span style="color:#646a73">
       近。
      </span>
     </li>
     <li>
      <span style="color:#646a73">
       对撞指针的终⽌条件⼀般是两个指针相遇或者错开（也可能在循环内部找到结果直接跳出循
      </span>
      <span style="color:#646a73">
       环），也就是：
      </span>
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#646a73">
       left == right
      </span>
      <span style="color:#646a73">
       （两个指针指向同⼀个位置）
      </span>
     </li>
     <li>
      <span style="color:#646a73">
       left &gt; right
      </span>
      <span style="color:#646a73">
       （两个指针错开）
      </span>
     </li>
    </ol>
    <div>
     <span style="color:#0d0016">
      <strong>
       快慢指针：
      </strong>
     </span>
     <span style="color:#646a73">
      ⼜称为⻳兔赛跑算法，其基本思想就是使⽤两个移动速度不同的指针在数组或链表等序列结构上移动。
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      这种⽅法对于处理环形链表或数组⾮常有⽤。
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      其实不单单是环形链表或者是数组，如果我们要研究的问题出现循环往复的情况时，均可考虑使⽤快慢指针的思想。
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      快慢指针的实现⽅式有很多种，最常⽤的⼀种就是：
     </span>
    </div>
    <ul>
     <li>
      <span style="color:#646a73">
       在⼀次循环中，每次让慢的指针向后移动⼀位，⽽快的指针往后移动两位，实现⼀快⼀慢。
      </span>
     </li>
    </ul>
    <p>
    </p>
    <h3 id="%E4%B8%80%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88easy%EF%BC%89" name="%E4%B8%80%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88easy%EF%BC%89">
     <span style="color:#fe2c24">
      一：移动零（easy）
     </span>
    </h3>
    <h4 id="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6" name="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6">
     <span style="color:#be191c">
      <strong>
       题目链接
      </strong>
     </span>
     <span style="color:#0d0016">
      ：
      <a class="link-info" href="https://leetcode.cn/problems/move-zeroes/" rel="nofollow" title="移动零">
       移动零
      </a>
     </span>
    </h4>
    <p>
     <img alt="" height="455" src="https://i-blog.csdnimg.cn/direct/63384d4f00f64954a26a7a2fcef38a95.png" width="791"/>
    </p>
    <p>
    </p>
    <h4 id="%E8%A7%A3%E6%B3%95%3A" name="%E8%A7%A3%E6%B3%95%3A">
     <span style="color:#be191c">
      <strong>
       解法:
      </strong>
     </span>
    </h4>
    <div>
     <div>
      <span style="color:#1f2329">
       ⽤⼀个
      </span>
      <span style="color:#1f2329">
       cur
      </span>
      <span style="color:#1f2329">
       指针来扫描整个数组，另⼀个
      </span>
      <span style="color:#1f2329">
       dest
      </span>
      <span style="color:#1f2329">
       指针⽤来记录⾮零数序列的最后⼀个位置。根据 cur
      </span>
      <span style="color:#1f2329">
       在扫描的过程中，遇到的不同情况，分类处理，实现数组的划分。在 cur
      </span>
      <span style="color:#1f2329">
       遍历期间，使
      </span>
      <span style="color:#1f2329">
       [0, dest]
      </span>
      <span style="color:#1f2329">
       的元素全部都是⾮零元素，
      </span>
      <span style="color:#1f2329">
       [dest + 1, cur - 1]
      </span>
      <span style="color:#1f2329">
       的
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       元素全是零。
      </span>
     </div>
    </div>
    <ul>
     <li>
      <strong>
       <span style="color:#1f2329">
        两个指针（数组用下标替代）：
       </span>
      </strong>
     </li>
    </ul>
    <p>
     cur：从左往右扫描数组，遍历数组
    </p>
    <p>
     dest：已处理的区间内最后一个非零元素（没有处理过的区间最开始定义为-1）
    </p>
    <ul>
     <li>
      <strong>
       三个区间
      </strong>
     </li>
    </ul>
    <p>
     [0,dest]: 非0元素
     <br/>
     [dest，cur-1]: 0
    </p>
    <p>
     [cur-1,size-1]: 待处理区间
    </p>
    <p>
     <img alt="" height="437" src="https://i-blog.csdnimg.cn/direct/6679b9ef1906481cb4077428db5af09f.png" width="1218"/>
    </p>
    <p>
     <img alt="" height="492" src="https://i-blog.csdnimg.cn/direct/d3ef429f863e4c058b207dd417eeb73d.png" width="800"/>
    </p>
    <p>
     <span style="color:#be191c">
      <strong>
       如何实现：
      </strong>
     </span>
    </p>
    <p>
     cur的遍历过程中：
    </p>
    <ol>
     <li>
      遇到0元素：不处理（cur++）
     </li>
     <li>
      遇到非零元素： 交换 dest+1和cur，dest++，cur++
     </li>
    </ol>
    <h4 id="%E4%BB%A3%E7%A0%81%EF%BC%9A" name="%E4%BB%A3%E7%A0%81%EF%BC%9A">
     <span style="color:#be191c">
      <strong>
       代码：
      </strong>
     </span>
    </h4>
    <p>
     <img alt="" height="228" src="https://i-blog.csdnimg.cn/direct/9adfbf1ef04e42528be7aea90aba0f5c.png" width="694"/>
    </p>
    <p>
     <img alt="" height="367" src="https://i-blog.csdnimg.cn/direct/d74477d0b1b54c9ba3fd4ded02146c5f.png" width="806"/>
    </p>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <h3 id="%E4%BA%8C%EF%BC%9A%E5%A4%8D%E5%86%99%E9%9B%B6%EF%BC%88easy%EF%BC%89" name="%E4%BA%8C%EF%BC%9A%E5%A4%8D%E5%86%99%E9%9B%B6%EF%BC%88easy%EF%BC%89">
     <span style="color:#fe2c24">
      二：复写零（easy）
     </span>
    </h3>
    <h4 id="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A%E5%A4%8D%E5%86%99%E9%9B%B6" name="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A%E5%A4%8D%E5%86%99%E9%9B%B6">
     <span style="color:#be191c">
      <strong>
       题目链接：
       <a class="link-info" href="https://leetcode.cn/problems/duplicate-zeros/description/" rel="nofollow" title="复写零">
        复写零
       </a>
      </strong>
     </span>
    </h4>
    <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="559" src="https://i-blog.csdnimg.cn/direct/7c5de31f4eb74eaab73180495bc4c13d.png" width="780"/>
    </h4>
    <h4 id="%E8%A7%A3%E6%B3%95%EF%BC%9A" name="%E8%A7%A3%E6%B3%95%EF%BC%9A">
     <span style="color:#be191c">
      <strong>
       解法：
      </strong>
     </span>
    </h4>
    <p>
     <span style="color:#0d0016">
      根据“异地”操作，优化为本地操作。
     </span>
    </p>
    <ul>
     <li>
      异地操作：
     </li>
    </ul>
    <p>
     <img alt="" height="476" src="https://i-blog.csdnimg.cn/direct/b46f8dc18cc6487596fbfa280d1fa839.png" width="975"/>
    </p>
    <p>
     通过“异地”复写可以很简单地完成这个题目但是题目要求“本地”操作
    </p>
    <ul>
     <li>
      本地操作
     </li>
    </ul>
    <div>
     <span style="color:#1f2329">
      如果
      <strong>
       「从前向后」
      </strong>
      进⾏原地复写操作的话，由于
     </span>
     <span style="color:#1f2329">
      0
     </span>
     <span style="color:#1f2329">
      的出现会复写两次，导致没有复写的数「被覆
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      盖掉」。
     </span>
    </div>
    <p>
     <img alt="" height="395" src="https://i-blog.csdnimg.cn/direct/9ae09c54fa8b415ca0fb9d37363dfd18.png" width="1041"/>
    </p>
    <p>
     2会被覆盖掉
    </p>
    <p>
     <img alt="" height="414" src="https://i-blog.csdnimg.cn/direct/9ccd37608ee34d348bfec61316d94cd2.png" width="1008"/>
    </p>
    <p>
    </p>
    <div>
     <span style="color:#1f2329">
      因此我们选择
      <strong>
       「从后往前」
      </strong>
      的复写策略。
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      但是「从后向前」复写的时候，我们需要找到「最后⼀个复写的数」，因此我们的⼤体流程分两
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      步：
     </span>
    </div>
    <ol>
     <li>
      <span style="color:#1f2329">
       先找到最后⼀个复写的数；（两种方法）
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       然后从后向前进⾏复写操作
      </span>
     </li>
    </ol>
    <p>
     <img alt="" height="500" src="https://i-blog.csdnimg.cn/direct/f5a8c92096774af6ad12a663903e78fe.png" width="1364"/>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#1f2329">
      在这里找最后⼀个复写的数提供两种方法
     </span>
    </p>
    <p>
     <strong>
      <span style="color:#1f2329">
       方法1：
      </span>
     </strong>
    </p>
    <p>
     <span style="color:#1f2329">
      让cur和dest都先指向第一个元素
     </span>
    </p>
    <p>
     <img alt="" height="465" src="https://i-blog.csdnimg.cn/direct/e52e9db1f3644fe9877bb957414c3d6e.png" width="1677"/>
    </p>
    <p>
     当dest&gt;=size-1的时候cur就是最后一个要复写的数。
    </p>
    <p>
     特殊情况下：dest=arr.size();
    </p>
    <p>
     <strong>
      方法2：
     </strong>
    </p>
    <p>
     由于每有一个0就需要多写一次，这也就意味着每有一个0原数组的最后一位都不会出现在复写之后的数组里面。
    </p>
    <p>
     据此我们让dest等于最后一个元素cur从前往后遍历，每次遇到一个0就让dest向前移动一位，当cur和dest相遇的位置就是最后要复写的数。
    </p>
    <p>
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/dcb651cd1e2e40ada683350a82a1d3c6.png" width="818"/>
    </p>
    <p>
     特殊情况下dest&lt;cur.
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       特殊情况的处理：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      当最后一个要复写的数为0的时候我们如果复写两次就会造成错误，此时我们需要特殊处理让最后的0只写一次
     </span>
    </p>
    <p>
     <img alt="" height="260" src="https://i-blog.csdnimg.cn/direct/1864e6ab6afe4c1988902b584cb6c3e9.png" width="562"/>
    </p>
    <p>
    </p>
    <h4 id="%E4%BB%A3%E7%A0%81%EF%BC%9A" name="%E4%BB%A3%E7%A0%81%EF%BC%9A">
     <span style="color:#be191c">
      代码：
     </span>
    </h4>
    <p>
     <img alt="" height="896" src="https://i-blog.csdnimg.cn/direct/45ea93fb8a0e496089f073f55492146e.png" width="1275"/>
    </p>
    <p>
     <img alt="" height="368" src="https://i-blog.csdnimg.cn/direct/aee0cfc5c78e43f9a871b08b2b7169cb.png" width="794"/>
    </p>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="841" src="https://i-blog.csdnimg.cn/direct/24baf694e2e6460f8442b6176dccd69b.png" width="1246"/>
    </h3>
    <p>
     <img alt="" height="391" src="https://i-blog.csdnimg.cn/direct/06505b8e7b2b4323a4e1ebfbc2cf2e31.png" width="875"/>
    </p>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <h3 id="%E4%B8%89%EF%BC%9A%E5%BF%AB%E4%B9%90%E6%95%B0%EF%BC%88medium%EF%BC%89" name="%E4%B8%89%EF%BC%9A%E5%BF%AB%E4%B9%90%E6%95%B0%EF%BC%88medium%EF%BC%89">
     <span style="color:#fe2c24">
      <strong>
       三：快乐数
      </strong>
      （medium）
     </span>
    </h3>
    <div>
     <span style="color:#1f2329">
      题⽬链接：
      <a class="link-info" href="https://leetcode.cn/problems/happy-number/description/" rel="nofollow" title="快乐数">
       快乐数
      </a>
     </span>
    </div>
    <div>
     <img alt="" height="889" src="https://i-blog.csdnimg.cn/direct/ab8e72f9fb4f407baaade38cf5854fd6.png" width="833"/>
    </div>
    <h4 id="%E8%A7%A3%E6%B3%95%EF%BC%9A" name="%E8%A7%A3%E6%B3%95%EF%BC%9A">
     解法：
    </h4>
    <div>
    </div>
    <div>
     <div>
      <span style="color:#1f2329">
       题⽬告诉我们，当我们不断重复
      </span>
      <span style="color:#1f2329">
       x
      </span>
      <span style="color:#1f2329">
       操作的时候，计算⼀定会「死循环」，死的⽅式有两种：
      </span>
     </div>
     <ul>
      <li>
       <span style="color:#1f2329">
        情况⼀：⼀直在
       </span>
       <span style="color:#1f2329">
        1
       </span>
       <span style="color:#1f2329">
        中死循环，即
       </span>
       <span style="color:#1f2329">
        1 -&gt; 1 -&gt; 1 -&gt; 1......
       </span>
      </li>
      <li>
       <span style="color:#1f2329">
        情况⼆：在历史的数据中死循环，但始终变不到
       </span>
       <span style="color:#1f2329">
        1
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#1f2329">
       由于上述两种情况只会出现⼀种，因此，只要我们能确定循环是在「情况⼀」中进⾏，还是在「情
      </span>
      <span style="color:#1f2329">
       况⼆」中进⾏，就能得到结果。
      </span>
     </p>
     <p>
      <img alt="" height="1035" src="https://i-blog.csdnimg.cn/direct/e6d54e26615745078e91bf652e8f6a78.png" width="1373"/>
     </p>
     <p>
      我们可以将这两种情况抽象一下：
     </p>
     <p>
      <img alt="" height="453" src="https://i-blog.csdnimg.cn/direct/b52dfe6533cb41939f6500ca3dcc9206.png" width="1169"/>
     </p>
     <p>
      也就是说，快乐数其实我们也可以看作最终会陷入一个循环只不过每次都是1.
     </p>
     <p>
      这种图形在之前的代换链表相关问题中有提到过
     </p>
     <p>
      <a href="https://blog.csdn.net/2301_79903399/article/details/138319503?spm=1001.2014.3001.5501" title="带环链表的快速判断与入环点寻找方法-CSDN博客">
       带环链表的快速判断与入环点寻找方法-CSDN博客
      </a>
     </p>
     <p>
      <img alt="" height="991" src="https://i-blog.csdnimg.cn/direct/65f85ababf094dc489edab29b4481d74.png" width="999"/>
     </p>
     <p>
      在那里我们用快慢指针判断一个链表是否带换，而本题一定会带环，因此我们使用快慢指针的思想那么快乐数的两个指针相遇一定为1，不是快乐数的两个指针相遇则不为1.
     </p>
     <p>
      当然这里的指针是一种思想并不一定是指针，它也可以是一个数字。
     </p>
     <h4 id="%E6%8B%93%E5%B1%95%EF%BC%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%EF%BC%89%EF%BC%9A" name="%E6%8B%93%E5%B1%95%EF%BC%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%EF%BC%89%EF%BC%9A">
      <span style="color:#be191c">
       拓展（鸽巢原理）：
      </span>
     </h4>
     <p>
      这里的题目告诉了我们只有这两种情况，那如果题目不给（
      <span style="color:#1f2329">
       情况⼆：在历史的数据中死循环，但始终变不到
      </span>
      <span style="color:#1f2329">
       1）这一条件，那是否存在一直变下去不为1且不成环的情况呢？
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       这里我们就需要用到 鸽巢原理（抽屉原理）：意思是有n个鸽子和n+1个巢穴，那么至少有一个巢穴有不止一个鸽子。
      </span>
     </p>
     <p>
      我们都知道int的最大值为2^31，结果就是
     </p>
     <p>
      <img alt="" height="123" src="https://i-blog.csdnimg.cn/direct/4dac03f27ccb4455aad1573dc4fcdc3f.png" width="541"/>
     </p>
     <p>
      我们直接让每位都变成9也就是9999999999（10个9）试通过题目
      <span style="color:#1f2329">
       x
      </span>
      <span style="color:#1f2329">
       操作
      </span>
      的那种计算方式下达到最大值（9*9*10=810）这意味着在int范围内无论取什么数通过
      <span style="color:#1f2329">
       x
      </span>
      <span style="color:#1f2329">
       操作都不可能超过810。那么我们随机取一个数进行至多811次操作就一定会得到重复的数字。即一定会成环！
      </span>
     </p>
     <p>
     </p>
     <h4 id="%E4%BB%A3%E7%A0%81%EF%BC%9A" name="%E4%BB%A3%E7%A0%81%EF%BC%9A">
      <span style="color:#1f2329">
       代码：
      </span>
     </h4>
    </div>
    <p>
     <img alt="" height="802" src="https://i-blog.csdnimg.cn/direct/5a137f2fd9ae47b78bd458bfede5d4de.png" width="1290"/>
    </p>
    <p>
     <img alt="" height="398" src="https://i-blog.csdnimg.cn/direct/3d50dc398bf843f0a99df958e38c8d8a.png" width="853"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <p>
    </p>
    <h3 id="%E5%9B%9B.%C2%A0%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88medium%EF%BC%89" name="%E5%9B%9B.%C2%A0%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88medium%EF%BC%89">
     <span style="color:#fe2c24">
      四. 盛水最多的容器（medium）
     </span>
    </h3>
    <h4 id="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8" name="%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8">
     <span style="color:#be191c">
      题目链接：
      <a class="link-info" href="https://leetcode.cn/problems/container-with-most-water/description/" rel="nofollow" title="盛水最多的容器">
       盛水最多的容器
      </a>
     </span>
    </h4>
    <p>
     <img alt="" height="1079" src="https://i-blog.csdnimg.cn/direct/7a03966562b64e61a52f4e3aded38213.png" width="1204"/>
    </p>
    <h4 id="%E8%A7%A3%E6%B3%95%EF%BC%9A" name="%E8%A7%A3%E6%B3%95%EF%BC%9A">
     <span style="color:#be191c">
      解法：
     </span>
    </h4>
    <ul>
     <li>
      <span style="color:#1f2329">
       解法⼀（暴⼒求解）（会超时）：
      </span>
     </li>
    </ul>
    <div>
     <div>
      <span style="color:#1f2329">
       枚举出能构成的所有容器，找出其中容积最⼤的值。
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       容器容积的计算⽅式：
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       设两指针
      </span>
      <span style="color:#1f2329">
       i
      </span>
      <span style="color:#1f2329">
       ,
      </span>
      <span style="color:#1f2329">
       j
      </span>
      <span style="color:#1f2329">
       ，分别指向⽔槽板的最左端以及最右端，此时容器的宽度为
      </span>
      <span style="color:#1f2329">
       j - i
      </span>
      <span style="color:#1f2329">
       。由于容器的⾼度由两板中的短板决定，因此可得容积公式 ： v = (j - i) * min(height[i], height[j])
      </span>
     </div>
     <div>
     </div>
     <ul>
      <li>
       <span style="color:#1f2329">
        解法⼆（对撞指针）：
       </span>
      </li>
     </ul>
     <p>
      <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/7adb6602a0e44ab3b3dba93a11d04404.png" width="878"/>
     </p>
     <p>
      我们先给一个区间取最两边的两个值算出 v1
     </p>
     <p>
      然后我们以两边较小的值向内取值（2，5，4）我们会发现有两种情况
     </p>
     <ol>
      <li>
       h（高度不变）* w（宽度变小）= v（体积减小）
      </li>
      <li>
       h（高度变小）* w（宽度变小）= v（体积减小）
      </li>
     </ol>
     <p>
      因此我们可以将这种单调性质应用上
     </p>
     <p>
      <img alt="" height="469" src="https://i-blog.csdnimg.cn/direct/7ba2b5d3a3e743efbb38ba2db04c9400.png" width="1482"/>
     </p>
     <p>
     </p>
     <h4 id="%E4%BB%A3%E7%A0%81%EF%BC%9A" name="%E4%BB%A3%E7%A0%81%EF%BC%9A" style="background-color:transparent">
      <strong>
       代码：
      </strong>
     </h4>
     <p>
      <img alt="" height="510" src="https://i-blog.csdnimg.cn/direct/e9278735a57d42f2b91a19950e2fc067.png" width="856"/>
     </p>
     <p>
      <img alt="" height="403" src="https://i-blog.csdnimg.cn/direct/36915107828244cbb46fa401680d6661.png" width="894"/>
     </p>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393930333339392f:61727469636c652f64657461696c732f313436313631393232" class_="artid" style="display:none">
 </p>
</div>


