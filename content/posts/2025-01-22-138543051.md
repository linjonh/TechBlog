---
layout: post
title: "2024年最新没啥用的纯前端打造一个实时-markdown-编辑器,前端开发究竟该如何学习"
date: 2025-01-22 22:41:21 +0800
description: "如果你已经下定决心要转行做编程行业，在最开始的时候就要对自己的学习有一个基本的规划，还要对这个行业的"
keywords: "前端markdown编辑器"
categories: ['程序员']
tags: ['编辑器', '学习', '前端']
artid: "138543051"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138543051
    alt: "2024年最新没啥用的纯前端打造一个实时-markdown-编辑器,前端开发究竟该如何学习"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=138543051
featuredImagePreview: https://bing.ee123.net/img/rand?artid=138543051
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     2024年最新没啥用的纯前端打造一个实时 markdown 编辑器，前端开发究竟该如何学习
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="_2">
     </a>
     最后
    </h4>
    <p>
     如果你已经下定决心要转行做编程行业，在最开始的时候就要对自己的学习有一个基本的规划，还要对这个行业的技术需求有一个基本的了解。有一个已就业为目的的学习目标，然后为之努力，坚持到底。如果你有幸看到这篇文章，希望对你有所帮助，祝你转行成功。
    </p>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618166371">
       开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
      </a>
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/d9bf9d92f824435f9b6d101c60394d51.png"/>
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       初始化编辑框
      </p>
     </li>
     <li>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function initEditor() {
     <!-- -->
    </p>
    <p>
     // 初始化编辑器
    </p>
    <p>
     var editor = ace.edit(‘md-editor’);
    </p>
    <p>
     editor.setTheme(‘ace/theme/monokai’); // 设置主题样式
    </p>
    <p>
     editor.getSession().setMode(‘ace/mode/markdown’); // 设置编辑器模式
    </p>
    <p>
     editor.getSession().setTabSize(4); // 设置 Tab 为４个空格
    </p>
    <p>
     editor.getSession().setUseWrapMode(true); // 自动换行
    </p>
    <p>
     }
    </p>
    <p>
     <strong>
      现在可以用浏览器打开 index.html ，可以看到编辑器了，而且可以输入内容。
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a2986f951a1a7f93dac565de5375e2db.png"/>
    </p>
    <p>
     <a href="https://bbs.csdn.net/topics/618166371">
     </a>
     4.解析markdown
    </p>
    <hr/>
    <p>
     下面我们来编写解析 markdown 的方法,输入如下代码:
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       解析markdown
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       @params {object} editor 编辑器
      </p>
     </li>
     <li>
      <p>
       @return {object} 预览框
      </p>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function parseMarkdown(editor) {
     <!-- -->
    </p>
    <p>
     var viewer = $(‘#md-viewer’); // 文档预览框
    </p>
    <p>
     var data = editor.getValue(); // 获取编辑器数据
    </p>
    <p>
     // 保存数据到本地
    </p>
    <p>
     localStorage.localData = data;
    </p>
    <p>
     // 解析 markdown
    </p>
    <p>
     data = marked(data);
    </p>
    <p>
     viewer.html(data);
    </p>
    <p>
     }
    </p>
    <blockquote>
     <ul>
      <li>
       解析 markdown 使用的是 marked.js 库，看上面的代码就知道使用的方法很简单，调用 marked(data) 就可以了。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       但是，我们要实现实时解析 markdown，也就是说要在编辑器中每输入一个字符，就会自动解析并在预览框中显示出来。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       那么我们只需要给编辑器绑定一个 change 事件就可以了，当编辑器中的内容发生变化时就调用 parseMarkdown() 方法解析一次，这样就是实时的了。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      main.js:
     </p>
    </blockquote>
    <p>
     // 初始化编辑器
    </p>
    <p>
     initEditor();
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       初始化编辑框
      </p>
     </li>
     <li>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function initEditor() {
     <!-- -->
    </p>
    <p>
     // 初始化编辑器
    </p>
    <p>
     var editor = ace.edit(‘md-editor’);
    </p>
    <p>
     editor.setTheme(‘ace/theme/monokai’); // 设置主题样式
    </p>
    <p>
     editor.getSession().setMode(‘ace/mode/markdown’); // 设置编辑器模式
    </p>
    <p>
     editor.getSession().setTabSize(4); // 设置 Tab 为４个空格
    </p>
    <p>
     editor.getSession().setUseWrapMode(true); // 自动换行
    </p>
    <p>
     // 加载本地缓存数据
    </p>
    <p>
     editor.setValue(localStorage.localData || ‘’);
    </p>
    <p>
     // 解析从本地加载的缓存数据
    </p>
    <p>
     parseMarkdown(editor);
    </p>
    <p>
     // 绑定 change 事件
    </p>
    <p>
     // 即时解析 markdown
    </p>
    <p>
     editor.getSession().on(‘change’, function (e) {
     <!-- -->
    </p>
    <p>
     parseMarkdown(editor);
    </p>
    <p>
     });
    </p>
    <p>
     }
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       解析markdown
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       @params {object} editor 编辑器
      </p>
     </li>
     <li>
      <p>
       @return {object} 预览框
      </p>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function parseMarkdown(editor) {
     <!-- -->
    </p>
    <p>
     var viewer = $(‘#md-viewer’); // 文档预览框
    </p>
    <p>
     var data = editor.getValue(); // 获取编辑器数据
    </p>
    <p>
     // 保存数据到本地
    </p>
    <p>
     localStorage.localData = data;
    </p>
    <p>
     // 解析 markdown
    </p>
    <p>
     data = marked(data);
    </p>
    <p>
     viewer.html(data);
    </p>
    <p>
     }
    </p>
    <blockquote>
     <p>
      我们用 localStorage 把每次修改后的数据都保存在了本地缓存中，这样即使刷新浏览器数据也不会丢失了。
     </p>
    </blockquote>
    <p>
     现在已经可以实时解析 markdown 了，可以打开浏览器试试。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/39edca55b5f5a0cafa1a14df4763d261.png"/>
    </p>
    <p>
     <a href="https://bbs.csdn.net/topics/618166371">
     </a>
     5.代码高亮
    </p>
    <hr/>
    <p>
     下面我们来美化一下 markdown 中的代码块， 这样预览框中的会更加好看。
    </p>
    <p>
     我们使用 highlight.js 库来高亮代码，
    </p>
    <blockquote>
     <p>
      highlight.js
     </p>
    </blockquote>
    <blockquote>
     <p>
      主要有两个常用方法：hljs.initHighlightingOnLoad(); 和 hljs.highlightBlock();
     </p>
    </blockquote>
    <blockquote>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       第一个方法：用于页面加载完后，需要高亮的代码文档不会被改变的情况。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       第二个方法：主要用于需要高亮的代码随时会被改变的情况。所以我们这里使用第二个方法。
      </li>
     </ul>
    </blockquote>
    <p>
     修改 parseMarkdown() 方法代码：
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       解析markdown
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       @params {object} editor 编辑器
      </p>
     </li>
     <li>
      <p>
       @return {object} 预览框
      </p>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function parseMarkdown(editor) {
     <!-- -->
    </p>
    <p>
     var viewer = $(‘#md-viewer’); // 文档预览框
    </p>
    <p>
     var data = editor.getValue(); // 获取编辑器数据
    </p>
    <p>
     // 保存数据到本地
    </p>
    <p>
     localStorage.localData = data;
    </p>
    <p>
     // 解析 markdown
    </p>
    <p>
     data = marked(data);
    </p>
    <p>
     viewer.html(data);
    </p>
    <p>
     // 高亮 markdown 文档中的代码
    </p>
    <p>
     $(‘pre &gt; code’, viewer).each(function () {
     <!-- -->
    </p>
    <p>
     hljs.highlightBlock(this);
    </p>
    <p>
     });
    </p>
    <p>
     }
    </p>
    <p>
     到这里，一个简单的 markdown 编辑器已经成型了。
    </p>
    <p>
     <a href="https://bbs.csdn.net/topics/618166371">
     </a>
     6.滚动条同步
    </p>
    <hr/>
    <p>
     为了让体验更好，我们再加一个功能，让两边的滚动条同步，也就是滚动左边或者右边的文档时，另一边的也会跟着滚动。
    </p>
    <p>
     在 main.js 中添加如下函数：
    </p>
    <p>
     /*
    </p>
    <ul>
     <li>
      <p>
       控制滚动条
      </p>
     </li>
     <li>
      <p>
       使编辑器和预览框同时滚动
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       @params {object} editor 编辑器
      </p>
     </li>
     <li>
      <p>
       @params {object} viewer 预览框
      </p>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function fixScrollBar(editor, viewer) {
     <!-- -->
    </p>
    <p>
     var session = editor.getSession();
    </p>
    <p>
     // 第一次加载页面时
    </p>
    <p>
     // 默认滚动到第一行
    </p>
    <p>
     session.setScrollTop(0);
    </p>
    <p>
     // 编辑器绑定滚动事件
    </p>
    <p>
     session.on(‘changeScrollTop’, function () {
     <!-- -->
    </p>
    <p>
     var sTop = session.getScrollTop();
    </p>
    <p>
     // 设置预览框的滚动条
    </p>
    <p>
     viewer.scrollTop(sTop);
    </p>
    <p>
     });
    </p>
    <p>
     // 预览框定滚动事件
    </p>
    <p>
     viewer.on(‘scroll’, function () {
     <!-- -->
    </p>
    <p>
     var sTop = viewer.scrollTop();
    </p>
    <p>
     // 设置编辑器的滚动条
    </p>
    <p>
     session.setScrollTop(sTop);
    </p>
    <p>
     });
    </p>
    <p>
     }
    </p>
    <blockquote>
     <ul>
      <li>
       在这个函数中，我们可以看到，给编辑器和预览框都绑定了 scroll 方法，滚动的时候，会改变另一边的 scrollTop 值，这样两边的滚动条就基本同步了。这个函数需要传入两个参数：编辑器对象和预览框对象。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       调用的时候，按逻辑是在 initEditor() 中调用，但是这个函数里面没有预览框对象，为了不重复通过 jQuery 获取预览框，我们可以在 parseMarkdown() 函数中 return viewer，然后传给 fixScrollBar()。
      </li>
     </ul>
    </blockquote>
    <p>
     <a href="https://bbs.csdn.net/topics/618166371">
     </a>
     7.最终main.js代码
    </p>
    <hr/>
    <p>
     // 初始化编辑器
    </p>
    <p>
     initEditor();
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       初始化编辑框
      </p>
     </li>
     <li>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function initEditor() {
     <!-- -->
    </p>
    <p>
     // 初始化编辑器
    </p>
    <p>
     var editor = ace.edit(‘md-editor’);
    </p>
    <p>
     editor.setTheme(‘ace/theme/monokai’); // 设置主题样式
    </p>
    <p>
     editor.getSession().setMode(‘ace/mode/markdown’); // 设置编辑器模式
    </p>
    <p>
     editor.getSession().setTabSize(4); // 设置 Tab 为４个空格
    </p>
    <p>
     editor.getSession().setUseWrapMode(true); // 自动换行
    </p>
    <p>
     // 加载本地缓存数据
    </p>
    <p>
     editor.setValue(localStorage.localData || ‘’);
    </p>
    <p>
     // 解析从本地加载的缓存数据
    </p>
    <p>
     // 并获取其返回的 viewer
    </p>
    <p>
     var viewer = parseMarkdown(editor);
    </p>
    <p>
     // 控制滚动条
    </p>
    <p>
     fixScrollBar(editor, viewer);
    </p>
    <p>
     // 即时解析 markdown
    </p>
    <p>
     editor.getSession().on(‘change’, function (e) {
     <!-- -->
    </p>
    <p>
     parseMarkdown(editor);
    </p>
    <p>
     });
    </p>
    <p>
     }
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      <p>
       解析markdown
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       @params {object} editor 编辑器
      </p>
     </li>
     <li>
      <p>
       @return {object} 预览框
      </p>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function parseMarkdown(editor) {
     <!-- -->
    </p>
    <p>
     var viewer = $(‘#md-viewer’); // 文档预览框
    </p>
    <p>
     var data = editor.getValue(); // 获取编辑器数据
    </p>
    <p>
     // 保存数据到本地
    </p>
    <p>
     localStorage.localData = data;
    </p>
    <p>
     // 解析 markdown
    </p>
    <p>
     data = marked(data);
    </p>
    <p>
     viewer.html(data);
    </p>
    <p>
     // 高亮 markdown 文档中的代码
    </p>
    <p>
     $(‘pre &gt; code’, viewer).each(function () {
     <!-- -->
    </p>
    <p>
     hljs.highlightBlock(this);
    </p>
    <p>
     });
    </p>
    <p>
     // 返回 viewer
    </p>
    <p>
     return viewer;
    </p>
    <p>
     }
    </p>
    <p>
     /*
    </p>
    <ul>
     <li>
      <p>
       控制滚动条
      </p>
     </li>
     <li>
      <p>
       使编辑器和预览框同时滚动
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       @params {object} editor 编辑器
      </p>
     </li>
     <li>
      <p>
       @params {object} viewer 预览框
      </p>
     </li>
    </ul>
    <p>
     */
    </p>
    <p>
     function fixScrollBar(editor, viewer) {
     <!-- -->
    </p>
    <p>
     var session = editor.getSession();
    </p>
    <p>
     // 默认滚动到第一行
    </p>
    <h4>
     <a id="_530">
     </a>
     文末
    </h4>
    <p>
     技术是没有终点的，也是学不完的，最重要的是活着、不秃。
    </p>
    <p>
     零基础入门的时候看书还是看视频，我觉得成年人，何必做选择题呢，两个都要。喜欢看书就看书，喜欢看视频就看视频。
    </p>
    <p>
     最重要的是在自学的过程中，一定不要眼高手低，要实战，把学到的技术投入到项目当中，解决问题，之后进一步锤炼自己的技术。
    </p>
    <p>
     自学最怕的就是缺乏自驱力，一定要自律，杜绝“三天打鱼两天晒网”，到最后白忙活一场。
    </p>
    <p>
     高度自律的同时，要保持耐心，不抛弃不放弃，切勿自怨自艾，每天给自己一点点鼓励，学习的劲头就会很足，不容易犯困。
    </p>
    <p>
     技术学到手后，找工作的时候一定要好好准备一份简历，不要无头苍蝇一样去海投简历，容易“竹篮打水一场空”。好好的准备一下简历，毕竟是找工作的敲门砖。
    </p>
    <p>
     拿到面试邀请后，在面试的过程中一定要大大方方，尽力把自己学到的知识舒适地表达出来，不要因为是自学就不够自信，给面试官一个好的印象，面试成功的几率就会大很多，加油吧，骚年！
    </p>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618166371">
       开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
      </a>
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343631363533332f:61727469636c652f64657461696c732f313338353433303531" class_="artid" style="display:none">
 </p>
</div>


