---
layout: post
title: "JVM系统变量的妙用"
date: 2025-03-14 16:15:13 +0800
description: "JVM系统变量使用指南"
keywords: "JVM系统变量的妙用"
categories: ['Java']
tags: ['Jvm', 'Java']
artid: "146257475"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257475
    alt: "JVM系统变量的妙用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257475
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257475
cover: https://bing.ee123.net/img/rand?artid=146257475
image: https://bing.ee123.net/img/rand?artid=146257475
img: https://bing.ee123.net/img/rand?artid=146257475
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM系统变量的妙用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     JVM系统变量说明
    </h3>
    <p>
     在java应用中，JVM系统变量指的是通过
     <strong>
      System.getProperty("xxx")
     </strong>
     能获取的变量。可以通过在jvm的启动参数中添加
     <strong>
      -Dkey=value
     </strong>
     来进行键值对的配置。其灵活性和高优先级特性可以使其成为解决复杂场景问题中的“瑞士军刀”。
    </p>
    <p>
     JVM系统变量有如下的优势
    </p>
    <ul>
     <li>
      <strong>
       优先级最高
      </strong>
      ，大于配置文件（如application.yml）
     </li>
     <li>
      <strong>
       即使生效
      </strong>
      ，无需等待spring框架初始化就可以使用
     </li>
     <li>
      <strong>
       跨平台通用
      </strong>
      ，jvm启动时注入，与操作系统无关
     </li>
    </ul>
    <p>
     接下来看一下JVM参数使用
    </p>
    <h3>
     JVM系统变量使用
    </h3>
    <p>
     一个简单的springboot项目配置如下
    </p>
    <pre><code class="language-XML">server:
  port: 9091

mybatis:
  typeAliasesPackage: com.tml.mouseDemo.model
  mapperLocations: classpath:mapper/*.xml

spring:
  datasource:
    driver-class-name: org.h2.Driver
    url: jdbc:h2:mem:db_users;MODE=MYSQL;INIT=RUNSCRIPT FROM 'classpath:sql/init.sql'
    username: tml
    password: helloTml
  h2:
    console:
      enabled: true

  logging:
    level:
      com.tml.mouseDemo.data.*: debug
    config: classpath:logback.xml


tml:
  name : helloWorld
</code></pre>
    <p>
     一个简单的测试类
    </p>
    <pre><code class="language-java">package com.tml.mouseDemo.job;

import com.tml.mouseDemo.mapper.UserMapper;
import com.tml.mouseDemo.model.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@Slf4j
public class MyCoreJob {

    @Autowired
    private UserMapper userMapper;

    @Value("${tml.name:}")
    private String name;

    @Scheduled(cron = "0/10 * * * * ?")
    public void testOk(){
        log.info("testOk,name:{}", name);
        List&lt;User&gt; list = userMapper.listByName("tml");
        log.info("oneUser:{}", list.size());
    }
}
</code></pre>
    <p>
     直接运行springboot主类，运行结果，如下
    </p>
    <p>
     <img alt="" height="282" src="https://i-blog.csdnimg.cn/direct/a27529edbcc240ada0c84acc72c6e03f.png" width="1653"/>
    </p>
    <p>
     现在在启动参数中增加JVM系统变量，如下
    </p>
    <p>
     <img alt="" height="699" src="https://i-blog.csdnimg.cn/direct/573fa48924ef433083115c8d36649d5c.png" width="794">
     </img>
    </p>
    <p>
     运行结果如下
    </p>
    <p>
     <img alt="" height="466" src="https://i-blog.csdnimg.cn/direct/0317f10479d74dc291ee1a963e526ec5.png" width="1513">
     </img>
    </p>
    <p>
     从这个简单的代码案例中，可以发现JVM系统变量的优先级确实是高于application.yml配置文件的，可以通过这个来覆盖配置文件中的变量。
    </p>
    <p>
    </p>
    <p>
     生效时间块，这个是毫无疑问的，可以利用这个特点，在框架中去使用。比如在logback框架中就有读取JVM系统变量的值
    </p>
    <p>
     <img alt="" height="735" src="https://i-blog.csdnimg.cn/direct/5c69bdfb019442909ea64695749ed472.png" width="1551"/>
    </p>
    <p>
     需要注意的是，获取jvm系统变量可能会出现运行时异常SecurityException，为了保障系统的健壮，需要手动处理这个异常，避免将异常抛给调用方。
    </p>
    <pre><code class="language-java">    /**
     * Very similar to &lt;code&gt;System.getProperty&lt;/code&gt; except that the
     * {@link SecurityException} is absorbed.
     *
     * @param key The key to search for.
     * @return the string value of the system property.
     */
    public static String getSystemProperty(String key) {
        try {
            return System.getProperty(key);
        } catch (SecurityException e) {
            return null;
        }
    }</code></pre>
    <h3>
     JVM系统变量应用场景示例
    </h3>
    <h4>
     利用灵活的配置属性调整代码逻辑
    </h4>
    <p>
     比如，在一个需要登录的web系统中，为了方便本地测试，可能会注释掉与权限相关的代码逻辑，这样做是没有问题的，但是不够好，可能会把注释的代码也提交上去了，这个时候，就可以使用System.getProperties("xxx")来进行优化代码，本地启动的时候添加对应的jvm参数，生产环境去掉这个jvm参数
    </p>
    <p>
     这样做的好处就是，大家直接将代码clone下来，就能本地debug调试，而不需要本地做额外的一些代码修改，大大提升效率
    </p>
    <p>
     比如这样
    </p>
    <pre><code class="language-java">public class AuthInterceptor implements HandlerInterceptor {
    
    // 定义系统属性的Key（避免硬编码字符串）
    private static final String AUTH_DISABLE_KEY = "auth.disable";
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 检查是否启用了权限绕过开关
        if (Boolean.parseBoolean(System.getProperty(AUTH_DISABLE_KEY, "false"))) {
            return true; // 本地测试跳过所有权限校验
        }
        
        // 正式环境的权限校验逻辑
        User user = (User) request.getAttribute("currentUser");
        if (!user.hasPermission("admin")) {
            throw new AuthException("无权限访问");
        }
        return true;
    }
}</code></pre>
    <p>
     本地的jvm启动
    </p>
    <blockquote>
     <p>
      # 添加JVM参数临时禁用权限校验
      <br/>
      java -Dauth.disable=true -jar app.jar
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     生产环境的jvm启动
    </p>
    <blockquote>
     <p>
      # 不添加参数，权限校验正常生效
      <br/>
      java -jar app.jar
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     元数据传递标识身份
    </h4>
    <blockquote>
     <p>
      # 为微服务实例添加唯一标识
      <br/>
      java -Dapp.instance.id=$(uuidgen) -jar app.jar
     </p>
    </blockquote>
    <p>
     注意：这里的uuidgen是一个linux bash命令，返回的是一个uuid的字符串
    </p>
    <p>
     在日志和Metrics中携带实例ID，便于分布式追踪和监控
    </p>
    <p>
    </p>
    <h3>
     JVM系统变量注意事项
    </h3>
    <p>
     在使用jvm系统变量的时候，需要注意点如下
    </p>
    <ol>
     <li>
      避免错误的覆盖，在配置jvm参数的时候，全局检索一下
     </li>
     <li>
      注意System.getProperties()可能会抛出SecurityException带来的问题
     </li>
    </ol>
    <p>
     那么，朋友们，你们在使用JVM系统变量来解决什么问题呢？欢迎评论区留言~
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f7469616e6d6c696e312f:61727469636c652f64657461696c732f313436323537343735" class_="artid" style="display:none">
 </p>
</div>


