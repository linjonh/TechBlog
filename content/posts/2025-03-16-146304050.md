---
layout: post
title: "AgentOpenManus-Prompt组件详细分析"
date: 2025-03-16 23:45:43 +0800
description: "openManus Prompt组件的详细分析"
keywords: "【Agent】OpenManus-Prompt组件详细分析"
categories: ['Ai']
tags: ['架构', 'Prompt', 'Openmanus', 'Manus', 'Ai', 'Agi', 'Agent']
artid: "146304050"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146304050
    alt: "AgentOpenManus-Prompt组件详细分析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146304050
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146304050
cover: https://bing.ee123.net/img/rand?artid=146304050
image: https://bing.ee123.net/img/rand?artid=146304050
img: https://bing.ee123.net/img/rand?artid=146304050
---

# 【Agent】OpenManus-Prompt组件详细分析

### 1\. 提示词架构概述

OpenManus 的提示词组件采用了模块化设计，为不同类型的智能体提供专门的提示词模板。每个提示词模块通常包含两种核心提示词：系统提示词（System
Prompt）和下一步提示词（Next Step
Prompt）。这种设计使得提示词可以独立于智能体代码进行管理和优化，同时保持了提示词与智能体之间的紧密集成。

### 2\. 提示词类型与设计

#### 2.1 系统提示词 (System Prompt)

**设计特点** ：

  * 定义智能体的角色、能力和行为边界
  * 设置智能体的整体行为模式和交互风格
  * 通常较为简洁，专注于角色定义
  * 在智能体初始化时设置，整个会话期间保持不变

**使用场景** ：

  * 在智能体初始化时设置基础行为模式
  * 在 LLM 调用时作为系统消息传递

#### 2.2 下一步提示词 (Next Step Prompt)

**设计特点** ：

  * 指导智能体在每个步骤中的决策和行动
  * 提供可用工具的详细说明和使用指南
  * 通常较为详细，包含具体指令和约束
  * 在每个思考步骤中使用，可以动态更新

**使用场景** ：

  * 在每个 `think` 方法调用前添加到消息历史
  * 引导智能体选择合适的工具和行动
  * 提供上下文信息和决策指南

#### 2.3 模板提示词 (Template Prompt)

**设计特点** ：

  * 包含占位符，可以在运行时动态填充
  * 支持格式化字符串语法
  * 适用于需要动态内容的场景

**使用场景** ：

  * SWE 智能体中的工作目录和文件信息
  * 规划流程中的步骤执行提示

### 3\. 提示词调用流程

#### 3.1 智能体初始化

    
    
    # 在智能体类定义中设置提示词
    class Manus(ToolCallAgent):
        system_prompt: str = SYSTEM_PROMPT
        next_step_prompt: str = NEXT_STEP_PROMPT
    

  1. 提示词常量从相应模块导入
  2. 在智能体类定义中设置为类属性
  3. 可以在子类中覆盖或扩展

#### 3.2 思考过程中的提示词使用

    
    
    # ToolCallAgent.think 方法中的提示词使用
    async def think(self) -> bool:
        if self.next_step_prompt:
            user_msg = Message.user_message(self.next_step_prompt)
            self.messages += [user_msg]
        
        response = await self.llm.ask_tool(
            messages=self.messages,
            system_msgs=[Message.system_message(self.system_prompt)]
            if self.system_prompt
            else None,
            tools=self.available_tools.to_params(),
            tool_choice=self.tool_choices,
        )
    

  1. 如果存在下一步提示词，创建用户消息并添加到消息历史
  2. 调用 LLM 时，将系统提示词作为系统消息传递
  3. 同时传递工具参数和工具选择模式

#### 3.3 动态提示词处理

    
    
    # SWEAgent.think 方法中的动态提示词处理
    async def think(self) -> bool:
        # Update working directory
        self.working_dir = await self.bash.execute("pwd")
        self.next_step_prompt = self.next_step_prompt.format(
            current_dir=self.working_dir
        )
        
        return await super().think()
    

  1. 获取当前工作目录
  2. 使用 format 方法填充提示词模板中的占位符
  3. 调用父类的 think 方法继续处理

#### 3.4 规划流程中的提示词使用

    
    
    # PlanningFlow._create_initial_plan 方法中的提示词使用
    async def _create_initial_plan(self, request: str) -> None:
        # Create a system message for plan creation
        system_message = Message.system_message(
            "You are a planning assistant. Create a concise, actionable plan with clear steps. "
            "Focus on key milestones rather than detailed sub-steps. "
            "Optimize for clarity and efficiency."
        )
        
        # Create a user message with the request
        user_message = Message.user_message(
            f"Create a reasonable plan with clear steps to accomplish the task: {request}"
        )
        
        # Call LLM with PlanningTool
        response = await self.llm.ask_tool(
            messages=[user_message],
            system_msgs=[system_message],
            tools=[self.planning_tool.to_param()],
            tool_choice=ToolChoice.REQUIRED,
        )
    

  1. 创建特定于任务的系统消息
  2. 创建包含用户请求的用户消息
  3. 调用 LLM 时传递这些消息和工具参数

### 4\. LLM 接口中的提示词处理

#### 4.1 消息格式化

    
    
    # LLM.ask 方法中的消息处理
    async def ask(
        self,
        messages: List[Union[dict, Message]],
        system_msgs: Optional[List[Union[dict, Message]]] = None,
        stream: bool = True,
        temperature: Optional[float] = None,
    ) -> str:
        # Format system and user messages
        if system_msgs:
            system_msgs = self.format_messages(system_msgs)
            messages = system_msgs + self.format_messages(messages)
        else:
            messages = self.format_messages(messages)
    

  1. 接收消息和系统消息作为参数
  2. 使用 format_messages 方法将消息转换为标准格式
  3. 将系统消息添加到消息列表的开头

#### 4.2 工具调用提示词处理

    
    
    # LLM.ask_tool 方法中的工具提示词处理
    async def ask_tool(
        self,
        messages: List[Union[dict, Message]],
        system_msgs: Optional[List[Union[dict, Message]]] = None,
        timeout: int = 300,
        tools: Optional[List[dict]] = None,
        tool_choice: TOOL_CHOICE_TYPE = ToolChoice.AUTO,
        temperature: Optional[float] = None,
        **kwargs,
    ):
        # 类似的消息处理逻辑
        # 加上工具参数和工具选择模式
        if system_msgs:
            system_msgs = self.format_messages(system_msgs)
            messages = system_msgs + self.format_messages(messages)
        else:
            messages = self.format_messages(messages)
    

  1. 与 ask 方法类似的消息处理
  2. 额外传递工具参数和工具选择模式
  3. 支持超时和温度等参数

* * *

OpenManus
的提示词组件设计了一个灵活、模块化的提示词。通过将提示词与代码分离，同时保持紧密集成，它实现了提示词的可维护性和可扩展性。系统提示词和下一步提示词的组合，加上动态模板能力，使智能体能够适应各种任务和环境，同时保持一致的行为模式和交互风格。



