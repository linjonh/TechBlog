---
layout: post
title: "MySQL-优化方案"
date: 2025-03-12 20:57:04 +0800
description: "MySQL 查询过程是指从客户端发送 SQL 语句到 MySQL 服务器，再到服务器返回结果集的整个过程。这个过程涉及多个组件的协作，包括连接管理、查询解析、优化、执行和结果返回等。索引是提高查询性能的核心手段，但需要合理使用。查询缓存（MySQL 8.0 之前）优化查询语句本身可以显著提升性能。使用 LIMIT 时避免高偏移量。合理使用 IN 和 EXISTS。使用 EXPLAIN 分析查询。避免 SELECT *"
keywords: "MySQL 优化方案"
categories: ['数据库']
tags: ['Mysql']
artid: "146210642"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146210642
    alt: "MySQL-优化方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146210642
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146210642
cover: https://bing.ee123.net/img/rand?artid=146210642
image: https://bing.ee123.net/img/rand?artid=146210642
img: https://bing.ee123.net/img/rand?artid=146210642
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL 优化方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="MySQL__0">
     </a>
     一、MySQL 查询过程
    </h4>
    <p>
     MySQL 查询过程是指从客户端发送 SQL 语句到 MySQL 服务器，再到服务器返回结果集的整个过程。这个过程涉及多个组件的协作，包括连接管理、查询解析、优化、执行和结果返回等。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4f84c534139c36292f0dd558ff020079.png"/>
    </p>
    <h5>
     <a id="11__3">
     </a>
     1.1 查询过程的关键组件
    </h5>
    <ol>
     <li>
      连接管理器：管理客户端连接。
     </li>
     <li>
      解析器：解析 SQL 语句。
     </li>
     <li>
      优化器：生成执行计划。
     </li>
     <li>
      执行引擎：执行查询。
     </li>
     <li>
      存储引擎：存储和检索数据。
     </li>
    </ol>
    <h5>
     <a id="12__9">
     </a>
     1.2 查询过程的详细步骤
    </h5>
    <ol>
     <li>
      <p>
       客户端发送查询请求
      </p>
      <ul>
       <li>
        客户端（如应用程序、命令行工具）通过 MySQL 协议（如 TCP/IP）向 MySQL 服务器发送 SQL 查询请求。
       </li>
       <li>
        请求内容可以是 SELECT、INSERT、UPDATE、DELETE 等 SQL 语句。
       </li>
      </ul>
     </li>
     <li>
      <p>
       连接管理
      </p>
      <ul>
       <li>
        MySQL 服务器接收到请求后，首先由 连接管理器 处理。
       </li>
       <li>
        连接管理器负责：
        <ul>
         <li>
          验证客户端的用户名和密码。
         </li>
         <li>
          检查客户端的权限（是否有权限执行该查询）。
         </li>
         <li>
          分配一个线程来处理该请求（MySQL 是多线程架构，每个连接由一个线程处理）。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       查询缓存（MySQL 8.0 之前）
      </p>
      <ul>
       <li>
        在 MySQL 8.0 之前，服务器会检查查询缓存（Query Cache）。
        <ul>
         <li>
          如果查询缓存中已经存在该查询的结果，则直接返回缓存结果。
         </li>
         <li>
          如果查询缓存未命中，则继续后续步骤。
         </li>
        </ul>
       </li>
       <li>
        在MySQL 8.0 移除了查询缓存功能，因为在高并发场景下，查询缓存可能成为性能瓶颈。
       </li>
      </ul>
     </li>
     <li>
      <p>
       查询解析
      </p>
      <ul>
       <li>
        解析器（Parser） 对 SQL 语句进行词法分析和语法分析。
        <ul>
         <li>
          词法分析：将 SQL 语句拆分为关键字、表名、列名、操作符等 token。
         </li>
         <li>
          语法分析：检查 SQL 语句是否符合 MySQL 的语法规则。
         </li>
        </ul>
       </li>
       <li>
        如果 SQL 语句有语法错误，解析器会返回错误信息。
       </li>
      </ul>
     </li>
     <li>
      <p>
       查询优化
      </p>
      <ul>
       <li>
        查询优化器（Optimizer） 对 SQL 语句进行优化，生成一个高效的执行计划。
        <ul>
         <li>
          优化器会考虑以下因素：
          <ul>
           <li>
            使用哪些索引。
           </li>
           <li>
            表的连接顺序（JOIN 的顺序）。
           </li>
           <li>
            是否可以使用覆盖索引。
           </li>
           <li>
            是否可以使用索引合并（Index Merge）。
           </li>
          </ul>
         </li>
         <li>
          优化器会生成多个可能的执行计划，并选择成本最低的一个。
         </li>
        </ul>
       </li>
       <li>
        可以通过 EXPLAIN 命令查看优化器生成的执行计划。
       </li>
      </ul>
     </li>
     <li>
      <p>
       查询执行
      </p>
      <ul>
       <li>
        执行引擎（Execution Engine） 根据优化器生成的执行计划，调用存储引擎的接口执行查询。
        <ul>
         <li>
          执行引擎负责：
          <ul>
           <li>
            打开表。
           </li>
           <li>
            读取数据（通过索引或全表扫描）。
           </li>
           <li>
            执行排序、分组、聚合等操作。
           </li>
           <li>
            处理 JOIN 操作。
           </li>
          </ul>
         </li>
         <li>
          执行引擎与存储引擎（如 InnoDB、MyISAM）交互，获取数据。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       存储引擎处理
      </p>
      <ul>
       <li>
        存储引擎（Storage Engine） 负责数据的存储和检索。
        <ul>
         <li>
          存储引擎根据执行引擎的请求，从磁盘或内存中读取数据。
         </li>
         <li>
          存储引擎会将数据返回给执行引擎。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       结果返回
      </p>
      <ul>
       <li>
        执行引擎将处理后的数据返回给客户端。
        <ul>
         <li>
          如果查询涉及排序、分组或聚合，执行引擎会在返回结果前完成这些操作。
         </li>
         <li>
          结果集通过 MySQL 协议发送给客户端。
         </li>
        </ul>
       </li>
       <li>
        客户端接收到结果后，可以继续处理数据（如显示、存储或进一步计算）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       日志记录
      </p>
      <ul>
       <li>
        MySQL 会根据配置记录相关日志：
        <ul>
         <li>
          二进制日志（Binlog）：记录所有修改数据的操作（如 INSERT、UPDATE、DELETE），用于主从复制和数据恢复。
         </li>
         <li>
          慢查询日志（Slow Query Log）：记录执行时间超过阈值的查询，用于性能分析。
         </li>
         <li>
          通用日志（General Log）：记录所有查询请求，用于调试。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       连接关闭
      </p>
      <ul>
       <li>
        查询完成后，客户端可以选择关闭连接或继续发送新的查询请求。
       </li>
       <li>
        如果连接空闲时间超过 wait_timeout，MySQL 会自动关闭连接以释放资源。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="SQL__65">
     </a>
     二、SQL 优化方案
    </h4>
    <h5>
     <a id="21__66">
     </a>
     2.1 索引优化
    </h5>
    <p>
     索引是提高查询性能的核心手段，但需要合理使用。
    </p>
    <ol>
     <li>
      创建合适的索引
      <ul>
       <li>
        单列索引：对经常用于 WHERE、JOIN、ORDER BY 和 GROUP BY 的列创建索引。
        <pre><code class="prism language-bash">CREATE INDEX idx_name ON table_name<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
       </li>
       <li>
        复合索引：对多个列的组合查询创建复合索引。
        <pre><code class="prism language-bash">CREATE INDEX idx_name ON table_name<span class="token punctuation">(</span>column1, column2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
       </li>
       <li>
        前缀索引：对文本列的前缀创建索引，减少索引大小。
        <pre><code class="prism language-bash">CREATE INDEX idx_name ON table_name<span class="token punctuation">(</span>column_name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      避免过度索引
      <ul>
       <li>
        索引会增加写操作（INSERT、UPDATE、DELETE）的开销，因此不要为不常用的列创建索引。
       </li>
       <li>
        删除未使用或重复的索引。
        <pre><code class="prism language-bash">DROP INDEX idx_name ON table_name<span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      使用覆盖索引
      <ul>
       <li>
        如果查询只需要从索引中获取数据，而不需要回表查询数据行，可以显著提升性能。
        <pre><code class="prism language-bash">SELECT column1, column2 FROM table_name WHERE column1 <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span>
-- 确保 <span class="token punctuation">(</span>column1, column2<span class="token punctuation">)</span> 上有索引
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      避免索引失效
      <ol>
       <li>
        避免在索引列上使用函数或表达式
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE YEAR<span class="token punctuation">(</span>created_at<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：MySQL 无法对 YEAR(created_at) 使用索引，因为它需要对每一行的 created_at 进行计算。
         </li>
         <li>
          优化方法：
          <pre><code class="prism language-bash">-- 优化后
SELECT * FROM <span class="token function">users</span> WHERE created_at <span class="token operator">&gt;=</span> <span class="token string">'2023-01-01'</span> AND created_at <span class="token operator">&lt;</span> <span class="token string">'2024-01-01'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
        </ul>
       </li>
       <li>
        避免在索引列上使用 NOT、!= 或 &lt;&gt;
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE status <span class="token operator">!=</span> <span class="token string">'active'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：NOT、!= 或 &lt;&gt; 需要扫描所有不等于条件的值，无法有效利用索引。
         </li>
         <li>
          优化方法：尽量避免使用 !=，尝试改写查询逻辑。
         </li>
        </ul>
       </li>
       <li>
        避免在索引列上使用 OR 条件
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE age <span class="token operator">=</span> <span class="token number">25</span> OR name <span class="token operator">=</span> <span class="token string">'John'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：如果 name 列没有索引，MySQL 无法使用 age 列的索引。
         </li>
         <li>
          优化方法：
          <pre><code class="prism language-bash">-- 优化后
SELECT * FROM <span class="token function">users</span> WHERE age <span class="token operator">=</span> <span class="token number">25</span>
UNION
SELECT * FROM <span class="token function">users</span> WHERE name <span class="token operator">=</span> <span class="token string">'John'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
        </ul>
       </li>
       <li>
        避免在索引列上使用 LIKE 以通配符开头
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE name LIKE <span class="token string">'%John%'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：当通配符%出现在查询字符串的开头时，MySQL无法利用索引的前缀部分来加速查询。
         </li>
         <li>
          优化方法：
          <ul>
           <li>
            尽量避免以 % 开头的模糊查询。
           </li>
           <li>
            如果必须使用，考虑全文索引（FULLTEXT）或其他搜索引擎（如 Elasticsearch）。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        避免数据类型不匹配
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE phone <span class="token operator">=</span> <span class="token number">123456789</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：如果 phone 列是字符串类型，而查询条件是数字类型，MySQL 会对索引字段进行隐式类型转换，导致索引失效。
         </li>
         <li>
          优化方法：
          <pre><code class="prism language-bash">-- 优化后
SELECT * FROM <span class="token function">users</span> WHERE phone <span class="token operator">=</span> <span class="token string">'123456789'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
        </ul>
       </li>
       <li>
        避免复合索引未遵循最左前缀原则
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 创建复合索引
CREATE INDEX idx_name_age ON users<span class="token punctuation">(</span>name, age<span class="token punctuation">)</span><span class="token punctuation">;</span>

-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：没有遵循最左前缀原则，MySQL 无法利用复合索引的有序性，从而导致索引失效。
         </li>
         <li>
          优化方法：确保查询条件包含复合索引的最左列。
          <pre><code class="prism language-bash">-- 优化后
SELECT * FROM <span class="token function">users</span> WHERE name <span class="token operator">=</span> <span class="token string">'John'</span> AND age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</code></pre>
         </li>
        </ul>
       </li>
       <li>
        避免在低区分度的字段上建索引
        <ul>
         <li>
          示例：
          <pre><code class="prism language-bash">-- 索引失效
SELECT * FROM <span class="token function">users</span> WHERE sex <span class="token operator">=</span> <span class="token string">'男'</span><span class="token punctuation">;</span>
</code></pre>
         </li>
         <li>
          原因：在低区分度的字段上，索引树中每个键值对应的数据行数非常多。查询时，MySQL 需要扫描大量数据行，索引的效果几乎等同于全表扫描。
         </li>
         <li>
          优化方法：尽量避免对低选择性的列创建索引。
         </li>
        </ul>
       </li>
      </ol>
     </li>
    </ol>
    <h5>
     <a id="22__175">
     </a>
     2.2 查询重构
    </h5>
    <p>
     优化查询语句本身可以显著提升性能。
    </p>
    <ol>
     <li>
      <p>
       避免 SELECT *
      </p>
      <ul>
       <li>
        只选择需要的列，减少数据传输和内存占用。
        <pre><code class="prism language-bash">-- 不推荐
SELECT * FROM table_name<span class="token punctuation">;</span>
-- 推荐
SELECT column1, column2 FROM table_name<span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       使用 LIMIT 时避免高偏移量
      </p>
      <ul>
       <li>
        当 OFFSET 值很大时，MySQL 需要扫描大量数据才能找到起始位置，导致性能下降。
        <pre><code class="prism language-bash">-- 不推荐
SELECT * FROM table_name LIMIT <span class="token number">10</span> OFFSET <span class="token number">100000</span><span class="token punctuation">;</span>
-- 推荐
SELECT * FROM table_name WHERE <span class="token function">id</span> <span class="token operator">&gt;</span> <span class="token number">100000</span> ORDER BY <span class="token function">id</span> LIMIT <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       避免子查询
      </p>
      <ul>
       <li>
        子查询的内部执行计划是先执行子查询再执行外层查询，由于每次执行子查询都需要创建并删除临时表，会消耗大量资源，从而影响数据库性能。
        <pre><code class="prism language-bash">-- 不推荐
SELECT * FROM table_name WHERE column1 IN <span class="token punctuation">(</span>SELECT column1 FROM table2<span class="token punctuation">)</span><span class="token punctuation">;</span>
-- 推荐
SELECT t1.* FROM table_name t1 JOIN table2 t2 ON t1.column1 <span class="token operator">=</span> t2.column1<span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       JOIN 查询优化
      </p>
      <ul>
       <li>
        确保 JOIN 列上有索引：JOIN 条件中的列（通常是外键列）必须有索引。
       </li>
       <li>
        小表驱动大表：MySQL 通常会选择较小的表作为驱动表，以减少扫描的行数。
       </li>
       <li>
        过滤数据：在 JOIN 之前，使用 WHERE 条件减少参与 JOIN 的数据量。
        <pre><code class="prism language-bash">SELECT * FROM table1 t1
JOIN table2 t2 ON t1.id <span class="token operator">=</span> t2.id
WHERE t1.column <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       合理使用 IN 和 EXISTS
      </p>
      <ul>
       <li>
        IN
        <ul>
         <li>
          用法：用于判断某个值是否在子查询返回的结果集中。
         </li>
         <li>
          适用场景：当子查询返回的结果集较小时，IN 的性能较好。
         </li>
         <li>
          执行过程：
          <ol>
           <li>
            执行子查询，获取结果集。
           </li>
           <li>
            将结果集加载到内存中。
           </li>
           <li>
            对外部查询的每一行，检查是否在结果集中。
           </li>
          </ol>
         </li>
        </ul>
       </li>
       <li>
        EXISTS
        <ul>
         <li>
          用法：用于判断子查询是否返回任何行。如果子查询返回至少一行，EXISTS 返回 TRUE，否则返回 FALSE。
         </li>
         <li>
          适用场景：当子查询返回的结果集较大时，EXISTS 的性能较好。
         </li>
         <li>
          执行过程：
          <ul>
           <li>
            对外部查询的每一行，执行子查询。
           </li>
           <li>
            如果子查询返回至少一行，则返回 TRUE。
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       使用 EXPLAIN 分析查询
      </p>
      <ul>
       <li>
        使用 EXPLAIN 查看查询执行计划，找出性能瓶颈。
       </li>
       <li>
        关注 type（访问类型）、key（使用的索引）、rows（扫描的行数）等字段。
        <pre><code class="prism language-bash">EXPLAIN SELECT * FROM table_name WHERE column1 <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="23__232">
     </a>
     2.3 表结构优化
    </h5>
    <ol>
     <li>
      选择合适的数据类型
      <ul>
       <li>
        使用最小的数据类型存储数据，例如：
        <ul>
         <li>
          使用 INT 而不是 BIGINT。
         </li>
         <li>
          使用 VARCHAR 而不是 TEXT。
         </li>
        </ul>
       </li>
       <li>
        避免使用 NULL，尽量使用默认值。
       </li>
      </ul>
     </li>
     <li>
      规范化与反规范化
      <ul>
       <li>
        规范化：减少数据冗余，提高数据一致性。
       </li>
       <li>
        反规范化：在查询频繁的场景下，适当冗余数据以减少 JOIN 操作。
       </li>
      </ul>
     </li>
     <li>
      分区表
      <ul>
       <li>
        对大表进行分区，提升查询性能。
        <pre><code class="prism language-bash">CREATE TABLE table_name <span class="token punctuation">(</span>
	<span class="token function">id</span> INT,
	created_at DATE
<span class="token punctuation">)</span> PARTITION BY RANGE <span class="token punctuation">(</span>YEAR<span class="token punctuation">(</span>created_at<span class="token punctuation">))</span> <span class="token punctuation">(</span>
	PARTITION p0 VALUES LESS THAN <span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">)</span>,
	PARTITION p1 VALUES LESS THAN <span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">)</span>,
	PARTITION p2 VALUES LESS THAN <span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="24__254">
     </a>
     2.4 配置优化
    </h5>
    <ol>
     <li>
      调整缓冲区大小
      <ul>
       <li>
        增加 innodb_buffer_pool_size，使其足够容纳常用数据。
        <pre><code class="prism language-bash">SET GLOBAL innodb_buffer_pool_size <span class="token operator">=</span> 1G<span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      调整查询缓存
      <ul>
       <li>
        在 MySQL 8.0 之前，可以启用查询缓存（适用于读多写少的场景）。
        <pre><code class="prism language-bash">SET GLOBAL query_cache_size <span class="token operator">=</span> 64M<span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      调整连接数
      <ul>
       <li>
        增加最大连接数，避免连接耗尽。
        <pre><code class="prism language-bash">SET GLOBAL max_connections <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      调整日志配置
      <ul>
       <li>
        关闭不必要的日志（如慢查询日志、二进制日志）以减少 I/O 开销。
        <pre><code class="prism language-bash">SET GLOBAL slow_query_log <span class="token operator">=</span> OFF<span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="25__275">
     </a>
     2.5 其他优化技巧
    </h5>
    <ol>
     <li>
      批量操作
      <ul>
       <li>
        使用批量插入或更新，减少单条语句的开销。
        <pre><code class="prism language-bash">INSERT INTO table_name <span class="token punctuation">(</span>column1, column2<span class="token punctuation">)</span> VALUES <span class="token punctuation">(</span><span class="token string">'value1'</span>, <span class="token string">'value2'</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token string">'value3'</span>, <span class="token string">'value4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      使用缓存
      <ul>
       <li>
        使用 Redis 或 Memcached 缓存热点数据，减少数据库压力。
       </li>
      </ul>
     </li>
     <li>
      分库分表
      <ul>
       <li>
        对于超大规模数据，考虑分库分表（如使用 ShardingSphere 或 MyCat）。
       </li>
      </ul>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33333830373338302f:61727469636c652f64657461696c732f313436323130363432" class_="artid" style="display:none">
 </p>
</div>


