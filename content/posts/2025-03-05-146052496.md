---
layout: post
title: "FPGA基础-Verilog常用关键字"
date: 2025-03-05 20:44:37 +0800
description: "Verilog 是一种硬件描述语言（HDL），用于描述和设计数字电路。组成，每个模块表示一个硬件单元，具有输入和输出端口。组合逻辑直接由输入信号决定输出信号，不依赖时钟。用于验证 Verilog 设计的正确性。语句在仿真时执行一次，常用于仿真测试。时序逻辑依赖时钟信号，通常使用。Verilog 代码通常由。"
keywords: "FPGA基础 -- Verilog常用关键字"
categories: ['Fpga']
tags: ['Fpga']
artid: "146052496"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146052496
    alt: "FPGA基础-Verilog常用关键字"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146052496
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146052496
cover: https://bing.ee123.net/img/rand?artid=146052496
image: https://bing.ee123.net/img/rand?artid=146052496
img: https://bing.ee123.net/img/rand?artid=146052496
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     FPGA基础 -- Verilog常用关键字
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     Verilog 是一种硬件描述语言（HDL），用于描述和设计数字电路。下面是 Verilog 的常用语法和关键概念：
    </p>
    <hr/>
    <h3>
     <a id="1_Verilog__4">
     </a>
     <strong>
      1. Verilog 设计结构
     </strong>
    </h3>
    <p>
     Verilog 代码通常由
     <strong>
      模块（module）
     </strong>
     组成，每个模块表示一个硬件单元，具有输入和输出端口。
    </p>
    <pre><code class="prism language-verilog">module and_gate (
    input wire a,       // 输入信号 a
    input wire b,       // 输入信号 b
    output wire y       // 输出信号 y
);
    assign y = a &amp; b;   // 逻辑与操作
endmodule
</code></pre>
    <ul>
     <li>
      <strong>
       <code>
        module
       </code>
      </strong>
      定义一个模块
     </li>
     <li>
      <strong>
       <code>
        input
       </code>
       /
       <code>
        output
       </code>
      </strong>
      定义输入输出端口
     </li>
     <li>
      <strong>
       <code>
        assign
       </code>
      </strong>
      进行组合逻辑赋值
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="2__23">
     </a>
     <strong>
      2. 变量类型
     </strong>
    </h3>
    <p>
     Verilog 变量用于存储信号值，常见变量类型：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        wire
       </code>
      </strong>
      —— 组合逻辑信号（无存储能力）
     </li>
     <li>
      <strong>
       <code>
        reg
       </code>
      </strong>
      —— 触发器存储信号（用于时序逻辑）
     </li>
     <li>
      <strong>
       <code>
        integer
       </code>
      </strong>
      —— 存储整数（常用于循环变量）
     </li>
    </ul>
    <p>
     示例：
    </p>
    <pre><code class="prism language-verilog">wire a, b, y;     // 组合逻辑信号
reg clk, rst;     // 时序信号
integer i;        // 整数变量
</code></pre>
    <hr/>
    <h3>
     <a id="3__38">
     </a>
     <strong>
      3. 组合逻辑
     </strong>
    </h3>
    <p>
     组合逻辑直接由输入信号决定输出信号，不依赖时钟。
    </p>
    <h4>
     <a id="31_assign__41">
     </a>
     <strong>
      3.1
      <code>
       assign
      </code>
      语句
     </strong>
    </h4>
    <pre><code class="prism language-verilog">assign y = a &amp; b;  // 逻辑与运算
assign s = a ^ b;  // 异或运算
assign c = (a &amp; b) | (b &amp; c_in) | (a &amp; c_in);  // 组合逻辑表达式
</code></pre>
    <h4>
     <a id="32_always___48">
     </a>
     <strong>
      3.2
      <code>
       always @(*)
      </code>
      组合逻辑块
     </strong>
    </h4>
    <pre><code class="prism language-verilog">always @(*) begin
    y = a &amp; b;  // 组合逻辑
end
</code></pre>
    <hr/>
    <h3>
     <a id="4__57">
     </a>
     <strong>
      4. 时序逻辑
     </strong>
    </h3>
    <p>
     时序逻辑依赖时钟信号，通常使用
     <code>
      always @(posedge clk)
     </code>
     定义。
    </p>
    <pre><code class="prism language-verilog">always @(posedge clk or negedge rst) begin
    if (!rst)
        q &lt;= 0;  // 复位
    else
        q &lt;= d;  // D 触发器
end
</code></pre>
    <ul>
     <li>
      <strong>
       <code>
        posedge clk
       </code>
      </strong>
      表示在
      <strong>
       时钟上升沿
      </strong>
      触发
     </li>
     <li>
      <strong>
       <code>
        negedge rst
       </code>
      </strong>
      表示
      <strong>
       复位信号下降沿
      </strong>
      触发
     </li>
     <li>
      <strong>
       <code>
        &lt;=
       </code>
      </strong>
      非阻塞赋值（用于寄存器存储）
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="5__74">
     </a>
     <strong>
      5. 条件语句
     </strong>
    </h3>
    <h4>
     <a id="51_ifelse__75">
     </a>
     <strong>
      5.1
      <code>
       if-else
      </code>
      语句
     </strong>
    </h4>
    <pre><code class="prism language-verilog">always @(posedge clk) begin
    if (a == 1'b1)
        y &lt;= 1'b1;
    else
        y &lt;= 1'b0;
end
</code></pre>
    <h4>
     <a id="52_case__85">
     </a>
     <strong>
      5.2
      <code>
       case
      </code>
      语句
     </strong>
    </h4>
    <pre><code class="prism language-verilog">always @(posedge clk) begin
    case (sel)
        2'b00: y &lt;= a;
        2'b01: y &lt;= b;
        2'b10: y &lt;= c;
        default: y &lt;= 0;
    endcase
end
</code></pre>
    <hr/>
    <h3>
     <a id="6__99">
     </a>
     <strong>
      6. 循环结构
     </strong>
    </h3>
    <h4>
     <a id="61_for__100">
     </a>
     <strong>
      6.1
      <code>
       for
      </code>
      循环
     </strong>
    </h4>
    <pre><code class="prism language-verilog">integer i;
always @(posedge clk) begin
    for (i = 0; i &lt; 8; i = i + 1) begin
        mem[i] &lt;= data[i];
    end
end
</code></pre>
    <h4>
     <a id="62_while__110">
     </a>
     <strong>
      6.2
      <code>
       while
      </code>
      循环
     </strong>
    </h4>
    <pre><code class="prism language-verilog">integer i = 0;
always @(posedge clk) begin
    while (i &lt; 8) begin
        mem[i] &lt;= data[i];
        i = i + 1;
    end
end
</code></pre>
    <hr/>
    <h3>
     <a id="7__123">
     </a>
     <strong>
      7. 进程间通信
     </strong>
    </h3>
    <h4>
     <a id="71_initial__124">
     </a>
     <strong>
      7.1
      <code>
       initial
      </code>
      语句
     </strong>
    </h4>
    <p>
     <code>
      initial
     </code>
     语句在仿真时执行一次，常用于仿真测试。
    </p>
    <pre><code class="prism language-verilog">initial begin
    a = 0; b = 1;
    #10 a = 1;  // 10 时间单位后 a 变为 1
    #20 b = 0;  // 20 时间单位后 b 变为 0
end
</code></pre>
    <h4>
     <a id="72_always__135">
     </a>
     <strong>
      7.2
      <code>
       always
      </code>
      语句
     </strong>
    </h4>
    <pre><code class="prism language-verilog">always @(posedge clk) begin
    y &lt;= a &amp; b;
end
</code></pre>
    <hr/>
    <h3>
     <a id="8__144">
     </a>
     <strong>
      8. 任务和函数
     </strong>
    </h3>
    <h4>
     <a id="81_task__145">
     </a>
     <strong>
      8.1
      <code>
       task
      </code>
      任务
     </strong>
    </h4>
    <p>
     任务
     <code>
      task
     </code>
     可以有多个输入输出参数：
    </p>
    <pre><code class="prism language-verilog">task add;
    input a, b;
    output sum;
    begin
        sum = a + b;
    end
endtask
</code></pre>
    <h4>
     <a id="82_function__157">
     </a>
     <strong>
      8.2
      <code>
       function
      </code>
      函数
     </strong>
    </h4>
    <p>
     <code>
      function
     </code>
     只能返回一个值：
    </p>
    <pre><code class="prism language-verilog">function [3:0] add;
    input [3:0] a, b;
    add = a + b;
endfunction
</code></pre>
    <hr/>
    <h3>
     <a id="9_Testbench_168">
     </a>
     <strong>
      9. 测试平台（Testbench）
     </strong>
    </h3>
    <p>
     <strong>
      测试平台
     </strong>
     用于验证 Verilog 设计的正确性。
    </p>
    <pre><code class="prism language-verilog">module testbench;
    reg a, b;
    wire y;

    and_gate uut (.a(a), .b(b), .y(y));  // 连接被测模块

    initial begin
        a = 0; b = 0;
        #10 a = 1;
        #10 b = 1;
        #10 a = 0; b = 0;
        #10 $stop;  // 结束仿真
    end
endmodule
</code></pre>
    <hr/>
    <h3>
     <a id="10__189">
     </a>
     <strong>
      10. 关键语法总结
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        语法
       </th>
       <th>
        说明
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         module
        </code>
       </td>
       <td>
        定义模块
       </td>
       <td>
        <code>
         module my_module(); ... endmodule
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         input
        </code>
        /
        <code>
         output
        </code>
       </td>
       <td>
        端口定义
       </td>
       <td>
        <code>
         input a, b; output y;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         wire
        </code>
       </td>
       <td>
        组合逻辑信号
       </td>
       <td>
        <code>
         wire a, b, y;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         reg
        </code>
       </td>
       <td>
        时序逻辑信号
       </td>
       <td>
        <code>
         reg clk, rst;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         assign
        </code>
       </td>
       <td>
        组合逻辑赋值
       </td>
       <td>
        <code>
         assign y = a &amp; b;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         always @(*)
        </code>
       </td>
       <td>
        组合逻辑块
       </td>
       <td>
        <code>
         always @(*) y = a &amp; b;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         always @(posedge clk)
        </code>
       </td>
       <td>
        时序逻辑块
       </td>
       <td>
        <code>
         always @(posedge clk) q &lt;= d;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         if-else
        </code>
       </td>
       <td>
        条件判断
       </td>
       <td>
        <code>
         if (a) y = 1; else y = 0;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         case
        </code>
       </td>
       <td>
        多路选择
       </td>
       <td>
        <code>
         case(sel) 2'b00: y = a; endcase
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         for
        </code>
       </td>
       <td>
        循环
       </td>
       <td>
        <code>
         for (i = 0; i &lt; 8; i = i + 1)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         task
        </code>
       </td>
       <td>
        任务
       </td>
       <td>
        <code>
         task add(input a, b, output sum);
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         function
        </code>
       </td>
       <td>
        函数
       </td>
       <td>
        <code>
         function [3:0] add(input [3:0] a, b);
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         initial
        </code>
       </td>
       <td>
        初始化块
       </td>
       <td>
        <code>
         initial begin a = 0; #10 a = 1; end
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <a id="_208">
     </a>
     <strong>
      总结
     </strong>
    </h3>
    <ol>
     <li>
      <strong>
       Verilog 是硬件描述语言（HDL），主要用于 FPGA/ASIC 设计
      </strong>
      。
     </li>
     <li>
      <strong>
       使用
       <code>
        module
       </code>
       组织代码，每个模块表示一个硬件单元
      </strong>
      。
     </li>
     <li>
      <strong>
       <code>
        wire
       </code>
       表示组合逻辑，
       <code>
        reg
       </code>
       表示寄存器存储
      </strong>
      。
     </li>
     <li>
      <strong>
       组合逻辑使用
       <code>
        assign
       </code>
       或
       <code>
        always @(*)
       </code>
       ，时序逻辑使用
       <code>
        always @(posedge clk)
       </code>
      </strong>
      。
     </li>
     <li>
      <strong>
       支持
       <code>
        if-else
       </code>
       、
       <code>
        case
       </code>
       、
       <code>
        for
       </code>
       等控制结构
      </strong>
      。
     </li>
     <li>
      <strong>
       <code>
        initial
       </code>
       用于仿真，
       <code>
        always
       </code>
       用于时序逻辑
      </strong>
      。
     </li>
     <li>
      <strong>
       <code>
        task
       </code>
       和
       <code>
        function
       </code>
       提供代码复用能力
      </strong>
      。
     </li>
     <li>
      <strong>
       测试平台
       <code>
        testbench
       </code>
       用于验证设计
      </strong>
      。
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f737a3636636d2f:61727469636c652f64657461696c732f313436303532343936" class_="artid" style="display:none">
 </p>
</div>


