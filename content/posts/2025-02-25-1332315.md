---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6c656e677869616f5f77616e:672f61727469636c652f64657461696c732f31333332333135"
layout: post
title: "远离微软"
date: 2025-02-25 08:48:51 +0800
description: "         今天,在csdn上读了《告别Win32，你准备好了吗?》，心里觉得十分不爽，如果正"
keywords: "远离微软"
categories: ['读书随感']
tags: ['微软', '图形', 'Windows', 'Microsoft', 'Java', '.Net']
artid: "1332315"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=1332315
    alt: "远离微软"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=1332315
featuredImagePreview: https://bing.ee123.net/img/rand?artid=1332315
---

# 远离微软

今天,在csdn上读了《告别Win32，你准备好了吗?》，心里觉得十分不爽，如果正如该文章所言——windows如果真是强迫所有的程序员转到.Net平台，那么，我想，是时候远离微软了， 是的，作为程序员，我们在windows这片土地上耕耘得太久了，这里除了微软本身的强大而外，对开发人员热情而慷慨的支持外，也正是因为我们的对其的依恋成就了微软，成就了它作为windows程序员的统治者的地位，然而，作为一个程序员，这个被认为充满个性的领域，我们是不是忍得太久了？
  
对于Vista ，我充满疑虑，首先，是不是今后我们都不得在.Net上进行我们的程序开发，而那个被称作.Net FrameWork 的东西是不是成为我们和操作系统之间的唯一界面？是不是我们今后所有的东西（特别是有高性能需求的软件）是不是都不得不在此之上完成？而那个被称作. Net的东西能否完成开发者的需求。我们还能否象以前一样使用C/C++,甚至汇编优雅地来完成那些充满挑战的高性能编程？我们还能否写这样的语句 char strArray1[n]，

strArray2[n]

；然后在函数调用时只需传递两个指向数组

strArray1

，

strArray2的

指针p1,p2，有时为了交换p1,p2两个缓冲区的数据（例如，屏幕的当前帧的数据是下一帧数据的计算起点）时候只需要 char\* temp; temp =

p2

;

p2

=

p1
;
p1

=

temp

;就可以优雅快速地完成我们的工作？是的，假设这一切如果还都可以，那么我们时候还有理由怀疑微软在那个所谓的指针后面是否在做了很多工作？指针的使用对于我们是否还有

提高

性能的

意义？
  
注意了，可怜的Windows的忠实拥护者（其实之前我也一样），让我们一起粗略地回顾一下微软的发家史，以及这个Microsoft是怎么一步步的将我 们绑定在windows之上 ，首先是dos,一个不得不提的操作系统，那是一个单任务的操作系统，程序员可以通过中断来优先自己对CPU的掌控，那时，Dos是一个可爱的平民形象。 接着是win3.1,我更倾向于win3.1给我们带来的“新奇”大于它给我们的“方便”，然而，我们对图形界面充满了期待与渴望，顺利成章，微软以一种 极富亲和力的姿态让许多的开发人员转移到windows系统之上，如果操作系统上缺少应用软件，那么这个操作系统必将被用户抛弃，斯言真也！那时，我们还 可以直接访问硬件，程序员还依然是这个系统上的王者。后来，windows95出来了，windows开始变得逐渐稳定，我们从那时开始就开始我们的 win32之旅，相对Dos来说，win95表现出开始让程序员兴奋的一些特征——比如，多任务管理，我们可以创建自己的并发程序，通过 Intel提供的保护模式，

程序员可以访问

高达32位线形地址空间，进程与进程之间的都有独立的地址空间让应用更加稳定。然而在硬件管理方面，VM和Vdx虚拟机开始出现了，我们逐渐失对内存的控制，也失去了对CPU的绝对控制权， 对于Cpu的0特权级我们已经似乎无能为力了，记得当年有位大师提供了一种可以访问跳转到cpu的0级特权，于是，一时之间开发者们在自己的应用中争相使用使windows变得很不稳定，微软很尴尬，然而，那时，微软作为王者的霸气已经显现。直到windows98 微软依然对开发者那么热情，然而已经不那么慷慨了，我们在windows95上如果使用了未公开的API,windows98上将不再能使用，除此之外，对于开发人员，98是更好更稳定的95，而这时，微软的地位已经固若金汤——每天疯狂地卖着他操作系统的copy。直到，2000年的到来，我们进入windows2000的时代，windows已更加强大的功能和复杂的架构出现在我们面前，

这个时候，我们已经完全的被隔离在硬件之外了，

即使通过driver，我们最多也只能到达hal层，是的，这是必须的，因为我们需要更加稳定的操作系统，而这个时候，windows的图形系统也一改以往被放置在内核模式的做法，它直接设计了一个图形驱动，将图形系统放置在其上，而这样的做法除了为程序员作想外，

恐怕

也包含了和OPenGL恶意竞争的意味，这对OpenGL来说，这种做法的确有点“小人”的味道，因为是自己的系统，我们就有权利绕过操作系统让图形子系统直接访问硬件，而在windows之上，OpenGL却只能遵循这个游戏规则，好在OpenGL也不是浪得虚名，凭自己过硬的技术以及跨平台性在图形高端计算领域依然保持统治地位。扯远了，直到windows2000我们仍然能忍受，因为我们还可以直接和操作系统打交道，通过驱动，我们在万般无奈的情况下还可以直接使用物理内存，我们还可以绕过那个所谓的“通天塔”——复杂而又低性能的.Net FrameWork来设计我们的程序，尽管我们一度被微软攻城掠地，不断

入

侵蚕食，但我们还可以，至少还可以欣赏他所提供优美的系统架构，而且我们在自己的应用中使用的公开的API还是那么健壮地在高版本的操作系统中工作！尽管，在2000之中那个可怕的蓝屏时常因为一点点的非法访问就出现，但是在XP之中，那种脆弱的情况我们已经看不到了。而xp眩目的界面和前所未有(和以往的windows版本相比)的稳定以及较好的安全性让我们臣服在微软的脚下。
  
然而，他终究要来临了，正如当时Java的出现，.Net让那些技能脆弱的人开始兴奋，另那些玩弄概念的炒作者感到兴奋，那些憎恨com的人感到兴奋！就像当时人们认为java将是所有语言的终结者一样,人们对.Net的所持的期待就像

期待

一个国王来统一这个混乱的语言世界！？对于那些技能脆弱的人们，.Net的出现只会让我们技能越来脆弱；而玩弄概念的理想主义者，通天塔不可能建造成功；那些憎恨com的人们，你们受骗了，.Net其实就是更好的com。正如java今日的无比臃肿印证了Bjarne Stroustrup当年的预言,.Net 是不是一个"通天塔"还需要时间去验证。是的，有时我们不得不承认新事物的出现有其优越的地方，比如当年的java,的跨平台性，.Net也有自己的优势，比如在平台上能方便地调用各种语言写的dll,与web交互的能力强大，但是，问题在于，我们真的需要那些东西吗？正如windows的日渐华丽的界面，我们是否真的需要，有时候，这种问题真是个矛盾，人们对于形而上的东西总是很狂热，而有时这种狂热成就了一些东西，windows的风行和Intel的发展，软件的日益庞大与硬件的发展，但是正如我们今天的城市交通一样，我们已经步入了以车代步的时代，但是我们的速度却远比骑自行车的时候慢。硬件日益发展，软件厂家却不再像当年一样对内存铢镏必较了。直到今天，我们仍然发现，.Net除了给我们带来微软不知疲倦的吹嘘和言过其实的宣传外，它给我们带来的失望远大于给我们带来的惊喜，除了Asp.Net而外，个人认为我们完全没有必要使用.Net！
  
是的，是该远离微软的时候了，因为现在我们已经明白，微软推出.Net 的企图就和当初sun的java一样，那么，按照微软的意图，在windows上我们只有一种终极语言，那就是C#,是的，微软也放心了，因为我们在也调用不到.Net FrameWork之外的东西，大不了我就中止你的应用，而作为用户，你永远没有能力在我们系统上做任何东西——微软又将我们隔离在离系统更远的另一个特权ring之外。从硬件到系统，从系统被赶到.Net，谁知道，今后我们被赶到哪儿？Unix上的开发人员在这方面来说比windows的开发人员幸运多了，他们一直使用自己熟悉的东西，而不象我们为了跟上微软的步伐而疲于奔命，因为我们永远需要顾虑我们所学的知识是否过时？若干年后，我们要面对的也许是下一个.Net之上的.Net，C#之后的C##，而作为技术爱好者，作为想要有点深度的程序员，我们是否还有能力追赶这位“巨人”的脚步！