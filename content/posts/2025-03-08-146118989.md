---
layout: post
title: "第七章go-切片"
date: 2025-03-08 18:40:33 +0800
description: "类型的切片，它可以存储任何类型的值。这样，你就可以根据实际存储在切片中的数据类型来处理它们了。使用空接口和类型断言是处理这种“混合”类型切片的有效方式。a :=[]int{} // 这上叫始化。注意：　切片必须要初始化　才能使用　，两个切片追加　需要用到  ..."
keywords: "第七章：go 切片"
categories: ['Golang']
tags: ['开发语言', '后端', 'Golang']
artid: "146118989"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146118989
    alt: "第七章go-切片"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146118989
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146118989
cover: https://bing.ee123.net/img/rand?artid=146118989
image: https://bing.ee123.net/img/rand?artid=146118989
img: https://bing.ee123.net/img/rand?artid=146118989
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     第七章：go 切片
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     注意：　切片必须要初始化　才能使用　，
     <span style="color:#fe2c24">
      <strong>
       切片是引用类型
      </strong>
     </span>
    </p>
    <p>
     a :=[]int{} // 这上叫始化
     <span style="color:#fe2c24">
      <strong>
       此时并没有申请内存
      </strong>
     </span>
     // 如果要
     <span style="color:#fe2c24">
      <strong>
       追加值的
      </strong>
     </span>
     话：　append
    </p>
    <pre><span style="color:#fe2c24"><strong>ints := append(a, 1, 2, 3)
</strong></span></pre>
    <p>
     a := make([]int,5)
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="406" src="https://i-blog.csdnimg.cn/direct/043d49dd20e14676bd16f28874800987.png" width="1066"/>
    </p>
    <pre><code class="language-Go">// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="182" src="https://i-blog.csdnimg.cn/direct/fe01ac9387744028a2a7698ba1028743.png" width="1324"/>
    </p>
    <p>
     <img alt="" height="866" src="https://i-blog.csdnimg.cn/direct/28cf6640d2684a0aa3cd97754c7c8b83.png" width="1278"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       两个切片追加　需要用到  ...
      </span>
     </strong>
    </p>
    <pre><code class="language-Go">s1 := []int{1, 2, 3}
	s2 := []int{4, 5, 6}
	//把s2　切片追加到　s1切片中去
	appendStr := append(s1, s2...)
	fmt.Println(appendStr)</code></pre>
    <p>
     <span style="color:#fe2c24">
      <strong>
       注意如果是不同类型的切片：　可以用 interface 类型
      </strong>
     </span>
    </p>
    <pre><code class="language-Go">package main
 
import (
    "fmt"
)
 
type Data struct {
    Value interface{} // 使用空接口来存储任意类型的数据
}
 
func main() {
    var dataSlice []Data
    dataSlice = append(dataSlice, Data{Value: 1})       // 追加 int 类型
    dataSlice = append(dataSlice, Data{Value: "hello"}) // 追加 string 类型
    dataSlice = append(dataSlice, Data{Value: 3.14})    // 追加 float64 类型
 
    for _, data := range dataSlice {
        fmt.Println(data.Value)
    }
}</code></pre>
    <p>
     <span style="color:#fe2c24">
      <strong>
       类型断言的应用
      </strong>
     </span>
    </p>
    <p>
    </p>
    <p>
     下面是如何定义一个可以包含字符串和数字的切片的示例：
    </p>
    <p>
    </p>
    <p>
     <code>
      <code>
       package main
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       import (
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       "fmt"
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       )
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       func main() {
       <!-- -->
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       // 创建一个可以包含任意类型数据的切片
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       var mixedSlice []interface{}
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       // 向切片中添加字符串
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       mixedSlice = append(mixedSlice, "Hello")
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       // 向切片中添加数字
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       mixedSlice = append(mixedSlice, 42)
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       // 添加更多的数据类型
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       mixedSlice = append(mixedSlice, true) // 布尔值
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       mixedSlice = append(mixedSlice, 3.14) // 浮点数
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       // 打印切片内容
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       for _, value := range mixedSlice {
       <!-- -->
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       fmt.Println(value)
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       }
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       }
      </code>
     </code>
    </p>
    <p>
     在这个例子中，
     <code>
      mixedSlice
     </code>
     是一个
     <code>
      []interface{}
     </code>
     类型的切片，它可以存储任何类型的值。当你想要访问切片中的具体值时，你需要将它们断言（type assertion）回原始类型，例如：
    </p>
    <p>
    </p>
    <p>
     <code>
      <code>
       for _, value := range mixedSlice {
       <!-- -->
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       switch v := value.(type) {
       <!-- -->
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       case string:
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       fmt.Println("String:", v)
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       case int:
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       fmt.Println("Int:", v)
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       case bool:
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       fmt.Println("Bool:", v)
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       case float64:
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       fmt.Println("Float64:", v)
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       default:
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       fmt.Println("Unknown type")
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       }
      </code>
     </code>
    </p>
    <p>
     <code>
      <code>
       }
      </code>
     </code>
    </p>
    <p>
     这样，你就可以根据实际存储在切片中的数据类型来处理它们了。使用空接口和类型断言是处理这种“混合”类型切片的有效方式。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f6c69757869616f6a756e3832382f:61727469636c652f64657461696c732f313436313138393839" class_="artid" style="display:none">
 </p>
</div>


