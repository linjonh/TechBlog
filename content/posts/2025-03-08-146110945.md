---
layout: post
title: "Android-List按属性排序方法总结工具类"
date: 2025-03-08 09:35:25 +0800
description: "在 Android 中，你可以使用 Collections.sort() 方法或 List.sort() 方法对 List 进行排序。假设你有一个 Person 类，并且你想根据 age 属性对 List 进行排序。假设你有一个 Person 类，并且你想根据 age 属性对 List 进行排序。支持链式调用：通过返回 List 本身，支持链式调用，方便在流式编程中使用。所有方法都返回排序后的 List，支持链式调用，方便在流式编程中使用。支持空安全：增加对空列表和空属性的处理，避免空指针异常。"
keywords: "Android List按属性排序方法总结工具类"
categories: ['未分类']
tags: ['List', 'Android']
artid: "146110945"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146110945
    alt: "Android-List按属性排序方法总结工具类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146110945
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146110945
cover: https://bing.ee123.net/img/rand?artid=146110945
image: https://bing.ee123.net/img/rand?artid=146110945
img: https://bing.ee123.net/img/rand?artid=146110945
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android List按属性排序方法总结工具类
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在 Android 中，你可以使用 Collections.sort() 方法或 List.sort() 方法对 List 进行排序。为了根据指定属性排序，你可以使用 Comparator 来定义排序规则。以下是几种常见的排序方式：
    </p>
    <p>
     <strong>
      1. 使用 Comparator 进行排序
     </strong>
     <br/>
     假设你有一个 Person 类，并且你想根据 age 属性对 List 进行排序。
    </p>
    <p>
     假设你有一个 Person 类，并且你想根据 age 属性对 List 进行排序。
    </p>
    <pre><code>public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
</code></pre>
    <p>
     你可以使用 Comparator 来根据 age 属性进行排序：
    </p>
    <pre><code>List&lt;Person&gt; personList = new ArrayList&lt;&gt;();
personList.add(new Person("Alice", 30));
personList.add(new Person("Bob", 25));
personList.add(new Person("Charlie", 35));

// 使用 Comparator 根据 age 排序
Collections.sort(personList, new Comparator&lt;Person&gt;() {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.getAge(), p2.getAge());
    }
});
</code></pre>
    <p>
     或者使用 Java 8 的 Lambda 表达式简化代码：
    </p>
    <pre><code>Collections.sort(personList, (p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge()));
</code></pre>
    <ol start="2">
     <li>
      使用 List.sort() 方法
      <br/>
      你也可以直接使用 List.sort() 方法进行排序：
     </li>
    </ol>
    <pre><code>personList.sort((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge()));
</code></pre>
    <ol start="3">
     <li>
      使用 Comparator.comparing() 方法
      <br/>
      Java 8 引入了 Comparator.comparing() 方法，可以更简洁地根据对象的属性进行排序：
     </li>
    </ol>
    <pre><code>personList.sort(Comparator.comparing(Person::getAge));
</code></pre>
    <ol start="4">
     <li>
      降序排序
      <br/>
      如果你想进行降序排序，可以使用 Comparator.reversed() 方法：
     </li>
    </ol>
    <pre><code>personList.sort(Comparator.comparing(Person::getAge).reversed());
</code></pre>
    <ol start="5">
     <li>
      多属性排序
      <br/>
      如果你想根据多个属性进行排序，可以使用 Comparator.thenComparing() 方法。例如，先根据 age 排序，再根据 name 排序：
     </li>
    </ol>
    <pre><code>personList.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName));
</code></pre>
    <ol start="6">
     <li>
      使用 Kotlin 进行排序
      <br/>
      如果你使用 Kotlin，排序会更加简洁：
     </li>
    </ol>
    <pre><code>val personList = listOf(
    Person("Alice", 30),
    Person("Bob", 25),
    Person("Charlie", 35)
)

// 根据 age 排序
val sortedList = personList.sortedBy { it.age }

// 降序排序
val sortedListDesc = personList.sortedByDescending { it.age }
</code></pre>
    <p>
     以下是进一步优化后的工具类：
     <br/>
     为了进一步优化代码，我们可以从以下几个方面进行改进：
    </p>
    <p>
     减少方法参数：通过引入链式调用的方式，让代码更符合现代编程风格。
    </p>
    <p>
     增强可读性：通过方法命名和注释，让代码更直观易懂。
    </p>
    <p>
     支持链式调用：通过返回 List 本身，支持链式调用，方便在流式编程中使用。
    </p>
    <p>
     支持空安全：增加对空列表和空属性的处理，避免空指针异常。
    </p>
    <p>
     <strong>
      工具类：ListSorter
     </strong>
    </p>
    <pre><code>import java.util.Comparator;
import java.util.List;
import java.util.function.Function;

public final class ListSorter {

    /**
     * 私有构造函数，禁止实例化
     */
    private ListSorter() {
        throw new UnsupportedOperationException("Utility class, do not instantiate!");
    }

    /**
     * 对 List 按照指定属性进行排序（支持升序或降序）
     *
     * @param list         需要排序的列表
     * @param keyExtractor 用于提取排序属性的函数
     * @param ascending    是否升序排序（true：升序，false：降序）
     * @param &lt;T&gt;          列表元素类型
     * @param &lt;U&gt;          排序属性的类型（必须实现 Comparable 接口）
     * @return 排序后的列表（支持链式调用）
     */
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; List&lt;T&gt; sort(List&lt;T&gt; list, Function&lt;T, U&gt; keyExtractor, boolean ascending) {
        if (list == null || list.isEmpty() || keyExtractor == null) {
            return list;
        }

        Comparator&lt;T&gt; comparator = Comparator.comparing(keyExtractor);
        if (!ascending) {
            comparator = comparator.reversed();
        }

        list.sort(comparator);
        return list;
    }

    /**
     * 对 List 按照指定属性进行升序排序
     *
     * @param list         需要排序的列表
     * @param keyExtractor 用于提取排序属性的函数
     * @param &lt;T&gt;          列表元素类型
     * @param &lt;U&gt;          排序属性的类型（必须实现 Comparable 接口）
     * @return 排序后的列表（支持链式调用）
     */
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; List&lt;T&gt; sortAscending(List&lt;T&gt; list, Function&lt;T, U&gt; keyExtractor) {
        return sort(list, keyExtractor, true);
    }

    /**
     * 对 List 按照指定属性进行降序排序
     *
     * @param list         需要排序的列表
     * @param keyExtractor 用于提取排序属性的函数
     * @param &lt;T&gt;          列表元素类型
     * @param &lt;U&gt;          排序属性的类型（必须实现 Comparable 接口）
     * @return 排序后的列表（支持链式调用）
     */
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; List&lt;T&gt; sortDescending(List&lt;T&gt; list, Function&lt;T, U&gt; keyExtractor) {
        return sort(list, keyExtractor, false);
    }

    /**
     * 对 List 按照多个属性进行排序（支持升序或降序）
     *
     * @param list          需要排序的列表
     * @param ascending     是否升序排序（true：升序，false：降序）
     * @param keyExtractors 用于提取排序属性的函数数组
     * @param &lt;T&gt;           列表元素类型
     * @param &lt;U&gt;           排序属性的类型（必须实现 Comparable 接口）
     * @return 排序后的列表（支持链式调用）
     */
    @SafeVarargs
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; List&lt;T&gt; sortByMultipleKeys(List&lt;T&gt; list, boolean ascending, Function&lt;T, U&gt;... keyExtractors) {
        if (list == null || list.isEmpty() || keyExtractors == null || keyExtractors.length == 0) {
            return list;
        }

        Comparator&lt;T&gt; comparator = Comparator.comparing(keyExtractors[0]);
        for (int i = 1; i &lt; keyExtractors.length; i++) {
            comparator = comparator.thenComparing(keyExtractors[i]);
        }

        if (!ascending) {
            comparator = comparator.reversed();
        }

        list.sort(comparator);
        return list;
    }
}
</code></pre>
    <p>
     优化点
     <br/>
     <strong>
      链式调用：
     </strong>
    </p>
    <p>
     所有方法都返回排序后的 List，支持链式调用，方便在流式编程中使用。
    </p>
    <p>
     例如：ListSorter.sortAscending(list, Person::getAge).forEach(System.out::println);
    </p>
    <p>
     <strong>
      空安全：
     </strong>
    </p>
    <p>
     增加了对 list 和 keyExtractor 的空值检查，避免空指针异常。
    </p>
    <p>
     如果输入为空，直接返回原列表。
    </p>
    <p>
     <strong>
      方法命名更直观：
     </strong>
    </p>
    <p>
     方法名如 sortAscending 和 sortDescending 更直观地表达了功能。
    </p>
    <p>
     <strong>
      支持多属性排序：
     </strong>
    </p>
    <p>
     通过 sortByMultipleKeys 方法，支持按多个属性排序。
    </p>
    <p>
     <strong>
      工具类设计：
     </strong>
    </p>
    <p>
     工具类为 final，并私有化构造函数，避免被实例化。
     <br/>
     使用示例：
    </p>
    <p>
     使用 ListSorter 对 List 进行排序：
    </p>
    <pre><code>import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List&lt;Person&gt; personList = new ArrayList&lt;&gt;();
        personList.add(new Person("Alice", 30));
        personList.add(new Person("Bob", 25));
        personList.add(new Person("Charlie", 35));
        personList.add(new Person("Alice", 20));

        // 按年龄升序排序
        ListSorter.sortAscending(personList, Person::getAge)
                 .forEach(System.out::println);

        // 按年龄降序排序
        ListSorter.sortDescending(personList, Person::getAge)
                 .forEach(System.out::println);

        // 按姓名升序排序
        ListSorter.sortAscending(personList, Person::getName)
                 .forEach(System.out::println);

        // 按年龄升序排序，年龄相同则按姓名升序排序
        ListSorter.sortByMultipleKeys(personList, true, Person::getAge, Person::getName)
                 .forEach(System.out::println);
    }
}
</code></pre>
    <p>
     <strong>
      输出结果
     </strong>
    </p>
    <pre><code>按年龄升序排序:
Person{name='Bob', age=25}
Person{name='Alice', age=30}
Person{name='Charlie', age=35}

按年龄降序排序:
Person{name='Charlie', age=35}
Person{name='Alice', age=30}
Person{name='Bob', age=25}

按姓名升序排序:
Person{name='Alice', age=30}
Person{name='Alice', age=20}
Person{name='Bob', age=25}
Person{name='Charlie', age=35}

按年龄和姓名升序排序:
Person{name='Alice', age=20}
Person{name='Bob', age=25}
Person{name='Alice', age=30}
Person{name='Charlie', age=35}
</code></pre>
    <p>
     总结
     <br/>
     优化后的 ListSorter 工具类具有以下特点：
    </p>
    <p>
     链式调用：支持流式编程，代码更简洁。
    </p>
    <p>
     空安全：避免空指针异常。
    </p>
    <p>
     多属性排序：支持按多个属性排序。
    </p>
    <p>
     高可读性：方法命名清晰，注释详细。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f74616e6777656967756f30333035313938372f:61727469636c652f64657461696c732f313436313130393435" class_="artid" style="display:none">
 </p>
</div>


