---
layout: post
title: "Leetcode2012数组美丽值求和"
date: 2025-03-11 21:21:16 +0800
description: "【代码】Leetcode2012：数组美丽值求和。"
keywords: "Leetcode2012：数组美丽值求和"
categories: ['未分类']
tags: ['数组', '后缀数组', '前缀和', 'Python', 'Leetcode']
artid: "146188946"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146188946
    alt: "Leetcode2012数组美丽值求和"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146188946
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146188946
cover: https://bing.ee123.net/img/rand?artid=146188946
image: https://bing.ee123.net/img/rand?artid=146188946
img: https://bing.ee123.net/img/rand?artid=146188946
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Leetcode2012：数组美丽值求和
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     题目描述：
    </h3>
    <p>
     给你一个下标从
     <strong>
      0
     </strong>
     开始的整数数组
     <code>
      nums
     </code>
     。对于每个下标
     <code>
      i
     </code>
     （
     <code>
      1 &lt;= i &lt;= nums.length - 2
     </code>
     ），
     <code>
      nums[i]
     </code>
     的
     <strong>
      美丽值
     </strong>
     等于：
    </p>
    <ul>
     <li>
      <code>
       2
      </code>
      ，对于所有
      <code>
       0 &lt;= j &lt; i
      </code>
      且
      <code>
       i &lt; k &lt;= nums.length - 1
      </code>
      ，满足
      <code>
       nums[j] &lt; nums[i] &lt; nums[k]
      </code>
     </li>
     <li>
      <code>
       1
      </code>
      ，如果满足
      <code>
       nums[i - 1] &lt; nums[i] &lt; nums[i + 1]
      </code>
      ，且不满足前面的条件
     </li>
     <li>
      <code>
       0
      </code>
      ，如果上述条件全部不满足
     </li>
    </ul>
    <p>
     返回符合
     <code>
      1 &lt;= i &lt;= nums.length - 2
     </code>
     的所有
     <em>
     </em>
     <code>
      nums[i]
     </code>
     <em>
     </em>
     的
     <strong>
      美丽值的总和
     </strong>
     。
    </p>
    <h3>
     代码思路：
    </h3>
    <ol>
     <li>
      <strong>
       前缀最大值和后缀最小值
      </strong>
      ：
      <ul>
       <li>
        <code>
         pre1
        </code>
        是一个数组，保存了从左到右遍历时
        <code>
         nums
        </code>
        的前缀最大值。即，对于每个位置
        <code>
         i
        </code>
        ，
        <code>
         pre1[i]
        </code>
        表示从
        <code>
         nums[0]
        </code>
        到
        <code>
         nums[i]
        </code>
        的最大值。
       </li>
       <li>
        <code>
         pre2
        </code>
        是一个数组，保存了从右到左遍历时
        <code>
         nums
        </code>
        的后缀最小值。即，对于每个位置
        <code>
         i
        </code>
        ，
        <code>
         pre2[i]
        </code>
        表示从
        <code>
         nums[i]
        </code>
        到
        <code>
         nums[n-1]
        </code>
        的最小值（注意
        <code>
         pre2
        </code>
        是通过反转
        <code>
         nums
        </code>
        计算然后再反转回来的）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       初始化
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         accumulate
        </code>
        函数来计算
        <code>
         pre1
        </code>
        和
        <code>
         pre2
        </code>
        。
       </li>
       <li>
        <code>
         ans
        </code>
        初始化为 0，用于累加所有符合条件的
        <code>
         nums[i]
        </code>
        的美丽值。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       遍历数组
      </strong>
      ：
      <ul>
       <li>
        遍历数组
        <code>
         nums
        </code>
        的每个元素（从下标 1 到
        <code>
         len(nums) - 2
        </code>
        ），计算每个
        <code>
         nums[i]
        </code>
        的美丽值。
       </li>
       <li>
        对于每个
        <code>
         i
        </code>
        ：
        <ul>
         <li>
          如果
          <code>
           nums[i]
          </code>
          满足条件
          <code>
           pre1[i - 1] &lt; nums[i] &lt; pre2[i + 1]
          </code>
          ，即比左侧所有元素都大且比右侧所有元素都小，则美丽值为 2，累加到
          <code>
           ans
          </code>
          。
         </li>
         <li>
          否则如果
          <code>
           nums[i]
          </code>
          满足条件
          <code>
           nums[i - 1] &lt; nums[i] &lt; nums[i + 1]
          </code>
          ，即仅比相邻的两个元素大，则美丽值为 1，累加到
          <code>
           ans
          </code>
          。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回结果
      </strong>
      ：
      <ul>
       <li>
        遍历完成后，
        <code>
         ans
        </code>
        就是符合条件的所有
        <code>
         nums[i]
        </code>
        的美丽值总和，返回
        <code>
         ans
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     代码实现：
    </h3>
    <div contenteditable="false" tabindex="-1">
     <pre><code class="hljs hljs">class Solution:
    def sumOfBeauties(self, nums: List[int]) -&gt; int:
        pre1, pre2, ans = list(accumulate(nums, func = max)), list(accumulate(nums[::-1], func = min))[::-1], 0
        for i in range(1, len(nums) - 1):
            if   pre1[i - 1] &lt; nums[i] &lt; pre2[i + 1]: ans += 2
            elif nums[i - 1] &lt; nums[i] &lt; nums[i + 1]: ans += 1
        return ans
</code></pre>
    </div>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36373539383832332f:61727469636c652f64657461696c732f313436313838393436" class_="artid" style="display:none">
 </p>
</div>


