---
layout: post
title: "Python中的坑while1比whileTrue更快"
date: 2025-01-14 05:49:41 +0800
description: "1、前言前些天被Python的多线程坑了一把，本篇讲的内容是Python的bool类型。2、前提2."
keywords: "python while 1"
categories: ['Python']
tags: ['Python']
artid: "85116302"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=85116302
    alt: "Python中的坑while1比whileTrue更快"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=85116302
featuredImagePreview: https://bing.ee123.net/img/rand?artid=85116302
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python中的坑？while1比whileTrue更快？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      1、前言
     </strong>
    </p>
    <p>
     前些天被Python的多线程坑了一把，本篇讲的内容是Python的bool类型。
    </p>
    <p>
     <strong>
      2、前提
     </strong>
    </p>
    <p>
     <strong>
      2.1 bool是int的子类
     </strong>
    </p>
    <p>
     根据PEP285中Review部分第6条所述，bool类是从int类继承而来的，这样可以极大的简化实现（C代码中调用PyInt_Check()的地方仍将继续工作）。
    </p>
    <blockquote>
     <p>
      更多Python视频、源码、资料加群683380553免费获取
     </p>
    </blockquote>
    <p>
     <strong>
      2.2 Python2中True/False不是关键字，但Python3中是
     </strong>
    </p>
    <p>
     我们可以导入keyword模块，来查看关键字：
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/08c734f69d6aa6e3e93a96f249a5613d.png"/>
    </p>
    <p>
    </p>
    <p>
     而在Python3中，关键字中添加了True/False/None。
    </p>
    <p>
     由于Python2中True/False不是关键字，因此我们可以对其进行任意的赋值：
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/6b01991809bca0bb216380f8239c39d8.png"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      3. True + True = 2
     </strong>
    </p>
    <p>
     由于bool是继承自int的子类，因此为了保证向下兼容性，在进行算术运算中，True/False会被当作int值来执行。
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/a978d0f9c248de0160b6435daf651757.png"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      4. While 1比While True快？
     </strong>
    </p>
    <p>
     首先来看一个比较while 1和while True循环的脚本，两个函数中，除了1和True的区别之外，其他地方完全相同。
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/6e810162419ec3e492a7662a2d721223.png"/>
    </p>
    <p>
    </p>
    <p>
     执行结果：
    </p>
    <p>
     while one: 1.37000703812
    </p>
    <p>
     while_true: 2.07638716698
    </p>
    <p>
     可以看出wihle 1的执行时间约为while True的2/3。
    </p>
    <p>
     那么，这是为什么呢？
    </p>
    <p>
     其实这就是前提中提到的关键字的问题。由于Python2中，True/False不是关键字，因此我们可以对其进行任意的赋值，这就导致程序在每次循环时都需要对True/False的值进行检查；而对于1，则被程序进行了优化，而后不会再进行检查。
    </p>
    <p>
     我们可以通过dis模块来查看while_one和while_true的字节码，下面的程序是对刚才的程序进行了一定的简化后的版本。
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/43f51fea6a9dd9598d8972da5f972e0a.png"/>
    </p>
    <p>
    </p>
    <p>
     执行的结果是：
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/e134177687e9e6f3f69afd1ce82a29c7.png"/>
    </p>
    <p>
    </p>
    <p>
     可以看出，正如上面所讲到的，在while True的时候，字节码中多出了几行语句，正是这几行语句进行了True值的检查。
    </p>
    <p>
     而在Python3中，由于True/False已经是关键字了，不允许进行重新赋值，因此，其执行结果与while 1不再有区别（好吧，我这没有Python3的环境，就不去验证了，网上有人验证过了）。但是由于Python2的使用十分广泛，因此大家不得不注意这个可能会降低性能的地方。
    </p>
    <p>
     <strong>
      5. if x == True: 还是 if x:
     </strong>
    </p>
    <p>
     在PEP285中，还提到了这两种写法的比较。PEP285中认为，==具有传递性，a==b, b==c会被化简为a==c。也就是说，如果选择前一种写法的话，6和7在if语句中都应该被认为是真值，那么就会造成6==True==7，被化简为6==7的问题，因此后一种写法才是正确的。
    </p>
    <p>
     现在，让我们偏个题，假设x就是True，那么程序的执行效率又如何呢？
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/321e0853c72d1253e943b1a3c4b4756e.png"/>
    </p>
    <p>
    </p>
    <p>
     执行结果是：
    </p>
    <p>
     if_x_eq_true: 0.212558031082
    </p>
    <p>
     if_x: 0.144327878952
    </p>
    <p>
     让我们再来看看字节码（程序未作修改，dis的使用方式同上，因此不再给出程序）：
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/7f9c75d338fe5bdc0a40ff95189ddef6.png"/>
    </p>
    <p>
    </p>
    <p>
     可以清晰的看到第9行比第14行，多出了检查True值和进行比较的操作。
    </p>
    <p>
     也就是说，不论从遵循PEP的规范，还是执行效率，或者程序的简洁性来说，我们都应该使用if x:，而不是if x == True:来进行比较。同理，那些if x is not None:之类的语句也应当被简化为if x:（如果要比较的是非值，而不必须是None的话）。
    </p>
    <p>
     <img alt="Python中的坑？while1比whileTrue更快？" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/6a7b11e7b1be0b3b7bedec36a70c9deb.png"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f73696e61745f3338363832383630:2f61727469636c652f64657461696c732f3835313136333032" class_="artid" style="display:none">
 </p>
</div>


