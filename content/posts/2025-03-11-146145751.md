---
layout: post
title: "Java实用注解篇Transactional-事务失效的场景深度解析"
date: 2025-03-11 08:59:06 +0800
description: "在使用明明加了事务注解，但事务却没有生效，数据库操作仍然被提交了！这是因为事务机制的触发有一些前提条件，只要触碰到事务失效的“雷区”，就会让事务变成“摆设”。接下来，我们来详细剖析几种常见的事务失效场景以及解决方案！"
keywords: "Java实用注解篇：@Transactional 事务失效的场景深度解析"
categories: ['未分类']
tags: ['数据库', '开发语言', 'Java']
artid: "146145751"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146145751
    alt: "Java实用注解篇Transactional-事务失效的场景深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146145751
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146145751
cover: https://bing.ee123.net/img/rand?artid=146145751
image: https://bing.ee123.net/img/rand?artid=146145751
img: https://bing.ee123.net/img/rand?artid=146145751
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java实用注解篇：@Transactional 事务失效的场景深度解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     前言
    </h3>
    <p>
     在使用
     <code>
      @Transactional
     </code>
     时，很多开发者都会遇到一个常见困惑：
     <strong>
      明明加了事务注解，但事务却没有生效，数据库操作仍然被提交了！
     </strong>
     <br/>
     这是因为事务机制的触发有一些
     <strong>
      前提条件
     </strong>
     ，只要触碰到事务失效的“雷区”，就会让事务变成“摆设”。接下来，我们来详细剖析几种常见的
     <strong>
      事务失效场景
     </strong>
     以及
     <strong>
      解决方案
     </strong>
     ！
    </p>
    <p>
    </p>
    <h3>
     ✅
     <strong>
      1️⃣ 同一个类中方法直接调用，事务失效
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void methodA() {
        userRepository.save(new User("UserA"));
        methodB(); // 内部调用，不触发事务
    }

    @Transactional
    public void methodB() {
        userRepository.save(new User("UserB"));
        throw new RuntimeException("Test rollback"); // 期望回滚
    }
}</code></pre>
    <h4>
     <strong>
      执行结果：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       UserA 会被插入数据库
      </strong>
     </li>
     <li>
      <strong>
       UserB 没有插入，因为抛出了异常
      </strong>
     </li>
     <li>
      🚨
      <strong>
       事务没有回滚！
      </strong>
     </li>
    </ul>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <p>
     Spring 的事务是基于
     <strong>
      AOP 代理机制
     </strong>
     实现的，而代理对象只有在
     <strong>
      外部调用
     </strong>
     时才会触发拦截器逻辑，从而开启事务。
     <br/>
     <strong>
      同一个类内的方法调用不会经过代理对象，而是通过
      <code>
       this.methodB()
      </code>
      调用的，因此不会触发事务机制！
     </strong>
    </p>
    <h4>
    </h4>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <p>
     <strong>
      方案一：通过代理对象调用事务方法
     </strong>
    </p>
    <pre><code class="language-java">@Autowired
private UserService userService;

@Transactional
public void methodA() {
    userRepository.save(new User("UserA"));
    userService.methodB(); // 通过代理对象调用，触发事务
}
</code></pre>
    <p>
     <strong>
      方案二：使用
      <code>
       AopContext
      </code>
      获取当前代理对象
     </strong>
    </p>
    <p>
     Spring 提供了
     <code>
      AopContext
     </code>
     工具类，可以获取当前代理对象：
    </p>
    <pre><code class="language-java">import org.springframework.aop.framework.AopContext;

@Transactional
public void methodA() {
    userRepository.save(new User("UserA"));
    ((UserService) AopContext.currentProxy()).methodB();
}</code></pre>
    <p>
     <strong>
      注意：
     </strong>
    </p>
    <ul>
     <li>
      需要在配置类中开启
      <strong>
       暴露代理对象功能
      </strong>
      才能使用
      <code>
       AopContext
      </code>
      ：
     </li>
    </ul>
    <pre><code class="language-java">@EnableAspectJAutoProxy(exposeProxy = true)</code></pre>
    <h3>
     ✅
     <strong>
      2️⃣ 非
      <code>
       public
      </code>
      方法上的 @Transactional 注解无效
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    private void addUser() {
        userRepository.save(new User("PrivateUser"));
        throw new RuntimeException("Test rollback");
    }
}</code></pre>
    <h4>
     <strong>
      执行结果：
     </strong>
    </h4>
    <ul>
     <li>
      数据成功插入，事务
      <strong>
       没有回滚
      </strong>
      ！
     </li>
    </ul>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <p>
     Spring 的事务是基于
     <strong>
      动态代理机制
     </strong>
     ，只有
     <strong>
      <code>
       public
      </code>
      方法
     </strong>
     才会被代理，
     <strong>
      <code>
       private
      </code>
      、
      <code>
       protected
      </code>
      、
      <code>
       default
      </code>
      修饰的方法不会被代理
     </strong>
     ，因此不会触发事务机制。
    </p>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <p>
     <strong>
      改为
      <code>
       public
      </code>
      方法：
     </strong>
    </p>
    <pre><code class="language-java">@Transactional
public void addUser() {
    userRepository.save(new User("PublicUser"));
    throw new RuntimeException("Test rollback");
}</code></pre>
    <h3>
     ✅
     <strong>
      3️⃣ 数据库引擎不支持事务
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <p>
     如果你的数据库表使用的是 MySQL 的
     <strong>
      MyISAM 引擎
     </strong>
     而不是
     <strong>
      InnoDB
     </strong>
     ，事务机制是不会生效的！
    </p>
    <p>
     <strong>
      检查表引擎：
     </strong>
    </p>
    <pre><code class="language-java">SHOW TABLE STATUS WHERE Name = 'your_table';</code></pre>
    <p>
     如果看到
     <strong>
      <code>
       Engine=MyISAM
      </code>
     </strong>
     ：
    </p>
    <pre><code class="language-java">+------------+--------+ ...
| Name       | Engine | ...
+------------+--------+ ...
| user_table | MyISAM | ...
+------------+--------+ ...</code></pre>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       MyISAM
      </strong>
      是 MySQL 的早期存储引擎，不支持事务回滚、外键等特性。
     </li>
     <li>
      <strong>
       InnoDB
      </strong>
      才是支持事务、行级锁等功能的存储引擎。
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <p>
     <strong>
      把表引擎改为 InnoDB：
     </strong>
    </p>
    <pre><code class="language-java">ALTER TABLE your_table ENGINE=InnoDB;</code></pre>
    <p>
     <strong>
      查看所有 MyISAM 表：
     </strong>
    </p>
    <pre><code class="language-java">SELECT table_schema, table_name, engine
FROM information_schema.tables
WHERE engine = 'MyISAM';</code></pre>
    <h3>
     ✅
     <strong>
      4️⃣ 捕获了异常，导致事务无法回滚
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <pre><code class="language-java">@Transactional
public void addUser() {
    try {
        userRepository.save(new User("TryCatchUser"));
        int result = 1 / 0; // 抛出 ArithmeticException
    } catch (Exception e) {
        // 异常被捕获
        System.out.println("Exception caught: " + e.getMessage());
    }
}</code></pre>
    <h4>
     <strong>
      执行结果：
     </strong>
    </h4>
    <ul>
     <li>
      数据被插入
     </li>
     <li>
      🚨
      <strong>
       事务没有回滚！
      </strong>
     </li>
    </ul>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      Spring 默认只有
      <strong>
       未捕获的运行时异常
      </strong>
      （继承自
      <code>
       RuntimeException
      </code>
      ）才会触发回滚。
     </li>
     <li>
      <strong>
       受检异常
      </strong>
      （如
      <code>
       IOException
      </code>
      ）或者
      <strong>
       被捕获的异常
      </strong>
      不会触发事务回滚！
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <p>
     <strong>
      方案一：手动抛出异常，让 Spring 感知到事务需要回滚：
     </strong>
    </p>
    <pre><code class="language-java">@Transactional
public void addUser() {
    try {
        userRepository.save(new User("User"));
        int result = 1 / 0;
    } catch (Exception e) {
        throw new RuntimeException(e); // 抛出运行时异常触发回滚
    }
}</code></pre>
    <p>
     <strong>
      方案二：使用
      <code>
       rollbackFor
      </code>
      明确指定哪些异常触发回滚：
     </strong>
    </p>
    <pre><code class="language-java">@Transactional(rollbackFor = Exception.class)
public void addUser() {
    try {
        userRepository.save(new User("User"));
        int result = 1 / 0;
    } catch (Exception e) {
        // 异常依然被捕获，但事务仍然会回滚
        System.out.println("Caught exception, but rollback still happens!");
    }
}</code></pre>
    <h3>
     ✅
     <strong>
      5️⃣ 多线程环境下事务失效
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <pre><code class="language-java">@Transactional
public void addUser() {
    new Thread(() -&gt; {
        userRepository.save(new User("AsyncUser"));
        throw new RuntimeException("Test rollback");
    }).start();
}</code></pre>
    <h4>
     <strong>
      执行结果：
     </strong>
    </h4>
    <ul>
     <li>
      数据被插入
     </li>
     <li>
      🚨
      <strong>
       事务没有回滚！
      </strong>
     </li>
    </ul>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <p>
     Spring 的事务是
     <strong>
      线程绑定的
     </strong>
     （基于
     <code>
      ThreadLocal
     </code>
     实现），
     <br/>
     <strong>
      新线程不会继承原线程的事务上下文
     </strong>
     ，因此新线程无法感知到原线程的事务边界。
    </p>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <p>
     <strong>
      使用
      <code>
       @Async
      </code>
      配合事务：
     </strong>
    </p>
    <pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Async
    @Transactional
    public void addUserAsync() {
        userRepository.save(new User("AsyncUser"));
        throw new RuntimeException("Test rollback");
    }
}</code></pre>
    <p>
     <strong>
      注意：
     </strong>
    </p>
    <ul>
     <li>
      需要在启动类上加上
      <strong>
       <code>
        @EnableAsync
       </code>
      </strong>
      ：
     </li>
    </ul>
    <pre><code class="language-java">@SpringBootApplication
@EnableAsync
public class Application {
}</code></pre>
    <h3>
     ✅
     <strong>
      6️⃣ 数据库连接的自动提交未关闭
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <p>
     如果你的数据库连接池配置了
     <strong>
      自动提交
     </strong>
     ，那么事务控制会被绕过！
    </p>
    <p>
     <strong>
      可能的配置：
     </strong>
    </p>
    <pre><code class="language-java">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test_db
    username: root
    password: 123456
    hikari:
      auto-commit: true  # 🚨自动提交为true</code></pre>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      Spring 事务会通过
      <strong>
       DataSource
      </strong>
      获取连接，如果连接的
      <code>
       autoCommit=true
      </code>
      ，每次 SQL 执行都会立刻提交。
     </li>
     <li>
      <strong>
       事务注解控制的提交/回滚行为被绕过
      </strong>
      。
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       确保数据库连接池关闭自动提交
      </strong>
      ：
     </li>
    </ul>
    <pre><code class="language-java">spring:
  datasource:
    hikari:
      auto-commit: false</code></pre>
    <ul>
     <li>
      或者手动关闭自动提交：
     </li>
    </ul>
    <pre><code class="language-java">Connection conn = dataSource.getConnection();
conn.setAutoCommit(false);</code></pre>
    <h3>
     ✅
     <strong>
      7️⃣ 代理对象被绕过（比如使用 this 关键字）
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void outerMethod() {
        userRepository.save(new User("OuterMethod"));
        this.innerMethod(); // 🚨不会触发事务
    }

    @Transactional
    public void innerMethod() {
        userRepository.save(new User("InnerMethod"));
        throw new RuntimeException("Test rollback");
    }
}</code></pre>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       Spring 的事务是基于代理对象实现的
      </strong>
      ，
      <code>
       this.innerMethod()
      </code>
      是直接调用自身方法，绕过了代理对象。
     </li>
     <li>
      <strong>
       事务拦截器不会生效
      </strong>
      ，因此内部方法不会走事务逻辑。
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       通过代理对象调用事务方法：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Autowired
private UserService userService;

public void outerMethod() {
    userRepository.save(new User("OuterMethod"));
    userService.innerMethod(); // 🚀触发事务
}</code></pre>
    <h3>
     ✅
     <strong>
      8️⃣ 嵌套事务设置不当
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <p>
     当你有嵌套事务时，如果
     <strong>
      传播机制（Propagation）
     </strong>
     配置不当，也可能造成事务失效。
    </p>
    <p>
     <strong>
      例如：
     </strong>
    </p>
    <pre><code class="language-java">@Transactional
public void outerMethod() {
    userRepository.save(new User("Outer"));
    innerMethod();
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void innerMethod() {
    userRepository.save(new User("Inner"));
    throw new RuntimeException("Test rollback");
}</code></pre>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <pre><code class="language-java">@Transactional(propagation = Propagation.NESTED)</code></pre>
    <ul>
     <li>
      <strong>
       <code>
        Propagation.REQUIRES_NEW
       </code>
      </strong>
      表示开启一个新的事务，
      <br/>
      <strong>
       外层事务和内层事务是独立的
      </strong>
      ，即使内层回滚，外层不会受影响。
     </li>
     <li>
      所以
      <strong>
       <code>
        Outer
       </code>
       数据仍然会被提交！
      </strong>
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <ul>
     <li>
      如果你期望事务统一回滚，改成默认的
      <code>
       Propagation.REQUIRED
      </code>
      ：
     </li>
    </ul>
    <pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRED)
public void innerMethod() {
    userRepository.save(new User("Inner"));
    throw new RuntimeException("Test rollback");
}</code></pre>
    <ul>
     <li>
      如果你想实现嵌套事务，可以考虑
      <strong>
       <code>
        NESTED
       </code>
       传播机制
      </strong>
      ：
     </li>
    </ul>
    <h3>
     ✅
     <strong>
      9️⃣ 事务管理器配置错误
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <p>
     当你使用了多个数据源时，如果事务管理器没有正确配置，也会造成事务失效：
    </p>
    <pre><code class="language-java">@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}</code></pre>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      如果你的数据源和事务管理器不匹配，比如有多个数据源，但事务管理器只绑定了一个数据源，
      <br/>
      <strong>
       其他数据源的事务不会生效
      </strong>
      。
     </li>
     <li>
      <strong>
       没有声明事务管理器
      </strong>
      时，Spring 会使用
      <strong>
       默认事务管理器
      </strong>
      ，可能不是你想要的那个。
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       指定事务管理器：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Transactional(transactionManager = "transactionManager")</code></pre>
    <ul>
     <li>
      <strong>
       多数据源事务管理器配置：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Bean("transactionManager1")
public PlatformTransactionManager transactionManager1(@Qualifier("dataSource1") DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}

@Bean("transactionManager2")
public PlatformTransactionManager transactionManager2(@Qualifier("dataSource2") DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}</code></pre>
    <h3>
     ✅
     <strong>
      🔟 被代理类不是 Spring 管理的 Bean
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <pre><code class="language-java">public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void addUser() {
        userRepository.save(new User("User"));
        throw new RuntimeException("Test rollback");
    }
}</code></pre>
    <p>
     <strong>
      调用：
     </strong>
    </p>
    <pre><code class="language-java">UserService userService = new UserService();
userService.addUser(); // 🚨事务失效</code></pre>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       Spring 事务依赖于 AOP 代理
      </strong>
      ，只有被 Spring 托管的 Bean 才会启用代理机制。
     </li>
     <li>
      <strong>
       手动 new 对象不会触发事务机制
      </strong>
      。
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       让 Spring 托管 Bean：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Service
public class UserService {
    ...
}</code></pre>
    <ul>
     <li>
      <strong>
       使用
       <code>
        ApplicationContext
       </code>
       获取代理对象：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Autowired
private ApplicationContext applicationContext;

public void addUser() {
    UserService proxy = applicationContext.getBean(UserService.class);
    proxy.addUser(); // 🚀事务生效
}</code></pre>
    <h3>
     ✅
     <strong>
      1️⃣1️⃣ SpringBoot 的
      <code>
       @EnableTransactionManagement
      </code>
      未生效
     </strong>
    </h3>
    <h4>
     <strong>
      问题复现：
     </strong>
    </h4>
    <p>
     如果你在项目中使用的是 SpringBoot，但是
     <code>
      @Transactional
     </code>
     却完全没反应，
     <br/>
     可能是因为事务管理器没有启用！
    </p>
    <h4>
     <strong>
      为什么会失效？
     </strong>
    </h4>
    <ul>
     <li>
      SpringBoot 默认开启事务管理（自动配置），但如果你自己创建了配置类，并关闭了自动配置，就可能导致事务失效。
     </li>
    </ul>
    <h4>
     ✅
     <strong>
      解决方案：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       显式开启事务管理器：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Configuration
@EnableTransactionManagement
public class TransactionConfig {
}</code></pre>
    <ul>
     <li>
      <strong>
       确认事务管理器是否生效：
      </strong>
     </li>
    </ul>
    <pre><code class="language-java">@Autowired
private PlatformTransactionManager transactionManager;

@PostConstruct
public void checkTransactionManager() {
    System.out.println("Transaction Manager: " + transactionManager);
}</code></pre>
    <h3>
     ✅
     <strong>
      1️⃣2️⃣ 数据库本身的问题
     </strong>
    </h3>
    <p>
     最后，有时候
     <strong>
      不是代码问题
     </strong>
     ，而是
     <strong>
      数据库层面的配置问题
     </strong>
     导致事务失效：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        数据库权限不足
       </strong>
       ：
       <br/>
       如果数据库用户权限不足，无法执行
       <code>
        ROLLBACK
       </code>
       操作，也会让事务无法回滚。
      </p>
     </li>
     <li>
      <p>
       <strong>
        触发器 (Trigger)
       </strong>
       ：
       <br/>
       如果表有触发器，会导致某些数据在触发器执行后直接提交，绕过事务管理。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     🎯
     <strong>
      总结：事务失效场景大全
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        事务失效场景
       </th>
       <th>
        失效原因
       </th>
       <th>
        解决方案
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        同类方法调用
       </td>
       <td>
        没有代理
       </td>
       <td>
        通过代理对象调用
       </td>
      </tr>
      <tr>
       <td>
        非 public 方法
       </td>
       <td>
        只有 public 方法才会被代理
       </td>
       <td>
        改为 public
       </td>
      </tr>
      <tr>
       <td>
        数据库引擎不支持事务
       </td>
       <td>
        使用 MyISAM 而不是 InnoDB
       </td>
       <td>
        修改为 InnoDB
       </td>
      </tr>
      <tr>
       <td>
        异常被捕获
       </td>
       <td>
        Spring 默认只回滚 RuntimeException
       </td>
       <td>
        显式指定 rollbackFor
       </td>
      </tr>
      <tr>
       <td>
        多线程调用
       </td>
       <td>
        新线程不会继承原线程的事务
       </td>
       <td>
        使用 @Async 结合事务
       </td>
      </tr>
      <tr>
       <td>
        自动提交未关闭
       </td>
       <td>
        数据源 autoCommit=true
       </td>
       <td>
        关闭自动提交
       </td>
      </tr>
      <tr>
       <td>
        代理对象被绕过
       </td>
       <td>
        this 调用自身方法
       </td>
       <td>
        使用代理对象调用
       </td>
      </tr>
      <tr>
       <td>
        嵌套事务传播机制设置不当
       </td>
       <td>
        REQUIRES_NEW 导致事务隔离
       </td>
       <td>
        使用 NESTED 或 REQUIRED
       </td>
      </tr>
      <tr>
       <td>
        事务管理器配置错误
       </td>
       <td>
        数据源和事务管理器不匹配
       </td>
       <td>
        确保事务管理器正确绑定数据源
       </td>
      </tr>
      <tr>
       <td>
        Bean 非 Spring 托管
       </td>
       <td>
        new 对象不会触发代理机制
       </td>
       <td>
        让 Spring 托管 Bean
       </td>
      </tr>
      <tr>
       <td>
        @EnableTransactionManagement 未开启
       </td>
       <td>
        没有启用事务管理器
       </td>
       <td>
        显式开启事务管理器
       </td>
      </tr>
      <tr>
       <td>
        数据库层面问题
       </td>
       <td>
        MySQL 触发器或权限问题
       </td>
       <td>
        检查数据库配置
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
     ✨
     <strong>
      思考题：
     </strong>
    </p>
    <ol>
     <li>
      如何在同一类方法调用时，确保事务能够生效？
     </li>
     <li>
      为什么捕获异常后事务不会回滚？
     </li>
     <li>
      事务和线程之间的关系是怎样的？
     </li>
    </ol>
    <p>
    </p>
    <p>
     如果觉得这篇文章对你有帮助，记得点赞⭐、收藏📌、关注🚀！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353237373036382f:61727469636c652f64657461696c732f313436313435373531" class_="artid" style="display:none">
 </p>
</div>


