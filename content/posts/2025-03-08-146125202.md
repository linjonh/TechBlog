---
layout: post
title: "系统架构设计师系统架构设计篇软件架构风格"
date: 2025-03-08 23:47:29 +0800
description: "软件体系结构（架构）风格是描述某一特定应用领域中系统组织方式的惯用模式。体系结构风格定义一个系统家族，即一个体系结构定义一个词汇表和一组约束。词汇表：包含一些构件和连接件类型。约束：指出系统是如何将这些构件和连接件组合起来的。体系结构风格反应了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。"
keywords: "系统架构设计师—系统架构设计篇—软件架构风格"
categories: ['系统架构设计师']
tags: ['软件架构风格', '系统架构']
artid: "146125202"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146125202
    alt: "系统架构设计师系统架构设计篇软件架构风格"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146125202
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146125202
cover: https://bing.ee123.net/img/rand?artid=146125202
image: https://bing.ee123.net/img/rand?artid=146125202
img: https://bing.ee123.net/img/rand?artid=146125202
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     系统架构设计师—系统架构设计篇—软件架构风格
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     概述
    </h2>
    <p>
     软件体系结构（架构）风格是描述
     <strong>
      某一特定应用领域
     </strong>
     中系统组织方式的
     <strong>
      惯用模式
     </strong>
     。
    </p>
    <p>
     体系结构风格定义一个系统家族，即一个体系结构定义
     <strong>
      一个词汇表
     </strong>
     和
     <strong>
      一组约束
     </strong>
     。
    </p>
    <ul>
     <li>
      <strong>
       词汇表
      </strong>
      ：包含一些构件和连接件类型。
     </li>
     <li>
      <strong>
       约束
      </strong>
      ：指出系统是如何将这些构件和连接件组合起来的。
     </li>
    </ul>
    <p>
     <strong>
      体系结构风格
     </strong>
     反应了领域中众多系统所共有的
     <strong>
      结构
     </strong>
     和
     <strong>
      语义特性
     </strong>
     ，并指导如何将各个模块和子系统有效地组织成一个完整的系统。
    </p>
    <h2>
     <a id="_10">
     </a>
     经典体系结构风格
    </h2>
    <ul>
     <li>
      数据流风格
      <ul>
       <li>
        批处理
       </li>
       <li>
        管道过滤器
       </li>
      </ul>
     </li>
     <li>
      调用/返回风格
      <ul>
       <li>
        主程序/子程序
       </li>
       <li>
        面向对象风格
       </li>
       <li>
        层次结构风格
       </li>
      </ul>
     </li>
     <li>
      独立构件风格
      <ul>
       <li>
        进程通信
       </li>
       <li>
        事件驱动的系统
       </li>
      </ul>
     </li>
     <li>
      虚拟机风格
      <ul>
       <li>
        解释器
       </li>
       <li>
        基于规则的系统
       </li>
      </ul>
     </li>
     <li>
      仓库风格（数据共享风格）
      <ul>
       <li>
        数据库系统
       </li>
       <li>
        黑板系统
       </li>
       <li>
        超文本系统
       </li>
      </ul>
     </li>
     <li>
      闭环控制风格
     </li>
     <li>
      C2风格
     </li>
    </ul>
    <h3>
     <a id="_31">
     </a>
     数据流风格
    </h3>
    <h4>
     <a id="_32">
     </a>
     批处理
    </h4>
    <ul>
     <li>
      每一步处理都是独立的，并且每一步是顺序执行的。
     </li>
     <li>
      只有当前一步处理完成，后一步才能开始处理。
     </li>
     <li>
      <strong>
       数据必须是完整的
      </strong>
      ，以整体的方式传递。
     </li>
     <li>
      如：日志分析、计费程序、数据仓库等。
     </li>
    </ul>
    <h4>
     <a id="_38">
     </a>
     管道过滤器
    </h4>
    <ul>
     <li>
      每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。
     </li>
     <li>
      这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。
     </li>
     <li>
      如传统的编译期、UNIX管道等。
     </li>
    </ul>
    <h4>
     <a id="_43">
     </a>
     对比
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        批处理
       </th>
       <th>
        管道过滤器
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        整体数据传送
       </td>
       <td>
        增量数据传送
       </td>
      </tr>
      <tr>
       <td>
        构件粒度大
       </td>
       <td>
        构件粒度小
       </td>
      </tr>
      <tr>
       <td>
        延迟高、实时性差
       </td>
       <td>
        实时性好
       </td>
      </tr>
      <tr>
       <td>
        无并发
       </td>
       <td>
        可并发
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_52">
     </a>
     调用/返回风格
    </h3>
    <h4>
     <a id="_53">
     </a>
     主程序/子程序
    </h4>
    <ul>
     <li>
      一般采用单线程控制。
     </li>
     <li>
      把问题划分成若干处理步骤，主程序的正确性取决于他调用的子程序的正确性。
     </li>
     <li>
      如开发语言。
     </li>
    </ul>
    <h4>
     <a id="_58">
     </a>
     面向对象架构风格
    </h4>
    <ul>
     <li>
      数据的标识鄂它们的相应操作被封装起来，对象的行为体现在其接受和请求的动作中。
     </li>
     <li>
      对象具有封装性，一个对象的改变不会影响其他对象。
     </li>
     <li>
      如面向对象开发语言。
     </li>
    </ul>
    <h4>
     <a id="_63">
     </a>
     层次架构风格
    </h4>
    <ul>
     <li>
      每一层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。
     </li>
     <li>
      在层次结构中，修改某一层，最多影响其相邻的上下两层（通常只能影响上层）。
     </li>
     <li>
      上层必须指导下层的身份，不能调整层次之间的顺序。
     </li>
     <li>
      如TCP/IP协议。
     </li>
    </ul>
    <h3>
     <a id="_69">
     </a>
     独立构件风格
    </h3>
    <p>
     主要特点：每个构件都是独立的个体，可以代表一切体现
     <strong>
      封装
     </strong>
     的“对象”。
     <br/>
     例如：小到代码级的函数、类，大到一个服务端进程、集群、完整的系统。
    </p>
    <h4>
     <a id="_72">
     </a>
     进程通信
    </h4>
    <p>
     进程间消息传递的方式可以是点对点、异步或同步方式，以及远程过程（方法）调用等。
    </p>
    <h4>
     <a id="_74">
     </a>
     事件驱动的系统
    </h4>
    <ul>
     <li>
      当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。
     </li>
     <li>
      一个事件的触发就导致另一个模块中的过程调用。这是一种隐式调用的方式，优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便，其缺点是构件放弃了对系统计算的控制。
     </li>
     <li>
      如：断点调试、新闻、公众号等订阅信息。
     </li>
    </ul>
    <h3>
     <a id="_79">
     </a>
     虚拟机风格
    </h3>
    <p>
     当底层不支持上层时，在两者之间加入一层虚拟机做模拟仿真，消除硬件和软件之间的差异。
    </p>
    <ul>
     <li>
      解题技巧：自定义、灵活
     </li>
    </ul>
    <h4>
     <a id="_83">
     </a>
     解释器
    </h4>
    <ul>
     <li>
      <p>
       通常包括一个完成解释工作的解释引擎、一个包含将被解释代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行进度的数据结构。
      </p>
     </li>
     <li>
      <p>
       缺点是执行效率比较低。
      </p>
     </li>
     <li>
      <p>
       如JVM。
      </p>
     </li>
     <li>
      <p>
       解题技巧：游戏
      </p>
     </li>
    </ul>
    <h4>
     <a id="_89">
     </a>
     基于规则的系统
    </h4>
    <ul>
     <li>
      包括规则集、规则解释器、规则/数据选择器和工作内存。
     </li>
     <li>
      一般用在人工智能领域和
      <br/>
      决策支持系统（Decision-making Support System, DSS）中。
     </li>
    </ul>
    <h3>
     <a id="_94">
     </a>
     仓库风格（数据共享风格）
    </h3>
    <h4>
     <a id="_95">
     </a>
     数据库系统
    </h4>
    <ul>
     <li>
      <p>
       构件分为中央共享数据源、独立处理单元。
      </p>
     </li>
     <li>
      <p>
       构件控制中央共享数据。
      </p>
     </li>
     <li>
      <p>
       如
       <strong>
        IDE集成开发环境
       </strong>
       、
       <strong>
        注册表
       </strong>
       、
       <strong>
        剪贴板
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       一个或多个构件以
       <strong>
        主动触发
       </strong>
       的方式以
       <strong>
        调用顺序
       </strong>
       去更新共享数据存储区。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_102">
     </a>
     黑板系统
    </h4>
    <ul>
     <li>
      <p>
       包括
       <strong>
        知识源
       </strong>
       、
       <strong>
        黑板
       </strong>
       和
       <strong>
        控制
       </strong>
       三个部分。
      </p>
     </li>
     <li>
      <p>
       知识源：若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板。
      </p>
     </li>
     <li>
      <p>
       黑板：一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯一媒介。知识源响应是通过黑板状态的变化来控制的。
      </p>
     </li>
     <li>
      <p>
       黑板系统通常应用在
       <strong>
        对于解决问题没有确定性算法的软件中
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       如
       <strong>
        语音识别
       </strong>
       、
       <strong>
        信号处理
       </strong>
       。
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/53a17677ce434d21979e01714aca7f03.png"/>
      </p>
     </li>
     <li>
      <p>
       与数据库系统相反，一个或多个构件由
       <strong>
        控制单元通知
       </strong>
       以
       <strong>
        被动触发
       </strong>
       的方式以
       <strong>
        不确定
       </strong>
       的顺序去更新共享数据存储区。
      </p>
     </li>
     <li>
      <p>
       每个构件可能多次参与执行流程，但流程本身无法事先确定。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_114">
     </a>
     超文本系统
    </h4>
    <ul>
     <li>
      <p>
       静态网页
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/02f23cd163d642b6a626ed8d23c72802.png"/>
      </p>
     </li>
     <li>
      <p>
       超文本系统中出现的构件以网状链接方式相互连接，用户可以在构件之间按照人类的思维方式任意跳转到相关构件。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_120">
     </a>
     闭环控制风格
    </h3>
    <p>
     闭环（过程）控制是将过程输出的指定属性维护在一个特定的参考值（设定值），将事务处理看成输入、加工、输出、反馈、再输入的一个持续的过程模型。
     <br/>
     实例：空调的温度自动调节器（设定值是温度）、定速巡航系统（设定值是速度）。
    </p>
    <p>
     闭环控制是根据控制对象输出反馈来进行校正的控制方式，它是在测定实际与计划发生偏差时，按定额或标准来进行纠正的。
    </p>
    <ul>
     <li>
      解题技巧：空调的温度调节系统、巡航系统，数据流转允许存在环路，循环过程。
     </li>
    </ul>
    <h3>
     <a id="C2_127">
     </a>
     C2风格
    </h3>
    <p>
     C2体系结构风格可以概括为通过连接件绑定在一起按照一组规则运作的并行构件风格。
    </p>
    <p>
     C2风格中的系统组织规则如下：
    </p>
    <ol>
     <li>
      系统中的构件和连接都有一个顶部和一个底部。
     </li>
     <li>
      构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部。而
      <strong>
       构件与构件之间的直接连接是不允许的
      </strong>
      。
     </li>
     <li>
      一个连接件可以和任意数目的其他构件和连接件连接。
     </li>
     <li>
      当两个连接件进行直接连接时，
      <strong>
       必须由其中一个的底部连接到另一个的顶部
      </strong>
      。
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/86b796cd63f04afb9aeea44284ea4ac5.png"/>
    </p>
    <h3>
     <a id="CS_140">
     </a>
     二层C/S架构风格
    </h3>
    <p>
     二层C/S架构为单一服务器且以局域网为中心，所以难以扩展至大型企业广域网或Internet；软、硬件的组合及集成能力有限。
    </p>
    <p>
     它的缺点主要有：
    </p>
    <ol>
     <li>
      服务器的负荷太重，难以管理大量的客户机，系统的性能容易变坏。
     </li>
     <li>
      数据安全性不好。客户端可以直接访问服务器，那么客户端上其他程序也可想办法访问服务器，从而使服务器的安全性受到威胁。
     </li>
    </ol>
    <h3>
     <a id="CS_148">
     </a>
     三层C/S架构风格
    </h3>
    <p>
     与二层C/S架构相比，在三层C/S架构中，
     <strong>
      增加
     </strong>
     了一个
     <strong>
      应用服务器
     </strong>
     。可以将整个应用逻辑驻留在应用服务器上，而只有表示层存在于客户机上。这种客户机称为瘦客户机。
    </p>
    <p>
     三层C/S架构将应用系统分成
     <strong>
      表示层、功能层、数据层
     </strong>
     三个部分。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        层次
       </th>
       <th>
        功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        表示层
       </td>
       <td>
        <strong>
         用户接口
        </strong>
        ，检查用户输入的数据，显示输出的数据。
       </td>
      </tr>
      <tr>
       <td>
        功能层
       </td>
       <td>
        业务逻辑层，是将具体的业务处理逻辑编入程序中。
       </td>
      </tr>
      <tr>
       <td>
        数据层
       </td>
       <td>
        对DBMS进行管理和控制。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     与传统二层C/S架构相比，三层C/S架构具有以下优点：
    </p>
    <ol>
     <li>
      允许合理地划分三层结构，使之在逻辑上保持相对独立性，从而使整个系统的逻辑结构更为清晰，能提高系统的可维护性和可扩展性。
     </li>
     <li>
      允许更灵活、有效地选用相应的平台和硬件系统，使之在处理负荷能力与处理特性上分别适应于结构清晰的三层，并且这些平台和各个组成部分可以都具有良好的可升级性和开放性。
     </li>
     <li>
      系统的各层可以并行开发，各层也可以选择最适合的开发语言，使之能并行且高效的开发，达到较高的性能价格比。对每一层的处理逻辑的开发和维护也会更容易些。
     </li>
     <li>
      利用功能层可以有效地隔离表示层与数据层，未授权的用户难以绕过功能层去利用数据库工具或黑客手段非法的访问数据层，这就为严格的安全性奠定了坚实的基础。
     </li>
    </ol>
    <h3>
     <a id="BS_166">
     </a>
     B/S架构
    </h3>
    <ul>
     <li>
      B/S-浏览器/服务器（Browser/Server）架构是三层C/S架构的一种实现方式，其具体结构为“浏览器/Web服务器/数据库服务器”。
     </li>
     <li>
      B/S架构利用WWW浏览器技术，结合浏览器的多种脚本语言，用通用浏览器就实现了原来需要复杂的专用软件才能实现的强大功能，并节约了开发成本。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f31383934313731332f:61727469636c652f64657461696c732f313436313235323032" class_="artid" style="display:none">
 </p>
</div>


