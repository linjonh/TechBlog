---
layout: post
title: "Linux进程1进程概念和进程状态"
date: 2025-03-15 21:49:55 +0800
description: "通过学习进程的创建、调度、同步等机制，你可以更好地掌握操作系统的运行原理，进而优化系统性能和解决实际问题。本文将从基础知识入手，带领大家逐步深入探索 Linux 中进程的各个方面，帮助你在 Linux 学习的道路上迈出坚实的第一步。"
keywords: "【Linux】进程（1）进程概念和进程状态"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "146122274"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146122274
    alt: "Linux进程1进程概念和进程状态"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146122274
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146122274
cover: https://bing.ee123.net/img/rand?artid=146122274
image: https://bing.ee123.net/img/rand?artid=146122274
img: https://bing.ee123.net/img/rand?artid=146122274
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Linux】进程（1）进程概念和进程状态
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" height="200" src="https://i-blog.csdnimg.cn/direct/c344ef600f044c059c9f08abc3d6be91.png" width="200"/>
    </p>
    <p style="text-align:center">
     <strong>
      🌟🌟
      <span style="color:#956fe7">
       作者主页：
      </span>
      <strong>
       <a href="https://blog.csdn.net/2301_80955819?type=sub&amp;subType=watch" title="ephemerals__">
        ephemerals__
       </a>
      </strong>
     </strong>
    </p>
    <p style="text-align:center">
     <strong>
      🌟🌟
      <span style="color:#956fe7">
       所属专栏：
      </span>
      <a href="https://blog.csdn.net/2301_80955819/category_12821738.html?spm=1001.2014.3001.5482" title="Linux">
       Linux
      </a>
     </strong>
    </p>
    <hr/>
    <h2 id="%E5%89%8D%E8%A8%80" name="%E5%89%8D%E8%A8%80">
     前言
    </h2>
    <p>
     在学习 Linux 操作系统的过程中，
     <strong>
      进程
     </strong>
     是一个至关重要的概念。无论你是想了解系统的基础操作，还是深入研究 Linux 内核，进程管理的理解都将为你打下坚实的基础。
     <span style="color:#956fe7">
      <strong>
       进程不仅是操作系统资源管理的核心，也是实现多任务处理的关键所在。
      </strong>
     </span>
     通过学习进程的创建、调度、同步等机制，你可以更好地掌握操作系统的运行原理，进而优化系统性能和解决实际问题。本文将从基础知识入手，带领大家逐步深入探索 Linux 中进程的各个方面，帮助你在 Linux 学习的道路上迈出坚实的第一步。
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B" name="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B">
     一、什么是进程
    </h2>
    <p>
     进程有多种描述方式，例如：程序的运行实例、正在执行的程序、操作系统进行资源调配的基本单位等。不过，以上说法都太理论化，我们用程序运行的实际情况来描述进程。
    </p>
    <p class="img-center">
     <img alt="" height="563" src="https://i-blog.csdnimg.cn/direct/517782e2bf514d54811d3cbad889d9eb.png" width="952"/>
    </p>
    <p>
     一个程序在执行前，其
     <strong>
      二进制代码和数据（变量、常量、堆栈数据等）
     </strong>
     需要加载到内存。当加载完成之后，操作系统就会为这一块代码和数据创建一个对应的
     <strong>
      <span style="color:#956fe7">
       PCB（也叫做进程控制块，本质是一个存储进程相关信息的结构体）
      </span>
     </strong>
     ，其中存在一个内存指针，指向代码和数据，便于访问。
    </p>
    <p>
     所以“进程”不仅仅包括了程序的运行实例，它也包括操作系统管理该进程的相关信息。简而言之，
     <span style="color:#fe2c24">
      <strong>
       “进程”是指PCB与程序代码数据的集合
      </strong>
     </span>
     。
     <span style="color:#ff9900">
      <strong>
       操作系统根据PCB来跟踪进程的执行状态，方便对进程进行调度。
      </strong>
     </span>
    </p>
    <p>
     而当有多个程序需要执行时，操作系统就会为每一个程序的代码和数据都创建一个对应的PCB
     <strong>
      （描述过程）
     </strong>
     ，再通过
     <strong>
      容器
     </strong>
     将所有的PCB串联起来
     <strong>
      （组织过程）
     </strong>
     。此时，
     <span style="color:#956fe7">
      <strong>
       操作系统对于进程的管理即为对容器的增删查改
      </strong>
     </span>
     。
    </p>
    <p>
     需要注意：
    </p>
    <blockquote>
     <p>
      在Linux下，
      <strong>
       PCB（进程控制块）是一个叫做task_struct的结构体
      </strong>
      ；进程的所有属性都可以通过task_struct直接或间接地找到。
     </p>
     <p>
      Linux下的task_struct之间通过
      <strong>
       双向链表
      </strong>
      进行连接。
     </p>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81task_struct%E7%9A%84%E5%86%85%E5%AE%B9" name="%E4%BA%8C%E3%80%81task_struct%E7%9A%84%E5%86%85%E5%AE%B9">
     二、task_struct的内容
    </h2>
    <p>
     task_struct有如下成员，用于表示进程各种状态信息，以及访问程序的代码和数据：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        进程标识符(PID)--区别其他进程
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        进程状态信息
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        优先级
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        程序计数器
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        内存指针--指向代码和数据
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        上下文数据
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        I/O状态信息
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        记账信息
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        其他信息
       </strong>
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#ff9900">
      <strong>
       之后的进程学习当中，我们将围绕以上成员数据，学习进程的相关概念及操作
      </strong>
     </span>
     。
    </p>
    <h2 id="%E4%B8%89%E3%80%81Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" name="%E4%B8%89%E3%80%81Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" style="background-color:transparent">
     三、Linux下进程基本操作
    </h2>
    <hr/>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       C语言函数
      </span>
     </strong>
     <span style="background-color:#ffd900">
      获取当前进程标识符和父进程的标识符（PID）：
     </span>
    </p>
    <pre><code class="language-cpp">getpid(); //返回当前进程标识符，返回值类型是pid_t
getppid(); //返回当前进程的父进程标识符</code></pre>
    <p>
     注意使用以上函数时，需要引头文件
     <strong>
      &lt;unistd.h&gt;
     </strong>
     。
    </p>
    <hr/>
    <p>
     <span style="background-color:#ffd900">
      使用指令查看当前所有进程：
     </span>
    </p>
    <pre><code class="language-bash">ps ajx</code></pre>
    <pre><code class="language-bash">ls /proc</code></pre>
    <hr/>
    <p>
     <span style="background-color:#ffd900">
      根据程序名查看某个进程信息：
     </span>
    </p>
    <pre><code class="language-bash">ps ajx | head -1 &amp;&amp; ps ajx | grep (可执行程序名)</code></pre>
    <hr/>
    <p>
     <span style="background-color:#ffd900">
      根据标识符查看进程文件：
     </span>
    </p>
    <pre><code class="language-bash">ll /proc/(标识符)</code></pre>
    <p>
     示例：
    </p>
    <p class="img-center">
     <img alt="" height="433" src="https://i-blog.csdnimg.cn/direct/379cd66a309f437ea70f363e038c129e.png" width="1085"/>
    </p>
    <p>
     我们可以重点关注一下图中列举出的两个文件
     <strong>
      cwd
     </strong>
     和
     <strong>
      exe
     </strong>
     ：
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       cwd指的是当前进程对应的可执行程序所在目录；
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       exe指的是当前进程对应的可执行程序位置。
      </strong>
     </span>
    </p>
    <hr/>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       C语言函数
      </span>
     </strong>
     <span style="background-color:#ffd900">
      修改当前进程所在路径：
     </span>
    </p>
    <pre><code class="language-cpp">chdir("（路径）");</code></pre>
    <p>
     注意使用该函数要引头文件
     <strong>
      &lt;unistd.h&gt;
     </strong>
     。
    </p>
    <hr/>
    <p>
     <span style="background-color:#ffd900">
      杀进程的两种方式：
     </span>
    </p>
    <p>
     <strong>
      1. ctrl + c
     </strong>
    </p>
    <p>
     <strong>
      2. 命令行输入kill -9  （进程标识符）
     </strong>
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B" name="%E5%9B%9B%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B" style="background-color:transparent">
     四、父进程和子进程
    </h2>
    <p>
     一个进程通过系统调用创建出的另一个进程称之为该进程的
     <strong>
      子进程
     </strong>
     ，反之该进程称为其
     <strong>
      父进程
     </strong>
     。在Linux下，我们在命令行输入的命令都是Bash（命令行解释器）的子进程。
    </p>
    <h3 id="1.%20%E7%94%A8fork%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B" name="1.%20%E7%94%A8fork%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B" style="background-color:transparent">
     1. 用fork函数创建子进程
    </h3>
    <p>
     fork是一个系统调用，存在于头文件
     <strong>
      &lt;unistd.h&gt;
     </strong>
     中，当执行fork函数之后，当前进程会
     <strong>
      创建一个子进程
     </strong>
     ，后续的代码会被父进程和子进程
     <span style="color:#956fe7">
      <strong>
       分别执行一次
      </strong>
     </span>
     。
    </p>
    <p>
     代码示例：
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    fork();
    printf("hello world\n");
    return 0;
}
</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" class="left" height="96" src="https://i-blog.csdnimg.cn/direct/f3023b4e1432410985e179ff4746e151.png" width="585"/>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       注意：fork函数创建的子进程没有自己的代码和数据，虽然操作系统为其创建了PCB，但是其内存指针指向的还是父进程的代码和数据。
      </strong>
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="494" src="https://i-blog.csdnimg.cn/direct/1ca03417f49147419e1544121532982c.png" width="876"/>
    </p>
    <p>
     子进程在创建成功后，
     <span style="color:#ff9900">
      <strong>
       fork函数会给子进程返回0，给父进程返回子进程的PID
      </strong>
     </span>
     。为什么会给父子进程不同的返回值呢？因为一个父进程可能会有多个子进程，给父进程返回子进程的PID，
     <span style="color:#956fe7">
      <strong>
       更方便父进程对子进程进行管理
      </strong>
     </span>
     。而子进程如果想要知道父进程的PID，直接调用getppidh函数即可。另外，
     <strong>
      返回值不同可以配合分支语句让父子进程执行不同的代码
     </strong>
     。示例如下：
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    pid_t id = fork();
    if(id == 0)//子进程
    {
        printf("我是子进程，我的pid是%d\n", getpid());
    }
    else//父进程
    {
        printf("我是父进程，我的pid是%d\n", getpid());
    }
    return 0;
}</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" height="62" src="https://i-blog.csdnimg.cn/direct/5e6897b0a0f841b889a4e39796f1d2f0.png" width="484"/>
    </p>
    <p>
     那么，为什么fork函数能够做到返回两个值呢？实际上fork函数在执行return语句之前，就已经创建好了子进程，此时就可以通过分支语句来区分给父进程和子进程的返回值。
    </p>
    <blockquote>
     <p>
      注意：虽然fork函数创建的子进程与父进程的代码是共享的，但如果父子任何一方要修改其中的数据，那么操作系统就会将数据进行拷贝，
      <span style="color:#956fe7">
       <strong>
        此时父子就各自维护自己的数据，本质上修改的是拷贝的数据
       </strong>
      </span>
      ，不会影响另一方。这种状况叫做
      <strong>
       写时拷贝
      </strong>
      。
     </p>
    </blockquote>
    <h2 id="%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81" name="%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">
     五、进程状态
    </h2>
    <p>
     对于不同的操作系统，进程状态可能略有不同，但常见的大体上的进程状态有如下几种：
     <strong>
      创建、就绪、运行、阻塞、终止、挂起
     </strong>
     。我们介绍一下其中最重要的三点：
     <span style="color:#ff9900">
      <strong>
       运行状态、阻塞状态和挂起状态
      </strong>
     </span>
     。
    </p>
    <h3 id="1.%20%E4%B8%89%E7%A7%8D%E9%87%8D%E8%A6%81%E7%8A%B6%E6%80%81" name="1.%20%E4%B8%89%E7%A7%8D%E9%87%8D%E8%A6%81%E7%8A%B6%E6%80%81">
     1. 三种重要状态
    </h3>
    <h4 id="%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81" name="%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81">
     <span style="background-color:#ffd900">
      运行状态
     </span>
    </h4>
    <p>
     首先要知道，一般情况下一个CPU维护一个
     <strong>
      进程调度队列
     </strong>
     ，该队列中存放着一个个PCB，等待CPU对它们进行调度。
     <span style="color:#956fe7">
      <strong>
       而一个PCB在运行队列中排队时，就称该进程处于运行状态
      </strong>
     </span>
     。
    </p>
    <h4 id="%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81" name="%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81">
     <span style="background-color:#ffd900">
      阻塞状态
     </span>
    </h4>
    <p>
     当一个进程需要
     <span style="color:#956fe7">
      <strong>
       等待某种资源或设备（如鼠标、键盘等）就绪时，该进程就处于阻塞状态
      </strong>
     </span>
     。阻塞状态的进程在代码层面的体现是：
     <strong>
      PCB从运行队列中移出，转而进入设备的等待队列当中
     </strong>
     。
    </p>
    <p>
     此时若设备准备就绪（如按下键盘），则操作系统会修改当前设备状态，然后检查等待队列，将等待队列中的PCB重新移动到运行队列当中，该进程重新恢复运行状态。
    </p>
    <h4 id="%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81" name="%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81">
     <span style="background-color:#ffd900">
      挂起状态
     </span>
    </h4>
    <p>
     <span style="color:#956fe7">
      <strong>
       当一个进程被暂停执行时，称该进程处于挂起状态
      </strong>
     </span>
     。 那么它的具体体现是什么呢？
    </p>
    <p>
     当内存空间较为吃紧时，操作系统会将一些暂时不需要使用的内存数据（
     <strong>
      如阻塞状态的
     </strong>
     <strong>
      PCB
     </strong>
     <strong>
      控制的代码和数据
     </strong>
     ）
     <span style="color:#ff9900">
      <strong>
       唤出
      </strong>
     </span>
     到磁盘中的swap交换分区。此时等待队列中的PCB不再维护该进程的代码和数据，这样的进程状态叫做
     <strong>
      阻塞挂起
     </strong>
     。
    </p>
    <p>
     此时，若设备准备就绪，则操作系统就将swap交换分区中的代码和数据重新
     <span style="color:#ff9900">
      <strong>
       唤入
      </strong>
     </span>
     到内存中，给PCB维护，然后恢复到运行状态。
    </p>
    <p>
     当内存空间严重不足时，操作系统会将运行状态的PCB控制的代码和数据也唤出到swap交换分区。此时称之为
     <strong>
      运行挂起
     </strong>
     。
    </p>
    <hr/>
    <p>
     由这三种状态在代码层面的一部分具体体现，我们可以得出如下结论：
     <span style="color:#fe2c24">
      <strong>
       进程状态的变化表现之一就是PCB在不同的数据结构之间移动，变化本质是操作系统对数据结构的增删查改
      </strong>
     </span>
     。
    </p>
    <h3 id="2.%20%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3" name="2.%20%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3">
     2. 内核链表的理解
    </h3>
    <p>
     之前提到，在Linux下，操作系统会使用双向链表将PCB串联起来，方便进程管理。那么为什么PCB还会出现在CPU维护的调度队列当中呢？其实task_struct确实是
     <strong>
      同时出现在两种数据结构当中
     </strong>
     的，它基于一种特殊的结构来实现：
    </p>
    <p class="img-center">
     <img alt="" height="771" src="https://i-blog.csdnimg.cn/direct/d4b71d307f2b48bca9100c49f70dd0a9.png" width="1304"/>
    </p>
    <p>
     task_struct当中，
     <span style="color:#956fe7">
      <strong>
       将用于构成双向链表的指针域封装成一个结构体list_head，它的指针指向的是其他task_struct的list_head
      </strong>
     </span>
     。那么既然指向另一个指针域，如何能访问到task_struct的其他成员呢？这就需要用到
     <strong>
      结构体内存对齐
     </strong>
     的相关知识了：结构体的成员都是按照自身的对齐数进行存储的，第一个成员变量的地址就是结构体的首地址。
     <span style="color:#ff9900">
      <strong>
       通过求出list_head相对于结构体第一个成员的偏移量，就能间接访问结构体的其他成员
      </strong>
     </span>
     。例如，如下表达式就可以表示
     <strong>
      next指针指向的list_head所在task_struct的首地址
     </strong>
     （其中links表示list_head的变量）：
    </p>
    <pre><code class="language-cpp">(struct task_struct*)(next - &amp;((struct task_struct*)0-&gt;links))</code></pre>
    <p>
     将0强转为task_struct*类型，求出成员links的地址，即为links的偏移量，然后用links的地址减去该偏移量，得出task_struct的首地址，再强转为task_struct*类型，然后就可以访问其他成员了。
    </p>
    <p>
     而其他指针域也可以通过这种方式访问task_struct的其余成员，但可以用不同的链接方式，形成不同的数据结构，这样就实现了
     <span style="color:#956fe7">
      <strong>
       一个PCB同时存在于多种数据结构
      </strong>
     </span>
     的壮举。
    </p>
    <h3 id="3.%20Linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81" name="3.%20Linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">
     3. Linux的进程状态
    </h3>
    <p>
     相比于之前提到的操作系统大体上的进程状态，Linux的进程状态就显得更加具体化。在Linux下，进程状态本质是task_struct内的
     <strong>
      长整型变量
     </strong>
     ，它有以下几种进程状态表示：
    </p>
    <pre><code class="language-cpp">static const char *const task_state_array[] = {
    "R (running)", /*0 */
    "S (sleeping)", /*1 */
    "D (disk sleep)", /*2 */
    "T (stopped)", /*4 */
    "t (tracing stop)", /*8 */
    "X (dead)", /*16 */
    "Z (zombie)", /*32 */
};</code></pre>
    <p>
     <strong>
      R：运行状态
     </strong>
    </p>
    <p>
     <strong>
      S：休眠状态（可中断休眠）
     </strong>
    </p>
    <p>
     <strong>
      D：深度睡眠状态（不可中断休眠）
     </strong>
    </p>
    <blockquote>
     <p>
      进程处于深度睡眠状态时，不可被杀。
     </p>
    </blockquote>
    <p>
     <strong>
      T：暂停状态--用户手动暂停进程（如Ctrl + z）
     </strong>
    </p>
    <p>
     <strong>
      t：追踪状态--调试过程中执行到断点处，进程被暂停
     </strong>
    </p>
    <p>
     <strong>
      x：死亡状态
     </strong>
    </p>
    <p>
     <strong>
      z：僵尸状态--子进程在死亡之后，代码和数据可以释放，但其PCB不能直接释放，需要被父进程读取信息，读取信息之前称之为僵尸状态。
     </strong>
    </p>
    <blockquote>
     <p>
      <span style="color:#956fe7">
       <strong>
        注意：如果父进程一直都不读取子进程的信息，那么僵尸状态就会一直存在，PCB也会一直存在，这就导致了内存泄漏。
       </strong>
      </span>
     </p>
    </blockquote>
    <h4 id="%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%C2%A0" name="%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%C2%A0">
     孤儿进程
    </h4>
    <p>
     除了以上几种状态，进程还有一种特殊情况：
     <span style="color:#ff9900">
      <strong>
       孤儿进程
      </strong>
     </span>
     。 当父进程先死亡，子进程就会被
     <span style="color:#4da8ee">
      <strong>
       1号进程
      </strong>
     </span>
     领养，成为新的父进程，此时该子进程就被称作孤儿进程。
    </p>
    <blockquote>
     <p>
      注：
      <strong>
       1 号进程（init 或 systemd）
      </strong>
      是 Linux 系统中的第一个用户态进程，负责初始化系统并管理其他进程。它由内核在系统启动时创建，PID固定为 1。现代 Linux 主要使用 systemd 作为 1 号进程，提供服务管理、日志收集和系统控制功能，而早期系统则使用 sysvinit 或 upstart。如果 1 号进程崩溃，系统通常会进入不可用状态，需要重启。
     </p>
    </blockquote>
    <p>
     那么为什么子进程会被1号进程领养呢？如果1号进程不领养它，则当子进程死亡后，
     <span style="color:#956fe7">
      <strong>
       没有父进程读取信息，就会造成内存泄漏
      </strong>
     </span>
     。
    </p>
    <h2 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93">
     总结
    </h2>
    <p>
     通过本篇文章，我们学习了Linux进程的基础知识，包括进程概念、task_struct 结构、进程状态以及父子进程关系，希望这篇文章能帮助你更清晰地理解Linux进程的运行机制。如果你觉得博主讲的还不错，就请留下一个小小的赞在走哦，感谢大家的支持❤❤❤
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303935353831392f:61727469636c652f64657461696c732f313436313232323734" class_="artid" style="display:none">
 </p>
</div>


