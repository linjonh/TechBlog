---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303935353831392f:61727469636c652f64657461696c732f313436313232323734"
layout: post
title: "Linux进程1进程概念和进程状态"
date: 2025-03-15 21:49:55 +08:00
description: "通过学习进程的创建、调度、同步等机制，你可以更好地掌握操作系统的运行原理，进而优化系统性能和解决实际问题。本文将从基础知识入手，带领大家逐步深入探索 Linux 中进程的各个方面，帮助你在 Linux 学习的道路上迈出坚实的第一步。"
keywords: "【Linux】进程（1）进程概念和进程状态"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "146122274"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146122274
    alt: "Linux进程1进程概念和进程状态"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146122274
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146122274
cover: https://bing.ee123.net/img/rand?artid=146122274
image: https://bing.ee123.net/img/rand?artid=146122274
img: https://bing.ee123.net/img/rand?artid=146122274
---

# 【Linux】进程（1）进程概念和进程状态

![](https://i-blog.csdnimg.cn/direct/c344ef600f044c059c9f08abc3d6be91.png)

**🌟🌟
作者主页：
**[ephemerals\_\_](https://blog.csdn.net/2301_80955819?type=sub&subType=watch "ephemerals__")****

**🌟🌟
所属专栏：
[Linux](https://blog.csdn.net/2301_80955819/category_12821738.html?spm=1001.2014.3001.5482 "Linux")**

---

## 前言

在学习 Linux 操作系统的过程中，
**进程**
是一个至关重要的概念。无论你是想了解系统的基础操作，还是深入研究 Linux 内核，进程管理的理解都将为你打下坚实的基础。
**进程不仅是操作系统资源管理的核心，也是实现多任务处理的关键所在。**
通过学习进程的创建、调度、同步等机制，你可以更好地掌握操作系统的运行原理，进而优化系统性能和解决实际问题。本文将从基础知识入手，带领大家逐步深入探索 Linux 中进程的各个方面，帮助你在 Linux 学习的道路上迈出坚实的第一步。

## 一、什么是进程

进程有多种描述方式，例如：程序的运行实例、正在执行的程序、操作系统进行资源调配的基本单位等。不过，以上说法都太理论化，我们用程序运行的实际情况来描述进程。

![](https://i-blog.csdnimg.cn/direct/517782e2bf514d54811d3cbad889d9eb.png)

一个程序在执行前，其
**二进制代码和数据（变量、常量、堆栈数据等）**
需要加载到内存。当加载完成之后，操作系统就会为这一块代码和数据创建一个对应的
**PCB（也叫做进程控制块，本质是一个存储进程相关信息的结构体）**
，其中存在一个内存指针，指向代码和数据，便于访问。

所以“进程”不仅仅包括了程序的运行实例，它也包括操作系统管理该进程的相关信息。简而言之，
**“进程”是指PCB与程序代码数据的集合**
。
**操作系统根据PCB来跟踪进程的执行状态，方便对进程进行调度。**

而当有多个程序需要执行时，操作系统就会为每一个程序的代码和数据都创建一个对应的PCB
**（描述过程）**
，再通过
**容器**
将所有的PCB串联起来
**（组织过程）**
。此时，
**操作系统对于进程的管理即为对容器的增删查改**
。

需要注意：

> 在Linux下，
> **PCB（进程控制块）是一个叫做task\_struct的结构体**
> ；进程的所有属性都可以通过task\_struct直接或间接地找到。
>
> Linux下的task\_struct之间通过
> **双向链表**
> 进行连接。

## 二、task\_struct的内容

task\_struct有如下成员，用于表示进程各种状态信息，以及访问程序的代码和数据：

* **进程标识符(PID)--区别其他进程**
* **进程状态信息**
* **优先级**
* **程序计数器**
* **内存指针--指向代码和数据**
* **上下文数据**
* **I/O状态信息**
* **记账信息**
* **其他信息**

**之后的进程学习当中，我们将围绕以上成员数据，学习进程的相关概念及操作**
。

## 三、Linux下进程基本操作

---

**C语言函数**

获取当前进程标识符和父进程的标识符（PID）：

```cpp
getpid(); //返回当前进程标识符，返回值类型是pid_t
getppid(); //返回当前进程的父进程标识符
```

注意使用以上函数时，需要引头文件
**<unistd.h>**
。

---

使用指令查看当前所有进程：

```bash
ps ajx
```

```bash
ls /proc
```

---

根据程序名查看某个进程信息：

```bash
ps ajx | head -1 && ps ajx | grep (可执行程序名)
```

---

根据标识符查看进程文件：

```bash
ll /proc/(标识符)
```

示例：

![](https://i-blog.csdnimg.cn/direct/379cd66a309f437ea70f363e038c129e.png)

我们可以重点关注一下图中列举出的两个文件
**cwd**
和
**exe**
：

**cwd指的是当前进程对应的可执行程序所在目录；**

**exe指的是当前进程对应的可执行程序位置。**

---

**C语言函数**

修改当前进程所在路径：

```cpp
chdir("（路径）");
```

注意使用该函数要引头文件
**<unistd.h>**
。

---

杀进程的两种方式：

**1. ctrl + c**

**2. 命令行输入kill -9  （进程标识符）**

## 四、父进程和子进程

一个进程通过系统调用创建出的另一个进程称之为该进程的
**子进程**
，反之该进程称为其
**父进程**
。在Linux下，我们在命令行输入的命令都是Bash（命令行解释器）的子进程。

### 1. 用fork函数创建子进程

fork是一个系统调用，存在于头文件
**<unistd.h>**
中，当执行fork函数之后，当前进程会
**创建一个子进程**
，后续的代码会被父进程和子进程
**分别执行一次**
。

代码示例：

```cpp
#include <stdio.h>
#include <unistd.h>

int main()
{
    fork();
    printf("hello world\n");
    return 0;
}

```

运行结果：

![](https://i-blog.csdnimg.cn/direct/f3023b4e1432410985e179ff4746e151.png)

**注意：fork函数创建的子进程没有自己的代码和数据，虽然操作系统为其创建了PCB，但是其内存指针指向的还是父进程的代码和数据。**

![](https://i-blog.csdnimg.cn/direct/1ca03417f49147419e1544121532982c.png)

子进程在创建成功后，
**fork函数会给子进程返回0，给父进程返回子进程的PID**
。为什么会给父子进程不同的返回值呢？因为一个父进程可能会有多个子进程，给父进程返回子进程的PID，
**更方便父进程对子进程进行管理**
。而子进程如果想要知道父进程的PID，直接调用getppidh函数即可。另外，
**返回值不同可以配合分支语句让父子进程执行不同的代码**
。示例如下：

```cpp
#include <stdio.h>
#include <unistd.h>

int main()
{
    pid_t id = fork();
    if(id == 0)//子进程
    {
        printf("我是子进程，我的pid是%d\n", getpid());
    }
    else//父进程
    {
        printf("我是父进程，我的pid是%d\n", getpid());
    }
    return 0;
}
```

运行结果：

![](https://i-blog.csdnimg.cn/direct/5e6897b0a0f841b889a4e39796f1d2f0.png)

那么，为什么fork函数能够做到返回两个值呢？实际上fork函数在执行return语句之前，就已经创建好了子进程，此时就可以通过分支语句来区分给父进程和子进程的返回值。

> 注意：虽然fork函数创建的子进程与父进程的代码是共享的，但如果父子任何一方要修改其中的数据，那么操作系统就会将数据进行拷贝，
> **此时父子就各自维护自己的数据，本质上修改的是拷贝的数据**
> ，不会影响另一方。这种状况叫做
> **写时拷贝**
> 。

## 五、进程状态

对于不同的操作系统，进程状态可能略有不同，但常见的大体上的进程状态有如下几种：
**创建、就绪、运行、阻塞、终止、挂起**
。我们介绍一下其中最重要的三点：
**运行状态、阻塞状态和挂起状态**
。

### 1. 三种重要状态

#### 运行状态

首先要知道，一般情况下一个CPU维护一个
**进程调度队列**
，该队列中存放着一个个PCB，等待CPU对它们进行调度。
**而一个PCB在运行队列中排队时，就称该进程处于运行状态**
。

#### 阻塞状态

当一个进程需要
**等待某种资源或设备（如鼠标、键盘等）就绪时，该进程就处于阻塞状态**
。阻塞状态的进程在代码层面的体现是：
**PCB从运行队列中移出，转而进入设备的等待队列当中**
。

此时若设备准备就绪（如按下键盘），则操作系统会修改当前设备状态，然后检查等待队列，将等待队列中的PCB重新移动到运行队列当中，该进程重新恢复运行状态。

#### 挂起状态

**当一个进程被暂停执行时，称该进程处于挂起状态**
。 那么它的具体体现是什么呢？

当内存空间较为吃紧时，操作系统会将一些暂时不需要使用的内存数据（
**如阻塞状态的**
**PCB**
**控制的代码和数据**
）
**唤出**
到磁盘中的swap交换分区。此时等待队列中的PCB不再维护该进程的代码和数据，这样的进程状态叫做
**阻塞挂起**
。

此时，若设备准备就绪，则操作系统就将swap交换分区中的代码和数据重新
**唤入**
到内存中，给PCB维护，然后恢复到运行状态。

当内存空间严重不足时，操作系统会将运行状态的PCB控制的代码和数据也唤出到swap交换分区。此时称之为
**运行挂起**
。

---

由这三种状态在代码层面的一部分具体体现，我们可以得出如下结论：
**进程状态的变化表现之一就是PCB在不同的数据结构之间移动，变化本质是操作系统对数据结构的增删查改**
。

### 2. 内核链表的理解

之前提到，在Linux下，操作系统会使用双向链表将PCB串联起来，方便进程管理。那么为什么PCB还会出现在CPU维护的调度队列当中呢？其实task\_struct确实是
**同时出现在两种数据结构当中**
的，它基于一种特殊的结构来实现：

![](https://i-blog.csdnimg.cn/direct/d4b71d307f2b48bca9100c49f70dd0a9.png)

task\_struct当中，
**将用于构成双向链表的指针域封装成一个结构体list\_head，它的指针指向的是其他task\_struct的list\_head**
。那么既然指向另一个指针域，如何能访问到task\_struct的其他成员呢？这就需要用到
**结构体内存对齐**
的相关知识了：结构体的成员都是按照自身的对齐数进行存储的，第一个成员变量的地址就是结构体的首地址。
**通过求出list\_head相对于结构体第一个成员的偏移量，就能间接访问结构体的其他成员**
。例如，如下表达式就可以表示
**next指针指向的list\_head所在task\_struct的首地址**
（其中links表示list\_head的变量）：

```cpp
(struct task_struct*)(next - &((struct task_struct*)0->links))
```

将0强转为task\_struct*类型，求出成员links的地址，即为links的偏移量，然后用links的地址减去该偏移量，得出task\_struct的首地址，再强转为task\_struct*类型，然后就可以访问其他成员了。

而其他指针域也可以通过这种方式访问task\_struct的其余成员，但可以用不同的链接方式，形成不同的数据结构，这样就实现了
**一个PCB同时存在于多种数据结构**
的壮举。

### 3. Linux的进程状态

相比于之前提到的操作系统大体上的进程状态，Linux的进程状态就显得更加具体化。在Linux下，进程状态本质是task\_struct内的
**长整型变量**
，它有以下几种进程状态表示：

```cpp
static const char *const task_state_array[] = {
    "R (running)", /*0 */
    "S (sleeping)", /*1 */
    "D (disk sleep)", /*2 */
    "T (stopped)", /*4 */
    "t (tracing stop)", /*8 */
    "X (dead)", /*16 */
    "Z (zombie)", /*32 */
};
```

**R：运行状态**

**S：休眠状态（可中断休眠）**

**D：深度睡眠状态（不可中断休眠）**

> 进程处于深度睡眠状态时，不可被杀。

**T：暂停状态--用户手动暂停进程（如Ctrl + z）**

**t：追踪状态--调试过程中执行到断点处，进程被暂停**

**x：死亡状态**

**z：僵尸状态--子进程在死亡之后，代码和数据可以释放，但其PCB不能直接释放，需要被父进程读取信息，读取信息之前称之为僵尸状态。**

> **注意：如果父进程一直都不读取子进程的信息，那么僵尸状态就会一直存在，PCB也会一直存在，这就导致了内存泄漏。**

#### 孤儿进程

除了以上几种状态，进程还有一种特殊情况：
**孤儿进程**
。 当父进程先死亡，子进程就会被
**1号进程**
领养，成为新的父进程，此时该子进程就被称作孤儿进程。

> 注：
> **1 号进程（init 或 systemd）**
> 是 Linux 系统中的第一个用户态进程，负责初始化系统并管理其他进程。它由内核在系统启动时创建，PID固定为 1。现代 Linux 主要使用 systemd 作为 1 号进程，提供服务管理、日志收集和系统控制功能，而早期系统则使用 sysvinit 或 upstart。如果 1 号进程崩溃，系统通常会进入不可用状态，需要重启。

那么为什么子进程会被1号进程领养呢？如果1号进程不领养它，则当子进程死亡后，
**没有父进程读取信息，就会造成内存泄漏**
。

## 总结

通过本篇文章，我们学习了Linux进程的基础知识，包括进程概念、task\_struct 结构、进程状态以及父子进程关系，希望这篇文章能帮助你更清晰地理解Linux进程的运行机制。如果你觉得博主讲的还不错，就请留下一个小小的赞在走哦，感谢大家的支持❤❤❤