---
layout: post
title: "4linux-c-进程"
date: 2025-03-16 15:37:16 +0800
description: "存放在磁盘上的指令和数据的有序集合（文件），是静态的。：执行一个程序所分配的资源的总称，是动态的。"
keywords: "4、linux c 进程"
categories: ['Linuxc']
tags: ['运维', '服务器', 'Linux', 'C']
artid: "146296173"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296173
    alt: "4linux-c-进程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296173
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296173
cover: https://bing.ee123.net/img/rand?artid=146296173
image: https://bing.ee123.net/img/rand?artid=146296173
img: https://bing.ee123.net/img/rand?artid=146296173
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     4、linux c 进程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     【三】进程
    </h2>
    <h3>
     1. 进程与程序的区别
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        程序
       </strong>
       ：存放在磁盘上的指令和数据的有序集合（文件），是静态的。
      </p>
     </li>
     <li>
      <p>
       <strong>
        进程
       </strong>
       ：执行一个程序所分配的资源的总称，是动态的。
      </p>
     </li>
    </ul>
    <h3>
     2. 进程的组成部分
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        BSS段（bss）
       </strong>
       ：存放程序中未初始化的全局变量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据段（data）
       </strong>
       ：存放已初始化的全局变量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        代码段（text）
       </strong>
       ：存放程序执行代码。
      </p>
     </li>
     <li>
      <p>
       <strong>
        堆（heap）
       </strong>
       ：通过
       <code>
        malloc
       </code>
       等函数分配内存，动态扩张或缩减。
      </p>
     </li>
     <li>
      <p>
       <strong>
        栈（stack）
       </strong>
       ：存放局部变量、函数参数和函数返回值，先进后出。
      </p>
     </li>
     <li>
      <p>
       <strong>
        进程控制块（PCB）
       </strong>
       ：包含进程ID（PID）、进程优先级、文件描述符表等。
      </p>
     </li>
    </ul>
    <h3>
     3. 进程类型
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        交互进程
       </strong>
       ：用户通过终端与系统交互的进程。
      </p>
     </li>
     <li>
      <p>
       <strong>
        批处理进程
       </strong>
       ：在后台运行，不需要用户交互。
      </p>
     </li>
     <li>
      <p>
       <strong>
        守护进程
       </strong>
       ：在后台运行的特殊进程，通常用于系统服务。
      </p>
     </li>
    </ul>
    <h3>
     4. 进程状态
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        运行态
       </strong>
       ：进程正在运行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        等待态
       </strong>
       ：进程等待某些资源（如I/O）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        停止态
       </strong>
       ：进程被暂停。
      </p>
     </li>
     <li>
      <p>
       <strong>
        死亡态
       </strong>
       ：进程已结束，但父进程尚未读取其状态信息。
      </p>
     </li>
    </ul>
    <h3>
     5. 堆与栈
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        堆（heap）
       </strong>
       ：用于存放进程运行中被动态分配的内存段，当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
      </p>
     </li>
     <li>
      <p>
       <strong>
        栈（stack）
       </strong>
       ：又称堆栈，是用户存放程序临时创建的局部变量，（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
      </p>
     </li>
    </ul>
    <hr/>
    <h2>
     一、查看进程信息
    </h2>
    <h3>
     1.
     <code>
      ps
     </code>
     命令
    </h3>
    <p>
     用于查看系统进程的快照。
    </p>
    <h4>
     1.1 常用参数
    </h4>
    <ul>
     <li>
      <p>
       <code>
        -e
       </code>
       ：显示所有进程。
      </p>
     </li>
     <li>
      <p>
       <code>
        -l
       </code>
       ：长格式显示更详细信息。
      </p>
     </li>
     <li>
      <p>
       <code>
        -f
       </code>
       ：全格式显示，通常与其他选项联用。
      </p>
     </li>
    </ul>
    <h4>
     1.2 输出字段说明
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         字段
        </strong>
       </th>
       <th>
        <strong>
         含义
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         F
        </strong>
       </td>
       <td>
        进程标志，说明进程的权限。常见标志：1（不可执行）、4（超级用户权限）等。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         S
        </strong>
       </td>
       <td>
        进程状态。常见状态：-D（不可唤醒的睡眠状态）、-R（运行）、-S（睡眠）、-T（停止）、-Z（僵尸进程）等。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         UID
        </strong>
       </td>
       <td>
        运行此进程的用户ID。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         PID
        </strong>
       </td>
       <td>
        进程的ID。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         PPID
        </strong>
       </td>
       <td>
        父进程的ID。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         C
        </strong>
       </td>
       <td>
        进程的CPU使用率（百分比）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         PRI
        </strong>
       </td>
       <td>
        进程的优先级，数值越小优先级越高。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         NI
        </strong>
       </td>
       <td>
        进程的nice值，数值越小优先级越高。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         ADDR
        </strong>
       </td>
       <td>
        进程在内存中的位置。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         SZ
        </strong>
       </td>
       <td>
        进程占用的内存大小。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         WCHAN
        </strong>
       </td>
       <td>
        进程是否运行，"-"表示正在运行。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         TTY
        </strong>
       </td>
       <td>
        进程由哪个终端产生。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         TIME
        </strong>
       </td>
       <td>
        进程占用CPU的时间。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         CMD
        </strong>
       </td>
       <td>
        产生此进程的命令名。
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     1.3 示例
    </h4>
    <pre>ps -elf</pre>
    <h3>
     2.
     <code>
      top
     </code>
     命令
    </h3>
    <p>
     用于查看进程的动态信息。
    </p>
    <h4>
     2.1 常用操作
    </h4>
    <ul>
     <li>
      <p>
       <code>
        shift + &gt;
       </code>
       ：后翻页。
      </p>
     </li>
     <li>
      <p>
       <code>
        shift + &lt;
       </code>
       ：前翻页。
      </p>
     </li>
     <li>
      <p>
       <code>
        top -p PID
       </code>
       ：查看指定进程。
      </p>
     </li>
    </ul>
    <h3>
     3.
     <code>
      /proc
     </code>
     目录
    </h3>
    <p>
     用于查看进程的详细信息。
    </p>
    <p>
     每个进程在
     <code>
      /proc
     </code>
     目录下都有一个以PID命名的子目录，包含进程的各种信息文件，如
     <code>
      status
     </code>
     、
     <code>
      maps
     </code>
     等。
    </p>
    <hr/>
    <h2>
     二、改变进程优先级
    </h2>
    <h3>
     1.
     <code>
      nice
     </code>
     命令
    </h3>
    <p>
     按用户指定的优先级运行进程。
    </p>
    <h4>
     1.1 命令格式
    </h4>
    <pre>nice [-n NI值] 命令</pre>
    <ul>
     <li>
      <p>
       <strong>
        NI值范围
       </strong>
       ：-20~19。
      </p>
      <ul>
       <li>
        <p>
         数值越大，优先级越低。
        </p>
       </li>
       <li>
        <p>
         普通用户可调整范围为0~19，只能调高优先级。
        </p>
       </li>
       <li>
        <p>
         只有
         <code>
          root
         </code>
         用户可以设置负值。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     2.
     <code>
      renice
     </code>
     命令
    </h3>
    <p>
     改变正在运行进程的优先级。
    </p>
    <h4>
     2.1 命令格式
    </h4>
    <pre>renice [优先级] PID</pre>
    <hr/>
    <h2>
     三、进程管理
    </h2>
    <h3>
     1. 查看后台进程
    </h3>
    <h4>
     1.1 命令
    </h4>
    <pre>jobs</pre>
    <h3>
     2. 将挂起的进程在后台运行
    </h3>
    <h4>
     2.1 命令
    </h4>
    <pre>bg</pre>
    <h3>
     3. 将后台进程放到前台运行
    </h3>
    <h4>
     3.1 命令
    </h4>
    <pre>fg</pre>
    <h3>
     4. 将前台进程转为后台并停止
    </h3>
    <h4>
     4.1 操作
    </h4>
    <pre>Ctrl + Z</pre>
    <h3>
     5. 后台运行程序
    </h3>
    <h4>
     5.1 示例
    </h4>
    <pre>./test &amp;</pre>
    <hr/>
    <h2>
     四、创建子进程
    </h2>
    <h3>
     1.
     <code>
      fork()
     </code>
     函数
    </h3>
    <p>
     创建新的进程。
    </p>
    <h4>
     1.1 函数原型
    </h4>
    <pre>#include &lt;unistd.h&gt;
pid_t fork(void);</pre>
    <h4>
     1.2 返回值
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        成功
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         父进程返回子进程的PID。
        </p>
       </li>
       <li>
        <p>
         子进程返回0。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        失败
       </strong>
       ：返回-1。
      </p>
     </li>
    </ul>
    <h4>
     1.3 特点
    </h4>
    <ul>
     <li>
      <p>
       子进程只执行
       <code>
        fork()
       </code>
       之后的代码。
      </p>
     </li>
     <li>
      <p>
       父子进程的执行顺序由操作系统决定。
      </p>
     </li>
     <li>
      <p>
       子进程继承父进程的内容，但父子进程有独立的地址空间。
      </p>
     </li>
    </ul>
    <h4>
     1.4 注意事项
    </h4>
    <ul>
     <li>
      <p>
       若父进程先结束：
      </p>
      <ul>
       <li>
        <p>
         子进程成为孤儿进程，被
         <code>
          init
         </code>
         进程收养。
        </p>
       </li>
       <li>
        <p>
         子进程可能成为后台进程。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       若子进程先结束：
      </p>
      <ul>
       <li>
        <p>
         父进程如果没有及时回收，子进程变成僵尸进程。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     1.5 示例
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
​
int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        printf("I am the child process, PID: %d\n", getpid());
    } else {
        printf("I am the parent process, PID: %d, Child PID: %d\n", getpid(), pid);
    }
    return 0;
}</pre>
    <hr/>
    <h2>
     五、进程的退出
    </h2>
    <h3>
     1.
     <code>
      exit()
     </code>
     函数
    </h3>
    <p>
     结束当前进程。
    </p>
    <h4>
     1.1 函数原型
    </h4>
    <pre>#include &lt;stdlib.h&gt;
void exit(int status);</pre>
    <h4>
     1.2 特点
    </h4>
    <ul>
     <li>
      <p>
       会刷新流缓冲区。
      </p>
     </li>
     <li>
      <p>
       通常用于正常退出。
      </p>
     </li>
    </ul>
    <h3>
     2.
     <code>
      _exit()
     </code>
     函数
    </h3>
    <p>
     结束当前进程。
    </p>
    <h4>
     2.1 函数原型
    </h4>
    <pre>#include &lt;unistd.h&gt;
void _exit(int status);</pre>
    <h4>
     2.2 特点
    </h4>
    <ul>
     <li>
      <p>
       不刷新流缓冲区。
      </p>
     </li>
     <li>
      <p>
       通常用于异常退出。
      </p>
     </li>
    </ul>
    <h3>
     3.
     <code>
      return
     </code>
     与
     <code>
      exit
     </code>
     的区别
    </h3>
    <ul>
     <li>
      <p>
       <code>
        main
       </code>
       函数结束时会隐式调用
       <code>
        exit
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       普通函数的
       <code>
        return
       </code>
       是返回上一级。
      </p>
     </li>
    </ul>
    <hr/>
    <h2>
     六、进程的回收
    </h2>
    <h3>
     1.
     <code>
      wait()
     </code>
     函数
    </h3>
    <p>
     回收子进程。
    </p>
    <h4>
     1.1 函数原型
    </h4>
    <pre>#include &lt;unistd.h&gt;
pid_t wait(int *status);</pre>
    <h4>
     1.2 返回值
    </h4>
    <ul>
     <li>
      <p>
       成功时返回回收的子进程的 PID。
      </p>
     </li>
     <li>
      <p>
       失败时返回 -1。
      </p>
     </li>
    </ul>
    <h4>
     1.3 特点
    </h4>
    <ul>
     <li>
      <p>
       若子进程未结束，父进程会阻塞。
      </p>
     </li>
     <li>
      <p>
       <code>
        status
       </code>
       用于保存子进程的返回值和结束方式。
      </p>
     </li>
     <li>
      <p>
       若
       <code>
        status
       </code>
       为
       <code>
        NULL
       </code>
       ，表示直接释放子进程的 PCB。
      </p>
     </li>
    </ul>
    <h3>
     2.
     <code>
      waitpid()
     </code>
     函数
    </h3>
    <p>
     更灵活的子进程回收。
    </p>
    <h4>
     2.1 函数原型
    </h4>
    <pre>#include &lt;unistd.h&gt;
pid_t waitpid(pid_t pid, int *status, int options);</pre>
    <h4>
     2.2 参数说明
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         pid
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          &gt;0
         </code>
         ：只等待指定 PID 的子进程。
        </p>
       </li>
       <li>
        <p>
         <code>
          = -1
         </code>
         ：等待任意子进程。
        </p>
       </li>
       <li>
        <p>
         <code>
          = 0
         </code>
         ：等待同一进程组中的子进程。
        </p>
       </li>
       <li>
        <p>
         <code>
          &lt; -1
         </code>
         ：等待指定进程组中的子进程。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         options
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          WNOHANG
         </code>
         ：非阻塞，若子进程未结束，立即返回 0。
        </p>
       </li>
       <li>
        <p>
         <code>
          WUNTRACED
         </code>
         ：返回终止子进程信息和因信号停止的子进程信息。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     2.3 示例代码
    </h4>
    <h5>
     示例 1：
     <code>
      wait()
     </code>
     示例
    </h5>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
​
int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }
​
    if (pid == 0) {
        // 子进程
        printf("Child process, PID: %d\n", getpid());
        sleep(2); // 模拟子进程运行
        printf("Child process finished\n");
        return 0; // 子进程退出
    } else {
        // 父进程
        printf("Parent process, PID: %d, waiting for child...\n", getpid());
        int status;
        wait(&amp;status); // 等待子进程结束
        printf("Child process exited with status: %d\n", status);
        return 0;
    }
}</pre>
    <h5>
     示例 2：
     <code>
      waitpid()
     </code>
     示例
    </h5>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
​
int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }
​
    if (pid == 0) {
        // 子进程
        printf("Child process, PID: %d\n", getpid());
        sleep(3); // 模拟子进程运行
        printf("Child process finished\n");
        return 0; // 子进程退出
    } else {
        // 父进程
        printf("Parent process, PID: %d, waiting for child...\n", getpid());
        int status;
        pid_t ret = waitpid(pid, &amp;status, WNOHANG); // 非阻塞等待子进程
        if (ret == 0) {
            printf("Child process is still running\n");
        } else if (ret == -1) {
            perror("waitpid failed");
        } else {
            printf("Child process exited with status: %d\n", status);
        }
        return 0;
    }
}</pre>
    <hr/>
    <h2>
     七、
     <code>
      exec
     </code>
     函数族
    </h2>
    <h3>
     1. 背景
    </h3>
    <p>
     <code>
      fork
     </code>
     创建进程后，子进程会继承父进程的代码和数据，父子进程执行相同的代码。然而，在实际开发中，我们通常希望子进程执行与父进程不同的程序。
     <code>
      exec
     </code>
     函数族的作用就是用来替换当前进程的代码和数据，从而执行指定的程序。
    </p>
    <h3>
     2. 作用
    </h3>
    <p>
     <code>
      exec
     </code>
     函数族用于替换当前进程的代码和数据，执行指定的程序。这些函数不会创建新的进程，而是直接替换当前进程的内容。
    </p>
    <h3>
     3. 函数原型
    </h3>
    <pre>#include &lt;unistd.h&gt;
​
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int system(const char *command);</pre>
    <h3>
     4. 参数说明
    </h3>
    <h4>
     4.1
     <code>
      execl
     </code>
    </h4>
    <pre>int execl(const char *path, const char *arg, ...);</pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         path
        </code>
       </strong>
       ：指定要执行的程序的路径。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         arg
        </code>
       </strong>
       ：传递给程序的参数列表，必须以
       <code>
        NULL
       </code>
       结尾。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：参数列表是可变参数，每个参数都是字符串。
      </p>
     </li>
    </ul>
    <h4>
     4.2
     <code>
      execlp
     </code>
    </h4>
    <pre>int execlp(const char *file, const char *arg, ...);</pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         file
        </code>
       </strong>
       ：指定要执行的程序的文件名。
       <code>
        execlp
       </code>
       会在环境变量
       <code>
        PATH
       </code>
       中查找该文件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         arg
        </code>
       </strong>
       ：传递给程序的参数列表，必须以
       <code>
        NULL
       </code>
       结尾。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：不需要指定文件的全路径，
       <code>
        execlp
       </code>
       会自动在
       <code>
        PATH
       </code>
       中查找。
      </p>
     </li>
    </ul>
    <h4>
     4.3
     <code>
      execv
     </code>
    </h4>
    <pre>int execv(const char *path, char *const argv[]);</pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         path
        </code>
       </strong>
       ：指定要执行的程序的路径。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         argv
        </code>
       </strong>
       ：传递给程序的参数数组，必须以
       <code>
        NULL
       </code>
       结尾。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：参数以数组形式传递，适合参数较多的情况。
      </p>
     </li>
    </ul>
    <h4>
     4.4
     <code>
      execvp
     </code>
    </h4>
    <pre>int execvp(const char *file, char *const argv[]);</pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         file
        </code>
       </strong>
       ：指定要执行的程序的文件名。
       <code>
        execvp
       </code>
       会在环境变量
       <code>
        PATH
       </code>
       中查找该文件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         argv
        </code>
       </strong>
       ：传递给程序的参数数组，必须以
       <code>
        NULL
       </code>
       结尾。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：不需要指定文件的全路径，
       <code>
        execvp
       </code>
       会自动在
       <code>
        PATH
       </code>
       中查找。
      </p>
     </li>
    </ul>
    <h4>
     4.5
     <code>
      system
     </code>
    </h4>
    <pre>int system(const char *command);</pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         command
        </code>
       </strong>
       ：要执行的命令字符串。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
       <code>
        system
       </code>
       是一个高级函数，会调用
       <code>
        /bin/sh
       </code>
       来执行命令。它会创建一个子进程来运行命令，并等待命令执行完成。
      </p>
     </li>
    </ul>
    <h3>
     5. 返回值
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        成功
       </strong>
       ：执行指定的程序，不会返回到调用
       <code>
        exec
       </code>
       的代码。
      </p>
     </li>
     <li>
      <p>
       <strong>
        失败
       </strong>
       ：返回 -1，并设置
       <code>
        errno
       </code>
       。
      </p>
     </li>
    </ul>
    <h3>
     6. 特点
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        进程替换
       </strong>
       ：
       <code>
        exec
       </code>
       函数会替换当前进程的代码和数据，但进程号（PID）保持不变。
      </p>
     </li>
     <li>
      <p>
       <strong>
        参数传递
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         第一个参数（如
         <code>
          arg
         </code>
         或
         <code>
          argv[0]
         </code>
         ）通常是程序的名称，虽然它在程序中没有实际用途。
        </p>
       </li>
       <li>
        <p>
         参数列表或数组必须以
         <code>
          NULL
         </code>
         结尾。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        路径查找
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          execl
         </code>
         和
         <code>
          execv
         </code>
         需要指定程序的完整路径。
        </p>
       </li>
       <li>
        <p>
         <code>
          execlp
         </code>
         和
         <code>
          execvp
         </code>
         会在环境变量
         <code>
          PATH
         </code>
         中查找程序。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        环境变量
       </strong>
       ：
       <code>
        exec
       </code>
       函数不会改变当前进程的环境变量。
      </p>
     </li>
    </ol>
    <h3>
     7. 示例代码
    </h3>
    <h4>
     示例 1：
     <code>
      execl
     </code>
     示例
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
​
int main() {
    printf("Before exec\n");
    execl("/bin/ls", "ls", "-l", NULL); // 替换当前进程为 ls 程序
    printf("After exec\n"); // 不会执行到这里
    return 0;
}</pre>
    <h4>
     示例 2：
     <code>
      execlp
     </code>
     示例
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
​
int main() {
    printf("Before exec\n");
    execlp("ls", "ls", "-l", NULL); // 替换当前进程为 ls 程序
    printf("After exec\n"); // 不会执行到这里
    return 0;
}</pre>
    <h4>
     示例 3：
     <code>
      execv
     </code>
     示例
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
​
int main() {
    printf("Before exec\n");
    char *args[] = {"/bin/ls", "-l", NULL};
    execv("/bin/ls", args); // 替换当前进程为 ls 程序
    printf("After exec\n"); // 不会执行到这里
    return 0;
}</pre>
    <h4>
     示例 4：
     <code>
      execvp
     </code>
     示例
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
​
int main() {
    printf("Before exec\n");
    char *args[] = {"ls", "-l", NULL};
    execvp("ls", args); // 替换当前进程为 ls 程序
    printf("After exec\n"); // 不会执行到这里
    return 0;
}</pre>
    <h4>
     示例 5：
     <code>
      system
     </code>
     示例
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
​
int main() {
    printf("Before system\n");
    system("ls -l"); // 使用 shell 执行命令
    printf("After system\n"); // 会执行到这里
    return 0;
}</pre>
    <hr/>
    <h4>
     <code>
      exec
     </code>
     函数族的使用注意事项
    </h4>
    <h4>
     1. 参数传递
    </h4>
    <ul>
     <li>
      <p>
       参数列表或数组必须以
       <code>
        NULL
       </code>
       结尾，否则会导致未定义行为。
      </p>
     </li>
     <li>
      <p>
       第一个参数（如
       <code>
        arg
       </code>
       或
       <code>
        argv[0]
       </code>
       ）通常是程序的名称，虽然它在程序中没有实际用途，但建议正确填写。
      </p>
     </li>
    </ul>
    <h4>
     2. 环境变量
    </h4>
    <ul>
     <li>
      <p>
       <code>
        exec
       </code>
       函数不会改变当前进程的环境变量。如果需要修改环境变量，可以使用
       <code>
        putenv
       </code>
       或
       <code>
        setenv
       </code>
       函数。
      </p>
     </li>
    </ul>
    <h4>
     3. 文件描述符
    </h4>
    <ul>
     <li>
      <p>
       在调用
       <code>
        exec
       </code>
       函数之前，应确保关闭不需要的文件描述符，以避免资源泄漏。
      </p>
     </li>
     <li>
      <p>
       如果需要保留某些文件描述符（如日志文件），应确保它们在调用
       <code>
        exec
       </code>
       之前已正确打开。
      </p>
     </li>
    </ul>
    <h4>
     4. 错误处理
    </h4>
    <ul>
     <li>
      <p>
       如果
       <code>
        exec
       </code>
       函数失败，会返回 -1，并设置
       <code>
        errno
       </code>
       。可以通过
       <code>
        perror
       </code>
       或
       <code>
        strerror
       </code>
       获取错误信息。
      </p>
     </li>
     <li>
      <p>
       常见错误包括：
      </p>
      <ul>
       <li>
        <p>
         文件路径错误或文件不存在。
        </p>
       </li>
       <li>
        <p>
         文件没有执行权限。
        </p>
       </li>
       <li>
        <p>
         环境变量
         <code>
          PATH
         </code>
         中未找到程序。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <ol>
     <li>
      <p>
       与
       <code>
        fork
       </code>
       结合使用
      </p>
     </li>
    </ol>
    <ul>
     <li>
      <p>
       <code>
        exec
       </code>
       函数通常与
       <code>
        fork
       </code>
       结合使用，创建子进程并执行不同的程序。
      </p>
     </li>
     <li>
      <p>
       示例代码：
      </p>
     </li>
    </ul>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
​
int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }
​
    if (pid == 0) {
        // 子进程
        printf("Child process, PID: %d\n", getpid());
        execlp("ls", "ls", "-l", NULL); // 子进程执行 ls 程序
        perror("execlp failed"); // 如果 execlp 失败，会执行到这里
        return 1;
    } else {
        // 父进程
        printf("Parent process, PID: %d\n", getpid());
        wait(NULL); // 等待子进程结束
        printf("Child process finished\n");
    }
    return 0;
}</pre>
    <h3>
     6. 使用
     <code>
      system
     </code>
     的注意事项
    </h3>
    <ul>
     <li>
      <p>
       <code>
        system
       </code>
       函数会调用
       <code>
        /bin/sh
       </code>
       来执行命令，因此可能会引入安全风险（如注入攻击）。
      </p>
     </li>
     <li>
      <p>
       如果需要执行简单的命令，可以使用
       <code>
        system
       </code>
       ，但建议优先使用
       <code>
        exec
       </code>
       函数族。
      </p>
     </li>
     <li>
      <p>
       示例：避免注入攻击
      </p>
     </li>
    </ul>
    <pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
​
int main() {
    char *filename = "test.txt";
    char command[256];
    snprintf(command, sizeof(command), "ls -l %s", filename); // 安全地构造命令
    system(command);
    return 0;
}</pre>
    <hr/>
    <h2>
     八、守护进程（Daemon Process）
    </h2>
    <h3>
     1. 概念
    </h3>
    <p>
     守护进程（Daemon Process）是一种生存期较长的进程，通常独立于控制终端，并周期性地执行某种任务或等待处理某些事件。
    </p>
    <h3>
     2. 特点
    </h3>
    <ul>
     <li>
      <p>
       始终在后台运行，独立于任何终端。
      </p>
     </li>
     <li>
      <p>
       周期性地执行任务或等待处理特定事件。
      </p>
     </li>
     <li>
      <p>
       是一种特殊的孤儿进程，脱离终端，避免被终端信息打断。
      </p>
     </li>
    </ul>
    <h3>
     3. 创建守护进程
    </h3>
    <h4>
     3.1 简便方法
    </h4>
    <p>
     使用
     <code>
      nohup
     </code>
     命令：
    </p>
    <pre>nohup xxxx &amp;</pre>
    <h4>
     3.2 使用
     <code>
      setsid
     </code>
     函数
    </h4>
    <pre>#include &lt;unistd.h&gt;
​
pid_t setsid(void);</pre>
    <ul>
     <li>
      <p>
       成功时返回调用进程的会话 ID。
      </p>
     </li>
     <li>
      <p>
       失败时返回 -1，并设置
       <code>
        errno
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       调用
       <code>
        setsid
       </code>
       的进程成为新的会话组长和组长进程。
      </p>
     </li>
    </ul>
    <h4>
     3.3 使用
     <code>
      getsid
     </code>
     函数
    </h4>
    <pre>#include &lt;unistd.h&gt;
​
pid_t getsid(pid_t pid);</pre>
    <ul>
     <li>
      <p>
       成功时返回调用进程的会话 ID。
      </p>
     </li>
     <li>
      <p>
       失败时返回 -1，并设置
       <code>
        errno
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       参数
       <code>
        pid
       </code>
       为 0 时，查看当前进程的会话 ID。
      </p>
     </li>
    </ul>
    <h4>
     3.4 其他辅助函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         getpid
        </code>
       </strong>
       ：获取进程 ID。
      </p>
      <pre>pid_t getpid(void);</pre>
     </li>
     <li>
      <p>
       <strong>
        <code>
         getpgid
        </code>
       </strong>
       ：获取进程组 ID。
      </p>
      <pre>pid_t getpgid(pid_t pid);</pre>
     </li>
    </ul>
    <h3>
     4. 创建守护进程的步骤
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        创建子进程，父进程退出
       </strong>
       ：
      </p>
      <pre>if (fork() &gt; 0) {
    exit(0); // 父进程退出
}</pre>
     </li>
     <li>
      <p>
       <strong>
        子进程变成孤儿进程，被
        <code>
         init
        </code>
        进程收养
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         子进程在后台运行。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        子进程创建新会话
       </strong>
       ：
      </p>
      <pre>if (setsid() &lt; 0) {
    exit(-1); // 创建会话失败
}</pre>
      <ul>
       <li>
        <p>
         子进程成为新的会话组长。
        </p>
       </li>
       <li>
        <p>
         子进程脱离原先的终端。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        更改当前工作目录
       </strong>
       ：
      </p>
      <pre>chdir("/"); // 或 chdir("/tmp");</pre>
      <ul>
       <li>
        <p>
         防止守护进程的工作目录被卸载。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        重设文件权限掩码
       </strong>
       ：
      </p>
      <pre>umask(0); // 文件权限掩码设置为 0</pre>
     </li>
     <li>
      <p>
       <strong>
        关闭打开的文件描述符
       </strong>
       ：
      </p>
      <pre>for (int i = 0; i &lt; 3; i++) {
    close(i); // 关闭标准输入、输出和错误
}</pre>
     </li>
    </ol>
    <h4>
     4.1 示例代码
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
​
int main() {
    // 创建子进程，父进程退出
    if (fork() &gt; 0) {
        exit(0); // 父进程退出
    }
​
    // 创建新会话
    if (setsid() &lt; 0) {
        perror("setsid failed");
        exit(-1);
    }
    
// 更改当前工作目录
if (chdir("/") &lt; 0) {
    perror("chdir failed");
    exit(-1);
}
​
// 重设文件权限掩码
umask(0);
​
// 关闭打开的文件描述符
for (int i = 0; i &lt; 3; i++) {
    close(i); // 关闭标准输入、输出和错误
}
​
// 执行守护进程的任务
while (1) {
    printf("Daemon process running...\n");
    sleep(10); // 模拟周期性任务
}
​
return 0;
}</pre>
    <h2>
     九、守护进程的注意事项
    </h2>
    <h3>
     1. 避免守护进程占用终端
    </h3>
    <p>
     守护进程不应与终端关联，否则可能会因终端关闭而退出。使用
     <code>
      setsid()
     </code>
     可以确保进程脱离终端。
    </p>
    <h3>
     2. 防止工作目录被卸载
    </h3>
    <p>
     守护进程的工作目录应设置为根目录（
     <code>
      /
     </code>
     ）或
     <code>
      /tmp
     </code>
     ，避免因工作目录被卸载而导致守护进程无法运行。
    </p>
    <h3>
     3. 关闭不必要的文件描述符
    </h3>
    <p>
     守护进程不应继承父进程的文件描述符。关闭标准输入、输出和错误（
     <code>
      stdin
     </code>
     、
     <code>
      stdout
     </code>
     、
     <code>
      stderr
     </code>
     ），并根据需要重新打开日志文件。
    </p>
    <h3>
     4. 日志记录
    </h3>
    <p>
     守护进程通常需要记录日志以便调试和监控。可以将日志写入
     <code>
      /var/log
     </code>
     或其他日志文件中，而不是直接输出到终端。
    </p>
    <h3>
     5. 示例：守护进程与日志记录
    </h3>
    <h4 style="background-color:transparent">
     示例代码
    </h4>
    <pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
​
int main() {
    // 创建子进程，父进程退出
    if (fork() &gt; 0) {
        exit(0); // 父进程退出
    }
​
    // 创建新会话
    if (setsid() &lt; 0) {
        perror("setsid failed");
        exit(-1);
    }
​
    // 更改当前工作目录
    if (chdir("/") &lt; 0) {
        perror("chdir failed");
        exit(-1);
    }
​
    // 重设文件权限掩码
    umask(0);
​
    // 关闭标准输入、输出和错误
    for (int i = 0; i &lt; 3; i++) {
        close(i);
    }
​
    // 打开日志文件
    int log_fd = open("/var/log/mydaemon.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (log_fd &lt; 0) {
        perror("open log file failed");
        exit(-1);
    }
​
    // 重定向标准输出和错误到日志文件
    dup2(log_fd, STDOUT_FILENO);
    dup2(log_fd, STDERR_FILENO);
​
    // 执行守护进程的任务
    while (1) {
        printf("Daemon process running...\n");
        sleep(10); // 模拟周期性任务
    }
​
    return 0;
}</pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36363430353837362f:61727469636c652f64657461696c732f313436323936313733" class_="artid" style="display:none">
 </p>
</div>


