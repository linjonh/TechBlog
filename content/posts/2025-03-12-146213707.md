---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f38323137363636372f:61727469636c652f64657461696c732f313436323133373037"
layout: post
title: "代码块与设计模式"
date: 2025-03-12 20:06:59 +0800
description: "静态方法和属性的经典使用设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱,不同的棋局,我们用不同的棋谱，免去我们自己再思考和摸索。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。单例模式有两种方式:1) 饿汉式 2) 懒汉式。"
keywords: "代码块与设计模式"
categories: ['未分类']
tags: ['设计模式', '算法', 'Java']
artid: "146213707"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146213707
    alt: "代码块与设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146213707
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146213707
cover: https://bing.ee123.net/img/rand?artid=146213707
image: https://bing.ee123.net/img/rand?artid=146213707
img: https://bing.ee123.net/img/rand?artid=146213707
---

# 代码块与设计模式

## 1.代码块

### 1.1基本介绍

代码化块又称为初始化块,属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过包围起来。

但和方法不同，没有方法名，没有返回，没有参数，
**只有方法体**
，而且不用通过对象或类显式调用，而是
**加载类时，或创建对象时隐式调用**
。

#### 基本语法

```java
[修饰符]{
   代码
};

```

说明注意;

1. 修饰符可选,要写的话,也只能写static
2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块。
3. 逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)
4. ；号可以写上,也可以省略。

### 1.2代码块的好处和案例演示

1. 相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作
2. 场景:如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容，代码块调用的顺序优先于构造器。

```java
package com.hspedu.codeblock_;

public class CodeBlock01 {
    public static void main(String[] args) {
        Movie movie = new Movie("你好，李焕英");
        System.out.println("===============");
        Movie movie2 = new Movie("唐探3", 100, "陈思诚");
    }
}

class Movie {
    private String name;
    private double price;
    private String director;

    // 3个构造器-》重载
    {
        System.out.println("电影屏幕打开...");
        System.out.println("广告开始...");
        System.out.println("电影正是开始...");
    };

    public Movie(String name) {
        System.out.println("Movie(String name) 被调用...");
        this.name = name;
    }

    public Movie(String name, double price) {

        this.name = name;
        this.price = price;
    }

    public Movie(String name, double price, String director) {

        System.out.println("Movie(String name, double price, String director) 被调用...");
        this.name = name;
        this.price = price;
        this.director = director;
    }
}

```

### 1.3代码块使用注意事项和细节讨论!!!

1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着
   **类的加载**
   而执行，并且只会执行一次。如果是普通代码块，每创建一个对象, 就执行一次。
2. **类什么时候被加载**

   * **创建对象实例时(new)**
   * **创建子类对象实例,父类也会被加载**
   * **使用类的静态成员时(静态属性,静态方法)**
3. 普通的代码块，
   **在创建对象实例**
   时，会被隐式的调用。被创建一次，就会调用一次。
     
   **如果只是使用类的静态成员时,普通代码块并不会执行。（没有创建对象实例）**
4. 创建一个对象时，在一个类调用顺序是
   **(重点，难点)**
   ∶

   5. 调用静态代码块和静态属性初始化 (注意:静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的先后顺序调用)
   6. 调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样,如果有多个普通代码块和多个普通属性初始化,则按定义先后顺序调用)
   7. 调用构造方法
5. 最前面其实隐含了
   **super()和调用普通代码块**
   , 静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的。
6. 看一下创建一个子类对象时(继承关系)，他们的调用顺序如下\*\*:

   6. 父类的静态代码块和静态属性(优先级一样,按定义顺序执行)（类加载）
   7. 子类的静态代码块和静态属性(优先级一样,按定义顺序执行)（类加载）
   8. 父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
   9. 父类的构造方法
   10. 子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
   11. 子类的构造方法
7. 代码块（本质上是静态方法）只能直接调用静态成员(静态属性和静态方法)，普通代码块（本质上是普通方法）可以调用任意成员。

```java
package com.hspedu.codeblock_;

public class CodeBlockDetail04 {
    public static void main(String[] args) {
        //老师说明
        //(1) 进行类的加载
        //1.1 先加载 父类 A02 1.2 再加载 B02
        //(2) 创建对象
        //2.1 从子类的构造器开始
        //new B02();//对象

        new C02();
    }
}

class A02 { //父类
    private static int n1 = getVal01();
    static {
        System.out.println("A02的一个静态代码块..");//(2)
    }
    {
        System.out.println("A02的第一个普通代码块..");//(5)
    }
    pulic int n3 = getVal02();//普通属性的初始化
    public static int getVal01() {
        System.out.println("getVal01");//(1)
        return 10;
    }

    public int getVal02() {
        System.out.println("getVal02");//(6)
        return 10;
    }

    public A02() {//构造器
        //隐藏
        //super()
        //普通代码和普通属性的初始化......
        System.out.println("A02的构造器");//(7)
    }

}

class C02 {
    private int n1 = 100;
    private static  int n2 = 200;

    private void m1() {

    }
    private static void m2() {

    }

    static {
        //静态代码块，只能调用静态成员
        //System.out.println(n1);错误
        System.out.println(n2);//ok
        //m1();//错误
        m2();
    }
    {
        //普通代码块，可以使用任意成员
        System.out.println(n1);
        System.out.println(n2);//ok
        m1();
        m2();
    }
}

class B02 extends A02 { //

    private static int n3 = getVal03();

    static {
        System.out.println("B02的一个静态代码块..");//(4)
    }
    public int n5 = getVal04();
    {
        System.out.println("B02的第一个普通代码块..");//(9)
    }

    public static int getVal03() {
        System.out.println("getVal03");//(3)
        return 10;
    }

    public int getVal04() {
        System.out.println("getVal04");//(8)
        return 10;
    }
    //一定要慢慢的去品..
    public B02() {//构造器
        //隐藏了
        //super()
        //普通代码块和普通属性的初始化...
        System.out.println("B02的构造器");//(10)
        // TODO Auto-generated constructor stub
    }
}

```

练习：

```java
package com.hspedu.codeblock_;

public class CodeBlockExercise02 {
}

class Sample
{
    Sample(String s)
    {
        System.out.println(s);
    }
    Sample()
    {
        System.out.println("Sample默认构造函数被调用");
    }
}
class Test{
    Sample sam1=new Sample("sam1成员初始化");//
    static Sample sam=new Sample("静态成员sam初始化 ");//
    static{
        System.out.println("static块执行");//
        if(sam==null)System.out.println("sam is null");
    }
    Test()//构造器
    {
        System.out.println("Test默认构造函数被调用");//
    }
    //主方法
    public static void  main(String  str[])
    {
        Test a=new Test();//无参构造器
    }

}

1. 静态成员sam 初始化
2. static 块执行
3. sam1 成员初始化
4. Test 默认构造函数被调用

```

## 2.单例设计模式

### 2.1什么是设计模式

静态方法和属性的经典使用

设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱,不同的棋局,我们用不同的棋谱，免去我们自己再思考和摸索。

### 2.2什么是单例模式

1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对
   **某个类只能存在一个对象实例**
   ，并且该类只提供一个取得其对象实例的方法。
2. 单例模式有两种方式:1) 饿汉式 2) 懒汉式

#### 2.2.1饿汉式

步骤如下:

1. 构造器私有化 =》防止直接new
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法。getlnstance

饿汉式：有可能还没有用到这个对象，但是由于类的机制已经将对象创建好了。在线程还没出现之前就已经实例化了,因此饿汉式线程一定是安全的。

```java
package com.hspedu.single_;

public class SingleTon01 {

    public static void main(String[] args) {
//        GirlFriend xh = new GirlFriend("小红");
//        GirlFriend xb = new GirlFriend("小白");

        //通过方法可以获取对象
        GirlFriend instance = GirlFriend.getInstance();
        System.out.println(instance);
        // 都是同一个对象
        GirlFriend instance2 = GirlFriend.getInstance();
        System.out.println(instance2);

        System.out.println(instance == instance2);// T 同一个对象
        //System.out.println(GirlFriend.n1);
    }
}

// 有一个类， GirlFriend
// 只能有一个女朋友
class GirlFriend {

    private String name;
    // public static  int n1 = 100;
    // 为了能够在静态方法中，返回 gf对象，需要将其修饰为static
    // 對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.
    // 只要类加载了，就一定创建了gf对象
    private static GirlFriend gf = new GirlFriend("小红红");

    // 如何保障我们只能创建一个 GirlFriend 对象
    // 步骤[单例模式-饿汉式]
    // 1. 将构造器私有化
    // 2. 在类的内部直接创建对象(该对象是static)
    // 3. 提供一个公共的static方法，返回 gf 对象
    private GirlFriend(String name) {
        System.out.println("構造器被調用.");
        this.name = name;
    }

    // 用static的目的就是在不创建对象的前提下直接调用
    public static GirlFriend getInstance() {
        return gf;
    }

    @Override
    public String toString() {
        return "GirlFriend{" +
                "name='" + name + '\'' +
                '}';
    }
}

```

#### 2.2.2懒汉式

懶漢式，只有當用戶使用getInstance時，才返回cat對象, 後面再次調用時，會返回上次創建的cat對象。

懒汉式可能会存在线程安全的问题。

```java
package com.hspedu.single_;

/**
 * 演示懶漢式的單例模式
 */
public class SingleTon02 {
    public static void main(String[] args) {
        //new Cat("大黃");
        //System.out.println(Cat.n1);
        Cat instance = Cat.getInstance();
        System.out.println(instance);


        //再次調用getInstance
        Cat instance2 = Cat.getInstance();
        System.out.println(instance2);

        System.out.println(instance == instance2);//T

    }
}


//希望在程序運行過程中，只能創建一個Cat對象
//使用單例模式
class Cat {
    private String name;
    public static  int n1 = 999;
    private static Cat cat ; //默認是null

    //步驟
    //1.仍然構造器私有化
    //2.定義一個static靜態屬性對象
    //3.提供一個public的static方法，可以返回一個Cat對象
    //4.懶漢式，只有當用戶使用getInstance時，才返回cat對象, 後面再次調用時，會返回上次創建的cat對象
    //  從而保證了單例
    private Cat(String name) {
        System.out.println("構造器調用...");
        this.name = name;
    }
    public static Cat getInstance() {

        if(cat == null) {//如果還沒有創建cat對象
            cat = new Cat("小可愛");
        }
        return cat;
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                '}';
    }
}

```

#### 2.2.3比较

1. 二者最主要的区别在于创建对象的时机不同:饿汉式是在类加载就创建了对象实例,而懒汉式是在使用时才创建。
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。(后面学习线程后，会完善一把)。
3. 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。
4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式.