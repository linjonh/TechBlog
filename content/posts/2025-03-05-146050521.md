---
layout: post
title: "Leetcode-378-有序矩阵中第-K-小的元素"
date: 2025-03-05 19:02:55 +0800
description: "因为每次值域收缩都保证了第 k 小的数在 left ~ right 之间，当 left==right 时，第 k 小的数即被找出，等于left//left和right是矩阵值不是矩阵下标//一步步收缩值域范围直至left==right//因为每次值域收缩都保证了第 k 小的数在 left ~ right 之间，当 left==right 时，第 k 小的数即被找出，等于left//避免溢出//满足 num >= k，范围太大，移动right至mid， 范围收缩。"
keywords: "Leetcode 378-有序矩阵中第 K 小的元素"
categories: ['未分类']
tags: ['算法', '矩阵', 'Leetcode']
artid: "146050521"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146050521
    alt: "Leetcode-378-有序矩阵中第-K-小的元素"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146050521
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146050521
cover: https://bing.ee123.net/img/rand?artid=146050521
image: https://bing.ee123.net/img/rand?artid=146050521
img: https://bing.ee123.net/img/rand?artid=146050521
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Leetcode 378-有序矩阵中第 K 小的元素
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
     <br/>
     请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。
    </p>
    <p>
     你必须找到一个内存复杂度优于 O(n2) 的解决方案。
    </p>
    <p>
     示例 1：
    </p>
    <p>
     输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
     <br/>
     输出：13
     <br/>
     解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
     <br/>
     示例 2：
    </p>
    <p>
     输入：matrix = [[-5]], k = 1
     <br/>
     输出：-5
    </p>
    <p>
     提示：
    </p>
    <p>
     n == matrix.length
     <br/>
     n == matrix[i].length
     <br/>
     1 &lt;= n &lt;= 300
     <br/>
     -109 &lt;= matrix[i][j] &lt;= 109
     <br/>
     题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列
     <br/>
     1 &lt;= k &lt;= n2
    </p>
    <h2>
     <a id="_27">
     </a>
     题解
    </h2>
    <h3>
     <a id="%E3%80%80%E3%80%80%E3%80%80_28">
     </a>
     有序　＋　确定范围　可以使用二分查找
    </h3>
    <ol>
     <li>
      左上角matrix[0][0]是下限，右下角matrix[n-1][n-1]是上限，就有了一个值，第 k 小的元素在这个值域中
      <br/>
      我们对值域进行二分查找(mid=(matrix[0][0]+matrix[n-1][n-1])/2)，使得mid逼近值域中的目标值(第 k 小的元素)
     </li>
     <li>
      求出矩阵里小于等于mid的有几个，num个
     </li>
     <li>
      num 和 k 比较
      <br/>
      如果比 k 小，说明中间值小了，调整值域范围(left=mid+1)
      <br/>
      否则，说明中间值大了，调整值域范围(right=mid)，一步步锁定目标值
     </li>
    </ol>
    <h3>
     <a id="_36">
     </a>
     注：
    </h3>
    <h4>
     <a id="1__37">
     </a>
     1. 为什么对值二分而不是对索引二分
    </h4>
    <p>
     二分查找可以根据索引二分，也可以根据数值二分，有序数组中，索引的大小可以反映值的大小，对索引二分就行
     <br/>
     但这里不是有序的一维数组，索引不能体现值谁大谁小，无法通过二分索引逼近目标值
    </p>
    <h4>
     <a id="2_leftkleft_or_right__40">
     </a>
     2. 为什么最后left是第k小的数||二分法如何保证最后的left or right 是数组中的元素？
    </h4>
    <p>
     因为每次值域收缩都保证了第 k 小的数在 left ~ right 之间，当 left==right 时，第 k 小的数即被找出，等于left
    </p>
    <pre><code class="prism language-bash">class Solution <span class="token punctuation">{<!-- --></span>
    public int kthSmallest<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix, int k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        int n <span class="token operator">=</span> matrix.length<span class="token punctuation">;</span>
        //left和right是矩阵值不是矩阵下标
        int left <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        int right <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n - <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n - <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

       //一步步收缩值域范围直至left<span class="token operator">==</span>right
       //因为每次值域收缩都保证了第 k 小的数在 left ~ right 之间，当 <span class="token assign-left variable">left</span><span class="token operator">==</span>right 时，第 k 小的数即被找出，等于left
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            //避免溢出
            int mid <span class="token operator">=</span> left + <span class="token punctuation">(</span>right - left<span class="token punctuation">)</span>/2<span class="token punctuation">;</span>
            //满足 num <span class="token operator">&gt;=</span> k，范围太大，移动right至mid， 范围收缩
            //注意num<span class="token operator">=</span>k时说明小于等于mid数的数量等于k，但不代表mid就是结果，因为此时mid不一定在matrix中
            <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">(</span>matrix, mid, k, n<span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>//满足 num <span class="token operator">&lt;</span> k，范围太小，移动left至mid+1， 范围收缩
                left <span class="token operator">=</span> mid + <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        //跳出循环时left<span class="token operator">=</span>right,返回值left是什么？？？
        <span class="token builtin class-name">return</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    //从矩阵左下角开始按列遍历每一列，计算每一列中比mid小的元素个数并累加获得num，将num与k比较
    //返回值boolean：矩阵中小于mid的数<span class="token operator">&gt;=</span>k
    //为什么不直接返回num<span class="token operator">=</span>k时的mid值？因为mid是通过值域二分法计算出的值，不是实际的矩阵值
    public boolean check<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix, int mid, int k, int n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        int i <span class="token operator">=</span> n - <span class="token number">1</span><span class="token punctuation">;</span>
        int j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        int num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                //当前元素小于mid，则本列此元素及上方元素均小于mid，num<span class="token operator">+=</span>i+1（行号是i,行的数目是i+1）
                num <span class="token operator">+=</span> i + <span class="token number">1</span><span class="token punctuation">;</span>
                //列向右移动，计算下一列小于mid的元素的个数
                j++<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                //当前元素大于mid，则向上移动，直到找到比mid小的值，或者出矩阵
                i--<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
        <span class="token builtin class-name">return</span> num<span class="token operator">&gt;=</span>k<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f48656c656e65313939362f:61727469636c652f64657461696c732f313436303530353231" class_="artid" style="display:none">
 </p>
</div>


