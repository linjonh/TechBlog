---
layout: post
title: "自由学习记录43"
date: 2025-03-12 11:55:47 +0800
description: "public Task<int> GetNumber() { return Task.FromResult(42); }\t直接返回 Taskpublic async Task<int> GetNumberAsync() { await Task.Delay(1000); return 42; }\t需要 await public async Task<int> GetNumber() { return Task.FromResult(42); }\tasync 没发挥作"
keywords: "deepseek-reasoner和 chat和coder"
categories: ['Tobeme']
tags: ['学习']
artid: "146052369"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146052369
    alt: "自由学习记录43"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146052369
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146052369
cover: https://bing.ee123.net/img/rand?artid=146052369
image: https://bing.ee123.net/img/rand?artid=146052369
img: https://bing.ee123.net/img/rand?artid=146052369
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     自由学习记录（43）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/direct/01f547d0381f427788a1315c127be77c.png" width="1779"/>
    </p>
    <p>
     不同的服务器可以使用不同协议，但协议本身不会决定服务器的类型
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         类型
        </strong>
       </th>
       <th>
        <strong>
         特点
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         物理服务器
        </strong>
       </td>
       <td>
        真实的计算机（如 Dell、HP 服务器）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         虚拟服务器
        </strong>
       </td>
       <td>
        运行在云计算平台上的 VM（如 AWS EC2、阿里云 ECS）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         容器化服务器
        </strong>
       </td>
       <td>
        通过 Docker / Kubernetes 运行多个轻量级服务
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     不同协议可以在同一服务器上运行，或者分布在不同服务器上：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         协议
        </strong>
       </th>
       <th>
        <strong>
         用途
        </strong>
       </th>
       <th>
        <strong>
         常见服务器
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        HTTP / HTTPS
       </td>
       <td>
        Web 访问
       </td>
       <td>
        Nginx、Apache、IIS
       </td>
      </tr>
      <tr>
       <td>
        FTP / SFTP
       </td>
       <td>
        文件传输
       </td>
       <td>
        vsftpd、FileZilla Server
       </td>
      </tr>
      <tr>
       <td>
        SMTP / IMAP / POP3
       </td>
       <td>
        邮件通信
       </td>
       <td>
        Postfix、Dovecot
       </td>
      </tr>
      <tr>
       <td>
        SSH
       </td>
       <td>
        远程登录
       </td>
       <td>
        OpenSSH
       </td>
      </tr>
      <tr>
       <td>
        WebSocket
       </td>
       <td>
        实时通信
       </td>
       <td>
        Socket.IO、SignalR
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         服务器类型
        </strong>
       </th>
       <th>
        <strong>
         作用
        </strong>
       </th>
       <th>
        <strong>
         常见软件
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         Web 服务器
        </strong>
       </td>
       <td>
        处理 HTTP/HTTPS 请求，提供网页
       </td>
       <td>
        Nginx、Apache、IIS
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据库服务器
        </strong>
       </td>
       <td>
        存储和管理数据
       </td>
       <td>
        MySQL、PostgreSQL、MongoDB
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         应用服务器
        </strong>
       </td>
       <td>
        运行业务逻辑，如 API
       </td>
       <td>
        Tomcat、Node.js、Django
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         文件服务器
        </strong>
       </td>
       <td>
        提供文件存储和访问
       </td>
       <td>
        Samba、FTP 服务器
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         邮件服务器
        </strong>
       </td>
       <td>
        发送和接收邮件
       </td>
       <td>
        Postfix、Exim、Microsoft Exchange
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      HTTP（
      <strong>
       不加密
      </strong>
      ）和 HTTPS（
      <strong>
       加密
      </strong>
      ）都是基于
      <strong>
       TCP/IP
      </strong>
      的
      <strong>
       应用层协议
      </strong>
     </li>
     <li>
      <strong>
       Web 服务器（如 Nginx、Apache、IIS）可以同时支持 HTTP 和 HTTPS
      </strong>
      <ul>
       <li>
        <strong>
         如果服务器配置了 SSL 证书，就可以使用 HTTPS
        </strong>
       </li>
       <li>
        <strong>
         如果没有 SSL 证书，只能使用 HTTP
        </strong>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     http
    </p>
    <p>
     <img alt="" height="316" src="https://i-blog.csdnimg.cn/direct/bdea665eb2df43ae93466d02e267cbe1.png" width="1889"/>
    </p>
    <p>
     自定义handler类，自己在里面处理数据
    </p>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/34f587f8921e447bbbce5a9742f6d3de.png" width="1117"/>
    </p>
    <p>
     texture也是一样的
    </p>
    <p>
     <img alt="" height="477" src="https://i-blog.csdnimg.cn/direct/2ee3a4f33c56499b8eb9554c5e6a4695.png" width="1361"/>
    </p>
    <p>
     这里的File子类型就是直接下载文件，不用再转成二进制数组来使用
    </p>
    <p>
     DownloadHandler存在多个可以不同处理返回的数据的子类封装
    </p>
    <p>
     <img alt="" height="694" src="https://i-blog.csdnimg.cn/direct/ba4b281c327a4a2e8cd8cf12ff228d40.png" width="1784"/>
    </p>
    <p>
     <img alt="" height="205" src="https://i-blog.csdnimg.cn/direct/02f9dd8d5d4a429bb2992a2a45267844.png" width="897"/>
    </p>
    <p>
     <img alt="" height="166" src="https://i-blog.csdnimg.cn/direct/cc4d249905164ad5a1cdf75e49cb4281.png" width="926"/>
    </p>
    <ul>
     <li>
      <strong>
       有
       <code>
        await
       </code>
       →
       <code>
        async Task
       </code>
      </strong>
     </li>
     <li>
      <strong>
       没有
       <code>
        await
       </code>
       → 直接
       <code>
        Task
       </code>
      </strong>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         写法
        </strong>
       </th>
       <th>
        <strong>
         用法
        </strong>
       </th>
       <th>
        <strong>
         是否推荐
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         public
         <span style="color:#be191c">
          <strong>
           Task&lt;int&gt;
          </strong>
         </span>
         GetNumber() {
         <span style="color:#be191c">
          <strong>
           return
          </strong>
         </span>
         Task.FromResult(42); }
        </code>
       </td>
       <td>
        直接返回
        <code>
         Task
        </code>
       </td>
       <td>
        ✅
        <strong>
         推荐
        </strong>
        （更高效）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         public
         <span style="color:#be191c">
          <strong>
           async Task&lt;int&gt;
          </strong>
         </span>
         GetNumberAsync() {
         <span style="color:#be191c">
          <strong>
           await
          </strong>
         </span>
         Task.Delay(1000);
         <span style="color:#be191c">
          <strong>
           return
          </strong>
         </span>
         42; }
        </code>
       </td>
       <td>
        需要
        <code>
         await
        </code>
        异步等待
       </td>
       <td>
        ✅
        <strong>
         推荐
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         public
         <span style="color:#be191c">
          <strong>
           async Task&lt;int&gt;
          </strong>
         </span>
         GetNumber() {
         <strong>
          <span style="color:#be191c">
           return
          </span>
         </strong>
         Task.FromResult(42); }
        </code>
       </td>
       <td>
        <code>
         async
        </code>
        没发挥作用
       </td>
       <td>
        🚨
        <strong>
         不推荐
        </strong>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <code>
      async
     </code>
     让方法可以使用
     <code>
      await
     </code>
     关键字
    </p>
    <p>
     <strong>
      <code>
       async
      </code>
      本身不会让方法变异步
     </strong>
     ，它只是告诉编译器：
    </p>
    <ul>
     <li>
      这个方法
      <strong>
       可能
      </strong>
      包含异步操作
     </li>
     <li>
      这个方法的返回值
      <strong>
       一定要是
       <code>
        Task
       </code>
       /
       <code>
        Task&lt;T&gt;
       </code>
       或
       <code>
        void
       </code>
      </strong>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         类型
        </strong>
       </th>
       <th>
        <strong>
         返回值类型
        </strong>
       </th>
       <th>
        <strong>
         <code>
          await
         </code>
         作用
        </strong>
       </th>
       <th>
        <strong>
         示例
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         Task
        </code>
       </td>
       <td>
        无返回值
       </td>
       <td>
        等待任务完成
       </td>
       <td>
        <code>
         await SomeMethodAsync();
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Task&lt;T&gt;
        </code>
       </td>
       <td>
        返回
        <code>
         T
        </code>
       </td>
       <td>
        等待任务完成，并获取
        <code>
         T
        </code>
        结果
       </td>
       <td>
        <code>
         string result = await SomeMethodAsync();
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         ValueTask&lt;T&gt;
        </code>
       </td>
       <td>
        返回
        <code>
         T
        </code>
       </td>
       <td>
        比
        <code>
         Task&lt;T&gt;
        </code>
        轻量
       </td>
       <td>
        <code>
         int value = await GetValueAsync();
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     在 C# 中，
     <span style="color:#be191c">
      <strong>
       <code>
        await
       </code>
       只能用于
       <code>
        Task
       </code>
       或
       <code>
        Task&lt;T&gt;
       </code>
       类型
      </strong>
      ，因为
      <code>
       await
      </code>
      <strong>
       的作用是等待一个异步任务完成
      </strong>
      ，然后获取返回值。
     </span>
    </p>
    <p>
     <img alt="" height="554" src="https://i-blog.csdnimg.cn/direct/3a0e77ac74cb47cdbb22380ab9a49419.png" width="1005"/>
    </p>
    <p>
     一段很错误的代码
    </p>
    <pre><code class="language-cs">async Task&lt;IEnumerator&gt; GetGPTStreamResponse(string userInput)</code></pre>
    <p>
     <code>
      IEnumerator
     </code>
     和
     <strong>
      <code>
       async
      </code>
      方法
     </strong>
     不能直接混用
    </p>
    <p>
     <strong>
      <code>
       async
      </code>
      方法不能返回
      <code>
       IEnumerator
      </code>
     </strong>
     ，
     <code>
      Coroutine
     </code>
     只支持
     <strong>
      <code>
       IEnumerator
      </code>
     </strong>
    </p>
    <p>
     <code>
      async Task&lt;IEnumerator&gt;
     </code>
     并不符合 Unity 的
     <code>
      Coroutine
     </code>
     要求
    </p>
    <p>
     --------------
    </p>
    <ul>
     <li>
      <code>
       await
      </code>
      确保 HTTP 请求完成（但
      <strong>
       不会等待完整响应体
      </strong>
      ）。
     </li>
     <li>
      <code>
       HttpCompletionOption.ResponseHeadersRead
      </code>
      让
      <code>
       HttpClient
      </code>
      <strong>
       只等 HTTP 头部，而不是整个响应
      </strong>
      （适用于流式数据）。
     </li>
    </ul>
    <p>
     <img alt="" height="688" src="https://i-blog.csdnimg.cn/direct/dce66255e3a641398ad33a0ffcbd438b.png" width="1230"/>
    </p>
    <p>
     <strong>
      普通
      <code>
       PostAsync()
      </code>
     </strong>
     <strong>
      不会
     </strong>
     立即返回数据，而是等服务器
     <strong>
      完全返回后才解析
     </strong>
     ：
    </p>
    <pre><code class="language-cs">HttpResponseMessage response = await client.PostAsync(apiUrl, new StringContent(jsonData, Encoding.UTF8, "application/json"));
string responseBody = await response.Content.ReadAsStringAsync(); // ❌ 这里会卡住直到整个响应完成
</code></pre>
    <p>
     <img alt="" height="837" src="https://i-blog.csdnimg.cn/direct/f877dce916a7459aabf6ba08ac04f92e.png" width="1218"/>
    </p>
    <p>
     关于请求体里的message
    </p>
    <p>
     <img alt="" height="558" src="https://i-blog.csdnimg.cn/direct/7e9f7977849241108a0390ee16e520cf.png" width="1044"/>
    </p>
    <p>
     <img alt="" height="745" src="https://i-blog.csdnimg.cn/direct/ef950d6da7614ed8a59f044c0ec43dc5.png" width="1241"/>
    </p>
    <p>
     必须写的请求体
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         字段
        </strong>
       </th>
       <th>
        <strong>
         作用
        </strong>
       </th>
       <th>
        <strong>
         示例值
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         model
        </strong>
       </td>
       <td>
        指定使用的 GPT 模型
       </td>
       <td>
        <code>
         "gpt-4"
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         messages
        </strong>
       </td>
       <td>
        聊天上下文（数组）
       </td>
       <td>
        <code>
         [{"role": "user", "content": "Hello"}]
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <img alt="" height="524" src="https://i-blog.csdnimg.cn/direct/72003644969245d8b27aae0317a5c6fd.png" width="1195"/>
    </p>
    <p>
     但在JSON 内写的数组的顺序是重要的：
    </p>
    <p>
     {
     <!-- -->
     <br/>
     "messages": [
     <br/>
     {"role": "user", "content": "Hello"},
     <br/>
     {"role": "assistant", "content": "Hi! How can I help you?"}
     <br/>
     ]
     <br/>
     }
    </p>
    <p>
     {
     <!-- -->
     <br/>
     "messages": [
     <br/>
     {"role": "assistant", "content": "Hi! How can I help you?"},
     <br/>
     {"role": "user", "content": "Hello"}
     <br/>
     ]
     <br/>
     }
    </p>
    <p>
     ❌ 这两个请求是不同的！ OpenAI API 会按照数组的顺序解析 messages，所以调换 user 和 assistant 的顺序会影响对话上下文。
    </p>
    <p>
     ——————
    </p>
    <p>
     HTTP 请求体（Body）或请求头（Headers）里，字段的前后顺序通常不影响请求的识别，
    </p>
    <p>
     服务器是按字段名读取的，顺序无关(一些低级 HTTP 代理或老旧的 Web 服务器可能对 Headers 顺序敏感。，但极其少见)
    </p>
    <p>
     API既会规定请求体里的内容，也会规定请求头里的内容
    </p>
    <p>
     ——
    </p>
    <p>
    </p>
    <p>
     newtonsoft的匿名类写法实际上是借助c#的特殊写法，达到更直观的效果，处理成json字符串
    </p>
    <p>
     ——————
    </p>
    <p>
     如果 HttpClient 发送的数据格式不对，比如：
    </p>
    <p>
     少了 Content-Type: application/json
    </p>
    <p>
     少了 Authorization: Bearer API_KEY
    </p>
    <p>
     JSON 结构错误
    </p>
    <p>
     <br/>
     OpenAI 服务器会返回：
    </p>
    <p>
     {
     <!-- -->
     <br/>
     "error": {
     <!-- -->
     <br/>
     "message": "Invalid JSON",
     <br/>
     "type": "invalid_request_error",
     <br/>
     "code": 400
     <br/>
     }
     <br/>
     }
     <br/>
    </p>
    <p>
     ——————
    </p>
    <p>
     如何保证 HttpClient 发送的格式是正确的？
    </p>
    <p>
     ✅ 1. 通过 OpenAI API 文档 确定请求格式
    </p>
    <p>
     在 OpenAI API 文档里，规定了正确的请求格式：
    </p>
    <p>
     {
     <!-- -->
     <br/>
     "model": "gpt-4",
     <br/>
     "messages": [{"role": "user", "content": "Hello"}],
     <br/>
     "temperature": 0.7
     <br/>
     }
    </p>
    <p>
     你需要 自己确保 你的 JSON 完全符合这个格式，否则 OpenAI 服务器会返回错误。
    </p>
    <p>
     <br/>
     ---
    </p>
    <p>
     ✅ 2. 使用 Newtonsoft.Json 确保 JSON 序列化正确
    </p>
    <p>
     C# 原始字符串拼接 JSON 容易出错，所以推荐用 Newtonsoft.Json 进行 序列化：
    </p>
    <p>
     using Newtonsoft.Json;
    </p>
    <p>
     var requestData = new
     <br/>
     {
     <!-- -->
     <br/>
     model = "gpt-4",
     <br/>
     messages = new object[]
     <br/>
     {
     <!-- -->
     <br/>
     new { role = "user", content = "Hello!" }
     <br/>
     },
     <br/>
     temperature = 0.7
     <br/>
     };
    </p>
    <p>
     string jsonData = JsonConvert.SerializeObject(requestData);
    </p>
    <p>
     这样生成的 JSON 一定是符合 OpenAI API 规则的，不会因为手动写错 JSON 而导致格式错误
    </p>
    <p>
    </p>
    <p>
     ——————
    </p>
    <p>
     HttpClient 不会验证你构造的 JSON 是否符合 OpenAI API 的要求，它只是：
    </p>
    <p>
     封装 HTTP 请求（处理 TCP 连接、HTTP 头、数据流）
    </p>
    <p>
     发送你写的 JSON 数据
    </p>
    <p>
     接收服务器的响应
    </p>
    <p>
    </p>
    <p>
     The C# keyword readonly is used to declare fields that can only be assigned in the constructor or at declaration.
    </p>
    <blockquote>
     <p>
      Example:
     </p>
     <p>
      class Example
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      public readonly int MyValue; // Can only be set in the constructor
     </p>
     <p>
     </p>
     <p>
      public Example(int value)
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      MyValue = value;
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
    </blockquote>
    <p>
     Impact: Used for immutability to prevent changes after initialization.
    </p>
    <p>
    </p>
    <p>
     requireComponent
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a5042d2b131241569006d35604f4d184.jpg"/>
    </p>
    <p>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a5d1b29d721e48cf84ed623d81456f7e.png"/>
    </p>
    <p>
    </p>
    <p>
     本来觉得ai toolbox是非常重要的插件，没有血亏，现在看来也就那样了
    </p>
    <h4>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/0f5f359c7101430eafb4b996d9e715b8.png"/>
    </h4>
    <h4>
    </h4>
    <h4>
    </h4>
    <h4 style="background-color:transparent">
     <strong>
      解析器（Parser）？
     </strong>
    </h4>
    <p>
     解析器（Parser）是一个
     <strong>
      将 JSON 格式的字符串转换为编程语言中的数据结构
     </strong>
     的程序或库（newtonsoftJson就是）。
    </p>
    <h4>
     <strong>
      解析的基本过程
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       原始 JSON 字符串
      </strong>
      （通常是从文件、网络请求或数据库中读取的）：
      <pre><code>"{ \"name\": \"Alice\", \"age\": 25, \"skills\": [\"C++\", \"Python\"] }"
</code></pre>
     </li>
    </ol>
    <hr/>
    <h4 style="background-color:transparent">
     <strong>
      解析器的作用
     </strong>
    </h4>
    <p>
     解析器会把 JSON 字符串解析成
     <strong>
      编程语言可用的数据结构
     </strong>
     ，这样程序可以方便地访问、修改、存储这些数据。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        语言
       </th>
       <th>
        解析器库
       </th>
       <th>
        解析后数据类型
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         C#
        </strong>
       </td>
       <td>
        <code>
         Newtonsoft.Json
        </code>
        ，
        <code>
         System.Text.Json
        </code>
       </td>
       <td>
        <code>
         Dictionary&lt;string, object&gt;
        </code>
        ，
        <code>
         List&lt;T&gt;
        </code>
        ，自定义类
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         JavaScript
        </strong>
       </td>
       <td>
        <code>
         JSON.parse()
        </code>
       </td>
       <td>
        <code>
         Object
        </code>
        ，
        <code>
         Array
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Python
        </strong>
       </td>
       <td>
        <code>
         json.loads()
        </code>
       </td>
       <td>
        <code>
         dict
        </code>
        ，
        <code>
         list
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Java
        </strong>
       </td>
       <td>
        <code>
         Gson
        </code>
        ，
        <code>
         Jackson
        </code>
       </td>
       <td>
        <code>
         Map&lt;String, Object&gt;
        </code>
        ，自定义类
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Go
        </strong>
       </td>
       <td>
        <code>
         encoding/json
        </code>
       </td>
       <td>
        <code>
         map[string]interface{}
        </code>
        ，结构体
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
    </h4>
    <pre><code class="language-cs">using Newtonsoft.Json;
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        string json = "{ \"name\": \"Alice\", \"age\": 25 }";

        // 解析 JSON 字符串为 Dictionary
        Dictionary&lt;string, object&gt; data = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, object&gt;&gt;(json);
        Console.WriteLine(data["name"]);  // 输出: Alice
        Console.WriteLine(data["age"]);   // 输出: 25
    }
}
</code></pre>
    <blockquote>
     <p>
      <strong>
       解析后，JSON 变成了 C# 的
       <code>
        Dictionary&lt;string, object&gt;
       </code>
       ，可以随时访问 name、age 这些字段。
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h4 style="background-color:transparent">
     <strong>
      解析器是如何存储数据的？
     </strong>
    </h4>
    <p>
     解析器不会缓存 JSON，而是仅仅具有这种 JSON 转换为
     <strong>
      编程语言的内存数据结构
     </strong>
     （如对象、字典、列表等）的能力，没有被结构接下，则无用。
    </p>
    <p>
     解析后的数据通常存储在：
    </p>
    <ul>
     <li>
      <strong>
       内存（RAM）
      </strong>
      中的
      <strong>
       对象、字典、数组
      </strong>
      ，可以随时访问。
     </li>
     <li>
      <strong>
       缓存（Cache）
      </strong>
      ：如果手动存入 Redis、文件、数据库等，就可以缓存起来，方便后续读取。
     </li>
    </ul>
    <p>
     示例：
    </p>
    <pre><code class="language-cs">// 解析 JSON 成 C# 类
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

string json = "{ \"name\": \"Alice\", \"age\": 25 }";

// 解析成 Person 对象
Person person = JsonConvert.DeserializeObject&lt;Person&gt;(json);
Console.WriteLine(person.Name);  // Alice
Console.WriteLine(person.Age);   // 25
</code></pre>
    <blockquote>
     <p>
      这里
      <code>
       person
      </code>
      存在于
      <strong>
       C# 内存
      </strong>
      ，你可以随时访问
      <code>
       person.Name
      </code>
      和
      <code>
       person.Age
      </code>
      。
     </p>
     <p>
      <strong>
       默认情况下
      </strong>
      ，
      <code>
       Newtonsoft.Json
      </code>
      解析 JSON 时，使用
      <strong>
       大小写不敏感
      </strong>
      的匹配规则。
     </p>
    </blockquote>
    <h4>
    </h4>
    <p>
     -----
    </p>
    <p>
     <strong>
      什么是达摩 ASR？
     </strong>
    </p>
    <p>
     <strong>
      达摩 ASR
     </strong>
     是阿里巴巴
     <strong>
      达摩院
     </strong>
     开发的一款
     <strong>
      批量离线语音识别（ASR，Automatic Speech Recognition）工具
     </strong>
     ，专门用于
     <strong>
      高效、精准地转换音频到文本
     </strong>
     ，特别适用于
     <strong>
      中文语音
     </strong>
     的大规模处理场景。
    </p>
    <p>
    </p>
    <p>
    </p>
    <h4>
     <strong>
      0a-UVR5 人声伴奏分离 &amp; 去混响去延迟工具
     </strong>
    </h4>
    <p>
     <strong>
      1. 为什么叫 0a-UVR5？
     </strong>
    </p>
    <p>
     这个名称主要来源于
     <strong>
      UVR5（Ultimate Vocal Remover 5）
     </strong>
     ，它是一款开源的
     <strong>
      人声伴奏分离工具
     </strong>
     。
    </p>
    <ul>
     <li>
      <strong>
       “0a” 可能是该工具的某个特殊版本或开发者的命名方式
      </strong>
      ，但主功能仍然基于 UVR5 的
      <strong>
       神经网络模型
      </strong>
      ，用于从混音中提取人声或伴奏。
     </li>
    </ul>
    <p>
     <strong>
      2. 混响是什么？为什么要去混响？
     </strong>
    </p>
    <p>
     <strong>
      混响（Reverb）
     </strong>
     是声音在封闭空间传播时，经过墙壁、地面、天花板等表面反射后产生的回声效果。
    </p>
    <ul>
     <li>
      例如，在
      <strong>
       浴室、体育馆、音乐厅
      </strong>
      说话时，声音会持续一段时间，不会立即消失，这就是混响。
     </li>
     <li>
      <strong>
       去混响（De-Reverb）
      </strong>
      在 AI 语音处理中很重要，因为：
      <ul>
       <li>
        <strong>
         提高清晰度
        </strong>
        ：消除不必要的回声，使声音更干净。
       </li>
       <li>
        <strong>
         提升模型识别率
        </strong>
        ：混响会干扰
        <strong>
         TTS、语音识别（ASR）、变声
        </strong>
        等 AI 任务，使其更难识别语音。
       </li>
       <li>
        <strong>
         改善语音合成
        </strong>
        ：让克隆出来的声音更自然、真实，而不是“带着房间回音”。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      3. 为什么要去延迟？
     </strong>
    </p>
    <p>
     在音频处理中，
     <strong>
      延迟（Latency）
     </strong>
     通常指的是音频信号传输或处理过程中产生的时间滞后。
    </p>
    <ul>
     <li>
      <strong>
       去延迟（De-Delay）
      </strong>
      主要用于：
      <ul>
       <li>
        <strong>
         消除录音中的音频延迟
        </strong>
        ：有些录音会因为麦克风或网络传输问题导致声音和原音轨不同步。
       </li>
       <li>
        <strong>
         优化 AI 变声、TTS 处理
        </strong>
        ：减少因
        <strong>
         音频滞后
        </strong>
        导致的发音不自然或不同步问题。
       </li>
       <li>
        <strong>
         修复音频回声
        </strong>
        ：如果声音经过多次反射，可能会有类似
        <strong>
         回音（Echo）
        </strong>
        的效果，去延迟可以减少这种影响。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      SoVITS 由开源社区开发
     </strong>
     ，在
     <strong>
      Bilibili、GitHub 社区
     </strong>
     非常流行，特别适用于
     <strong>
      AI VTuber、AI 歌声合成
     </strong>
     。
    </p>
    <p>
     AI 语音合成通常分为
     <strong>
      两个主要部分
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       文本 → 声学特征
      </strong>
      （文本分析 + 语音建模）
     </li>
     <li>
      <strong>
       声学特征 → 波形
      </strong>
      （波形合成）
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       文本分析
      </strong>
      → 解析语法，标记重音、韵律、停顿
     </li>
     <li>
      <strong>
       音素转换
      </strong>
      → 将文字转换成音素（如 "hello" → /hɛˈloʊ/）
     </li>
     <li>
      <strong>
       语调、韵律预测
      </strong>
      → 预测语音的起伏（高低音）
     </li>
     <li>
      <strong>
       时长预测
      </strong>
      → 计算每个音素的持续时间
     </li>
    </ul>
    <p>
     AI 能模仿声音，是因为
     <strong>
      人类的语音可以被数学化描述
     </strong>
     ，主要涉及以下几个关键参数：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         参数
        </strong>
       </th>
       <th>
        <strong>
         作用
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         音素 (Phoneme)
        </strong>
       </td>
       <td>
        语音的最小单位，比如英语的 /a/, /s/
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         语调 (Prosody, Pitch, F0)
        </strong>
       </td>
       <td>
        控制说话的高低起伏
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         音长 (Duration)
        </strong>
       </td>
       <td>
        语音的时长（慢速、快速）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         音色 (Timbre, Spectral Features)
        </strong>
       </td>
       <td>
        声音的独特性，决定声音是男、女、孩子
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         共振峰 (Formants)
        </strong>
       </td>
       <td>
        语音中的频谱特征，影响口音
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         语速 (Speaking Rate)
        </strong>
       </td>
       <td>
        说话的快慢
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         情感 (Emotion)
        </strong>
       </td>
       <td>
        控制语音的情感（开心、悲伤、愤怒等）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      现代 AI 语音合成
     </strong>
     主要使用
     <strong>
      音频采样 + 机器学习
     </strong>
     来获取这些参数，并用
     <strong>
      深度神经网络
     </strong>
     生成新的语音。
    </p>
    <p>
     要想想做完这个之后，我要做什么，，做完这些就去百度网盘里觅食，挑出重要的东西加深印象
    </p>
    <p>
     现代 AI 语音合成（如
     <strong>
      GPT-4 TTS、VITS、Tacotron、WaveNet
     </strong>
     ）主要依赖
     <strong>
      深度学习
     </strong>
     和
     <strong>
      信号处理
     </strong>
     ，让计算机模仿人类的语音。
    </p>
    <p>
    </p>
    <p style="background-color:transparent">
     GPT接入unity中
    </p>
    <p>
    </p>
    <p>
     是命名空间没有管理，所以出现了有冲突名的情况
    </p>
    <p>
     ----搞错了，是之前DeepseekAPI里我就已经生成了一次这些json接收类，冲突了我没注意
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/0b37c94c25e34f32a1f043c21c39822d.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/8e7eced960004ac9a9c18461b2ad4966.png"/>
    </p>
    <p>
     类型化后，取出Json格式下的Content
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/52f513d745c349f881f780c10472cbd1.png"/>
    </p>
    <h4 style="background-color:transparent">
     <strong>
      使用
      <code>
       Newtonsoft.Json
      </code>
      （推荐，适用于复杂JSON）
     </strong>
    </h4>
    <p>
     <strong>
      安装步骤
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        安装
        <code>
         Newtonsoft.Json
        </code>
        （JSON.NET）
       </strong>
      </p>
      <ul>
       <li>
        Unity
        <strong>
         2021+ 版本
        </strong>
        已自带 Newtonsoft.Json，你可以直接
        <code>
         using Newtonsoft.Json;
        </code>
       </li>
       <li>
        如果没有，可以用 NuGet 或从
        <a href="https://github.com/JamesNK/Newtonsoft.Json/releases" title="GitHub">
         GitHub
        </a>
        下载 DLL。
       </li>
      </ul>
     </li>
    </ol>
    <p>
    </p>
    <p>
     <code>
      JsonUtility
     </code>
     只能解析
     <strong>
      简单的 JSON 结构
     </strong>
     ，但 OpenAI API 的返回数据是
     <strong>
      嵌套的 JSON
     </strong>
     ，所以你需要创建多个 C# 类。
    </p>
    <p>
     主要关心的是
     <strong>
      <code>
       choices[0].message.content
      </code>
     </strong>
     ，这个字段里包含 GPT 的回复内容
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/47b747c19c5646aaafc81dae2b47fdb3.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/c5de89a08f2a47219119f8b6bb773db8.png"/>
    </p>
    <p>
     终于连上了
    </p>
    <pre><code class="language-cs">using System.Collections;
using UnityEngine;
using UnityEngine.Networking;
using System.Text;

public class OpenAIClient : MonoBehaviour
{
    private string apiKey = "your-api-key";  // 你的 OpenAI API Key
    private string apiUrl = "https://api.openai.com/v1/chat/completions";

    public void SendMessageToGPT(string userMessage)
    {
        StartCoroutine(SendRequest(userMessage));
    }

    private IEnumerator SendRequest(string message)
    {
        // 构造 JSON 请求体
        string requestBody = "{\"model\": \"gpt-4\", \"messages\": [{\"role\": \"user\", \"content\": \"" + message + "\"}]}";
        byte[] requestData = Encoding.UTF8.GetBytes(requestBody);

        // 创建 UnityWebRequest
        using (UnityWebRequest request = new UnityWebRequest(apiUrl, "POST"))
        {
            request.uploadHandler = new UploadHandlerRaw(requestData);
            request.downloadHandler = new DownloadHandlerBuffer();
            request.SetRequestHeader("Content-Type", "application/json");
            request.SetRequestHeader("Authorization", "Bearer " + apiKey);

            // 发送请求并等待响应
            yield return request.SendWebRequest();

            if (request.result == UnityWebRequest.Result.Success)
            {
                Debug.Log("Response: " + request.downloadHandler.text);
            }
            else
            {
                Debug.LogError("Error: " + request.error);
            }
        }
    }
}
</code></pre>
    <p>
     已经给GPT的API冲10美刀了，但问题还在（钱都冲了，今天不搞懂不行，damn）
    </p>
    <p>
    </p>
    <blockquote>
     <p>
      如何关注unity store的打折信息
     </p>
     <p>
      <strong>
       订阅Unity官方邮件
      </strong>
     </p>
     <ul>
      <li>
       <p>
        访问
        <a href="https://assetstore.unity.com/" rel="nofollow" title="Unity Asset Store">
         Unity Asset Store
        </a>
        。
       </p>
      </li>
      <li>
       <p>
        在页面底部找到“Subscribe”或“Newsletter”选项，输入邮箱订阅，及时收到促销信息。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       Unity官方社交媒体
      </strong>
     </p>
     <ul>
      <li>
       <p>
        关注Unity的Twitter、Facebook等平台，官方会发布打折信息。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       定期查看Asset Store
      </strong>
     </p>
     <ul>
      <li>
       <p>
        经常访问Asset Store，首页通常会展示打折活动。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       第三方折扣追踪网站
      </strong>
     </p>
     <ul>
      <li>
       <p>
        使用第三方网站或论坛，如Reddit的Unity3D板块，获取打折信息。
       </p>
      </li>
      <li>
       <p>
        <a href="https://www.youtube.com/watch?v=BLwcEMXtuGI" rel="nofollow" title="https://www.youtube.com/watch?v=BLwcEMXtuGI">
         https://www.youtube.com/watch?v=BLwcEMXtuGI
        </a>
        了解一下素材购买
       </p>
      </li>
      <li>
       <p>
        Asset deal for unity
        <a href="https://www.gameassetdeals.com/" rel="nofollow" title="Asset Deals for Unity">
         Asset Deals for Unity
        </a>
       </p>
      </li>
     </ul>
    </blockquote>
    <p>
     --------
    </p>
    <p>
     q，，原来野卡里可以买openAI的API
    </p>
    <p>
    </p>
    <p>
     Ollama 是一个专注于提供本地化 AI 模型部署和管理的平台。它允许用户在本地环境中运行和自定义大型语言模型（LLMs），如 DeepSeek 和其他先进的 AI 模型。以下是 Ollama 的一些主要功能和用途：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        本地部署
       </strong>
       ：Ollama 支持在本地计算机上部署 AI 模型，这意味着用户可以在不依赖互联网连接的情况下使用这些模型。
      </p>
     </li>
     <li>
      <p>
       <strong>
        隐私保护
       </strong>
       ：由于模型和数据都在本地运行，Ollama 提供了更高的隐私和安全性，确保敏感信息不会被上传到云端。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自定义和扩展
       </strong>
       ：用户可以根据自己的需求对模型进行自定义和扩展，例如添加特定的知识库或调整模型参数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多模型支持
       </strong>
       ：Ollama 支持多种 AI 模型，用户可以根据不同的任务选择最适合的模型。
      </p>
     </li>
     <li>
      <p>
       <strong>
        开发者友好
       </strong>
       ：Ollama 提供了丰富的 API 和工具，方便开发者集成和使用这些模型。
      </p>
     </li>
     <li>
      <p>
       <strong>
        离线使用
       </strong>
       ：通过 Ollama，用户可以在没有互联网连接的环境中继续使用 AI 模型，这对于某些特定场景（如远程工作或保密项目）非常有用。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     扩展名为
     <strong>
      Open I
     </strong>
     ，由 Kingleo 开发。它的功能是在 VS Code 编辑器内打开一个 URL。安装这个扩展后，你可以直接在 VS Code 中打开并查看网页，而不需要切换到浏览器
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/1f3c68aea96c4c809ad8f5382e91723a.png"/>
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        <strong>
         在
         <a href="https://chat.deepseek.com/" rel="nofollow" title="DeepSeek">
          DeepSeek
         </a>
         官网
        </strong>
        ：这是DeepSeek官方提供的服务，运行在DeepSeek的服务器上，用户可以直接通过网页与我交互。
       </p>
      </li>
      <li>
       <p>
        <strong>
         通过API Key调用的我
        </strong>
        ：如果你使用自己的API Key调用我，这意味着你可能通过DeepSeek提供的API服务将我集成到你的应用程序或工具（如VSCode）中。这种情况下，请求会发送到DeepSeek的API服务器，但具体的实现方式（如响应速度、可用功能等）可能会根据API的配置和权限有所不同。
       </p>
      </li>
      <li>
       <p>
        <strong>
         内置到VSCode的我
        </strong>
        ：如果你通过插件或扩展将我集成到VSCode中，这可能是通过API调用实现的，也可能是本地化的部署（取决于插件的实现方式）。如果是通过API调用，那么请求仍然会发送到DeepSeek的服务器；如果是本地部署，则可能运行在你的本地环境中。
       </p>
      </li>
     </ol>
    </blockquote>
    <p>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        Top_p（Nucleus Sampling）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          较低的值（如 0.1 到 0.5）
         </strong>
         ：生成文本会更加集中和确定，适合需要准确和一致输出的场景。
        </p>
       </li>
       <li>
        <p>
         <strong>
          较高的值（如 0.7 到 1.0）
         </strong>
         ：生成文本会更加多样化和创造性，适合需要创意和变化的场景。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Top_k
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          较低的值（如 10 到 50）
         </strong>
         ：生成文本会更加集中，模型只考虑概率最高的几个 token。
        </p>
       </li>
       <li>
        <p>
         <strong>
          较高的值（如 100 到 500）
         </strong>
         ：生成文本会更加多样化，模型会考虑更多的 token。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Frequency_penalty
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          较低的值（如 0.0 到 0.5）
         </strong>
         ：允许更多的重复，适合需要一致性和连贯性的文本。
        </p>
       </li>
       <li>
        <p>
         <strong>
          较高的值（如 1.0 到 2.0）
         </strong>
         ：减少重复，使文本更加多样化，适合需要避免重复的场景。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
    </p>
    <p>
    </p>
    <p>
     DeepSeek API 中，
     <strong>
      Temperature
     </strong>
     参数用于控制生成文本的随机性和创造性。这个参数的值范围通常在 0 到 2 之间，具体作用如下：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        低温度值（接近 0）
       </strong>
       ：生成的文本会更加确定性和保守。模型倾向于选择概率最高的词，结果通常更加一致和可预测。适用于需要准确和确定性输出的场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        高温度值（接近 2）
       </strong>
       ：生成的文本会更加随机和多样化。模型会更倾向于选择概率较低的词，结果可能更加创造性和不可预测。适用于需要创意和多样性的场景。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
     DeepSeek 的三个模型（Deepseek-Chat、Deepseek-Coder、Deepseek-Reasoner）是为了不同的应用场景和任务而设计的。每个模型都有其特定的功能和优势：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        Deepseek-Chat
       </strong>
       ：专注于自然语言对话和交互。它适用于需要高质量对话体验的场景，如客服、虚拟助手等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Deepseek-Coder
       </strong>
       ：专门用于代码生成和理解。它可以帮助开发者编写、调试和优化代码，适用于编程辅助工具和开发环境。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Deepseek-Reasoner
       </strong>
       ：专注于逻辑推理和问题解决。它适用于需要复杂推理和分析的任务，如数学问题求解、逻辑谜题等。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     想调用GPT，，果然还是太麻烦了，，效率太低了
    </p>
    <ul>
     <li>
      <p>
       生成式 AI
      </p>
      <p>
       这是一类令人兴奋的新工具，可帮助您生成新内容。您可以用它快速制作艺术作品的变体、创建角色对话等等。
      </p>
     </li>
     <li>
      <p>
      </p>
      <p>
       <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a74aca69d48546a90d96f58862e63a11.jpeg"/>
      </p>
      <p>
       AI / ML 集成
      </p>
      <p>
       这些集成充当 Unity 与 Open AI 等流行 AI 系统之间的中间桥梁。通过 SDK 访问不断增加的助手和工作流程加速器目录。
      </p>
     </li>
     <li>
      <p>
      </p>
      <p>
       <img alt="" src="https://i-blog.csdnimg.cn/img_convert/8db1c7c3ba633540536d3273bc33f5d7.jpeg"/>
      </p>
      <p>
       行为 AI
      </p>
      <p>
       This is a group of tools to help you build simulated behavior for in-game non-player elements like characters and vehicles.
      </p>
     </li>
    </ul>
    <blockquote>
     <p>
      Deepseek回答里值得注意的一些工具，可以了解的
     </p>
     <p>
     </p>
     <p>
      Unity生态系统中常用的AI工具和插件。
     </p>
     <p>
      1.Unity自己的ML-Agents肯定是重点，用于机器学习和训练智能体。
     </p>
     <p>
      2.第三方插件，比如A* Pathfinding Project，用于路径规划，虽然不是严格意义上的AI，但常被用于AI移动。
     </p>
     <p>
     </p>
     <p>
      3.行为树插件，比如Behavior Designer，这在游戏AI中很常见。
     </p>
     <p>
      4.对话系统，比如
      <strong>
       SALSA和Dialogue System for Unity
      </strong>
      ，这些可能整合了AI生成对话的功能，特别是现在有生成式AI的兴起，可能会有集成ChatGPT之类的插件。
     </p>
     <p>
     </p>
     <p>
      5.一些
      <strong>
       语音识别和处理的插件，比如CROSStalk
      </strong>
      ，可能属于AI范畴。另外，Unity的
      <strong>
       Sentience
      </strong>
      插件，虽然不确定现在是否还在维护。可能还有第三方服务，比如OpenAI的API集成，用户自己写的插件或者Asset Store上的资源。
     </p>
     <p>
     </p>
     <p>
      需要检查是否有新的插件出现，比如最近Unity和Meta的合作是否带来了一些新工具。还有，比如
      <strong>
       Replica Voice或者Inworld AI
      </strong>
      ，这些
      <u>
       专注于语音生成或NPC行为的插件
      </u>
      。另外，像DeepSeek之类的AI创作工具是否支持Unity。
     </p>
     <p>
     </p>
     <p>
      还要注意区分AI的不同应用，比如机器学习、路径寻找、自然语言处理、语音合成、行为树等，每个类别可能有不同的插件。同时，用户可能想知道是否有支持生成式AI的工具，比如集成GPT-3或
      <strong>
       Stable Diffusion的插件
      </strong>
      。
     </p>
     <p>
     </p>
     <p>
      需要确认一些插件的名称是否正确，比如A* Pathfinding Project确实存在，Behavior Designer也是常用的。另外，Unity的Sentience可能已经被其他工具取代，或者是否还在活跃开发中。可能还需要提到一些
      <strong>
       云端AI服务，如AWS或Google AI的集成
      </strong>
      ，但用户可能更关注Unity Asset Store中的插件。
     </p>
     <p>
     </p>
     <p>
      总结一下，应该分几个类别：机器学习框架、路径寻找、行为树、对话与NPC、语音处理、生成式AI集成、第三方服务集成。每个类别下列举几个主要插件，并简要说明其用途和特点。同时提醒用户注意插件的兼容性和版本，
      <u>
       因为Unity更新频繁，有些插件可能不支持最新版本。最后，建议用户根据具体需求选择合适的插件，并查看Asset Store的评价和文档
      </u>
      。
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     ---
    </p>
    <p>
     现在再填充一些关于AI相关的功能应用，了解一些前沿的知识点，看看可不可以填进对话项目里
    </p>
    <p>
     ---
    </p>
    <p>
     一种很好的提问方法，问具体的信息不一定可以精准快速地回复
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/1efd9ce0e2734dffa5fd1b8dd3a35038.png"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f7265645f726564656d7074696f6e2f:61727469636c652f64657461696c732f313436303532333639" class_="artid" style="display:none">
 </p>
</div>


