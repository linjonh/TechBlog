---
layout: post
title: "C游记List的使用和模拟实现"
date: 2025-08-25T16:51:57+0800
description: "【C++学习笔记：list容器详解】本文系统讲解了C++中list容器的使用与实现。内容涵盖：1）list基础介绍与构造函数；2）迭代器使用及失效问题分析；3）完整list模拟实现代码（含节点结构、迭代器封装和核心功能）；4）list与vector的底层结构、访问效率等对比；5）操作性能测试实例。通过西游记的学习比喻，以通俗易懂的方式解析list双向链表特性，特别强调迭代器失效机制和模拟实现细节，配有完整可测试代码，帮助读者深入理解STL容器设计思想。"
keywords: "【C++游记】List的使用和模拟实现"
categories: ['未分类']
tags: ['开发语言', 'List', 'C']
artid: "150770585"
arturl: "https://blog.csdn.net/m0_69282950/article/details/150770585"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150770585
    alt: "C游记List的使用和模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150770585
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150770585
cover: https://bing.ee123.net/img/rand?artid=150770585
image: https://bing.ee123.net/img/rand?artid=150770585
img: https://bing.ee123.net/img/rand?artid=150770585
---



# 【C++游记】List的使用和模拟实现



![](https://i-blog.csdnimg.cn/direct/79692b368f34447c8e4187c1cf69e070.gif)

![](https://i-blog.csdnimg.cn/direct/ec86d46d74ed454d9999ca5fa033aae1.png)

[枫の个人主页](https://blog.csdn.net/m0_69282950?spm=1010.2135.3001.5343 "枫の个人主页")

你不能改变过去，但你可以改变未来

算法/C++/数据结构/C

> *Hello，这里是小枫。C语言与数据结构和算法初阶两个板块都更新完毕，我们继续来学习C++的内容呀。C++是接近底层有比较经典的语言，因此学习起来注定枯燥无味，西游记大家都看过吧~，我希望能带着大家一起跨过九九八十一难，降伏各类难题，学会C++，我会尽我所能，以通俗易懂、幽默风趣的方式带给大家形象生动的知识，也希望大家遇到困难不退缩，遇到难题不放弃，学习师徒四人的精神！！！故此得名【C++游记】*

> *话不多说，让我们一起进入今天的学习吧~~~*  

## 1>>[List介绍](https://cplusplus.com/reference/list/list/?kw=list "List介绍")

![](https://i-blog.csdnimg.cn/direct/164d8130195d4fe1be08bb1759a09fb5.png)

## 2>>List使用

### 2.1>>list构造

        下面是一些用接口，大伙熟悉一下，后面模拟实现都会用到噢~

|  |  |
| --- | --- |
| 构造函数（ (constructor)） | 接口说明 |
| list (size_type n, const value_type& val =value_type()) | 构造的list中包含n个值为val的元素 |
| list() | 构造空的list |
| list (const list& x) | 拷贝构造函数 |
| list (InputIterator first, InputIterator last) | 用[first, last)区间中的元素构造lis |

### 2.2>>list iterator的使用

        这个就是一个迭代器，可以想象为指向某个节点的指针。

|  |  |
| --- | --- |
| 函数声明 | 接口说明 |
| begin + end | 返回第一个元素的迭代器+返回最后一个元素下一个位置的迭代器 |
| rbegin+ rend | 返回第一个元素的reverse_iterator,即end位置，返回最后一个元素下一个位  置的reverse_iterator,即begin位置（可以理解为rbegin就是end,rend就是begin） |

> **!!!**
>
>         1. begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动  
>          2. rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动

### 2.3>>迭代器失效

        迭代器失效即迭代器所指向的节点的无效，**即该节点被删除了**。因为list的底层结构为带头结点的双向循环链表，因此在list中进行插入时是不会导致list的迭代器失效的，只有在删除时才会失效，并且失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响。下面代码可供大伙练习，以get到失效的那个点。

```
void TestListIterator1()
{
int array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
  list<int> l(array, array+sizeof(array)/sizeof(array[0]));
  auto it = l.begin();
  while (it != l.end())
 {
 // erase()函数执行后，it所指向的节点已被删除，因此it无效，在下一次使用it时，必须先给
其赋值
  l.erase(it); 
  ++it;
 }
}
// 改正
void TestListIterator()
{
int array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
  list<int> l(array, array+sizeof(array)/sizeof(array[0]));
  auto it = l.begin();
  while (it != l.end())
 {
  l.erase(it++);   // it = l.erase(it);
 }
}
```

## 3>>list的模拟实现

        经过上面的学习，我们了解到大部分list的使用了，接下来我会给大家两端代码，一个是list.h包含list的功能实现，还有test.cpp包含测试代码，list.h包含一些注释，有我自己和ai的注释，大家可以仿写，不会的欢迎评论区探讨。

### 3.1>>list.h

```
#pragma once
// 防止头文件被多次包含

namespace wc  // 自定义命名空间，避免与标准库冲突
{
	// 链表节点结构定义
	template<class T>
	struct list_node
	{
		T _data;               // 节点存储的数据
		list_node<T>* _next;   // 指向后一个节点的指针
		list_node<T>* _prev;   // 指向前一个节点的指针

		// 节点构造函数，默认参数为T的默认构造
		list_node(const T& x = T())
			:_data(x)
			, _next(nullptr)
			, _prev(nullptr)
		{
		}
	};

	// 链表迭代器实现（通过模板参数区分普通迭代器和const迭代器）
	// T: 数据类型, Ref: 引用类型(T& 或 const T&), Ptr: 指针类型(T* 或 const T*)
	template<class T, class Ref, class Ptr>
	struct __list_iterator
	{
		typedef list_node<T> Node;                  // 节点类型重定义
		typedef __list_iterator<T, Ref, Ptr> Self;  // 迭代器自身类型重定义
		Node* _node;                                // 指向当前节点的指针

		// 迭代器构造函数
		__list_iterator(Node* node)
			:_node(node)
		{
		}

		// 解引用操作符，返回节点数据的引用
		Ref operator*()
		{
			return _node->_data;
		}

		// 箭头操作符，返回节点数据的指针
		Ptr operator->()
		{
			return &_node->_data;
		}

		// 前置++，移动到下一个节点
		Self& operator++()
		{
			_node = _node->_next;
			return *this;
		}

		// 后置++，移动到下一个节点（返回原值）
		Self operator++(int)
		{
			Self tmp(*this);  // 保存当前状态
			_node = _node->_next;
			return tmp;       // 返回未修改的临时对象
		}

		// 前置--，移动到前一个节点
		Self& operator--()
		{
			_node = _node->_prev;
			return *this;
		}

		// 后置--，移动到前一个节点（返回原值）
		Self operator--(int)
		{
			Self tmp(*this);  // 保存当前状态
			_node = _node->_prev;
			return tmp;       // 返回未修改的临时对象
		}

		// 不等比较操作符
		bool operator!=(const Self& it) const
		{
			return _node != it._node;
		}

		// 相等比较操作符
		bool operator==(const Self& it) const
		{
			return _node == it._node;
		}
	};

	/* 注释掉的const迭代器实现，已通过模板参数方式优化
	template<class T>
	struct __list_const_iterator
	{
		typedef list_node<T> Node;
		Node* _node;

		__list_const_iterator(Node* node)
			:_node(node)
		{}

		const T& operator*()
		{
			return _node->_data;
		}

		__list_const_iterator<T>& operator++()
		{
			_node = _node->_next;
			return *this;
		}

		__list_const_iterator<T> operator++(int)
		{
			__list_iterator<T> tmp(*this);
			_node = _node->_next;
			return tmp;
		}

		__list_const_iterator<T>& operator--()
		{
			_node = _node->_prev;
			return *this;
		}

		__list_const_iterator<T> operator--(int)
		{
			__list_const_iterator<T> tmp(*this);
			_node = _node->_prev;
			return tmp;
		}

		bool operator!=(const __list_const_iterator<T>& it) const
		{
			return _node != it._node;
		}

		bool operator==(const __list_const_iterator<T>& it) const
		{
			return _node == it._node;
		}
	};*/

	// 链表类定义
	template<class T>
	class list
	{
		typedef list_node<T> Node;  // 节点类型重定义
	public:
		// 迭代器类型定义：普通迭代器和const迭代器
		typedef __list_iterator<T, T&, T*> iterator;
		typedef __list_iterator<T, const T&, const T*> const_iterator;

		// 迭代器接口：返回第一个元素的迭代器
		iterator begin()
		{
			return iterator(_head->_next);  // 头节点的下一个是第一个元素
		}

		// 迭代器接口：返回尾后迭代器
		iterator end()
		{
			return iterator(_head);  // 头节点作为尾后标记
		}

		// const版本迭代器：返回第一个元素的const迭代器
		const_iterator begin() const
		{
			return const_iterator(_head->_next);
		}

		// const版本迭代器：返回尾后const迭代器
		const_iterator end() const
		{
			return const_iterator(_head);
		}

		// 初始化空链表（带头节点的双向循环链表）
		void empty_init()
		{
			_head = new Node;       // 创建头节点
			_head->_next = _head;   // 头节点的next指向自己
			_head->_prev = _head;   // 头节点的prev指向自己
		}

		// 默认构造函数
		list()
		{
			empty_init();
		}

		// 拷贝构造函数
		list(const list<T>& lt)
		{
			empty_init();  // 先初始化空链表

			// 遍历源链表，将每个元素插入到新链表
			for (const auto& e : lt)
			{
				push_back(e);
			}
		}

		// 初始化列表构造函数，支持{1,2,3}形式初始化
		list(initializer_list<T> il)
		{
			empty_init();
			// 遍历初始化列表，插入元素
			for (const auto& e : il)
			{
				push_back(e);
			}
		}

		// 交换两个链表的内容
		void swap(list<T>& lt)
		{
			std::swap(_head, lt._head);  // 交换头节点指针
			std::swap(_size, lt._size);  // 交换大小
		}

		// 赋值运算符重载（现代写法，利用拷贝构造和交换）
		list<T>& operator=(list<T> lt)  // 传值参数会调用拷贝构造
		{
			swap(lt);  // 与临时对象交换，出作用域后临时对象自动析构原数据

			return *this;
		}

		/* 传统赋值运算符实现（已注释）
		list<T>& operator=(const list<T>& lt)
		{
			if (this != &lt)  // 防止自赋值
			{
				clear();  // 清空当前链表
				// 拷贝元素
				for (const auto& e : lt)
				{
					push_back(e);
				}
			}

			return *this;
		}*/

		// 析构函数
		~list()
		{
			clear();       // 清空所有元素节点
			delete _head;  // 删除头节点
			_head = nullptr;
		}

		// 清空链表（保留头节点）
		void clear()
		{
			iterator it = begin();
			// 逐个删除节点直到链表为空
			while (it != end())
			{
				it = erase(it);  // erase返回下一个迭代器
			}
		}

		// 尾插
		void push_back(const T& x)
		{
			insert(end(), x);  // 在尾后迭代器位置插入
		}

		// 头插
		void push_front(const T& x)
		{
			insert(begin(), x);  // 在第一个元素位置插入
		}

		// 尾删
		void pop_back()
		{
			erase(--end());  // 删除最后一个元素
		}

		// 头删
		void pop_front()
		{
			erase(begin());  // 删除第一个元素
		}

		// 在指定位置插入元素
		iterator insert(iterator pos, const T& val)
		{
			Node* cur = pos._node;       // 获取当前位置节点
			Node* newnode = new Node(val);// 创建新节点
			Node* prev = cur->_prev;     // 获取当前节点的前一个节点

			// 调整指针连接新节点
			prev->_next = newnode;
			newnode->_next = cur;
			cur->_prev = newnode;
			newnode->_prev = prev;

			++_size;  // 大小加1

			return iterator(newnode);  // 返回指向新节点的迭代器
		}

		// 删除指定位置的元素
		iterator erase(iterator pos)
		{
			Node* cur = pos._node;       // 获取当前节点
			Node* prev = cur->_prev;     // 前一个节点
			Node* next = cur->_next;     // 后一个节点

			// 调整指针跳过当前节点
			prev->_next = next;
			next->_prev = prev;
			delete cur;  // 释放当前节点内存

			--_size;  // 大小减1

			return iterator(next);  // 返回指向后一个节点的迭代器
		}

		// 获取链表大小
		size_t size() const
		{
			/* 遍历计数方式（已注释，改用_size成员变量）
			size_t n = 0;
			for (auto& e : *this)
			{
				++n;
			}
			return n;*/

			return _size;
		}

	private:
		Node* _head;    // 头节点指针（哨兵节点）
		size_t _size = 0;  // 链表元素个数
	};
}
```

### 3.2>>test.cpp

```
#define _CRT_SECURE_NO_WARNINGS 1

#include<iostream>
#include<algorithm>
#include<vector>
#include<list>
using namespace std;

void test_list1()
{
	list<int> lt1;
	list<int> lt2(10, 1);
	vector<int> v1 = { 1,2,3,4,5,6 };
	list<int> lt3(v1.begin(), v1.end());
	list<int> lt4 = { 1,2,3,4,5,6,1,1,1,1 };

	int a[] = { 1,20,3,40 };
	list<int> lt5(a, a + 4);
	sort(a, a + 4);

	// 1、封装，通用的相似的遍历容器的方式，并且封装屏蔽容器结构的差异，和底层实现细节
	// 2、通用/复用，实现算法时用迭代器函数模板方式实现，跟底层容器结构解耦
	list<int>::iterator it4 = lt4.begin();
	while (it4 != lt4.end())
	{
		cout << *it4 << " ";
		++it4;
	}
	cout << endl;

	for (auto e : lt4)
	{
		cout << e << " ";
	}
	cout << endl;

	sort(a, a + 4);
	sort(v1.begin(), v1.end());
	// 不能用，要求是随时迭代器
	//sort(lt3.begin(), lt3.end());

	reverse(lt3.begin(), lt3.end());
	reverse(v1.begin(), v1.end());
}

void test_list2()
{
	list<int> lt2(10, 1);
	lt2.push_back(10);
	lt2.push_front(10);
	for (auto e : lt2)
	{
		cout << e << " ";
	}
	cout << endl;

	lt2.resize(20, 2);
	for (auto e : lt2)
	{
		cout << e << " ";
	}
	cout << endl;

	lt2.resize(5);
	for (auto e : lt2)
	{
		cout << e << " ";
	}
	cout << endl;
}

void test_list3()
{
	std::list<double> first, second;

	first.push_back(3.1);
	first.push_back(2.2);
	first.push_back(2.9);

	second.push_back(3.7);
	second.push_back(7.1);
	second.push_back(1.4);

	first.sort();
	second.sort();

	first.merge(second);

	std::list<double> lt1 = { 1,2,3,4,5,6,2,3,2 };
	lt1.remove(2);
	for (auto e : lt1)
	{
		cout << e << " ";
	}
	cout << endl;

	// 
	std::list<double> lt2 = { 1,2,3,4,5,6 };
	for (auto e : lt2)
	{
		cout << e << " ";
	}
	cout << endl;
	// 把5转移到头部位置
	auto it = find(lt2.begin(), lt2.end(), 5);
	lt2.splice(lt2.begin(), lt2, it);
	for (auto e : lt2)
	{
		cout << e << " ";
	}
	cout << endl;
}

void test_op1()
{
	srand(time(0));
	const int N = 100000;

	list<int> lt1;
	vector<int> v;

	for (int i = 0; i < N; ++i)
	{
		auto e = rand() + i;
		lt1.push_back(e);
		v.push_back(e);
	}

	int begin1 = clock();
	// 排序
	sort(v.begin(), v.end());
	int end1 = clock();

	int begin2 = clock();
	lt1.sort();
	int end2 = clock();

	printf("vector sort:%d\n", end1 - begin1);
	printf("list sort:%d\n", end2 - begin2);
}

void test_op2()
{
	srand(time(0));
	const int N = 1000000;

	list<int> lt1;
	list<int> lt2;

	for (int i = 0; i < N; ++i)
	{
		auto e = rand() + i;
		lt1.push_back(e);
		lt2.push_back(e);
	}

	int begin1 = clock();
	// 拷贝vector
	vector<int> v(lt2.begin(), lt2.end());
	// 排序
	sort(v.begin(), v.end());

	// 拷贝回lt2
	lt2.assign(v.begin(), v.end());

	int end1 = clock();

	int begin2 = clock();
	lt1.sort();
	int end2 = clock();

	printf("list copy vector sort copy list sort:%d\n", end1 - begin1);
	printf("list sort:%d\n", end2 - begin2);
}

#include"list.h"

namespace wc
{
	void test_list1()
	{
		wc::list<int> lt;
		lt.push_back(1);
		lt.push_back(2);
		lt.push_back(3);
		lt.push_back(4);

		list<int>::iterator it = lt.begin();
		while (it != lt.end())
		{
			cout << *it << " ";
			++it;
		}
		cout << endl;
	}

	template<class T>
	void print(const list<T>& lt)
	{
		// 类模板未实例化，不能去类模板中找后面的东西
		// 编译器就分不清const_iterator是嵌套内类，还是静态成员变量
		// typename告诉编译器，我确认过了这里是类型
		//typename list<T>::const_iterator it = lt.begin();
		auto it = lt.begin();
		while (it != lt.end())
		{
			//*it += 1;
			cout << *it << " ";
			++it;
		}

		cout << endl;
	}

	void test_list2()
	{
		wc::list<int> lt1;
		lt1.push_back(1);
		lt1.push_back(2);
		lt1.push_back(3);
		lt1.push_back(4);
		list<int>::iterator it = lt1.begin();
		while (it != lt1.end())
		{
			*it += 1;

			cout << *it << " ";
			++it;
		}
		cout << endl;

		print(lt1);
	}

	struct Pos
	{
		int _row;
		int _col;

		Pos(int row = 0, int col = 0)
			:_row(row)
			, _col(col)
		{
		}
	};

	void test_list3()
	{
		std::list<Pos> lt1;
		lt1.push_back({ 1,1 });
		lt1.push_back({ 2,2 });
		lt1.push_back({ 3,3 });
		lt1.push_back({ 4,4 });

		//list<Pos>::iterator it = lt1.begin();
		auto it = lt1.begin();
		while (it != lt1.end())
		{
			//cout << (*it)._row << ":" << (*it)._col << endl;
			// 为了可读性，这里省略了一个->
			cout << it->_row << ":" << it->_col << endl;
			//cout << it.operator->()->_row << ":" << it.operator->()->_col << endl;
			++it;
		}
		cout << endl;
	}

	void test_list4()
	{
		wc::list<int> lt1;
		lt1.push_back(1);
		lt1.push_back(2);
		lt1.push_back(3);
		lt1.push_back(4);
		print(lt1);

		lt1.push_front(10);
		lt1.push_front(20);
		print(lt1);

		lt1.pop_back();
		lt1.pop_back();
		print(lt1);

		lt1.pop_front();
		lt1.pop_front();
		print(lt1);
	}

	void test_list5()
	{
		wc::list<int> lt1;
		lt1.push_back(1);
		lt1.push_back(2);
		lt1.push_back(3);
		lt1.push_back(4);
		print(lt1);

		wc::list<int> lt2 = lt1;
		print(lt1);

		wc::list<int> lt3 = { 10,20,30,40 };
		lt1 = lt3;
		print(lt1);
	}

	void test_list6()
	{
		wc::list<int> lt1 = { 10,20,30,40 };
		print(lt1);

		wc::list<double> lt2 = { 10.1,20.1,30.1,40.1 };
		print(lt2);
	}
}

int main()
{
	wc::test_list6();
	//test_op2();
	// 
	//cout<<typeid(vector<int>::iterator).name() << endl;

	return 0;
}
```

## 4>>list和vector的对比

|  |  |  |
| --- | --- | --- |
|  | vector | list |
| 底  层  结  构 | 动态顺序表，一段连续空间 | 带头结点的双向循环链表 |
| 随  机  访  问 | 支持随机访问，访问某个元素效率O(1) | 不支持随机访问，访问某个元  素效率O(N) |
| 插  入  和  删  除 | 任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)，插入时有可能需要增容，增容：开辟新空间，拷贝元素，释放旧空间，导致效率更低 | 任意位置插入和删除效率高，不需要搬移元素，时间复杂度为O(1) |
| 空  间  利  用  率 | 底层为连续空间，不容易造成内存碎片，空间利用  率高，缓存利用率高 | 底层节点动态开辟，小节点容  易造成内存碎片，空间利用率  低，缓存利用率低 |
| 迭  代  器 | 原生态指针 | 对原生态指针(节点指针)进行  封装 |
| 迭  代  器  失  效 | 在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，致使原来迭代器失效，删除时，当前迭代器需要重新赋值否则会失效 | 插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响 |
| 使  用  场  景 | 需要高效存储，支持随机访问，不关心插入删除效率 | 大量插入和删除操作，不关心  随机访问 |

## 5>>结语

        今日C++到这里就结束啦，如果觉得文章还不错的话，可以三连支持一下。感兴趣的宝子们欢迎持续订阅小枫，小枫在这里谢谢宝子们啦~[小枫の主页](https://blog.csdn.net/m0_69282950?spm=1010.2135.3001.5343 "小枫の主页")还有更多生动有趣的文章，欢迎宝子们去点评鸭~C++的学习很陡，时而巨难时而巨简单，希望宝子们和小枫一起坚持下去~你们的三连就是小枫的动力，感谢支持~

##



