---
layout: post
title: java中定义一个时间_Java中的日期和时间
date: 2021-02-26 10:27:39 +0800
categories: ['Java']
tags: ['Java']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=114725510
    alt: java中定义一个时间_Java中的日期和时间
artid: 114725510
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=114725510
featuredImagePreview: https://bing.ee123.net/img/rand?artid=114725510
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java中定义一个时间_Java中的日期和时间
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div style="font-size:16px;">
     <p>
      根据个人目前正在编写的《Java核心编程-基础篇》的规划，这部分属于第15章内容，这里沿用了书中的章节编号。另外，因为原文篇幅太长，这里适当做了删减。
     </p>
     <p>
      15.1、概述
     </p>
     <p>
      在 Java 8 之前，Java 语言表示时间的方法很简单，几乎都是采用毫秒值来表示时间。
     </p>
     <p>
      比如获得系统当前时间可以使用以下方法:
     </p>
     <p>
      long now = System.currentTimeMillis();
     </p>
     <p>
      System.out.println( now );
     </p>
     <p>
      这里获取的毫秒值是从 格里高利历 的 1970年1月1日 0点0分0秒0毫秒 至现在所经历的毫秒数。
     </p>
     <p>
      即使是在 java.util.Date 类的实例 或 java.util.Calendar类的实例中，也仍然是通过毫秒值来表示时间。
     </p>
     <p>
      因为 java.util.Date 类的实例 或 java.util.Calendar类在设计上的缺陷，
     </p>
     <p>
      从 Java 8 开始提供了一个全新的包 (java.time ) 来表示时区、日期、时间。
     </p>
     <p>
      接下来我们将从 Date 和 Calendar 说起，来研究 时期、时间的表示方法 以及 日期格式化 等操作。
     </p>
     <p>
      15.2、Date 类
     </p>
     <p>
      Date 类的实例表示特定的瞬间( 精确到毫秒 )。
     </p>
     <p>
      package java.util;
     </p>
     <p>
      import java.io.Serializable ;
     </p>
     <p>
      public class Date implements Serializable, Cloneable, Comparable {
      <!-- -->
     </p>
     <p>
      }
     </p>
     <p>
      Date 类实现了 Serializable 、Cloneable 、Comparable 等接口。
     </p>
     <p>
      15.2.1、实例字段
     </p>
     <p>
      Date 类中封装了一个 long 类型的字段，用来保存 Date 实例所表示的时间:
     </p>
     <p>
      private transient long fastTime;
     </p>
     <p>
      15.2.2、构造方法
     </p>
     <p>
      目前还有两个未被废弃的构造方法:
     </p>
     <p>
      public Date( long millis ) {
      <!-- -->
     </p>
     <p>
      fastTime = millis ;
     </p>
     <p>
      }
     </p>
     <p>
      public Date() {
      <!-- -->
     </p>
     <p>
      this( System.currentTimeMillis() );
     </p>
     <p>
      }
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.util.Date;
     </p>
     <p>
      public class DateTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      // 构造方法内部将 System.currentTimeMillis() 保存到 fastTime 字段中
     </p>
     <p>
      Date date = new Date();
     </p>
     <p>
      System.out.println( date ); // CST : China Standard Time
     </p>
     <p>
      // 构造方法内部将 -1000L 保存到 fastTime 字段中
     </p>
     <p>
      Date d = new Date( -1000L );
     </p>
     <p>
      System.out.println( d );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      注意，输出 date 对象的字符串形式时，CST 表示 China Standard Time ，即中国标准时间。
     </p>
     <p>
      15.2.3、实例方法
     </p>
     <p>
      Date 类中绝大多数实例方法都已经被废弃(不赞成使用)，仅存的几个可用的实例方法如下:
     </p>
     <p>
      public long getTime()
     </p>
     <p>
      获取 Date 实例内部存储的毫秒值。
     </p>
     <p>
      public void setTime( long time )
     </p>
     <p>
      设置 Date 实例内部存储的毫秒值。
     </p>
     <p>
      public String toString()
     </p>
     <p>
      将当前 Date 实例所存储的毫秒值转换为以下形式的 字符串：
     </p>
     <p>
      dow mon dd hh:mm:ss zzz yyyy
     </p>
     <p>
      其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。
     </p>
     <p>
      public boolean equals( Object obj )
     </p>
     <p>
      Date 类重写了从 Object 类继承的 equals 方法用于判断当前 Date 实例与另外一个对象是否"相等"。
     </p>
     <p>
      public boolean after( Date when )
     </p>
     <p>
      测试 当前 Date 实例 所表示的时间 是否在 指定Date实例 所表示的时间之后。
     </p>
     <p>
      public boolean before( Date when )
     </p>
     <p>
      测试 当前 Date 实例 所表示的时间 是否在 指定Date实例 所表示的时间之前。
     </p>
     <p>
      15.2.3.1、Date实例是可变的
     </p>
     <p>
      Date 实例 是 【可变的】，在创建 Date 实例后，其内部的 毫秒值 是可以更改的
     </p>
     <p>
      import java.util.Date;
     </p>
     <p>
      public class DateTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      long ms = 1000L * 60 * 60 * 24 * 365 * 30 ;
     </p>
     <p>
      final Date date = new Date( ms );
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      birthdate.setTime( 1000 );
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.2.3.2、比较Date实例
     </p>
     <p>
      Date实例的比较，可以通过 equals 、after 、before 方法来实现:
     </p>
     <p>
      import java.util.Date;
     </p>
     <p>
      public class DateTest3 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      long ms = 1000L * 60 * 60 * 24 * 365 * 30 ;
     </p>
     <p>
      Date first = new Date( ms );
     </p>
     <p>
      System.out.println( first );
     </p>
     <p>
      Date second = new Date( ms );
     </p>
     <p>
      System.out.println( second );
     </p>
     <p>
      System.out.println( first == second ); // false
     </p>
     <p>
      // java.utl.Date 类 重写了 从 Object 类继承的 equals 方法
     </p>
     <p>
      System.out.println( first.equals( second ) ); // true
     </p>
     <p>
      Date now = new Date();
     </p>
     <p>
      System.out.println( now.after( first ) ); // true
     </p>
     <p>
      System.out.println( now.after( second ) ); // true
     </p>
     <p>
      System.out.println( first.before( now ) ); // true
     </p>
     <p>
      System.out.println( second.before( now ) ); // true
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      不建议使用的比较方法是这样子的:
     </p>
     <p>
      long firstTime = first.getTime() ;
     </p>
     <p>
      long secondTime = second.getTime() ;
     </p>
     <p>
      if( firstTime &gt; secondTime ) {
      <!-- -->
     </p>
     <p>
      System.out.println( first + " 晚于 " + second );
     </p>
     <p>
      }
     </p>
     <p>
      15.3 Calendar类
     </p>
     <p>
      Calendar一词表示日历，而 Java 语言中 Calendar 则是一个类，一个声明在 java.util 包中的抽象类。
     </p>
     <p>
      Calendar 类为
      <b style="color:#0000FF;">
       特定瞬间
      </b>
      与
      <b style="color:#0000FF;">
       日历字段
      </b>
      之间的转换提供了一些方法，并为操作日历字段提供了一些方法
     </p>
     <p>
      瞬间可用毫秒值来表示，它是距历元的偏移量。
     </p>
     <p>
      历元(epoch) 是指 格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000 ( 格里高利历 ) 。
     </p>
     <p>
      15.3.1、日历字段
     </p>
     <p>
      日历字段是 Calendar 类中声明的用来表示日期时间中指定部分的常量。
     </p>
     <p>
      常用的日历字段如下:
     </p>
     <p>
      Calendar.ERA 对应纪元
     </p>
     <p>
      比如罗马儒略历中的 AD 或 BC ( 中文表示为 公元 或 公元前 )
     </p>
     <p>
      Calendar.YEAR 对应年份
     </p>
     <p>
      Calendar.MONTH 对应月份
     </p>
     <p>
      月份从 0 开始计数，0 表示 January (一月)，1 表示 February ( 二月 )
     </p>
     <p>
      Calendar.DATE 对应月份中的日期
     </p>
     <p>
      日期从 1 开始计数，有效范围为 1 ~ 31 。
     </p>
     <p>
      Calendar.HOUR_OF_DAY 对应一天当中的小时
     </p>
     <p>
      小时从 0 开始计数，有效范围为 0 ~ 23 。
     </p>
     <p>
      Calendar.MINUTE 对应分钟
     </p>
     <p>
      分钟从 0 开始计数，有效范围为 0 ~ 59 。
     </p>
     <p>
      Calendar.SECOND 对应秒
     </p>
     <p>
      秒数从 0 开始计数，有效范围为 0 ~ 60 。(要注意闰秒)
     </p>
     <p>
      Calendar.MILLISECOND 对应毫秒
     </p>
     <p>
      毫秒数从 0 开始计数，有效范围为 0 ~ 999 。
     </p>
     <p>
      Calendar.DAY_OF_MONTH 对应月份中的日期
     </p>
     <p>
      日期从 1 开始计数，有效范围为 1 ~ 31 。
     </p>
     <p>
      Calendar.HOUR 对应上午或下午的小时
     </p>
     <p>
      小时从 0 开始计数，有效范围为 0 ~ 11 。
     </p>
     <p>
      Calendar.DAY_OF_WEEK 对应星期
     </p>
     <p>
      用于指示一个星期中的某天。
     </p>
     <p>
      该字段可取的值可以是 SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY 和 SATURDAY。
     </p>
     <p>
      Calendar.DAY_OF_YEAR 对应年份中的天数
     </p>
     <p>
      指示当前年中的天数。一年中第一天的值为 1，最大值为 366 。
     </p>
     <p>
      15.3.2、获取Calendar实例
     </p>
     <p>
      15.3.2.1、通过创建子类实例的方式
     </p>
     <p>
      GregorianCalendar 类是 Calendar 类的子类，
     </p>
     <p>
      通过创建 GregorianCalendar类的实例即可使用 Calendar 中的方法。
     </p>
     <p>
      Calendar c = new GregorianCalendar(); // 父类引用 指向 子类对象
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      15.3.2.2、通过类方法获取
     </p>
     <p>
      Calendar 类中定义了大量的类方法用于获取 Calendar 实例:
     </p>
     <p>
      public static Calendar getInstance()
     </p>
     <p>
      举例:
     </p>
     <p>
      Calendar c = Calendar.getInstance();
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      public static Calendar getInstance( TimeZone zone, Locale locale )
     </p>
     <p>
      举例：
     </p>
     <p>
      TimeZone zone = TimeZone.getDefault();
     </p>
     <p>
      Locale locale = Locale.getDefault() ;
     </p>
     <p>
      Calendar c = Calendar.getInstance( zone , locale );
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      15.3.3、从 Calendar 实例中获取时间
     </p>
     <p>
      Calendar 类中声明了以下方法用于从 特定瞬间 中获取 指定日历字段 对应的值:
     </p>
     <p>
      public int get( int calendarField )
     </p>
     <p>
      同时在 Calendar 类中声明了以下方法用于获取 Calendar实例所表示的瞬间对应的毫秒值:
     </p>
     <p>
      public long getTimeInMillis()
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.util.Calendar;
     </p>
     <p>
      import java.util.GregorianCalendar;
     </p>
     <p>
      public class CalendarTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      // 父类引用 指向 子类对象
     </p>
     <p>
      Calendar c = new GregorianCalendar();
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      // 从 c 对应的 Calendar 实例中获取 日历字段 ERA 对应的值
     </p>
     <p>
      int era = c.get( Calendar.ERA ) ;
     </p>
     <p>
      System.out.println( era );
     </p>
     <p>
      int year = c.get( Calendar.YEAR );
     </p>
     <p>
      System.out.println( year );
     </p>
     <p>
      // 在西方国家，月份的索引从 零 开始，0 表示 1月 ， 11 表示12月
     </p>
     <p>
      int month = c.get( Calendar.MONTH );
     </p>
     <p>
      System.out.println( month );
     </p>
     <p>
      int date = c.get( Calendar.DATE );
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      int hourOfDay = c.get( Calendar.HOUR_OF_DAY );
     </p>
     <p>
      System.out.println( hourOfDay );
     </p>
     <p>
      int minute = c.get( Calendar.MINUTE );
     </p>
     <p>
      System.out.println( minute );
     </p>
     <p>
      int second = c.get( Calendar.SECOND );
     </p>
     <p>
      System.out.println( second );
     </p>
     <p>
      // 仅仅获取 MILLISECOND 字段对应的值，取值范围为 [ 0 , 1000 )
     </p>
     <p>
      int millis = c.get( Calendar.MILLISECOND );
     </p>
     <p>
      System.out.println( millis );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      // 获取 当前的 Calendar 实例所表示的瞬间 对应的毫秒值(距离历元的偏移量)
     </p>
     <p>
      long ms = c.getTimeInMillis();
     </p>
     <p>
      System.out.println( ms );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.3.4、设置 Calendar 实例
     </p>
     <p>
      Calendar 类中声明了以下方法用于用于为 指定的 日历字段 设置相应的值:
     </p>
     <p>
      public void set( int calendarField, int value )
     </p>
     <p>
      同时也提供了以下方法来批量设置年、月、日、小时、分钟、秒、毫秒等 日历字段 的值
     </p>
     <p>
      public final void set( int year, int month, int date )
     </p>
     <p>
      public final void set( int year, int month, int date, int hourOfDay )
     </p>
     <p>
      public final void set( int year, int month, int date, int hourOfDay, int minute,int second )
     </p>
     <p>
      需要注意的是，这里的 hourOfDay 与 Calendar.HOUR_OF_DAY对应，表示一天中的小时，取值范围是 0 ~ 23 。
     </p>
     <p>
      另外，Calendar 类中声明了用于清空所有日历字段取值的方法:
     </p>
     <p>
      public final void clear()
     </p>
     <p>
      Calendar 类中也声明了用于清空指定的 日历字段取值的方法:
     </p>
     <p>
      public final void clear( int calendarField )
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.util.*;
     </p>
     <p>
      public class CalendarTest3 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      // 父类引用 指向 子类对象
     </p>
     <p>
      Calendar c = new GregorianCalendar();
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      c.set( Calendar.YEAR , 1996 ); // 公元1996年
     </p>
     <p>
      c.set( Calendar.MONTH , 0 ); // 月份的索引从 0 开始，0表示1月
     </p>
     <p>
      c.set( Calendar.DATE , 10 );
     </p>
     <p>
      c.set( Calendar.HOUR_OF_DAY , 11 );
     </p>
     <p>
      c.set( Calendar.MINUTE , 45 );
     </p>
     <p>
      c.set( Calendar.SECOND , 0 );
     </p>
     <p>
      c.set( Calendar.MILLISECOND , 0 );
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      System.out.println( c.getTimeInMillis() );
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      c.clear(); // 清除所有日历字段的值
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      // YEAR 、MONTH 、HOUR_OF_DAY 、MINUTE、SECOND
     </p>
     <p>
      c.set( 0 , 0 , 10 , 11 , 45 , 30 );
     </p>
     <p>
      c.set( Calendar.MILLISECOND , 100 );
     </p>
     <p>
      System.out.println( c.getTimeInMillis() );
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.3.5、将 Calendar 实例转换为 Date类型的实例
     </p>
     <p>
      Calendar 类中声明了用于将当前的Calendar实例所表示的瞬间转换为Date实例的方法:
     </p>
     <p>
      public final Date getTime()
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.util.*;
     </p>
     <p>
      public class CalendarTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      // 父类引用 指向 子类对象
     </p>
     <p>
      Calendar c = new GregorianCalendar();
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      // java.util.Date 类中的 getTime() 方法可以返回一个毫秒值
     </p>
     <p>
      // java.util.Calendar 类中的 getTime() 用于返回相应的 Date 实例
     </p>
     <p>
      Date date = c.getTime(); // 返回 当前 Calendar 实例所表示的瞬间 对应的 Date 实例
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.3.6、获取任意时间对应的Date实例
     </p>
     <p>
      截至目前，我们可以借助于 Calendar 实例来获取任意时间对应的 Date 实例，其步骤为
     </p>
     <p>
      a&gt;、获得 Calendar 实例
     </p>
     <p>
      b&gt;、清空所有日历字段的值
     </p>
     <p>
      c&gt;、根据实际需要设置 年月日、时分秒 等日历字段的值
     </p>
     <p>
      d&gt;、获取 Calendar 实例所表示的瞬间 对应的 Date 实例
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.util.*;
     </p>
     <p>
      public class CalendarTest4 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      TimeZone zone = TimeZone.getDefault();
     </p>
     <p>
      Locale locale = Locale.getDefault() ;
     </p>
     <p>
      // 1、获得 Calendar 实例
     </p>
     <p>
      Calendar c = Calendar.getInstance( zone , locale );
     </p>
     <p>
      System.out.println( c );
     </p>
     <p>
      // 2、清空所有日历字段的值
     </p>
     <p>
      c.clear();
     </p>
     <p>
      // 3、根据实际需要设置 年月日、时分秒
     </p>
     <p>
      c.set( 1998 , 10 , 20 , 5 , 30 , 40 );
     </p>
     <p>
      c.set( Calendar.MILLISECOND , 0 );
     </p>
     <p>
      // 4、获取 Calendar 实例所表示的瞬间 对应的 Date 实例
     </p>
     <p>
      Date date = c.getTime();
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      在 Java 8 之前，获得 任意的 年月日、时分秒 对应的 Date 实例，可以使用两种方法:
     </p>
     <p>
      通过将特定格式的字符串解析为Date实例 ( 在 DateFormat 中讲解 )
     </p>
     <p>
      通过 Calendar 实例来获取
     </p>
     <p>
      15.4 DateFormat 类
     </p>
     <p>
      java.text.DateFormat 类提供了用于将日期格式化和解析字符串为Date实例的方法：
     </p>
     <p>
      public final String format( Date date )
     </p>
     <p>
      public Date parse(String source) throws ParseException
     </p>
     <p>
      但是 DateFormat 类是个抽象类，其子类 SimpleDateFormat 是个具体类(非抽象类)。
     </p>
     <p>
      SimpleDateFormat 类的构造方法:
     </p>
     <p>
      public SimpleDateFormat()
     </p>
     <p>
      public SimpleDateFormat( String pattern )
     </p>
     <p>
      public SimpleDateFormat( String pattern , Locale locale )
     </p>
     <p>
      public SimpleDateFormat( String pattern , DateFormatSymbols formatSymbols )
     </p>
     <p>
      其中最常用的是:
     </p>
     <p>
      public SimpleDateFormat( String pattern )
     </p>
     <p>
      参数中的 pattern 表示日期的模式。
     </p>
     <p>
      日期模式的字符串可以使用以下模式字母:
     </p>
     <p align="center">
      <img alt="cc803d6af9c5" src="https://www.jianshu.com/p/cc803d6af9c5"/>
     </p>
     <p>
      dateformat-pattern.png
     </p>
     <p>
      比如 yyyy-MM-dd 对应 1996-12-12 。
     </p>
     <p>
      15.4.1、日期格式化
     </p>
     <p>
      日期格式化举例:
     </p>
     <p>
      import java.text.DateFormat;
     </p>
     <p>
      import java.text.SimpleDateFormat;
     </p>
     <p>
      import java.util.Date;
     </p>
     <p>
      import java.util.Locale;
     </p>
     <p>
      /**
     </p>
     <p>
      * 重要: 将 java.util.Date 实例所表示的 【瞬间】 格式化为 【特定模式】的字符串
     </p>
     <p>
      */
     </p>
     <p>
      public class DateFormatTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      long ms = 1000L * 60 * 60 * 24 * 365 * 30 ;
     </p>
     <p>
      Date birthdate = new Date( ms );
     </p>
     <p>
      String pattern = "G yyyy年MM月dd日 EEEE HH:mm:ss.SSS" ; // 确定 "日期时间" 的模式
     </p>
     <p>
      DateFormat df = new SimpleDateFormat( pattern );
     </p>
     <p>
      String s = df.format( birthdate );
     </p>
     <p>
      System.out.println( s );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.4.2、解析字符串为Date实例
     </p>
     <p>
      将指定字符串按照特定的模式解析为 Date 实例:
     </p>
     <p>
      import java.text.DateFormat;
     </p>
     <p>
      import java.text.ParseException;
     </p>
     <p>
      import java.text.SimpleDateFormat;
     </p>
     <p>
      import java.util.Date;
     </p>
     <p>
      import java.util.Locale;
     </p>
     <p>
      import java.util.Scanner;
     </p>
     <p>
      /**
     </p>
     <p>
      * 重要: 将 字符串 解析为 java.util.Date 实例
     </p>
     <p>
      */
     </p>
     <p>
      public class DateFormatTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      final String pattern = "yyyy-MM-dd" ;
     </p>
     <p>
      DateFormat df = new SimpleDateFormat( pattern );
     </p>
     <p>
      Scanner sc = new Scanner( System.in );// 创建扫描器用户读取用户输入的数据
     </p>
     <p>
      System.out.println( "请输入一个日期( 格式为 " + pattern + " ，比如 2019-09-01 )" );
     </p>
     <p>
      String s = sc.nextLine(); // 读取用户输入的整行数据
     </p>
     <p>
      System.out.println( "你输入的是: " + s );
     </p>
     <p>
      try {
      <!-- -->
     </p>
     <p>
      // 将 字符串 解析为 Date 类型的实例
     </p>
     <p>
      Date date = df.parse( s ); // 可能抛出 ParseException 异常
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      long time = date.getTime() ;
     </p>
     <p>
      System.out.println( time );
     </p>
     <p>
      } catch ( ParseException e ) {
      <!-- -->
     </p>
     <p>
      System.out.println( "你输入的日期格式不符合 " + pattern );
     </p>
     <p>
      e.printStackTrace();
     </p>
     <p>
      }
     </p>
     <p>
      sc.close(); // 关闭扫描器
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.5 LocalDate类
     </p>
     <p>
      有鉴于 java.util.Date 类 和 java.util.Calendar 类在设计上的缺陷，从 Java 8 开始，JDK 中新增了 java.time 包，其中定义了大量的用来表示日期、时间的类型。
     </p>
     <p>
      15.5.1、LocalDate类的设计
     </p>
     <p>
      java.time.LocalDate 类是一个不可变类，该类是被 final 所修饰，因此该类没有子类。
     </p>
     <p>
      package java.time;
     </p>
     <p>
      // 省略 import 语句
     </p>
     <p>
      public final class LocalDate
     </p>
     <p>
      implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {
      <!-- -->
     </p>
     <p>
      // 省略其它代码
     </p>
     <p>
      private final int year; // The year.
     </p>
     <p>
      private final short month; // The month-of-year.
     </p>
     <p>
      private final short day; // The day-of-month.
     </p>
     <p>
      // 省略其它代码
     </p>
     <p>
      }
     </p>
     <p>
      在 java.time.LocalDate 类中声明了三个实例字段用来存储 年份、月份、日期:
     </p>
     <p>
      private final int year;
     </p>
     <p>
      private final short month;
     </p>
     <p>
      private final short day;
     </p>
     <p>
      因为它们都是 final 修饰的，因此一旦创建 LocalDate 实例，其 年份、月份、日期 的值再也不能被更改。
     </p>
     <p>
      另外，LocalDate 类还声明了以下常量:
     </p>
     <p>
      public static final LocalDate MIN = LocalDate.of( Year.MIN_VALUE, 1, 1 );
     </p>
     <p>
      public static final LocalDate MAX = LocalDate.of( Year.MAX_VALUE, 12, 31 );
     </p>
     <p>
      public static final LocalDate EPOCH = LocalDate.of( 1970, 1, 1 );
     </p>
     <p>
      从常量命名可知，MAX、MIN 分别表示 LocalDate 所能表示的日期的最大值和最小值。
     </p>
     <p>
      而 EPOCH 则表示历元对应的日期。
     </p>
     <p>
      15.5.2、获取 LocalDate 实例
     </p>
     <p>
      java.time.LocalDate 类提供了许多类方法用于获取 LocalDate 实例，以下是几个常用的方法:
     </p>
     <p>
      public static LocalDate now()
     </p>
     <p>
      public static LocalDate of( int year , int month , int dayOfMonth )
     </p>
     <p>
      public static LocalDate ofYearDay( int year , int dayOfYear )
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      public class LocalDateTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      // 通过 LocalDate 类中的 类方法 ( now ) 来获取 LocalDate 实例
     </p>
     <p>
      LocalDate now = LocalDate.now();
     </p>
     <p>
      System.out.println( now );
     </p>
     <p>
      // 通过 LocalDate 类中的 类方法 ( of ) 来获取 LocalDate 实例
     </p>
     <p>
      LocalDate birthdate = LocalDate.of( 1999 , 12 , 31 );
     </p>
     <p>
      System.out.println( birthdate );
     </p>
     <p>
      // 通过 LocalDate 类中的 类方法 ( ofYearDay ) 来获取 LocalDate 实例
     </p>
     <p>
      LocalDate date = LocalDate.ofYearDay( 2019 , 244 );
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.5.3、常用实例方法
     </p>
     <p>
      LocalDate 类中定义了大量的实例方法，其中比较常用的是:
     </p>
     <p>
      public int getYear() 用于获取年份
     </p>
     <p>
      public int getMonthValue() 用于获取月份 ( 取值范围是 1 ~ 12 )
     </p>
     <p>
      public int getDayOfMonth() 用于获取日期 ( 取值范围是 1 ~ 31 )
     </p>
     <p>
      public DayOfWeek getDayOfWeek() 用于获取星期 ( 返回类型为 DayOfWeek )
     </p>
     <p>
      public boolean isLeapYear() 用于判断 LocalDate 实例对应的年份是否是闰年
     </p>
     <p>
      public int lengthOfYear() 用于获取 LocalDate 实例对应的年份的总天数
     </p>
     <p>
      public int lengthOfMonth() 用于获取 LocalDate 实例对应的月份的总天数
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.DayOfWeek;
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      public class LocalDateTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDate n = LocalDate.now() ;
     </p>
     <p>
      System.out.println( n.getYear() + "年" );
     </p>
     <p>
      System.out.println( n.getMonthValue() + "月" );
     </p>
     <p>
      System.out.println( n.getDayOfMonth() + "日" );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      DayOfWeek day = n.getDayOfWeek();
     </p>
     <p>
      System.out.println( day );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      boolean leap = n.isLeapYear();
     </p>
     <p>
      System.out.println( leap );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      System.out.println( n.lengthOfYear() );
     </p>
     <p>
      System.out.println( n.lengthOfMonth() );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      同时，LocalDate 类中定义了用于比较 LocalDate 实例的方法:
     </p>
     <p>
      public boolean equals( Object obj )
     </p>
     <p>
      public boolean isEqual( ChronoLocalDate other )
     </p>
     <p>
      public boolean isBefore( ChronoLocalDate other )
     </p>
     <p>
      public boolean isAfter( ChronoLocalDate other )
     </p>
     <p>
      另外，LocalDate 类还定义了 在指定的 LocalDate 对应的日期基础上 增加或减少 指定时间的方法:
     </p>
     <p>
      public LocalDate plusYears( long yearsToAdd )
     </p>
     <p>
      public LocalDate plusDays( long daysToAdd )
     </p>
     <p>
      public LocalDate plusMonths( long monthsToAdd )
     </p>
     <p>
      public LocalDate plusWeeks( long weeksToAdd )
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.DayOfWeek;
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      public class LocalDateTest3 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDate n = LocalDate.now(); // 获得当前日期
     </p>
     <p>
      System.out.println( n );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      // 在 n 所表示的日期基础上减少18年后返回 新的 LocalDate 实例
     </p>
     <p>
      LocalDate f = n.plusYears( -18 );
     </p>
     <p>
      System.out.println( f );
     </p>
     <p>
      System.out.println( n == f );
     </p>
     <p>
      System.out.println( n.equals( f ) );
     </p>
     <p>
      System.out.println( n.isEqual( f ) ); // 比较两个 LocalDate 实例是否相等
     </p>
     <p>
      System.out.println( n.isAfter( f ) );
     </p>
     <p>
      System.out.println( n.isBefore( f ) );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      // 在 f 所表示的日期基础上增加18年后返回 新的 LocalDate 实例
     </p>
     <p>
      LocalDate s = f.plusYears( 18 );
     </p>
     <p>
      System.out.println( s == n );
     </p>
     <p>
      System.out.println( s.equals( n ) );
     </p>
     <p>
      System.out.println( s.isEqual( n ) );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      // 在 n 所表示的日期基础上增加 10天 后返回 新的 LocalDate 实例
     </p>
     <p>
      LocalDate t = n.plusDays( 10 );
     </p>
     <p>
      System.out.println( t );
     </p>
     <p>
      // 在 n 所表示的日期基础上增加 5个月 后返回 新的 LocalDate 实例
     </p>
     <p>
      LocalDate o = n.plusMonths( 5 );
     </p>
     <p>
      System.out.println( o );
     </p>
     <p>
      // 在 n 所表示的日期基础上增加 9周 后返回 新的 LocalDate 实例
     </p>
     <p>
      LocalDate x = n.plusWeeks( 9 );
     </p>
     <p>
      System.out.println( x );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.6 LocalTime 类
     </p>
     <p>
      15.6.1、LocalTime 类的设计
     </p>
     <p>
      java.time.LocalTime 类是一个不可变类，该类是被 final 所修饰，因此该类没有子类。
     </p>
     <p>
      package java.time;
     </p>
     <p>
      // 省略 import 语句
     </p>
     <p>
      public final class LocalTime
     </p>
     <p>
      implements Temporal, TemporalAdjuster, Comparable, Serializable {
      <!-- -->
     </p>
     <p>
      // 省略其它代码
     </p>
     <p>
      private final byte hour ; // The hour.
     </p>
     <p>
      private final byte minute ; // The minute.
     </p>
     <p>
      private final byte second ; // The second.
     </p>
     <p>
      private final int nano ; // The nanosecond.
     </p>
     <p>
      // 省略其它代码
     </p>
     <p>
      }
     </p>
     <p>
      在 java.time.LocalTime 类中声明了四个实例字段用来存储 小时、分钟、秒、纳秒:
     </p>
     <p>
      private final byte hour ;
     </p>
     <p>
      private final byte minute ;
     </p>
     <p>
      private final byte second ;
     </p>
     <p>
      private final int nano ;
     </p>
     <p>
      因为它们都是 final 修饰的，因此一旦创建 LocalTime 实例，其中各个字段的值再也不能被更改。
     </p>
     <p>
      15.6.2、获取 LocalTime 实例
     </p>
     <p>
      java.time.LocalTime 类提供了许多类方法用于获取 LocalTime 实例，以下是几个常用的方法:
     </p>
     <p>
      public static LocalTime now()
     </p>
     <p>
      public static LocalTime of( int hour , int minute )
     </p>
     <p>
      public static LocalTime of( int hour , int minute , int second )
     </p>
     <p>
      public static LocalTime of( int hour , int minute , int second , int nanoOfSecond)
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.LocalTime;
     </p>
     <p>
      public class LocalTimeTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalTime now = LocalTime.now();
     </p>
     <p>
      System.out.println( now );
     </p>
     <p>
      LocalTime f = LocalTime.of( 12,0 );
     </p>
     <p>
      System.out.println( f );
     </p>
     <p>
      LocalTime s = LocalTime.of( 12,24 , 36 );
     </p>
     <p>
      System.out.println( s );
     </p>
     <p>
      // 1s = 1000ms (毫秒)
     </p>
     <p>
      // 1ms = 1000us (微秒)
     </p>
     <p>
      // 1us = 1000ns ( 纳秒 或 毫微秒 )
     </p>
     <p>
      LocalTime t = LocalTime.of( 12,24 , 36 , 100200300);
     </p>
     <p>
      System.out.println( t );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.6.3、常用实例方法
     </p>
     <p>
      LocalTime 类中定义了大量的实例方法，其中比较常用的是:
     </p>
     <p>
      public int getHour() 用于获取小时 (取值范围为 0 ~ 23 )
     </p>
     <p>
      public int getMinute() 用于获取分钟 (取值范围为 0 ~ 59 )
     </p>
     <p>
      public int getSecond() 用于获取秒 (取值范围为 0 ~ 59 )
     </p>
     <p>
      public int getNano() 用于获取纳秒 (取值范围为 0 ~ 999999999 )
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.LocalTime;
     </p>
     <p>
      public class LocalTimeTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalTime now = LocalTime.now();
     </p>
     <p>
      System.out.println( now );
     </p>
     <p>
      System.out.println( now.getHour() + "时" );
     </p>
     <p>
      System.out.println( now.getMinute() + "分" );
     </p>
     <p>
      System.out.println( now.getSecond() + "秒" );
     </p>
     <p>
      long nano = now.getNano(); // 其返回值为 0 ~ 999999999
     </p>
     <p>
      long ms = nano / 1000000 ; // 求取毫秒部分的数值( 范围为 0 ~ 999 )
     </p>
     <p>
      System.out.println( ms + "毫秒" );
     </p>
     <p>
      long us = nano % 1000000 / 1000 ; // 求取微秒部分的数值( 范围为 0 ~ 999 )
     </p>
     <p>
      System.out.println( us + "微秒" );
     </p>
     <p>
      long ns = nano % 1000000 % 1000 ; // 求取纳秒部分的数值( 范围为 0 ~ 999 )
     </p>
     <p>
      System.out.println( ns + "纳秒" );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      同时，LocalTime 类中定义了用于比较 LocalTime 实例的方法:
     </p>
     <p>
      public boolean isAfter( LocalTime other )
     </p>
     <p>
      public boolean isBefore( LocalTime other )
     </p>
     <p>
      public boolean equals( Object obj )
     </p>
     <p>
      另外，LocalTime 类还定义了 在指定的 LocalTime 对应的时间基础上 增加或减少 指定时间的方法:
     </p>
     <p>
      public LocalTime plusHours( long hoursToAdd )
     </p>
     <p>
      public LocalTime plusMinutes( long minutesToAdd )
     </p>
     <p>
      public LocalTime plusSeconds( long secondstoAdd )
     </p>
     <p>
      public LocalTime plusNanos( long nanosToAdd )
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.LocalTime;
     </p>
     <p>
      public class LocalTimeTest3 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalTime time = LocalTime.now(); // 获取当前时间
     </p>
     <p>
      System.out.println( time );
     </p>
     <p>
      // 在 time 所表示的时间基础上增加 5 小时后返回新的 LocalTime 实例
     </p>
     <p>
      LocalTime t1 = time.plusHours( 5 );
     </p>
     <p>
      System.out.println( t1 );
     </p>
     <p>
      // 在 time 所表示的时间基础上减少 20 分钟 后返回新的 LocalTime 实例
     </p>
     <p>
      LocalTime t2 = time.plusMinutes( -20 );
     </p>
     <p>
      System.out.println( t2 );
     </p>
     <p>
      // 在 time 所表示的时间基础上增加 30 秒 后返回新的 LocalTime 实例
     </p>
     <p>
      LocalTime t3 = time.plusSeconds( 30 );
     </p>
     <p>
      System.out.println( t3 );
     </p>
     <p>
      // 在 time 所表示的时间基础上增加 100200300 纳秒 后返回新的 LocalTime 实例
     </p>
     <p>
      LocalTime t4 = time.plusNanos( 100200300L );
     </p>
     <p>
      System.out.println( t4 );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      System.out.println( t1.isAfter( t2 ) );
     </p>
     <p>
      System.out.println( t2.isBefore( t3 ) );
     </p>
     <p>
      System.out.println( t3.equals( t4 ) );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.7 LocalDateTime类
     </p>
     <p>
      15.7.1、LocalDateTime 类的设计
     </p>
     <p>
      java.time.LocalDateTime 类是一个 不可变类，该类是被 final 所修饰，因此该类没有子类。
     </p>
     <p>
      package java.time;
     </p>
     <p>
      // 省略 import 语句
     </p>
     <p>
      public final class LocalDateTime
     </p>
     <p>
      implements Temporal, TemporalAdjuster, ChronoLocalDateTime,
     </p>
     <p>
      Serializable {
      <!-- -->
     </p>
     <p>
      // 省略其它代码
     </p>
     <p>
      private final LocalDate date ; // The date part.
     </p>
     <p>
      private final LocalTime time ; // The time part.
     </p>
     <p>
      // 省略其它代码
     </p>
     <p>
      }
     </p>
     <p>
      在 java.time.LocalDateTime 类中声明了两个实例字段用来存储 日期 和 时间 :
     </p>
     <p>
      private final LocalDate date ;
     </p>
     <p>
      private final LocalTime time ;
     </p>
     <p>
      这里需要注意，不仅仅 date 和 time 字段是 final 修饰的，LocalDate 、LocalTime 类中的实例字段也是 final 修饰的，因此 LocalDateTime 的实例一经创建，其内部的各项取值都是不可更改的。
     </p>
     <p>
      15.7.2、获取 LocalDateTime 实例
     </p>
     <p>
      举例:
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      import java.time.LocalDateTime;
     </p>
     <p>
      import java.time.LocalTime;
     </p>
     <p>
      public class LocalDateTimeTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDateTime datetime = LocalDateTime.now();
     </p>
     <p>
      System.out.println( datetime );
     </p>
     <p>
      LocalDateTime first = LocalDateTime.of( 1996 , 7 , 4 , 7 , 30 ) ;
     </p>
     <p>
      System.out.println( first );
     </p>
     <p>
      LocalDateTime second = LocalDateTime.of( 1999 , 11 , 20, 6 , 30 , 7 ) ;
     </p>
     <p>
      System.out.println( second );
     </p>
     <p>
      LocalDateTime third = LocalDateTime.of( 1999 , 11 , 20, 6 , 30 , 7 , 0 ) ;
     </p>
     <p>
      System.out.println( third );
     </p>
     <p>
      LocalDate date = LocalDate.of( 1997 , 7 , 1 );
     </p>
     <p>
      LocalTime time = LocalTime.of( 10 , 20 );
     </p>
     <p>
      LocalDateTime fourth = LocalDateTime.of( date , time );
     </p>
     <p>
      System.out.println( fourth );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.7.3、获取日期时间值
     </p>
     <p>
      从 LocalDateTime 实例中获取 年份、月份、日期 、星期 、小时、分钟、秒、纳秒举例:
     </p>
     <p>
      import java.time.LocalDateTime;
     </p>
     <p>
      public class LocalDateTimeTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDateTime n = LocalDateTime.now();
     </p>
     <p>
      System.out.println( n.getYear() + "年" );
     </p>
     <p>
      System.out.println( n.getMonthValue() + "月" );
     </p>
     <p>
      System.out.println( n.getDayOfMonth() + "日" );
     </p>
     <p>
      System.out.println( n.getDayOfWeek() );
     </p>
     <p>
      int hour = n.getHour() ;
     </p>
     <p>
      int minute = n.getMinute() ;
     </p>
     <p>
      int second = n.getSecond() ;
     </p>
     <p>
      int nanos = n.getNano() ;
     </p>
     <p>
      System.out.println( hour + ":" + minute + ":" + second + "." + nanos );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.7.4、增加或减少指定时间
     </p>
     <p>
      在指定的时间基础之上增加或减少时间 ( 年、月、周、天、时、分、秒、纳秒 )举例:
     </p>
     <p>
      import java.time.LocalDateTime;
     </p>
     <p>
      public class LocalDateTimeTest3 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDateTime dt = LocalDateTime.now();
     </p>
     <p>
      System.out.println( dt );
     </p>
     <p>
      LocalDateTime dt1 = dt.plusYears( -3 ); // 减少 3 年
     </p>
     <p>
      System.out.println( dt1 );
     </p>
     <p>
      LocalDateTime dt2 = dt.plusMonths( 5 ); // 增加 5 个月
     </p>
     <p>
      System.out.println( dt2 );
     </p>
     <p>
      LocalDateTime dt3 = dt.plusWeeks( 10 ); // 增加 10 周
     </p>
     <p>
      System.out.println( dt3 );
     </p>
     <p>
      LocalDateTime dt4 = dt.plusDays( 15 ); // 增加 15 天
     </p>
     <p>
      System.out.println( dt4 );
     </p>
     <p>
      LocalDateTime dt5 = dt.plusHours( 8 ); // 增加 8 小时
     </p>
     <p>
      System.out.println( dt5 );
     </p>
     <p>
      LocalDateTime dt6 = dt.plusMinutes( 30 ); // 增加 30 分钟
     </p>
     <p>
      System.out.println( dt6 );
     </p>
     <p>
      LocalDateTime dt7 = dt.plusSeconds( 50 ); // 增加 50 秒
     </p>
     <p>
      System.out.println( dt7 );
     </p>
     <p>
      LocalDateTime dt8 = dt.plusNanos( 100300500L ); // 增加 100300500L 纳秒
     </p>
     <p>
      System.out.println( dt8 );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.8、转换
     </p>
     <p>
      在 Java 8 提供了新的日期时间API后，我们需要在新旧两套日期时间API之间完成转换。
     </p>
     <p>
      这里仅列举几个常见的类型之间的转换方法。
     </p>
     <p>
      15.8.1、LocalDate 转 LocalDateTime
     </p>
     <p>
      在 LocalDate 实例中已经存在年、月、日的数值，因此将 LocalDate 转换到 LocalDateTime 时需要指定相应的时、分、秒、纳秒等数值，借助于 LocalDate 类中提供的 atStartOfDay 、atTime 等方法可以完成该操作。
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      import java.time.LocalDateTime;
     </p>
     <p>
      public class LocalDateTest4 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDate n = LocalDate.now();
     </p>
     <p>
      System.out.println( n );
     </p>
     <p>
      LocalDateTime datetime = n.atStartOfDay();
     </p>
     <p>
      System.out.println( datetime );
     </p>
     <p>
      LocalDateTime first = n.atTime( 10 , 20 );
     </p>
     <p>
      System.out.println( first );
     </p>
     <p>
      LocalDateTime second = n.atTime( 10 , 20 , 30 );
     </p>
     <p>
      System.out.println( second );
     </p>
     <p>
      LocalDateTime third = n.atTime( 10 , 20 , 30 , 100200300 );
     </p>
     <p>
      System.out.println( third );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.8.2、LocalTime 转 LocalDateTime
     </p>
     <p>
      在 LocalTime 实例中已经存在时、分、秒、纳秒等数值，因此将 LocalTime 转换到 LocalDateTime 时需要指定相应的年、月、日等数值，借助于 LocalTime 类中提供的 atDate 方法可以完成该操作。
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      import java.time.LocalDateTime;
     </p>
     <p>
      import java.time.LocalTime;
     </p>
     <p>
      public class LocalTimeTest4 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalTime time = LocalTime.now() ;
     </p>
     <p>
      System.out.println( time );
     </p>
     <p>
      LocalDate date = LocalDate.of( 2019 , 10 , 10 );
     </p>
     <p>
      LocalDateTime dateTime = time.atDate( date );
     </p>
     <p>
      System.out.println( dateTime );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.8.3、LocalDateTime 转 LocalDate 或 LocalTime
     </p>
     <p>
      我们已经知道在 LocalDateTime 实例中封装了一个 LocalDate 实例和一个 LocalTime 实例，因此可以通过 LocalDateTime 提供的方法直接获取相应的 LocalDate 实例和 LocalTime 实例。
     </p>
     <p>
      import java.time.LocalDate;
     </p>
     <p>
      import java.time.LocalDateTime;
     </p>
     <p>
      import java.time.LocalTime;
     </p>
     <p>
      public class LocalDateTimeTest4 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDateTime datetime = LocalDateTime.now();
     </p>
     <p>
      System.out.println( datetime );
     </p>
     <p>
      LocalDate date = datetime.toLocalDate();
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      LocalTime time = datetime.toLocalTime();
     </p>
     <p>
      System.out.println( time );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      15.8.4、Date 转 LocalDateTime
     </p>
     <p>
      将 java.util.Date 类型的实例转换成 LocalDateTime 类型实例的方法不止一种，这里介绍其中一种实现方法，并通过举例，简单了解一下 Instant 、 ZoneId 、ZonedDateTime 三个类的作用。
     </p>
     <p>
      以下举例说明将 java.util.Date 类型的实例转换为 java.time.LocalDate 类型的实例:
     </p>
     <p>
      import java.time.*;
     </p>
     <p>
      public class TransformTest1 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      final long ms = 1000L * 60 * 60 * 24 * 365 * 30 ;
     </p>
     <p>
      java.util.Date date = new java.util.Date( ms );
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      System.out.println( "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~" );
     </p>
     <p>
      // 根据指定的 java.util.Date 实例获取与之对应的 java.time.Instant 实例
     </p>
     <p>
      Instant instant = date.toInstant();
     </p>
     <p>
      // 根据时区编号(ID)获取相应的 java.time.ZoneId 实例
     </p>
     <p>
      ZoneId zone = ZoneId.of( "Asia/Shanghai" ) ;
     </p>
     <p>
      // 根据 Instant 实例获取带有时区的日期时间对象( ZonedDateTime 实例 )
     </p>
     <p>
      ZonedDateTime zonedDateTime = instant.atZone( zone );
     </p>
     <p>
      // 根据 带有时区的日期时间对象 ( ZonedDateTime 实例 ) 获取 LocalDateTime 实例
     </p>
     <p>
      LocalDateTime datetime = zonedDateTime.toLocalDateTime() ;
     </p>
     <p>
      System.out.println( datetime );
     </p>
     <p>
      // 根据 带有时区的日期时间对象 ( ZonedDateTime 实例 ) 获取 LocalDate 实例
     </p>
     <p>
      LocalDate d = zonedDateTime.toLocalDate();
     </p>
     <p>
      System.out.println( d );
     </p>
     <p>
      // 根据 带有时区的日期时间对象 ( ZonedDateTime 实例 ) 获取 LocalTime 实例
     </p>
     <p>
      LocalTime t = zonedDateTime.toLocalTime();
     </p>
     <p>
      System.out.println( t );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      以上举例，实际上完成了以下几种转换:
     </p>
     <p>
      将 java.util.Date 实例 转换为 java.time.LocalDateTime 实例
     </p>
     <p>
      将 java.util.Date 实例 转换为 java.time.LocalDate 实例
     </p>
     <p>
      将 java.util.Date 实例 转换为 java.time.LocalTime 实例
     </p>
     <p>
      15.8.5、LocalDateTime转 Date
     </p>
     <p>
      在了解将 java.util.Date 实例转换为 java.time.LocalDateTime 实例的基础上，我们可以实现将 java.time.LocalDateTime 实例转换为 java.util.Date 实例 ( 仅列举一种方法 )。
     </p>
     <p>
      import java.time.*;
     </p>
     <p>
      import java.util.Date;
     </p>
     <p>
      public class TransformTest2 {
      <!-- -->
     </p>
     <p>
      public static void main(String[] args) {
      <!-- -->
     </p>
     <p>
      LocalDateTime datetime = LocalDateTime.of( 1999 , 11 , 22 , 6 , 30 , 7 );
     </p>
     <p>
      // 获取系统平台默认的时区编号对应的 java.time.ZoneId 实例
     </p>
     <p>
      ZoneId zone = ZoneId.systemDefault() ;
     </p>
     <p>
      // 根据 LocalDateTime 实例获取带有时区的日期时间对象 ( ZonedDateTime 实例 )
     </p>
     <p>
      ZonedDateTime zonedDateTime = ZonedDateTime.of( datetime , zone ) ;
     </p>
     <p>
      // 根据 带有时区的日期时间对象 ( ZonedDateTime 实例 ) 获取与其相应的 Instant 实例
     </p>
     <p>
      Instant instant = Instant.from( zonedDateTime );
     </p>
     <p>
      // 使用 java.util.Date 类提供的 from 方法获取与指定 Instant 实例对应的 Date 实例
     </p>
     <p>
      java.util.Date date = Date.from( instant );
     </p>
     <p>
      System.out.println( date );
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
    </div>
   </div>
  </div>
  <div id="recommendDown">
  </div>
 </article>
</div>


