---
arturl_encode: "68747470:733a2f2f626c6f672e6373646e2e6e65742f485558494e592f:61727469636c652f64657461696c732f313236393636373236"
layout: post
title: æ¯•ä¸šè®¾è®¡-pythonå°æ¸¸æˆè®¾è®¡-èµ°è¿·å®«æ¸¸æˆè®¾è®¡ä¸å®ç°
date: 2022-09-21 09:56:53 +08:00
description: "ğŸ”¥ è¿™ä¸¤å¹´å¼€å§‹æ¯•ä¸šè®¾è®¡å’Œæ¯•ä¸šç­”è¾©çš„è¦æ±‚å’Œéš¾åº¦ä¸æ–­æå‡"
keywords: æ¯•ä¸šè®¾è®¡æ¸¸æˆè®¾è®¡é¢˜ç›®
categories: ['è®¡ç®—æœºä¸“ä¸š', 'æ¯•è®¾é€‰é¢˜', 'æ¯•ä¸šè®¾è®¡ç³»åˆ—']
tags: ['èµ°è¿·å®«æ¸¸æˆè®¾è®¡', 'æ¸¸æˆ', 'æ¯•ä¸šè®¾è®¡', 'Python', 'Pygame']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=126966726
    alt: æ¯•ä¸šè®¾è®¡-pythonå°æ¸¸æˆè®¾è®¡-èµ°è¿·å®«æ¸¸æˆè®¾è®¡ä¸å®ç°
artid: 126966726
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=126966726
featuredImagePreview: https://bing.ee123.net/img/rand?artid=126966726
---

# ã€æ¯•ä¸šè®¾è®¡ã€‘ pythonå°æ¸¸æˆè®¾è®¡ - èµ°è¿·å®«æ¸¸æˆè®¾è®¡ä¸å®ç°

#### æ–‡ç« ç›®å½•

* [0 å‰è¨€](#0__3)
* [1 è¯¾é¢˜èƒŒæ™¯](#1__23)
* [2 å®ç°æ•ˆæœ](#2__31)
* [3 Pygameä»‹ç»](#3_Pygame_42)
* [4 å…·ä½“å®ç°](#4__101)
* + [4.1 åˆ›å»ºè¿·å®«](#41__103)
  + [4.2 å®šä¹‰è§’è‰²ç±»](#42__196)
  + [4.3 ç•Œé¢åˆ‡æ¢](#43__266)
* [5 æœ€å](#5__345)

---

## 0 å‰è¨€

ğŸ”¥ è¿™ä¸¤å¹´å¼€å§‹æ¯•ä¸šè®¾è®¡å’Œæ¯•ä¸šç­”è¾©çš„è¦æ±‚å’Œéš¾åº¦ä¸æ–­æå‡ï¼Œä¼ ç»Ÿçš„æ¯•è®¾é¢˜ç›®ç¼ºå°‘åˆ›æ–°å’Œäº®ç‚¹ï¼Œå¾€å¾€è¾¾ä¸åˆ°æ¯•ä¸šç­”è¾©çš„è¦æ±‚ï¼Œè¿™ä¸¤å¹´ä¸æ–­æœ‰å­¦å¼Ÿå­¦å¦¹å‘Šè¯‰å­¦é•¿è‡ªå·±åšçš„é¡¹ç›®ç³»ç»Ÿè¾¾ä¸åˆ°è€å¸ˆçš„è¦æ±‚ã€‚

ä¸ºäº†å¤§å®¶èƒ½å¤Ÿé¡ºåˆ©ä»¥åŠæœ€å°‘çš„ç²¾åŠ›é€šè¿‡æ¯•è®¾ï¼Œå­¦é•¿åˆ†äº«ä¼˜è´¨æ¯•ä¸šè®¾è®¡é¡¹ç›®ï¼Œä»Šå¤©è¦åˆ†äº«çš„æ˜¯

ğŸš©
**åŸºäºpythonçš„èµ°è¿·å®«æ¸¸æˆè®¾è®¡ä¸å®ç°**

ğŸ¥‡å­¦é•¿è¿™é‡Œç»™ä¸€ä¸ªé¢˜ç›®ç»¼åˆè¯„åˆ†(æ¯é¡¹æ»¡åˆ†5åˆ†)

* éš¾åº¦ç³»æ•°ï¼š3åˆ†
* å·¥ä½œé‡ï¼š3åˆ†
* åˆ›æ–°ç‚¹ï¼š3åˆ†

ğŸ§¿
**é€‰é¢˜æŒ‡å¯¼, é¡¹ç›®åˆ†äº«ï¼š**

<https://gitee.com/dancheng-senior/project-sharing-1/blob/master/%E6%AF%95%E8%AE%BE%E6%8C%87%E5%AF%BC/README.md>

## 1 è¯¾é¢˜èƒŒæ™¯

äººç±»å»ºé€ è¿·å®«å·²æœ‰5000å¹´çš„å†å²ã€‚åœ¨ä¸–ç•Œçš„ä¸åŒæ–‡åŒ–å‘å±•æ—¶æœŸï¼Œè¿™äº›å¥‡ç‰¹çš„å»ºç­‘ç‰©å§‹ç»ˆå¸å¼•äººä»¬æ²¿ç€å¼¯å¼¯æ›²æ›²ã€å›°éš¾é‡é‡çš„å°è·¯åƒåŠ›åœ°è¡Œèµ°ï¼Œå¯»æ‰¾çœŸç›¸ã€‚è¿·å®«ç±»å°æ¸¸æˆåº”è¿è€Œç”Ÿã€‚

ä»Šå¤©æˆ‘ä»¬ç”¨pygameåšä¸€ä¸ªèµ°è¿·å®«å°æ¸¸æˆï¼Œæ¸¸æˆè§„åˆ™å¦‚ä¸‹ï¼š

ç©å®¶é€šè¿‡â†‘â†“â†â†’é”®æ§åˆ¶ä¸»è§’è¡ŒåŠ¨ï¼Œä½¿ä¸»è§’ä»å‡ºå‘ç‚¹(å·¦ä¸Šè§’)ç»•å‡ºè¿·å®«ï¼Œåˆ°è¾¾ç»ˆç‚¹(å³ä¸‹è§’)å³ä¸ºæ¸¸æˆèƒœåˆ©ã€‚

## 2 å®ç°æ•ˆæœ

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/2766045271564c94a905c9ca3762b381.png#pic_center)

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/83002fc19f354179720559c0c1e798fc.png#pic_center)

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/05820d794c2f528115a8a97eec441a47.png#pic_center)

## 3 Pygameä»‹ç»

**ç®€ä»‹**

Pygameæ˜¯ä¸€ç³»åˆ—ä¸“é—¨ä¸ºç¼–å†™ç”µå­æ¸¸æˆè€Œè®¾è®¡çš„Pythonæ¨¡å—(modules)ã€‚Pygameåœ¨å·²ç»éå¸¸ä¼˜ç§€çš„SDLåº“çš„åŸºç¡€ä¸Šå¢åŠ äº†è®¸å¤šåŠŸèƒ½ã€‚è¿™è®©ä½ èƒ½å¤Ÿç”¨Pythonè¯­è¨€ç¼–å†™å‡ºä¸°å¯Œå¤šå½©çš„æ¸¸æˆç¨‹åºã€‚

Pygameå¯ç§»æ¤æ€§é«˜ï¼Œå‡ ä¹èƒ½åœ¨ä»»ä½•å¹³å°å’Œæ“ä½œç³»ç»Ÿä¸Šè¿è¡Œã€‚

Pygameå·²ç»è¢«ä¸‹è½½è¿‡æ•°ç™¾ä¸‡æ¬¡ã€‚

Pygameå…è´¹å¼€æºã€‚å®ƒåœ¨LGPLè®¸å¯è¯(Lesser General Public Licenseï¼ŒGNUå®½é€šç”¨å…¬å…±è®¸å¯è¯)ä¸‹å‘è¡Œã€‚ä½¿ç”¨Pygameï¼Œä½ å¯ä»¥åˆ›é€ å‡ºå…è´¹å¼€æºï¼Œå¯å…±äº«ï¼Œæˆ–è€…å•†ä¸šåŒ–çš„æ¸¸æˆã€‚è¯¦æƒ…è¯·è§LGPLè®¸å¯è¯ã€‚

**ä¼˜ç‚¹**

* èƒ½å¤Ÿè½»æ¾ä½¿ç”¨å¤šæ ¸CPU(multi core CPUs) :å¦‚ä»ŠåŒæ ¸CPUå¾ˆå¸¸ç”¨ï¼Œ8æ ¸CPUåœ¨æ¡Œé¢ç³»ç»Ÿä¸­ä¹Ÿå¾ˆä¾¿å®œï¼Œè€Œåˆ©ç”¨å¥½å¤šæ ¸ç³»ç»Ÿï¼Œèƒ½è®©ä½ åœ¨ä½ çš„æ¸¸æˆä¸­å®ç°æ›´å¤šä¸œè¥¿ã€‚ç‰¹å®šçš„pygameå‡½æ•°èƒ½å¤Ÿé‡Šæ”¾ä»¤äººç”Ÿç•çš„python GIL(å…¨å±€è§£é‡Šå™¨é”),è¿™å‡ ä¹æ˜¯ä½ ç”¨Cè¯­è¨€æ‰èƒ½åšçš„äº‹ã€‚
* æ ¸å¿ƒå‡½æ•°ç”¨æœ€ä¼˜åŒ–çš„Cè¯­è¨€æˆ–æ±‡ç¼–è¯­è¨€ç¼–å†™:Cè¯­è¨€ä»£ç é€šå¸¸æ¯”Pythonä»£ç è¿è¡Œé€Ÿåº¦å¿«10-20å€ã€‚è€Œæ±‡ç¼–è¯­è¨€ç¼–å†™çš„ä»£ç (assembly code)æ¯”Pythonç”šè‡³å¿«åˆ°100å¤šå€ã€‚
* å®‰è£…ä¾¿æ·:ä¸€èˆ¬ä»…éœ€åŒ…ç®¡ç†ç¨‹åºæˆ–äºŒè¿›åˆ¶ç³»ç»Ÿç¨‹åºä¾¿èƒ½å®‰è£…ã€‚
* çœŸæ­£åœ°å¯ç§»æ¤:æ”¯æŒLinux (ä¸»è¦å‘è¡Œç‰ˆ), Windows (95, 98, ME, 2000, XP, Vista, 64-bit Windows,), Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNXç­‰æ“ä½œç³»ç»Ÿ.ä¹Ÿèƒ½æ”¯æŒAmigaOS, Dreamcast, Atari, AIX, OSF/Tru64, RISC OS, SymbianOS and OS/2ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å—åˆ°å®˜æ–¹è®¤å¯ã€‚ä½ ä¹Ÿå¯ä»¥åœ¨æ‰‹æŒè®¾å¤‡,æ¸¸æˆæ§åˆ¶å°ï¼Œ One Laptop Per Child (OLPC) computeré¡¹ç›®çš„ç”µè„‘ç­‰è®¾å¤‡ä¸­ä½¿ç”¨pygame.
* ç”¨æ³•ç®€å•:æ— è®ºæ˜¯å°å­©å­è¿˜æ˜¯å¤§äººéƒ½èƒ½å­¦ä¼šç”¨pygameæ¥åˆ¶ä½œå°„å‡»ç±»æ¸¸æˆã€‚
* å¾ˆå¤šPygameæ¸¸æˆå·²å‘è¡Œ:å…¶ä¸­åŒ…æ‹¬å¾ˆå¤šæ¸¸æˆå¤§èµ›å…¥å›´ä½œå“ã€éå¸¸å—æ¬¢è¿çš„å¼€æºå¯åˆ†äº«çš„æ¸¸æˆã€‚
* ç”±ä½ æ¥æ§åˆ¶ä¸»å¾ªç¯:ç”±ä½ æ¥è°ƒç”¨pygameçš„å‡½æ•°ï¼Œpygameçš„å‡½æ•°å¹¶ä¸éœ€è¦è°ƒç”¨ä½ çš„å‡½æ•°ã€‚å½“ä½ åŒæ—¶è¿˜åœ¨ä½¿ç”¨å…¶ä»–åº“æ¥ç¼–å†™å„ç§å„ç§çš„ç¨‹åºæ—¶ï¼Œè¿™èƒ½å¤Ÿä¸ºä½ æä¾›æå¤§çš„æŒæ§æƒã€‚
* ä¸éœ€è¦GUIå°±èƒ½ä½¿ç”¨æ‰€æœ‰å‡½æ•°:ä»…åœ¨å‘½ä»¤è¡Œä¸­ï¼Œä½ å°±å¯ä»¥ä½¿ç”¨pygameçš„æŸäº›å‡½æ•°æ¥å¤„ç†å›¾ç‰‡ï¼Œè·å–æ¸¸æˆæ†è¾“å…¥ï¼Œæ’­æ”¾éŸ³ä¹â€¦â€¦
* å¯¹bugååº”è¿…é€Ÿ:å¾ˆå¤šbugåœ¨è¢«ä¸ŠæŠ¥çš„1å°æ—¶å†…å°±èƒ½è¢«æˆ‘ä»¬ä¿®å¤ã€‚è™½ç„¶æœ‰æ—¶å€™æˆ‘ä»¬ç¡®å®ä¼šå¡åœ¨æŸä¸€ä¸ªbugä¸Šå¾ˆä¹…ï¼Œä½†å¤§å¤šæ•°æ—¶å€™æˆ‘ä»¬éƒ½æ˜¯å¾ˆä¸é”™çš„bugä¿®å¤è€…ã€‚å¦‚ä»Šbugçš„ä¸ŠæŠ¥å·²ç»å¾ˆå°‘äº†ï¼Œå› ä¸ºè®¸å¤šbugæ—©å·²è¢«æˆ‘ä»¬ä¿®å¤ã€‚
* ä»£ç é‡å°‘:pygameå¹¶æ²¡æœ‰æ•°ä»¥ä¸‡è®¡çš„ä¹Ÿè®¸ä½ æ°¸è¿œç”¨ä¸åˆ°çš„å†—æ‚ä»£ç ã€‚pygameçš„æ ¸å¿ƒä»£ç ä¸€ç›´ä¿æŒç€ç®€æ´ç‰¹ç‚¹ï¼Œå…¶ä»–é™„åŠ ç‰©è¯¸å¦‚GUIåº“ç­‰ï¼Œéƒ½æ˜¯åœ¨æ ¸å¿ƒä»£ç ä¹‹å¤–å•ç‹¬è®¾è®¡ç ”å‘çš„ã€‚
* æ¨¡å—åŒ–:ä½ å¯ä»¥å•ç‹¬ä½¿ç”¨pygameçš„æŸä¸ªæ¨¡å—ã€‚æƒ³è¦æ¢ç€ä½¿ç”¨ä¸€ä¸ªåˆ«çš„å£°éŸ³å¤„ç†åº“ï¼Ÿæ²¡é—®é¢˜ã€‚pygameçš„å¾ˆå¤šæ ¸å¿ƒæ¨¡å—æ”¯æŒç‹¬ç«‹åˆå§‹åŒ–ä¸ä½¿ç”¨ã€‚

**æœ€å°å¼€å‘æ¡†æ¶**

```python
import pygame,sys #sysæ˜¯pythonçš„æ ‡å‡†åº“ï¼Œæä¾›Pythonè¿è¡Œæ—¶ç¯å¢ƒå˜é‡çš„æ“æ§

pygame.init()  #å†…éƒ¨å„åŠŸèƒ½æ¨¡å—è¿›è¡Œåˆå§‹åŒ–åˆ›å»ºåŠå˜é‡è®¾ç½®ï¼Œé»˜è®¤è°ƒç”¨
size = width,height = 800,600  #è®¾ç½®æ¸¸æˆçª—å£å¤§å°ï¼Œåˆ†åˆ«æ˜¯å®½åº¦å’Œé«˜åº¦
screen = pygame.display.set_mode(size)  #åˆå§‹åŒ–æ˜¾ç¤ºçª—å£
pygame.display.set_caption("å°æ¸¸æˆç¨‹åº")  #è®¾ç½®æ˜¾ç¤ºçª—å£çš„æ ‡é¢˜å†…å®¹ï¼Œæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹
while True:  #æ— é™å¾ªç¯ï¼Œç›´åˆ°Pythonè¿è¡Œæ—¶é€€å‡ºç»“æŸ
    for event in pygame.event.get():  #ä»Pygameçš„äº‹ä»¶é˜Ÿåˆ—ä¸­å–å‡ºäº‹ä»¶ï¼Œå¹¶ä»é˜Ÿåˆ—ä¸­åˆ é™¤è¯¥äº‹ä»¶
        if event.type == pygame.QUIT:  #è·å¾—äº‹ä»¶ç±»å‹ï¼Œå¹¶é€ç±»å“åº”
            sys.exit()   #ç”¨äºé€€å‡ºç»“æŸæ¸¸æˆå¹¶é€€å‡º          
    pygame.display.update()  #å¯¹æ˜¾ç¤ºçª—å£è¿›è¡Œæ›´æ–°ï¼Œé»˜è®¤çª—å£å…¨éƒ¨é‡ç»˜


```

**ä»£ç æ‰§è¡Œæµç¨‹**

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/36f02db4ff5ef470d20b6f8d270b7017.png)

## 4 å…·ä½“å®ç°

### 4.1 åˆ›å»ºè¿·å®«

é¦–å…ˆï¼Œå½“ç„¶æ˜¯åˆ›å»ºè¿·å®«å•¦ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œè¿™é‡Œé‡‡ç”¨éšæœºç”Ÿæˆè¿·å®«çš„æ–¹å¼(äººå·¥è®¾è®¡çœŸçš„è´¹çœ¼ç›ï¼Œå¼„åˆ°ä¸€åŠä¸æƒ³å¼„äº†ï¼Œæœ‰å…´è¶£çš„å¯ä»¥è‡ªè¡Œå°è¯•ã€‚)ã€‚æ€è·¯å…¶å®å¾ˆç®€å•ï¼Œå°±æ˜¯æŠŠæ¸¸æˆç•Œé¢åˆ’åˆ†æˆå¤šä¸ªcellï¼Œç±»ä¼¼è¿™æ ·å­ï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/8f43b1f77723737235d7c9c0a9ad54cf.png#pic_center)
  
ç„¶åè®¾è®¡ç®—æ³•éå†æ‰€æœ‰çš„cellï¼Œæ¯ä¸ªè¢«éå†åˆ°çš„cellåœ¨æŸå‡ ä¸ªéšæœºçš„æ–¹å‘ä¸Šæ‰“å¼€ä¸€å µå¢™(å°±æ˜¯å»æ‰åˆ†å‰²cellçš„çº¿æ¡)å°±okå•¦~

ç®—æ³•å¦‚ä¸‹ï¼š

```python
'''éšæœºç”Ÿæˆè¿·å®«ç±»'''
class RandomMaze():
  def __init__(self, maze_size, block_size, border_size, **kwargs):
    self.block_size = block_size
    self.border_size = border_size
    self.maze_size = maze_size
    self.blocks_list = RandomMaze.createMaze(maze_size, block_size, border_size)
    self.font = pygame.font.SysFont('Consolas', 15)
  '''ç”»åˆ°å±å¹•ä¸Š'''
  def draw(self, screen):
    for row in range(self.maze_size[0]):
      for col in range(self.maze_size[1]):
        self.blocks_list[row][col].draw(screen)
    # èµ·ç‚¹å’Œç»ˆç‚¹æ ‡å¿—
    showText(screen, self.font, 'S', (255, 0, 0), (self.border_size[0]-10, self.border_size[1]))
    showText(screen, self.font, 'D', (255, 0, 0), (self.border_size[0]+(self.maze_size[1]-1)*self.block_size, self.border_size[1]+self.maze_size[0]*self.block_size+5))
  '''åˆ›å»ºè¿·å®«'''
  @staticmethod
  def createMaze(maze_size, block_size, border_size):
    def nextBlock(block_now, blocks_list):
      directions = ['top', 'bottom', 'left', 'right']
      blocks_around = dict(zip(directions, [None]*4))
      block_next = None
      count = 0
      # æŸ¥çœ‹ä¸Šè¾¹block
      if block_now.coordinate[1]-1 >= 0:
        block_now_top = blocks_list[block_now.coordinate[1]-1][block_now.coordinate[0]]
        if not block_now_top.is_visited:
          blocks_around['top'] = block_now_top
          count += 1
      # æŸ¥çœ‹ä¸‹è¾¹block
      if block_now.coordinate[1]+1 < maze_size[0]:
        block_now_bottom = blocks_list[block_now.coordinate[1]+1][block_now.coordinate[0]]
        if not block_now_bottom.is_visited:
          blocks_around['bottom'] = block_now_bottom
          count += 1
      # æŸ¥çœ‹å·¦è¾¹block
      if block_now.coordinate[0]-1 >= 0:
        block_now_left = blocks_list[block_now.coordinate[1]][block_now.coordinate[0]-1]
        if not block_now_left.is_visited:
          blocks_around['left'] = block_now_left
          count += 1
      # æŸ¥çœ‹å³è¾¹block
      if block_now.coordinate[0]+1 < maze_size[1]:
        block_now_right = blocks_list[block_now.coordinate[1]][block_now.coordinate[0]+1]
        if not block_now_right.is_visited:
          blocks_around['right'] = block_now_right
          count += 1
      if count > 0:
        while True:
          direction = random.choice(directions)
          if blocks_around.get(direction):
            block_next = blocks_around.get(direction)
            if direction == 'top':
              block_next.has_walls[1] = False
              block_now.has_walls[0] = False
            elif direction == 'bottom':
              block_next.has_walls[0] = False
              block_now.has_walls[1] = False
            elif direction == 'left':
              block_next.has_walls[3] = False
              block_now.has_walls[2] = False
            elif direction == 'right':
              block_next.has_walls[2] = False
              block_now.has_walls[3] = False
            break
      return block_next
    blocks_list = [[Block([col, row], block_size, border_size) for col in range(maze_size[1])] for row in range(maze_size[0])]
    block_now = blocks_list[0][0]
    records = []
    while True:
      if block_now:
        if not block_now.is_visited:
          block_now.is_visited = True
          records.append(block_now)
        block_now = nextBlock(block_now, blocks_list)
      else:
        block_now = records.pop()
        if len(records) == 0:
          break
    return blocks_list

```

### 4.2 å®šä¹‰è§’è‰²ç±»

è§’è‰²ç±»éœ€è¦æ ¹æ®ç”¨æˆ·çš„æ“ä½œè¿›è¡Œä¸Šä¸‹å·¦å³çš„ç§»åŠ¨ï¼ŒåŒæ—¶ï¼Œä¿è¯ç§»åŠ¨æ˜¯ä¸èƒ½è·¨è¶Šå¢™çš„å°±OKäº†~å…·ä½“è€Œè¨€ï¼Œä»¥ä¸‹ä¸¤ç‚¹ï¼š

**å®šä¹‰è§’è‰²**

```python
'''å®šä¹‰hero'''
class Hero(pygame.sprite.Sprite):
  def __init__(self, imagepath, coordinate, block_size, border_size, **kwargs):
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.image.load(imagepath)
    self.image = pygame.transform.scale(self.image, (block_size, block_size))
    self.rect = self.image.get_rect()
    self.rect.left, self.rect.top = coordinate[0] * block_size + border_size[0], coordinate[1] * block_size + border_size[1]
    self.coordinate = coordinate
    self.block_size = block_size
    self.border_size = border_size

```

**ç§»åŠ¨è®¾ç½®**

```python
'''ç§»åŠ¨'''
  def move(self, direction, maze):
    blocks_list = maze.blocks_list
    if direction == 'up':
      if blocks_list[self.coordinate[1]][self.coordinate[0]].has_walls[0]:
        return False
      else:
        self.coordinate[1] = self.coordinate[1] - 1
        return True
    elif direction == 'down':
      if blocks_list[self.coordinate[1]][self.coordinate[0]].has_walls[1]:
        return False
      else:
        self.coordinate[1] = self.coordinate[1] + 1
        return True
    elif direction == 'left':
      if blocks_list[self.coordinate[1]][self.coordinate[0]].has_walls[2]:
        return False
      else:
        self.coordinate[0] = self.coordinate[0] - 1
        return True
    elif direction == 'right':
      if blocks_list[self.coordinate[1]][self.coordinate[0]].has_walls[3]:
        return False
      else:
        self.coordinate[0] = self.coordinate[0] + 1
        return True
    else:
      raise ValueError('Unsupport direction <%s> in Hero.move...' % direction)
  '''ç»‘å®šåˆ°å±å¹•'''
  def draw(self, screen):
    self.rect.left, self.rect.top = self.coordinate[0] * self.block_size + self.border_size[0], self.coordinate[1] * self.block_size + self.border_size[1]
    screen.blit(self.image, self.rect)

```

**ç»‘å®šåˆ°å±å¹•**

```python
 '''ç»‘å®šåˆ°å±å¹•'''
  def draw(self, screen):
    self.rect.left, self.rect.top = self.coordinate[0] * self.block_size + self.border_size[0], self.coordinate[1] * self.block_size + self.border_size[1]
    screen.blit(self.image, self.rect)

```

### 4.3 ç•Œé¢åˆ‡æ¢

æœ€åè¦å®Œæˆæ¸¸æˆä¸»å¾ªç¯ï¼Œåªè¦æ¯æ¬¡è½½å…¥ä¸€ä¸ªéšæœºç”Ÿæˆçš„è¿·å®«åœ°å›¾å’Œå®ä¾‹åŒ–ä¸€ä¸ªä¸»è§’ï¼Œä¸æ–­è¿›è¡ŒæŒ‰é”®æ£€æµ‹ï¼Œå¹¶æ ¹æ®æŒ‰é”®æ£€æµ‹çš„ç»“æœç§»åŠ¨ä¸»è§’ï¼Œæœ€åæ ¹æ®è¡ŒåŠ¨ç»“æœæ›´æ–°ç•Œé¢æ•°æ®å°±å¯ä»¥äº†

è‹¥ä¸»è§’åˆ°è¾¾äº†ç»ˆç‚¹ï¼Œåˆ™è¿›å…¥å…³å¡åˆ‡æ¢ç•Œé¢ã€‚

å…·ä½“è€Œè¨€ï¼Œä»£ç å®ç°å¦‚ä¸‹ï¼š

```python
'''ä¸»å‡½æ•°'''
def main(cfg):
  # åˆå§‹åŒ–
  pygame.init()
  pygame.mixer.init()
  pygame.font.init()
  pygame.mixer.music.load(cfg.BGMPATH)
  pygame.mixer.music.play(-1, 0.0)
  screen = pygame.display.set_mode(cfg.SCREENSIZE)
  pygame.display.set_caption('Maze - å¾®ä¿¡å…¬ä¼—å·: Charlesçš„çš®å¡ä¸˜')
  font = pygame.font.SysFont('Consolas', 15)
  # å¼€å§‹ç•Œé¢
  Interface(screen, cfg, 'game_start')
  # è®°å½•å…³å¡æ•°
  num_levels = 0
  # è®°å½•æœ€å°‘ç”¨äº†å¤šå°‘æ­¥é€šå…³
  best_scores = 'None'
  # å…³å¡å¾ªç¯åˆ‡æ¢
  while True:
    num_levels += 1
    clock = pygame.time.Clock()
    screen = pygame.display.set_mode(cfg.SCREENSIZE)
    # --éšæœºç”Ÿæˆå…³å¡åœ°å›¾
    maze_now = RandomMaze(cfg.MAZESIZE, cfg.BLOCKSIZE, cfg.BORDERSIZE)
    # --ç”Ÿæˆhero
    hero_now = Hero(cfg.HEROPICPATH, [0, 0], cfg.BLOCKSIZE, cfg.BORDERSIZE)
    # --ç»Ÿè®¡æ­¥æ•°
    num_steps = 0
    # --å…³å¡å†…ä¸»å¾ªç¯
    while True:
      dt = clock.tick(cfg.FPS)
      screen.fill((255, 255, 255))
      is_move = False
      # ----â†‘â†“â†â†’æ§åˆ¶hero
      for event in pygame.event.get():
        if event.type == pygame.QUIT:
          pygame.quit()
          sys.exit(-1)
        elif event.type == pygame.KEYDOWN:
          if event.key == pygame.K_UP:
            is_move = hero_now.move('up', maze_now)
          elif event.key == pygame.K_DOWN:
            is_move = hero_now.move('down', maze_now)
          elif event.key == pygame.K_LEFT:
            is_move = hero_now.move('left', maze_now)
          elif event.key == pygame.K_RIGHT:
            is_move = hero_now.move('right', maze_now)
      num_steps += int(is_move)
      hero_now.draw(screen)
      maze_now.draw(screen)
      # ----æ˜¾ç¤ºä¸€äº›ä¿¡æ¯
      showText(screen, font, 'LEVELDONE: %d' % num_levels, (255, 0, 0), (10, 10))
      showText(screen, font, 'BESTSCORE: %s' % best_scores, (255, 0, 0), (210, 10))
      showText(screen, font, 'USEDSTEPS: %s' % num_steps, (255, 0, 0), (410, 10))
      showText(screen, font, 'S: your starting point    D: your destination', (255, 0, 0), (10, 600))
      # ----åˆ¤æ–­æ¸¸æˆæ˜¯å¦èƒœåˆ©
      if (hero_now.coordinate[0] == cfg.MAZESIZE[1] - 1) and (hero_now.coordinate[1] == cfg.MAZESIZE[0] - 1):
        break
      pygame.display.update()
    # æ›´æ–°æœ€ä¼˜æˆç»©
    if best_scores == 'None':
      best_scores = num_steps
    else:
      if best_scores > num_steps:
        best_scores = num_steps
    # å…³å¡åˆ‡æ¢
    Interface(screen, cfg, mode='game_switch')

```

## 5 æœ€å