---
layout: post
title: "Java数据结构第二十一期解构排序算法的艺术与科学三"
date: 2025-03-09 20:58:13 +0800
description: "我们先定义三个指针，先让三个指针同时指向三个数组的第一个下标，比较nums[s1]与nums[s2]的值。我们对数组里的元素进行分组，每一个单独的元素都是有序的；由于合并需要3个参数，根据上一种做法的分析，left=i，mid=left+gap-1，right=mid+gap。类似于快速排序，利用数组下标的中间值mid进行分解，当left=right时，说明左树已经分解完毕，然后再去分解右树，然后再进行排序与合并。这样临时数组中储存的就是有序数据，但原数组还不是有序的，我们将临时数组拷贝到原始数组中。"
keywords: "Java数据结构第二十一期：解构排序算法的艺术与科学(三)"
categories: ['Java']
tags: ['算法', '数据结构', '排序算法']
artid: "146128364"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146128364
    alt: "Java数据结构第二十一期解构排序算法的艺术与科学三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146128364
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146128364
cover: https://bing.ee123.net/img/rand?artid=146128364
image: https://bing.ee123.net/img/rand?artid=146128364
img: https://bing.ee123.net/img/rand?artid=146128364
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java数据结构第二十一期：解构排序算法的艺术与科学(三)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9f5fb5a02acd465c8783b8cbffd58aad.gif"/>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/8919f012b5aa43e7a9b93432c084bc03.gif"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/919412da38a2444482e4c765a76b6f81.jpeg"/>
    </p>
    <blockquote>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        专栏：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927/category_12839364.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12839364&amp;sharerefer=PC&amp;sharesource=2401_85198927&amp;sharefrom=from_link" title=" Java数据结构秘籍">
         Java数据结构秘籍
        </a>
       </strong>
      </span>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        个人主页：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927?type=blog" title="手握风云">
         手握风云
        </a>
       </strong>
      </span>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0" name="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">
     一、常见排序算法的实现
    </h2>
    <h3 id="1.1.%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" name="1.1.%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">
     1.1. 归并排序
    </h3>
    <p>
     归并排序是建⽴在归并操作上的⼀种有效的排序算法,该算法是采⽤分治法的一个⾮常典型的应⽤。将已有序的⼦序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。如下图所示。
    </p>
    <p class="img-center">
     <img alt="" height="474" src="https://i-blog.csdnimg.cn/direct/a7443ccc12dd431bb5cb506c042fdf25.png" width="395"/>
    </p>
    <p>
     类似于快速排序，利用数组下标的中间值mid进行分解，当left=right时，说明左树已经分解完毕，然后再去分解右树，然后再进行排序与合并。
    </p>
    <p class="img-center">
     <img alt="" height="246" src="https://i-blog.csdnimg.cn/direct/c2486e80bdc94e689bc3f60ec4a608e4.png" width="314"/>
    </p>
    <pre><code class="language-java">    public void MergeSort(int[] array) {
        MergeSortChild(array, 0, array.length - 1);
    }

    private void MergeSortChild(int[] array, int left, int right) {
        if(left &gt;= right){
            return;
        }

        int mid =(left+right)/2;

        MergeSortChild(array,left,mid);//递归左树
        MergeSortChild(array,mid+1,right);//递归右树

        //开始合并
        Merge(array,left,mid,right);
    }</code></pre>
    <p>
     我们接下来说一下合并有序数组的思路。首先，我们需要额外定义一个临时数组用来储存合并后的数据。我们先定义三个指针，先让三个指针同时指向三个数组的第一个下标，比较nums[s1]与nums[s2]的值。如果nums[s1]&gt;nums[s2]，将nums[s1]放入nums里面，同时s1、s向右移动；如果nums[s1]&lt;nums[s2]，将nums[s2]放入nums里面，同时s2、s向右移动。在移动期间，要保证指针不会越界。
    </p>
    <p class="img-center">
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/3edd356cda8e4f34a3dc2b67943dbfa6.png" width="595"/>
    </p>
    <pre><code class="language-java">    private void Merge(int[] array, int left, int mid, int right) {
        int[] tmpArr = new int[right + left + 1];
        int k = 0;
        int s1 = left, e1 = mid, s2 = mid + 1, e2 = right;
        while (s1 &lt;= e1 &amp;&amp; s2 &lt;= e2) {
            if (array[s1] &lt;= array[s2]) {
                tmpArr[k++] = array[s1++];
            } else {
                tmpArr[k++] = array[s2++];
            }
        }
        while (s1 &lt;= e1) {
            tmpArr[k++] = array[s1++];
        }
        while (s2 &lt;= e2) {
            tmpArr[k++] = array[s2++];
        }
    }</code></pre>
    <p>
     这样临时数组中储存的就是有序数据，但原数组还不是有序的，我们将临时数组拷贝到原始数组中。
    </p>
    <pre><code class="language-java">        for (int i = 0; i &lt; k; i++) {
            array[i + left] = tmpArr[i];
        }</code></pre>
    <p>
     完整代码：
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void MergeSort(int[] array) {
        MergeSortChild(array, 0, array.length - 1);
    }

    private void MergeSortChild(int[] array, int left, int right) {
        if(left &gt;= right) {
            return;
        }

        int mid = (left + right) / 2;

        MergeSortChild(array,left,mid);

        MergeSortChild(array,mid+1,right);
        //开始合并
        Merge(array,left,mid,right);
    }

    private void Merge(int[] array, int left, int mid, int right) {
        int[] tmpArr = new int[right - left + 1];
        int k = 0;
        int s1 = left, e1 = mid, s2 = mid + 1, e2 = right;
        while (s1 &lt;= e1 &amp;&amp; s2 &lt;= e2) {
            if (array[s1] &lt;= array[s2]) {
                tmpArr[k++] = array[s1++];
            } else {
                tmpArr[k++] = array[s2++];
            }
        }
        while (s1 &lt;= e1) {
            tmpArr[k++] = array[s1++];
        }
        while (s2 &lt;= e2) {
            tmpArr[k++] = array[s2++];
        }
        //临时数组当中存储的是有序的数据 -&gt; 拷贝数据到原始数组当中
        for (int i = 0; i &lt; k; i++) {
            array[i+left] = tmpArr[i];
        }
    }
    public void DsiOrder(int[] array) {
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(1, 100);
        }
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[7];
        sort.DsiOrder(array);
        System.out.println("排序前："+ Arrays.toString(array));
        sort.MergeSort(array);
        System.out.println("排序后："+ Arrays.toString(array));
    }
}</code></pre>
    <p>
     归并排序还可以进行非递归实现。要想进行非递归的实现，就要模拟出递归的过程。上面采用了分解与合并的过程，非递归的方式我们就可以省去分解的过程。我们对数组里的元素进行分组，每一个单独的元素都是有序的；然后缩小分组，对两个元素进行排序，变成每两个元素有序……直到数组里的每个元素都有序，也就是gap大于数组长度时。由于合并需要3个参数，根据上一种做法的分析，left=i，mid=left+gap-1，right=mid+gap。
    </p>
    <p>
     <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/a49d6ff6157844d0afb534507cfa54d7.png" width="810"/>
    </p>
    <pre><code class="language-java">    public void MergeSort(int[] array){
        int gap=1;
        while(gap &lt; array.length){
            for (int i = 0; i &lt; array.length; i=i+2*gap) {
                int left = i;
                int mid = left+gap-1;
                int right = mid+gap;
                Merge(array,left,mid,right);
            }
            gap = 2*gap;
        }
    }</code></pre>
    <p>
     代码写到这里，我们需要考虑mid和right是否会越界的问题。
    </p>
    <p class="img-center">
     <img alt="" height="175" src="https://i-blog.csdnimg.cn/direct/fc717343e65a4499b782dbb1f143356a.png" width="461"/>
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void DisOrder(int[] array) {
        Random in = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = in.nextInt(1, 100);
        }
    }

    public void MergeSort(int[] array) {
        int gap = 1;
        while (gap &lt; array.length) {
            for (int i = 0; i &lt; array.length; i = i + 2 * gap) {
                int left = i;
                int mid = left + gap - 1;
                if (mid &gt;= array.length) {
                    mid = array.length - 1;
                }
                int right = mid + gap;
                if (right &gt;= array.length) {
                    right = array.length - 1;
                }
                Merge(array, left, mid, right);
            }
            gap = 2 * gap;
        }
    }

    private void Merge(int[] array, int left, int mid, int right) {
        int[] tmpArr = new int[right - left + 1];
        int k = 0;
        int s1 = left, e1 = mid, s2 = mid + 1, e2 = right;
        while (s1 &lt;= e1 &amp;&amp; s2 &lt;= e2) {
            if (array[s1] &lt;= array[s2]) {
                tmpArr[k++] = array[s1++];
            } else {
                tmpArr[k++] = array[s2++];
            }
        }
        while (s1 &lt;= e1) {
            tmpArr[k++] = array[s1++];
        }
        while (s2 &lt;= e2) {
            tmpArr[k++] = array[s2++];
        }
        //临时数组当中存储的是有序的数据 -&gt; 拷贝数据到原始数组当中
        for (int i = 0; i &lt; k; i++) {
            array[i + left] = tmpArr[i];
        }
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前："+ Arrays.toString(array));
        sort.MergeSort(array);
        System.out.println("排序后："+ Arrays.toString(array));
    }
}</code></pre>
    <p>
     归并排序是稳定的。时间复杂度，每次递归都需要合并，
     <img alt="O(n) = nlogn" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%20%3D%20nlogn"/>
     ；空间复杂度上，申请的临时数组与原数组长度一样，
     <img alt="O(n)=n" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3Dn"/>
     。
    </p>
    <p>
     归并排序而已用于海量数据的排序问题。比如在磁盘等外部存储进行的排序，内存只有1G，需要排序的数据有100G。我们把100G内存分成200份，每一份512M。每一个文件都经过内存的排序后，每个文件都单独有序了。进行2路归并，同时对 200 份有序⽂件做归并过程，最终结果就有序了。
    </p>
    <p class="img-center">
     <img alt="" height="275" src="https://i-blog.csdnimg.cn/direct/de28e4a8bc0546d6a561e7455ab989d9.png" width="610"/>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90" name="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90">
     二、排序算法复杂度及稳定性分析
    </h2>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td style="text-align:center; width:99px">
        排序方式
       </td>
       <td style="text-align:center; width:92px">
        最好情况
       </td>
       <td style="text-align:center; width:92px">
        最坏情况
       </td>
       <td style="text-align:center; width:107px">
        空间复杂度
       </td>
       <td style="text-align:center; width:108px">
        稳定性
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        冒泡排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:107px">
        1
       </td>
       <td style="text-align:center; width:108px">
        稳定
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        插入排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n" class="mathcode" src="https://latex.csdn.net/eq?n"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:107px">
        1
       </td>
       <td style="text-align:center; width:108px">
        稳定
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        选择排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:107px">
        1
       </td>
       <td style="text-align:center; width:108px">
        不稳定
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        希尔排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n" class="mathcode" src="https://latex.csdn.net/eq?n"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:107px">
        1
       </td>
       <td style="text-align:center; width:108px">
        不稳定
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        堆排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="nlogn" class="mathcode" src="https://latex.csdn.net/eq?nlogn"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="nlogn" class="mathcode" src="https://latex.csdn.net/eq?nlogn"/>
       </td>
       <td style="text-align:center; width:107px">
        1
       </td>
       <td style="text-align:center; width:108px">
        不稳定
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        快速排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="nlogn" class="mathcode" src="https://latex.csdn.net/eq?nlogn"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="n^{2}" class="mathcode" src="https://latex.csdn.net/eq?n%5E%7B2%7D"/>
       </td>
       <td style="text-align:center; width:107px">
        <img alt="logn\rightarrow n" class="mathcode" src="https://latex.csdn.net/eq?logn%5Crightarrow%20n"/>
       </td>
       <td style="text-align:center; width:108px">
        不稳定
       </td>
      </tr>
      <tr>
       <td style="text-align:center; width:99px">
        归并排序
       </td>
       <td style="text-align:center; width:92px">
        <img alt="nlogn" class="mathcode" src="https://latex.csdn.net/eq?nlogn"/>
       </td>
       <td style="text-align:center; width:92px">
        <img alt="nlogn" class="mathcode" src="https://latex.csdn.net/eq?nlogn"/>
       </td>
       <td style="text-align:center; width:107px">
        n
       </td>
       <td style="text-align:center; width:108px">
        稳定
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38353139383932372f:61727469636c652f64657461696c732f313436313238333634" class_="artid" style="display:none">
 </p>
</div>


