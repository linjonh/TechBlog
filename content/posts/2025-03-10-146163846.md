---
layout: post
title: "rust学习笔记13-18.-四数之和"
date: 2025-03-10 21:00:26 +0800
description: "两数之和与三数之和、四数之和解法不一样，主要是因为返回值，两数之和要返回下角标不能做排序，用hashmap合适，而三数之和、四数之和是要求返回结果集且不能重复，需要对数组进行排序，用双指针更适合。"
keywords: "rust学习笔记13-18. 四数之和"
categories: ['未分类']
tags: ['笔记', '学习', 'Rust']
artid: "146163846"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146163846
    alt: "rust学习笔记13-18.-四数之和"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146163846
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146163846
cover: https://bing.ee123.net/img/rand?artid=146163846
image: https://bing.ee123.net/img/rand?artid=146163846
img: https://bing.ee123.net/img/rand?artid=146163846
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     rust学习笔记13-18. 四数之和
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     上一篇已经说到了两数之和，索性将三数之和与四数之和一起都复习一下
    </p>
    <p>
     <a href="https://leetcode.cn/problems/3sum/" rel="nofollow" title="15. 三数之和">
      15. 三数之和
     </a>
    </p>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，判断是否存在三元组
     <code>
      [nums[i], nums[j], nums[k]]
     </code>
     满足
     <code>
      i != j
     </code>
     、
     <code>
      i != k
     </code>
     且
     <code>
      j != k
     </code>
     ，同时还满足
     <code>
      nums[i] + nums[j] + nums[k] == 0
     </code>
     。请你返回所有和为
     <code>
      0
     </code>
     且不重复的三元组。
    </p>
    <p>
     <strong>
      注意：
     </strong>
     答案中不可以包含重复的三元组。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]
<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]
<strong>解释：</strong>
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,1,1]
<strong>输出：</strong>[]
<strong>解释：</strong>唯一可能的三元组和不为 0 。
</pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,0,0]
<strong>输出：</strong>[[0,0,0]]
<strong>解释：</strong>唯一可能的三元组和为 0 。
</pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       3 &lt;= nums.length &lt;= 3000
      </code>
     </li>
     <li>
      <code>
       -105 &lt;= nums[i] &lt;= 105
      </code>
     </li>
    </ul>
    <p>
     解答
    </p>
    <pre><code class="language-rust">//双指针
pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {

    let mut resultList:Vec&lt;Vec&lt;i32&gt;&gt; =Vec::new();
    let mut nums2 = nums.clone();
    // 先进行排序
    nums2.sort();
    for i in 0..nums2.len() {
        // 如果最小的都大于0，那就没有集合，直接返回
        if nums2[i] &gt; 0 {
            return resultList;
        }
        // 去重
        if i &gt; 0 &amp;&amp; nums2[i] == nums2[i - 1] {
            continue;
        }
        
        let mut  left = i + 1;
        let mut  rigth = nums2.len() - 1;
        while left &lt; rigth {
            let n = nums2[i] + nums2[left] + nums2[rigth];
            if n &gt; 0 {
                rigth -= 1;
            }else if  n &lt; 0  {
                left += 1; 
            }else {
                resultList.push(vec![nums2[i],nums2[left],nums2[rigth]]);
                //右侧去重
                while left &lt; rigth &amp;&amp; nums2[rigth] == nums2[rigth - 1] {
                    rigth -= 1;
                }
                //左侧去重
                while left &lt; rigth &amp;&amp; nums2[left] == nums2[left + 1] {
                    left += 1;
                }
                rigth -= 1;
                left += 1; 
            }  
        }
    }

    return  resultList;
        
}


//三数之和
fn main() {
    let nums = vec![-1,0,1,2,-1,-4];
    let res = three_sum(nums);
    println!("{:?}", res);
}
</code></pre>
    <p>
     <img alt="" height="336" src="https://i-blog.csdnimg.cn/direct/139b6dfc2e0c42409f9b808fd73d35f4.png" width="963"/>
    </p>
    <p>
     <a href="https://leetcode.cn/problems/4sum/" rel="nofollow" title="18. 四数之和">
      18. 四数之和
     </a>
    </p>
    <p>
     给你一个由
     <code>
      n
     </code>
     个整数组成的数组
     <code>
      nums
     </code>
     ，和一个目标值
     <code>
      target
     </code>
     。请你找出并返回满足下述全部条件且
     <strong>
      不重复
     </strong>
     的四元组
     <code>
      [nums[a], nums[b], nums[c], nums[d]]
     </code>
     （若两个四元组元素一一对应，则认为两个四元组重复）：
    </p>
    <ul>
     <li>
      <code>
       0 &lt;= a, b, c, d &lt; n
      </code>
     </li>
     <li>
      <code>
       a
      </code>
      、
      <code>
       b
      </code>
      、
      <code>
       c
      </code>
      和
      <code>
       d
      </code>
      <strong>
       互不相同
      </strong>
     </li>
     <li>
      <code>
       nums[a] + nums[b] + nums[c] + nums[d] == target
      </code>
     </li>
    </ul>
    <p>
     你可以按
     <strong>
      任意顺序
     </strong>
     返回答案 。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [1,0,-1,0,-2,2], target = 0
<strong>输出：</strong>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [2,2,2,2,2], target = 8
<strong>输出：</strong>[[2,2,2,2]]
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= nums.length &lt;= 200
      </code>
     </li>
     <li>
      <code>
       -109 &lt;= nums[i] &lt;= 109
      </code>
     </li>
     <li>
      <code>
       -109 &lt;= target &lt;= 109
      </code>
     </li>
    </ul>
    <p>
     四数之和与三数之和一样，无非多了一层循环，具体解法如下
    </p>
    <pre><code class="language-rust">
pub fn four_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let mut resultList:Vec&lt;Vec&lt;i32&gt;&gt; =Vec::new();
    let mut nums2 = nums.clone();
    // 先进行排序
    nums2.sort();
    for i in 0..nums2.len() {
        //剪枝
        if nums2[i] &gt; target &amp;&amp; nums2[i] &gt;= 0 {
            break;
        }

        // 第一层去重
        if i &gt; 0 &amp;&amp; nums2[i] == nums2[i - 1] {
            continue;
        }

        for j in  i+1..nums2.len() {
            // 解释一下，i=nums[0], j=nums[1], left=nums[2], rigth=nums[3]
            // 第二层剪枝
            if nums2[i] + nums2[j] &gt; target &amp;&amp; nums2[i] + nums2[j] &gt;= 0 {
                break;
            }
            // 第二层去重
            if j &gt; i + 1 &amp;&amp; nums2[j] == nums2[j - 1] {
                continue;
            }

            let mut  left = j + 1;
            let mut  rigth = nums2.len() - 1;
            while left &lt; rigth {
                let n: i32 = nums2[i] + nums2[j] + nums2[left] + nums2[rigth];
                if n &gt; target {
                    rigth -= 1;
                }else if  n &lt; target  {
                    left += 1; 
                }else {
                    resultList.push(vec![nums2[i], nums2[j], nums2[left],nums2[rigth]]);
                    //右侧去重
                    while left &lt; rigth &amp;&amp; nums2[rigth] == nums2[rigth - 1] {
                        rigth -= 1;
                    }
                    //左侧去重
                    while left &lt; rigth &amp;&amp; nums2[left] == nums2[left + 1] {
                        left += 1;
                    }
                    rigth -= 1;
                    left += 1; 
                }  
            }
        }

    }

    return resultList;
        
}
fn main() {
    let nums = vec![1,0,-1,0,-2,2];
    let res = four_sum(nums, 0);
    println!("{:?}", res);
}
</code></pre>
    <p>
     <img alt="" height="334" src="https://i-blog.csdnimg.cn/direct/e89f4bebb2fa48fca5f95f51359abb1a.png" width="952"/>
    </p>
    <p>
     总结，两数之和与三数之和、四数之和解法不一样，主要是因为返回值，两数之和要返回下角标不能做排序，用hashmap合适，而三数之和、四数之和是要求返回结果集且不能重复，需要对数组进行排序，用双指针更适合。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35303235333938352f:61727469636c652f64657461696c732f313436313633383436" class_="artid" style="display:none">
 </p>
</div>


