---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35313632363231362f:61727469636c652f64657461696c732f313436323638313539"
layout: post
title: "Java创造型模式之原型模式详解"
date: 2025-03-14 22:25:00 +0800
description: "原型模式是一种通过复制原型对象来创建新对象的设计模式。它使得对象的创建不依赖于具体的类构造，而是依赖于原型实例。原型实例通过浅拷贝或深拷贝的方式复制，从而生成新的实例对象。关键点：原型对象：一个可以复制的对象。克隆操作：通过复制（克隆）原型对象来创建新的对象。浅拷贝与深拷贝：浅拷贝指的是复制对象时，原对象和复制对象共享引用类型的成员变量。深拷贝则是完全复制对象，确保复制对象和原对象没有任何共享的引用类型变量。原型设计模式通过克隆现有对象来创建新对象，而不是每次都通过构造函数创建。"
keywords: "Java创造型模式之原型模式详解"
categories: ['设计模式']
tags: ['开发语言', 'Java']
artid: "146268159"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268159
    alt: "Java创造型模式之原型模式详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268159
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268159
cover: https://bing.ee123.net/img/rand?artid=146268159
image: https://bing.ee123.net/img/rand?artid=146268159
img: https://bing.ee123.net/img/rand?artid=146268159
---

# Java创造型模式之原型模式详解

设计模式是面向对象设计中的一种标准方法，用于解决常见的设计问题。原型设计模式（Prototype Pattern）是23种经典设计模式之一，属于创建型模式，它允许通过复制现有对象来创建新对象，而不是通过构造函数或工厂方法来创建。这样，开发者可以在运行时通过复制原型对象来快速生成新的对象，极大地提高了程序的灵活性和性能。

本文将深入讲解Java中的原型设计模式，解释其概念、使用场景、以及如何在Java中实现。

### 一、原型设计模式的定义

原型模式是一种通过复制原型对象来创建新对象的设计模式。它使得对象的创建不依赖于具体的类构造，而是依赖于原型实例。原型实例通过浅拷贝或深拷贝的方式复制，从而生成新的实例对象。

#### **关键点：**

1. **原型对象**
   ：一个可以复制的对象。
2. **克隆操作**
   ：通过复制（克隆）原型对象来创建新的对象。
3. **浅拷贝与深拷贝**
   ：浅拷贝指的是复制对象时，原对象和复制对象共享引用类型的成员变量。深拷贝则是完全复制对象，确保复制对象和原对象没有任何共享的引用类型变量。

### 二、使用原型模式的原因

在某些场景中，传统的对象创建方式可能过于复杂或不够高效。通过原型模式，我们可以通过现有的对象（即原型）来快速创建新对象，而无需重新构造对象。

#### **原型模式的优势：**

1. **提高性能**
   ：当对象的创建过程比较复杂时，通过原型复制对象来创建新实例通常比使用构造函数更高效。
2. **简化创建过程**
   ：对象的创建不需要重复复杂的初始化操作，只需要通过复制已有对象来实现。
3. **支持变更**
   ：通过复制原型对象，开发者可以在运行时修改对象的某些属性，而不影响原对象。

#### **适用场景：**

* 创建对象的过程较为复杂，且有多个相似对象需要频繁创建时，原型模式尤其有效。
* 需要在程序运行时动态创建大量相似对象的情况。
* 在复制对象时不希望重复调用构造函数，特别是当对象初始化代价较大时。

### 三、原型模式的实现

在Java中，原型模式通常通过实现
`Cloneable`
接口来实现，
`Cloneable`
接口是Java标准库中的一个标记接口，表示该对象支持克隆操作。
`Object`
类中的
`clone()`
方法是用于执行浅拷贝的默认实现。

#### 1. **浅拷贝与深拷贝**

* **浅拷贝**
  ：复制对象时，只复制对象本身的基本数据类型成员，引用类型成员复制的是地址，意味着原对象和克隆对象会共享引用类型的成员。
* **深拷贝**
  ：复制对象时，不仅复制对象本身，还会复制对象的引用类型成员，确保原对象和克隆对象互不影响。

#### 2. **实现原型模式的步骤**

##### 步骤 1：实现 `Cloneable` 接口

首先，确保要复制的类实现了
`Cloneable`
接口。
`Cloneable`
接口是一个标记接口，它告诉
`Object.clone()`
方法该对象支持克隆操作。

##### 步骤 2：重写 `clone()` 方法

由于
`Object`
类的
`clone()`
方法是保护的（
`protected`
），我们需要在自己的类中覆盖
`clone()`
方法。通常我们会将
`clone()`
方法设为
`public`
，以便外部可以调用。

##### 步骤 3：深拷贝或浅拷贝

根据需求，可以在
`clone()`
方法中实现深拷贝或浅拷贝。默认的
`clone()`
方法是浅拷贝，如果需要深拷贝，需要手动实现。

### 四、Java中原型设计模式的示例代码

#### 1、浅拷贝

```java
// 实现Cloneable接口
class Prototype implements Cloneable {
    private String name;
    private int age;

    // 构造方法
    public Prototype(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 获取对象的浅拷贝
    @Override
    public Prototype clone() {
        try {
            return (Prototype) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    // Getter和Setter方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Prototype{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

public class PrototypeDemo {
    public static void main(String[] args) {
        // 创建原型对象
        Prototype original = new Prototype("Alice", 30);
        System.out.println("Original Object: " + original);

        // 克隆原型对象
        Prototype clone = original.clone();
        System.out.println("Cloned Object: " + clone);
        
        // 修改克隆对象的属性
        clone.setName("Bob");
        clone.setAge(25);

        System.out.println("Modified Cloned Object: " + clone);
        System.out.println("Original Object after modification: " + original);
    }
}

```

结果为：

```bash
Original Object: Prototype{name='Alice', age=30}
Cloned Object: Prototype{name='Alice', age=30}
Modified Cloned Object: Prototype{name='Bob', age=25}
Original Object after modification: Prototype{name='Alice', age=30}

```

#### 2、深拷贝

```java
class Address {
    private String street;
    private String city;

    public Address(String street, String city) {
        this.street = street;
        this.city = city;
    }

    public Address(Address address) {
        this.street = address.street;
        this.city = address.city;
    }

    @Override
    public String toString() {
        return "Address{" +
                "street='" + street + '\'' +
                ", city='" + city + '\'' +
                '}';
    }
}

class DeepPrototype implements Cloneable {
    private String name;
    private Address address;

    public DeepPrototype(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    public DeepPrototype clone() {
        try {
            DeepPrototype cloned = (DeepPrototype) super.clone();
            cloned.address = new Address(this.address); // 深拷贝
            return cloned;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public String toString() {
        return "DeepPrototype{" +
                "name='" + name + '\'' +
                ", address=" + address +
                '}';
    }
}

public class DeepPrototypeDemo {
    public static void main(String[] args) {
        Address address = new Address("Baker Street", "London");
        DeepPrototype original = new DeepPrototype("John", address);
        System.out.println("Original Object: " + original);

        // 深拷贝原型对象
        DeepPrototype cloned = original.clone();
        System.out.println("Cloned Object: " + cloned);

        // 修改克隆对象的属性
        cloned.address = new Address("Wall Street", "New York");
        System.out.println("Modified Cloned Object: " + cloned);
        System.out.println("Original Object after modification: " + original);
    }
}

```

结果为：

```bash
Original Object: DeepPrototype{name='John', address=Address{street='Baker Street', city='London'}}
Cloned Object: DeepPrototype{name='John', address=Address{street='Baker Street', city='London'}}
Modified Cloned Object: DeepPrototype{name='John', address=Address{street='Wall Street', city='New York'}}
Original Object after modification: DeepPrototype{name='John', address=Address{street='Baker Street', city='London'}}

```

### 五、总结

原型设计模式通过克隆现有对象来创建新对象，而不是每次都通过构造函数创建。这种方式非常适合需要频繁创建相似对象的场景。Java提供了
`Cloneable`
接口和
`clone()`
方法来支持该模式的实现。在实际开发中，使用原型模式可以减少对象创建时的性能开销，同时也可以在对象状态变化时避免重复操作。

无论是浅拷贝还是深拷贝，原型模式都能有效提高开发效率，并在某些情况下避免不必要的资源浪费。理解并合理使用原型模式，可以在复杂系统的设计中发挥重要作用。