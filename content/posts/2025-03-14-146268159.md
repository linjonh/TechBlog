---
layout: post
title: "Java创造型模式之原型模式详解"
date: 2025-03-14 22:25:00 +0800
description: "原型模式是一种通过复制原型对象来创建新对象的设计模式。它使得对象的创建不依赖于具体的类构造，而是依赖于原型实例。原型实例通过浅拷贝或深拷贝的方式复制，从而生成新的实例对象。关键点：原型对象：一个可以复制的对象。克隆操作：通过复制（克隆）原型对象来创建新的对象。浅拷贝与深拷贝：浅拷贝指的是复制对象时，原对象和复制对象共享引用类型的成员变量。深拷贝则是完全复制对象，确保复制对象和原对象没有任何共享的引用类型变量。原型设计模式通过克隆现有对象来创建新对象，而不是每次都通过构造函数创建。"
keywords: "Java创造型模式之原型模式详解"
categories: ['设计模式']
tags: ['开发语言', 'Java']
artid: "146268159"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268159
    alt: "Java创造型模式之原型模式详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268159
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268159
cover: https://bing.ee123.net/img/rand?artid=146268159
image: https://bing.ee123.net/img/rand?artid=146268159
img: https://bing.ee123.net/img/rand?artid=146268159
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java创造型模式之原型模式详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     设计模式是面向对象设计中的一种标准方法，用于解决常见的设计问题。原型设计模式（Prototype Pattern）是23种经典设计模式之一，属于创建型模式，它允许通过复制现有对象来创建新对象，而不是通过构造函数或工厂方法来创建。这样，开发者可以在运行时通过复制原型对象来快速生成新的对象，极大地提高了程序的灵活性和性能。
    </p>
    <p>
     本文将深入讲解Java中的原型设计模式，解释其概念、使用场景、以及如何在Java中实现。
    </p>
    <h3>
     一、原型设计模式的定义
    </h3>
    <p>
     原型模式是一种通过复制原型对象来创建新对象的设计模式。它使得对象的创建不依赖于具体的类构造，而是依赖于原型实例。原型实例通过浅拷贝或深拷贝的方式复制，从而生成新的实例对象。
    </p>
    <h4>
     <strong>
      关键点：
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       原型对象
      </strong>
      ：一个可以复制的对象。
     </li>
     <li>
      <strong>
       克隆操作
      </strong>
      ：通过复制（克隆）原型对象来创建新的对象。
     </li>
     <li>
      <strong>
       浅拷贝与深拷贝
      </strong>
      ：浅拷贝指的是复制对象时，原对象和复制对象共享引用类型的成员变量。深拷贝则是完全复制对象，确保复制对象和原对象没有任何共享的引用类型变量。
     </li>
    </ol>
    <h3>
     二、使用原型模式的原因
    </h3>
    <p>
     在某些场景中，传统的对象创建方式可能过于复杂或不够高效。通过原型模式，我们可以通过现有的对象（即原型）来快速创建新对象，而无需重新构造对象。
    </p>
    <h4>
     <strong>
      原型模式的优势：
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       提高性能
      </strong>
      ：当对象的创建过程比较复杂时，通过原型复制对象来创建新实例通常比使用构造函数更高效。
     </li>
     <li>
      <strong>
       简化创建过程
      </strong>
      ：对象的创建不需要重复复杂的初始化操作，只需要通过复制已有对象来实现。
     </li>
     <li>
      <strong>
       支持变更
      </strong>
      ：通过复制原型对象，开发者可以在运行时修改对象的某些属性，而不影响原对象。
     </li>
    </ol>
    <h4>
     <strong>
      适用场景：
     </strong>
    </h4>
    <ul>
     <li>
      创建对象的过程较为复杂，且有多个相似对象需要频繁创建时，原型模式尤其有效。
     </li>
     <li>
      需要在程序运行时动态创建大量相似对象的情况。
     </li>
     <li>
      在复制对象时不希望重复调用构造函数，特别是当对象初始化代价较大时。
     </li>
    </ul>
    <h3>
     三、原型模式的实现
    </h3>
    <p>
     在Java中，原型模式通常通过实现
     <code>
      Cloneable
     </code>
     接口来实现，
     <code>
      Cloneable
     </code>
     接口是Java标准库中的一个标记接口，表示该对象支持克隆操作。
     <code>
      Object
     </code>
     类中的
     <code>
      clone()
     </code>
     方法是用于执行浅拷贝的默认实现。
    </p>
    <h4>
     1.
     <strong>
      浅拷贝与深拷贝
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       浅拷贝
      </strong>
      ：复制对象时，只复制对象本身的基本数据类型成员，引用类型成员复制的是地址，意味着原对象和克隆对象会共享引用类型的成员。
     </li>
     <li>
      <strong>
       深拷贝
      </strong>
      ：复制对象时，不仅复制对象本身，还会复制对象的引用类型成员，确保原对象和克隆对象互不影响。
     </li>
    </ul>
    <h4>
     2.
     <strong>
      实现原型模式的步骤
     </strong>
    </h4>
    <h5>
     步骤 1：实现
     <code>
      Cloneable
     </code>
     接口
    </h5>
    <p>
     首先，确保要复制的类实现了
     <code>
      Cloneable
     </code>
     接口。
     <code>
      Cloneable
     </code>
     接口是一个标记接口，它告诉
     <code>
      Object.clone()
     </code>
     方法该对象支持克隆操作。
    </p>
    <h5>
     步骤 2：重写
     <code>
      clone()
     </code>
     方法
    </h5>
    <p>
     由于
     <code>
      Object
     </code>
     类的
     <code>
      clone()
     </code>
     方法是保护的（
     <code>
      protected
     </code>
     ），我们需要在自己的类中覆盖
     <code>
      clone()
     </code>
     方法。通常我们会将
     <code>
      clone()
     </code>
     方法设为
     <code>
      public
     </code>
     ，以便外部可以调用。
    </p>
    <h5>
     步骤 3：深拷贝或浅拷贝
    </h5>
    <p>
     根据需求，可以在
     <code>
      clone()
     </code>
     方法中实现深拷贝或浅拷贝。默认的
     <code>
      clone()
     </code>
     方法是浅拷贝，如果需要深拷贝，需要手动实现。
    </p>
    <h3>
     四、Java中原型设计模式的示例代码
    </h3>
    <h4>
     1、浅拷贝
    </h4>
    <pre><code class="language-java">// 实现Cloneable接口
class Prototype implements Cloneable {
    private String name;
    private int age;

    // 构造方法
    public Prototype(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 获取对象的浅拷贝
    @Override
    public Prototype clone() {
        try {
            return (Prototype) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    // Getter和Setter方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Prototype{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

public class PrototypeDemo {
    public static void main(String[] args) {
        // 创建原型对象
        Prototype original = new Prototype("Alice", 30);
        System.out.println("Original Object: " + original);

        // 克隆原型对象
        Prototype clone = original.clone();
        System.out.println("Cloned Object: " + clone);
        
        // 修改克隆对象的属性
        clone.setName("Bob");
        clone.setAge(25);

        System.out.println("Modified Cloned Object: " + clone);
        System.out.println("Original Object after modification: " + original);
    }
}
</code></pre>
    <p>
     结果为：
    </p>
    <pre><code class="language-bash">Original Object: Prototype{name='Alice', age=30}
Cloned Object: Prototype{name='Alice', age=30}
Modified Cloned Object: Prototype{name='Bob', age=25}
Original Object after modification: Prototype{name='Alice', age=30}
</code></pre>
    <h4>
     2、深拷贝
    </h4>
    <pre><code class="language-java">class Address {
    private String street;
    private String city;

    public Address(String street, String city) {
        this.street = street;
        this.city = city;
    }

    public Address(Address address) {
        this.street = address.street;
        this.city = address.city;
    }

    @Override
    public String toString() {
        return "Address{" +
                "street='" + street + '\'' +
                ", city='" + city + '\'' +
                '}';
    }
}

class DeepPrototype implements Cloneable {
    private String name;
    private Address address;

    public DeepPrototype(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    public DeepPrototype clone() {
        try {
            DeepPrototype cloned = (DeepPrototype) super.clone();
            cloned.address = new Address(this.address); // 深拷贝
            return cloned;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public String toString() {
        return "DeepPrototype{" +
                "name='" + name + '\'' +
                ", address=" + address +
                '}';
    }
}

public class DeepPrototypeDemo {
    public static void main(String[] args) {
        Address address = new Address("Baker Street", "London");
        DeepPrototype original = new DeepPrototype("John", address);
        System.out.println("Original Object: " + original);

        // 深拷贝原型对象
        DeepPrototype cloned = original.clone();
        System.out.println("Cloned Object: " + cloned);

        // 修改克隆对象的属性
        cloned.address = new Address("Wall Street", "New York");
        System.out.println("Modified Cloned Object: " + cloned);
        System.out.println("Original Object after modification: " + original);
    }
}
</code></pre>
    <p>
     结果为：
    </p>
    <pre><code class="language-bash">Original Object: DeepPrototype{name='John', address=Address{street='Baker Street', city='London'}}
Cloned Object: DeepPrototype{name='John', address=Address{street='Baker Street', city='London'}}
Modified Cloned Object: DeepPrototype{name='John', address=Address{street='Wall Street', city='New York'}}
Original Object after modification: DeepPrototype{name='John', address=Address{street='Baker Street', city='London'}}
</code></pre>
    <p>
    </p>
    <h3>
     五、总结
    </h3>
    <p>
     原型设计模式通过克隆现有对象来创建新对象，而不是每次都通过构造函数创建。这种方式非常适合需要频繁创建相似对象的场景。Java提供了
     <code>
      Cloneable
     </code>
     接口和
     <code>
      clone()
     </code>
     方法来支持该模式的实现。在实际开发中，使用原型模式可以减少对象创建时的性能开销，同时也可以在对象状态变化时避免重复操作。
    </p>
    <p>
     无论是浅拷贝还是深拷贝，原型模式都能有效提高开发效率，并在某些情况下避免不必要的资源浪费。理解并合理使用原型模式，可以在复杂系统的设计中发挥重要作用。
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35313632363231362f:61727469636c652f64657461696c732f313436323638313539" class_="artid" style="display:none">
 </p>
</div>


