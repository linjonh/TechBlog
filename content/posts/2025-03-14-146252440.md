---
layout: post
title: "RocketMQ-性能优化与调优策略一"
date: 2025-03-14 11:07:23 +0800
description: "RocketMQ 性能优化与调优策略（一）"
keywords: "RocketMQ 性能优化与调优策略（一）"
categories: ['Rocketmq']
tags: ['性能优化', 'Rocketmq']
artid: "146252440"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146252440
    alt: "RocketMQ-性能优化与调优策略一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146252440
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146252440
cover: https://bing.ee123.net/img/rand?artid=146252440
image: https://bing.ee123.net/img/rand?artid=146252440
img: https://bing.ee123.net/img/rand?artid=146252440
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RocketMQ 性能优化与调优策略（一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     RocketMQ：分布式消息中间件的璀璨之星
    </h3>
    <p class="img-center">
     <img alt='{"type":"load_by_key","key":"auto_image_0_0","image_type":"search"}' height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=undefined&amp;pos_id=wEYbjSbD" width="534"/>
    </p>
    <p>
     在当今数字化时代，分布式系统已成为构建大型应用的核心架构。随着业务规模的不断扩大和用户量的持续增长，系统间的通信和数据交互变得愈发复杂。为了解决这些挑战，消息中间件应运而生，而 RocketMQ 便是其中的佼佼者。
    </p>
    <p>
     RocketMQ 是一款由阿里巴巴开源的分布式消息中间件，具备高性能、低延迟、高可靠、功能丰富和良好扩展性等优势，在众多领域得到了广泛应用。它采用分布式架构设计，通过多节点协作实现高可用和高性能，能够轻松应对海量消息的处理需求。在性能方面，RocketMQ 表现卓越，具备高吞吐量和低延迟的特性。以电商领域为例，在双十一等购物狂欢节期间，面对海量的订单和交易消息，RocketMQ 能够稳定运行，确保消息的及时处理，保障了电商平台的顺畅运营。同时，RocketMQ 还支持多种消息模式，如顺序消息、事务消息、定时消息等，满足了不同业务场景的多样化需求。例如，在订单处理系统中，通过顺序消息可以保证订单的创建、支付、发货等步骤按顺序执行，确保业务逻辑的正确性；在分布式事务场景下，事务消息能够保证数据的最终一致性，避免数据不一致问题的出现。
    </p>
    <p>
     在实际应用中，RocketMQ 的身影随处可见。在电商领域，它被用于订单处理、库存管理、物流配送等环节，实现系统间的解耦和异步通信，提升系统的响应速度和处理能力；在物流行业，RocketMQ 帮助物流企业实现订单信息的实时传输和跟踪，优化物流配送流程，提高物流效率；在金融领域，它保障了交易信息的可靠传递和处理，满足金融业务对数据一致性和可靠性的严格要求；在大数据领域，RocketMQ 作为数据传输的桥梁，将海量数据高效地传输到各个数据处理环节，为数据分析和挖掘提供支持。
    </p>
    <p>
     随着业务的不断发展和用户量的增长，对 RocketMQ 性能的要求也越来越高。性能优化与调优成为了保障系统高效稳定运行的关键。通过合理的配置和优化，可以充分发挥 RocketMQ 的潜力，提升系统的整体性能，为业务的发展提供有力支持。接下来，让我们深入探讨 RocketMQ 的性能优化与调优策略。
    </p>
    <h3>
     深入剖析性能优化基本原则
    </h3>
    <h4>
     （一）吃透消息模型
    </h4>
    <p>
     RocketMQ 采用生产者 - 代理 - 消费者的经典消息模型。生产者负责创建并发送消息，代理（Broker）承担消息的存储与转发重任，消费者则专注于接收并处理消息。在这个模型中，消息从生产者诞生，经由网络传输抵达 Broker，Broker 依据自身的存储策略将消息持久化到磁盘，同时为消费者的拉取请求做好准备。消费者通过与 Broker 建立连接，按照一定的策略拉取消息并进行消费处理。
    </p>
    <p>
     理解这一消息模型对于性能优化至关重要。它帮助我们清晰地把握消息的流动路径和处理过程，从而精准定位性能瓶颈。例如，当发现消息发送延迟较高时，我们可以从生产者的发送逻辑、网络传输状况以及 Broker 的接收处理能力等方面进行排查；当消息消费速度过慢时，我们可以聚焦于消费者的消费逻辑、消费线程池配置以及与 Broker 的交互方式等。只有深入理解消息模型，才能在性能优化时有的放矢，采取有效的措施提升系统性能。
    </p>
    <h4>
     （二）大力提升吞吐量
    </h4>
    <p>
     批量消息发送是提升 RocketMQ 吞吐量的重要手段。其原理是将多条消息打包成一个批次进行发送，减少了网络连接和 IO 操作的次数，从而显著提高了消息发送的效率。在 Java 中，实现批量消息发送的示例代码如下：
    </p>
    <pre></pre>
    <p>
     <code>
      import org.apache.rocketmq.client.producer.DefaultMQProducer;
     </code>
    </p>
    <p>
     <code>
      import org.apache.rocketmq.client.producer.SendResult;
     </code>
    </p>
    <p>
     <code>
      import org.apache.rocketmq.common.message.Message;
     </code>
    </p>
    <p>
     <code>
      import java.util.ArrayList;
     </code>
    </p>
    <p>
     <code>
      import java.util.List;
     </code>
    </p>
    <p>
     <code>
      public class BatchProducer {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      public static void main(String[] args) throws Exception {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      // 实例化生产者
     </code>
    </p>
    <p>
     <code>
      DefaultMQProducer producer = new DefaultMQProducer("BatchProducerGroup");
     </code>
    </p>
    <p>
     <code>
      // 指定NameServer地址
     </code>
    </p>
    <p>
     <code>
      producer.setNamesrvAddr("localhost:9876");
     </code>
    </p>
    <p>
     <code>
      // 启动生产者
     </code>
    </p>
    <p>
     <code>
      producer.start();
     </code>
    </p>
    <p>
     <code>
      String topic = "BatchTopic";
     </code>
    </p>
    <p>
     <code>
      List&lt;Message&gt; messageList = new ArrayList&lt;&gt;();
     </code>
    </p>
    <p>
     <code>
      messageList.add(new Message(topic, "Tag1", "OrderID-001", "Hello world 1".getBytes()));
     </code>
    </p>
    <p>
     <code>
      messageList.add(new Message(topic, "Tag1", "OrderID-002", "Hello world 2".getBytes()));
     </code>
    </p>
    <p>
     <code>
      messageList.add(new Message(topic, "Tag1", "OrderID-003", "Hello world 3".getBytes()));
     </code>
    </p>
    <p>
     <code>
      try {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      // 批量发送消息
     </code>
    </p>
    <p>
     <code>
      SendResult sendResult = producer.send(messageList);
     </code>
    </p>
    <p>
     <code>
      System.out.printf("Message sent: %s%n", sendResult);
     </code>
    </p>
    <p>
     <code>
      } catch (Exception e) {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      e.printStackTrace();
     </code>
    </p>
    <p>
     <code>
      } finally {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      // 关闭生产者
     </code>
    </p>
    <p>
     <code>
      producer.shutdown();
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     通过上述代码，我们将多条消息添加到messageList中，然后调用producer.send(messageList)方法进行批量发送。这样，原本需要多次发送的消息，现在只需一次网络请求即可完成，大大减少了网络开销，提高了消息发送的效率。批量发送适用于大量消息需要发送的场景，如电商订单处理、物流信息同步等，能够显著提升系统的吞吐量。
    </p>
    <h4>
     （三）全力降低延迟
    </h4>
    <p>
     异步消息发送机制是降低消息发送延迟的有效方式。在异步发送模式下，生产者在发送消息后，无需等待 Broker 的确认响应，即可继续执行后续操作。当 Broker 处理完消息后，通过事先设置的 Callback 回调函数来通知生产者消息的发送结果。这种方式避免了生产者在等待响应过程中的阻塞，大大提高了消息发送的效率，降低了延迟。
    </p>
    <p>
     在 Python 中，实现异步消息发送的示例代码如下：
    </p>
    <pre></pre>
    <p>
     <code>
      from rocketmq.client import Producer, Message, SendCallback
     </code>
    </p>
    <p>
     <code>
      class MySendCallback(SendCallback):
     </code>
    </p>
    <p>
     <code>
      def on_success(self, send_result):
     </code>
    </p>
    <p>
     <code>
      print(f"Send Success: {send_result}")
     </code>
    </p>
    <p>
     <code>
      def on_exception(self, exception):
     </code>
    </p>
    <p>
     <code>
      print(f"Send Exception: {exception}")
     </code>
    </p>
    <p>
     <code>
      producer = Producer("ProducerGroup")
     </code>
    </p>
    <p>
     <code>
      producer.set_name_server_address("localhost:9876")
     </code>
    </p>
    <p>
     <code>
      producer.start()
     </code>
    </p>
    <p>
     <code>
      msg = Message("TopicTest")
     </code>
    </p>
    <p>
     <code>
      msg.set_tags("TagA")
     </code>
    </p>
    <p>
     <code>
      msg.set_keys("Key1")
     </code>
    </p>
    <p>
     <code>
      msg.set_body("Hello RocketMQ".encode("utf-8"))
     </code>
    </p>
    <p>
     <code>
      producer.send_async(msg, MySendCallback())
     </code>
    </p>
    <p>
     <code>
      # 保持主线程运行，等待异步发送结果
     </code>
    </p>
    <p>
     <code>
      import time
     </code>
    </p>
    <p>
     <code>
      time.sleep(3)
     </code>
    </p>
    <p>
     <code>
      producer.shutdown()
     </code>
    </p>
    <p>
     在上述代码中，我们定义了一个MySendCallback类，实现了on_success和on_exception方法，分别用于处理消息发送成功和失败的情况。然后，通过producer.send_async(msg, MySendCallback())方法发送异步消息，并传入回调函数实例。这样，生产者在发送消息后可以立即返回，继续执行其他任务，而消息发送的结果则由回调函数在后台处理，有效减少了等待时间，提高了发送效率。
    </p>
    <h4>
     （四）巧妙优化消息存储
    </h4>
    <p>
     合理优化消息存储是提升 RocketMQ 性能的关键环节。首先，合理设置存储路径可以有效减少磁盘负载。例如，将存储路径设置在高性能的磁盘阵列上，或者分散存储在多个磁盘上，避免单点磁盘 I/O 瓶颈。同时，设置合适的文件大小和数量也能显著提高存储效率。RocketMQ 的 CommitLog 文件默认大小为 1GB，通过调整这个值，可以平衡文件切换的频率和单个文件的存储容量，从而优化存储性能。
    </p>
    <p>
     异步刷盘模式是一种高效的消息持久化方式。在异步刷盘模式下，消息在写入内存后，立即返回确认给生产者，而刷盘操作则由后台线程异步进行。这样可以大大提高消息发送的吞吐量，减少延迟。以 Go 语言实现异步刷盘的示例代码如下：
    </p>
    <pre></pre>
    <p>
     <code>
      package main
     </code>
    </p>
    <p>
     <code>
      import (
     </code>
    </p>
    <p>
     <code>
      "fmt"
     </code>
    </p>
    <p>
     <code>
      "github.com/apache/rocketmq-client-go/v2"
     </code>
    </p>
    <p>
     <code>
      "github.com/apache/rocketmq-client-go/v2/primitive"
     </code>
    </p>
    <p>
     <code>
      "github.com/apache/rocketmq-client-go/v2/producer"
     </code>
    </p>
    <p>
     <code>
      )
     </code>
    </p>
    <p>
     <code>
      func main() {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      p, err := rocketmq.NewProducer(
     </code>
    </p>
    <p>
     <code>
      producer.WithNsResovler(primitive.NewPassthroughResolver([]string{"localhost:9876"})),
     </code>
    </p>
    <p>
     <code>
      producer.WithRetry(2),
     </code>
    </p>
    <p>
     <code>
      )
     </code>
    </p>
    <p>
     <code>
      if err != nil {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      fmt.Printf("Failed to create producer: %s\n", err)
     </code>
    </p>
    <p>
     <code>
      return
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     <code>
      defer p.Shutdown()
     </code>
    </p>
    <p>
     <code>
      msg := &amp;primitive.Message{
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      Topic: "TopicTest",
     </code>
    </p>
    <p>
     <code>
      Body: primitive.NewMessageBodyFromString("Hello RocketMQ"),
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     <code>
      // 发送异步消息
     </code>
    </p>
    <p>
     <code>
      err = p.SendAsync(msg, func(result *primitive.SendResult, err error) {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      if err != nil {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      fmt.Printf("Send message failed: %s\n", err)
     </code>
    </p>
    <p>
     <code>
      } else {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      fmt.Printf("Send Success: %s\n", result)
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     <code>
      })
     </code>
    </p>
    <p>
     <code>
      if err != nil {
      <!-- -->
     </code>
    </p>
    <p>
     <code>
      fmt.Printf("Failed to send message: %s\n", err)
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     <code>
      // 保持程序运行，等待异步发送结果
     </code>
    </p>
    <p>
     <code>
      select {}
     </code>
    </p>
    <p>
     <code>
      }
     </code>
    </p>
    <p>
     在上述代码中，我们使用rocketmq.NewProducer创建生产者，并通过p.SendAsync方法发送异步消息。在发送消息时，传入一个回调函数，用于处理消息发送的结果。这样，消息在发送后，生产者无需等待刷盘完成，即可继续执行其他操作，提高了系统的性能和响应速度。
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34323139303533302f:61727469636c652f64657461696c732f313436323532343430" class_="artid" style="display:none">
 </p>
</div>


