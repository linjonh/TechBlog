---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34343830393933342f:61727469636c652f64657461696c732f313436303134363937"
layout: post
title: "C-基础知识总结持续更新中..."
date: 2025-03-04 14:17:23 +08:00
description: "介绍C#中一些基础知识总结，读者可以通过该笔记查漏补缺、巩固基础知识，一些知识点也可能在面试中遇到。本笔记会持续更新......"
keywords: "c#基础知识文档下载"
categories: ['未分类']
tags: ['C']
artid: "146014697"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146014697
    alt: "C-基础知识总结持续更新中..."
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146014697
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146014697
cover: https://bing.ee123.net/img/rand?artid=146014697
image: https://bing.ee123.net/img/rand?artid=146014697
img: https://bing.ee123.net/img/rand?artid=146014697
---

# C# 基础知识总结（持续更新中...）

## C#有哪些数据类型？

|  |  |
| --- | --- |
| 值类型 | 引用类型 |
| 整数类型  实数类型  布尔类型  字符类型  结构类型  枚举类型 | 类  数组  字符串  接口  委托  对象型 |

## C#有哪几种访问修饰符，有何区别？

|  |  |  |
| --- | --- | --- |
| **public** | 公共成员 | 访问不受限制 |
| **private** | 私有成员 | 只限于当前类成员访问 |
| **protected** | 保护成员 | 访问限于当前类及其派生类 |
| **internal** | 内部成员 | 访问限于当前程序集 |
| **protected internal** | 保护内部成员 | 访问限于当前程序集或派生类 |
| **seald** | 密封 | 密封类不能被继承  密封方法必须是在重写父类虚方法的派生类的方法 |

## 装箱和拆箱

装箱：将值类型隐式地转换为引用类型

拆箱：将引用类型显式地转换为值类型

## 数据类型转换有哪些方法？

1、隐式类型转换和显式类型转换。

2、Parse方法和TryParse方法

3、Convert类方法

4、ToString()方法

5、is和as

## is 和 as的区别？

is用来判断对象是否和指定类型兼容，如果兼容返回true;不兼容返回false

as在判断兼容性的同时，进行类型转换。如果兼容则返回类型转换后的对象，如果不兼容则返回null

## 虚方法和抽象方法的区别？

**相同点：**

1、重写虚方法或实现抽象方法时，都要使用override关键字来修饰

2、派生类中的重写方法应该与基类中被重写的方法有相同访问权限、返回值类型、方法名和参数列表。

**不同点：**

1、虚方法关键字是virtual,抽象方法关键字是abstract;

2、虚方法既有声明部分也有实现部分，抽象方法只有声明部分没有实现部分。

3、派生类对基类虚方法的重写不是必须的，但必须对基类的抽象方法提供实现过程

## 构造函数和析构函数分别有什么作用，相同点和不同点？

构造函数：初始化一个对象的状态

析构函数：用于销毁对象，释放对象占用的系统资源

**相同点：**

1、函数的名称与类名相同

2、如果没有自定义该函数时，系统会自动生成一个默认的指定函数

3、都没有返回值

**不同点：**

1、构造函数可以重载，析构函数不能

2、构造函数可以有访问修饰符、可以是静态的、可以有多个参数，析构函数不能有访问修饰符、不能是静态的、不能包含任何参数

3、构造函数可以被显示调用，析构函数由系统自动调用

## C#静态构造函数特点是什么？

与类名相同

不能定义访问修饰符

没有参数

不能被重载

只能访问类的静态成员，不能访问实例成员

一个类只能有一个静态构造函数

不能显式调用静态构造函数，而是由.NET运行时自动调用。

## C#中有哪些值类型和引用类型？

值类型：整型、实数型、字符型 、布尔类型、枚举类型、结构类型

引用类型：类 、接口、委托、数组、 字符串、对象类型

## 抽象类和接口的区别

**相同点**

1、都可以被继承，派生类必须实现抽象方法和接口中声明的方法

2、都不能被实例化

**不同点**

1、抽象类用abstract关键字修饰，接口用interface关键字修饰

2、一个类可以继承多个接口、但是只能继承一个抽象类

3、实现抽象方法时需要使用override关键字，实现接口成员时不能使用override.

4、接口只能包含不实现的接口成员，抽象类除了可以包含抽象方法之外，还可以包含数据成员以及完全实现的方法和属性。

5、抽象类可以有构造方法，接口不能有构造方法

## 类和结构的区别？

**相同点**

都可以用来实现封装

**不同点**

1、类是用class 关键字来修饰，结构是用struct关键字来修饰

2、类是引用类型，结构是值类型

3、类支持继承，结构不支持继承

4、结构体成员不能使用protected访问修饰符，而类可以

5、结构体需要在构造函数中初始化所有成员变量，而类随意

6、结构体不能被static关键字修饰，而类可以

## new关键字的作用

可以用作运算符、约束、修饰符

1、运算符：用于创建对象和调用构造函数

2、修饰符：可以显式隐藏从基类继承的成员（变量、属性、函数）

3、约束：用于在泛型声明中约束可能用作类型参数的参数类型。

## i++和++i有什么区别？

i++称为后置运算，表示先使用变量的值再进行自增；

++i称为前置运算，表示先进行自增再使用变量的值

## 介绍一下重载和重写，它们的区别是什么？

重载：在一个中有多个相同名称的方法，它们的具有不同的签名（即参数列表有不同的参数类型或者不同的参数个数），一般它们实现的功能也不一样

重写：重写在继承时发生，在派生类中重新定义基类中的方法

区别：

1、重载发生同一个类中，重写在继承时发生，在派生类中实现

2、重载方法的参数列表必须不同，返回值可不同。重写方法和基类方法的名称、返回值类型、参数列表都必须完全一致。

3、重载是编译时多态；重写时运行时多态

## foreach与for的区别

1、使用for遍历时可以对集合的数据进行修改，使用foreach只能对数据进行读取不能修改

2、在循环次数未知或只需读取数据的情况下使用foreach,在需要对数据进行修改时使用for

## Math.Round

Math.Round(11.5)等于多少? Math.Round(-11.5)等于多少?

Math.Round(11.5)=12

Math.Round(-11.5)=-12

## 用sealed修饰的类有什么特点？

1、用Sealed关键字修饰的类是密封类

2、密封类不能被其他类继承但可以继承其他类或接口

3、密封类中不能声明虚方法

4、密封类不能声明为抽象的

## C#如何实现变长参数？

使用params关键字声明的数组型参数来实现

## base关键字和this关键字

this关键字表示当前类的对象

base关键字表示基类

[C#中this与base的区别_this base-CSDN博客](https://blog.csdn.net/wrs120/article/details/53667362 "C#中this与base的区别_this base-CSDN博客")

## C#中值传递与引用传递的区别是什么？

值传递：调用方传递给形参的只是实参数据的一个副本，形参发生更改不会影响实参的值

引用传递：调用方将实参变量的引用传递给形参，实参变量的引用代表数据值的内存地址，形参和实参指向同一个引用。形参的发生更改时，实参的值也会发生更改。

## 值类型和引用类型的区别是什么？

内存区域上的区别

值类型：数据存储在栈上，超出作用域就自动清理

引用类型：一个具有引用类型的数据并不驻留在栈内存中，而是存储于堆内存中。在堆内存中分配内存空间直接存储所包含的值，而在栈内存中存放定位到存储具体值的索引位置编号。当访问一个具有引用类型的数据时，需要到栈内存中检查变量的内容，而该内容指向堆中的一个实际数据。

## ref 和out 的区别

**相同点：**

都可以实现方法返回多个数据的效果

**不同点：**

1、使用ref关键字修饰的参数称为引用型参数，而out关键字修饰的参数被称为输出型参数

2、用ref传入的参数需要先初始化，而用out传入的参数不用初始化

3、用out传入的参数需要在方法内部赋值，而用ref传入的参数不需要

## C#如何实现多返回

使用ref关键字来声明多个引用型参数来实现

使用out关键字来声明多个输出型参数来实现

## 属性的作用？

1、属性是对变量的一种封装，通过设置对变量读写的属性来控制对字段的访问，保证了数据的封装性

2、在对需要与外界交互的字段，开放权限，保证了灵活性

3、可以在属性内部添加像方法一样处理逻辑和运算

## 字符串声明

字符串中string str=null和string str=""和string str=string.Empty的区别

string.Empty 相当于"",Empty 是一个静态只读的字段。

string str="" , 初始化对象，并分配一个空字符串的内存空间

string str=null, 初始化对象，不会分配内存空间

## Array(数组)、ArrayList(动态数组)和List（列表)的区别？

**1、容量大小**

Array的容量在创建时被确定，之后不能改变。

ArrayList和List的容量大小根据存储元素的多少进行自动调整。

**2、类型安全**

Array和List是类型安全的，它只能存储一种特定类型的元素

ArrayList不是类型安全的，它可以存储object类型的元素。可以将任何类型的对象添加到ArrayList中，编译时不会报错，但可能在运行时引发类型错误。

**3、维度不同**

数组可以有多个维度，ArrayList和List只有一个维度。

## C#中的委托是什么？事件是不是一种委托？

委托是一种引用类型，它可以将方法作为变量或者参数进行传递。事件是委托类型的变量，是委托的一种特殊形式。

## 简述Func与Action的区别？

Func和Action都是系统预定义的泛型委托，Func 是有返回值的委托， Action 是没有返回值的委托。

## C#字符串的驻留机制，如何解决？

一旦声明一个字符串并赋值，那么对该字符串的操作，系统会额外开辟内存地址存储处理后的新字符串，原来字符串不会发生改变；如果声明一个新的字符串与原来的字符串内容相同，那么该字符串仍然指向原来字符串的地址，不会开辟新的内存空间。

使用StringBuilder进行字符串的操作，它是对自身对象进行操作，不会生成新的对象。

## string和StringBuilder的区别,两者性能的比较

![](https://i-blog.csdnimg.cn/img_convert/bf549aee42fce520060542918fd4b14d.png)

![](https://i-blog.csdnimg.cn/img_convert/d4f1e2ade9e9ef426f5fbad635d23e45.png)

使用链表，利用链接代替复制

![](https://i-blog.csdnimg.cn/img_convert/b34dffdae3426e4a9eda0412e2817abc.png)

## 面向对象三大特性

|  |  |  |  |
| --- | --- | --- | --- |
|  | 封装性 | 继承性 | 多态性 |
| 定义 | 将对象的数据和操作代码组合到同一个结构中. | 派生类继承了基类中的类成员。既有继承又有扩展。 | 方法具有相同的名称，但是根据不同的情况，方法具有不同的实现方式。 |
| 体现 | 通过访问修饰符来体现封装 | 一个类可以继承单个类或者继承多个接口 | 方法重载  方法重写 |