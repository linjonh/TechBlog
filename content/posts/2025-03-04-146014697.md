---
layout: post
title: "C-基础知识总结持续更新中..."
date: 2025-03-04 14:17:23 +0800
description: "介绍C#中一些基础知识总结，读者可以通过该笔记查漏补缺、巩固基础知识，一些知识点也可能在面试中遇到。本笔记会持续更新......"
keywords: "c#基础知识文档下载"
categories: ['未分类']
tags: ['C']
artid: "146014697"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146014697
    alt: "C-基础知识总结持续更新中..."
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146014697
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146014697
cover: https://bing.ee123.net/img/rand?artid=146014697
image: https://bing.ee123.net/img/rand?artid=146014697
img: https://bing.ee123.net/img/rand?artid=146014697
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# 基础知识总结（持续更新中...）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="kfiwy">
     C#有哪些数据类型？
    </h2>
    <table id="UntI5">
     <tbody>
      <tr>
       <td style="width:314px">
        <p id="u6f981517">
         值类型
        </p>
       </td>
       <td style="width:374px">
        <p id="ud0650b34">
         引用类型
        </p>
       </td>
      </tr>
      <tr>
       <td style="width:314px">
        <p id="ufada2ea6">
         整数类型
        </p>
        <p id="ud5cfbb16">
         实数类型
        </p>
        <p id="uf1d2ec0a">
         布尔类型
        </p>
        <p id="u57657eb4">
         字符类型
        </p>
        <p id="u4b8b38f9">
         结构类型
        </p>
        <p id="u8ede6e93">
         枚举类型
        </p>
       </td>
       <td style="width:374px">
        <p id="u2f2aa94d">
         类
        </p>
        <p id="u92f14b27">
         数组
        </p>
        <p id="u4f0d662a">
         字符串
        </p>
        <p id="u9e0fc8ad">
         接口
        </p>
        <p id="u95c65d85">
         委托
        </p>
        <p id="ue1be640a">
         对象型
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h2 id="FPciv">
     C#有哪几种访问修饰符，有何区别？
    </h2>
    <table id="dPPzJ">
     <tbody>
      <tr>
       <td>
        <p id="u27d61ab3">
         <span style="color:#1c7331">
          <strong>
           public
          </strong>
         </span>
        </p>
       </td>
       <td>
        <p id="u229e4008">
         公共成员
        </p>
       </td>
       <td>
        <p id="u3573cd68">
         访问不受限制
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u50280fdf">
         <span style="color:#1c7331">
          <strong>
           private
          </strong>
         </span>
        </p>
       </td>
       <td>
        <p id="uee1e483c">
         私有成员
        </p>
       </td>
       <td>
        <p id="u8dabb3aa">
         只限于当前类成员访问
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="udf83037f">
         <span style="color:#1c7331">
          <strong>
           protected
          </strong>
         </span>
        </p>
       </td>
       <td>
        <p id="u4ee35391">
         保护成员
        </p>
       </td>
       <td>
        <p id="ue3f3aa26">
         访问限于当前类及其派生类
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="uad91a80c">
         <span style="color:#1c7331">
          <strong>
           internal
          </strong>
         </span>
        </p>
       </td>
       <td>
        <p id="u73c36207">
         内部成员
        </p>
       </td>
       <td>
        <p id="u670c7349">
         访问限于当前程序集
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u72aa19fe">
         <span style="color:#1c7331">
          <strong>
           protected internal
          </strong>
         </span>
        </p>
       </td>
       <td>
        <p id="u927a5928">
         保护内部成员
        </p>
       </td>
       <td>
        <p id="ufb61054f">
         访问限于当前程序集或派生类
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u4ec7dde5">
         <span style="color:#1c7331">
          <strong>
           seald
          </strong>
         </span>
        </p>
       </td>
       <td>
        <p id="u6007a154">
         密封
        </p>
       </td>
       <td>
        <p id="u935e6c84">
         密封类不能被继承
        </p>
        <p id="uaac01697">
         密封方法必须是在重写父类虚方法的派生类的方法
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h2 id="IW9Kv">
     装箱和拆箱
    </h2>
    <p id="u8cced484">
     装箱：将值类型隐式地转换为引用类型
    </p>
    <p id="ub61dd497">
     拆箱：将引用类型显式地转换为值类型
    </p>
    <p>
    </p>
    <h2 id="Owe6n">
     数据类型转换有哪些方法？
    </h2>
    <p id="u62df0fe1">
     1、隐式类型转换和显式类型转换。
    </p>
    <p id="u324b403c">
     2、Parse方法和TryParse方法
    </p>
    <p id="u20d679d4">
     3、Convert类方法
    </p>
    <p id="u0dbb8618">
     4、ToString()方法
    </p>
    <p id="ufec1c56b">
     5、is和as
    </p>
    <p id="u472a698b">
    </p>
    <h2 id="rh3nU">
     is 和 as的区别？
    </h2>
    <p id="u7875fb88">
     is用来判断对象是否和指定类型兼容，如果兼容返回true;不兼容返回false
    </p>
    <p id="uaacc64cb">
     as在判断兼容性的同时，进行类型转换。如果兼容则返回类型转换后的对象，如果不兼容则返回null
    </p>
    <p id="ub86da883">
    </p>
    <h2 id="W1ZqW">
     虚方法和抽象方法的区别？
    </h2>
    <p id="u4eac2052">
     <strong>
      相同点：
     </strong>
    </p>
    <p id="u2ab80cb0">
     1、重写虚方法或实现抽象方法时，都要使用override关键字来修饰
    </p>
    <p id="uc2bd3bfc">
     2、派生类中的重写方法应该与基类中被重写的方法有相同访问权限、返回值类型、方法名和参数列表。
    </p>
    <p id="uc4a35ea8">
     <strong>
      不同点：
     </strong>
    </p>
    <p id="u3d716e4e">
     1、虚方法关键字是virtual,抽象方法关键字是abstract;
    </p>
    <p id="u86a06b84">
     2、虚方法既有声明部分也有实现部分，抽象方法只有声明部分没有实现部分。
    </p>
    <p id="uacb97fcb">
     3、派生类对基类虚方法的重写不是必须的，但必须对基类的抽象方法提供实现过程
    </p>
    <p id="u7de45a4b">
    </p>
    <h2 id="ivWCN">
     构造函数和析构函数分别有什么作用，相同点和不同点？
    </h2>
    <p id="u138ef5df">
     构造函数：初始化一个对象的状态
    </p>
    <p id="uaa42ca8d">
     析构函数：用于销毁对象，释放对象占用的系统资源
    </p>
    <p id="u7e2c4ac3">
     <strong>
      相同点：
     </strong>
    </p>
    <p id="uf292d50a">
     1、函数的名称与类名相同
    </p>
    <p id="uf6a416b3">
     2、如果没有自定义该函数时，系统会自动生成一个默认的指定函数
    </p>
    <p id="u264be98d">
     3、都没有返回值
    </p>
    <p id="u3e5ab352">
     <strong>
      不同点：
     </strong>
    </p>
    <p id="u2b867f53">
     1、构造函数可以重载，析构函数不能
    </p>
    <p id="u5fcadd7e">
     2、构造函数可以有访问修饰符、可以是静态的、可以有多个参数，析构函数不能有访问修饰符、不能是静态的、不能包含任何参数
    </p>
    <p id="uc08fbc12">
     3、构造函数可以被显示调用，析构函数由系统自动调用
    </p>
    <p id="u6753f922">
    </p>
    <h2 id="qEr7N">
     C#静态构造函数特点是什么？
    </h2>
    <p id="u22a9c33e">
     与类名相同
    </p>
    <p id="u2a40eb70">
     不能定义访问修饰符
    </p>
    <p id="u9039e976">
     没有参数
    </p>
    <p id="uc20cccd8">
     不能被重载
    </p>
    <p id="uc4653e32">
     只能访问类的静态成员，不能访问实例成员
    </p>
    <p id="udb87cba1">
     一个类只能有一个静态构造函数
    </p>
    <p id="u5126d31b">
     不能显式调用静态构造函数，而是由.NET运行时自动调用。
    </p>
    <p id="ubfd6fcec">
    </p>
    <h2 id="y0e2V">
     C#中有哪些值类型和引用类型？
    </h2>
    <p id="u643967f1">
     值类型：整型、实数型、字符型 、布尔类型、枚举类型、结构类型
    </p>
    <p id="ub898897c">
     引用类型：类 、接口、委托、数组、 字符串、对象类型
    </p>
    <p id="u2974da2d">
    </p>
    <h2 id="PF8Q4">
     抽象类和接口的区别
    </h2>
    <p id="ufde04d9c">
     <strong>
      相同点
     </strong>
    </p>
    <p id="ub4b9ea2c">
     1、都可以被继承，派生类必须实现抽象方法和接口中声明的方法
    </p>
    <p id="u7bd1d7f6">
     2、都不能被实例化
    </p>
    <p id="u1dbd62fb">
     <strong>
      不同点
     </strong>
    </p>
    <p id="uf5318c5a">
     1、抽象类用abstract关键字修饰，接口用interface关键字修饰
    </p>
    <p id="uda113d1c">
     2、一个类可以继承多个接口、但是只能继承一个抽象类
    </p>
    <p id="u80211225">
     3、实现抽象方法时需要使用override关键字，实现接口成员时不能使用override.
    </p>
    <p id="u38a5db8f">
     4、接口只能包含不实现的接口成员，抽象类除了可以包含抽象方法之外，还可以包含数据成员以及完全实现的方法和属性。
    </p>
    <p id="uc3881a91">
     5、抽象类可以有构造方法，接口不能有构造方法
    </p>
    <p>
    </p>
    <h2 id="JoV68" style="background-color:transparent">
     类和结构的区别？
    </h2>
    <p id="u0215c384">
     <strong>
      相同点
     </strong>
    </p>
    <p id="u180cffb7">
     都可以用来实现封装
    </p>
    <p id="u0eb0ea15">
     <strong>
      不同点
     </strong>
    </p>
    <p id="u74817da6">
     1、类是用class 关键字来修饰，结构是用struct关键字来修饰
    </p>
    <p id="ucf3e9573">
     2、类是引用类型，结构是值类型
    </p>
    <p id="u9e184eae">
     3、类支持继承，结构不支持继承
    </p>
    <p id="u966a8c2e">
     4、结构体成员不能使用protected访问修饰符，而类可以
    </p>
    <p id="u5b32d158">
     5、结构体需要在构造函数中初始化所有成员变量，而类随意
    </p>
    <p id="u025084b9">
     6、结构体不能被static关键字修饰，而类可以
    </p>
    <p>
    </p>
    <h2 id="M3bKs">
     new关键字的作用
    </h2>
    <p id="u87bc04fe">
     可以用作运算符、约束、修饰符
    </p>
    <p id="u07eb1a89">
     1、运算符：用于创建对象和调用构造函数
    </p>
    <p id="u1b2fc2f7">
     2、修饰符：可以显式隐藏从基类继承的成员（变量、属性、函数）
    </p>
    <p id="u1182a8bc">
     3、约束：用于在泛型声明中约束可能用作类型参数的参数类型。
    </p>
    <p id="ubf90e243">
    </p>
    <h2 id="G7c23">
     i++和++i有什么区别？
    </h2>
    <p id="ud8fb0357">
     i++称为后置运算，表示先使用变量的值再进行自增；
    </p>
    <p id="ue980f7a2">
     ++i称为前置运算，表示先进行自增再使用变量的值
    </p>
    <p id="u464ef112">
    </p>
    <h2 id="gtj19">
     介绍一下重载和重写，它们的区别是什么？
    </h2>
    <p id="uc68d66d6">
     重载：在一个中有多个相同名称的方法，它们的具有不同的签名（即参数列表有不同的参数类型或者不同的参数个数），一般它们实现的功能也不一样
    </p>
    <p id="u94484649">
     重写：重写在继承时发生，在派生类中重新定义基类中的方法
    </p>
    <p id="uf8a6d184">
     区别：
    </p>
    <p id="u5cd0ff49">
     1、重载发生同一个类中，重写在继承时发生，在派生类中实现
    </p>
    <p id="u0c627972">
     2、重载方法的参数列表必须不同，返回值可不同。重写方法和基类方法的名称、返回值类型、参数列表都必须完全一致。
    </p>
    <p id="u5410955d">
     3、重载是编译时多态；重写时运行时多态
    </p>
    <p id="u5cb632fa">
    </p>
    <h2 id="hkgKR">
     foreach与for的区别
    </h2>
    <p id="u395066d8">
     1、使用for遍历时可以对集合的数据进行修改，使用foreach只能对数据进行读取不能修改
    </p>
    <p id="ubc4ef069">
     2、在循环次数未知或只需读取数据的情况下使用foreach,在需要对数据进行修改时使用for
    </p>
    <p id="u0179a348">
    </p>
    <h2>
     Math.Round
    </h2>
    <p id="p16YN" style="background-color:transparent">
     Math.Round(11.5)等于多少? Math.Round(-11.5)等于多少?
    </p>
    <p id="u2b114110">
     Math.Round(11.5)=12
    </p>
    <p id="uc850ed96">
     Math.Round(-11.5)=-12
    </p>
    <p id="u768c354c">
    </p>
    <h2 id="fqoti">
     用sealed修饰的类有什么特点？
    </h2>
    <p id="ufe5395cd">
     1、用Sealed关键字修饰的类是密封类
    </p>
    <p id="u3cf9568e">
     2、密封类不能被其他类继承但可以继承其他类或接口
    </p>
    <p id="u846564a7">
     3、密封类中不能声明虚方法
    </p>
    <p id="u473944fb">
     4、密封类不能声明为抽象的
    </p>
    <p id="u198f33dd">
    </p>
    <h2 id="p6cG3">
     C#如何实现变长参数？
    </h2>
    <p id="ue047ca73">
     使用params关键字声明的数组型参数来实现
    </p>
    <p id="u010bb6b1">
    </p>
    <h2 id="hkDh6">
     base关键字和this关键字
    </h2>
    <p id="uf515f15c">
     this关键字表示当前类的对象
    </p>
    <p id="ub432917f">
     base关键字表示基类
    </p>
    <p id="uf70256c4">
     <a href="https://blog.csdn.net/wrs120/article/details/53667362" title="C#中this与base的区别_this base-CSDN博客">
      C#中this与base的区别_this base-CSDN博客
     </a>
    </p>
    <p id="ue9122f92">
    </p>
    <h2 id="iLB3N">
     C#中值传递与引用传递的区别是什么？
    </h2>
    <p id="u24eb7d0c">
     值传递：调用方传递给形参的只是实参数据的一个副本，形参发生更改不会影响实参的值
    </p>
    <p id="ud9d1cf7a">
     引用传递：调用方将实参变量的引用传递给形参，实参变量的引用代表数据值的内存地址，形参和实参指向同一个引用。形参的发生更改时，实参的值也会发生更改。
    </p>
    <p id="udeb3a90f">
    </p>
    <h2 id="e9e15">
     值类型和引用类型的区别是什么？
    </h2>
    <p id="u6811e474">
     内存区域上的区别
    </p>
    <p id="u356c5cd0">
     值类型：数据存储在栈上，超出作用域就自动清理
    </p>
    <p id="u176481aa">
     引用类型：一个具有引用类型的数据并不驻留在栈内存中，而是存储于堆内存中。在堆内存中分配内存空间直接存储所包含的值，而在栈内存中存放定位到存储具体值的索引位置编号。当访问一个具有引用类型的数据时，需要到栈内存中检查变量的内容，而该内容指向堆中的一个实际数据。
    </p>
    <p id="u470eae32">
    </p>
    <h2 id="uhLHH">
     ref 和out 的区别
    </h2>
    <p id="u294d7ccd">
     <strong>
      相同点：
     </strong>
    </p>
    <p id="u34b45aa6">
     都可以实现方法返回多个数据的效果
    </p>
    <p id="u775b9ffc">
     <strong>
      不同点：
     </strong>
    </p>
    <p id="u86511f03">
     1、使用ref关键字修饰的参数称为引用型参数，而out关键字修饰的参数被称为输出型参数
    </p>
    <p id="u7661f2d8">
     2、用ref传入的参数需要先初始化，而用out传入的参数不用初始化
    </p>
    <p id="u89ec6d97">
     3、用out传入的参数需要在方法内部赋值，而用ref传入的参数不需要
    </p>
    <p>
    </p>
    <h2 id="nuKsO">
     C#如何实现多返回
    </h2>
    <p id="u5de46715">
     使用ref关键字来声明多个引用型参数来实现
    </p>
    <p id="ub08045b8">
     使用out关键字来声明多个输出型参数来实现
    </p>
    <p id="u5c54ed8f">
    </p>
    <h2 id="vMiX1">
     属性的作用？
    </h2>
    <p id="ue4e8a661">
     1、属性是对变量的一种封装，通过设置对变量读写的属性来控制对字段的访问，保证了数据的封装性
    </p>
    <p id="u39de39ce">
     2、在对需要与外界交互的字段，开放权限，保证了灵活性
    </p>
    <p id="u5505f1b1">
     3、可以在属性内部添加像方法一样处理逻辑和运算
    </p>
    <p id="ufe963985">
    </p>
    <h2>
     字符串声明
    </h2>
    <p id="cuiNA">
     字符串中string str=null和string str=""和string str=string.Empty的区别
    </p>
    <p id="u396e3187">
     string.Empty 相当于"",Empty 是一个静态只读的字段。
    </p>
    <p id="u882d84d6">
     string str="" , 初始化对象，并分配一个空字符串的内存空间
    </p>
    <p id="u50db4dad">
     string str=null, 初始化对象，不会分配内存空间
    </p>
    <p id="uf3645271">
    </p>
    <h2 id="H2rDD">
     Array(数组)、ArrayList(动态数组)和List（列表)的区别？
    </h2>
    <p id="u535b6b0b">
     <strong>
      1、容量大小
     </strong>
    </p>
    <p id="u17e4c670">
     Array的容量在创建时被确定，之后不能改变。
    </p>
    <p id="u77fb1cd7">
     ArrayList和List的容量大小根据存储元素的多少进行自动调整。
    </p>
    <p id="u258da821">
     <strong>
      2、类型安全
     </strong>
    </p>
    <p id="u80b4042b">
     Array和List是类型安全的，它只能存储一种特定类型的元素
    </p>
    <p id="uf9410b2f">
     ArrayList不是类型安全的，它可以存储object类型的元素。可以将任何类型的对象添加到ArrayList中，编译时不会报错，但可能在运行时引发类型错误。
    </p>
    <p id="u0d276cd1">
     <strong>
      3、维度不同
     </strong>
    </p>
    <p id="u04527267">
     数组可以有多个维度，ArrayList和List只有一个维度。
    </p>
    <p id="u27c3b54d">
    </p>
    <h2 id="VG3cR">
     C#中的委托是什么？事件是不是一种委托？
    </h2>
    <p id="u3923787e">
     委托是一种引用类型，它可以将方法作为变量或者参数进行传递。事件是委托类型的变量，是委托的一种特殊形式。
    </p>
    <p id="u60ea8442">
    </p>
    <h2 id="uqgaE">
     简述Func与Action的区别？
    </h2>
    <p id="u4021d2a4">
     Func和Action都是系统预定义的泛型委托，Func 是有返回值的委托， Action 是没有返回值的委托。
    </p>
    <p>
    </p>
    <h2 id="Mh8rW">
     C#字符串的驻留机制，如何解决？
    </h2>
    <p id="u4e1942e8">
     一旦声明一个字符串并赋值，那么对该字符串的操作，系统会额外开辟内存地址存储处理后的新字符串，原来字符串不会发生改变；如果声明一个新的字符串与原来的字符串内容相同，那么该字符串仍然指向原来字符串的地址，不会开辟新的内存空间。
    </p>
    <p id="uf7e61488">
     使用StringBuilder进行字符串的操作，它是对自身对象进行操作，不会生成新的对象。
    </p>
    <p id="ufc7941dd">
    </p>
    <h2 id="eduKC">
     string和StringBuilder的区别,两者性能的比较
    </h2>
    <p id="ue58addd1">
    </p>
    <p>
     <img alt="" class="left" height="254" id="GDrEa" src="https://i-blog.csdnimg.cn/img_convert/bf549aee42fce520060542918fd4b14d.png" width="454"/>
    </p>
    <p id="u57cbc8ce">
    </p>
    <p>
     <img alt="" class="left" height="338" id="D3uX2" src="https://i-blog.csdnimg.cn/img_convert/d4f1e2ade9e9ef426f5fbad635d23e45.png" width="637"/>
    </p>
    <p id="uc2d19b50">
     使用链表，利用链接代替复制
    </p>
    <p id="ubfecd628">
    </p>
    <p class="img-center">
     <img alt="" height="416" id="SMEyM" src="https://i-blog.csdnimg.cn/img_convert/b34dffdae3426e4a9eda0412e2817abc.png" width="808"/>
    </p>
    <p id="ub644d4b1">
    </p>
    <h2 id="ttTM5">
     面向对象三大特性
    </h2>
    <table id="j5eXJ">
     <tbody>
      <tr>
       <td>
       </td>
       <td>
        <p id="ue380f48b">
         封装性
        </p>
       </td>
       <td>
        <p id="u31c9a4da">
         继承性
        </p>
       </td>
       <td>
        <p id="uf6be51f5">
         多态性
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="ub1b60e74">
         定义
        </p>
       </td>
       <td>
        <p id="ub2a9faeb">
         将对象的数据和操作代码组合到同一个结构中.
        </p>
       </td>
       <td>
        <p id="ued35b6c4">
         派生类继承了基类中的类成员。既有继承又有扩展。
        </p>
       </td>
       <td>
        <p id="u74712d23">
         方法具有相同的名称，但是根据不同的情况，方法具有不同的实现方式。
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="uc6ca51dd">
         体现
        </p>
       </td>
       <td>
        <p id="uc63efa4e">
         通过访问修饰符来体现封装
        </p>
       </td>
       <td>
        <p id="ud3136c5a">
         一个类可以继承单个类或者继承多个接口
        </p>
       </td>
       <td>
        <p id="u7035f3f0">
        </p>
        <p id="ua50386f4">
         方法重载
        </p>
        <p id="ue6b539d0">
         方法重写
        </p>
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34343830393933342f:61727469636c652f64657461696c732f313436303134363937" class_="artid" style="display:none">
 </p>
</div>


