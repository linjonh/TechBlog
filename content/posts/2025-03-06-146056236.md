---
layout: post
title: "系统架构设计师数据库基础篇数据库规范化"
date: 2025-03-06 00:17:23 +0800
description: "设R(U)是在属性U上的关系模式，X、Y是U的子集，若对于R(U)的任意一个可能得关系r，r中的任意两个元组在X上的属性值相等，那么在Y上的属性值也相等，则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。关系模式R∈1NF，若对于R的每个非平凡多值依赖X→→Y且Y非⊆X时，X必含有码，则关系模式R(U, F)∈4NF。外键，如果关系模式R中的某些属性集不是R的主键，而是关系模式S的主键，则这个属性集对模式R而言是外键。若关系模式R∈1NF，且每一个非主属性完全依赖主键时，则关系式R是2NF。"
keywords: "系统架构设计师—数据库基础篇—数据库规范化"
categories: ['系统架构设计师']
tags: ['规范化', '范式', '系统架构设计师', '数据库']
artid: "146056236"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146056236
    alt: "系统架构设计师数据库基础篇数据库规范化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146056236
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146056236
cover: https://bing.ee123.net/img/rand?artid=146056236
image: https://bing.ee123.net/img/rand?artid=146056236
img: https://bing.ee123.net/img/rand?artid=146056236
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     系统架构设计师—数据库基础篇—数据库规范化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     函数依赖
    </h2>
    <p>
     设R(U)是在属性U上的关系模式，X、Y是U的子集，若对于R(U)的任意一个可能得关系r，r中的任意两个元组在X上的属性值相等，那么在Y上的属性值也相等，则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。
     <br/>
     X称为这个函数依赖的决定属性组，也称为决定因素。
    </p>
    <h3>
     <a id="1_4">
     </a>
     示例1
    </h3>
    <p>
     关系式：
     <br/>
     S(Sno, Sname, Ssex, Sage, Sdept)
     <br/>
     F={Sno→Sname, Sno→Ssex, Sno→Sage, Sno→Sdept}
     <br/>
     若Y不函数依赖于X，则记为
    </p>
    <pre><code class="prism language-math">X \nrightarrow Y
</code></pre>
    <p>
     例如：
    </p>
    <pre><code class="prism language-math">S_{sex}\nrightarrow S_{age} 
</code></pre>
    <h3>
     <a id="_16">
     </a>
     非平凡函数依赖
    </h3>
    <pre><code class="prism language-math">X \rightarrow Y, Y\nsubseteq X
</code></pre>
    <p>
     称，X→Y是
     <strong>
      非平凡的
     </strong>
     函数依赖。
     <br/>
     如，AB→C。
    </p>
    <h3>
     <a id="_22">
     </a>
     平凡的函数依赖
    </h3>
    <pre><code class="prism language-math">X \rightarrow Y, Y \subseteq X
</code></pre>
    <p>
     称，X→Y是
     <strong>
      平凡的
     </strong>
     函数依赖
     <br/>
     如，AB→B。
    </p>
    <h2>
     <a id="_28">
     </a>
     名词
    </h2>
    <blockquote>
     <p>
      例如有两个关系模式：
      <br/>
      学生（学号、姓名、性别身份证号、教师编号）
      <br/>
      教师（教师编号、姓名、工资）
     </p>
    </blockquote>
    <p>
     超键，在关系中能
     <strong>
      唯一标识
     </strong>
     元组的属性及称为关系模式的超键。
    </p>
    <ul>
     <li>
      一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。
     </li>
     <li>
      例如学生关系模式中的（学号）、（身份证号）、（学号、姓名）、（身份证号、性别）。
     </li>
    </ul>
    <p>
     候选键，
     <strong>
      不含有多余属性
     </strong>
     的超键称为候选键，是超键的最小子集。
    </p>
    <ul>
     <li>
      例如（学号）、（身份证号）、（教师编号）。
     </li>
    </ul>
    <p>
     主键，
     <strong>
      用户挑选
     </strong>
     出来做元组标识的一个候选键称为主键。
    </p>
    <ul>
     <li>
      例如通常选择（学号）作为主键。
     </li>
    </ul>
    <p>
     外键，如果关系模式R中的某些属性集不是R的主键，而是关系模式S的主键，则这个属性集对模式R而言是外键。
    </p>
    <ul>
     <li>
      例如（教师编号）是学生关系模式的外键。
     </li>
    </ul>
    <p>
     主属性，包含在
     <strong>
      任何一个候选键中
     </strong>
     的属性称为主属性，否则称为非主属性。
    </p>
    <h2>
     <a id="_47">
     </a>
     函数依赖关系
    </h2>
    <p>
     建立在非平凡函数依赖的基础上。
     <br/>
     例如：关系式Student（Sno-学号, Sdept-系别, Mname-系主任姓名, Cno-课程号, Grade-成绩）
    </p>
    <table>
     <thead>
      <tr>
       <th>
        名称
       </th>
       <th>
        定义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        完全函数依赖
       </td>
       <td>
        (Sno, Cno)→Grade是完全函数依赖
       </td>
      </tr>
      <tr>
       <td>
        部分函数依赖
       </td>
       <td>
        (Sno, Cno)→Sdept是部分函数依赖
       </td>
      </tr>
      <tr>
       <td>
        传递依赖
       </td>
       <td>
        Sno→Sdept, Sdept→Mname，则称Mname传递依赖于Sno
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="Armstrong_56">
     </a>
     Armstrong公理
    </h2>
    <p>
     从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则，这些规则常被称作“Armstrong公理”。
    </p>
    <p>
     设关系式R(U, F)，U是关系模式R的属性集，F是U上一组函数依赖，则有以下三条推理规则：
    </p>
    <ol>
     <li>
      A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含。
     </li>
     <li>
      A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含。
     </li>
     <li>
      A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。
     </li>
    </ol>
    <p>
     根据上面三条推理规则，又可推出下面三条推理规则。
    </p>
    <ol>
     <li>
      合并规则：若X→Y，X→Z，则X→YZ为F所蕴含。
     </li>
     <li>
      伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含。
     </li>
     <li>
      分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。
     </li>
    </ol>
    <h3>
     <a id="_68">
     </a>
     闭包
    </h3>
    <p>
     针对某几个（A）属性，基于已知依赖关系，通过Armstrong公理，能够推导出全部属性（U）时，则称属性闭包成立。
    </p>
    <pre><code class="prism language-math">(A)^+_F=U
</code></pre>
    <h2>
     <a id="_73">
     </a>
     规范化
    </h2>
    <p>
     范式：符合某一种级别的关系模式的集合。
     <br/>
     关系数据库设计的方法之一就是设计满足适当范式的模式，通常可以通过判断分解后的模式达到几范式来评价模式的规范化程度。
    </p>
    <h3>
     <a id="1NF_76">
     </a>
     第一范式（1NF）
    </h3>
    <p>
     若关系模式R的每一个分量是不可再分的数据项，则关系模式R属于第一范式。
    </p>
    <h3>
     <a id="2NF_78">
     </a>
     第二范式（2NF）
    </h3>
    <p>
     若关系模式R∈1NF，且每一个非主属性完全依赖主键时，则关系式R是2NF。
    </p>
    <blockquote>
     <p>
      优先确认是否存在
      <strong>
       联合主键
      </strong>
      。
      <br/>
      如存在，则考虑是否存在
      <strong>
       部分依赖主键
      </strong>
      的情况。
     </p>
    </blockquote>
    <h3>
     <a id="3NF_83">
     </a>
     第三范式（3NF）
    </h3>
    <p>
     当2NF消除了非主属性对主键的传递函数依赖，则称为第三范式。
    </p>
    <h3>
     <a id="BCBCNF_85">
     </a>
     BC范式（BCNF）
    </h3>
    <p>
     R∈3NF，且消除了
     <strong>
      主属性对码
     </strong>
     的部分和传递函数依赖。
    </p>
    <blockquote>
     <p>
      多个包含多个元素的候选键之间，可能存在主属性对码的部分或传递函数依赖。
     </p>
    </blockquote>
    <h3>
     <a id="4NF_89">
     </a>
     第四范式（4NF）
    </h3>
    <p>
     关系模式R∈1NF，若对于R的每个非平凡多值依赖X→→Y且Y非⊆X时，X必含有码，则关系模式R(U, F)∈4NF。
     <br/>
     4NF是限制关系模式的属性间不允许有非平凡且非函数依赖的多值依赖。
    </p>
    <p>
     注意，如果只考虑函数依赖，关系模式最高的的规范化程度是BCNF；
     <br/>
     如果考虑多值依赖，关系模式最高规范化程度是4NF。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f31383934313731332f:61727469636c652f64657461696c732f313436303536323336" class_="artid" style="display:none">
 </p>
</div>


