---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f4c696e5f4a756d70696e672f:61727469636c652f64657461696c732f313436313633383139"
layout: post
title: "10.OSPF专题"
date: 2025-03-10 20:52:19 +08:00
description: "在 P2P 网络中，只会使用 224.0.0.5 的组播地址在MA 网络中、首先会选举出 DR和 BDR，其他设备为DRother，当 DRother 发送LSA 更新时会向 224.0.0.6 的组播地址发送，224.0.0.6代表发送给网络中的 DR和BDR，当 DR收到LSA 更新时，在以组播地址 224.0.0.5 发送给其他的有的 OSPF 邻居。"
keywords: "10.OSPF专题"
categories: ['Rs']
tags: ['面试', '网络', '智能路由器']
artid: "146163819"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146163819
    alt: "10.OSPF专题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146163819
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146163819
cover: https://bing.ee123.net/img/rand?artid=146163819
image: https://bing.ee123.net/img/rand?artid=146163819
img: https://bing.ee123.net/img/rand?artid=146163819
---

# 10.OSPF专题

## .OSPF 什么情况下使用 224.0.05 和 224.0.0.6 组播地址

* 在 P2P 网络中，只会使用 224.0.0.5 的组播地址
* 在MA 网络中、首先会选举出 DR和 BDR，其他设备为DRother，当 DRother 发送LSA 更新时会向 224.0.0.6 的组播地址发送，224.0.0.6代表发送给网络中的 DR和BDR，当 DR收到LSA 更新时，在以组播地址 224.0.0.5 发送给其他的有的 OSPF 邻居。

## OSPF 为什么要划分区域

* **减少资源消耗:**
  OSPF是链路状态路由协议,需要进行数据库的同步。若不划分区域，每个设备都要处理整个网络的链路状态信息，这会大量消耗设备的 CPU、内存等资源。而划分区域后，设备只需处理所在区域内的链路状态信息，减少了区域内LSDB 中链路状态信息的数量，降低了对设备性能的要求，也减轻了设备的负载。
* **降低网络不稳定性:**
  当网络中的链路发生变化时，会触发 OSPF 重新进行路由计算。在未划分区域的情况下，这种变化会导致同一网络内的所有设备都进行路由计算，增加网络的不稳定性。划分区域后，链路变化的影响主要局限在本区域内，区域间通过 3 类或 5 类 LSA来传递其他区域或外部区域的路由信息，从而降低了因链路变化对整个网络的影响。
* **便于网络管理:**
  过划分区域，可以将具有相同功能性或者处于相同地理位置的路由器划分在一个区域内，这样便于网络管理员对网络进行管理和维护，提高了管理效
* **隔离拓扑变化:**
  在 OSPF 的区域边界或 ASBR可以进行路由汇总。区域内的个别条目变化，不会导致其他区的设备需要重新处理聚合路由

* **区域划分:**

  + 从逻辑上将路由器划分为不同的组，每个组用区域号（Area ID）来标识
  + 区域的边界是路由器，而不是链路。一个路由器可以属于不同的区域，但是一个网段（链路）只能属于一个区域
* **骨干区域:**
  Area0

  + 骨干区域负责区域之间的路由，非骨干区域之间的路由信息必须通过骨干区域来转发
  + 所有非骨干区域必须与骨干区域保持连通
  + 骨干区域自身也必须保持连通

## OSPF 的邻接建立过程(状态机)

![image-20250311095351990](https://i-blog.csdnimg.cn/img_convert/7893d68f873a2d06c774ecf61d146ac1.png)

* **Down (关闭)状态:**
  刚启动OSPF进程，还未收到邻居的任何信息(稳定状态)
* (可以跳过)
  **Attempt (尝试)状态:**
  只发生在
  **NBMA 网络中**
  ，使用单播更新，发出了单播Hello包，但未收到对方的单播Hello包
* **Init (初始化)状态:**
  收到了对方的 Hello 包,且 Helo 包中邻居字段未包含自己的 Router id。意味着自己发现了对方，但对方还未发现自己
* **2-Way (邻居)状态:**
  收到了对方的 Hello 包，且 Hello 包中包含了自己的 Router-id.意味着自己发现了对方，且对方也发现了自己，形成邻居关系;并选举出了DR/BDR角色
* **Exstant (开始交换)状态:**

  + 第一个DD报文:不传送LSDB摘要,仅用于确认LSDB协商的主从;Master会主导 DD 报文的序列号;Router-id 大的成为 Master,主导序列号;
  + DD报文位置符:

    - DD报文的
      **|**
      位:Init 位，置位1表示是第一个 DD报文
    - DD 报文的
      **M**
      位:More 位，置位1表示还有后续 DD 报文
    - DD报文的
      **MS**
      位:Master位，置位1表示本机为Master
* **Exchange(交换) 状态:**
  通过交互 DD 报文来传递本地 LSDB的所有信息的摘要
* **Loading(读取) 状态:**
  通过 LSR、LSU、LSAck 来进行LSDB 的更新和同步。如果 DD 交互完成后，对方没有自己需要的 LSA,则直接进入 Full 状态
* **Full(邻接) 状态:**
  LSDB 完成同步，最终形成邻接关系;

  + 最终确定DR和BDR的角色;当选举完毕，就算出现一台更高优先级的路由器，也不会替换成新的DR/BDR;需要原DR/BDR失效，或者重置ospf进程才会成为新的DR/BDR

* 三个稳定状态:

  + Down , 2-way , Full
* 三种异常:

  + 不能2-way , 能够extart,exchange但是不能full ,可以full但是学习不到路由

* 2-Way状态的前提

  + Router-id无冲突 -修改Router-id需要重置ospf进程使生效
  + 掩码长度一致(MA网络中 多路访问）
  + 区域ID一致
  + 验证密码一致
  + hello-time/ dead-time 一致
  + 特殊区域类型一致
* Full状态的前提:

  + 两端MTU（最大传输单元）一致; 否则可能邻居状态卡在exstart、exchange

    - OSPF报文不允许分片,导致处理不了报文;hello包小,所以不影响
  + 能够计算路由的前提: 两端网络类型一致,否则邻居状态FULL，但无法学习路由
* 一直处于2-Way的原因:

  + RID冲突
  + 优先级都为0
* 一直处于Exstart/Exchange状态的原因:

  + MTU
  + MA网络RID冲突,冲突的设备会处于Exstart/Exchange状态
* 几个DR/BDR?

  ![image-20250310144351465](https://i-blog.csdnimg.cn/img_convert/36b9925323b7a22f88eaed51ef9ebc49.png)

  + 每个网段独立选举
* R1R2R3可以都划分到区域1,然后没有区域0吗?

  ![image-20250310144644318](https://i-blog.csdnimg.cn/img_convert/bbf8ddd81569e54458a2c2754cd884c1.png)

  + 可以,多区域中才需要骨干区域
* 区域号可以任意吗?

  ![image-20250310144827099](https://i-blog.csdnimg.cn/img_convert/ecd7ac0ec39b4e379cd07a64147d6741.png)

  + R1不能和R3互通,无骨干区域,无ABR,无法交互LSA
* 邻居和邻接的关系?

  + 本质区别:会不会交互LSA
* FULL状态,却没有学习到路由有什么原因?

  + 网络类型不一致
* 我的设备怎么知道对端网络的类型

  + 在hello报文中携带,影响工作模式

## OSPF协议报文

| 类型 | 报文名称 | 报文描述 |
| --- | --- | --- |
| 1 | Hello | 周期性发送,用来发现和维持OSPF邻居关系 |
| 2 | DD(数据库描述) | 用于描述LSDB,携带LSDB中LSA的头部数据(并非完整LSA) |
| 3 | LSR(链路状态请求) | 用于向OSPF邻居请求LSA |
| 4 | LSU(链路状态更新) | 用于向对方发送其所需要的LSA,承载在LSU中泛洪 |
| 5 | LSAck(链路状态确认) | 设备收到LSU后,LSAck用于对接收的LSA进行确认 |

* OSPF报文直接封装为IP报文协议报文，协议号为89。
* OSPF报文结构

  ![image-20250311091950664](https://i-blog.csdnimg.cn/img_convert/219c0fe9e20137ab0f66216a53309011.png)
* OSPF报文头格式

  ![image-20250311092041381](https://i-blog.csdnimg.cn/img_convert/4f694eee3166ed645ab08a09b502659b.png)

  + Version：OSPF的版本号。对于OSPFv2来说，其值为2。
  + **Type：OSPF报文的类型。数值从1到5，分别对应Hello报文、DD报文、LSR报文、LSU报文和LSAck报文。**
  + Packet length：OSPF报文的总长度，包括报文头在内，单位为字节。
  + **Router ID：始发该LSA的路由器的ID。**
  + **Area ID：始发LSA的路由器所在的区域ID**
    。
  + Checksum：对整个报文的校验和
  + AuType：验证类型。可分为不验证、简单（明文）口令验证和MD5验证，其值分别为0、1、2
  + Authentication：其数值根据验证类型而定。当验证类型为0时未作定义，为1时此字段为密码信息，类型为2时此字段包括Key ID、MD5验证数据长度和序列号的信息。
* **Hello报文:**

  + 用于建立和维持邻居关系
  + **Hello报文格式**

    ![image-20250311092254539](https://i-blog.csdnimg.cn/img_convert/97bac7f6aea6c1577b9043eb80c8f711.png)
  + 网络掩码network mask:发送Hello报文的接口所在网络的掩码;掩码不一致不能建立邻居关系
  + hello interval:发送Hello报文的时间间隔,间隔不同不能建立邻居关系

    - 缺省情况: P2P,Broadcast类型的hello间隔为10s;NBMA,P2MP类型的hello间隔为30s
  + 可选项(option):每个比特位用来指示路由器的某个特定OSPF特性
  + Router priority：路由器优先级,默认1;设置为0路由器接口不能成为DR/BDR
  + RouterDeadInterval：失效时间;时间内未收到邻居发来的Hello报文，则认为邻居失效。时间不同,不能建立邻居;缺省情况下为hello time的4倍
  + 指定路由器：指定路由器的接口的IP地址;0.0.0.0代表没有DR或者未选出
  + 备份指定路由器：备份指定路由器的接口的IP地址
  + 邻居Neighbor：邻居路由器的Router ID
* DD报文格式:

  + 数据库描述报文
  + ![image-20250311092713695](https://i-blog.csdnimg.cn/img_convert/d56c63f915330997de3288bd58ac7003.png)
  + Interface MTU:在不分片的情况下，此接口最大可发出的IP报文长度。
  + I(Initial):当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。
  + M(More):当连续发送多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。
  + MS（Master/Slave）：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。
  + DD Sequence Number：DD报文序列号，由Master方规定起始序列号，每发送一个DD报文序列号加1，Slave方使用Master的序列号作为确认。主从双方利用序列号来保证DD报文传输的可靠性和完整性
* LSR报文

  + 链路状态请求;互相交换过DD报文之后，知道对端的路由器有哪些LSA是本地的LSDB所缺少的，这时需要发送LSR报文向对方请求所需的LSA
  + ![image-20250311092948541](https://i-blog.csdnimg.cn/img_convert/15e3b2c033def7f3a1e41b0d4e5f39ae.png)
  + LS type：LSA的类型号。例如Type1表示Router LSA
  + Link State ID：链路状态标识，根据LSA的类型而定
  + Advertising Router：产生此LSA的路由器的Router ID
* LSU报文

  + 向对端路由器发送它所需要的LSA，内容是多条LSA（全部内容）的集合
  + ![image-20250311093122549](https://i-blog.csdnimg.cn/img_convert/fc069db38f323e61fbf3dcdc2aa5ef77.png)
  + Number of LSAs：该报文包含的LSA的数量
  + LSA：该报文包含的LSA
* LSAck报文:

  + LSAck报文用来对接收到的LSU报文进行确认，内容是需要确认的LSA的Header。一个LSAck报文可对多个LSA进行确认。
  + ![image-20250311093223916](https://i-blog.csdnimg.cn/img_convert/d7ed8a5b380a756335a764daafc904e0.png)
  + LSA Headers：该报文包含的LSA头部

## 、OSPF 中 DD 报文的作用，DD 报文中有什么字段

![image-20250311092713695](https://i-blog.csdnimg.cn/img_convert/d56c63f915330997de3288bd58ac7003.png)

* DD 报文称为数据库摘要消息，可以用来完成数据库的同步，以及在同步数据 库之前通过交互 DD 报文来进行主从关系的协商
* DD 报文进行主从关系协商时携带的字段

  + Interface MTU:在不分片的情况下，此接口最大可发出的IP报文长度。
  + I(Initial):当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。
  + M(More):当连续发送多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。
  + MS（Master/Slave）：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。
  + DD Sequence Number：DD报文序列号，由Master方规定起始序列号，每发送一个DD报文序列号加1，Slave方使用Master的序列号作为确认。主从双方利用序列号来保证DD报文传输的可靠性和完整性

## OSPF Hello报文中包含的内容

![image-20250311092254539](https://i-blog.csdnimg.cn/img_convert/97bac7f6aea6c1577b9043eb80c8f711.png)

* 包含两部分，一个是 OSPF 的 Header(报头)，另一个是 OSPF 的 hello Packet(数据包)
* OSPF Header 包含的内容有:报头

  + 版本，有V2和V3，并且两个版本不兼容
  + 消息类型，hello 报文的消息类型为1
  + 报文长度
  + OSPF 的Router-lD
  + 区域 ID
  + 验证类型:无认证验证类型为0，明文验证类型为1，MD5验证类型为2
  + 验证数据
* OSPF Hello Packet 包含的内容有:

  + 网络掩码:在 MA 网络，接口的子网掩码不一致会导致邻居无法正常建立
  + Option 字段

    - DN 比特位，在 MPLS VPN 用来防环的
    - 特殊区域的标识:是否支持 NSSA，是否支持外部路由计算等
  + 路由器优先级:在 MA网络中用来选举 DR/BDR 的，如果路由器优先级为0，则表示不参与 DR/BDR 的选举。
  + 失效间隔:默认 40s，失效间隔不一致会影响 OSPF 的邻居建立
  + DR/BDR 信息:在 MA 网络发送的 hello 报文才携带
* 串行接口与以太网接口 OSPF Hello 报文的区别

  + OSPF Header 与以太网接口的一致
  + OSPF Hello packet 与以太网接口的一致，在 P2P 网络掩码不一致，不会影响邻居的建立，但是要保证邻居地址可达，在P2P 网络中的路由器优先级没有特殊含义

## OSPF引入外部路由时 type-1和 type-2 的区别

* OSPF将路由分为4类,优先级从高到低的顺序依次为：

  + 区域内路由（Intra Area）
  + 区域间路由（Inter Area）
  + 第一类外部路由（Type1 External）
  + 第二类外部路由（Type2 External）
* 区域内和区域间路由描述的是AS内部的网络结构，外部路由则描述了应该如何选择到AS以外目的地址的路由。
* 外部路由分为两类:

  + 第一类外部路由：这类路由的可信程度较高，并且和OSPF自身路由的开销具有可比性，所以到第一类外部路由的开销等于本路由器到相应的ASBR的开销与ASBR到该路由目的地址的开销之和。
  + 第二类外部路由：这类路由的可信度比较低，所以OSPF协议认为从ASBR到自治系统之外的开销远远大于在自治系统之内到达ASBR的开销。即到第二类外部路由的开销等于ASBR到该路由目的地址的开销。如果计算出开销值相等的两条路由，再考虑本路由器到相应的ASBR的开销。
  + OSPF引入外部路由时，默认是Type-2，可以通过命令将类型修改为 Type-1

## 影响OSPF邻居建立的因素

(邻接也差不多一样)

* 双方 Router-id有冲突，如何检测 Router-1D 是否冲突，通过 hello 报文来实现
* Area ID 不一致,只有处于相同 Area ID 的路由器才能建立邻居关系。
* 验证类型及口令不一致
* 网络类型不一致(一方是 NBMA,另一方不是 NBMA 则邻接无法建立，其他情况的网络类型不一致邻接能够建立，但无法计算路由)可能原因
* Option 字段不一致(区域类型不一致:Stub/TotallyStub与NSSATotay NSSA无法建立邻接关系)可以先不说
* 接口 MTU 不一致，默认情况华三和华为设备不会对接口的 MTU 做检测，需要单独通过命令去开启，接口的 MTU不一致，会卡在 exstart/exchange 状态
* NBMA 没有手动指定 Peer,NBMÁ 网络类型是无法发送组播和广播包的
* Hello/Dead 时间不一致
* MA 网络中掩码不一致，即不是同一网段
* 接口被设置为静默接口
* ACL的过滤，过滤讯协议号 89
* 对于有从地址的接口，没有都使用主地址进行邻居建立
* 接口没有正确通告
* 通过什么命令可以较快速定位影响 OSPF 邻居建立的原因

  + 可以通过使用 display ospf statistics error 命令

## OSPF 邻接 Full 后，哪些情况路由会有问题

* 非邻居的 Router-id 冲突，会导致 SPF 的重复计算，同一个区域内不相邻设备的 RID 冲突，或者不同区域内设备的 RID 与其他区域 ASBR 的 RID 冲突，都会SPF 的重复计算;
* 网络类型不匹配(修改 Hello 时间等参数可建立邻接关系)
* 链路的网络类型一端是 P2P，一端是 MA 网络，邻居可以正常建立，也可以进入 Full，为什么无法正常学习路由?

  + 在 MA 网络，链路类型为 TransNet(传输网络),通常需要选举DR/BDR来优化LSA泛洪过程,允许存在多个邻居
  + 在 P2P 网络，链路类型为 StubNet(末梢网络),只连接两个路由器,不需要选举DR和BDR,LSA泛洪简单
  + 因为链路类型不一致，导致无法正常学习路由信息，但是可以正常建立并进入 Full 状态，意味着它们可以互相交换 LSA 并同步链路状态数据库，但在将这些信息转换为路由表项时，由于链路类型的差异，路由器无法正确解析和处理这些信息，导致无法将数据库中的信息添加到路由表中。即 OSPF 数据库中存在，但是无法加表
* 在接收方向进行路由过滤
* 当学习到的外部路由的 FA 地址不是通过区域内或区域间的形式存在时，意味着该 FA 地址在本地路由器的路由表中无法通过 OSPF 内部路由到达。虽然这些外部路由信息会存在于 OSPF 数据库中，但由于无法确定如何到达 FA 地址，路由器无法将这些外部路由添加到本地路由表中。因为没有有效的下一跳信息，路由器无法确定如何转发数据包到这些外部网络，所以只能将这些路由信息保留在数据库中，而不加入路由表。
* 在 MCE场景、因为 OSPF DN 比特的原因，导致数据库存在，但是无法加表;

  当 DN 比特被错误设置或处理时，可能会导致路由器对这些路由信息的理解出现偏差。虽然这些路由信息会存在于 OSPF 数据库中，但由于 DN 比特的问题，路由器可能认为这些路由不可用，从而不将它们添加到本地路由表中。

* FA地址的作用?

  + 解决次优,解决环路
* 什么是DN比特?什么是MCE?

  + DN(Down比特):是 OSPF（开放式最短路径优先）协议中的一个标志位。它主要用于在特定场景下对路由信息进行标记和处理。
  + MCE:多CE设备:在网络架构中，它通常指的是一种部署在用户边缘的网络设备或网络节点架构，用于连接多个不同的网络区域或服务提供商等。

## 同区域内 Router-id 冲突会有什么后果?不同区域 Router-id 冲突会有什么后果)

* Router-id是一个区域内的唯一标识，在同一个区域内相连路由器 Router-id 冲突，会导致邻居建立失败。在同一区域不相连的路由器之间 Router-id 冲突邻居能够建立，但是会导致1类LSA 的序列号一直更新，路由出现问题，下跳不稳定
* 不同区域的Router-id冲突

  + ![image-20250310163609751](https://i-blog.csdnimg.cn/img_convert/66625389b4c5917451e69b06d4ba5c55.png)
  + 如果 R1和 R5 的 Router-ID 冲突，并且在 R1 和 R5 上有一个相同的IP地址宣告进入了 OSPF Area1 和 Area2 中。针对 R1 来说，R1 将该网络宣告进入Area1 中之后，生成了一类的 LSA,然后被 ABR R2 转换成3类传递到 Area0中，这时令3类 LSA 的 Router ID 被改成 ABR 的 Router-ID;同理，R5 上的网络也会被传递到 R3 上。由于 LSA 类型和开销相同，并且网络的地址一样,故ABR 上会有两条负载的路由去往该网络，但是下一跳不同。
  + 如果 R1 和 R5 的 Router ID 冲突，在 R1 和 R5 上同时引入相同的外部路由信息。结果是在R3 上同样会出现负载分担的现象。在 OSPF LSDB 中，R3上关于 R1 和 R5 的5类LSA 的 Sequence Number 一直在增加，导致去往R1 和 R5 的网络的路由表异常。
* ![image-20250310182827477](https://i-blog.csdnimg.cn/img_convert/c298dfa828bc5322d3c173e3c68135d8.png)
* ![image-20250310183148181](https://i-blog.csdnimg.cn/img_convert/fd3a16bc3d5e4646c1827331604a9dd6.png)

* RID冲突的影响:

  + 直连,同区域非直连,不同区域
* MA网络中的RID冲突

  + 冲突的设备卡在Extart,exchange

## LSA 的类型和作用

* | **LSA类型** | **名称** | **始发者** | **描述内容** | **传播范围** |
  | --- | --- | --- | --- | --- |
  | **Type-1** | **Router LSA (路由LSA)** | **每个路由器都会产生** | **路由器的链路状态和开销** | **在发布路由器所在的区域内传播** |
  | **Type-2** | **Network LSA (网段LSA)** | **DR产生** | **本网段的链路状态** | **在DR所属的区域内传播** |
  | **Type-3** | **Summary LSA(网络汇总LSA)** | **ABR产生** | **区域内某个网段的路由** | **通告给发布或接收此LSA的非Totally STUB或 NSSA区域** |
  | **Type-4** | **Asbr-summary (ASBR汇总LSA)** | **ABR产生** | **到ASBR的路由** | **通告给除ASBR所在区域的其他区域** |
  | **Type-5** | **AS-extenal LSA (外部LSA)** | **ASBR产生** | **到AS外部的路由** | **通告到所有区域(除了STUB区域和NSSA区域)** |
  | **Type-7** | **NSSA LSA（次末结区域 LSA）** | **ASBR产生** | **到AS外部的路由** | **仅在NSSA区域内传播** |
* 一个路由器产生几个一类LSA

  + 在每个区域内,每个OSPF,每个OSPF进程路由器只会产生一个一类LSA
* P2P无二类LSA

## LSA 的泛洪机制、泛洪周期、LSA 的标识方法、LSA 如何判断新旧

* LSA 的泛洪是除了接收端口外，向其他所有运行了 OSPF 接口泛洪。泛洪周期为 1800 秒，老化时间为 3600 秒，所有的 OSPF 路由器每1800秒把自己 LSDB中所有的 LSA 向外泛洪。(当收到 3600秒的 LSA,则直接删除数据库中对应的LSA)可以不提;
* OSPF 中通过三要素标识一条LSA:LSA 的 Type,Link state lD,ADV router
* OSPF通过序列号,checksum,Age time来判断LSA的新旧

  + 序列号最小为80000001,最大为7ffffffff序列号越大代表LSA越新
  + Age time越小越新

## 特殊区域的特征和适用场景

* 要点:

  + 每种区域哪些LSA进不来;
  + 缺省路由怎么产生的;
  + 区域中是否存在ASBR引入外部路由;
  + 特殊区域存在多个ABR会由更大的RID做7转5
* |  | Type-1 | Type-2 | Type-3 | Type-4 | Type-5 | Type-7 |
  | --- | --- | --- | --- | --- | --- | --- |
  | 常规区域 | √ | √ | √ | √ | √ | X |
  | Stub区域 | √ | √ | √ | X | X | X |
  | Totally stub区域 | √ | √ | X | X | X | X |
  | NSSA | √ | √ | √ | X | X | √ |
  | Totally NSSA | √ | √ | X | X | X | √ |
* ![image-20250311192614196](https://i-blog.csdnimg.cn/img_convert/429c04c42c0b7edfb69cbdb692616eb3.png)

  + Totally Stub区域：允许ABR发布的Type3缺省路由，不允许自治系统外部路由和区域间的路由；
  + Stub区域：和Totally Stub区域不同在于该区域允许区域间路由；
  + NSSA区域：和Stub区域不同在于该区域允许自治系统外部路由的引入，由ASBR发布Type7 LSA通告给本区域；
  + Totally NSSA区域：和NSSA区域不同在于该区域不允许区域间路由。
* **STUB区域:末梢区域:**

  + 特征:

    - 不允许Type-4 和Type-5 LSA 注入(不接受自治系统外部路由),由 ABR 自动下发一条 Type-3 的缺省路由到区域内,区域内的路由器依靠缺省路由访问 OSPF 外部网络。
    - Stub区域路由器需要对Stub属性由一致性认知(区域中的所有路由器必须都要配置stub命令)
  + 适用:非0常规区域只有单一的出口;区域中路由器性能较低,不希望接收大量LSA;区域内路由器不需要根据特定的路由来选择离开区域的出口的场景

    ![image-20250311185439569](https://i-blog.csdnimg.cn/img_convert/f665a7a18da152a9689641641f55c7c7.png)
* **Totally Stub区域: 完全末梢区域**

  + 特征

    - 不允许 Type-3、Type-4 和 Type-5 LSA 注入(不接受自治系统外部路由和区域间路由)，由 ABR 自动下发一条Type-3 的缺省路由到区域内，区域内的路由器依靠缺省路由访问其他区域和 OSPF外部网络。在Stub的基础上,ABR不会将区域间路由信息传递到本区域;除了默认路由外，区域内的路由器只知道本区域的路由信息，不知道其他区域的路由。
    - 不允许出现ASBR;区域0不能被配置为totally stub区域
    - 与stub区域区别:需要在ABR追加no-summary参数
  + 适用场景:

    - 适用于该区域路由器性能较差，不希望接收大量其他区域和引入的外部路由的场景
* **NSSA 区域 非纯末梢区域**

  + 特征:

    - 不允许4类和5类LSA注入,但区域中存在 ASBR 需要引入外部路由。本区域 ASBR 引入的外部路由以 Type-7 LSA 存在
    - 由NSSA区域中Router-id最大的ABR把7类LSA转换成5类LSA再传递至其他区域;
    - 由ABR手工配置下发Type-7的缺省路由,通过协议视图中的 nssadefault-route-advertise 命令来实现
  + 适用于:区域中路由器性能较低,不希望接收大量AS外部路由,但本区域存在ASBR引入外部路由的场景

    ![image-20250311191732833](https://i-blog.csdnimg.cn/img_convert/a67e970b92522fdc9cb12025dbcc0439.png)
* **Totally NSSA 区域:完全非纯末梢区域:**

  + 特征:

    - 不允许 Type-3、Type-4 和 Type-5 LSA注入，但区域中存在 ASBR 需要引入外部路由。
    - 本区域 ASBR 引入的外部路由以 Type-7 LSA 存在，由 NSSA 区域中 Router-id 最大的 ABR 把Type-7 转换为Type-5 再传递至其他区域。
    - 由ABR自动下发Type-3 的缺省路由
  + 适用于:区域中路由器性能比较低,不希望接收大量AS外部和其他区域路由,但本区域存在ASBR引入外部路由的场景

* 如何实现让一台 Route-id 不是最大的 ABR 执行将7类 LSA 转换成5类?

  + 答:可以通过在 OSPF 的区域视图使用 nssa translate-always 来实现，如果本 ABR 执行该命令就会强制执行7 类 LSA 转成5 类 LSA，那么其他 ABR则不执行7类转5类。
* 部署特殊区域的注意事项

  + 所有特殊区域都不允许是骨干区城
  + 所有特殊区域都不允许被虚连接穿越
  + 区域内的所有设备都得设置一致的特殊区域，即同一个区域内的设备，要 设置相同类型的特殊区域
  + Stub 和 Totally Stub 不允许存在 ASBR

## FA 地址的作用及产生条件

* FA地址的主要作用有防止路由环路,以及避免产生次优路径,即用于路径选择
* 在 OSPF 中引人外部路由时，将对应产生Type 5 LSA或 Type 7 LSA。而后续路由器再计算外部路由时需要用到 FA 地址，通过 FA 地址作为前往外部路由的下一跳，如果FA 地址为 0.0.0.0,则 ASBR 就是去往外部路由的下一跳，可以通过4 类 LSA 来获取前往 ASBR 的路径信息，如果 FA 地址非 0、即一个具体的IP 地址，则该IP 地址就是去往外部路由的真实下一跳。 精确计算避免环路,次优
* 5 类 LSA 的 FA 地址默认为 0.0.0.0，若同时满足以下三个条件，将把引入的外部路由的下一跳地址设置为 FA 地址(Type7 LSA 除外，Type7的 FA 地址都是以具体 IP 地址的形式存在):

  + 引入的这条外部路由，其对应的出接口启用了 OSPF
  + 引入的这条外部路由，其对应的出接口未设置为静默接口
  + 引入的这条外部路由，其对应的出接口的 OSPF 网络类型为 broadcast(即非 P2P、P2MP 网络类型)

  在NSSA区域中,执行7类转换成5类LSA时,转换之后产生的5类LSA的FA地址是继承来自7类LSA的FA地址
* Type 5 LSA 中的 FA 地址:

  + 在OSPF引入外部路由时、若产生的Type 5 LSA的FA地址为0000.则其他路由器在计算到达该外部网络时,将考虑如何到达ASBR(即产生该Type5 LSA 的路由器)来计算出外部路由的下一跳地址。
  + 在 OSPF 引入外部路由时，若产生的 Type 5 LSA 的FA地址不为0000,则其他路由器在计算到达该外部网络时，将考虑如何到达该 FA 地址来计算出外部路由的下一跳地址,并且前往该 FA 地址的路由信息必须以 OSPF 区域内或区域间的路由形式存在
* Type7LSA 中的 FA地址:若在NSSA区域引入外部路由，则产生的Type7LSA中其 FA 地址均不为0.具体FA地址等于该 ASBR 上最后启用OSPF 的环回口的IP 地址;若 ASBR 上没有环回口、则FA地址等于最后启用 OSPF 的物理口的 IP地址

## OSPF中的 FA地址如何避免环路

![image-20250310185712370](https://i-blog.csdnimg.cn/img_convert/9ed5926eaeda36203ac3595c2da94637.png)

![image-20250310190149674](https://i-blog.csdnimg.cn/img_convert/a7d06f75e08cc67ba07dd40d2b09a4ea.png)

* 如图所示:区域1为 NSSA 区域，各链路的 cost 如图所示:

  + 在 R1 上把 RIPV2 引入 OSPF,此时 R1 会产生关于 172.16.5.0/24 网段的7 类LSA
  + R2与R3作为Area1的ABR，都有责任进行7转5的动作，但 OSPF 规定默认情况下只有 RID 大的才能进行7转 5，图示中 R2 的 RID 为 10.255.1.2,R3 的RID为 10.255.1.3，R3的RID 更大，所以R3 会进行7转5的动作，由R3 产生关于 172.16.5.0/24 的5类 LSA,并在 Area0 中泛洪。
  + R4从Area0中收到此5类LSA，并泛洪给 R2
  + 我们来分析 R4 如何去往 172.16.5.1，此时会有两种情况
  + 【情况一:R4 收到的这条5类 LSA 中 FA 地址为 0.0.0.0】

    - 此时产生此条5类LSA的是 R3，所以R3为 ASBR，R4 可直接通过 Area0 到达ASBR(R3)。
    - R3 是通过 Area 1 学习到的 172.16.5.0/24 网段，所以 R3 可通过 Area 1 去往172.16.5.1，即把数据包发送给 R2。
    - 此时 R2 可通过两条 LSA 学习到 172.16.50/24 的路由

      * 第一条:R1产生的7类SA。类型为Type2，外部Cost 为1(外部 cost 默认都为 1)，内部 cost为 1562(内部 cost本路由器到 ASBR 的 cost,R1 和 R2 之间的互联链路位串行接口，开销为1562)
      * 第二条:R3产生的5类LSA，由 R4 泛洪给 R2(参考上面第二步)，类型为Type2,外部 Cost 为1 内部 cost 为 2(R2-R4-R3 的 cost)
      * R2 执行选路规则，两条 LSA 同为ype2 类型，先对比外部 cost 值，都为 1.然后对比内部 cost 值。第一条为 1562，第二条为 2，所以 R2 会优选第二条(R3产生的5类LSA)，即会把数据包转发给 R4。
      * 环路形成:R4-R3-R2-R4
  + 【情况二:R4 收到的这条5类 LSA 中 FA 地址为 10.255.1.1(R1 的 Loopback 接口)】

    - 根据 OSPF 外部路由的选路规则，当5类 LSA 中 FA地址为非0时，直接计算去往 FA 地址的路径。
    - 在此图中 R4 收到的5类 LSA 中 FA 地址为 10.255.1.1、关于 10.255.1.1 这个地址、R4是通过 3类 LSA 学习到的(10.255.1.1 位于 Area1中，R2与R3都为ABR,都会产生关于10.255.1.1/32网段的3类LSA),R4此时其实可以收到两条10.255.1.1/32的3类LSA,一条R2产生,一条R3产生,通过计算cost后发现,选择去往10.255.1.1更近,所以R4会把数据包转发给R2
    - R2 同样执行选路计算，计算去往FA 地址 10.255.1.1 的路径，R2 和 1 在同一个区域，所以 R2 会把数据包转发给 R1。
    - 此时全程的路径为:R4-R2-R1，解决了环路问题
  + 总结:OSPF 针对外部路由可以通过FA 地址来防环,7类LSA 中一般情况下都会携带 FA 地址，在执行7转5后 FA 地址会默认保留、所以在默认情况下面不会出现环路问题 如果我们在做7转5时把FA地址抵制了,就有可能出现上述的环路问题。

## 如何减小 OSPF 路田器中LSDB的大小

* **分区域设计**
  :因为1,2类LSA只在本区域泛洪，分区域设计可以减少每个区域1、2类 LSA 的数量
* **特殊区域:**
  特殊区域无法传递5类或3类LSA,可以减少 OSPF 中 LSA 的数量
* **过滤:**
  通过在 ABR 上对 3类 LSA 的过滤，可以减少某一区域中3类 LSA 的数量;在 ASBR 上路由引入时，可以对引入的路由进行过滤,来减少 OSPF 中5类LSA 的数量
* **路由聚合:**
  在 ABR 上对 3类 LSA 进行聚合,可以把多条3类 LSA 汇聚为1条,并可以通过聚合来进行 3类 LSA的过滤

## OSPF 路由选择的原则

* 区域内路由>区域间路由>Type1 外部路由>Type2 外部路由
* 路由类型一致则对比 Cost,小的优先。Cost 也一致则形成等价路由

## OSPF 路由聚合的方法

* OSPF只能手动聚合;
* **ABR聚合:**

  + 把一个区域的LSA聚合后发布到相邻区域
  + 在传入区域的区域视图配置
  + 只能对Type-3类的LSA进行聚合
  + ABR聚合不会影响ABR本机的路由，只会影响相邻区域的下游路由器的路由
  + ABR聚合后，会在ABR本机上产生一条该聚合的黑洞路由，来防止环路出现
* **ASBR聚合:**

  + 把引入的AS外部路由聚合后发布到OSPF内部
  + 在协议视图配置
  + 只能对Type-5、Type-7LSA的路由进行聚合
  + ASBR聚合不会影响ASBR本机的路由，只会影响OSPF内部的其他路由器
  + ASBR聚合后，会在ASBR本机上产生一条聚合的黑洞路由，来防止环路出现
* 使用聚合实现路由过滤:在聚合后加入not-advertise参数

## OSPF 路由过滤的方法

* **针对计算出的路由进行过滤:**
  在OSPF的进程上使用 Filter-policy 进行路由过滤。由于 OSPF 邻居之间传递的是 LSA,路由是每台路由器自行计算的，所以该过滤方法只影响本机的路由，而不影响任何其他邻居。该方法只能使用在入方向(Import)
* **针对3类LSA进行过滤:**
  在OSPF区域进程中使用Filter进行3类LSA的过滤,可以应用在import或export方向进行过滤,由于OSPF邻居之间传递的是LSA,所以该过滤方法会影响出方向的所有其他邻居;1类和2类LSA无法过滤;因为SPF算法的前提是区域内的1类和2类LSA要同步;如果在某些路由器上被过滤的话，会导致 OSPF 无法计算路由。
* OSPF接口上的过滤,在启用OSPF的接口上使用ospf database-filter进行过滤

  + AI:过滤所有的LSA
  + Ase:过滤5类LSA
  + Nssa:过滤7类LSA
  + Summary: 过滤3类 LSA
* 针对发送给特定邻居的 LSA 进行过滤

  + 在 OSPF 视图使用 database-filter peer x.x.xx来实现
  + all:对发送给接口的网络类型为 P2MP 的邻居的所有LSA 进行过滤(除了Grace LSA) 。
  + ase:对发送给接口的网络类型为 P2MP 的邻居的 Type-5 LSA 进行过滤
  + nssa:对发送给接口的网络类型为P2MP 的邻居的Type-7 LSA 进行过滤
  + summary:对发送给接口的网络类型为 P2MP 的邻居的 Type-3 LSA 进行过 滤。
* ![image-20250310193239709](https://i-blog.csdnimg.cn/img_convert/f9313b93a95279dffc881639c44e4c41.png)
* ![image-20250310193509702](https://i-blog.csdnimg.cn/img_convert/c288c1290de92207b299fba6f8553dda.png)

  + **本地标识**
    ：OSPF 进程号只是在路由器本地起到标识进程的作用，用于区分同一台路由器上可能运行的多个 OSPF 进程。它在本地设备上用于管理和区分不同的 OSPF 配置和路由计算等操作，并不具有全局唯一性，也不会在网络中进行传播。

## OSPF 中静默接口和 RIP 中静默接口的区别

* RIP:sient-interface在RIP 里只会阻止接口对外发送更新消息,但是仍然接收更新消息。如果一个接口被抑制，该接口所在网段的直连路由仍然可以发布给其它接口
* OSPF 如果要使 OSPF 路由信息不被其他网络中的路由器获得,并且使本地路由器不接收网络中其他路由器发布的路由更新信息，可使用 Silent-interface 命令禁止此接口接收和发送 OSPF 报文。禁止接口收发 OSPF报文后，该接口的直连路由仍可以发布出去，但接口的 Hello 报文将被阻塞，接口上无法建立邻居关系。这样可以增强 OSPF 的组网适应能力，减少系统资源的消耗

## OSPF 多实例和多进程的区别

* OSPF 多进程是指在一台会层设备上运行多个OSPF进程，每个OSPF 进程维护自己的一个.OSPF LSDB数据库，并计算维护自己的 OSPF 路由表,每个进程之间并没有什么关系，类似是在本路由器上运行的多个动态路由协议，多个进程共同维护一张全局路由表，并在全局路由表中优选各进程的 OSPF路由;
* OSPF多实例是将不同的进程和不同的VPN实例绑定,每个OSPF进程维护自己的一条VPN路由表,OSPF多实例主要应用于MCE的场景

## OSPF 的验证方式和优先顺序

* OSPF支持接口验证和区域验证
* 当开启区域认证的时候，也就意味着所有属于该区域的接口收发的 OSPF 协议消息都需要包含认证相关字段
* 当开启接口验证时，就只有该接口收发的OSPF协议消息需要包含认证相关字段。相比之下，接口验证更加灵活
* 当同时配置了接口验证和区域验证时，接口验证优先于区域验证。如果接口验证成功了，区域验证是否成功都可以建立起邻居关系
* OSPF 的验证信息是在 OSPF 头部中携带的,所以每个 OSPF 报文都包含验证信息

* MD5和明文验证的区别

## 虚连接的作用

* 虚连接的主要作用有两个

  + **修复骨干区域不连续、或非骨干区域没有与骨干区域连续的问题**
  + **在特殊场景下，可以通过虚连接来解决路径次优问题**
  + 虚连接虚是指在两合ABR之间，穿过一个非骨干区域，建立的一条逻辑上的连接通道,可以理解为两台 ABR 之间存在一个点对点的邻接关系
  + 虚连接可以用于解决骨干区域被分割的问题。当骨干区域物理上被分割，可以使用虚连接让2个ABR仍然保持逻辑上的连通，而保持完整的骨干区域
  + 虚连接可以用于解决某个非骨干区域无法和骨干区域相连的问题
  + 虚连接可以用于解决两个非骨干区域之间的路由一定要经过骨干区域而导致的次优路径问题
  + 虚连接是在相邻的 ABR 之间，基于 RÍD 建立的，在 OSPF 的区域视图中使用命令vlink-peer x.x.x.x来实现

    ![image-20250310193913497](https://i-blog.csdnimg.cn/img_convert/d9e0580f2d10ec1dd9895fd797490368.png)

## OSPF 的防环机制

* 首先从区域架构设针上来避免环路，OSPF要求所有的非骨干区域与骨干区域连接，非骨干区域之间互访必须通过骨干区域来实现，构成一个星型环境，从网络设计来来避免环路
* Type-1 LSA及Type-2 LSA 的防环

  + 区域内泛洪的Type-1 LSA 及 Type-2 LSA,还原区域内的网络拓扑及网段信息。路由器为每个区域维护一个独立的LSDB,并且运行一套独立的 SPF 算法,同一个区域内的路由器,拥有针对该区域的相同LSDB,都基于这个LSDB计算出一颗以自己为根的、无环的最短路径树。
* Type-3 LSA及 Type-4 LSA 的防环

  + OSPF要求所有的非骨干区域必须与骨干区域直接相连，区域间路由需经由骨干区域中转。这个要求使得区域间的路由传递不能发生在两个非骨子的区域之间，这在很大程度上规避了区域间路由环路的发生,也使得 OSPF的区域架构在逻辑上形成了一个类似星型的拓扑。
  + ABR 只能够将从 Type-1 转成的 Type-3 LSA 注入到区域 0;能够将 Type-1转成的 Type-3 和接收到的 Type-3 的LSA 注入进非骨干区域。
  + ABR 不允许根据一条从非骨干区域收到的 Type-3 LSA 计算路由，即不能将来自骨干区域的3类LSA 在传回给骨干区域，类似 OSPF 区域间的水平分割

    ![image-20250310193956006](https://i-blog.csdnimg.cn/img_convert/1ffb1b7e77b3d2c79244ee8164c77c42.png)

    R2和R3规划为骨干区域的缺点

    - 【说明】当 R1 和 R5 之间的链路出现中断时，R5 产生的 LSA1 传给 R3，R3 会将来自 R5 的 LSA1 转换成 LSA3、通过 R3 和 R2 之间的链路传递给 R2,此时 R2依然是 ABR，因为 ABR 不允许根据一条从非骨干区域收到的 Type-3 LSA 计算路由，所以此时 R2 不能根据来自 R3 的 LSA3 进行路由计算。

      * ABR 不会将描述一个取自内部路由信息的 Type-3 LSA 再注入回该区域中。
  + Type-5 LSA 的防环

    - 引入的外部路由以 Type-5 LSA 在整个 OSPF 域内泛洪。一台路由器使用Type-5 LSA 计算出路由的前提是两个，其一是要收到 Type-5 LSA,其二是要知道产生这个 Type-5 LSA 的 ASBR 在哪里。
    - 与 ASBR 接入同一个区域的路由器能够根据该区域内泛洪的Type-1LSA 及Type-2LSA计算出到达该 ASBR 的最短路径，从而计算出外部路由。而其他区域的路由器因为ASBR产生的Type-1 LSA只能在其所在的区域内防洪,所以才需要Type-4 LSA.因此其他区域的路由器在获取Type-4 LSA后便能计算出到达ASBR最短路径,进而利用该ASBR产生的Type-5 LSA计算出外部路由
    - Type-5 LSA 将会被泛洪到整个 OSPF 域，表面上看，它本身并不具有防环的能力、但是实际上,它并不需要，因为它可以依赖 Type-1和3类LSA及Type-4 LSA 来实现防环。
  + Type-7 LSA 的防环

    - Type-7 LSA 只在本区域存在，故依靠Type-1及Type-2 LSA 来实现防环

## OSPF 双塔奇兵问题

* ![image-20250310194030489](https://i-blog.csdnimg.cn/img_convert/0250c3c30aad35a40a90e27d2de56d15.png)

  + OSPF如果某个区域存在两个ABR，并且在两个ABR上都对Area n内的路由做了聚合操作。
  + Loopback0应该属于Area 0还是Area n?
  + 如果骨干区域被分割有何后果?
  + 如果非骨干区域n被分割有何后果?
  + 图中的红线应该属于Area 0还是Area n?
* Loopback0 只宣告进 Area0 或者 AreaN 都不影响 OSPF 正常工作。在早期OSPF 对 ABR 的定义是连接一个骨干区域和一个非骨干区域，且至少在骨干区域有一个存活的接口。按照这个规则，就应该把 Loopback0 口宣告进 Area N,因为如果宣告进 Area0 的话,一旦 R1 和 R3 之间的链路故障,R3 的 Loopback0口由于仍在 Area0 存活、所以 R3 仍然是 ABR。根据 OSPF 防环规则，ABR不会根据一条从非骨干区域接收的 Type 3 LSA 来计算路由，所以会导致 R1 和 R2上的路由从 R4 进入到 AreaN 后,再传递至 R3 时,R3 也无法计算出相关路由,而导致网络故障。而目前 OSPF 对 ABR 的新的定义是连接一个骨干区域和非骨干区域，且至少在骨干区域有一个存活的邻居。根据新规则，就算 R3把Loopback0 口宣告进 Area0,当 R1 和 R3 之间链路故障时，R3 由于在 Area0 没有邻居了，所以自然就不再是 ABR,也就能够根据从非骨干区域接收的 Type 3LSA 来计算路由，不会导致路由丢失
* 如果骨干区域被分割，会导致被分割出来的骨干区域部分各自无法学习到其他被分割的部分的路由，但是不影响非骨干区域路由的学习
* 如果非骨干区域被分割，并不影响区域之间的路由学习。但本题中说到 R3 和R4 都对 AreaN 的路由做了聚合后再发布至 Area0。所以如果 AreaN 被分割的话，会导致 Area0 到达 AreaN 的聚合路由要么是指向 R3,要么是指向 R4,但无法区分到底 R3 可以到达哪些具体的目的网段，R4 可以到达哪些具体的目的网段
* 图中的红线建议宣告进 Area0。这样可以让红线对 Area0 做链路备份，防止骨干区域被分割。AreáN被分割虽然也有问题,但R3 和 R4 之间在 AreaN 中本来就有两条链路可达，已经有备份了。所以宣告进 Area0 更为稳妥

## OSPF 犬牙交错问题

* ![image-20250310194105800](https://i-blog.csdnimg.cn/img_convert/ed9c4a9f1db9c6353c5a7a256c1d70be.png)

  + 有时接入层的设备会以乱序的方式与汇聚层进行连接。OSPF的区域该如何划分?

    - 建议按照每台汇聚层设备与之相连的所有链路接口划分为一个区域

      * 如果所有的汇聚层和接入层设备都划为一个区域则会太大
      * 如果选择两台汇聚层设备加上所有同时与之相连的接入层设备划分为一个区域，则会导致区域太多，并没有规律。而且IP地址规划会非常复杂
    - 按照上述的区域划分方式，接入层设备的接口就按照对接的是哪台汇聚层设备来判断应该划分到哪个区域。那么接入层设备的 Loopback 口应该属于哪个区域?

      * Loopback 口属于任何一个区域都不能达到双上行互为备份的目的。所以这种情况下一般建议把Loopback口运行单独的路由协议或者配置静态路由再引入至 OSPF中

## OSPF 网络类型

* 网络类型的要点:

  + 什么网络默认的类型?
  + 怎么发送协议报文
  + 需不需要选举DR/BDR?
  + Hello time和dead time
* | 网络类型 | 链路层协议 | 是否选举DR | 怎么发送协议报文 | Hello time |
  | --- | --- | --- | --- | --- |
  | Broadcast广播 BMA | 以太网(Ethernet) FDDI(光纤) | 是 | 组播发送;(.5.6) | 10s 40s |
  | NBMA非广播多点可达 | 帧中继,ATM,X.25 FR对点子接口 | 是 | 单播发送;手工指定 | 30s 120s |
  | P2MP点到多点 | 手动指定 | 否 | 模拟组播发送(.5) | 30s 120s |
  | P2P点到点 | PPP,HDLC, FR点对点子接口 | 否 | 组播发送(.5) | 10s 40s |
  | vlink |  | 否 |  | 10a 40s |
* Broadcast 广播网络:

  + 链路层是以太网,FDDI(光纤)默认的网络类型;默认情况下OSPF的网络类型
  + 组播发送发送hello报文和LSAck报文;对于LSU报文通常组播形式首次发送,单播形式进行重传;其中224.0.0.5所有运行OSPF的接口侦听 ; 224.0.0.6DR/BDR侦听;
  + 单播形式发送DD和LSR报文
  + 需要选举DR/BDR
  + hello time 10s ; dead time 40s;
* NBMA 非广播多点可达:

  + 当链路层协议是ATM或FR时,缺省情况下,OSPF认为的网络类型
  + 单播形式发送协议报文,需要手工指定邻居
  + 需要选举DR/BDR
  + hello time 30s ;dead time 120s;
* P2MP 点到多点网络;

  + 没有一种协议会缺省认为是P2MP,必须是其他网络类型强制更改的;(常用将非全连通的NBMA改为点到多点网络)
  + 以组播(224.0.0.5)发送hello报文,以单播形式发送其他协议报文;
  + 不选举DR/BDR
  + hello time 30s dead time 40s
* P2P 点到点网络

  + PPP默认的网络类型
  + 组播(224.0.0.5)发送协议报文,组播形式重传LSU报文
  + 无需进行DR和BDR的选举
  + hello time 10s dead time 40s

## OSPF 缺省路由产生的方式

* 对于普通区域的路由器，缺省路由需要在 ASBR 上通过命令来引入。使用命令default-route-advertise,可以在 ASBR 本身已经具有缺省路由的情况下引入使用命令 default-route-advertise always,在ASBR本身并不具备有缺省路由的情况下引入
* 对于特殊区域,stub区域,Totally stub区域,totally nssa 区域会由ABR自动下发Type3的缺省路由,NSSA区域需要通过手工的方式下发Type7的缺省路由

## OSPFV3 与 OSPFV2 的相同与不同点

* 相同点

  + 相同的 SPF 算法
  + 区域和 Router-id 的概念一致,且 OSPFv3 的 Router-id 格式仍为 IPv4 地址格式
  + 相同的邻居和邻接形成机制
  + 相同的LSA 扩散和老化机制
* 不同点

  + OSPFV2 是基于网段运行的。两个路由器要形成邻居关系,IP 地址必须在同一网段; 而 OSPFv3 的实现是基于链路的。一个链路可以划分为多个子网,节点即使不在同一个子网内，只要在同一链路上就可以。而且 OSPFv3 建立邻居关系是通过链路本地地址，而不是手动配置的IPv6 单播地址
  + OSPFv3 支持在同一链路上运行多个 OSPF 实例，实现链路复用并节约成本。OSPFv3 的报文头部中添加了 Instance ID 的字段来描述本报文属于该链路上的哪一个 OSPF 实例
  + 在 OSPFV2 中，当网络类型为点到点或者通过虚连接与邻居相连时，通过Router ID 来标识邻居路由器，当网络类型为广播或 NBMA 时，通过邻居接口的IP 地址来标识邻居路由器。OSPFv3 取消了这种复杂性，无论对于何种网络类型，都是通过 Router ID 来唯一标识邻居
  + OSPFV3 协议自身不再提供认证功能，而是通过使用IPv6 提供的安全机制来保证自身报文的合法性。所以，OSPFv2 报文中的认证字段，在OSPFv3报文头中被取消
  + OSPFV3 的报文有变化。版本号变更为3;Helo 报文中增加了InstanceID字段，去掉了认证字段
  + OSPFV3 的 LSA 的类型和内容都有变化

## OSPFV3 在 OSPFv2 的基础上,LSA有哪些变化

* LSA 的名称、LSA的类型以及 LSA 携带的内容三个方面比较
* Router-LSA 和Network-LSA 不再描述网段的前缀和前缀长度，只描述路由器接口的链路状态和开销等参数
* 增加了9类LSA,Intra-area-prefix-LSA,用来描述区域内的网段的前缀和前缀长度
* 3 类和 4 类 LSA 只是名称做了修改,分别是 Inter-area-prefix-LSA 和 Inter-router-prefix-LSA
* 新增了8类LSA，Link-LSA,用于在一条链路上描述链路本地地址信息。路由器把当前接口的链路本地地址向该链路上的所有其它路由器通告

## OSPFV3 的配置和 v2 有什么区别

* OSPFv2 可以通过 network 的方式或将接口加入 OSPF 的方式启用 OSPF，在OSPFv3 中取消了network的方式,只能通过将接口加入 OSPF的方式启用 OSPF
* OSPFV2 的一个接口只能加入一个 OSPF 进程,在 OSPFv3 中一个接口可以同时加入到不同的 OSPFv3 的实例中。

## OSPF 骨干区域路由器数量太多怎么解决

* 按照三层模型来规划区域。核心和汇聚之间的网络规划到 Area0，核心的内部网络规划为 Area1,汇聚和接入层规划为另一个非骨干区域

## OSPF 非骨干区域路由器数量太多怎么解决

* 可以把该区域再划分2到3个非骨干区域,在ASBR上配置路由聚合来缩小路由表规模

## OSPF4级网络结构怎么规划

* 基于非骨干区域必须对接到骨干区域的规则，OSPF最多只能支持三级网络结构。即省和市规划为骨干区域每个市级和其直属下辖的所有区县级规划为一个非骨干区域。但如果区县级下还有营业网点的话这部分的区域则无法对接到骨干区域。
* 这种情况一般就建议区县级和营业网点的网络部分运行其他协议，或者另开一个 OSPF 进程，然后在两个协议间通过路由引入来解决互通问题
* 也可以使用 BGP 协议，规划成多个 AS 来传递路由。

## .OSPF 为什么要设置优先级内部10,外部150

* 防止双向引入出现环路问题
* ![image-20250310195309659](https://i-blog.csdnimg.cn/img_convert/43b21ac565569c29ce4a6f6c50c475ee.png)

## .OSPF 有哪些快速收敛方法

* 手动把Hello-time 改小，使 OSPF 能更快的侦测出邻居失效
* 通过Hello报文来检测邻居失效:Dead-time是四倍的 Hello-time,时间太长,可以使用BFD,使 OSPF能够在毫秒级实现邻居失效检测
* 在只有两台设备互联的以太网环境，将网络类型改成P2P，改成 P2P 网络类型之后，无需进行 DR和 BDR 的选举，而选举 DR/BDR 要花费 40s 的时间，通过将网络类型改成 P2P 可以减少将近 40s的收敛时间。
* 出于稳定考虑，OSPF 在每次数据库发生变化后并未马上计算 SPF,而是等待一个路由计算时间间隔这个时间值最小为50毫秒,最大为5秒;通过改小这个值也可也加快收敛速度
* LSA有一个传输延迟,，trans-delay，目的是为了减少链路上同时泛洪的 LSA 的数量，缩短这个时间可以让 LSA 的更新更快。该时间默认1秒
* PRC，部分路由计算，当网络上路由发生变化的时候，只对发生变化的路由进行重新计算。OSPF 对区域间和引入的外部路由进行的是部分路由计算机制
* 配置 OSPF 的前缀按优先权收敛功能，可以通过配置策略来为不同前缀的路由分配不同的优先权。优先权一共4个等级，分别是 Critical、High、Medium、Low。当路由收敛时、OSPF 会优先计算高优先权的路由，来使重要业务的路由实现更快速收敛
* 设置特殊区域
* 在 ABR或 ASRB 上进行路由汇总

## OSPF 能够和哪些机制联动

* OSPF 与 BFD 联动。BFD 能够为 OSPF 邻居之间的链路提供毫秒级的快速检测功能。当邻居之间链路出现故障时，加快 OSPF 的收敛速度。OSPF 联动 BFD 有两种方式:

  + 使用 Control报文双向检测，邻居双方互相发送 Control 报文来检测状态需要建立 OSPF 邻居的两端设备均支持并配置 BFD
  + Echo 报文单跳检测，仅需在一端配置，对端邻居在收到 Echo 报文后会直接回传来进行状态检测
* OSPF 与 GR(平滑重危)联动实现路由协议重启时业务不中断。正常情况下当一台路由器的 OSPF进程被重置后，该路由器会断开所有邻居并重新建立。在邻居断开并重新建立的过程中路由会丢失，导致数据转发中断。GR 可以解决这个问题。配置 GR 后，当路由器 OSPF 进程被重置，会通告邻居不要断开与自己的邻居关系，同时保持 FIB 表一直有效，然后当进程重置完成后，再迅速与对端建立起邻居关系。整个过程中流量不会中断

  + GR 是 Gracefu Restart 的简称，又被称为平滑重启，是一种用于保证当路由协议重启时数据正常转发并且不影响关键业务的技术。
  + OSPF 通过新增 Grace-LSA 来支持 GR 功能。这种 LSA 用于在开始 GR 和退出 GR 时向邻居通告 GR 的时间、原因以及接口地址等内容
* 路由器在 GR 中的角色

  + Restarter:重启路由器。
  + Helper:协助重启路由器。
* ![image-20250310194212482](https://i-blog.csdnimg.cn/img_convert/022c7a8533e75bcce17c78a3f62ffa22.png)

## 引入外部路由后，[SDB 中有儿LSA但是没有计算出路由，可能是什么原因?

* 引入的外部路由通过Type5或 Type7 的 LSA 描述。既然 LSA 存在，所以不可能是过滤的 Type 5 LSA。但是对OSPF 可以在单台路由器上过滤计算出的路由来实现LSA有，但是无路由的情况。所以如果是对该路由做了过滤，可能出现 这种情况。
* Type 5 LSA 在非 ASBR 的区域通过 Type3 的防环机制防止环路。也就是一个ABR 不会根据从一个非骨干区域接收的 Type 5 LSA,计算路由。所以如果一个区域有多个 ABR,某个 ABR 上出现了骨干区域被分割而导致无法从本 ABR 连接的区域0连接到 ASBR,就会导致能从其他 ABR 收到 Type 5 LSA,但无法计算路由的结果。
* Type5 LSA 的 FA 地址是非 0.0.0.0 的,并且前往该 FA 地址的路由不是 OSPF 区域内或区域间的形式，则 Type5 LSA 只存在于数据库中，并且不加路由表。
* 非相邻设备的 RID 与 ASBR 的 RID 冲突时，也会导 RID 冲突的 LSA 无法加表
* 在 MPLS VPN 的环境中，MCE 设备上运行 OSPF，并且 OSPF 进程没有关闭down-bit 检查的场景在 OSPF的VPN实例进程中使用vpn-instance-capability simple 来关闭 down-bit 检查。

## NSSA 区域的P置位有什么用

* 在 NSSA 区域的 ABSR 上,如果 P-bit 位置位 1,这样 Type7 的 LSA 就会在 ABR上转换为Type 5否则置位0的话,就不允许转换为Type 5
* 可以在 OSPF 的区域视图中使用 translate-akways 命令，来强制实现该 ABR 执行7类 LSA 转换成5类 LSA。
* 以在 OSPF 的区域视图中使用 translate-never 命令,来禁止该 ABR 执行7类LSA 转换成5 类 LSA。

## OSPF 正常情况下邻居关系 2-Way 的场景是什么?

* 正常情况下,一条广播或 NBMA 链路上多台路由器,存在多个 DRother,DRother之间只会保持 2-way 的邻居关系，而不会进入到 Full 状态

## .OSPF 同一链路上两台路由器都卡在 2-Way状态，而且都显示是 DRother,是什么情况?

* 如果两台路由器都把 DR 优先级设置为0两台路由器都将不参与 DR 和 BDR 的选举，于是都停留在2-Way状态，并成为DRother。

## .OSPF 中广播网络和 P2P 网络类型为什么能够建立邻接，但无法计算路由

* 广播网络和P2P 都是通过组播来收发 Helo 报文，邻居建立原理也一致，默认Hello time 和 deadtime 也一致，所以可以建立邻接关系
* 但是路由器收到对方的 LSA，在进行 SPF 计算路由时发现LSA 的链路类型不一致，导致无法成功计算出路由。

## OSPF 的过载保护

* 随着网络上路由数量不断增加，一些路由器由于系统资源有限，不能再承载如此多的路由信息，这种状态就被称为数据库超限(OSPF Database Overflow)
* 为了解决数据库超限引发的问题，通过设置 LSDB 中 External LSA 的最大条目数，可以动态限制链路数据库的规模。
* 通过设置路由器上非缺省外部路由数量的上限，来避免数据库超限。
* OSPF 网络中所有路由器都必须配置相同的上限值。只要路由器上外部路由的数量达到该上限，路由器就进入 Overflow 状态，并同时启动超限状态定时器默认超时时间为5秒)，路由器在定时器超过5秒后自动退出超限状态。
* 进入 Overflow 状态时

  + 路由器删除所有自己产生的非缺省外部路由。
* 处于Overflow状态中

  + 不产生非缺省外部路由
  + 丢弃新收到的非缺省外部路由,不回复确认报文
  + 当超限状态定时器超时,检测外部路由数量是否仍然超过上限,如果不是则退出超限状态,如果仍然超过上限,则重启超限状态定时器
* 退出Overflow状态时

  + 删除超限状态定时器
  + 产生非缺省外部路由。
  + 接收新收到的非缺省外部路由，回复确认报文。
  + 准备下一次进入超限状态。

## 怎么判断 OSPF 的 RID 冲突

* 在 OSPF(Open Shortest Path First)协议中，RID(RouterID)是一个在同一个OSPF 域中唯一标识每个路由器的 32 位标识符。当 OSPF 路由器之间存在相同的 RID 时，会导致冲突和问题。以下是判断 OSPF RID 冲突的方法:

  + 查看日志信息:在 OSPF 路由器上查看日志信息，特别是有关 OSPF 协议的日志。如果存在 RID 冲突，通常会在日志中显示警告或错误消息，指示发现了重复的 RID。
  + 查看 OSPF 邻居关系:检查 OSPF 邻居关系表(neighborrelationship table)查看是否有路由器之间的邻居关系异常或无法建立。RID 冲突可能会导致邻居关系的问题,如邻居状态为 EXSTART 或两个路由器之间无法建立邻居关系
  + 查看 OSPF 数据库:使用命令查看 OSPF 数据库，比如”display ospf database”，检查是否有重复的LSA(LinkState Advertisement)。如果发现多个路由器具有相同的 LSA 和相同的 RID，这可能是因为存在 RID 冲突。
  + 使用网络分析工具:可以使用网络分析工具如 Wireshark 来捕获并分析OSPF 协议的数据包。在数据包中找 OSPFHello 消息,并检查其中的 RID字段。如果发现多个路由器具有相同的 RID，那么可能存在 RID 冲突。
  + 配置检查:检查每个OSPF 路由器的配置文件，查看其配置的 RID、确保每个路虫器的 RID 是唯一的，并且没有配置错误。
  + 数据库中存在,但是部分路由不加表

## 两台 ASBR 引入同一条路由到内部，会产生几条 LSA?

* 只会产生一条
* 路由器收到一条5类 LSA 时，如果这条5类LSA 包含的路由和本地路由的IP、掩码都相同，并且其中的 FA 地址和本地路由的下一跳地址也相同，那么这台路由器会去比较这个5类 LSA 产生者的 Router-id 和自己的 Router-id,如果自己的 Router-id 小，那么自己就不会再将这条路由引入到 OSPF 中,也不会再产生5类 LSA。也就是说当两条外部5类 LSA 的 FA 地址相同时,LSDB中只能看到一条。Router-id 小的ASBR 会撤销自己发布的5类 LSA。

## OSPF 和 BGP 的 Router-id 和 LDP 的LSR ID 是否可以设置一个不存在的地址?

* OSPF 和 BGP 的 Router 可以设置一个不存在的地址，但LDP 的 LSR ID 必须设置一个存在的地方

## OSPF 单区域与多区域的优缺点对比

* 单区域

  + 单区域 OSPF配置简单，不需要考虑多个区域之间的连接
  + 单区域OSPF计算SPF速度更快,因为只需要计算一个区域的LSDB
  + 单区域OSPF对于小型网络来说更稳定,减少数据库同步和路由计算的复杂度
  + 单区域的扩展性较差，当路由器超过100台时，会出现LSDB 过大,SPF计算时间过长等问题
* 多区域

  + 多区域 OSPF 可以解决单区域扩展性差的问题，将网络划分为多个区域来减少每个路由器上LSDB 大小和 SPF 计算时间
  + 多区域 OSPF 允许管理员更灵活的管理网络，可以根据不同的需求将路由器分配到不同区域中
  + 多区域 OSPF 可以把网络故障隔离在区域内部
  + 多区域配置更复杂
  + 多区域相对单区域不够稳定，当网络规模较小时，划分多个区域可能会增加路由器之间的复杂度和故障点

## OSPF 认证方式有哪些

* 根据报文的种类，认证可以分为以下两类:

  + 区域认证:在 OSPF 区域视图下配置，对本区域的所有孩口下的报文进行认证
  + 接口认证:在接口视图下配置，对本接口的所有报文进行认证
* 根据报文的认证方式，可以分为:

  + 空认证:不进行认证。
  + 简单认证:这是一种简单的加密方式，将配置的密码直接加入报文中，这种加密方式安全性不高。
  + MD5(Message Digest5)认证:通过将配置的密码进行 MD5 等加密算法之后再加入报文中,这样提高了密码的安全性,目前支持MD5/HMAC-MD5,为了保证更好的安全性，建议不要使用 MD5_算法，推荐使用 HMAC-SHA256 算法。
  + Keychain 认证:Keychain 由多个认证密钥组成,每个密钥包含一个ID 和密码,密钥存在生命期，通过密钥的生命期可以在 Keychain 中滚动选择不同的认证密钥。Keychain 可以滚动选择认证密钥来增强防攻击性。
  + Keychain为 OSPF提供了认证保护，Keychain 通过动态的更改认证算法和密钥，提高了 OSPF 的安全性。应用 Keychain 认证，除了可以对 OSPF 协议报文进行认证之外，还可以对TCP建立连接的过程进行认证。
  + HMAC-SHA256 认证:通过将配置的密码进行 HMAC-SHA256 算法加密之后再加入报文中，提高密码的安全性。

## OSPF 邻接关系停滞在 ExStart或 Exchange 状态的可能原因有哪些?

* 接口 MTU 设置不匹配

  + OSPF 在 DD 报文中携带了接口的 MTU 信息，如果双方的 MTU 信息不匹配，那么邻居关系将会停滞在 ExStart 状态。
* 邻居 Router lD 重复

  + 在 ExStart 过程中，需要通过 Router ID 的信息确定邻居的主从关系，如果邻居双方的 RouterID 设置相同,那么设备就会陷入主从确定的循环中,停滞在 ExStart 状态
  + 传输路径 MTU 小于网络设备接口的链路 MTU
  + 如果 OSPF 发送的 DD 报文较大,达到或接近设备接口上链路 MTU 的大小,但是报文传输路径上存在链路 MTU 较小的传输节点，那么很有可能大的 OSPF报文将在传输路径上被丢弃，导致邻居双方无法完成完整的数据库信息交互而停滞在 Exchange 状态。

## OSPF 中如何发布缺省路由及应用场景

* | 区域类型 | 产生条件 | 发布方式 | 产生LSA的类型 | LSA泛洪范围 |
  | --- | --- | --- | --- | --- |
  | 普通区域 | 配置default-route-advertise命令 | ASBR发布 | Type-5 LSA | 普通区域 |
  | STUB区域 | 自动产生 | ABR发布 | Type-3 LSA | STUB区域 |
  | NSSA区域 | 配置nssa default-route-advertise | ASBR发布 | Type-7 LSA | NSSA区域 |
  | 完全NSSA区域 | 自动产生 | ABR发布 | Type-3 LSA | NSSA区域 |
* OSPF 缺省路由的发布方式取决于引入缺省路由的区域类型。
* OSPF 不能通过 import-route 命令从其它协议引入缺省路由，如果想把缺省路由引入到 OSPF 路由区域，必须在ASBR 上执行 default-route-advertise 配置
* OSPF缺省路由通常应用于下面两种情况:

  + 由区域边界路由器发布Type3 LSA,用来指导区域内路由器进行区域之间报文的转发
  + 由自治系统边界路由器发布Type5 LSA或 Type7 LSA，用来指导 OSPF 路由域内路由器进行域外报文的转发。

## OSPF的区域规划有什么注意事项

* 需要规划使用单区域还是多区域。
* OSPF 的 LSDB 大小,以及拓扑的变化会影响运行 OSPF 设备的性能,如果 LSDB数据库太大，或者拓扑变化频繁，则需要进行区域划分。
* 另外一个影响因素是路由控制的需要。OSPF 进行路由过滤时,如果没有 ABR,则需要在每一台路由器上都配置过滤，才能实现过滤的效果。所以，如果网络需要进行路由控制(过滤)，则需要考虑进行区域划分。
* 多区域时，需要考虑骨干区域的位置与 ABR。OSPF 规定，骨干区域负责区域之间的路由，非骨干区域之间的路由信息必须通过骨干区域来转发。
* 非骨干区域的规划可以与网络中实际的行政，地域划分相吻合
* OSPF的特殊区域(Stub、Totaly Stub、NSSA、Totaly NSSA)的作用是减少设备路由表的大小;所以，如果网络中设备性能不足时、将可以考虑使用特殊区域。通常将边缘位置(如接入层、最小行政区)的设备规划成特殊区域的设备;
* 如果某设备需要进行路由引入，如互联网出口路由器，则需要规划成 NSSA Totally NSSA 区域，否则无法引入外部路由。
* OSPFv3 的区域规划原则同 OSPFv2。

## OSPF防环规划有什么注意事项

* OSPF 是一个无环的动态路由协议，但这是针对域内路由和域间路由而言的

  OSPF对于引入的外部路由引发的路由环路没有很好的防范机制

  + 尽量使用单向引入，单向引入情况下,网络结构简单,数据流向是单向的,不容易产生环路。
  + 双向引入时要进行路由过滤。尤其是在双向多点的情况下，由于双方有多个边界，且多个边界都互相引入，极易引发环路和次优路径。此时的原则是要进行路由过滤。
* 如果规划不当，在路由引入时还容易产生次优路径。

  + 调整路由优先级，多次引入路由的优先级，一定要小于原路由的优先级。
  + 设置合理的开销，原则上，从外部引入的路由开销值应该大于任何内部路由的开销值。
* OSPF 做路由聚合后，也有可能产生环路，H3C 路由器缺省会自动对聚合后的汇总路由生成黑洞路由，也可以通过手工来配置，下一跳指向 NULL0 接口。

## OSPF路由无法通告故障要如何排查

* OSPF 无法通告从地址的路由:

  + 当启用 OSPF 的接口配置从地址时，必须保证从地址与主地址属于相同的OSPF 区域，否则从地址路由无法通告。
* ABR 无法通告路由

  + 区域不允许接收汇总路由:如果 OSPF 的区域为完全存根区域或完全 NSSA区域，那么该区域的 ABR 不会向该区域通告其它区域的路由。
  + ABR 与骨干区域隔离:与 ABR 相连的区域必须有一个是骨干区域，如果ABR 无法连接骨干区域，那么它将不能通告区域间路由。
  + OSPF骨干区域分割:ABR 不能通过非骨干区域学习区域间路由,如果OSPF的骨干区域分割，那么 ABR 可能无法生成全部的区域间路由。
* 无法通告外部路由:

  + 区域不允许接收外部路由:如果 OSPF 的区域为存根区域、完全存根区域NSSA 区域、完全 NSSA 区域，那么外部路由无法向这些区域通告。
  + NSSA 区域多 ABR:如果 NSSA 区域存在多个 ABR，具有较大 RouterID 的ABR 才会进行类型7的 LSA 转换成类型5的 LSA 操作，其它的 ABR不能进行这个转换，如果 NSSA 区域存在配置错误的 ABR 而且其 Router ID较大，那么该 NSSA 区域的外部路由可能无法通告到其它区域。

## OSPF路由无法加入路由表故障排查

* 路由表中没有 OSPF路由:

  + 网络类型不匹配:由于 OSRF 数据库中网络类型不匹配，导致 OSPF 不会在路由表中添加路由
  + 点到点网络单边无地址:如果一端配置有IP地址，另外一边配置为借用IP地址,则二者的LSA链路数据值不匹配
* OSPF外部路由无法加入路由表

  + 可能为 Forwarding Address,地址有效性检查失败
  + OSPF 外部路由中会携带转发地址信息，如果该转发地址非零，那么OSPF必须能够通过区域内或区域间路由到达该转发地址，否则该外部路由不会加入 OSPF 路由表

## 引起 OSPF 的 SPF 重复计算有哪些可能原因

* 链路抖动引起 SPF 重复计算

  + 如果 OSPF 区域中存在不稳定的链路，那么每当发生链路抖动时，都将导致区域内的路由器重新运行 SPF 算法，以适应网络拓扑的改变
  + 一般可以通过消除链路抖动或合理规划区域对该问题进行解决;
* Router ID 重复引起 SPF 重复计算

  + 果运行 OSPF 的路由器 RouterID 重复，将会导致 OSPF 拓扑数据库处于混乱状态，进而导致 SPF 频繁计算。
  + 发生这个问题时一般可以观察到部分路由的频繁删除与增加，以及部分LSA 的 LSA Age 总是很小

## OSPF中 DR 和 BDR 的作用

* 在广播网和 NBMA 网络中，任意两合路由器之间都要交换路由信息。如果网络中有n台路由器，则需要建立 n(n-1)/2 个邻接关系。这使得任何一台路由器的路由变化都会导致多次传递，浪费了带宽资源。为解决这一问题,OSPF 协议定义了指定路由器 DR，所有路由器都只将信息发送给 DR，由 DR 将网络链路状态发送出去。如果 DR 由于某种故障而失效，则网络中的路由器必须重新选举DR、再与新的 DR 同步。这需要较长的时间，在这段时间内，路由的计算是不正确的。为了能够缩短这个过程，OSPF 提出了 BDR 的概念。
* BDR 实际上是对 DR 的一个备份;在选举 DR 的同时也选举出 BDR，BDR 也和本网段内的所有路由器建立邻接关系并交换路由信息。当DR失效后，BDR会立即成为 DR。由于不需要重新选举，并且邻接关系事先已建立，所以这个过程是非常短暂的。当然这时还需要再重新选举出一个新的 BDR，虽然一样需要较长的时间,但并不会影响路由的计算。DR和BDR之外的路由器(称为 DR Other)之间将不再建业邻接关系，也不再交换任何路由信息。这样就减少了广播网和NBMA网络上各路由器之间邻接关系的数量

## DR/BDR 选举过程

* DR 和 BDR 是由同一网段中所有的路由器根据路由器优先级、Router ID 通过HELLO 报文选举出来的，只有优先级大于0的路由器才具有选取资格。
* 进行 DR/BDR 选举时每台路由器将自己选出的 DR 写入 Hello 报文中，发给网段上的每台运行 OSPF 协议的路由器。当处于同一网段的两台路由器同时宣布自己是 DR 时，路由器优先级高者胜出。如果优先级相等，则 RouterlD 大者胜出。如果一台路由器的优先级为0，则它不会被选举为 DR 或 BDR。
* DR/BDR 选举的注意事项:

  + 只有在广播或 NBMA 类型接口才会选举 DR，在点到点或点到多点类型的接口上不需要选举 DR。
  + DR 是某个网段中的概念,是针对路由器的接口而言的。某台路由器在一个接口上可能是 DR，在另一个接口上有可能是 BDR，或者是 DR Other。
  + 路由器的优先级可以影响一个选取过程，但是当 DR/BDR已经选取完毕就算一台具有更高优先级的路由器变为有效，也不会替换该网段中已经选取的DR/BDR成为新的DR/BDR
  + DR 并不一定就是路由器优先级更高的路由器接口;同理，BDR 也并不一定就是路由器优先级次高的路由器接口。