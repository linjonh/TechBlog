---
layout: post
title: "jsonRPC实现前后端分离"
date: 2025-03-07 11:33:09 +0800
description: "介绍实现前后端分离的jsonRPC框架，从前后端分离的重要性、jsonRPC的概念、jsonRPC的特点、以及背后的网络原理进行分享"
keywords: "jsonRPC实现前后端分离"
categories: ['未分类']
tags: ['C']
artid: "146089242"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146089242
    alt: "jsonRPC实现前后端分离"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146089242
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146089242
cover: https://bing.ee123.net/img/rand?artid=146089242
image: https://bing.ee123.net/img/rand?artid=146089242
img: https://bing.ee123.net/img/rand?artid=146089242
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     jsonRPC实现前后端分离
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="jsonRPC_1">
     </a>
     jsonRPC实现先后端分离
    </h2>
    <p>
     去年学习了韦东山的嵌入式快速入门课程，在课程中学习了jsonRPC。
    </p>
    <p>
     我将从前后端分离的重要性、jsonRPC的特点、背后的网络通讯协议进行介绍和拆解。
    </p>
    <h3>
     <a id="_7">
     </a>
     为什么要实现前后端分离
    </h3>
    <ol>
     <li>
      提高开发效率，前后端程序可交由不同人员进行并行开发
     </li>
     <li>
      增强可维护性，前后端程序实现了解耦，各自模块的错误与其他模块关系为0
     </li>
     <li>
      促进跨平台兼容性，前后端程序的环境可以不同，可分别是linux、windows、安卓系统
     </li>
    </ol>
    <h3>
     <a id="JsonRPC_12">
     </a>
     实现前后端分离的技术-JsonRPC
    </h3>
    <p>
     Remote Procedure Call。它是一种协议，允许一个计算机程序调用另一个地址空间（通常是通过网络连接的不同计算机）中的子程序或过程，而不需要程序员显式地编码这个远程交互的细节。换句话说，RPC 使得开发人员可以像调用本地函数一样调用远程服务器上的方法或过程，从而简化了分布式系统的开发。
    </p>
    <blockquote>
     <p>
      Json-rpc 有两个版本，1.0 和 2.0。JSON-RPC 1.0 是一种轻量级的远程过程调用（RPC）协议，它使用 JSON格式来编码数据。
     </p>
    </blockquote>
    <h3>
     <a id="jsonRPC_16">
     </a>
     jsonRPC主要特性
    </h3>
    <ul>
     <li>
      简单性：JSON-RPC 1.0设计非常简洁，易于实现。它定义了非常简洁的客户端如何向服务器发送请求以及服务器如何响应这些请求的基本规则。
     </li>
     <li>
      无版本标识：与 JSON-RPC 2.0 不同，1.0版本的消息中没有专门的字段来指定协议版本。这意味着所有消息都遵循相同的格式，除非另有说明。
     </li>
     <li>
      同步通信：JSON-RPC 1.0 主要支持同步请求/响应模式
     </li>
    </ul>
    <h3>
     <a id="_21">
     </a>
     同步通信
    </h3>
    <ul>
     <li>
      <p>
       顺序性：发送方发送一个请求后，必须等到接收方返回响应后才能继续执行下一个操作。
      </p>
     </li>
     <li>
      <p>
       阻塞行为：在同步通信中，发起请求的一方（如客户端）通常会被阻塞，直到收到响应为止。这意味着，在这段时间内，调用线程无法执行其他任务。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_26">
     </a>
     请求格式
    </h3>
    <p>
     一个典型的 JSON-RPC 1.0 请求包含以下几个部分：
    </p>
    <ul>
     <li>
      method: 要调用的方法名称。
     </li>
     <li>
      params: （可选）传递给方法的参数列表，可以是数组。
     </li>
     <li>
      id: （对于请求而言）用于标识请求的唯一ID，以便将响应与对应的请求匹配起来。如果是一个通知（即不需要响应），则此字段可省略
     </li>
    </ul>
    <p>
     实例：
    </p>
    <pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"method"</span><span class="token builtin class-name">:</span> <span class="token string">"controlLed"</span>,
  <span class="token string">"params"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">42</span>, <span class="token number">23</span><span class="token punctuation">]</span>,
  <span class="token string">"id"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_42">
     </a>
     响应格式
    </h3>
    <p>
     响应消息包含以下内容：
    </p>
    <ul>
     <li>
      result: 如果请求成功，则包含返回的结果。
     </li>
     <li>
      error: 如果请求失败，则包含错误信息的对象。
     </li>
     <li>
      id: 必须与对应的请求中的id相匹配。
     </li>
    </ul>
    <p>
     成功响应示例
    </p>
    <pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"result"</span><span class="token builtin class-name">:</span> <span class="token number">19</span>,
  <span class="token string">"error"</span><span class="token builtin class-name">:</span> null,
  <span class="token string">"id"</span><span class="token builtin class-name">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     错误响应示例
    </p>
    <pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"result"</span><span class="token builtin class-name">:</span> null,
  <span class="token string">"error"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"JSONRPCError"</span>,
    <span class="token string">"code"</span><span class="token builtin class-name">:</span> -32601,
    <span class="token string">"message"</span><span class="token builtin class-name">:</span> <span class="token string">"Method not found."</span>
  <span class="token punctuation">}</span>,
  <span class="token string">"id"</span><span class="token builtin class-name">:</span> <span class="token string">"1"</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="jsonRPC_71">
     </a>
     jsonRPC背后支撑其通讯的网络协议
    </h3>
    <p>
     TCP、UDP、Http、https。以tcp为例。
    </p>
    <p>
     TCP 是一种面向连接的、可靠的传输层协议，用于在网络中的不同设备之间提供数据传输服务。它确保了数据能够从一个端点准确无误地传递到另一个端点，并且按照发送顺序到达。
    </p>
    <h4>
     <a id="TCP_75">
     </a>
     TCP主要特点
    </h4>
    <p>
     面向连接：
    </p>
    <blockquote>
     <p>
      在开始数据传输之前，TCP 需要在发送方和接收方之间建立一条逻辑上的连接（通过三次握手）。这条连接会在数据传输完成后被关闭（四次挥手）。
     </p>
    </blockquote>
    <p>
     可靠性：
    </p>
    <blockquote>
     <ul>
      <li>
       确认机制：每收到一个数据包，接收方都会向发送方发送确认（ACK），告知已经成功接收到数据包。
      </li>
      <li>
       重传机制：如果发送方在一定时间内没有收到确认，就会重新发送该数据包。
      </li>
      <li>
       序列号：每个数据包都有一个序列号，这使得数据包可以按正确的顺序重组，即使它们到达接收端的顺序不正确。
      </li>
      <li>
       校验和：每个数据包都包含一个校验和，用于检测数据是否在传输过程中损坏。
      </li>
     </ul>
    </blockquote>
    <p>
     流量控制：
    </p>
    <blockquote>
     <p>
      TCP 使用滑动窗口机制来防止发送方发送的数据量超过接收方能处理的能力。这样可以避免网络拥塞和数据丢失。
     </p>
    </blockquote>
    <p>
     拥塞控制：
    </p>
    <blockquote>
     <p>
      TCP 动态调整发送速率以适应网络状况。当网络负载较轻时，发送速率会增加；当网络出现拥塞迹象时，发送速率会减慢。
     </p>
    </blockquote>
    <h4>
     <a id="_95">
     </a>
     工作流程
    </h4>
    <p>
     三次握手（建立连接）：
    </p>
    <blockquote>
     <p>
      SYN：客户端向服务器发送一个 SYN（同步）报文段，表示希望与服务器建立连接。
      <br/>
      SYN-ACK：服务器接收到 SYN 后，回复一个SYN-ACK 报文段，表示同意建立连接并确认收到了客户端的请求。
      <br/>
      ACK：客户端接收到 SYN-ACK 后，发送一个 ACK报文段给服务器，确认连接已建立。此时，双方都可以开始传输数据。
     </p>
    </blockquote>
    <p>
     数据传输：
    </p>
    <blockquote>
     <p>
      数据被分割成多个小的数据包进行传输。每个数据包都包含序列号，以便于在接收端重新排序。接收方对每个接收到的数据包发送确认（ACK）。
      <br/>
      如果发送方在一个设定的时间内没有收到确认，则认为该数据包丢失并重新发送。
     </p>
    </blockquote>
    <p>
     四次挥手（断开连接）：
    </p>
    <blockquote>
     <p>
      当一方完成数据传输后，可以发起断开连接的请求
      <br/>
      FIN：首先，主动关闭的一方向另一方发送 FIN 报文段，表示不再发送数据。
      <br/>
      ACK：另一方接收到 FIN 后，发送一个 ACK 确认
      <br/>
      FIN：接着，另一方也发送一个 FIN 报文段，表示自己也不再发送数据。
      <br/>
      ACK：最初发送 FIN 的一方再次发送 ACK 确认，随后等待一段时间后关闭连接。
     </p>
    </blockquote>
    <h4>
     <a id="_TCP_114">
     </a>
     为什么选择 TCP？
    </h4>
    <ul>
     <li>
      可靠性高：TCP 提供了多种机制确保数据可靠传输，适用于需要保证数据完整性和顺序的应用场景。
     </li>
     <li>
      广泛支持：几乎所有的现代操作系统和网络设备都内置了对 TCP 的支持。
     </li>
     <li>
      适用范围广：适合文件传输、电子邮件、网页浏览等需要确保数据完整性的应用。
     </li>
    </ul>
    <h4>
     <a id="TCP_119">
     </a>
     服务端和客户端如何通过TCP构建连接与通讯
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/798cb14fc95b4256a3b31055f39400b7.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333436313430332f:61727469636c652f64657461696c732f313436303839323432" class_="artid" style="display:none">
 </p>
</div>


