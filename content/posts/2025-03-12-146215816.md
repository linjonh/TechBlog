---
layout: post
title: "Go语言圣经1.5"
date: 2025-03-12 21:40:43 +0800
description: "这段代码是串行处理每个 URL，但 Go 内置的并发机制（goroutine、channel）可以很方便地改造此程序为何在操作结束后需要关闭流（I/O流：文件流，网络流）操作系统为每个进程分配的文件描述符和网络连接数量是有限的。如果程序中频繁打开流而不关闭，长时间运行后会耗尽这些资源，导致后续无法打开新的文件或建立新的网络连接。不及时关闭流会导致资源泄露（Resource Leak），即占用的内存和其他系统资源不能被其他部分程序或其他程序使用。这种泄露会降低程序的性能，甚至引发系统崩溃或不稳定。"
keywords: "【Go语言圣经1.5】"
categories: ['未分类']
tags: ['开发语言', 'Xcode', 'Golang']
artid: "146215816"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146215816
    alt: "Go语言圣经1.5"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146215816
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146215816
cover: https://bing.ee123.net/img/rand?artid=146215816
image: https://bing.ee123.net/img/rand?artid=146215816
img: https://bing.ee123.net/img/rand?artid=146215816
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Go语言圣经1.5】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     目标
    </h3>
    <h3>
     <a id="_2">
     </a>
     概念
    </h3>
    <h3>
     <a id="_4">
     </a>
     要点（案例）
    </h3>
    <p>
     实现了一个简单的 HTTP 客户端程序，主要功能是：
    </p>
    <ul>
     <li>
      <strong>
       读取命令行参数
      </strong>
      ：程序从命令行获取一个或多个 URL。
     </li>
     <li>
      <strong>
       发送 HTTP GET 请求
      </strong>
      ：使用 Go 内置的
      <code>
       net/http
      </code>
      包，通过
      <code>
       http.Get
      </code>
      函数向每个 URL 发送请求。
     </li>
     <li>
      <strong>
       读取并输出响应内容
      </strong>
      ：利用
      <code>
       io.ReadAll
      </code>
      读取服务器返回的响应体，将其作为字符串输出到标准输出（屏幕）。
     </li>
     <li>
      <strong>
       错误处理
      </strong>
      ：如果请求过程中出现错误，程序会在标准错误输出（os.Stderr）中打印错误信息，并以错误状态码退出程序。
     </li>
    </ul>
    <p>
     这段代码的设计思路与 Unix 下的
     <code>
      curl
     </code>
     工具有相似之处，展示了如何用 Go 编写一个最简单的 HTTP 请求工具。
    </p>
    <ol>
     <li>
      <p>
       包导入
      </p>
      <pre><code class="prism language-go"><span class="token comment">// Fetch prints the content found at a URL.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io/ioutil"</span>
    <span class="token string">"net/http"</span> <span class="token comment">// 实现了 HTTP 客户端和服务端的基本功能，这里主要用来发起 GET 请求。</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <p>
       程序入口和获取命令行参数
      </p>
      <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
     </li>
     <li>
      <p>
       发起 HTTP GET 请求
      </p>
      <pre><code class="prism language-go">resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"fetch: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      <ul>
       <li>
        使用
        <code>
         fmt.Fprintf
        </code>
        将错误信息写入标准错误流，并通过
        <code>
         os.Exit(1)
        </code>
        退出程序，状态码 1 表示出现错误。
       </li>
      </ul>
     </li>
     <li>
      <p>
       读取响应体
      </p>
      <pre><code class="prism language-go">b<span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"fetch: reading %s: %v\n"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre>
      <ul>
       <li>
        服务器返回的响应体是一个流
       </li>
       <li>
        用io.ReadAll全部读取出来，并存入变量
        <code>
         b
        </code>
        中。
        <ul>
         <li>
          <code>
           b
          </code>
          是由
          <code>
           io.ReadAll
          </code>
          返回的一个
          <code>
           []byte
          </code>
          ，它用来存储从
          <code>
           resp.Body
          </code>
          中读取到的所有数据。从这个角度看，
          <code>
           b
          </code>
          就充当了一个缓冲区，其主要特点和作用如下：
          <ul>
           <li>
            当你调用
            <code>
             io.ReadAll(resp.Body)
            </code>
            时，Go 语言会从网络流（
            <code>
             resp.Body
            </code>
            ）中一次性读取所有数据，并将这些数据存储到一个新的切片
            <code>
             b
            </code>
            中。
           </li>
           <li>
            这个切片
            <code>
             b
            </code>
            就起到了“缓冲”的作用：它暂时保存了从网络中读取到的数据，方便程序后续操作（比如打印到标准输出）。
           </li>
           <li>
            为了存储数据，程序必须从操作系统申请一块内存区域，这就是“申请缓冲区”。在这里，
            <code>
             io.ReadAll
            </code>
            内部会动态分配足够大小的内存来保存整个响应体的数据。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <strong>
         关闭响应体
        </strong>
        ：调用
        <code>
         resp.Body.Close()
        </code>
        释放与响应相关的资源，防止内存或文件描述符泄露。
       </li>
       <li>
        很多程序会使用
        <code>
         defer resp.Body.Close()
        </code>
        来确保函数退出时自动关闭流，这也是 Go 中的一个重要惯用法。
        <ul>
         <li>
          在更多场景下推荐使用
          <code>
           defer
          </code>
          来保证资源释放，即使函数中途发生错误也能正确关闭资源。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       输出结果
      </p>
      <pre><code class="prism language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
</code></pre>
     </li>
    </ol>
    <h3>
     <a id="_79">
     </a>
     语言特性
    </h3>
    <ol>
     <li>
      <strong>
       检查错误
      </strong>
      ：Go 语言没有异常机制，而是通过返回值来处理错误。每一步操作（如 HTTP 请求、读取流）都需要检查错误，这种显式的错误处理方式有助于写出健壮的代码。
     </li>
     <li>
      资源管理：
      <strong>
       及时释放资源
      </strong>
      ：读取完响应体后调用
      <code>
       resp.Body.Close()
      </code>
      是非常重要的，防止资源泄露。理解这点对于编写网络或文件 I/O 程序尤为关键。
     </li>
     <li>
      标准库的强大支持
      <ul>
       <li>
        <strong>
         net/http 包
        </strong>
        ：Go 语言的标准库提供了对 HTTP 的强大支持，不仅能发起请求，还可以构建服务器，这让开发者能快速实现网络应用。
       </li>
       <li>
        <strong>
         io 包
        </strong>
        ：提供了对 I/O 操作的统一抽象，如
        <code>
         io.ReadAll
        </code>
        能简化从流中读取数据的操作。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_87">
     </a>
     总结
    </h3>
    <ol>
     <li>
      这段代码是串行处理每个 URL，但 Go 内置的并发机制（goroutine、channel）可以很方便地改造此程序
     </li>
     <li>
      为何在操作结束后需要关闭流（I/O流：文件流，网络流）
      <ul>
       <li>
        操作系统为每个进程分配的文件描述符和网络连接数量是有限的。如果程序中频繁打开流而不关闭，长时间运行后会耗尽这些资源，导致后续无法打开新的文件或建立新的网络连接。
       </li>
       <li>
        不及时关闭流会导致资源泄露（Resource Leak），即占用的内存和其他系统资源不能被其他部分程序或其他程序使用。这种泄露会降低程序的性能，甚至引发系统崩溃或不稳定。
       </li>
       <li>
        某些流在写操作时会进行缓冲，如果不调用关闭操作，缓冲区中的数据可能没有及时刷新到磁盘或发送到网络端，可能破坏数据完整性。通过关闭流，系统会自动刷新缓冲区，确保所有数据都已经正确写入或传输。
       </li>
       <li>
        文件在打开时可能被操作系统或其他程序加锁，防止数据被同时修改。关闭文件流可以释放这些锁定，使其他进程能够正常访问文件，保障系统的安全性和数据的一致性。
       </li>
      </ul>
     </li>
     <li>
      缓冲区
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：在程序设计中，缓冲区是一个抽象概念，用来描述数据暂存的位置。它帮助平滑数据流的传输，比如在从磁盘读取数据或向网络发送数据时，不必每次都进行低效的逐字节操作，而是先把数据存入缓冲区，再统一处理。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_98">
     </a>
     题目
    </h3>
    <p>
     <strong>
      练习 1.7：
     </strong>
     函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。
    </p>
    <pre><code class="prism language-go"><span class="token comment">// 使用 io.Copy 将响应体直接写入标准输出，避免申请额外的缓冲区</span>
<span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
</code></pre>
    <ul>
     <li>
      调用
      <code>
       io.Copy
      </code>
      函数，将数据从
      <code>
       src
      </code>
      （这里是
      <code>
       resp.Body
      </code>
      ）流式复制到
      <code>
       dst
      </code>
      （这里是
      <code>
       os.Stdout
      </code>
      ）
      <ul>
       <li>
        <code>
         io.Copy
        </code>
        的工作原理是创建一个固定大小(比如32KB)的缓冲区，在循环中不断地从源（src）读取一块数据，然后立即写入目标（dst）。这样，只需要维持这块缓冲区的内存，而不必为整个数据内容分配一大块连续内存区域。
       </li>
       <li>
        分块，chunk
       </li>
      </ul>
     </li>
     <li>
      对于大文件或长响应数据，直接拷贝可以减少内存占用。
      <strong>
       流式处理
      </strong>
      ：不需要一次性把所有数据加载到内存中，有助于处理大数据流。
     </li>
    </ul>
    <p>
     <strong>
      练习 1.8：
     </strong>
     修改fetch这个范例，如果输入的url参数没有
     <code>
      http://
     </code>
     前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。
    </p>
    <pre><code class="prism language-go">  	<span class="token comment">// 如果 URL 没有 "http://" 前缀，则自动添加</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"http://"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			url <span class="token operator">=</span> <span class="token string">"http://"</span> <span class="token operator">+</span> url
		<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      练习 1.9：
     </strong>
     修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。
    </p>
    <pre><code class="prism language-go"><span class="token comment">// 打印出 HTTP 协议的状态码</span>
fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"HTTP status: %s\n"</span><span class="token punctuation">,</span> resp<span class="token punctuation">.</span>Status<span class="token punctuation">)</span>

</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f5079726f79737465722f:61727469636c652f64657461696c732f313436323135383136" class_="artid" style="display:none">
 </p>
</div>


