---
layout: post
title: "Python-性能优化从入门到精通的实用指南"
date: 2025-03-07 16:28:48 +0800
description: "Hey，你有没有遇到过这样的情况：代码跑得太慢，CPU 风扇狂转，甚至内存直接爆满？在 Python 开发中，性能问题是个绕不过去的坎儿。无论是处理大数据、写爬虫，还是开发 Web 应用，优化性能都能让你的程序更快、更省资源。这篇文章的目标很简单：带你从零开始，搞懂影响 Python 性能的因素，学会几个超实用的优化技巧，还要教你怎么用timeit模块测测代码到底有多快。不管你是刚入门的小白，还是有点经验的开发者，这里都有干货等着你！影响 Python 性能的“幕后黑手”：时间复杂度和空间复杂度。"
keywords: "Python 性能优化：从入门到精通的实用指南"
categories: ['Python']
tags: ['编程', '性能优化', '开发语言', '人工智能', 'Pytorch', 'Python', 'Llm']
artid: "146098727"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146098727
    alt: "Python-性能优化从入门到精通的实用指南"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146098727
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146098727
cover: https://bing.ee123.net/img/rand?artid=146098727
image: https://bing.ee123.net/img/rand?artid=146098727
img: https://bing.ee123.net/img/rand?artid=146098727
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python 性能优化：从入门到精通的实用指南
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Langchain_2">
     </a>
     Langchain系列文章目录
    </h2>
    <p>
     <a href="https://blog.csdn.net/Kiradzy/article/details/144973054?spm=1001.2014.3001.5501">
      01-玩转LangChain：从模型调用到Prompt模板与输出解析的完整指南
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145063066?spm=1001.2014.3001.5501">
      02-玩转 LangChain Memory 模块：四种记忆类型详解及应用场景全覆盖
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145143465">
      03-全面掌握 LangChain：从核心链条构建到动态任务分配的实战指南
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145277111?spm=1001.2014.3001.5501">
      04-玩转 LangChain：从文档加载到高效问答系统构建的全程实战
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145383291?spm=1001.2014.3001.5501">
      05-玩转 LangChain：深度评估问答系统的三种高效方法（示例生成、手动评估与LLM辅助评估）
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145438477">
      06-从 0 到 1 掌握 LangChain Agents：自定义工具 + LLM 打造智能工作流！
     </a>
    </p>
    <h2>
     <a id="python_11">
     </a>
     python系列文章目录
    </h2>
    <p>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145869326">
      01-Python 基础语法入门：从变量到输入输出，零基础也能学会！
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145883474?spm=1001.2014.3001.5501">
      02-Python 流程控制终极指南：if-else 和 for-while深度解析
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145897303?spm=1001.2014.3001.5501">
      03-Python 列表与元组全攻略：从新手到高手的必备指南
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145911256?spm=1001.2014.3001.5501">
      04-Python 字典与集合：从入门到精通的全面解析
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145912222?spm=1001.2014.3001.5501">
      05-Python函数入门指南：从定义到应用
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145912299?spm=1001.2014.3001.5501">
      06-Python 函数高级特性：从默认参数到闭包的全面解析
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145912540?spm=1001.2014.3001.5501">
      07-Python 模块与包：从零到自定义的全面指南
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145912631?spm=1001.2014.3001.5501">
      08-Python异常处理：从入门到精通的实用指南
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145912684?spm=1001.2014.3001.5501">
      09-Python 文件操作：从零基础到日志记录实战
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145912832?spm=1001.2014.3001.5501">
      10-Python面向对象编程入门：从类与对象到方法与属性
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145913015?spm=1001.2014.3001.5501">
      11-Python类的方法与属性：从入门到进阶的全面解析
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145913149?spm=1001.2014.3001.5501">
      12-Python继承与多态：提升代码复用与灵活性的关键技术
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145913244?spm=1001.2014.3001.5501">
      13-掌握Python魔法方法：如何用__add__和__len__自定义类的行为
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/145913392?spm=1001.2014.3001.5501">
      14-python面向对象编程总结：从基础到进阶的 OOP 核心思想与设计技巧
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/146039792?spm=1001.2014.3001.5501">
      15-掌握 Python 高级特性：深入理解迭代器与生成器
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/146060307?spm=1001.2014.3001.5501">
      16-用 Python 装饰器提升效率：日志与权限验证案例
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/146077987?spm=1001.2014.3001.5501">
      17-再也不怕资源泄漏！Python 上下文管理器，with语句全攻略
     </a>
     <br/>
     <a href="https://blog.csdn.net/Kiradzy/article/details/146086075?spm=1001.2014.3001.5501">
      18-Python 标准库必备模块：math、random、os、json 全解析
     </a>
     <br/>
     19-Python 性能优化：从入门到精通的实用指南
    </p>
    <hr/>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_41">
     </a>
     前言
    </h2>
    <p>
     Hey，你有没有遇到过这样的情况：代码跑得太慢，CPU 风扇狂转，甚至内存直接爆满？在 Python 开发中，性能问题是个绕不过去的坎儿。无论是处理大数据、写爬虫，还是开发 Web 应用，优化性能都能让你的程序更快、更省资源。这篇文章的目标很简单：带你从零开始，搞懂影响 Python 性能的因素，学会几个超实用的优化技巧，还要教你怎么用
     <code>
      timeit
     </code>
     模块测测代码到底有多快。不管你是刚入门的小白，还是有点经验的开发者，这里都有干货等着你！
    </p>
    <p>
     本文会聊三大块：
    </p>
    <ul>
     <li>
      影响 Python 性能的“幕后黑手”：时间复杂度和空间复杂度。
     </li>
     <li>
      优化代码的“锦囊妙计”：避免重复计算、减少 IO 操作。
     </li>
     <li>
      性能检测的“秘密武器”：
      <code>
       timeit
      </code>
      模块。
     </li>
    </ul>
    <p>
     准备好了吗？咱们这就开始！
    </p>
    <hr/>
    <h2>
     <a id="_Python__53">
     </a>
     一、影响 Python 性能的因素
    </h2>
    <p>
     性能优化得先知道问题出在哪儿，对吧？Python 虽然简单好用，但有些地方不注意就会拖慢速度。这部分咱们聊聊两个核心因素：时间复杂度和空间复杂度。
    </p>
    <h3>
     <a id="11__57">
     </a>
     1.1 时间复杂度
    </h3>
    <p>
     时间复杂度听起来有点学术，其实就是“你的代码跑起来需要多久”。它跟数据量大小直接挂钩，数据越多，影响越明显。
    </p>
    <h4>
     <a id="111__60">
     </a>
     1.1.1 为什么时间复杂度重要？
    </h4>
    <p>
     简单说，时间复杂度决定了一个算法的效率。比如你在列表里找个数，数据量小还好，可要是列表里有几百万条数据，效率低的算法能让你等到怀疑人生。
    </p>
    <ul>
     <li>
      <strong>
       举个例子
      </strong>
      ：用列表和集合找数字的区别。
      <pre><code class="prism language-python"><span class="token comment"># 列表找数字，时间复杂度 O(n)</span>
my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> <span class="token number">3</span> <span class="token keyword">in</span> my_list<span class="token punctuation">:</span>  <span class="token comment"># 得一个个检查</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"找到啦！"</span><span class="token punctuation">)</span>

<span class="token comment"># 集合找数字，时间复杂度 O(1)</span>
my_set <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token number">3</span> <span class="token keyword">in</span> my_set<span class="token punctuation">:</span>  <span class="token comment"># 直接定位，超快</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"找到啦！"</span><span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <strong>
       关键点
      </strong>
      ：列表是线性查找，时间复杂度是 O(n)；集合用哈希表，平均时间复杂度是 O(1)。数据量越大，差距越明显。
     </li>
    </ul>
    <h4>
     <a id="112__76">
     </a>
     1.1.2 怎么优化时间复杂度？
    </h4>
    <ul>
     <li>
      <strong>
       建议
      </strong>
      ：需要频繁查找时，用集合（
      <code>
       set
      </code>
      ）或字典（
      <code>
       dict
      </code>
      ）代替列表。
     </li>
     <li>
      <strong>
       场景
      </strong>
      ：比如去重、查重这种操作，集合简直是神器。
     </li>
    </ul>
    <h3>
     <a id="12__80">
     </a>
     1.2 空间复杂度
    </h3>
    <p>
     时间跑得快还不够，内存用得少也很重要。空间复杂度就是“你的代码占了多少内存”。
    </p>
    <h4>
     <a id="121__83">
     </a>
     1.2.1 空间复杂度为啥关键？
    </h4>
    <p>
     Python 自动管理内存，但用错了数据结构，内存照样吃紧。比如存一堆数字，用列表和生成器差别可不小。
    </p>
    <ul>
     <li>
      <strong>
       举个例子
      </strong>
      ：
      <pre><code class="prism language-python"><span class="token comment"># 列表存一百万个数，全都加载到内存</span>
my_list <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment"># 内存占用大</span>

<span class="token comment"># 生成器，边用边生成，内存几乎不占</span>
my_gen <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 超省空间</span>
</code></pre>
     </li>
     <li>
      <strong>
       关键点
      </strong>
      ：列表把所有数据都存下来，空间复杂度 O(n)；生成器只存当前值，空间复杂度接近 O(1)。
     </li>
    </ul>
    <h4>
     <a id="122__95">
     </a>
     1.2.2 怎么优化空间复杂度？
    </h4>
    <ul>
     <li>
      <strong>
       建议
      </strong>
      ：大数据场景下，优先用生成器或迭代器。
     </li>
     <li>
      <strong>
       场景
      </strong>
      ：比如读取大文件、处理流数据，用生成器能省下不少内存。
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="Python__101">
     </a>
     二、Python 性能优化技巧
    </h2>
    <p>
     知道了影响性能的因素，咱们得动手优化代码。这部分分享两个超实用的技巧：避免重复计算和减少 IO 操作。
    </p>
    <h3>
     <a id="21__105">
     </a>
     2.1 避免重复计算
    </h3>
    <p>
     重复计算就像你炒菜时把同一个葱花切了十遍，太浪费时间！Python 里有些操作可以提前做好，省下不少力气。
    </p>
    <h4>
     <a id="211__108">
     </a>
     2.1.1 使用缓存机制
    </h4>
    <p>
     缓存就是把算过的结果存起来，下次直接拿来用。Python 自带一个神器：
     <code>
      functools.lru_cache
     </code>
     。
    </p>
    <ul>
     <li>
      <strong>
       代码示例
      </strong>
      ：优化递归计算斐波那契数列。
      <pre><code class="prism language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> lru_cache

<span class="token decorator annotation punctuation">@lru_cache</span><span class="token punctuation">(</span>maxsize<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">)</span>  <span class="token comment"># 缓存最多 128 个结果</span>
<span class="token keyword">def</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> n
    <span class="token keyword">return</span> fibonacci<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fibonacci<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 超快！</span>
</code></pre>
     </li>
     <li>
      <strong>
       关键点
      </strong>
      ：没缓存时，递归会重复算好多次；加了缓存，直接查表，时间从“天文数字”变成“秒级”。
     </li>
     <li>
      <strong>
       场景
      </strong>
      ：递归函数、频繁调用的计算任务。
     </li>
    </ul>
    <h4>
     <a id="212__125">
     </a>
     2.1.2 预计算和惰性计算
    </h4>
    <ul>
     <li>
      <strong>
       预计算
      </strong>
      ：提前把结果算好，比如程序启动时把常用数据准备好。
     </li>
     <li>
      <strong>
       惰性计算
      </strong>
      ：用到时再算，用生成器就是典型例子。
      <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">lazy_range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
        <span class="token keyword">yield</span> i  <span class="token comment"># 每次只生成一个数</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">for</span> num <span class="token keyword">in</span> lazy_range<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 按需取值</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <strong>
       建议
      </strong>
      ：不常用的数据用惰性计算，常用的小数据用预计算。
     </li>
    </ul>
    <h3>
     <a id="22__IO__140">
     </a>
     2.2 减少 IO 操作
    </h3>
    <p>
     IO 操作（比如读文件、发网络请求）特别慢，减少它的次数能让代码飞起来。
    </p>
    <h4>
     <a id="221__143">
     </a>
     2.2.1 批量处理数据
    </h4>
    <p>
     别一行行读文件，一次性读完再处理效率更高。
    </p>
    <ul>
     <li>
      <strong>
       代码示例
      </strong>
      ：
      <pre><code class="prism language-python"><span class="token comment"># 逐行读，IO 次数多</span>
<span class="token keyword">def</span> <span class="token function">process</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>

<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>  <span class="token comment"># 每次都调用 IO</span>
        process<span class="token punctuation">(</span>line<span class="token punctuation">)</span>

<span class="token comment"># 一次性读，IO 次数少</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 一次读完</span>
    lines <span class="token operator">=</span> content<span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">:</span>
        process<span class="token punctuation">(</span>line<span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <strong>
       关键点
      </strong>
      ：批量操作把多次 IO 变成一次，速度提升明显。
     </li>
     <li>
      <strong>
       场景
      </strong>
      ：读写大文件、数据库操作。
     </li>
    </ul>
    <h4>
     <a id="222__IO_165">
     </a>
     2.2.2 使用异步 IO
    </h4>
    <p>
     网络请求多的时候，等一个完再发下一个太慢，用异步 IO 可以同时处理。
    </p>
    <ul>
     <li>
      <strong>
       代码示例
      </strong>
      ：用
      <code>
       asyncio
      </code>
      抓网页。
      <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> aiohttp

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch_url</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>
        <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://example.com'</span><span class="token punctuation">,</span> <span class="token string">'http://example.org'</span><span class="token punctuation">]</span>
    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>fetch_url<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">for</span> url <span class="token keyword">in</span> urls<span class="token punctuation">]</span>
    results <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 只打印前 100 个字符</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <strong>
       关键点
      </strong>
      ：异步 IO 让多个请求并行，特别适合爬虫或高并发任务。
     </li>
     <li>
      <strong>
       场景
      </strong>
      ：网络密集型任务。
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="_timeit__190">
     </a>
     三、使用
     <code>
      timeit
     </code>
     模块测量代码性能
    </h2>
    <p>
     优化完代码，怎么知道效果咋样？用
     <code>
      timeit
     </code>
     模块测一测就知道了！
    </p>
    <h3>
     <a id="31_timeit__194">
     </a>
     3.1
     <code>
      timeit
     </code>
     模块简介
    </h3>
    <p>
     <code>
      timeit
     </code>
     是 Python 自带的小工具，专门测小段代码的运行时间。它会重复跑代码取平均值，结果很靠谱。
    </p>
    <h4>
     <a id="311__timeit_197">
     </a>
     3.1.1 为什么用
     <code>
      timeit
     </code>
     ？
    </h4>
    <p>
     手动用
     <code>
      time.time()
     </code>
     测时间不准，因为系统负载会干扰。
     <code>
      timeit
     </code>
     跑很多次，数据更稳定。
    </p>
    <h3>
     <a id="32__timeit__200">
     </a>
     3.2 如何使用
     <code>
      timeit
     </code>
     测量代码性能
    </h3>
    <h4>
     <a id="321__timeit_202">
     </a>
     3.2.1 命令行使用
     <code>
      timeit
     </code>
    </h4>
    <p>
     直接在终端跑，适合快速测试。
    </p>
    <ul>
     <li>
      <strong>
       示例
      </strong>
      ：测列表推导式的速度。
      <pre><code class="prism language-bash">python <span class="token parameter variable">-m</span> timeit <span class="token string">"sum([i for i in range(1000)])"</span>
</code></pre>
     </li>
     <li>
      <strong>
       输出
      </strong>
      ：类似“1000 loops, best of 5: 123 usec per loop”，表示平均每次多久。
     </li>
     <li>
      <strong>
       建议
      </strong>
      ：调试小代码时用这个，简单又快。
     </li>
    </ul>
    <h4>
     <a id="322__timeit_211">
     </a>
     3.2.2 在代码中使用
     <code>
      timeit
     </code>
    </h4>
    <p>
     想在脚本里测？也很简单。
    </p>
    <ul>
     <li>
      <strong>
       代码示例
      </strong>
      ：
      <pre><code class="prism language-python"><span class="token keyword">import</span> timeit

<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 跑 100 次，测总时间</span>
execution_time <span class="token operator">=</span> timeit<span class="token punctuation">.</span>timeit<span class="token punctuation">(</span>my_function<span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"总耗时: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>execution_time<span class="token punctuation">}</span></span><span class="token string"> 秒"</span></span><span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <strong>
       关键点
      </strong>
      ：
      <code>
       number
      </code>
      是运行次数，自己调，别设太大跑不动。
     </li>
     <li>
      <strong>
       场景
      </strong>
      ：对比不同实现方案的性能。
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="_229">
     </a>
     四、总结
    </h2>
    <p>
     本文聊了 Python 性能优化的三大块：
    </p>
    <ul>
     <li>
      <strong>
       影响因素
      </strong>
      ：时间复杂度管速度，空间复杂度管内存，选对数据结构很关键。
     </li>
     <li>
      <strong>
       优化技巧
      </strong>
      ：避免重复计算用缓存和生成器，减少 IO 用批量和异步。
     </li>
     <li>
      <strong>
       测量工具
      </strong>
      ：
      <code>
       timeit
      </code>
      帮你量化优化效果。
     </li>
    </ul>
    <p>
     希望你看完能有所收获，赶紧把这些技巧用到自己的代码里吧！有什么问题，随时问我哦～
    </p>
    <hr/>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f4b697261647a792f:61727469636c652f64657461696c732f313436303938373237" class_="artid" style="display:none">
 </p>
</div>


