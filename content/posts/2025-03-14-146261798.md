---
layout: post
title: "区块链btc"
date: 2025-03-14 17:21:35 +0800
description: "学习视频源链接：本文是根据肖老师的视频进行的笔记记录。"
keywords: "【区块链】btc"
categories: ['未分类']
tags: ['区块链']
artid: "146261798"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146261798
    alt: "区块链btc"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146261798
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146261798
cover: https://bing.ee123.net/img/rand?artid=146261798
image: https://bing.ee123.net/img/rand?artid=146261798
img: https://bing.ee123.net/img/rand?artid=146261798
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【区块链】btc
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     学习视频源链接：
     <br/>
     https://www.bilibili.com/video/BV1Vt411X7JF/
     <br/>
     本文是根据肖老师的视频进行的笔记记录
    </p>
    <h2>
     <a id="_cryptographic_hash_function_5">
     </a>
     一、 cryptographic hash function
    </h2>
    <h2>
     <a id="11__collision_resistance__7">
     </a>
     1.1. collision resistance抗碰撞性 ：
    </h2>
    <p>
     collision 指的是hash碰撞
    </p>
    <p>
     <strong>
      抗碰撞性 (Collision Resistance
     </strong>
     ) 是密码学哈希函数的一个重要安全属性，指的是：很难找到两个不同的输入 x 和 y，使得它们的哈希值相同，即 hash(x) = hash(y)。
    </p>
    <p>
     作用：
    </p>
    <ul>
     <li>
      数字签名安全性：防止攻击者找到与已签名文档具有相同哈希值的伪造文档
     </li>
     <li>
      区块链技术：确保交易和区块的唯一性，防止伪造
     </li>
     <li>
      数据完整性：保证数据没有被篡改
     </li>
     <li>
      在以太坊的上下文中，抗碰撞性在多个地方都很重要，比如：
     </li>
     <li>
      区块头的哈希计算
     </li>
     <li>
      交易哈希的生成
     </li>
     <li>
      Merkle树的构建
     </li>
     <li>
      账户地址的生成
     </li>
    </ul>
    <p>
     后果： 如果一个哈希函数失去了抗碰撞性，攻击者可能能够构造碰撞来进行双花攻击或其他欺诈行为。（bitcoin这种pow就容易有double spending，以太坊po
    </p>
    <p>
     以太坊主要使用Keccak-256（一种SHA-3变种）作为哈希算法，它被设计为具有强抗碰撞性。
    </p>
    <p>
     （从数学上证明不出来抗碰撞行，就是实践中验证的。。。
     <br/>
     md5 之前以为做不出来hash碰撞，但是后来证明可以做出了。。。）
    </p>
    <h4>
     <a id="112__hiding_Oneway_Function__Preimage_Resistance_31">
     </a>
     1.1.2 hiding 单项One-way Function / Preimage Resistance
    </h4>
    <p>
     给定哈希值 h，计算上不可行找到任何输入 x 使得 hash(x) = h
     <br/>
     即从哈希值反推原始输入在计算上是不可行的
    </p>
    <p>
     成立前提：
     <strong>
      输入的分布均匀，数量足够大
     </strong>
     。
     <br/>
     单向函数 (One-way Function)
    </p>
    <p>
     <strong>
      1.1.1、1.1.2 两个性质和起来的作用： 可以形成digital commitment /digital equivalent of a sealed envelope 。
     </strong>
    </p>
    <p>
     数字承诺（Digital Commitment）
    </p>
    <h4>
     <a id="113_puzzle_friendly_46">
     </a>
     1.1.3 puzzle friendly
    </h4>
    <p>
     挖矿就是 一直寻找随机数（none） 让 block header+ none 进行运算后的hash 函数值，在target 目标内
     <br/>
     所以这个才能 proof of work 。
    </p>
    <p>
     difficult to solve ，but easy to verify
     <br/>
     一到有人找到这个none ，发布出去之后，验证算一下就行。
     <br/>
     挖矿很难，验证很容易
    </p>
    <h3>
     <a id="2__56">
     </a>
     2. 签名
    </h3>
    <p>
     公私钥来自非对象加密的概念
     <br/>
     一个公私钥就是一个账户
    </p>
    <p>
     加密和解密用的是同一个人的公钥和私钥
    </p>
    <p>
     公钥相当于你的银行账户。
     <br/>
     公私钥用来签名。
     <br/>
     如果我想转给你的钱，我要用自己的私钥进行签名，然后其他人用我自己的公钥 验证 ，我是不是真的想转给你这笔钱。
     <br/>
     如果两个人生成的公私钥恰好相同，可以吗？ 256位hash，出现两个人相同的公私钥，概率微乎其微。 （假设产生公私钥的时候有一个好的随机源
    </p>
    <p>
     先对一个message 取hash 然后再对这个hash值签名
    </p>
    <h2>
     <a id="__71">
     </a>
     二、 数据结构
    </h2>
    <h3>
     <a id="21_hash_pointers_72">
     </a>
     2.1 hash pointers
    </h3>
    <p>
     区块链： 一个一个区块 组成的链表
     <br/>
     block chain is a linked list using hash pointers。
     <br/>
     哈希指针（Hash Pointer） ： 有环链表不能使用hash pointer
    </p>
    <p>
     第一个区块： Genesis block
     <br/>
     最后一个： most recent block
    </p>
    <p>
     每一个区块都有指向前一个区块的指针。
     <br/>
     每一个区块的hash值时前面+自己的hashpointer 一起取的hash 值算出来的
    </p>
    <p>
     我们通过这种数据结构可以实现 tamper- evident log
    </p>
    <p>
     所以保证了区块链中间东西不能变，如果改变前面任何一个区块，都会引发多米诺骨牌效应
    </p>
    <p>
     防篡改日志（Tamper-Evident Log）
    </p>
    <h3>
     <a id="22_merkle_tree_90">
     </a>
     2.2 merkle tree
    </h3>
    <p>
     相对于
     <br/>
     binray tree
     <br/>
     用hash 指针代替普通指针
     <br/>
     Merkle树（Merkle Tree）
     <br/>
     好处： 只要记住根hash值，就能记住树中 对任何的修改。 这叫 maerkle proof
    </p>
    <p>
     Merkle证明（Merkle Proof）
    </p>
    <p>
     proof of membership / proof of inclusion
    </p>
    <p>
     Merkle非成员证明 (Proof of Non-membership)
    </p>
    <p>
     Btc 只用了 membership的证明
     <br/>
     proof of membership
    </p>
    <h2>
     <a id="_btc__107">
     </a>
     三、 btc 协议
    </h2>
    <p>
     如何防范 double spending attack
     <br/>
     比特币与以太坊防范双重支付（Double Spending）的机制
     <br/>
     铸币交易：
    </p>
    <p>
     btc每个区块链的组成：
     <br/>
     输入部分： 币的来源，指向前面某个交易
     <br/>
     输出部分： 收款人公钥的hash （相当于收款人地址）
    </p>
    <p>
     为什么要说明币的来源？ 证明这个钱不是凭空捏造的，也防范double spending
     <br/>
     付款方需要知道 收款方的地址（公钥的hash值）
     <br/>
     收款方需要知道 付款方的公钥 ，a的公钥代表a的身份，代表知道从哪来的
     <br/>
     所有节点也要知道付款方的公钥，为了认证这笔交易是不是合法的。
     <br/>
     认证原则：因为有的节点是恶意的，所有的节点验证时，都要独立验证。
    </p>
    <p>
     怎么才能知道付款方的公钥？
    </p>
    <p>
     我给你发送信息，我是用你的公钥加密，然后你收到后用你的私钥解密。
    </p>
    <p>
     比特币区块的组成结构
    </p>
    <p>
     全节点（Full Node）与轻节点（Light Node）的区别
    </p>
    <p>
     哪些交易应该放到下一个区块中？ 哪一个时合法的？
     <br/>
     区块链： 账本的内容钥取得分布式共识—— 又绕到了分布式共识算法中。
    </p>
    <h3>
     <a id="32___133">
     </a>
     3.2 分布式共识 ：
    </h3>
    <p>
     eg： distributed hash table
     <br/>
     需要取得共识的是 hash表中的kv
     <br/>
     有很多impossibility result
     <br/>
     eg. FLP
     <br/>
     在一个异步的系统里（asynchronous ，如果有一个成员时faulty 的，那么也无法达成共识
    </p>
    <p>
     eg. CAP theorem
    </p>
    <p>
     虽然这些和btc 应用
    </p>
    <p>
     假定系统中小部分为恶意节点，大部分是好的，所以如何处理consensus in bitcoin
    </p>
    <p>
     比如 hyperledger（如fabric） ，当membership 是有门槛的，所以可以使用投票协议。
     <br/>
     如果没有门槛，还采用投票协议，会出现sybil attack
     <br/>
     Sybil攻击（Sybil Attack）
    </p>
    <h4>
     <a id="321_bitcoin__150">
     </a>
     3.2.1 bitcoin 如何解决？
    </h4>
    <p>
     只有找到nonce ，才会有记账权，
    </p>
    <p>
     记账权（Bookkeeping Rights）
     <br/>
     分叉攻击？ forking attack 。bitcoin 的规则是： 连接到最长合法链 。
    </p>
    <p>
     longgest valid chain 。
     <br/>
     比特币中被废弃的分叉：孤块（Orphan Block）与陈旧块（Stale Block）
     <br/>
     求解 puzzle friendly 就是靠算力来投票。看每秒钟能试出多少个nasco数 ，hash rate 决定投票权重
    </p>
    <h2>
     <a id="_btc__166">
     </a>
     四、 btc 实现
    </h2>
    <p>
     UTXO（Unspent Transaction Output）未花费交易输出
     <br/>
     utxo 检测是不是double spending
    </p>
    <p>
     交易型账本 vs 账户型账本
    </p>
    <p>
     挖矿的时候用 block header就能保证这个链没有篡改。
     <br/>
     区块头（Block Header）与区块体（Block Body）比较
    </p>
    <p>
     比特币的Extra Nonce与挖矿双层循环
    </p>
    <p>
     挖矿公平性保证： progress free
     <br/>
     Progress-Free（无进展性）
     <br/>
     比特币的挖矿 除了比拼算力外，没有任何意义，稀缺性是人为造成的，他越来越少是因为初块奖励人为减少。
     <br/>
     但是！bitcoin is secured by mining
     <br/>
     只要大部分算力掌握在诚实节点手里，那么系统安全就能得到保证。
     <br/>
     是不是说挖矿动力越来越小呢？ 恰恰相反，竞争越来越激烈，bitcoin的价格飙升
    </p>
    <p>
     挖矿是比较大的概率落到诚实的节点上。
     <br/>
     就算落到不诚实节点，由于不诚实节点虽然获得记账权，但是他不知道别人的私钥，那么这个钱就转不走。
     <br/>
     如果不诚实的节点获得记账权，乱记，诚实的节点不会接受这个交易，诚实节点会向上追溯，链接到上面去。
    </p>
    <p>
     抛弃不诚实的节点。
    </p>
    <ul>
     <li>
      <p>
       那么问题来了，不诚实的节点能做到double spending吗？
       <br/>
       不行，如果不合法，诚实节点不会接受。
      </p>
     </li>
     <li>
      <p>
       那能不能分叉攻击呢？
       <br/>
       也不行，因为挖矿的时候，设置的block header里要填上前一个区块的hash，所以要差到前面的区块的话，一开始就要差到前面。
      </p>
     </li>
    </ul>
    <p>
     分叉攻击的目的是什么？ 干掉其他链。开始m-&gt;a 成功后，非要再来个下面的m-&gt;m, 干掉下面的m-&gt;a
     <br/>
     如何防范？ 后面跟一个区块后，后面再跟6个区块，然后才认为前面的是不可篡改的。
     <br/>
     一个区块是10分钟。
     <br/>
     <strong>
      mining 机制的设立为了维护系统安全性
     </strong>
    </p>
    <p>
     假设大部分的算力掌握在诚实的矿工手里，也不能保证所有写入区块链的交易是合法的。挖矿给出的是概率上的保证。
    </p>
    <ol start="5">
     <li>
      btc 网络 ： the bitcoin network
      <br/>
      用户把 交易发送的btc网络上，节点收到交易，把这些交易打包到区块里，然后把区块发布到比特币网络上。
      <br/>
      那么btc网络怎么传播呢？
     </li>
    </ol>
    <p>
     <strong>
      application layer： bitcoin block chain
      <br/>
      network layer： p2p overlay network
     </strong>
     <br/>
     这个p2p节点很简单，每个节点都是对等的
     <br/>
     simple ，robust，but not efficient
     <br/>
     消息节点采用flooding
     <br/>
     邻居节点是随机的，不考虑网络拓扑，这样增强了鲁棒性（robust），但是降低了效率 。
     <br/>
     转发的前提是这个交易是合法的，
     <br/>
     每个节点要维护一个等待上链的交易集合：
     <br/>
     传播属于best effort
     <br/>
     越是大的区块，在网络上传播越慢
     <br/>
     带宽是瓶颈。限制是1m
    </p>
    <p>
     挖矿难度
    </p>
    <p>
     H(block header) &lt;= target
     <br/>
     采用的是SHA-256
     <br/>
     通俗来说要是合法的区块，要求hash 前面有多少个0
    </p>
    <p>
     51% attack
     <br/>
     出块 时间是10min
     <br/>
     以太坊 出块速度变快为 15s ，就需要设置新的共识协议 ghost ，会产生了很多orphan block ，但是对orphan block 也会有奖励
    </p>
    <p>
     如何调整挖矿难度？
     <br/>
     2016个区块调整一下难度 ，每个区块十分钟，大概是14天调整一下区块。
     <br/>
     调整公式： target= target x （actual time / expected time）
    </p>
    <p>
     expected time = 2016 x10 min
     <br/>
     actual time 最近的2016 个区块实际花费的时间
    </p>
    <p>
     5 btc 脚本
    </p>
    <p>
     6 分叉
    </p>
    <p>
     比特币中的分叉类型全解析：Forking Attack、Deliberate Fork 与 Protocol Fork
    </p>
    <p>
     P2SH (Pay-to-Script-Hash) 详解
    </p>
    <ol start="7">
     <li>
      匿名性
     </li>
    </ol>
    <p>
     bitcoin and anonymity
    </p>
    <p>
     bitcoin 匿名性&lt;银行存款&lt; 现金
    </p>
    <p>
     bitcoin 完全公开
    </p>
    <p>
     如何保证匿名性： 建议出入使用不同账户但是找零
    </p>
    <p>
     7.1 找零
     <br/>
     把不同的地址关联在一起： 找零
     <br/>
     输出地址之间有可能是一部分是同一个的。
     <br/>
     但是找零的地址虽然不是固定位置，但是可以分析出来 。
     <br/>
     7.2 资金转入转出
     <br/>
     bitcoin 和实体账户换钱
     <br/>
     怎么办？ 去交易所、场外交易
     <br/>
     7.3 用btc 支付
     <br/>
     在实体世界用btc 支付
     <br/>
     交易费贵
     <br/>
     等待确认时间长
     <br/>
     引起隐私泄露，你的虚拟账户和真实世界产生联系了
    </p>
    <p>
     hide your identity from whom？
     <br/>
     在application layer 层
     <br/>
     但是可以在network layer
    </p>
    <p>
     在线钱包、交易所 天然的 coin mixing
    </p>
    <p>
     不可篡改实际上对隐私保护并不合适，是摘难性的，账户之间的关联性是要小心的
     <br/>
     可摘难性（NP-hardness）解释
    </p>
    <p>
     7.5 零知识证明 （zero-knowledge proof）
     <br/>
     零知识证明是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无序透露除该成熟时正确的歪的忍者信息
    </p>
    <p>
     eg: 数字签名 不一定是零知识证明，因为透露了公钥
    </p>
    <p>
     7.6 同态隐藏
     <br/>
     如果x,y 不同，那么他们的加密函数值 e(x),e(y) 也不相同
     <br/>
     给定e（x）的 值，很难翻推出x的值
     <br/>
     给定e（x） 和 e（y）的值，我们可以很容易地计算出某些关于x，y 的加密函数值。
     <br/>
     同态加法： 通过ex和 ey 计算出e（x+y）的 值
     <br/>
     同态乘法： 通·过ex 和 ey 计算出e（xy）的值
     <br/>
     扩展到多项式
    </p>
    <p>
     同态隐藏（Homomorphic Hiding）
    </p>
    <p>
     虚拟货币编号不能是央行产生的，这样信息泄漏了。
    </p>
    <p>
     和 bitcoin 不一样。 零币就是破坏了关联性。
     <br/>
     为什么这些匿名性 不是主流货币： 1. 性能不行， 2. 对初始化要求比较高。3. 需要强匿名性的用户不是很多。4. 和实体发生交互的时候还是要暴露身份。
    </p>
    <p>
     零钞(Zerocash)和零币(Zerocoin)
    </p>
    <p>
     Bitcoin区块链的创世区块溯源
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33323634313039352f:61727469636c652f64657461696c732f313436323631373938" class_="artid" style="display:none">
 </p>
</div>


