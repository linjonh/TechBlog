---
layout: post
title: "JS如何判断数据类型全能判断方式Object.prototype.toString.call"
date: 2025-03-11 19:25:28 +0800
description: "b. ​引用类型：优先使用 Object.prototype.toString.call()。​功能：允许对象自定义 Object.prototype.toString 返回的标签。返回结果：格式为 [object Xxx]（如 [object Array]）。无法区分数组、对象、日期等引用类型（均返回 “object”）。​a. 基本类型：使用 typeof（注意 null 的陷阱）。无法区分 null（返回 “object”）和对象类型。适用于检测所有数据类型（包括基本类型和引用类型）。"
keywords: "JS—如何判断数据类型：全能判断方式Object.prototype.toString.call()"
categories: ['Web']
tags: ['开发语言', '原型模式', '判断数据类型', 'Javascript']
artid: "146186263"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146186263
    alt: "JS如何判断数据类型全能判断方式Object.prototype.toString.call"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146186263
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146186263
cover: https://bing.ee123.net/img/rand?artid=146186263
image: https://bing.ee123.net/img/rand?artid=146186263
img: https://bing.ee123.net/img/rand?artid=146186263
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JS—如何判断数据类型：全能判断方式Object.prototype.toString.call()
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      个人博客：
      <a href="http://haichenyi.com" rel="nofollow">
       haichenyi.com
      </a>
      。感谢关注
     </strong>
     <br/>
     <span id="c1">
     </span>
    </p>
    <h3>
     <a id="1__2">
     </a>
     1. 目录
    </h3>
    <ul>
     <li>
      <a href="#c1" rel="nofollow">
       1–目录
      </a>
     </li>
     <li>
      <a href="#c2" rel="nofollow">
       2–typeof 操作符
      </a>
     </li>
     <li>
      <a href="#c3" rel="nofollow">
       3–instanceof 操作符
      </a>
     </li>
     <li>
      <a href="#c4" rel="nofollow">
       4–Object.prototype.toString.call()
      </a>
     </li>
     <li>
      <a href="#c5" rel="nofollow">
       5–Array.isArray()
      </a>
     </li>
     <li>
      <a href="#c6" rel="nofollow">
       6–=== 严格相等
      </a>
     </li>
     <li>
      <a href="#c7" rel="nofollow">
       7–constructor 属性
      </a>
     </li>
     <li>
      <a href="#c8" rel="nofollow">
       8–Symbol.toStringTag（ES6+）
      </a>
     </li>
    </ul>
    <p>
     <span id="c2">
     </span>
    </p>
    <h3>
     <a id="2_typeof__13">
     </a>
     2. typeof 操作符
    </h3>
    <p>
     ​功能：检测基本数据类型。
     <br/>
     返回结果：返回类型字符串（如 “number”, “string”）
     <br/>
     特点：
     <br/>
     无法区分 null（返回 “object”）和对象类型。
     <br/>
     无法区分数组、对象、日期等引用类型（均返回 “object”）。
    </p>
    <pre><code>console.log(typeof 42);          // "number"
console.log(typeof "hello");     // "string"
console.log(typeof true);        // "boolean"
console.log(typeof undefined);   // "undefined"
console.log(typeof null);        // "object" (历史遗留问题)
console.log(typeof []);          // "object"
console.log(typeof {});          // "object"
</code></pre>
    <p>
     <img alt="typeof结果图" src="https://i-blog.csdnimg.cn/direct/9347eeceedea4c21931597a7e4c0be63.png">
      <br/>
      <span id="c3">
      </span>
     </img>
    </p>
    <h3>
     <a id="3_instanceof__31">
     </a>
     3. instanceof 操作符
    </h3>
    <p>
     功能：检测对象是否为某个构造函数的实例
     <br/>
     ​特点：
     <br/>
     用于检测引用类型（如数组、自定义对象）。
     <br/>
     无法检测基本数据类型。
     <br/>
     跨窗口/框架时可能失效（不同全局环境下的构造函数不同）
    </p>
    <pre><code>console.log([] instanceof Array);       // true
console.log({} instanceof Object);       // true
console.log(new Date() instanceof Date); // true

function Person() {}
const person = new Person();
console.log(person instanceof Person);  // true
</code></pre>
    <p>
     <img alt="instanceof结果图" src="https://i-blog.csdnimg.cn/direct/1f15df89370f4e8db4419bfd92620e5c.png">
      <br/>
      <span id="c4">
      </span>
     </img>
    </p>
    <h3>
     <a id="4_ObjectprototypetoStringcall_49">
     </a>
     4. Object.prototype.toString.call()
    </h3>
    <p>
     功能：最精确的类型检测方法，可区分所有内置对象。
     <br/>
     返回结果：格式为 [object Xxx]（如 [object Array]）。
     <br/>
     ​特点：
     <br/>
     适用于检测所有数据类型（包括基本类型和引用类型）。
     <br/>
     可识别 null 和 undefined。
    </p>
    <pre><code>console.log(Object.prototype.toString.call(42));          // "[object Number]"
console.log(Object.prototype.toString.call("hello"));     // "[object String]"
console.log(Object.prototype.toString.call(null));        // "[object Null]"
console.log(Object.prototype.toString.call(undefined));   // "[object Undefined]"
console.log(Object.prototype.toString.call([]));          // "[object Array]"
console.log(Object.prototype.toString.call({}));          // "[object Object]"
console.log(Object.prototype.toString.call(new Date()));  // "[object Date]"
</code></pre>
    <p>
     <img alt="Object.prototype.toString.call()结果图" src="https://i-blog.csdnimg.cn/direct/38b24bf054db4e70bf9f6faae19ca8c1.png">
      <br/>
      <span id="c5">
      </span>
     </img>
    </p>
    <h3>
     <a id="5_ArrayisArray_66">
     </a>
     5. Array.isArray()
    </h3>
    <p>
     功能：专门检测变量是否为数组
     <br/>
     ​特点：
     <br/>
     ES5 引入，比 instanceof 更可靠（避免跨窗口问题）。
     <br/>
     替代旧方法 arr instanceof Array。
    </p>
    <pre><code>console.log(Array.isArray([]));     // true
console.log(Array.isArray({}));     // false
</code></pre>
    <p>
     <img alt="Array.isArray()结果图" src="https://i-blog.csdnimg.cn/direct/180da82ca80448e3a50a6b9c75be7300.png">
      <br/>
      <span id="c6">
      </span>
     </img>
    </p>
    <h3>
     <a id="6___77">
     </a>
     6. === 严格相等
    </h3>
    <p>
     功能：检测 null 或 undefined
     <br/>
     ​特点：
     <br/>
     null 和 undefined 无法用 typeof 准确检测。
     <br/>
     直接使用严格相等判断。
    </p>
    <pre><code>const value = null;
console.log(value === null);        // true
const value2 = undefined;
console.log(value2 === undefined); // true
</code></pre>
    <p>
     <img alt="=== 严格相等结果图" src="https://i-blog.csdnimg.cn/direct/7cec6583f5654bfda306bc906bc420b0.png">
      <br/>
      <span id="c7">
      </span>
     </img>
    </p>
    <h3>
     <a id="7_constructor__90">
     </a>
     7. constructor 属性
    </h3>
    <p>
     功能：通过对象的构造函数属性判断类型。
     <br/>
     ​特点：
     <br/>
     不推荐使用，因为 constructor 可被修改。
     <br/>
     对基本数据类型无效（如 42.constructor 会报错）。
    </p>
    <pre><code>const arr = [];
console.log(arr.constructor === Array); // true

const obj = {};
console.log(obj.constructor === Object); // true

// 可能被篡改
arr.constructor = Object;
console.log(arr.constructor === Array);  // false
</code></pre>
    <p>
     <img alt="constructor 属性结果图" src="https://i-blog.csdnimg.cn/direct/90ec879488c342e9866dce43f21f9206.png">
      <br/>
      <span id="c8">
      </span>
     </img>
    </p>
    <h3>
     <a id="8_SymboltoStringTag_108">
     </a>
     8. Symbol.toStringTag
    </h3>
    <p>
     ​功能：允许对象自定义 Object.prototype.toString 返回的标签。
     <br/>
     ​特点：
     <br/>
     用于高级场景（如自定义类）。
     <br/>
     不影响 typeof 或 instanceof。
    </p>
    <pre><code>class MyClass {
  get [Symbol.toStringTag]() {
    return "MyClass";
  }
}
const obj = new MyClass();
console.log(Object.prototype.toString.call(obj)); // "[object MyClass]"
</code></pre>
    <p>
     <img alt="Symbol.toStringTag结果图" src="https://i-blog.csdnimg.cn/direct/2a9098b496b140db9fa1244c830bb8b1.png">
      <br/>
      <strong>
       PS:整篇文章，精炼一下，如下
      </strong>
      <br/>
      方法对比与选择指南
     </img>
    </p>
    <table>
     <thead>
      <tr>
       <th align="center">
        检测方式
       </th>
       <th align="center">
        ​适用场景
       </th>
       <th align="center">
        注意事项
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        typeof
       </td>
       <td align="center">
        检测基本数据类型(除null)
       </td>
       <td align="center">
        无法区分null和对象
       </td>
      </tr>
      <tr>
       <td align="center">
        instanceof
       </td>
       <td align="center">
        检测引用类型(如数组，自定义对象)
       </td>
       <td align="center">
        无法检测基本数据类型，跨窗口失效
       </td>
      </tr>
      <tr>
       <td align="center">
        Object.prototype.toString.call()
       </td>
       <td align="center">
        <strong>
         精确检测所有类型，推荐
        </strong>
       </td>
       <td align="center">
        需配合.call方法使用
       </td>
      </tr>
      <tr>
       <td align="center">
        Array.isArray()
       </td>
       <td align="center">
        检测数组
       </td>
       <td align="center">
        只能用于检测数组，无法检测其他
       </td>
      </tr>
      <tr>
       <td align="center">
        === 严格相等
       </td>
       <td align="center">
        检测null和undefined
       </td>
       <td align="center">
        只能检测这两个类型，无法检测其他
       </td>
      </tr>
      <tr>
       <td align="center">
        constructor 属性
       </td>
       <td align="center">
        快速检测已知构造函数
       </td>
       <td align="center">
        构造函数可被篡改，不推荐
       </td>
      </tr>
      <tr>
       <td align="center">
        Symbol.toStringTag
       </td>
       <td align="center">
        自定义对象的类型标签
       </td>
       <td align="center">
        高级用法，兼容性需注意
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     最佳实践
     <br/>
     ​a. 基本类型：使用 typeof（注意 null 的陷阱）。
     <br/>
     b. ​引用类型：优先使用 Object.prototype.toString.call()。
     <br/>
     ​c. 数组检测：使用 Array.isArray()。
     <br/>
     d. ​
     <strong>
      null/undefined
     </strong>
     ：直接使用 === 判断。
     <br/>
     ​f. 自定义类型：结合 instanceof 和 Symbol.toStringTag
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32373633343739372f:61727469636c652f64657461696c732f313436313836323633" class_="artid" style="display:none">
 </p>
</div>


