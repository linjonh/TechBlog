---
layout: post
title: "设计模式-原型模式"
date: 2025-03-16 23:34:34 +0800
description: "原型模式是一种创建型设计模式，它通过复制现有对象来创建新对象，而不是通过实例化类。原型模式的核心思想是通过克隆（Clone）来创建对象，从而避免重复的初始化操作，提高性能。"
keywords: "设计模式-原型模式"
categories: ['设计模式']
tags: ['设计模式', '原型模式', 'Java']
artid: "146303780"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146303780
    alt: "设计模式-原型模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146303780
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146303780
cover: https://bing.ee123.net/img/rand?artid=146303780
image: https://bing.ee123.net/img/rand?artid=146303780
img: https://bing.ee123.net/img/rand?artid=146303780
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     设计模式-原型模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     原型模式是一种
     <code>
      创建型设计模式
     </code>
     ，它通过复制现有对象来创建新对象，而不是通过实例化类。原型模式的核心思想是通过克隆（Clone）来创建对象，从而避免重复的初始化操作，提高性能。
    </p>
    <h3>
     <a id="_2">
     </a>
     核心思想
    </h3>
    <p>
     原型模式的核心思想是
     <code>
      通过克隆来创建对象
     </code>
     ，而不是通过new关键字实例化对象。它的主要优点包括：
    </p>
    <ul>
     <li>
      减少重复初始化操作：如果对象的创建过程比较复杂或耗时，可以通过克隆来避免重复的初始化。
     </li>
     <li>
      动态创建对象：可以在运行时动态地创建对象，而不需要知道具体的类。
     </li>
     <li>
      简化对象创建：对于复杂的对象结构，克隆比重新构建更加方便。
     </li>
    </ul>
    <h3>
     <a id="_9">
     </a>
     原型模式的结构
    </h3>
    <p>
     原型模式通常包含以下角色：
    </p>
    <ul>
     <li>
      <code>
       原型接口
      </code>
      （Prototype）
      <br/>
      定义克隆方法的接口。通常是一个抽象类或接口，包含一个clone()方法。
     </li>
     <li>
      <code>
       具体原型类
      </code>
      （Concrete Prototype）
      <br/>
      实现原型接口，提供具体的克隆逻辑。负责复制自身并返回一个新的对象。
     </li>
     <li>
      <code>
       客户端
      </code>
      （Client）
      <br/>
      通过调用原型对象的clone()方法来创建新对象。
     </li>
    </ul>
    <h3>
     <a id="_19">
     </a>
     原型模式的实现示例
    </h3>
    <p>
     以下是一个简单的原型模式实现示例，假设我们要克隆一个“汽车”对象。
     <br/>
     <strong>
      （1）原型接口（Prototype）
     </strong>
    </p>
    <pre><code>public interface Prototype extends Cloneable {
    Prototype clone();
}
</code></pre>
    <p>
     <strong>
      （2）具体原型类（Concrete Prototype）
     </strong>
    </p>
    <pre><code>public class Car implements Prototype {
    private String brand;
    private String model;
    private String color;

    public Car(String brand, String model, String color) {
        this.brand = brand;
        this.model = model;
        this.color = color;
    }

    @Override
    public Car clone() {
        try {
            return (Car) super.clone(); // 调用Object的clone()方法
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String toString() {
        return "Car [brand=" + brand + ", model=" + model + ", color=" + color + "]";
    }
}
</code></pre>
    <p>
     <strong>
      （3）客户端代码（Client）
     </strong>
    </p>
    <pre><code>public class Client {
    public static void main(String[] args) {
        // 创建原型对象
        Car originalCar = new Car("Tesla", "Model S", "Red");
        System.out.println("Original Car: " + originalCar);

        // 克隆原型对象
        Car clonedCar = originalCar.clone();
        System.out.println("Cloned Car: " + clonedCar);

        // 修改克隆对象的属性
        clonedCar.setColor("Blue");
        System.out.println("Modified Cloned Car: " + clonedCar);
    }
}
</code></pre>
    <h3>
     <a id="_78">
     </a>
     原型模式的优点
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        减少初始化开销
       </strong>
       <br/>
       通过克隆来创建对象，避免了重复的初始化操作，提高了性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        动态创建对象
       </strong>
       <br/>
       可以在运行时动态地创建对象，而不需要知道具体的类。
      </p>
     </li>
     <li>
      <p>
       <strong>
        简化对象创建
       </strong>
       <br/>
       对于复杂的对象结构，克隆比重新构建更加方便。
      </p>
     </li>
     <li>
      <p>
       <strong>
        避免构造函数的约束
       </strong>
       <br/>
       克隆不需要调用构造函数，因此可以避免构造函数中的一些限制。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_92">
     </a>
     原型模式的缺点
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        深拷贝与浅拷贝问题
       </strong>
       <br/>
       默认的clone()方法是浅拷贝，如果对象包含引用类型的属性，可能需要实现深拷贝。
      </p>
     </li>
     <li>
      <p>
       <strong>
        需要实现Cloneable接口
       </strong>
       <br/>
       必须实现Cloneable接口并重写clone()方法，否则会抛出CloneNotSupportedException异常。
      </p>
     </li>
     <li>
      <p>
       <strong>
        破坏封装性
       </strong>
       <br/>
       克隆可能会绕过构造函数，导致对象的初始化逻辑被忽略。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_103">
     </a>
     原型模式的应用场景
    </h3>
    <ol>
     <li>
      <p>
       对象创建成本较高
       <br/>
       例如，对象的初始化需要从数据库或网络中加载大量数据。
      </p>
     </li>
     <li>
      <p>
       需要动态创建对象
       <br/>
       例如，在运行时根据条件创建不同的对象。
      </p>
     </li>
     <li>
      <p>
       对象结构复杂
       <br/>
       例如，对象包含多个嵌套的子对象，重新构建比较困难。
      </p>
     </li>
     <li>
      <p>
       需要避免重复初始化
       <br/>
       例如，对象的初始化过程非常耗时，可以通过克隆来避免重复初始化。
      </p>
     </li>
    </ol>
    <h3>
     <a id="_117">
     </a>
     原型模式的实际应用
    </h3>
    <ul>
     <li>
      <p>
       Java中的Cloneable接口
       <br/>
       Java提供了Cloneable接口和clone()方法，支持原型模式的实现。
      </p>
     </li>
     <li>
      <p>
       Spring框架中的原型Bean
       <br/>
       在Spring框架中，可以通过配置scope="prototype"来创建原型Bean，每次请求都会返回一个新的实例。
      </p>
     </li>
     <li>
      <p>
       游戏开发中的对象复制
       <br/>
       在游戏开发中，可以通过原型模式快速复制游戏角色、道具等对象。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_127">
     </a>
     原型模式与工厂模式的区别
    </h3>
    <p>
     <code>
      工厂模式
     </code>
     ：通过工厂类来创建对象，隐藏了对象的创建逻辑。
     <br/>
     <code>
      原型模式
     </code>
     ：通过克隆现有对象来创建新对象，避免了重复的初始化操作。
    </p>
    <blockquote>
     <p>
      通过原型模式，可以高效地创建复杂对象，同时避免重复的初始化操作。在实际开发中，需要根据具体需求选择浅拷贝或深拷贝。
     </p>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34303937383438382f:61727469636c652f64657461696c732f313436333033373830" class_="artid" style="display:none">
 </p>
</div>


