---
layout: post
title: "linux-天气爬虫"
date: 2025-03-07 20:22:53 +0800
description: "这段代码实现了一个天气查询系统，支持实时天气、未来天气和历史天气查询。用户可以通过终端菜单选择查询类型，并输入城市名称来获取相应的天气信息。程序通过 TCP 连接发送 HTTP 请求，并解析返回的 JSON 数据来展示天气信息。演示视频：存储菜单选项，包括实时天气、未来天气、历史天气和退出查询。 和 ：定义菜单显示的起始和结束位置。：当前用户选择的菜单焦点。：标志当前显示的菜单层级， 表示主菜单， 表示二级菜单。：存储用户输入的城市名称。：TCP 套接字文件描述符。功能：捕捉用户按键输入，支持方向键和"
keywords: "linux---天气爬虫"
categories: ['未分类']
tags: ['运维', '爬虫', 'Linux']
artid: "146103875"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146103875
    alt: "linux-天气爬虫"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146103875
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146103875
cover: https://bing.ee123.net/img/rand?artid=146103875
image: https://bing.ee123.net/img/rand?artid=146103875
img: https://bing.ee123.net/img/rand?artid=146103875
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     linux---天气爬虫
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     代码概述
    </h5>
    <p>
     这段代码实现了一个天气查询系统，支持实时天气、未来天气和历史天气查询。用户可以通过终端菜单选择查询类型，并输入城市名称来获取相应的天气信息。程序通过 TCP 连接发送 HTTP 请求，并解析返回的 JSON 数据来展示天气信息。
    </p>
    <pre><code class="language-cpp">#include "main.h"

#include "cJSON.h"
#define BUFFER_SIZE 30000
#define TEMP_BUFFER_SIZE 4096

#define COLOR_FIELD "\033[34m"   // 字段蓝色
#define COLOR_VALUE "\033[36m"   // 值青色
#define COLOR_WARN  "\033[33m"   // 警告黄色
#define COLOR_RESET "\033[0m"    // 重置颜色
#define COLOR_HEAD "\033[35m"    // 提示头颜色


char weather_inquiry[4][1024] = 
{
	{"实时天气"},
	{"未来天气"},
	{"历史天气"},
	{"退出查询"},
};

int pos_start = 0;
int pos_end = 4;
int focus = 0;//选择的焦点
int menu_flag = 1;
char city[512];//储存城市名字
int sockfd;

int getch(void)
{
	struct termios oldt, newt;
	int ch;
	int esc_mode = 0;
	unsigned long key = 0;
	//获取终端属性信息
	tcgetattr(STDIN_FILENO, &amp;oldt);
	newt = oldt;
	//设置非阻塞模式
	newt.c_lflag &amp;= ~(ICANON | ECHO);
	newt.c_cc[VMIN] = 0;//读取最小字符
	newt.c_cc[VTIME] = 1;//等待时间１０/１秒

	//修改new中的ECHO和ICANON参数，使得new为不回显输入内容
	//设置终端信息
	tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt);
	//组合多字节按键
	for(int i = 0;i &lt; 3;i++)
	{
		ch = getchar();
		if(ch == EOF)break;
		key = (key &lt;&lt; 8)|(ch &amp; 0xFF);
	}
		//用完之后，恢复原来的终端属性
		tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt);

		switch(key){
		case 0x1B5B41:	return KEY_UP;
		case 0x1B5B42:	return KEY_DOWN;
		case 0x0A:		return KEY_ENTER;
		default:		return (key&amp;0xFF);//返回首个有效字符				
		}
}

void View_two(void)
{
	if(menu_flag == 2)
	{
		int i = 0;
		printf("\033[10;35H");
		printf("| 	     	   天气查询	          |\n");
		printf("\033[0m");
		for(i = pos_start;i &lt;pos_end;i++)
		{
			if(i == focus)
			{
				printf("\033[%d;50H",i+12);
				printf("|\033[30;43m%2d.%s\033[0m\n",i+1,weather_inquiry[i]);
			}else{
				printf("\033[%d;50H",12+i);
				printf("|%2d.%-20s\n",i+1,weather_inquiry[i]);
			}
		}
	}
	return;
}

void city_name(void)
{		
	scanf("%s",city);
	while(getchar()!= '\n');
	printf("\033[0m");
	if(strncmp(city,"quit",4) == 0)
	{
		exit(0);
		printf("感谢使用！\n");
	}
}


#if 1
void view(void)
{
	if(menu_flag == 1)
	{
		printf("\033[15;55H");
		printf("\033[;31m");
		printf("输入quit退出\n");

		printf("\033[10;25H");
		printf("\033[;33m");
		printf("～欢迎来到天气查询系统～\n");
		printf("\033[0m");

		printf("\033[12;25H");
		printf("\033[;34m");
		printf("请输入你要查询的城市:");
		// 清空城市名
		memset(city, 0, sizeof(city));
		city_name();
		menu_flag = 2;
		system("clear");
	}else if(menu_flag == 2)
	{
		View_two();
	}

	return;
}

#endif

void CreateTcpClient(void)//创建ＴＣＰ
{
	int ret = 0;

	sockfd = socket(AF_INET,SOCK_STREAM,0);
	if(sockfd &lt; 0)
	{
		perror("sockfd fail");
		return;
	}
	
	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(PORT);
	seraddr.sin_addr.s_addr = inet_addr(IP);

	if(connect(sockfd,(struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return;
	}
}

//发送HTTP请求(参数：天气类型)
void SendHttpRequest(int sockfd,char *head)
{
	char tmpbuff[4096] = {0};
	int written = 0;
	const char *template =
		"GET %s HTTP/1.1\r\n"
		"Host: api.k780.com\r\n"
		"User-Agent: WeatherClient/1.0\r\n"
		"Accept: */*\r\n"
		"Connection: close\r\n"  // 改为短连接
		"\r\n";  // 必须的空行
	
	// 安全格式化（限制最大长度）
	written = snprintf(tmpbuff,sizeof(tmpbuff),template,head);
	if (written &gt;= sizeof(tmpbuff)) {
        fprintf(stderr, "Request too large (max %zd bytes)\n", sizeof(tmpbuff));
        return;
    }
	//发送请求
	ssize_t sent = send(sockfd,tmpbuff,written,0);
	if(sent != written)
	{
		perror("send fail");
		return;
	}
}


void RecvSendWeather(void)
{
    int fd = 0;
    char buff[BUFFER_SIZE] = {0}; // 确保初始化为全0
    char cmpbuff[BUFFER_SIZE] = {0}; // 用于存储处理后的数据
    char tmpbuff[TEMP_BUFFER_SIZE] = {0}; // 临时缓冲区
    ssize_t nsize = 0; // recv函数接收的数据大小
    char *ptmp = NULL; // 临时指针
    char *pstart = NULL; // 数据起始位置指针
    char *pend = NULL; // 数据结束位置指针

    fd = open("recv.txt", O_RDWR | O_CREAT | O_TRUNC, 0666);

    while(1)
    {
        memset(tmpbuff, 0, sizeof(tmpbuff)); // 清空临时缓冲区
        nsize = recv(sockfd, tmpbuff, sizeof(tmpbuff), 0);

        if(nsize &lt;= 0)
        {
            break;
        }

        strncat(buff, tmpbuff, (size_t)nsize); // 将接收到的数据追加到buff中

        if(strstr(tmpbuff, "0\r\n") != NULL)
            break;
    }

    //查找数据正文的起始位置
    ptmp = strstr(buff, "\r\n\r\n");
    if(ptmp != NULL)
    {
        ptmp += 4; //跳过"\r\n\r\n"
        ptmp = strstr(ptmp, "\r\n");
        if(ptmp != NULL)
        {
            ptmp += 2;
            pstart = ptmp; //标记数据起始位置
            pend = strstr(ptmp, "\r\n"); //查找数据结束位置

            if(pend != NULL)
            {
                strncat(cmpbuff, pstart, pend - pstart);
            }
        }
    }

    write(fd, cmpbuff, strlen(cmpbuff)); // 将处理后的数据写入文件

    close(fd);
    close(sockfd);
}

void real_time_weather()
{
    int ret = -1;
    int fd = -1;
    char *buffer = NULL;
    ssize_t bytes_read = 0;

    CreateTcpClient(); // 创建新的连接
    if(!(buffer = malloc(BUFFER_SIZE))){
        perror("malloc fail");
        return;
    }
    if((fd = open("recv.txt", O_RDONLY)) == -1){
        perror("open fail");
        return;
    }
    if((bytes_read = read(fd, buffer, BUFFER_SIZE)) &lt;= 0){
        fprintf(stderr, "Read failed or empty file\n");
        return;
    }
    buffer[bytes_read] = '\0'; // 确保字符终止

    cJSON *root = cJSON_Parse(buffer);
    if(!root){
        fprintf(stderr, "JSON parse failed\n");
        return;
    }

    // 使用结构体定义字段映射
    struct FieldMapping {
        const char *json_key;
        const char *display_name;
        int required;  // 1表示必须字段
    } fields[] = {
        {"days", "日期", 1},
        {"week", "星期", 1},
        {"citynm", "城市", 1},
        {"temperature_curr", "当前温度", 1},
        {"temp_high", "最高温度", 0},
        {"temp_low", "最低温度", 0},
        {"weather", "天气状况", 1},
        {"humidity", "当前湿度", 0},
        {"humi_high", "最大湿度", 0},
        {"humi_low", "最小湿度", 0},
        {"wind", "风向", 1},
        {"winp", "风力", 1},
        {"aqi", "PM2.5", 0}
    };

    cJSON *result = cJSON_GetObjectItem(root, "result");
    if(!result){
        fprintf(stderr, "Missing result object\n");
        cJSON_Delete(root);
        return;
    }

    // 遍历所有字段定义
    for(size_t i = 0; i &lt; sizeof(fields)/sizeof(fields[0]); i++)
    {
        cJSON *item = cJSON_GetObjectItem(result, fields[i].json_key);

        printf(COLOR_FIELD"%-8s: "COLOR_RESET, fields[i].display_name);

        if(item &amp;&amp; item-&gt;valuestring)
        {
            printf(COLOR_VALUE"%s\n"COLOR_RESET, item-&gt;valuestring);
        }
        else
        {
            printf(COLOR_WARN"N/A\n"COLOR_RESET);
            if(fields[i].required)
            {
                fprintf(stderr, "Missing required field: %s\n", fields[i].json_key);
                cJSON_Delete(root);
                return;
            }
        }
    }

    ret = 0;
    free(buffer);
    cJSON_Delete(root);
    close(fd);
}



void future_weather()
{
	int ret = -1;
	int fd = -1;
	char *buffer = NULL;
	ssize_t bytes_read = 0;
	
	CreateTcpClient(); // 创建新的连接
	
	if(!(buffer = malloc(BUFFER_SIZE))){
		perror("malloc fail");
		return;
	}
	if((fd = open("recv.txt",O_RDONLY)) == -1){
		perror("open fail");
		return;
	}
	if((bytes_read = read(fd,buffer,BUFFER_SIZE)) &lt;= 0){
        fprintf(stderr, "Read failed or empty file\n");
		return;
	}
	buffer[bytes_read] = '\0';//确保字符终止

	cJSON *root = cJSON_Parse(buffer);
	if(!root){
        fprintf(stderr, "JSON parse failed\n");
		return;
	}

	// 使用结构体定义字段映射
    struct FieldMapping {
        const char *json_key;
       const char *display_name;
        int required;  // 1表示必须字段
    } fields[] = {
        {"days", "日期", 1},
        {"week", "星期", 1},
        {"citynm", "城市", 1},
        {"temp_high", "最高温度", 0},
        {"temp_low", "最低温度", 0},
        {"weather", "天气状况", 1},
        {"wind", "风向", 1},
        {"winp", "风力", 1},
    };

	cJSON *result = cJSON_GetObjectItem(root,"result");
	if(!result){
        fprintf(stderr, "Missing result object\n");
		cJSON_Delete(root);
	}
	
	int i = 0;
	cJSON *item;

	cJSON_ArrayForEach(item,result)
	{
		printf(COLOR_HEAD"=============第%d天气预报=============\n"COLOR_RESET,i+1);

		// 遍历所有字段定义
		for (size_t j = 0; j &lt; sizeof(fields)/sizeof(fields[0]); j++) {
			cJSON *field = cJSON_GetObjectItem(item, fields[j].json_key);

			printf(COLOR_FIELD"%-8s: "COLOR_RESET, fields[j].display_name);

			if (field &amp;&amp; field-&gt;valuestring) {
				printf(COLOR_VALUE"%s\n"COLOR_RESET, field-&gt;valuestring);
			} else {
				printf(COLOR_WARN"N/A\n"COLOR_RESET);
				if (fields[j].required) {
					fprintf(stderr, "Missing required field: %s\n", fields[j].json_key);
				}
        }
    }

		i++;
	}	

	cJSON_Delete(root);
	free(buffer);
	close(fd);
}



void historical_weather()
{
}

void MenuChoose(void)
{
	int key = getch();

	char tmpbuff[1024]={0};
	//ESC按键处理
	if(key == KEY_ESC){
		if(menu_flag == 2){
			menu_flag = 1;//切换到菜单一
			system("clear");
		}
	}

	switch(key){
		case KEY_UP:
			if(focus &gt; pos_start)
			{
				system("clear");
				focus--;
			}
			break;
		case KEY_DOWN:
			if(focus &lt; pos_end)
			{
				system("clear");
				focus++;
			}
			break;
		case KEY_ENTER:
			switch(focus){
			case 0:
				system("clear");
				CreateTcpClient();
				sprintf(tmpbuff,"/?app=weather.today&amp;weaid=%s&amp;appkey=%s&amp;sign=%s",city,API_KEY,API_SIGN);
				SendHttpRequest(sockfd,tmpbuff);

				RecvSendWeather();
				
				real_time_weather();
				if (sockfd &gt; 0) {
					close(sockfd);
					sockfd = -1;
				}
				break;

			case 1:
				system("clear");
				CreateTcpClient();
				sprintf(tmpbuff,"http://api.k780.com/?app=weather.future&amp;weaid=%s&amp;appkey=%s&amp;sign=%s&amp;format=json",city,API_KEY,API_SIGN);
				SendHttpRequest(sockfd,tmpbuff);
				RecvSendWeather();
				future_weather();
				break;

			case 2:

				break;

			case 3:
				printf("感谢使用！\n");
				exit(0);
				break;
			
			} 
	}
}

int main(int argc, const char *argv[])
{
	system("clear");
	while(1)
	{
		view();
		MenuChoose();
	}
	return 0;
}</code></pre>
    <p>
     演示视频
    </p>
    <div class="video">
     <iframe allowfullscreen="true" data-mediaembed="csdn" frameborder="0" id="LCWsi5dF-1741399551615" src="https://live.csdn.net/v/embed/467549" style="width:100%;height:100%;">
     </iframe>
     <p>
      天气查询演示视频
     </p>
    </div>
    <h2>
     一、函数总览
    </h2>
    <h3>
     全局变量
    </h3>
    <ul>
     <li>
      <p>
       <code>
        weather_inquiry[4][1024]
       </code>
       ：存储菜单选项，包括实时天气、未来天气、历史天气和退出查询。
      </p>
     </li>
     <li>
      <p>
       <code>
        pos_start
       </code>
       和
       <code>
        pos_end
       </code>
       ：定义菜单显示的起始和结束位置。
      </p>
     </li>
     <li>
      <p>
       <code>
        focus
       </code>
       ：当前用户选择的菜单焦点。
      </p>
     </li>
     <li>
      <p>
       <code>
        menu_flag
       </code>
       ：标志当前显示的菜单层级，
       <code>
        1
       </code>
       表示主菜单，
       <code>
        2
       </code>
       表示二级菜单。
      </p>
     </li>
     <li>
      <p>
       <code>
        city[512]
       </code>
       ：存储用户输入的城市名称。
      </p>
     </li>
     <li>
      <p>
       <code>
        sockfd
       </code>
       ：TCP 套接字文件描述符。
      </p>
     </li>
    </ul>
    <h3>
     第二部分：输入处理和菜单显示
    </h3>
    <h4>
     <code>
      getch()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：捕捉用户按键输入，支持方向键和回车键。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          termios
         </code>
         修改终端属性，禁用回显和行缓冲。
        </p>
       </li>
       <li>
        <p>
         捕捉按键组合，识别上方向键（
         <code>
          KEY_UP
         </code>
         ）、下方向键（
         <code>
          KEY_DOWN
         </code>
         ）和回车键（
         <code>
          KEY_ENTER
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         恢复终端属性。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <code>
      View_two()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：显示二级菜单，包括实时天气、未来天气、历史天气和退出查询。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据
         <code>
          focus
         </code>
         的值，高亮显示当前选中的菜单项。
        </p>
       </li>
       <li>
        <p>
         使用终端控制字符（如
         <code>
          \033
         </code>
         ）设置文字颜色和位置。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <code>
      city_name()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：获取用户输入的城市名称，并检查是否为退出命令。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          scanf
         </code>
         获取输入，并清除输入缓冲区。
        </p>
       </li>
       <li>
        <p>
         如果输入为
         <code>
          quit
         </code>
         ，程序退出。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <code>
      view()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：根据
       <code>
        menu_flag
       </code>
       的值，显示主菜单或二级菜单。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         主菜单显示欢迎信息，并提示用户输入城市名称。
        </p>
       </li>
       <li>
        <p>
         二级菜单显示天气查询选项。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     第三部分：TCP 连接和 HTTP 请求
    </h3>
    <h4>
     <code>
      CreateTcpClient()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：创建一个 TCP 套接字，并连接到指定的服务器。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          socket
         </code>
         创建套接字。
        </p>
       </li>
       <li>
        <p>
         设置服务器地址和端口。
        </p>
       </li>
       <li>
        <p>
         使用
         <code>
          connect
         </code>
         建立连接。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <code>
      SendHttpRequest()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：发送 HTTP GET 请求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          snprintf
         </code>
         格式化请求头，包括目标 URL 和必要头部信息。
        </p>
       </li>
       <li>
        <p>
         使用
         <code>
          send
         </code>
         发送请求。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     第四部分：数据接收和处理
    </h3>
    <h4>
     <code>
      RecvSendWeather()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：接收服务器响应，并提取数据正文。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          recv
         </code>
         循环接收数据，直到遇到空行（
         <code>
          0\r\n
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         查找数据正文的起始和结束位置，提取并存储到文件中。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     第五部分：实时天气查询
    </h3>
    <h4>
     <code>
      real_time_weather()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：解析实时天气 JSON 数据，并展示相关信息。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         从文件读取 JSON 数据。
        </p>
       </li>
       <li>
        <p>
         使用
         <code>
          cJSON
         </code>
         解析 JSON 数据。
        </p>
       </li>
       <li>
        <p>
         定义字段映射结构体，遍历字段并显示对应值。
        </p>
       </li>
       <li>
        <p>
         检查必填字段是否存在，若缺失则报错。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     第六部分：未来天气查询
    </h3>
    <h4>
     <code>
      future_weather()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：解析未来天气 JSON 数据，并展示相关信息。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         从文件读取 JSON 数据。
        </p>
       </li>
       <li>
        <p>
         使用
         <code>
          cJSON
         </code>
         解析 JSON 数据。
        </p>
       </li>
       <li>
        <p>
         定义字段映射结构体，遍历字段并显示对应值。
        </p>
       </li>
       <li>
        <p>
         遍历 JSON 数组，逐条显示未来天气信息。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     第七部分：菜单选择和主程序
    </h3>
    <h4>
     <code>
      MenuChoose()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：处理用户按键输入，实现菜单导航和功能选择。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据按键调整
         <code>
          focus
         </code>
         值，实现菜单上下导航。
        </p>
       </li>
       <li>
        <p>
         处理回车键，根据选中项执行对应功能：
        </p>
        <ul>
         <li>
          <p>
           实时天气查询：构造 URL 并发送请求，调用
           <code>
            real_time_weather
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           未来天气查询：构造 URL 并发送请求，调用
           <code>
            future_weather
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           退出程序：退出并显示感谢信息。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <code>
      main()
     </code>
     函数
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：主程序入口，循环显示菜单并处理用户输入。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         清屏并初始化终端。
        </p>
       </li>
       <li>
        <p>
         循环调用
         <code>
          view
         </code>
         和
         <code>
          MenuChoose
         </code>
         ，实现菜单显示和交互。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     二、重点函数
    </h2>
    <h3>
     <code>
      RecvSendWeather()
     </code>
     函数
    </h3>
    <pre><code class="language-cpp">void RecvSendWeather(void)
{
    int fd = 0;
    char buff[BUFFER_SIZE] = {0}; // 确保初始化为全0
    char cmpbuff[BUFFER_SIZE] = {0}; // 用于存储处理后的数据
    char tmpbuff[TEMP_BUFFER_SIZE] = {0}; // 临时缓冲区
    ssize_t nsize = 0; // recv函数接收的数据大小
    char *ptmp = NULL; // 临时指针
    char *pstart = NULL; // 数据起始位置指针
    char *pend = NULL; // 数据结束位置指针

    fd = open("recv.txt", O_RDWR | O_CREAT | O_TRUNC, 0666);

    while(1)
    {
        memset(tmpbuff, 0, sizeof(tmpbuff)); // 清空临时缓冲区
        nsize = recv(sockfd, tmpbuff, sizeof(tmpbuff), 0);

        if(nsize &lt;= 0)
        {
            break;
        }

        strncat(buff, tmpbuff, (size_t)nsize); // 将接收到的数据追加到buff中

        if(strstr(tmpbuff, "0\r\n") != NULL)
            break;
    }

    //查找数据正文的起始位置
    ptmp = strstr(buff, "\r\n\r\n");
    if(ptmp != NULL)
    {
        ptmp += 4; //跳过"\r\n\r\n"
        ptmp = strstr(ptmp, "\r\n");
        if(ptmp != NULL)
        {
            ptmp += 2;
            pstart = ptmp; //标记数据起始位置
            pend = strstr(ptmp, "\r\n"); //查找数据结束位置

            if(pend != NULL)
            {
                strncat(cmpbuff, pstart, pend - pstart);
            }
        }
    }

    write(fd, cmpbuff, strlen(cmpbuff)); // 将处理后的数据写入文件

    close(fd);
    close(sockfd);
}

</code></pre>
    <h4>
     1. 初始化与文件准备
    </h4>
    <ul>
     <li>
      定义缓冲区
      <code>
       buff
      </code>
      （存储完整数据）、
      <code>
       cmpbuff
      </code>
      （存储处理后的数据）和
      <code>
       tmpbuff
      </code>
      （临时接收数据）。
     </li>
     <li>
      创建/清空文件
      <code>
       recv.txt
      </code>
      用于保存最终数据。
     </li>
    </ul>
    <h4>
     2. 循环接收数据
    </h4>
    <ul>
     <li>
      通过
      <code>
       recv
      </code>
      从套接字
      <code>
       sockfd
      </code>
      接收数据到
      <code>
       tmpbuff
      </code>
      。
     </li>
     <li>
      将每次接收的数据追加到主缓冲区
      <code>
       buff
      </code>
      中。
     </li>
     <li>
      <strong>
       终止条件
      </strong>
      ：当收到包含
      <code>
       "0\r\n"
      </code>
      的数据时，认为传输结束，退出循环。
     </li>
    </ul>
    <h4>
     3. 数据解析
    </h4>
    <ul>
     <li>
      <strong>
       定位数据起始点
      </strong>
      ：
      <ul>
       <li>
        查找首个
        <code>
         \r\n\r\n
        </code>
        ，跳过HTTP头部。
       </li>
       <li>
        继续查找下一个
        <code>
         \r\n
        </code>
        ，跳过可能的分块长度字段（如
        <code>
         5\r\n
        </code>
        ）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       提取数据正文
      </strong>
      ：
      <ul>
       <li>
        从
        <code>
         pstart
        </code>
        到下一个
        <code>
         \r\n
        </code>
        之间的内容被视为有效数据，复制到
        <code>
         cmpbuff
        </code>
        。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     4. 保存与清理
    </h4>
    <ul>
     <li>
      将处理后的数据写入文件
      <code>
       recv.txt
      </code>
      。
     </li>
     <li>
      关闭文件描述符和套接字。
     </li>
    </ul>
    <hr/>
    <h4>
     潜在问题与改进建议
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        缓冲区溢出风险
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         问题
        </strong>
        ：
        <code>
         buff
        </code>
        和
        <code>
         cmpbuff
        </code>
        是固定大小，未检查
        <code>
         strncat
        </code>
        是否越界。
       </li>
       <li>
        <strong>
         建议
        </strong>
        ：增加长度检查，或改用动态内存分配。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分块编码处理不完整
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         问题
        </strong>
        ：代码假设数据仅包含一个分块（如
        <code>
         5\r\nhello\r\n0\r\n
        </code>
        ），可能漏掉多分块数据。
       </li>
       <li>
        <strong>
         建议
        </strong>
        ：循环解析所有分块，处理格式如
        <code>
         长度\r\n数据\r\n
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结束标志可靠性
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         问题
        </strong>
        ：若
        <code>
         0\r\n
        </code>
        被拆分成多次接收（如
        <code>
         0\r
        </code>
        和
        <code>
         \n
        </code>
        ），可能无法正确退出。
       </li>
       <li>
        <strong>
         建议
        </strong>
        ：在
        <code>
         buff
        </code>
        中全局搜索
        <code>
         0\r\n
        </code>
        ，而非仅检查
        <code>
         tmpbuff
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <code>
      real_time_weather()
     </code>
     函数
    </h3>
    <pre><code class="language-cpp">void real_time_weather()
{
    int ret = -1;
    int fd = -1;
    char *buffer = NULL;
    ssize_t bytes_read = 0;


    CreateTcpClient(); // 创建新的连接
    if(!(buffer = malloc(BUFFER_SIZE))){
        perror("malloc fail");
        return;
    }
    if((fd = open("recv.txt", O_RDONLY)) == -1){
        perror("open fail");
        return;
    }
    if((bytes_read = read(fd, buffer, BUFFER_SIZE)) &lt;= 0){
        fprintf(stderr, "Read failed or empty file\n");
        return;
    }
    buffer[bytes_read] = '\0'; // 确保字符终止


    cJSON *root = cJSON_Parse(buffer);
    if(!root){
        fprintf(stderr, "JSON parse failed\n");
        return;
    }


    // 使用结构体定义字段映射
    struct FieldMapping {
        const char *json_key;
        const char *display_name;
        int required;  // 1表示必须字段
    } fields[] = {
        {"days", "日期", 1},
        {"week", "星期", 1},
        {"citynm", "城市", 1},
        {"temperature_curr", "当前温度", 1},
        {"temp_high", "最高温度", 0},
        {"temp_low", "最低温度", 0},
        {"weather", "天气状况", 1},
        {"humidity", "当前湿度", 0},
        {"humi_high", "最大湿度", 0},
        {"humi_low", "最小湿度", 0},
        {"wind", "风向", 1},
        {"winp", "风力", 1},
        {"aqi", "PM2.5", 0}
    };


    cJSON *result = cJSON_GetObjectItem(root, "result");
    if(!result){
        fprintf(stderr, "Missing result object\n");
        cJSON_Delete(root);
        return;
    }


    // 遍历所有字段定义
    for(size_t i = 0; i &lt; sizeof(fields)/sizeof(fields[0]); i++)
    {
        cJSON *item = cJSON_GetObjectItem(result, fields[i].json_key);


        printf(COLOR_FIELD"%-8s: "COLOR_RESET, fields[i].display_name);


        if(item &amp;&amp; item-&gt;valuestring)
        {
            printf(COLOR_VALUE"%s\n"COLOR_RESET, item-&gt;valuestring);
        }
        else
        {
            printf(COLOR_WARN"N/A\n"COLOR_RESET);
            if(fields[i].required)
            {
                fprintf(stderr, "Missing required field: %s\n", fields[i].json_key);
                cJSON_Delete(root);
                return;
            }
        }
    }


    ret = 0;
    free(buffer);
    cJSON_Delete(root);
    close(fd);
}
</code></pre>
    <h5>
     <strong>
      亮点分析补充与优化建议
     </strong>
    </h5>
    <h6>
     1.
     <strong>
      模块化设计
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       优势
      </strong>
      ：
      <br/>
      将天气查询功能封装为独立函数
      <code>
       real_time_weather()
      </code>
      ，逻辑边界清晰，符合“高内聚”原则。
     </li>
     <li>
      <strong>
       改进空间
      </strong>
      ：
      <ul>
       <li>
        <strong>
         单一职责原则
        </strong>
        ：当前函数承担了网络连接、文件操作、JSON解析、数据展示等多个职责，可进一步拆分为子函数（如
        <code>
         fetch_weather_data()
        </code>
        、
        <code>
         parse_json()
        </code>
        、
        <code>
         display_weather()
        </code>
        ）。
       </li>
       <li>
        <strong>
         依赖解耦
        </strong>
        ：文件
        <code>
         recv.txt
        </code>
        作为数据传递媒介，属于硬编码依赖，建议改用内存直接传递（如通过函数参数传递数据缓冲区）。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     2.
     <strong>
      动态内存管理
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       优势
      </strong>
      ：
      <br/>
      使用
      <code>
       malloc
      </code>
      动态分配内存，避免栈溢出风险，适应大数据场景。
     </li>
     <li>
      <strong>
       改进空间
      </strong>
      ：
      <ul>
       <li>
        <strong>
         内存泄漏风险
        </strong>
        ：错误处理路径中未完全释放内存（如
        <code>
         malloc
        </code>
        成功但
        <code>
         open
        </code>
        失败时未
        <code>
         free(buffer)
        </code>
        ），需用
        <code>
         goto
        </code>
        或
        <code>
         cleanup
        </code>
        标签统一释放资源。
       </li>
       <li>
        <strong>
         缓冲区溢出
        </strong>
        ：
        <code>
         read(fd, buffer, BUFFER_SIZE)
        </code>
        未检查
        <code>
         bytes_read
        </code>
        是否等于
        <code>
         BUFFER_SIZE
        </code>
        ，可能导致数据截断或越界。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     3.
     <strong>
      错误处理
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       优势
      </strong>
      ：
      <br/>
      覆盖文件操作、内存分配、JSON解析等关键错误点，避免程序崩溃。
     </li>
     <li>
      <strong>
       改进空间
      </strong>
      ：
      <ul>
       <li>
        <strong>
         错误码统一管理
        </strong>
        ：
        <code>
         ret
        </code>
        变量未被实际使用，建议通过返回值或全局错误码明确错误类型。
       </li>
       <li>
        <strong>
         错误信息分级
        </strong>
        ：区分“致命错误”（如必填字段缺失）与“警告信息”（如可选字段缺失），避免冗余报错。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     4.
     <strong>
      数据解析
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       优势
      </strong>
      ：
      <br/>
      使用
      <code>
       cJSON
      </code>
      库解析复杂JSON数据，通过结构体
      <code>
       FieldMapping
      </code>
      实现字段映射，扩展性强。
     </li>
     <li>
      <strong>
       改进空间
      </strong>
      ：
      <ul>
       <li>
        <strong>
         字段类型校验
        </strong>
        ：未检查JSON字段实际类型（如数值型字段可能被误读为字符串），需增加
        <code>
         cJSON_IsString
        </code>
        /
        <code>
         cJSON_IsNumber
        </code>
        等校验。
       </li>
       <li>
        <strong>
         嵌套结构处理
        </strong>
        ：若JSON层级更深（如
        <code>
         result
        </code>
        下包含嵌套对象），需支持递归解析。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     5.
     <strong>
      用户输出
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       优势
      </strong>
      ：
      <br/>
      ANSI颜色代码提升可读性，字段映射表确保输出完整性。
     </li>
     <li>
      <strong>
       改进空间
      </strong>
      ：
      <ul>
       <li>
        <strong>
         跨平台兼容性
        </strong>
        ：Windows终端默认不支持ANSI颜色，需通过条件编译适配。
       </li>
       <li>
        <strong>
         格式化输出
        </strong>
        ：使用固定宽度（
        <code>
         %-8s
        </code>
        ）可能导致长字段显示不全，建议动态调整列宽。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      难点分析与解决方案
     </strong>
    </h5>
    <h6>
     1.
     <strong>
      JSON数据解析
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       核心挑战
      </strong>
      ：
      <ul>
       <li>
        字段路径依赖性强（如直接访问
        <code>
         root-&gt;result-&gt;temperature_curr
        </code>
        ），若服务器返回结构变化，需修改代码。
       </li>
       <li>
        未处理特殊字符（如转义字符
        <code>
         \"
        </code>
        ）或Unicode编码（如
        <code>
         \u4e2d\u6587
        </code>
        ）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         cJSON_GetObjectItemCaseSensitive
        </code>
        避免大小写敏感问题。
       </li>
       <li>
        通过
        <code>
         cJSON_Print
        </code>
        标准化输出，确保转义字符正确处理。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     2.
     <strong>
      网络通信
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       核心挑战
      </strong>
      ：
      <ul>
       <li>
        <code>
         CreateTcpClient()
        </code>
        实现未展示，可能隐藏连接超时、重试等逻辑缺失。
       </li>
       <li>
        未处理HTTP协议细节（如状态码检查、分块传输编码）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        封装HTTP客户端库（如
        <code>
         libcurl
        </code>
        ）简化网络操作。
       </li>
       <li>
        增加超时机制和重试逻辑，提升鲁棒性。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     3.
     <strong>
      文件操作
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       核心挑战
      </strong>
      ：
      <ul>
       <li>
        文件读写与网络通信耦合，可能导致数据不同步（如文件未及时刷新）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ul>
       <li>
        使用内存映射文件（
        <code>
         mmap
        </code>
        ）或管道（
        <code>
         pipe
        </code>
        ）替代临时文件。
       </li>
       <li>
        增加文件锁（
        <code>
         flock
        </code>
        ）避免多进程竞争。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <code>
      future_weather()
     </code>
     函数
    </h3>
    <pre><code class="language-cpp">
void future_weather()
{
	int ret = -1;
	int fd = -1;
	char *buffer = NULL;
	ssize_t bytes_read = 0;
	
	CreateTcpClient(); // 创建新的连接
	
	if(!(buffer = malloc(BUFFER_SIZE))){
		perror("malloc fail");
		return;
	}
	if((fd = open("recv.txt",O_RDONLY)) == -1){
		perror("open fail");
		return;
	}
	if((bytes_read = read(fd,buffer,BUFFER_SIZE)) &lt;= 0){
        fprintf(stderr, "Read failed or empty file\n");
		return;
	}
	buffer[bytes_read] = '\0';//确保字符终止

	cJSON *root = cJSON_Parse(buffer);
	if(!root){
        fprintf(stderr, "JSON parse failed\n");
		return;
	}

	// 使用结构体定义字段映射
    struct FieldMapping {
        const char *json_key;
       const char *display_name;
        int required;  // 1表示必须字段
    } fields[] = {
        {"days", "日期", 1},
        {"week", "星期", 1},
        {"citynm", "城市", 1},
        {"temp_high", "最高温度", 0},
        {"temp_low", "最低温度", 0},
        {"weather", "天气状况", 1},
        {"wind", "风向", 1},
        {"winp", "风力", 1},
    };

	cJSON *result = cJSON_GetObjectItem(root,"result");
	if(!result){
        fprintf(stderr, "Missing result object\n");
		cJSON_Delete(root);
	}
	
	int i = 0;
	cJSON *item;

	cJSON_ArrayForEach(item,result)
	{
		printf(COLOR_HEAD"=============第%d天气预报=============\n"COLOR_RESET,i+1);

		// 遍历所有字段定义
		for (size_t j = 0; j &lt; sizeof(fields)/sizeof(fields[0]); j++) {
			cJSON *field = cJSON_GetObjectItem(item, fields[j].json_key);

			printf(COLOR_FIELD"%-8s: "COLOR_RESET, fields[j].display_name);

			if (field &amp;&amp; field-&gt;valuestring) {
				printf(COLOR_VALUE"%s\n"COLOR_RESET, field-&gt;valuestring);
			} else {
				printf(COLOR_WARN"N/A\n"COLOR_RESET);
				if (fields[j].required) {
					fprintf(stderr, "Missing required field: %s\n", fields[j].json_key);
				}
        }
    }

		i++;
	}	

	cJSON_Delete(root);
	free(buffer);
	close(fd);
}


</code></pre>
    <h5>
     <strong>
      功能概述
     </strong>
    </h5>
    <p>
     该函数用于获取并展示未来多天的天气预报数据，整体流程如下：
    </p>
    <ol>
     <li>
      建立TCP连接获取数据（依赖
      <code>
       CreateTcpClient()
      </code>
      ）。
     </li>
     <li>
      从文件
      <code>
       recv.txt
      </code>
      读取JSON格式的天气数据。
     </li>
     <li>
      解析JSON数据并格式化输出未来多天的天气信息。
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      亮点与改进建议
     </strong>
    </h4>
    <h5>
     <strong>
      1. 核心亮点
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        数据遍历逻辑
       </strong>
       <br/>
       使用
       <code>
        cJSON_ArrayForEach
       </code>
       遍历天气预报的多个结果，支持动态数量的天气预报条目，灵活性较高。
      </p>
      <pre><code>cJSON_ArrayForEach(item, result) {
    printf("第%d天天气预报", i+1);
    // 遍历字段并输出
}
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        字段映射复用
       </strong>
       <br/>
       复用
       <code>
        FieldMapping
       </code>
       结构体定义字段映射关系，与
       <code>
        real_time_weather()
       </code>
       保持一致性，降低维护成本。
      </p>
     </li>
     <li>
      <p>
       <strong>
        用户交互友好
       </strong>
       <br/>
       通过颜色区分标题、字段名和数值，输出层次清晰：
      </p>
      <pre><code>printf(COLOR_HEAD"=============第%d天气预报=============\n"COLOR_RESET, i+1);
</code></pre>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      2. 潜在问题与改进
     </strong>
    </h5>
    <h6>
     <strong>
      问题1：内存与资源泄漏
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       <strong>
        风险点
       </strong>
      </p>
      <ul>
       <li>
        文件打开失败（
        <code>
         open
        </code>
        返回
        <code>
         -1
        </code>
        ）时，未释放
        <code>
         malloc
        </code>
        分配的
        <code>
         buffer
        </code>
        。
       </li>
       <li>
        JSON解析失败时，未关闭文件描述符
        <code>
         fd
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        修复建议
       </strong>
       <br/>
       使用
       <strong>
        统一清理逻辑
       </strong>
       确保资源释放：
      </p>
      <pre><code>void future_weather() {
    int fd = -1;
    char *buffer = NULL;
    cJSON *root = NULL;

    // 初始化代码...

    // 错误处理跳转标签
    cleanup:
        if (buffer) free(buffer);
        if (root) cJSON_Delete(root);
        if (fd != -1) close(fd);
}
</code></pre>
     </li>
    </ul>
    <h6>
     <strong>
      问题2：JSON类型安全性
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       <strong>
        风险点
       </strong>
       <br/>
       直接访问
       <code>
        field-&gt;valuestring
       </code>
       ，若字段值为数值类型（如温度），会导致空指针或错误输出。
      </p>
      <pre><code>// 错误示例：若temp_high为数值，valuestring为NULL
printf("%s", field-&gt;valuestring);
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        修复建议
       </strong>
       <br/>
       增加类型检查，支持数值和字符串：
      </p>
      <pre><code>if (cJSON_IsString(field)) {
    printf("%s", field-&gt;valuestring);
} else if (cJSON_IsNumber(field)) {
    printf("%d", field-&gt;valueint);
}
</code></pre>
     </li>
    </ul>
    <h6>
     <strong>
      问题3：数据完整性风险
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       <strong>
        风险点
       </strong>
       <br/>
       假设
       <code>
        result
       </code>
       为数组类型，若服务器返回非数组数据（如空对象），程序会错误遍历。
      </p>
      <pre><code>cJSON *result = cJSON_GetObjectItem(root, "result");
cJSON_ArrayForEach(item, result); // 若result非数组，崩溃！
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        修复建议
       </strong>
       <br/>
       验证数据类型：
      </p>
      <pre><code>if (!cJSON_IsArray(result)) {
    fprintf(stderr, "Invalid result format: expected array\n");
    goto cleanup;
}
</code></pre>
     </li>
    </ul>
    <h6>
     <strong>
      问题4：代码冗余
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       <strong>
        风险点
       </strong>
       <br/>
       <code>
        future_weather
       </code>
       与
       <code>
        real_time_weather
       </code>
       存在大量重复代码（如文件操作、JSON解析），违反DRY原则。
      </p>
     </li>
     <li>
      <p>
       <strong>
        修复建议
       </strong>
       <br/>
       抽象公共逻辑为独立函数：
      </p>
      <pre><code>// 公共函数：读取文件到缓冲区
char* read_weather_data(const char *filename) {
    int fd = open(filename, O_RDONLY);
    // 读取并返回buffer...
}

// 公共函数：解析并打印天气字段
void print_weather_fields(cJSON *item, struct FieldMapping *fields, size_t count) {
    // 遍历字段并输出...
}
</code></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      难点与解决方案
     </strong>
    </h4>
    <h5>
     <strong>
      1. 动态数组遍历
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       难点
      </strong>
      <br/>
      需处理未知数量的天气预报条目，且每个条目需完整解析字段。
     </li>
     <li>
      <strong>
       方案
      </strong>
      <br/>
      使用
      <code>
       cJSON_ArrayForEach
      </code>
      宏安全遍历数组，避免手动索引越界。
     </li>
    </ul>
    <h5>
     <strong>
      2. 多层级JSON解析
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       难点
      </strong>
      <br/>
      若JSON结构复杂（如嵌套对象），需递归解析。
     </li>
     <li>
      <strong>
       方案
      </strong>
      <br/>
      设计递归解析函数，处理嵌套结构：
      <pre><code>void parse_nested(cJSON *node, int depth) {
    if (cJSON_IsObject(node)) {
        cJSON_ArrayForEach(child, node) {
            parse_nested(child, depth + 1);
        }
    }
}</code></pre>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343338323937302f:61727469636c652f64657461696c732f313436313033383735" class_="artid" style="display:none">
 </p>
</div>


