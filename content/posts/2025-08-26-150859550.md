---
layout: post
title: "LeetCode动态规划542.01-矩阵"
date: 2025-08-26T16:10:01+0800
description: "从左上到右下扫描一遍、从右下到左上扫描一遍，初始化全矩阵中为0的值对应的dp数组距离为0（注意错误思路”从四周初始化“）。扫描时，不用再注意对应mat[i][j]值是否为1还是0，而是对全数组都进行min的判断，并且判断里要分两种情况，一种是左侧，一种是上侧（以及一种是右侧，一种是下侧），因此，就要对下标进行边界判断，只要不在初始边界出界的情况下都判断两侧，判断时，由于0已经初始化为了0，为1时自动判断是否+1为最小，而0永远不变，因此可以得出不判断0和1的情况所得的dp数组是正确的。"
keywords: "【LeetCode】动态规划——542.01 矩阵"
categories: ['未分类']
tags: ['矩阵', '动态规划', 'Leetcode']
artid: "150859550"
arturl: "https://blog.csdn.net/qq_42988614/article/details/150859550"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150859550
    alt: "LeetCode动态规划542.01-矩阵"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150859550
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150859550
cover: https://bing.ee123.net/img/rand?artid=150859550
image: https://bing.ee123.net/img/rand?artid=150859550
img: https://bing.ee123.net/img/rand?artid=150859550
---



# 【LeetCode】动态规划——542.01 矩阵

**LeetCode题目链接**  
https://leetcode.cn/problems/01-matrix/description/

**题解**  
从左上到右下扫描一遍、从右下到左上扫描一遍，初始化全矩阵中为0的值对应的dp数组距离为0（注意错误思路”从四周初始化“）。扫描时，不用再注意对应mat[i][j]值是否为1还是0，而是对全数组都进行min的判断，并且判断里要分两种情况，一种是左侧，一种是上侧（以及一种是右侧，一种是下侧），因此，就要对下标进行边界判断，只要不在初始边界出界的情况下都判断两侧，判断时，由于0已经初始化为了0，为1时自动判断是否+1为最小，而0永远不变，因此可以得出不判断0和1的情况所得的dp数组是正确的。

**代码**

```cpp
//542.01矩阵
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        vector<vector<int>> dp(mat.size(),vector<int>(mat[0].size(), INT_MAX / 2));
        //初始化
        for (int i = 0;i < mat.size();i++) {
            for (int j = 0;j < mat[0].size();j++) {
				if (mat[i][j] == 0) {
					dp[i][j] = 0;
				}
            }
        }
        //看前面的不看后面的
        for (int i = 0;i < mat.size();i++) {
            for (int j = 0;j < mat[0].size();j++) {
                if (i > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);
                if (j > 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);
            }
        }
        for (int i = mat.size() - 1;i >= 0;i--) {
            for (int j = mat[0].size() - 1;j >= 0;j--) {
                if (i < mat.size() - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);
                if (j < mat[0].size() - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);
            }
        }
        //递推公式
        return dp;
    }
};

int main() {
    Solution s;
    vector<vector<int>> mat = {
        {0},
        {0},
        {0},
        {0},
        {0}
    };
    vector<vector<int>> result = s.updateMatrix(mat);
    for (int i = 0;i < result.size();i++) {
		for (int j = 0;j < result[0].size();j++) {
			cout << result[i][j] << " ";
		}
		cout << endl;
    }
	return 0;
}

```



