---
layout: post
title: "一篇博客搞定时间复杂度"
date: 2025-03-14 21:46:27 +0800
description: "本篇博客让你速通时间复杂度！"
keywords: "一篇博客搞定时间复杂度"
categories: ['学习分享']
tags: ['时间复杂度', '开发语言', 'C']
artid: "146256841"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146256841
    alt: "一篇博客搞定时间复杂度"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146256841
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146256841
cover: https://bing.ee123.net/img/rand?artid=146256841
image: https://bing.ee123.net/img/rand?artid=146256841
img: https://bing.ee123.net/img/rand?artid=146256841
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     一篇博客搞定时间复杂度
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <br/>
    前言：
    <p>
    </p>
    <blockquote>
     <p>
      <font color="red">
       算法在编写成可执行程序后，运行时要耗费时间和空间资源，因此衡量一个算法的好坏，一般是从时间和空间两个维度入手的，也就是时间复杂度和空间复杂度。
      </font>
      <br/>
      <strong>
       时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要耗费的额外空间。
      </strong>
      <br/>
      我们在学习算法的时候总是听到有人讨论时间复杂度，但却很少听到有人讲空间复杂度，这是因为在计算机发展的早期，计算机的容量很小，空间很金贵，所以当时对空间复杂度很在乎，但随着时代的快速发展，计算机的容量已经达到了很高的程度，所以我们今天不很在乎一个算法的空间复杂度。
      <strong>
       那么问题来了，什么是时间复杂度呢？
      </strong>
     </p>
    </blockquote>
    <h2>
     <a id="1_6">
     </a>
     1、什么是时间复杂度？
    </h2>
    <p>
     在计算机科学中，算法的时间复杂度是一个函数式T(N)，
     <font color="red">
      一个算法花费的时间与算法中语句的执行次数成正比
     </font>
     。
     <br/>
     一般情况下，
     <strong>
      算法中基本操作重复执行的次数是问题规模n的函数，用T(N)表示
     </strong>
     ，它定量描述了该算法的运行时间。
     <strong>
      如果有一个函数f(n)，使得当n趋于无穷大时，T(N)/f(n)的极限值是不为0的常数，那就称T(N)和f(n)是同数量级函数，记作T(N)=O(f(n))
     </strong>
     ，
     <strong>
      称O(f(n))就是该算法的渐进时间复杂度，也就是时间复杂度。
      <font color="red">
       时间复杂度描述的是变化的趋势，不是大小，即便一个基础语句执行1亿次，只要明确知道它运行的次数，它的时间复杂度就是O(1)，因为它的执行次数不会发生变化
      </font>
     </strong>
    </p>
    <p>
     <font color="red">
      注意：复杂度的表示通常使用大O的渐进表示法。
     </font>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/42894b85499e4e759a5b65ed9a1ada0d.png#pic_center">
      <br/>
      <font color="red">
       如上图，随着规模n的不断增大，代码的执行时间不断增大，它的执行效率就不断降低。
      </font>
     </img>
    </p>
    <h2>
     <a id="2O_13">
     </a>
     2、推导大O的规则
    </h2>
    <blockquote>
     <p>
      1、
      <font color="blue">
       时间复杂度只保留函数式T(N)中最高阶项，去掉那些低阶项，因为当n不断变大时，低阶项对结果的影响越来越小，当n无穷大时，就可以忽略不计了。
      </font>
     </p>
     <p>
      2、
      <font color="low blue">
       如果高阶项的系数存在且不是1，就去除它的常数系数，因为当n 不断变大时，常数系数对结果的影响越来越小，当n无穷大时，就可以忽略不计了。
      </font>
     </p>
     <p>
      3、
      <font color="onewagreen">
       T(N)中如果没有N相关的项目，只有常数项，用常数1取代，即O(1)。
      </font>
     </p>
    </blockquote>
    <p>
     关于以上时间复杂度大O的推导规则还有以下
     <font color="red">
      <strong>
       补充
      </strong>
     </font>
     ，我们以代码形式讲解：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		num<span class="token operator">++</span><span class="token punctuation">;</span>
		arr<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      这是一段简单的计算字符个数的代码，当运行这段代码时我们可以分为三种情况：
      <br/>
      假设字符串长度为n。
     </strong>
    </p>
    <ul>
     <li>
      arr数组中只有一个字符，此时T(N)=1
     </li>
     <li>
      arr数组中有很长一段字符，此时T(N)=N
     </li>
     <li>
      平均情况下T(N)=N/2。
     </li>
    </ul>
    <blockquote>
     <p>
      时间复杂度：
      <br/>
      最好情况下：O(1)（下界）
      <br/>
      最坏情况下：O(n)（上界）
      <br/>
      平均情况下：O(n)
     </p>
    </blockquote>
    <p>
     <font color="red">
      大O推导规则的补充：大O的渐进表示法在实际中一般情况下关注的是算法的上界，也就是最坏的运行情况。
     </font>
    </p>
    <h2>
     <a id="3_45">
     </a>
     3、时间复杂度的计算
    </h2>
    <h3>
     <a id="31__1_46">
     </a>
     3.1 基础题 1
    </h3>
    <p>
     求该算法的时间复杂度：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     T(N)=N，即时间复杂度为O(n)
    </p>
    <h3>
     <a id="32__2_60">
     </a>
     3.2 基础题 2
    </h3>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     T(N)=2*N+100，由规则1和规则2得，时间复杂度是O(n)
    </p>
    <h3>
     <a id="33_3_78">
     </a>
     3.3基础题 3
    </h3>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     T(N)=N+M，由于我们不知道N与M谁大谁小，分为3种情况
     <br/>
     1：N近似等于M，此时T(N)=2*N 或 T(N)=2*M，根据规则2去除常数系数，时间复杂度为O(n)
     <br/>
     2：N&gt;&gt;M，此时T(N)=N，时间复杂度为O(n)
     <br/>
     3：M&gt;&gt;N，此时T(N)=M，时间复杂度为O(n)
     <br/>
     综上，时间复杂度为O(n)
    </p>
    <h3>
     <a id="34_1_100">
     </a>
     3.4进阶题 1
    </h3>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     由基本操作次数得知：T(N)=N
     <sup>
      2
     </sup>
     +2*N+10，由规则1保留最高阶项，又因为无常数系数得：时间复杂度为O(n
     <sup>
      2
     </sup>
     ).
    </p>
    <h3>
     <a id="35_2_125">
     </a>
     3.5进阶题 2
    </h3>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			count<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     遇到这种多重循环体，我们一般是从内层循环到外层循环依次分析：
     <br/>
     当i=1时，内层循环执行1次
     <br/>
     当i=2时，内层循环执行2次
     <br/>
     当i=3时，内层循环执行3次
     <br/>
     ……
     <br/>
     当i=n时，内层循环执行n次
    </p>
    <p>
     <font color="kubsowamocred">
      通过观察i从1到n的整个过程，我们可以推导出T(N)=N*(N+1)/2，也就是我们所熟悉的等差数列求和，展开T(N)得T(N)=N
      <sup>
       2
      </sup>
      /2 + N/2，根据规则1保留最高项，根据规则2去除常数系数，得到时间复杂度为O(n
      <sup>
       2
      </sup>
      ).
     </font>
    </p>
    <h3>
     <a id="36__1_148">
     </a>
     3.6 偏难题 1
    </h3>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cnt <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     当遇到这种题时，我们依旧逐步分析即可，
     <br/>
     当n=2时，执行1次
     <br/>
     当n=4时，执行2次
     <br/>
     ……
     <br/>
     当n=16时，执行4次
     <br/>
     假设执行次数为x，则2
     <sup>
      x
     </sup>
     =n
     <br/>
     即x=log(2)n，所以时间复杂度为O(logn)
    </p>
    <p>
     <font color="red">
      注意：当n接近无穷大时，底数的大小对结果影响不大，因此一般情况下不管底数是多少都可以忽略不写，即O(logn)，所以上面将2忽略了。
     </font>
    </p>
    <h3>
     <a id="37_2_169">
     </a>
     3.7偏难题 2（递归）
    </h3>
    <pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <font color="red">
      递归算法的时间复杂度=单次递归的时间复杂度*递归次数。
     </font>
     <br/>
     在本题调用一次func函数的时间复杂度是O(1)，而在本题中调用了n次，即T(N)=N，因此时间复杂度为O(n)。
    </p>
    <p>
     此时有人会有疑惑，说递归不是分为递推和回归吗？我们调用一共花了n次，而回归也要花费n次，那T(N）不该是2*N吗？
     <strong>
      这种思想在本题没有影响，因为我们一次函数调用的时间复杂度是O(1)，但当不是O(1)时会出错，
      <font color="red">
       注意我们调用过程创建了函数栈帧，并且执行了函数中的语句，而回归过程是函数栈帧销毁的过程，没有语句执行，所以不耗费时间。
      </font>
      因此在本题中T(N)=N，时间复杂度为O(n)。
     </strong>
    </p>
    <blockquote>
     <p>
      总结：
      <br/>
      <font color="sky blue">
       以上就是本期博客分享的全部内容啦！技术的探索永无止境。
       <br/>
       道阻且长，行则将至！后续我会给大家带来更多博客内容，欢迎关注我的CSDN账号，我们一同成长！
       <br/>
       (～￣▽￣)～
      </font>
     </p>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38363738353035322f:61727469636c652f64657461696c732f313436323536383431" class_="artid" style="display:none">
 </p>
</div>


