---
layout: post
title: "在-JDK-1.8-的-ConcurrentHashMap-中,为什么存在两种插入方式"
date: 2025-03-11 21:53:12 +0800
description: "中，之所以对“容器为空”和“计算位置为空”采取不同的处理方式，主要是因为。，需要遍历该链表或红黑树进行替换或追加。，这就是它不同情况下采用不同方式的原因。，并不会在构造时就初始化所有桶（：当第一次插入元素时，会先判断。位置已经有元素了，可能会遇到。操作来保证线程安全的初始化。在 JDK 1.8 的。"
keywords: "在 JDK 1.8 的 ConcurrentHashMap 中，为什么存在两种插入方式？"
categories: ['未分类']
tags: ['开发语言', 'Java']
artid: "146190159"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146190159
    alt: "在-JDK-1.8-的-ConcurrentHashMap-中,为什么存在两种插入方式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146190159
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146190159
cover: https://bing.ee123.net/img/rand?artid=146190159
image: https://bing.ee123.net/img/rand?artid=146190159
img: https://bing.ee123.net/img/rand?artid=146190159
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     在 JDK 1.8 的 ConcurrentHashMap 中，为什么存在两种插入方式？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 JDK 1.8 的
     <code>
      ConcurrentHashMap
     </code>
     中，之所以对“容器为空”和“计算位置为空”采取不同的处理方式，主要是因为
     <strong>
      并发场景下的性能优化和并发安全保证
     </strong>
     。我们可以分开来看这两种情况：
    </p>
    <h4>
     <strong>
      1. 容器为空时，使用
      <code>
       volatile
      </code>
      +
      <code>
       CAS
      </code>
      初始化
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        原因
       </strong>
       ：
       <code>
        ConcurrentHashMap
       </code>
       采用
       <strong>
        懒加载
       </strong>
       ，并不会在构造时就初始化所有桶（
       <code>
        Node&lt;K, V&gt;[] table
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：当第一次插入元素时，会先判断
       <code>
        table
       </code>
       是否为空：
      </p>
     </li>
    </ul>
    <pre><code class="language-java">if (tab == null || (n = tab.length) == 0) 
    tab = initTable();
</code></pre>
    <ul>
     <li>
      <p>
       <code>
        initTable()
       </code>
       方法使用
       <strong>
        CAS（Compare-And-Swap）
       </strong>
       操作来保证线程安全的初始化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        为什么用 CAS 而不是
        <code>
         synchronized
        </code>
        ?
       </strong>
      </p>
      <ul>
       <li>
        目的是减少不必要的锁竞争，提高并发性能。
       </li>
       <li>
        由于初始化操作通常只需要执行一次（典型的
        <strong>
         双重检查锁
        </strong>
        模式），CAS 在多数情况下不会失败，所以开销较小。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      2. 计算出的位置为空时，使用 CAS 插入
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       原因
      </strong>
      ：如果某个桶（即
      <code>
       table[index]
      </code>
      ）位置为空，说明没有哈希冲突，我们可以直接尝试插入数据。
     </li>
     <li>
      <strong>
       实现
      </strong>
      ：使用
      <code>
       CAS
      </code>
      方式直接插入：
     </li>
     <li>
      <pre><code class="language-java">if (casTabAt(tab, i, null, new Node&lt;K, V&gt;(hash, key, value, null))) {
    break; // 插入成功，退出循环
}
</code></pre>
      <p>
       <strong>
        为什么用 CAS 而不是
        <code>
         synchronized
        </code>
        ?
       </strong>
      </p>
     </li>
     <li>
      因为这个位置是
      <code>
       null
      </code>
      ，没有竞争，所以可以直接尝试用
      <strong>
       无锁的 CAS 操作
      </strong>
      插入，避免加锁的开销，提高性能。
     </li>
    </ul>
    <h4>
     <strong>
      3. 计算出的位置不为空时，使用
      <code>
       synchronized
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        原因
       </strong>
       ：如果
       <code>
        table[index]
       </code>
       位置已经有元素了，可能会遇到
       <strong>
        哈希冲突
       </strong>
       ，需要遍历该链表或红黑树进行替换或追加。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        先通过
        <code>
         synchronized
        </code>
        锁住该桶（
        <code>
         synchronized (f)
        </code>
        ）。
       </li>
       <li>
        然后遍历这个桶：
        <ul>
         <li>
          如果
          <strong>
           key 已存在
          </strong>
          ，则更新 value。
         </li>
         <li>
          如果
          <strong>
           key 不存在
          </strong>
          ，则添加新的节点（链表 or 红黑树）。
         </li>
        </ul>
       </li>
       <li>
        插入完成后，
        <strong>
         判断链表长度是否达到阈值（8），如果达到就转换为红黑树
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        为什么用
        <code>
         synchronized
        </code>
        而不是 CAS?
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         CAS 只能保证单个变量的原子性，而不能保证整个链表或树结构的原子性
        </strong>
        。
       </li>
       <li>
        当多个线程同时修改一个桶时，直接用
        <code>
         synchronized
        </code>
        保护整个桶的操作，避免复杂的 CAS 失败重试，提高效率。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     JDK 1.8 在
     <code>
      ConcurrentHashMap
     </code>
     中通过
     <strong>
      分阶段使用 CAS 和 synchronized
     </strong>
     ，既保证了
     <strong>
      高并发性能
     </strong>
     ，又保证了
     <strong>
      线程安全
     </strong>
     ，这就是它不同情况下采用不同方式的原因。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f666f726d61745f707573682f:61727469636c652f64657461696c732f313436313930313539" class_="artid" style="display:none">
 </p>
</div>


