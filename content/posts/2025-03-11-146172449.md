---
layout: post
title: "使用dockerfile创建镜像"
date: 2025-03-11 16:34:17 +0800
description: "Dockerfile 是一个用于指导 Docker 镜像构建过程的脚本文件。它通过一系列指令来详细描述了构建镜像所需的步骤和配置细节。利用 Dockerfile，我们可以精确地设定容器的运行环境，安装必要的软件，复制项目文件，以及配置环境变量等。Dockerfile 的优势在于其可重复性和自动化，使得应用程序的容器化过程既高效又可靠。通过将构建过程代码化，我们能够对构建步骤进行版本控制，并在不同的环境中复现相同的镜像。"
keywords: "使用dockerfile创建镜像"
categories: ['未分类']
tags: ['开发语言', 'Java']
artid: "146172449"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146172449
    alt: "使用dockerfile创建镜像"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146172449
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146172449
cover: https://bing.ee123.net/img/rand?artid=146172449
image: https://bing.ee123.net/img/rand?artid=146172449
img: https://bing.ee123.net/img/rand?artid=146172449
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     使用dockerfile创建镜像
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.什么是Dockerfile
    </h2>
    <p>
     Dockerfile 是一个用于指导 Docker 镜像构建过程的脚本文件。它通过一系列指令来详细描述了构建镜像所需的步骤和配置细节。利用 Dockerfile，我们可以精确地设定容器的运行环境，安装必要的软件，复制项目文件，以及配置环境变量等。
    </p>
    <p>
     Dockerfile 的优势在于其可重复性和自动化，使得应用程序的容器化过程既高效又可靠。通过将构建过程代码化，我们能够对构建步骤进行版本控制，并在不同的环境中复现相同的镜像。
    </p>
    <p>
     Dockerfile 的组成通常包括以下几个方面：指定基础镜像、提供维护者信息、执行镜像构建指令以及定义容器启动时要运行的命令。
    </p>
    <p>
     在 Dockerfile 中，指令是按照从上到下的顺序执行的，且首个非注释指令必须是 FROM，用以指定基础镜像。Dockerfile 中的注释以“#”开头。
    </p>
    <p>
     Dockerfile 支持多种指令，例如 RUN、CMD、FROM、EXPOSE、ENV 等，这些指令帮助我们定义镜像的操作系统、安装软件、设置环境变量等。
    </p>
    <p>
     编写完 Dockerfile 后，我们可以通过执行 docker build 命令并指定 Dockerfile 的位置来构建镜像。Docker 引擎将按照 Dockerfile 中的指令逐步构建，最终生成一个新的镜像。
    </p>
    <p>
     综上所述，Dockerfile 是一个关键工具，它通过简洁明了的文本指令，帮助我们自动化和标准化 Docker 镜像的构建过程，从而简化了容器化应用程序的部署工作。
    </p>
    <h2>
     2.Dockerfile 中常用的指令
    </h2>
    <table border="1" cellpadding="1" cellspacing="1" style="width:950px">
     <tbody>
      <tr>
       <td>
        指令
       </td>
       <td>
        说明
       </td>
      </tr>
      <tr>
       <td>
        FROM
       </td>
       <td>
        指定基础镜像
       </td>
      </tr>
      <tr>
       <td>
        MAINTAINER
       </td>
       <td>
        设置维护者信息
       </td>
      </tr>
      <tr>
       <td>
        RUN
       </td>
       <td>
        在镜像中执行命令
       </td>
      </tr>
      <tr>
       <td>
        CMD
       </td>
       <td>
        指定容器启动时要执行的命令
       </td>
      </tr>
      <tr>
       <td>
        ENTRYPOINT
       </td>
       <td>
        与 CMD 类似，但不会被 docker run 命令行参数覆盖
       </td>
      </tr>
      <tr>
       <td>
        COPY
       </td>
       <td>
        复制文件或目录到镜像中
       </td>
      </tr>
      <tr>
       <td>
        ADD
       </td>
       <td>
        复制文件或目录到镜像中，支持远程 URL 和解压缩功能
       </td>
      </tr>
      <tr>
       <td>
        ENV
       </td>
       <td>
        设置环境变量
       </td>
      </tr>
      <tr>
       <td>
        ARG
       </td>
       <td>
        定义构建时的变量，可以通过 --build-arg 参数传递
       </td>
      </tr>
      <tr>
       <td>
        WORKDIR
       </td>
       <td>
        设置工作目录
       </td>
      </tr>
      <tr>
       <td>
        USER
       </td>
       <td>
        指定运行容器时的用户名或 UID
       </td>
      </tr>
      <tr>
       <td>
        EXPOSE
       </td>
       <td>
        声明容器运行时需要监听的端口
       </td>
      </tr>
      <tr>
       <td>
        HEALTHCHECK
       </td>
       <td>
        定义容器的健康检查命令
       </td>
      </tr>
      <tr>
       <td>
        VOLUME
       </td>
       <td>
        声明容器中的挂载点
       </td>
      </tr>
      <tr>
       <td>
        LABEL
       </td>
       <td>
        为镜像添加元数据
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      <strong>
       注意事项：
      </strong>
     </p>
     <p>
      <strong>
       FROM
      </strong>
     </p>
     <ul>
      <li>
       尽量使用官方镜像作为基础镜像，以确保稳定性和安全性。
      </li>
      <li>
       指定镜像时，最好使用具体标签（例如
       <code>
        ubuntu:20.04
       </code>
       而不是
       <code>
        ubuntu:latest
       </code>
       ），以避免构建时的不一致性。
      </li>
     </ul>
     <p>
      <strong>
       MAINTAINER
      </strong>
      （已废弃，推荐使用 LABEL）
     </p>
     <ul>
      <li>
       请注意，MAINTAINER 指令已被废弃，现在推荐使用 LABEL 指令来设置维护者信息。
      </li>
     </ul>
     <p>
      <strong>
       RUN
      </strong>
     </p>
     <ul>
      <li>
       为了保持 Dockerfile 的可读性和可维护性，尽量使用
       <code>
        &amp;&amp;
       </code>
       来链式执行命令，并使用
       <code>
        \
       </code>
       来换行。
      </li>
      <li>
       尽可能使用
       <code>
        RUN apt-get clean
       </code>
       来清理缓存，减少镜像大小。
      </li>
     </ul>
     <p>
      <strong>
       CMD
      </strong>
     </p>
     <ul>
      <li>
       CMD 指令的目的是为执行容器提供默认值，如果
       <code>
        docker run
       </code>
       指定了命令，CMD 会被覆盖。
      </li>
      <li>
       当 Dockerfile 中有多个 CMD 指令时，只有最后一个 CMD 会生效。
      </li>
     </ul>
     <p>
      <strong>
       ENTRYPOINT
      </strong>
     </p>
     <ul>
      <li>
       ENTRYPOINT 与 CMD 结合使用可以设置容器启动时要执行的默认命令和参数。
      </li>
      <li>
       使用
       <code>
        ENTRYPOINT ["executable", "param1", "param2"]
       </code>
       的形式可以确保
       <code>
        docker run
       </code>
       的参数被追加到
       <code>
        param1
       </code>
       ,
       <code>
        param2
       </code>
       后面。
      </li>
     </ul>
     <p>
      <strong>
       COPY 和 ADD
      </strong>
     </p>
     <ul>
      <li>
       尽可能使用 COPY 而不是 ADD，除非你需要 ADD 的额外功能（如解压缩）。
      </li>
      <li>
       为了提高可读性，请明确指定源路径和目标路径。
      </li>
     </ul>
     <p>
      <strong>
       ENV
      </strong>
     </p>
     <ul>
      <li>
       使用 ENV 来设置环境变量，可以在后续的指令中使用这些变量。
      </li>
      <li>
       尽量将环境变量设置在 Dockerfile 的顶部，以便于其他指令引用。
      </li>
     </ul>
     <p>
      <strong>
       ARG
      </strong>
     </p>
     <ul>
      <li>
       ARG 指令定义的变量只在构建时有效，容器运行时不可用。
      </li>
      <li>
       使用 ARG 定义的变量可以在
       <code>
        docker build
       </code>
       时通过
       <code>
        --build-arg
       </code>
       传递。
      </li>
     </ul>
     <p>
      <strong>
       WORKDIR
      </strong>
     </p>
     <ul>
      <li>
       使用 WORKDIR 而不是多个 RUN 指令中的
       <code>
        cd
       </code>
       ，以确保路径的清晰性和一致性。
      </li>
     </ul>
     <p>
      <strong>
       USER
      </strong>
     </p>
     <ul>
      <li>
       使用 USER 指令来指定运行容器的用户，以减少安全风险。
      </li>
     </ul>
     <p>
      <strong>
       EXPOSE
      </strong>
     </p>
     <ul>
      <li>
       EXPOSE 指令只是声明容器将监听指定的端口，并不会自动映射端口到宿主机。
      </li>
     </ul>
     <p>
      <strong>
       HEALTHCHECK
      </strong>
     </p>
     <ul>
      <li>
       使用 HEALTHCHECK 来检测容器的健康状态，这对于自动重启失败的容器很有用。
      </li>
     </ul>
     <p>
      <strong>
       VOLUME
      </strong>
     </p>
     <ul>
      <li>
       使用 VOLUME 来管理容器的数据持久化，避免数据丢失。
      </li>
     </ul>
     <p>
      <strong>
       LABEL
      </strong>
     </p>
     <ul>
      <li>
       使用 LABEL 来添加元数据，便于组织镜像和记录版本信息。
      </li>
     </ul>
    </blockquote>
    <p>
     这些指令可以根据需要灵活组合，构建出符合需求的 Docker 镜像。请注意，Dockerfile 中的指令顺序很重要，因为每个指令都会创建一个新的镜像层，而后续的指令将基于前面的镜像层进行操作。
    </p>
    <p>
     更详细的指令说明和用法，请参考 Docker 官方文档：
    </p>
    <p>
     <a href="https://docs.docker.com/engine/reference/builder/" rel="nofollow" title="Dockerfile reference | Docker Docs">
      Dockerfile reference | Docker Docs
     </a>
    </p>
    <h2>
     3.dockerfile基本结构和构建镜像原则
    </h2>
    <h3>
     3.1 基本结构
    </h3>
    <p>
     <img alt="" height="514" src="https://i-blog.csdnimg.cn/direct/e03794164b9144ef8a5fee7203f12081.png" width="927"/>
    </p>
    <h3>
     3.2 构建基本原则
    </h3>
    <p>
     dockerfile构建镜像需要遵循一下原则：
    </p>
    <ul>
     <li>
      单一职责：每个层级只做每个层级的事
     </li>
     <li>
      提供注释信息：最好提供注释信息，以便他人理解
     </li>
     <li>
      保持容器最小化
     </li>
     <li>
      合理选择基础镜像：基础镜像的选择很重要，尽量选择成熟易用的基础镜像版本
     </li>
     <li>
      最小化镜像层数：镜像层数不宜过多，尽量精简，否则容易出错，也可能会影响加载速度
     </li>
    </ul>
    <p>
     <img alt="" height="224" src="https://i-blog.csdnimg.cn/direct/4837ac5ac87443f38b49608932b003c1.png" width="779"/>
    </p>
    <p>
     通过上面的示例图可以看出，每多一行命令，镜像的内容就多一层。
    </p>
    <blockquote>
     <p>
      <strong>
       其他注意事项：
      </strong>
     </p>
     <ul>
      <li>
       尽量减少镜像层数，可以通过合并 RUN 指令来实现。
      </li>
      <li>
       使用
       <code>
        .dockerignore
       </code>
       文件排除不必要的文件和目录，减少构建上下文的大小。
      </li>
      <li>
       保持 Dockerfile 的简洁性，避免在其中执行复杂的操作，尽可能在构建上下文中准备数据。
      </li>
      <li>
       定期更新基础镜像以包含最新的安全补丁。
      </li>
     </ul>
    </blockquote>
    <h2>
     4.Dockerfile使用示例
    </h2>
    <h3>
     4.1 基于centos8镜像构建nginxWeb服务镜像
    </h3>
    <p>
     以下是一个简单的 Dockerfile示例，以构建一个基于 centos 的配置web服务的镜像：
    </p>
    <p>
     <strong>
      1.创建构建上下文目录：
     </strong>
    </p>
    <pre><code class="language-bash">[root@open-Euler3 ~]# mkdir dockerfile_test
</code></pre>
    <p>
     <strong>
      2.本地添加nginx测试界面用于COPY
     </strong>
    </p>
    <pre><code class="language-bash">[root@open-Euler3 ~]# echo "nginx test" &gt; dockerfile_test/index.html
</code></pre>
    <p>
     <strong>
      3.编写Dockerfile文件
     </strong>
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_test]# cat Dockerfile
# 1. 第一行必须指定基础镜像信息
ARG VER=8
FROM centos:${VER}

# 2. 作者信息
LABEL maintainer="openlab &lt;openlab@123.com&gt;"

# 3. 安装 nginx
RUN mkdir -p /etc/yum.repos.d/bak_repo &amp;&amp; \
    mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak_repo/ 2&gt;/dev/null || true &amp;&amp; \
    curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo &amp;&amp; \
    dnf clean all &amp;&amp; \
    dnf makecache &amp;&amp; \
    dnf install -y nginx
  
# 4. 复制静态文件
COPY index.html /usr/share/nginx/html

# 5. 暴露端口
EXPOSE 80 443

# 6. 启动服务
ENTRYPOINT ["/usr/sbin/nginx", "-g", "daemon off;"]
</code></pre>
    <p>
     <strong>
      4.docker build 构建镜像
     </strong>
    </p>
    <p>
     <img alt="" height="243" src="https://i-blog.csdnimg.cn/direct/72ee4b0741724ec19059f87e68a2b2bf.png" width="724"/>
    </p>
    <blockquote>
     <p>
      注意：
      <strong>
       -t
      </strong>
      选项指定构建出镜像的标签 最后的 "." 指定的是当前目录，也就是构建上下文目录，Dockerfile所在的目录
     </p>
    </blockquote>
    <p>
     <strong>
      5.查看构建的镜像
     </strong>
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_test]# docker images
REPOSITORY                   TAG       IMAGE ID       CREATED         SIZE
centos_nginx                 latest    7ca95c53855e   2 minutes ago   342MB
ubuntu                       18.04     f9a80a55f492   21 months ago   63.2MB
reg.yym.com/openlab/ubuntu   18.04     f9a80a55f492   21 months ago   63.2MB
centos                       8         5d0da3dc9764   3 years ago     231MB
</code></pre>
    <p>
     <strong>
      6.启动容器并进行测试：
     </strong>
    </p>
    <p>
     <img alt="" height="65" src="https://i-blog.csdnimg.cn/direct/61d91dd2428a45b9bee1d14edd6b6aeb.png" width="729"/>
    </p>
    <h3>
     4.2 基于ubuntu镜像配置SSH服务
    </h3>
    <p>
     <strong>
      要求：
     </strong>
     <br/>
     1、基础镜像ubuntu:18.04。
     <br/>
     2、替换为国内的安装源（比如阿里或163）。
     <br/>
     3、安装openssh-server。
     <br/>
     4、允许root用户远程登录。
     <br/>
     5、暴露端口22。
     <br/>
     6、服务开机自启动。
    </p>
    <p>
     <strong>
      1.创建构建上下文目录：
     </strong>
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# pwd #这是我的构建上下文位置
/root/dockerfile_ssh
</code></pre>
    <p>
     <strong>
      2.文件准备
     </strong>
    </p>
    <p>
     1）apt源：
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# cat 163.list
deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse
</code></pre>
    <p>
     2）客户端公钥文件
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# ssh-keygen -f ~/.ssh/id_rsa -P '' -q #生成公私钥
[root@open-Euler3 dockerfile_ssh]# cp ~/.ssh/id_rsa.pub ./authorized_keys

</code></pre>
    <p>
     3）准备启动脚本文件
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# cat run.sh
#!/bin/bash
/usr/sbin/sshd -D
[root@open-Euler3 dockerfile_ssh]# chmod +x run.sh
</code></pre>
    <p>
     4）编写Dockerfile文件
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# vim Dockerfile
FROM ubuntu:18.04

MAINTAINER "kongd &lt;kongd@11.com&gt;"

RUN mv /etc/apt/sources.list /etc/apt/sources.bak
COPY aliyun.list /etc/apt/sources.list.d/aliyun.list
RUN apt update &amp;&amp; apt install -y openssh-server &amp;&amp; mkdir -p /var/run/sshd
RUN sed -ri 's/session    required     pam_loginuid.so/#session    required     pam_loginuid.so/' /etc/pam.d/sshd
COPY run.sh /run.sh
RUN chmod +x /run.sh
RUN mkdir /root/.ssh
COPY authorized_keys /root/.ssh/authorized_keys

EXPOSE 22/tcp

CMD ["/run.sh"]
</code></pre>
    <p>
     docker build 构建镜像）
    </p>
    <p>
     <img alt="" height="333" src="https://i-blog.csdnimg.cn/direct/8e778a9fb08e4dd9b74cae29d600cfca.png" width="730"/>
    </p>
    <p>
     查看镜像：
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# docker images
REPOSITORY                   TAG       IMAGE ID       CREATED         SIZE
ssh1_image                   latest    98ea77f917f0   4 minutes ago   248MB
centos_nginx                 latest    fb1d61ed3b60   3 hours ago     342MB
ubuntu                       18.04     f9a80a55f492   21 months ago   63.2MB
reg.yym.com/openlab/ubuntu   18.04     f9a80a55f492   21 months ago   63.2MB
centos                       8         5d0da3dc9764   3 years ago     231MB
</code></pre>
    <p>
     通过构建的镜像启动一个容器：
    </p>
    <pre><code class="language-bash">[root@open-Euler3 dockerfile_ssh]# docker run -itd --name ssh1_c1 -p 10022:22 ssh1_image
cfec71666b634dfbfea43427cf1846d9516bcc3a9806f923a6391e560a721319
[root@open-Euler3 dockerfile_ssh]# docker ps -a
CONTAINER ID   IMAGE        COMMAND     CREATED         STATUS         PORTS                                     NAMES
cfec71666b63   ssh1_image   "/run.sh"   3 seconds ago   Up 3 seconds   0.0.0.0:10022-&gt;22/tcp, :::10022-&gt;22/tcp   ssh1_c1
</code></pre>
    <p>
     测试ssh免密登录：
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/1f99f5530ca74ee3bac4431ee1f410df.png" width="733"/>
    </p>
    <p>
     可以看到直接通过映射后的宿主机IP+端口登录到容器的shell上。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37373739313930352f:61727469636c652f64657461696c732f313436313732343439" class_="artid" style="display:none">
 </p>
</div>


