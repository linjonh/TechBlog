---
layout: post
title: "玛卡巴卡的k8s知识点问答题三"
date: 2025-03-12 18:09:24 +0800
description: "提供高效的容器网络连接。实现精细化的网络策略，增强安全性。支持高性能和可扩展性，适用于大规模集群。提供丰富的网络安全功能，如加密通信和微隔离。支持多平台和灵活的部署选项。组件作用关键功能Kubernetes 的前端接口，处理所有请求提供 API、验证请求、写入etcdetcd分布式键值存储，保存集群状态存储集群元数据、提供高可用性和一致性运行控制器，确保集群状态与期望状态一致管理节点、Pod、Service 等资源的状态调度 Pod 到合适的节点根据资源需求和调度策略选择节点组件作用关键功能。"
keywords: "玛卡巴卡的k8s知识点问答题（三）"
categories: ['未分类']
tags: ['容器', '云原生', 'Kubernetes']
artid: "146210624"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146210624
    alt: "玛卡巴卡的k8s知识点问答题三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146210624
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146210624
cover: https://bing.ee123.net/img/rand?artid=146210624
image: https://bing.ee123.net/img/rand?artid=146210624
img: https://bing.ee123.net/img/rand?artid=146210624
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     玛卡巴卡的k8s知识点问答题（三）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="9.%20Calico%20%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E5%9C%A8%20K8s%20%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82" name="9.%20Calico%20%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E5%9C%A8%20K8s%20%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82">
     9. Calico 网络插件在 K8s 集群的作用。
    </h3>
    <p>
     Calico是一个开源的网络和网络安全解决方案，在k8s集群中是非常重要的角色，主要用于提高网络连接、网络策略和网络安全功能。以下是主要作用：
    </p>
    <h4 id="1.%20%E6%8F%90%E4%BE%9B%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" name="1.%20%E6%8F%90%E4%BE%9B%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">
     1.
     <strong>
      提供容器网络连接
     </strong>
    </h4>
    <p>
     Calico 为 Kubernetes 集群中的 Pod 提供网络连接，确保 Pod 之间可以相互通信。它通过以下方式实现：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        IP 地址管理（IPAM）
       </strong>
       ：Calico 为每个 Pod 分配唯一的 IP 地址，并管理 IP 地址的分配和回收。
      </p>
     </li>
     <li>
      <p>
       <strong>
        路由分发
       </strong>
       ：Calico 使用
       <strong>
        BGP（Border Gateway Protocol）
       </strong>
       协议在集群节点之间分发路由信息，确保 Pod 之间的流量能够正确路由。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持多种网络模式
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Overlay 模式
         </strong>
         ：使用 IP-in-IP 或 VXLAN 封装技术，适用于跨子网的集群。
        </p>
       </li>
       <li>
        <p>
         <strong>
          非 Overlay 模式
         </strong>
         ：直接路由模式，适用于同一子网内的集群，性能更高。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4 id="2.%20%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5%EF%BC%88Network%20Policy%EF%BC%89" name="2.%20%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5%EF%BC%88Network%20Policy%EF%BC%89">
     2.
     <strong>
      实现网络策略（Network Policy）
     </strong>
    </h4>
    <p>
     Calico 提供了强大的网络策略功能，允许用户定义精细化的网络访问规则，控制 Pod 之间的通信。这些策略可以用于：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        限制 Pod 的入口和出口流量
       </strong>
       ：例如，只允许特定的 Pod 或命名空间之间的通信。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现微服务的安全隔离
       </strong>
       ：通过策略限制服务之间的访问，提高安全性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持 Kubernetes 原生的 NetworkPolicy API
       </strong>
       ：Calico 完全兼容 Kubernetes 的 NetworkPolicy 资源，用户可以通过 YAML 文件定义策略。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      示例 NetworkPolicy
     </strong>
     ：
    </p>
    <pre><code class="hljs">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 80</code></pre>
    <hr/>
    <h4 id="3.%20%E6%8F%90%E4%BE%9B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8A%9F%E8%83%BD" name="3.%20%E6%8F%90%E4%BE%9B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8A%9F%E8%83%BD">
     3.
     <strong>
      提供网络安全功能
     </strong>
    </h4>
    <p>
     Calico 通过以下方式增强 Kubernetes 集群的安全性：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        基于身份的微隔离
       </strong>
       ：通过标签（Labels）和选择器（Selectors）定义策略，实现基于身份的访问控制。
      </p>
     </li>
     <li>
      <p>
       <strong>
        加密通信
       </strong>
       ：支持 WireGuard 加密技术，确保 Pod 之间的通信安全。
      </p>
     </li>
     <li>
      <p>
       <strong>
        防止 IP 欺骗
       </strong>
       ：Calico 会验证 Pod 的 IP 地址，防止 IP 欺骗攻击。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="4.%20%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7" name="4.%20%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">
     4.
     <strong>
      高性能和可扩展性
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        高性能
       </strong>
       ：Calico 的非 Overlay 模式（直接路由）避免了额外的封装和解封装开销，提供了接近原生网络的性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        可扩展性
       </strong>
       ：Calico 支持大规模的 Kubernetes 集群，能够处理数千个节点和数万个 Pod。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="5.%20%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81" name="5.%20%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81">
     5.
     <strong>
      多平台支持
     </strong>
    </h4>
    <p>
     Calico 不仅支持 Kubernetes，还支持其他容器编排平台，如 OpenShift、Rancher 等。此外，Calico 还可以与云服务商（如 AWS、GCP、Azure）的网络集成。
    </p>
    <hr/>
    <h4 id="6.%20%E7%81%B5%E6%B4%BB%E7%9A%84%E9%83%A8%E7%BD%B2%E9%80%89%E9%A1%B9" name="6.%20%E7%81%B5%E6%B4%BB%E7%9A%84%E9%83%A8%E7%BD%B2%E9%80%89%E9%A1%B9">
     6.
     <strong>
      灵活的部署选项
     </strong>
    </h4>
    <p>
     Calico 支持多种部署方式，包括：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        Kubernetes 集成
       </strong>
       ：通过 Kubernetes 的 CNI（Container Network Interface）插件部署。
      </p>
     </li>
     <li>
      <p>
       <strong>
        独立部署
       </strong>
       ：可以作为独立的网络解决方案部署在非 Kubernetes 环境中。
      </p>
     </li>
     <li>
      <p>
       <strong>
        托管服务
       </strong>
       ：通过 Tigera 提供的托管服务（如 Calico Cloud）获得企业级支持。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="7.%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E7%9B%91%E6%8E%A7" name="7.%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E7%9B%91%E6%8E%A7">
     7.
     <strong>
      可视化和监控
     </strong>
    </h4>
    <p>
     Calico 提供了丰富的可视化和监控工具，帮助用户更好地理解和管理集群中的网络流量和策略：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        Calico UI
       </strong>
       ：提供网络拓扑、策略状态和流量监控的可视化界面。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Prometheus 集成
       </strong>
       ：支持将网络指标导出到 Prometheus，方便用户进行监控和告警。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93">
     总结
    </h4>
    <p>
     Calico 在 Kubernetes 集群中的作用可以概括为：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        提供高效的容器网络连接
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实现精细化的网络策略
       </strong>
       ，增强安全性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持高性能和可扩展性
       </strong>
       ，适用于大规模集群。
      </p>
     </li>
     <li>
      <p>
       <strong>
        提供丰富的网络安全功能
       </strong>
       ，如加密通信和微隔离。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持多平台和灵活的部署选项
       </strong>
       。
      </p>
     </li>
    </ol>
    <h3 id="10.%20kube-apiserver%2C%20etcd%2C%20kube-controller-manager%2C%20kube-scheduler%20%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82" name="10.%20kube-apiserver%2C%20etcd%2C%20kube-controller-manager%2C%20kube-scheduler%20%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82">
     <br/>
     10. kube-apiserver, etcd, kube-controller-manager, kube-scheduler 的作用。
    </h3>
    <p>
     首先先来看官网的一张图：
     <br/>
     <img alt="" height="527" src="https://i-blog.csdnimg.cn/direct/7bf0c17af2394512b28b80c57e2b44d0.png" width="837"/>
    </p>
    <h4 id="1.%20kube-apiserver" name="1.%20kube-apiserver">
     1.
     <strong>
      kube-apiserver
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Kubernetes API 服务器，是 Kubernetes 集群的
       <strong>
        前端接口
       </strong>
       ，所有与集群的交互都通过它进行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         提供 RESTful API，供用户、命令行工具（如
         <code>
          kubectl
         </code>
         ）和其他组件访问。
        </p>
       </li>
       <li>
        <p>
         验证和授权请求（通过认证、授权和准入控制机制）。
        </p>
       </li>
       <li>
        <p>
         处理资源的创建、更新、删除和查询操作（如 Pod、Service、Deployment 等）。
        </p>
       </li>
       <li>
        <p>
         将集群的期望状态（Desired State）写入
         <code>
          etcd
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是无状态的，所有状态都存储在
         <code>
          etcd
         </code>
         中。
        </p>
       </li>
       <li>
        <p>
         支持水平扩展，可以通过
         <span style="background-color:#fbd4d0">
          部署多个实例来提高可用性和性能
         </span>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="2.%20etcd" name="2.%20etcd">
     2.
     <strong>
      etcd
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：分布式键值存储，是 Kubernetes 集群的
       <strong>
        持久化存储
       </strong>
       ，用于保存集群的所有配置数据和状态信息。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         存储 Kubernetes 集群的元数据，如节点信息、Pod 信息、服务信息、配置信息等。
        </p>
       </li>
       <li>
        <p>
         提供高可用性和一致性，确保集群状态的一致性和可靠性。
        </p>
       </li>
       <li>
        <p>
         支持 Watch 机制，其他组件可以通过 Watch 监听
         <code>
          etcd
         </code>
         中的数据变化。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是 Kubernetes 集群的
         <strong>
          唯一数据源
         </strong>
         ，所有组件都依赖
         <code>
          etcd
         </code>
         获取集群状态。
        </p>
       </li>
       <li>
        <p>
         支持分布式部署，确保高可用性
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="3.%20kube-controller-manager" name="3.%20kube-controller-manager">
     3.
     <strong>
      kube-controller-manager
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：控制器管理器，负责运行 Kubernetes 中的各种
       <strong>
        控制器
       </strong>
       ，确保集群的当前状态与期望状态一致。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         包含多个控制器，每个控制器负责管理特定类型的资源。常见的控制器包括：
        </p>
        <ul>
         <li>
          <p>
           <strong>
            Node Controller
           </strong>
           ：监控节点的状态，处理节点故障。
          </p>
         </li>
         <li>
          <p>
           <strong>
            Replication Controller
           </strong>
           ：确保 Pod 的副本数与期望值一致。
          </p>
         </li>
         <li>
          <p>
           <strong>
            Deployment Controller
           </strong>
           ：管理 Deployment 的创建、更新和回滚。
          </p>
         </li>
         <li>
          <p>
           <strong>
            Service Controller
           </strong>
           ：管理 Service 和 Endpoints 的创建和更新。
          </p>
         </li>
         <li>
          <p>
           <strong>
            Namespace Controller
           </strong>
           ：管理命名空间的生命周期。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         通过 Watch 机制监听
         <code>
          etcd
         </code>
         中的资源变化，并根据期望状态进行调整。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         控制器是 Kubernetes 实现
         <strong>
          声明式 API
         </strong>
         的核心组件。
        </p>
       </li>
       <li>
        <p>
         控制器通过不断调谐（Reconcile）确保集群状态与期望状态一致。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="4.%20kube-scheduler" name="4.%20kube-scheduler">
     4.
     <strong>
      kube-scheduler
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：调度器，负责将新创建的 Pod 分配到合适的节点上运行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据 Pod 的资源需求（如 CPU、内存）和节点的可用资源，选择合适的节点。
        </p>
       </li>
       <li>
        <p>
         考虑调度策略和约束条件，如节点亲和性（Node Affinity）、Pod 亲和性（Pod Affinity）、污点和容忍（Taints and Tolerations）等。
        </p>
       </li>
       <li>
        <p>
         支持扩展和自定义调度策略。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调度器只负责决策，不负责实际的 Pod 启动和运行。
        </p>
       </li>
       <li>
        <p>
         调度器是无状态的，所有调度决策都基于当前集群状态。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4 id="%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB" name="%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB">
     组件之间的协作关系
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        用户通过
        <code>
         kubectl
        </code>
        或其他客户端工具向
        <code>
         kube-apiserver
        </code>
        发送请求
       </strong>
       ，例如创建 Pod。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         kube-apiserver
        </code>
        验证请求并将资源信息写入
        <code>
         etcd
        </code>
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         kube-scheduler
        </code>
        监听
        <code>
         etcd
        </code>
        中的未调度 Pod
       </strong>
       ，并根据调度策略为 Pod 选择合适的节点，然后将调度结果写入
       <code>
        etcd
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         kube-controller-manager
        </code>
        监听
        <code>
         etcd
        </code>
        中的资源状态
       </strong>
       ，并根据期望状态进行调整。例如，确保 Pod 的副本数与期望值一致。
      </p>
     </li>
     <li>
      <p>
       <strong>
        节点上的
        <code>
         kubelet
        </code>
        从
        <code>
         kube-apiserver
        </code>
        获取调度到本节点的 Pod 信息
       </strong>
       ，并启动 Pod。
      </p>
     </li>
    </ol>
    <hr/>
    <h4 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93">
     总结
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <p>
         组件
        </p>
       </th>
       <th>
        作用
       </th>
       <th>
        关键功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         kube-apiserver
        </strong>
       </td>
       <td>
        Kubernetes 的前端接口，处理所有请求
       </td>
       <td>
        提供 API、验证请求、写入
        <code>
         etcd
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         etcd
        </strong>
       </td>
       <td>
        分布式键值存储，保存集群状态
       </td>
       <td>
        存储集群元数据、提供高可用性和一致性
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         kube-controller-manager
        </strong>
       </td>
       <td>
        运行控制器，确保集群状态与期望状态一致
       </td>
       <td>
        管理节点、Pod、Service 等资源的状态
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         kube-scheduler
        </strong>
       </td>
       <td>
        调度 Pod 到合适的节点
       </td>
       <td>
        根据资源需求和调度策略选择节点
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="11.%20kubelet%2C%20kube-proxy%20%E4%BD%9C%E7%94%A8%E3%80%82" name="11.%20kubelet%2C%20kube-proxy%20%E4%BD%9C%E7%94%A8%E3%80%82">
     <br/>
     11. kubelet, kube-proxy 作用。
    </h3>
    <p>
     kubelete会在集群中的每个节点上运行，它保证容器都运行在Pod中。
    </p>
    <h4 id="1.%20kubelet" name="1.%20kubelet">
     1.
     <strong>
      kubelet
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Kubernetes 节点上的主要代理组件，负责管理节点上的 Pod 和容器。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Pod 生命周期管理
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           从
           <code>
            kube-apiserver
           </code>
           获取调度到本节点的 Pod 信息。
          </p>
         </li>
         <li>
          <p>
           根据 Pod 的配置启动、停止和管理容器。
          </p>
         </li>
         <li>
          <p>
           确保 Pod 中的容器处于运行状态，并在容器失败时重启它们。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          资源监控
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           监控节点上的资源使用情况（如 CPU、内存、磁盘等），并将这些信息上报给
           <code>
            kube-apiserver
           </code>
           。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          容器健康检查
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           执行
           <code>
            livenessProbe
           </code>
           和
           <code>
            readinessProbe
           </code>
           ，确保容器的健康状态。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          镜像管理
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           拉取 Pod 所需的容器镜像，并管理镜像的缓存。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          与容器运行时交互
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           通过 CRI（Container Runtime Interface）与容器运行时（如 Docker、containerd）交互，执行容器的创建、启动和停止操作。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          Volume 和网络管理
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           挂载 Pod 所需的 Volume（如 ConfigMap、Secret、Persistent Volume 等）。
          </p>
         </li>
         <li>
          <p>
           配置 Pod 的网络命名空间和网络接口。
          </p>
         </li>
        </ul>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是 Kubernetes 集群中每个节点上必须运行的组件。
        </p>
       </li>
       <li>
        <p>
         直接与容器运行时和操作系统交互，是 Kubernetes 管理容器的核心组件。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="2.%20kube-proxy" name="2.%20kube-proxy">
     2.
     <strong>
      kube-proxy
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Kubernetes 节点上的网络代理组件，负责实现 Service 的网络转发和负载均衡。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Service 的实现
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           监听
           <code>
            kube-apiserver
           </code>
           中的 Service 和 Endpoints 变化。
          </p>
         </li>
         <li>
          <p>
           根据 Service 的配置，为每个 Service 创建虚拟 IP（ClusterIP）和端口。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          流量转发
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           将发送到 Service ClusterIP 的流量转发到后端的 Pod。
          </p>
         </li>
         <li>
          <p>
           支持多种代理模式：
          </p>
          <ul>
           <li>
            <p>
             <strong>
              userspace 模式
             </strong>
             ：流量通过用户空间的代理程序转发（性能较低，已逐渐淘汰）。
            </p>
           </li>
           <li>
            <p>
             <strong>
              iptables 模式
             </strong>
             ：使用 Linux 的
             <code>
              iptables
             </code>
             规则实现流量转发（性能较高，是默认模式）。
            </p>
           </li>
           <li>
            <p>
             <strong>
              IPVS 模式
             </strong>
             ：使用 Linux 的 IPVS（IP Virtual Server）实现流量转发（性能最高，支持更复杂的负载均衡算法）。
            </p>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          负载均衡
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           在多个 Pod 之间分配流量，实现负载均衡。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          网络策略支持
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           配合网络插件（如 Calico、Cilium）实现网络策略（Network Policy）的流量控制。
          </p>
         </li>
        </ul>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是 Kubernetes 集群中每个节点上必须运行的组件。
        </p>
       </li>
       <li>
        <p>
         通过维护节点上的网络规则，确保 Service 的流量能够正确转发到后端的 Pod。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB" name="%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB">
     组件之间的协作关系
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         kubelet
        </code>
        与
        <code>
         kube-apiserver
        </code>
        的交互
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          kubelet
         </code>
         从
         <code>
          kube-apiserver
         </code>
         获取调度到本节点的 Pod 信息。
        </p>
       </li>
       <li>
        <p>
         <code>
          kubelet
         </code>
         将节点的状态（如资源使用情况、Pod 状态）上报给
         <code>
          kube-apiserver
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         kube-proxy
        </code>
        与
        <code>
         kube-apiserver
        </code>
        的交互
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          kube-proxy
         </code>
         监听
         <code>
          kube-apiserver
         </code>
         中的 Service 和 Endpoints 变化。
        </p>
       </li>
       <li>
        <p>
         <code>
          kube-proxy
         </code>
         根据 Service 的配置更新节点上的网络规则。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         kubelet
        </code>
        与
        <code>
         kube-proxy
        </code>
        的协作
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          kubelet
         </code>
         负责启动和管理 Pod 中的容器。
        </p>
       </li>
       <li>
        <p>
         <code>
          kube-proxy
         </code>
         负责将 Service 的流量转发到这些容器。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93">
     总结
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        组件
       </th>
       <th>
        作用
       </th>
       <th>
        关键功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         kubelet
        </strong>
       </td>
       <td>
        管理节点上的 Pod 和容器
       </td>
       <td>
        启动/停止容器、监控资源、健康检查、镜像管理、Volume 挂载
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         kube-proxy
        </strong>
       </td>
       <td>
        实现 Service 的网络转发和负载均衡
       </td>
       <td>
        流量转发、负载均衡、维护网络规则
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="12.%20%E4%BB%80%E4%B9%88%E6%98%AF%20K8s%20%E7%9A%84%20namespace%EF%BC%9F" name="12.%20%E4%BB%80%E4%B9%88%E6%98%AF%20K8s%20%E7%9A%84%20namespace%EF%BC%9F">
     <br/>
     12. 什么是 K8s 的 namespace？
    </h3>
    <p>
     在k8s中，namespace提供一种机制，将同一集群中的资源划分未相互隔离的组。同一命名空间中的资源名称要唯一，但是跨命名空间没这个要求。
    </p>
    <p>
    </p>
    <h3>
     13.namespace和cgroup的关系？
    </h3>
    <h4>
     1.
     <strong>
      Namespace（命名空间）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Namespace 是 Kubernetes 中的一种逻辑分区机制，用于将集群资源划分为多个虚拟集群。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         资源隔离：将资源（如 Pod、Service、Deployment 等）划分到不同的命名空间中。
        </p>
       </li>
       <li>
        <p>
         权限控制：通过 RBAC 限制用户或团队对特定命名空间的访问权限。
        </p>
       </li>
       <li>
        <p>
         资源配额管理：为命名空间设置资源配额，限制其资源使用量。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        级别
       </strong>
       ：Namespace 是 Kubernetes 集群级别的概念，主要用于组织和隔离 Kubernetes 资源。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     2.
     <strong>
      控制组（cgroups）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：cgroups 是 Linux 内核的一种机制，用于限制、记录和隔离进程组的资源使用（如 CPU、内存、磁盘 I/O 等）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         资源限制：限制进程组可以使用的资源量（如 CPU、内存）。
        </p>
       </li>
       <li>
        <p>
         资源统计：记录进程组的资源使用情况。
        </p>
       </li>
       <li>
        <p>
         优先级控制：为进程组分配不同的资源使用优先级。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        级别
       </strong>
       ：cgroups 是操作系统级别的概念，主要用于管理单个节点上的进程资源。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     3.
     <strong>
      Namespace 和 cgroups 的关系
     </strong>
    </h4>
    <p>
     虽然 Namespace 和 cgroups 都涉及资源隔离和管理，但它们的作用范围和层次不同：
    </p>
    <h5>
     （1）
     <strong>
      作用范围
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        Namespace
       </strong>
       ：作用于 Kubernetes 集群级别，用于隔离 Kubernetes 资源（如 Pod、Service 等）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        cgroups
       </strong>
       ：作用于操作系统级别，用于隔离和管理单个节点上的进程资源。
      </p>
     </li>
    </ul>
    <h5>
     （2）
     <strong>
      资源管理
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        Namespace
       </strong>
       ：通过资源配额（Resource Quota）和限制范围（Limit Range）管理 Kubernetes 资源的使用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        cgroups
       </strong>
       ：通过 Linux 内核机制管理进程的资源使用（如 CPU、内存）。
      </p>
     </li>
    </ul>
    <h5>
     （3）
     <strong>
      协作关系
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       在 Kubernetes 中，
       <strong>
        cgroups 是实现资源限制的基础
       </strong>
       。例如，当你在 Kubernetes 中为 Pod 设置资源请求（requests）和限制（limits）时，Kubernetes 会通过 cgroups 在节点上实施这些限制。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Namespace 的资源配额
       </strong>
       （如 CPU、内存）最终会通过 cgroups 在节点上生效。例如，如果你为某个命名空间设置了 CPU 配额，Kubernetes 会通过 cgroups 限制该命名空间中所有 Pod 的 CPU 使用。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     4.
     <strong>
      示例：Namespace 和 cgroups 的协作
     </strong>
    </h4>
    <p>
     假设你在 Kubernetes 中创建了一个命名空间
     <code>
      my-namespace
     </code>
     ，并为其设置了资源配额：
    </p>
    <pre><code class="hljs">apiVersion: v1
kind: ResourceQuota
metadata:
  name: my-quota
  namespace: my-namespace
spec:
  hard:
    requests.cpu: "2"
    requests.memory: "4Gi"
    limits.cpu: "4"
    limits.memory: "8Gi"</code></pre>
    <p>
     当你在
     <code>
      my-namespace
     </code>
     中创建 Pod 时，Kubernetes 会通过以下步骤实施资源管理：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        Kubernetes 调度器
       </strong>
       ：根据 Pod 的资源请求（requests）和节点的可用资源，将 Pod 调度到合适的节点。
      </p>
     </li>
     <li>
      <p>
       <strong>
        kubelet
       </strong>
       ：在节点上启动 Pod 的容器，并通过 cgroups 设置容器的资源限制（如 CPU、内存）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        cgroups
       </strong>
       ：在操作系统级别限制容器的资源使用，确保其不超过命名空间的资源配额。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     5.
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Namespace
       </strong>
       是 Kubernetes 中的逻辑分区机制，用于隔离和管理 Kubernetes 资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        cgroups
       </strong>
       是 Linux 内核的机制，用于隔离和管理进程资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        协作关系
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Namespace 的资源配额和限制通过 cgroups 在节点上实施。
        </p>
       </li>
       <li>
        <p>
         cgroups 是实现 Kubernetes 资源管理的基础。
        </p>
       </li>
      </ul>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393839333837382f:61727469636c652f64657461696c732f313436323130363234" class_="artid" style="display:none">
 </p>
</div>


