---
layout: post
title: 白盒测试用例设计方法
date: 2024-12-10 12:41:07 +0800
categories: ['测试Test']
tags: ['设计', '白盒', '用例', '测试', '方法']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=53846650
    alt: 白盒测试用例设计方法
artid: 53846650
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=53846650
featuredImagePreview: https://bing.ee123.net/img/rand?artid=53846650
---

# 白盒测试用例设计方法

**一、白盒测试**

根据软件产品的内部工作过程，在计算机上进行测试，以证实每种内部操作是否符合设计规格要求，所有内部成分是否已经过检查。这种测试方法就是白盒测试。白盒测试把测试对象看做一个打开的盒子，允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。

不论是黑盒测试，还是白盒测试，都不可能把所有可能的输入数据都拿来进行所谓的穷举测试。因为可能的测试输入数据数目往往达到天文数字。下面让我们看两个例子。

假设一个程序

P

有输入

X

和

Y

及输出

Z

，参看图

10-4-1

。在字长为

32

位的计算机上运行。如果

X

、

Y

只取整数，考虑把所有的

X

、

Y

值都做为测试数据，按黑盒测试方法进行穷举测试，力图全面、无遗漏地

“

挖掘

”

出程序中的所有错误。这样做可能采用的测试数据组（

Xi

，

Yi

）的最大可能数目为：

。如果程序
P
测试一组

X

、

Y

数据需要

1

毫秒，且一天工作

24

小时，一年工作

365

天，要完成

264

组测试，需要

5

亿年。

![](https://i-blog.csdnimg.cn/blog_migrate/21df7b780ff1474c11d061bc8c9686cd.jpeg)
  
图
10-4-1
黑盒子

而对一个具有多重选择和循环嵌套的程序，不同的路径数目也可能是天文数字。设给出一个如图
10-4-2
所示的小程序的流程图，其中包括了一个执行达

20

次的循环。那么它所包含的不同执行路径数高达

条，若要对它进行穷举测试，覆盖所有的路径。假使测试程序对每一条路径进行测试需要

1

毫秒，同样假定一天工作

24

小时，一年工作

365

天，那么要想把如图

10-4-2

所示的小程序的所有路径测试完，则需要

3170

年。

![](https://i-blog.csdnimg.cn/blog_migrate/8454201b2bb2709c7bd40de0e6a95d75.jpeg)
  
图
10-4-2
白盒测试中的穷举测试

以上的分析表明，实行穷举测试，由于工作量过大，实施起来是不现实的。任何软件开发项目都要受到期限、费用、人力和机时等条件的限制，尽管为了充分揭露程序中所有隐藏错误，需要针对所有可能的数据进行测试，但事实告诉我们，这样做是不可能的。

软件工程的总目标是充分利用有限的人力、物力资源，高效率、高质量、低成本地完成软件开发项目。在测试阶段既然穷举测试不可行，为了节省时间和资源，提高测试效率，就必须要从数量极大的可用测试用例中精心地挑选少量的测试数据，使得采用这些测试数据能够达到最佳的测试效果，能够高效率地把隐藏的错误揭露出来。

**二、逻辑覆盖**

逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。属白盒测试。这一方法要求测试人员对程序的逻辑结构有清楚的了解，甚至要能掌握源程序的所有细节。由于覆盖测试的目标不同，逻辑覆盖又可分为：语句覆盖、判定覆盖、判定－条件覆盖、条件组合覆盖及路径覆盖。

1.

语句覆盖

语句覆盖就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。这种覆盖又称为点覆盖，它使得程序中每个可执行语句都得到执行，但它是最弱的逻辑覆盖准，效果有限，必须与其他方法交互使用。

2.

判定覆盖

判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。判定覆盖又称为分支覆盖。

判定覆盖只比语句覆盖稍强一些，但实际效果表明，只是判定覆盖，还不能保证一定能查出在判断的条件中存在的错误。因此，还需要更强的逻辑覆盖准则去检验判断内部条件。

3.

条件覆盖

条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次。

条件覆盖深入到判定中的每个条件，但可能不能满足判定覆盖的要求。

4.

判定－条件覆盖

判定－条件覆盖就是设计足够的测试用例，使得判断中每个条件的所有可能取值至少执行一次，同时每个判断本身的所有可能判断结果至少执行一次。换言之，即是要求各个判断的所有可能的条件取值组合至少执行一次。

判定－条件覆盖有缺陷。从表面上来看，它测试了所有条件的取值。但是事实并非如此。往往某些条件掩盖了另一些条件。会遗漏某些条件取值错误的情况。为彻底地检查所有条件的取值，需要将判定语句中给出的复合条件表达式进行分解，形成由多个基本判定嵌套的流程图。这样就可以有效地检查所有的条件是否正确了。

![](https://i-blog.csdnimg.cn/blog_migrate/027ee549026131fd17e23939917f08a4.jpeg)
  
图
10-4-3
（
a
）　复合判定的例子

![](https://i-blog.csdnimg.cn/blog_migrate/4617f7d3c164c6aac81cfb8a36879620.jpeg)
  
图
10-4-3
（
b
）　改为单个条件判定的嵌套结构的例子

5.

多重条件覆盖

多重条件覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次。

这是一种相当强的覆盖准则，可以有效地检查各种可能的条件取值的组合是否正确。它不但可覆盖所有条件的可能取值的组合，还可覆盖所有判断的可取分支，但可能有的路径会遗漏掉。测试还不完全。

6.

路径测试

路径测试就是设计足够的测试用例，覆盖程序中所有可能的路径。这是最强的覆盖准则。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。下面我们做一分析。

**三、关于控制结构测试的一些讨论**

1.

分支结构的路径数

当程序中判定多于一个时，形成的分支结构可以分为两类：嵌套型分支结构和连锁型分支结构。如图

10-4-4

所示。对于嵌套型分支结构，若有

n

个判定语句，则需要

n+1

个测试用例；但对连锁型分支结构，若有

n

个判定语句，则需要有

个测试用例，去覆盖它的

条路径。当

n

较大时将无法测试。

![](https://i-blog.csdnimg.cn/blog_migrate/150dad4ff2ca0c242dfad0e3eebc8938.jpeg)
  
（
a
）嵌套型分支结构

![](https://i-blog.csdnimg.cn/blog_migrate/2993433aee623be0c8f2c94e3e3d6f2d.jpeg)
  
（
b
）连锁型分支结构

图
10-4-4
分支的两种类型

为减少测试用例的数目，可采用试验设计法，抽取部分路径进行测试。由于抽样服从均匀分布，因此，在假定各条路径的重要性相同，或暂不明确各条路径的重要性的情况下可以做到均匀抽样。如果明确了各条路径的重要性，还可以采取加权的办法，筛选掉部分路径，再用如下的措施进行抽样。具体步骤如下：

（

1

）

设耦合型分支结构中有

n

个判定，计算满足关系式

的最小自然数

m

；

（

2

）

设

，取正交表

L4

，并利用它设计测试数据。

例如，一个耦合型分支结构中有三个判定语句

P1

，

P2

，

P3

。它全部路径是

23

＝

8

条。先计算

的

t

，得

t= 4

。取正交表

L4

，如图

10-
4-5
（

a

）所示，把每一列当做一个判定，每一行当做可取的测试用例，则正交表

L4

最多可取三个判定，分别代之以

P1

，

P2

，

P3

。判定

P1

，

P2

，

P3

的取假分支和取真分支分别记作

S1

、

S2

；

S3

、

S4

；

S5

、

S6

，用各个判定的取假分支取代正交表

L4

中的

“0”

，用取真分支取代正交表中的

“1”

，就建立起一个测试路径矩阵，如图

10-4-5

（

b

）所示。这样，测试路径数目从

条减少到

3

＋

1

＝

4

条。

![](https://i-blog.csdnimg.cn/blog_migrate/35eb384603b171c97134feef0fdd1260.jpeg)
  
图
10-4-5
（
a
）　正交表
L4

![](https://i-blog.csdnimg.cn/blog_migrate/8ae9dbed39f8d9a5f887ce1dfe51a0e6.jpeg)
  
图
10-4-5
（
b
）　路径抽样矩阵

2.

条件测试的策略

程序中的条件分为简单条件和复合条件。简单条件是一个布尔变量或一个关系表达式（可加前缀

NOT

），复合条件由简单条件通过逻辑运算符（

AND

、

OR

、

NOT

）和括号连接而成。如果条件出错，至少是条件中某一成分有错。条件中可能的出错类型有：布尔运算符错、布尔变量错、布尔括号错、关系运算符错、算术表达式错。

如果在一个判定的复合条件表达式中每个布尔变量和关系运算符最多只出现一次，而且没有公共变量，应用一种称之为

BRO

（分支与关系运算符）的测试法可以发现多个布尔运算符或关系运算符错，以及其他错误。

BRO

策略引入条件约束的概念。设有

n

个简单条件的复合条件

C

，其条件约束为

，其中

是条件

C

中第

i

个简单条件的输出约束。如果在

C

的执行过程中，其每个简单条件的输出都满足

D

中对应的约束，则称条件

C

的条件约束

D

由

C

的执行所覆盖。特别地，布尔变量或布尔表达式的输出约束必须是真（

t

）或假（

f

）；关系表达式的输出约束为符号

>

、

=

、

<

。

（

1

）

设条件为

。其中

是布尔变量，

的输出约束为

，在此，

和

或为

t

或为

f

。则

是

可能的一个约束。覆盖此约束的测试（一次运行）将令

为

t

，

为

f

。

BR
O
策略要求对

的可能约束集合

中的每一个，分别设计一组测试用例。如果布尔运算符有错，这三组测试用例的运行结果必有一组导致

失败。

（

2

）

设条件为

。其中

是布尔表达式，

和

是算术表达式，

的输出约束为

，在此，

或为

t

或为

f

；

则是

<

、

=

或

>

。因此，只有

与

中

的不同，可以修改

的约束集合

，导出

的约束集合。因为在

中，

“t”

相当于

“=”

，

“f”

相当于

“<”

或

“>”

，则

的约束集合为

。据此设计

4

组测试用例，检查

中可能的布尔或关系运算符中的错误。

（

3

）

设条件为

。其中

都是算术表达式，

的输出约束为

，在此，

和

的约束均为

<

、

=

、

>

。

中只有

与

中的

不同，可以修改

的约束集合

，导出

的约束集合。因为在

中，

“t”

相当于

“>”

，

"f"

相当于

“<”

或

“=”

，则

的约束集合为

。根据这个约束集合设计测试用例，就能够检测

中的关系运算符中的错误。

3.

循环测试

循环分为

4

种不同类型：简单循环、连锁循环、嵌套循环和非结构循环，见图

10-4-6

。

![](https://i-blog.csdnimg.cn/blog_migrate/baf1bc7f58024e2ffa6c47a591b8c9be.jpeg)
  
图
10-4-6
循环的分类

对于简单循环，测试应包括以下几种，其中的

n

表示循环允许的最大次数。

（

1

）

零次循环：从循环入口直接跳到循环出口。

（

2

）

一次循环：查找循环初始值方面的错误。

（

3

）

二次循环：检查在多次循环时才能暴露的错误。

（

4

）

m

次循环：此时的

m

＜

n

，也是检查在多次循环时才能暴露的错误。

·

最大次数循环、比最大次数多一次的循环、比最大次数少一次的循环。

对于嵌套循环，不能将简单循环的测试方法简单地扩大到嵌套循环，因为可能的测试数目将随嵌套层次的增加呈几何倍数增长。这可能导致一个天文数字的测试数目。下面给出一种有助于减少测试数目的测试方法。

·

除最内层循环外，从最内层循环开始，置所有其他层的循环为最小值；

·

对最内层循环做简单循环的全部测试。测试时保持所有外层循环的循环变量为最小值。另外，对越界值和非法值做类似的测试。

·

逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取

“

典型

”

值。

·

反复进行，直到所有各层循环测试完毕。

·

对全部各层循环同时取最小循环次数，或者同时取最大循环次数。对于后一种测试，由于测试量太大，需人为指定最大循环次数。

对于连锁循环，要区别两种情况。如果各个循环互相独立，则连锁循环可以用与简单循环相同的方法进行测试。例如，有两个循环处于连锁状态，则前一个循环的循环变量的值就可以做为后一个循环的初值。但如果几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理。

对于非结构循环，应该使用结构化程序设计方法重新设计测试用例。

**四、基本路径测试**

如果把覆盖的路径数压缩到一定限度内，例如，程序中的循环体只执行零次和一次，就成为基本路径测试。它是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。

设计出的测试用例要保证在测试中，程序的每一个可执行语句至少要执行一次。

1.

程序的控制流图

控制流图是描述程序控制流的一种图示方法。基本控制构造的图形符号如图

10-4-7

所示。符号

○

称为控制流图的一个结点，一组顺序处理框可以映射为一个单一的结点。控制流图中的箭头称为边，它表示了控制流的方向，在选择或多分支结构中分支的汇聚处，即使没有执行语句也应该有一个汇聚结点。边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域。

![](https://i-blog.csdnimg.cn/blog_migrate/45c26ae7a07d351faf2a37a3d688651e.jpeg)
  
图
10-4-7
控制流图的各种图形符号

如果判定中的条件表达式是复合条件时，即条件表达式是由一个或多个逻辑运算符（

OR

，

AND

，

NAND

，

NOR

）连接的逻辑表达式，则需要改复合条件的判定为一系列只有单个条件的嵌套的判定。例如对应图

1
0-4-8
（

a

）的复合条件的判定，应该画成如图

10-4-8

（

b

）所示的控制流图。条件语句

ifaORb

中条件

a

和条件

b

各有一个只有单个条件的判定结点。

![](https://i-blog.csdnimg.cn/blog_migrate/c9a9030ecb22690ab292b0a0e15dbb9f.jpeg)
  
图
10-4-8
复合逻辑下的控制流图

2.

计算程序环路复杂性

进行程序的基本路径测试时，程序的环路复杂性给出了程序基本路径集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必需的测试用例数目的上界。

所谓独立路径，是指包括一组以前没有处理的语句或条件的一条路径。如在图

10-4-9

（

b

）所示的控制流图中，一组独立的路径是

path1

：

1-11

path2

：

1-2-3-4-5-10-1-11

path3

：

1-2-3-6-8-9-10-1-11

path4

：

1-2-3-6-7-9-10-1-11

路径

path1

，

path2

，

path3

，

path4

组成了图

10-4-9

（

b

）所示控制流图的一个基本路径集。只要设计出的测试用例能够确保这些基本路径的执行，就可以使得程序中的每个可执行语句至少执行一次，每个条件的取真和取假分支也能得到测试。基本路径集不是唯一的，对于给定的控制流图，可以得到不同的基本路径集。

![](https://i-blog.csdnimg.cn/blog_migrate/ea5ae70785678d1317cac390d2f378c8.jpeg)
  
（
a
）程序流程图

![](https://i-blog.csdnimg.cn/blog_migrate/5cdc264f062dc54205571c27da3c2450.jpeg)
  
（
b
）控制流图

图
10-4-9
程序流程图与对应的控制流图

通常环路复杂性可用以下

3

种方法求得。

（

1

）

将环路复杂性定义为控制流图中的区域数。

（

2

）

设

E

为控制流图的边数，

N

为图的结点数，则定义环路复杂性为

V

（

G

）＝

E

－

N

＋

2

。

（

3

）

若设

P

为控制流图中的判定结点数，则有

V

（

G

）＝

P

＋

1

。

因为图

10-4-9

（

b

）所示控制流图有

4

个区域。其环路复杂性为

4

。它是构成基本路径集的独立路径数的上界。可以据此得到应该设计的测试用例的数目。

3.

导出测试用例

利用逻辑覆盖方法生成测试用例，确保基本路径集中每条路径的执行。
  
  

Word版本下载地址
[/Files/Jackc/白盒测试用例设计方法.doc](http://files.cnblogs.com/Jackc/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.doc)

from: http://www.cnblogs.com/Jackc/archive/2009/09/16/1567203.html