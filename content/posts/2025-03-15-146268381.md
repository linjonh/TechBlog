---
layout: post
title: "ElasticSearch组合查询及实际应用"
date: 2025-03-15 01:24:10 +0800
description: "ElasticSearch组合查询及实际应用"
keywords: "ElasticSearch组合查询及实际应用"
categories: ['未分类']
tags: ['搜索引擎', '大数据', '后端', '全文检索', 'Java', 'Elasticsearch']
artid: "146268381"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268381
    alt: "ElasticSearch组合查询及实际应用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268381
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268381
cover: https://bing.ee123.net/img/rand?artid=146268381
image: https://bing.ee123.net/img/rand?artid=146268381
img: https://bing.ee123.net/img/rand?artid=146268381
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ElasticSearch组合查询及实际应用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、引言
    </h2>
    <p>
     在
     <a class="link-info" href="https://blog.csdn.net/2301_77251217/article/details/146216933?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=146216933&amp;sharerefer=PC&amp;sharesource=2301_77251217&amp;sharefrom=from_link" title="ElasticSearch快速入门">
      ElasticSearch快速入门
     </a>
     一文中，我向大家简单介绍了ES和一些基本的查询语法，接下来我将结合黑马程序员的黑马旅游案例再深入介绍一些组合DSL，并将其与开发中的应用对照起来。
    </p>
    <h2>
     二、场景功能简介
    </h2>
    <p>
     这部分我们简单介绍一下有哪些业务场景以及需要用到的查询和属性（注意并非所有属性，其他属性可自行扩展）。
    </p>
    <p>
     <img alt="" height="918" src="https://i-blog.csdnimg.cn/direct/933a4e4e6f3e4a588c4efe84d3861ba3.png" width="1383"/>
    </p>
    <h3>
     1.条件查询回显ES索引库中的文档
    </h3>
    <h4>
     （1）Boolean Query
    </h4>
    <p>
     BooleanQuery 是一个非常强大且常用的查询类型，它允许你组合多个查询条件来构建复杂的查询逻辑。BooleanQuery支持四种类型的子查询：
     <code>
      must
     </code>
     、
     <code>
      should
     </code>
     、
     <code>
      must_not
     </code>
     和
     <code>
      filter
     </code>
     。
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         must
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          必须条件：查询中所有
          <code>
           must
          </code>
          子句柄指定的条件都必须满足。这相当于逻辑运算中的
          <code>
           AND
          </code>
          。如果一个文档满足所有
          <code>
           must
          </code>
          条件，那么它将被包含在查询结果中。
         </p>
        </li>
        <li>
         <p>
          评分相关性：
          <code>
           must
          </code>
          条件会影响文档的相关性评分，即更符合
          <code>
           must
          </code>
          条件的文档会有更高的评分。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         should
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          可选条件：查询中
          <code>
           should
          </code>
          子句柄指定的条件至少有一个需要满足。这相当于逻辑运算中的
          <code>
           OR
          </code>
          。
          <code>
           should
          </code>
          子句柄通常用于指定那些理想条件下的查询，但不是强制要求。
         </p>
        </li>
        <li>
         <p>
          评分相关性：
          <code>
           should
          </code>
          条件也会影响文档的相关性评分，满足的
          <code>
           should
          </code>
          条件越多，文档的相关性评分越高。
         </p>
        </li>
        <li>
         <p>
          最小匹配：可以通过
          <code>
           minimum_should_match
          </code>
          参数指定必须满足的最小
          <code>
           should
          </code>
          条件数。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         must_not
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          排除条件：查询中
          <code>
           must_not
          </code>
          子句柄指定的条件必须不满足。这相当于逻辑运算中的
          <code>
           NOT
          </code>
          。如果一个文档不满足
          <code>
           must_not
          </code>
          条件，那么它将被包含在查询结果中。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         filter
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          过滤条件：
          <code>
           filter
          </code>
          子句柄用于应用过滤查询结果，但不会影响文档的相关性评分。
          <code>
           filter
          </code>
          子句柄通常用于那些不需要计算评分的查询条件，如范围查询、术语查询等。
         </p>
        </li>
        <li>
         <p>
          缓存：
          <code>
           filter
          </code>
          条件通常会被缓存，这可以提高查询性能，特别是当相同的过滤条件被多次使用时。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h4>
     （2）Bucket 聚合
    </h4>
    <p>
     Bucket 聚合是 Elasticsearch 中一种基于文档集合进行切分的聚合方式，它将文档集合分成多个 bucket，并对每个 bucket 进行计算和分析，类似GroupBy。
    </p>
    <h3>
     2.广告置顶
    </h3>
    <h4>
     （3）Function_score Query
    </h4>
    <p>
     <code>
      function_score
     </code>
     查询允许你修改由查询检索到的文档的分数。
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         script
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          一个脚本，用于计算每个文档的新分数。脚本可以访问文档的字段值，并基于这些值计算分数。
         </p>
        </li>
        <li>
         <p>
          脚本中可以使用内置的数学函数和逻辑运算符。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         boost
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          一个乘法因子，用于调整
          <code>
           script
          </code>
          脚本计算出的分数。这允许你控制脚本分数的影响程度。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         boost_mode
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定如何将脚本分数与查询分数结合。常见的选项包括：
         </p>
         <ul>
          <li>
           <p>
            <code>
             "replace"
            </code>
            ：用脚本分数替换查询分数。
           </p>
          </li>
          <li>
           <p>
            <code>
             "multiply"
            </code>
            ：将脚本分数与查询分数相乘。
           </p>
          </li>
          <li>
           <p>
            <code>
             "sum"
            </code>
            ：将脚本分数与查询分数相加。
           </p>
          </li>
          <li>
           <p>
            <code>
             "avg"
            </code>
            ：计算脚本分数和查询分数的平均值。
           </p>
          </li>
          <li>
           <p>
            <code>
             "max"
            </code>
            ：取脚本分数和查询分数的最大值。
           </p>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         weight
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          属性允许你控制评分函数对最终分数的影响程度。通过增加
          <code>
           weight
          </code>
          值，可以增强评分函数对文档相关性的影响。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h3>
     3.通过经纬度点匹配附近酒店
    </h3>
    <h4>
     （4）
     <strong>
      Geo-distance Query
     </strong>
    </h4>
    <p>
     Geo-distance Query基于距离查询，返回距离指定点一定范围内的文档。
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          distance
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定要搜索的距离范围，可以是任意正数，并且可以附带单位（如
          <code>
           km
          </code>
          表示公里，
          <code>
           mi
          </code>
          表示英里）。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          location
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定参考点的地理坐标。可以是如下格式之一：
         </p>
         <ul>
          <li>
           <p>
            经纬度和经度的数组：
            <code>
             [lon, lat]
            </code>
           </p>
          </li>
          <li>
           <p>
            GeoJSON 格式的点对象：
            <code>
             { "type": "point", "coordinates": [lon, lat]}
            </code>
           </p>
          </li>
          <li>
           <p>
            Well-Known Text（WKT）格式的字符串，例如：
            <code>
             "POINT (lon lat)"
            </code>
           </p>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h3>
     4.自动补全回显搜索框内容
    </h3>
    <h4>
     （5）Suggestion
    </h4>
    <p>
     Elasticsearch 的自动补全（Suggestion）功能主要通过
     <code>
      suggest
     </code>
     查询来实现，它通常与
     <code>
      completion
     </code>
     类型的字段一起使用。
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          prefix
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定自动补全的前缀字符串，用户输入的初始部分内容。这是触发自动补全功能的关键输入。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          completion
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定用于自动补全的字段，它必须是
          <code>
           completion
          </code>
          类型字段。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          size
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定返回的建议列表的大小，即返回的最大建议项数。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          context
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          提供上下文信息，用于改进自动补全的准确性。上下文可以是任何可以识别的字段，Elasticsearch 会使用这些上下文信息来优化建议的相关性。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          skip_duplicates
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定是否跳过重复的建议项。如果设置为
          <code>
           true
          </code>
          ，则自动补全结果中不会包含重复项。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          sort
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定对自动补全结果进行排序的方式。可以是
          <code>
           score
          </code>
          （基于分数排序）或
          <code>
           score_desc
          </code>
          （分数降序）。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          source
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定是否返回建议项的详细来源信息。如果设置为
          <code>
           true
          </code>
          ，则返回包含文档的详细信息。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          context_values
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定用于自动补全的上下文字段的值。这些值用于在提供建议时考虑额外的过滤条件。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          collate
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          指定是否对自动补全结果进行聚合。如果设置为
          <code>
           true
          </code>
          ，则对相同建议进行聚合。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h2>
     三、实际应用（RestHighLevelClient）
    </h2>
    <p>
     这部分我会结合DSL和代码块展示给大家，流程大致分为创建Request对象-&gt;编辑DSL-&gt;发送请求-&gt;解析响应结果，大家可以自行对照理解扩展。
    </p>
    <h3>
     1.首先在配置类注入Bean对象
    </h3>
    <pre><code class="language-java">    @Bean
    public RestHighLevelClient client(){
        return new RestHighLevelClient(RestClient.builder(
                HttpHost.create("http://ip")));//ip换自己的主机ip和端口
    }</code></pre>
    <h3>
     2.创建SearchRequest对象
    </h3>
    <pre><code class="language-java">        //准备Request
        SearchRequest request = new SearchRequest("hotel");</code></pre>
    <h3>
     3.条件过滤查询
    </h3>
    <ul>
     <li>
      查询
     </li>
    </ul>
    <p>
     <img alt="" height="908" src="https://i-blog.csdnimg.cn/direct/127036d4107f4d19acfce9fe40ce7abe.png" width="1309"/>
    </p>
    <ul>
     <li>
      解析
     </li>
    </ul>
    <p>
     <img alt="" height="677" src="https://i-blog.csdnimg.cn/direct/931b1cb6e6824d93920dd88a6289967a.png" width="1397"/>
    </p>
    <h3>
     4.Buket聚合
    </h3>
    <ul>
     <li>
      聚合
     </li>
    </ul>
    <p>
     <img alt="" height="466" src="https://i-blog.csdnimg.cn/direct/c63829a787ba47ffa61b345ed5e20daf.png" width="920"/>
    </p>
    <ul>
     <li>
      解析
     </li>
    </ul>
    <p>
     <img alt="" height="844" src="https://i-blog.csdnimg.cn/direct/5acf1e716b2c41479e590111f2fbce74.png" width="1312"/>
    </p>
    <h3>
     5.Function_score Query（广告置顶）
    </h3>
    <ul>
     <li>
      算分控制
     </li>
    </ul>
    <p>
     <img alt="" height="427" src="https://i-blog.csdnimg.cn/direct/674450f9873c49879c2c03aaa84c0c49.png" width="1083"/>
    </p>
    <ul>
     <li>
      结果解析
     </li>
    </ul>
    <p>
     <img alt="" height="885" src="https://i-blog.csdnimg.cn/direct/0c8b3b52a41c4d518889eacd137200b2.png" width="1486"/>
    </p>
    <p>
     经过前五步即可实现基本的条件过滤查询及广告置顶功能
    </p>
    <p>
     <img alt="" height="862" src="https://i-blog.csdnimg.cn/direct/5584e995e1eb4d75acbc6510a9208952.png" width="1402"/>
    </p>
    <h3>
     6.
     <strong>
      Geo-distance Query附近酒店
     </strong>
    </h3>
    <ul>
     <li>
      查询
     </li>
    </ul>
    <p>
     <img alt="" height="478" src="https://i-blog.csdnimg.cn/direct/3fcc42517d4841baa13cb0bf32c583c6.png" width="1337"/>
    </p>
    <p>
    </p>
    <ul>
     <li>
      解析
     </li>
    </ul>
    <p>
     <img alt="" height="893" src="https://i-blog.csdnimg.cn/direct/06af9878f77e43a3835465b87e41fa77.png" width="1131"/>
     至此附近酒店查询已完成
    </p>
    <p>
     <img alt="" height="909" src="https://i-blog.csdnimg.cn/direct/30a37741d8e641219c264b8d6f3d377f.png" width="1350"/>
    </p>
    <h3>
     7.Suggestion自动补全回显搜索框内容
    </h3>
    <p>
     此处根据首字母提示补全关键词，需要用到ES的pinyin分词插件，大家可以自行寻找教程安装
    </p>
    <ul>
     <li>
      DSL
     </li>
    </ul>
    <p>
     <img alt="" height="290" src="https://i-blog.csdnimg.cn/direct/c3ea35901c2446699af82d295d21eda4.png" width="1256"/>
    </p>
    <ul>
     <li>
      解析
     </li>
    </ul>
    <p>
     <img alt="" height="849" src="https://i-blog.csdnimg.cn/direct/ec7a4197ea054545aa7c714230495337.png" width="1364"/>
    </p>
    <p>
     至此搜索框自动补全功能也已完成
    </p>
    <p>
     <img alt="" height="366" src="https://i-blog.csdnimg.cn/direct/05378529cf824e69a89820b7d61e6fc4.png" width="791"/>
    </p>
    <p>
     可见ES不但在海量数据检索提效上有重要意义，其对于特殊场景的处理也十分灵活精确，那ES可以代替MySQL吗，答案是否定的，他们两者各有千秋，在事务处理方面MySQL是优于ES的，在实际开发中往往会将两者结合使用发挥各自的长处。
    </p>
    <p>
     那么本次分享到这里就结束了，感谢阅读。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373235313231372f:61727469636c652f64657461696c732f313436323638333831" class_="artid" style="display:none">
 </p>
</div>


