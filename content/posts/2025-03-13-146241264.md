---
layout: post
title: "Unity-工具类消息管理器-延迟分发"
date: 2025-03-13 20:56:13 +0800
description: "消息管理器除了简单的订阅(Subscribe)、取消订阅(Unsubscribe)操作以外，还需处理延迟分发(Dispatch)的情况。"
keywords: "Unity | 工具类：消息管理器-延迟分发"
categories: ['Unity']
tags: ['游戏', 'Unity']
artid: "146241264"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146241264
    alt: "Unity-工具类消息管理器-延迟分发"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146241264
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146241264
cover: https://bing.ee123.net/img/rand?artid=146241264
image: https://bing.ee123.net/img/rand?artid=146241264
img: https://bing.ee123.net/img/rand?artid=146241264
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity | 工具类：消息管理器-延迟分发
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
     消息管理器除了简单的订阅(Subscribe)、取消订阅(Unsubscribe)操作以外，还需处理延迟分发(Dispatch)的情况。
    </p>
    <p>
     （即时处理可参考：
     <a href="https://blog.csdn.net/weixin_39766005/article/details/137072480" title="Unity | 工具类-利用事件系统进行业务串通-CSDN博客">
      Unity | 工具类-利用事件系统进行业务串通-CSDN博客
     </a>
     ）
    </p>
    <p>
     假设玩家在游戏中获得新装备后，系统则会发送消息通知UI面板去显示第二个页签上的红点提示，但此时UI面板尚未创建，当玩家打开UI面板时消息早就发送过了。而延迟消息可以先把消息推送到缓存中，由需要拉取延迟消息的类（UI面板）自行调用拉取函数即可。这样的设计可以应对大部分游戏对于消息管理方面的需求，包括刷怪、关卡的消息提示等。
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E7%AE%A1%E7%90%86%E5%99%A8" name="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E7%AE%A1%E7%90%86%E5%99%A8">
     一、消息管理器
    </h2>
    <pre><code class="language-cs">
public class MessageManager
{
    static MessageManager mInstance;
    public static MessageManager Instance
    {
        get
        {
            return mInstance ?? (mInstance = new MessageManager());
        }
    }
    Dictionary&lt;string, Action&lt;object[]&gt;&gt; mMessageDict = new Dictionary&lt;string, Action&lt;object[]&gt;&gt;(32);

    // 将缓存字典设置为存储队列，防止多次分发时覆盖，key为消息名，value为参数队列
    Dictionary&lt;string, Queue&lt;object[]&gt;&gt; mDispatchCacheDict = new Dictionary&lt;string, Queue&lt;object[]&gt;&gt;(16);
    private MessageManager() { }
    //订阅消息
    public void Subscribe(string message, Action&lt;object[]&gt; action)
    {
        Action&lt;object[]&gt; value = null;
        //已有消息则追加绑定
        if (mMessageDict.TryGetValue(message, out value))
        {
            value += action;
            mMessageDict[message] = value;
        }
        else                                                       //没有消息则添加到字典里
        {
            mMessageDict.Add(message, action);
        }
    }
    //取消消息订阅
    public void Unsubscribe(string message)
    {
        mMessageDict.Remove(message);
    }
    //允许按委托实例取消订阅
    public void Unsubscribe(string message, Action&lt;object[]&gt; action)
    {
        if (mMessageDict.TryGetValue(message, out var existingAction))
        {
            existingAction -= action; // 移除特定委托
            if (existingAction == null)
            {
                mMessageDict.Remove(message); // 无订阅者则移除消息
            }
            else
            {
                mMessageDict[message] = existingAction;
            }
        }
    }


    public void Dispatch(string message, object[] args = null, bool addToCache = false)
    {
        if (addToCache)
        {
            // 如果不存在则创建新队列
            if (!mDispatchCacheDict.TryGetValue(message, out var queue))
            {
                queue = new Queue&lt;object[]&gt;();
                mDispatchCacheDict[message] = queue;
            }
            queue.Enqueue(args); // 参数入队
        }
        else
        {
            // 触发所有订阅者
            if (mMessageDict.TryGetValue(message, out var action))
            {
                action.Invoke(args);
            }
        }
    }

    public void ProcessDispatchCache(string message)
    {
        if (mDispatchCacheDict.TryGetValue(message, out var queue))
        {
            // 处理队列中的所有消息
            while (queue.Count &gt; 0)
            {
                var args = queue.Dequeue();
                Dispatch(message, args); // 分发时不再缓存
            }
            mDispatchCacheDict.Remove(message);
        }
    }

    /// &lt;summary&gt;
    /// 重置消息管理器，必须用Static方法修饰
    /// &lt;/summary&gt;
    public static void Reset()
    {
        mInstance = null; // 下次访问时会重新初始化
    }
}</code></pre>
    <h2 id="%E4%BA%8C%E3%80%81%E8%8E%B7%E5%BE%97%E6%96%B0%E8%A3%85%E5%A4%87" name="%E4%BA%8C%E3%80%81%E8%8E%B7%E5%BE%97%E6%96%B0%E8%A3%85%E5%A4%87">
     二、获得新装备
    </h2>
    <p>
     获得新食物时，UI面板未初始化。
    </p>
    <pre><code class="language-cs">    //处理获得新食物的消息
    void OnGetNewFood1()
    {
        MessageManager.Instance.Dispatch("GetNewFood", new object[] { 3 }, true);
    }
    void OnGetNewFood2()
    {
        MessageManager.Instance.Dispatch("GetNewFood", new object[] { 2 }, true);
    }</code></pre>
    <h2 id="%E4%B8%89%E3%80%81UI%E9%9D%A2%E6%9D%BF%E5%88%9B%E5%BB%BA" name="%E4%B8%89%E3%80%81UI%E9%9D%A2%E6%9D%BF%E5%88%9B%E5%BB%BA">
     三、UI面板创建
    </h2>
    <pre><code class="language-cs">
    void OnEnable()
    {
        MessageManager.Instance.Subscribe("GetNewFood", OnGetNewFood);

        //处理延迟消息
        MessageManager.Instance.ProcessDispatchCache("GetNewFood");

        //避免场景切换后残留旧数据，可重置单例实例。
        SceneManager.sceneLoaded += (scene, mode) =&gt; MessageManager.Reset();
    }

    /// &lt;summary&gt;
    /// 移除所有订阅
    /// &lt;/summary&gt;
    // void OnDisable()
    // {
    //     MessageManager.Instance.Unsubscribe("GetNewFood");
    // }


    /// &lt;summary&gt;
    /// 移除当前实例的订阅
    /// &lt;/summary&gt;
    void OnDisable()
    {
        // 仅移除当前实例的委托
        MessageManager.Instance.Unsubscribe("GetNewFood", OnGetNewFood);
    }

    private void OnGetNewFood(object[] obj)
    {
        if (obj != null &amp;&amp; obj.Length &gt; 0 &amp;&amp; obj[0] is int count)
        {
            Debug.Log($"获得 {count} 个新食物");
        }
        else
        {
            Debug.LogError("无效的食物数量参数！");
        }
    }</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33393736363030352f:61727469636c652f64657461696c732f313436323431323634" class_="artid" style="display:none">
 </p>
</div>


