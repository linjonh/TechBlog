---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f4368656e374368616e2f:61727469636c652f64657461696c732f313436313838333035"
layout: post
title: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—28-å‰ç«¯å›½é™…åŒ–å®ç°"
date: 2025-03-11 20:25:41 +0800
description: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ä¹‹æ—…ç¬¬äºŒåå…«ç«™"
keywords: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ28ï¼‰--å‰ç«¯å›½é™…åŒ–å®ç°"
categories: ['å‰ç«¯å·¥ç¨‹åŒ–ä¸æ¡†æ¶']
tags: ['çŠ¶æ€æ¨¡å¼', 'å‰ç«¯']
artid: "146188305"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146188305
    alt: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—28-å‰ç«¯å›½é™…åŒ–å®ç°"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146188305
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146188305
cover: https://bing.ee123.net/img/rand?artid=146188305
image: https://bing.ee123.net/img/rand?artid=146188305
img: https://bing.ee123.net/img/rand?artid=146188305
---

# å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ28ï¼‰--å‰ç«¯å›½é™…åŒ–å®ç°

## å‰ç«¯å›½é™…åŒ–å®ç° ğŸŒ

### å¼•è¨€

å‰ç«¯å›½é™…åŒ–ï¼ˆi18nï¼‰æ˜¯ç°ä»£Webåº”ç”¨ä¸­çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå®ƒèƒ½å¤Ÿè®©åº”ç”¨æ”¯æŒå¤šè¯­è¨€å’Œå¤šåœ°åŒºçš„ç”¨æˆ·ä½¿ç”¨ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å‰ç«¯å›½é™…åŒ–çš„å®ç°æ–¹æ¡ˆå’Œæœ€ä½³å®è·µï¼ŒåŒ…æ‹¬æ–‡æœ¬ç¿»è¯‘ã€æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–ã€è´§å¸å¤„ç†ç­‰æ–¹é¢ã€‚

### å›½é™…åŒ–æ¦‚è¿°

å‰ç«¯å›½é™…åŒ–ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹æ–¹é¢ï¼š

* **æ–‡æœ¬ç¿»è¯‘**
  ï¼šç•Œé¢æ–‡å­—çš„å¤šè¯­è¨€æ”¯æŒ
* **æ—¥æœŸæ—¶é—´**
  ï¼šä¸åŒåœ°åŒºçš„æ—¥æœŸæ—¶é—´æ ¼å¼
* **è´§å¸å¤„ç†**
  ï¼šä¸åŒåœ°åŒºçš„è´§å¸æ ¼å¼
* **æ•°å­—æ ¼å¼**
  ï¼šä¸åŒåœ°åŒºçš„æ•°å­—è¡¨ç¤ºæ–¹å¼
* **æ–‡å­—æ–¹å‘**
  ï¼šä»å·¦åˆ°å³ï¼ˆLTRï¼‰å’Œä»å³åˆ°å·¦ï¼ˆRTLï¼‰çš„å¸ƒå±€æ”¯æŒ

### å›½é™…åŒ–å·¥å…·å®ç°

#### å›½é™…åŒ–ç®¡ç†å™¨

```typescript
// å›½é™…åŒ–ç®¡ç†å™¨ç±»
class I18nManager {
    private static instance: I18nManager;
    private currentLocale: string;
    private messages: Map<string, Record<string, string>>;
    private numberFormatter: Intl.NumberFormat;
    private dateFormatter: Intl.DateTimeFormat;
    private currencyFormatter: Intl.NumberFormat;
    
    private constructor() {
        this.currentLocale = 'en-US';
        this.messages = new Map();
        
        // åˆå§‹åŒ–æ ¼å¼åŒ–å™¨
        this.numberFormatter = new Intl.NumberFormat(this.currentLocale);
        this.dateFormatter = new Intl.DateTimeFormat(this.currentLocale);
        this.currencyFormatter = new Intl.NumberFormat(this.currentLocale, {
            style: 'currency',
            currency: 'USD'
        });
        
        // åˆå§‹åŒ–äº‹ä»¶åˆ†å‘
        this.initializeEventDispatcher();
    }
    
    // è·å–å•ä¾‹å®ä¾‹
    static getInstance(): I18nManager {
        if (!I18nManager.instance) {
            I18nManager.instance = new I18nManager();
        }
        return I18nManager.instance;
    }
    
    // è®¾ç½®è¯­è¨€ç¯å¢ƒ
    setLocale(locale: string): void {
        this.currentLocale = locale;
        
        // æ›´æ–°æ ¼å¼åŒ–å™¨
        this.numberFormatter = new Intl.NumberFormat(locale);
        this.dateFormatter = new Intl.DateTimeFormat(locale);
        this.currencyFormatter = new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: this.getCurrencyCode(locale)
        });
        
        // è§¦å‘è¯­è¨€å˜æ›´äº‹ä»¶
        this.dispatchLocaleChange();
    }
    
    // è·å–å½“å‰è¯­è¨€ç¯å¢ƒ
    getLocale(): string {
        return this.currentLocale;
    }
    
    // åŠ è½½è¯­è¨€åŒ…
    loadMessages(locale: string, messages: Record<string, string>): void {
        this.messages.set(locale, messages);
    }
    
    // è·å–ç¿»è¯‘æ–‡æœ¬
    translate(key: string, params?: Record<string, any>): string {
        const messages = this.messages.get(this.currentLocale);
        if (!messages) {
            return key;
        }
        
        let text = messages[key] || key;
        
        // æ›¿æ¢å‚æ•°
        if (params) {
            Object.entries(params).forEach(([key, value]) => {
                text = text.replace(`{${key}}`, String(value));
            });
        }
        
        return text;
    }
    
    // æ ¼å¼åŒ–æ•°å­—
    formatNumber(value: number): string {
        return this.numberFormatter.format(value);
    }
    
    // æ ¼å¼åŒ–æ—¥æœŸ
    formatDate(date: Date, options?: Intl.DateTimeFormatOptions): string {
        if (options) {
            return new Intl.DateTimeFormat(this.currentLocale, options).format(date);
        }
        return this.dateFormatter.format(date);
    }
    
    // æ ¼å¼åŒ–è´§å¸
    formatCurrency(value: number): string {
        return this.currencyFormatter.format(value);
    }
    
    // è·å–æ–‡å­—æ–¹å‘
    getTextDirection(): 'ltr' | 'rtl' {
        return ['ar', 'he'].includes(this.currentLocale.split('-')[0])
            ? 'rtl'
            : 'ltr';
    }
    
    // åˆå§‹åŒ–äº‹ä»¶åˆ†å‘
    private initializeEventDispatcher(): void {
        document.addEventListener('DOMContentLoaded', () => {
            this.updateDocumentDirection();
        });
    }
    
    // æ›´æ–°æ–‡æ¡£æ–¹å‘
    private updateDocumentDirection(): void {
        document.documentElement.dir = this.getTextDirection();
        document.documentElement.lang = this.currentLocale;
    }
    
    // è§¦å‘è¯­è¨€å˜æ›´äº‹ä»¶
    private dispatchLocaleChange(): void {
        const event = new CustomEvent('localechange', {
            detail: { locale: this.currentLocale }
        });
        document.dispatchEvent(event);
        
        // æ›´æ–°æ–‡æ¡£æ–¹å‘
        this.updateDocumentDirection();
    }
    
    // è·å–è´§å¸ä»£ç 
    private getCurrencyCode(locale: string): string {
        const region = locale.split('-')[1] || 'US';
        const currencyMap: Record<string, string> = {
            'US': 'USD',
            'GB': 'GBP',
            'EU': 'EUR',
            'CN': 'CNY',
            'JP': 'JPY'
            // æ·»åŠ æ›´å¤šè´§å¸æ˜ å°„
        };
        return currencyMap[region] || 'USD';
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const i18n = I18nManager.getInstance();

// åŠ è½½è‹±æ–‡è¯­è¨€åŒ…
i18n.loadMessages('en-US', {
    'greeting': 'Hello, {name}!',
    'farewell': 'Goodbye!',
    'items_count': 'You have {count} items.'
});

// åŠ è½½ä¸­æ–‡è¯­è¨€åŒ…
i18n.loadMessages('zh-CN', {
    'greeting': 'ä½ å¥½ï¼Œ{name}ï¼',
    'farewell': 'å†è§ï¼',
    'items_count': 'ä½ æœ‰ {count} ä¸ªç‰©å“ã€‚'
});

// åˆ‡æ¢è¯­è¨€
i18n.setLocale('zh-CN');

// ä½¿ç”¨ç¿»è¯‘
console.log(i18n.translate('greeting', { name: 'John' })); // è¾“å‡ºï¼šä½ å¥½ï¼ŒJohnï¼
console.log(i18n.translate('items_count', { count: 5 })); // è¾“å‡ºï¼šä½ æœ‰ 5 ä¸ªç‰©å“ã€‚

// æ ¼å¼åŒ–æ•°å­—å’Œæ—¥æœŸ
console.log(i18n.formatNumber(1234567.89)); // è¾“å‡ºï¼š1,234,567.89
console.log(i18n.formatDate(new Date())); // è¾“å‡ºï¼š2024/2/20
console.log(i18n.formatCurrency(99.99)); // è¾“å‡ºï¼šÂ¥99.99

```

#### ç»„ä»¶å›½é™…åŒ–

```typescript
// å›½é™…åŒ–ç»„ä»¶è£…é¥°å™¨
function withI18n<T extends { new (...args: any[]): any }>(
    Component: T
) {
    return class extends Component {
        private i18n: I18nManager;
        private localeChangeHandler: () => void;
        
        constructor(...args: any[]) {
            super(...args);
            
            this.i18n = I18nManager.getInstance();
            this.localeChangeHandler = this.onLocaleChange.bind(this);
            
            // ç›‘å¬è¯­è¨€å˜æ›´äº‹ä»¶
            document.addEventListener('localechange', this.localeChangeHandler);
        }
        
        // ç»„ä»¶é”€æ¯æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬
        disconnectedCallback() {
            document.removeEventListener('localechange', this.localeChangeHandler);
            if (super.disconnectedCallback) {
                super.disconnectedCallback();
            }
        }
        
        // è¯­è¨€å˜æ›´å¤„ç†
        private onLocaleChange(): void {
            this.requestUpdate();
        }
        
        // ç¿»è¯‘è¾…åŠ©æ–¹æ³•
        protected t(key: string, params?: Record<string, any>): string {
            return this.i18n.translate(key, params);
        }
        
        // æ ¼å¼åŒ–æ•°å­—
        protected formatNumber(value: number): string {
            return this.i18n.formatNumber(value);
        }
        
        // æ ¼å¼åŒ–æ—¥æœŸ
        protected formatDate(date: Date): string {
            return this.i18n.formatDate(date);
        }
        
        // æ ¼å¼åŒ–è´§å¸
        protected formatCurrency(value: number): string {
            return this.i18n.formatCurrency(value);
        }
    };
}

// å›½é™…åŒ–æ–‡æœ¬ç»„ä»¶
@withI18n
class I18nText extends HTMLElement {
    private key: string;
    private params: Record<string, any>;
    
    constructor() {
        super();
        this.key = '';
        this.params = {};
    }
    
    // è§‚å¯Ÿçš„å±æ€§
    static get observedAttributes() {
        return ['key', 'params'];
    }
    
    // å±æ€§å˜åŒ–å¤„ç†
    attributeChangedCallback(
        name: string,
        oldValue: string,
        newValue: string
    ) {
        if (name === 'key') {
            this.key = newValue;
        } else if (name === 'params') {
            try {
                this.params = JSON.parse(newValue);
            } catch (e) {
                this.params = {};
            }
        }
        
        this.updateContent();
    }
    
    // æ›´æ–°å†…å®¹
    private updateContent(): void {
        this.textContent = this.t(this.key, this.params);
    }
}

// æ³¨å†Œç»„ä»¶
customElements.define('i18n-text', I18nText);

// å›½é™…åŒ–æ—¥æœŸç»„ä»¶
@withI18n
class I18nDate extends HTMLElement {
    private date: Date;
    private format: Intl.DateTimeFormatOptions;
    
    constructor() {
        super();
        this.date = new Date();
        this.format = {};
    }
    
    // è§‚å¯Ÿçš„å±æ€§
    static get observedAttributes() {
        return ['value', 'format'];
    }
    
    // å±æ€§å˜åŒ–å¤„ç†
    attributeChangedCallback(
        name: string,
        oldValue: string,
        newValue: string
    ) {
        if (name === 'value') {
            this.date = new Date(newValue);
        } else if (name === 'format') {
            try {
                this.format = JSON.parse(newValue);
            } catch (e) {
                this.format = {};
            }
        }
        
        this.updateContent();
    }
    
    // æ›´æ–°å†…å®¹
    private updateContent(): void {
        this.textContent = this.formatDate(this.date);
    }
}

// æ³¨å†Œç»„ä»¶
customElements.define('i18n-date', I18nDate);

// ä½¿ç”¨ç¤ºä¾‹
const template = `
    <div>
        <i18n-text key="greeting" params='{"name":"John"}'></i18n-text>
        <i18n-date value="2024-02-20"></i18n-date>
    </div>
`;

```

#### è·¯ç”±å›½é™…åŒ–

```typescript
// å›½é™…åŒ–è·¯ç”±ç®¡ç†å™¨
class I18nRouter {
    private static instance: I18nRouter;
    private i18n: I18nManager;
    private routes: Map<string, I18nRoute>;
    private currentRoute: I18nRoute | null;
    
    private constructor() {
        this.i18n = I18nManager.getInstance();
        this.routes = new Map();
        this.currentRoute = null;
        
        this.initializeRouter();
    }
    
    // è·å–å•ä¾‹å®ä¾‹
    static getInstance(): I18nRouter {
        if (!I18nRouter.instance) {
            I18nRouter.instance = new I18nRouter();
        }
        return I18nRouter.instance;
    }
    
    // æ³¨å†Œè·¯ç”±
    registerRoute(route: I18nRoute): void {
        this.routes.set(route.name, route);
    }
    
    // è·å–è·¯ç”±URL
    getRouteUrl(
        name: string,
        params?: Record<string, string>
    ): string {
        const route = this.routes.get(name);
        if (!route) {
            throw new Error(`Route "${name}" not found`);
        }
        
        const locale = this.i18n.getLocale();
        let path = route.paths[locale] || route.paths['en-US'];
        
        // æ›¿æ¢è·¯å¾„å‚æ•°
        if (params) {
            Object.entries(params).forEach(([key, value]) => {
                path = path.replace(`:${key}`, value);
            });
        }
        
        return `/${locale}${path}`;
    }
    
    // å¯¼èˆªåˆ°è·¯ç”±
    navigate(
        name: string,
        params?: Record<string, string>
    ): void {
        const url = this.getRouteUrl(name, params);
        window.history.pushState(null, '', url);
        this.handleRoute();
    }
    
    // åˆå§‹åŒ–è·¯ç”±å™¨
    private initializeRouter(): void {
        // ç›‘å¬popstateäº‹ä»¶
        window.addEventListener('popstate', () => {
            this.handleRoute();
        });
        
        // ç›‘å¬è¯­è¨€å˜æ›´
        document.addEventListener('localechange', () => {
            this.updateRoute();
        });
        
        // å¤„ç†åˆå§‹è·¯ç”±
        this.handleRoute();
    }
    
    // å¤„ç†è·¯ç”±
    private handleRoute(): void {
        const path = window.location.pathname;
        const [, locale, ...segments] = path.split('/');
        
        // è®¾ç½®è¯­è¨€
        if (locale && locale !== this.i18n.getLocale()) {
            this.i18n.setLocale(locale);
        }
        
        // æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±
        const matchedRoute = this.findMatchingRoute(segments.join('/'));
        if (matchedRoute) {
            this.currentRoute = matchedRoute;
            this.renderRoute(matchedRoute);
        }
    }
    
    // æ›´æ–°å½“å‰è·¯ç”±
    private updateRoute(): void {
        if (this.currentRoute) {
            const params = this.extractRouteParams();
            this.navigate(this.currentRoute.name, params);
        }
    }
    
    // æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±
    private findMatchingRoute(path: string): I18nRoute | null {
        const locale = this.i18n.getLocale();
        
        for (const route of this.routes.values()) {
            const routePath = route.paths[locale] || route.paths['en-US'];
            if (this.matchPath(path, routePath)) {
                return route;
            }
        }
        
        return null;
    }
    
    // åŒ¹é…è·¯å¾„
    private matchPath(path: string, pattern: string): boolean {
        const pathSegments = path.split('/');
        const patternSegments = pattern.split('/');
        
        if (pathSegments.length !== patternSegments.length) {
            return false;
        }
        
        return patternSegments.every((segment, index) => {
            if (segment.startsWith(':')) {
                return true;
            }
            return segment === pathSegments[index];
        });
    }
    
    // æå–è·¯ç”±å‚æ•°
    private extractRouteParams(): Record<string, string> {
        if (!this.currentRoute) {
            return {};
        }
        
        const locale = this.i18n.getLocale();
        const routePath = this.currentRoute.paths[locale] || this.currentRoute.paths['en-US'];
        const currentPath = window.location.pathname.split('/').slice(2).join('/');
        
        const params: Record<string, string> = {};
        const pathSegments = currentPath.split('/');
        const patternSegments = routePath.split('/');
        
        patternSegments.forEach((segment, index) => {
            if (segment.startsWith(':')) {
                const paramName = segment.slice(1);
                params[paramName] = pathSegments[index];
            }
        });
        
        return params;
    }
    
    // æ¸²æŸ“è·¯ç”±
    private renderRoute(route: I18nRoute): void {
        const params = this.extractRouteParams();
        route.component.render(params);
    }
}

// è·¯ç”±é…ç½®æ¥å£
interface I18nRoute {
    name: string;
    paths: Record<string, string>;
    component: {
        render: (params: Record<string, string>) => void;
    };
}

// ä½¿ç”¨ç¤ºä¾‹
const router = I18nRouter.getInstance();

// æ³¨å†Œè·¯ç”±
router.registerRoute({
    name: 'home',
    paths: {
        'en-US': '/home',
        'zh-CN': '/é¦–é¡µ'
    },
    component: {
        render: () => {
            document.getElementById('app')!.innerHTML = `
                <h1><i18n-text key="home_title"></i18n-text></h1>
            `;
        }
    }
});

router.registerRoute({
    name: 'product',
    paths: {
        'en-US': '/product/:id',
        'zh-CN': '/äº§å“/:id'
    },
    component: {
        render: (params) => {
            document.getElementById('app')!.innerHTML = `
                <h1>
                    <i18n-text key="product_title" params='{"id":"${params.id}"}'></i18n-text>
                </h1>
            `;
        }
    }
});

// å¯¼èˆªåˆ°è·¯ç”±
router.navigate('home');
router.navigate('product', { id: '123' });

```

### æœ€ä½³å®è·µä¸å»ºè®®

1. **æ–‡æœ¬ç®¡ç†**

   * ä½¿ç”¨é”®å€¼å¯¹ç®¡ç†æ–‡æœ¬
   * æ”¯æŒå‚æ•°æ›¿æ¢
   * å¤„ç†å¤æ•°å½¢å¼
   * ç»´æŠ¤ç¿»è¯‘æ–‡æ¡£
2. **æ ¼å¼å¤„ç†**

   * ä½¿ç”¨Intl API
   * å¤„ç†æ—¶åŒºé—®é¢˜
   * æ”¯æŒä¸åŒæ•°å­—ç³»ç»Ÿ
   * è€ƒè™‘è´§å¸è½¬æ¢
3. **å¸ƒå±€é€‚é…**

   * æ”¯æŒRTLå¸ƒå±€
   * å¤„ç†æ–‡æœ¬é•¿åº¦å˜åŒ–
   * é€‚é…ä¸åŒå­—ä½“
   * è€ƒè™‘æ–‡åŒ–å·®å¼‚
4. **æ€§èƒ½ä¼˜åŒ–**

   * æŒ‰éœ€åŠ è½½è¯­è¨€åŒ…
   * ç¼“å­˜ç¿»è¯‘ç»“æœ
   * ä¼˜åŒ–é‡æ¸²æŸ“
   * å‡å°‘æ ¼å¼åŒ–å¼€é”€

### æ€»ç»“

å‰ç«¯å›½é™…åŒ–éœ€è¦è€ƒè™‘ä»¥ä¸‹æ–¹é¢ï¼š

1. æ–‡æœ¬ç¿»è¯‘ç®¡ç†
2. æ—¥æœŸæ—¶é—´å¤„ç†
3. è´§å¸æ•°å­—æ ¼å¼åŒ–
4. å¸ƒå±€æ–¹å‘é€‚é…
5. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

é€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡å’Œä¼˜åŒ–æªæ–½ï¼Œå¯ä»¥æ„å»ºå‡ºä¼˜ç§€çš„å›½é™…åŒ–åº”ç”¨ã€‚

### å­¦ä¹ èµ„æº

1. Intl APIæ–‡æ¡£
2. i18næœ€ä½³å®è·µ
3. RTLå¸ƒå±€æŒ‡å—
4. åŒºåŸŸè®¾ç½®æ ‡å‡†
5. å›½é™…åŒ–æµ‹è¯•æ–¹æ³•

---

å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è—ï¼Œä¹ŸæœŸå¾…åœ¨è¯„è®ºåŒºçœ‹åˆ°ä½ çš„æƒ³æ³•å’Œå»ºè®®ï¼ğŸ‘‡

***ç»ˆèº«å­¦ä¹ ï¼Œå…±åŒæˆé•¿ã€‚***

å’±ä»¬ä¸‹ä¸€æœŸè§

ğŸ’»