---
layout: post
title: "Nginx中http_hosthostproxy_host的区别"
date: 2025-03-07 22:30:58 +0800
description: "变量是否显示端口值是否存在host浏览器请求的ip，不显示端口否\"Host:value\"显示值为a:b的时候，只显示ahttp_host浏览器请求的ip和端口号是“Host:value”，value存在就显示proxy_host被代理服务的ip和端口号默认80不显示其他端口显示\"Host:value\"显示配置反向代理时，接口请求报404问题应用描述：前端应用域名为A（ww.a.com）, 后端服务域名为B（www.b.com）;"
keywords: "Nginx中$http_host、$host、$proxy_host的区别"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['运维', 'Nginx', 'Http']
artid: "146106966"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146106966
    alt: "Nginx中http_hosthostproxy_host的区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146106966
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146106966
cover: https://bing.ee123.net/img/rand?artid=146106966
image: https://bing.ee123.net/img/rand?artid=146106966
img: https://bing.ee123.net/img/rand?artid=146106966
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Nginx中$http_host、$host、$proxy_host的区别
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      知识巩固！
     </strong>
    </p>
    <p>
     <strong>
      网上看到这篇文章，这里转载记录一下。
     </strong>
    </p>
    <h3>
     <a id="_8">
     </a>
     简介
    </h3>
    <p>
     变量
    </p>
    <p>
     是否显示端口
    </p>
    <p>
     值是否存在
    </p>
    <p>
     host
    </p>
    <p>
     浏览器请求的ip，不显示端口
    </p>
    <p>
     否
    </p>
    <p>
     "Host:value"显示
    </p>
    <p>
     值为a:b的时候，只显示a
    </p>
    <p>
     http_host
    </p>
    <p>
     浏览器请求的ip和端口号
    </p>
    <p>
     是
    </p>
    <p>
     “Host:value”，value存在就显示
    </p>
    <p>
     proxy_host
    </p>
    <p>
     被代理服务的ip和端口号
    </p>
    <p>
     默认80不显示
    </p>
    <p>
     其他端口显示
    </p>
    <p>
     "Host:value"显示
    </p>
    <p>
     配置反向代理时，接口请求报404问题
    </p>
    <p>
     应用描述：前端应用域名为A（ww.a.com）, 后端服务域名为B（www.b.com）; 为了解决跨域问题，配置nginx反向代理如下：
    </p>
    <p>
     …
     <br/>
     proxy_set_header Host
     <span class="katex--inline">
      KaTeX parse error: Undefined control sequence: \* at position 54: …write "^/api/(.\̲*̲)
     </span>
     " /$1 break;
     <br/>
     proxy_pass http://www.b.com;
     <br/>
     }
     <br/>
     问题：这样配置完成后，接口报404问题。
    </p>
    <p>
     解决：
     <br/>
     方案一：将proxy_set_header注释掉
     <br/>
     方案二：修改反向代理配置，设置请求头Host，如下所示：
    </p>
    <p>
     location ^~ /api/ {
     <!-- -->
     <br/>
     rewrite “^/api/(.*)$” /$1 break;
     <br/>
     proxy_pass http://www.b.com;
     <br/>
     <strong>
      proxy_set_header Host $proxy_host; //方式一：设置请求头host为www.b.com的ip和端口号
      <br/>
      proxy_set_header Host www.b.com; //方式二：设置请求host为www.b.com
     </strong>
     <br/>
     }
    </p>
    <h3>
     <a id="nginxproxy_set_header_Host_host_70">
     </a>
     nginx中proxy_set_header Host $host的作用
    </h3>
    <p>
     nginx为了实现反向代理的需求而增加了一个ngx_http_proxy_module模块。其中proxy_set_header指令就是该模块需要读取的配置文件。在这里，所有设置的值的含义和http请求体中的含义完全相同，除了Host外还有X-Forward-For。
    </p>
    <p>
     Host的含义是表明请求的主机名，因为nginx作为反向代理使用，
     <strong>
      而如果后端真实服务器设置有类似防盗链或者根据http请求头中的host字段来进行路由或判断功能的话，如果反向代理层的nginx不重写请求头中的host字段，将会导致请求失败
     </strong>
     【默认反向代理服务器会向后端真实服务器发送请求，并且请求头中的host字段应为proxy_pass指令设置的服务器】
    </p>
    <p>
     同理，X_Forward_For字段表示该条http请求是由谁发起的？如果反向代理服务器不重写该请求头的话，那么后端真实服务器在处理时会认为所有的请求都来在反向代理服务器，如果后端有防攻击策略的话，那么机器就被封掉了。因此，在配置用作反向代理的nginx中一般会增加两条配置，修改http的请求头。
    </p>
    <p>
     1
    </p>
    <p>
     2
    </p>
    <p>
     <code>
      proxy_set_header Host $http_host;
     </code>
    </p>
    <p>
     <code>
      proxy_set_header X-Forward-For $remote_addr;
     </code>
    </p>
    <p>
     这里的
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         t 
        
       
         t 
        
       
         p 
        
       
         _ 
        
       
         h 
        
       
         o 
        
       
         s 
        
       
         t 
        
       
         和 
        
       
      
        http\_host和
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1.0044em; vertical-align: -0.31em;">
         </span>
         <span class="mord mathnormal">
          h
         </span>
         <span class="mord mathnormal">
          ttp
         </span>
         <span class="mord" style="margin-right: 0.0278em;">
          _
         </span>
         <span class="mord mathnormal">
          h
         </span>
         <span class="mord mathnormal">
          os
         </span>
         <span class="mord mathnormal">
          t
         </span>
         <span class="mord cjk_fallback">
          和
         </span>
        </span>
       </span>
      </span>
     </span>
     remote_addr都是nginx的导出变量，可以在配置文件中直接使用。如果Host请求头部没有出现在请求头中，则
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         t 
        
       
         t 
        
       
         p 
        
       
         _ 
        
       
         h 
        
       
         o 
        
       
         s 
        
       
         t 
        
       
         值为空，但是 
        
       
      
        http\_host值为空，但是
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1.0044em; vertical-align: -0.31em;">
         </span>
         <span class="mord mathnormal">
          h
         </span>
         <span class="mord mathnormal">
          ttp
         </span>
         <span class="mord" style="margin-right: 0.0278em;">
          _
         </span>
         <span class="mord mathnormal">
          h
         </span>
         <span class="mord mathnormal">
          os
         </span>
         <span class="mord mathnormal">
          t
         </span>
         <span class="mord cjk_fallback">
          值为空，但是
         </span>
        </span>
       </span>
      </span>
     </span>
     host值为主域名。因此，一般而言，会用
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         o 
        
       
         s 
        
       
         t 
        
       
         代替 
        
       
      
        host代替
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.6944em;">
         </span>
         <span class="mord mathnormal">
          h
         </span>
         <span class="mord mathnormal">
          os
         </span>
         <span class="mord mathnormal">
          t
         </span>
         <span class="mord cjk_fallback">
          代替
         </span>
        </span>
       </span>
      </span>
     </span>
     http_host变量，从而避免http请求中丢失Host头部的情况下Host不被重写的失误。
    </p>
    <p>
     X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。 它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。标准格式如下：X-Forwarded-For: client1, proxy1, proxy2。
    </p>
    <p>
     这一HTTP头一般格式如下：X-Forwarded-For: client1, proxy1, proxy2。其中的值通过一个“逗号+空格”把多个IP地址区分开, 最左边(client1)是最原始客户端的IP地址, 代理服务器每成功收到一个请求，就把
     <strong>
      请求来源IP地址
     </strong>
     添加到右边。
    </p>
    <p>
     在上面这个例子中，这个请求成功通过了三台代理服务器：proxy1, proxy2 及 proxy3。请求由client1发出，到达了proxy3(proxy3可能是请求的终点)。请求刚从client1中发出时，XFF是空的，请求被发往proxy1；通过proxy1的时候，client1被添加到XFF中，之后请求被发往proxy2;通过proxy2的时候，proxy1被添加到XFF中，之后请求被发往proxy3；通过proxy3时，proxy2被添加到XFF中，之后请求的的去向不明，如果proxy3不是请求终点，请求会被继续转发。
    </p>
    <p>
     鉴于伪造这一字段非常容易，应该谨慎使用X-Forwarded-For字段。正常情况下XFF中最后一个IP地址是最后一个代理服务器的IP地址, 这通常是一个比较可靠的信息来源。
    </p>
    <h3>
     <a id="proxy_set_headerHostproxy_hosthostlocal_host_97">
     </a>
     proxy_set_header设置Host为
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        p 
        
       
         r 
        
       
         o 
        
       
         x 
        
       
         y 
        
       
         _ 
        
       
         h 
        
       
         o 
        
       
         s 
        
       
         t 
        
       
         ， 
        
       
      
        proxy\_host，
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1.0044em; vertical-align: -0.31em;">
         </span>
         <span class="mord mathnormal">
          p
         </span>
         <span class="mord mathnormal">
          ro
         </span>
         <span class="mord mathnormal">
          x
         </span>
         <span class="mord mathnormal" style="margin-right: 0.0359em;">
          y
         </span>
         <span class="mord" style="margin-right: 0.0278em;">
          _
         </span>
         <span class="mord mathnormal">
          h
         </span>
         <span class="mord mathnormal">
          os
         </span>
         <span class="mord mathnormal">
          t
         </span>
         <span class="mord cjk_fallback">
          ，
         </span>
        </span>
       </span>
      </span>
     </span>
     host与$local_host的区别
    </h3>
    <p>
     先来看下proxy_set_header的语法：
     <code>
      **proxy_set_header**?`field``value`;
     </code>
    </p>
    <p>
     默认值：
    </p>
    <p>
     1
    </p>
    <p>
     2
    </p>
    <p>
     <code>
      proxy_set_header Host $proxy_host;
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Connection close;
     </code>
    </p>
    <p>
     上下文：
     <code>
      http
     </code>
     ,
     <code>
      server
     </code>
     ,
     <code>
      location
     </code>
    </p>
    <p>
     作用：允许重新定义或者添加发往后端服务器的请求头。
     <code>
      value
     </code>
     可以包含文本、变量或者它们的组合。 当且仅当当前配置级别中没有定义
     <code>
      proxy_set_header
     </code>
     指令时，会从上面的级别继承配置。 默认情况下，只有两个请求头会被重新定义：
    </p>
    <p>
     1
    </p>
    <p>
     2
    </p>
    <p>
     <code>
      proxy_set_header Host?????? $proxy_host;
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Connection close;
     </code>
    </p>
    <p>
     nginx对于upstream默认使用的是基于IP的转发，因此对于以下配置：
    </p>
    <p>
     1
    </p>
    <p>
     2
    </p>
    <p>
     3
    </p>
    <p>
     4
    </p>
    <p>
     5
    </p>
    <p>
     6
    </p>
    <p>
     7
    </p>
    <p>
     8
    </p>
    <p>
     9
    </p>
    <p>
     10
    </p>
    <p>
     11
    </p>
    <p>
     12
    </p>
    <p>
     13
    </p>
    <p>
     14
    </p>
    <p>
     15
    </p>
    <p>
     16
    </p>
    <p>
     17
    </p>
    <p>
     18
    </p>
    <p>
     19
    </p>
    <p>
     20
    </p>
    <p>
     21
    </p>
    <p>
     22
    </p>
    <p>
     23
    </p>
    <p>
     24
    </p>
    <p>
     25
    </p>
    <p>
     26
    </p>
    <p>
     <code>
      upstream backend {?
     </code>
    </p>
    <p>
     <code>
      ????????``server 127.0.0.1:8080;?
     </code>
    </p>
    <p>
     <code>
      ????``}?
     </code>
    </p>
    <p>
     <code>
      ????``upstream crmtest {?
     </code>
    </p>
    <p>
     <code>
      ????????``server crmtest.aty.sohuno.com;?
     </code>
    </p>
    <p>
     <code>
      ????``}?
     </code>
    </p>
    <p>
     <code>
      ????``server {?
     </code>
    </p>
    <p>
     <code>
      ????????????``listen?????? 80;?
     </code>
    </p>
    <p>
     <code>
      ????????????``server_name? chuan.aty.sohuno.com;?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_set_header Host $http_host;?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_set_header x-forwarded-for? $remote_addr;?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_buffer_size???????? 64k;?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_buffers???????????? 32 64k;?
     </code>
    </p>
    <p>
     <code>
      ????????????``charset utf-8;?
     </code>
    </p>
    <p>
     <code>
      ????????????``access_log? logs/host.access.log? main;?
     </code>
    </p>
    <p>
     <code>
      ????????????``location = /50x.html {?
     </code>
    </p>
    <p>
     <code>
      ????????????????``root?? html;?
     </code>
    </p>
    <p>
     <code>
      ????????????``}?
     </code>
    </p>
    <p>
     <code>
      ????????``location / {?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_pass backend ;?
     </code>
    </p>
    <p>
     <code>
      ????????``}?
     </code>
    </p>
    <p>
     <code>
      ????????``location = /customer/straightcustomer/download {?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_pass http://crmtest;?
     </code>
    </p>
    <p>
     <code>
      ????????????``proxy_set_header Host $proxy_host;?
     </code>
    </p>
    <p>
     <code>
      ????????``}?
     </code>
    </p>
    <p>
     <code>
      ????``}
     </code>
    </p>
    <p>
     当匹配到 /customer/straightcustomer/download时，使用crmtest处理，到upstream就匹配到crmtest.aty.sohuno.com，这里直接转换成IP进行转发了。假如crmtest.aty.sohuno.com是在另一台nginx下配置的，ip为10.22.10.116，则$proxy_host则对应为10.22.10.116。此时相当于设置了Host为10.22.10.116。
    </p>
    <p>
     1
    </p>
    <p>
     2
    </p>
    <p>
     3
    </p>
    <p>
     4
    </p>
    <p>
     5
    </p>
    <p>
     6
    </p>
    <p>
     7
    </p>
    <p>
     8
    </p>
    <p>
     9
    </p>
    <p>
     10
    </p>
    <p>
     11
    </p>
    <p>
     <code>
      // 如果想让Host是crmtest.aty.sohuno.com，则进行如下设置：
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Host crmtest.aty.sohuno.com;
     </code>
    </p>
    <p>
     <code>
      // 如果不想改变请求头“Host”的值，可以这样来设置：
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Host $http_host;
     </code>
    </p>
    <p>
     <code>
      // 但是，如果客户端请求头中没有携带这个头部，那么传递到后端服务器的请求也不含这个头部。
     </code>
    </p>
    <p>
     <code>
      // 这种情况下，更好的方式是使用$host变量——它的值在请求包含“Host”请求头时为“Host”字段的值，在请求未携带“Host”请求头时为虚拟主机的主域名：
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Host?????? $host;
     </code>
    </p>
    <p>
     <code>
      // 此外，服务器名可以和后端服务器的端口一起传送：
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Host $host:$proxy_port;
     </code>
    </p>
    <p>
     <code>
      // 如果某个请求头的值为空，那么这个请求头将不会传送给后端服务器：
     </code>
    </p>
    <p>
     <code>
      proxy_set_header Accept-Encoding "";
     </code>
    </p>
    <h3>
     <a id="Nginx_276">
     </a>
     通过Nginx配置演示：
    </h3>
    <p>
     [root@ans3 conf]# cat nginx.conf
    </p>
    <pre><code>#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
error_log  logs/error.log  info;
#pid        logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  logs/access.log  main;
    sendfile        on;
    tcp_nopush     on;
    keepalive_timeout  65;

    server {
       listen       80;
       server_name  a.test.com;

       location / {
            proxy_pass http://10.0.0.50:8080;
            proxy_set_header X-Proxy-Host $proxy_host;
            proxy_set_header Host $http_host;
            index index.html index.htm;
       }
    }
}
</code></pre>
    <p>
     另一台服务器配置
    </p>
    <p>
     [root@master conf]# cat nginx.conf
    </p>
    <pre><code>#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       8080;
        server_name  www.test.com aa.test.com;

        location / {
              return 200 'http_host=[$http_host] host=[$host] proxy_host=[$http_x_proxy_host]
';
        }
    }
}
</code></pre>
    <h4>
     <a id="_Host_353">
     </a>
     不携带请求头 Host
    </h4>
    <p>
     [root@ans3 conf]# curl -H ‘Host:’ --http1.0 http://a.test.com
    </p>
    <p>
     http_host=[]
     <br/>
     host=[www.test.com]
     <br/>
     proxy_host=[10.0.0.50:8080]
    </p>
    <p>
     变量
    </p>
    <p>
     值
    </p>
    <p>
     说明
    </p>
    <p>
     http_host
    </p>
    <p>
     请求无 Host, 则 http_host 为空, 继而无 Host 传到 proxy
    </p>
    <p>
     host
    </p>
    <p>
     www.test.com
    </p>
    <p>
     proxy 无 Host 传入, 则使用其 server_name 的第一项
    </p>
    <p>
     proxy_host
    </p>
    <p>
     10.0.0.50:8080
    </p>
    <p>
     取自于 proxy_pass 的参数
    </p>
    <h4>
     <a id="_Host_383">
     </a>
     携带请求头 Host
    </h4>
    <p>
     [root@ans3 conf]# curl -H ‘Host🔤123’ --http1.0 http://a.test.com
    </p>
    <p>
     http_host=[abc:123]
     <br/>
     host=[abc]
     <br/>
     proxy_host=[10.0.0.50:8080]
    </p>
    <p>
     变量
    </p>
    <p>
     值
    </p>
    <p>
     说明
    </p>
    <p>
     http_host
    </p>
    <p>
     abc:123
    </p>
    <p>
     给啥拿啥
    </p>
    <p>
     host
    </p>
    <p>
     abc
    </p>
    <p>
     第一个
     <code>
      :
     </code>
     前的内容(小写)
    </p>
    <p>
     proxy_host
    </p>
    <p>
     10.0.0.50:8080
    </p>
    <p>
     带端口显示
    </p>
    <p>
     修改真实服务器的端口为默认端口
    </p>
    <p>
     http {
     <!-- -->
     <br/>
     include mime.types;
     <br/>
     default_type application/octet-stream;
    </p>
    <pre><code>log\_format  main  '$remote\_addr - $remote\_user \[$time\_local\] "$request" '
                  '$status $body\_bytes\_sent "$http\_referer" '
                  '"$http\_user\_agent" "$http\_x\_forwarded\_for"';

access\_log  logs/access.log  main;
sendfile        on;
tcp\_nopush     on;
keepalive\_timeout  65;

server {
    listen  80;
    server\_name  a.test.com;
    
    location / {
        proxy\_pass http://10.0.0.50:80;
        proxy\_set\_header X-Proxy-Host $proxy\_host;
        proxy\_set\_header Host $http\_host;
        index index.html index.htm;
   }
</code></pre>
    <p>
     }
     <br/>
     }
    </p>
    <p>
     http {
     <!-- -->
     <br/>
     include mime.types;
     <br/>
     default_type application/octet-stream;
    </p>
    <pre><code>sendfile        on;
keepalive\_timeout  65;

server {
    listen       80;
    server\_name www.test.com aa.test.com;


    location / {
         return 200 'http\_host=\[$http\_host\] host=\[$host\] proxy\_host= \[$http\_x\_proxy\_host\]
</code></pre>
    <p>
     ';
     <br/>
     }
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     访问时proxy_host会省略80端口
    </p>
    <p>
     [root@ans3 conf]# curl -H
     <strong>
      ‘Host🔤123’
     </strong>
     --http1.0 http://a.test.com
    </p>
    <p>
     http_host=[abc:123]
     <br/>
     host=[abc]
     <br/>
     proxy_host=[10.0.0.50]
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343832333433342f:61727469636c652f64657461696c732f313436313036393636" class_="artid" style="display:none">
 </p>
</div>


