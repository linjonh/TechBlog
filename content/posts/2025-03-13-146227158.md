---
layout: post
title: "java-中判断对象是否可以被回收和-GCROOT"
date: 2025-03-13 11:58:55 +0800
description: "每个对象都维护一个引用计数器，当有一个地方引用该对象时，计数器加一；当引用失效时，计数器减一。当计数器的值为零时，说明该对象不再被引用，系统就会认为它是垃圾，可以被回收。实现简单，效率较高，能快速判断对象是否可以被回收。循环引用问题：如果两个对象互相引用（形成循环依赖），它们的引用计数器不会为零，即使它们都无法被访问，引用计数法也无法回收它们。JVM 采用可达性分析算法来判断对象是否可以被回收。"
keywords: "java垃圾回收的根节点一般是什么"
categories: ['未分类']
tags: ['开发语言', 'Jvm', 'Java']
artid: "146227158"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146227158
    alt: "java-中判断对象是否可以被回收和-GCROOT"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146227158
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146227158
cover: https://bing.ee123.net/img/rand?artid=146227158
image: https://bing.ee123.net/img/rand?artid=146227158
img: https://bing.ee123.net/img/rand?artid=146227158
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java 中判断对象是否可以被回收和 GCROOT
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Reference_Counting_0">
     </a>
     <strong>
      引用计数法（Reference Counting）
     </strong>
    </h2>
    <p>
     每个对象都维护一个引用计数器，当有一个地方引用该对象时，计数器加一；当引用失效时，计数器减一。
     <br/>
     当计数器的值为零时，说明该对象不再被引用，系统就会认为它是垃圾，可以被回收。
     <br/>
     实现简单，效率较高，能快速判断对象是否可以被回收。
     <br/>
     循环引用问题：如果两个对象互相引用（形成循环依赖），它们的引用计数器不会为零，即使它们都无法被访问，引用计数法也无法回收它们。
    </p>
    <h2>
     <a id="Reachability_Analysis_5">
     </a>
     <strong>
      可达性分析法（Reachability Analysis）
     </strong>
    </h2>
    <p>
     JVM 采用可达性分析算法来判断对象是否可以被回收。这个方法从一组称为 GC Roots 的根对象开始，沿着引用链进行遍历，能够到达的对象被认为是“存活”的，无法到达的对象被认为是不可达的，可以被回收。
     <br/>
     没有循环引用问题：因为是通过可达性分析来判断对象是否可以回收，循环引用不会影响对象的回收。
     <br/>
     更加准确，现代垃圾回收器大多基于这种方法。
    </p>
    <h2>
     <a id="GCROOT_9">
     </a>
     GCROOT
    </h2>
    <p>
     在 Java 中，GC Root（垃圾回收根对象）是垃圾回收器进行内存管理的重要起点，任何从 GC Root 可达的对象都不会被垃圾回收。以下是 Java 中哪些对象可以充当 GC Root。
    </p>
    <h3>
     <a id="_11">
     </a>
     <strong>
      虚拟机栈中的引用对象
     </strong>
    </h3>
    <p>
     方法执行时，局部变量表中的所有引用类型变量（局部变量、方法参数等）都可以作为 GC Root。
     <br/>
     当方法调用时，局部变量表中的对象引用始终可达，JVM 不会回收这些对象，直到方法结束后局部变量表被销毁。
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exampleMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 局部变量 obj 是 GC Root</span>
    <span class="token comment">// do something...</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_20">
     </a>
     <strong>
      方法区中的静态变量
     </strong>
    </h3>
    <p>
     类的静态属性（static 修饰的变量）会随着类的加载进入方法区，并且静态变量会一直存在于内存中，直到类被卸载。因此，所有的静态变量也是 GC Root。
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> staticObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// staticObject 是 GC Root</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_27">
     </a>
     <strong>
      方法区中的常量
     </strong>
    </h3>
    <p>
     常量（如 final 修饰的常量）在类加载时就已经被初始化，它们存在于方法区中，可以作为 GC Root。
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> constantObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// constantObject 是 GC Root</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_JNI__34">
     </a>
     <strong>
      本地方法栈中的 JNI 引用
     </strong>
    </h3>
    <p>
     JNI（Java Native Interface） 是 Java 调用本地（非 Java）代码的机制。在 JNI 中使用的引用也是 GC Root。JVM 通过本地方法栈来管理 JNI 的本地引用。
     <br/>
     当 Java 调用 C/C++ 代码时，通过 JNI 持有的对象引用。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34313839333530352f:61727469636c652f64657461696c732f313436323237313538" class_="artid" style="display:none">
 </p>
</div>


