---
arturl_encode: "68747470:733a2f2f626c6f672e6373646e2e6e65742f4c5f7365726569:6e2f61727469636c652f64657461696c732f36363839393434"
layout: post
title: "java-socket及java心跳"
date: 2024-03-15 09:07:26 +0800
description: "java socket 心跳              在JAVA socket 异步操作中经常会用"
keywords: "java中socket心跳检测"
categories: ['Java']
tags: ['服务器', 'Socket', 'Java', 'Byte']
artid: "6689944"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=6689944
    alt: "java-socket及java心跳"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=6689944
featuredImagePreview: https://bing.ee123.net/img/rand?artid=6689944
---

# java socket及java心跳

**java socket 心跳**
  
在JAVA socket 异步操作中经常会用到心跳机制去检查服务器端是否在线，其实这个很容易实现，就是开启一个新的线程，在run方法里去给服务器端发心跳包，但是这一步是可以省掉的，可以直接在接收服务器端消息的线程里完成这个机制，在run方法里写上while ((ii = in.read(revBuffer)) != -1)这么句话就行了，如果服务器端关闭了，这里就会抛SocketException了，不信可以试试，心跳机制的实现就这么简单 。
  
**java 异步socket**
java socket心跳的一个简单实现，那么它的出现就暗示了你采用了异步socket，而所谓异步socket就是将收消息和发消息作为两个单独的线程去跑，当建立连接的时候收的线程就开始监听了，发消息很简单了，只要得到了socket连接对象，想怎么发就怎么发；那么收到的消息这么处理呢？这时候就得在开启一个线程用来读了，不过既然是异步socket那么你的需求不是应答模式，而是被动模式，所谓被动，就是你没发指令服务器也给你发消息，这个时候你就得考虑队列了，因为你要保存数据的完整性和不被丢失，在就是读数据的时候，大家应该记得有这么个步骤:new byte[100];这个byte的长度就是能读到一条数据的长度，大家别以为这样就够了，因为服务器端很有可能不只发100个长度，有可能是1000，或者更多，都有可能的，那么应该这么设计这个消息发送和接受的模式呢？那就是封装数据，在消息的头和尾加上协商后的开始和结束，当客户端看到了开始和结束的标语时就明白了 这是一条消息，否则继续读，直到读取到了开始和结束的标识语，那么就将数据存到队列里，然后用刚才讲到的读的线程一直去取队列的消息，现在取出来肯定是一条一条的了，但是这个办法在服务器端一秒之类回很多消息的话就会造成很严重的后果---数据丢失，那么怎么避免呢？第一：读取不要延时，一直读取；第二：在收到数据的时候不加以逻辑处理，而是直接放入队列，第三：将所有的逻辑出来都放在从队列中取数据，从而保证数据不被丢失。然后通过团队协商的协议去解析包就可以了，代码太简单，就说到这了