---
layout: post
title: "freertos关键函数理解-uxListRemove"
date: 2025-07-22T22:26:31+0800
description: "/|-------&gt;volatile UBaseType_t uxNumberOfItems = 1  0x20000088  链表中元素的个数。&lt;-------------|    0x200004ac  链表节点的值。"
keywords: "freertos关键函数理解 uxListRemove"
categories: ['未分类']
tags: ['算法']
artid: "149549370"
arturl: "https://blog.csdn.net/dp__mcu/article/details/149549370"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=149549370
    alt: "freertos关键函数理解-uxListRemove"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=149549370
featuredImagePreview: https://bing.ee123.net/img/rand?artid=149549370
cover: https://bing.ee123.net/img/rand?artid=149549370
image: https://bing.ee123.net/img/rand?artid=149549370
img: https://bing.ee123.net/img/rand?artid=149549370
---



# freertos关键函数理解 uxListRemove

//删除pxItemToRemove节点  
UBaseType_t uxListRemove(ListItem_t *pxItemToRemove)  
{                
    //The list item knows which list it is in.  Obtain the list from the list item.  
    //找到节点所在的链表

    //my_printf( "uxListRemove pxItemToRemove = %#p\n", pxItemToRemove );

    List_t *pxList = pxItemToRemove->pxContainer;

    List_t *pxList_;          //指向目标优先级的就绪任务列表 (通过TCB的优先级索引)  
    //pxList_ = &pxReadyTasksLists[4];

    //my_printf( "pxList = %#p\n", pxList );  
    //my_printf( "pxList->uxNumberOfItems = %d\n", pxList->uxNumberOfItems );  
    //my_printf( "&pxList->uxNumberOfItems = %#p\n", &pxList->uxNumberOfItems );  
    //my_printf( "pxList->pxIndex = %#p\n", pxList->pxIndex );  
    //my_printf( "&pxList->pxIndex = %#p\n", &pxList->pxIndex );  
    //my_printf( "pxList->pxIndex->pvOwner = %#p\n", pxList->pxIndex->pvOwner );  
    //my_printf( "pxList->pxIndex->pxContainer = %#p\n", pxList->pxIndex->pxContainer );

    //|------->volatile UBaseType_t uxNumberOfItems = 1  0x20000088  链表中元素的个数            
    //| |<-----ListItem_t *pxIndex;                         0x2000008c  总是指向xListEnd节点,在链表尾部插入的时候,方便找到位置  
    //| |  |-->TickType_t xItemValue = portMAX_DELAY     0x20000090  [MiniListItem_t xListEnd]     
    //| |  |   struct xLIST_ITEM *pxNext;     ----->|    0x20000094  后继节点  
    //| |  |   struct xLIST_ITEM *pxPrevious; ----->|    0x20000098  前驱节点      
    //| |  |                                        |                    
    //| |--|-->TickType_t xItemValue; <-------------|    0x200004ac  链表节点的值          
    //|    |<--struct xLIST_ITEM *pxNext;                            后继节点  
    //|    |<--struct xLIST_ITEM *pxPrevious;                        前驱节点  
    //|        void *pvOwner;                            0x200004a8  保存私有数据         [ &TCB ]  
    //|<------ struct xLIST *pxContainer;                0x20000088  节点所在的链表 [ &pxReadyTasksLists[x] ]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;  
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;

    //Make sure the index is left pointing to a valid item.   
    if( pxList->pxIndex == pxItemToRemove ){  
        pxList->pxIndex = pxItemToRemove->pxPrevious;  
    }  
    pxItemToRemove->pxContainer = NULL;  
    pxList->uxNumberOfItems--;

    //         volatile UBaseType_t uxNumberOfItems = 0  0x20000088  链表中元素的个数            
    //  |<-----ListItem_t *pxIndex;                         0x2000008c  总是指向xListEnd节点,在链表尾部插入的时候,方便找到位置  
    //  |->|-->TickType_t xItemValue = portMAX_DELAY     0x20000090  [MiniListItem_t xListEnd]     
    //     |<--struct xLIST_ITEM *pxNext;                0x20000094  后继节点  
    //     |<--struct xLIST_ITEM *pxPrevious;            0x20000098  前驱节点      
                                                                       
      
    //返回剩余节点数  
    return pxList->uxNumberOfItems;  
}



