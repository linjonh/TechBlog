---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430335f38393130373837332f:61727469636c652f64657461696c732f313436313035343830"
layout: post
title: "Oracle-数据库基础入门七触发器与事务的深度探究"
date: 2025-03-07 21:25:08 +08:00
description: "在 Oracle 数据库的生态系统中，触发器与事务是构建可靠、高效数据处理流程的关键组件。触发器能够自动响应特定数据库事件执行预设操作，而事务则确保一组数据库操作的原子性、一致性、隔离性和持久性。对于 Java 全栈开发者而言，深入理解并熟练运用触发器与事务，不仅能提升数据库操作的精细化程度，还能为构建稳健的企业级应用提供坚实支撑。让我们一同深入探索 Oracle 数据库中的触发器与事务。"
keywords: "Oracle 数据库基础入门（七）：触发器与事务的深度探究"
categories: ['Oracle']
tags: ['数据库', 'Sql', 'Oracle', 'Java']
artid: "146105480"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146105480
    alt: "Oracle-数据库基础入门七触发器与事务的深度探究"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146105480
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146105480
cover: https://bing.ee123.net/img/rand?artid=146105480
image: https://bing.ee123.net/img/rand?artid=146105480
img: https://bing.ee123.net/img/rand?artid=146105480
---

# Oracle 数据库基础入门（七）：触发器与事务的深度探究

在 Oracle 数据库的生态系统中，触发器与事务是构建可靠、高效数据处理流程的关键组件。触发器能够自动响应特定数据库事件执行预设操作，而事务则确保一组数据库操作的原子性、一致性、隔离性和持久性。对于 Java 全栈开发者而言，深入理解并熟练运用触发器与事务，不仅能提升数据库操作的精细化程度，还能为构建稳健的企业级应用提供坚实支撑。让我们一同深入探索 Oracle 数据库中的触发器与事务。

### **目录**

---

### 一、触发器

#### （一）触发器的概念与分类

1. **触发器的本质**
   ：触发器是一种特殊的存储过程，它会在特定事件发生时自动触发执行。这些特定事件包括数据的新增、修改和删除操作，并且可以在操作发生之前（Before）或之后（After）触发。根据触发事件的不同，触发器主要分为 DML 触发器（包括新增触发器、修改触发器、删除触发器）和时间触发器（基于 Before 或 After 时间点）。
2. **常见使用场景**
   ：
   * **维护历史数据**
     ：在许多企业应用中，需要记录数据的变更历史，以便进行数据追溯和审计。例如，在一个电商订单管理系统中，当订单状态发生修改时，通过触发器将修改前的订单信息保存到历史记录表中，方便后续查询和分析订单的变化过程。
   * **统计分析**
     ：触发器可以用于汇总数据和更新其他相关表的数据。比如在一个销售统计系统中，当有新的销售记录插入时，通过触发器自动更新销售总额、产品销量等统计信息到相关的汇总表中，确保统计数据的实时性和准确性。
   * **模拟数据库的 ID 自增长**
     ：在 MySQL 中，自带 ID 自增长约束，但在 Oracle 11g 及以下版本中，需要借助其他方式来实现类似功能，触发器就是一种可行的方案。

#### （二）自定义触发器示例

1. **维护历史数据的触发器**
   ：
   * **创建历史表序列**
     ：首先，为历史表创建一个序列，用于生成唯一的 ID。例如：

```
Create sequence cls_his_seq start with 1 increment by 1;

```

* **创建触发器**
  ：接下来，给
  `class_info`
  表创建一个删除之前的触发器。当
  `class_info`
  表中的记录被删除时，该触发器会将删除前的数据插入到
  `class_info_his`
  历史表中。

```
Create trigger trg_before_del_cls before delete on class_info for each row
Begin
    -- :old 表示修改/删除之前的数据
    -- :new 表示新增/修改之后的数据
    insert into class_info_his(id,class_name) values (cls_his_seq.nextval,:old.class_name);
end;

```

在 Java 全栈开发的学校管理系统中，后端开发人员可以利用这个触发器来维护班级信息的变更历史。当通过 Java 代码调用数据库接口删除班级信息时，触发器自动将被删除的班级信息保存到历史表中。前端可以提供一个历史记录查询功能，让管理员能够查看班级信息的变更情况，方便进行数据管理和回溯。

2.
**实现 ID 自增长的触发器**
：在 Oracle 11g 以上版本虽然有 ID 自增长约束，但 11g 版本没有。我们可以通过触发器来模拟 ID 自增长功能。

* **创建表和序列**
  ：先创建
  `role_info`
  表和一个序列
  `role_seq`
  。

```
create sequence role_seq start with 1 increment by 1;
create table role_info (
    id number primary key,
    role_name nvarchar2(10)    
);

```

* **插入数据**
  ：当向
  `role_info`
  表插入数据时，通过触发器使用序列生成唯一的
  `id`
  。虽然这里没有给出具体的触发器创建语句，但基本思路是在插入操作前，获取序列的下一个值并赋给
  `id`
  字段。在实际的 Java 全栈开发的权限管理系统中，这种通过触发器实现的 ID 自增长功能可以确保角色信息表中的
  `id`
  字段唯一且有序增长。后端开发人员在插入角色信息时，无需手动处理
  `id`
  的生成，数据库会自动完成这一过程，减少了代码的复杂性和出错的可能性。前端在展示角色列表时，也能依赖有序的
  `id`
  进行数据的排序和管理。

#### 

#### （三）企业使用建议

在企业项目中，虽然触发器具有强大的功能，但需要谨慎使用。触发器的维护成本较高，因为它的逻辑与数据库表紧密耦合。一旦表结构或业务逻辑发生变化，可能需要同时修改触发器。此外，过多的触发器可能会影响数据库的性能，因为每次触发事件发生时，数据库都需要额外执行触发器中的代码。在 Java 全栈开发团队中，当决定使用触发器时，后端开发人员需要与数据库管理员密切沟通，评估触发器对系统性能和可维护性的影响。在设计触发器时，要确保其逻辑清晰、简洁，避免复杂的业务逻辑在触发器中实现，尽量将复杂逻辑放在 Java 代码层进行处理，以降低数据库的负担。

#### 

### 二、数据库事务

#### （一）事务的概念与重要性

1. **事务的定义**
   ：事务是一段具有明确开始和结束标记的有序执行过程。它就像是一个不可分割的工作单元，其中包含的一系列数据库操作要么全部成功执行，要么全部失败回滚。例如，在一个银行转账系统中，张三给李四转 5000 元的操作可以看作一个事务。这个事务包含三个步骤：首先查询张三的余额是否充足；然后从张三的账户中扣除 5000 元；最后给李四的账户添加 5000 元。整个过程必须保证原子性，即要么三个步骤都成功完成，实现转账；要么在任何一个步骤出现问题时，整个事务回滚，确保张三和李四的账户余额不会出现错误的变更。
2. **事务在业务中的作用**
   ：事务在企业级应用中至关重要，它确保了数据的完整性和一致性。在涉及多个数据库操作的业务流程中，如果没有事务机制，可能会出现部分操作成功，部分操作失败的情况，导致数据处于不一致的状态。例如，在一个电商购物流程中，涉及库存减少、订单生成、支付记录添加等多个数据库操作。如果在库存减少后，由于网络问题导致订单生成失败，而没有事务回滚机制，就会出现库存已扣但订单未生成的情况，严重影响业务的正常运转。

#### 

#### （二）事务的操作

1. **提交（Commit）**
   ：在 Oracle 数据库中，使用
   `commit`
   命令来提交事务。当执行
   `commit`
   时，它会告诉数据库确认之前对数据库所做的一系列操作，将这些操作的结果永久保存到数据库中。例如：

```
#关闭Oracle的自动提交功能
set autocommit off;
#对数据库造成影响
insert into class_info(id,class_name) values ('3','Java3班');
insert into class_info(id,class_name) values ('4','Java4班');
insert into class_info(id,class_name) values ('5','Java5班');
#提交
commit;

```

在 Java 全栈开发的项目中，后端开发人员在使用 JDBC 或相关框架（如 MyBatis）操作数据库时，当完成一系列需要作为一个事务处理的数据库操作后，会调用相应的提交方法（在 JDBC 中是
`Connection.commit()`
方法）来提交事务。这确保了前端发起的业务请求所涉及的数据库操作能够正确持久化到数据库中。

2.
**回滚（Rollback）**
：
`rollback`
命令用于回滚事务。当执行
`rollback`
时，数据库会撤销之前在该事务中对数据库所做的所有操作，将数据库状态恢复到事务开始之前的状态。例如：

```
#关闭Oracle的自动提交功能
set autocommit off;
#对数据库造成影响
insert into class_info(id,class_name) values ('6','Java6班');
insert into class_info(id,class_name) values ('7','Java7班');
#回滚
rollback;

```

在实际开发中，如果在事务执行过程中捕获到异常（如数据库连接异常、数据违反约束等），后端开发人员会在 Java 代码中调用回滚方法（如 JDBC 中的
`Connection.rollback()`
方法），确保事务中的所有操作都被撤销，避免数据不一致问题。

3.
**自动提交设置**
：Oracle 数据库默认开启自动提交功能，即每一条 SQL 语句执行后都会立即提交到数据库。通过
`set autocommit off`
命令可以关闭自动提交，将多条 SQL 语句组合成一个事务进行处理。在完成事务操作后，再通过
`commit`
或
`rollback`
来决定事务的最终结果。最后，可以使用
`set autocommit on`
命令重新开启自动提交功能。

#### 

#### （三）事务的特性（ACID）

1. **原子性（Atomicity）**
   ：事务是一个不可分割的整体，其中的所有操作要么全部成功，要么全部失败。就像一个原子一样，不能再被细分。例如，在一个涉及多个表数据更新的业务场景中，如同时更新用户信息表和用户订单表，如果其中一个表的更新失败，根据原子性，整个事务应该回滚，确保两个表的数据状态保持一致。在 Java 全栈开发中，开发人员在设计数据库操作逻辑时，要确保将相关的数据库操作合理地组合成一个事务，利用事务的原子性保证数据的完整性。
2. **一致性（Consistency）**
   ：事务在执行过程中，必须保证数据从一个一致性状态转换到另一个一致性状态。这意味着事务执行前后，数据库的完整性约束（如主键约束、外键约束、唯一约束等）都要得到满足。例如，在一个涉及订单状态更新和库存变更的事务中，订单状态更新为 “已发货” 时，库存数量必须相应减少，以保证数据的一致性。在 Java 全栈开发中，后端开发人员在编写数据库操作代码时，要充分考虑业务逻辑对数据一致性的影响，确保事务执行过程中不会破坏数据库的完整性约束。
3. **隔离性（Isolation）**
   ：事务与事务之间是相互独立的，互不干扰。一个事务的执行不会影响其他事务的执行结果。例如，在一个多用户并发访问数据库的系统中，用户 A 执行的事务不会因为用户 B 同时执行的事务而出现数据错误或不一致。Oracle 数据库提供了不同的事务隔离级别（如读未提交、读已提交、可重复读、串行化等）来满足不同业务场景对隔离性的要求。在 Java 全栈开发中，开发人员可以根据业务需求选择合适的事务隔离级别。例如，在一些对数据一致性要求极高的金融业务场景中，可能会选择串行化隔离级别，以确保事务之间完全隔离，但这可能会降低系统的并发性能。而在一些对并发性能要求较高，对数据一致性要求相对较低的场景中，可以选择读已提交等较低的隔离级别。
4. **持久性（Durability）**
   ：事务一旦提交（Commit），其结果就会被永久保存到数据库中。即使数据库系统出现故障（如断电、硬件故障等），在系统恢复后，已提交事务的结果依然存在。这保证了数据的可靠性和稳定性。在 Java 全栈开发中，开发人员可以依赖事务的持久性，确保用户的操作结果能够可靠地存储在数据库中，为业务的持续运行提供保障。

#### 

#### 

### 三、企业工作小技巧

1. **触发器相关技巧**
   ：
   * **定期审查触发器**
     ：在企业项目中，随着业务的发展和数据库结构的调整，触发器的逻辑可能需要相应修改。定期审查触发器，确保其与当前业务逻辑和数据库结构保持一致。例如，每季度或每半年对数据库中的触发器进行全面检查，查看是否有因业务变更而导致触发器逻辑不再适用的情况。
   * **记录触发器执行日志**
     ：为了便于排查问题和进行性能优化，在触发器中添加日志记录功能。记录触发器的触发时间、触发事件（新增、修改、删除）、涉及的数据等信息。在 Java 全栈开发中，可以通过在数据库中创建一个日志表，触发器在执行时向该日志表插入记录。后端开发人员可以定期分析这些日志，了解触发器的执行情况，发现潜在的性能问题或错误。
2. **事务相关技巧**
   ：
   * **合理设置事务边界**
     ：在编写 Java 代码时，要根据业务逻辑合理确定事务的边界。避免将过多或过少的数据库操作包含在一个事务中。例如，在一个复杂的电商订单处理流程中，将订单生成、库存更新、支付处理等紧密相关的操作放在一个事务中，但不要将与订单处理无关的用户信息查询等操作也包含进来，以提高事务的执行效率和并发性能。
   * **处理事务并发问题**
     ：在多用户并发访问数据库的环境中，要注意事务并发带来的问题，如脏读、不可重复读、幻读等。根据业务需求选择合适的事务隔离级别，并通过加锁等机制来避免并发问题。例如，在一个库存管理系统中，为了防止多个用户同时修改库存导致数据不一致，可以在更新库存的事务中使用悲观锁，确保同一时间只有一个事务能够修改库存数据。

### 四、致谢

至此，本系列关于 Oracle 数据库基础入门的博客已更新完结。在撰写这些博客的过程中，我深感 Oracle 数据库的博大精深。希望这些内容能够帮助到正在学习 Oracle 数据库的同行们，无论是在理论知识的理解上，还是在实际项目的应用中。同时，也感谢 CSDN 这个平台，让我能够与大家分享学习心得和经验。在未来的技术探索中，我们将继续前行，不断提升自己的技术能力，为构建更强大的软件系统贡献力量。