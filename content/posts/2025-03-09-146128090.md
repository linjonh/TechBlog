---
layout: post
title: "8.2linux竞争与并发驱动LED灯原子操作实验_csdn"
date: 2025-03-09 10:06:06 +0800
description: "这两者作用在后续./dev/beep 1/0中创建/dev/beep。方便执行代码程序，传入到设备执行，关联设备号1.添加pinctrl信息。2.检查当前设备树中要使用的IO有没有被其他设备使用，如果有的话要处理。3.添加设备节点，在设备节点中创建一个属性，吃属性描述所使用的gpio。4.编写驱动，获取对应的gpio编号，并申请IO，成功后即可使用此IO。申请失败绝大部分情况是被其他外设给占用了！！！这种情况在根节点或者设备树检查一下pinctrl复用情况。加油！！！"
keywords: "8.2linux竞争与并发驱动LED灯(原子操作实验)_csdn"
categories: ['未分类']
tags: ['运维', '服务器', '原子操作', 'Ubuntu', 'Linux']
artid: "146128090"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146128090
    alt: "8.2linux竞争与并发驱动LED灯原子操作实验_csdn"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146128090
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146128090
cover: https://bing.ee123.net/img/rand?artid=146128090
image: https://bing.ee123.net/img/rand?artid=146128090
img: https://bing.ee123.net/img/rand?artid=146128090
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     8.2linux竞争与并发驱动LED灯(原子操作实验)_csdn
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     本例程我们在第二十五章的
     <mark>
      基于pinctrl与gpio子系统驱动LED灯实验
     </mark>
     的基础上完成。在本节使用中我们使用原子操作来实现对 LED 这个设备的互斥访问，也就是一次只允许一个应用程序可以使用 LED 灯。
     <br/>
     原子操作属于临界区，临界区必须保证一次只有一个线程访问。
    </p>
    <h3>
     <a id="1_2">
     </a>
     1.修改设备树文件
    </h3>
    <p>
     这一步骤在前面已经有过，所以跟着前面文章的同学应该很熟悉！
     <br/>
     在 stm32mp157d-atk.dts 文件的根节点“/”下创建 LED 灯节点，节点名为“gpioled”，节点内容如下：
     <br/>
     <img alt="Pasted image 20250301160937.png" src="https://i-blog.csdnimg.cn/img_convert/deb3f96424ed67b9eaa9b7f354b97d63.png">
      <br/>
      发现节点已经有了！
      <br/>
      <img alt="c0c940864af044e806e98e9ae9e921b.png" src="https://i-blog.csdnimg.cn/img_convert/81a8c13337c6b4480477fbdd91375acc.png"/>
     </img>
    </p>
    <h3>
     <a id="2LED__8">
     </a>
     2.LED 灯驱动程序编写
    </h3>
    <p>
     <mark>
      之前的博客也是跟大家按照肌肉记忆来编写程序！一步一步按照思路来编写！
     </mark>
     <br/>
     <mark>
      总代码会放在最后。
     </mark>
     <br/>
     <mark>
      为了让大家更能明白，可以先对着总代码，进行对我的写代码流程更加详细得当！
     </mark>
     <br/>
     放心，我也是一步一步打的代码，不是复制粘贴！！！
    </p>
    <h4>
     <a id="21_13">
     </a>
     2.1头文件
    </h4>
    <pre><code>#include &lt;linux/types.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/ide.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/gpio.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/of_address.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;asm/mach/map.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;asm/io.h&gt;
</code></pre>
    <h4>
     <a id="22MODULE_32">
     </a>
     2.2驱动入口函数和出口函数及MODULE函数
    </h4>
    <p>
     <img alt="Pasted image 20250308093131.png" src="https://i-blog.csdnimg.cn/img_convert/be666ce48a1d775874352d2a324c2d2d.png">
      <br/>
      这里的MODULE_LICENCE要改为
      <mark>
       MODULE_LICENSE
      </mark>
      。
     </img>
    </p>
    <h4>
     <a id="23_35">
     </a>
     2.3创建设备结构体
    </h4>
    <p>
     在跟之前一样，为了后续的注册设备字符，要在开发板内核里面显示的话，要申请设备号，便包括主设备号和次设备号；为了显得更专业一点，就要使用结构体来统一有关设备的相关父子类结构体信息。后面也可以添加更多的子类信息！
     <br/>
     <img alt="Pasted image 20250308093824.png" src="https://i-blog.csdnimg.cn/img_convert/5fdde6d03e119e1f7451daa75e0e03af.png">
      <br/>
      <mark>
       这里看总代码就知道我放在哪个位置了！
      </mark>
      <br/>
      <code>
       dev_t
      </code>
      是一个用于表示设备编号的数据类型，它在
      <code>
       &lt;sys/types.h&gt;
      </code>
      头文件中被定义。
      <br/>
      <mark>
       <code>
        gpioled
       </code>
      </mark>
      ：这是一个变量名，它的类型是
      <code>
       struct gpioled_dev
      </code>
      。也就是说，
      <code>
       gpioled
      </code>
      是一个
      <code>
       gpioled_dev
      </code>
      结构体类型的变量，通过这个变量可以存储和操作该结构体所定义的各种数据。
      <br/>
      比如gpioled.devid,gpioled.major,gpioled,minor。等等。
      <br/>
      后续有很多子类会在这里!
      <br/>
      例如：
     </img>
    </p>
    <pre><code>struct gpioled_dev { 
          dev_t devid; // 设备号
          struct cdev cdev; // 字符设备对象 
          struct class *class; // 设备类（sysfs接口）
          struct device *device; // 设备节点（/dev目录下） 
          int major; // 主设备号 
          int minor; // 次设备号 
          struct device_node *nd; // 设备树节点指针 
          int led_gpio; // GPIO编号（从设备树解析） };
</code></pre>
    <h4>
     <a id="24_55">
     </a>
     2.4注册字符设备
    </h4>
    <p>
     <mark>
      这个很早就说了，在驱动入口就开始注册字符了，打开驱动就是注册！
     </mark>
     <br/>
     <img alt="Pasted image 20250308095917.png" src="https://i-blog.csdnimg.cn/img_convert/4409635fedcdc074b9fad9cd53f6fc4b.png">
      <br/>
      <img alt="Pasted image 20250308095943.png" src="https://i-blog.csdnimg.cn/img_convert/1d61ceb41ea014fd9105dc744d0a369e.png">
       <br/>
       33行是先让主设备号为0，防止以前的实验占用及未注销的设备号继续利用。
       <br/>
       34-41行分别以给定设备号和未给定设备号的情况进行编程。其中gpioled.major,gpioled.minor便是利用了结构体内的变量子类，
       <code>
        MKDEV
       </code>
       是 Linux 内核提供的一个宏，用于根据主设备号和次设备号生成一个
       <code>
        dev_t
       </code>
       类型的设备编号。其定义通常位于
       <code>
        &lt;linux/kdev_t.h&gt;
       </code>
       头文件中，
       <code>
        register_chrdev_region
       </code>
       函数的原型定义在
       <code>
        &lt;linux/fs.h&gt;
       </code>
       头文件中，若是给了设备号就是用这个函数，从gpio.devid所赋值的设备号告诉内核进行相应设备号的注册。第二个位置就是设备号个数，第三个位置就是设备号名称。
       <br/>
       <code>
        alloc_chrdev_region
       </code>
       不需要手动指定主设备号，内核会自动分配一个未被使用的主设备号给驱动程序。&amp;gpioled.devid是指针类型，原型是
       <code>
        dev_t *dev
       </code>
       ,要通过&amp;取地址来存储设备号，第二个位置是起始的此设备号。
       <br/>
       <mark>
        既然有创建字符设备，那就要有删除字符设备。
       </mark>
       <br/>
       <img alt="Pasted image 20250308100707.png" src="https://i-blog.csdnimg.cn/img_convert/a7bdaefc1c5d7076ad61de274d7c65ce.png"/>
      </img>
     </img>
    </p>
    <h5>
     <a id="241_64">
     </a>
     2.4.1补充设备结构体
    </h5>
    <p>
     完成字符设备注册后，就是在设备结构体中添加字符设备对象。
     <br/>
     <img alt="Pasted image 20250308100159.png" src="https://i-blog.csdnimg.cn/img_convert/f315dfe00a0ea4141bb7bfa11279eec1.png"/>
    </p>
    <h4>
     <a id="25cdev_67">
     </a>
     2.5初始化cdev
    </h4>
    <p>
     很显然cdev也是变量gpioled的子类gpioled.cdev。同时在内核里面cdev里面包括很多子类信息。
     <br/>
     这里是内核里面的定义。不用管，只要配置cdev的子类即可。
     <br/>
     <img alt="Pasted image 20250302154007.png" src="https://i-blog.csdnimg.cn/img_convert/1f9d206382bda6235e72d9059a7e2822.png"/>
     <br/>
     对cdev进行初始化，这个是字符设备对象。
     <br/>
     <img alt="Pasted image 20250308101846.png" src="https://i-blog.csdnimg.cn/img_convert/fad2390f9a803390c2f28b20be0b2095.png"/>
     <br/>
     <mark>
      <code>
       gpioled.cdev.owner = THIS_MODULE;
      </code>
      的作用
     </mark>
     - 内核利用这个关联来管理模块的引用计数。当有用户空间程序对该字符设备进行操作（如打开、读写）时，内核会增加当前模块的引用计数，以确保在设备被使用期间模块不会被卸载。当所有使用该设备的操作结束后，内核会减少引用计数，当引用计数降为 0 时，模块可以被安全卸载。
     <br/>
     <mark>
      <code>
       cdev_init
      </code>
     </mark>
     函数的核心功能是对一个
     <code>
      struct cdev
     </code>
     结构体实例进行初始化，并且把一组文件操作函数（由
     <code>
      struct file_operations
     </code>
     结构体定义）和该字符设备关联起来。这样一来，当用户空间的程序通过文件操作接口（像
     <code>
      open
     </code>
     、
     <code>
      read
     </code>
     、
     <code>
      write
     </code>
     等）对该字符设备进行操作时，内核就能调用相应的函数来处理这些请求。
    </p>
    <h5>
     <a id="251file_operations_75">
     </a>
     2.5.1配置file_operations
    </h5>
    <p>
     同理，上面的&amp;led_fops需要配置。
     <br/>
     <img alt="Pasted image 20250302161659.png" src="https://i-blog.csdnimg.cn/img_convert/32a42f47555a249d316884b74c16b79a.png"/>
     <br/>
     <mark>
      图片中还有些未进行修改
     </mark>
     ，
     <mark>
      不用管，后面对字符添加操作集子类函数时改，先初始化cdev。
     </mark>
    </p>
    <h4>
     <a id="26cdev_79">
     </a>
     2.6添加cdev
    </h4>
    <p>
     <img alt="Pasted image 20250308101330.png" src="https://i-blog.csdnimg.cn/img_convert/28e5f49a6d1aab2008d4d088c8caba44.png"/>
     <br/>
     <mark>
      <code>
       cdev_add
      </code>
     </mark>
     函数的主要作用是将一个已经初始化好的字符设备（
     <code>
      struct cdev
     </code>
     结构体实例）添加到内核的字符设备管理系统中，使该字符设备正式在系统中可用。一旦调用
     <code>
      cdev_add
     </code>
     成功，用户空间的程序就可以通过设备文件（通常位于
     <mark>
      <code>
       /dev
      </code>
     </mark>
     目录下）来访问这个字符设备。
     <br/>
     即后续的./ledApp 可以执行到/dev
    </p>
    <h5>
     <a id="261_83">
     </a>
     2.6.1注销字符设备对象
    </h5>
    <p>
     目前已经注册和注销了字符设备，同时也注册了字符设备对象，所以要进行字符设备对象的注销。
     <br/>
     依然按照
     <mark>
      逻辑顺序
     </mark>
     进行注销。
     <br/>
     <img alt="Pasted image 20250308101529.png" src="https://i-blog.csdnimg.cn/img_convert/e5c9c623dcdaef99c4b922f68e59c3e8.png"/>
    </p>
    <h4>
     <a id="27_87">
     </a>
     2.7创建设备类和设备节点
    </h4>
    <h5>
     <a id="271_88">
     </a>
     2.7.1补充类与节点的定义
    </h5>
    <p>
     <img alt="Pasted image 20250302163153.png" src="https://i-blog.csdnimg.cn/img_convert/284f8603e8a202335b07da8d27c8da4f.png"/>
     <br/>
     <mark>
      这两者作用在后续./dev/beep 1/0中创建/dev/beep。方便执行代码程序，传入到设备执行，关联设备号
     </mark>
    </p>
    <h5>
     <a id="272_91">
     </a>
     2.7.2创建类
    </h5>
    <p>
     <img alt="Pasted image 20250308102835.png" src="https://i-blog.csdnimg.cn/img_convert/290a7d9d426beff0cbcbdda2255ca700.png"/>
     <br/>
     其中定义
     <br/>
     <code>
      #define class_create(owner, name)
     </code>
     <br/>
     owner和结构体内的owner都是module模块的，一般来说是THIS_MODULE；name就是设备名字。
    </p>
    <h5>
     <a id="273_96">
     </a>
     2.7.3创建设备节点
    </h5>
    <p>
     以便访问设备设备树根节点的信息，与下文的获取设备节点相互呼应。
     <br/>
     <img alt="Pasted image 20250308102947.png" src="https://i-blog.csdnimg.cn/img_convert/af9515ebfb88209e20d32e29d0f8b5e3.png"/>
     <br/>
     代码如下：
    </p>
    <pre><code>struct device *device_create(struct class *cls, struct device *parent,

                 dev_t devt, void *drvdata,const char *fmt, ...);
</code></pre>
    <p>
     <mark>
      <code>
       struct device *parent
      </code>
     </mark>
     ，指向父设备的指针。如果该设备没有父设备，可以传入
     <code>
      NULL
     </code>
     。
     <br/>
     <mark>
      dev_t
     </mark>
     ：即本文的gpioled.devid。
     <br/>
     <mark>
      <code>
       void *drvdata
      </code>
     </mark>
     ，是一个指向设备驱动私有数据的指针。可以传入自定义的数据结构指针，用于在设备驱动中存储和管理设备相关的信息，这里同样给NULL。
     <br/>
     <mark>
      const char *fmt-
     </mark>
     <code>
      fmt
     </code>
     是一个格式化字符串，
     <code>
      ...
     </code>
     表示可变参数列表。类似于
     <code>
      printf
     </code>
     函数的用法，用于指定设备节点的名称。作用是指定要创建的设备节点在
     <code>
      /dev
     </code>
     目录下的名称，可以使用格式化字符串动态生成名称。
    </p>
    <h5>
     <a id="274_109">
     </a>
     2.7.4补充错误信息
    </h5>
    <p>
     <img alt="Pasted image 20250308103621.png" src="https://i-blog.csdnimg.cn/img_convert/c2065e13f9a9b1b1df5f3da81b27ef29.png"/>
     <br/>
     <mark>
      <code>
       IS_ERR
      </code>
     </mark>
     宏通过比较指针的值和
     <code>
      (unsigned long)-MAX_ERRNO
     </code>
     的大小来判断该指针是否为错误指针。如果指针的值大于等于
     <code>
      (unsigned long)-MAX_ERRNO
     </code>
     ，则认为它是一个==错误指针，返回
     <code>
      true
     </code>
     ；==否则返回
     <code>
      false
     </code>
     。
     <br/>
     <mark>
      PTR_ERR
     </mark>
     ：当
     <code>
      IS_ERR(gpioled.cls)
     </code>
     返回
     <code>
      true
     </code>
     时，代码会执行
     <code>
      return PTR_ERR(gpioled.cls);
     </code>
     ，这会将
     <code>
      gpioled.cls
     </code>
     转换为对应的错误码并返回给调用者。调用者可以根据这个错误码进行相应的错误处理，例如打印错误信息、释放已经分配的资源等。
     <br/>
     同样：
     <br/>
     <img alt="Pasted image 20250308103632.png" src="https://i-blog.csdnimg.cn/img_convert/3e6e2b555e20b8377384dd9b70e6e574.png"/>
    </p>
    <h5>
     <a id="275_115">
     </a>
     2.7.5注销类和设备节点
    </h5>
    <p>
     <img alt="Pasted image 20250308103408.png" src="https://i-blog.csdnimg.cn/img_convert/3e8757f2657fce0f4ffd88a5ff145bb1.png"/>
    </p>
    <h5>
     <a id="276_117">
     </a>
     2.7.6配置操作集函数
    </h5>
    <p>
     <img alt="Pasted image 20250308103817.png" src="https://i-blog.csdnimg.cn/img_convert/fa8d101792c1f86b56d5c6c80e44b03f.png"/>
    </p>
    <pre><code>复制上一节的操作函数集
static int dtsled_open(struct inode *inode, struct file *filp)
{
   filp-&gt;private_data = &amp;dtsled;
   return 0;
}

static int dtsled_release(struct inode *inode, struct file *filp)
{
   struct dtsled_dev *dev = (struct dtsled_dev*)filp-&gt;private_data;
   return 0;
}
static ssize_t dtsled_write(struct file *filp, const char __user *buf,
			 size_t count, loff_t *ppos)
{
   struct dtsled_dev *dev = (struct dtsled_dev*)filp-&gt;private_data;
   int retvalue;
   unsigned char databuf[1]; 
   retvalue = copy_from_user(databuf,buf,count);
   if (retvalue &lt; 0)
   {
      printk("kernel write failed!\r\n");
      return -EFAULT;
   }

   /*判断开灯还是关灯*/
   led_switch(databuf[0]);
     return 0;
}

</code></pre>
    <p>
     <img alt="Pasted image 20250308103909.png" src="https://i-blog.csdnimg.cn/img_convert/ebf4acd32364eeeb4e8841afb5ab0e5d.png"/>
    </p>
    <h4>
     <a id="28_152">
     </a>
     2.8获取设备节点(设备树属性)
    </h4>
    <h5>
     <a id="281_153">
     </a>
     2.8.1配置设备树结构体
    </h5>
    <p>
     <img alt="Pasted image 20250308104435.png" src="https://i-blog.csdnimg.cn/img_convert/2529aa64915c7774537089e951212107.png"/>
    </p>
    <h5>
     <a id="282_155">
     </a>
     2.8.2获取设备树节点
    </h5>
    <p>
     <img alt="Pasted image 20250303163241.png" src="https://i-blog.csdnimg.cn/img_convert/e55aadb8656755f6d12e3d24a21a9d98.png"/>
    </p>
    <h5>
     <a id="283ledGPIO_157">
     </a>
     2.8.3获取led所对应的GPIO编号
    </h5>
    <p>
     <img alt="Pasted image 20250308105603.png" src="https://i-blog.csdnimg.cn/img_convert/13c15dea8ce4b6ae1b7fea549910975f.png"/>
     <br/>
     这里知道了有关led驱动的gpio信息，仅仅是能知道信息，并没有驱动能力，所以要向内核申请权限来驱动gpio口。
    </p>
    <h5>
     <a id="284IO_160">
     </a>
     2.8.4申请IO
    </h5>
    <p>
     <img alt="Pasted image 20250308105802.png" src="https://i-blog.csdnimg.cn/img_convert/b222c1ca297a7f538be383ae3ed8fbd5.png"/>
     <br/>
     相应需要注销函数时释放，不然占用资源。
     <br/>
     <img alt="Pasted image 20250308105926.png" src="https://i-blog.csdnimg.cn/img_convert/7deadd8f788c9dc9b85a7bc636bc66ac.png"/>
    </p>
    <h5>
     <a id="285IO_164">
     </a>
     2.8.5使用IO，设置为输出
    </h5>
    <p>
     <img alt="Pasted image 20250303163354.png" src="https://i-blog.csdnimg.cn/img_convert/9a14c61e54798f26fc75467c71c773d8.png"/>
    </p>
    <h5>
     <a id="286_166">
     </a>
     2.8.6配置错误处理
    </h5>
    <p>
     <mark>
      按照以前的习惯，从后面进行处理错误信息，按照逻辑！！！
     </mark>
     <br/>
     <img alt="Pasted image 20250308111018.png" src="https://i-blog.csdnimg.cn/img_convert/a38040a22c308f834a820ac4d55b3929.png"/>
    </p>
    <h4>
     <a id="29write_169">
     </a>
     2.9配置私有数据进行write设备
    </h4>
    <p>
     提供宏定义给LEDAPP进行操作。
     <br/>
     <img alt="Pasted image 20250308111115.png" src="https://i-blog.csdnimg.cn/img_convert/251f73a60deeaba4f7e6356acd26701e.png"/>
     <br/>
     <img alt="Pasted image 20250308111743.png" src="https://i-blog.csdnimg.cn/img_convert/5076b3a4bd151f7f9351bcaa348d883a.png"/>
     <br/>
     图中：
     <code>
      struct gpioled_dev *dev = filp-&gt;private_data;
     </code>
     与
     <code>
      struct gpioled_dev gpioled; /*LED*/
     </code>
     <br/>
     类似，其中可以看作gpioled为全局变量，而dev为局部变量。而私有变量写法要加箭头
     <br/>
     <code>
      dev = filp-&gt;private_data
     </code>
     这是个整体，在前面加个指针，后面要用这个就dev-&gt;给私有数据。
     <br/>
     如
     <code>
      gpioled.led_gpio
     </code>
     和
     <code>
      dev-&gt;led_gpio
     </code>
     一样调用。和全局变量，局部变量一样。
     <br/>
     同理要在输出口设置关灯。
     <br/>
     <img alt="Pasted image 20250308111929.png" src="https://i-blog.csdnimg.cn/img_convert/7435079956f646142f376e64d588cb31.png"/>
     <br/>
     以上就是可以点亮led灯。
     <br/>
     下面结合原子操作，编写相关代码程序!
    </p>
    <h4>
     <a id="210_181">
     </a>
     2.10添加原子操作
    </h4>
    <p>
     <mark>
      原子操作属于临界区，临界区必须保证一次只有一个线程访问。
     </mark>
     <br/>
     这里我们重点分析一下，因为这里有很多API函数，我们可以多拿几个分析。
    </p>
    <h5>
     <a id="2101_184">
     </a>
     2.10.1配置原子操作设备结构体
    </h5>
    <p>
     <img alt="Pasted image 20250308141322.png" src="https://i-blog.csdnimg.cn/img_convert/eb55354b3598ea766fdeb340f532e853.png"/>
    </p>
    <h5>
     <a id="2102_186">
     </a>
     2.10.2初始化原子操作
    </h5>
    <p>
     <img alt="Pasted image 20250308141803.png" src="https://i-blog.csdnimg.cn/img_convert/1a08c4442251c17e959d26fcc1d87516.png"/>
    </p>
    <h5>
     <a id="2103_188">
     </a>
     2.10.3配置操作函数
    </h5>
    <p>
     <img alt="Pasted image 20250308143117.png" src="https://i-blog.csdnimg.cn/img_convert/98313269e1a68017386ebbc095445380.png"/>
     <br/>
     当原子变量没有被使用时，gpioled.lock=1，一旦被上图程序执行，会被减1。后面释放原子变量会回到1。
     <br/>
     这里也可以用别的API函数，只要逻辑可以就行!(根据lock初始化为1，所以后面要回到1)
     <br/>
     <mark>
      例如
     </mark>
     ：
    </p>
    <pre><code>static int led_open(struct inode *inode, struct file *filp)
 {
 /* 通过判断原子变量的值来检查 LED 有没有被别的应用使用 */
 if (!atomic_dec_and_test(&amp;gpioled.lock)) {
 atomic_inc(&amp;gpioled.lock);/* 小于 0 的话就加 1,使其原子变量等于 0 */
 return -EBUSY; /* LED 被使用，返回忙 */
 filp-&gt;private_data = &amp;gpioled; /* 设置私有数据 */
}
 return 0; 
 }
 /*这里的atomic_dec_and_test(&amp;gpioled.lock),假如没有被使用，gpioled.lock=1,则减1，变为0，返回真，又因为“！”，变为假，就不执行return -EBUSY;但是已经变为0，后面释放会加到1，如果还没释放就又要使用这个原子变量，就会执行这个if，跟上面的相反。*/
 /*这样就保证了每次就只允许一个应用使用 LED 灯。*/
</code></pre>
    <p>
     这里加原子变量是因为限制一个应用进来操作。例如gpioled，beep等多个线程同时要执行，就要一个一个来，获得原子变量。原子变量是贯穿内核的。
     <br/>
     <img alt="Pasted image 20250308143321.png" src="https://i-blog.csdnimg.cn/img_convert/ad9affcc978a4a187aa9bce87582633b.png"/>
     <br/>
     <mark>
      测试结果：
     </mark>
    </p>
    <pre><code>./atomicApp /dev/gpioled 1 &amp;//其中&amp;表示在后台运行 atomicApp 这个软件
./atomicApp /dev/gpioled 0
</code></pre>
    <p>
     <mark>
      我发现./atomicApp /dev/gpioled 1不可以执行到原子变量的效果，
     </mark>
     <br/>
     <mark>
      但是发现/atomicApp /dev/gpioled 1&amp;可以
     </mark>
    </p>
    <h5>
     <a id="2104_216">
     </a>
     2.10.4两种命令的区别
    </h5>
    <ul>
     <li>
      <strong>
       <code>
        ./atomicApp /dev/gpioled 1
       </code>
      </strong>
      ：这是一个在前台执行程序的命令。当你运行这个命令时，终端会被该程序占用，直到程序执行完毕才会返回命令提示符，你在程序执行期间无法在同一终端输入其他命令。
     </li>
     <li>
      <strong>
       <code>
        ./atomicApp /dev/gpioled 1 &amp;
       </code>
      </strong>
      ：
      <code>
       &amp;
      </code>
      符号的作用是将程序放到后台执行。程序启动后，终端不会被其占用，你可以立即输入其他命令，同时该程序会在后台继续运行。
      <br/>
      <img alt="Pasted image 20250308152032.png" src="https://i-blog.csdnimg.cn/img_convert/93218cec7e81ea2cf548fd38a09f3cd6.png"/>
      <br/>
      可以看出， atomicApp 运行正常，输出了“App running times:1”和“App running times:2”等字符串，这就是模拟 25S 占用，说明 atomicApp 这个软件正在使用 LED 灯,假如在模拟占用25s内再输入命令./atomicApp /dev/gpioled 0关闭 LED 灯，则会失败。
      <br/>
      打开/dev/gpioled 失败！原因运行的 atomicAPP软件正在占用/dev/gpioled，如果再次运行atomicApp 软件去操作/dev/gpioled 肯定会失败。
      <mark>
       必须等待atomicApp运行结束，也就是25S结束以后其他软件才能去操作/dev/gpioled
      </mark>
      。这个就是采用原子变量实现一次只能有一个应用程序访问 LED 灯。
     </li>
    </ul>
    <h4>
     <a id="211_222">
     </a>
     2.11总代码
    </h4>
    <p>
     <mark>
      gpioled.c
     </mark>
    </p>
    <pre><code>#include &lt;linux/types.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/ide.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/gpio.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/of_address.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;asm/mach/map.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;asm/io.h&gt;

#define GPIOLED_NAME "gpioled"
#define GPIOLED_CNT 1
#define LEDON 1
#define LEDOFF 0
/*gpioled设备结构体*/
struct gpioled_dev{
       dev_t devid; //dev_t 是一个用于表示设备编号的数据类型,设备号
       int major;//主设备号
       int minor;//次设备号
       struct cdev cdev;//设备关联，字符设备对象
       struct class *class;//设备类
       struct device *device;//设备节点
       struct device_node *nd;//设备树节点指针
       int led_gpio;//GPIO编号(从设备树上获取)
       atomic_t lock; /* 原子变量 */
};
struct gpioled_dev gpioled;//设备

static int led_open(struct inode *inode, struct file *filp)
{
   /*通过判断原子变量的值来检查 LED 有没有被别的应用使用*/
   if(atomic_read(&amp;gpioled.lock) &lt;= 0){
        return -EBUSY; /* LED 被使用，返回忙 */
   }else {
      atomic_dec(&amp;gpioled.lock);//LED没有被使用，就减1，表示现在要用这个原子操作
   }
   filp-&gt;private_data = &amp;gpioled;
   return 0;
}

static int led_release(struct inode *inode, struct file *filp)
{
    struct gpioled_dev *dev = filp-&gt;private_data;
    /* 关闭驱动文件的时候释放原子变量 */
    atomic_inc(&amp;dev-&gt;lock);//加1变成1，表示用完，释放原子变量
   return 0;
}
static ssize_t led_write(struct file *filp, const char __user *buf,
			 size_t count, loff_t *ppos)
{
     int ret;
     unsigned char databuf[1];
     struct gpioled_dev *dev=filp-&gt;private_data;
     ret = copy_from_user(databuf,buf,count);
     if(ret &lt; 0){
        return -EINVAL;
     }
     if(databuf[0] == LEDON){
        gpio_set_value(dev-&gt;led_gpio,0);//开灯
     }else if(databuf[0] == LEDOFF){
        gpio_set_value(dev-&gt;led_gpio,1);//关灯
     }
     return 0;
}

/*操作集*/
static const struct file_operations led_fops = {
	.owner   = THIS_MODULE,
	.write   = led_write,
	.open    = led_open,
	.release = led_release,
};


/*驱动入口函数*/
static int __init led_init(void)
{
    int ret;
    /*1.注册字符设备*/
    gpioled.major = 0;
    if(gpioled.major){//若给定主设备号
         gpioled.devid = MKDEV(gpioled.major,0);//0为次设备号
         ret =  register_chrdev_region(gpioled.devid,GPIOLED_CNT,GPIOLED_NAME);
    }else{//若给定主设备号
         ret =  alloc_chrdev_region(&amp;gpioled.devid,0,GPIOLED_CNT,GPIOLED_NAME);
         //0为次设备号,起始的次设备号
         gpioled.major = MAJOR(gpioled.devid);
         gpioled.minor = MINOR(gpioled.devid);
    }
    if(ret &lt; 0){
        goto fail_devid;
    }
    printk("major=%d minor=%d\r\n",gpioled.major,gpioled.minor);

    /*2.初始化cdev*/
    gpioled.cdev.owner= THIS_MODULE;//模块关联与引用计数管理
    cdev_init(&amp;gpioled.cdev, &amp;led_fops);//字符设备操作函数绑定

    /*3.添加cdev*/
    ret = cdev_add(&amp;gpioled.cdev,gpioled.devid,GPIOLED_CNT);//即后续的./ledApp 可以执行到/dev
    if(ret &lt; 0){
        goto fail_cdev;
    }
    
    /*4.创建类class*/
    gpioled.class = class_create(THIS_MODULE,GPIOLED_NAME);//创建/dev/beep
    if(IS_ERR(gpioled.class)){
        ret = PTR_ERR(gpioled.class);
        goto fail_class;
    }
    
    /*5.创建设备节点device*/
    gpioled.device = device_create(gpioled.class,NULL,gpioled.devid,NULL,GPIOLED_NAME);
    //创建/dev/beep
    if(IS_ERR(gpioled.device)){
        ret = PTR_ERR(gpioled.device);
        goto fail_device;
    }

    /*6.获取设备树节点*/
    gpioled.nd = of_find_node_by_path("/gpioled");//根节点
    if(gpioled.nd ==NULL ){
        ret = -EINVAL;
        goto fail_findnode;
    }

    /*7.获取gpioled根节点下的属性*/
    gpioled.led_gpio = of_get_named_gpio(gpioled.nd,"led-gpio",0);
    if(gpioled.led_gpio &lt; 0){
        printk("can't find led gpio\r\n");
        ret = -EINVAL;
        goto fail_findnode;
       }
       printk("led gpio num = %d\r\n",gpioled.led_gpio);

    /*8.申请IO*/
    ret = gpio_request(gpioled.led_gpio,"led-gpio");
    if(ret){
        printk("Failed to request the led gpio\r\n");
        ret = -EINVAL;
        goto fail_findnode;
    }

    /*9.设置IO口电气属性，设置为输出模式*/
    ret = gpio_direction_output(gpioled.led_gpio,1);//默认高电平
    if (ret &lt; 0) {
        ret = -EINVAL;
        goto fail_setoutput;
    }

    /*10.初始化原子变量*/
    gpioled.lock = (atomic_t)ATOMIC_INIT(0);//gpioled.lock=0
    /*11.原子变量初始值为1*/
    atomic_set(&amp;gpioled.lock, 1);
    
    return 0;
fail_setoutput:/*设置输出失败，释放已申请的IO，避免资源浪费*/
    gpio_free(gpioled.led_gpio);
fail_findnode:
    device_destroy(gpioled.class,gpioled.devid);
fail_device:
    class_destroy(gpioled.class);
fail_class:
    cdev_del(&amp;gpioled.cdev);
fail_cdev:
    unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);
fail_devid:
    return ret;
}

/*驱动出口函数*/
static void __exit led_exit(void)
{
  /*关灯*/
  gpio_set_value(gpioled.led_gpio,1);
  /*释放IO*/
  gpio_free(gpioled.led_gpio);
  /*注销设备节点*/  
  device_destroy(gpioled.class,gpioled.devid);
  /*注销设备类*/
  class_destroy(gpioled.class);
  /*注销字符设备对象驱动*/
  cdev_del(&amp;gpioled.cdev);
  /*注销字符设备驱动*/
  unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);
}

module_init(led_init);
module_exit(led_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("chensir");
MODULE_INFO(intree,"Y");//INFO,信息
</code></pre>
    <p>
     <mark>
      LEDAPP.c
     </mark>
    </p>
    <pre><code>#include "stdio.h"
#include "unistd.h"
#include "sys/types.h"  /*open执行所需头文件，根文件目录终端输入man 2 open*/
#include "sys/stat.h"   /*open执行所需头文件，根文件目录终端输入man 2 open*/
#include "fcntl.h"      /*open执行所需头文件，根文件目录终端输入man 2 open*/
#include "stdlib.h"     
#include "string.h"     /*memcpy执行所需头文件，根文件目录终端输入man 3 memcpy*/

/*
*argc:应用程序参数个数
*argv[]：具体的参数内容，字符串形式
*./ledAPP  &lt;fliename&gt;  &lt;0:1&gt;  0表示关灯，1表示开灯
*./ledAPP /dev/gpioled 0   关灯
*./ledAPP /dev/gpioled 1   开灯
*/

#define LEDOFF   0
#define LEDON    1

int main(int argc,char *argv[])
{
  int fd,retvalue;/*fd:类似文件的ID号；retvalue:返回值。*/
  unsigned char databuf[1];/*这种数组可以存储数字或字符*/
  char *filename;
  unsigned char cnt = 0;
  if(argc !=3)
  {
    printf("Error usage!\r\n");
    return -1;
  }
  filename = argv[1];
  /*打开文件*/
  /* int open (const char *pathname,int flags)*/
  fd = open(filename,O_RDWR);/*以读写模式打开文件,fd用于打开文件获取ID号*/
  if(fd&lt;0)
  {
    printf("file %s open failed!\r\n",filename);
    return -1;
  }
  databuf[0] = atoi(argv[2]);/*将字符转换为数字*/
  retvalue=write(fd,databuf,sizeof(databuf));
  if(retvalue&lt;0)
  {
    printf("LED Control Failed!\r\n");
    close(fd);
    
  }
   while(1) {
   sleep(5);
   cnt++;
   printf("App running times:%d\r\n", cnt);
   if(cnt &gt;= 5) break;
 }
  close(fd);
  return 0;
  }


</code></pre>
    <p>
     <mark>
      makefile
     </mark>
    </p>
    <pre><code>KERNELDIR := /home/chensir/linux/atk-mp1/linux/my_linux/linux-5.4.31
CURRENT_PATH := $(shell pwd) 
obj-m := atomic.o

build: kernel_modules

kernel_modules:
	$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules
clean:
	$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean
</code></pre>
    <h3>
     <a id="3_499">
     </a>
     3.总结
    </h3>
    <p>
     1.添加pinctrl信息。
     <br/>
     2.检查当前设备树中要使用的IO有没有被其他设备使用，如果有的话要处理。
     <br/>
     3.添加设备节点，在设备节点中创建一个属性，吃属性描述所使用的gpio。
     <br/>
     4.编写驱动，获取对应的gpio编号，并申请IO，成功后即可使用此IO。
     <br/>
     <mark>
      申请失败绝大部分情况是被其他外设给占用了！！！这种情况在根节点或者设备树检查一下pinctrl复用情况。
     </mark>
    </p>
    <p>
     <mark>
      加油！！！
     </mark>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36363637363831392f:61727469636c652f64657461696c732f313436313238303930" class_="artid" style="display:none">
 </p>
</div>


