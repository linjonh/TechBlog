---
layout: post
title: "HDU-学数数导致的"
date: 2025-03-14 23:29:54 +0800
description: "首先，数对是有序的，<1,2>和<2,1>被视为不同的两组数字。其次，数对<p,q>的p和q可以相等。子序列为 p 0 p q，观察到，中间要出现一个0。那么，我们只需要找到第一个 p 满足与前一个 p 中间隔了最少一个0，并记录它的位置。那么，在它位置之后出现的所有正整数组成的集合的大小，就是 p 对答案的贡献。那么只需要先把满足条件的p的位置都求出来，然后按照从大到小的顺序排序一下，从后往前维护一个集合，然后遍历到p的位置的时候更新答案值，即可。"
keywords: "HDU 学数数导致的"
categories: ['未分类']
tags: ['算法']
artid: "146268766"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268766
    alt: "HDU-学数数导致的"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268766
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268766
cover: https://bing.ee123.net/img/rand?artid=146268766
image: https://bing.ee123.net/img/rand?artid=146268766
img: https://bing.ee123.net/img/rand?artid=146268766
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     HDU 学数数导致的
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <img alt="" height="1034" src="https://i-blog.csdnimg.cn/direct/1f8b29a1d91942b78cd952d05e8447a5.png" width="818">
      题目解析
     </img>
    </h2>
    <p>
     首先，数对是有序的，&lt;1,2&gt;和&lt;2,1&gt;被视为不同的两组数字。
    </p>
    <p>
     其次，数对&lt;p,q&gt;的p和q可以相等。
    </p>
    <p>
     子序列为 p 0 p q，观察到，中间要出现一个0。那么，我们只需要找到第一个 p 满足与前一个 p 中间隔了最少一个0，并记录它的位置。那么，在它位置之后出现的所有正整数组成的集合的大小，就是 p 对答案的贡献。
    </p>
    <p>
     那么只需要先把满足条件的p的位置都求出来，然后按照从大到小的顺序排序一下，从后往前维护一个集合，然后遍历到p的位置的时候更新答案值，即可。
    </p>
    <h2>
     代码实现
    </h2>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
long long t, n, a[1000010], sum0, ans, num;
struct node {
    long long num0;
    long long pos;
}e[1000010];
vector&lt;long long&gt;pos;
bool vis[1000010] = {};
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin &gt;&gt; t;
    while (t--) {
        sum0 = 0;
        ans = 0;
        num = 0;
        pos.clear();
        for (int i = 0; i &lt; 1000010; i++) {
            vis[i] = false;
            e[i].pos = -1;
        }
        vis[0] = true;
        cin &gt;&gt; n;
        for (int i = 0; i &lt; n; i++) {
            cin &gt;&gt; a[i];
            if (a[i] == 0)sum0++;//记录0出现过的次数
            else if (e[a[i]].pos == -1) {//如果a[i]之前没出现过，则记录位置和前导0的数量
                e[a[i]].pos = i;
                e[a[i]].num0 = sum0;
            }
            else if (e[a[i]].pos &gt;= 0 &amp;&amp; e[a[i]].num0 != sum0) {//如果出现过，则比较前导0的数量是否相等。若不等，则说明之间出现0，记录位置
                pos.push_back(i);
                e[a[i]].pos = -2;//打上标记，防止再被处理
            }
        }
        sort(pos.begin(), pos.end());//对位置进行排序
        for (int i = pos.size() - 1, j = n - 1; i &gt;= 0; j--) {
            if (j == pos[i]) {//碰到符合的位置，则更新答案值
                ans += num;
                i--;
            }
            if (!vis[a[j]]) {//之前没遇到过，则放入集合中，更新集合大小
                vis[a[j]] = true;
                num++;
            }
        }
        cout &lt;&lt; ans &lt;&lt; "\n";
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f41726b6e6967687473446f63746f742f:61727469636c652f64657461696c732f313436323638373636" class_="artid" style="display:none">
 </p>
</div>


