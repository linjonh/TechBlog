---
layout: post
title: "RabbitMQ高级特性-消息确认机制"
date: 2025-03-09 22:13:26 +0800
description: "生产者发送消息之后，到达消费端之后，可能会有以下情况：1. 消息处理成功；2. 消息处理异常。RabbitMQ向消费者发送消息后，就会把这条消息删除掉，那么第二种情况就会造成消息丢失。那么如何确保消息端已经被成功接收了并且被正确处理了呢？为了确保消息从队列可靠的到达消费者，RabbitMQ提供了消息确认机制（Messageacknowledment）。"
keywords: "RabbitMQ高级特性--消息确认机制"
categories: ['Rabbitmq']
tags: ['Rabbitmq', 'Java', 'Idea']
artid: "146138202"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146138202
    alt: "RabbitMQ高级特性-消息确认机制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146138202
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146138202
cover: https://bing.ee123.net/img/rand?artid=146138202
image: https://bing.ee123.net/img/rand?artid=146138202
img: https://bing.ee123.net/img/rand?artid=146138202
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ高级特性--消息确认机制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="" name="">
    </h2>
    <h2 id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4" name="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4">
     一、消息确认
    </h2>
    <h3 id="1.%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6" name="1.%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6">
     1.消息确认机制
    </h3>
    <p>
     生产者发送消息之后，到达消费端之后，可能会有以下情况：
    </p>
    <p>
     1. 消息处理成功；
    </p>
    <p>
     2. 消息处理异常。
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3c4afc6bb34c4804833155a3088cb10a.png"/>
    </p>
    <p>
     RabbitMQ向消费者发送消息后，就会把这条消息删除掉，那么第二种情况就会造成消息丢失。
    </p>
    <p>
     那么如何确保消息端已经被成功接收了并且被正确处理了呢？
    </p>
    <p>
     为了确保消息从队列可靠的到达消费者，RabbitMQ提供了消息确认机制（Messageacknowledment）。
    </p>
    <p>
     消费者在订阅队列时，可以指定autoAck参数，根据这个参数，消息确认机制分为以下两种：
    </p>
    <p>
     <strong>
      自动确认：
     </strong>
     当autoAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正的接收到消息，自动确认模式适用于对于消息可靠性要求不高的场景。
    </p>
    <p>
     <strong>
      手动确认：
     </strong>
     当autoAck等于false时，RabbitMQ会等待消费者显式的调用BasicAck命令，回复确认信号后才从内存（或者磁盘）中删除，这种方式适用于对消息可靠性要求较高的场景。
    </p>
    <p>
     自动确认代码示例：
    </p>
    <pre><code class="language-java">DefaultConsumer consumer = new DefaultConsumer(channel) {
 @Override
 public void handleDelivery(String consumerTag, Envelope envelope, 
AMQP.BasicProperties properties, byte[] body) throws IOException {
 System.out.println("接收到消息: " + new String(body));
 }
};
channel.basicConsume(Constants.TOPIC_QUEUE_NAME1, true, consumer);</code></pre>
    <p>
     当autoAck参数置为false，对于RabbitMQ服务器来说，队列中的消息分为了两个部分：
    </p>
    <p>
     一是等待发送给消费者的消息；二是已经发送给消费者，但是还没收到消费者确认信号的消息。
    </p>
    <p>
     如果RabbitMQ一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则RabbitMQ会重新安排这条消息进入队列，等待投递给下一个消费者，当然也有可能是原来的那个消费者。
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7863e3472f5543e5a13bbc722534a023.png"/>
    </p>
    <p>
     从RabbitMQ的Web管理平台上也可以看到当前队列中Ready状态和Unacked状态的消息数。
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/63be9be7bc78410fac2735c556007f0b.png"/>
    </p>
    <p>
     Ready：等待投递给消费者的消息数。
    </p>
    <p>
     Unacked：已经投递给消费者，但是未收到消费者确认信号的消息数。
    </p>
    <h3 id="2.%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4%E6%96%B9%E6%B3%95" name="2.%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4%E6%96%B9%E6%B3%95">
     2.手动确认方法
    </h3>
    <p>
     消费者在收到消息后，可以选择确认，也可以选择跳过或者直接拒绝确认，RabbitMQ也提供了不同的确认方法，消费者客户端可以调用与其对应的channel的相关方法，共有以下三种：
    </p>
    <pre><code class="language-java">肯定确认: Channel.basicAck(long deliveryTag, boolean multiple);</code></pre>
    <p>
     RabbitMQ 已经知道该消息并且成功的处理消息，可以将其丢弃。
    </p>
    <p>
     参数说明：
    </p>
    <p>
     deliveryTag：消息的唯一标识，它是一个单调递增的64位的长整型值，deliveryTag是每个信道（Channel）独立维护的，所以在每个信道上都是唯一的，当消费者确认（ack）一条消息时，必须使用对应的信道进行确认。
    </p>
    <p>
     multiple：是否批量确认，在某些情况下，为了减少网络流量，可以对一系列连续的deliveryTag进行批量确认，值为true则会一次性ack所以小于等于指定deliveryTag的消息，值为false，则只确认当前deliveryTag的消息。
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b884c39e3a3b44659f434e799e9567e4.png"/>
    </p>
    <div>
     <span style="color:#646a73">
      deliveryTag
     </span>
     <span style="color:#646a73">
      是RabbitMQ中消息确认机制的⼀个重要组成部分, 它确保了消息传递的可靠性和顺
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      序性。
     </span>
    </div>
    <div>
    </div>
    <div>
     <pre><code class="language-java">否定确认: Channel.basicReject(long deliveryTag, boolean requeue);</code></pre>
     <p>
      参数说明：
     </p>
     <p>
      deliveryTag：参考上文。
     </p>
     <p>
      requeue：表示拒绝后，这条消息该如何处理，如果值为true那么，则RabbitMQ会将这条消息重新入队，重新发送给下一个订阅的消费者，值为false，则RabbitMQ会把这条消息从队列中移除，不会再发送给消费者。
     </p>
     <pre><code class="language-java">否定确认: Channel.basicNack(long deliveryTag, boolean multiple,
boolean requeue);</code></pre>
     <p>
      参数说明：
     </p>
     <p>
      参考上文
     </p>
     <p>
      <span style="color:#1f2329">
       multiple参数设置为true则表⽰拒绝deliveryTag编号之前所有未被当前消费者确认的消息。
      </span>
     </p>
     <h2 id="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" name="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
      <span style="color:#1f2329">
       二、代码示例
      </span>
     </h2>
     <p>
      <span style="color:#1f2329">
       我们基于SpringBoot来演示消息的确认机制，使用方式和方法与RabbitMQ Java Client有一定差异，
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       Spring AMQP对消息确认提供了三种策略：
      </span>
     </p>
     <pre><code class="language-java">public enum AcknowledgeMode {
 NONE,
 MANUAL,
 AUTO;
}</code></pre>
     <div>
      <span style="color:#1456f0">
       .
      </span>
      <span style="color:#1f2329">
       AcknowledgeMode.NONE：
      </span>
     </div>
     <div>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        这种模式下, 消息⼀旦投递给消费者, 不管消费者是否成功处理了消息, RabbitMQ 就会⾃动确认
       </span>
      </strong>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        消息, 从RabbitMQ队列中移除消息. 如果消费者处理消息失败, 消息可能会丢失.
       </span>
      </strong>
     </div>
     <div>
     </div>
     <div>
      <span style="color:#1456f0">
      </span>
      <span style="color:#1f2329">
       AcknowledgeMode.AUTO(默认)：
      </span>
     </div>
     <div>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        这种模式下, 消费者在消息处理成功时会⾃动确认消息, 但如果处理过程中抛出了异常, 则不会确
       </span>
      </strong>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        认消息.
       </span>
      </strong>
     </div>
     <div>
     </div>
     <div>
      <span style="color:#1456f0">
      </span>
      <span style="color:#1f2329">
       AcknowledgeMode.MANUAL：
      </span>
     </div>
     <div>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        ⼿动确认模式下, 消费者必须在成功处理消息后显式调⽤
       </span>
       <span style="color:#1f2329">
        basicAck
       </span>
       <span style="color:#1f2329">
        ⽅法来确认消息. 如果消
       </span>
      </strong>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        息未被确认, RabbitMQ 会认为消息尚未被成功处理, 并且会在消费者可⽤时重新投递该消息, 这
       </span>
      </strong>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        种模式提⾼了消息处理的可靠性, 因为即使消费者处理消息后失败, 消息也不会丢失, ⽽是可以被
       </span>
      </strong>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        重新处理.
       </span>
      </strong>
     </div>
    </div>
    <p>
    </p>
    <h3 id="1.%C2%A0AcknowledgeMode.NONE" name="1.%C2%A0AcknowledgeMode.NONE">
     1.
     <span style="color:#1f2329">
      AcknowledgeMode.NONE
     </span>
    </h3>
    <h4 id="1.1%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" name="1.1%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">
     <span style="color:#1f2329">
      1.1 配置文件
     </span>
    </h4>
    <pre><code class="language-java">spring:
 rabbitmq:
 addresses: amqp:
 listener:
 simple:
 acknowledge-mode: none
</code></pre>
    <h4 id="1.2%20%E7%94%9F%E4%BA%A7%E8%80%85" name="1.2%20%E7%94%9F%E4%BA%A7%E8%80%85">
     1.2 生产者
    </h4>
    <pre><code class="language-java">public class Constant {
 public static final String ACK_EXCHANGE_NAME = "ack_exchange";
 public static final String ACK_QUEUE = "ack_queue";
}</code></pre>
    <pre><code class="language-java">/*
以下为消费端⼿动应答代码⽰例配置
*/
@Bean("ackExchange")
public Exchange ackExchange(){
 return
ExchangeBuilder.topicExchange(Constant.ACK_EXCHANGE_NAME).durable(true).build()
;
}
//2. 队列
@Bean("ackQueue")
public Queue ackQueue() {
 return QueueBuilder.durable(Constant.ACK_QUEUE).build();
}
//3. 队列和交换机绑定 Binding
@Bean("ackBinding")
public Binding ackBinding(@Qualifier("ackExchange") Exchange exchange, 
@Qualifier("ackQueue") Queue queue) {
 return BindingBuilder.bind(queue).to(exchange).with("ack").noargs();
}</code></pre>
    <pre><code class="language-java">import com.xiaowu.rabbitmq.constant.Constant;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
@RequestMapping("/producer")
public class ProductController {
 @Autowired
 private RabbitTemplate rabbitTemplate;
 @RequestMapping("/ack")
 public String ack(){
 rabbitTemplate.convertAndSend(Constant.ACK_EXCHANGE_NAME, "ack", 
"consumer ack test...");
 return "发送成功!";
 }
}</code></pre>
    <h4 id="%C2%A01.3%20%E6%B6%88%E8%B4%B9%E8%80%85" name="%C2%A01.3%20%E6%B6%88%E8%B4%B9%E8%80%85">
     1.3 消费者
    </h4>
    <p>
    </p>
    <pre><code class="language-java">import com.xiaowu.rabbitmq.constant.Constant;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
@Component
public class AckQueueListener {
 //指定监听队列的名称
 @RabbitListener(queues = Constant.ACK_QUEUE)
 public void ListenerQueue(Message message, Channel channel) throws
Exception {
 System.out.printf("接收到消息: %s, deliveryTag: %d%n", new
String(message.getBody(),"UTF-8"), 
message.getMessageProperties().getDeliveryTag());
 //模拟处理失败
 int num = 3/0;
 System.out.println("处理完成");
 }
}</code></pre>
    <h4 id="1.4%20%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%C2%A0" name="1.4%20%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%C2%A0">
     1.4 运行程序
    </h4>
    <p>
     启动生产者可以从RabbitMQ Web管理界面看到如下：
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/65e28c2008f44d058acedc15495fac38.png"/>
    </p>
    <p>
     再启动消费者，控制台输出：
    </p>
    <pre><code class="language-java">接收到消息: consumer ack test..., deliveryTag: 1
2024-04-29T17:03:57.797+08:00 WARN 16952 --- [ntContainer#0-1] 
s.a.r.l.ConditionalRejectingErrorHandler : Execution of Rabbit message 
listener failed.
org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: 
Listener method 'public void 
com.xiaowu.rabbitmq.listener.AckQueueListener.ListenerQueue(org.springframework.a
mqp.core.Message,com.rabbitmq.client.Channel) throws java.lang.Exception'
threw exception
//....</code></pre>
    <p>
     管理界面：
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ff3e2170331749de9d4ac5544b69e6dd.png"/>
    </p>
    <p>
     可以看到消息处理失败但是消息已经从管理界面移除。
    </p>
    <h3 id="%C2%A02.AcknowledgeMode.AUTO" name="%C2%A02.AcknowledgeMode.AUTO">
     2.
     <span style="color:#1f2329">
      AcknowledgeMode.AUTO
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      将配置文件修改为：
     </span>
    </p>
    <pre><code class="language-java">spring:
 rabbitmq:
 addresses: amqp:
 listener:
 simple:
 acknowledge-mode: auto</code></pre>
    <p>
     再次启动程序，控制台不断输出错误信息：
    </p>
    <pre><code class="language-java">接收到消息: consumer ack test..., deliveryTag: 1
2024-04-29T17:07:06.114+08:00 WARN 16488 --- [ntContainer#0-1] 
s.a.r.l.ConditionalRejectingErrorHandler : Execution of Rabbit message 
listener failed.
org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: 
Listener method 'public void 
com.xiaowu.rabbitmq.listener.AckQueueListener.ListenerQueue(org.springframework.a
mqp.core.Message,com.rabbitmq.client.Channel) throws java.lang.Exception'
threw exception
 
接收到消息: consumer ack test..., deliveryTag: 2
2024-04-29T17:07:07.161+08:00 WARN 16488 --- [ntContainer#0-1] 
s.a.r.l.ConditionalRejectingErrorHandler : Execution of Rabbit message 
listener failed.
org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: 
Listener method 'public void 
com.xiaowu.rabbitmq.listener.AckQueueListener.ListenerQueue(org.springframework.a
mqp.core.Message,com.rabbitmq.client.Channel) throws java.lang.Exception'
threw exception
 
接收到消息: consumer ack test..., deliveryTag: 3
2024-04-29T17:07:08.208+08:00 WARN 16488 --- [ntContainer#0-1] 
s.a.r.l.ConditionalRejectingErrorHandler : Execution of Rabbit message 
listener failed.
org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: 
Listener method 'public void 
com.xiaowu.rabbitmq.listener.AckQueueListener.ListenerQueue(org.springframework.a
mqp.core.Message,com.rabbitmq.client.Channel) throws java.lang.Exception'
threw exception
 
接收到消息: consumer ack test..., deliveryTag: 4
2024-04-29T17:07:09.254+08:00 WARN 16488 --- [ntContainer#0-1] 
s.a.r.l.ConditionalRejectingErrorHandler : Execution of Rabbit message 
listener failed.
org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: 
Listener method 'public void 
com.xiaowu.rabbitmq.listener.AckQueueListener.ListenerQueue(org.springframework.a
mqp.core.Message,com.rabbitmq.client.Channel) throws java.lang.Exception'
threw exception
 </code></pre>
    <div>
     <span style="color:#1f2329">
      从⽇志上可以看出, 当消费者出现异常时, RabbitMQ会不断的重发. 由于异常，多次重试还是失败，消 息没被确认，也无法nack，就⼀直是unacked状态，导致消息积压。
     </span>
    </div>
    <div>
    </div>
    <h3 id="3.AcknowledgeMode.MANUAL" name="3.AcknowledgeMode.MANUAL">
     <span style="color:#1f2329">
      3.AcknowledgeMode.MANUAL
     </span>
    </h3>
    <pre><code class="language-java">spring:
 rabbitmq:
 addresses: amqp:
 listener:
 simple:
 acknowledge-mode: manual</code></pre>
    <p>
     消费者手动确认逻辑：
    </p>
    <pre><code class="language-java">import com.xiaowu.rabbitmq.constant.Constant;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
@Component
public class AckQueueListener {
 //指定监听队列的名称
 @RabbitListener(queues = Constant.ACK_QUEUE)
 public void ListenerQueue(Message message, Channel channel) throws
Exception {
 long deliveryTag = message.getMessageProperties().getDeliveryTag();
 try {
 //1. 接收消息
 System.out.printf("接收到消息: %s, deliveryTag: %d%n", new
String(message.getBody(),"UTF-8"), 
message.getMessageProperties().getDeliveryTag());
 //2. 处理业务逻辑
 System.out.println("处理业务逻辑");
 //⼿动设置⼀个异常, 来测试异常拒绝机制
// int num = 3/0;
 //3. ⼿动签收
 channel.basicAck(deliveryTag, true);
 } catch (Exception e) {
 //4. 异常了就拒绝签收
 //第三个参数requeue, 是否重新发送, 如果为true, 则会重新发送,,若为false, 
则直接丢弃
 channel.basicNack(deliveryTag, true,true);
 }
 }
}
</code></pre>
    <p>
     <span style="color:#1f2329">
      这个代码运行的结果是正常的, 运行后消息会被签收: Ready为0, unacked为0。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      异常时拒绝：
     </span>
    </p>
    <pre><code class="language-java">import com.xiaowu.rabbitmq.constant.Constant;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
@Component
public class AckQueueListener {
 //指定监听队列的名称
 @RabbitListener(queues = Constant.ACK_QUEUE)
 public void ListenerQueue(Message message, Channel channel) throws
Exception {
 long deliveryTag = message.getMessageProperties().getDeliveryTag();
 try {
 //1. 接收消息
 System.out.printf("接收到消息: %s, deliveryTag: %d%n", new
String(message.getBody(),"UTF-8"), 
message.getMessageProperties().getDeliveryTag());
 //2. 处理业务逻辑
 System.out.println("处理业务逻辑");
 //⼿动设置⼀个异常, 来测试异常拒绝机制
 int num = 3/0;
 //3. ⼿动签收
 channel.basicAck(deliveryTag, true);
 } catch (Exception e) {
 //4. 异常了就拒绝签收
 //第三个参数requeue, 是否重新发送, 如果为true, 则会重新发送,,若为false, 
则直接丢弃
 channel.basicNack(deliveryTag, true,true);
 }
 }
}
</code></pre>
    <div>
     <span style="color:#1f2329">
      运⾏结果: 消费异常时不断重试, deliveryTag 从1递增
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      控制台日志:
     </span>
    </div>
    <div>
    </div>
    <div>
     <pre><code class="language-java">接收到消息: consumer ack test..., deliveryTag: 1
处理业务逻辑
接收到消息: consumer ack test..., deliveryTag: 2
处理业务逻辑
接收到消息: consumer ack test..., deliveryTag: 3
处理业务逻辑
接收到消息: consumer ack test..., deliveryTag: 4
处理业务逻辑
接收到消息: consumer ack test..., deliveryTag: 5
处理业务逻辑
接收到消息: consumer ack test..., deliveryTag: 6
处理业务逻辑
</code></pre>
     <p>
      管理页面上unacked也是1：
     </p>
     <p style="text-align:center">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/e9675c8432124e609e7621bccb347989.png"/>
     </p>
    </div>
    <div>
    </div>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h4 id="" name="">
    </h4>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393939353232362f:61727469636c652f64657461696c732f313436313338323032" class_="artid" style="display:none">
 </p>
</div>


