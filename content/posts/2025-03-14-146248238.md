---
layout: post
title: "stack_queue常用接口及模拟实现"
date: 2025-03-14 09:12:34 +0800
description: "本篇文章主要介绍了栈和队列、优先队列的常用接口和模拟实现，并且在优先队列的模拟实现中，使用了堆算法和C++中less和greater两个比较大小的类，以及涉及到模板的一些知识点，希望这些内容对大家有所帮助！！！"
keywords: "stack_queue常用接口及模拟实现"
categories: ['C']
tags: ['算法', '数据结构', 'C']
artid: "146248238"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146248238
    alt: "stack_queue常用接口及模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146248238
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146248238
cover: https://bing.ee123.net/img/rand?artid=146248238
image: https://bing.ee123.net/img/rand?artid=146248238
img: https://bing.ee123.net/img/rand?artid=146248238
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     stack_queue常用接口及模拟实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8" name="%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8">
     容器适配器
    </h2>
    <h3 id="a.%E6%A6%82%E5%BF%B5" name="a.%E6%A6%82%E5%BF%B5">
     a.概念
    </h3>
    <p>
     适配器是一种设计模式（设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结），该种模式是将一个类的接口转换成客户希望的另外一个接口
    </p>
    <p style="text-align:center">
     <img alt="" height="400" src="https://i-blog.csdnimg.cn/direct/9df4880c395d4910a7384d414be95084.png" width="644"/>
    </p>
    <p>
    </p>
    <h3 id="b.%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84" name="b.%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">
     b.底层结构
    </h3>
    <p>
     STL标准库中stack和queue的底层结构
    </p>
    <p>
     虽然stack和queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为stack和队列只是对其他容器的接口进行了包装，STL中stack和queue默认使用deque，比如：
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e674feb3af3449d382baf01454c51645.png"/>
    </p>
    <p>
    </p>
    <h3 id="c.deque" name="c.deque">
     c.deque
    </h3>
    <h4 id="%E2%91%A0%20%E5%8E%9F%E7%90%86" name="%E2%91%A0%20%E5%8E%9F%E7%90%86">
     ① 原理
    </h4>
    <p>
     deque(双端队列)：是一种双开口的"连续"空间的数据结构，双开口的含义是：可以在头尾两端进行插入和删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ec8006140e964b1bbed19f50177fd186.png"/>
    </p>
    <p>
     deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成的，实际deque类似于一个动态的二维数组，其底层结构如下图所示：
    </p>
    <p style="text-align:center">
     <img alt="" height="400" src="https://i-blog.csdnimg.cn/direct/bbf48c723f6045b8822c4a1f00b8dcd6.png" width="487"/>
    </p>
    <p>
     双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂，如下图所示：
    </p>
    <p style="text-align:center">
     <img alt="" height="400" src="https://i-blog.csdnimg.cn/direct/281c4eea840b48a498deed38f956c852.png" width="719"/>
    </p>
    <p>
     迭代器遍历的实现
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6d3a72825d9540f6ad3d2fe15b5f73c9.png"/>
    </p>
    <h4 id="" name="">
    </h4>
    <h4 id="%E2%91%A1%20%E7%BC%BA%E9%99%B7" name="%E2%91%A1%20%E7%BC%BA%E9%99%B7">
     ② 缺陷
    </h4>
    <p>
     与vector比较，deque的优势是：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的
    </p>
    <p>
     与list比较，deque底层是连续空间，空间利用率比较高，不需要存储额外字段
    </p>
    <p>
     deque有一个致命缺陷：不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率较低
    </p>
    <p>
    </p>
    <h3 id="d.%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8" name="d.%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8">
     d.底层默认容器
    </h3>
    <p>
     stack是一种后进先出的特殊线性数据结构，因此只要具有push_back()和pop_back()操作的线性结构，都可以作为stack的底层容器，比如vector和list都可以；queue是先进先出的特殊线性数据结构，只要具有push_back和pop_front操作的线性结构，都可以作为queue的底层容器，比如list
    </p>
    <p>
     STL中对stack和queue默认选择deque作为其底层容器，主要是因为：
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        ① stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        ② 在stack中元素增长时，deque比vector的效率高(扩容时不需要搬移大量数据)；queue中的元素增长时，deque不仅效率高，而且内存使用率高
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
    </p>
    <h2 id="stack" name="stack">
     stack
    </h2>
    <h3 id="a.%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0" name="a.%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0">
     a.基础构造
    </h3>
    <p>
     栈是一种特殊的线性表，它遵循“后进先出”（Last In First Out，LIFO）的原则，具有压栈和弹栈两种基本操作
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a0588bc06b3846e6811ceadb5144257e.png"/>
    </p>
    <h3 id="" name="">
    </h3>
    <h3 id="b.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3" name="b.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">
     b.常用接口
    </h3>
    <p>
     大家可以配合C++官网的介绍来看下面的内容
    </p>
    <p>
     <a href="https://legacy.cplusplus.com/reference/stack/stack/" rel="nofollow" title="stack - C++ Reference">
      stack - C++ Reference
     </a>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数名称
       </th>
       <th>
        功能说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        stack()
       </td>
       <td>
        构造空的栈
       </td>
      </tr>
      <tr>
       <td>
        empty()
       </td>
       <td>
        检测stack是否为空
       </td>
      </tr>
      <tr>
       <td>
        size()
       </td>
       <td>
        返回stack中元素的个数
       </td>
      </tr>
      <tr>
       <td>
        top()
       </td>
       <td>
        返回栈顶元素的引用
       </td>
      </tr>
      <tr>
       <td>
        push()
       </td>
       <td>
        将元素val压入stack中
       </td>
      </tr>
      <tr>
       <td>
        pop()
       </td>
       <td>
        将stack中尾部的元素弹出
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h3 id="c.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="c.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     c.模拟实现
    </h3>
    <pre><code class="language-cpp">// 除 deque 以外，也可以复用 vector
#include&lt;deque&gt;

namespace tianci
{
	template&lt;class T, class Container = deque&lt;T&gt;&gt;
	class stack
	{
	public:
		void push(const T&amp; x)
		{
			_con.push_back(x);
		}

		void pop()
		{
			_con.pop_back();
		}

		const T&amp; top()const
		{
			return _con.back();
		}

		size_t size()const
		{
			return _con.size();
		}

		bool empty()
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}</code></pre>
    <p>
    </p>
    <h2 id="queue" name="queue">
     queue
    </h2>
    <h3 id="a.%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0" name="a.%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0">
     a.基础构造
    </h3>
    <p>
     队列是一种遵循“先进先出”（First In First Out，FIFO）原则的线性数据结构。与栈不同，队列允许在一端插入元素（入队），而在另一端删除元素（出队）
    </p>
    <p>
     <img alt="" height="201" src="https://i-blog.csdnimg.cn/direct/32f241d5f95a4fecb0e1221246e2b877.png" width="936"/>
    </p>
    <p>
    </p>
    <h3 id="b.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3" name="b.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">
     b.常用接口
    </h3>
    <p>
     大家可以配合C++官网的介绍来看下面的内容
    </p>
    <p>
     <a href="https://legacy.cplusplus.com/reference/queue/queue/" rel="nofollow" title="queue - C++ Reference">
      queue - C++ Reference
     </a>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数名称
       </th>
       <th>
        功能说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        queue()
       </td>
       <td>
        构造空的队列
       </td>
      </tr>
      <tr>
       <td>
        empty()
       </td>
       <td>
        检测队列是否为空，是返回true，否则返回false
       </td>
      </tr>
      <tr>
       <td>
        size()
       </td>
       <td>
        返回队列中有效元素的个数
       </td>
      </tr>
      <tr>
       <td>
        front()
       </td>
       <td>
        返回队头元素的引用
       </td>
      </tr>
      <tr>
       <td>
        back()
       </td>
       <td>
        返回队尾元素的引用
       </td>
      </tr>
      <tr>
       <td>
        push()
       </td>
       <td>
        在队尾将元素val入队列
       </td>
      </tr>
      <tr>
       <td>
        pop()
       </td>
       <td>
        将队头元素出队列
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h3 id="c.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="c.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     c.模拟实现
    </h3>
    <pre><code class="language-cpp">// 除 deque 以外，也可以复用 list
#include &lt;deque&gt;

namespace tianci
{
	template&lt;class T, class Container = deque&lt;T&gt;&gt;
	class queue
	{
	public:
		void push(const T&amp; x)
		{
			_con.push_back(x);
		}

		void pop()
		{
			_con.pop_front();
		}

		const T&amp; front()
		{
			return _con.front();
		}

		const T&amp; back()
		{
			return _con.back();
		}

		size_t size()const
		{
			return _con.size();
		}

		bool empty()const
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}</code></pre>
    <p>
    </p>
    <h2 id="priority_queue" name="priority_queue">
     priority_queue
    </h2>
    <h3 id="a.%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0" name="a.%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0">
     a.基础构造
    </h3>
    <p>
     priority_queue是一种基于容器适配器的优先队列数据结构，类似于堆，并且默认是大堆
    </p>
    <p>
     priority_queue默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue可以考虑使用在需要堆的问题中
    </p>
    <p>
     （关于堆算法，大家可以看看我数据结构里的堆的实现这篇文章，里面有详细的介绍）
    </p>
    <p>
    </p>
    <h3 id="b.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3" name="b.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">
     b.常用接口
    </h3>
    <p>
     大家可以配合C++官网的介绍来看下面的内容
    </p>
    <p>
     <a href="https://legacy.cplusplus.com/reference/queue/priority_queue/" rel="nofollow" title="priority_queue - C++ Reference">
      priority_queue - C++ Reference
     </a>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        函数名称
       </th>
       <th>
        功能说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        priority_queue()/priority_queue(first, last)
       </td>
       <td>
        构造一个空的优先级队列
       </td>
      </tr>
      <tr>
       <td>
        empty( )
       </td>
       <td>
        检测优先级队列是否为空，是返回true，否则返回false
       </td>
      </tr>
      <tr>
       <td>
        top( )
       </td>
       <td>
        返回优先级队列中最大(最小元素)，即堆顶元素
       </td>
      </tr>
      <tr>
       <td>
        push(x)
       </td>
       <td>
        在优先级队列中插入元素x
       </td>
      </tr>
      <tr>
       <td>
        pop()
       </td>
       <td>
        删除优先级队列中最大(最小)元素，即堆顶元素
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
    </p>
    <h4 id="%E2%91%A0%20less%20%26%20greater" name="%E2%91%A0%20less%20%26%20greater">
     ① less &amp; greater
    </h4>
    <p>
     关于priority_queue的使用还有一个点，就是选择大堆or小堆
    </p>
    <p>
     C++中 less 和 greater 是用来专门比较大小的类
    </p>
    <p style="text-align:center">
     <img alt="" height="500" src="https://i-blog.csdnimg.cn/direct/03c2620080da402fbcb8745a32c2f2e8.png" width="720"/>
    </p>
    <h4 id="%E2%91%A1%20%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" name="%E2%91%A1%20%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">
     ② 使用方法
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/096a039daa6042aa8ac2de5877206cc0.png"/>
    </p>
    <p>
     大家需要注意的是，greater对应的是小堆，less对应的是大堆，这里设计的有点奇怪
    </p>
    <p>
    </p>
    <h3 id="c.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="c.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     c.模拟实现
    </h3>
    <p>
     对于priority_queue的模拟实现相对麻烦一点，因为涉及到堆算法和模版的使用
    </p>
    <p>
     （大家可以先看看我另外两篇文章，堆的实现和模版，里面有介绍堆算法以及模版的一些知识点，再来看模拟实现会理解的通透一点）
    </p>
    <pre><code class="language-cpp">#include&lt;vector&gt;

namespace tianci
{
	template &lt;class T&gt;
	struct less
	{
		bool operator() (const T&amp; x, const T&amp; y) const
		{
			return x &lt; y;
		}
	};

	template &lt;class T&gt;
	struct greater
	{
		bool operator() (const T&amp; x, const T&amp; y) const
		{
			return x &gt; y;
		}
	};


	template&lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;int&gt;&gt;
	class priority_queue
	{
	public:

		// 强制生成
		priority_queue() = default;

		template &lt;class InputIterator&gt;
		priority_queue(InputIterator first, InputIterator last)
			:_con(first, last)
		{
			// 建堆
			for (int i = (_con.size() - 1 - 1) / 2; i &gt;= 0; i--)
			{
				AdjustDown(i);
			}
		}

		void Adjustup(size_t child)
		{
			Compare com;

			size_t parent = (child - 1) / 2;
			
			while (child &gt; 0)
			{
				//if (_con[parent] &lt; _con[child])
				if (com(_con[parent], _con[child]))
				{
					swap(_con[child], _con[parent]);
					child = parent;
					parent = (child - 1) / 2;
				}
				else
				{
					break;
				}
			}
		}

		void push(const T&amp; x)
		{
			_con.push_back(x);
			Adjustup(_con.size() - 1);
		}

		void Adjustdown(size_t parent)
		{
			Compare com;

			size_t child = parent * 2 + 1;

			while (child &lt; _con.size())
			{
				//if (child + 1 &lt; _con.size() &amp;&amp; _con[child] &lt; _con[child + 1])
				if (child + 1 &lt; _con.size() &amp;&amp; com(_con[child], _con[child + 1]))
				{
					++child;
				}

				//if (_con[parent] &lt; _con[child])
				if(com(_con[parent], _con[child]))
				{
					swap(_con[child], _con[parent]);
					parent = child;
					child = parent * 2 + 1;
				}
				else
				{
					break;
				}
			}
		}

		void pop()
		{
			swap(_con[0], _con[_con.size() - 1]);
			_con.pop_back();
			Adjustdown(0);
		}
		
		size_t size()const
		{
			return _con.size();
		}

		const T&amp; top()
		{
			return _con[0];
		}

		bool empty()const
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}</code></pre>
    <p>
    </p>
    <p>
     本篇文章到这里就结束啦，希望这些内容对大家有所帮助！
    </p>
    <p>
     下篇文章见，希望大家多多来支持一下！
    </p>
    <p>
     感谢大家的三连支持！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38343433333932392f:61727469636c652f64657461696c732f313436323438323338" class_="artid" style="display:none">
 </p>
</div>


