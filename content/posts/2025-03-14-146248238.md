---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38343433333932392f:61727469636c652f64657461696c732f313436323438323338"
layout: post
title: "stack_queue常用接口及模拟实现"
date: 2025-03-14 09:12:34 +0800
description: "本篇文章主要介绍了栈和队列、优先队列的常用接口和模拟实现，并且在优先队列的模拟实现中，使用了堆算法和C++中less和greater两个比较大小的类，以及涉及到模板的一些知识点，希望这些内容对大家有所帮助！！！"
keywords: "stack_queue常用接口及模拟实现"
categories: ['C']
tags: ['算法', '数据结构', 'C']
artid: "146248238"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146248238
    alt: "stack_queue常用接口及模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146248238
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146248238
cover: https://bing.ee123.net/img/rand?artid=146248238
image: https://bing.ee123.net/img/rand?artid=146248238
img: https://bing.ee123.net/img/rand?artid=146248238
---

# stack\_queue常用接口及模拟实现

---

## 容器适配器

### a.概念

适配器是一种设计模式（设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结），该种模式是将一个类的接口转换成客户希望的另外一个接口

![](https://i-blog.csdnimg.cn/direct/9df4880c395d4910a7384d414be95084.png)

### b.底层结构

STL标准库中stack和queue的底层结构

虽然stack和queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为stack和队列只是对其他容器的接口进行了包装，STL中stack和queue默认使用deque，比如：

![](https://i-blog.csdnimg.cn/direct/e674feb3af3449d382baf01454c51645.png)

### c.deque

#### ① 原理

deque(双端队列)：是一种双开口的"连续"空间的数据结构，双开口的含义是：可以在头尾两端进行插入和删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高

![](https://i-blog.csdnimg.cn/direct/ec8006140e964b1bbed19f50177fd186.png)

deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成的，实际deque类似于一个动态的二维数组，其底层结构如下图所示：

![](https://i-blog.csdnimg.cn/direct/bbf48c723f6045b8822c4a1f00b8dcd6.png)

双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂，如下图所示：

![](https://i-blog.csdnimg.cn/direct/281c4eea840b48a498deed38f956c852.png)

迭代器遍历的实现

![](https://i-blog.csdnimg.cn/direct/6d3a72825d9540f6ad3d2fe15b5f73c9.png)

#### 

#### ② 缺陷

与vector比较，deque的优势是：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的

与list比较，deque底层是连续空间，空间利用率比较高，不需要存储额外字段

deque有一个致命缺陷：不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率较低

### d.底层默认容器

stack是一种后进先出的特殊线性数据结构，因此只要具有push\_back()和pop\_back()操作的线性结构，都可以作为stack的底层容器，比如vector和list都可以；queue是先进先出的特殊线性数据结构，只要具有push\_back和pop\_front操作的线性结构，都可以作为queue的底层容器，比如list

STL中对stack和queue默认选择deque作为其底层容器，主要是因为：

> **① stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。**
>
> **② 在stack中元素增长时，deque比vector的效率高(扩容时不需要搬移大量数据)；queue中的元素增长时，deque不仅效率高，而且内存使用率高**

## stack

### a.基础构造

栈是一种特殊的线性表，它遵循“后进先出”（Last In First Out，LIFO）的原则，具有压栈和弹栈两种基本操作

![](https://i-blog.csdnimg.cn/direct/a0588bc06b3846e6811ceadb5144257e.png)

### 

### b.常用接口

大家可以配合C++官网的介绍来看下面的内容

[stack - C++ Reference](https://legacy.cplusplus.com/reference/stack/stack/ "stack - C++ Reference")

| 函数名称 | 功能说明 |
| --- | --- |
| stack() | 构造空的栈 |
| empty() | 检测stack是否为空 |
| size() | 返回stack中元素的个数 |
| top() | 返回栈顶元素的引用 |
| push() | 将元素val压入stack中 |
| pop() | 将stack中尾部的元素弹出 |

### c.模拟实现

```cpp
// 除 deque 以外，也可以复用 vector
#include<deque>

namespace tianci
{
	template<class T, class Container = deque<T>>
	class stack
	{
	public:
		void push(const T& x)
		{
			_con.push_back(x);
		}

		void pop()
		{
			_con.pop_back();
		}

		const T& top()const
		{
			return _con.back();
		}

		size_t size()const
		{
			return _con.size();
		}

		bool empty()
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}
```

## queue

### a.基础构造

队列是一种遵循“先进先出”（First In First Out，FIFO）原则的线性数据结构。与栈不同，队列允许在一端插入元素（入队），而在另一端删除元素（出队）

![](https://i-blog.csdnimg.cn/direct/32f241d5f95a4fecb0e1221246e2b877.png)

### b.常用接口

大家可以配合C++官网的介绍来看下面的内容

[queue - C++ Reference](https://legacy.cplusplus.com/reference/queue/queue/ "queue - C++ Reference")

| 函数名称 | 功能说明 |
| --- | --- |
| queue() | 构造空的队列 |
| empty() | 检测队列是否为空，是返回true，否则返回false |
| size() | 返回队列中有效元素的个数 |
| front() | 返回队头元素的引用 |
| back() | 返回队尾元素的引用 |
| push() | 在队尾将元素val入队列 |
| pop() | 将队头元素出队列 |

### c.模拟实现

```cpp
// 除 deque 以外，也可以复用 list
#include <deque>

namespace tianci
{
	template<class T, class Container = deque<T>>
	class queue
	{
	public:
		void push(const T& x)
		{
			_con.push_back(x);
		}

		void pop()
		{
			_con.pop_front();
		}

		const T& front()
		{
			return _con.front();
		}

		const T& back()
		{
			return _con.back();
		}

		size_t size()const
		{
			return _con.size();
		}

		bool empty()const
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}
```

## priority\_queue

### a.基础构造

priority\_queue是一种基于容器适配器的优先队列数据结构，类似于堆，并且默认是大堆

priority\_queue默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority\_queue可以考虑使用在需要堆的问题中

（关于堆算法，大家可以看看我数据结构里的堆的实现这篇文章，里面有详细的介绍）

### b.常用接口

大家可以配合C++官网的介绍来看下面的内容

[priority\_queue - C++ Reference](https://legacy.cplusplus.com/reference/queue/priority_queue/ "priority_queue - C++ Reference")

| 函数名称 | 功能说明 |
| --- | --- |
| priority\_queue()/priority\_queue(first, last) | 构造一个空的优先级队列 |
| empty( ) | 检测优先级队列是否为空，是返回true，否则返回false |
| top( ) | 返回优先级队列中最大(最小元素)，即堆顶元素 |
| push(x) | 在优先级队列中插入元素x |
| pop() | 删除优先级队列中最大(最小)元素，即堆顶元素 |

#### ① less & greater

关于priority\_queue的使用还有一个点，就是选择大堆or小堆

C++中 less 和 greater 是用来专门比较大小的类

![](https://i-blog.csdnimg.cn/direct/03c2620080da402fbcb8745a32c2f2e8.png)

#### ② 使用方法

![](https://i-blog.csdnimg.cn/direct/096a039daa6042aa8ac2de5877206cc0.png)

大家需要注意的是，greater对应的是小堆，less对应的是大堆，这里设计的有点奇怪

### c.模拟实现

对于priority\_queue的模拟实现相对麻烦一点，因为涉及到堆算法和模版的使用

（大家可以先看看我另外两篇文章，堆的实现和模版，里面有介绍堆算法以及模版的一些知识点，再来看模拟实现会理解的通透一点）

```cpp
#include<vector>

namespace tianci
{
	template <class T>
	struct less
	{
		bool operator() (const T& x, const T& y) const
		{
			return x < y;
		}
	};

	template <class T>
	struct greater
	{
		bool operator() (const T& x, const T& y) const
		{
			return x > y;
		}
	};


	template<class T, class Container = vector<T>, class Compare = less<int>>
	class priority_queue
	{
	public:

		// 强制生成
		priority_queue() = default;

		template <class InputIterator>
		priority_queue(InputIterator first, InputIterator last)
			:_con(first, last)
		{
			// 建堆
			for (int i = (_con.size() - 1 - 1) / 2; i >= 0; i--)
			{
				AdjustDown(i);
			}
		}

		void Adjustup(size_t child)
		{
			Compare com;

			size_t parent = (child - 1) / 2;
			
			while (child > 0)
			{
				//if (_con[parent] < _con[child])
				if (com(_con[parent], _con[child]))
				{
					swap(_con[child], _con[parent]);
					child = parent;
					parent = (child - 1) / 2;
				}
				else
				{
					break;
				}
			}
		}

		void push(const T& x)
		{
			_con.push_back(x);
			Adjustup(_con.size() - 1);
		}

		void Adjustdown(size_t parent)
		{
			Compare com;

			size_t child = parent * 2 + 1;

			while (child < _con.size())
			{
				//if (child + 1 < _con.size() && _con[child] < _con[child + 1])
				if (child + 1 < _con.size() && com(_con[child], _con[child + 1]))
				{
					++child;
				}

				//if (_con[parent] < _con[child])
				if(com(_con[parent], _con[child]))
				{
					swap(_con[child], _con[parent]);
					parent = child;
					child = parent * 2 + 1;
				}
				else
				{
					break;
				}
			}
		}

		void pop()
		{
			swap(_con[0], _con[_con.size() - 1]);
			_con.pop_back();
			Adjustdown(0);
		}
		
		size_t size()const
		{
			return _con.size();
		}

		const T& top()
		{
			return _con[0];
		}

		bool empty()const
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}
```

本篇文章到这里就结束啦，希望这些内容对大家有所帮助！

下篇文章见，希望大家多多来支持一下！

感谢大家的三连支持！