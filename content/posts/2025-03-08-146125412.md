---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f6c756f67616e747463632f:61727469636c652f64657461696c732f313436313235343132"
layout: post
title: "è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨-ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡éªŒè¯çš„é¡¹ç›®-opentitan"
date: 2025-03-08 23:57:56 +0800
description: "è¿™å‡ å¹´èŠ¯ç‰‡è®¾è®¡è¡Œä¸šåœ¨å›½å†…åƒåè¿‡å±±è½¦ã€‚æ—¶è€Œé«˜äº¢ï¼Œæ—¶è€Œä½æ½®ã€‚æœ€è¿‘åˆå› ä¸ºAIçš„çƒ­æ½®å¼€å§‹highèµ·æ¥ã€‚åˆ°åº•èŠ¯ç‰‡è¡Œä¸šçš„è§„å¾‹æ˜¯å¦‚ä½•ï¼Ÿæˆ‘è°ˆè°ˆè‡ªå·±è§‚ç‚¹ï¼šèŠ¯ç‰‡è®¾è®¡æ˜¯â€œåŠ³åŠ¨å¯†é›†å‹â€è¡Œä¸šã€‚â€œEDAå’Œå·¥å…·é«˜åº¦æ ‡å‡†åŒ–å’Œä»£å·¥å‚çš„å·¥è‰ºæ ‡å‡†åŒ–ä¹‹åï¼ŒèŠ¯ç‰‡è®¾è®¡å°±å˜æˆäº†â€œåŠ³åŠ¨å¯†é›†å‹â€å·¥ä½œï¼Œè¿™ä¹Ÿæ˜¯ç¾å›½å¾ˆé•¿ä¸€æ®µæ—¶é—´å‡ ä¹è¦æ”¾å¼ƒèŠ¯ç‰‡è®¾è®¡è¡Œä¸šçš„æŠ€æœ¯èƒŒæ™¯ã€‚å½“ç„¶ç¾å›½å›½å†…ä¹Ÿæ²¡æœ‰è¿™ä¹ˆå¤šEEå·¥ç¨‹å¸ˆä¾›åº”ã€‚è¦è·Ÿåˆ¶é€ ä¸šä¸€æ ·è½¬ç§»ç»™å…¨çƒå„åœ°ã€‚ä¸€å®¶ä¹‹è¨€ï¼Œå¤§å®¶çœ‹çœ‹ç¬‘ç¬‘å°±å¯ä»¥äº†ã€‚æˆ‘ä»¬å›½å†…èƒŒæ™¯æ˜¯ç ”ç©¶ç”Ÿå¤§é‡æ‰©æ‹›ï¼Œåˆä»€ä¹ˆå­¦ç¡•/ä¸“ç¡•ã€å…¨æ—¥/éå…¨ï¼Œå“ç§å¾ˆé½ã€‚"
keywords: "è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨ ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡ã€éªŒè¯çš„é¡¹ç›® opentitan"
categories: ['æ•°å­—ç”µè·¯']
tags: ['æ¶æ„', 'äººå·¥æ™ºèƒ½', 'Fpga']
artid: "146125412"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146125412
    alt: "è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨-ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡éªŒè¯çš„é¡¹ç›®-opentitan"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146125412
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146125412
cover: https://bing.ee123.net/img/rand?artid=146125412
image: https://bing.ee123.net/img/rand?artid=146125412
img: https://bing.ee123.net/img/rand?artid=146125412
---

# è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨ ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡ã€éªŒè¯çš„é¡¹ç›® opentitan

### å‰è¨€

è¿™å‡ å¹´èŠ¯ç‰‡è®¾è®¡è¡Œä¸šåœ¨å›½å†…åƒåè¿‡å±±è½¦ã€‚æ—¶è€Œé«˜äº¢ï¼Œæ—¶è€Œä½æ½®ã€‚æœ€è¿‘åˆå› ä¸ºAIçš„çƒ­æ½®å¼€å§‹highèµ·æ¥ã€‚åˆ°åº•èŠ¯ç‰‡è¡Œä¸šçš„è§„å¾‹æ˜¯å¦‚ä½•ï¼Ÿ

æˆ‘è°ˆè°ˆè‡ªå·±è§‚ç‚¹ï¼šèŠ¯ç‰‡è®¾è®¡æ˜¯â€œåŠ³åŠ¨å¯†é›†å‹â€è¡Œä¸šã€‚

**â€œEDAå’Œå·¥å…·é«˜åº¦æ ‡å‡†åŒ–å’Œä»£å·¥å‚çš„å·¥è‰ºæ ‡å‡†åŒ–ä¹‹åï¼ŒèŠ¯ç‰‡è®¾è®¡å°±å˜æˆäº†â€œåŠ³åŠ¨å¯†é›†å‹â€å·¥ä½œï¼Œè¿™ä¹Ÿæ˜¯ç¾å›½å¾ˆé•¿ä¸€æ®µæ—¶é—´å‡ ä¹è¦æ”¾å¼ƒèŠ¯ç‰‡è®¾è®¡è¡Œä¸šçš„æŠ€æœ¯èƒŒæ™¯ã€‚å½“ç„¶ç¾å›½å›½å†…ä¹Ÿæ²¡æœ‰è¿™ä¹ˆå¤šEEå·¥ç¨‹å¸ˆä¾›åº”ã€‚è¦è·Ÿåˆ¶é€ ä¸šä¸€æ ·è½¬ç§»ç»™å…¨çƒå„åœ°ã€‚â€**

ä¸€å®¶ä¹‹è¨€ï¼Œå¤§å®¶çœ‹çœ‹ç¬‘ç¬‘å°±å¯ä»¥äº†ã€‚

æˆ‘ä»¬å›½å†…èƒŒæ™¯æ˜¯ç ”ç©¶ç”Ÿå¤§é‡æ‰©æ‹›ï¼Œåˆä»€ä¹ˆå­¦ç¡•/ä¸“ç¡•ã€å…¨æ—¥/éå…¨ï¼Œå“ç§å¾ˆé½ã€‚

å›½å¤–ç ”ç©¶ç”Ÿã€ç¾å›½ã€æ¬§æ´²ç¡•å£«é˜¶æ®µéƒ½æ˜¯æˆè¯¾å‹æ•™è‚²ï¼Œå¤šå¤šç›Šå–„ã€‚å›½å†…ç°åœ¨ä¹Ÿæ˜¯ã€‚

è¿™ç»™ç ”ç©¶ç”Ÿé—¨å¾ˆå¤§å›°æƒ‘ã€‚

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ
**ç¼ºé¡¹ç›®å®è·µã€‚**

**1 æˆ‘ä¸€è´¯çš„è§‚ç‚¹æ˜¯è®¾è®¡èŠ¯ç‰‡å’ŒFPGAæ˜¯ä¸€ä¸ªæŠ€æœ¯ï¼Œå¸Œæœ›FPGAå­¦ä¹ è€…ä¹Ÿå…³æ³¨è¿™æ–¹é¢æŠ€æœ¯ã€‚**

**2 AIæ—¶ä»£å…¥é—¨èŠ¯ç‰‡è®¾è®¡è¦å…ˆå­¦å¥½è®¾è®¡å’ŒéªŒè¯ï¼Œåœ¨å­¦ä¹ æ¶æ„è®¾è®¡**

æ‰€ä»¥ï¼Œæœ¬äººå°è¯•åœ¨çŸ¥ä¹å¼€è¿™ä¸ªæ ç›®ï¼Œæä¾›ä¸€äº›ç¨å¾®å®æˆ˜é¡¹ç›®ã€‚ä¸€æ–¹é¢è®²è§£ã€ä¸€æ–¹é¢è·Ÿå„ä½äº’åŠ¨ã€‚

æ— è®ºæ˜¯æœ¬ä¸“ä¸šç§‘ç­å­¦ç”Ÿè¿˜æ˜¯éç§‘ç­å­¦ä¹ ï¼Œä¹Ÿæ— è®ºæ˜¯ä½ å·²ç»å°±ä¸šæƒ³è½¬è¡Œï¼Œéƒ½å¯ä»¥å‚è€ƒä¸Šé¢çš„é¡¹ç›®æ¥å­¦ä¹ ã€‚

ç½‘ä¸Šæœ‰opentitanæœ‰ä»‹ç»ï¼Œè®©æˆ‘æ¥åšç¬¬ä¸€äººï¼Œæ¥è¯¦ç»†ä»‹ç»è¿™ä¸ªé¡¹ç›®å¦‚ä½•å­¦ä¹ å’Œåƒä¸‹æ¥ã€‚

### èŠ¯ç‰‡è®¾è®¡ã€éªŒè¯ä¸€ä½“åŒ–é¡¹ç›®opentitanå­¦ä¹ 

å…³äºèŠ¯ç‰‡è®¾è®¡ã€éªŒè¯çš„å…¥é—¨å­¦ä¹ ä¹¦ç±ã€ä»¥åŠä¸€äº›å°ç»ƒä¹ ç½‘ä¸Šæœ‰å¾ˆå¤šä¹¦ç±ã€è§†é¢‘ã€ä¹Ÿæœ‰åŸ¹è®­å…¬å¸åœ¨åšè¿™æ–¹é¢å·¥ä½œã€‚æ„Ÿè°¢ä»–ä»¬åœ¨ç›®å‰ä¸­å›½èŠ¯ç‰‡è¡Œä¸šæ€¥éœ€å·¥ç¨‹å¸ˆèƒŒæ™¯ä¸‹æ‰€åšçš„åŠªåŠ›ã€‚ç½‘ä¸ŠåšèŠ¯ç‰‡éªŒè¯åŸ¹è®­çš„è·¯ç§‘ï¼Œæˆ‘å°±è§‰å¾—å¾ˆå¥½ã€‚æˆ‘ä»¬å¤§å­¦è¿™æ–¹é¢æ•™å­¦å¤ªç¼ºäº†ã€‚

æŒæ¡åŸºç¡€çŸ¥è¯†å¦‚ä½•é€šè¿‡é¡¹ç›®æå‡ï¼Œå¯èƒ½éœ€è¦çš„æ—¶é—´æ›´é•¿ï¼Œä¹Ÿæ›´å›°éš¾ã€‚

opentitanå°±æ˜¯è¿™æ ·ä¸€ä¸ªè®¾è®¡ã€éªŒè¯çš„ç»¼åˆæ€§é¡¹ç›®ã€‚

è™½ç„¶ä»–æ˜¯Googleå…¬å¸è”åˆä¸€äº›åŠå¯¼ä½“å…¬å¸ä»¥
[RISC-V](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=RISC-V&zhida_source=entity)
SOCå’Œå®‰å…¨èŠ¯ç‰‡ä¸ºæ ·æœ¬æ¥æ‰“é€ ï¼Œä½†æ˜¯å®Œå…¨ä¸å½±å“æˆ‘ä»¬æŠŠå®ƒä½œä¸ºæˆ‘ä»¬å…¥é—¨èŠ¯ç‰‡è®¾è®¡å’ŒéªŒè¯åçš„å®æˆ˜é¡¹ç›®ã€‚å¦‚æœè¦æµç‰‡ï¼Œä½ ä¹Ÿå¯ä»¥é‡‡ç”¨openLaneå·¥å…·é“¾æ¥ç”Ÿæˆç‰ˆå›¾ã€‚

#### 1 Opentitané¡¹ç›®ä»‹ç»

[OpenTitan - OpenTitan Documentation

â€‹


opentitan.org/book/doc/introduction.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/introduction.html)

æ‰çœ‹åˆ°è¿™ä¸ªé¡¹ç›®è‚¯å®šä¼šå¾ˆæ‡µï¼Œå°±è®©æˆ‘ä»¬ä¸€ç‚¹ä¸€ç‚¹åƒé€è¿™ä¸ªé¡¹ç›®ã€‚

é™¤äº†åœ¨githubå¼€æºäº†å…¨éƒ¨é¡¹ç›®ä»£ç ä¹‹å¤–ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ–‡æ¡£å­¦ä¹ åˆ°å¾ˆå¤šã€‚

å‰å‡ å¹´å›½å†…æˆç«‹å¤ªå¤šèŠ¯ç‰‡è®¾è®¡å…¬å¸ï¼Œå»ºè®®è¡¥è¯¾ã€‚

#### 2 èŠ¯ç‰‡è®¾è®¡çš„æµç¨‹(å‰ç«¯)

1 è®¾è®¡éªŒè¯

[https://

opentitan.org/book/doc/

getting\_started/setup\_dv.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/setup_dv.html)

2 å½¢å¼éªŒè¯

[https://

opentitan.org/book/doc/

getting\_started/setup\_formal.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/setup_formal.html)

3 åˆ›å»ºæµ‹è¯•è½¯ä»¶ï¼ˆSOCéœ€è¦ï¼‰

[https://

opentitan.org/book/doc/

getting\_started/build\_sw.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/build_sw.html)

4 æ–‡æ¡£åˆ›å»º

[https://

opentitan.org/book/doc/

getting\_started/build\_docs.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/build_docs.html)

5 FPGA éªŒè¯

[https://

opentitan.org/book/doc/

getting\_started/using\_openocd.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/using_openocd.html)

#### 3 OpentitanèŠ¯ç‰‡çš„è®¾è®¡éªŒè¯

æœ¬ç¯‡æ–‡ç« å°±æš‚æ—¶ä»è¿™æ¬¾RISC-VèŠ¯ç‰‡çš„è®¾è®¡å’ŒéªŒè¯å¼€å§‹ï¼Œçœ‹çœ‹æˆ‘ä»¬æ”¹å¦‚ä½•å­¦ä¹ å’Œä¸‹æ‰‹è¿™ä¸ªé¡¹ç›®ã€‚

ç®€å•æ¥è®²ï¼ŒSOCèŠ¯ç‰‡å°±æ˜¯ CPU coreå’Œ å¤–å›´ç”µè·¯ åŠ  æ€»çº¿ è¿æ¥èµ·æ¥çš„åŠŸèƒ½æ¨¡å—ã€‚

å…ˆçœ‹çœ‹æ•´ä½“æ¨¡å—æ„æˆ

![](https://i-blog.csdnimg.cn/img_convert/8422526580c363bb4f12f501217a9500.jpeg)

opentitanæ•´ä½“æ¨¡å—æ„æˆ

å¯è§ è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„SOCèŠ¯ç‰‡ã€‚ è¿˜æ¯”è¾ƒå¤æ‚ï¼Œè·Ÿå•†ä¸šèŠ¯ç‰‡ä¸šå·®ä¸äº†å¤ªå¤šã€‚

æŒ‡ä»¤é›†æ”¯æŒRV32IMCBï¼ˆ32ä½æ•´æ•°æŒ‡ä»¤é›† M æ•´å‹ä¹˜é™¤æ³•æ‰©å±• C å‹ç¼©æŒ‡ä»¤é›†æ‰©å±• B ä½æ“ä½œæ‰©å±• ï¼‰å¤§æ¦‚ç›¸å½“äºARM cortex-M3çš„æ°´å¹³å§ã€‚

å…³äºcoreçœ‹è¿™ä¸ªæ–‡æ¡£ï¼š

[https://ibex-core.readthedocs.io/en/latest/01\_overview/index.html

â€‹


ibex-core.readthedocs.io/en/latest/01\_overview/index.html](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

[Introduction to Ibex](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

[Introduction to Ibex

â€‹


ibex-core.readthedocs.io/en/latest/01\_overview/index.html](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

æ€»çº¿çœ‹è¿™ä¸ªæ–‡æ¡£ï¼š

[https://sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a\_tilelink-spec-1.7.1.pdf

â€‹


sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a\_tilelink-spec-1.7.1.pdf](https://link.zhihu.com/?target=https%3A//sifive.cdn.prismic.io/sifive%252F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf)

æ˜¯SiFiveå…¬å¸çš„ã€‚å‰å‡ å¹´æ®è¯´INTELè¦æ”¶è´­SiFiveï¼Œæ²¡æœ‰æˆåŠŸã€‚èŠ¯ç‰‡è¡Œä¸šæ±Ÿæ¹–çˆ±æ¨æƒ…ä»‡æ¯å¤©éƒ½åœ¨ä¸Šæ¼”ï¼Œä¸äºšäºç”µè§†è¿ç»­å‰§ã€‚

æˆ‘ç›¸ä¿¡ï¼Œå„ä½è·Ÿå…³æ³¨å¤–å›´æ¨¡å—çš„è®¾è®¡éªŒè¯ï¼Œè¿™æ˜¯å¤§å®¶å…¥è¡Œæœ€å¼€å§‹å¹²çš„å·¥ä½œï¼š

![](https://i-blog.csdnimg.cn/img_convert/e43cdf02a95533c5acec6024beb14e87.jpeg)

#### 4 UART å¤–å›´ç”µè·¯æ¨¡å—çš„è®¾è®¡å’ŒéªŒè¯

![](https://i-blog.csdnimg.cn/img_convert/50f5fff8efa75e2c2d28fc0b763a5651.jpeg)

æœ¬ç¯‡æ–‡ç« å°±ä»¥è¿™ä¸ªæœ€ç®€å•çš„UARTæ¨¡å—è®²è§£ä¸€ä¸‹è®¾è®¡å’ŒéªŒè¯çš„æ¦‚è¿°ï¼Œè¯¦ç»†åœ¨åé¢æ–‡ç« è®²è§£ã€‚ç›®å‰ä½ æš‚æ—¶æ²¡æœ‰system veriloå’ŒUVMåŸºç¡€æš‚æ—¶ä¹Ÿæ²¡å…³ç³»ï¼Œæˆ‘å¸¦ç€ä½ å…ˆå…¥é—¨å†è¯¦ç»†å»å­¦ä¹ è¿™æ–¹é¢çŸ¥è¯†ã€‚

è¿™æ–¹é¢æˆ‘ä¸Šé¢æçš„è·¯ç§‘éªŒè¯å°±å¯ä»¥ã€‚

è®¾è®¡ï¼š

ä¸€èˆ¬èŠ¯ç‰‡é‡‡ç”¨çš„verilogã€‚è¿™ä¸ªé¡¹ç›®é‡‡ç”¨çš„æ˜¯
[system verilog](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=system+verilog&zhida_source=entity)
ä½œä¸ºè®¾è®¡è¯­è¨€ï¼Œä½†æ˜¯ä¹Ÿæœ‰è‡ªå·±çš„è§„èŒƒï¼š

[style-guides/VerilogCodingStyle.md at master Â· lowRISC/style-guides

â€‹


github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md

![](https://i-blog.csdnimg.cn/img_convert/b9e9535de559b82036fd73528cce1aa7.png)](https://link.zhihu.com/?target=https%3A//github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md)

å„ä½åˆ°è‡ªå·±çš„å…¬å¸ä¹Ÿä¼šæœ‰å„ä¸ªå…¬å¸çš„è®¾è®¡è¯­è¨€è§„èŒƒã€‚

```text
A template that demonstrates many of the items is given below.

```

Template:

// Copyright lowRISC contributors.
  
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
  
// SPDX-License-Identifier: Apache-2.0
  
//
  
// One line description of the module

module my\_module #(
  
parameter Width = 80,
  
parameter Height = 24
  
) (
  
input clk\_i,
  
input rst\_ni,
  
input req\_valid\_i,
  
input [Width-1:0] req\_data\_i,
  
output req\_ready\_o,
  
â€¦
  
);

logic [Width-1:0] req\_data\_masked;

submodule u\_submodule (
  
.clk\_i,
  
.rst\_ni,
  
.req\_valid\_i,
  
.req\_data\_i (req\_data\_masked),
  
.req\_ready\_o(req\_ready),
  
â€¦
  
);

always\_comb begin
  
req\_data\_masked = req\_data\_i;
  
case (fsm\_state\_q)
  
ST\_IDLE: begin
  
req\_data\_masked = req\_data\_i & MASK\_IDLE;
  
â€¦
  
end

â€¦

endmodule

å¦å¤– é«˜åº¦ä¾èµ–
[Linting](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=Linting&zhida_source=entity)

#### â€œLinting is a productivity tool for designers to quickly find typos and bugs at the time when the RTL is written. Running lint is important when using SystemVerilog, a weakly-typed language, unlike other hardware description languages. We consider linting to be critical for conformance to our goals of high quality designsâ€

å› ä¸ºsystem verilogå†™èµ·çˆ½ï¼Œå¯èƒ½å…¶ä»–å·¥å…·å°±è¦è·Ÿä¸Šã€‚

#### 5 UARTåŠŸèƒ½æ¡†å›¾å’Œä»£ç 

![](https://i-blog.csdnimg.cn/img_convert/1002f7673d4e7ca1355d011bfe35ccfa.jpeg)

UARTåŠŸèƒ½æ¡†å›¾

#### 5.1 uartæ¨¡å—çš„TOP

```text
// Copyright lowRISC contributors.  

// Licensed under the Apache License, Version 2.0, see LICENSE for details.  

// SPDX-License-Identifier: Apache-2.0  

//  

// Description: UART top level wrapper file

```

`include â€œprim\_assert.svâ€

module uart
  
import uart\_reg\_pkg:ğŸ˜—;
  
#(
  
parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1â€™b1}}
  
) (
  
input clk\_i,
  
input rst\_ni,

// Bus Interface
  
input tlul\_pkg::tl\_h2d\_t tl\_i,
  
output tlul\_pkg::tl\_d2h\_t tl\_o,

// Alerts
  
input prim\_alert\_pkg::alert\_rx\_t [NumAlerts-1:0] alert\_rx\_i,
  
output prim\_alert\_pkg::alert\_tx\_t [NumAlerts-1:0] alert\_tx\_o,

// Generic IO
  
input cio\_rx\_i,
  
output logic cio\_tx\_o,
  
output logic cio\_tx\_en\_o,

// Interrupts
  
output logic intr\_tx\_watermark\_o ,
  
output logic intr\_rx\_watermark\_o ,
  
output logic intr\_tx\_empty\_o ,
  
output logic intr\_rx\_overflow\_o ,
  
output logic intr\_rx\_frame\_err\_o ,
  
output logic intr\_rx\_break\_err\_o ,
  
output logic intr\_rx\_timeout\_o ,
  
output logic intr\_rx\_parity\_err\_o
  
);

logic [NumAlerts-1:0] alert\_test, alerts;
  
uart\_reg2hw\_t reg2hw;
  
uart\_hw2reg\_t hw2reg;

uart\_reg\_top u\_reg (
  
.clk\_i,
  
.rst\_ni,
  
.tl\_i,
  
.tl\_o,
  
.reg2hw,
  
.hw2reg,
  
// SEC\_CM: BUS.INTEGRITY
  
.intg\_err\_o (alerts[0]),
  
.devmode\_i (1â€™b1)
  
);

uart\_core uart\_core (
  
.clk\_i,
  
.rst\_ni,
  
.reg2hw,
  
.hw2reg,

```
.rx    (cio_rx_i   ),
.tx    (cio_tx_o   ),

.intr_tx_watermark_o,
.intr_rx_watermark_o,
.intr_tx_empty_o,
.intr_rx_overflow_o,
.intr_rx_frame_err_o,
.intr_rx_break_err_o,
.intr_rx_timeout_o,
.intr_rx_parity_err_o

```

);

// Alerts
  
assign alert\_test = {
  
reg2hw.alert\_test.q &
  
reg2hw.alert\_test.qe
  
};

for (genvar i = 0; i < NumAlerts; i++) begin : gen\_alert\_tx
  
prim\_alert\_sender #(
  
.AsyncOn(AlertAsyncOn[i]),
  
.IsFatal(1â€™b1)
  
) u\_prim\_alert\_sender (
  
.clk\_i,
  
.rst\_ni,
  
.alert\_test\_i ( alert\_test[i] ),
  
.alert\_req\_i ( alerts[0] ),
  
.alert\_ack\_o ( ),
  
.alert\_state\_o ( ),
  
.alert\_rx\_i ( alert\_rx\_i[i] ),
  
.alert\_tx\_o ( alert\_tx\_o[i] )
  
);
  
end

// always enable the driving out of TX
  
assign cio\_tx\_en\_o = 1â€™b1;

// Assert Known for outputs
  
`ASSERT(TxEnIsOne_A, cio_tx_en_o === 1'b1)`
ASSERT\_KNOWN(TxKnown\_A, cio\_tx\_o, clk\_i, !rst\_ni || !cio\_tx\_en\_o)

// Assert Known for alerts
  
`ASSERT\_KNOWN(AlertsKnown\_A, alert\_tx\_o)

// Assert Known for interrupts
  
`ASSERT_KNOWN(TxWatermarkKnown_A, intr_tx_watermark_o)`
ASSERT\_KNOWN(RxWatermarkKnown\_A, intr\_rx\_watermark\_o)
  
`ASSERT_KNOWN(TxEmptyKnown_A, intr_tx_empty_o)`
ASSERT\_KNOWN(RxOverflowKnown\_A, intr\_rx\_overflow\_o)
  
`ASSERT_KNOWN(RxFrameErrKnown_A, intr_rx_frame_err_o)`
ASSERT\_KNOWN(RxBreakErrKnown\_A, intr\_rx\_break\_err\_o)
  
`ASSERT_KNOWN(RxTimeoutKnown_A, intr_rx_timeout_o)`
ASSERT\_KNOWN(RxParityErrKnown\_A, intr\_rx\_parity\_err\_o)

// Alert assertions for reg\_we onehot check
  
`ASSERT\_PRIM\_REG\_WE\_ONEHOT\_ERROR\_TRIGGER\_ALERT(RegWeOnehotCheck\_A, u\_reg, alert\_tx\_o[0])
  
endmodule

ä»£ç ä¸‹é¢æ˜¯ç”¨äºå½¢å¼éªŒè¯ï¼Œæš‚æ—¶ä¸ç®¡ï¼Œå¯è§æ ¸å¿ƒæ˜¯uart\_core:

å…¶ä¸­.reg2hw .hw2reg

```text
  // Register -> HW type  

typedef struct packed {  

uart_reg2hw_intr_state_reg_t intr_state; // [126:119]  

uart_reg2hw_intr_enable_reg_t intr_enable; // [118:111]  

uart_reg2hw_intr_test_reg_t intr_test; // [110:95]  

uart_reg2hw_alert_test_reg_t alert_test; // [94:93]  

uart_reg2hw_ctrl_reg_t ctrl; // [92:68]  

uart_reg2hw_status_reg_t status; // [67:56]  

uart_reg2hw_rdata_reg_t rdata; // [55:47]  

uart_reg2hw_wdata_reg_t wdata; // [46:38]  

uart_reg2hw_fifo_ctrl_reg_t fifo_ctrl; // [37:27]  

uart_reg2hw_ovrd_reg_t ovrd; // [26:25]  

uart_reg2hw_timeout_ctrl_reg_t timeout_ctrl; // [24:0]  

} uart_reg2hw_t;  


```

```text
  // HW -> register type  

typedef struct packed {  

uart_hw2reg_intr_state_reg_t intr_state; // [64:49]  

uart_hw2reg_status_reg_t status; // [48:43]  

uart_hw2reg_rdata_reg_t rdata; // [42:35]  

uart_hw2reg_fifo_ctrl_reg_t fifo_ctrl; // [34:28]  

uart_hw2reg_fifo_status_reg_t fifo_status; // [27:16]  

uart_hw2reg_val_reg_t val; // [15:0]  

} uart_hw2reg_t;  


```

hwå°±æ˜¯æˆ‘ä»¬UARTçš„ç¡¬ä»¶å®ç°äº‹å®œå«hwã€‚

åŠç¡¬ä»¶ç”µè·¯ä¸å¯„å­˜å™¨ä¹‹é—´çš„å…³ç³»

#### 5.2 coreä»£ç 

```text
module uart_core (  

input                  clk_i,  

input                  rst_ni,

```

input uart\_reg\_pkg::uart\_reg2hw\_t reg2hw,
  
output uart\_reg\_pkg::uart\_hw2reg\_t hw2reg,

input rx,
  
output logic tx,

output logic intr\_tx\_watermark\_o,
  
output logic intr\_rx\_watermark\_o,
  
output logic intr\_tx\_empty\_o,
  
output logic intr\_rx\_overflow\_o,
  
output logic intr\_rx\_frame\_err\_o,
  
output logic intr\_rx\_break\_err\_o,
  
output logic intr\_rx\_timeout\_o,
  
output logic intr\_rx\_parity\_err\_o
  
);

import uart\_reg\_pkg:ğŸ˜—;

localparam int NcoWidth = $bits(reg2hw.ctrl.nco.q);

logic [15:0] rx\_val\_q;
  
logic [7:0] uart\_rdata;
  
logic tick\_baud\_x16, rx\_tick\_baud;
  
logic [5:0] tx\_fifo\_depth, rx\_fifo\_depth;
  
logic [5:0] rx\_fifo\_depth\_prev\_q;
  
logic [23:0] rx\_timeout\_count\_d, rx\_timeout\_count\_q, uart\_rxto\_val;
  
logic rx\_fifo\_depth\_changed, uart\_rxto\_en;
  
logic tx\_enable, rx\_enable;
  
logic sys\_loopback, line\_loopback, rxnf\_enable;
  
logic uart\_fifo\_rxrst, uart\_fifo\_txrst;
  
logic [2:0] uart\_fifo\_rxilvl;
  
logic [1:0] uart\_fifo\_txilvl;
  
logic ovrd\_tx\_en, ovrd\_tx\_val;
  
logic [7:0] tx\_fifo\_data;
  
logic tx\_fifo\_rready, tx\_fifo\_rvalid;
  
logic tx\_fifo\_wready, tx\_uart\_idle;
  
logic tx\_out;
  
logic tx\_out\_q;
  
logic [7:0] rx\_fifo\_data;
  
logic rx\_valid, rx\_fifo\_wvalid, rx\_fifo\_rvalid;
  
logic rx\_fifo\_wready, rx\_uart\_idle;
  
logic rx\_sync;
  
logic rx\_in;
  
logic break\_err;
  
logic [4:0] allzero\_cnt\_d, allzero\_cnt\_q;
  
logic allzero\_err, not\_allzero\_char;
  
logic event\_tx\_watermark, event\_rx\_watermark, event\_tx\_empty, event\_rx\_overflow;
  
logic event\_rx\_frame\_err, event\_rx\_break\_err, event\_rx\_timeout, event\_rx\_parity\_err;
  
logic tx\_watermark\_d, tx\_watermark\_prev\_q;
  
logic rx\_watermark\_d, rx\_watermark\_prev\_q;
  
logic tx\_uart\_idle\_q;

assign tx\_enable = reg2hw.ctrl.tx.q;
  
assign rx\_enable = reg2hw.ctrl.rx.q;
  
assign rxnf\_enable = reg2hw.ctrl.nf.q;
  
assign sys\_loopback = reg2hw.ctrl.slpbk.q;
  
assign line\_loopback = reg2hw.ctrl.llpbk.q;

assign uart\_fifo\_rxrst = reg2hw.fifo\_ctrl.rxrst.q & reg2hw.fifo\_ctrl.rxrst.qe;
  
assign uart\_fifo\_txrst = reg2hw.fifo\_ctrl.txrst.q & reg2hw.fifo\_ctrl.txrst.qe;
  
assign uart\_fifo\_rxilvl = reg2hw.fifo\_ctrl.rxilvl.q;
  
assign uart\_fifo\_txilvl = reg2hw.fifo\_ctrl.txilvl.q;

assign ovrd\_tx\_en = reg2hw.ovrd.txen.q;
  
assign ovrd\_tx\_val = reg2hw.ovrd.txval.q;

typedef enum logic {
  
BRK\_CHK,
  
BRK\_WAIT
  
} break\_st\_e ;

break\_st\_e break\_st\_q;

assign not\_allzero\_char = rx\_valid & (~event\_rx\_frame\_err | (rx\_fifo\_data != 8â€™h0));
  
assign allzero\_err = event\_rx\_frame\_err & (rx\_fifo\_data == 8â€™h0);

assign allzero\_cnt\_d = (break\_st\_q == BRK\_WAIT || not\_allzero\_char) ? 5â€™h0 :
  
//allzero\_cnt\_q[4] never be 1b without break\_st\_q as BRK\_WAIT
  
//allzero\_cnt\_q[4] ? allzero\_cnt\_q :
  
allzero\_err ? allzero\_cnt\_q + 5â€™d1 :
  
allzero\_cnt\_q;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) allzero\_cnt\_q <= '0;
  
else if (rx\_enable) allzero\_cnt\_q <= allzero\_cnt\_d;
  
end

// break\_err edges in same cycle as event\_rx\_frame\_err edges ; that way the
  
// reset-on-read works the same way for break and frame error interrupts.

always\_comb begin
  
unique case (reg2hw.ctrl.rxblvl.q)
  
2â€™h0: break\_err = allzero\_cnt\_d >= 5â€™d2;
  
2â€™h1: break\_err = allzero\_cnt\_d >= 5â€™d4;
  
2â€™h2: break\_err = allzero\_cnt\_d >= 5â€™d8;
  
default: break\_err = allzero\_cnt\_d >= 5â€™d16;
  
endcase
  
end

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) break\_st\_q <= BRK\_CHK;
  
else begin
  
unique case (break\_st\_q)
  
BRK\_CHK: begin
  
if (event\_rx\_break\_err) break\_st\_q <= BRK\_WAIT;
  
end

```
    BRK_WAIT: begin
      if (rx_in) break_st_q &lt;= BRK_CHK;
    end

    default: begin
      break_st_q &lt;= BRK_CHK;
    end
  endcase
end

```

end

assign hw2reg.val.d = rx\_val\_q;

assign hw2reg.rdata.d = uart\_rdata;

assign hw2reg.status.rxempty.d = ~rx\_fifo\_rvalid;
  
assign hw2reg.status.rxidle.d = rx\_uart\_idle;
  
assign hw2reg.status.txidle.d = tx\_uart\_idle & ~tx\_fifo\_rvalid;
  
assign hw2reg.status.txempty.d = ~tx\_fifo\_rvalid;
  
assign hw2reg.status.rxfull.d = ~rx\_fifo\_wready;
  
assign hw2reg.status.txfull.d = ~tx\_fifo\_wready;

assign hw2reg.fifo\_status.txlvl.d = tx\_fifo\_depth;
  
assign hw2reg.fifo\_status.rxlvl.d = rx\_fifo\_depth;

// resets are self-clearing, so need to update FIFO\_CTRL
  
assign hw2reg.fifo\_ctrl.rxilvl.de = 1â€™b0;
  
assign hw2reg.fifo\_ctrl.rxilvl.d = 3â€™h0;
  
assign hw2reg.fifo\_ctrl.txilvl.de = 1â€™b0;
  
assign hw2reg.fifo\_ctrl.txilvl.d = 2â€™h0;

// NCO 16x Baud Generator
  
// output clock rate is:
  
// Fin \* (NCO/2\*\*NcoWidth)
  
logic [NcoWidth:0] nco\_sum\_q; // extra bit to get the carry

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
nco\_sum\_q <= 17â€™h0;
  
end else if (tx\_enable || rx\_enable) begin
  
nco\_sum\_q <= {1â€™b0,nco\_sum\_q[NcoWidth-1:0]} + {1â€™b0,reg2hw.ctrl.nco.q[NcoWidth-1:0]};
  
end
  
end

assign tick\_baud\_x16 = nco\_sum\_q[16];

//
  
// TX Logic //
  
//

assign tx\_fifo\_rready = tx\_uart\_idle & tx\_fifo\_rvalid & tx\_enable;

prim\_fifo\_sync #(
  
.Width (8),
  
.Pass (1â€™b0),
  
.Depth (32)
  
) u\_uart\_txfifo (
  
.clk\_i,
  
.rst\_ni,
  
.clr\_i (uart\_fifo\_txrst),
  
.wvalid\_i(reg2hw.wdata.qe),
  
.wready\_o(tx\_fifo\_wready),
  
.wdata\_i (reg2hw.wdata.q),
  
.depth\_o (tx\_fifo\_depth),
  
.full\_o (),
  
.rvalid\_o(tx\_fifo\_rvalid),
  
.rready\_i(tx\_fifo\_rready),
  
.rdata\_o (tx\_fifo\_data),
  
.err\_o ()
  
);

uart\_tx uart\_tx (
  
.clk\_i,
  
.rst\_ni,
  
.tx\_enable,
  
.tick\_baud\_x16,
  
.parity\_enable (reg2hw.ctrl.parity\_en.q),
  
.wr (tx\_fifo\_rready),
  
.wr\_parity ((^tx\_fifo\_data) ^ reg2hw.ctrl.parity\_odd.q),
  
.wr\_data (tx\_fifo\_data),
  
.idle (tx\_uart\_idle),
  
.tx (tx\_out)
  
);

assign tx = line\_loopback ? rx : tx\_out\_q ;
  
always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
tx\_out\_q <= 1â€™b1;
  
end else if (ovrd\_tx\_en) begin
  
tx\_out\_q <= ovrd\_tx\_val ;
  
end else if (sys\_loopback) begin
  
tx\_out\_q <= 1â€™b1;
  
end else begin
  
tx\_out\_q <= tx\_out;
  
end
  
end

//
  
// RX Logic //
  
//

// sync the incoming data
  
prim\_flop\_2sync #(
  
.Width(1),
  
.ResetValue(1â€™b1)
  
) sync\_rx (
  
.clk\_i,
  
.rst\_ni,
  
.d\_i(rx),
  
.q\_o(rx\_sync)
  
);

// Based on: en.wikipedia.org/wiki/Repetition\_code mentions the use of a majority filter
  
// in UART to ignore brief noise spikes
  
logic rx\_sync\_q1, rx\_sync\_q2, rx\_in\_mx, rx\_in\_maj;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
rx\_sync\_q1 <= 1â€™b1;
  
rx\_sync\_q2 <= 1â€™b1;
  
end else begin
  
rx\_sync\_q1 <= rx\_sync;
  
rx\_sync\_q2 <= rx\_sync\_q1;
  
end
  
end

assign rx\_in\_maj = (rx\_sync & rx\_sync\_q1) |
  
(rx\_sync & rx\_sync\_q2) |
  
(rx\_sync\_q1 & rx\_sync\_q2);
  
assign rx\_in\_mx = rxnf\_enable ? rx\_in\_maj : rx\_sync;

assign rx\_in = sys\_loopback ? tx\_out :
  
line\_loopback ? 1â€™b1 :
  
rx\_in\_mx;

uart\_rx uart\_rx (
  
.clk\_i,
  
.rst\_ni,
  
.rx\_enable,
  
.tick\_baud\_x16,
  
.parity\_enable (reg2hw.ctrl.parity\_en.q),
  
.parity\_odd (reg2hw.ctrl.parity\_odd.q),
  
.tick\_baud (rx\_tick\_baud),
  
.rx\_valid,
  
.rx\_data (rx\_fifo\_data),
  
.idle (rx\_uart\_idle),
  
.frame\_err (event\_rx\_frame\_err),
  
.rx (rx\_in),
  
.rx\_parity\_err (event\_rx\_parity\_err)
  
);

assign rx\_fifo\_wvalid = rx\_valid & ~event\_rx\_frame\_err & ~event\_rx\_parity\_err;

prim\_fifo\_sync #(
  
.Width (8),
  
.Pass (1â€™b0),
  
.Depth (32)
  
) u\_uart\_rxfifo (
  
.clk\_i,
  
.rst\_ni,
  
.clr\_i (uart\_fifo\_rxrst),
  
.wvalid\_i(rx\_fifo\_wvalid),
  
.wready\_o(rx\_fifo\_wready),
  
.wdata\_i (rx\_fifo\_data),
  
.depth\_o (rx\_fifo\_depth),
  
.full\_o (),
  
.rvalid\_o(rx\_fifo\_rvalid),
  
.rready\_i(reg2hw.rdata.re),
  
.rdata\_o (uart\_rdata),
  
.err\_o ()
  
);

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) rx\_val\_q <= 16â€™h0;
  
else if (tick\_baud\_x16) rx\_val\_q <= {rx\_val\_q[14:0], rx\_in};
  
end

// Interrupt & Status //

always\_comb begin
  
unique case(uart\_fifo\_txilvl)
  
2â€™h0: tx\_watermark\_d = (tx\_fifo\_depth < 6â€™d2);
  
2â€™h1: tx\_watermark\_d = (tx\_fifo\_depth < 6â€™d4);
  
2â€™h2: tx\_watermark\_d = (tx\_fifo\_depth < 6â€™d8);
  
default: tx\_watermark\_d = (tx\_fifo\_depth < 6â€™d16);
  
endcase
  
end

assign event\_tx\_watermark = tx\_watermark\_d & ~tx\_watermark\_prev\_q;

// The empty condition handling is a bit different.
  
// If empty rising conditions were detected directly, then every first write of a burst
  
// would trigger an empty. This is due to the fact that the uart\_tx fsm immediately
  
// withdraws the content and asserts â€œemptyâ€.
  
// To guard against this false trigger, empty is qualified with idle to extend the window
  
// in which software has an opportunity to deposit new data.
  
// However, if software deposit speed is TOO slow, this would still be an issue.
  
//
  
// The alternative software fix is to disable tx\_enable until it has a chance to
  
// burst in the desired amount of data.
  
assign event\_tx\_empty = ~tx\_fifo\_rvalid & ~tx\_uart\_idle\_q & tx\_uart\_idle;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
tx\_watermark\_prev\_q <= 1â€™b1; // by default watermark condition is true
  
rx\_watermark\_prev\_q <= 1â€™b0; // by default watermark condition is false
  
tx\_uart\_idle\_q <= 1â€™b1;
  
end else begin
  
tx\_watermark\_prev\_q <= tx\_watermark\_d;
  
rx\_watermark\_prev\_q <= rx\_watermark\_d;
  
tx\_uart\_idle\_q <= tx\_uart\_idle;
  
end
  
end

always\_comb begin
  
unique case(uart\_fifo\_rxilvl)
  
3â€™h0: rx\_watermark\_d = (rx\_fifo\_depth >= 6â€™d1);
  
3â€™h1: rx\_watermark\_d = (rx\_fifo\_depth >= 6â€™d4);
  
3â€™h2: rx\_watermark\_d = (rx\_fifo\_depth >= 6â€™d8);
  
3â€™h3: rx\_watermark\_d = (rx\_fifo\_depth >= 6â€™d16);
  
3â€™h4: rx\_watermark\_d = (rx\_fifo\_depth >= 6â€™d30);
  
default: rx\_watermark\_d = 1â€™b0;
  
endcase
  
end

assign event\_rx\_watermark = rx\_watermark\_d & ~rx\_watermark\_prev\_q;

// rx timeout interrupt
  
assign uart\_rxto\_en = reg2hw.timeout\_ctrl.en.q;
  
assign uart\_rxto\_val = reg2hw.timeout\_ctrl.val.q;

assign rx\_fifo\_depth\_changed = (rx\_fifo\_depth != rx\_fifo\_depth\_prev\_q);

assign rx\_timeout\_count\_d =
  
// donâ€™t count if timeout feature not enabled ;
  
// will never reach timeout val + lower power
  
(uart\_rxto\_en == 1â€™b0) ? 24â€™d0 :
  
// reset count if timeout interrupt is set
  
event\_rx\_timeout ? 24â€™d0 :
  
// reset count upon change in fifo level: covers both read and receiving a new byte
  
rx\_fifo\_depth\_changed ? 24â€™d0 :
  
// reset count if no bytes are pending
  
(rx\_fifo\_depth == '0) ? 24â€™d0 :
  
// stop the count at timeout value (this will set the interrupt)
  
// Removed below line as when the timeout reaches the value,
  
// event occured, and timeout value reset to 0h.
  
//(rx\_timeout\_count\_q == uart\_rxto\_val) ? rx\_timeout\_count\_q :
  
// increment if at rx baud tick
  
rx\_tick\_baud ? (rx\_timeout\_count\_q + 24â€™d1) :
  
rx\_timeout\_count\_q;

assign event\_rx\_timeout = (rx\_timeout\_count\_q == uart\_rxto\_val) & uart\_rxto\_en;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
rx\_timeout\_count\_q <= 24â€™d0;
  
rx\_fifo\_depth\_prev\_q <= 6â€™d0;
  
end else begin
  
rx\_timeout\_count\_q <= rx\_timeout\_count\_d;
  
rx\_fifo\_depth\_prev\_q <= rx\_fifo\_depth;
  
end
  
end

assign event\_rx\_overflow = rx\_fifo\_wvalid & ~rx\_fifo\_wready;
  
assign event\_rx\_break\_err = break\_err & (break\_st\_q == BRK\_CHK);

// instantiate interrupt hardware primitives

prim\_intr\_hw #(.Width(1)) intr\_hw\_tx\_watermark (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_tx\_watermark),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.tx\_watermark.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.tx\_watermark.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.tx\_watermark.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.tx\_watermark.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.tx\_watermark.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.tx\_watermark.d),
  
.intr\_o (intr\_tx\_watermark\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_watermark (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_watermark),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_watermark.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_watermark.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_watermark.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_watermark.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_watermark.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_watermark.d),
  
.intr\_o (intr\_rx\_watermark\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_tx\_empty (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_tx\_empty),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.tx\_empty.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.tx\_empty.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.tx\_empty.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.tx\_empty.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.tx\_empty.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.tx\_empty.d),
  
.intr\_o (intr\_tx\_empty\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_overflow (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_overflow),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_overflow.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_overflow.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_overflow.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_overflow.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_overflow.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_overflow.d),
  
.intr\_o (intr\_rx\_overflow\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_frame\_err (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_frame\_err),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_frame\_err.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_frame\_err.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_frame\_err.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_frame\_err.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_frame\_err.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_frame\_err.d),
  
.intr\_o (intr\_rx\_frame\_err\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_break\_err (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_break\_err),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_break\_err.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_break\_err.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_break\_err.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_break\_err.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_break\_err.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_break\_err.d),
  
.intr\_o (intr\_rx\_break\_err\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_timeout (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_timeout),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_timeout.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_timeout.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_timeout.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_timeout.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_timeout.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_timeout.d),
  
.intr\_o (intr\_rx\_timeout\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_parity\_err (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_parity\_err),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_parity\_err.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_parity\_err.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_parity\_err.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_parity\_err.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_parity\_err.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_parity\_err.d),
  
.intr\_o (intr\_rx\_parity\_err\_o)
  
);

// unused registers
  
logic unused\_reg;
  
assign unused\_reg = ^reg2hw.alert\_test;

endmodule

coreä»£ç æœ‰ç‚¹å¤šï¼Œå…¶æ ¸å¿ƒå°±æ˜¯ä¸€ä¸ªå¸¦FIFOçš„uartå®ç°ã€‚å…¶ä»–ä¸åˆ†æ˜¯æ‰€æœ‰æ¨¡å—éƒ½æœ‰çš„éƒ¨åˆ†ï¼Œæ˜¯ä¸­æ–­å’Œé”™è¯¯çš„ç®¡ç†ã€‚

åˆ°ç°åœ¨ï¼Œä½ ä¼šå‘ç°è¿™ä¸ªé¡¹ç›®çœŸæ˜¯ä¸€ä¸ªå®åº“ï¼Œå®Œå…¨å¯ä»¥å®è·µä½ å­¦çš„è®¾è®¡å’ŒéªŒè¯æŠ€å·§ï¼Œå¹¶ä¸”å®ç°å¾—éå¸¸è§„èŒƒï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„èŒƒä¾‹ã€‚

### åç»­

ç½—é©¬ä¸æ˜¯ä¸€å¤©å»ºæˆçš„ã€‚è¦åœ¨AIæ—¶ä»£æˆä¸ºæ—¶ä»£çš„å¼„æ½®å„¿ï¼Œä¸€å®šè¦æ‰“ä¸‹æ‰å®çš„åŸºç¡€ï¼Œæ‰èƒ½å‘æŒ¥ä½ çš„åˆ›é€ åŠ›

åé¢æˆ‘ä¼šä»‹ç»ä½¿ç”¨ä»€ä¹ˆå·¥å…·é“¾å’Œä½¿ç”¨è‡ªå·±çš„å·¥å…·é“¾å¦‚ä½•æ¥è®¾è®¡å’ŒéªŒè¯è¿™ä¸ªé¡¹ç›®çš„æ¯ä¸ªæ¨¡å—ã€‚

ä¸€å¤©ä¸€å¤©çš„è¿›æ­¥ã€‚

æ¬¢è¿å…³æ³¨æˆ‘è¿™ä¸ªæ–°é¡¹ç›®ã€‚

ä¸ºè‡ªå·±åŠ æ²¹ï¼