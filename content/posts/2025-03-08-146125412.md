---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f6c756f67616e747463632f:61727469636c652f64657461696c732f313436313235343132"
layout: post
title: "è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨-ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡éªŒè¯çš„é¡¹ç›®-opentitan"
date: 2025-03-08 23:57:56 +08:00
description: "è¿™å‡ å¹´èŠ¯ç‰‡è®¾è®¡è¡Œä¸šåœ¨å›½å†…åƒåè¿‡å±±è½¦ã€‚æ—¶è€Œé«˜äº¢ï¼Œæ—¶è€Œä½æ½®ã€‚æœ€è¿‘åˆå› ä¸ºAIçš„çƒ­æ½®å¼€å§‹highèµ·æ¥ã€‚åˆ°åº•èŠ¯ç‰‡è¡Œä¸šçš„è§„å¾‹æ˜¯å¦‚ä½•ï¼Ÿæˆ‘è°ˆè°ˆè‡ªå·±è§‚ç‚¹ï¼šèŠ¯ç‰‡è®¾è®¡æ˜¯â€œåŠ³åŠ¨å¯†é›†å‹â€è¡Œä¸šã€‚â€œEDAå’Œå·¥å…·é«˜åº¦æ ‡å‡†åŒ–å’Œä»£å·¥å‚çš„å·¥è‰ºæ ‡å‡†åŒ–ä¹‹åï¼ŒèŠ¯ç‰‡è®¾è®¡å°±å˜æˆäº†â€œåŠ³åŠ¨å¯†é›†å‹â€å·¥ä½œï¼Œè¿™ä¹Ÿæ˜¯ç¾å›½å¾ˆé•¿ä¸€æ®µæ—¶é—´å‡ ä¹è¦æ”¾å¼ƒèŠ¯ç‰‡è®¾è®¡è¡Œä¸šçš„æŠ€æœ¯èƒŒæ™¯ã€‚å½“ç„¶ç¾å›½å›½å†…ä¹Ÿæ²¡æœ‰è¿™ä¹ˆå¤šEEå·¥ç¨‹å¸ˆä¾›åº”ã€‚è¦è·Ÿåˆ¶é€ ä¸šä¸€æ ·è½¬ç§»ç»™å…¨çƒå„åœ°ã€‚ä¸€å®¶ä¹‹è¨€ï¼Œå¤§å®¶çœ‹çœ‹ç¬‘ç¬‘å°±å¯ä»¥äº†ã€‚æˆ‘ä»¬å›½å†…èƒŒæ™¯æ˜¯ç ”ç©¶ç”Ÿå¤§é‡æ‰©æ‹›ï¼Œåˆä»€ä¹ˆå­¦ç¡•/ä¸“ç¡•ã€å…¨æ—¥/éå…¨ï¼Œå“ç§å¾ˆé½ã€‚"
keywords: "è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨ ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡ã€éªŒè¯çš„é¡¹ç›® opentitan"
categories: ['æ•°å­—ç”µè·¯']
tags: ['æ¶æ„', 'äººå·¥æ™ºèƒ½', 'Fpga']
artid: "146125412"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146125412
    alt: "è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨-ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡éªŒè¯çš„é¡¹ç›®-opentitan"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146125412
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146125412
cover: https://bing.ee123.net/img/rand?artid=146125412
image: https://bing.ee123.net/img/rand?artid=146125412
img: https://bing.ee123.net/img/rand?artid=146125412
---

# è®¾è®¡AIèŠ¯ç‰‡æ¶æ„çš„å…¥é—¨ ç ”ç©¶ç”Ÿå…¥è¡Œæ•°å­—èŠ¯ç‰‡è®¾è®¡ã€éªŒè¯çš„é¡¹ç›® opentitan

### å‰è¨€

è¿™å‡ å¹´èŠ¯ç‰‡è®¾è®¡è¡Œä¸šåœ¨å›½å†…åƒåè¿‡å±±è½¦ã€‚æ—¶è€Œé«˜äº¢ï¼Œæ—¶è€Œä½æ½®ã€‚æœ€è¿‘åˆå› ä¸ºAIçš„çƒ­æ½®å¼€å§‹highèµ·æ¥ã€‚åˆ°åº•èŠ¯ç‰‡è¡Œä¸šçš„è§„å¾‹æ˜¯å¦‚ä½•ï¼Ÿ

æˆ‘è°ˆè°ˆè‡ªå·±è§‚ç‚¹ï¼šèŠ¯ç‰‡è®¾è®¡æ˜¯â€œåŠ³åŠ¨å¯†é›†å‹â€è¡Œä¸šã€‚

**â€œEDAå’Œå·¥å…·é«˜åº¦æ ‡å‡†åŒ–å’Œä»£å·¥å‚çš„å·¥è‰ºæ ‡å‡†åŒ–ä¹‹åï¼ŒèŠ¯ç‰‡è®¾è®¡å°±å˜æˆäº†â€œåŠ³åŠ¨å¯†é›†å‹â€å·¥ä½œï¼Œè¿™ä¹Ÿæ˜¯ç¾å›½å¾ˆé•¿ä¸€æ®µæ—¶é—´å‡ ä¹è¦æ”¾å¼ƒèŠ¯ç‰‡è®¾è®¡è¡Œä¸šçš„æŠ€æœ¯èƒŒæ™¯ã€‚å½“ç„¶ç¾å›½å›½å†…ä¹Ÿæ²¡æœ‰è¿™ä¹ˆå¤šEEå·¥ç¨‹å¸ˆä¾›åº”ã€‚è¦è·Ÿåˆ¶é€ ä¸šä¸€æ ·è½¬ç§»ç»™å…¨çƒå„åœ°ã€‚â€**

ä¸€å®¶ä¹‹è¨€ï¼Œå¤§å®¶çœ‹çœ‹ç¬‘ç¬‘å°±å¯ä»¥äº†ã€‚

æˆ‘ä»¬å›½å†…èƒŒæ™¯æ˜¯ç ”ç©¶ç”Ÿå¤§é‡æ‰©æ‹›ï¼Œåˆä»€ä¹ˆå­¦ç¡•/ä¸“ç¡•ã€å…¨æ—¥/éå…¨ï¼Œå“ç§å¾ˆé½ã€‚

å›½å¤–ç ”ç©¶ç”Ÿã€ç¾å›½ã€æ¬§æ´²ç¡•å£«é˜¶æ®µéƒ½æ˜¯æˆè¯¾å‹æ•™è‚²ï¼Œå¤šå¤šç›Šå–„ã€‚å›½å†…ç°åœ¨ä¹Ÿæ˜¯ã€‚

è¿™ç»™ç ”ç©¶ç”Ÿé—¨å¾ˆå¤§å›°æƒ‘ã€‚

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ
**ç¼ºé¡¹ç›®å®è·µã€‚**

**1 æˆ‘ä¸€è´¯çš„è§‚ç‚¹æ˜¯è®¾è®¡èŠ¯ç‰‡å’ŒFPGAæ˜¯ä¸€ä¸ªæŠ€æœ¯ï¼Œå¸Œæœ›FPGAå­¦ä¹ è€…ä¹Ÿå…³æ³¨è¿™æ–¹é¢æŠ€æœ¯ã€‚**

**2 AIæ—¶ä»£å…¥é—¨èŠ¯ç‰‡è®¾è®¡è¦å…ˆå­¦å¥½è®¾è®¡å’ŒéªŒè¯ï¼Œåœ¨å­¦ä¹ æ¶æ„è®¾è®¡**

æ‰€ä»¥ï¼Œæœ¬äººå°è¯•åœ¨çŸ¥ä¹å¼€è¿™ä¸ªæ ç›®ï¼Œæä¾›ä¸€äº›ç¨å¾®å®æˆ˜é¡¹ç›®ã€‚ä¸€æ–¹é¢è®²è§£ã€ä¸€æ–¹é¢è·Ÿå„ä½äº’åŠ¨ã€‚

æ— è®ºæ˜¯æœ¬ä¸“ä¸šç§‘ç­å­¦ç”Ÿè¿˜æ˜¯éç§‘ç­å­¦ä¹ ï¼Œä¹Ÿæ— è®ºæ˜¯ä½ å·²ç»å°±ä¸šæƒ³è½¬è¡Œï¼Œéƒ½å¯ä»¥å‚è€ƒä¸Šé¢çš„é¡¹ç›®æ¥å­¦ä¹ ã€‚

ç½‘ä¸Šæœ‰opentitanæœ‰ä»‹ç»ï¼Œè®©æˆ‘æ¥åšç¬¬ä¸€äººï¼Œæ¥è¯¦ç»†ä»‹ç»è¿™ä¸ªé¡¹ç›®å¦‚ä½•å­¦ä¹ å’Œåƒä¸‹æ¥ã€‚

### èŠ¯ç‰‡è®¾è®¡ã€éªŒè¯ä¸€ä½“åŒ–é¡¹ç›®opentitanå­¦ä¹ 

å…³äºèŠ¯ç‰‡è®¾è®¡ã€éªŒè¯çš„å…¥é—¨å­¦ä¹ ä¹¦ç±ã€ä»¥åŠä¸€äº›å°ç»ƒä¹ ç½‘ä¸Šæœ‰å¾ˆå¤šä¹¦ç±ã€è§†é¢‘ã€ä¹Ÿæœ‰åŸ¹è®­å…¬å¸åœ¨åšè¿™æ–¹é¢å·¥ä½œã€‚æ„Ÿè°¢ä»–ä»¬åœ¨ç›®å‰ä¸­å›½èŠ¯ç‰‡è¡Œä¸šæ€¥éœ€å·¥ç¨‹å¸ˆèƒŒæ™¯ä¸‹æ‰€åšçš„åŠªåŠ›ã€‚ç½‘ä¸ŠåšèŠ¯ç‰‡éªŒè¯åŸ¹è®­çš„è·¯ç§‘ï¼Œæˆ‘å°±è§‰å¾—å¾ˆå¥½ã€‚æˆ‘ä»¬å¤§å­¦è¿™æ–¹é¢æ•™å­¦å¤ªç¼ºäº†ã€‚

æŒæ¡åŸºç¡€çŸ¥è¯†å¦‚ä½•é€šè¿‡é¡¹ç›®æå‡ï¼Œå¯èƒ½éœ€è¦çš„æ—¶é—´æ›´é•¿ï¼Œä¹Ÿæ›´å›°éš¾ã€‚

opentitanå°±æ˜¯è¿™æ ·ä¸€ä¸ªè®¾è®¡ã€éªŒè¯çš„ç»¼åˆæ€§é¡¹ç›®ã€‚

è™½ç„¶ä»–æ˜¯Googleå…¬å¸è”åˆä¸€äº›åŠå¯¼ä½“å…¬å¸ä»¥
[RISC-V](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=RISC-V&zhida_source=entity)
SOCå’Œå®‰å…¨èŠ¯ç‰‡ä¸ºæ ·æœ¬æ¥æ‰“é€ ï¼Œä½†æ˜¯å®Œå…¨ä¸å½±å“æˆ‘ä»¬æŠŠå®ƒä½œä¸ºæˆ‘ä»¬å…¥é—¨èŠ¯ç‰‡è®¾è®¡å’ŒéªŒè¯åçš„å®æˆ˜é¡¹ç›®ã€‚å¦‚æœè¦æµç‰‡ï¼Œä½ ä¹Ÿå¯ä»¥é‡‡ç”¨openLaneå·¥å…·é“¾æ¥ç”Ÿæˆç‰ˆå›¾ã€‚

#### 1 Opentitané¡¹ç›®ä»‹ç»

[OpenTitan - OpenTitan Documentation

â€‹


opentitan.org/book/doc/introduction.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/introduction.html)

æ‰çœ‹åˆ°è¿™ä¸ªé¡¹ç›®è‚¯å®šä¼šå¾ˆæ‡µï¼Œå°±è®©æˆ‘ä»¬ä¸€ç‚¹ä¸€ç‚¹åƒé€è¿™ä¸ªé¡¹ç›®ã€‚

é™¤äº†åœ¨githubå¼€æºäº†å…¨éƒ¨é¡¹ç›®ä»£ç ä¹‹å¤–ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ–‡æ¡£å­¦ä¹ åˆ°å¾ˆå¤šã€‚

å‰å‡ å¹´å›½å†…æˆç«‹å¤ªå¤šèŠ¯ç‰‡è®¾è®¡å…¬å¸ï¼Œå»ºè®®è¡¥è¯¾ã€‚

#### 2 èŠ¯ç‰‡è®¾è®¡çš„æµç¨‹(å‰ç«¯)

1 è®¾è®¡éªŒè¯

[https://

opentitan.org/book/doc/

getting_started/setup_dv.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/setup_dv.html)

2 å½¢å¼éªŒè¯

[https://

opentitan.org/book/doc/

getting_started/setup_formal.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/setup_formal.html)

3 åˆ›å»ºæµ‹è¯•è½¯ä»¶ï¼ˆSOCéœ€è¦ï¼‰

[https://

opentitan.org/book/doc/

getting_started/build_sw.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/build_sw.html)

4 æ–‡æ¡£åˆ›å»º

[https://

opentitan.org/book/doc/

getting_started/build_docs.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/build_docs.html)

5 FPGA éªŒè¯

[https://

opentitan.org/book/doc/

getting_started/using_openocd.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/using_openocd.html)

#### 3 OpentitanèŠ¯ç‰‡çš„è®¾è®¡éªŒè¯

æœ¬ç¯‡æ–‡ç« å°±æš‚æ—¶ä»è¿™æ¬¾RISC-VèŠ¯ç‰‡çš„è®¾è®¡å’ŒéªŒè¯å¼€å§‹ï¼Œçœ‹çœ‹æˆ‘ä»¬æ”¹å¦‚ä½•å­¦ä¹ å’Œä¸‹æ‰‹è¿™ä¸ªé¡¹ç›®ã€‚

ç®€å•æ¥è®²ï¼ŒSOCèŠ¯ç‰‡å°±æ˜¯ CPU coreå’Œ å¤–å›´ç”µè·¯ åŠ  æ€»çº¿ è¿æ¥èµ·æ¥çš„åŠŸèƒ½æ¨¡å—ã€‚

å…ˆçœ‹çœ‹æ•´ä½“æ¨¡å—æ„æˆ

![](https://i-blog.csdnimg.cn/img_convert/8422526580c363bb4f12f501217a9500.jpeg)

opentitanæ•´ä½“æ¨¡å—æ„æˆ

å¯è§ è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„SOCèŠ¯ç‰‡ã€‚ è¿˜æ¯”è¾ƒå¤æ‚ï¼Œè·Ÿå•†ä¸šèŠ¯ç‰‡ä¸šå·®ä¸äº†å¤ªå¤šã€‚

æŒ‡ä»¤é›†æ”¯æŒRV32IMCBï¼ˆ32ä½æ•´æ•°æŒ‡ä»¤é›† M æ•´å‹ä¹˜é™¤æ³•æ‰©å±• C å‹ç¼©æŒ‡ä»¤é›†æ‰©å±• B ä½æ“ä½œæ‰©å±• ï¼‰å¤§æ¦‚ç›¸å½“äºARM cortex-M3çš„æ°´å¹³å§ã€‚

å…³äºcoreçœ‹è¿™ä¸ªæ–‡æ¡£ï¼š

[https://ibex-core.readthedocs.io/en/latest/01_overview/index.html

â€‹


ibex-core.readthedocs.io/en/latest/01_overview/index.html](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

[Introduction to Ibex](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

[Introduction to Ibex

â€‹


ibex-core.readthedocs.io/en/latest/01_overview/index.html](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

æ€»çº¿çœ‹è¿™ä¸ªæ–‡æ¡£ï¼š

[https://sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf

â€‹


sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf](https://link.zhihu.com/?target=https%3A//sifive.cdn.prismic.io/sifive%252F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf)

æ˜¯SiFiveå…¬å¸çš„ã€‚å‰å‡ å¹´æ®è¯´INTELè¦æ”¶è´­SiFiveï¼Œæ²¡æœ‰æˆåŠŸã€‚èŠ¯ç‰‡è¡Œä¸šæ±Ÿæ¹–çˆ±æ¨æƒ…ä»‡æ¯å¤©éƒ½åœ¨ä¸Šæ¼”ï¼Œä¸äºšäºç”µè§†è¿ç»­å‰§ã€‚

æˆ‘ç›¸ä¿¡ï¼Œå„ä½è·Ÿå…³æ³¨å¤–å›´æ¨¡å—çš„è®¾è®¡éªŒè¯ï¼Œè¿™æ˜¯å¤§å®¶å…¥è¡Œæœ€å¼€å§‹å¹²çš„å·¥ä½œï¼š

![](https://i-blog.csdnimg.cn/img_convert/e43cdf02a95533c5acec6024beb14e87.jpeg)

#### 4 UART å¤–å›´ç”µè·¯æ¨¡å—çš„è®¾è®¡å’ŒéªŒè¯

![](https://i-blog.csdnimg.cn/img_convert/50f5fff8efa75e2c2d28fc0b763a5651.jpeg)

æœ¬ç¯‡æ–‡ç« å°±ä»¥è¿™ä¸ªæœ€ç®€å•çš„UARTæ¨¡å—è®²è§£ä¸€ä¸‹è®¾è®¡å’ŒéªŒè¯çš„æ¦‚è¿°ï¼Œè¯¦ç»†åœ¨åé¢æ–‡ç« è®²è§£ã€‚ç›®å‰ä½ æš‚æ—¶æ²¡æœ‰system veriloå’ŒUVMåŸºç¡€æš‚æ—¶ä¹Ÿæ²¡å…³ç³»ï¼Œæˆ‘å¸¦ç€ä½ å…ˆå…¥é—¨å†è¯¦ç»†å»å­¦ä¹ è¿™æ–¹é¢çŸ¥è¯†ã€‚

è¿™æ–¹é¢æˆ‘ä¸Šé¢æçš„è·¯ç§‘éªŒè¯å°±å¯ä»¥ã€‚

è®¾è®¡ï¼š

ä¸€èˆ¬èŠ¯ç‰‡é‡‡ç”¨çš„verilogã€‚è¿™ä¸ªé¡¹ç›®é‡‡ç”¨çš„æ˜¯
[system verilog](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=system+verilog&zhida_source=entity)
ä½œä¸ºè®¾è®¡è¯­è¨€ï¼Œä½†æ˜¯ä¹Ÿæœ‰è‡ªå·±çš„è§„èŒƒï¼š

[style-guides/VerilogCodingStyle.md at master Â· lowRISC/style-guides

â€‹


github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md

![](https://i-blog.csdnimg.cn/img_convert/b9e9535de559b82036fd73528cce1aa7.png)](https://link.zhihu.com/?target=https%3A//github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md)

å„ä½åˆ°è‡ªå·±çš„å…¬å¸ä¹Ÿä¼šæœ‰å„ä¸ªå…¬å¸çš„è®¾è®¡è¯­è¨€è§„èŒƒã€‚

```text
A template that demonstrates many of the items is given below.

```

Template:

// Copyright lowRISC contributors.
  
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
  
// SPDX-License-Identifier: Apache-2.0
  
//
  
// One line description of the module

module my_module #(
  
parameter Width = 80,
  
parameter Height = 24
  
) (
  
input clk_i,
  
input rst_ni,
  
input req_valid_i,
  
input [Width-1:0] req_data_i,
  
output req_ready_o,
  
â€¦
  
);

logic [Width-1:0] req_data_masked;

submodule u_submodule (
  
.clk_i,
  
.rst_ni,
  
.req_valid_i,
  
.req_data_i (req_data_masked),
  
.req_ready_o(req_ready),
  
â€¦
  
);

always_comb begin
  
req_data_masked = req_data_i;
  
case (fsm_state_q)
  
ST_IDLE: begin
  
req_data_masked = req_data_i & MASK_IDLE;
  
â€¦
  
end

â€¦

endmodule

å¦å¤– é«˜åº¦ä¾èµ–
[Linting](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=Linting&zhida_source=entity)

#### â€œLinting is a productivity tool for designers to quickly find typos and bugs at the time when the RTL is written. Running lint is important when using SystemVerilog, a weakly-typed language, unlike other hardware description languages. We consider linting to be critical for conformance to our goals of high quality designsâ€

å› ä¸ºsystem verilogå†™èµ·çˆ½ï¼Œå¯èƒ½å…¶ä»–å·¥å…·å°±è¦è·Ÿä¸Šã€‚

#### 5 UARTåŠŸèƒ½æ¡†å›¾å’Œä»£ç 

![](https://i-blog.csdnimg.cn/img_convert/1002f7673d4e7ca1355d011bfe35ccfa.jpeg)

UARTåŠŸèƒ½æ¡†å›¾

#### 5.1 uartæ¨¡å—çš„TOP

```text
// Copyright lowRISC contributors.  

// Licensed under the Apache License, Version 2.0, see LICENSE for details.  

// SPDX-License-Identifier: Apache-2.0  

//  

// Description: UART top level wrapper file

```

`include â€œprim_assert.svâ€

module uart
  
import uart_reg_pkg:ğŸ˜—;
  
#(
  
parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1â€™b1}}
  
) (
  
input clk_i,
  
input rst_ni,

// Bus Interface
  
input tlul_pkg::tl_h2d_t tl_i,
  
output tlul_pkg::tl_d2h_t tl_o,

// Alerts
  
input prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
  
output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,

// Generic IO
  
input cio_rx_i,
  
output logic cio_tx_o,
  
output logic cio_tx_en_o,

// Interrupts
  
output logic intr_tx_watermark_o ,
  
output logic intr_rx_watermark_o ,
  
output logic intr_tx_empty_o ,
  
output logic intr_rx_overflow_o ,
  
output logic intr_rx_frame_err_o ,
  
output logic intr_rx_break_err_o ,
  
output logic intr_rx_timeout_o ,
  
output logic intr_rx_parity_err_o
  
);

logic [NumAlerts-1:0] alert_test, alerts;
  
uart_reg2hw_t reg2hw;
  
uart_hw2reg_t hw2reg;

uart_reg_top u_reg (
  
.clk_i,
  
.rst_ni,
  
.tl_i,
  
.tl_o,
  
.reg2hw,
  
.hw2reg,
  
// SEC_CM: BUS.INTEGRITY
  
.intg_err_o (alerts[0]),
  
.devmode_i (1â€™b1)
  
);

uart_core uart_core (
  
.clk_i,
  
.rst_ni,
  
.reg2hw,
  
.hw2reg,

```
.rx    (cio_rx_i   ),
.tx    (cio_tx_o   ),

.intr_tx_watermark_o,
.intr_rx_watermark_o,
.intr_tx_empty_o,
.intr_rx_overflow_o,
.intr_rx_frame_err_o,
.intr_rx_break_err_o,
.intr_rx_timeout_o,
.intr_rx_parity_err_o

```

);

// Alerts
  
assign alert_test = {
  
reg2hw.alert_test.q &
  
reg2hw.alert_test.qe
  
};

for (genvar i = 0; i < NumAlerts; i++) begin : gen_alert_tx
  
prim_alert_sender #(
  
.AsyncOn(AlertAsyncOn[i]),
  
.IsFatal(1â€™b1)
  
) u_prim_alert_sender (
  
.clk_i,
  
.rst_ni,
  
.alert_test_i ( alert_test[i] ),
  
.alert_req_i ( alerts[0] ),
  
.alert_ack_o ( ),
  
.alert_state_o ( ),
  
.alert_rx_i ( alert_rx_i[i] ),
  
.alert_tx_o ( alert_tx_o[i] )
  
);
  
end

// always enable the driving out of TX
  
assign cio_tx_en_o = 1â€™b1;

// Assert Known for outputs
  
`ASSERT(TxEnIsOne_A, cio_tx_en_o === 1'b1)`
ASSERT_KNOWN(TxKnown_A, cio_tx_o, clk_i, !rst_ni || !cio_tx_en_o)

// Assert Known for alerts
  
`ASSERT_KNOWN(AlertsKnown_A, alert_tx_o)

// Assert Known for interrupts
  
`ASSERT_KNOWN(TxWatermarkKnown_A, intr_tx_watermark_o)`
ASSERT_KNOWN(RxWatermarkKnown_A, intr_rx_watermark_o)
  
`ASSERT_KNOWN(TxEmptyKnown_A, intr_tx_empty_o)`
ASSERT_KNOWN(RxOverflowKnown_A, intr_rx_overflow_o)
  
`ASSERT_KNOWN(RxFrameErrKnown_A, intr_rx_frame_err_o)`
ASSERT_KNOWN(RxBreakErrKnown_A, intr_rx_break_err_o)
  
`ASSERT_KNOWN(RxTimeoutKnown_A, intr_rx_timeout_o)`
ASSERT_KNOWN(RxParityErrKnown_A, intr_rx_parity_err_o)

// Alert assertions for reg_we onehot check
  
`ASSERT_PRIM_REG_WE_ONEHOT_ERROR_TRIGGER_ALERT(RegWeOnehotCheck_A, u_reg, alert_tx_o[0])
  
endmodule

ä»£ç ä¸‹é¢æ˜¯ç”¨äºå½¢å¼éªŒè¯ï¼Œæš‚æ—¶ä¸ç®¡ï¼Œå¯è§æ ¸å¿ƒæ˜¯uart_core:

å…¶ä¸­.reg2hw .hw2reg

```text
  // Register -> HW type  

typedef struct packed {  

uart_reg2hw_intr_state_reg_t intr_state; // [126:119]  

uart_reg2hw_intr_enable_reg_t intr_enable; // [118:111]  

uart_reg2hw_intr_test_reg_t intr_test; // [110:95]  

uart_reg2hw_alert_test_reg_t alert_test; // [94:93]  

uart_reg2hw_ctrl_reg_t ctrl; // [92:68]  

uart_reg2hw_status_reg_t status; // [67:56]  

uart_reg2hw_rdata_reg_t rdata; // [55:47]  

uart_reg2hw_wdata_reg_t wdata; // [46:38]  

uart_reg2hw_fifo_ctrl_reg_t fifo_ctrl; // [37:27]  

uart_reg2hw_ovrd_reg_t ovrd; // [26:25]  

uart_reg2hw_timeout_ctrl_reg_t timeout_ctrl; // [24:0]  

} uart_reg2hw_t;  


```

```text
  // HW -> register type  

typedef struct packed {  

uart_hw2reg_intr_state_reg_t intr_state; // [64:49]  

uart_hw2reg_status_reg_t status; // [48:43]  

uart_hw2reg_rdata_reg_t rdata; // [42:35]  

uart_hw2reg_fifo_ctrl_reg_t fifo_ctrl; // [34:28]  

uart_hw2reg_fifo_status_reg_t fifo_status; // [27:16]  

uart_hw2reg_val_reg_t val; // [15:0]  

} uart_hw2reg_t;  


```

hwå°±æ˜¯æˆ‘ä»¬UARTçš„ç¡¬ä»¶å®ç°äº‹å®œå«hwã€‚

åŠç¡¬ä»¶ç”µè·¯ä¸å¯„å­˜å™¨ä¹‹é—´çš„å…³ç³»

#### 5.2 coreä»£ç 

```text
module uart_core (  

input                  clk_i,  

input                  rst_ni,

```

input uart_reg_pkg::uart_reg2hw_t reg2hw,
  
output uart_reg_pkg::uart_hw2reg_t hw2reg,

input rx,
  
output logic tx,

output logic intr_tx_watermark_o,
  
output logic intr_rx_watermark_o,
  
output logic intr_tx_empty_o,
  
output logic intr_rx_overflow_o,
  
output logic intr_rx_frame_err_o,
  
output logic intr_rx_break_err_o,
  
output logic intr_rx_timeout_o,
  
output logic intr_rx_parity_err_o
  
);

import uart_reg_pkg:ğŸ˜—;

localparam int NcoWidth = $bits(reg2hw.ctrl.nco.q);

logic [15:0] rx_val_q;
  
logic [7:0] uart_rdata;
  
logic tick_baud_x16, rx_tick_baud;
  
logic [5:0] tx_fifo_depth, rx_fifo_depth;
  
logic [5:0] rx_fifo_depth_prev_q;
  
logic [23:0] rx_timeout_count_d, rx_timeout_count_q, uart_rxto_val;
  
logic rx_fifo_depth_changed, uart_rxto_en;
  
logic tx_enable, rx_enable;
  
logic sys_loopback, line_loopback, rxnf_enable;
  
logic uart_fifo_rxrst, uart_fifo_txrst;
  
logic [2:0] uart_fifo_rxilvl;
  
logic [1:0] uart_fifo_txilvl;
  
logic ovrd_tx_en, ovrd_tx_val;
  
logic [7:0] tx_fifo_data;
  
logic tx_fifo_rready, tx_fifo_rvalid;
  
logic tx_fifo_wready, tx_uart_idle;
  
logic tx_out;
  
logic tx_out_q;
  
logic [7:0] rx_fifo_data;
  
logic rx_valid, rx_fifo_wvalid, rx_fifo_rvalid;
  
logic rx_fifo_wready, rx_uart_idle;
  
logic rx_sync;
  
logic rx_in;
  
logic break_err;
  
logic [4:0] allzero_cnt_d, allzero_cnt_q;
  
logic allzero_err, not_allzero_char;
  
logic event_tx_watermark, event_rx_watermark, event_tx_empty, event_rx_overflow;
  
logic event_rx_frame_err, event_rx_break_err, event_rx_timeout, event_rx_parity_err;
  
logic tx_watermark_d, tx_watermark_prev_q;
  
logic rx_watermark_d, rx_watermark_prev_q;
  
logic tx_uart_idle_q;

assign tx_enable = reg2hw.ctrl.tx.q;
  
assign rx_enable = reg2hw.ctrl.rx.q;
  
assign rxnf_enable = reg2hw.ctrl.nf.q;
  
assign sys_loopback = reg2hw.ctrl.slpbk.q;
  
assign line_loopback = reg2hw.ctrl.llpbk.q;

assign uart_fifo_rxrst = reg2hw.fifo_ctrl.rxrst.q & reg2hw.fifo_ctrl.rxrst.qe;
  
assign uart_fifo_txrst = reg2hw.fifo_ctrl.txrst.q & reg2hw.fifo_ctrl.txrst.qe;
  
assign uart_fifo_rxilvl = reg2hw.fifo_ctrl.rxilvl.q;
  
assign uart_fifo_txilvl = reg2hw.fifo_ctrl.txilvl.q;

assign ovrd_tx_en = reg2hw.ovrd.txen.q;
  
assign ovrd_tx_val = reg2hw.ovrd.txval.q;

typedef enum logic {
  
BRK_CHK,
  
BRK_WAIT
  
} break_st_e ;

break_st_e break_st_q;

assign not_allzero_char = rx_valid & (~event_rx_frame_err | (rx_fifo_data != 8â€™h0));
  
assign allzero_err = event_rx_frame_err & (rx_fifo_data == 8â€™h0);

assign allzero_cnt_d = (break_st_q == BRK_WAIT || not_allzero_char) ? 5â€™h0 :
  
//allzero_cnt_q[4] never be 1b without break_st_q as BRK_WAIT
  
//allzero_cnt_q[4] ? allzero_cnt_q :
  
allzero_err ? allzero_cnt_q + 5â€™d1 :
  
allzero_cnt_q;

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) allzero_cnt_q <= '0;
  
else if (rx_enable) allzero_cnt_q <= allzero_cnt_d;
  
end

// break_err edges in same cycle as event_rx_frame_err edges ; that way the
  
// reset-on-read works the same way for break and frame error interrupts.

always_comb begin
  
unique case (reg2hw.ctrl.rxblvl.q)
  
2â€™h0: break_err = allzero_cnt_d >= 5â€™d2;
  
2â€™h1: break_err = allzero_cnt_d >= 5â€™d4;
  
2â€™h2: break_err = allzero_cnt_d >= 5â€™d8;
  
default: break_err = allzero_cnt_d >= 5â€™d16;
  
endcase
  
end

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) break_st_q <= BRK_CHK;
  
else begin
  
unique case (break_st_q)
  
BRK_CHK: begin
  
if (event_rx_break_err) break_st_q <= BRK_WAIT;
  
end

```
    BRK_WAIT: begin
      if (rx_in) break_st_q &lt;= BRK_CHK;
    end

    default: begin
      break_st_q &lt;= BRK_CHK;
    end
  endcase
end

```

end

assign hw2reg.val.d = rx_val_q;

assign hw2reg.rdata.d = uart_rdata;

assign hw2reg.status.rxempty.d = ~rx_fifo_rvalid;
  
assign hw2reg.status.rxidle.d = rx_uart_idle;
  
assign hw2reg.status.txidle.d = tx_uart_idle & ~tx_fifo_rvalid;
  
assign hw2reg.status.txempty.d = ~tx_fifo_rvalid;
  
assign hw2reg.status.rxfull.d = ~rx_fifo_wready;
  
assign hw2reg.status.txfull.d = ~tx_fifo_wready;

assign hw2reg.fifo_status.txlvl.d = tx_fifo_depth;
  
assign hw2reg.fifo_status.rxlvl.d = rx_fifo_depth;

// resets are self-clearing, so need to update FIFO_CTRL
  
assign hw2reg.fifo_ctrl.rxilvl.de = 1â€™b0;
  
assign hw2reg.fifo_ctrl.rxilvl.d = 3â€™h0;
  
assign hw2reg.fifo_ctrl.txilvl.de = 1â€™b0;
  
assign hw2reg.fifo_ctrl.txilvl.d = 2â€™h0;

// NCO 16x Baud Generator
  
// output clock rate is:
  
// Fin * (NCO/2**NcoWidth)
  
logic [NcoWidth:0] nco_sum_q; // extra bit to get the carry

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) begin
  
nco_sum_q <= 17â€™h0;
  
end else if (tx_enable || rx_enable) begin
  
nco_sum_q <= {1â€™b0,nco_sum_q[NcoWidth-1:0]} + {1â€™b0,reg2hw.ctrl.nco.q[NcoWidth-1:0]};
  
end
  
end

assign tick_baud_x16 = nco_sum_q[16];

//
  
// TX Logic //
  
//

assign tx_fifo_rready = tx_uart_idle & tx_fifo_rvalid & tx_enable;

prim_fifo_sync #(
  
.Width (8),
  
.Pass (1â€™b0),
  
.Depth (32)
  
) u_uart_txfifo (
  
.clk_i,
  
.rst_ni,
  
.clr_i (uart_fifo_txrst),
  
.wvalid_i(reg2hw.wdata.qe),
  
.wready_o(tx_fifo_wready),
  
.wdata_i (reg2hw.wdata.q),
  
.depth_o (tx_fifo_depth),
  
.full_o (),
  
.rvalid_o(tx_fifo_rvalid),
  
.rready_i(tx_fifo_rready),
  
.rdata_o (tx_fifo_data),
  
.err_o ()
  
);

uart_tx uart_tx (
  
.clk_i,
  
.rst_ni,
  
.tx_enable,
  
.tick_baud_x16,
  
.parity_enable (reg2hw.ctrl.parity_en.q),
  
.wr (tx_fifo_rready),
  
.wr_parity ((^tx_fifo_data) ^ reg2hw.ctrl.parity_odd.q),
  
.wr_data (tx_fifo_data),
  
.idle (tx_uart_idle),
  
.tx (tx_out)
  
);

assign tx = line_loopback ? rx : tx_out_q ;
  
always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) begin
  
tx_out_q <= 1â€™b1;
  
end else if (ovrd_tx_en) begin
  
tx_out_q <= ovrd_tx_val ;
  
end else if (sys_loopback) begin
  
tx_out_q <= 1â€™b1;
  
end else begin
  
tx_out_q <= tx_out;
  
end
  
end

//
  
// RX Logic //
  
//

// sync the incoming data
  
prim_flop_2sync #(
  
.Width(1),
  
.ResetValue(1â€™b1)
  
) sync_rx (
  
.clk_i,
  
.rst_ni,
  
.d_i(rx),
  
.q_o(rx_sync)
  
);

// Based on: en.wikipedia.org/wiki/Repetition_code mentions the use of a majority filter
  
// in UART to ignore brief noise spikes
  
logic rx_sync_q1, rx_sync_q2, rx_in_mx, rx_in_maj;

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) begin
  
rx_sync_q1 <= 1â€™b1;
  
rx_sync_q2 <= 1â€™b1;
  
end else begin
  
rx_sync_q1 <= rx_sync;
  
rx_sync_q2 <= rx_sync_q1;
  
end
  
end

assign rx_in_maj = (rx_sync & rx_sync_q1) |
  
(rx_sync & rx_sync_q2) |
  
(rx_sync_q1 & rx_sync_q2);
  
assign rx_in_mx = rxnf_enable ? rx_in_maj : rx_sync;

assign rx_in = sys_loopback ? tx_out :
  
line_loopback ? 1â€™b1 :
  
rx_in_mx;

uart_rx uart_rx (
  
.clk_i,
  
.rst_ni,
  
.rx_enable,
  
.tick_baud_x16,
  
.parity_enable (reg2hw.ctrl.parity_en.q),
  
.parity_odd (reg2hw.ctrl.parity_odd.q),
  
.tick_baud (rx_tick_baud),
  
.rx_valid,
  
.rx_data (rx_fifo_data),
  
.idle (rx_uart_idle),
  
.frame_err (event_rx_frame_err),
  
.rx (rx_in),
  
.rx_parity_err (event_rx_parity_err)
  
);

assign rx_fifo_wvalid = rx_valid & ~event_rx_frame_err & ~event_rx_parity_err;

prim_fifo_sync #(
  
.Width (8),
  
.Pass (1â€™b0),
  
.Depth (32)
  
) u_uart_rxfifo (
  
.clk_i,
  
.rst_ni,
  
.clr_i (uart_fifo_rxrst),
  
.wvalid_i(rx_fifo_wvalid),
  
.wready_o(rx_fifo_wready),
  
.wdata_i (rx_fifo_data),
  
.depth_o (rx_fifo_depth),
  
.full_o (),
  
.rvalid_o(rx_fifo_rvalid),
  
.rready_i(reg2hw.rdata.re),
  
.rdata_o (uart_rdata),
  
.err_o ()
  
);

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) rx_val_q <= 16â€™h0;
  
else if (tick_baud_x16) rx_val_q <= {rx_val_q[14:0], rx_in};
  
end

// Interrupt & Status //

always_comb begin
  
unique case(uart_fifo_txilvl)
  
2â€™h0: tx_watermark_d = (tx_fifo_depth < 6â€™d2);
  
2â€™h1: tx_watermark_d = (tx_fifo_depth < 6â€™d4);
  
2â€™h2: tx_watermark_d = (tx_fifo_depth < 6â€™d8);
  
default: tx_watermark_d = (tx_fifo_depth < 6â€™d16);
  
endcase
  
end

assign event_tx_watermark = tx_watermark_d & ~tx_watermark_prev_q;

// The empty condition handling is a bit different.
  
// If empty rising conditions were detected directly, then every first write of a burst
  
// would trigger an empty. This is due to the fact that the uart_tx fsm immediately
  
// withdraws the content and asserts â€œemptyâ€.
  
// To guard against this false trigger, empty is qualified with idle to extend the window
  
// in which software has an opportunity to deposit new data.
  
// However, if software deposit speed is TOO slow, this would still be an issue.
  
//
  
// The alternative software fix is to disable tx_enable until it has a chance to
  
// burst in the desired amount of data.
  
assign event_tx_empty = ~tx_fifo_rvalid & ~tx_uart_idle_q & tx_uart_idle;

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) begin
  
tx_watermark_prev_q <= 1â€™b1; // by default watermark condition is true
  
rx_watermark_prev_q <= 1â€™b0; // by default watermark condition is false
  
tx_uart_idle_q <= 1â€™b1;
  
end else begin
  
tx_watermark_prev_q <= tx_watermark_d;
  
rx_watermark_prev_q <= rx_watermark_d;
  
tx_uart_idle_q <= tx_uart_idle;
  
end
  
end

always_comb begin
  
unique case(uart_fifo_rxilvl)
  
3â€™h0: rx_watermark_d = (rx_fifo_depth >= 6â€™d1);
  
3â€™h1: rx_watermark_d = (rx_fifo_depth >= 6â€™d4);
  
3â€™h2: rx_watermark_d = (rx_fifo_depth >= 6â€™d8);
  
3â€™h3: rx_watermark_d = (rx_fifo_depth >= 6â€™d16);
  
3â€™h4: rx_watermark_d = (rx_fifo_depth >= 6â€™d30);
  
default: rx_watermark_d = 1â€™b0;
  
endcase
  
end

assign event_rx_watermark = rx_watermark_d & ~rx_watermark_prev_q;

// rx timeout interrupt
  
assign uart_rxto_en = reg2hw.timeout_ctrl.en.q;
  
assign uart_rxto_val = reg2hw.timeout_ctrl.val.q;

assign rx_fifo_depth_changed = (rx_fifo_depth != rx_fifo_depth_prev_q);

assign rx_timeout_count_d =
  
// donâ€™t count if timeout feature not enabled ;
  
// will never reach timeout val + lower power
  
(uart_rxto_en == 1â€™b0) ? 24â€™d0 :
  
// reset count if timeout interrupt is set
  
event_rx_timeout ? 24â€™d0 :
  
// reset count upon change in fifo level: covers both read and receiving a new byte
  
rx_fifo_depth_changed ? 24â€™d0 :
  
// reset count if no bytes are pending
  
(rx_fifo_depth == '0) ? 24â€™d0 :
  
// stop the count at timeout value (this will set the interrupt)
  
// Removed below line as when the timeout reaches the value,
  
// event occured, and timeout value reset to 0h.
  
//(rx_timeout_count_q == uart_rxto_val) ? rx_timeout_count_q :
  
// increment if at rx baud tick
  
rx_tick_baud ? (rx_timeout_count_q + 24â€™d1) :
  
rx_timeout_count_q;

assign event_rx_timeout = (rx_timeout_count_q == uart_rxto_val) & uart_rxto_en;

always_ff @(posedge clk_i or negedge rst_ni) begin
  
if (!rst_ni) begin
  
rx_timeout_count_q <= 24â€™d0;
  
rx_fifo_depth_prev_q <= 6â€™d0;
  
end else begin
  
rx_timeout_count_q <= rx_timeout_count_d;
  
rx_fifo_depth_prev_q <= rx_fifo_depth;
  
end
  
end

assign event_rx_overflow = rx_fifo_wvalid & ~rx_fifo_wready;
  
assign event_rx_break_err = break_err & (break_st_q == BRK_CHK);

// instantiate interrupt hardware primitives

prim_intr_hw #(.Width(1)) intr_hw_tx_watermark (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_tx_watermark),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.tx_watermark.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.tx_watermark.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.tx_watermark.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.tx_watermark.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.tx_watermark.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.tx_watermark.d),
  
.intr_o (intr_tx_watermark_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_rx_watermark (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_rx_watermark),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_watermark.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.rx_watermark.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.rx_watermark.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.rx_watermark.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.rx_watermark.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.rx_watermark.d),
  
.intr_o (intr_rx_watermark_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_tx_empty (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_tx_empty),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.tx_empty.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.tx_empty.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.tx_empty.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.tx_empty.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.tx_empty.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.tx_empty.d),
  
.intr_o (intr_tx_empty_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_rx_overflow (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_rx_overflow),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_overflow.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.rx_overflow.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.rx_overflow.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.rx_overflow.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.rx_overflow.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.rx_overflow.d),
  
.intr_o (intr_rx_overflow_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_rx_frame_err (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_rx_frame_err),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_frame_err.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.rx_frame_err.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.rx_frame_err.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.rx_frame_err.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.rx_frame_err.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.rx_frame_err.d),
  
.intr_o (intr_rx_frame_err_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_rx_break_err (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_rx_break_err),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_break_err.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.rx_break_err.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.rx_break_err.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.rx_break_err.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.rx_break_err.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.rx_break_err.d),
  
.intr_o (intr_rx_break_err_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_rx_timeout (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_rx_timeout),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_timeout.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.rx_timeout.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.rx_timeout.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.rx_timeout.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.rx_timeout.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.rx_timeout.d),
  
.intr_o (intr_rx_timeout_o)
  
);

prim_intr_hw #(.Width(1)) intr_hw_rx_parity_err (
  
.clk_i,
  
.rst_ni,
  
.event_intr_i (event_rx_parity_err),
  
.reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_parity_err.q),
  
.reg2hw_intr_test_q_i (reg2hw.intr_test.rx_parity_err.q),
  
.reg2hw_intr_test_qe_i (reg2hw.intr_test.rx_parity_err.qe),
  
.reg2hw_intr_state_q_i (reg2hw.intr_state.rx_parity_err.q),
  
.hw2reg_intr_state_de_o (hw2reg.intr_state.rx_parity_err.de),
  
.hw2reg_intr_state_d_o (hw2reg.intr_state.rx_parity_err.d),
  
.intr_o (intr_rx_parity_err_o)
  
);

// unused registers
  
logic unused_reg;
  
assign unused_reg = ^reg2hw.alert_test;

endmodule

coreä»£ç æœ‰ç‚¹å¤šï¼Œå…¶æ ¸å¿ƒå°±æ˜¯ä¸€ä¸ªå¸¦FIFOçš„uartå®ç°ã€‚å…¶ä»–ä¸åˆ†æ˜¯æ‰€æœ‰æ¨¡å—éƒ½æœ‰çš„éƒ¨åˆ†ï¼Œæ˜¯ä¸­æ–­å’Œé”™è¯¯çš„ç®¡ç†ã€‚

åˆ°ç°åœ¨ï¼Œä½ ä¼šå‘ç°è¿™ä¸ªé¡¹ç›®çœŸæ˜¯ä¸€ä¸ªå®åº“ï¼Œå®Œå…¨å¯ä»¥å®è·µä½ å­¦çš„è®¾è®¡å’ŒéªŒè¯æŠ€å·§ï¼Œå¹¶ä¸”å®ç°å¾—éå¸¸è§„èŒƒï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„èŒƒä¾‹ã€‚

### åç»­

ç½—é©¬ä¸æ˜¯ä¸€å¤©å»ºæˆçš„ã€‚è¦åœ¨AIæ—¶ä»£æˆä¸ºæ—¶ä»£çš„å¼„æ½®å„¿ï¼Œä¸€å®šè¦æ‰“ä¸‹æ‰å®çš„åŸºç¡€ï¼Œæ‰èƒ½å‘æŒ¥ä½ çš„åˆ›é€ åŠ›

åé¢æˆ‘ä¼šä»‹ç»ä½¿ç”¨ä»€ä¹ˆå·¥å…·é“¾å’Œä½¿ç”¨è‡ªå·±çš„å·¥å…·é“¾å¦‚ä½•æ¥è®¾è®¡å’ŒéªŒè¯è¿™ä¸ªé¡¹ç›®çš„æ¯ä¸ªæ¨¡å—ã€‚

ä¸€å¤©ä¸€å¤©çš„è¿›æ­¥ã€‚

æ¬¢è¿å…³æ³¨æˆ‘è¿™ä¸ªæ–°é¡¹ç›®ã€‚

ä¸ºè‡ªå·±åŠ æ²¹ï¼