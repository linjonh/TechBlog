---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f6c756f67616e747463632f:61727469636c652f64657461696c732f313436313235343132"
layout: post
title: "设计AI芯片架构的入门-研究生入行数字芯片设计验证的项目-opentitan"
date: 2025-03-08 23:57:56 +0800
description: "这几年芯片设计行业在国内像坐过山车。时而高亢，时而低潮。最近又因为AI的热潮开始high起来。到底芯片行业的规律是如何？我谈谈自己观点：芯片设计是“劳动密集型”行业。“EDA和工具高度标准化和代工厂的工艺标准化之后，芯片设计就变成了“劳动密集型”工作，这也是美国很长一段时间几乎要放弃芯片设计行业的技术背景。当然美国国内也没有这么多EE工程师供应。要跟制造业一样转移给全球各地。一家之言，大家看看笑笑就可以了。我们国内背景是研究生大量扩招，又什么学硕/专硕、全日/非全，品种很齐。"
keywords: "设计AI芯片架构的入门 研究生入行数字芯片设计、验证的项目 opentitan"
categories: ['数字电路']
tags: ['架构', '人工智能', 'Fpga']
artid: "146125412"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146125412
    alt: "设计AI芯片架构的入门-研究生入行数字芯片设计验证的项目-opentitan"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146125412
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146125412
cover: https://bing.ee123.net/img/rand?artid=146125412
image: https://bing.ee123.net/img/rand?artid=146125412
img: https://bing.ee123.net/img/rand?artid=146125412
---

# 设计AI芯片架构的入门 研究生入行数字芯片设计、验证的项目 opentitan

### 前言

这几年芯片设计行业在国内像坐过山车。时而高亢，时而低潮。最近又因为AI的热潮开始high起来。到底芯片行业的规律是如何？

我谈谈自己观点：芯片设计是“劳动密集型”行业。

**“EDA和工具高度标准化和代工厂的工艺标准化之后，芯片设计就变成了“劳动密集型”工作，这也是美国很长一段时间几乎要放弃芯片设计行业的技术背景。当然美国国内也没有这么多EE工程师供应。要跟制造业一样转移给全球各地。”**

一家之言，大家看看笑笑就可以了。

我们国内背景是研究生大量扩招，又什么学硕/专硕、全日/非全，品种很齐。

国外研究生、美国、欧洲硕士阶段都是授课型教育，多多益善。国内现在也是。

这给研究生门很大困惑。

为什么呢？
**缺项目实践。**

**1 我一贯的观点是设计芯片和FPGA是一个技术，希望FPGA学习者也关注这方面技术。**

**2 AI时代入门芯片设计要先学好设计和验证，在学习架构设计**

所以，本人尝试在知乎开这个栏目，提供一些稍微实战项目。一方面讲解、一方面跟各位互动。

无论是本专业科班学生还是非科班学习，也无论是你已经就业想转行，都可以参考上面的项目来学习。

网上有opentitan有介绍，让我来做第一人，来详细介绍这个项目如何学习和吃下来。

### 芯片设计、验证一体化项目opentitan学习

关于芯片设计、验证的入门学习书籍、以及一些小练习网上有很多书籍、视频、也有培训公司在做这方面工作。感谢他们在目前中国芯片行业急需工程师背景下所做的努力。网上做芯片验证培训的路科，我就觉得很好。我们大学这方面教学太缺了。

掌握基础知识如何通过项目提升，可能需要的时间更长，也更困难。

opentitan就是这样一个设计、验证的综合性项目。

虽然他是Google公司联合一些半导体公司以
[RISC-V](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=RISC-V&zhida_source=entity)
SOC和安全芯片为样本来打造，但是完全不影响我们把它作为我们入门芯片设计和验证后的实战项目。如果要流片，你也可以采用openLane工具链来生成版图。

#### 1 Opentitan项目介绍

[OpenTitan - OpenTitan Documentation

​


opentitan.org/book/doc/introduction.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/introduction.html)

才看到这个项目肯定会很懵，就让我们一点一点吃透这个项目。

除了在github开源了全部项目代码之外，我们可以通过文档学习到很多。

前几年国内成立太多芯片设计公司，建议补课。

#### 2 芯片设计的流程(前端)

1 设计验证

[https://

opentitan.org/book/doc/

getting\_started/setup\_dv.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/setup_dv.html)

2 形式验证

[https://

opentitan.org/book/doc/

getting\_started/setup\_formal.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/setup_formal.html)

3 创建测试软件（SOC需要）

[https://

opentitan.org/book/doc/

getting\_started/build\_sw.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/build_sw.html)

4 文档创建

[https://

opentitan.org/book/doc/

getting\_started/build\_docs.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/build_docs.html)

5 FPGA 验证

[https://

opentitan.org/book/doc/

getting\_started/using\_openocd.html](https://link.zhihu.com/?target=https%3A//opentitan.org/book/doc/getting_started/using_openocd.html)

#### 3 Opentitan芯片的设计验证

本篇文章就暂时从这款RISC-V芯片的设计和验证开始，看看我们改如何学习和下手这个项目。

简单来讲，SOC芯片就是 CPU core和 外围电路 加 总线 连接起来的功能模块。

先看看整体模块构成

![](https://i-blog.csdnimg.cn/img_convert/8422526580c363bb4f12f501217a9500.jpeg)

opentitan整体模块构成

可见 这是一个标准的SOC芯片。 还比较复杂，跟商业芯片业差不了太多。

指令集支持RV32IMCB（32位整数指令集 M 整型乘除法扩展 C 压缩指令集扩展 B 位操作扩展 ）大概相当于ARM cortex-M3的水平吧。

关于core看这个文档：

[https://ibex-core.readthedocs.io/en/latest/01\_overview/index.html

​


ibex-core.readthedocs.io/en/latest/01\_overview/index.html](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

[Introduction to Ibex](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

[Introduction to Ibex

​


ibex-core.readthedocs.io/en/latest/01\_overview/index.html](https://link.zhihu.com/?target=https%3A//ibex-core.readthedocs.io/en/latest/01_overview/index.html)

总线看这个文档：

[https://sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a\_tilelink-spec-1.7.1.pdf

​


sifive.cdn.prismic.io/sifive%2F57f93ecf-2c42-46f7-9818-bcdd7d39400a\_tilelink-spec-1.7.1.pdf](https://link.zhihu.com/?target=https%3A//sifive.cdn.prismic.io/sifive%252F57f93ecf-2c42-46f7-9818-bcdd7d39400a_tilelink-spec-1.7.1.pdf)

是SiFive公司的。前几年据说INTEL要收购SiFive，没有成功。芯片行业江湖爱恨情仇每天都在上演，不亚于电视连续剧。

我相信，各位跟关注外围模块的设计验证，这是大家入行最开始干的工作：

![](https://i-blog.csdnimg.cn/img_convert/e43cdf02a95533c5acec6024beb14e87.jpeg)

#### 4 UART 外围电路模块的设计和验证

![](https://i-blog.csdnimg.cn/img_convert/50f5fff8efa75e2c2d28fc0b763a5651.jpeg)

本篇文章就以这个最简单的UART模块讲解一下设计和验证的概述，详细在后面文章讲解。目前你暂时没有system verilo和UVM基础暂时也没关系，我带着你先入门再详细去学习这方面知识。

这方面我上面提的路科验证就可以。

设计：

一般芯片采用的verilog。这个项目采用的是
[system verilog](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=system+verilog&zhida_source=entity)
作为设计语言，但是也有自己的规范：

[style-guides/VerilogCodingStyle.md at master · lowRISC/style-guides

​


github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md

![](https://i-blog.csdnimg.cn/img_convert/b9e9535de559b82036fd73528cce1aa7.png)](https://link.zhihu.com/?target=https%3A//github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md)

各位到自己的公司也会有各个公司的设计语言规范。

```text
A template that demonstrates many of the items is given below.

```

Template:

// Copyright lowRISC contributors.
  
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
  
// SPDX-License-Identifier: Apache-2.0
  
//
  
// One line description of the module

module my\_module #(
  
parameter Width = 80,
  
parameter Height = 24
  
) (
  
input clk\_i,
  
input rst\_ni,
  
input req\_valid\_i,
  
input [Width-1:0] req\_data\_i,
  
output req\_ready\_o,
  
…
  
);

logic [Width-1:0] req\_data\_masked;

submodule u\_submodule (
  
.clk\_i,
  
.rst\_ni,
  
.req\_valid\_i,
  
.req\_data\_i (req\_data\_masked),
  
.req\_ready\_o(req\_ready),
  
…
  
);

always\_comb begin
  
req\_data\_masked = req\_data\_i;
  
case (fsm\_state\_q)
  
ST\_IDLE: begin
  
req\_data\_masked = req\_data\_i & MASK\_IDLE;
  
…
  
end

…

endmodule

另外 高度依赖
[Linting](https://zhida.zhihu.com/search?content_id=247046922&content_type=Article&match_order=1&q=Linting&zhida_source=entity)

#### “Linting is a productivity tool for designers to quickly find typos and bugs at the time when the RTL is written. Running lint is important when using SystemVerilog, a weakly-typed language, unlike other hardware description languages. We consider linting to be critical for conformance to our goals of high quality designs”

因为system verilog写起爽，可能其他工具就要跟上。

#### 5 UART功能框图和代码

![](https://i-blog.csdnimg.cn/img_convert/1002f7673d4e7ca1355d011bfe35ccfa.jpeg)

UART功能框图

#### 5.1 uart模块的TOP

```text
// Copyright lowRISC contributors.  

// Licensed under the Apache License, Version 2.0, see LICENSE for details.  

// SPDX-License-Identifier: Apache-2.0  

//  

// Description: UART top level wrapper file

```

`include “prim\_assert.sv”

module uart
  
import uart\_reg\_pkg:😗;
  
#(
  
parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1’b1}}
  
) (
  
input clk\_i,
  
input rst\_ni,

// Bus Interface
  
input tlul\_pkg::tl\_h2d\_t tl\_i,
  
output tlul\_pkg::tl\_d2h\_t tl\_o,

// Alerts
  
input prim\_alert\_pkg::alert\_rx\_t [NumAlerts-1:0] alert\_rx\_i,
  
output prim\_alert\_pkg::alert\_tx\_t [NumAlerts-1:0] alert\_tx\_o,

// Generic IO
  
input cio\_rx\_i,
  
output logic cio\_tx\_o,
  
output logic cio\_tx\_en\_o,

// Interrupts
  
output logic intr\_tx\_watermark\_o ,
  
output logic intr\_rx\_watermark\_o ,
  
output logic intr\_tx\_empty\_o ,
  
output logic intr\_rx\_overflow\_o ,
  
output logic intr\_rx\_frame\_err\_o ,
  
output logic intr\_rx\_break\_err\_o ,
  
output logic intr\_rx\_timeout\_o ,
  
output logic intr\_rx\_parity\_err\_o
  
);

logic [NumAlerts-1:0] alert\_test, alerts;
  
uart\_reg2hw\_t reg2hw;
  
uart\_hw2reg\_t hw2reg;

uart\_reg\_top u\_reg (
  
.clk\_i,
  
.rst\_ni,
  
.tl\_i,
  
.tl\_o,
  
.reg2hw,
  
.hw2reg,
  
// SEC\_CM: BUS.INTEGRITY
  
.intg\_err\_o (alerts[0]),
  
.devmode\_i (1’b1)
  
);

uart\_core uart\_core (
  
.clk\_i,
  
.rst\_ni,
  
.reg2hw,
  
.hw2reg,

```
.rx    (cio_rx_i   ),
.tx    (cio_tx_o   ),

.intr_tx_watermark_o,
.intr_rx_watermark_o,
.intr_tx_empty_o,
.intr_rx_overflow_o,
.intr_rx_frame_err_o,
.intr_rx_break_err_o,
.intr_rx_timeout_o,
.intr_rx_parity_err_o

```

);

// Alerts
  
assign alert\_test = {
  
reg2hw.alert\_test.q &
  
reg2hw.alert\_test.qe
  
};

for (genvar i = 0; i < NumAlerts; i++) begin : gen\_alert\_tx
  
prim\_alert\_sender #(
  
.AsyncOn(AlertAsyncOn[i]),
  
.IsFatal(1’b1)
  
) u\_prim\_alert\_sender (
  
.clk\_i,
  
.rst\_ni,
  
.alert\_test\_i ( alert\_test[i] ),
  
.alert\_req\_i ( alerts[0] ),
  
.alert\_ack\_o ( ),
  
.alert\_state\_o ( ),
  
.alert\_rx\_i ( alert\_rx\_i[i] ),
  
.alert\_tx\_o ( alert\_tx\_o[i] )
  
);
  
end

// always enable the driving out of TX
  
assign cio\_tx\_en\_o = 1’b1;

// Assert Known for outputs
  
`ASSERT(TxEnIsOne_A, cio_tx_en_o === 1'b1)`
ASSERT\_KNOWN(TxKnown\_A, cio\_tx\_o, clk\_i, !rst\_ni || !cio\_tx\_en\_o)

// Assert Known for alerts
  
`ASSERT\_KNOWN(AlertsKnown\_A, alert\_tx\_o)

// Assert Known for interrupts
  
`ASSERT_KNOWN(TxWatermarkKnown_A, intr_tx_watermark_o)`
ASSERT\_KNOWN(RxWatermarkKnown\_A, intr\_rx\_watermark\_o)
  
`ASSERT_KNOWN(TxEmptyKnown_A, intr_tx_empty_o)`
ASSERT\_KNOWN(RxOverflowKnown\_A, intr\_rx\_overflow\_o)
  
`ASSERT_KNOWN(RxFrameErrKnown_A, intr_rx_frame_err_o)`
ASSERT\_KNOWN(RxBreakErrKnown\_A, intr\_rx\_break\_err\_o)
  
`ASSERT_KNOWN(RxTimeoutKnown_A, intr_rx_timeout_o)`
ASSERT\_KNOWN(RxParityErrKnown\_A, intr\_rx\_parity\_err\_o)

// Alert assertions for reg\_we onehot check
  
`ASSERT\_PRIM\_REG\_WE\_ONEHOT\_ERROR\_TRIGGER\_ALERT(RegWeOnehotCheck\_A, u\_reg, alert\_tx\_o[0])
  
endmodule

代码下面是用于形式验证，暂时不管，可见核心是uart\_core:

其中.reg2hw .hw2reg

```text
  // Register -> HW type  

typedef struct packed {  

uart_reg2hw_intr_state_reg_t intr_state; // [126:119]  

uart_reg2hw_intr_enable_reg_t intr_enable; // [118:111]  

uart_reg2hw_intr_test_reg_t intr_test; // [110:95]  

uart_reg2hw_alert_test_reg_t alert_test; // [94:93]  

uart_reg2hw_ctrl_reg_t ctrl; // [92:68]  

uart_reg2hw_status_reg_t status; // [67:56]  

uart_reg2hw_rdata_reg_t rdata; // [55:47]  

uart_reg2hw_wdata_reg_t wdata; // [46:38]  

uart_reg2hw_fifo_ctrl_reg_t fifo_ctrl; // [37:27]  

uart_reg2hw_ovrd_reg_t ovrd; // [26:25]  

uart_reg2hw_timeout_ctrl_reg_t timeout_ctrl; // [24:0]  

} uart_reg2hw_t;  


```

```text
  // HW -> register type  

typedef struct packed {  

uart_hw2reg_intr_state_reg_t intr_state; // [64:49]  

uart_hw2reg_status_reg_t status; // [48:43]  

uart_hw2reg_rdata_reg_t rdata; // [42:35]  

uart_hw2reg_fifo_ctrl_reg_t fifo_ctrl; // [34:28]  

uart_hw2reg_fifo_status_reg_t fifo_status; // [27:16]  

uart_hw2reg_val_reg_t val; // [15:0]  

} uart_hw2reg_t;  


```

hw就是我们UART的硬件实现事宜叫hw。

及硬件电路与寄存器之间的关系

#### 5.2 core代码

```text
module uart_core (  

input                  clk_i,  

input                  rst_ni,

```

input uart\_reg\_pkg::uart\_reg2hw\_t reg2hw,
  
output uart\_reg\_pkg::uart\_hw2reg\_t hw2reg,

input rx,
  
output logic tx,

output logic intr\_tx\_watermark\_o,
  
output logic intr\_rx\_watermark\_o,
  
output logic intr\_tx\_empty\_o,
  
output logic intr\_rx\_overflow\_o,
  
output logic intr\_rx\_frame\_err\_o,
  
output logic intr\_rx\_break\_err\_o,
  
output logic intr\_rx\_timeout\_o,
  
output logic intr\_rx\_parity\_err\_o
  
);

import uart\_reg\_pkg:😗;

localparam int NcoWidth = $bits(reg2hw.ctrl.nco.q);

logic [15:0] rx\_val\_q;
  
logic [7:0] uart\_rdata;
  
logic tick\_baud\_x16, rx\_tick\_baud;
  
logic [5:0] tx\_fifo\_depth, rx\_fifo\_depth;
  
logic [5:0] rx\_fifo\_depth\_prev\_q;
  
logic [23:0] rx\_timeout\_count\_d, rx\_timeout\_count\_q, uart\_rxto\_val;
  
logic rx\_fifo\_depth\_changed, uart\_rxto\_en;
  
logic tx\_enable, rx\_enable;
  
logic sys\_loopback, line\_loopback, rxnf\_enable;
  
logic uart\_fifo\_rxrst, uart\_fifo\_txrst;
  
logic [2:0] uart\_fifo\_rxilvl;
  
logic [1:0] uart\_fifo\_txilvl;
  
logic ovrd\_tx\_en, ovrd\_tx\_val;
  
logic [7:0] tx\_fifo\_data;
  
logic tx\_fifo\_rready, tx\_fifo\_rvalid;
  
logic tx\_fifo\_wready, tx\_uart\_idle;
  
logic tx\_out;
  
logic tx\_out\_q;
  
logic [7:0] rx\_fifo\_data;
  
logic rx\_valid, rx\_fifo\_wvalid, rx\_fifo\_rvalid;
  
logic rx\_fifo\_wready, rx\_uart\_idle;
  
logic rx\_sync;
  
logic rx\_in;
  
logic break\_err;
  
logic [4:0] allzero\_cnt\_d, allzero\_cnt\_q;
  
logic allzero\_err, not\_allzero\_char;
  
logic event\_tx\_watermark, event\_rx\_watermark, event\_tx\_empty, event\_rx\_overflow;
  
logic event\_rx\_frame\_err, event\_rx\_break\_err, event\_rx\_timeout, event\_rx\_parity\_err;
  
logic tx\_watermark\_d, tx\_watermark\_prev\_q;
  
logic rx\_watermark\_d, rx\_watermark\_prev\_q;
  
logic tx\_uart\_idle\_q;

assign tx\_enable = reg2hw.ctrl.tx.q;
  
assign rx\_enable = reg2hw.ctrl.rx.q;
  
assign rxnf\_enable = reg2hw.ctrl.nf.q;
  
assign sys\_loopback = reg2hw.ctrl.slpbk.q;
  
assign line\_loopback = reg2hw.ctrl.llpbk.q;

assign uart\_fifo\_rxrst = reg2hw.fifo\_ctrl.rxrst.q & reg2hw.fifo\_ctrl.rxrst.qe;
  
assign uart\_fifo\_txrst = reg2hw.fifo\_ctrl.txrst.q & reg2hw.fifo\_ctrl.txrst.qe;
  
assign uart\_fifo\_rxilvl = reg2hw.fifo\_ctrl.rxilvl.q;
  
assign uart\_fifo\_txilvl = reg2hw.fifo\_ctrl.txilvl.q;

assign ovrd\_tx\_en = reg2hw.ovrd.txen.q;
  
assign ovrd\_tx\_val = reg2hw.ovrd.txval.q;

typedef enum logic {
  
BRK\_CHK,
  
BRK\_WAIT
  
} break\_st\_e ;

break\_st\_e break\_st\_q;

assign not\_allzero\_char = rx\_valid & (~event\_rx\_frame\_err | (rx\_fifo\_data != 8’h0));
  
assign allzero\_err = event\_rx\_frame\_err & (rx\_fifo\_data == 8’h0);

assign allzero\_cnt\_d = (break\_st\_q == BRK\_WAIT || not\_allzero\_char) ? 5’h0 :
  
//allzero\_cnt\_q[4] never be 1b without break\_st\_q as BRK\_WAIT
  
//allzero\_cnt\_q[4] ? allzero\_cnt\_q :
  
allzero\_err ? allzero\_cnt\_q + 5’d1 :
  
allzero\_cnt\_q;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) allzero\_cnt\_q <= '0;
  
else if (rx\_enable) allzero\_cnt\_q <= allzero\_cnt\_d;
  
end

// break\_err edges in same cycle as event\_rx\_frame\_err edges ; that way the
  
// reset-on-read works the same way for break and frame error interrupts.

always\_comb begin
  
unique case (reg2hw.ctrl.rxblvl.q)
  
2’h0: break\_err = allzero\_cnt\_d >= 5’d2;
  
2’h1: break\_err = allzero\_cnt\_d >= 5’d4;
  
2’h2: break\_err = allzero\_cnt\_d >= 5’d8;
  
default: break\_err = allzero\_cnt\_d >= 5’d16;
  
endcase
  
end

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) break\_st\_q <= BRK\_CHK;
  
else begin
  
unique case (break\_st\_q)
  
BRK\_CHK: begin
  
if (event\_rx\_break\_err) break\_st\_q <= BRK\_WAIT;
  
end

```
    BRK_WAIT: begin
      if (rx_in) break_st_q &lt;= BRK_CHK;
    end

    default: begin
      break_st_q &lt;= BRK_CHK;
    end
  endcase
end

```

end

assign hw2reg.val.d = rx\_val\_q;

assign hw2reg.rdata.d = uart\_rdata;

assign hw2reg.status.rxempty.d = ~rx\_fifo\_rvalid;
  
assign hw2reg.status.rxidle.d = rx\_uart\_idle;
  
assign hw2reg.status.txidle.d = tx\_uart\_idle & ~tx\_fifo\_rvalid;
  
assign hw2reg.status.txempty.d = ~tx\_fifo\_rvalid;
  
assign hw2reg.status.rxfull.d = ~rx\_fifo\_wready;
  
assign hw2reg.status.txfull.d = ~tx\_fifo\_wready;

assign hw2reg.fifo\_status.txlvl.d = tx\_fifo\_depth;
  
assign hw2reg.fifo\_status.rxlvl.d = rx\_fifo\_depth;

// resets are self-clearing, so need to update FIFO\_CTRL
  
assign hw2reg.fifo\_ctrl.rxilvl.de = 1’b0;
  
assign hw2reg.fifo\_ctrl.rxilvl.d = 3’h0;
  
assign hw2reg.fifo\_ctrl.txilvl.de = 1’b0;
  
assign hw2reg.fifo\_ctrl.txilvl.d = 2’h0;

// NCO 16x Baud Generator
  
// output clock rate is:
  
// Fin \* (NCO/2\*\*NcoWidth)
  
logic [NcoWidth:0] nco\_sum\_q; // extra bit to get the carry

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
nco\_sum\_q <= 17’h0;
  
end else if (tx\_enable || rx\_enable) begin
  
nco\_sum\_q <= {1’b0,nco\_sum\_q[NcoWidth-1:0]} + {1’b0,reg2hw.ctrl.nco.q[NcoWidth-1:0]};
  
end
  
end

assign tick\_baud\_x16 = nco\_sum\_q[16];

//
  
// TX Logic //
  
//

assign tx\_fifo\_rready = tx\_uart\_idle & tx\_fifo\_rvalid & tx\_enable;

prim\_fifo\_sync #(
  
.Width (8),
  
.Pass (1’b0),
  
.Depth (32)
  
) u\_uart\_txfifo (
  
.clk\_i,
  
.rst\_ni,
  
.clr\_i (uart\_fifo\_txrst),
  
.wvalid\_i(reg2hw.wdata.qe),
  
.wready\_o(tx\_fifo\_wready),
  
.wdata\_i (reg2hw.wdata.q),
  
.depth\_o (tx\_fifo\_depth),
  
.full\_o (),
  
.rvalid\_o(tx\_fifo\_rvalid),
  
.rready\_i(tx\_fifo\_rready),
  
.rdata\_o (tx\_fifo\_data),
  
.err\_o ()
  
);

uart\_tx uart\_tx (
  
.clk\_i,
  
.rst\_ni,
  
.tx\_enable,
  
.tick\_baud\_x16,
  
.parity\_enable (reg2hw.ctrl.parity\_en.q),
  
.wr (tx\_fifo\_rready),
  
.wr\_parity ((^tx\_fifo\_data) ^ reg2hw.ctrl.parity\_odd.q),
  
.wr\_data (tx\_fifo\_data),
  
.idle (tx\_uart\_idle),
  
.tx (tx\_out)
  
);

assign tx = line\_loopback ? rx : tx\_out\_q ;
  
always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
tx\_out\_q <= 1’b1;
  
end else if (ovrd\_tx\_en) begin
  
tx\_out\_q <= ovrd\_tx\_val ;
  
end else if (sys\_loopback) begin
  
tx\_out\_q <= 1’b1;
  
end else begin
  
tx\_out\_q <= tx\_out;
  
end
  
end

//
  
// RX Logic //
  
//

// sync the incoming data
  
prim\_flop\_2sync #(
  
.Width(1),
  
.ResetValue(1’b1)
  
) sync\_rx (
  
.clk\_i,
  
.rst\_ni,
  
.d\_i(rx),
  
.q\_o(rx\_sync)
  
);

// Based on: en.wikipedia.org/wiki/Repetition\_code mentions the use of a majority filter
  
// in UART to ignore brief noise spikes
  
logic rx\_sync\_q1, rx\_sync\_q2, rx\_in\_mx, rx\_in\_maj;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
rx\_sync\_q1 <= 1’b1;
  
rx\_sync\_q2 <= 1’b1;
  
end else begin
  
rx\_sync\_q1 <= rx\_sync;
  
rx\_sync\_q2 <= rx\_sync\_q1;
  
end
  
end

assign rx\_in\_maj = (rx\_sync & rx\_sync\_q1) |
  
(rx\_sync & rx\_sync\_q2) |
  
(rx\_sync\_q1 & rx\_sync\_q2);
  
assign rx\_in\_mx = rxnf\_enable ? rx\_in\_maj : rx\_sync;

assign rx\_in = sys\_loopback ? tx\_out :
  
line\_loopback ? 1’b1 :
  
rx\_in\_mx;

uart\_rx uart\_rx (
  
.clk\_i,
  
.rst\_ni,
  
.rx\_enable,
  
.tick\_baud\_x16,
  
.parity\_enable (reg2hw.ctrl.parity\_en.q),
  
.parity\_odd (reg2hw.ctrl.parity\_odd.q),
  
.tick\_baud (rx\_tick\_baud),
  
.rx\_valid,
  
.rx\_data (rx\_fifo\_data),
  
.idle (rx\_uart\_idle),
  
.frame\_err (event\_rx\_frame\_err),
  
.rx (rx\_in),
  
.rx\_parity\_err (event\_rx\_parity\_err)
  
);

assign rx\_fifo\_wvalid = rx\_valid & ~event\_rx\_frame\_err & ~event\_rx\_parity\_err;

prim\_fifo\_sync #(
  
.Width (8),
  
.Pass (1’b0),
  
.Depth (32)
  
) u\_uart\_rxfifo (
  
.clk\_i,
  
.rst\_ni,
  
.clr\_i (uart\_fifo\_rxrst),
  
.wvalid\_i(rx\_fifo\_wvalid),
  
.wready\_o(rx\_fifo\_wready),
  
.wdata\_i (rx\_fifo\_data),
  
.depth\_o (rx\_fifo\_depth),
  
.full\_o (),
  
.rvalid\_o(rx\_fifo\_rvalid),
  
.rready\_i(reg2hw.rdata.re),
  
.rdata\_o (uart\_rdata),
  
.err\_o ()
  
);

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) rx\_val\_q <= 16’h0;
  
else if (tick\_baud\_x16) rx\_val\_q <= {rx\_val\_q[14:0], rx\_in};
  
end

// Interrupt & Status //

always\_comb begin
  
unique case(uart\_fifo\_txilvl)
  
2’h0: tx\_watermark\_d = (tx\_fifo\_depth < 6’d2);
  
2’h1: tx\_watermark\_d = (tx\_fifo\_depth < 6’d4);
  
2’h2: tx\_watermark\_d = (tx\_fifo\_depth < 6’d8);
  
default: tx\_watermark\_d = (tx\_fifo\_depth < 6’d16);
  
endcase
  
end

assign event\_tx\_watermark = tx\_watermark\_d & ~tx\_watermark\_prev\_q;

// The empty condition handling is a bit different.
  
// If empty rising conditions were detected directly, then every first write of a burst
  
// would trigger an empty. This is due to the fact that the uart\_tx fsm immediately
  
// withdraws the content and asserts “empty”.
  
// To guard against this false trigger, empty is qualified with idle to extend the window
  
// in which software has an opportunity to deposit new data.
  
// However, if software deposit speed is TOO slow, this would still be an issue.
  
//
  
// The alternative software fix is to disable tx\_enable until it has a chance to
  
// burst in the desired amount of data.
  
assign event\_tx\_empty = ~tx\_fifo\_rvalid & ~tx\_uart\_idle\_q & tx\_uart\_idle;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
tx\_watermark\_prev\_q <= 1’b1; // by default watermark condition is true
  
rx\_watermark\_prev\_q <= 1’b0; // by default watermark condition is false
  
tx\_uart\_idle\_q <= 1’b1;
  
end else begin
  
tx\_watermark\_prev\_q <= tx\_watermark\_d;
  
rx\_watermark\_prev\_q <= rx\_watermark\_d;
  
tx\_uart\_idle\_q <= tx\_uart\_idle;
  
end
  
end

always\_comb begin
  
unique case(uart\_fifo\_rxilvl)
  
3’h0: rx\_watermark\_d = (rx\_fifo\_depth >= 6’d1);
  
3’h1: rx\_watermark\_d = (rx\_fifo\_depth >= 6’d4);
  
3’h2: rx\_watermark\_d = (rx\_fifo\_depth >= 6’d8);
  
3’h3: rx\_watermark\_d = (rx\_fifo\_depth >= 6’d16);
  
3’h4: rx\_watermark\_d = (rx\_fifo\_depth >= 6’d30);
  
default: rx\_watermark\_d = 1’b0;
  
endcase
  
end

assign event\_rx\_watermark = rx\_watermark\_d & ~rx\_watermark\_prev\_q;

// rx timeout interrupt
  
assign uart\_rxto\_en = reg2hw.timeout\_ctrl.en.q;
  
assign uart\_rxto\_val = reg2hw.timeout\_ctrl.val.q;

assign rx\_fifo\_depth\_changed = (rx\_fifo\_depth != rx\_fifo\_depth\_prev\_q);

assign rx\_timeout\_count\_d =
  
// don’t count if timeout feature not enabled ;
  
// will never reach timeout val + lower power
  
(uart\_rxto\_en == 1’b0) ? 24’d0 :
  
// reset count if timeout interrupt is set
  
event\_rx\_timeout ? 24’d0 :
  
// reset count upon change in fifo level: covers both read and receiving a new byte
  
rx\_fifo\_depth\_changed ? 24’d0 :
  
// reset count if no bytes are pending
  
(rx\_fifo\_depth == '0) ? 24’d0 :
  
// stop the count at timeout value (this will set the interrupt)
  
// Removed below line as when the timeout reaches the value,
  
// event occured, and timeout value reset to 0h.
  
//(rx\_timeout\_count\_q == uart\_rxto\_val) ? rx\_timeout\_count\_q :
  
// increment if at rx baud tick
  
rx\_tick\_baud ? (rx\_timeout\_count\_q + 24’d1) :
  
rx\_timeout\_count\_q;

assign event\_rx\_timeout = (rx\_timeout\_count\_q == uart\_rxto\_val) & uart\_rxto\_en;

always\_ff @(posedge clk\_i or negedge rst\_ni) begin
  
if (!rst\_ni) begin
  
rx\_timeout\_count\_q <= 24’d0;
  
rx\_fifo\_depth\_prev\_q <= 6’d0;
  
end else begin
  
rx\_timeout\_count\_q <= rx\_timeout\_count\_d;
  
rx\_fifo\_depth\_prev\_q <= rx\_fifo\_depth;
  
end
  
end

assign event\_rx\_overflow = rx\_fifo\_wvalid & ~rx\_fifo\_wready;
  
assign event\_rx\_break\_err = break\_err & (break\_st\_q == BRK\_CHK);

// instantiate interrupt hardware primitives

prim\_intr\_hw #(.Width(1)) intr\_hw\_tx\_watermark (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_tx\_watermark),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.tx\_watermark.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.tx\_watermark.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.tx\_watermark.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.tx\_watermark.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.tx\_watermark.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.tx\_watermark.d),
  
.intr\_o (intr\_tx\_watermark\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_watermark (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_watermark),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_watermark.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_watermark.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_watermark.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_watermark.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_watermark.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_watermark.d),
  
.intr\_o (intr\_rx\_watermark\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_tx\_empty (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_tx\_empty),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.tx\_empty.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.tx\_empty.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.tx\_empty.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.tx\_empty.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.tx\_empty.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.tx\_empty.d),
  
.intr\_o (intr\_tx\_empty\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_overflow (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_overflow),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_overflow.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_overflow.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_overflow.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_overflow.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_overflow.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_overflow.d),
  
.intr\_o (intr\_rx\_overflow\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_frame\_err (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_frame\_err),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_frame\_err.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_frame\_err.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_frame\_err.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_frame\_err.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_frame\_err.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_frame\_err.d),
  
.intr\_o (intr\_rx\_frame\_err\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_break\_err (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_break\_err),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_break\_err.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_break\_err.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_break\_err.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_break\_err.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_break\_err.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_break\_err.d),
  
.intr\_o (intr\_rx\_break\_err\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_timeout (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_timeout),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_timeout.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_timeout.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_timeout.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_timeout.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_timeout.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_timeout.d),
  
.intr\_o (intr\_rx\_timeout\_o)
  
);

prim\_intr\_hw #(.Width(1)) intr\_hw\_rx\_parity\_err (
  
.clk\_i,
  
.rst\_ni,
  
.event\_intr\_i (event\_rx\_parity\_err),
  
.reg2hw\_intr\_enable\_q\_i (reg2hw.intr\_enable.rx\_parity\_err.q),
  
.reg2hw\_intr\_test\_q\_i (reg2hw.intr\_test.rx\_parity\_err.q),
  
.reg2hw\_intr\_test\_qe\_i (reg2hw.intr\_test.rx\_parity\_err.qe),
  
.reg2hw\_intr\_state\_q\_i (reg2hw.intr\_state.rx\_parity\_err.q),
  
.hw2reg\_intr\_state\_de\_o (hw2reg.intr\_state.rx\_parity\_err.de),
  
.hw2reg\_intr\_state\_d\_o (hw2reg.intr\_state.rx\_parity\_err.d),
  
.intr\_o (intr\_rx\_parity\_err\_o)
  
);

// unused registers
  
logic unused\_reg;
  
assign unused\_reg = ^reg2hw.alert\_test;

endmodule

core代码有点多，其核心就是一个带FIFO的uart实现。其他不分是所有模块都有的部分，是中断和错误的管理。

到现在，你会发现这个项目真是一个宝库，完全可以实践你学的设计和验证技巧，并且实现得非常规范，是一个很好的范例。

### 后续

罗马不是一天建成的。要在AI时代成为时代的弄潮儿，一定要打下扎实的基础，才能发挥你的创造力

后面我会介绍使用什么工具链和使用自己的工具链如何来设计和验证这个项目的每个模块。

一天一天的进步。

欢迎关注我这个新项目。

为自己加油！