---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f53616b7572615f64696e672f:61727469636c652f64657461696c732f313436323037323139"
layout: post
title: "深度学习图像卷积"
date: 2025-03-12 16:21:56 +08:00
description: "上节我们解析了卷积层的原理，现在我们看看它的实际应用。由于卷积神经网络的设计是用于探索图像数据，本节我们将以图像为例。"
keywords: "【深度学习】图像卷积"
categories: ['深度学习']
tags: ['深度学习', '人工智能']
artid: "146207219"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146207219
    alt: "深度学习图像卷积"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146207219
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146207219
cover: https://bing.ee123.net/img/rand?artid=146207219
image: https://bing.ee123.net/img/rand?artid=146207219
img: https://bing.ee123.net/img/rand?artid=146207219
---

# 【深度学习】图像卷积

## 图像卷积

上节我们解析了卷积层的原理，现在我们看看它的实际应用。由于卷积神经网络的设计是用于探索图像数据，本节我们将以图像为例。

### 互相关运算

严格来说，卷积层是个错误的叫法，因为它所表达的运算其实是
*互相关运算*
（cross-correlation），而不是卷积运算。
  
已知，在卷积层中，输入张量和核张量通过(
**互相关运算**
)产生输出张量。
  




[
H
]
i
,
j
=
u
+
∑
a
=
−
Δ
Δ
∑
b
=
−
Δ
Δ
[
V
]
a
,
b
[
X
]
i
+
a
,
j
+
b
.
[\mathbf{H}]\_{i, j} = u + \sum\_{a = -\Delta}^{\Delta} \sum\_{b = -\Delta}^{\Delta} [\mathbf{V}]\_{a, b} [\mathbf{X}]\_{i+a, j+b}.





[

H


]










i

,

j

​




=





u



+














a

=

−

Δ





∑






Δ

​













b

=

−

Δ





∑






Δ

​


[

V


]










a

,

b

​


[

X


]










i

+

a

,

j

+

b

​


.

V
\mathbf{V}





V
被称为
***卷积核***
（convolution kernel）或者
***滤波器***
（filter）。

首先，我们暂时忽略通道（第三维）这一情况，看看如何处理二维图像数据和隐藏表示。

在图6.2.1中，输入是高度为

3
3





3
、宽度为

3
3





3
的二维张量（即形状为

3
×
3
3 \times 3





3



×





3
）。卷积核的高度和宽度都是

2
2





2
，
**而卷积核窗口（或卷积窗口）的形状由内核的高度和宽度决定**
（即

2
×
2
2 \times 2





2



×





2
）。
  
![图6.2.1](https://i-blog.csdnimg.cn/direct/9123b761e76d4c60ba8ebc02085f18ac.png)

在二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。
  
当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。
  
在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为

2
2





2
、宽度为

2
2





2
，如下所示：

0
×
0
+
1
×
1
+
3
×
2
+
4
×
3
=
19
,
1
×
0
+
2
×
1
+
4
×
2
+
5
×
3
=
25
,
3
×
0
+
4
×
1
+
6
×
2
+
7
×
3
=
37
,
4
×
0
+
5
×
1
+
7
×
2
+
8
×
3
=
43.
0\times0+1\times1+3\times2+4\times3=19,\\ 1\times0+2\times1+4\times2+5\times3=25,\\ 3\times0+4\times1+6\times2+7\times3=37,\\ 4\times0+5\times1+7\times2+8\times3=43.





0



×





0



+





1



×





1



+





3



×





2



+





4



×





3



=





19

,






1



×





0



+





2



×





1



+





4



×





2



+





5



×





3



=





25

,






3



×





0



+





4



×





1



+





6



×





2



+





7



×





3



=





37

,






4



×





0



+





5



×





1



+





7



×





2



+





8



×





3



=





43.

注意，输出大小略小于输入大小。这是因为卷积核的宽度和高度大于1，而卷积核只与图像中每个大小完全适合的位置进行互相关运算。

所以，输出大小等于输入大小

n
h
×
n
w
n\_h \times n\_w






n









h

​




×






n









w

​

减去卷积核大小

k
h
×
k
w
k\_h \times k\_w






k









h

​




×






k









w

​

，即：（）

(
n
h
−
k
h
+
1
)
×
(
n
w
−
k
w
+
1
)
.
(n\_h-k\_h+1) \times (n\_w-k\_w+1).





(


n









h

​




−






k









h

​




+





1

)



×





(


n









w

​




−






k









w

​




+





1

)

.

这是因为我们需要足够的空间在图像上“移动”卷积核。稍后，我们将看到如何通过在图像边界周围填充零来保证有足够的空间移动卷积核，从而保持输出大小不变。
  
接下来，我们在
`corr2d`
函数中实现如上过程，该函数接受输入张量
`X`
和卷积核张量
`K`
，并返回输出张量
`Y`
。

```python
import torch
from torch import nn
from d2l import torch as d2l

```

```python
def corr2d(X, K):  #@save
    """
    计算二维互相关运算。

    参数:
    X (torch.Tensor): 输入的二维张量。
    K (torch.Tensor): 卷积核的二维张量。

    返回:
    torch.Tensor: 互相关运算后的二维张量。
    """
    # 获取卷积核的高度和宽度
    h, w = K.shape
    # 初始化输出张量，其大小由输入张量和卷积核大小决定
    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    # 遍历输出张量的每一行
    for i in range(Y.shape[0]):
        # 遍历输出张量的每一列
        for j in range(Y.shape[1]):
            # 计算输入张量与卷积核对应区域的逐元素乘积之和，并赋值给输出张量的对应位置
            Y[i, j] = (X[i:i + h, j:j + w] * K).sum()
    return Y

```

通过 图6.2.1的输入张量
`X`
和卷积核张量
`K`
，我们来[
**验证上述二维互相关运算的输出**
]。

```python
X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])
K = torch.tensor([[0.0, 1.0], [2.0, 3.0]])
corr2d(X, K)

```

```
tensor([[19., 25.],
        [37., 43.]])

```

### 卷积层

卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。

所以，卷积层中的两个被训练的参数是
`卷积核权重`
和
`标量偏置`
。
  
就像我们之前随机初始化全连接层一样，在训练基于卷积层的模型时，我们也随机初始化卷积核权重。

基于上面定义的
`corr2d`
函数[
**实现二维卷积层**
]。在
`__init__`
构造函数中，将
`weight`
和
`bias`
声明为两个模型参数。前向传播函数调用
`corr2d`
函数并添加偏置。

```python
class Conv2D(nn.Module):
    """
    自定义的二维卷积层。

    参数:
    kernel_size (tuple): 卷积核的大小，格式为 (height, width)。
    """
    def __init__(self, kernel_size):
        # 调用父类 nn.Module 的构造函数
        super().__init__()
        # 定义可学习的卷积核权重，初始化为随机值
        self.weight = nn.Parameter(torch.rand(kernel_size))
        # 定义可学习的偏置，初始化为零
        self.bias = nn.Parameter(torch.zeros(1))

    def forward(self, x):
        """
        前向传播方法。

        参数:
        x (torch.Tensor): 输入的二维张量。

        返回:
        torch.Tensor: 经过卷积和偏置加法后的输出张量。
        """
        # 计算输入与卷积核的互相关，并加上偏置
        return corr2d(x, self.weight) + self.bias

```

高度和宽度分别为

h
h





h
和

w
w





w
的卷积核可以被称为

h
×
w
h \times w





h



×





w
卷积或

h
×
w
h \times w





h



×





w
卷积核。
  
我们也将带有

h
×
w
h \times w





h



×





w
卷积核的卷积层称为

h
×
w
h \times w





h



×





w
卷积层。

### 图像中目标的边缘检测

如下是[
**卷积层的一个简单应用：**
]通过找到像素变化的位置，来(
**检测图像中不同颜色的边缘**
)。

首先，我们构造一个

6
×
8
6\times 8





6



×





8
像素的黑白图像。中间四列为黑色（

0
0





0
），其余像素为白色（

1
1





1
）。

```python
X = torch.ones((6, 8))
X[:, 2:6] = 0
X

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/41aebf1dfa28406a9a046bfbd62c976f.png)
  
接下来，我们构造一个高度为

1
1





1
、宽度为

2
2





2
的卷积核
`K`
。当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零。

```python
K = torch.tensor([[1.0, -1.0]])

```

现在，我们对参数
`X`
（输入）和
`K`
（卷积核）执行互相关运算。
  
如下所示，[
**输出
`Y`
中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘**
]，其他情况的输出为

0
0





0
。

```python
Y = corr2d(X, K)
Y

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/18dfbd8cab104849b53ec0a6675b7e3f.png)

现在我们将输入的二维图像转置，再进行如上的互相关运算。

其输出如下，之前检测到的垂直边缘消失了。不出所料，这个[
**卷积核
`K`
只可以检测垂直边缘**
]，无法检测水平边缘。

```python
corr2d(X.t(), K)

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/614b2f7b44a944ea88be4cfca29d1cc1.png)

> 在 PyTorch 里，.t() 是张量（Tensor）对象的一个方法，它的作用是对二维张量进行转置操作。也就是说，它会把一个二维张量的行和列进行互换。

### 学习卷积核

如果我们只需寻找黑白边缘，那么以上
`[1, -1]`
的边缘检测器足以。
  
然而，当有了更复杂数值的卷积核，或者连续的卷积层时，我们不可能手动设计滤波器。那么我们是否可以[
**学习由
`X`
生成
`Y`
的卷积核**
]呢？

现在让我们看看是否可以通过仅查看“输入-输出”对来学习由
`X`
生成
`Y`
的卷积核。
  
我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较
`Y`
与卷积层输出的平方误差，然后计算梯度来更新卷积核。
  
为了简单起见，我们在此使用内置的二维卷积层，并忽略偏置。

```python
# 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核，且不使用偏置
conv2d = nn.Conv2d(1, 1, kernel_size=(1, 2), bias=False)

# 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），
# 其中批量大小和通道数都为1
X = X.reshape((1, 1, 6, 8))
Y = Y.reshape((1, 1, 6, 7))
lr = 3e-2  # 学习率

for i in range(10):
    # 通过卷积层对输入 X 进行前向传播，得到预测输出 Y_hat
    Y_hat = conv2d(X)
    # 计算预测输出 Y_hat 与真实输出 Y 之间的均方误差损失
    l = (Y_hat - Y) ** 2
    # 清空卷积层的梯度
    conv2d.zero_grad()
    # 对损失求和并进行反向传播，计算梯度
    l.sum().backward()
    # 根据梯度和学习率更新卷积层的权重
    conv2d.weight.data[:] -= lr * conv2d.weight.grad
    # 每迭代2次，打印当前的训练轮数和损失值
    if (i + 1) % 2 == 0:
        print(f'epoch {i+1}, loss {l.sum():.3f}')

```

```
epoch 2, loss 3.657
epoch 4, loss 0.675
epoch 6, loss 0.138
epoch 8, loss 0.033
epoch 10, loss 0.010

```

在

10
10





10
次迭代之后，误差已经降到足够低。现在我们来看看我们[
**所学的卷积核的权重张量**
]。

```python
conv2d.weight.data.reshape((1, 2))

```

```
conv2d.weight.data.reshape((1, 2))

```

细心的读者一定会发现，我们学习到的卷积核权重非常接近我们之前定义的卷积核
`K`
。

### 互相关和卷积

回想一下我们在观察到的互相关和卷积运算之间的对应关系。
  
为了得到正式的
*卷积*
运算输出，我们需要执行严格的卷积运算
  




(
f
∗
g
)
(
i
,
j
)
=
∑
a
∑
b
f
(
a
,
b
)
g
(
i
−
a
,
j
−
b
)
.
(f * g)(i, j) = \sum\_a\sum\_b f(a, b) g(i-a, j-b).





(

f



∗





g

)

(

i

,



j

)



=













a





∑

​












b





∑

​




f

(

a

,



b

)

g

(

i



−





a

,



j



−





b

)

.
，而不是互相关运算。

幸运的是，它们差别不大，我们只需水平和垂直翻转二维卷积核张量，然后对输入张量执行
*互相关*
运算。

值得注意的是，由于卷积核是从数据中学习到的，因此无论这些层执行严格的卷积运算还是互相关运算，卷积层的输出都不会受到影响。
  
为了说明这一点，假设卷积层执行
*互相关*
运算并学习图6.2.1中的卷积核，该卷积核在这里由矩阵

K
\mathbf{K}





K
表示。
  
假设其他条件不变，当这个层执行严格的
*卷积*
时，学习的卷积核

K
′
\mathbf{K}'






K










′
在水平和垂直翻转之后将与

K
\mathbf{K}





K
相同。
  
也就是说，当卷积层对 图6.2.1中的输入和

K
′
\mathbf{K}'






K










′
执行严格
*卷积*
运算时，将得到与互相关运算 图6.2.1中相同的输出。

为了与深度学习文献中的标准术语保持一致，我们将继续把“互相关运算”称为卷积运算，尽管严格地说，它们略有不同。
  
此外，对于卷积核张量上的权重，我们称其为
*元素*
。

### 特征映射和感受野

已知 图6.2.1中输出的卷积层有时被称为
*特征映射*
（feature map），因为它可以被视为一个输入映射到下一层的空间维度的转换器。

在卷积神经网络中，对于某一层的任意元素

x
x





x
，其
***感受野***
（receptive field）是指在前向传播期间可能影响

x
x





x
计算的所有元素（来自所有先前层）。

请注意，感受野可能大于输入的实际大小。让我们用图6.2.1为例来解释感受野：

给定

2
×
2
2 \times 2





2



×





2
卷积核，阴影输出元素值

19
19





19
的感受野是输入阴影部分的四个元素。假设之前输出为

Y
\mathbf{Y}





Y
，其大小为

2
×
2
2 \times 2





2



×





2
，现在我们在其后附加一个卷积层，该卷积层以

Y
\mathbf{Y}





Y
为输入，输出单个元素

z
z





z
。在这种情况下，

Y
\mathbf{Y}





Y
上的

z
z





z
的感受野包括

Y
\mathbf{Y}





Y
的所有四个元素，而输入的感受野包括最初所有九个输入元素。
  
因此，当一个特征图中的任意元素需要检测更广区域的输入特征时，我们可以构建一个更深的网络。