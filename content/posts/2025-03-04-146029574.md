---
layout: post
title: "一个月备战蓝桥算法递归与递推"
date: 2025-03-04 23:11:58 +0800
description: "将整数序列看作由数字组成的字符串，从序列的第一个元素开始逐个比较元素的大小，如果对应位置的元素不同，则元素值小的序列排在前面；比较 \"apple\" 和 \"banana\"，因为第一个字符 'a' 的 ASCII 码值小于 'b'，所以 \"apple\" 在字典序中排在 \"banana\" 前面。比较 \"apple\" 和 \"app\"，前三个字符都相同，但 \"app\" 先结束，所以 \"app\" 在字典序中排在 \"apple\" 前面。：要求输出给定序列的所有全排列，并且按照字典序输出。，其全排列按照字典序输出为。"
keywords: "【一个月备战蓝桥算法】递归与递推"
categories: ['一个月学习蓝桥杯']
tags: ['算法']
artid: "146029574"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146029574
    alt: "一个月备战蓝桥算法递归与递推"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146029574
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146029574
cover: https://bing.ee123.net/img/rand?artid=146029574
image: https://bing.ee123.net/img/rand?artid=146029574
img: https://bing.ee123.net/img/rand?artid=146029574
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【一个月备战蓝桥算法】递归与递推
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h6 id="main-toc" name="tableOfContents">
     字典序
    </h6>
    <p>
     在刷题和计算机科学领域，字典序（Lexicographical order）也称为词典序、字典顺序、字母序，是一种对序列元素进行排序的方式，它模仿了字典中单词的排序规则。下面从不同的数据类型来详细解释字典序：
    </p>
    <p>
     <strong>
      字符串的字典序
     </strong>
    </p>
    <p>
     在字典中，单词是按照字母的先后顺序排列的。对于两个字符串，字典序的比较规则如下：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        比较过程
       </strong>
       ：从两个字符串的第一个字符开始逐个比较，如果对应位置的字符不同，则字符 ASCII 码值小的字符串排在前面；如果对应位置字符相同，则继续比较下一个位置的字符，直到出现不同字符或者其中一个字符串结束。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         比较 "apple" 和 "banana"，因为第一个字符 'a' 的 ASCII 码值小于 'b'，所以 "apple" 在字典序中排在 "banana" 前面。
        </p>
       </li>
       <li>
        <p>
         比较 "apple" 和 "app"，前三个字符都相同，但 "app" 先结束，所以 "app" 在字典序中排在 "apple" 前面。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      整数序列的字典序
     </strong>
    </p>
    <p>
     对于整数序列，同样可以按照字典序进行比较：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        比较过程
       </strong>
       ：将整数序列看作由数字组成的字符串，从序列的第一个元素开始逐个比较元素的大小，如果对应位置的元素不同，则元素值小的序列排在前面；如果对应位置元素相同，则继续比较下一个位置的元素，直到出现不同元素或者其中一个序列结束。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         比较序列
         <code>
          [1, 2, 3]
         </code>
         和
         <code>
          [2, 1, 3]
         </code>
         ，第一个元素 1 小于 2，所以
         <code>
          [1, 2, 3]
         </code>
         在字典序中排在
         <code>
          [2, 1, 3]
         </code>
         前面。
        </p>
       </li>
       <li>
        <p>
         比较序列
         <code>
          [1, 2, 3]
         </code>
         和
         <code>
          [1, 2]
         </code>
         ，前两个元素都相同，但
         <code>
          [1, 2]
         </code>
         先结束，所以
         <code>
          [1, 2]
         </code>
         在字典序中排在
         <code>
          [1, 2, 3]
         </code>
         前面。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      在刷题中的应用
     </strong>
    </p>
    <p>
     在很多算法题中，字典序常常作为排序的依据或者要求输出的结果满足字典序的要求，例如：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        全排列问题
       </strong>
       ：要求输出给定序列的所有全排列，并且按照字典序输出。例如，对于序列
       <code>
        [1, 2, 3]
       </code>
       ，其全排列按照字典序输出为
       <code>
        [1, 2, 3]
       </code>
       、
       <code>
        [1, 3, 2]
       </code>
       、
       <code>
        [2, 1, 3]
       </code>
       、
       <code>
        [2, 3, 1]
       </code>
       、
       <code>
        [3, 1, 2]
       </code>
       、
       <code>
        [3, 2, 1]
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        子集问题
       </strong>
       ：可能要求输出所有子集，并且按照字典序排列。
      </p>
     </li>
    </ul>
    <p>
     代码示例（C++ 实现全排列并按字典序输出）
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; nums = {1, 2, 3};
    do {
        for (int num : nums) {
            std::cout &lt;&lt; num &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    } while (std::next_permutation(nums.begin(), nums.end()));
    return 0;
}</code></pre>
    <p>
     这些代码示例展示了如何生成全排列并按字典序输出，在刷题中可以根据具体需求对代码进行调整。
    </p>
    <h6 id="92.%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE" name="92.%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE">
     92.递归实现指数型枚举
    </h6>
    <p>
     <img alt="" height="1678" src="https://i-blog.csdnimg.cn/direct/ea083b20da6f4000a7d2f26803314403.png" width="2232"/>
    </p>
    <pre><code class="language-cpp"> #include &lt;cstdio&gt;
 #include &lt;cstring&gt;
 #include &lt;iostream&gt;
 #include &lt;algorithm&gt;
 
 using namespace std;
 
 const int N = 16; // 最大数据范围
 int statu[N]; // 状态数组 0表示未考虑 1表示选 2表示不选
 int n; // 标准输入
 
 void dfs(int u) // d
 {
     if(u &gt; n) // 考虑到了最后一个位置 -- 递归出口
     {
        // 打印所有的数
        for(int i = 0; i &lt;= n; i++)
        {
            if(statu[i] == 1)
            printf("%d ", i);
        }
        printf("\n");// 打印换行，表示这一次枚举完毕
        return;// 返回上一层
     }
     
     // 不选的情况
     statu[u] = 2;
     dfs(u+1);
     statu[u] = 0;// 恢复现场
     
     // 选的情况
     statu[u] = 1;
     dfs(u+1);
     statu[u] = 0; 
     
 }
 
 int main()
 {
     cin &gt;&gt; n;
     dfs(1); //对第1个数进行考虑
     return 0;
 }</code></pre>
    <h6 id="%C2%A094.%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE" name="%C2%A094.%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE">
     94.递归实现排列型枚举
    </h6>
    <p>
     <img alt="" height="1528" src="https://i-blog.csdnimg.cn/direct/537c9acb7ecb4b6ba8d6639cb91624bc.png" width="2290"/>
    </p>
    <p>
     <img alt="" height="594" src="https://i-blog.csdnimg.cn/direct/4e20a113411846bd854c82235a1e7c4a.png" width="1620"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

 // 数组定义成全局变量，初始值一定是0，如果定义成局部变量，初始值随机
const int N = 10;
int status[N]; // 0表示未填入 1—n表示填入的数
bool used[N];// 标记这个数有没有被用过 true用过 false没有用过
int n;

void dfs(int u)
{
    // 递归出口
    if(u &gt; n)
    {
        for(int i = 1; i &lt;= n; i++) printf("%d ", status[i]);
        puts("");
        return;
    }
    
    // 依此枚举每个分支，即当前位置可以填哪些数
    for(int i = 1; i &lt;= n; i++)
    {
        if(!used[i]) // 当前的数没有用
        {
            status[u] = i; // 填入这个数
            used[i] = true; // 标记已使用
            dfs(u + 1);
            
            // 恢复现场
            used[i] = false;
            status[u] = 0;
        }
    }
    
}

int main()
{
    scanf("%d", &amp;n);
    dfs(1);
    return 0;
}</code></pre>
    <h6 id="%C2%A093.%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE" name="%C2%A093.%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE">
     93.递归实现组合型枚举
    </h6>
    <p>
     <img alt="" height="1832" src="https://i-blog.csdnimg.cn/direct/8512ef49b3a44869a17393ea590403cd.png" width="2248"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
int n, m;
const int N = 30;
int status[N];



void dfs(int u, int start)
{
    // （u-1 + n - start + 1 &lt; m）
    if(u + n - start &lt; m) return; // 剪枝 -- start后面的数加起来都不够凑m个数
    // 递归出口
    if(u &gt; m)
    {
        for(int i = 1; i &lt;= m; i++) printf("%d ", status[i]);
        puts("");
        return;
    }
    
    for(int i = start; i &lt;= n; i++)
    {
        status[u] = i;
        dfs(u+1, i+1);
        // 恢复现场
        status[u] = 0;
    }
}

int main()
{
    scanf("%d %d", &amp;n, &amp;m);
    dfs(1, 1);
    return 0;
}</code></pre>
    <h6 id="%C2%A01209.%E5%B8%A6%E5%88%86%E6%95%B0" name="%C2%A01209.%E5%B8%A6%E5%88%86%E6%95%B0">
     1209.带分数
    </h6>
    <p>
     <img alt="" height="1788" src="https://i-blog.csdnimg.cn/direct/b0aba1bdf6dc42a6bb60db2917daf697.png" width="2264"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
const int N = 10;
int ans = 0;

int n;
bool status[N]; // 判重数组
bool backup[N];

bool check(int a, int c)
{
    long long b = n * (long long)c - a * c;
    
    // a b c 不能为0
    if(!a || !b || !c) return false;
    
    memcpy(backup, status, sizeof(status));
    while(b)
    {
        int x = b % 10;
        b = b / 10;
        
        // x在ac中不能出现, x不能为0
        if(!x || backup[x]) return false;
        backup[x] = true; 
    }
    // 看看每个数字是否出现过 -- 必须全部出现
    for(int i = 1; i &lt;= 9; i++)
    {
        if(!backup[i]) return false;
    }
    return true;
}

void dfs_c(int u, int a, int c)
{
    if(u == n) return;
    if(check(a, c)) ans++;
    
    for(int i = 1; i &lt;= 9; i++)
    {
        if(!status[i])
        {
            status[i] = true;
            dfs_c(u+1, a, c * 10 +i);
            status[i] = false;
        }
    }

}

void dfs_a(int u, int a)
{
    if(a &gt;= n) return; 
    if(a) dfs_c(u, a, 0); // 只要a小于n，每种情况下都有dfs_c
    
    for(int i = 1; i &lt;= 9; i++)
    {
        if(!status[i])
        {
            status[i] = true;
            dfs_a(u+1, a * 10 + i);
            status[i] = false; 
        }
    }
}

int main()
{
    cin &gt;&gt; n;
    dfs_a(0, 0);  // 当前已经用了多少个数字，  最开始a是0 
    
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
    <h6 id="%C2%A0717.%E7%AE%80%E5%8D%95%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91" name="%C2%A0717.%E7%AE%80%E5%8D%95%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91">
     717.简单斐波那契
    </h6>
    <p>
     <img alt="" height="1356" src="https://i-blog.csdnimg.cn/direct/530e7666d6e74962b5102a962f8cc863.png" width="2258"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    int n = 0;
    cin &gt;&gt; n;
    
    int F[47];
    F[0] = 0, F[1] = 1, F[2] = 1;
    
    for(int i = 3; i &lt;= n; i++)
    {
        F[i] = F[i-1] + F[i-2];
    }
    for(int i = 0; i &lt; n; i++)
    {
        cout &lt;&lt; F[i] &lt;&lt; " ";
    }
    return 0;
}</code></pre>
    <p>
     优化
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    int n; cin &gt;&gt; n;
    int a = 0, b = 1;
    for(int i = 1; i &lt;= n; i++)
    {
        cout &lt;&lt; a &lt;&lt; ' ';
        int fn = a + b;
        a = b; b = fn;
    }
    return 0;
}</code></pre>
    <h6 id="1208.%E7%BF%BB%E7%A1%AC%E5%B8%81" name="1208.%E7%BF%BB%E7%A1%AC%E5%B8%81">
     1208.翻硬币
    </h6>
    <p>
     <img alt="" height="2034" src="https://i-blog.csdnimg.cn/direct/99d426b0dc8b4648bd6a1320c25c30e2.png" width="1916"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;

using namespace std;

const int N = 110;
char start[N], aim[N];

void turn(int i)
{
    if(start[i] == '*') start[i] = 'o';
    else start[i] = '*';
}


int main()
{
    cin &gt;&gt; start &gt;&gt; aim;
    int n = strlen(start);// 计算输入长度
    int ret = 0;
    for(int i = 0; i &lt; n - 1; i++)
    {
        if(start[i] != aim[i])
        {
            turn(i), turn(i+1);
            ret++;
        }
    }
    cout &lt;&lt; ret &lt;&lt; endl;
    
    return 0;
}</code></pre>
    <h6 id="%C2%A0116.%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F" name="%C2%A0116.%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F">
     116.飞行员兄弟
    </h6>
    <p>
     <img alt="" height="2196" src="https://i-blog.csdnimg.cn/direct/d9ac6c79ac254ce896bc5a6abf5b7657.png" width="1898"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;
const int N = 5;
char g[N][N], backup[N][N];
typedef pair&lt;int, int&gt; PII;

// 映射函数
int get(int i, int j)
{
    return i * 4 + j;
}

void turn_one(int x, int y)
{
    if(g[x][y] == '-') g[x][y] = '+';
    else g[x][y] = '-';
}

void turn_all(int x, int y)
{
    for(int i = 0; i &lt; 4; i++)
    {
        turn_one(x, i);
        turn_one(i, y);
    }
    turn_one(x, y); // xy在循环中被按了两次，现在调回去
}

int main()
{
    vector&lt;PII&gt; res;
    // 输入
    for(int i = 0; i &lt; 4; i++)
        for(int j = 0; j &lt; 4; j++)
            cin &gt;&gt; g[i][j];
            
    // 枚举所有方案
    for(int op = 0; op &lt; (1 &lt;&lt; 16); op++)
    {
        vector&lt;PII&gt; temp; // 存储方案
        memcpy(backup, g, sizeof(g)); // 备份方案
        
        // 枚举16个位置
        for(int i = 0; i &lt; 4; i++)
            for(int j = 0; j &lt; 4; j++)
            {
                if(op &gt;&gt; get(i, j) &amp;1) // 判断是不是要按开关
                {
                    temp.push_back({i, j});
                    turn_all(i, j);
                }
            }
        
        bool hash_close = false;
        // 判断是否全部灯泡已经亮了
        for(int i = 0; i &lt; 4; i++)
            for(int j = 0; j &lt; 4; j++)
                if(g[i][j] == '+')
                    hash_close = true;
        
        if(!hash_close)
        {
            if(res.empty() || res.size() &gt; temp.size() ) res = temp;
        }
        
        memcpy(g, backup, sizeof(backup)); // 恢复方案
    }
    cout &lt;&lt; res.size() &lt;&lt; endl;
    for (auto op : res) cout &lt;&lt; op.first + 1 &lt;&lt; ' ' &lt;&lt; op.second + 1 &lt;&lt; endl;
    
    
    return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323230325f37353333313333382f:61727469636c652f64657461696c732f313436303239353734" class_="artid" style="display:none">
 </p>
</div>


