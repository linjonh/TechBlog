---
layout: post
title: "C语言强化训练16天-从基础到进阶的蜕变之旅Day16"
date: 2025-08-30T06:59:06+0800
description: "本文为C语言强化训练系列文章，通过5道选择题和2道编程题帮助读者巩固C语言知识。选择题考察了浮点数精度判断、指针使用、联合体存储、数组越界等常见问题。编程题包含数对统计和字符串截取两个实际问题，提供了基础解法和优化思路。文章强调C语言学习需要注重细节理解和持续实践，并附有答案解析和代码示例。适合有一定C语言基础的学习者进行知识回顾和技能提升。"
keywords: "【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day16"
categories: ['C']
tags: ['经验分享', '算法', '强化', '开发语言', 'C']
artid: "150855304"
arturl: "https://blog.csdn.net/2503_91389547/article/details/150855304"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150855304
    alt: "C语言强化训练16天-从基础到进阶的蜕变之旅Day16"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150855304
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150855304
cover: https://bing.ee123.net/img/rand?artid=150855304
image: https://bing.ee123.net/img/rand?artid=150855304
img: https://bing.ee123.net/img/rand?artid=150855304
---



# 【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day16



![](https://i-blog.csdnimg.cn/direct/4d32fdc5f9ab42efba330f733ef60252.jpeg)

![](https://i-blog.csdnimg.cn/direct/19c67e36c0b74e46a0f3df3d7636f1df.gif)

> **🔥个人主页：[@草莓熊Lotso](https://blog.csdn.net/2503_91389547?type=blog "@草莓熊Lotso")**
>
> **🎬作者简介：C++研发方向学习者**
>
> 📖**个人专栏：**************************************************************************************************************************************************************************************************************************************************************[《C语言》](https://blog.csdn.net/2503_91389547/category_12935782.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=12935782&sharerefer=PC&sharesource=2503_91389547&sharefrom=from_link " 《C语言》 ")[《数据结构与算法》](https://blog.csdn.net/2503_91389547/category_12980013.html "《数据结构与算法》")[《C++知识分享》](https://blog.csdn.net/2503_91389547/category_13015037.html "《C++知识分享》")[《编程工具入门指南》](https://blog.csdn.net/2503_91389547/category_13028808.html "《编程工具入门指南》")****************************************************************************************************************************************************************************************************************************************************************
>
> **⭐️人生格言：生活是默默的坚持，毅力是永久的享受。**

**前言：我们距离学习完C语言已经很久了，在数据结构学完后，博主准备通过这16天的强化训练和大家一起回顾C语言的知识，今天依旧是五道选择和两道编程题，希望大家能有所收获。**

---








---

## 选择题：

**1、指出下列代码的缺陷【多选】（ ）  
 A: for(int i = 0; i < 10;)这一行写错了 B: f是float型数据直接做相等判断有风险**

**C: f[++i]应该是f[i++] D: 没有缺陷**

```
float f[10];
// 假设这里有对f进行初始化的代码
for (int i = 0; i < 10;)
{
	if (f[++i] == 0)
		break;
}
```

> **答案解析：**
>
> 正确答案：BC
>
> 一般float型只能精确到小数后六位（即1e-6），将float型数据的绝对值与1e-6比较，来判断是否相等（为零）。float的精度误差在1e-6；double精度误差在1e-15；所以要判断一个float型数：if(fabs(f)<1e-6)；要判断一个double型数：if(fabs(f)<1e- 15)；若满足，则为零。考虑B选项是对的。若要判断float a,b是否相等，要看if(fabs(a-b)<1e-6)是否为真。C选项，考虑的是数组越界问题

**2、请指出以下程序的错误【多选】（ ）  
 A: 1 B: 2 C: 3 D: 4**

```
int main()
{
	char* str = NULL;
	GetMemory(&str, 80); //2
	if (NULL != str)
	{
		strcpy(&str, "hello"); //3
		printf(str); //4
	} 
	return 0;
}
```

> **答案解析：**
>
> 正确答案：AC
>
> 第1处两种情况之一成立都是要返回的，应该用或，此处用与错误。在语句GetMemory(&str,100);中传入str的地址，在语句char*str=NULL;中str初始化为空指针，但是str指针变量也有地址，所以参数char**p里面的p保存的是指针变量str的地址，所以调用GetMemory函数之后，动态开辟的空间的地址存放在了str中，在函数返回之后没有释放内存，但是这不会导致程序错误，只会导致内存泄漏。第3处用&str是错的，应该直接用str，是刚申请下来的空间首地址，可以用来接收字符串的copy。

**3、请问下列代码的输出结果有可能是哪些【多选】（ ）  
 A: 2015,810 B: 50810,201 C: 810,2015 D:`20150,810**

```
#include <stdio.h>
typedef union
{
	int a;
	struct
	{
		short b;
		short c;
	};
}X;
int main()
{
	X x;
	x.a = 0x20150810;
	printf("%x,%x\n", x.b, x.c);
	return 0;
}
```

> **答案解析：**
>
> 正确答案：AC
>   
>  对于0x20150810
>   
>  如果按照大端模式存储：从低地址到高地址：20 15 08 10 输出从低地址到高地址：20 15 08 10
>   
>  如果按照小端模式存储：从低地址到高地址：10 08 15 20 输出从高地址到低地址：08 10 20 15
>
> 此数以int类型赋值给联合体x.a，而以结构成员b和c分开访问，分别拿到低地址的2个字节和高地址的2个字节，大端下是2015和810，小端下是810和2015

**4、下面这个程序执行后会有什么错误或者效果【多选】（ ）  
 A: 数组越界 B: 死循环 C: 栈溢出 D: 内存泄露**

> **答案解析：**
>
> 正确答案：AB
>
> 数组下标越界：数组大小255，但是当a[255]就是256个元素，导致越界了。死循环：这个是因为无符号字符型的变量大小在0-255之间，所以说i永远不可能大于255的，是个死循环。内存泄漏：创建的临时变量，在栈中，应该会由系统自动释放，所以应该是不存在内存泄漏的问题。栈溢出：属于缓冲区溢出的一种。栈溢出是由于C语言系列没有内置检查机制来确保复制到缓冲区的数据不得大于缓冲区的大小，因此当这个数据足够大的时候，将会溢出缓冲区的范围

**5、请问下列程序的输出是多少（ ）  
 A: 2 B: 死循环 C: 173 D: 172**

```

#include<stdio.h>
int main()
{
	unsigned char i = 7;
	int j = 0;
	for (; i > 0; i -= 3)
	{
		++j;
	}
	printf("%d\n", j);
	return 0;
}
```

> **答案解析：**
>
> 正确答案：C
>
> 本题就是找规律，计算什么时候能遇到0
>   
>  unsigned char 8位数据位，范围在0-255，所以-2（11111110）时，变成254；同理-1（11111111）时，变成255；最后减
>   
>  到0时，不满足循环条件，for停止。刚好173次。 7 4 1 ==> 共(7-1)/3+1=3次（1-3=-2，即254，继续循环）
>   
>  254 251 ... 5 2 ==> 共(254-2)/3+1=85次（2-3=-1，即255，继续循环）
>
> 255 252 ... 6 3 ==> 共(255-5)/3+1=85次（3-3=0，退出循环） 所以总共173次

---

## 编程题：

### 1.数对

> **题目链接：**[数对_牛客题霸_牛客网](https://www.nowcoder.com/practice/bac5a2372e204b2ab04cc437db76dc4f?tpId=182&&tqId=34323&rp=1&ru=/ta/exam-all&qru=/ta/exam-all/question-ranking "数对_牛客题霸_牛客网")

**题目描述：**

![](https://i-blog.csdnimg.cn/direct/48544ce1813441519eea0e9c8ee0d14e.png)

**题目示例：**

![](https://i-blog.csdnimg.cn/direct/1476166c8f5f46999d96299f28b3f88f.png)

**代码演示：**

```
#include <stdio.h>

int main() {
    int n=0;
    int k=0;
    scanf("%d%d",&n,&k);
    int count=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i%j>=k)
            {
                count++;
            }
        }
    }
    printf("%d ",count);
}
```

**更优解法：**

```
#include <stdio.h>
int main() {
    long n, k;
    while (~scanf("%ld %ld", &n, &k)) {
        if (k == 0) {
            printf("%ld\n", n * n);//任意数对的取模结果都是大于等于0的
            continue;
        }
        long count = 0;
        for (long y = k + 1; y <= n; y++) {
            count += ((n / y) * (y - k)) + ((n % y < k) ? 0 : (n % y - k + 1));
        }
        printf("%ld\n", count);
    }
    return 0;
}
```

> **题目解析：**
>
> 当 y <=k 时，意味着任何数字取模y的结果都在 [0, k-1]之间，都是不符合条件的。当 y = k+1=4 时，x符合条件的数字有 3,7
>
> 当 y = k+2=5 时，x符合条件的数字有 3,4,8,9当 y = k+3=6 时，x符合条件的数字有 3,4,5,9,10当 y = k+n时，
>
> x小于y当前值，且符合条件的数字数量是：y-k个，
>
> x大于y当前值，小于2*y的数据中，且符合条件的数字数量是：y-k个
>
> 从上一步能看出来，在y的整数倍区间内，x符合条件的数量就是 (n / y) * (y - k)个
>
> n / y 表示有多少个完整的 0 ~ y区间， y - k 表示有每个区间内有多少个符合条件的数字最后还要考虑的是6...往后这种超出倍数区间超过n的部分的统计
>
> n % y 就是多出完整区间部分的数字个数，其中k以下的不用考虑，则符合条件的是 n % y - (k-1) 个
>
> 这里需要注意的是类似于9这种超出完整区间的数字个数 本就小于k的情况，则为0最终公式：(n / y) * (y - k) + ((n % y < k) ? 0, (n % y - k + 1));

### 2.截取字符串

> **题目链接：**[截取字符串_牛客题霸_牛客网](https://www.nowcoder.com/practice/a30bbc1a0aca4c27b86dd88868de4a4a?tpId=37&&tqId=21269&rp=1&ru=/ta/huawei&qru=/ta/huawei/question-ranking "截取字符串_牛客题霸_牛客网")

**题目描述：**

![](https://i-blog.csdnimg.cn/direct/8166db9c71c744399dc4ce07ebd9d4fd.png)

**题目示例：**

![](https://i-blog.csdnimg.cn/direct/b9ada44db5354026bb2f7aa2de6fb4f0.png)

**代码演示：**

```
#include <stdio.h>
#include <string.h>

int main() {
    char s[1000]={0};
    int k=0;
    scanf("%s%d",s,&k);
    char d[1000]={0};

    strncpy(d,s,k);
    printf("%s",d);
}
```

> **题目解析：**
>
> * 通过 `scanf` 读取字符串和截取长度 `k`，利用 `strncpy` 截取字符串前 `k` 个字符并输出，实现题目要求的字符串截取功能

---

**往期回****顾：**

**[【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day12](https://blog.csdn.net/2503_91389547/article/details/150556195?spm=1001.2014.3001.5501 "【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day12")**

**[【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day13](https://blog.csdn.net/2503_91389547/article/details/150610163?spm=1001.2014.3001.5502 "【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day13")**

**[【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day14](https://blog.csdn.net/2503_91389547/article/details/150640907?spm=1001.2014.3001.5501 "【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day14")**

**[【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day15](https://blog.csdn.net/2503_91389547/article/details/150701097?spm=1001.2014.3001.5502 "【C语言强化训练16天】--从基础到进阶的蜕变之旅:Day15")**

**结语：本篇博客就到此结束了，C 语言的精髓在于对细节的掌控和对底层的理解，这需要持续实践。愿你带着这份训练中获得的思维与习惯，在编程路上走得更稳、更远。如果文章对你有帮助的话，欢迎评论，点赞，收藏加关注，感谢大家的支持。**



