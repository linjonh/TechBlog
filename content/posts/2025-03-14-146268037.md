---
layout: post
title: "C语言实现括号匹配检查及栈的应用详解"
date: 2025-03-14 22:02:30 +0800
description: "栈是一种后进先出（LIFO, Last In First Out）的数据结构。它就像一个放盘子的栈，最后放上去的盘子总是最先被拿下来。在栈中，有几个基本操作：- 初始化（Init）：创建一个空栈。- 销毁（Destroy）：释放栈占用的内存。- 插入（Push）：将元素添加到栈顶。- 删除（Pop）：从栈顶移除元素。- 判空（Empty）：检查栈是否为空。- 获取元素个数（Size）：返回栈中元素的数量。- 获取栈顶数据（Top）"
keywords: "C语言实现括号匹配检查及栈的应用详解"
categories: ['数据结构', 'C']
tags: ['算法', '数据结构']
artid: "146268037"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268037
    alt: "C语言实现括号匹配检查及栈的应用详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268037
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268037
cover: https://bing.ee123.net/img/rand?artid=146268037
image: https://bing.ee123.net/img/rand?artid=146268037
img: https://bing.ee123.net/img/rand?artid=146268037
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言实现括号匹配检查及栈的应用详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/489c8b8fbc3c4ea888b053466c17665d.jpeg"/>
    </p>
    <blockquote>
     <p>
      <span style="background-color:#edf6e8">
       在编程中，经常会遇到需要检查括号是否匹配的问题，比如在编译器中检查代码的语法正确性，或者在文本处理中确保括号的正确使用。本文将通过C语言实现一个括号匹配检查的程序，并详细介绍栈数据结构在其中的应用。
      </span>
      <br/>
     </p>
    </blockquote>
    <h2 id="%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B%C2%A0" name="%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B%C2%A0">
     <br/>
     栈数据结构简介
     <br/>
    </h2>
    <blockquote>
     <hr/>
     <p>
      <br/>
      栈是一种后进先出（LIFO, Last In First Out）的数据结构。它就像一个放盘子的栈，最后放上去的盘子总是最先被拿下来。在栈中，有几个基本操作：
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 初始化（Init）
       </strong>
      </span>
      ：创建一个空栈。
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 销毁（Destroy）
       </strong>
      </span>
      ：释放栈占用的内存。
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 插入（Push）
       </strong>
      </span>
      ：将元素添加到栈顶。
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 删除（Pop）
       </strong>
      </span>
      ：从栈顶移除元素。
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 判空（Empty）
       </strong>
      </span>
      ：检查栈是否为空。
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 获取元素个数（Size）
       </strong>
      </span>
      ：返回栈中元素的数量。
      <br/>
      <br/>
      <span style="color:#be191c">
       <strong>
        - 获取栈顶数据（Top）
       </strong>
      </span>
      ：返回栈顶的元素，但不删除它。
      <br/>
     </p>
     <hr/>
    </blockquote>
    <h2 id="C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A0%88%C2%A0" name="C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A0%88%C2%A0">
     C语言实现栈
     <br/>
    </h2>
    <p>
    </p>
    <pre><code class="language-cpp">
c
  
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef char typestk;
typedef struct Stack
{
    typestk* a;
    int top;
    int capacity;
} ST;
 </code></pre>
    <p>
     <br/>
     <br/>
     这里定义了一个栈的结构体 Stack ，包含一个字符类型的指针 a 用于存储栈中的元素， top 表示栈顶的位置， capacity 表示栈的容量。
     <br/>
    </p>
    <h3 id="%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" name="%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">
     <br/>
     栈的初始化
     <br/>
    </h3>
    <pre><code class="language-cpp">
c
  
// 栈的初始化
void STInit(ST* ps)
{
    assert(ps);

    ps-&gt;a = (typestk*)malloc(sizeof(typestk) * 4);
    if (ps-&gt;a == NULL)
    {
        perror("malloc");
        return;
    }
    ps-&gt;top = 0;
    ps-&gt;capacity = 4;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <span style="color:#fe2c24">
      <strong>
       STInit 函数用于初始化栈。
      </strong>
     </span>
     首先通过 malloc 分配4个字符大小的内存空间给栈的数组 a ，如果分配失败，使用 perror 打印错误信息。然后将栈顶位置 top 设为0，栈容量 capacity 设为4。
     <br/>
    </p>
    <h3 id="%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%C2%A0" name="%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%C2%A0">
     <br/>
     栈的销毁
     <br/>
    </h3>
    <pre><code class="language-cpp">
c
  
// 栈的销毁
void STDestory(ST* ps)
{
    // 查空
    assert(ps);
    free(ps-&gt;a);
    ps-&gt;a = NULL;
    ps-&gt;capacity = ps-&gt;top = 0;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <span style="color:#fe2c24">
      <strong>
       STDestory 函数用于销毁栈。
      </strong>
     </span>
     先使用 free 释放栈数组 a 占用的内存，然后将指针 a 设为 NULL ，并将栈顶位置 top 和栈容量 capacity 都设为0。
     <br/>
    </p>
    <h3 id="%E6%A0%88%E7%9A%84%E6%8F%92%E5%85%A5" name="%E6%A0%88%E7%9A%84%E6%8F%92%E5%85%A5">
     <br/>
     栈的插入
    </h3>
    <pre><code class="language-cpp"> 
c
  
// 栈的插入
void STPush(ST* ps, typestk x)
{
    assert(ps);

    if (ps-&gt;top == ps-&gt;capacity)
    {
        typestk* tmp = (typestk*)realloc(ps-&gt;a, sizeof(typestk) * ps-&gt;capacity * 2);
        if (tmp == NULL)
        {
            perror("realloc error");
            return;
        }
        ps-&gt;a = tmp;
        ps-&gt;capacity *= 2;
    }

    ps-&gt;a[ps-&gt;top] = x;
    ps-&gt;top++;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <span style="color:#fe2c24">
      <strong>
       STPush 函数用于将元素插入栈顶
      </strong>
     </span>
     。首先检查栈是否已满（即 top 等于 capacity ），如果已满，使用 realloc 将栈的容量扩大为原来的2倍。如果内存重新分配失败，打印错误信息并返回。然后将元素 x 插入到栈顶位置，并将栈顶位置 top 加1。
     <br/>
    </p>
    <h3 id="%E6%A0%88%E7%9A%84%E5%88%A0%E9%99%A4" name="%E6%A0%88%E7%9A%84%E5%88%A0%E9%99%A4">
     <br/>
     栈的删除
    </h3>
    <pre><code class="language-cpp"> 
c
  
// 栈的删除
void STPop(ST* ps)
{
    assert(ps);
    assert(!STEmpty(ps));    ps-&gt;top--;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <span style="color:#fe2c24">
      <strong>
       STPop 函数用于从栈顶删除元素
      </strong>
     </span>
     。首先检查栈是否为空，如果为空则使用 assert 断言报错。然后将栈顶位置 top 减1，相当于删除了栈顶元素。
     <br/>
    </p>
    <h3 id="%E6%A0%88%E7%9A%84%E5%88%A4%E7%A9%BA" name="%E6%A0%88%E7%9A%84%E5%88%A4%E7%A9%BA">
     <br/>
     栈的判空
    </h3>
    <pre><code class="language-cpp"> 
c
  
// 栈的判空
bool STEmpty(ST* ps)
{
    assert(ps);
    return ps-&gt;top == 0;
}
 
 
 STEmpty 函数用于检查栈是否为空。如果栈顶位置 top 为0，则返回 true ，否则返回 false 。
 
栈的元素个数
 
c
  
// 栈的元素个数
int STSize(ST* ps)
{
    assert(ps);
    return ps-&gt;top;
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <span style="color:#fe2c24">
      <strong>
       STSize 函数返回栈中元素的个数
      </strong>
     </span>
     ，即栈顶位置 top 的值。
     <br/>
    </p>
    <h3 id="%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%C2%A0" name="%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE%C2%A0">
     <br/>
     获取栈顶数据
     <br/>
    </h3>
    <pre><code class="language-cpp">
c
  
// 获取栈顶数据
typestk STTop(ST* ps)
{
    assert(ps);
    assert(!STEmpty(ps));
    return ps-&gt;a[ps-&gt;top - 1];
}
 </code></pre>
    <p>
     <br/>
     <br/>
     <strong>
      <span style="color:#fe2c24">
       STTop 函数返回栈顶的元素
      </span>
     </strong>
     ，但不删除它。首先检查栈是否为空，如果为空则使用 assert 断言报错。然后返回栈顶位置 top - 1 处的元素。
     <br/>
    </p>
    <h3 id="%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%A3%80%E6%9F%A5" name="%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%A3%80%E6%9F%A5">
     <br/>
     利用栈实现括号匹配检查
    </h3>
    <pre><code class="language-cpp"> 
c
  
bool isValid(char* s)
{
    ST st;
    STInit(&amp;st);
    while (*s)
    {
        if (*s == '[' || *s == '(' || *s == '{')
        {
            STPush(&amp;st, *s);
        }
        else
        {
            if (STEmpty(&amp;st))
            {
                STDestory(&amp;st);
                return false;
            }
            char top = STTop(&amp;st);
            STPop(&amp;st);
            if ((*s == ')' &amp;&amp; top != '(') || (*s == ']' &amp;&amp; top != '[') || (*s == '}' &amp;&amp; top != '{'))
            {
                STDestory(&amp;st);
                return false;
            }

        }
        ++s;
    }
    bool ret = STEmpty(&amp;st);
    STDestory(&amp;st);
    return ret;
}
 </code></pre>
    <p>
     <br/>
    </p>
    <blockquote>
     <p>
      <br/>
      isValid 函数用于检查给定字符串中的括号是否匹配。
      <br/>
      <br/>
      初始化一个栈 st 。
      <br/>
      <br/>
      <span style="color:#fe2c24">
       <strong>
        遍历字符串 s ：
       </strong>
      </span>
      <br/>
      <br/>
      <u>
       - 如果当前字符是左括号（ [ 、 ( 、 { ），将其压入栈中。
       <br/>
       <br/>
       - 如果当前字符是右括号（ ] 、 ) 、 } ）：
       <br/>
       <br/>
       - 检查栈是否为空，如果为空，说明没有匹配的左括号，返回 false 。
       <br/>
       <br/>
       - 否则，获取栈顶元素并弹出栈，检查栈顶元素是否与当前右括号匹配。如果不匹配，返回 false 。
      </u>
      <br/>
      <br/>
      遍历结束后，如果栈为空，说明所有括号都匹配，返回 true ；否则返回 false 。最后销毁栈。
      <br/>
     </p>
    </blockquote>
    <h2 id="%E6%80%BB%E7%BB%93%C2%A0" name="%E6%80%BB%E7%BB%93%C2%A0" style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/d2fa06cb607f4edcb47c22c3ef130ac5.jpeg">
      <br/>
      总结
      <br/>
     </img>
    </h2>
    <blockquote>
     <p>
      <br/>
      <span style="background-color:#edf6e8">
       通过以上代码，我们实现了一个简单的
       <span style="color:#fe2c24">
        栈数据结构
       </span>
       ，并利用栈解决了括号匹配检查的问题。栈作为一种基本的数据结构，在很多算法和应用中都有广泛的应用，如表达式求值、深度优先搜索等。掌握栈的基本操作和应用场景，对于提升编程能力和解决实际问题都非常有帮助。希望本文能帮助你更好地理解栈和括号匹配问题。
      </span>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6e706c706c75732f:61727469636c652f64657461696c732f313436323638303337" class_="artid" style="display:none">
 </p>
</div>


