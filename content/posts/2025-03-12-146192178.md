---
layout: post
title: "ngx_conf_parse"
date: 2025-03-12 01:33:07 +0800
description: "parse_file。"
keywords: "ngx_conf_parse"
categories: ['未分类']
tags: ['运维', '服务器', 'Linux']
artid: "146192178"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146192178
    alt: "ngx_conf_parse"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146192178
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146192178
cover: https://bing.ee123.net/img/rand?artid=146192178
image: https://bing.ee123.net/img/rand?artid=146192178
img: https://bing.ee123.net/img/rand?artid=146192178
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ngx_conf_parse
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <span style="color:#be191c">
      ngx_conf_parse
     </span>
    </h3>
    <h3>
     <strong>
      定义
     </strong>
     在
     <span style="color:#be191c">
      <code>
       src/core/ngx_conf_file.c
      </code>
     </span>
    </h3>
    <pre><code>char *
ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename)
{
    char             *rv;
    ngx_fd_t          fd;
    ngx_int_t         rc;
    ngx_buf_t         buf;
    ngx_conf_file_t  *prev, conf_file;
    enum {
        parse_file = 0,
        parse_block,
        parse_param
    } type;

#if (NGX_SUPPRESS_WARN)
    fd = NGX_INVALID_FILE;
    prev = NULL;
#endif

    if (filename) {

        /* open configuration file */

        fd = ngx_open_file(filename-&gt;data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

        if (fd == NGX_INVALID_FILE) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                               ngx_open_file_n " \"%s\" failed",
                               filename-&gt;data);
            return NGX_CONF_ERROR;
        }

        prev = cf-&gt;conf_file;

        cf-&gt;conf_file = &amp;conf_file;

        if (ngx_fd_info(fd, &amp;cf-&gt;conf_file-&gt;file.info) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, ngx_errno,
                          ngx_fd_info_n " \"%s\" failed", filename-&gt;data);
        }

        cf-&gt;conf_file-&gt;buffer = &amp;buf;

        buf.start = ngx_alloc(NGX_CONF_BUFFER, cf-&gt;log);
        if (buf.start == NULL) {
            goto failed;
        }

        buf.pos = buf.start;
        buf.last = buf.start;
        buf.end = buf.last + NGX_CONF_BUFFER;
        buf.temporary = 1;

        cf-&gt;conf_file-&gt;file.fd = fd;
        cf-&gt;conf_file-&gt;file.name.len = filename-&gt;len;
        cf-&gt;conf_file-&gt;file.name.data = filename-&gt;data;
        cf-&gt;conf_file-&gt;file.offset = 0;
        cf-&gt;conf_file-&gt;file.log = cf-&gt;log;
        cf-&gt;conf_file-&gt;line = 1;

        type = parse_file;

        if (ngx_dump_config
#if (NGX_DEBUG)
            || 1
#endif
           )
        {
            if (ngx_conf_add_dump(cf, filename) != NGX_OK) {
                goto failed;
            }

        } else {
            cf-&gt;conf_file-&gt;dump = NULL;
        }

    } else if (cf-&gt;conf_file-&gt;file.fd != NGX_INVALID_FILE) {

        type = parse_block;

    } else {
        type = parse_param;
    }


    for ( ;; ) {
        rc = ngx_conf_read_token(cf);

        /*
         * ngx_conf_read_token() may return
         *
         *    NGX_ERROR             there is error
         *    NGX_OK                the token terminated by ";" was found
         *    NGX_CONF_BLOCK_START  the token terminated by "{" was found
         *    NGX_CONF_BLOCK_DONE   the "}" was found
         *    NGX_CONF_FILE_DONE    the configuration file is done
         */

        if (rc == NGX_ERROR) {
            goto done;
        }

        if (rc == NGX_CONF_BLOCK_DONE) {

            if (type != parse_block) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "unexpected \"}\"");
                goto failed;
            }

            goto done;
        }

        if (rc == NGX_CONF_FILE_DONE) {

            if (type == parse_block) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   "unexpected end of file, expecting \"}\"");
                goto failed;
            }

            goto done;
        }

        if (rc == NGX_CONF_BLOCK_START) {

            if (type == parse_param) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                   "block directives are not supported "
                                   "in -g option");
                goto failed;
            }
        }

        /* rc == NGX_OK || rc == NGX_CONF_BLOCK_START */

        if (cf-&gt;handler) {

            /*
             * the custom handler, i.e., that is used in the http's
             * "types { ... }" directive
             */

            if (rc == NGX_CONF_BLOCK_START) {
                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "unexpected \"{\"");
                goto failed;
            }

            rv = (*cf-&gt;handler)(cf, NULL, cf-&gt;handler_conf);
            if (rv == NGX_CONF_OK) {
                continue;
            }

            if (rv == NGX_CONF_ERROR) {
                goto failed;
            }

            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%s", rv);

            goto failed;
        }


        rc = ngx_conf_handler(cf, rc);

        if (rc == NGX_ERROR) {
            goto failed;
        }
    }

failed:

    rc = NGX_ERROR;

done:

    if (filename) {
        if (cf-&gt;conf_file-&gt;buffer-&gt;start) {
            ngx_free(cf-&gt;conf_file-&gt;buffer-&gt;start);
        }

        if (ngx_close_file(fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_ALERT, cf-&gt;log, ngx_errno,
                          ngx_close_file_n " %s failed",
                          filename-&gt;data);
            rc = NGX_ERROR;
        }

        cf-&gt;conf_file = prev;
    }

    if (rc == NGX_ERROR) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}
</code></pre>
    <h3>
     <span style="color:#be191c">
      <code>
       ngx_conf_parse
      </code>
     </span>
     是 Nginx 中解析配置文件的核心函数，其作用和意义可以通俗理解为：
    </h3>
    <h3>
     这个函数就像 Nginx 的“翻译官”，把用户写的配置文件“翻译”成程序能理解的指令，并确保语法正确、资源合理使用，是 Nginx 启动和配置生效的关键环节。
    </h3>
    <hr/>
    <pre><code>char *ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename);
</code></pre>
    <h3>
     函数签名
    </h3>
    <h3>
     1. 返回值类型 char *
    </h3>
    <h3>
     <br/>
     作用：返回配置解析的结果状态。
    </h3>
    <h3>
     <br/>
     可能值：
     <br/>
     NGX_CONF_OK：解析成功（通常定义为 NULL 或特定宏）。
     <br/>
     NGX_CONF_ERROR：解析失败（通常指向一个静态错误字符串或特定标记）。
     <br/>
     特殊设计：Nginx 中许多函数通过返回 char* 表示错误信息。若返回 NULL（即 NGX_CONF_OK），表示成功；若返回非空字符串（如 "invalid option"），表示错误原因。
    </h3>
    <h3>
     <br/>
     2. 参数 ngx_conf_t *cf
    </h3>
    <h3>
     <br/>
     类型：ngx_conf_t 是配置解析的上下文结构体，包含解析过程所需的所有状态信息。
    </h3>
    <h3>
     作用：维护解析过程中的全局状态，协调不同模块的配置指令。
    </h3>
    <p>
    </p>
    <h3>
     3. 参数 ngx_str_t *filename
     <br/>
     类型：ngx_str_t 是 Nginx 的字符串类型
    </h3>
    <h3>
     作用：
    </h3>
    <h3>
     若 filename 非空：表示需要解析的配置文件路径（如 nginx.conf）。
     <br/>
     若 filename 为空（NULL）：表示从其他来源解析配置（如命令行参数 -g 指定的配置片段）
     <br/>
     特殊逻辑：
    </h3>
    <h3>
     当解析文件时，会打开文件并读取内容到缓冲区。
     <br/>
     当解析命令行参数时，直接处理内存中的字符串（无需打开文件）。
    </h3>
    <hr/>
    <pre><code>    enum {
        parse_file = 0,
        parse_block,
        parse_param
    } type;</code></pre>
    <h3>
     作用：定义解析模式枚举，控制解析行为。
    </h3>
    <h3>
     <br/>
     枚举值含义：
     <br/>
     <span style="color:#be191c">
      parse_file
     </span>
     ：解析普通配置文件（默认模式）。
     <br/>
     <span style="color:#be191c">
      parse_block
     </span>
     ：解析代码块（如 http { ... }）。
     <br/>
     <span style="color:#be191c">
      parse_param
     </span>
     ：解析命令行参数（如 nginx -g "daemon off;"）。
    </h3>
    <h3>
     <br/>
     背景：
     <br/>
     不同模式下语法校验规则不同。
    </h3>
    <h3>
     <br/>
     意图：
     <br/>
     通过状态机模式统一处理不同输入源，避免代码冗余。
    </h3>
    <hr/>
    <pre><code>    if (filename) {<!-- --></code></pre>
    <ul>
     <li>
      <h3>
       <strong>
        作用
       </strong>
       ：判断是否需要解析一个具体的配置文件（而非命令行参数或代码块）
      </h3>
     </li>
    </ul>
    <h3>
     此次运行情况：
    </h3>
    <blockquote>
     <h3>
      filename=/home/wsd/桌面/nginx/conf/nginx.conf
     </h3>
    </blockquote>
    <hr/>
    <pre><code>fd = ngx_open_file(filename-&gt;data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);

if (fd == NGX_INVALID_FILE) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
                               ngx_open_file_n " \"%s\" failed",
                               filename-&gt;data);
            return NGX_CONF_ERROR;
        }</code></pre>
    <h3>
     打开配置文件，返回文件描述符
     <span style="color:#be191c">
      <code>
       fd
      </code>
     </span>
    </h3>
    <p>
    </p>
    <h3>
     <span style="color:#be191c">
      filename-&gt;data
     </span>
     指定要打开的文件路径
    </h3>
    <h3>
     <span style="color:#be191c">
      NGX_FILE_RDONLY
     </span>
     指定文件以
     <strong>
      只读模式
     </strong>
     打开
    </h3>
    <p>
    </p>
    <h3>
     <span style="color:#be191c">
      NGX_FILE_OPEN
     </span>
    </h3>
    <h3>
     指定文件打开模式为“仅打开现有文件”。
    </h3>
    <h3>
     若文件不存在，
     <code>
      NGX_FILE_OPEN
     </code>
     会阻止自动创建新文件（与
     <code>
      O_CREAT
     </code>
     标志相反）
    </h3>
    <p>
    </p>
    <h3>
     <span style="color:#be191c">
      <strong>
       <code>
        0
       </code>
      </strong>
     </span>
    </h3>
    <h3>
     指定新创建文件的权限
    </h3>
    <h3>
     由于第三个参数是
     <code>
      NGX_FILE_OPEN
     </code>
     （不创建新文件），此参数会被忽略。
     <br/>
     传递
     <code>
      0
     </code>
     ，明确表示“无需设置权限”。
    </h3>
    <ul>
     <li>
      <h3>
       <strong>
        错误处理
       </strong>
       ：
       <br/>
       若打开失败（如文件不存在），记录日志并返回
       <code>
        NGX_CONF_ERROR
       </code>
      </h3>
     </li>
    </ul>
    <hr/>
    <pre><code>        prev = cf-&gt;conf_file;</code></pre>
    <h3>
     保存当前配置文件的上下文
    </h3>
    <h3>
     当解析嵌套的
     <code>
      include
     </code>
     文件时，需暂存父级上下文，解析完成后恢复
    </h3>
    <h3>
    </h3>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146202904?sharetype=blogdetail&amp;sharerId=146202904&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="ngx_conf_file_t-CSDN博客">
      ngx_conf_file_t-CSDN博客
     </a>
    </h3>
    <p>
    </p>
    <h3>
     <code>
      此时的运行情况:
     </code>
    </h3>
    <blockquote>
     <h4>
      <code>
       prev=null
      </code>
     </h4>
     <h4>
      <font face="monospace">
       <strong>
        第一次执行到这里时
       </strong>
       ，
      </font>
      cf-&gt;conf_file 还没有设置
     </h4>
    </blockquote>
    <p>
    </p>
    <hr/>
    <pre><code class="hljs">        cf-&gt;conf_file = &amp;conf_file;</code></pre>
    <h4>
     将当前配置文件上下文切换为新打开的文件
    </h4>
    <pre><code class="hljs">        if (ngx_fd_info(fd, &amp;cf-&gt;conf_file-&gt;file.info) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, ngx_errno,
                          ngx_fd_info_n " \"%s\" failed", filename-&gt;data);
        }</code></pre>
    <h4>
     获取文件元信息（如大小、修改时间），存储到
     <code>
      cf-&gt;conf_file-&gt;file.info
     </code>
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145950396?sharetype=blogdetail&amp;sharerId=145950396&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_fd_info-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_fd_info-CSDN博客
     </a>
    </h4>
    <pre><code class="hljs">        cf-&gt;conf_file-&gt;buffer = &amp;buf;</code></pre>
    <h4>
     将缓冲区
     <code>
      buf
     </code>
     关联到当前配置文件上下文
    </h4>
    <pre><code class="hljs">        buf.start = ngx_alloc(NGX_CONF_BUFFER, cf-&gt;log);
        if (buf.start == NULL) {
            goto failed;
        }</code></pre>
    <h4>
     分配
     <code>
      NGX_CONF_BUFFER
     </code>
     大小的内存（4KB），用于存储文件内容
    </h4>
    <pre><code class="hljs">        buf.pos = buf.start;
</code></pre>
    <h5>
     初始化缓冲区的当前读取位置指针
    </h5>
    <h4>
     <code>
      pos
     </code>
     指向缓冲区的起始位置，表示尚未读取任何数据
    </h4>
    <pre><code class="hljs">        buf.last = buf.start;
</code></pre>
    <h4>
     <code>
      last
     </code>
     指向缓冲区的起始位置，表示缓冲区当前为空
    </h4>
    <pre><code class="hljs">        buf.end = buf.last + NGX_CONF_BUFFER;
</code></pre>
    <h4>
     标记缓冲区的结束位置
    </h4>
    <pre><code class="hljs">        buf.temporary = 1;</code></pre>
    <h4>
     标记缓冲区为临时内存
    </h4>
    <pre><code class="hljs">        cf-&gt;conf_file-&gt;file.fd = fd;
</code></pre>
    <h4>
     将文件描述符
     <code>
      fd
     </code>
     关联到配置文件上下文
    </h4>
    <h4>
     后续读取文件时直接使用该
     <code>
      fd
     </code>
    </h4>
    <pre><code class="hljs">        cf-&gt;conf_file-&gt;file.name.len = filename-&gt;len;
        cf-&gt;conf_file-&gt;file.name.data = filename-&gt;data;
        cf-&gt;conf_file-&gt;file.offset = 0;
        cf-&gt;conf_file-&gt;file.log = cf-&gt;log;
        cf-&gt;conf_file-&gt;line = 1;</code></pre>
    <pre><code class="hljs">        type = parse_file;</code></pre>
    <h4>
     设置解析模式为
     <code>
      parse_file
     </code>
     （普通文件模式）
    </h4>
    <pre><code class="hljs">       if (ngx_dump_config</code></pre>
    <h4>
     <code>
      ngx_dump_config
     </code>
     是全局变量，控制是否保存配置内容
    </h4>
    <h4>
     此时的情况：
    </h4>
    <blockquote>
     <h4>
      ngx_dump_config=0
     </h4>
    </blockquote>
    <h4>
     所以进入 else
    </h4>
    <pre><code class="hljs">else {
            cf-&gt;conf_file-&gt;dump = NULL;
        }</code></pre>
    <h4>
     此时的情况：
    </h4>
    <blockquote>
     <h4>
      cf-&gt;conf_file-&gt;dump = NULL
     </h4>
    </blockquote>
    <h3>
     接下来是：
    </h3>
    <pre><code class="hljs">   for ( ;; ) {
  </code></pre>
    <h3>
     创建无限循环，持续处理配置指令直到遇到终止条件
     <br/>
     配置解析需要顺序处理所有指令，直到文件结束或语法错误
    </h3>
    <p>
    </p>
    <pre><code class="hljs">      rc = ngx_conf_read_token(cf);</code></pre>
    <h3>
     读取并解析下一个配置token（指令/符号）
    </h3>
    <h3>
     该函数负责词法分析，识别分号、大括号等语法结构
    </h3>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145961581?sharetype=blogdetail&amp;sharerId=145961581&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_conf_read_token-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_conf_read_token-CSDN博客
     </a>
    </h3>
    <hr/>
    <h4>
     进入
     <span style="color:#be191c">
      ngx_conf_read_token
     </span>
    </h4>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146216930?sharetype=blogdetail&amp;sharerId=146216930&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="ngx_conf_read_token-CSDN博客">
      ngx_conf_read_token-CSDN博客
     </a>
    </h3>
    <hr/>
    <h4>
     接下来：
    </h4>
    <pre><code class="hljs">       /* rc == NGX_OK || rc == NGX_CONF_BLOCK_START */

        if (cf-&gt;handler) {<!-- --></code></pre>
    <h4>
     此时 cf-&gt;handler 是 NULL
    </h4>
    <pre><code class="hljs">        rc = ngx_conf_handler(cf, rc);</code></pre>
    <h4>
     调用
     <span style="color:#be191c">
      <code>
       ngx_conf_handler
      </code>
     </span>
     函数处理当前解析到的配置指令
    </h4>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34313831323334362f:61727469636c652f64657461696c732f313436313932313738" class_="artid" style="display:none">
 </p>
</div>


