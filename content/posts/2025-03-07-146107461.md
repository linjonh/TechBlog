---
layout: post
title: "node.js内置模块之-crypto-模块"
date: 2025-03-07 22:55:44 +0800
description: "在 Node.js 中，crypto模块提供了多种加密功能，包括哈希、对称加密、非对称加密和数字签名等。通过crypto模块，可以进行各种加密和解密操作，保护敏感数据的安全性。"
keywords: "node.js内置模块之---crypto 模块"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['Node']
artid: "146107461"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146107461
    alt: "node.js内置模块之-crypto-模块"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146107461
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146107461
cover: https://bing.ee123.net/img/rand?artid=146107461
image: https://bing.ee123.net/img/rand?artid=146107461
img: https://bing.ee123.net/img/rand?artid=146107461
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     node.js内置模块之---crypto 模块
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="crypto__4">
     </a>
     <strong>
      crypto 模块的作用
     </strong>
    </h3>
    <p>
     在 Node.js 中，
     <code>
      crypto
     </code>
     模块提供了多种加密功能，包括哈希、对称加密、非对称加密和数字签名等。通过
     <code>
      crypto
     </code>
     模块，可以进行各种加密和解密操作，保护敏感数据的安全性。
    </p>
    <h3>
     <a id="crypto__9">
     </a>
     <strong>
      crypto 模块
     </strong>
    </h3>
    <h5>
     <a id="1_Hashing_12">
     </a>
     1. 哈希算法（Hashing）
    </h5>
    <p>
     哈希函数（如 SHA、MD5 等）用于将输入数据映射为一个固定长度的字符串（哈希值）。它是单向的，不可逆的，通常用于数据完整性验证。
    </p>
    <ul>
     <li>
      <code>
       createHash(algorithm)
      </code>
      ：创建一个哈希对象，
      <code>
       algorithm
      </code>
      指定使用的哈希算法（例如
      <code>
       'sha256'
      </code>
      ,
      <code>
       'md5'
      </code>
      ）。
     </li>
     <li>
      <code>
       update(data)
      </code>
      ：向哈希对象添加数据，可以调用多次。
     </li>
     <li>
      <code>
       digest(encoding)
      </code>
      ：返回哈希值，
      <code>
       encoding
      </code>
      可以是
      <code>
       'hex'
      </code>
      、
      <code>
       'base64'
      </code>
      或
      <code>
       'binary'
      </code>
      。
     </li>
    </ul>
    <h6>
     <a id="_SHA256__20">
     </a>
     示例：生成 SHA-256 哈希值
    </h6>
    <pre><code>const hash = crypto.createHash('sha256');
hash.update('Hello, world!');
const result = hash.digest('hex');
console.log(result);  // 输出 SHA-256 哈希值
</code></pre>
    <h5>
     <a id="2Encryption_and_Decryption_28">
     </a>
     2、加密与解密（Encryption and Decryption）
    </h5>
    <h6>
     <a id="_30">
     </a>
     对称加密
    </h6>
    <p>
     对称加密使用相同的密钥进行加密和解密。
     <code>
      crypto
     </code>
     模块支持多种对称加密算法，如 AES（AES-128、AES-256）等。
    </p>
    <ul>
     <li>
      <code>
       createCipheriv(algorithm, key, iv)
      </code>
      ：创建加密对象，
      <code>
       algorithm
      </code>
      是加密算法，
      <code>
       key
      </code>
      是密钥，
      <code>
       iv
      </code>
      是初始化向量（IV）。
     </li>
     <li>
      <code>
       update(data, inputEncoding, outputEncoding)
      </code>
      ：将明文数据输入并指定编码，返回加密数据。
     </li>
     <li>
      <code>
       final(outputEncoding)
      </code>
      ：返回最后的加密数据。
     </li>
    </ul>
    <h6>
     <a id="_AES256CBC__38">
     </a>
     示例：使用 AES-256-CBC 加密和解密
    </h6>
    <pre><code>const algorithm = 'aes-256-cbc';
const key = crypto.randomBytes(32);  // 32 字节的密钥
const iv = crypto.randomBytes(16);   // 16 字节的初始化向量

// 加密
const cipher = crypto.createCipheriv(algorithm, key, iv);
let encrypted = cipher.update('Hello, world!', 'utf8', 'hex');
encrypted += cipher.final('hex');
console.log('Encrypted:', encrypted);

// 解密
const decipher = crypto.createDecipheriv(algorithm, key, iv);
let decrypted = decipher.update(encrypted, 'hex', 'utf8');
decrypted += decipher.final('utf8');
console.log('Decrypted:', decrypted);
</code></pre>
    <h6>
     <a id="_57">
     </a>
     非对称加密
    </h6>
    <p>
     非对称加密使用一对密钥——公钥和私钥。公钥用于加密，私钥用于解密。
    </p>
    <ul>
     <li>
      <code>
       generateKeyPairSync(type, options)
      </code>
      ：同步生成公钥和私钥对，
      <code>
       type
      </code>
      指定密钥类型（如
      <code>
       'rsa'
      </code>
      ），
      <code>
       options
      </code>
      指定密钥的参数。
     </li>
     <li>
      <code>
       publicEncrypt(publicKey, data)
      </code>
      ：使用公钥对数据进行加密。
     </li>
     <li>
      <code>
       privateDecrypt(privateKey, data)
      </code>
      ：使用私钥对数据进行解密。
     </li>
    </ul>
    <h6>
     <a id="_RSA__65">
     </a>
     示例：使用 RSA 非对称加密
    </h6>
    <pre><code>const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,  // 公钥的位数
});

// 使用公钥加密
const encrypted = crypto.publicEncrypt(publicKey, Buffer.from('Hello, world!'));
console.log('Encrypted:', encrypted.toString('hex'));

// 使用私钥解密
const decrypted = crypto.privateDecrypt(privateKey, encrypted);
console.log('Decrypted:', decrypted.toString());
</code></pre>
    <h5>
     <a id="3_HMACHashbased_Message_Authentication_Code_80">
     </a>
     3. HMAC（Hash-based Message Authentication Code）
    </h5>
    <p>
     HMAC 是一种基于哈希的消息认证码，用于验证消息的完整性和真实性。它结合了哈希函数和密钥，能够防止中间人攻击。
    </p>
    <ul>
     <li>
      <code>
       createHmac(algorithm, key)
      </code>
      ：创建 HMAC 对象，
      <code>
       algorithm
      </code>
      指定哈希算法（如
      <code>
       'sha256'
      </code>
      ），
      <code>
       key
      </code>
      是密钥。
     </li>
     <li>
      <code>
       update(data)
      </code>
      ：向 HMAC 对象输入数据。
     </li>
     <li>
      <code>
       digest(encoding)
      </code>
      ：返回 HMAC 的结果，通常是
      <code>
       'hex'
      </code>
      或
      <code>
       'base64'
      </code>
      编码。
     </li>
    </ul>
    <h6>
     <a id="_HMAC_88">
     </a>
     示例：生成 HMAC
    </h6>
    <pre><code>const secret = 'my-secret-key';
const hmac = crypto.createHmac('sha256', secret);
hmac.update('Hello, world!');
const result = hmac.digest('hex');
console.log('HMAC:', result);
</code></pre>
    <h5>
     <a id="4_Random_Number_Generation_97">
     </a>
     4. 随机数生成（Random Number Generation）
    </h5>
    <p>
     <code>
      crypto
     </code>
     提供了生成安全随机数的功能，用于生成随机密码、令牌等。
    </p>
    <ul>
     <li>
      <code>
       randomBytes(size)
      </code>
      ：生成指定字节数的随机数据。
     </li>
    </ul>
    <h6>
     <a id="_103">
     </a>
     示例：生成随机字节
    </h6>
    <pre><code>const randomBytes = crypto.randomBytes(16);  // 生成16个随机字节
console.log(randomBytes.toString('hex'));   // 输出十六进制字符串
</code></pre>
    <h5>
     <a id="5_Digital_Signature_109">
     </a>
     5. 数字签名（Digital Signature）
    </h5>
    <p>
     数字签名用于验证数据的完整性和身份认证，通常用于公钥基础设施（PKI）中。它使用私钥对数据签名，使用公钥验证签名。
    </p>
    <ul>
     <li>
      <code>
       createSign(algorithm)
      </code>
      ：创建一个签名对象，
      <code>
       algorithm
      </code>
      指定哈希算法。
     </li>
     <li>
      <code>
       createVerify(algorithm)
      </code>
      ：创建一个验证签名对象，
      <code>
       algorithm
      </code>
      指定哈希算法。
     </li>
     <li>
      <code>
       sign(privateKey, encoding)
      </code>
      ：使用私钥对数据进行签名。
     </li>
     <li>
      <code>
       verify(publicKey, signature, encoding)
      </code>
      ：使用公钥验证签名。
     </li>
    </ul>
    <h6>
     <a id="_118">
     </a>
     示例：生成签名
    </h6>
    <pre><code>const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
});

// 生成签名
const sign = crypto.createSign('SHA256');
sign.update('Hello, world!');
const signature = sign.sign(privateKey, 'hex');
console.log('Signature:', signature);

// 验证签名
const verify = crypto.createVerify('SHA256');
verify.update('Hello, world!');
const isVerified = verify.verify(publicKey, signature, 'hex');
console.log('Verified:', isVerified);  // true 或 false
</code></pre>
    <h5>
     <a id="6_Key_Pair_Generation_137">
     </a>
     6. 密钥对生成（Key Pair Generation）
    </h5>
    <p>
     非对称加密中，公钥和私钥的生成可以通过
     <code>
      crypto.generateKeyPairSync
     </code>
     方法。
    </p>
    <ul>
     <li>
      <code>
       generateKeyPairSync(type, options)
      </code>
      ：生成公钥和私钥对，
      <code>
       type
      </code>
      指定加密算法类型（如
      <code>
       'rsa'
      </code>
      ），
      <code>
       options
      </code>
      包含密钥的相关参数。
     </li>
     <li>
      <code>
       export(options)
      </code>
      ：将密钥导出为 PEM 格式。
     </li>
    </ul>
    <h6>
     <a id="_RSA__144">
     </a>
     示例：生成 RSA 密钥对
    </h6>
    <pre><code>const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
});

console.log('Private Key:', privateKey.export({ type: 'pkcs1', format: 'pem' }));
console.log('Public Key:', publicKey.export({ type: 'pkcs1', format: 'pem' }));
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343832333133312f:61727469636c652f64657461696c732f313436313037343631" class_="artid" style="display:none">
 </p>
</div>


