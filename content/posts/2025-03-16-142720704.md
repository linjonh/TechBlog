---
layout: post
title: "Unity小框架之单例模式基类"
date: 2025-03-16 19:41:12 +0800
description: "是一种常用的创建型设计模式，其核心目标是确保一个类只有一个实例，并提供一个全局访问点。它常用于需要控制资源访问、共享配置或管理全局状态的场景（如数据库连接池、日志管理器、应用配置等）。new下面来介绍一下在C#和unity中实现的单例模式基类，你某些需要进行单例模式化的脚本，就可以继承这个基类然后就实现了自己的单例化，那你就可以在其他地方进行使用了。"
keywords: "Unity小框架之单例模式基类"
categories: ['未分类']
tags: ['游戏引擎', 'Unity', 'C']
artid: "142720704"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=142720704
    alt: "Unity小框架之单例模式基类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=142720704
featuredImagePreview: https://bing.ee123.net/img/rand?artid=142720704
cover: https://bing.ee123.net/img/rand?artid=142720704
image: https://bing.ee123.net/img/rand?artid=142720704
img: https://bing.ee123.net/img/rand?artid=142720704
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity小框架之单例模式基类
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      单例模式（Singleton Pattern）
     </strong>
     是一种常用的创建型设计模式，其核心目标是确保一个类只有一个实例，并提供一个全局访问点。它常用于需要控制资源访问、共享配置或管理全局状态的场景（如数据库连接池、日志管理器、应用配置等）。
    </p>
    <h2>
     <strong>
      单例模式的核心思想
     </strong>
    </h2>
    <ol>
     <li>
      ​
      <strong>
       私有构造函数
      </strong>
      ：防止外部通过
      <code>
       new
      </code>
      创建多个实例。
     </li>
     <li>
      ​
      <strong>
       静态私有实例
      </strong>
      ：类内部持有唯一的实例。
     </li>
     <li>
      ​
      <strong>
       全局访问方法
      </strong>
      ：提供一个静态方法（如
      <code>
       getInstance()
      </code>
      ）获取唯一实例。
     </li>
    </ol>
    <p>
     下面来介绍一下在C#和unity中实现的单例模式基类，你某些需要进行单例模式化的脚本，就可以继承这个基类然后就实现了自己的单例化，那你就可以在其他地方进行使用了。
    </p>
    <p>
     一、最基本的单例基类
    </p>
    <p>
     代码：
    </p>
    <pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//单例模式基类模块

//1.C#泛型的知识
//2.设计模式中 单例模式的知识
public class BaseManager &lt;T&gt; where T : new()
{
    //单例模式
    private static T instance;


    public static T GetInstance()
    {
        if (instance == null)
        {
            instance = new T();
        }
        return instance;
    }
}

</code></pre>
    <p>
    </p>
    <p>
     使用方法：
    </p>
    <p>
     例如下面这个脚本，我们创建了一个NewBehaviourScript的脚本，然后直接继承单例模式基类，如果其他地方需要调用，就直接使用就行
    </p>
    <pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : BaseManager&lt;NewBehaviourScript&gt;
{   
   void Start()
    {
        Debug.Log(NewBehaviourScript.GetInstance());
    }
}
</code></pre>
    <p>
     再来一个示例：
    </p>
    <pre><code class="language-cs">// 子类继承 BaseManager，并满足 new() 约束
public class GameManager : BaseManager&lt;GameManager&gt;
{
    // 必须有一个公共无参构造函数
    public GameManager() 
    {
        Debug.Log("GameManager Created");
    }

    public void Init()
    {
        Debug.Log("GameManager Initialized");
    }
}

// 使用方式
void Start()
{
//可以在你项目中的任意一个地方进行使用
    GameManager manager = GameManager.GetInstance();
    manager.Init();

    // 问题：外部仍然可以 new GameManager()，破坏单例！
    GameManager another = new GameManager(); // 这是允许的 但是你自己选择可以不实现 后面我们还有保护措施 使得外部不能实例化
}</code></pre>
    <p>
     二、继承了Mono的单例模式基类
    </p>
    <p>
     继承了Mono那么我们就可以使用Unity的生命周期函数了
    </p>
    <p>
     代码：
    </p>
    <pre><code class="language-cs">public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour
{
    private static T _instance;

    // 使用属性替代 GetInstance()，更符合 C# 习惯
    public static T Instance
    {
        get
        {
            // 如果实例不存在，尝试查找或创建
            if (_instance == null)
            {
                _instance = FindObjectOfType&lt;T&gt;();

                // 如果场景中没有，自动创建一个新的 GameObject
                if (_instance == null)
                {
                    GameObject obj = new GameObject(typeof(T).Name);
                    _instance = obj.AddComponent&lt;T&gt;();
                }
            }
            return _instance;
        }
    }

    protected virtual void Awake()
    {
        // 如果实例已存在且不是当前对象，销毁自身
        if (_instance != null &amp;&amp; _instance != this)
        {
            Destroy(gameObject);
            return;
        }

        // 初始化实例
        _instance = this as T;

        // 按需设置跨场景保留
        DontDestroyOnLoad(gameObject); 
    }
}</code></pre>
    <p>
     还有个简单的版本：
    </p>
    <pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//C#泛型的知识
//设计模式中 单例模式的知识

//继承了MonoBehaviour的 单例模式对象 需要我们自己保证它的唯一性
public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour
{
   private static T instance;

    public static T GetInstance()
    {
        //继承了MonoBehaviour的类，不能直接new
        //只能通过拖动到对象上 或者通过加脚本的api AddComponent
        //U3d内部会帮助我们直接实例化
        return instance;
    }
    protected virtual void Awake()
    {
        instance = this as T;
    }
}
</code></pre>
    <p>
     请注意:继承了这个单例模式基类的话，是不能够自己去new的你只能拖拽到物体身上。
    </p>
    <p>
     示例：
    </p>
    <p>
     这样改进是为了让我们在没有继承Mono的时候，仍然能使用生命周期函数
    </p>
    <pre><code class="language-cs">public class AudioManager : SingletonMono&lt;AudioManager&gt;
{
    public void PlaySound(string clipName)
    {
        Debug.Log("Playing: " + clipName);
    }
}

// 使用方式
void Start()
{
    AudioManager.Instance.PlaySound("BackgroundMusic");
}</code></pre>
    <p>
     示例：
    </p>
    <pre><code class="language-cs">using UnityEngine;

// 继承 SingletonMono，并指定自身为泛型类型 T
public class SoundManager : SingletonMono&lt;SoundManager&gt;
{
    // 自定义音频方法
    public void PlaySound(string clipName)
    {
        Debug.Log("播放音效: " + clipName);
    }

    // 初始化音频资源（在 Awake 中调用）
    protected override void Awake()
    {
        base.Awake(); // 调用基类的 Awake 方法，确保单例赋值
        Debug.Log("SoundManager 初始化完成");
    }
}</code></pre>
    <p>
     <img alt="" height="1014" src="https://i-blog.csdnimg.cn/direct/1cb35ecc0df34a99addf9a14710da03d.png" width="1914"/>
    </p>
    <p>
     创建这样一个空物体，挂在脚本后，其他的类里面才能使用
    </p>
    <p>
     使用：
    </p>
    <pre><code class="language-cs">public class PlayerController : MonoBehaviour
{
    private void Start()
    {
        // 获取 SoundManager 实例并调用方法
        SoundManager.Instance.PlaySound("跳跃音效");
    }

    private void Update()
    {
        // 直接通过 Instance 属性访问
        if (Input.GetKeyDown(KeyCode.Space))
        {
            SoundManager.Instance.PlaySound("射击音效");
        }
    }
}</code></pre>
    <p>
     三、继承了mono并且已经自己实例化的
    </p>
    <pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SingletonAutoMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour
{
    private static T instance;

    public static T GetInstance()
    {
        if (instance == null)
        {
            GameObject obj = new GameObject();
            //设置对象的名字为脚本名字
            obj.name = typeof(T).ToString();
            //让这个单例模式对象过场景不移除
            //因为 单例模式对象 往往是存在于整个程序生命周期中的
            DontDestroyOnLoad(obj);

            instance = obj.AddComponent&lt;T&gt;();
        }
        return instance;
    }
  
}
</code></pre>
    <p>
     使用示例：
    </p>
    <p>
     在继承了这个类的脚本里面直接使用内部的函数即可
    </p>
    <pre><code class="language-cs">public class NetworkManager : SingletonAutoMono&lt;NetworkManager&gt;
{
    public void Connect(string serverIP)
    {
        Debug.Log($"连接到服务器: {serverIP}");
    }

    protected override void Awake()
    {
        base.Awake(); // 调用基类 Awake 确保单例初始化
        Debug.Log("网络管理器已初始化");
    }
}

// 使用方式
void Start()
{
    NetworkManager.Instance.Connect("127.0.0.1");
}</code></pre>
    <p>
    </p>
    <h4>
     ​
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       ​
       <strong>
        手动挂载与自动创建的冲突
       </strong>
       ：
      </p>
      <ul>
       <li>
        如果手动在场景中挂载脚本，需确保只有一个实例。
       </li>
       <li>
        优化后的代码会优先使用手动挂载的实例。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        跨场景行为
       </strong>
       ：
      </p>
      <ul>
       <li>
        若需某个单例仅在特定场景存在，移除
        <code>
         DontDestroyOnLoad
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343231323931362f:61727469636c652f64657461696c732f313432373230373034" class_="artid" style="display:none">
 </p>
</div>


