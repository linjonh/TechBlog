---
layout: post
title: "数据结构单循环链表clist"
date: 2025-03-13 11:12:11 +0800
description: "单循环链表是一种线性数据结构，其中每个节点包含两个部分：数据域：存储数据元素。指针域：存储指向下一个节点的指针。与普通单链表不同的是，单循环链表的最后一个节点的指针指向头节点，而不是 NULL。这种环状结构使得单循环链表在某些场景下具有独特的优势。"
keywords: "数据结构——单循环链表clist"
categories: ['数据结构']
tags: ['数据结构']
artid: "146158198"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158198
    alt: "数据结构单循环链表clist"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158198
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158198
cover: https://bing.ee123.net/img/rand?artid=146158198
image: https://bing.ee123.net/img/rand?artid=146158198
img: https://bing.ee123.net/img/rand?artid=146158198
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——单循环链表clist
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      前言：大家好😍，本文主要介绍了数据结构——单循环链表clist
     </p>
    </blockquote>
    <hr/>
    <h2 id="%E4%B8%80%E3%80%81%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" name="%E4%B8%80%E3%80%81%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">
     <a id="pandas_16">
     </a>
     一、单循环链表
     <strong>
      的定义
     </strong>
    </h2>
    <p>
     <img alt="" height="328" src="https://i-blog.csdnimg.cn/direct/f87f90b1254f4149acb2ce7957f6513b.png" width="572"/>
    </p>
    <p>
     单循环链表是一种线性数据结构，其中每个节点包含两个部分：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        数据域
       </strong>
       ：存储数据元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        指针域
       </strong>
       ：存储指向下一个节点的指针。
      </p>
     </li>
    </ol>
    <p>
     与普通单链表不同的是，
     <span style="background-color:#ffd900">
      单循环链表的最后一个节点的指针指向头节点，而不是
     </span>
     <code>
      <span style="background-color:#ffd900">
       NULL
      </span>
     </code>
     。这种环状结构使得单循环链表在某些场景下具有独特的优势。
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C" name="%E4%BA%8C%E3%80%81%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C">
     <a id="_19">
     </a>
     二、单循环链表
     <strong>
      的操作
     </strong>
    </h2>
    <h3 id="2.1%20%E5%AE%9A%E4%B9%89" name="2.1%20%E5%AE%9A%E4%B9%89">
     2.1 定义
    </h3>
    <pre><code class="hljs">typedef int ELEM_TYPE;
//单循环链表的有效节点的结构体设计
typedef struct CNode
{
    ELEM_TYPE data;//数据域
    struct CNode* next;//指针域(保存下一个有效节点的地址)
}CNode, * PCNode;</code></pre>
    <h3 id="2.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" name="2.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">
     2.2 初始化
    </h3>
    <p>
     <img alt="" height="178" src="https://i-blog.csdnimg.cn/direct/eee40c38c77549e08f8d2aad8c1c3ae0.png" width="517"/>
    </p>
    <pre><code class="hljs">void Init_CList(CNode* plist)
{
	plist-&gt;next = plist;//指针域指向自身
}</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        <code>
         <span style="background-color:#ffd900">
          plist-&gt;next = plist
         </span>
         ;
        </code>
        ：将头节点的
        <code>
         next
        </code>
        指针指向它自己。
       </p>
       <ul>
        <li>
         <p>
          <strong>
           目的
          </strong>
          ：
          <span style="color:#fe2c24">
           形成一个空的环状结构。
          </span>
         </p>
        </li>
        <li>
         <p>
          <strong>
           意义
          </strong>
          ：在单循环链表中，最后一个节点的
          <code>
           next
          </code>
          指针会指向头节点，而当链表为空时，头节点的
          <code>
           next
          </code>
          指针也指向它自己，表示链表中没有其他节点。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h3 id="%C2%A02.3%20%E6%8F%92%E5%85%A5" name="%C2%A02.3%20%E6%8F%92%E5%85%A5">
     2.3 插入
    </h3>
    <h4 id="2.3.1%20%E5%A4%B4%E6%8F%92" name="2.3.1%20%E5%A4%B4%E6%8F%92">
     <a id="1_20">
     </a>
     2.3.1 头插
    </h4>
    <p>
     <img alt="" height="529" src="https://i-blog.csdnimg.cn/direct/6eb6b8d70a2e4a3bbfc29edd27418c29.png" width="443"/>
    </p>
    <pre><code class="hljs">bool Insert_head(CNode* plist, ELEM_TYPE val)
{
	//0.assert
	assert(plist != NULL);
	if (plist == NULL)
	{
		return false;
	}

	//1.购买新节点
	CNode* pnewnode = (CNode*)malloc(sizeof(CNode));
	if (pnewnode == NULL)
		exit(1);
	pnewnode-&gt;data = val;

	//2.找到合适的待插入位置
	//因为是头插 比较特殊，就是插入在辅助节点的后边

	//3.插入
	pnewnode-&gt;next = plist-&gt;next;
	plist-&gt;next = pnewnode;

	return true;
}</code></pre>
    <h4 id="2.3.2%20%E5%B0%BE%E6%8F%92%C2%A0" name="2.3.2%20%E5%B0%BE%E6%8F%92%C2%A0">
     2.3.2 尾插
    </h4>
    <p>
     <img alt="" height="312" src="https://i-blog.csdnimg.cn/direct/a6dff51eab1d413f8bc87f3a798850fe.png" width="580"/>
    </p>
    <pre><code class="hljs">bool Insert_tail(CNode* plist, ELEM_TYPE val)
{
	//0.assert
	assert(plist != NULL);

	//1.购买新节点
	CNode* pnewnode = (CNode*)malloc(sizeof(CNode));
	if (pnewnode == NULL)
		exit(1);
	pnewnode-&gt;data = val;

	//2.找到合适的待插入位置
	//尾插，需要让临时指针p，停在当前的尾结点处
	CNode* p = plist;
	while (p-&gt;next != plist)
	{
		p = p-&gt;next;
	}

	//3.插入(两行代码)
	pnewnode-&gt;next = p-&gt;next;
	p-&gt;next = pnewnode;

	return true;
}</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        从头节点开始，通过循环找到链表的尾节点。
       </p>
      </li>
      <li>
       <p>
        <strong>
         条件
        </strong>
        ：
        <code>
         <span style="background-color:null">
          p-&gt;next != plist
         </span>
        </code>
        <span style="background-color:null">
         ，说明当前节点的下一个节点不是头节点，即当前节点不是尾节点。
        </span>
       </p>
      </li>
      <li>
       <p>
        <span style="background-color:#ffd900">
         当循环结束时，
        </span>
        <code>
         <span style="background-color:#ffd900">
          p
         </span>
        </code>
        <span style="background-color:#ffd900">
         指向尾节点
        </span>
        。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          pnewnode-&gt;next = p-&gt;next;
         </code>
        </strong>
        ：将新节点的
        <code>
         next
        </code>
        指针指向头节点（因为尾节点的
        <code>
         next
        </code>
        指向头节点）。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          p-&gt;next = pnewnode;
         </code>
        </strong>
        ：将尾节点的
        <code>
         next
        </code>
        指针指向新节点，完成插入操作。
       </p>
      </li>
     </ul>
    </blockquote>
    <h4 id="2.3.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92%C2%A0" name="2.3.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92%C2%A0">
     2.3.3 按位置插
    </h4>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%912.4%20%E5%88%A0%E9%99%A4" name="%E2%80%8B%E7%BC%96%E8%BE%912.4%20%E5%88%A0%E9%99%A4">
     <img alt="" height="686" src="https://i-blog.csdnimg.cn/direct/88d2757a623c46efa9065e41e53ef0c9.png" width="524">
      <br/>
      2.4 删除
     </img>
    </h3>
    <h4 id="2.4.1%20%E5%A4%B4%E5%88%A0" name="2.4.1%20%E5%A4%B4%E5%88%A0">
     2.4.1 头删
    </h4>
    <p>
     <img alt="" height="181" src="https://i-blog.csdnimg.cn/direct/2fbbc9fe01b147f1aa6344acf7f45a4d.png" width="554"/>
    </p>
    <pre><code class="hljs">bool Del_head(CNode* plist)
{
	//0.安全性处理
	assert(plist != NULL);
	if (plist == NULL)
		return false;

	//1.对单循环链表判空
	if (Is_Empty(plist))
		return false;

	//2.需要一个临时指针q指向待删除节点
	//因为是头删，所以待删除节点就是第一个有效值节点
	CNode* q = plist-&gt;next;

	//3.再需要一个临时指针p指向待删除节点的前驱(上一个节点)
	//因为是头删,所以这里的p用辅助节点plist代替即可

	//4.跨越指向+释放
	plist-&gt;next = q-&gt;next;
	free(q);
	q = NULL;

	return true;
}
</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        定义一个临时指针
        <code>
         q
        </code>
        ，指向第一个有效节点（即头节点的下一个节点 ）
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          plist-&gt;next = q-&gt;next;
         </code>
        </strong>
        ：将头节点的
        <code>
         next
        </code>
        指针指向
        <code>
         q
        </code>
        的下一个节点，即跨越
        <code>
         q
        </code>
        节点。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          free(q);
         </code>
        </strong>
        ：释放
        <code>
         q
        </code>
        节点的内存。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          q = NULL;
         </code>
        </strong>
        ：将
        <code>
         q
        </code>
        指针置为
        <code>
         NULL
        </code>
        ，避免野指针。
       </p>
      </li>
     </ul>
    </blockquote>
    <h4 id="2.4.2%20%E5%B0%BE%E5%88%A0" name="2.4.2%20%E5%B0%BE%E5%88%A0">
     2.4.2 尾删
    </h4>
    <p>
     <img alt="" height="176" src="https://i-blog.csdnimg.cn/direct/5c5ab1515b54474cbda6c726c8d44b72.png" width="656"/>
    </p>
    <pre><code class="hljs">bool Del_tail(CNode* plist)
{
	//0.安全性处理
	assert(plist != NULL);
	if (plist == NULL)
		return false;

	//1.对单循环链表判空
	if (Is_Empty(plist))
		return false;

	//2.需要一个临时指针q指向待删除节点
	CNode* q = plist;
	for (; q-&gt;next != plist; q = q-&gt;next);

	//3.再需要一个临时指针p指向待删除节点的前驱(上一个节点)
	CNode* p = plist;
	for (; p-&gt;next != q; p = p-&gt;next);


	//4.跨越指向+释放
	p-&gt;next = q-&gt;next;
	free(q);
	q = NULL;

	return true;
}</code></pre>
    <h4 id="2.4.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0" name="2.4.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0">
     2.4.3 按位置删
    </h4>
    <p>
     <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/ae743219106e44ad9cc50961995f32ee.png" width="511"/>
    </p>
    <pre><code class="hljs">bool Del_pos(CNode* plist, int pos)
{
	//0.安全性处理
	assert(plist != NULL);
	if (plist == NULL)
		return false;
	assert(pos &gt;= 0 &amp;&amp; pos &lt; Get_length(plist));

	//1.对单循环链表判空
	if (Is_Empty(plist))
		return false;

	//2.需要一个临时指针q指向待删除节点
	//3.再需要一个临时指针p指向待删除节点的前驱(上一个节点)

	CNode* p = plist;
	for (int i = 0; i &lt; pos; i++)
		p = p-&gt;next;
	CNode* q = p-&gt;next;


	//4.跨越指向+释放
	p-&gt;next = q-&gt;next;
	free(q);
	q = NULL;

	return true;
}</code></pre>
    <h4 id="2.4.4%20%E6%8C%89%E5%80%BC%E5%88%A0" name="2.4.4%20%E6%8C%89%E5%80%BC%E5%88%A0">
     2.4.4 按值删
    </h4>
    <pre><code class="hljs">
//8.按值删(删除值val出现的第一次的地方)
bool Del_val(CNode* plist, ELEM_TYPE val)
{
	//0.安全性处理
	assert(plist != NULL);
	if (plist == NULL)
		return false;

	//1.对单循环链表判空
	if (Is_Empty(plist))
		return false;

	//2.需要一个临时指针q指向待删除节点
	//通过Search去找一下，val值出现的第一次的位置
	CNode* q = Search(plist, val);
	if (q == NULL)
		return false;

	//3.再找到待删除节点的前驱，用p指向
	CNode* p = plist;
	for (; p-&gt;next != q; p = p-&gt;next);

	//4.跨越指向+释放
	p-&gt;next = q-&gt;next;
	free(q);
	q = NULL;

	return true;
}


//8.5 按值删(删除值val出现的所有的地方)
bool Del_val_all(CNode* plist, ELEM_TYPE val)
{
	CNode* p = plist;
	CNode* q = plist;

	while (p-&gt;next != plist)
	{
		q = p-&gt;next;
		if (q-&gt;data == val)
		{
			p-&gt;next = q-&gt;next;
			free(q);
			q = NULL;
		}
		else
		{
			p = q;
		}
	}

	return true;
}</code></pre>
    <h3 id="2.5%20%E5%85%B6%E4%BD%99%E4%BB%A3%E7%A0%81" name="2.5%20%E5%85%B6%E4%BD%99%E4%BB%A3%E7%A0%81">
     2.5 其余代码
    </h3>
    <pre><code class="hljs">//9.查找(查找值val出现的第一次的地方)
CNode* Search(CNode* plist, ELEM_TYPE val)
{
	for (CNode* p = plist-&gt;next; p != plist; p = p-&gt;next)
	{
		if (p-&gt;data == val)
		{
			return p;
		}
	}
	return NULL;
}

//10.清空
void Clear(CNode* plist)
{
	Destroy1(plist);
}

//11.销毁1(需要辅助节点参与进来)
void Destroy1(CNode* plist)
{
	while (plist-&gt;next != plist)
	{
		CNode* p = plist-&gt;next;
		plist-&gt;next = p-&gt;next;
		free(p);
		p = NULL;
	}

}

//12.销毁2(不需要辅助节点参与进来)
void Destroy2(CNode* plist)
{
	//0.assert  head
	//1.申请指针p，让其保存辅助节点的指针域
	CNode* p = plist-&gt;next;

	//2.申请指针q，先不给q赋值
	CNode* q = NULL;

	//3.反复通过p和q打配合，去销毁后续节点
	while (p != plist)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}

	//4.节点全部销毁完毕，别忘了把辅助节点的指针域处理一下
	plist-&gt;next = plist;
}

//13.判空 
bool Is_Empty(CNode* plist)
{
	return plist-&gt;next == plist;
}

//14.获取有效值长度
int Get_length(CNode* plist)
{
	int count = 0;
	for (CNode* p = plist-&gt;next; p != plist; p = p-&gt;next)
	{
		count++;
	}
	return count;
}

//15.打印
void Show(CNode* plist)
{
	for (CNode* p = plist-&gt;next; p != plist; p = p-&gt;next)
	{
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}
</code></pre>
    <h3 id="2.6%20%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" name="2.6%20%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">
     2.6 主函数测试代码
    </h3>
    <pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include "clist.h"


单循环链表的测试用例
int main()
{
	CNode head;
	Init_CList(&amp;head);
	Insert_head(&amp;head, 100);
	Insert_tail(&amp;head, 200);
	Insert_head(&amp;head, 300);
	Insert_tail(&amp;head, 400);
	Show(&amp;head);


	Del_head(&amp;head);
	Show(&amp;head);
	Del_tail(&amp;head);
	Show(&amp;head);
	Del_pos(&amp;head, 1);
	Show(&amp;head);
	Del_val(&amp;head, 100);
	Show(&amp;head);

	Insert_tail(&amp;head, 1);
	Insert_tail(&amp;head, 2);
	Insert_tail(&amp;head, 1);
	Insert_tail(&amp;head, 4);
	Insert_tail(&amp;head, 1);
	Show(&amp;head);
	
		Del_val_all(&amp;head, 1);
		Show(&amp;head);
		return 0;
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37353139373930362f:61727469636c652f64657461696c732f313436313538313938" class_="artid" style="display:none">
 </p>
</div>


