---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3431333938343438:2f61727469636c652f64657461696c732f3836363139343632"
layout: post
title: "网络安全期末大论文"
date: 2024-11-27 22:42:33 +08:00
description: "本文深入探讨了网络安全领域内的常见威胁，包括病毒、木马及网络入侵手法，同时介绍了网络安全技术的发展，"
keywords: "张识虔"
categories: ['网络安全']
tags: ['网络安全']
artid: "86619462"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=86619462
    alt: "网络安全期末大论文"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=86619462
featuredImagePreview: https://bing.ee123.net/img/rand?artid=86619462
---

# 网络安全期末大论文

桂林理工大学

**《网络安全》**

学生姓名


张识虔

学    号
3162052051116

所属学院


信息科学与工程学院

专    业


软件工程

班    级
16-1

班

教    师


张攀峰

桂林理工大学教务处

**《网络安全》课程论文**

作者 张识虔

［
**摘  要**
：
随着



[计算](http://www.studa.net/pc/)

机技术和



[网络](http://www.studa.net/network/)

技术的



[发展](http://www.studa.net/fazhan/)

， 网络安全问题， 在今天已经成为网络世界里最为人关注的问题之一 危害网络安全的因素很多， 它们主要依附于各种恶意软件， 其中病毒和木马最为一般网民所熟悉。针对这些危害因素， 网络安全技术得以快速发展， 这也大大提高了网络的安全性。文章分析了几种常见的网络入侵方法以及在此基础上探讨了网络安全的几点策略。
  
**关键词**
：
网络安全  计算机网络  入侵检测

1. 前 言
  

一、 计算机网络安全的含义
  

计算机网络安全的具体含义会随着使用者的变化而变化，使用者不同，对网络安全的认识和要求也就不同。例如从普通使用者的角度来说，可能仅仅希望个人隐私或机密信息在网络上传输时受到保护， 避免被窃听、篡改和伪造； 而网络提供商除了关心这些网络信息安全外，还要考虑如何应付突发的



[自然](http://www.studa.net/lixue/)

灾害、 军事打击等对网络硬件的破坏，以及在网络出现异常时如何恢复网络通信， 保持网络通信的连续性。从本质上来讲，网络安全包括组成网络系统的硬件、软件及其在网络上传输信息的安全性，使其不致 因偶然的或者恶意的攻击遭到破坏，网络安全既有技术方面的问题，也有管理方面的问题，两方面相互补充，缺一不可。
  

二、 常见的几种网络入侵方法
  

由于计算机网络的设计初衷是资源共享、分散控制、分组交换，这决定了互联网具有大跨度、分布式、无边界的特征。这种开放性使黑客可以轻而易举地进入各级网络，并将破坏行为迅速地在网络中传播。同时，计算机网络还有着自然社会中所不具有的隐蔽性：无法有效识别网络用户的真实身份；由于互联网上信息以二进制数码，即数字化的形式存在，所以操作者能比较容易地在数据传播过程中改变信息内容。计算机网络的传输协议及操作系统也存在设计上的缺陷和漏洞，从而导致各种被攻击的潜在危险层出不穷，这使网络安全问题与传统的各种安全问题相比面临着更加严峻的挑战，黑客们也正是利用这样的特征研发出了各种各样的攻击和入侵方法：
  

1.

通过伪装发动攻击
  

2.

利用开放端口漏洞发动攻击
  

3.

通过木马程序进行入侵或发动攻击
  

4.

嗅探器和扫描攻击
  

为了应对不断更新的网络攻击手段，网络安全技术也经历了从被动防护到主动检测的发展过程。主要的网络安全技术包括：防火墙、VPN、防毒墙、入侵检测、入侵防御、漏洞扫描。其中防病毒、防火墙和VPN属早期的被动防护技术，入侵检测、入侵防御和漏洞扫描属主动检测技术，这些技术领域的研究成果已经成为众多信息安全产品的基础。
  
1.1论文的目的和意义

我们是软件工程的本科生，《网络安全》是我们重要的课程。当代社会学要大学培养出理论扎实，动手实践能力强的大学生。所以，本次课程大作业的目的就在于通过一次实践性的活动加深对这门课程的理解，使我们在感性的认识上进一步升华为理性的认识。为后继课程的学习打下坚实的基础。

马克思主义唯物辩证法认为，实践是连接客观实在和人主观意识的通道和桥梁。物质对意识的作用以及意识对物质的反作用都蕴含在实践活动当中。也就是，实践是检验真理的唯一标准。对这门课的学习状况的好坏，用一次课程大作业便可以检验出来。而这，就是本次我们课程大作业的意义之所在。

1.2
大论文的目标

本次课程大作业主要是通过对上机软件如下的几点的认真落实：

1、 利用sniffer抓包软件，分析IP头的结构。

2、 利用sniffer工具，分析TCP头的结构，并分析TCP的三次握手过程。

3、 实现加解密程序。（详见《密码学及应用实验部分》，实验一）

4、 已知RSA算法中，素数p=5,q=7,模数n=35，公钥e=5，明文为bed，对明文进行加解密，使用手工完成RSA公开秘钥密码体制算法加密运算。

5、 安装一款杀毒软件，分析该软件从哪些方面对计算机进行防护，这些功能与

2. 论文任务

2.1
**利用**
**sniffer**
**抓包软件，分析**
**IP**
**头的结构。（请附上截图）**

根据IP数据报 来分析IP

![](https://i-blog.csdnimg.cn/blog_migrate/85fe76471e3a3b328cfb553005586293.png)

![](https://i-blog.csdnimg.cn/blog_migrate/9540b57929050180f71aaa280f7edb4f.png)

由抓包结果可知 IP包 红框内 灰色部分

![](https://i-blog.csdnimg.cn/blog_migrate/79db7d1f9837d8b693bf4176fa6cde7a.png)

“45”，其中“4”是IP协议的版本（Version），说明是IP4。“5”是IHL位，表示IP头部的长度，是一个4bit字段，最大就是1111了，值为15（表示有15行，一行有32bit），IP头部的最大长度就是60字节。而这里为“5”，说明是20字节，这是标准的IP头部长度，头部报文中没有发送可选部分数据。

“00”，为服务类型（Type of Service）。这个8bit字段由3bit的优先权子字段

“00 3C”，为IP数据报文总长，包含头部以及数据，这里表示60字节。这60字节由20字节的IP头部以及40字节的TCP头构成（最后的一个字节为数据）。因此目前最大的IP数据包长度是65535字节。

“
01 29

” 两个字节为数据包封装标识信息，与后面的偏移量一起用，这个是让目的主机来判断新来的分段属于哪个分组。

“00 00”其中前三位表示标志位，后面13位表示片段偏移地址。其中第一位是IP协议目前没有用上的，为0。接着的是两个标志DF和MF。DF为1表示不要分段，MF为1表示还有进一步的分段（本例为0）。然后的“0 0000”是分段便移（Fragment Offset）。

“
80
”
这个字节就是TTL（Time To Live）了，表示一个IP数据流的生命周期，用Ping显示的结果，能得到TTL的值50（将十六进制的80转化为十进制得48）。

“
01
”
这个字节表示传输层的协议类型（Protocol）。在RFC790中有定义，1表示传输层是ICMP协议

“
7d 44
”
这个16bit是头校验和（Header Checksum）。

“
c0 a8 9d 80
”表示
源地址，也就是PC的IP地址，转换为十进制的IP地址就是：192.168.157.128。

“c0 a8 9d 82”表示目标IP地址，转换为十进制的IP地址就是：192.168.1.130

2.2
**利用**
**sniffer**
**工具，分析**
**TCP**
**头的结构，并分析**
**TCP**
**的三次握手过程。（请附上截图）**

![](https://i-blog.csdnimg.cn/blog_migrate/7c1d47c12569774a7a8f8951bc27155f.png)

抓包结束后 可以获得TCP头

![](https://i-blog.csdnimg.cn/blog_migrate/a6676dfee22dfc87ea1af41be5730dc7.png)

根据TCP头结构对获得的TCP头进行分析

![](https://i-blog.csdnimg.cn/blog_migrate/ea1701c4c5a1cd54d3d5a11b0fdcf796.png)

TCP

包头占有20个字节，后00 00 6e 6f 6f 70 0d 0a
部分是可选项和数据部分。

“00 15”表示目的端口号为：21，可知用了FTP文件文件传输。

“68 47 e2 37”表示数据包
顺序号（Sequence Number）
。

“d7 44 7c a2”表示
（Acknowledgment Number），简写为ACKNUM。
在此为不全0，表示连接成功，有确认。

“50 18”两字节中，前4位为头部长度，用十进制表示为7，转化为字节，总共有7×4=28字节；中间六位为保留，
都为0，在TCP协议没有用上；
后面6位为000010，是重要的6个标志位，此时SYN=1，
ACK=0

，连接响应时，表示连接向应超时。

“f9 78”两个字节表示窗口大小为63864。

“6c 67”
这个16bit是头校验和（Header Checksum）。

“
00 00
”为紧急指针，此时表示没有，当且仅当URG同时置1才有效。

TCP

的三次握手过程

![](https://i-blog.csdnimg.cn/blog_migrate/b728dd08cfdec577d9628cecb844218f.png)

第一次握手：192.168.157.128发送位码syn＝1,随机产生SEQ number =1384476279的数据包到192.168.157.130 ，192.168.157.130由SYN=1知道192.168.157.128要求建立联机;

![](https://i-blog.csdnimg.cn/blog_migrate/bde9e28bd32b840d75f4a42ac7d75199.png)

第二次握手：192.168.157.130收到请求后要确认联机信息，向192.168.157.128发送ACK number =1384476280,SYN=1,ACK=1,随机产生SEQ number =337715159741的包;

![](https://i-blog.csdnimg.cn/blog_migrate/5c1688d31f44a66d62c6c90b5fcba635.png)

第三次握手：192.168.157.128收到后检查ACK是否正确，即第一次发送的SEQ number + 1,以及位码ACK是否为1，若正确，192.168.157.128会再发送ACK number =3377159742,ACK=1，192.168.157.130收到后确认SEQ = SEQ + 1,ACK=1则连接建立成功。

![](https://i-blog.csdnimg.cn/blog_migrate/0a742fd41048f8045d50850142da29bd.png)

2.3
**实现加解密程序。（详见《密码学及应用实验部分》，实验一）（附截图）**

**代替算法(JAVA实现)**

```java
import java.util.Scanner;

class Encryption{

public void Encryption() {

    char l;

    System.out.println("请输入要加密的明文");

    Scanner input = new Scanner(System.in);

    String str1 = input.nextLine();

    System.out.println("请输入要加密的密钥");

    int k = input.nextInt();

   

    System.out.print("加密后的明文为: ");

    for(int i = 0 ; i < str1.length() ; i ++) {

       int n = (int)(str1.charAt(i));

       if(n > 96 && n < 123) {

           n = (n - 97 + k) % 26; 

           l = (char)(n + 97);

           System.out.print(l);

       }

    }

}

}



class Decrypt{

public void Decrypt() {

    char l ;

   

    System.out.println("请输入需要解密的密文");

    Scanner input = new Scanner(System.in);

    String str3 = input.nextLine();

    System.out.println("请输入解密的密钥");

    int k = input.nextInt();

   

    System.out.println("解密的明文是： ");

    for(int i = 0 ; i < str3.length() ; i ++) {

       int n = (int)(str3.charAt(i));

      

       if(n > 96 && n < 123) {

           n = (n - 97 - k) % 26;

           if(n == -1)

              n = 25;

           l = (char)(n + 97);

           System.out.print(l);

       }

    }

}

}

public class Substitution {

    public static void main(String[] args) {

      

       while(true) {

           System.out.println("\n选择功能");

           System.out.println("1. 加密功能");

           System.out.println("2. 解密功能");

           Scanner input = new Scanner(System.in);

           int c = input.nextInt();

           switch(c) {

          

              case 1 :{

                  Encryption encryption  = new Encryption();

                  encryption.Encryption();

                  break;

              }

             

              case 2 : {

                  Decrypt decrypt = new Decrypt();

                  decrypt.Decrypt();

                  break;

              }

                 

           }

       }



    }

}
```

![](https://i-blog.csdnimg.cn/blog_migrate/2d44dcb8294e3ac92b404108a000debb.png)

**置换算法(JAVA实现)**

```java
import java.util.Arrays;

import java.util.Scanner;





public class zhihuan4 {

 private String sourceString = "attack begins at five";

 private String keyString = "cipher";



 private int[] secretMatrix;

 private char groupedSource[][];



 private void getSource(){//获取源字符串

  Scanner scan = new Scanner(System.in);

  System.out.print("请输入要加密的字符串:\t");

  sourceString = scan.nextLine();

  System.out.print("请为您输入密钥字符串:\t");

  keyString = scan.next();

 }



 public zhihuan4(){//此类的构造函数

  getSource();

 }



 private void groupSourceString(){//根据keystring为sourcestring创建组

  int sourceLen = sourceString.length();

  int keyLen = keyString.length();

  groupedSource = new char[sourceLen/keyLen+1][keyLen];

  if (sourceLen%keyLen!=0){

   for (int i = 0;i < (keyLen - sourceLen%keyLen);i++){

    sourceString += "#";

   }

  }

  sourceLen = sourceString.length();

  for(int i = 6,j=0;i <= sourceLen;i+=keyLen,j++){

    groupedSource[j] = sourceString.substring(i-keyLen, i).toCharArray();

  }

 }



 private void getTheMatrix(){//获取用于加密的矩阵

  char[] temp01 = keyString.toCharArray();

  secretMatrix = new int[keyString.length()];

  Arrays.sort(temp01);

  for (int i = 0;i < keyString.length();i++){

   for (int j = 0;j<keyString.length();j++){

    if (keyString.toCharArray()[i]==temp01[j]){

     secretMatrix[i] = j;

    }

   }

  }

  }



 private void changeSourceMatix(){

  groupSourceString();

  char temp[][] = new char[groupedSource.length][keyString.length()];

  for (int i = 0;i < groupedSource.length;i++){

   for (int j = 0;j < keyString.length();j++){

    temp[i][j] = groupedSource[i][j];

   }

  }

 

  for (int i = 0;i < groupedSource.length - 1;i++){

   for (int j = 0;j < keyString.length();j++){

    groupedSource[i][j] = temp[i][secretMatrix[j]];

   }

  }

 }



 private void getEncryptedString(){//获取将要打印的矩阵。

  groupSourceString();

  changeSourceMatix();

  char temp[][] = new char[groupedSource.length][keyString.length()];

  for (int i = 0;i < groupedSource.length;i++){

   for (int j = 0;j < keyString.length();j++){

    temp[i][j] = groupedSource[i][j];

   }

  }

 

  for (int i = 0;i < groupedSource.length - 1;i++){

   for (int j = 0;j < keyString.length();j++){

    groupedSource[i][j] = temp[i][secretMatrix[j]];

   }

  }

 }



 public void print1(){//打印密码已加密

  getEncryptedString();

  for(int i = 0;i < keyString.length();i++){

   for(int j = 0;j < groupedSource.length-1;j++){

    System.out.print(groupedSource[j][i]);

   }

  }

  System.out.println();

 }



 //解密过程

 private void groupEncryptedString(){

  int sourceLen = sourceString.length();

  int keyLen = keyString.length();

  char[][] temp =  new char[keyLen][sourceLen/keyLen+1];

  for (int i = 0;i < keyLen;i++){

   temp[i] = sourceString.substring(i*sourceLen/keyLen, (i+1)*sourceLen/keyLen).toCharArray();

  }

  groupedSource = new char[sourceLen/keyLen+1][keyLen];

  for(int j = 0; j < sourceLen/keyLen;j++){

   for (int i = 0;i < keyLen;i++){

    groupedSource[j][i] = temp[i][j];

   }

  }

 }



 private void getDecryptString(){//获取将要打印的矩阵。

  groupEncryptedString();

  char temp[][] = new char[groupedSource.length][keyString.length()];

  for (int i = 0;i < groupedSource.length;i++){

   for (int j = 0;j < keyString.length();j++){

    temp[i][j] = groupedSource[i][j];

   }

  }

 

  for (int i = 0;i < groupedSource.length - 1;i++){

   for (int j = 0;j < keyString.length();j++){

    groupedSource[i][j] = temp[i][secretMatrix[secretMatrix[j]]];

   }

  }

 }



 public void print2(){//打印密码已加密

  getDecryptString();

  for(int j = 0;j < groupedSource.length-1;j++){

   for(int i = 0;i < keyString.length();i++){

    System.out.print(groupedSource[j][i]);

   }

  }

  System.out.println();

 }



 public static void main(String args[]){

  zhihuan4 RD = null;

  Scanner scanin = null;

  System.out.println("请选择要操作的方法：\t（选择“0”进行加密，选择“1”进行解密。)");

  scanin = new Scanner(System.in);

  int selected = scanin.nextInt();

  while(selected==0 || selected==1){

   RD = new zhihuan4();

   RD.getTheMatrix();

   if (selected == 0){

    RD.print1();

   }

   else{

    RD.print2();

   }

   System.out.println("请选择要操作的方法：\t（选择“0”进行加密，选择“1”进行解密。)");

   scanin = new Scanner(System.in);

   selected = scanin.nextInt();

  }

 }

}
```

![](https://i-blog.csdnimg.cn/blog_migrate/bb580932bf012b8feb002acf9dc76ca0.png)

2.4
**已知**
**RSA**
**算法中，素数**
**p=5,q=7,**
**模数**
**n=35**
**，公钥**
**e=5**
**，明文为**
**bed**
**，对明文进行加解密，使用手工完成**
**RSA**
**公开秘钥密码体制算法加密运算。字母数字映射表如下：**

![](https://i-blog.csdnimg.cn/blog_migrate/937da147a7b331c8370d3db187c862cc.png)

**（**
**1**
**）设计公私密钥**
**(e,n)**
**和**
**(d,n)**
**。**
  

令p=5，q=7，得出n=p×q=5×7=35；f(n)=(p-1)(q-1)=4×6=24；公钥e=5，（5与24互质）则e×d≡1 mod f(n)，即5×d≡1 mod 24。

求d的值如下表：

|  |  |  |
| --- | --- | --- |
| d | e\*d = 5\*d | (e\*d)mod(p-1)(q-1)= (5\*d)mod24 |
| 1 | 5 | 5 |
| 2 | 10 | 10 |
| 3 | 15 | 15 |
| 4 | 20 | 20 |
| 5 | 25 | 1 |

通过试算我们找到，当d=5时，e×d≡1 mod f(n)同余等式成立。因此，可令d=5。从而我们可以设计出一对公私密钥，加密密钥（公钥）为：KU =(e,n)=(5,35)，解密密钥（私钥）为：KR =(d,n)=(5,35)。

**（**
**2**
**）英文数字化。**
  

将明文信息数字化，并将每块两个数字分组。假定明文英文字母编码表为按字母顺序排列数值，即：

![](https://i-blog.csdnimg.cn/blog_migrate/695878a404b1a411297fc76c5565a2d7.png)

则得到分组后的bed的明文信息为：02，05，04。

**（**
**3**
**）明文加密**

  

用户加密密钥(5,35) 将数字化明文分组信息加密成密文。由C≡Me(mod n)得：

M1 = {c1}
**e**
{mod n} = 025  {mod 35} = 32

M2 = {c1}e {mod n} = 055  {mod 35} = 10

M3 = {c1} e{mod n} = 045  {mod 35} = 9

（
**4**
**）密文解密。**
  

用户B收到密文，若将其解密，只需要计算M
≡Cd(mod n)
，即：

M1 = {c1} d {mod n} = 325  {mod 35} = 02

M2 = {c1} d {mod n} = 105  {mod 35} = 05

M3 = {c1} d {mod n} = 95  {mod 35} = 04

用户得到明文信息为：02,05,04。根据上面的编码表将其转换为英文，我们又得到了恢复后的原文“bed”。

2.5
**安装一款杀毒软件，分析该软件从哪些方面对计算机进行防护，这些功能与**
**HIDS**
**系统的功能有哪些异同？**

我使用的是德国的小红伞杀毒软件  它的功能

病毒防护

(AntiVir)–

病毒、蠕虫、木马的防御。

间谍软件的防护

(AntiSpyware)–

间谍程序、广告软件、身份盗用

(Identity Theft)

的防御。

恶意软件防护

(AntiRootkit)

此功能同免费版本

链接扫描

(AntiPhishing)

此功能同免费版本

邮件扫描

(AntiSpam) –

可以过滤垃圾信件、防止



[网络诈骗](https://baike.so.com/doc/5403501-5641197.html)

(



[网络钓鱼](https://baike.so.com/doc/5351713-5587171.html)

)

。

小红伞是一款德国著名杀毒软件，自带防火墙。它能有效的保护个人电脑以及工作站的使用，以免受到病毒侵害。它可以检测并移除超过

60

万种病毒，支持网络更新，资源占用很少，监控能力强

HIDS

全称是

Host-based Intrusion Detection System

，即基于



[主机](https://baike.so.com/doc/5331327.html)

型



[入侵检测](https://baike.so.com/doc/6630573.html)

系统。作为计算机系统的监视器和分析器，它并不作用于外部接口，而是专注于系统内部，监视系统全部或部分的动态的行为以及整个计算机系统的状态。由于

HIDS

动态地检查网络数据包这一特性，它可以检测到哪一个程序访问了什么资源以及确保文字处理器（

Word-Processor

）不会突然的、无缘无故的启动并修改系统密码数据库。同样的，不管是往



[内存](https://baike.so.com/doc/176561.html)

、



[文件系统](https://baike.so.com/doc/2574087.html)

、



[日志文件](https://baike.so.com/doc/3744746.html)

还是其它地方存储信息，

HIDS

会一直



[监控系统](https://baike.so.com/doc/5400819.html)

状态，并且核对他们是否还预期相同。

HIDS

运行依赖与这样一个原理：一个成功的



[入侵者](https://baike.so.com/doc/5419030.html)

一般而言都会留下他们入侵的痕迹。这样，



[计算机管理员](https://baike.so.com/doc/5912120.html)

就可以察觉到一些系统的修改，

HIDS

亦能检测并报告出检测结果。

一般而言，

HIDS

使用一个它们所监视的目标系统以及文件系统（非必需）的数据库，

HIDS

也可以核对内存中未被非法修改的区域。对于每一个正被处理的



[目标文件](https://baike.so.com/doc/501245.html)

来说，

HIDS

会记录下他们的属性（如权限、大小、修改时间等）然后，如果该文件有其文件内容的话，

HIDS

将会创建一个



[校验码](https://baike.so.com/doc/6735310.html)

（如



[SHA1](https://baike.so.com/doc/6734130.html)

，

MD5

或类似）。这个校验码信息将储存在一个安全的数据库中，即校验码数据库，以便将来的核对。

3.
总结

一个学期的网络安全课程要结束了，在这期间得到了很多的上机实践，能学到了很多东西，之前就知道编程，操作这些新的软件需要花很多的时间去弄懂，并且能操作他们，每个实验都运用不同的软件，对于我这种入门比较慢的学生，花很多时间跟很多同学交流，才慢慢地弄懂软件，并且一步步的操作都记录了下来，以免自己忘记。在Sniffer Pro网络分析器应用实验中，学习了Sniffer工具的安装和使用方法，通过使用Sniffer工具理解TCP/IP协议栈中IP，TCP,UDP等协议的数据结构，并且掌握了ICMP协议的类型和代码。在扫描器X-SCANNER应用实验中，基本上了解了X-scan扫描器的使用方法，对计算机的潜在的安全性问题有了进一步的理解，提高了我对计算机的安全意识，还对扫描器扫描原理的理解和掌握。在使用PGP实现电子邮件安全实验中,了解了PGP软件的使用，进一步加深对非对称密码算法RSA的认识和掌握，熟悉软件的操作及主要功能，使用它加密邮件，普通文件。为了用户邮件内容保密，以防止非法授权者阅读。从而我们使用了PGP。本次实验我通过PGP的安装，创建密钥。了解了如何使用

PGP输出和签名公共密钥。在防火墙技术的具体应用实验中，了解了防火墙的工作原理和规则设置方法，了解天网防火墙的有点及缺点: 1、灵活的安全级别设置2、实用的应用程序规则设置3、详细的访问记录4、严密的应用程序网络状态监控功能5、多样的缺省IP规则 6、可以自定义IP规则7、具有修补系统漏洞功能。

**参考文献：**

[1] 刘建伟 王育民 网络安全---技术与实践(第三版) 清华大学出版社 2017版