---
layout: post
title: "Linux-线程控制"
date: 2025-03-16 23:31:59 +0800
description: "而这些都是线程库在做的事情，也就是线程的概念是库给我们维护的，我们用的原生线程库，也要加载到内存中，因为都是基于内存的。我们的线程库只需要维护线程的概念即可，不用维护线程的执行流，不过线程库注定了要维护多个线程属性集合，线程也要管理这些线程，先描述在组织。这是因为新线程内部执行进程替换函数，这看起来像是把新线程中的代码替换了，但实际会把主线程中的代码也替换了，因为主线程和新线程共享地址空间，所以新线程内部进程替换后，所有的线程包括主线程都会被影响。参数是void*，和这个函数的返回值的含义是一样的。"
keywords: "Linux 线程控制"
categories: ['Linux']
tags: ['算法', '开发语言', 'Linux', 'C']
artid: "146286374"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146286374
    alt: "Linux-线程控制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146286374
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146286374
cover: https://bing.ee123.net/img/rand?artid=146286374
image: https://bing.ee123.net/img/rand?artid=146286374
img: https://bing.ee123.net/img/rand?artid=146286374
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux 线程控制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B" name="1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">
     1、创建线程
    </h3>
    <p>
     <img alt="" height="244" src="https://i-blog.csdnimg.cn/direct/529976fb777040188971f6c916c3d01f.png" width="902"/>
    </p>
    <blockquote>
     <ul>
      <li>
       thread：输出型参数，返回线程 ID。
      </li>
      <li>
       attr：设置线程的属性，attr 为 NULL 表示使用默认属性。
      </li>
      <li>
       start_routine：想让线程执行的任务，它是一个返回值 void*，参数 void* 的一个函数指针。
      </li>
      <li>
       arg：回调函数的参数，若线程创建成功，在执行 start_routine 时，会把 arg 传入start_routine
      </li>
     </ul>
    </blockquote>
    <p>
     <img alt="" height="80" src="https://i-blog.csdnimg.cn/direct/708bf303f72a4ca6890559b725ffbd35.png" width="905">
      返回值：成功返回0，失败返回非0，数字是几，代表什么原因出错。
     </img>
    </p>
    <blockquote>
     <ul>
      <li>
       传统的一些函数是，成功返回 0，失败返回 -1，并且对全局变量 errno 赋值以指示错误。
      </li>
      <li>
       pthreads 函数出错时不会设置全局变量 errno（而大部分其他 POSIX 函数会这样做），而是将错误代码通过返回值返回。
      </li>
      <li>
       pthreads 同样也提供了线程内的 errno 变量，以支持其它使用 errno 的代码。对于pthreads 函数的错误，建议通过返回值业判定，因为读取返回值要比读取线程内的 errno 变量的开销更小
      </li>
     </ul>
    </blockquote>
    <p>
     代码如下：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

using namespace std;
void* threadrun(void* args)
{
    while(1)
    {
        cout &lt;&lt; "pthread is running,pid is:" &lt;&lt; getpid() &lt;&lt; endl;
        sleep(1);
    }
    return nullptr;
}
int main()
{
    pthread_t rid;
    pthread_create(&amp;rid,nullptr,threadrun,nullptr);

    while(1)
    {
        cout &lt;&lt; "main thread is running,pid is" &lt;&lt;getpid() &lt;&lt; endl;
        sleep(1);
    }
    return 0;
}</code></pre>
    <p>
     <img alt="" height="336" src="https://i-blog.csdnimg.cn/direct/b9efaa609cab44719fb417e844df8466.png" width="666"/>
    </p>
    <p>
     <img alt="" height="89" src="https://i-blog.csdnimg.cn/direct/400a2878ec3b4381a634a04ac34c0666.png" width="822"/>
    </p>
    <p>
     这里让新线程执行除 0 操作，我们发现它会影响整个进程。线程是进程的一个执行分支，除 0 错误操作会导致线程退出的同时，也意味着进程触发了该错误，进而导致进程退出。这也就是线程会使用代码健壮性降低的一个表现。
    </p>
    <p>
     <img alt="" height="463" src="https://i-blog.csdnimg.cn/direct/766b9af84c8d48b4aeb5011491f284e5.png" width="699">
      <img alt="" height="403" src="https://i-blog.csdnimg.cn/direct/c50fcea3f978472d8347e9ca09b0397d.png" width="752"/>
     </img>
    </p>
    <p>
     我们能看到这个线程崩了，整个进程会一起被干掉。
    </p>
    <p>
     我们看这段代码
    </p>
    <p>
     <img alt="" height="574" src="https://i-blog.csdnimg.cn/direct/4ca79a157b2e4ef098315e41c43f1b03.png" width="716"/>
    </p>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="199" src="https://i-blog.csdnimg.cn/direct/ef2d0e1160e44f1abb1a656295f9479c.png" width="633"/>
    </p>
    <p>
     两个执行流都进入了show函数，就如我们上一篇写的，我们把show函数称作为可重入函数。
    </p>
    <p>
     我们再来看一段代码
    </p>
    <p>
     <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/aebccb3edb194fb9b95c35abb37c19a4.png" width="920"/>
    </p>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" height="320" src="https://i-blog.csdnimg.cn/direct/e6af1afa187647ddb79c6f3743a48f95.png" width="700"/>
    </p>
    <p>
     我们可以看到，主线程和新线程都可以看到这个变量被修改了。说明两个线程共享这个变量。
    </p>
    <p>
     <strong>
      所以两个线程想要进行通信实在是太容易了
     </strong>
    </p>
    <blockquote>
     <p>
      这里我们注意，如果我们设置gal为int的时候，会出现这样的报错
      <img alt="" height="128" src="https://i-blog.csdnimg.cn/direct/119a7e5f1e334748aa2b4924525b5491.png" width="828"/>
     </p>
     <p>
      这是因为int是4个字节，我们传入第四个参数的时候，是void* 64机器下为8个字节，强转的类型大小不一样可能会报错，所以我们用long，long类型在32位下是4个字节，64位下是8个字节。
     </p>
    </blockquote>
    <h3 id="2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85" name="2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85">
     2、线程等待
    </h3>
    <p>
     那么这两个线程谁先进行退出呢？一般来说是新线程先退出的，然后主线程才能退出的，因为是主线程创建的它，它要对这个新线程进行管理。
    </p>
    <p>
     如果我们主线程是一个死循环，而新线程一直不退出，那么也会造成类似于进程中的僵尸进程的问题（当然线程里没有这个说法）。所以新线程被创建出来以后，一般也要被等待，如果不等待，可能会造成类似于僵尸进程的问题。当然这个问题我们是无法验证出来的，因为新线程一退，我们查也就查不到了。但是确确实实会存在这个问题。
    </p>
    <p>
     更重要的是，我们将新线程创建出来，就是让他就办事的，我们得知道它办的怎么样，结果数据是什么？
    </p>
    <p>
     所以我们线程等待的两个目的：
    </p>
    <blockquote>
     <ol>
      <li>
       防止内存泄漏
      </li>
      <li>
       如果需要，我们也可以获取一下子进程的退出结果
      </li>
     </ol>
    </blockquote>
    <p>
     <br/>
     下面是线程等待的函数
    </p>
    <pre><code class="language-cpp">#include &lt;pthread.h&gt;
int pthread_join(pthread_t thread, void **retval);
//Compile and link with -pthread.
</code></pre>
    <p>
     如果成功返回0，失败返回错误码。注意：线程里面所有的函数都不用errno错误码，而是直接返回一个错误码。这就保证了所有的线程都可以有一个返回的错误码，不需要去抢占全局的那个变量
    </p>
    <blockquote>
     <p>
      关于参数：
     </p>
     <p>
      第一个参数是线程的tid
     </p>
     <p>
      第二个参数是该线程结束时的返回值。注意*retval才是void*类型,也就是*retval才是函数的返回值。
     </p>
     <p>
      如下图所示，当void*通过pthread_join的方式传递的时候，会产生一个临时变量。比如说，我们调用函数的时候传递&amp;x,那么&amp;x其实会被拷贝一份，我们这里暂且记作retavl。然后在pthread_join内部执行，*retval = z这一步。最终就成功的为x赋值了。即x就相当于一个输入型参数。
     </p>
     <p>
      <img alt="" height="482" src="https://i-blog.csdnimg.cn/direct/43c9b0f09543469dac7715e346b6ba7c.png" width="1235"/>
     </p>
    </blockquote>
    <p>
     下面我们用代码演示一下
    </p>
    <p>
     我们让新创建的线程退出，让主线程等待。主线程等待5秒，主线程也退出
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string&gt;

using namespace std;


void show(const string&amp; name)
{ 
    cout &lt;&lt; name &lt;&lt; "is running" &lt;&lt; endl;
}
void* threadrun(void* args)
{
    long gal = (long)args;
    int cnt = 8;
    while(cnt--)
    {
        show("[new pthread]");
        // cout &lt;&lt; "pthread is running,pid is:" &lt;&lt; getpid() &lt;&lt; "gal:" &lt;&lt; gal++ &lt;&lt;"   "&lt;&lt; "&amp;gal:" &lt;&lt; &amp;gal &lt;&lt; endl;
        sleep(1);
    }

    // int a = 10;
    // a /= 0;
    return nullptr;
}
int main()
{
    long gal = 0;
    pthread_t rid;
    pthread_create(&amp;rid,nullptr,threadrun,(void*)gal);
    void* retval;
    pthread_join(rid,&amp;retval);
    sleep(5);
    cout&lt;&lt; "main pthread quit!" &lt;&lt; endl;

    // while(1)
    // {
    //     show("[main pthread]");
    //     // cout &lt;&lt; "main thread is running,pid is" &lt;&lt;getpid() &lt;&lt; "gal:" &lt;&lt; gal++ &lt;&lt;"   "&lt;&lt; "&amp;gal:" &lt;&lt; &amp;gal &lt;&lt; endl;
    //     sleep(1);
    // }
    return 0;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="799" src="https://i-blog.csdnimg.cn/direct/7cd9810df0e14bc582764014a8d118a1.png" width="1503"/>
    </p>
    <p>
     我们现在利用一下这个*retavl
    </p>
    <p>
     <img alt="" height="543" src="https://i-blog.csdnimg.cn/direct/789ba10e328e466b9b73e864da7664fc.png" width="785"/>
    </p>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="254" src="https://i-blog.csdnimg.cn/direct/7bf8b8ccd76b4897ba672feab6f3bf43.png" width="700"/>
    </p>
    <p>
     这里我们让新线程退出为什么不能用exit接口呢？
    </p>
    <p>
     我们先来看看运行结果是什么样的
    </p>
    <p>
     <img alt="" height="701" src="https://i-blog.csdnimg.cn/direct/73eaa1f6f9ab440d806dcf68c73facbe.png" width="1629"/>
     我们看到主线程都没等待就全部退出了。
    </p>
    <p>
     其实exit是用来终止进程，不能用来终止线程。
    </p>
    <p>
     接下来我们来看终止线程的接口
    </p>
    <h3 id="3%E3%80%81%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B" name="3%E3%80%81%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B" style="background-color:transparent">
     3、终止线程
    </h3>
    <pre><code class="language-cpp">#include &lt;pthread.h&gt;
void pthread_exit(void *retval);
//Compile and link with -pthread.
</code></pre>
    <p>
     它的作用是终止调用这个函数的线程，谁调用它就终止谁。参数是void*，和这个函数的返回值的含义是一样的。
     <img alt="" height="560" src="https://i-blog.csdnimg.cn/direct/b70b86759d65433088d1d97d0b32a67d.png" width="918"/>
    </p>
    <p>
     运行结果如下
    </p>
    <p>
     <img alt="" height="786" src="https://i-blog.csdnimg.cn/direct/7072dafa1b504eb8b558eb5e7a199027.png" width="1477"/>
    </p>
    <p>
     上面是新线程去调用pthread_exit接口，那么只有这个线程会退出，如果主线程去调用这个接口退出的话，那么整个进程都会终止
     <img alt="" height="588" src="https://i-blog.csdnimg.cn/direct/8b9a96f7c0604485be27079dbba563af.png" width="904"/>
    </p>
    <p>
     运行结果人如下：进程直接退出了，没有进行等待。
    </p>
    <p>
     <img alt="" height="775" src="https://i-blog.csdnimg.cn/direct/5c2590ba9ebb48ad92a94c0c82a82478.png" width="1578"/>
    </p>
    <h3 id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85" name="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85">
     4、线程等待
    </h3>
    <pre><code class="language-cpp">#include &lt;pthread.h&gt;
int pthread_cancel(pthread_t thread);
//Compile and link with -pthread.
</code></pre>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string&gt;

using namespace std;
 
void* runpthread(void*args)
{   
    string name = (char*)args;
    int cnt = 5;
    while(cnt--)
    {
        cout &lt;&lt; name &lt;&lt; "pid:" &lt;&lt; getpid() &lt;&lt; endl;
        sleep(1);
    }
}
int main()
{
    pthread_t rid;
    pthread_create(&amp;rid,nullptr,runpthread,(void*)"pthread-");
    sleep(1);
    pthread_cancel(rid);
    void* retval;
    pthread_join(rid, &amp;retval); //main thread等待的时候，默认是阻塞等待的
    cout &lt;&lt; "main thread quit..., ret: " &lt;&lt; (long)retval &lt;&lt; endl;


    return 0;
}</code></pre>
    <p>
     <img alt="" height="105" src="https://i-blog.csdnimg.cn/direct/347d93e949694751811730bf4a17964f.png" width="635"/>
    </p>
    <p>
     我们可以注意到，此时这个线程等待以后的返回值为-1
    </p>
    <p>
     其实是因为一个线程如果被取消的话，会有这样一个宏
    </p>
    <pre><code class="language-cpp">#define PTHREAD_CANCELED ((void *) -1)
</code></pre>
    <p>
     换句话说，如果线程是被取消的，那么它退出时的返回码就是-1，即上面的宏
    </p>
    <h3 id="5%E3%80%81%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1" name="5%E3%80%81%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1">
     5、传递对象
    </h3>
    <p>
     其实线程的参数和返回值，不仅仅可以用来传递一般参数，也可以传递对象
    </p>
    <p>
     我们可以用下面的代码来看
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string&gt;

using namespace std;

class Request
{
public:
    Request(int start,int end,string name):start_(start),endl_(end),pthread_name(name)
    {}
public:
    int start_;
    int endl_;
    string pthread_name;
};
class Response
{
public:
    Response(int result,int exitcode):result_(result),exitcode_(exitcode)
    {}
public:
    int result_;
    int exitcode_;
};
void* sumcount(void* args)
{
    Request* rq = (Request*)args;
    Response* rep = new Response(0,0);
    for(int i = rq-&gt;start_; i &lt;=rq-&gt;endl_; i++)
    {
        cout &lt;&lt; rq-&gt;pthread_name &lt;&lt; " is running calling  "&lt;&lt; i&lt;&lt; endl;
        rep-&gt;result_ += i;
    }   
    delete rq;
    return (void*)rep;
}
int main()
{
    pthread_t tid;
    Request* rq = new Request(1,100,"pthread-1");
    pthread_create(&amp;tid,nullptr,sumcount,rq);
    void* ret;
    pthread_join(tid,&amp;ret);
    Response* rep = (Response*)ret;
    cout &lt;&lt; "rep-&gt;result_:" &lt;&lt; rep-&gt;result_ &lt;&lt; ",exitcode:" &lt;&lt; rep-&gt;exitcode_ &lt;&lt;endl;
    delete rep;
    return 0;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="827" src="https://i-blog.csdnimg.cn/direct/1c26edb8b83043e08e0dcae5a294ace0.png" width="833"/>
    </p>
    <p>
     所以它就可以用来求出和。让每一个线程只执行其中的一部分计算，然后我们自己在将这些结果合并起来。
    </p>
    <p>
     并且我们发现，我们的这些对象都是在堆区创建的。并且我们是交叉使用的，说明堆空间的也是被线程共享使用的
    </p>
    <h3 id="6%E3%80%81C%2B%2B11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B" name="6%E3%80%81C%2B%2B11%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B">
     6、C++11中的线程
    </h3>
    <p>
     目前，我们使用的是原生线程库（pthread库）
    </p>
    <p>
     其实C++11 语言本身也已经支持多线程了，它与我们的原生线程库有什么关系呢？
    </p>
    <p>
     C++11的线程需要用下面的库
    </p>
    <pre><code class="language-cpp">#include&lt;thread&gt;
</code></pre>
    <p>
     代码如下：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
using namespace std;
void threadrun()
{
    while(true)
    {
        cout &lt;&lt; "I am a new thread for C++" &lt;&lt; endl;
        sleep(1);
    }
}

int main()
{
    thread t1(threadrun);
    int cnt = 5;
    while(cnt--)
    {
        cout &lt;&lt; "main pthread is running " &lt;&lt;endl;
        sleep(1);
    }
    t1.join();
    return 0;
}</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/bddcdf075ef14cf7ae6d3718e6288090.png" width="716"/>
    </p>
    <p>
     我们需要注意的是，C++11中的线程库其实底层还是封装了linux提供的系统调用接口，所以我们编译的时候还是需要使用-lpthread选项的。
    </p>
    <p>
     而C++11其实是有跨平台性的。因为它在不同平台下已经写好了不同版本的库。所以对我们而言，不同的平台写代码是没有感觉的。
    </p>
    <p>
     <strong>
      我们最好使用C++的多线程。因为具有跨平台性
     </strong>
    </p>
    <h3 id="7%E3%80%81%E7%BA%BF%E7%A8%8BID%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80" name="7%E3%80%81%E7%BA%BF%E7%A8%8BID%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80" style="background-color:transparent">
     7、线程ID与线程地址空间布局
    </h3>
    <p>
     我们先来看一段代码
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
using namespace std;

void* runpthread(void* args)
{
    string name = (char*)args;
    printf("%s, tid:%p\n", name.c_str(), pthread_self());
    return nullptr;
}
int main()
{
    pthread_t tid;
    pthread_create(&amp;tid,nullptr,runpthread,(void*)"pthread-1");
    printf("main create a new pthread id is:%p\n", pthread_self());
    pthread_join(tid,nullptr);
    return 0;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="67" src="https://i-blog.csdnimg.cn/direct/730d1c1261254a53ae1e50c811f0f92f.png" width="578"/>
    </p>
    <p>
     我们能看到这个tid地址很大，那它具体存放在哪呢？
    </p>
    <hr/>
    <p>
     我们知道的是，内核中并没有明确的线程的概念，只有轻量级进程的概念
    </p>
    <p>
     而轻量级进程接口是这样的
    </p>
    <p>
     <img alt="" height="324" src="https://i-blog.csdnimg.cn/direct/a3e0ce8a951b49b59f564ccb2936e58c.png" width="961"/>
    </p>
    <p>
     这个接口我们一般是不用的，包括fork的底层其实用的也是这个接口
    </p>
    <p>
     这个的第一个参数是一个函数指针，第二个参数是自定义的一个栈…
    </p>
    <p>
     这个接口是被pthread线程库封装了。
    </p>
    <p>
     所以我们采用的是pthread_create,pthread_join这些接口。
    </p>
    <blockquote>
     <p>
      如下图所示，这个clone这个接口它需要提供一个回调函数，独立栈结构等，用它去维护线程。而这些都是线程库在做的事情，也就是线程的概念是库给我们维护的，我们用的原生线程库，也要加载到内存中，因为都是基于内存的。线程库是一个动态库，经过页表映射后，也要到共享区的。这些栈都是在共享区创建的。我们的线程库只需要维护线程的概念即可，不用维护线程的执行流，不过线程库注定了要维护多个线程属性集合，线程也要管理这些线程，先描述在组织。而这个线程控制块它就要可以找到这些回调函数，独立栈，以及在内部的LWP。这个线程控制块就是用户级线程
     </p>
    </blockquote>
    <p>
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/direct/8c1e15459d2d4b26b89a48cedf96738f.png" width="1477"/>
    </p>
    <p>
     所以我们就将这个下面的这个叫做线程的tcb。而每一个tcb的起始地址，叫做线程的tid
    </p>
    <p>
     <img alt="" height="662" src="https://i-blog.csdnimg.cn/direct/85b628db2f7d454099036f960c55fb4f.png" width="1382"/>
    </p>
    <p>
     所以拿着这个tid,就可以找到库里面的属性了。
    </p>
    <p>
     而我们前面打印出来的这个地址，我们也可以看到，它是比较大的，其实它就是介于堆栈之间的共享区
    </p>
    <p>
     <strong>
      每一个线程都必须要有自己的独立栈结构，因为它有独立的调用链，要进行压栈等操作。其中主线程用的就是地址空间中的这个栈。剩下的轻量级进程在我们创建的时候会先创建一个tcb，它里面的起始地址作为线程tid,它的里面有一个默认大小的空间，叫做线程栈，然后内核中调用clone创建好执行流。在clone中形成的临时数据都会压入到这个线程库中的栈结构中。
     </strong>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       所以除了主线程，所有其他线程的独立栈，都在共享区，具体来讲是在pthread库中，tid指向的用户tcb中，这个tid是这个线程所在动态库的起始地址，tid是虚拟地址。
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      总结：
     </span>
    </p>
    <blockquote>
     <ul>
      <li>
       Linux OS 没有真正意义上的线程，而是用进程 PCB 模拟的，这就叫作轻量级进程。其本身没有提供类似线程创建、终止、等待、分离等相关 System Call 接口，但是会提供轻量级进程的接口，如 clone。所以为了更好的适配，系统基于轻量级进程的接口，模拟封装了一个用户层的原生线程库 pthread。这样，系统通过 PCB 来进行管理，用户层也得知道线程 ID、状态、优先级等其它属性用来进行用户级线程管理。
      </li>
      <li>
       pthread_create 函数会产生一个线程 ID，存放在第一个参数指向的地址中，该线程 ID 和前面说的线程 ID LWP 不是一回事。LWP 属于进程调度的范畴，因为线程是轻量级进程，是 OS 调度器的最小单位，所以需要一个数值来唯一表示该线程。pthread_create 函数的第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程 ID，属于 NPTL 线程库的范畴，线程库的后续操作，就是根据该线程 ID 来操作线程。
      </li>
      <li>
       原生线程库是一个库，它在磁盘上就是一个 libpthread.so 文件，运行时加载到内存，然后将这个库映射到共享区，此时这个库就可以被所有线程执行流看到了。此时有两个 ID 概念，一个是在命令行上看到的 LWP，一个是在用户层上看到的 tid。前者是在系统层面上供 OS 调度的，后者是 pthread_create 获得的线程 ID，它是一个用户层概念，本质是一个地址，就是 pthread 库中某一个起始位置，也就是对应到共享区中的某一个位置。所以线程数据的维护全都是在 pthread 线程库中去维护的，上图所示，其中会包含每个线程的局部数据，struct pthread 就是描述线程的 TCB，线程局部存储可以理解是不会在线程栈上保存的数据，我们在上面说过线程会产生各种各样的中间数据，如上下文数据，此时就需要独立的栈去保存，它就是线程栈。而下图中拿到的 tid 就是线程在共享区中线程库内的相关属性的起始地址，所以只要拿到了用户层的 tid，就可以在库中找到线程相关的属性数据，很明显 tid 和 LWP 是 1 : 1 的，而主线程不使用库中的栈结构，直接使用地址空间中的栈区，称为主线程线。
      </li>
     </ul>
    </blockquote>
    <h3 id="8%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E8%AE%BA" name="8%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E8%AE%BA">
     8、验证结论
    </h3>
    <h4 id="(1)%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9C%89%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%9C" name="(1)%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9C%89%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%9C">
     (1)各个线程有独立的栈结果
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using namespace std;

void* threadrun(void* args)
{
    long gal = (long)args;
    while(true)
    {
        cout &lt;&lt; "pthread is running,tid is:" &lt;&lt; pthread_self() &lt;&lt; "gal:" &lt;&lt; gal++ &lt;&lt;"   "&lt;&lt; "&amp;gal:" &lt;&lt; &amp;gal &lt;&lt; endl;
        sleep(1);
    }
}
int main()
{
    vector&lt;pthread_t&gt; tids;
    long flag = 0;
    for(int i = 0; i &lt; 5; i++)
    {
        pthread_t tid;
        pthread_create(&amp;tid,nullptr,threadrun,(void*)flag);
        tids.push_back(tid);
    }
    for(auto&amp; e:tids)
    {
        pthread_join(e,nullptr);
    }
    return 0;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="592" src="https://i-blog.csdnimg.cn/direct/5322d92b9e2041cf983454bf10e9177a.png" width="865"/>
    </p>
    <p>
     我们能看到传入到每个线程的falg地址不一样，但它们地址又很相近。
    </p>
    <p>
     <strong>
      说明了每一个线程都有自己的栈，该栈存放该执行流创建的变量等，并且他们都在共享区的动态库中。
     </strong>
    </p>
    <h4 id="(2%EF%BC%89%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%83%BD%E6%8B%BF%E5%88%B0%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%98%E9%87%8F" name="(2%EF%BC%89%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%83%BD%E6%8B%BF%E5%88%B0%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%98%E9%87%8F" style="background-color:transparent">
     <strong>
      (2）主线程能拿到其中一个线程的变量
     </strong>
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using namespace std;

int *p = NULL;
struct pthreadname
{
    string threadname;
};
void InitThreadData(pthreadname *td, int number)
{
    td-&gt;threadname = "pthread-" + to_string(number); // thread-0
}
void* threadrun(void* args)
{
    int test_i = 0;
    pthreadname* name = (pthreadname*)args;
    if(name-&gt;threadname == "pthread-2") 
    {
        p = &amp;test_i;
    }
    int cnt = 3;
    while(cnt--)
    {
        cout &lt;&lt; name &lt;&lt; "tid is:" &lt;&lt; pthread_self() &lt;&lt; "  test_i:" &lt;&lt; test_i &lt;&lt; "   &amp;test_i" &lt;&lt; &amp;test_i &lt;&lt;endl;
        // cout &lt;&lt; "pthread is running,tid is:" &lt;&lt; pthread_self() &lt;&lt; "gal:" &lt;&lt; gal++ &lt;&lt;"   "&lt;&lt; "&amp;gal:" &lt;&lt; &amp;gal &lt;&lt; endl;
        sleep(1);
    }
}
int main()
{
    vector&lt;pthread_t&gt; tids;
    for(int i = 0; i &lt; 5; i++)
    {
        pthreadname* name = new pthreadname;
        pthread_t tid;
        InitThreadData(name,i);
        pthread_create(&amp;tid,nullptr,threadrun,name);
        tids.push_back(tid);
    }
    sleep(5);
    cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; endl;
    for(auto&amp; e:tids)
    {
        pthread_join(e,nullptr);
    }
    return 0;
}</code></pre>
    <p>
     运行结果如下：
     <img alt="" height="402" src="https://i-blog.csdnimg.cn/direct/6162c8f215f74123a0ac8a95b3df67e8.png" width="846"/>
    </p>
    <h3 id="9%E3%80%81__thread%E5%85%B3%E9%94%AE%E5%AD%97" name="9%E3%80%81__thread%E5%85%B3%E9%94%AE%E5%AD%97">
     9、__thread关键字
    </h3>
    <p>
     上面我们验证了主线程能拿到其中一个线程的变量，说明进程与进程之间没有秘密。
    </p>
    <p>
     我们可以用__thread关键字让一个线程有自己的私有全局变量。
    </p>
    <pre><code class="language-cpp">__thread int g_iThreadCount = 0;</code></pre>
    <p>
     这实际是线程的局部存储。
    </p>
    <p>
     让我们写段代码验证一下
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
using namespace std;
 
//一个用__thread关键字修饰的全局变量
__thread int g_iThreadCount = 0;
 
void *pthreadFunc1(void *pArg)
{
	g_iThreadCount += 1;
	cout &lt;&lt; "pthreadFunc1::g_iThreadCount = " &lt;&lt; g_iThreadCount &lt;&lt; endl;
	pthread_exit((void *)1);
}
 
void *pthreadFunc2(void *pArg)
{
	g_iThreadCount += 2;
	cout &lt;&lt; "pthreadFunc2::g_iThreadCount = " &lt;&lt; g_iThreadCount &lt;&lt; endl;
	pthread_exit((void *)2);
}
 
int main(void)
{
	int iRet;
	pthread_t pthreadId1;
	pthread_t pthreadId2;
	
	pthread_create(&amp;pthreadId1, NULL, pthreadFunc1, NULL);
	pthread_create(&amp;pthreadId2, NULL, pthreadFunc2, NULL);
	
	pthread_join(pthreadId1, NULL);
	pthread_join(pthreadId2, NULL);
	
	return 0;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="106" src="https://i-blog.csdnimg.cn/direct/71e6f2ea3af74e7992f3444b16a0dd50.png" width="626"/>
    </p>
    <p>
     注意：__thread只能够定义内置类型，不能定义自定义类型。
    </p>
    <h3 id="10%E3%80%81%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B" name="10%E3%80%81%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B">
     10、分离线程
    </h3>
    <p>
     <img alt="" height="215" src="https://i-blog.csdnimg.cn/direct/e847ab406ebb45b385e015f1c9296543.png" width="905"/>
    </p>
    <blockquote>
     <ul>
      <li>
       默认情况下，新创建的线程是 joinable 的，线程退出后，需要对其进行 pthread_join 操作，否则无法释放资源，从而造成内存泄漏。
      </li>
      <li>
       如果不关心线程的返回值，join 则是一种负担，这个时候，可以使用分离，此时就告诉系统，当线程退出时，自动释放线程资源，这就是线程分离的本质。
      </li>
      <li>
       joinable 和 pthread_detach 是冲突的，也就是说默认情况下，新创建的线程是不用 pthread_detach。
      </li>
      <li>
       就算线程被分离了，也还是会和其它线程影响的，因为它们共享同一块地址空间。
      </li>
     </ul>
    </blockquote>
    <p>
     可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离：
     <img alt="" height="45" src="https://i-blog.csdnimg.cn/direct/5250045882b6463594bced6f97e1f5ea.png" width="323"/>
    </p>
    <p>
     joinable 和分离是冲突的，一个线程不能既是 joinable 又是分离的。
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       注意：没有线程替换这种操作，但可以在线程中执行进程替换系列函数。这是因为新线程内部执行进程替换函数，这看起来像是把新线程中的代码替换了，但实际会把主线程中的代码也替换了，因为主线程和新线程共享地址空间，所以新线程内部进程替换后，所有的线程包括主线程都会被影响。所以轻易不要在多线程中执行进程替换函数。
      </span>
     </p>
    </blockquote>
    <p>
     <span style="color:#0d0016">
      我们来看一段代码
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cerrno&gt;
#include &lt;cstring&gt;
using namespace std;

int flag = 0;
void* runthread(void*args)
{
    pthread_detach(pthread_self());
    while(true)
    {
        cout &lt;&lt; (char*)args &lt;&lt; ":  " &lt;&lt; flag++ &lt;&lt; "&amp;" &lt;&lt;&amp;flag&lt;&lt;endl;
        sleep(1);
        break;
    }
    pthread_exit((void*)11);
}
int main()
{
    pthread_t tid;
    pthread_create(&amp;tid,nullptr,runthread,(void*)"pthread-1");
    while(true)
    {
        cout&lt;&lt;"main thread:"&lt;&lt;flag&lt;&lt;"  &amp;" &lt;&lt;&amp;flag&lt;&lt;endl;
        sleep(1);
        break;
    }
    int n =pthread_join(tid,nullptr);
    cout &lt;&lt; "n:" &lt;&lt; n &lt;&lt; "errstring: " &lt;&lt; strerror(n) &lt;&lt;endl;
    return 0;
}</code></pre>
    <p>
     结果如下：
    </p>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/7aeabb04c5744ed5ba8b6cd32cb4b16b.png" width="583"/>
    </p>
    <blockquote>
     <p>
      pthread_join 返回的是 22，说明等待失败了，然后返回，进程终止。其实一个线程被设置为分离状态，则该线程不应该被等待，如果被等待了，结果是未定义的，至少一定会等待出错。
     </p>
    </blockquote>
    <p>
     <img alt="" height="506" src="https://i-blog.csdnimg.cn/direct/265f5a755ad943abadb562dfc4e9194e.png" width="886"/>
    </p>
    <p>
     <img alt="" height="81" src="https://i-blog.csdnimg.cn/direct/c78575f502024174929ab94ce200242d.png" width="516"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f70757070795f316d6f2f:61727469636c652f64657461696c732f313436323836333734" class_="artid" style="display:none">
 </p>
</div>


