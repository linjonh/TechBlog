---
layout: post
title: "Ubuntu-下-nginx-1.24.0-源码分析-ngx_init_cycle-函数"
date: 2025-03-07 14:54:17 +0800
description: "【代码】Ubuntu 下 nginx-1.24.0 源码分析 - ngx_init_cycle 函数。"
keywords: "Ubuntu 下 nginx-1.24.0 源码分析 - ngx_init_cycle 函数"
categories: ['未分类']
tags: ['运维', 'Nginx']
artid: "146095766"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146095766
    alt: "Ubuntu-下-nginx-1.24.0-源码分析-ngx_init_cycle-函数"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146095766
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146095766
cover: https://bing.ee123.net/img/rand?artid=146095766
image: https://bing.ee123.net/img/rand?artid=146095766
img: https://bing.ee123.net/img/rand?artid=146095766
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Ubuntu 下 nginx-1.24.0 源码分析 - ngx_init_cycle 函数
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     <strong>
      nei声明
     </strong>
     在
     <span style="color:#be191c">
      src/core/ngx_cycle.h
     </span>
    </h4>
    <pre><code>ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);
</code></pre>
    <h4>
     <strong>
      实现
     </strong>
     在
     <span style="color:#be191c">
      src/core/ngx_cycle.c
     </span>
    </h4>
    <pre><code>ngx_cycle_t *
ngx_init_cycle(ngx_cycle_t *old_cycle)
{
    void                *rv;
    char               **senv;
    ngx_uint_t           i, n;
    ngx_log_t           *log;
    ngx_time_t          *tp;
    ngx_conf_t           conf;
    ngx_pool_t          *pool;
    ngx_cycle_t         *cycle, **old;
    ngx_shm_zone_t      *shm_zone, *oshm_zone;
    ngx_list_part_t     *part, *opart;
    ngx_open_file_t     *file;
    ngx_listening_t     *ls, *nls;
    ngx_core_conf_t     *ccf, *old_ccf;
    ngx_core_module_t   *module;
    char                 hostname[NGX_MAXHOSTNAMELEN];

    ngx_timezone_update();

    /* force localtime update with a new timezone */

    tp = ngx_timeofday();
    tp-&gt;sec = 0;

    ngx_time_update();


    log = old_cycle-&gt;log;

    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
    if (pool == NULL) {
        return NULL;
    }
    pool-&gt;log = log;

    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));
    if (cycle == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }

    cycle-&gt;pool = pool;
    cycle-&gt;log = log;
    cycle-&gt;old_cycle = old_cycle;

    cycle-&gt;conf_prefix.len = old_cycle-&gt;conf_prefix.len;
    cycle-&gt;conf_prefix.data = ngx_pstrdup(pool, &amp;old_cycle-&gt;conf_prefix);
    if (cycle-&gt;conf_prefix.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }

    cycle-&gt;prefix.len = old_cycle-&gt;prefix.len;
    cycle-&gt;prefix.data = ngx_pstrdup(pool, &amp;old_cycle-&gt;prefix);
    if (cycle-&gt;prefix.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }

    cycle-&gt;error_log.len = old_cycle-&gt;error_log.len;
    cycle-&gt;error_log.data = ngx_pnalloc(pool, old_cycle-&gt;error_log.len + 1);
    if (cycle-&gt;error_log.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }
    ngx_cpystrn(cycle-&gt;error_log.data, old_cycle-&gt;error_log.data,
                old_cycle-&gt;error_log.len + 1);

    cycle-&gt;conf_file.len = old_cycle-&gt;conf_file.len;
    cycle-&gt;conf_file.data = ngx_pnalloc(pool, old_cycle-&gt;conf_file.len + 1);
    if (cycle-&gt;conf_file.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }
    ngx_cpystrn(cycle-&gt;conf_file.data, old_cycle-&gt;conf_file.data,
                old_cycle-&gt;conf_file.len + 1);

    cycle-&gt;conf_param.len = old_cycle-&gt;conf_param.len;
    cycle-&gt;conf_param.data = ngx_pstrdup(pool, &amp;old_cycle-&gt;conf_param);
    if (cycle-&gt;conf_param.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }


    n = old_cycle-&gt;paths.nelts ? old_cycle-&gt;paths.nelts : 10;

    if (ngx_array_init(&amp;cycle-&gt;paths, pool, n, sizeof(ngx_path_t *))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }

    ngx_memzero(cycle-&gt;paths.elts, n * sizeof(ngx_path_t *));


    if (ngx_array_init(&amp;cycle-&gt;config_dump, pool, 1, sizeof(ngx_conf_dump_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }

    ngx_rbtree_init(&amp;cycle-&gt;config_dump_rbtree, &amp;cycle-&gt;config_dump_sentinel,
                    ngx_str_rbtree_insert_value);

    if (old_cycle-&gt;open_files.part.nelts) {
        n = old_cycle-&gt;open_files.part.nelts;
        for (part = old_cycle-&gt;open_files.part.next; part; part = part-&gt;next) {
            n += part-&gt;nelts;
        }

    } else {
        n = 20;
    }

    if (ngx_list_init(&amp;cycle-&gt;open_files, pool, n, sizeof(ngx_open_file_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }


    if (old_cycle-&gt;shared_memory.part.nelts) {
        n = old_cycle-&gt;shared_memory.part.nelts;
        for (part = old_cycle-&gt;shared_memory.part.next; part; part = part-&gt;next)
        {
            n += part-&gt;nelts;
        }

    } else {
        n = 1;
    }

    if (ngx_list_init(&amp;cycle-&gt;shared_memory, pool, n, sizeof(ngx_shm_zone_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }

    n = old_cycle-&gt;listening.nelts ? old_cycle-&gt;listening.nelts : 10;

    if (ngx_array_init(&amp;cycle-&gt;listening, pool, n, sizeof(ngx_listening_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }

    ngx_memzero(cycle-&gt;listening.elts, n * sizeof(ngx_listening_t));


    ngx_queue_init(&amp;cycle-&gt;reusable_connections_queue);


    cycle-&gt;conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));
    if (cycle-&gt;conf_ctx == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }


    if (gethostname(hostname, NGX_MAXHOSTNAMELEN) == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, "gethostname() failed");
        ngx_destroy_pool(pool);
        return NULL;
    }

    /* on Linux gethostname() silently truncates name that does not fit */

    hostname[NGX_MAXHOSTNAMELEN - 1] = '\0';
    cycle-&gt;hostname.len = ngx_strlen(hostname);

    cycle-&gt;hostname.data = ngx_pnalloc(pool, cycle-&gt;hostname.len);
    if (cycle-&gt;hostname.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }

    ngx_strlow(cycle-&gt;hostname.data, (u_char *) hostname, cycle-&gt;hostname.len);


    if (ngx_cycle_modules(cycle) != NGX_OK) {
        ngx_destroy_pool(pool);
        return NULL;
    }


    for (i = 0; cycle-&gt;modules[i]; i++) {
        if (cycle-&gt;modules[i]-&gt;type != NGX_CORE_MODULE) {
            continue;
        }

        module = cycle-&gt;modules[i]-&gt;ctx;

        if (module-&gt;create_conf) {
            rv = module-&gt;create_conf(cycle);
            if (rv == NULL) {
                ngx_destroy_pool(pool);
                return NULL;
            }
            cycle-&gt;conf_ctx[cycle-&gt;modules[i]-&gt;index] = rv;
        }
    }


    senv = environ;


    ngx_memzero(&amp;conf, sizeof(ngx_conf_t));
    /* STUB: init array ? */
    conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t));
    if (conf.args == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }

    conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
    if (conf.temp_pool == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }


    conf.ctx = cycle-&gt;conf_ctx;
    conf.cycle = cycle;
    conf.pool = pool;
    conf.log = log;
    conf.module_type = NGX_CORE_MODULE;
    conf.cmd_type = NGX_MAIN_CONF;

#if 0
    log-&gt;log_level = NGX_LOG_DEBUG_ALL;
#endif

    if (ngx_conf_param(&amp;conf) != NGX_CONF_OK) {
        environ = senv;
        ngx_destroy_cycle_pools(&amp;conf);
        return NULL;
    }

    if (ngx_conf_parse(&amp;conf, &amp;cycle-&gt;conf_file) != NGX_CONF_OK) {
        environ = senv;
        ngx_destroy_cycle_pools(&amp;conf);
        return NULL;
    }

    if (ngx_test_config &amp;&amp; !ngx_quiet_mode) {
        ngx_log_stderr(0, "the configuration file %s syntax is ok",
                       cycle-&gt;conf_file.data);
    }

    for (i = 0; cycle-&gt;modules[i]; i++) {
        if (cycle-&gt;modules[i]-&gt;type != NGX_CORE_MODULE) {
            continue;
        }

        module = cycle-&gt;modules[i]-&gt;ctx;

        if (module-&gt;init_conf) {
            if (module-&gt;init_conf(cycle,
                                  cycle-&gt;conf_ctx[cycle-&gt;modules[i]-&gt;index])
                == NGX_CONF_ERROR)
            {
                environ = senv;
                ngx_destroy_cycle_pools(&amp;conf);
                return NULL;
            }
        }
    }

    if (ngx_process == NGX_PROCESS_SIGNALLER) {
        return cycle;
    }

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);

    if (ngx_test_config) {

        if (ngx_create_pidfile(&amp;ccf-&gt;pid, log) != NGX_OK) {
            goto failed;
        }

    } else if (!ngx_is_init_cycle(old_cycle)) {

        /*
         * we do not create the pid file in the first ngx_init_cycle() call
         * because we need to write the demonized process pid
         */

        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle-&gt;conf_ctx,
                                                   ngx_core_module);
        if (ccf-&gt;pid.len != old_ccf-&gt;pid.len
            || ngx_strcmp(ccf-&gt;pid.data, old_ccf-&gt;pid.data) != 0)
        {
            /* new pid file name */

            if (ngx_create_pidfile(&amp;ccf-&gt;pid, log) != NGX_OK) {
                goto failed;
            }

            ngx_delete_pidfile(old_cycle);
        }
    }


    if (ngx_test_lockfile(cycle-&gt;lock_file.data, log) != NGX_OK) {
        goto failed;
    }


    if (ngx_create_paths(cycle, ccf-&gt;user) != NGX_OK) {
        goto failed;
    }


    if (ngx_log_open_default(cycle) != NGX_OK) {
        goto failed;
    }

    /* open the new files */

    part = &amp;cycle-&gt;open_files.part;
    file = part-&gt;elts;

    for (i = 0; /* void */ ; i++) {

        if (i &gt;= part-&gt;nelts) {
            if (part-&gt;next == NULL) {
                break;
            }
            part = part-&gt;next;
            file = part-&gt;elts;
            i = 0;
        }

        if (file[i].name.len == 0) {
            continue;
        }

        file[i].fd = ngx_open_file(file[i].name.data,
                                   NGX_FILE_APPEND,
                                   NGX_FILE_CREATE_OR_OPEN,
                                   NGX_FILE_DEFAULT_ACCESS);

        ngx_log_debug3(NGX_LOG_DEBUG_CORE, log, 0,
                       "log: %p %d \"%s\"",
                       &amp;file[i], file[i].fd, file[i].name.data);

        if (file[i].fd == NGX_INVALID_FILE) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ngx_open_file_n " \"%s\" failed",
                          file[i].name.data);
            goto failed;
        }

#if !(NGX_WIN32)
        if (fcntl(file[i].fd, F_SETFD, FD_CLOEXEC) == -1) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          "fcntl(FD_CLOEXEC) \"%s\" failed",
                          file[i].name.data);
            goto failed;
        }
#endif
    }

    cycle-&gt;log = &amp;cycle-&gt;new_log;
    pool-&gt;log = &amp;cycle-&gt;new_log;


    /* create shared memory */

    part = &amp;cycle-&gt;shared_memory.part;
    shm_zone = part-&gt;elts;

    for (i = 0; /* void */ ; i++) {

        if (i &gt;= part-&gt;nelts) {
            if (part-&gt;next == NULL) {
                break;
            }
            part = part-&gt;next;
            shm_zone = part-&gt;elts;
            i = 0;
        }

        if (shm_zone[i].shm.size == 0) {
            ngx_log_error(NGX_LOG_EMERG, log, 0,
                          "zero size shared memory zone \"%V\"",
                          &amp;shm_zone[i].shm.name);
            goto failed;
        }

        shm_zone[i].shm.log = cycle-&gt;log;

        opart = &amp;old_cycle-&gt;shared_memory.part;
        oshm_zone = opart-&gt;elts;

        for (n = 0; /* void */ ; n++) {

            if (n &gt;= opart-&gt;nelts) {
                if (opart-&gt;next == NULL) {
                    break;
                }
                opart = opart-&gt;next;
                oshm_zone = opart-&gt;elts;
                n = 0;
            }

            if (shm_zone[i].shm.name.len != oshm_zone[n].shm.name.len) {
                continue;
            }

            if (ngx_strncmp(shm_zone[i].shm.name.data,
                            oshm_zone[n].shm.name.data,
                            shm_zone[i].shm.name.len)
                != 0)
            {
                continue;
            }

            if (shm_zone[i].tag == oshm_zone[n].tag
                &amp;&amp; shm_zone[i].shm.size == oshm_zone[n].shm.size
                &amp;&amp; !shm_zone[i].noreuse)
            {
                shm_zone[i].shm.addr = oshm_zone[n].shm.addr;
#if (NGX_WIN32)
                shm_zone[i].shm.handle = oshm_zone[n].shm.handle;
#endif

                if (shm_zone[i].init(&amp;shm_zone[i], oshm_zone[n].data)
                    != NGX_OK)
                {
                    goto failed;
                }

                goto shm_zone_found;
            }

            break;
        }

        if (ngx_shm_alloc(&amp;shm_zone[i].shm) != NGX_OK) {
            goto failed;
        }

        if (ngx_init_zone_pool(cycle, &amp;shm_zone[i]) != NGX_OK) {
            goto failed;
        }

        if (shm_zone[i].init(&amp;shm_zone[i], NULL) != NGX_OK) {
            goto failed;
        }

    shm_zone_found:

        continue;
    }


    /* handle the listening sockets */

    if (old_cycle-&gt;listening.nelts) {
        ls = old_cycle-&gt;listening.elts;
        for (i = 0; i &lt; old_cycle-&gt;listening.nelts; i++) {
            ls[i].remain = 0;
        }

        nls = cycle-&gt;listening.elts;
        for (n = 0; n &lt; cycle-&gt;listening.nelts; n++) {

            for (i = 0; i &lt; old_cycle-&gt;listening.nelts; i++) {
                if (ls[i].ignore) {
                    continue;
                }

                if (ls[i].remain) {
                    continue;
                }

                if (ls[i].type != nls[n].type) {
                    continue;
                }

                if (ngx_cmp_sockaddr(nls[n].sockaddr, nls[n].socklen,
                                     ls[i].sockaddr, ls[i].socklen, 1)
                    == NGX_OK)
                {
                    nls[n].fd = ls[i].fd;
                    nls[n].inherited = ls[i].inherited;
                    nls[n].previous = &amp;ls[i];
                    ls[i].remain = 1;

                    if (ls[i].backlog != nls[n].backlog) {
                        nls[n].listen = 1;
                    }

#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined SO_ACCEPTFILTER)

                    /*
                     * FreeBSD, except the most recent versions,
                     * could not remove accept filter
                     */
                    nls[n].deferred_accept = ls[i].deferred_accept;

                    if (ls[i].accept_filter &amp;&amp; nls[n].accept_filter) {
                        if (ngx_strcmp(ls[i].accept_filter,
                                       nls[n].accept_filter)
                            != 0)
                        {
                            nls[n].delete_deferred = 1;
                            nls[n].add_deferred = 1;
                        }

                    } else if (ls[i].accept_filter) {
                        nls[n].delete_deferred = 1;

                    } else if (nls[n].accept_filter) {
                        nls[n].add_deferred = 1;
                    }
#endif

#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined TCP_DEFER_ACCEPT)

                    if (ls[i].deferred_accept &amp;&amp; !nls[n].deferred_accept) {
                        nls[n].delete_deferred = 1;

                    } else if (ls[i].deferred_accept != nls[n].deferred_accept)
                    {
                        nls[n].add_deferred = 1;
                    }
#endif

#if (NGX_HAVE_REUSEPORT)
                    if (nls[n].reuseport &amp;&amp; !ls[i].reuseport) {
                        nls[n].add_reuseport = 1;
                    }
#endif

                    break;
                }
            }

            if (nls[n].fd == (ngx_socket_t) -1) {
                nls[n].open = 1;
#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined SO_ACCEPTFILTER)
                if (nls[n].accept_filter) {
                    nls[n].add_deferred = 1;
                }
#endif
#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined TCP_DEFER_ACCEPT)
                if (nls[n].deferred_accept) {
                    nls[n].add_deferred = 1;
                }
#endif
            }
        }

    } else {
        ls = cycle-&gt;listening.elts;
        for (i = 0; i &lt; cycle-&gt;listening.nelts; i++) {
            ls[i].open = 1;
#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined SO_ACCEPTFILTER)
            if (ls[i].accept_filter) {
                ls[i].add_deferred = 1;
            }
#endif
#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined TCP_DEFER_ACCEPT)
            if (ls[i].deferred_accept) {
                ls[i].add_deferred = 1;
            }
#endif
        }
    }

    if (ngx_open_listening_sockets(cycle) != NGX_OK) {
        goto failed;
    }

    if (!ngx_test_config) {
        ngx_configure_listening_sockets(cycle);
    }


    /* commit the new cycle configuration */

    if (!ngx_use_stderr) {
        (void) ngx_log_redirect_stderr(cycle);
    }

    pool-&gt;log = cycle-&gt;log;

    if (ngx_init_modules(cycle) != NGX_OK) {
        /* fatal */
        exit(1);
    }


    /* close and delete stuff that lefts from an old cycle */

    /* free the unnecessary shared memory */

    opart = &amp;old_cycle-&gt;shared_memory.part;
    oshm_zone = opart-&gt;elts;

    for (i = 0; /* void */ ; i++) {

        if (i &gt;= opart-&gt;nelts) {
            if (opart-&gt;next == NULL) {
                goto old_shm_zone_done;
            }
            opart = opart-&gt;next;
            oshm_zone = opart-&gt;elts;
            i = 0;
        }

        part = &amp;cycle-&gt;shared_memory.part;
        shm_zone = part-&gt;elts;

        for (n = 0; /* void */ ; n++) {

            if (n &gt;= part-&gt;nelts) {
                if (part-&gt;next == NULL) {
                    break;
                }
                part = part-&gt;next;
                shm_zone = part-&gt;elts;
                n = 0;
            }

            if (oshm_zone[i].shm.name.len != shm_zone[n].shm.name.len) {
                continue;
            }

            if (ngx_strncmp(oshm_zone[i].shm.name.data,
                            shm_zone[n].shm.name.data,
                            oshm_zone[i].shm.name.len)
                != 0)
            {
                continue;
            }

            if (oshm_zone[i].tag == shm_zone[n].tag
                &amp;&amp; oshm_zone[i].shm.size == shm_zone[n].shm.size
                &amp;&amp; !oshm_zone[i].noreuse)
            {
                goto live_shm_zone;
            }

            break;
        }

        ngx_shm_free(&amp;oshm_zone[i].shm);

    live_shm_zone:

        continue;
    }

old_shm_zone_done:


    /* close the unnecessary listening sockets */

    ls = old_cycle-&gt;listening.elts;
    for (i = 0; i &lt; old_cycle-&gt;listening.nelts; i++) {

        if (ls[i].remain || ls[i].fd == (ngx_socket_t) -1) {
            continue;
        }

        if (ngx_close_socket(ls[i].fd) == -1) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,
                          ngx_close_socket_n " listening socket on %V failed",
                          &amp;ls[i].addr_text);
        }

#if (NGX_HAVE_UNIX_DOMAIN)

        if (ls[i].sockaddr-&gt;sa_family == AF_UNIX) {
            u_char  *name;

            name = ls[i].addr_text.data + sizeof("unix:") - 1;

            ngx_log_error(NGX_LOG_WARN, cycle-&gt;log, 0,
                          "deleting socket %s", name);

            if (ngx_delete_file(name) == NGX_FILE_ERROR) {
                ngx_log_error(NGX_LOG_EMERG, cycle-&gt;log, ngx_socket_errno,
                              ngx_delete_file_n " %s failed", name);
            }
        }

#endif
    }


    /* close the unnecessary open files */

    part = &amp;old_cycle-&gt;open_files.part;
    file = part-&gt;elts;

    for (i = 0; /* void */ ; i++) {

        if (i &gt;= part-&gt;nelts) {
            if (part-&gt;next == NULL) {
                break;
            }
            part = part-&gt;next;
            file = part-&gt;elts;
            i = 0;
        }

        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {
            continue;
        }

        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ngx_close_file_n " \"%s\" failed",
                          file[i].name.data);
        }
    }

    ngx_destroy_pool(conf.temp_pool);

    if (ngx_process == NGX_PROCESS_MASTER || ngx_is_init_cycle(old_cycle)) {

        ngx_destroy_pool(old_cycle-&gt;pool);
        cycle-&gt;old_cycle = NULL;

        return cycle;
    }


    if (ngx_temp_pool == NULL) {
        ngx_temp_pool = ngx_create_pool(128, cycle-&gt;log);
        if (ngx_temp_pool == NULL) {
            ngx_log_error(NGX_LOG_EMERG, cycle-&gt;log, 0,
                          "could not create ngx_temp_pool");
            exit(1);
        }

        n = 10;

        if (ngx_array_init(&amp;ngx_old_cycles, ngx_temp_pool, n,
                           sizeof(ngx_cycle_t *))
            != NGX_OK)
        {
            exit(1);
        }

        ngx_memzero(ngx_old_cycles.elts, n * sizeof(ngx_cycle_t *));

        ngx_cleaner_event.handler = ngx_clean_old_cycles;
        ngx_cleaner_event.log = cycle-&gt;log;
        ngx_cleaner_event.data = &amp;dumb;
        dumb.fd = (ngx_socket_t) -1;
    }

    ngx_temp_pool-&gt;log = cycle-&gt;log;

    old = ngx_array_push(&amp;ngx_old_cycles);
    if (old == NULL) {
        exit(1);
    }
    *old = old_cycle;

    if (!ngx_cleaner_event.timer_set) {
        ngx_add_timer(&amp;ngx_cleaner_event, 30000);
        ngx_cleaner_event.timer_set = 1;
    }

    return cycle;


failed:

    if (!ngx_is_init_cycle(old_cycle)) {
        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle-&gt;conf_ctx,
                                                   ngx_core_module);
        if (old_ccf-&gt;environment) {
            environ = old_ccf-&gt;environment;
        }
    }

    /* rollback the new cycle configuration */

    part = &amp;cycle-&gt;open_files.part;
    file = part-&gt;elts;

    for (i = 0; /* void */ ; i++) {

        if (i &gt;= part-&gt;nelts) {
            if (part-&gt;next == NULL) {
                break;
            }
            part = part-&gt;next;
            file = part-&gt;elts;
            i = 0;
        }

        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {
            continue;
        }

        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          ngx_close_file_n " \"%s\" failed",
                          file[i].name.data);
        }
    }

    /* free the newly created shared memory */

    part = &amp;cycle-&gt;shared_memory.part;
    shm_zone = part-&gt;elts;

    for (i = 0; /* void */ ; i++) {

        if (i &gt;= part-&gt;nelts) {
            if (part-&gt;next == NULL) {
                break;
            }
            part = part-&gt;next;
            shm_zone = part-&gt;elts;
            i = 0;
        }

        if (shm_zone[i].shm.addr == NULL) {
            continue;
        }

        opart = &amp;old_cycle-&gt;shared_memory.part;
        oshm_zone = opart-&gt;elts;

        for (n = 0; /* void */ ; n++) {

            if (n &gt;= opart-&gt;nelts) {
                if (opart-&gt;next == NULL) {
                    break;
                }
                opart = opart-&gt;next;
                oshm_zone = opart-&gt;elts;
                n = 0;
            }

            if (shm_zone[i].shm.name.len != oshm_zone[n].shm.name.len) {
                continue;
            }

            if (ngx_strncmp(shm_zone[i].shm.name.data,
                            oshm_zone[n].shm.name.data,
                            shm_zone[i].shm.name.len)
                != 0)
            {
                continue;
            }

            if (shm_zone[i].tag == oshm_zone[n].tag
                &amp;&amp; shm_zone[i].shm.size == oshm_zone[n].shm.size
                &amp;&amp; !shm_zone[i].noreuse)
            {
                goto old_shm_zone_found;
            }

            break;
        }

        ngx_shm_free(&amp;shm_zone[i].shm);

    old_shm_zone_found:

        continue;
    }

    if (ngx_test_config) {
        ngx_destroy_cycle_pools(&amp;conf);
        return NULL;
    }

    ls = cycle-&gt;listening.elts;
    for (i = 0; i &lt; cycle-&gt;listening.nelts; i++) {
        if (ls[i].fd == (ngx_socket_t) -1 || !ls[i].open) {
            continue;
        }

        if (ngx_close_socket(ls[i].fd) == -1) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,
                          ngx_close_socket_n " %V failed",
                          &amp;ls[i].addr_text);
        }
    }

    ngx_destroy_cycle_pools(&amp;conf);

    return NULL;
}
</code></pre>
    <hr/>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_init_cycle
      </code>
     </span>
     是 Nginx 核心模块中的一个关键函数，
     <br/>
     负责初始化 Nginx 的运行环境。
     <br/>
     它基于传入的旧周期（
     <code>
      old_cycle
     </code>
     ）创建一个新的周期（
     <code>
      cycle
     </code>
     ），
     <br/>
     并完成一系列复杂的初始化工作，
     <br/>
     包括配置文件解析、共享内存分配、监听套接字设置等。
    </h4>
    <hr/>
    <h3>
     <strong>
      函数签名
     </strong>
    </h3>
    <pre><code>ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle)
</code></pre>
    <h4>
     <strong>
      作用
     </strong>
    </h4>
    <ul>
     <li>
      <h4>
       接收一个指向旧周期（
       <code>
        old_cycle
       </code>
       ）的指针。
      </h4>
     </li>
     <li>
      <h4>
       返回一个新创建的周期（
       <code>
        cycle
       </code>
       ）指针，表示初始化后的运行时环境。
      </h4>
     </li>
     <li>
      <h4>
       如果初始化失败，返回
       <code>
        NULL
       </code>
       。
      </h4>
     </li>
     <li>
      <h4>
       新周期会继承旧周期的部分信息（如路径、配置文件路径等），同时根据新的配置进行更新。
      </h4>
     </li>
    </ul>
    <p>
    </p>
    <hr/>
    <pre><code>   ngx_timezone_update();

    /* force localtime update with a new timezone */

    tp = ngx_timeofday();
    tp-&gt;sec = 0;

    ngx_time_update();
</code></pre>
    <h4>
     <span style="color:#be191c">
      ngx_timezone_update
     </span>
     ()更新进程的时区缓存
     <br/>
     <span style="color:#be191c">
      ngx_timeofday()
     </span>
     获取当前时间缓存对象 tp。
     <br/>
     <span style="color:#be191c">
      tp-&gt;sec = 0
     </span>
     强制标记时间缓存为“已失效”。
     <br/>
     <span style="color:#be191c">
      ngx_time_update()
     </span>
     重新计算当前时间并更新缓存。
    </h4>
    <h4>
     <span style="color:#be191c">
      tp-&gt;sec = 0;
     </span>
     的作用是强制标记当前时间缓存为无效，从而确保在调用
     <span style="color:#be191c">
      ngx_time_update()
     </span>
     时会重新调用系统函数来获取最新的时间戳。
     <br/>
     如果没有强制刷新时间缓存（即
     <span style="color:#be191c">
      tp-&gt;sec != 0
     </span>
     ），
     <span style="color:#be191c">
      ngx_time_update()
     </span>
     可能不会真正调用系统函数，而是直接使用缓存值
    </h4>
    <hr/>
    <pre><code>   log = old_cycle-&gt;log;</code></pre>
    <h4>
     从旧的 Nginx 运行周期（
     <span style="color:#be191c">
      old_cycle
     </span>
     ）中继承日志对象（
     <span style="color:#be191c">
      log
     </span>
     ），并将其赋值给当前的局部变量
     <span style="color:#be191c">
      log
     </span>
    </h4>
    <h4>
     新周期初始化时，尚未解析新的配置文件，无法确定新的日志路径或级别。
     <br/>
     若直接使用新配置的日志可能失败（如路径无效），导致错误信息无法记录。
     <br/>
     复用旧日志配置，新周期完全初始化前,确保初始化阶段的日志记录可靠。
    </h4>
    <hr/>
    <pre><code>   pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
    if (pool == NULL) {
        return NULL;
    }
    pool-&gt;log = log;</code></pre>
    <h4>
     创建一个内存池（memory pool），用于管理 Nginx 运行周期（cycle）中的内存分配
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145886083?sharetype=blogdetail&amp;sharerId=145886083&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="NGX_CYCLE_POOL_SIZE">
      NGX_CYCLE_POOL_SIZE
     </a>
     <br/>
     这是一个宏定义，表示内存池的初始大小。
    </h4>
    <h4>
     <code>
      log
     </code>
     是一个指向日志对象的指针，用于记录内存池操作中的错误或调试信息。
    </h4>
    <hr/>
    <pre><code>   cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));
    if (cycle == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     从内存池分配一个新的
     <span style="color:#be191c">
      <code>
       ngx_cycle_t
      </code>
     </span>
     结构（核心运行时上下文）
    </h4>
    <hr/>
    <pre><code>   cycle-&gt;pool = pool;
   cycle-&gt;log = log;
   cycle-&gt;old_cycle = old_cycle;</code></pre>
    <h4>
     <span style="color:#be191c">
      cycle-&gt;pool = pool;
     </span>
     <br/>
     关联新内存池到新周期。
     <br/>
     所有后续内存分配均通过此池进行，确保统一管理。
    </h4>
    <h4>
     <span style="color:#be191c">
      cycle-&gt;log = log;
     </span>
     <br/>
     设置新周期的日志对象。
     <br/>
     确保新周期的所有操作使用继承的日志配置，直到新配置生效。
    </h4>
    <h4>
     <span style="color:#be191c">
      <strong>
       cycle-&gt;old_cycle = old_cycle;
      </strong>
     </span>
     <br/>
     保存旧周期指针到新周期。
     <br/>
     在平滑重启或重新配置时，新周期需要访问旧周期的资源（如监听套接字、共享内存）。
     <br/>
     资源复用：通过 old_cycle 复用旧资源（如 SO_REUSEPORT 套接字），实现零停机更新。
     <br/>
     渐进式释放：旧周期资源在新周期稳定后逐步清理，避免服务中断。
    </h4>
    <hr/>
    <pre><code>   cycle-&gt;conf_prefix.len = old_cycle-&gt;conf_prefix.len;
    cycle-&gt;conf_prefix.data = ngx_pstrdup(pool, &amp;old_cycle-&gt;conf_prefix);
    if (cycle-&gt;conf_prefix.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     复制配置文件前缀（
     <span style="color:#be191c">
      <code>
       conf_prefix
      </code>
     </span>
     ）
    </h4>
    <h4>
     从旧周期复制
     <span style="color:#be191c">
      <code>
       conf_prefix
      </code>
     </span>
     ，用于定位配置文件
     <br/>
     <strong>
      平滑重启
     </strong>
     ：保持配置路径一致，避免重新解析路径导致的延迟。
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145901904?sharetype=blogdetail&amp;sharerId=145901904&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="ngx_pstrdup">
      ngx_pstrdup
     </a>
    </h4>
    <hr/>
    <pre><code>    cycle-&gt;prefix.len = old_cycle-&gt;prefix.len;
    cycle-&gt;prefix.data = ngx_pstrdup(pool, &amp;old_cycle-&gt;prefix);
    if (cycle-&gt;prefix.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     从旧周期复制
     <span style="color:#be191c">
      <code>
       prefix
      </code>
     </span>
     （如
     <code>
      /usr/local/nginx/
     </code>
     ），用于解析相对路径
    </h4>
    <hr/>
    <pre><code>    cycle-&gt;error_log.len = old_cycle-&gt;error_log.len;
    cycle-&gt;error_log.data = ngx_pnalloc(pool, old_cycle-&gt;error_log.len + 1);
    if (cycle-&gt;error_log.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }
    ngx_cpystrn(cycle-&gt;error_log.data, old_cycle-&gt;error_log.data,
                old_cycle-&gt;error_log.len + 1);</code></pre>
    <h4>
     <strong>
      继承错误日志路径
     </strong>
     ：复制旧周期的错误日志
     <a href="https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84&amp;spm=1001.2101.3001.7020" title="文件路径">
      文件路径
     </a>
     <br/>
     <strong>
      日志连续性
     </strong>
     ：初始化阶段使用旧日志配置，避免日志记录中断
     <br/>
     <strong>
      字符串安全性
     </strong>
     ：通过
     <span style="color:#be191c">
      <code>
       ngx_cpystrn
      </code>
     </span>
     确保字符串以
     <span style="color:#be191c">
      <code>
       \0
      </code>
     </span>
     结尾
    </h4>
    <hr/>
    <pre><code>   cycle-&gt;conf_file.len = old_cycle-&gt;conf_file.len;
    cycle-&gt;conf_file.data = ngx_pnalloc(pool, old_cycle-&gt;conf_file.len + 1);
    if (cycle-&gt;conf_file.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }
    ngx_cpystrn(cycle-&gt;conf_file.data, old_cycle-&gt;conf_file.data,
                old_cycle-&gt;conf_file.len + 1);</code></pre>
    <h4>
     <strong>
      继承配置文件路径
     </strong>
     ：复制旧周期的配置文件路径
    </h4>
    <hr/>
    <pre><code>    cycle-&gt;conf_param.len = old_cycle-&gt;conf_param.len;
    cycle-&gt;conf_param.data = ngx_pstrdup(pool, &amp;old_cycle-&gt;conf_param);
    if (cycle-&gt;conf_param.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     <strong>
      继承命令行配置参数
     </strong>
     ：复制通过
     <code>
      -g
     </code>
     参数传递的配置
    </h4>
    <hr/>
    <pre><code>    n = old_cycle-&gt;paths.nelts ? old_cycle-&gt;paths.nelts : 10;</code></pre>
    <h4>
     确定
     <span style="color:#be191c">
      paths
     </span>
     数组的初始容量
     <span style="color:#be191c">
      n
     </span>
     。
    </h4>
    <h4>
     若旧周期（
     <span style="color:#be191c">
      old_cycle
     </span>
     ）存在路径配置，则继承其大小；否则预分配
     <span style="color:#be191c">
      10
     </span>
     个元素。
    </h4>
    <h4>
     <span style="color:#be191c">
      paths
     </span>
     用于存储 Nginx 运行时路径（如临时文件目录）。旧周期可能已包含路径信息（如 client_body_temp_path），新周期需复用或初始化。
    </h4>
    <h4>
     资源复用：继承旧周期的容量，避免重复计算路径数量。
     <br/>
     预分配优化：默认值
     <span style="color:#be191c">
      10
     </span>
     是经验值，平衡内存占用与扩容开销。
    </h4>
    <hr/>
    <pre><code>    ngx_memzero(cycle-&gt;paths.elts, n * sizeof(ngx_path_t *));</code></pre>
    <h4>
     将
     <span style="color:#be191c">
      <code>
       paths
      </code>
     </span>
     数组的前
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     个元素清零（初始化为
     <code>
      NULL
     </code>
     ）
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_array_init
      </code>
     </span>
     分配的内存未初始化，可能包含脏数据。路径指针需显式置空，避免后续误判
    </h4>
    <h4>
     确保数组初始状态明确（所有元素为
     <code>
      NULL
     </code>
     ）
    </h4>
    <hr/>
    <pre><code>    if (ngx_array_init(&amp;cycle-&gt;config_dump, pool, 1, sizeof(ngx_conf_dump_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     初始化数组
     <span style="color:#be191c">
      <code>
       config_dump
      </code>
     </span>
     ，用于存储配置转储条目
    </h4>
    <h4>
     使用内存池
     <span style="color:#be191c">
      <code>
       pool
      </code>
     </span>
     分配内存，初始容量为
     <span style="color:#be191c">
      1
     </span>
     ，每个元素大小为
     <span style="color:#be191c">
      <code>
       ngx_conf_dump_t
      </code>
     </span>
    </h4>
    <h4>
     若初始化失败（返回
     <code>
      NGX_ERROR
     </code>
     ），销毁内存池并终止初始化。
    </h4>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/weixin_41812346/article/details/146104723?sharetype=blogdetail&amp;sharerId=146104723&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_conf_dump_t-CSDN博客">
       Ubuntu 下 nginx-1.24.0 源码分析 - ngx_conf_dump_t-CSDN博客
      </a>
     </p>
    </blockquote>
    <hr/>
    <pre><code>    ngx_rbtree_init(&amp;cycle-&gt;config_dump_rbtree, &amp;cycle-&gt;config_dump_sentinel,
                    ngx_str_rbtree_insert_value);</code></pre>
    <h4>
     初始化红黑树
     <span style="color:#be191c">
      config_dump_rbtree
     </span>
     ，用于快速查找和去重
    </h4>
    <h4>
     根节点为
     <span style="color:#be191c">
      config_dump_rbtree
     </span>
     ，哨兵节点为
     <span style="color:#be191c">
      config_dump_sentinel
     </span>
     。
     <br/>
     使用
     <span style="color:#be191c">
      ngx_str_rbtree_insert_value
     </span>
     作为插入回调，按字符串键排序。
     <br/>
    </h4>
    <h4>
     <br/>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145904207" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_rbtree_init-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_rbtree_init-CSDN博客
     </a>
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145908313" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_str_rbtree_insert_value-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_str_rbtree_insert_value-CSDN博客
     </a>
    </h4>
    <table align="left" border="1" cellpadding="1" cellspacing="1" style="width:1200px">
     <tbody>
      <tr>
       <td style="width:62px">
        <h4>
         ngx_array_t config_dump
        </h4>
       </td>
       <td style="white-space:nowrap; width:130px">
        <h4>
         存储配置条目
        </h4>
       </td>
       <td style="width:540px">
        <h4>
         动态数组，存储 ngx_conf_dump_t 结构体
        </h4>
       </td>
      </tr>
      <tr>
       <td style="width:62px">
        <h4>
         ngx_rbtree_t config_dump_rbtree
        </h4>
       </td>
       <td style="width:130px">
        <h4>
         索引配置条目，加速查找与去重
        </h4>
       </td>
       <td style="white-space:nowrap; width:540px">
        <h4>
         红黑树键值为配置名称（ngx_str_t），节点数据指向 config_dump 数组素
        </h4>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
    </p>
    <p>
     <br/>
     <br/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h4>
     以
     <span style="color:#be191c">
      ngx_conf_dump_t.name
     </span>
     （配置块名称）作为红黑树的键，通过
     <span style="color:#be191c">
      ngx_str_rbtree_insert_value
     </span>
     回调按字符串排序。
    </h4>
    <h4>
     <br/>
     功能分离：
     <br/>
     数组存储数据，红黑树管理索引，职责清晰。
    </h4>
    <hr/>
    <pre><code>   if (old_cycle-&gt;open_files.part.nelts) {
        n = old_cycle-&gt;open_files.part.nelts;
        for (part = old_cycle-&gt;open_files.part.next; part; part = part-&gt;next) {
            n += part-&gt;nelts;
        }

    } else {
        n = 20;
    }</code></pre>
    <h4>
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     存储 nginx 运行时需持久打开的文件（如日志文件、共享内存文件）。
    </h4>
    <h4>
     在平滑重启或重新配置时，新周期需继承这些文件以避免频繁打开/关闭。
    </h4>
    <p>
    </p>
    <h4>
     判断旧
     <span style="color:#be191c">
      cycle（
      <code>
       old_cycle
      </code>
      ）
     </span>
     的
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     链表的第一个节点（
     <span style="color:#be191c">
      <code>
       part
      </code>
     </span>
     ）是否有元素
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     是
     <span style="color:#be191c">
      <code>
       ngx_list_t
      </code>
     </span>
     类型，内部由多个
     <span style="color:#be191c">
      <code>
       ngx_list_part_t
      </code>
     </span>
     节点组成，每个节点包含多个元素。
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145917079" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_list_t-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_list_t-CSDN博客
     </a>
    </h4>
    <h4>
    </h4>
    <h4>
     如果旧
     <span style="color:#be191c">
      cycle
     </span>
     的
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     存在元素，进入计算总元素数的逻辑
    </h4>
    <h4>
     初始化容量
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     为旧周期文件数量
    </h4>
    <h4>
     获取旧周期
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     列表第一个分片（
     <span style="color:#be191c">
      <code>
       part
      </code>
     </span>
     ）的元素数量。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_list_t
      </code>
     </span>
     是分片链表结构，每个分片（
     <span style="color:#be191c">
      <code>
       part
      </code>
     </span>
     ）包含
     <span style="color:#be191c">
      <code>
       nelts
      </code>
     </span>
     个元素。
     <br/>
     此处初始化
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     为第一个分片的元素数。
    </h4>
    <h4>
     遍历旧周期
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     的所有分片，累加总元素数到
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_list_t
      </code>
     </span>
     可能包含多个分片（如元素数量超过单个分片容量），需遍历所有分片统计总数。
    </h4>
    <h4>
     若旧周期无文件，设置初始容量
     <span style="color:#be191c">
      <code>
       n = 20
      </code>
     </span>
     。
    </h4>
    <hr/>
    <pre><code>if (ngx_list_init(&amp;cycle-&gt;open_files, pool, n, sizeof(ngx_open_file_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }
</code></pre>
    <h4>
     初始化新周期的
     <span style="color:#be191c">
      <code>
       open_files
      </code>
     </span>
     列表。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       pool
      </code>
     </span>
     ：内存池，用于管理列表内存。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     ：初始容量（继承旧文件数或默认
     <span style="color:#be191c">
      20
     </span>
     ）。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       sizeof(ngx_open_file_t)
      </code>
     </span>
     ：每个元素的大小（文件描述符结构）。
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145924270" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_list_init-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_list_init-CSDN博客
     </a>
    </h4>
    <hr/>
    <pre><code>    if (old_cycle-&gt;shared_memory.part.nelts) {
        n = old_cycle-&gt;shared_memory.part.nelts;
        for (part = old_cycle-&gt;shared_memory.part.next; part; part = part-&gt;next)
        {
            n += part-&gt;nelts;
        }

    } else {
        n = 1;
    }</code></pre>
    <h4>
     判断旧周期（
     <code>
      old_cycle
     </code>
     ）的共享内存列表是否非空。
     <br/>
     <span style="color:#be191c">
      <code>
       shared_memory
      </code>
     </span>
     存储 nginx 的共享内存区域
     <br/>
     在平滑重启或重新配置时，新周期需继承这些区域以避免重复创建。
    </h4>
    <h4>
     获取旧周期共享内存列表第一个分片（
     <span style="color:#be191c">
      <code>
       part
      </code>
     </span>
     ）的元素数量
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_list_t
      </code>
     </span>
     是分片链表结构，每个分片（
     <span style="color:#be191c">
      <code>
       part
      </code>
     </span>
     ）包含
     <span style="color:#be191c">
      <code>
       nelts
      </code>
     </span>
     个元素。此处初始化
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     为第一个分片的元素数。
    </h4>
    <h4>
     遍历旧周期
     <span style="color:#be191c">
      <code>
       shared_memory
      </code>
     </span>
     的所有分片，累加总元素数到
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_list_t
      </code>
     </span>
     可能包含多个分片（如元素数量超过单个分片容量），需遍历所有分片统计总数。
    </h4>
    <h4>
     若旧周期无共享内存，设置初始容量
     <span style="color:#be191c">
      <code>
       n = 1
      </code>
     </span>
     。
    </h4>
    <hr/>
    <pre><code>  if (ngx_list_init(&amp;cycle-&gt;shared_memory, pool, n, sizeof(ngx_shm_zone_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     初始化新周期的
     <span style="color:#be191c">
      <code>
       shared_memory
      </code>
     </span>
     列表。
    </h4>
    <hr/>
    <pre><code>   n = old_cycle-&gt;listening.nelts ? old_cycle-&gt;listening.nelts : 10;</code></pre>
    <h4>
     根据旧周期（
     <span style="color:#be191c">
      old_cycle
     </span>
     ）的监听套接字数量设置新周期的初始容量
     <span style="color:#be191c">
      n
     </span>
     。
     <br/>
     若旧周期无监听套接字，则默认预分配
     <span style="color:#be191c">
      10
     </span>
     个元素。
    </h4>
    <h4>
     <span style="color:#be191c">
      old_cycle-&gt;listening.nelts
     </span>
     是旧周期监听数组的元素数量。
     <br/>
     若存在旧监听套接字，继承其数量；否则使用默认值
     <span style="color:#be191c">
      10
     </span>
     。
     <br/>
     监听数组（
     <span style="color:#be191c">
      listening
     </span>
     ）存储 Nginx 监听的端口和套接字信息（如 listen 80;）。
    </h4>
    <p>
    </p>
    <h4>
     在 Nginx 启动时，所有监听套接字会被初始化并集中存储到
     <span style="color:#be191c">
      <code>
       cycle-&gt;listening
      </code>
     </span>
     数组中，方便后续统一操作（如绑定、监听、关闭）。
    </h4>
    <h4>
     <strong>
      初始化阶段
     </strong>
     ：在
     <span style="color:#be191c">
      <code>
       ngx_init_cycle()
      </code>
     </span>
     函数中，Nginx 会遍历
     <span style="color:#be191c">
      <code>
       cycle-&gt;listening
      </code>
     </span>
     数组，为每个监听创建套接字并设置为监听状态。
    </h4>
    <h4>
     <strong>
      平滑重启
     </strong>
     ：当配置文件更改时，Nginx 可以平滑地切换到新配置，而不中断当前连接。
    </h4>
    <h4>
     这需要能够比较新旧配置中的监听端口，
     <span style="color:#be191c">
      <code>
       cycle-&gt;listening
      </code>
     </span>
     提供了这种能力
    </h4>
    <hr/>
    <pre><code>  if (ngx_array_init(&amp;cycle-&gt;listening, pool, n, sizeof(ngx_listening_t))
        != NGX_OK)
    {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     初始化
     <span style="color:#be191c">
      <code>
       cycle-&gt;listening
      </code>
     </span>
     数组
    </h4>
    <hr/>
    <pre><code>    ngx_memzero(cycle-&gt;listening.elts, n * sizeof(ngx_listening_t));</code></pre>
    <h4>
     将监听数组的前
     <span style="color:#be191c">
      <code>
       n
      </code>
     </span>
     个元素清零。
    </h4>
    <h4>
     <span style="color:#be191c">
      <code>
       ngx_memzero
      </code>
     </span>
     是
     <span style="color:#be191c">
      <code>
       memset
      </code>
     </span>
     的封装，确保内存初始化为
     <span style="color:#be191c">
      0
     </span>
    </h4>
    <h4>
     动态数组分配的内存可能包含脏数据，直接使用可能导致未定义行为（如误判套接字状态）
    </h4>
    <hr/>
    <pre><code>   ngx_queue_init(&amp;cycle-&gt;reusable_connections_queue);</code></pre>
    <h4>
     初始化可重用连接队列：
     <br/>
     将
     <span style="color:#be191c">
      cycle-&gt;reusable_connections_queue
     </span>
     初始化为一个空的双向链表（队列），用于管理可重用的空闲连接（ngx_connection_t）。
    </h4>
    <h4>
     <span style="color:#be191c">
      ngx_queue_t
     </span>
     是 Nginx 的双向链表节点结构
    </h4>
    <h4>
     <span style="color:#be191c">
      ngx_queue_init(q)
     </span>
     宏会将队列的
     <span style="color:#be191c">
      prev
     </span>
     和
     <span style="color:#be191c">
      next
     </span>
     指针均指向自身，表示队列为空。
    </h4>
    <h4>
     队列用途：
     <br/>
     <span style="color:#be191c">
      reusable_connections_queue
     </span>
     存储当前未被使用的连接对象（如已关闭的 TCP 连接），这些连接可被重新分配以避免频繁创建/销毁的开销。
    </h4>
    <h4>
     频繁调用 accept() 创建新连接会导致性能下降，而重用空闲连接可显著降低延迟。
    </h4>
    <h4>
     资源复用：
     <br/>
     当连接关闭时，Nginx 不会立即释放其资源（如套接字、内存），而是将其放入
     <span style="color:#be191c">
      reusable_connections_queue
     </span>
     ，等待后续请求复用。
    </h4>
    <h4>
     在内存紧张时，可通过调整队列大小（worker_connections）动态平衡资源。
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145927534?sharetype=blogdetail&amp;sharerId=145927534&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_queue_init-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_queue_init-CSDN博客
     </a>
    </h4>
    <hr/>
    <pre><code>    cycle-&gt;conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));
    if (cycle-&gt;conf_ctx == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     从内存池
     <span style="color:#be191c">
      pool
     </span>
     中分配一个指针数组
     <span style="color:#be191c">
      conf_ctx
     </span>
     ，每个元素对应一个模块的配置结构指针。
    </h4>
    <h4>
     <span style="color:#be191c">
      ngx_max_module
     </span>
     ：编译时确定的模块总数
    </h4>
    <h4>
     <span style="color:#be191c">
      sizeof(void *)
     </span>
     ：每个指针的大小
    </h4>
    <h4>
     数组长度为
     <span style="color:#be191c">
      ngx_max_module
     </span>
     ，索引为模块的唯一标识符（
     <span style="color:#be191c">
      module-&gt;index
     </span>
     ）。
    </h4>
    <h4>
     若内存分配失败，销毁内存池并终止初始化。
    </h4>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146118481?sharetype=blogdetail&amp;sharerId=146118481&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - conf_ctx-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - conf_ctx-CSDN博客
     </a>
    </h3>
    <hr/>
    <pre><code>    if (gethostname(hostname, NGX_MAXHOSTNAMELEN) == -1) {
        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, "gethostname() failed");
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h3>
     调用
     <span style="color:#be191c">
      <code>
       gethostname()
      </code>
     </span>
     系统调用获取本地主机名，存储到
     <span style="color:#be191c">
      <code>
       hostname
      </code>
     </span>
     缓冲区。
    </h3>
    <h3>
     缓冲区大小为
     <code>
      NGX_MAXHOSTNAMELEN
     </code>
    </h3>
    <h3>
     若调用失败（返回
     <code>
      -1
     </code>
     ），记录致命错误（
     <code>
      NGX_LOG_EMERG
     </code>
     ），销毁内存池并终止初始化。
    </h3>
    <h4>
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146120905?sharetype=blogdetail&amp;sharerId=146120905&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="gethostname-CSDN博客">
      gethostname-CSDN博客
     </a>
    </h4>
    <p>
    </p>
    <hr/>
    <pre><code>    hostname[NGX_MAXHOSTNAMELEN - 1] = '\0';
    cycle-&gt;hostname.len = ngx_strlen(hostname);</code></pre>
    <h3>
     确保
     <span style="color:#be191c">
      <code>
       hostname
      </code>
     </span>
     以
     <span style="color:#be191c">
      <code>
       \0
      </code>
     </span>
     结尾，避免未终止字符串导致的安全风险。
    </h3>
    <h3>
     <span style="color:#be191c">
      Linux
     </span>
     的
     <span style="color:#be191c">
      <code>
       gethostname()
      </code>
     </span>
     在缓冲区不足时静默截断，但不会添加
     <span style="color:#be191c">
      <code>
       \0
      </code>
     </span>
     。
     <br/>
     手动设置最后一个字节为
     <span style="color:#be191c">
      <code>
       \0
      </code>
     </span>
     ，确保字符串合法性。
    </h3>
    <p>
    </p>
    <h3>
     计算主机名的实际长度（不含终止符），存储到
     <span style="color:#be191c">
      <code>
       cycle-&gt;hostname.len
      </code>
     </span>
    </h3>
    <hr/>
    <pre><code>    cycle-&gt;hostname.data = ngx_pnalloc(pool, cycle-&gt;hostname.len);
    if (cycle-&gt;hostname.data == NULL) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h3>
     从内存池
     <span style="color:#be191c">
      <code>
       pool
      </code>
     </span>
     分配内存，存储主机名的副本
    </h3>
    <h3>
     <span style="color:#be191c">
      <code>
       ngx_pnalloc
      </code>
     </span>
     分配指定长度的内存
     <br/>
     若分配失败，销毁内存池并终止初始化。
    </h3>
    <hr/>
    <pre><code>    ngx_strlow(cycle-&gt;hostname.data, (u_char *) hostname, cycle-&gt;hostname.len);</code></pre>
    <h3>
     将主机名转换为全小写，存储到
     <span style="color:#be191c">
      cycle-&gt;hostname.data
     </span>
     。
    </h3>
    <h3>
     <span style="color:#be191c">
      ngx_strlow
     </span>
     是 Nginx 的封装函数，逐字符转换为小写。
    </h3>
    <h3>
     主机名在 DNS 和 HTTP 协议中通常不区分大小写，统一格式避免配置或路由问题。
    </h3>
    <h3>
     统一小写格式，简化后续比较和匹配逻辑（如虚拟主机配置）。
    </h3>
    <hr/>
    <pre><code>    if (ngx_cycle_modules(cycle) != NGX_OK) {
        ngx_destroy_pool(pool);
        return NULL;
    }</code></pre>
    <h4>
     调用
     <span style="color:#be191c">
      ngx_cycle_modules
     </span>
     初始化
     <span style="color:#be191c">
      cycle-&gt;modules
     </span>
     数组，该数组包含所有核心模块的指针。
    </h4>
    <h4>
     Nginx 模块分为核心模块（NGX_CORE_MODULE）、事件模块、HTTP 模块等。
    </h4>
    <h4>
     <span style="color:#be191c">
      ngx_cycle_modules
     </span>
     会遍历全局模块列表（ngx_modules），筛选出核心模块并按优先级排序。
     <br/>
     若模块初始化失败（如内存不足），立即回滚资源。
    </h4>
    <h4>
    </h4>
    <h4>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146123748?sharetype=blogdetail&amp;sharerId=146123748&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_cycle_modules-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_cycle_modules-CSDN博客
     </a>
    </h4>
    <hr/>
    <pre><code>    for (i = 0; cycle-&gt;modules[i]; i++) {
        if (cycle-&gt;modules[i]-&gt;type != NGX_CORE_MODULE) {
            continue;
        }</code></pre>
    <h4>
     <span style="color:#333333">
      遍历所有核心模块
     </span>
    </h4>
    <h3>
    </h3>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146124763?sharetype=blogdetail&amp;sharerId=146124763&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - cycle-＞modules[i]-＞type-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - cycle-＞modules[i]-＞type-CSDN博客
     </a>
    </h3>
    <hr/>
    <pre><code>module = cycle-&gt;modules[i]-&gt;ctx;</code></pre>
    <h4>
     获取核心模块的配置
    </h4>
    <h3>
     module 的类型是：
    </h3>
    <pre><code>ngx_core_module_t   *module;</code></pre>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/146130962?sharetype=blogdetail&amp;sharerId=146130962&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - cycle-＞modules[i]-＞ctx-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - cycle-＞modules[i]-＞ctx-CSDN博客
     </a>
    </h3>
    <h3>
     <a href="https://blog.csdn.net/weixin_41812346/article/details/145937231?sharetype=blogdetail&amp;sharerId=145937231&amp;sharerefer=PC&amp;sharesource=weixin_41812346&amp;spm=1011.2480.3001.8118" title="Ubuntu 下 nginx-1.24.0 源码分析 - ngx_core_module_t-CSDN博客">
      Ubuntu 下 nginx-1.24.0 源码分析 - ngx_core_module_t-CSDN博客
     </a>
    </h3>
    <h3>
    </h3>
    <hr/>
    <pre><code class="hljs">if (module-&gt;create_conf) {
            rv = module-&gt;create_conf(cycle);
            if (rv == NULL) {
                ngx_destroy_pool(pool);
                return NULL;
            }
            cycle-&gt;conf_ctx[cycle-&gt;modules[i]-&gt;index] = rv;
        }
    }</code></pre>
    <h4>
     调用模块的
     <span style="color:#be191c">
      create_conf
     </span>
     方法创建默认配置结构，并将其存储到
     <span style="color:#be191c">
      conf_ctx
     </span>
     数组的对应位置。
    </h4>
    <h4>
     <span style="color:#be191c">
      create_conf
     </span>
     返回模块特定的配置结构
    </h4>
    <h4>
     <span style="color:#be191c">
      conf_ctx
     </span>
     数组通过模块的
     <span style="color:#be191c">
      index
     </span>
     索引定位配置结构。
    </h4>
    <h4>
     每个核心模块（如事件模块）需要独立的配置结构，conf_ctx 是全局配置的存储中心。
    </h4>
    <hr/>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h4>
     <br/>
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34313831323334362f:61727469636c652f64657461696c732f313436303935373636" class_="artid" style="display:none">
 </p>
</div>


