---
layout: post
title: "UDP-网络编程socket编程"
date: 2025-03-11 16:57:10 +0800
description: "我们来介绍socket编程的第一个接口：socket，它需要用到的头文件如图：其中domain表示域或者协议家族：本次我就用AF_INET（ipv4）来做演示type参数表示用什么通讯方式，我们用udp来演示，所以使用SOCK_DGRAM：protocol平时使用我们都传零就行目前来说我们再看看socket的返回值：可以看到，socket返回值是一个文件描述符，"
keywords: "UDP-网络编程/socket编程"
categories: ['未分类']
tags: ['网络协议', '网络', 'Udp']
artid: "146177700"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146177700
    alt: "UDP-网络编程socket编程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146177700
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146177700
cover: https://bing.ee123.net/img/rand?artid=146177700
image: https://bing.ee123.net/img/rand?artid=146177700
img: https://bing.ee123.net/img/rand?artid=146177700
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     UDP-网络编程/socket编程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一，socket相关接口
    </h2>
    <h3>
     1，socket
    </h3>
    <p>
     我们来介绍socket编程的第一个接口：socket，它需要用到的头文件如图：
    </p>
    <p>
     <img alt="" height="152" src="https://i-blog.csdnimg.cn/direct/c8a11ead51494da2a8126c5ba6ac7500.png" width="895"/>
    </p>
    <p>
     其中domain表示域或者协议家族：
    </p>
    <p>
     <img alt="" height="421" src="https://i-blog.csdnimg.cn/direct/12e440a7ab2e4515bc853fc981a16aef.png" width="715"/>
    </p>
    <p>
     本次我就用AF_INET（ipv4）来做演示
    </p>
    <p>
     type参数表示用什么通讯方式，我们用udp来演示，所以使用SOCK_DGRAM：
    </p>
    <p>
     <img alt="" height="436" src="https://i-blog.csdnimg.cn/direct/6706ee2ecd8941bb8c881866e342f92b.png" width="731"/>
    </p>
    <p>
     protocol平时使用我们都传零就行目前来说
    </p>
    <p>
     我们再看看socket的返回值：
    </p>
    <p>
     <img alt="" height="79" src="https://i-blog.csdnimg.cn/direct/41300edd9cb342f9b799327ce3265012.png" width="972"/>
    </p>
    <p>
     可以看到，socket返回值是一个文件描述符，
     <strong>
      socket本质就是创建了一个文件
     </strong>
    </p>
    <h3>
     <strong>
      2
     </strong>
     ，bind
    </h3>
    <p>
     bind头文件及其需要的参数如下：
    </p>
    <p>
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/59299904d2ee46c4bfe3c5f993fd8e3d.png" width="886"/>
    </p>
    <p>
     scokfd参数就是在socket创建成功之后的返回值（文件描述符）sockaddr是一个结构体指针addrlen是该结构体的大小。
    </p>
    <p>
     sockaddr和addrlen维护在一个sockaddr_in里面，
     <strong>
      这时我们知道，在使用bind填充网络信息时并没有写入内核，只是把数据维护到一个结构体里
     </strong>
    </p>
    <h3>
     3，sockaddr_in
    </h3>
    <p>
     <img alt="" height="409" src="https://i-blog.csdnimg.cn/direct/e8f4ec289d7c44498c7342e455af8942.png" width="799"/>
    </p>
    <p>
     对sockaddr_in转到定义之后我们可以看到两个参数：sin_port（服务器的端口号），sin_addr，（服务器的ip地址）我们对SOCKADDR COMMON转到定义可以看到：
    </p>
    <p>
     <img alt="" height="137" src="https://i-blog.csdnimg.cn/direct/d3bb5c09ae804a0ca5f6026f9512fa1e.png" width="941"/>
    </p>
    <p>
     此参数要传入对应的协议家族。
    </p>
    <p>
     在传入参数前，我们可以使用bzero来将其初始化：
    </p>
    <p>
     <img alt="" height="312" src="https://i-blog.csdnimg.cn/direct/a2d58d641b77418999f378b34728487b.png" width="986"/>
    </p>
    <p>
     bind的返回值小于零代表绑定失败，大于零代表成功。
    </p>
    <h3>
     4，recvfrom
    </h3>
    <p>
     该函数可以接收别人发送过来的消息
    </p>
    <h3>
     <img alt="" height="205" src="https://i-blog.csdnimg.cn/direct/149219e589cc4235b993f7c8da5cb967.png" width="670"/>
    </h3>
    <p>
     sockfd就是socket的返回值（文件描述符），*buf就是接收数据的容器，len就是最长接收数据的量，flags，目前我们将其设置成零，表示默认行为：非阻塞，src_addr是一个输出型参数，可以接受是谁发的消息，addrlen就是src_affr的大小，其返回值大于零代表接受成功。
    </p>
    <h3>
     5，sendto
    </h3>
    <p>
     sendto是 Linux 系统中用于发送数据的系统调用，主要用于无连接套接字（如 UDP 套接字）。它的作用是将数据发送到指定的目标地址，参数和上面的大差不差就不重新解释了。
    </p>
    <p>
     <img alt="" height="65" src="https://i-blog.csdnimg.cn/direct/040bcd8deba9438e8ddd2f6ce45b9d6e.png" width="726"/>
    </p>
    <h3>
     6，转换字节序
    </h3>
    <p>
     <img alt="" height="476" src="https://i-blog.csdnimg.cn/direct/30d5c561dff0420482abc0e159f0706c.png" width="1091"/>
    </p>
    <p>
     1. htonl
     <br/>
     作用: 将 32 位整数（如 IPv4 地址）从主机字节序转换为网络字节序。
     <br/>
     hostlong: 主机字节序的 32 位整数。
     <br/>
     返回值: 网络字节序的 32 位整数。
    </p>
    <p>
     2. htons
     <br/>
     作用: 将 16 位整数（如端口号）从主机字节序转换为网络字节序。
     <br/>
     hostshort: 主机字节序的 16 位整数。
     <br/>
     返回值: 网络字节序的 16 位整数。
    </p>
    <p>
     3. ntohl
     <br/>
     作用: 将 32 位整数（如 IPv4 地址）从网络字节序转换为主机字节序。
     <br/>
     netlong: 网络字节序的 32 位整数。
     <br/>
     返回值: 主机字节序的 32 位整数。
    </p>
    <p>
     4. ntohs
     <br/>
     作用: 将 16 位整数（如端口号）从网络字节序转换为主机字节序。
     <br/>
     netshort: 网络字节序的 16 位整数。
     <br/>
     返回值: 主机字节序的 16 位整数n。
    </p>
    <p>
     字节序说明
     <br/>
     主机字节序: 可能是大端序（Big-Endian）或小端序（Little-Endian），取决于 CPU 架构。
     <br/>
     网络字节序: 统一为大端序（Big-Endian），这是网络协议的标准。
    </p>
    <h3>
     7，点分十进制系列转换
    </h3>
    <p>
     <img alt="" height="365" src="https://i-blog.csdnimg.cn/direct/cc759ee83ce2483d9b9b1cfabd58b38a.png" width="714"/>
    </p>
    <p>
     1. inet_aton
     <br/>
     作用**: 将点分十进制格式的 IPv4 地址字符串（如 192.168.1.1）转换为网络字节序的二进制值，并存储到 `struct in_addr` 结构中。
     <br/>
     特点:
     <br/>
     与 inet_addr 类似，但更安全，因为它使用 `struct in_addr` 来存储结果，而不是返回一个可能被误解的值。
     <br/>
     成功时返回 1，失败时返回 0。
     <br/>
     支持所有有效的 IPv4 地址格式，包括特殊地址（如255.255.255.255）。
    </p>
    <p>
     2. inet_addr
     <br/>
     作用: 将点分十进制格式的 IPv4 地址字符串（如 192.168.1.1）转换为 32 位的网络字节序的二进制值。
     <br/>
     特点:
     <br/>
     返回值为 in_addr_t类型（通常是 uint32_t）。
     <br/>
     如果输入的字符串无效，返回 INADDR_NONE（通常是 -1）。
     <br/>
     已经被标记为过时，推荐使用 inet_aton 或 inet_pton。
    </p>
    <p>
     3. inet_ntoa
     <br/>
     作用: 将网络字节序的二进制 IPv4 地址（struct in_addr）转换为点分十进制格式的字符串。
     <br/>
     特点:
     <br/>
     返回一个指向静态缓冲区的指针，该缓冲区存储转换后的字符串。
     <br/>
     由于使用静态缓冲区，该函数不是线程安全的。
     <br/>
     适用于简单的调试或非并发场景。
    </p>
    <p>
     4.inet_lnaof
     <br/>
     作用: 从 struct in_addr 中提取主机部分（本地网络地址部分）的二进制值。
     <br/>
     特点:
     <br/>
     假设输入的 IPv4 地址是分类网络地址（如 A 类、B 类、C 类）。
     <br/>
     返回值为主机部分的二进制值（主机字节序）。
     <br/>
     在现代网络中，由于 CIDR（无类别域间路由）的广泛使用，此函数的使用场景有限。
    </p>
    <p>
     5.inet_netof
     <br/>
     作用: 从 `struct in_addr` 中提取网络部分（网络地址部分）的二进制值。                                      特点:
     <br/>
     假设输入的 IPv4 地址是分类网络地址
    </p>
    <p>
     返回值为网络部分的二进制值
    </p>
    <h2>
     二，基于网络接口写一个客户给服务端发消息的案例（使用udp）
    </h2>
    <p>
    </p>
    <p>
     <img alt="" height="1584" src="https://i-blog.csdnimg.cn/direct/a8e1e1b6c16e4eab83fb4fb76afad0d8.png" width="1199"/>
    </p>
    <p>
     <img alt="" height="527" src="https://i-blog.csdnimg.cn/direct/483682ae7ff84f3b82e00ee9eef24773.png" width="855"/>
    </p>
    <p>
     <img alt="" height="2083" src="https://i-blog.csdnimg.cn/direct/f4b49d7b4a9e43d5933a630371bf50a8.png" width="1093"/>
    </p>
    <p>
     <img alt="" height="673" src="https://i-blog.csdnimg.cn/direct/8bec1e82c6af4cc68fcb23fda9267ed2.png" width="752"/>
    </p>
    <p>
     <img alt="" height="1135" src="https://i-blog.csdnimg.cn/direct/af3b2caa4bd84523a75a982df1aa7219.png" width="1133"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f706f756f702f:61727469636c652f64657461696c732f313436313737373030" class_="artid" style="display:none">
 </p>
</div>


