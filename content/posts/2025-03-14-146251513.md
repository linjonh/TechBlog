---
layout: post
title: "spring-boot实现程序运行过程中数据源动态切换"
date: 2025-03-14 10:54:54 +0800
description: "项目中有一个需求，spring boot项目连接postgres数据库的地址，是存储在etcd当中的，在程序启动后，当etcd中的地址变化时，需要程序去连接新的postgres地址。1. 修改Datasource定义，改为使用DynamicPGDataSource，它是一个自定义类，集成了。3. 定义re方法，当监听到数据源IP更改之后，去切换连接到新的数据源，并且关闭老的数据源连接。"
keywords: "spring boot实现程序运行过程中数据源动态切换"
categories: ['未分类']
tags: ['数据库', 'Spring', 'Java', 'Boot']
artid: "146251513"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146251513
    alt: "spring-boot实现程序运行过程中数据源动态切换"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146251513
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146251513
cover: https://bing.ee123.net/img/rand?artid=146251513
image: https://bing.ee123.net/img/rand?artid=146251513
img: https://bing.ee123.net/img/rand?artid=146251513
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     spring boot实现程序运行过程中数据源动态切换
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     项目中有一个需求，spring boot项目连接postgres数据库的地址，是存储在etcd当中的，在程序启动后，当etcd中的地址变化时，需要程序去连接新的postgres地址。
    </p>
    <p>
     1. 修改Datasource定义，改为使用DynamicPGDataSource，它是一个自定义类，集成了
    </p>
    <pre>AbstractRoutingDataSource</pre>
    <pre><code class="hljs">@Primary
    @Bean
    public DataSource druidDataSource() {
        DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
        druidDataSource.setUrl(url);
        druidDataSource.setUsername(username);
        druidDataSource.setPassword(password);
        druidDataSource.setDriverClassName(driverClassName);
        druidDataSource.setInitialSize(druidInitSize);// 初始化连接数
        druidDataSource.setMinIdle(druidMinIdle); // 最小连接数
        druidDataSource.setMaxActive(druidMaxActive);// 最大连接数
        druidDataSource.setPoolPreparedStatements(true);// 开启缓存preparedStatement
        druidDataSource.setUseGlobalDataSourceStat(true);

        // 开启Druid提供的3s慢SQL监控
        Properties properties = new Properties();
        properties.put("druid.stat.mergeSql", true);
        properties.put("druid.stat.slowSqlMillis", 3000);
        druidDataSource.setConnectProperties(properties);
        try {
            druidDataSource.setFilters("stat,wall");
            druidDataSource.init();
        } catch (SQLException e) {
            log.error("构建数据库连接池异常，异常原因：{}", e);
            throw new RuntimeException(e);
        }

        DynamicPGDataSource dynamicPGDataSource = new DynamicPGDataSource();
        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
        targetDataSources.put(ConnectInfo.currentPGIP, druidDataSource);
        dynamicPGDataSource.setTargetDataSources(targetDataSources);
        dynamicPGDataSource.setDefaultTargetDataSource(druidDataSource);
        return dynamicPGDataSource;
    }</code></pre>
    <p>
     2. 类定义
    </p>
    <pre><code class="hljs">public class DynamicPGDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContext.getPGDataSource();
    }
}</code></pre>
    <pre><code class="hljs">public class DataSourceContext {
    private static String pgDataSource;

    public static void setPGDataSource(String ds) {
        pgDataSource = ds;
    }

    public static String getPGDataSource() {
        return pgDataSource;
    }
}</code></pre>
    <p>
     3. 定义re方法，当监听到数据源IP更改之后，去切换连接到新的数据源，并且关闭老的数据源连接。
    </p>
    <pre><code class="hljs">public void refreshPGDataSource(String ip) {
        if(ConnectInfo.currentPGIP.equals(ip)) {
            log.info("currentPGIP equals ip, not operate, ip:{}", ip);
        }
        DynamicPGDataSource dynamicPGDataSource = ((DynamicPGDataSource)druidDataSource);
        Field field = null;
        try {
            field = AbstractRoutingDataSource.class.getDeclaredField("targetDataSources");
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        field.setAccessible(true);

        // 获取当前的 targetDataSources
        Map&lt;Object, Object&gt; currentDataSources = null;
        try {
            currentDataSources = (Map&lt;Object, Object&gt;) field.get(dynamicPGDataSource);
            if(!currentDataSources.containsKey(ip)) {
                DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
                String address = String.format("jdbc:postgresql://%s:5432/dsgdb?characterEncoding=utf-8&amp;useSSL=false", ip);
                druidDataSource.setUrl(address);
                druidDataSource.setUsername(username);
                druidDataSource.setPassword(password);
                druidDataSource.setDriverClassName(driverClassName);
                druidDataSource.setInitialSize(20);// 初始化连接数
                druidDataSource.setMinIdle(10); // 最小连接数
                druidDataSource.setMaxActive(100);// 最大连接数
                druidDataSource.setPoolPreparedStatements(true);// 开启缓存preparedStatement
                druidDataSource.setUseGlobalDataSourceStat(true);
                // 开启Druid提供的3s慢SQL监控
                Properties properties = new Properties();
                properties.put("druid.stat.mergeSql", true);
                properties.put("druid.stat.slowSqlMillis", 3000);
                druidDataSource.setConnectProperties(properties);
                druidDataSource.setFilters("stat,wall");
                currentDataSources.put(ip, druidDataSource);
                field.set(dynamicPGDataSource, currentDataSources);
                dynamicPGDataSource.afterPropertiesSet();
            }
            DataSourceContext.setPGDataSource(ip);
            ConnectInfo.currentPGIP = ip;
            // 关闭无用连接
            Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = currentDataSources.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry&lt;Object, Object&gt; entry = iterator.next();
                if(!ip.equals(entry.getKey())) {
                    DruidDataSource dataSource = (DruidDataSource)currentDataSources.get(entry.getKey());
                    dataSource.close();
                    iterator.remove();
                }
            }
        } catch (IllegalAccessException | SQLException e) {
            e.printStackTrace();
        }
    }</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f66757375676f6e677a692f:61727469636c652f64657461696c732f313436323531353133" class_="artid" style="display:none">
 </p>
</div>


