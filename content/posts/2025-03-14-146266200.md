---
layout: post
title: "Java-代理模式从静态代理到动态代理"
date: 2025-03-14 20:27:29 +0800
description: "闺蜜在这里就可以看作是新娘的代理对象，代理的行为（方法）是接收和回复新郎的提问。这样做的好处是，我们可以在不修改原目标对象的前提下，扩展目标对象的功能。代理模式不仅可以扩展目标对象的功能，而且在不修改原目标对象的情况下，可以增加一些我们自定义的操作。CGLIB 动态代理通过继承目标类来生成代理类，因此它可以代理未实现任何接口的类。：动态代理更加灵活，不需要针对每个目标类都创建一个代理类，且可以直接代理实现类。我们需要手动为每个目标类创建一个代理类，并在代理类中调用目标类的方法。在 JDK 动态代理中，"
keywords: "Java 代理模式：从静态代理到动态代理"
categories: ['Java']
tags: ['开发语言', '代理模式', 'Java']
artid: "146266200"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146266200
    alt: "Java-代理模式从静态代理到动态代理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146266200
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146266200
cover: https://bing.ee123.net/img/rand?artid=146266200
image: https://bing.ee123.net/img/rand?artid=146266200
img: https://bing.ee123.net/img/rand?artid=146266200
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java 代理模式：从静态代理到动态代理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="java-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%88%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%BD%BB%E6%9D%BE%E6%8E%8C%E6%8F%A1">
     <span style="color:#0d0016">
      前言
     </span>
    </h2>
    <p>
     <span style="color:#0d0016">
     </span>
     <span style="color:#fe2c24">
      <strong>
       代理模式
      </strong>
     </span>
     <span style="color:#0d0016">
      是 Java 中常见的设计模式之一，它的核心思想是通过一个
     </span>
     <span style="color:#fe2c24">
      代理对象
     </span>
     <span style="color:#0d0016">
      来控制对真实对象的访问。代理模式不仅可以扩展目标对象的功能，而且在不修改原目标对象的情况下，可以增加一些我们自定义的操作。
     </span>
    </p>
    <p>
     <img alt="" height="673" src="https://i-blog.csdnimg.cn/direct/d85a6c2e137b4b40bb50591bfc7a3821.png" width="1185"/>
    </p>
    <h3 id="1.-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B">
     <span style="color:#0d0016">
      1. 代理模式简介
     </span>
    </h3>
    <p>
     <span style="color:#0d0016">
      代理模式的
     </span>
     <span style="color:#fe2c24">
      <strong>
       核心思想
      </strong>
     </span>
     <span style="color:#0d0016">
      是：
      <strong>
       通过代理对象来代替对真实对象的访问
      </strong>
      。这样做的好处是，我们可以在不修改原目标对象的前提下，扩展目标对象的功能。比如，在目标对象的某个方法执行前后，你可以增加一些自定义的操作。
     </span>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       举个例子：
      </span>
     </strong>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       新娘找来了自己的闺蜜来代替自己处理新郎的提问。新娘收到的提问都是经过闺蜜处理过滤之后的。闺蜜在这里就可以看作是新娘的代理对象，代理的行为（方法）是接收和回复新郎的提问。
      </span>
     </p>
    </blockquote>
    <p>
     <span style="color:#fe2c24">
      <strong>
       再举个例子：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       你是一个明星，每天有很多粉丝找你签名。但你是大忙人，没时间亲自处理这些请求，所以你找了一个经纪人（代理对象）来帮你处理。粉丝的请求先交给经纪人，经纪人再决定是否转交给你，或者帮你做一些额外的处理（比如记录谁来找你签名）。这样，你既不用亲自处理所有请求，又能保证签名工作顺利进行。
      </span>
     </p>
    </blockquote>
    <h3 id="2.-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">
     <span style="color:#0d0016">
      2. 静态代理
     </span>
    </h3>
    <h4 id="2.1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F">
     <span style="color:#0d0016">
      2.1 什么是静态代理？
     </span>
    </h4>
    <p>
     <span style="color:#0d0016">
      静态代理是指，
     </span>
     <span style="color:#fe2c24">
      <strong>
       在编译时就已经确定了代理类和目标类的关系
      </strong>
     </span>
     <span style="color:#0d0016">
      。我们需要手动为每个目标类创建一个代理类，并在代理类中调用目标类的方法。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      静态代理的缺点：
      <span style="background-color:#4da8ee">
       灵活性较差，一旦接口新增方法，目标类和代理类都需要进行修改。
      </span>
     </span>
    </p>
    <h4 id="2.2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">
     <span style="color:#0d0016">
      2.2 静态代理的实现步骤
     </span>
    </h4>
    <blockquote>
     <ol>
      <li>
       <span style="color:#fe2c24">
        <strong>
         定义一个接口及其实现类
        </strong>
        ；
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         创建一个代理类并实现该接口
        </strong>
        ；
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         将目标对象注入代理类，并在代理类的方法中调用目标类的方法
        </strong>
        。
       </span>
      </li>
     </ol>
    </blockquote>
    <h4 id="2.3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
     <span style="color:#0d0016">
      2.3 代码示例
     </span>
    </h4>
    <h5 id="1.-%E5%AE%9A%E4%B9%89%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E7%9A%84%E6%8E%A5%E5%8F%A3">
     <span style="color:#0d0016">
      1. 定义发送短信的接口
     </span>
    </h5>
    <pre><code class="language-java">public interface SmsService {
    String send(String message);
}
</code></pre>
    <h5 id="2.-%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E7%9A%84%E6%8E%A5%E5%8F%A3">
     <span style="color:#0d0016">
      2. 实现发送短信的接口
     </span>
    </h5>
    <pre><code class="language-java">public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
</code></pre>
    <h5 id="3.-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E7%9A%84%E6%8E%A5%E5%8F%A3">
     <span style="color:#0d0016">
      3. 创建代理类并实现发送短信的接口
     </span>
    </h5>
    <pre><code class="language-java">public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        // 调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        // 调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}
</code></pre>
    <h5 id="4.-%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8">
     <span style="color:#0d0016">
      4. 实际使用
     </span>
    </h5>
    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send("java");
    }
}
</code></pre>
    <p>
     <span style="color:#0d0016">
      运行上述代码之后，控制台打印出：
     </span>
    </p>
    <pre><code class="language-java">before method send()
send message:java
after method send()
</code></pre>
    <p>
     <span style="color:#0d0016">
      可以看到，我们成功地在
      <code>
       SmsServiceImpl
      </code>
      的
      <code>
       send()
      </code>
      方法前后增加了自定义操作。
     </span>
    </p>
    <h3 id="3.-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">
     <span style="color:#0d0016">
      3. 动态代理
     </span>
    </h3>
    <h4 id="3.1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F">
     <span style="color:#0d0016">
      3.1 什么是动态代理？
     </span>
    </h4>
    <p>
     <span style="color:#0d0016">
      相比于静态代理，
      <strong>
       动态代理更加灵活
      </strong>
      。我们不需要针对每个目标类都单独创建一个代理类，而是可以在运行时动态生成代理类。动态代理的实现方式有很多种，比如 JDK 动态代理和 CGLIB 动态代理。
     </span>
    </p>
    <h4 id="3.2-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">
     <span style="color:#0d0016">
      3.2 JDK 动态代理
     </span>
    </h4>
    <h5 id="3.2.1-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83" style="background-color:transparent">
     <span style="color:#0d0016">
      3.2.1 JDK 动态代理的核心
     </span>
    </h5>
    <p>
     <span style="color:#0d0016">
      在 JDK 动态代理中，
      <code>
       InvocationHandler
      </code>
      接口和
      <code>
       Proxy
      </code>
      类是核心。
      <code>
       Proxy
      </code>
      类的
      <code>
       newProxyInstance()
      </code>
      方法用于生成代理对象，而
      <code>
       InvocationHandler
      </code>
      接口的
      <code>
       invoke()
      </code>
      方法则用于处理代理对象的方法调用。
     </span>
    </p>
    <h5 id="3.2.2-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">
     <span style="color:#0d0016">
      3.2.2 JDK 动态代理的实现步骤
     </span>
    </h5>
    <blockquote>
     <ol>
      <li>
       <span style="color:#fe2c24">
        <strong>
         定义一个接口及其实现类
        </strong>
        ；
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         自定义
         <code>
          InvocationHandler
         </code>
         并重写
         <code>
          invoke
         </code>
         方法
        </strong>
        ；
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         通过
         <code>
          Proxy.newProxyInstance()
         </code>
         方法创建代理对象
        </strong>
        。
       </span>
      </li>
     </ol>
    </blockquote>
    <h5 id="3.2.3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
     <span style="color:#0d0016">
      3.2.3 代码示例
     </span>
    </h5>
    <h6 id="1.-%E5%AE%9A%E4%B9%89%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E7%9A%84%E6%8E%A5%E5%8F%A3-2">
     <span style="color:#0d0016">
      1. 定义发送短信的接口
     </span>
    </h6>
    <pre><code class="language-java">public interface SmsService {
    String send(String message);
}
</code></pre>
    <h6 id="2.-%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E7%9A%84%E6%8E%A5%E5%8F%A3-2">
     <span style="color:#0d0016">
      2. 实现发送短信的接口
     </span>
    </h6>
    <pre><code class="language-java">public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
</code></pre>
    <h6 id="3.-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB">
     <span style="color:#0d0016">
      3. 定义一个 JDK 动态代理类
     </span>
    </h6>
    <pre><code class="language-java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class DebugInvocationHandler implements InvocationHandler {
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}
</code></pre>
    <h6 id="4.-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E5%8E%82%E7%B1%BB">
     <span style="color:#0d0016">
      4. 获取代理对象的工厂类
     </span>
    </h6>
    <pre><code class="language-java">import java.lang.reflect.Proxy;

public class JdkProxyFactory {
    public static Object getProxy(Object target) {
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new DebugInvocationHandler(target)
        );
    }
}
</code></pre>
    <h6 id="5.-%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8">
     <span style="color:#0d0016">
      5. 实际使用
     </span>
    </h6>
    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
        smsService.send("java");
    }
}
</code></pre>
    <p>
     <span style="color:#0d0016">
      运行上述代码之后，控制台打印出：
     </span>
    </p>
    <pre><code class="language-java">before method send
send message:java
after method send
</code></pre>
    <h4 id="3.3-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" style="background-color:transparent">
     <span style="color:#0d0016">
      3.3 CGLIB 动态代理
     </span>
    </h4>
    <h5 id="3.3.1-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83">
     <span style="color:#0d0016">
      3.3.1 CGLIB 动态代理的核心
     </span>
    </h5>
    <p>
     <span style="color:#0d0016">
      CGLIB 动态代理通过继承目标类来生成代理类，因此它可以代理未实现任何接口的类。CGLIB 的核心是
      <code>
       MethodInterceptor
      </code>
      接口和
      <code>
       Enhancer
      </code>
      类。
     </span>
    </p>
    <h5 id="3.3.2-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">
     <span style="color:#0d0016">
      3.3.2 CGLIB 动态代理的实现步骤
     </span>
    </h5>
    <blockquote>
     <ol>
      <li>
       <span style="color:#fe2c24">
        <strong>
         定义一个类
        </strong>
        ；
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         自定义
         <code>
          MethodInterceptor
         </code>
         并重写
         <code>
          intercept
         </code>
         方法
        </strong>
        ；
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         通过
         <code>
          Enhancer
         </code>
         类的
         <code>
          create()
         </code>
         方法创建代理类
        </strong>
        。
       </span>
      </li>
     </ol>
    </blockquote>
    <h5 id="3.3.3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
     <span style="color:#0d0016">
      3.3.3 代码示例
     </span>
    </h5>
    <h6 id="1.-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E7%9A%84%E7%B1%BB">
     <span style="color:#0d0016">
      1. 实现一个使用阿里云发送短信的类
     </span>
    </h6>
    <pre><code class="language-java">public class AliSmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
</code></pre>
    <h6 id="2.-%E8%87%AA%E5%AE%9A%E4%B9%89-methodinterceptor">
     <span style="color:#0d0016">
      2. 自定义
      <code>
       MethodInterceptor
      </code>
     </span>
    </h6>
    <pre><code class="language-java">import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class DebugMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        System.out.println("after method " + method.getName());
        return object;
    }
}
</code></pre>
    <h6 id="3.-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E7%B1%BB">
     <span style="color:#0d0016">
      3. 获取代理类
     </span>
    </h6>
    <pre><code class="language-java">import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {
    public static Object getProxy(Class&lt;?&gt; clazz) {
        Enhancer enhancer = new Enhancer();
        enhancer.setClassLoader(clazz.getClassLoader());
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(new DebugMethodInterceptor());
        return enhancer.create();
    }
}
</code></pre>
    <h6 id="4.-%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8-2">
     <span style="color:#0d0016">
      4. 实际使用
     </span>
    </h6>
    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
        aliSmsService.send("java");
    }
}
</code></pre>
    <p>
     <span style="color:#0d0016">
      运行上述代码之后，控制台打印出：
     </span>
    </p>
    <pre><code class="language-java">before method send
send message:java
after method send
</code></pre>
    <h3 id="4.-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94">
     <span style="color:#0d0016">
      4. 静态代理和动态代理的对比
     </span>
    </h3>
    <blockquote>
     <ul>
      <li>
       <span style="color:#fe2c24">
        <strong>
         灵活性
        </strong>
       </span>
       <span style="color:#0d0016">
        ：动态代理更加灵活，不需要针对每个目标类都创建一个代理类，且可以直接代理实现类。
       </span>
      </li>
      <li>
       <span style="color:#fe2c24">
        <strong>
         JVM 层面
        </strong>
       </span>
       <span style="color:#0d0016">
        ：静态代理在编译时生成 class 文件，而动态代理在运行时动态生成类字节码。
       </span>
      </li>
     </ul>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333830343736342f:61727469636c652f64657461696c732f313436323636323030" class_="artid" style="display:none">
 </p>
</div>


