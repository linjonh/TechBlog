---
layout: post
title: "HOT100系列普通数组矩阵"
date: 2025-03-12 20:45:32 +0800
description: "普通数组的操作较为简单，矩阵部分看K神的解体很有收获"
keywords: "HOT100系列——(普通数组+矩阵)"
categories: ['未分类']
tags: ['算法', 'Leetcode']
artid: "146055697"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146055697
    alt: "HOT100系列普通数组矩阵"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146055697
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146055697
cover: https://bing.ee123.net/img/rand?artid=146055697
image: https://bing.ee123.net/img/rand?artid=146055697
img: https://bing.ee123.net/img/rand?artid=146055697
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     HOT100系列——(普通数组+矩阵)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     普通数组
    </h2>
    <h3>
     1.合并区间
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/merge-intervals/" rel="nofollow" title="56. 合并区间">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        56. 合并区间
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
         https://leetcode.cn/problems/merge-intervals/
        </img>
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      先针对左区间进行排序，这样可以对右边进行考虑，如果intervals 中一个新的区间的左端点小于原ans的右端点，那么就能合并，右端点合并成原p【1】和新ans.get(nums - 1)[1]的最大值，否则没有交接，直接add进ans。
     </p>
    </blockquote>
    <p>
     <img alt="" height="124" src="https://i-blog.csdnimg.cn/direct/0b73cce931f946ceaddce9ac0ed4a818.png" width="421"/>
    </p>
    <p>
     <strong>
      补一下.toArray（）;方法，把将List&lt;&gt;(可变长度的有序列表)转为数组
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(p,q) -&gt; p[0] - q[0]);
        List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();
        for(int [] p :intervals){
            int nums = ans.size();
            if(nums &gt; 0 &amp;&amp; ans.get(nums -1)[1] &gt;= p[0]){
                //可以合并
                ans.get(nums - 1)[1] = Math.max(ans.get(nums - 1)[1],p[1]);
            }
            else{
                ans.add(p);
            }
        }
        return ans.toArray(new int[ans.size()][]);//返回一个object数组指定一下类型
    }
}</code></pre>
    <h3>
     2.轮转数组
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/rotate-array/" rel="nofollow" title="189. 轮转数组">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        189. 轮转数组
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
         https://leetcode.cn/problems/rotate-array/
        </img>
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      发现规律，如何反转，就是先把整体反转，然后以k为分界，0-k先反转，k-1到n -1再翻转，只需要写一个reverse函数就完事
     </p>
    </blockquote>
    <pre><code class="language-java">class Solution {
    public void rotate(int[] nums, int k) {
       k %= nums.length;
       reverse(nums,0,nums.length -1);
       reverse(nums,0,k -1);
       reverse(nums,k,nums.length -1); 
    }
    public void reverse(int []nums,int start,int end){
        while(start&lt;end){
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
        }
    }
}</code></pre>
    <p>
    </p>
    <h3>
     3.除自身以外数组的乘积
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/product-of-array-except-self/" rel="nofollow" title="238. 除自身以外数组的乘积">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        238. 除自身以外数组的乘积
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
         https://leetcode.cn/problems/product-of-array-except-self/
        </img>
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      不让用除法，如果让用，其实可以直接所有的前缀积，除以自身，但是不让用了，就用一手前缀积&amp;后缀积。非常巧妙,注意在算后缀积的时候，要×以前前缀积存到ans的东西
     </p>
    </blockquote>
    <pre><code class="language-java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int pre = 1;
        int suf = 1;
        int[] ans = new int[n];
        for(int i = 0; i &lt; n; ++i){
            ans[i] = pre;
            pre *= nums[i];
        }
        //注意后缀积的顺序不太一样
        for(int j = n - 1; j &gt;=0; --j){
            ans[j] *= suf;//这是×了以前存储的前缀积
            suf *= nums[j];
        }
        return ans;
    }
}</code></pre>
    <h3>
     4.缺失的第一个正数
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/first-missing-positive/" rel="nofollow" title="41. 缺失的第一个正数">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        41. 缺失的第一个正数
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
         https://leetcode.cn/problems/first-missing-positive/
        </img>
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      有点脑筋急转弯的一个题目，难点在于要求空间复杂度为1，所以哈希的方法不行
     </p>
     <p>
      学了一手原地哈希
     </p>
     <p>
      就是把这个nums数组直接看成一个哈希
     </p>
     <p>
      这个整体过程就是，把1放在下标为0的位置上，一直交换，最后遍历，看哪个不满足
     </p>
    </blockquote>
    <p>
     <img alt="" height="217" src="https://i-blog.csdnimg.cn/direct/ba5356d226b147c38831c5a5571884ac.png" width="729"/>
    </p>
    <pre><code class="language-java">class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for(int i = 0; i &lt; len; ++i){
            //这里if换成while是因为换完以后要接着换
            while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - 1] != nums[i]){
                //这个条件其实是有点绕的,将1放在下标为0的位置上
                swap(nums,i,nums[i] - 1);//所以就是i和nums[i] - 1来换
            }
        }
            for(int i = 0; i &lt; len; ++i){
                if(nums[i] != i + 1){
                    return i + 1;
                }
            }
            return len + 1;
    }
      private void swap(int[] nums,int first,int end){
            int temp = nums[first];
            nums[first] = nums[end];
            nums[end] = temp;
        }
}</code></pre>
    <blockquote>
     其实用一个Hashset也能过，但是空间复杂度是O(n)
    </blockquote>
    <pre><code class="language-java">class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
        for(int num : nums){
            hashSet.add(num);
        }
        for(int i = 1; i &lt;= n ;++i){
            if(!hashSet.contains(i))
                return i;
        }
        return n + 1;
    }
}</code></pre>
    <h2>
     矩阵
    </h2>
    <h3>
     1.矩阵置零
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/set-matrix-zeroes/" rel="nofollow" title="73. 矩阵置零">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        73. 矩阵置零
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
         https://leetcode.cn/problems/set-matrix-zeroes/
        </img>
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      使用两个标记数组boolen【】行何列各一个，如果一个点为0，把这一行和这一列都置为true，然后再重新遍历
     </p>
    </blockquote>
    <pre><code class="language-java">class Solution {
    public void setZeroes(int[][] matrix) {
       int m = matrix.length;
       int n = matrix[0].length;
       boolean[] row = new boolean[m];
       boolean[] col = new boolean[n];
       for(int i = 0; i &lt; m; ++i){
        for(int j = 0; j &lt; n; ++j){
        if(matrix[i][j] == 0){
            row[i] = col[j] = true;
        }
        }
       } 

       for(int i = 0;i &lt; m; ++i){
        for(int j = 0; j &lt; n; ++j){
            if(row[i] || col[j]){
                matrix[i][j] = 0;
            }
        }
       }
    }
}</code></pre>
    <h3>
     2.螺旋矩阵
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/spiral-matrix/" rel="nofollow" title="54. 螺旋矩阵">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        54. 螺旋矩阵
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7"/>
        https://leetcode.cn/problems/spiral-matrix/
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      这种螺旋矩阵的题都是类似的模拟问题，看了k神的题解，真的非常清晰比官解清晰的多得多
     </p>
    </blockquote>
    <p>
     <img alt="" height="642" src="https://i-blog.csdnimg.cn/direct/44131e2bdb2e41f4adac3ee657df95a7.png" width="891"/>
    </p>
    <pre><code class="language-java"> class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        if(matrix.length ==0){
            return new ArrayList&lt;Integer&gt;();
        }
        int l = 0,r = matrix[0].length -1,t = 0,b = matrix.length - 1,x  = 0;
        Integer[] res = new Integer[(r + 1) * (b + 1)];
        while(true){
            for(int i = l; i &lt;= r; i++) res[x++] = matrix[t][i];
            if(++t &gt; b)    break;
            for(int i = t; i &lt;= b; i++) res[x++] = matrix[i][r];
            if(--r &lt; l)    break;
            for(int i = r; i &gt;= l; i--) res[x++] = matrix[b][i];
            if(--b &lt; t)     break;
            for(int i = b; i &gt;= t; i--) res[x++] = matrix[i][l];
            if(++l &gt; r)     break;
        }
        return Arrays.asList(res);
    }
}</code></pre>
    <h3>
     <strong>
      3.旋转图像
     </strong>
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/rotate-image/" rel="nofollow" title="48. 旋转图像">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        48. 旋转图像
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7"/>
        https://leetcode.cn/problems/rotate-image/
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      这道题目对空间复杂度有要求，要求不能使用辅助矩阵
     </p>
    </blockquote>
    <p>
     先使用一下
     <strong>
      使用辅助矩阵
     </strong>
     的,重要的点是搞清楚映射公式
    </p>
    <p>
     <img alt="" height="183" src="https://i-blog.csdnimg.cn/direct/cffaf5e255af446691b30edd46e9024f.png" width="549"/>
    </p>
    <p>
     但是这个存在一个问题，就是说映射之后会使原始矩阵元素被覆盖，所以要克隆一个相同的辅助矩阵
    </p>
    <pre><code class="language-java">class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int [][] tmp = new int[n][n];
        for(int i = 0; i &lt; n; ++i){
            tmp[i] = matrix[i].clone();
        }
        for(int i = 0; i &lt; n; ++i){
            for(int j = 0; j &lt; n; ++j){
                matrix[j][n - 1 - i] = tmp[i][j];
            }
        }
    }
}</code></pre>
    <blockquote>
     <p>
      如果不做一个辅助矩阵，
     </p>
     <p>
      只要分别以矩阵左上角 1/4 的各元素为起始点执行以上旋转操作，即可完整实现矩阵旋转。
     </p>
     <p>
      具体来看，当矩阵大小 n 为偶数时，取前  2/n行、前  2/n  列的元素为起始点；当矩阵大小 n 为奇数时，取前  2/n 行、前  2/n+1 列的元素为起始点。
     </p>
    </blockquote>
    <pre><code class="language-java">class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for(int i = 0; i &lt; n/2; ++i){
            for(int j = 0; j &lt; (n +1) /2; ++j){
                //做一个临时变量
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = tmp;
            }
        }
    }
}</code></pre>
    <h3>
     4.搜索二维矩阵Ⅱ
    </h3>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/" rel="nofollow" title="240. 搜索二维矩阵 II">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        240. 搜索二维矩阵 II
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7"/>
        https://leetcode.cn/problems/search-a-2d-matrix-ii/
       </span>
      </span>
     </a>
    </p>
    <blockquote>
     <p>
      暴力的话就两遍遍历就能解决,时间复杂度就是O（mn）
     </p>
    </blockquote>
    <pre><code class="language-java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int[] row : matrix){
            for(int ele : row){
                if(ele == target){
                    return true;
                }
            }
        }
        return false;
    }
}</code></pre>
    <blockquote>
     <p>
      再次看了K神的解题，太夸张了，怎么能想到的，用到了从上到下递增和从左到右递增的性质
     </p>
     <p>
      把左下角这个数作为标志数flag
     </p>
     <p>
      若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。
      <br/>
      若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。
     </p>
    </blockquote>
    <pre><code class="language-java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        //从左下角开始
        int i = matrix.length - 1,j = 0;
        while(i &gt;= 0 &amp;&amp; j &lt; matrix[0].length){
            if(matrix[i][j] &gt; target) i--;
            else if(matrix[i][j] &lt; target) j++;
            else return true;
        }
        return false;
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f73686f7779302f:61727469636c652f64657461696c732f313436303535363937" class_="artid" style="display:none">
 </p>
</div>


