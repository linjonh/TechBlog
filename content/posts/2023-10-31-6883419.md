---
layout: post
title: "ARM11硬件编解码例程,实现视频的采集压缩以及传输显示"
date: 2023-10-31 16:12:56 +0800
description: "摘要：介绍基于华恒科技HHS3C6410平台，将摄像头采集的数据通过硬件编码后通过网络发送，客户端("
keywords: "arm 编码 画面合成"
categories: ['嵌入式Linux']
tags: ['网络', '嵌入式', 'Mfc', 'Linux', 'H', 'Cam']
artid: "6883419"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=6883419
    alt: "ARM11硬件编解码例程,实现视频的采集压缩以及传输显示"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=6883419
featuredImagePreview: https://bing.ee123.net/img/rand?artid=6883419
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ARM11硬件编解码例程,实现视频的采集压缩以及传输显示
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <span style="color:rgb(68,68,68); font-family:Verdana,Helvetica,Arial,sans-serif; line-height:19px; background-color:rgb(238,238,238)">
    </span>
    <div class="t_msgfontfix" style="word-wrap:break-word; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; line-height:22px; width:846px; min-height:100px">
     <table cellpadding="0" cellspacing="0" style="word-wrap:break-word; margin-top:5px; margin-right:0px; margin-bottom:0px; margin-left:1px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; empty-cells:show; border-collapse:collapse; line-height:22px; width:829px; table-layout:fixed; clear:both; float:left">
      <tbody style="word-wrap:break-word; line-height:22px">
       <tr style="word-wrap:break-word; line-height:22px">
        <td class="t_msgfont" id="postmessage_657657" style="word-wrap:break-word; color:rgb(68,68,68); font:normal normal normal 12px/1.6em Verdana,Helvetica,Arial,sans-serif; line-height:22px; clear:both; float:left; width:829px">
         摘要：介绍基于华恒科技HHS3C6410平台，将摄像头采集的
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          数据
         </span>
         通过硬件编码后通过
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          网络
         </span>
         发送，客户端(Linux)通过网络实时接收并显示的具体实现；主要介绍S3C6410的H264硬件编码特性和V4L2编程。
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         关键词：S3C6410 H.264
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          视频
         </span>
         监控 V4L2
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         0 引言
         <br style="word-wrap:break-word; line-height:normal"/>
         HHS3C6410是华恒科技推出的一款针对高性能手持
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          设备
         </span>
         和通用视频处理
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          应用
         </span>
         的低功率, 高性能的
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          嵌入式
         </span>
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          开发
         </span>
         板，采用三星S3C6410 ARM1176JZF-S处理器，最高主频可达667MHz；S3C6410内部集成的多媒体编解码器(MFC)支持mpeg4/h.263/h.264的编码与解码，并支持VC1解码，性能可以达到全双工30fps@640x480同时编解码和半双工30fps@720x480或25fps@720x576编解码。
         <br style="word-wrap:break-word; line-height:normal"/>
         H.264/AVC标准是一套兼顾广播和电信，覆盖从低码率
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          通信
         </span>
         到高清晰电视的广域标准，相比以前的标准，具有更高的压缩率，高质量图像，容错
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          功能
         </span>
         ，并有很强的网络适应性。
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         1 总体
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          设计
         </span>
         <br style="word-wrap:break-word; line-height:normal"/>
         监控
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          系统
         </span>
         由监控前端，监控终端，网络三部分组成，监控前端是一个嵌入式Linux系统，它通过S3C6410的Camera IF接收摄像头(SAA7113)采集的数据，并传送给硬件编解码(MFC)
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          模块
         </span>
         ，并把得到的经过H264压缩的数据打包发送到IP网络上，监控终端(Linux)通过网络接收数据包，经过解码实时播放。总体框架如图1:
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         图1. 总体框架图
         <br style="word-wrap:break-word; line-height:normal"/>
         整个嵌入式视频采集系统由
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          软件
         </span>
         和硬件两部分组成。硬件方面，以S3C6410处理器为核心通过Camera IF
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          接口
         </span>
         接收摄像头数据，经过MFC硬件编码后通过DM9000发送，UART作为开发
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          调试
         </span>
         接口；软件方面，引导
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          程序
         </span>
         和Linux内核，设备
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          驱动
         </span>
         程序形成基本的嵌入式运行环境，应用层负责视频采集，压缩及传输。
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         2 软件设计
         <br style="word-wrap:break-word; line-height:normal"/>
         软件设计包括嵌入式系统构建和应用软件两部分，其中嵌入式系统部分按照华恒科技S3C6410用户手册构建，其中包括了Bootloader，Linux内核，交叉
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          编译
         </span>
         器，驱动等；下面介绍应用软件设计：
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         监控前端：
         <br style="word-wrap:break-word; line-height:normal"/>
         监控前端主要包括视频采集模块和视频压缩编码模块。
         <br style="word-wrap:break-word; line-height:normal"/>
         视频采集模块使用V4L2接口收集摄像头数据到缓冲区中，视频压缩模块调用MFC驱动把YUV420数据压缩编码，同时可以指定编码参数。示例代码如下：
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         cam_fp = open(cam_name, O_RDWR);        //打开camera设备
         <br style="word-wrap:break-word; line-height:normal"/>
         ...
         <br style="word-wrap:break-word; line-height:normal"/>
         mfc_fd = open(MFC_DEV_NAME, O_RDWR|O_NDELAY);    //打开MFC设备
         <br style="word-wrap:break-word; line-height:normal"/>
         ...
         <br style="word-wrap:break-word; line-height:normal"/>
         addr = (char *) mmap(0,BUF_SIZE,PROT_READ | PROT_WRITE,MAP_SHARED,mfc_fd,0);        //mmap MFC
         <br style="word-wrap:break-word; line-height:normal"/>
         //
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          设置
         </span>
         编码参数
         <br style="word-wrap:break-word; line-height:normal"/>
         enc_init.in_width        =    out_width;
         <br style="word-wrap:break-word; line-height:normal"/>
         enc_init.in_height        =    out_height;
         <br style="word-wrap:break-word; line-height:normal"/>
         enc_init.in_frameRateRes    =    atoi(argv[2]);
         <br style="word-wrap:break-word; line-height:normal"/>
         enc_init.in_frameRateDiv    =    0;
         <br style="word-wrap:break-word; line-height:normal"/>
         enc_init.in_bitrate         =    atoi(argv[3]);
         <br style="word-wrap:break-word; line-height:normal"/>
         enc_init.in_gopNum        =    atoi(argv[4]);
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(mfc_fd, IOCTL_MFC_H264_ENC_INIT, &amp;enc_init);
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         frame_size  = (enc_init.in_width * enc_init.in_height * 3) &gt;&gt; 1;
         <br style="word-wrap:break-word; line-height:normal"/>
         //得到MFC
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          输入
         </span>
         缓冲区地址
         <br style="word-wrap:break-word; line-height:normal"/>
         get_buf_addr.in_usr_data = (int)addr;
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(mfc_fd, IOCTL_MFC_GET_FRAM_BUF_ADDR, &amp;get_buf_addr);
         <br style="word-wrap:break-word; line-height:normal"/>
         in_buf = (char *)get_buf_addr.out_buf_addr;
         <br style="word-wrap:break-word; line-height:normal"/>
         //得到MFC
         <span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">
          输出
         </span>
         缓冲区地址
         <br style="word-wrap:break-word; line-height:normal"/>
         get_buf_addr.in_usr_data = (int)addr;
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(mfc_fd, IOCTL_MFC_GET_LINE_BUF_ADDR, &amp;get_buf_addr);
         <br style="word-wrap:break-word; line-height:normal"/>
         out_buf = (char *)get_buf_addr.out_buf_addr;
         <br style="word-wrap:break-word; line-height:normal"/>
         //V4L2编程
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(cam_fp, VIDIOC_QUERYCAP, &amp;cap);
         <br style="word-wrap:break-word; line-height:normal"/>
         //选择输入/输出
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(cam_fp, VIDIOC_S_INPUT, &amp;index);
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(cam_fp, VIDIOC_S_OUTPUT, &amp;index);
         <br style="word-wrap:break-word; line-height:normal"/>
         //设置格式，注意必须设置输出为YUV420格式
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(cam_fp, VIDIOC_G_FBUF, &amp;fb);
         <br style="word-wrap:break-word; line-height:normal"/>
         fb.capability = cap.capabilities;
         <br style="word-wrap:break-word; line-height:normal"/>
         fb.fmt.width = out_width;
         <br style="word-wrap:break-word; line-height:normal"/>
         fb.fmt.height = out_height;
         <br style="word-wrap:break-word; line-height:normal"/>
         fb.fmt.pixelformat = V4L2_PIX_FMT_YUV420;
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(cam_fp, VIDIOC_S_FBUF, &amp;fb);
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         on = 1;
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(cam_fp, VIDIOC_OVERLAY, &amp;on);
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         while(1)
         <br style="word-wrap:break-word; line-height:normal"/>
         {
         <!-- -->
         <br style="word-wrap:break-word; line-height:normal"/>
         ...
         <br style="word-wrap:break-word; line-height:normal"/>
         //接收摄像头数据到MFC的输入缓冲区
         <br style="word-wrap:break-word; line-height:normal"/>
         read(cam_fp,  in_buf,  (out_width * out_height * 3 / 2));
         <br style="word-wrap:break-word; line-height:normal"/>
         //控制MFC开始编码
         <br style="word-wrap:break-word; line-height:normal"/>
         ioctl(mfc_fd, IOCTL_MFC_H264_ENC_EXE, &amp;enc_exe);
         <br style="word-wrap:break-word; line-height:normal"/>
         //把编码后帧的大小及数据发送出去
         <br style="word-wrap:break-word; line-height:normal"/>
         send(net_fd, &amp;enc_exe.out_encoded_size, 2, 0);
         <br style="word-wrap:break-word; line-height:normal"/>
         send(net_fd, out_buf, enc_exe.out_encoded_size, 0);
         <br style="word-wrap:break-word; line-height:normal"/>
         ...
         <br style="word-wrap:break-word; line-height:normal"/>
         }
         <br style="word-wrap:break-word; line-height:normal"/>
         把摄像头的输出直接设为MFC的输入可以节省一次内存操作。
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         监控终端：
         <br style="word-wrap:break-word; line-height:normal"/>
         监控终端是一台运行Linux的PC机，主要负责从网络接收压缩包，使用SDL和Avcodec解码并显示，示例代码如下：
         <br style="word-wrap:break-word; line-height:normal"/>
         ...
         <br style="word-wrap:break-word; line-height:normal"/>
         While(1)
         <br style="word-wrap:break-word; line-height:normal"/>
         {
         <!-- -->
         <br style="word-wrap:break-word; line-height:normal"/>
         ...
         <br style="word-wrap:break-word; line-height:normal"/>
         //接收压缩包
         <br style="word-wrap:break-word; line-height:normal"/>
         recv(sock_fd, &amp;size, 2, MSG_WAITALL);
         <br style="word-wrap:break-word; line-height:normal"/>
         recv(sock_fd, &amp;frame_buf[0], size, MSG_WAITALL);
         <br style="word-wrap:break-word; line-height:normal"/>
         //初始化avcodec
         <br style="word-wrap:break-word; line-height:normal"/>
         if (!pCodecCtx)
         <br style="word-wrap:break-word; line-height:normal"/>
         {
         <!-- -->
         <br style="word-wrap:break-word; line-height:normal"/>
         avcodec_init();
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx = avcodec_alloc_context();
         <br style="word-wrap:break-word; line-height:normal"/>
         avcodec_open(pCodecCtx, pCodec);
         <br style="word-wrap:break-word; line-height:normal"/>
         //设置参数
         <br style="word-wrap:break-word; line-height:normal"/>
         if (pCodec-&gt;capabilities &amp; CODEC_CAP_TRUNCATED)
         <br style="word-wrap:break-word; line-height:normal"/>
         {
         <!-- -->
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx-&gt;flags |=   CODEC_FLAG_TRUNCATED;
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx-&gt;height = 480;
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx-&gt;width  = 640;
         <br style="word-wrap:break-word; line-height:normal"/>
         }
         <br style="word-wrap:break-word; line-height:normal"/>
         pFrame = avcodec_alloc_frame();
         <br style="word-wrap:break-word; line-height:normal"/>
         avcodec_decode_video(pCodecCtx, pFrame, &amp;frame_finishd, sps_buf, sizeof(sps_buf));
         <br style="word-wrap:break-word; line-height:normal"/>
         //初始化SDL
         <br style="word-wrap:break-word; line-height:normal"/>
         SDL_Init(SDL_INIT_VIDEO);
         <br style="word-wrap:break-word; line-height:normal"/>
         screen = SDL_SetVideoMode (pCodecCtx-&gt;width, pCodecCtx-&gt;height, 0, 0);
         <br style="word-wrap:break-word; line-height:normal"/>
         yuv = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height, SDL_YV12_OVERLAY, screen);
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         SDL_WM_SetCaption(buf, "H264/TCP");
         <br style="word-wrap:break-word; line-height:normal"/>
         rect.y = rect.x = 0;
         <br style="word-wrap:break-word; line-height:normal"/>
         rect.w = pCodecCtx-&gt;width;
         <br style="word-wrap:break-word; line-height:normal"/>
         rect.h = pCodecCtx-&gt;height;
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         pict.data[0]     = yuv-&gt;pixels[0];
         <br style="word-wrap:break-word; line-height:normal"/>
         pict.data[1]     = yuv-&gt;pixels[2];
         <br style="word-wrap:break-word; line-height:normal"/>
         pict.data[2]     = yuv-&gt;pixels[1];
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         pict.linesize[0] = yuv-&gt;pitches[0];
         <br style="word-wrap:break-word; line-height:normal"/>
         pict.linesize[1] = yuv-&gt;pitches[2];
         <br style="word-wrap:break-word; line-height:normal"/>
         pict.linesize[2] = yuv-&gt;pitches[1];
         <br style="word-wrap:break-word; line-height:normal"/>
         }
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         if (pCodecCtx)
         <br style="word-wrap:break-word; line-height:normal"/>
         {
         <!-- -->
         <br style="word-wrap:break-word; line-height:normal"/>
         //解码视频流
         <br style="word-wrap:break-word; line-height:normal"/>
         avcodec_decode_video(pCodecCtx, pFrame, &amp;frame_finishd, frame_buf, size);
         <br style="word-wrap:break-word; line-height:normal"/>
         if (frame_finishd &amp;&amp; yuv)
         <br style="word-wrap:break-word; line-height:normal"/>
         {
         <!-- -->
         <br style="word-wrap:break-word; line-height:normal"/>
         SDL_LockYUVOverlay(yuv);
         <br style="word-wrap:break-word; line-height:normal"/>
         if ((!swsctx &amp;&amp; !(swsctx = sws_getContext(pCodecCtx-&gt;width,
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt,
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx-&gt;width,  pCodecCtx-&gt;height,
         <br style="word-wrap:break-word; line-height:normal"/>
         PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL))) ||
         <br style="word-wrap:break-word; line-height:normal"/>
         sws_scale(swsctx, pFrame-&gt;data, pFrame-&gt;linesize, 0,
         <br style="word-wrap:break-word; line-height:normal"/>
         pCodecCtx-&gt;height, pict.data, pict.linesize))
         <br style="word-wrap:break-word; line-height:normal"/>
         perror("sws ");
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         SDL_UnlockYUVOverlay (yuv);
         <br style="word-wrap:break-word; line-height:normal"/>
         //显示
         <br style="word-wrap:break-word; line-height:normal"/>
         SDL_DisplayYUVOverlay(yuv, &amp;rect);
         <br style="word-wrap:break-word; line-height:normal"/>
         }
         <br style="word-wrap:break-word; line-height:normal"/>
         }
         <br style="word-wrap:break-word; line-height:normal"/>
         }
         <br style="word-wrap:break-word; line-height:normal"/>
         以上程序编译需要libSDL, libavcodec, libswscale。
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         3 小结
         <br style="word-wrap:break-word; line-height:normal"/>
         本系统基于S3C6410实时采集，编码，传输数据，基本实现了视频监控的功能，测试采集，编码，传输VGA的图像可以达到25fps，使用多线程优化后应该可以更高，VGA分辨率图像经过H.264编码后平均每帧只有12k左右，占用网络带宽很少。
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         <br style="word-wrap:break-word; line-height:normal"/>
         参考文献
         <br style="word-wrap:break-word; line-height:normal"/>
         [1]    S3C6410X_UM_Rev1.10_080822.pdf
         <br style="word-wrap:break-word; line-height:normal"/>
         [2]    Video for Linux Two API Specification Revision 0.23.pdf
         <br style="word-wrap:break-word; line-height:normal"/>
         [3]    http://ffmpeg.mplayerhq.hu/
         <br style="word-wrap:break-word; line-height:normal"/>
        </td>
       </tr>
      </tbody>
     </table>
     <br/>
    </div>
    <div id="post_rate_div_657657" style="word-wrap:break-word; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; line-height:22px">
    </div>
   </div>
  </div>
 </article>
 <p alt="6874:7470733a2f2f626c6f672e6373646e2e6e65742f544a553335:352f61727469636c652f64657461696c732f36383833343139" class_="artid" style="display:none">
 </p>
</div>


