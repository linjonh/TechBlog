---
arturl_encode: "6874:7470733a2f2f626c6f672e6373646e2e6e65742f544a553335:352f61727469636c652f64657461696c732f36383833343139"
layout: post
title: "ARM11硬件编解码例程,实现视频的采集压缩以及传输显示"
date: 2023-10-31 16:12:56 +08:00
description: "摘要：介绍基于华恒科技HHS3C6410平台，将摄像头采集的数据通过硬件编码后通过网络发送，客户端("
keywords: "arm 编码 画面合成"
categories: ['嵌入式Linux']
tags: ['网络', '嵌入式', 'Mfc', 'Linux', 'H', 'Cam']
artid: "6883419"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=6883419
    alt: "ARM11硬件编解码例程,实现视频的采集压缩以及传输显示"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=6883419
featuredImagePreview: https://bing.ee123.net/img/rand?artid=6883419
---

# ARM11硬件编解码例程,实现视频的采集压缩以及传输显示

|  |
| --- |
| 摘要：介绍基于华恒科技HHS3C6410平台，将摄像头采集的 数据 通过硬件编码后通过 网络 发送，客户端(Linux)通过网络实时接收并显示的具体实现；主要介绍S3C6410的H264硬件编码特性和V4L2编程。     关键词：S3C6410 H.264 视频 监控 V4L2     0 引言   HHS3C6410是华恒科技推出的一款针对高性能手持 设备 和通用视频处理 应用 的低功率, 高性能的 嵌入式  开发 板，采用三星S3C6410 ARM1176JZF-S处理器，最高主频可达667MHz；S3C6410内部集成的多媒体编解码器(MFC)支持mpeg4/h.263/h.264的编码与解码，并支持VC1解码，性能可以达到全双工30fps@640x480同时编解码和半双工30fps@720x480或25fps@720x576编解码。   H.264/AVC标准是一套兼顾广播和电信，覆盖从低码率 通信 到高清晰电视的广域标准，相比以前的标准，具有更高的压缩率，高质量图像，容错 功能 ，并有很强的网络适应性。     1 总体 设计   监控 系统 由监控前端，监控终端，网络三部分组成，监控前端是一个嵌入式Linux系统，它通过S3C6410的Camera IF接收摄像头(SAA7113)采集的数据，并传送给硬件编解码(MFC) 模块 ，并把得到的经过H264压缩的数据打包发送到IP网络上，监控终端(Linux)通过网络接收数据包，经过解码实时播放。总体框架如图1:     图1. 总体框架图   整个嵌入式视频采集系统由 软件 和硬件两部分组成。硬件方面，以S3C6410处理器为核心通过Camera IF 接口 接收摄像头数据，经过MFC硬件编码后通过DM9000发送，UART作为开发 调试 接口；软件方面，引导 程序 和Linux内核，设备 驱动 程序形成基本的嵌入式运行环境，应用层负责视频采集，压缩及传输。     2 软件设计   软件设计包括嵌入式系统构建和应用软件两部分，其中嵌入式系统部分按照华恒科技S3C6410用户手册构建，其中包括了Bootloader，Linux内核，交叉 编译 器，驱动等；下面介绍应用软件设计：     监控前端：   监控前端主要包括视频采集模块和视频压缩编码模块。   视频采集模块使用V4L2接口收集摄像头数据到缓冲区中，视频压缩模块调用MFC驱动把YUV420数据压缩编码，同时可以指定编码参数。示例代码如下：     cam\_fp = open(cam\_name, O\_RDWR);        //打开camera设备   ...   mfc\_fd = open(MFC\_DEV\_NAME, O\_RDWR|O\_NDELAY);    //打开MFC设备   ...   addr = (char \*) mmap(0,BUF\_SIZE,PROT\_READ | PROT\_WRITE,MAP\_SHARED,mfc\_fd,0);        //mmap MFC   // 设置 编码参数   enc\_init.in\_width        =    out\_width;   enc\_init.in\_height        =    out\_height;   enc\_init.in\_frameRateRes    =    atoi(argv[2]);   enc\_init.in\_frameRateDiv    =    0;   enc\_init.in\_bitrate         =    atoi(argv[3]);   enc\_init.in\_gopNum        =    atoi(argv[4]);     ioctl(mfc\_fd, IOCTL\_MFC\_H264\_ENC\_INIT, &enc\_init);     frame\_size  = (enc\_init.in\_width \* enc\_init.in\_height \* 3) >> 1;   //得到MFC 输入 缓冲区地址   get\_buf\_addr.in\_usr\_data = (int)addr;   ioctl(mfc\_fd, IOCTL\_MFC\_GET\_FRAM\_BUF\_ADDR, &get\_buf\_addr);   in\_buf = (char \*)get\_buf\_addr.out\_buf\_addr;   //得到MFC 输出 缓冲区地址   get\_buf\_addr.in\_usr\_data = (int)addr;   ioctl(mfc\_fd, IOCTL\_MFC\_GET\_LINE\_BUF\_ADDR, &get\_buf\_addr);   out\_buf = (char \*)get\_buf\_addr.out\_buf\_addr;   //V4L2编程   ioctl(cam\_fp, VIDIOC\_QUERYCAP, &cap);   //选择输入/输出   ioctl(cam\_fp, VIDIOC\_S\_INPUT, &index);   ioctl(cam\_fp, VIDIOC\_S\_OUTPUT, &index);   //设置格式，注意必须设置输出为YUV420格式   ioctl(cam\_fp, VIDIOC\_G\_FBUF, &fb);   fb.capability = cap.capabilities;   fb.fmt.width = out\_width;   fb.fmt.height = out\_height;   fb.fmt.pixelformat = V4L2\_PIX\_FMT\_YUV420;   ioctl(cam\_fp, VIDIOC\_S\_FBUF, &fb);     on = 1;   ioctl(cam\_fp, VIDIOC\_OVERLAY, &on);     while(1)   {   ...   //接收摄像头数据到MFC的输入缓冲区   read(cam\_fp,  in\_buf,  (out\_width \* out\_height \* 3 / 2));   //控制MFC开始编码   ioctl(mfc\_fd, IOCTL\_MFC\_H264\_ENC\_EXE, &enc\_exe);   //把编码后帧的大小及数据发送出去   send(net\_fd, &enc\_exe.out\_encoded\_size, 2, 0);   send(net\_fd, out\_buf, enc\_exe.out\_encoded\_size, 0);   ...   }   把摄像头的输出直接设为MFC的输入可以节省一次内存操作。     监控终端：   监控终端是一台运行Linux的PC机，主要负责从网络接收压缩包，使用SDL和Avcodec解码并显示，示例代码如下：   ...   While(1)   {   ...   //接收压缩包   recv(sock\_fd, &size, 2, MSG\_WAITALL);   recv(sock\_fd, &frame\_buf[0], size, MSG\_WAITALL);   //初始化avcodec   if (!pCodecCtx)   {   avcodec\_init();   pCodecCtx = avcodec\_alloc\_context();   avcodec\_open(pCodecCtx, pCodec);   //设置参数   if (pCodec->capabilities & CODEC\_CAP\_TRUNCATED)   {   pCodecCtx->flags |=   CODEC\_FLAG\_TRUNCATED;   pCodecCtx->height = 480;   pCodecCtx->width  = 640;   }   pFrame = avcodec\_alloc\_frame();   avcodec\_decode\_video(pCodecCtx, pFrame, &frame\_finishd, sps\_buf, sizeof(sps\_buf));   //初始化SDL   SDL\_Init(SDL\_INIT\_VIDEO);   screen = SDL\_SetVideoMode (pCodecCtx->width, pCodecCtx->height, 0, 0);   yuv = SDL\_CreateYUVOverlay(pCodecCtx->width, pCodecCtx->height, SDL\_YV12\_OVERLAY, screen);     SDL\_WM\_SetCaption(buf, "H264/TCP");   rect.y = rect.x = 0;   rect.w = pCodecCtx->width;   rect.h = pCodecCtx->height;     pict.data[0]     = yuv->pixels[0];   pict.data[1]     = yuv->pixels[2];   pict.data[2]     = yuv->pixels[1];     pict.linesize[0] = yuv->pitches[0];   pict.linesize[1] = yuv->pitches[2];   pict.linesize[2] = yuv->pitches[1];   }     if (pCodecCtx)   {   //解码视频流   avcodec\_decode\_video(pCodecCtx, pFrame, &frame\_finishd, frame\_buf, size);   if (frame\_finishd && yuv)   {   SDL\_LockYUVOverlay(yuv);   if ((!swsctx && !(swsctx = sws\_getContext(pCodecCtx->width,   pCodecCtx->height, pCodecCtx->pix\_fmt,   pCodecCtx->width,  pCodecCtx->height,   PIX\_FMT\_YUV420P, SWS\_BICUBIC, NULL, NULL, NULL))) ||   sws\_scale(swsctx, pFrame->data, pFrame->linesize, 0,   pCodecCtx->height, pict.data, pict.linesize))   perror("sws ");     SDL\_UnlockYUVOverlay (yuv);   //显示   SDL\_DisplayYUVOverlay(yuv, &rect);   }   }   }   以上程序编译需要libSDL, libavcodec, libswscale。     3 小结   本系统基于S3C6410实时采集，编码，传输数据，基本实现了视频监控的功能，测试采集，编码，传输VGA的图像可以达到25fps，使用多线程优化后应该可以更高，VGA分辨率图像经过H.264编码后平均每帧只有12k左右，占用网络带宽很少。       参考文献   [1]    S3C6410X\_UM\_Rev1.10\_080822.pdf   [2]    Video for Linux Two API Specification Revision 0.23.pdf   [3]    http://ffmpeg.mplayerhq.hu/ |