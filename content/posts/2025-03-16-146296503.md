---
layout: post
title: "微服务分层架构技术解析从-API-到数据访问的全方位探秘"
date: 2025-03-16 15:58:07 +0800
description: "微服务分层架构技术解析：从 API 到数据访问的全方位探秘"
keywords: "微服务分层架构技术解析：从 API 到数据访问的全方位探秘"
categories: ['面试', '算法', 'Java']
tags: ['微服务', 'Java', 'Dubbo']
artid: "146296503"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296503
    alt: "微服务分层架构技术解析从-API-到数据访问的全方位探秘"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296503
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296503
cover: https://bing.ee123.net/img/rand?artid=146296503
image: https://bing.ee123.net/img/rand?artid=146296503
img: https://bing.ee123.net/img/rand?artid=146296503
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微服务分层架构技术解析：从 API 到数据访问的全方位探秘
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="b35dd547">
     微服务分层架构技术解析：从 API 到数据访问的全方位探秘
    </h2>
    <h3 id="df368884">
     前言
    </h3>
    <p id="ucfa939b3">
     在当今复杂多变的软件开发领域，微服务架构已成为构建大型分布式系统的核心范式。它通过将系统分解为一组小型、独立且高度内聚的服务，实现了模块化开发、独立部署与扩展，从而显著提升了系统的可维护性、可扩展性和灵活性。本系列文章深入剖析微服务架构的各个关键层面，从 API 层的设计原则与最佳实践，到业务逻辑层的服务解耦与协作模式，再到数据访问层的高效数据处理与持久化策略，全方位揭示微服务系统的设计精髓与技术细节。无论是初涉微服务的开发新手，还是渴望深化架构理解的技术专家，都能从本文中获取宝贵的知识与洞见，助力您在微服务架构的实践中游刃有余，构建出高效、稳定、可扩展的软件系统。
    </p>
    <p id="ub566782d">
    </p>
    <h2 id="IyzVS">
     api 层
    </h2>
    <p id="uf5c786e8">
    </p>
    <p id="u7b9dad8b">
     该代码片段中的两个 Lombok 注解在订单状态枚举类中起到以下核心作用：
    </p>
    <pre id="RelPf"><code>@RequiredArgsConstructor  // 自动生成包含所有 final 字段的构造函数
@Getter                     // 自动生成所有字段的 getter 方法</code></pre>
    <p id="u79643d21">
     <strong>
      具体作用说明
     </strong>
     ：
    </p>
    <ol>
     <li id="uf3dc1d80">
      <strong>
       @RequiredArgsConstructor
      </strong>
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="u374ed783">
        自动生成包含
        <code>
         type
        </code>
        和
        <code>
         name
        </code>
        两个字段的构造函数
       </li>
       <li id="u9c10013a">
        使枚举实例的初始化更简洁（示例）：
       </li>
      </ul>
     </li>
    </ul>
    <pre id="UiQ06"><code>WAITING_FOR_PAYMENT(0, "待支付")  // 实际调用构造函数</code></pre>
    <ol>
     <li id="u23142b1a">
      <strong>
       @Getter
      </strong>
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="u8d1e0b63">
        自动生成
        <code>
         getType()
        </code>
        和
        <code>
         getName()
        </code>
        方法
       </li>
       <li id="u639ab356">
        在业务代码中可直接调用（示例）：
       </li>
      </ul>
     </li>
    </ul>
    <pre id="mn4lU"><code>OrderOrderStatusEnum status = ...;
Integer type = status.getType();  // 获取状态码
String name = status.getName();   // 获取中文描述</code></pre>
    <p id="uc5fb2276">
     <strong>
      设计亮点
     </strong>
     ：
    </p>
    <ul>
     <li id="uc9df9475">
      通过注解替代样板代码，使枚举类更简洁
     </li>
     <li id="u022d7224">
      便于与其他模块交互（如状态码与数据库字段映射）
     </li>
     <li id="u15ae2504">
      提升代码可维护性（新增状态只需添加枚举项，无需修改方法）
     </li>
    </ul>
    <p id="u38f59fa7">
     <strong>
      注意事项
     </strong>
     ：
    </p>
    <ul>
     <li id="u257c9eca">
      枚举构造函数默认是
      <code>
       private
      </code>
      ，Lombok 在此场景下会自动处理访问权限
     </li>
     <li id="u678fe99a">
      枚举字段必须声明为
      <code>
       final
      </code>
      才能配合
      <code>
       @RequiredArgsConstructor
      </code>
      使用
     </li>
    </ul>
    <p id="u87ddfd3f">
    </p>
    <p id="ued6e0d7e">
    </p>
    <h3 id="aU6fr">
     public static final Integer[] ARRAYS = Arrays.stream(values()).map(OrderOrderTypeEnum::getType).toArray(Integer[]::new);
    </h3>
    <p id="u38348d53">
    </p>
    <p id="u2c1c79fb">
     这段代码的作用是生成包含所有订单类型枚举值的数组，以下是具体分析：
    </p>
    <pre id="AYvtJ"><code>public static final Integer[] ARRAYS = Arrays.stream(values())  // 获取所有枚举实例
    .map(OrderOrderTypeEnum::getType)   // 提取 type 字段值
    .toArray(Integer[]::new);          // 转换为 Integer 数组</code></pre>
    <p id="u7f3adc0b">
     <strong>
      三个核心作用
     </strong>
     ：
    </p>
    <ol>
     <li id="ud3e7edf6">
      <strong>
       统一枚举值管理
      </strong>
      <br/>
      自动收集所有枚举项的
      <code>
       type
      </code>
      值（0/1/2/3），避免手动维护数组
     </li>
     <li id="uc3aef3f0">
      <strong>
       支持框架接口实现
      </strong>
      <br/>
      为
      <code>
       ArrayValuable
      </code>
      接口提供数据源，实现以下方法时会直接返回该数组：
     </li>
    </ol>
    <pre id="UGe1m"><code>public Integer[] array() {
    return ARRAYS; // 返回 [0,1,2,3]
}</code></pre>
    <ol>
     <li id="u6f171322">
      <strong>
       业务应用场景
      </strong>
     </li>
    </ol>
    <pre id="GFitS"><code>// 前端下拉框选项
List&lt;CommonOptionRespVO&gt; options = Arrays.stream(OrderOrderTypeEnum.ARRAYS)
    .map(type -&gt; new CommonOptionRespVO(type, getNameByType(type)))
    .collect(Collectors.toList());

// 数据库查询校验
if (!ArrayUtils.contains(OrderOrderTypeEnum.ARRAYS, queryType)) {
    throw exception(ORDER_TYPE_NOT_EXISTS);
}</code></pre>
    <p id="u66c0d85e">
     <strong>
      设计优势
     </strong>
     ：
    </p>
    <ul>
     <li id="u27764617">
      自动同步：新增枚举项时数组自动更新
     </li>
     <li id="u5bde8bc0">
      类型安全：避免硬编码数字带来的错误
     </li>
     <li id="u5b15cfad">
      统一出口：所有类型值通过唯一入口获取
     </li>
    </ul>
    <p id="u372948cb">
     <strong>
      注意点
     </strong>
     ：枚举项 Route 的命名建议改为全大写 ROUTE 保持命名规范
    </p>
    <p id="ud950735e">
    </p>
    <p id="u020a3210">
    </p>
    <p id="ud34dc619">
    </p>
    <h3 id="UMKSI">
     apiconstants 详细分析
    </h3>
    <p id="u354b6619">
    </p>
    <p id="u954d980e">
     我将从 API 配置管理的角度解析该类的设计意图和实际应用：
    </p>
    <h4 id="pFsbU">
     核心作用分析
    </h4>
    <pre id="xD0u1"><code>public class ApiConstants {
    // 服务注册与发现标识（需与 application.yml 中 spring.application.name 一致）
    public static final String NAME = "ticket-server";

    // RPC 接口统一前缀（示例：最终路径为 /rpc/api/resource/xxx）
    public static final String PREFIX = RpcConstants.RPC_API_PREFIX + "/resource";

    // 接口版本标识（用于灰度发布）
    public static final String VERSION = "1.0.0";
}</code></pre>
    <h4 id="sz2zG">
     各常量使用场景
    </h4>
    <ol>
     <li id="u0a0bb575">
      <strong>
       NAME 常量
      </strong>
     </li>
    </ol>
    <pre id="P7DV7"><code># 应用配置示例
spring:
  application:
    name: #{ApiConstants.NAME}  # 实际会被替换为 ticket-server
  cloud:
    nacos:
      discovery:
        service: ${spring.application.name}</code></pre>
    <ol>
     <li id="uc1d0b339">
      <strong>
       PREFIX 常量
      </strong>
     </li>
    </ol>
    <pre id="UwzKl"><code>// 接口路径统一管理示例
@RestController
@RequestMapping(ApiConstants.PREFIX + "/order")
public class TicketOrderController {
    @GetMapping("/get") // 完整路径：/rpc/api/resource/order/get
    public CommonResult&lt;OrderVO&gt; getOrder() { ... }
}</code></pre>
    <ol>
     <li id="u09478841">
      <strong>
       VERSION 常量
      </strong>
     </li>
    </ol>
    <pre id="Ro8P0"><code>// Feign 客户端版本控制
@FeignClient(name = ApiConstants.NAME, url = "${yudao.service.url}", 
    configuration = FeignConfiguration.class,
    contextId = "ticketResourceApi")
public interface TicketResourceApi {

    @GetMapping(value = "/version", headers = "API-VERSION=" + ApiConstants.VERSION)
    String getVersion();
}</code></pre>
    <h4 id="ms9VO">
     设计优势
    </h4>
    <ol>
     <li id="u1ff9e494">
      <strong>
       集中管理
      </strong>
      ：避免配置散落在多处
     </li>
     <li id="u955be2e7">
      <strong>
       命名规范
      </strong>
      ：统一服务标识和接口路径
     </li>
     <li id="ue1116a11">
      <strong>
       可维护性
      </strong>
      ：修改服务名只需改动常量值
     </li>
     <li id="ubb51c99a">
      <strong>
       可读性
      </strong>
      ：常量名称自解释（优于直接使用字符串）
     </li>
    </ol>
    <h4 id="VNdxw">
     扩展建议
    </h4>
    <p id="u6e0b873a">
     如需新增配置项可参考以下模式：
    </p>
    <pre id="UY4E4"><code>// 新增示例
public static final String CACHE_PREFIX = "ticket:resource";
public static final int MAX_RETRY_TIMES = 3;</code></pre>
    <p id="uadbdcfd7">
    </p>
    <p id="ud7a60ee3">
    </p>
    <p id="u1a169fa7">
    </p>
    <h3 id="MdGeQ">
     DictTypeConstants.java
    </h3>
    <p id="udb273c71">
    </p>
    <p id="u1ad27faa">
     我将从字典管理的角度解析该接口的设计意图和实际应用：
    </p>
    <h4 id="WD8sj">
     核心作用分析
    </h4>
    <pre id="gBVWK"><code>public interface DictTypeConstants {
    // 订单模块 - 订单类型（对应字典表的数据）
    String ORDER_MODULE_ORDER_TYPE = "order_module_order_type";
    // ...其他字典类型常量
}</code></pre>
    <h4 id="yPQif">
     具体应用场景
    </h4>
    <ol>
     <li id="uc8e21bd2">
      <strong>
       后端数据查询
      </strong>
     </li>
    </ol>
    <pre id="YO3iC"><code>// 查询订单类型字典数据
List&lt;DictData&gt; orderTypes = dictDataService.getDictData(DictTypeConstants.ORDER_MODULE_ORDER_TYPE);</code></pre>
    <ol>
     <li id="ua7355fc5">
      <strong>
       前端选项渲染
      </strong>
     </li>
    </ol>
    <pre id="Cp2ON"><code>// 前端通过接口获取字典选项
@GetMapping("/dict-data/list")
public CommonResult&lt;List&lt;DictDataRespVO&gt;&gt; listDictData(@RequestParam String dictType) {
    // 例如传入 ORDER_MODULE_PAYMENT_METHOD 获取支付方式选项
}</code></pre>
    <ol>
     <li id="u616efa45">
      <strong>
       数据校验
      </strong>
     </li>
    </ol>
    <pre id="ED8ka"><code>// 校验支付方式是否合法
if (!DictTypeConstants.ORDER_MODULE_PAYMENT_METHOD.equals(paymentMethod.getDictType())) {
    throw exception(PAYMENT_METHOD_INVALID);
}</code></pre>
    <h4 id="HuQad">
     数据结构示例
    </h4>
    <h3 id="LYm6z">
     <strong>
      字典表数据示例
     </strong>
     ：
     <br/>
     ```text
     <br/>
     dict_type | dict_value | dict_label
    </h3>
    <p id="u28a3c49b">
     order_module_order_type | 0 | 普通订单
     <br/>
     order_module_order_type | 1 | 团购订单
     <br/>
     order_module_order_type | 2 | 秒杀订单
    </p>
    <pre id="rKQlQ"><code>
### 设计优势
1. **统一管理**：避免字典类型硬编码
2. **强类型约束**：编译时检查替代字符串拼写错误
3. **模块化隔离**：通过模块前缀避免字典类型冲突
4. **可维护性**：新增字典类型只需添加常量

### 扩展建议
如需新增字典类型可参考以下模式：
```java
// 新增退票原因字典类型
String ORDER_MODULE_REFUND_REASON = "order_module_refund_reason";</code></pre>
    <p id="u6b155b0a">
     该设计通过预定义字典类型常量，实现了业务字典的标准化管理，是典型的高可维护性解决方案。
    </p>
    <p id="u0227f0b5">
    </p>
    <p id="ue37ce21a">
    </p>
    <p id="u7f0500a7">
    </p>
    <h2 id="hFwXY">
     Biz 层
    </h2>
    <p id="u66db18d5">
    </p>
    <p id="uf2dc0484">
     重点看服务解耦那块分层
    </p>
    <p id="uda2bb864">
    </p>
    <p>
     此处为语雀内容卡片，点击链接查看：
     <a href="https://www.yuque.com/hunshazhao-kxzhf/vnt2dy/xe9tc961usm4cl76" rel="nofollow" title="https://www.yuque.com/hunshazhao-kxzhf/vnt2dy/xe9tc961usm4cl76">
      https://www.yuque.com/hunshazhao-kxzhf/vnt2dy/xe9tc961usm4cl76
     </a>
    </p>
    <p id="u9046057f">
    </p>
    <p id="uf9d7b14e">
    </p>
    <h3 id="z3ixz">
     biz层中详细每个分层的分析
    </h3>
    <h4 id="idPtw">
     1. 框架层（Framework Layer）
    </h4>
    <ul>
     <li id="uf7734807">
      <strong>
       功能与技术点配置
      </strong>
      ：作为整个系统的基础，需先搭建好 Spring Security、Feign、JWT 等配置，为系统提供安全和通信支持。
     </li>
    </ul>
    <ul>
     <li>
      <ul>
       <li id="u50a29591">
        <strong>
         Spring Security 配置
        </strong>
        ：定义安全策略，如基于角色的访问控制，配置用户认证和授权方式。
       </li>
       <li id="u5d20e83c">
        <strong>
         Feign 客户端配置
        </strong>
        ：设置超时时间、重试机制等，确保服务间远程调用的稳定性和可靠性。
       </li>
       <li id="udd08664b">
        <strong>
         JWT 配置
        </strong>
        ：实现用户令牌的生成和解析，确保用户身份在无状态分布式环境中安全传递。
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li id="u54314930">
      <strong>
       联动方式实现
      </strong>
      ：通过过滤器或拦截器检查请求中的认证信息，确保请求的合法性和安全性。
     </li>
    </ul>
    <p id="ub0246055">
    </p>
    <p class="img-center">
     <img alt="" height="251" id="u51459f15" src="https://i-blog.csdnimg.cn/img_convert/ba75817a1475582d057a5be74c645c91.png" width="309"/>
    </p>
    <p id="uca0cfe7d">
    </p>
    <p id="u0ff3f15f">
    </p>
    <p id="ua991bd35">
     分模块解析 ticket 模块的 framework 框架层设计，首先分析安全配置部分：
    </p>
    <p id="u636c4ed6">
    </p>
    <h5 id="NaPqX">
     1. 安全配置模块 (security)
    </h5>
    <p id="uff5475fc">
    </p>
    <pre id="A7Voo"><code>@Configuration("resourceSecurityConfiguration")
public class SecurityConfiguration {
    
    @Bean("resourceAuthorizeRequestsCustomizer")
    public AuthorizeRequestsCustomizer authorizeRequestsCustomizer() {
        return new AuthorizeRequestsCustomizer() {
            @Override
            public void customize(registry) {
                // Swagger 文档
                registry.requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/swagger-ui.html").permitAll()
                // SpringBoot Actuator
                registry.requestMatchers("/actuator/**").permitAll()
                // RPC 接口
                registry.requestMatchers(ApiConstants.PREFIX + "/**").authenticated();
            }
        };
    }
}</code></pre>
    <p id="u8c6f2bb2">
     <strong>
      核心作用
     </strong>
     ：
    </p>
    <ul>
     <li id="uddddd2f0">
      定义模块专属安全策略（与其他模块隔离）
     </li>
     <li id="uc4b7c73b">
      开放 Swagger/Actuator 端点无需认证
     </li>
     <li id="u34134397">
      限制
      <code>
       /resource
      </code>
      前缀接口必须认证
     </li>
     <li id="u5f17cb3a">
      通过
      <code>
       @Configuration("resourceSecurityConfiguration")
      </code>
      实现多模块安全配置共存
     </li>
    </ul>
    <h5 id="o4v6y">
     2. RPC 配置模块 (rpc)
    </h5>
    <p id="uc7cb2f91">
    </p>
    <pre id="rhhh9"><code>@Configuration(proxyBeanMethods = false)
@EnableFeignClients(clients = AdminUserApi.class)
public class RpcConfiguration {
}</code></pre>
    <p id="u1906b991">
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li id="u7eb7a368">
      精准控制 Feign 客户端扫描范围（避免全包扫描）
     </li>
     <li id="u3e01b3df">
      集成系统模块的用户服务 API（AdminUserApi）
     </li>
     <li id="u159df716">
      <code>
       proxyBeanMethods = false
      </code>
      提升启动速度
     </li>
    </ul>
    <h5 id="XmVwW">
     3. 常量配置模块
    </h5>
    <p id="u1304dc34">
    </p>
    <pre id="tMJ5u"><code>public class ApiConstants {
    public static final String NAME = "ticket-server";
    public static final String PREFIX = RpcConstants.RPC_API_PREFIX + "/resource";
}</code></pre>
    <p id="u0b78a21b">
     <strong>
      跨模块应用
     </strong>
     ：
    </p>
    <ul>
     <li id="u15529834">
      服务注册发现（NAME 对应 Nacos 服务名）
     </li>
     <li id="uede32c7d">
      安全配置（PREFIX 用于接口权限控制）
     </li>
     <li id="ub378afbb">
      Feign 客户端标识（name = ApiConstants.NAME）
     </li>
    </ul>
    <p id="u65bace65">
    </p>
    <h5 id="DxQJE">
     4. 数据翻译模块 (easy-trans)
    </h5>
    <p id="u9f71d4f4">
     通过 application.yaml 配置实现全局翻译：
    </p>
    <pre id="y6gJm"><code>easy-trans:
  is-enable-global: true # 启用全局翻译（拦截所有 SpringMVC ResponseBody）</code></pre>
    <p id="u19b6c0ad">
     <strong>
      业务应用示例
     </strong>
     ：
     <br/>
    </p>
    <pre id="Fy8nD"><code>public class TicketOrderInfoRespVO {
    @Trans(type = TransType.DICTIONARY, key = DictTypeConstants.ORDER_MODULE_ORDER_TYPE)
    private Integer orderType; // 自动转换为 "普通订单"/"团购订单"
}</code></pre>
    <p id="u7030c918">
     <strong>
      核心价值
     </strong>
     ：
    </p>
    <ul>
     <li id="u449d469f">
      自动将数据字典值转换为前端可读标签
     </li>
     <li id="u0bb143c3">
      减少 Controller 层的转换代码
     </li>
     <li id="uefa98b5b">
      支持 Redis 缓存字典数据提升性能
     </li>
    </ul>
    <h5 id="cpYlI">
     5. 缓存策略模块
    </h5>
    <p id="u15479151">
     <strong>
      Redis 配置示例
     </strong>
     ：
    </p>
    <pre id="aeMpR"><code>spring:
  data:
    redis:
      host: 127.0.0.1
      port: 6379
      password: 282312
      database: 0</code></pre>
    <p id="ua8dab65b">
     <strong>
      缓存应用模式
     </strong>
     ：
    </p>
    <pre id="jvuYG"><code>@Service
public class TicketOrderServiceImpl implements TicketOrderService {
    
    // 方法结果缓存
    @Cacheable(value = "ticketOrder", key = "#id")
    public TicketOrderInfoDO getOrder(Long id) {
        return mapper.selectById(id);
    }
    
    // 缓存更新
    @CacheEvict(value = "ticketOrder", key = "#order.id")
    public void updateOrder(TicketOrderInfoDO order) {
        mapper.updateById(order);
    }
}</code></pre>
    <h5 id="ZQmSV">
     6. 监控模块
    </h5>
    <p id="u4a1e90c3">
     通过 starter 集成多种监控能力：
    </p>
    <pre id="RpZKF"><code>&lt;dependency&gt;
    &lt;groupId&gt;cn.iocoder.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;yudao-spring-boot-starter-monitor&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
    <p id="uf8774de8">
     <strong>
      监控维度
     </strong>
     ：
    </p>
    <ol>
     <li id="u39aa58cf">
      Spring Boot Actuator 端点（健康检查、metrics）
     </li>
     <li id="u9169df23">
      Prometheus 格式指标采集
     </li>
     <li id="u0f7f660a">
      SkyWalking GRPC 日志收集（分布式追踪）
     </li>
    </ol>
    <pre id="h45YR"><code>&lt;appender name="GRPC" class="org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;${PATTERN_DEFAULT}&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre>
    <p id="u68abd3fc">
    </p>
    <h5 id="Bxbi3">
     7. 定时任务模块
    </h5>
    <p id="u6fe5caf2">
     <strong>
      配置示例
     </strong>
     （基于 XXL-JOB）：
    </p>
    <pre id="X1MFL"><code>xxl:
  job:
    admin: 
      addresses: http://127.0.0.1:9080/xxl-job-admin
    executor:
      appname: ticket-server
      port: 9998</code></pre>
    <p id="u48e54608">
     <strong>
      任务处理器示例
     </strong>
     ：
    </p>
    <pre id="FFE3u"><code>@JobHandler(name = "orderStatusSyncJob")
@Component
public class OrderStatusSyncJob extends IJobHandler {

    @XxlJob("syncOrderStatus")
    public ReturnT&lt;String&gt; execute(String param) {
        // 同步第三方订单状态
        return SUCCESS;
    }
}</code></pre>
    <h5 id="fZcdf">
     8. 消息队列模块
    </h5>
    <p id="uaef57d02">
     <strong>
      配置示例
     </strong>
     （基于 RocketMQ）：
    </p>
    <pre id="N2aEb"><code>rocketmq:
  name-server: 127.0.0.1:9876
  producer:
    group: ticket-group</code></pre>
    <p id="u8d36786d">
     <strong>
      消息监听示例
     </strong>
     ：
    </p>
    <pre id="OD6BD"><code>@RocketMQMessageListener(
    topic = "ORDER_TOPIC", 
    consumerGroup = "ticket-order-group",
    selectorExpression = "order_create"
)
@Component
public class OrderCreateConsumer implements RocketMQListener&lt;OrderCreateMessage&gt; {
    
    @Override
    public void onMessage(OrderCreateMessage message) {
        // 处理订单创建消息
    }
}</code></pre>
    <p id="u061f4358">
    </p>
    <h5 id="eojUd">
     9. 数据权限模块
    </h5>
    <p id="ue70cab78">
     <strong>
      实现原理
     </strong>
     （基于 MyBatis 拦截器）：
    </p>
    <pre id="ppTxh"><code>@Bean
public DataPermissionDatabaseInterceptor dataPermissionDatabaseInterceptor(
        @Value("${central.data-permission.enable:true}") Boolean enable) {
    return new DataPermissionDatabaseInterceptor(enable);
}</code></pre>
    <p id="ub8339bb7">
     <strong>
      业务应用示例
     </strong>
     ：
     <br/>
    </p>
    <pre id="LFQxt"><code>@DataPermission(
    deptColumn = "create_dept",  // 部门字段
    userIdColumn = "create_user" // 用户字段
)
public class TicketOrderInfoPageReqVO extends PageParam {
    // 查询条件自动追加数据权限过滤
}</code></pre>
    <p id="u61fa8617">
     <strong>
      SQL 自动改写效果
     </strong>
     ：
    </p>
    <pre id="VOWSc"><code>/* 原始 SQL */
SELECT * FROM order_ticket_order_info WHERE cenic_spots_id = ?

/* 改写后 SQL */
SELECT * FROM order_ticket_order_info 
WHERE cenic_spots_id = ? 
  AND create_dept IN (当前用户部门及子部门)
  AND create_user = 当前用户ID</code></pre>
    <h5 id="JTGdr">
     10. 工作流模块
    </h5>
    <p id="u06c1b09a">
     <strong>
      流程定义示例
     </strong>
     （退款审批流程）：
    </p>
    <pre id="MMRcE"><code>&lt;process id="refundAudit" name="退款审批流程"&gt;
    &lt;startEvent id="start"/&gt;
    &lt;userTask id="leaderAudit" name="主管审批"/&gt;
    &lt;exclusiveGateway id="exclusiveGw"/&gt;
    &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="leaderAudit"/&gt;
    &lt;sequenceFlow id="flow2" sourceRef="leaderAudit" targetRef="exclusiveGw"/&gt;
    &lt;sequenceFlow id="flow3" sourceRef="exclusiveGw" targetRef="end"&gt;
        &lt;conditionExpression xsi:type="tFormalExpression"&gt;
            ${refundAmount &lt;= 1000}
        &lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;
&lt;/process&gt;
</code></pre>
    <p id="u7c1a05f0">
     <strong>
      业务集成代码
     </strong>
     ：
    </p>
    <pre id="sIMOV"><code>@Transactional(rollbackFor = Exception.class)
public void applyRefund(Long refundId) {
    // 启动流程实例
    BpmProcessInstanceCreateReqDTO reqDTO = new BpmProcessInstanceCreateReqDTO();
    reqDTO.setProcessDefinitionKey("refundAudit");
    reqDTO.setBusinessKey(String.valueOf(refundId));
    String processInstanceId = bpmProcessInstanceApi.createProcessInstance(reqDTO);
    
    // 更新业务记录状态
    refundMapper.updateProcessInstanceIdById(refundId, processInstanceId);
}</code></pre>
    <p id="ua5454f12">
    </p>
    <p id="u2fb96ae8">
    </p>
    <p id="uffc37192">
    </p>
    <h4 id="vLKlE">
     2. 数据访问层（Data Access Layer - DAL）
    </h4>
    <ul>
     <li id="u8b12ebd5">
      <strong>
       功能与技术点实现
      </strong>
      ：负责数据存储与访问，包含 DataObject、MySQL 和 Redis 三部分。
     </li>
    </ul>
    <ul>
     <li>
      <ul>
       <li id="uf7ddb6ba">
        <strong>
         实体类定义
        </strong>
        ：使用 MyBatis Plus 定义数据库实体类（DataObject），映射数据库表结构。
       </li>
       <li id="u93f39d38">
        <strong>
         Mapper 接口与 XML 文件编写
        </strong>
        ：编写 Mapper 接口和对应的 XML 文件，定义 SQL 语句，实现数据库操作。
       </li>
       <li id="u053ba3d7">
        <strong>
         RedisTemplate 配置
        </strong>
        ：配置 RedisTemplate，实现与 Redis 的交互，支持多种数据结构存储查询。
       </li>
       <li id="u7775cf4c">
        <strong>
         事务管理配置
        </strong>
        ：结合 Spring 的事务管理器，确保数据操作一致性。
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li id="u1a6880b5">
      <strong>
       联动方式实现
      </strong>
      ：通过 MyBatis Plus 的 Mapper 接口与 MySQL 数据库交互，执行 SQL 语句完成数据操作。对于 Redis 缓存操作，使用 RedisTemplate 进行数据的存取和过期设置。在数据查询时，优先从 Redis 缓存中获取数据，若缓存不存在则查询 MySQL 数据库，并将查询结果缓存到 Redis 中。
     </li>
    </ul>
    <p id="u428c1f70">
    </p>
    <p id="u1ab7eebc">
    </p>
    <p class="img-center">
     <img alt="" height="245" id="u019043cf" src="https://i-blog.csdnimg.cn/img_convert/6996ab6d14d4de06c3d6a3734446e45a.png" width="351"/>
    </p>
    <p id="ub60e3488">
    </p>
    <p id="u4047bbbe">
    </p>
    <p id="uaea05501">
     我将从数据访问层的角度，解析 ticket 模块的 DAL 结构设计：
    </p>
    <h5 id="EAtRP">
     核心结构概览
    </h5>
    <pre id="xLAfN"><code>central-module-ticket-biz/src/main/java/cn/iocoder/central/module/ticket/dal/
├─ dataobject/          # 持久化对象
│  ├─ ticketinfo/       # 门票核心业务DO
│  │  └─ TicketOrderInfoDO.java
├─ mysql/               # MyBatis Mapper 接口
│  ├─ ticketinfo/
│  │  └─ TicketOrderInfoMapper.java
└─ redis/               # Redis 缓存操作（当前为占位设计）</code></pre>
    <h5 id="RJUC3">
     核心组件解析
    </h5>
    <h5 id="SjPdY">
     1. 数据对象（DataObject）
    </h5>
    <p id="u2571a523">
    </p>
    <pre id="LYPgI"><code>@TableName("order_ticket_order_info")
public class TicketOrderInfoDO extends BaseDO {
    @TableId
    private Long id; // 主键
    private String cenicSpotsId; // 景区编号
    private String ticketName;  // 门票名称
    // ...其他 40+ 业务字段
}</code></pre>
    <p id="u9bfc0df5">
     <strong>
      作用
     </strong>
     ：
    </p>
    <ul>
     <li id="ua63e7573">
      数据库表结构映射（@TableName 指定表名）
     </li>
     <li id="uf81f824a">
      继承 BaseDO 获得创建时间、更新时间等公共字段
     </li>
     <li id="uc29fc381">
      使用 MyBatis-Plus 注解实现 ORM 映射
     </li>
     <li id="u3f750c40">
     </li>
    </ul>
    <p id="u0a4ff978">
     XML 格式的代码符号引用为您分析 的关键设计：
    </p>
    <pre id="ImWTj"><code>@TableName("order_ticket_order_info") // ① 表名映射
@KeySequence("order_ticket_order_info_seq") // ② 多数据库主键策略
@Data // ③ Lombok 数据对象简化
@EqualsAndHashCode(callSuper = true) // ④ 包含父类字段的相等性判断
@ToString(callSuper = true) // ⑤ 包含父类字段的字符串表示
@Builder // ⑥ 建造者模式支持
@NoArgsConstructor // ⑦ MyBatis 反射需要无参构造
@AllArgsConstructor // ⑧ 全字段构造
public class TicketOrderInfoDO extends BaseDO { // ⑨ 继承审计字段
    @TableId // ⑩ 主键标识
    private Long id;
    private String cenicSpotsId; // ⑪ 业务字段标准命名（景区编码）</code></pre>
    <h5 id="sIaH5">
     关键设计解析
    </h5>
    <ol>
     <li id="u9d7b8e83">
      <strong>
       多数据库支持
      </strong>
      <br/>
      <code>
       @KeySequence
      </code>
      实现 Oracle/PostgreSQL 等数据库的序列主键，MySQL 自动忽略（通过
      <code>
       application.yaml
      </code>
      的
      <code>
       mybatis-plus.global-config.db-config.id-type
      </code>
      配置自增策略）
     </li>
     <li id="uaf3981b4">
      <strong>
       审计字段继承
      </strong>
      <br/>
      继承的 包含：
     </li>
    </ol>
    <pre id="xJMlN"><code>public abstract class BaseDO {
    private LocalDateTime createTime; // 创建时间（DB 自动填充）
    private LocalDateTime updateTime; // 更新时间（DB 自动填充）
    private Long creator; // 创建人（通过线程上下文自动填充）
    private Long updater; // 更新人（通过线程上下文自动填充）
}</code></pre>
    <ol>
     <li id="ub3805672">
      <strong>
       Lombok 最佳实践
      </strong>
      <br/>
      <code>
       callSuper = true
      </code>
      确保审计字段参与对象比较和日志输出，避免以下问题：
     </li>
    </ol>
    <pre id="Bxrj8"><code>TicketOrderInfoDO order1 = TicketOrderInfoDO.builder().id(1L).build();
TicketOrderInfoDO order2 = TicketOrderInfoDO.builder().id(1L).build();
// 没有 callSuper=true 时可能错误判断两个对象相等</code></pre>
    <ol>
     <li id="u4c8c1027">
      <strong>
       字段设计规范
      </strong>
      <br/>
      <code>
       cenicSpotsId
      </code>
      字段采用「业务语义 + ID 类型」命名法：
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="ue41d7009">
        <code>
         cenic
        </code>
        : Centralized Entertainment &amp; Information Center 缩写（项目专属业务术语）
       </li>
       <li id="u82beb1e1">
        <code>
         Spots
        </code>
        : 景区业务域标识
       </li>
       <li id="ud079aab3">
        <code>
         Id
        </code>
        : 明确标识为业务编码（非自增主键）
       </li>
      </ul>
     </li>
    </ul>
    <p id="u204a9bb5">
    </p>
    <h5 id="PH1VH">
     <code>
      @Builder
     </code>
     注解核心作用
    </h5>
    <p id="ua51405b3">
     这是 Lombok 的建造者模式注解，自动生成如下代码结构：
    </p>
    <pre id="iXIOQ"><code>public class TicketOrderInfoDO {
    public static TicketOrderInfoDO.TicketOrderInfoDOBuilder builder() {
        return new TicketOrderInfoDO.TicketOrderInfoDOBuilder();
    }

    public static class TicketOrderInfoDOBuilder {
        private Long id;
        private String cenicSpotsId;
        // ... 其他字段

        TicketOrderInfoDOBuilder() {}

        public TicketOrderInfoDO.TicketOrderInfoDOBuilder id(Long id) {
            this.id = id;
            return this;
        }

        public TicketOrderInfoDO.TicketOrderInfoDOBuilder cenicSpotsId(String cenicSpotsId) {
            this.cenicSpotsId = cenicSpotsId;
            return this;
        }

        // ... 其他字段的链式方法

        public TicketOrderInfoDO build() {
            return new TicketOrderInfoDO(id, cenicSpotsId, ...);
        }
    }
}</code></pre>
    <h5 id="E4ixg">
     实际应用场景
    </h5>
    <pre id="lsyUV"><code>// 创建复杂对象时避免过长的构造函数参数
TicketOrderInfoDO order = TicketOrderInfoDO.builder()
    .id(1L)
    .cenicSpotsId("CS_001")
    .ticketName("迪士尼成人票")
    .price(new BigDecimal("599.00"))
    .buyTime(LocalDateTime.now())
    .build();</code></pre>
    <h5 id="QCHo1">
     设计注意事项
    </h5>
    <p id="uf81c1c8d">
     当同时使用
     <code>
      @NoArgsConstructor
     </code>
     和
     <code>
      @Builder
     </code>
     时，需要显式声明无参构造器：
    </p>
    <pre id="w5Tdg"><code>@NoArgsConstructor(access = AccessLevel.PRIVATE) // 强制私有无参构造
@AllArgsConstructor
public class TicketOrderInfoDO extends BaseDO {
    // ... 字段
}</code></pre>
    <p id="uffc7eb42">
     该模式特别适用于需要创建包含 40+ 字段的复杂数据对象场景，可显著提升代码可读性。
    </p>
    <p id="u95c45488">
    </p>
    <h5 id="b5blj">
     代码生成器特征分析
    </h5>
    <p id="u61914c47">
    </p>
    <p id="u562fa0e9">
     该实体类具有典型的代码生成器特征，主要体现在以下方面：
    </p>
    <h5 id="R3yTS">
     代码生成器特征分析
    </h5>
    <pre id="IQnWF"><code>// 特征 1 - 标准模板结构
@TableName("order_ticket_order_info") // ① 表名映射
@KeySequence("order_ticket_order_info_seq") // ② 多数据库主键策略
@Data // ③ 自动化 Lombok 配置
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TicketOrderInfoDO extends BaseDO { ... }

// 特征 2 - 字段与表结构强对应
@TableId
private Long id; // 主键（完全对应表结构）
private String cenicSpotsId; // 字段名与数据库列名 cenic_spots_id 自动转换
private LocalDateTime buyTime; // 时间类型精确对应</code></pre>
    <h5 id="Ik4K9">
     典型代码生成场景
    </h5>
    <ol>
     <li id="u218349b6">
      <strong>
       数据库表逆向工程
      </strong>
      <br/>
      根据
      <code>
       order_ticket_order_info
      </code>
      表结构自动生成字段（含注释）
     </li>
     <li id="u2ea888a2">
      <strong>
       MyBatis-Plus 代码生成器配置
      </strong>
      <br/>
      常见生成配置示例：
     </li>
    </ol>
    <pre id="jDPCt"><code>FastAutoGenerator.create(dataSourceConfig)
    .globalConfig(builder -&gt; builder.outputDir("c:\\project\\centralservice")) 
    .packageConfig(builder -&gt; builder.parent("cn.iocoder.central.module.ticket"))
    .strategyConfig(builder -&gt; 
        builder.entityBuilder()
            .enableLombok()
            .enableChainModel()
            .addSuperEntityColumns("create_time", "update_time") // 继承 BaseDO
    );</code></pre>
    <h5 id="VaR8S">
     生成后的人工干预点
    </h5>
    <pre id="fXIIk"><code>// 干预 1 - 补充业务语义注释
/**
 * 远端订单号（对接第三方系统）
 */
private String remoteOrderNumber;

// 干预 2 - 增加特殊字段类型
@JsonSerialize(using = ToStringSerializer.class) // 防止 Long 精度丢失
private Long distributorId;

// 干预 3 - 自定义校验注解
@NotNull(message = "采购单价不能为空")
private BigDecimal purchasePrice;</code></pre>
    <p id="u99ee3bd6">
    </p>
    <p id="uc121e066">
    </p>
    <p id="ue8915c20">
    </p>
    <p id="ufa9e5e6a">
    </p>
    <p id="uf3a3808b">
    </p>
    <h5 id="EzQui">
     2. Mapper 数据接口
    </h5>
    <p id="ue9cb15fb">
    </p>
    <pre id="BMtpY"><code>public interface TicketOrderInfoMapper extends BaseMapperX&lt;TicketOrderInfoDO&gt; {
    default PageResult&lt;TicketOrderInfoDO&gt; selectPage(TicketOrderInfoPageReqVO reqVO) {
        return selectPage(reqVO, new LambdaQueryWrapperX&lt;TicketOrderInfoDO&gt;()
            .eqIfPresent(TicketOrderInfoDO::getCenicSpotsId, reqVO.getCenicSpotsId())
            .likeIfPresent(TicketOrderInfoDO::getCenicSpotsName, reqVO.getCenicSpotsName()));
    }
}</code></pre>
    <p id="u0171a429">
     <strong>
      作用
     </strong>
     ：
    </p>
    <ul>
     <li id="u9dddf29b">
      继承 BaseMapperX 获得通用 CRUD 方法
     </li>
     <li id="u35db88b1">
      使用 MyBatis-Plus 动态查询条件构建器
     </li>
     <li id="u45dd1426">
      分页查询自动处理（与前端传参对接）
     </li>
    </ul>
    <h5 id="klth0">
     3. SQL 映射文件
    </h5>
    <pre id="EShHq"><code>&lt;select id="selectById" resultType="TicketOrderInfoDO"&gt;
    SELECT * FROM order_ticket_order_info
    WHERE id = #{id}
&lt;/select&gt;
&lt;insert id="insert" parameterType="TicketOrderInfoDO" useGeneratedKeys="true" keyProperty="id"&gt;
    INSERT INTO order_ticket_order_info (cenic_spots_id, ticket_name, ...)
    VALUES (#{cenicSpotsId}, #{ticketName}, ...)
&lt;/insert&gt;
</code></pre>
    <p id="u26e3c701">
     <strong>
      作用
     </strong>
     ：
    </p>
    <ul>
     <li id="u5bd95aa1">
      复杂 SQL 的 XML 实现
     </li>
     <li id="u7704b9df">
      结果集自动映射到 DO 对象
     </li>
     <li id="u7b0ea9da">
      主键自增配置（useGeneratedKeys）
     </li>
    </ul>
    <h5 id="gCAf6">
     数据流转流程
    </h5>
    <pre id="igtVK"><code>Controller（VO）
    ↓ 转换
Service（DTO）
    ↓ 转换
Mapper（DO） ↔ XML
    ↓
DB</code></pre>
    <h5 id="CdInw">
     设计亮点
    </h5>
    <ol>
     <li id="u5c299f34">
      <strong>
       模块化分层
      </strong>
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="u9eeb7dd7">
        按业务域划分 ticketinfo 子包
       </li>
       <li id="u454384c5">
        不同业务模块的 DO/Mapper 物理隔离
       </li>
      </ul>
     </li>
    </ul>
    <ol>
     <li id="uce04d050">
      <strong>
       继承复用
      </strong>
     </li>
    </ol>
    <pre id="fT8SH"><code>public class BaseDO {
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private Long creator;
    private Long updater;
}</code></pre>
    <ol>
     <li id="uc938c15c">
      <strong>
       动态查询
      </strong>
     </li>
    </ol>
    <pre id="EsLhk"><code>// 自动处理空值条件
.eqIfPresent(TicketOrderInfoDO::getTicketId, reqVO.getTicketId()) </code></pre>
    <h5 id="t8o4o">
     扩展建议
    </h5>
    <p id="u2d291f98">
     对于复杂查询场景，可增加
     <code>
      @Select
     </code>
     注解实现动态 SQL：
    </p>
    <pre id="kAIEV"><code>@SelectProvider(type = TicketOrderSqlBuilder.class, method = "buildQuery")
List&lt;TicketOrderInfoDO&gt; selectByComplexCondition(TicketOrderQuery query);</code></pre>
    <p id="u75e660be">
    </p>
    <p id="u53971296">
    </p>
    <h5 id="kg9kp">
     代码详细注释
    </h5>
    <pre id="PTfqI"><code>// 包路径声明（领域驱动设计中的基础设施层）
package cn.iocoder.central.module.ticket.dal.mysql.ticketinfo;

// ... 导入部分省略 ...

/**
 * 门票订单信息 Mapper（数据访问层核心组件）
 * 
 * 功能定位：
 * 1. 实现 TicketOrderInfoDO 与 order_ticket_order_info 表的 CRUD 操作
 * 2. 处理复杂查询条件构建和分页逻辑
 * 3. 对接 MyBatis-Plus 增强功能
 *
 * @author 陕文旅
 */
@Mapper // MyBatis 组件标识，由 Spring 管理 Bean 生命周期
public interface TicketOrderInfoMapper extends BaseMapperX&lt;TicketOrderInfoDO&gt; {

    /**
     * 动态分页查询（Java 链式 API 实现）
     * 
     * @param reqVO 分页查询请求参数 VO 
     * @return 分页结果（包含 total/list/pageNo/pageSize）
     * 
     * 实现特点：
     * 1. 使用 LambdaQueryWrapperX 实现类型安全的条件构建
     * 2. eqIfPresent/likeIfPresent 实现 null 值自动过滤
     * 3. 支持 40+ 字段的精确匹配、模糊查询、时间范围过滤
     * 4. 默认按 ID 倒序排序
     */
    default PageResult&lt;TicketOrderInfoDO&gt; selectPage(TicketOrderInfoPageReqVO reqVO) {
        return selectPage(reqVO, new LambdaQueryWrapperX&lt;TicketOrderInfoDO&gt;()
                // 景区相关条件（示例）
                .eqIfPresent(TicketOrderInfoDO::getCenicSpotsId, reqVO.getCenicSpotsId())
                .likeIfPresent(TicketOrderInfoDO::getCenicSpotsName, reqVO.getCenicSpotsName())
                
                // ... 中间字段条件省略 ...

                // 时间范围条件（示例）
                .betweenIfPresent(TicketOrderInfoDO::getCreateTime, reqVO.getCreateTime())
                
                // 排序规则
                .orderByDesc(TicketOrderInfoDO::getId));
    }

    /**
     * XML 映射方式的分页查询（复杂 SQL 场景）
     * 
     * @param page MyBatis-Plus 分页对象
     * @param reqVO 查询参数
     * @return 分页结果（响应 VO 对象）
     * 
     * 适用场景：
     * 1. 多表联合查询
     * 2. 复杂统计计算
     * 3. 数据库特性函数使用
     */
    IPage&lt;TicketOrderInfoRespVO&gt; selectPageUseXML(IPage&lt;TicketOrderInfoRespVO&gt; page, @Param("reqVO") TicketOrderInfoPageReqVO reqVO);

    /**
     * 导出数据查询接口
     * 
     * @param pageReqVO 查询参数（复用分页 VO）
     * @return 导出数据列表（Excel 专用 VO）
     * 
     * 设计要点：
     * 1. 复用分页查询条件确保数据一致性
     * 2. 返回结构适配 Excel 导出格式
     */
    List&lt;TicketImportVo&gt; getOrderTicketOrderInfoList(@Param("reqVO") TicketOrderInfoPageReqVO pageReqVO);
}
</code></pre>
    <p id="u62097e80">
    </p>
    <p id="u85929e21">
    </p>
    <p id="ufc7ad8c3">
    </p>
    <h5 id="NVMbN">
     <br/>
     MyBatis-Plus 实现角度分析 TicketOrderInfoMapper.java 的核心设计：
    </h5>
    <h5 id="pICl3">
     架构分层
    </h5>
    <pre id="jrv4t"><code>@Mapper // ① MyBatis 组件标识
public interface TicketOrderInfoMapper 
    extends BaseMapperX&lt;TicketOrderInfoDO&gt; { // ② 继承增强基类
    // ③ 默认方法实现动态查询
    default PageResult&lt;TicketOrderInfoDO&gt; selectPage(TicketOrderInfoPageReqVO reqVO) { ... }
    
    // ④ XML 映射的复杂查询
    IPage&lt;TicketOrderInfoRespVO&gt; selectPageUseXML(IPage&lt;TicketOrderInfoRespVO&gt; page, @Param("reqVO") TicketOrderInfoPageReqVO reqVO);
}</code></pre>
    <h5 id="XYlhr">
     核心机制解析
    </h5>
    <ol>
     <li id="u2829feac">
      <strong>
       动态条件构建
      </strong>
      <br/>
      通过 LambdaQueryWrapperX 实现 40+ 字段的动态条件匹配：
     </li>
    </ol>
    <pre id="fDAD4"><code>.eqIfPresent(TicketOrderInfoDO::getCenicSpotsId, reqVO.getCenicSpotsId())</code></pre>
    <p id="u3f0d82d0">
     等效于：
    </p>
    <pre id="v7bs0"><code>&lt;if test="reqVO.cenicSpotsId != null"&gt;
    cenic_spots_id = #{reqVO.cenicSpotsId}
&lt;/if&gt;
</code></pre>
    <ol>
     <li id="u7b477bd9">
      <strong>
       分页结果处理
      </strong>
      <br/>
      <code>
       PageResult&lt;T&gt;
      </code>
      封装结构：
     </li>
    </ol>
    <pre id="WQWDv"><code>{
  "total": 100,
  "list": [...],
  "pageNo": 1,
  "pageSize": 10
}</code></pre>
    <p id="uabdf827d">
     与前端分页参数自动对接
    </p>
    <ol>
     <li id="u73867a89">
      <strong>
       XML 映射模式
      </strong>
      <br/>
      复杂联表查询示例：
     </li>
    </ol>
    <pre id="QONBa"><code>&lt;select id="selectPageUseXML" resultType="TicketOrderInfoRespVO"&gt;
    SELECT 
        o.*, 
        s.supplier_contact AS supplier_contact
    FROM order_ticket_order_info o
    LEFT JOIN ticket_supplier s ON o.supplier_id = s.id
    &lt;where&gt;
        &lt;if test="reqVO.supplierName != null"&gt;
            o.supplier_name LIKE CONCAT('%', #{reqVO.supplierName}, '%')
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
    <p id="uea135a75">
    </p>
    <h5 id="E1fYm">
     扩展应用场景
    </h5>
    <pre id="fG7wm"><code>// 场景 1 - 导出数据对接
public void exportTicketOrders(TicketOrderInfoPageReqVO reqVO) {
    List&lt;TicketImportVo&gt; list = ticketOrderInfoMapper.getOrderTicketOrderInfoList(reqVO);
    excelUtil.export(list, "门票订单数据");
}

// 场景 2 - 复杂统计查询
@Select("SELECT COUNT(*) FROM order_ticket_order_info WHERE price &gt; #{minPrice}")
int countByMinPrice(@Param("minPrice") BigDecimal minPrice);</code></pre>
    <h5 id="lTXtY">
     设计优化建议
    </h5>
    <p id="u27278d64">
     <strong>
      问题
     </strong>
     ：动态条件方法过长（40+ 字段）
     <br/>
     <strong>
      解决方案
     </strong>
     ：使用元编程自动生成条件
    </p>
    <pre id="o4Y0t"><code>public abstract class BaseMapperX&lt;T&gt; extends BaseMapper&lt;T&gt; {
    
    public PageResult&lt;T&gt; selectPageAuto(PageParam reqVO, Function&lt;LambdaQueryWrapperX&lt;T&gt;, LambdaQueryWrapperX&lt;T&gt;&gt; predicate) {
        LambdaQueryWrapperX&lt;T&gt; wrapper = new LambdaQueryWrapperX&lt;&gt;();
        // 通过反射自动匹配 reqVO 与 DO 字段
        ReflectUtil.getFields(reqVO.getClass()).forEach(field -&gt; {
            Object value = ReflectUtil.getFieldValue(reqVO, field);
            if (value != null) {
                wrapper.eq(getColumn(field), value);
            }
        });
        return selectPage(reqVO, predicate.apply(wrapper));
    }
}</code></pre>
    <p id="u5dc198e9">
    </p>
    <p id="u857ef60d">
    </p>
    <p id="u409986db">
    </p>
    <p id="u9257884a">
    </p>
    <p id="uf98996e7">
    </p>
    <p id="ub156df50">
    </p>
    <p id="u891e9513">
    </p>
    <p id="u567374c1">
    </p>
    <h4 id="EuyfO">
     3. 服务层（Service Layer）
    </h4>
    <ul>
     <li id="u27fe3266">
      <strong>
       功能与技术点实现
      </strong>
      ：作为业务逻辑核心，处理票务信息的增删改查。
     </li>
    </ul>
    <ul>
     <li>
      <ul>
       <li id="uc7a29f9d">
        <strong>
         服务接口与实现类编写
        </strong>
        ：定义服务接口，编写实现类，处理业务规则。
       </li>
       <li id="uf83c5ecb">
        <strong>
         分布式事务处理
        </strong>
        ：涉及多数据源或服务的事务操作时，使用 Seata 等框架确保事务一致性。
       </li>
       <li id="u95bf7c08">
        <strong>
         服务发现与调用配置
        </strong>
        ：通过 Nacos 发现服务，用 Feign 或 Dubbo 进行远程调用。
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li id="u7513fdd0">
      <strong>
       联动方式实现
      </strong>
      ：通过依赖注入调用 DAL 层的 DAO 方法进行数据操作。当涉及多个服务的协作时，通过 Feign 客户端调用其他服务的 API，Nacos 实现服务发现和负载均衡。对于需要缓存的数据，服务层会先调用 Redis 相关操作从缓存中获取数据，若缓存失效则再调用 MySQL 相关操作从数据库中查询数据并更新缓存。
     </li>
    </ul>
    <p id="u732367e9">
    </p>
    <p class="img-center">
     <img alt="" height="106" id="ub1ba35c9" src="https://i-blog.csdnimg.cn/img_convert/b425f0e303a0dce8d9087ee54af42220.png" width="283"/>
    </p>
    <p id="uc3b2db61">
    </p>
    <p id="u2878e70e">
    </p>
    <p id="u915db7dc">
    </p>
    <p id="u278a6866">
    </p>
    <p id="ub55c1269">
     我将从 MyBatis-Plus 集成和业务逻辑处理两个维度，详细分析
     <code>
      &lt;mcsymbol name="TicketOrderInfoServiceImpl" filename="TicketOrderInfoServiceImpl.java" path="c:\project\centralservice\central-module-ticket\central-module-ticket-biz\src\main\java\cn\iocoder\central\module\ticket\service\ticketinfo\TicketOrderInfoServiceImpl.java" startline="37" type="class"&gt;&lt;/mcsymbol&gt;
     </code>
     的实现：
    </p>
    <h5 id="B5wk6">
     服务层核心架构
    </h5>
    <pre id="QiPdL"><code>@Service
@Validated
@Slf4j
public class TicketOrderInfoServiceImpl implements TicketOrderInfoService {
    
    @Resource
    private TicketOrderInfoMapper ticketOrderInfoMapper;

    // 核心方法实现...
}</code></pre>
    <h5 id="iVYKf">
     分层设计分析
    </h5>
    <table id="JBPXW">
     <tbody>
      <tr>
       <td>
        <p id="ue0a8e326">
         层级
        </p>
       </td>
       <td>
        <p id="uda57924f">
         组件
        </p>
       </td>
       <td>
        <p id="u84221bbe">
         职责说明
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u8c5c3752">
         Controller
        </p>
       </td>
       <td>
        <p id="u0d269cd3">
         <code>
          TicketOrderInfoController
         </code>
        </p>
       </td>
       <td>
        <p id="u03a87d3b">
         处理 HTTP 请求/响应
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u423d909d">
         Service
        </p>
       </td>
       <td>
        <p id="u5801eaf6">
         <code>
          TicketOrderInfoServiceImpl
         </code>
        </p>
       </td>
       <td>
        <p id="u452aabb0">
         业务逻辑编排/事务控制
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u7f0dde46">
         Mapper
        </p>
       </td>
       <td>
        <p id="u79f2e084">
         <code>
          TicketOrderInfoMapper
         </code>
        </p>
       </td>
       <td>
        <p id="uc1c3b598">
         数据库访问/动态 SQL 生成
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u835636d9">
         DO
        </p>
       </td>
       <td>
        <p id="ua0f38caf">
         <code>
          TicketOrderInfoDO
         </code>
        </p>
       </td>
       <td>
        <p id="u52426a26">
         数据库实体映射
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="uac86abe6">
         VO
        </p>
       </td>
       <td>
        <p id="u0ab93444">
         <code>
          TicketOrderInfoPageReqVO
         </code>
        </p>
       </td>
       <td>
        <p id="u6446d2fe">
         前端请求参数封装
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h5 id="QAfHv">
     核心方法实现分析
    </h5>
    <h5 id="XZbTf">
     1. 分页查询服务
    </h5>
    <pre id="slHYC"><code>public PageResult&lt;TicketOrderInfoDO&gt; selectPage(TicketOrderInfoPageReqVO reqVO) {
    return ticketOrderInfoMapper.selectPage(reqVO);
}

// 实际调用链路：
Controller → Service → Mapper → MyBatis-Plus 分页插件 → 数据库</code></pre>
    <h5 id="RqqXU">
     2. 数据创建逻辑
    </h5>
    <pre id="IjfUC"><code>public Long createTicketOrderInfo(TicketOrderInfoSaveReqVO createReqVO) {
    // 数据转换 + 持久化操作
    TicketOrderInfoDO ticketOrderInfo = BeanUtils.toBean(createReqVO, TicketOrderInfoDO.class);
    ticketOrderInfoMapper.insert(ticketOrderInfo);
    return ticketOrderInfo.getId();
}</code></pre>
    <p id="u48d5fe73">
     3. 复杂业务场景示例（门票订单核销）
    </p>
    <pre id="MhLbP"><code>@Transactional(rollbackFor = Exception.class)
public void verifyTicketOrder(Long id, String operator) {
    // 1. 校验订单状态
    TicketOrderInfoDO order = ticketOrderInfoMapper.selectById(id);
    if (order.getVerifiedCount() &gt;= order.getTicketCount()) {
        throw new ServiceException("订单已全部核销");
    }
    
    // 2. 更新核销数量
    ticketOrderInfoMapper.update(null, 
        new LambdaUpdateWrapper&lt;TicketOrderInfoDO&gt;()
            .setSql("verified_count = verified_count + 1")
            .eq(TicketOrderInfoDO::getId, id));
    
    // 3. 记录核销日志（需要扩展日志服务）
    ticketVerifyLogService.logVerify(id, operator);
}</code></pre>
    <h5 id="Alafr">
     性能优化建议
    </h5>
    <p id="ud5fd518b">
     <strong>
      问题
     </strong>
     ：全字段更新效率低
     <br/>
     <strong>
      解决方案
     </strong>
     ：动态字段更新
    </p>
    <pre id="wq5XD"><code>public void updateTicketOrderInfo(TicketOrderInfoSaveReqVO updateReqVO) {
    // 仅更新非空字段
    TicketOrderInfoDO updateObj = BeanUtils.toBean(updateReqVO, TicketOrderInfoDO.class);
    ticketOrderInfoMapper.updateById(updateObj);
    
    // 替换 MyBatis-Plus 默认的 updateById 实现为：
    ticketOrderInfoMapper.update(
        new LambdaUpdateWrapper&lt;TicketOrderInfoDO&gt;()
            .set(updateReqVO.getCenicSpotsId() != null, TicketOrderInfoDO::getCenicSpotsId, updateReqVO.getCenicSpotsId())
            // 逐个设置非空字段...
            .eq(TicketOrderInfoDO::getId, updateReqVO.getId())
    );
}</code></pre>
    <h5 id="D461i">
     事务管理策略
    </h5>
    <pre id="xJNlT"><code>spring:
  transaction:
    default-timeout: 30 # 事务默认超时时间30秒
    rollback-on-commit-failure: true # 提交失败时回滚</code></pre>
    <h5 id="E4jEZ">
     扩展功能建议
    </h5>
    <p id="u7b7436d6">
     <strong>
      分布式锁集成
     </strong>
     ：
    </p>
    <pre id="I8gK6"><code>public void processOrder(Long id) {
    Lock lock = lockTemplate.getLock("order_process:" + id);
    try {
        if (lock.tryLock()) {
            // 处理订单核心逻辑...
        }
    } finally {
        lock.unlock();
    }
}</code></pre>
    <p id="uc94802d1">
     <strong>
      缓存集成示例
     </strong>
     ：
    </p>
    <pre id="GuqWY"><code>@Cacheable(value = "ticketOrder", key = "#id", unless = "#result == null")
public TicketOrderInfoDO getTicketOrderInfo(Long id) {
    return ticketOrderInfoMapper.selectById(id);
}</code></pre>
    <p id="u136c7151">
     需要根据具体业务场景选择适合的优化策略。当前服务层实现已具备基础 CRUD 能力，后续可结合具体业务需求增加风控校验、异步处理等高级功能。
    </p>
    <p id="u6d0330b4">
    </p>
    <p id="ueadef714">
    </p>
    <h5 id="YlTHS">
     TicketOrderInfoServiceImpl.java 实现类
    </h5>
    <pre id="bRVou"><code>package cn.iocoder.central.module.ticket.service.ticketinfo;


import cn.hutool.core.collection.CollectionUtil;

import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoPageReqVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoSaveReqVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.excel.TicketImportRespVo;
import cn.iocoder.central.module.ticket.controller.admin.vo.excel.TicketImportVo;
import cn.iocoder.central.module.ticket.dal.dataobject.ticketinfo.TicketOrderInfoDO;
import cn.iocoder.central.module.ticket.dal.mysql.ticketinfo.TicketOrderInfoMapper;
import cn.iocoder.yudao.framework.common.exception.ErrorCode;
import cn.iocoder.yudao.framework.common.pojo.PageResult;
import cn.iocoder.yudao.framework.common.util.date.DateTimeFormatterUtils;
import cn.iocoder.yudao.framework.common.util.object.BeanUtils;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;

import java.util.ArrayList;
import java.util.List;

import static cn.iocoder.central.module.ticket.enums.ErrorCodeConstants.TICKET_IMPORT_LIST_IS_EMPTY;
import static cn.iocoder.central.module.ticket.enums.ErrorCodeConstants.TICKET_ORDER_INFO_NOT_EXISTS;
import static cn.iocoder.yudao.framework.common.exception.util.ServiceExceptionUtil.exception;

/**
 * 门票订单信息 Service 实现类
 *
 * @author 陕文旅
 */
@Service
@Validated
@Slf4j
public class TicketOrderInfoServiceImpl implements TicketOrderInfoService {

    @Resource
    private TicketOrderInfoMapper ticketOrderInfoMapper;

    /**
     * 创建门票订单信息
     *
     * @param createReqVO 创建请求对象，包含门票订单的详细信息
     * @return 创建的门票订单的主键ID
     */
    @Override
    public Long createTicketOrderInfo(TicketOrderInfoSaveReqVO createReqVO) {
        // 将请求对象转换为数据访问对象
        TicketOrderInfoDO ticketOrderInfo = BeanUtils.toBean(createReqVO, TicketOrderInfoDO.class);
        // 插入到数据库
        ticketOrderInfoMapper.insert(ticketOrderInfo);
        // 返回生成的主键ID
        return ticketOrderInfo.getId();
    }

    /**
     * 更新门票订单信息
     *
     * @param updateReqVO 更新请求对象，包含门票订单的详细信息
     */
    @Override
    public void updateTicketOrderInfo(TicketOrderInfoSaveReqVO updateReqVO) {
        // 校验门票订单是否存在
        validateTicketOrderInfoExists(updateReqVO.getId());
        // 将请求对象转换为数据访问对象
        TicketOrderInfoDO updateObj = BeanUtils.toBean(updateReqVO, TicketOrderInfoDO.class);
        // 执行更新操作
        ticketOrderInfoMapper.updateById(updateObj);
    }

    /**
     * 删除门票订单信息
     *
     * @param id 门票订单的主键ID
     */
    @Override
    public void deleteTicketOrderInfo(Long id) {
        // 校验门票订单是否存在
        validateTicketOrderInfoExists(id);
        // 执行删除操作
        ticketOrderInfoMapper.deleteById(id);
    }

    /**
     * 校验门票订单是否存在，不存在则抛出异常
     *
     * @param id 门票订单的主键ID
     */
    private void validateTicketOrderInfoExists(Long id) {
        if (ticketOrderInfoMapper.selectById(id) == null) {
            // 如果不存在，抛出异常
            throw exception((ErrorCode) TICKET_ORDER_INFO_NOT_EXISTS);
        }
    }

    /**
     * 获取单个门票订单信息
     *
     * @param id 门票订单的主键ID
     * @return 门票订单信息对象
     */
    @Override
    public TicketOrderInfoDO getTicketOrderInfo(Long id) {
        return ticketOrderInfoMapper.selectById(id);
    }

    /**
     * 分页获取门票订单信息列表
     *
     * @param pageReqVO 分页请求对象，包含分页参数和查询条件
     * @return 分页结果对象，包含门票订单信息列表和分页信息
     */
    @Override
    public PageResult&lt;TicketOrderInfoDO&gt; getTicketOrderInfoPage(TicketOrderInfoPageReqVO pageReqVO) {
        return ticketOrderInfoMapper.selectPage(pageReqVO);
    }

    /**
     * 导入门票订单信息列表
     *
     * @param list           待导入的门票订单信息列表
     * @param updateSupport  是否支持更新已存在的记录
     * @return 导入结果对象，包含新增、更新和失败的订单编号列表
     */
    @Override
    @Transactional
    public TicketImportRespVo importTicketList(List&lt;TicketImportVo&gt; list, Boolean updateSupport) {
        // 参数校验：列表是否为空
        if (CollectionUtil.isEmpty(list)) {
            throw exception(TICKET_IMPORT_LIST_IS_EMPTY);
        }
        // 初始化导入结果对象
        TicketImportRespVo respVO = TicketImportRespVo.builder()
                .addOrderCodes(new ArrayList&lt;&gt;())
                .updateOrderCodes(new ArrayList&lt;&gt;())
                .failureOrderCodes(new ArrayList&lt;&gt;())
                .build();

        log.info("导入的数量：{}, 导入数据：{}", list.size(), list);

        log.info("\n================================== 导入开始 ============================");
        long startImportTime = System.currentTimeMillis();
        // 遍历导入列表，逐个处理
        list.forEach(item -&gt; {
            log.info("开始导入：{}", item);
            // 处理时间字段，格式化为标准日期时间格式
            item.setBuyTime(DateTimeFormatterUtils.formatDateTime(item.getBuyTime()));
            item.setExpectedTime(DateTimeFormatterUtils.formatDateTime(item.getExpectedTime()));
            item.setStartDate(DateTimeFormatterUtils.formatDateTime(item.getStartDate()));
            item.setEndDate(DateTimeFormatterUtils.formatDateTime(item.getEndDate()));
            item.setCompletionTime(DateTimeFormatterUtils.formatDateTime(item.getCompletionTime()));
            item.setCancelTime(DateTimeFormatterUtils.formatDateTime(item.getCancelTime()));
            // 转换为数据访问对象
            TicketOrderInfoDO TicketOrderInfoDO = BeanUtils.toBean(item, TicketOrderInfoDO.class);
            // 插入数据库
            ticketOrderInfoMapper.insert(TicketOrderInfoDO);
            log.info("新增的ID：{}", TicketOrderInfoDO.getId());
        });
        long endImportTime = System.currentTimeMillis();
        log.info("\n================================== 导入结束 ============================");
        log.info("一共用了：{}", endImportTime - startImportTime);

        return respVO;
    }

}</code></pre>
    <p id="u9e592192">
    </p>
    <p id="ua0992afe">
    </p>
    <h5 id="WX8f8">
     TicketOrderInfoService.java 接口
    </h5>
    <p id="uf218fda6">
    </p>
    <pre id="TzTZk"><code>package cn.iocoder.central.module.ticket.service.ticketinfo;

import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoPageReqVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoSaveReqVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.excel.TicketImportRespVo;
import cn.iocoder.central.module.ticket.controller.admin.vo.excel.TicketImportVo;
import cn.iocoder.central.module.ticket.dal.dataobject.ticketinfo.TicketOrderInfoDO;
import cn.iocoder.yudao.framework.common.pojo.PageResult;
import jakarta.validation.Valid;

import java.util.List;

/**
 * 门票订单信息 Service 接口
 *
 * @author 陕文旅
 */
public interface TicketOrderInfoService {

    /**
     * 创建门票订单信息
     *
     * @param createReqVO 创建信息，包含门票订单的详细数据
     * @return 生成的门票订单编号
     */
    Long createTicketOrderInfo(@Valid TicketOrderInfoSaveReqVO createReqVO);

    /**
     * 更新门票订单信息
     *
     * @param updateReqVO 更新信息，包含门票订单的详细数据和主键ID
     */
    void updateTicketOrderInfo(@Valid TicketOrderInfoSaveReqVO updateReqVO);

    /**
     * 删除门票订单信息
     *
     * @param id 门票订单的主键ID
     */
    void deleteTicketOrderInfo(Long id);

    /**
     * 获取单个门票订单信息
     *
     * @param id 门票订单的主键ID
     * @return 门票订单信息对象
     */
    TicketOrderInfoDO getTicketOrderInfo(Long id);

    /**
     * 分页获取门票订单信息列表
     *
     * @param pageReqVO 分页请求对象，包含分页参数和查询条件
     * @return 分页结果对象，包含门票订单信息列表和分页信息
     */
    PageResult&lt;TicketOrderInfoDO&gt; getTicketOrderInfoPage(TicketOrderInfoPageReqVO pageReqVO);

    /**
     * 批量导入门票订单信息
     *
     * @param list           待导入的门票订单信息列表
     * @param updateSupport  是否支持更新已存在的记录
     * @return 导入结果对象，包含新增、更新和失败的订单编号列表
     */
    TicketImportRespVo importTicketList(List&lt;TicketImportVo&gt; list, Boolean updateSupport);
}</code></pre>
    <p id="u01587a10">
    </p>
    <p id="u72c2f137">
    </p>
    <p id="ua5e2f838">
    </p>
    <p id="u390b2b48">
    </p>
    <p id="u261c43d6">
    </p>
    <h4 id="BfBk6">
     4. 控制层（Controller Layer）
    </h4>
    <ul>
     <li id="u474d3585">
      <strong>
       功能与技术点实现
      </strong>
      ：处理客户端的 HTTP 请求，尤其针对管理员操作和 Excel 文件相关视图对象（VO）。
     </li>
    </ul>
    <ul>
     <li>
      <ul>
       <li id="u06ecd780">
        <strong>
         控制器类与方法编写
        </strong>
        ：使用 Spring MVC 处理 HTTP 请求响应，定义请求映射和参数绑定。
       </li>
       <li id="u1a761b55">
        <strong>
         Sentinel 配置
        </strong>
        ：在方法级配置流量控制和熔断降级规则，防止接口过载。
       </li>
       <li id="u7e48b25b">
        <strong>
         统一响应格式设置
        </strong>
        ：使用全局异常处理和响应封装，确保接口返回格式一致。
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li id="uc19ea8a2">
      <strong>
       联动方式实现
      </strong>
      ：通过依赖注入（@Autowired）调用服务层的业务逻辑方法。例如，当处理一个门票订单信息的查询请求时，控制器方法会调用服务层的查询业务逻辑方法，获取数据后将其转换为 Excel 格式返回给客户端。
     </li>
    </ul>
    <p id="ufcbafe90">
    </p>
    <p class="img-center">
     <img alt="" height="264" id="uad11d79f" src="https://i-blog.csdnimg.cn/img_convert/9bfd07fccba0db43b782001d6bcd4d25.png" width="344"/>
    </p>
    <p id="uab995809">
    </p>
    <p id="u5a485e84">
    </p>
    <p id="ua878f606">
    </p>
    <h5 id="x3UTq">
     主要功能模块分析
    </h5>
    <ol>
     <li id="u77a25832">
      <strong>
       数据导入功能
      </strong>
      (
      <code>
       importTicketList
      </code>
      )
     </li>
    </ol>
    <pre id="J8TUO"><code>@Transactional
public TicketImportRespVo importTicketList(List&lt;TicketImportVo&gt; list, Boolean updateSupport)</code></pre>
    <ul>
     <li id="u4fd9c95d">
      实现Excel数据批量导入
     </li>
     <li id="u22a06f5e">
      核心流程：
     </li>
    </ul>
    <ul>
     <li>
      <ul>
       <li id="u46d19a91">
        参数校验 → 数据准备 → 时间格式处理 → 数据转换 → 持久化存储
       </li>
       <li id="udd8fb50f">
        支持事务管理（@Transactional）
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li id="u30dd6e5f">
      关键日志：
     </li>
    </ul>
    <pre id="TLRrN"><code>log.info("导入的数量：{}, 导入数据：{}", list.size(), list);
log.info("\n================================== 导入开始 ============================");</code></pre>
    <ol>
     <li id="ubdcd4eb2">
      <strong>
       基础CRUD操作
      </strong>
     </li>
    </ol>
    <pre id="Bn7r5"><code>// 创建（带ID返回）
Long createTicketOrderInfo(TicketOrderInfoSaveReqVO createReqVO)

// 更新（带存在性校验）
void updateTicketOrderInfo(TicketOrderInfoSaveReqVO updateReqVO)

// 删除（带存在性校验）
void deleteTicketOrderInfo(Long id)

// 分页查询
PageResult&lt;TicketOrderInfoDO&gt; getTicketOrderInfoPage(TicketOrderInfoPageReqVO pageReqVO)</code></pre>
    <ol>
     <li id="u791d78a7">
      <strong>
       校验机制
      </strong>
     </li>
    </ol>
    <pre id="SbJtx"><code>private void validateTicketOrderInfoExists(Long id) {
    if (ticketOrderInfoMapper.selectById(id) == null) {
        throw exception((ErrorCode) TICKET_ORDER_INFO_NOT_EXISTS);
    }
}</code></pre>
    <h5 id="TVZW3">
     关联组件
    </h5>
    <ol>
     <li id="u004c07cd">
      <strong>
       数据访问层
      </strong>
      ：
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="u15a5222c">
        依赖 实现数据库操作
       </li>
       <li id="u6c878573">
        使用 MyBatis-Plus 的
        <code>
         BaseMapperX
        </code>
        基础功能
       </li>
      </ul>
     </li>
    </ul>
    <ol>
     <li id="ue037669b">
      <strong>
       数据传输对象
      </strong>
      ：
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="ue2f9201a">
        入参：
       </li>
       <li id="u8cac0aa6">
        出参：
       </li>
      </ul>
     </li>
    </ul>
    <p id="u7d6cb4d3">
    </p>
    <h5 id="RKq4x">
     TicketOrderInfoController.java
    </h5>
    <p id="u31304ee5">
    </p>
    <pre id="RG5TC"><code>// 包名，表示该控制器位于 cn.iocoder.central.module.ticket.controller.admin 包下
package cn.iocoder.central.module.ticket.controller.admin;

// 导入所需的各类依赖包和自定义类，包括 VO、DO、Service、工具类等
import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoPageReqVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoRespVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.TicketOrderInfoSaveReqVO;
import cn.iocoder.central.module.ticket.controller.admin.vo.excel.TicketImportRespVo;
import cn.iocoder.central.module.ticket.controller.admin.vo.excel.TicketImportVo;
import cn.iocoder.central.module.ticket.dal.dataobject.ticketinfo.TicketOrderInfoDO;
import cn.iocoder.central.module.ticket.service.ticketinfo.TicketOrderInfoService;
import cn.iocoder.yudao.framework.apilog.core.annotation.ApiAccessLog;
import cn.iocoder.yudao.framework.common.pojo.CommonResult;
import cn.iocoder.yudao.framework.common.pojo.PageParam;
import cn.iocoder.yudao.framework.common.pojo.PageResult;
import cn.iocoder.yudao.framework.common.util.object.BeanUtils;
import cn.iocoder.yudao.framework.excel.core.util.ExcelUtils;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

// 静态导入 CommonResult 的 success 方法和 ApiAccessLog 的枚举值 EXPORT
import static cn.iocoder.yudao.framework.apilog.core.enums.OperateTypeEnum.EXPORT;
import static cn.iocoder.yudao.framework.common.pojo.CommonResult.success;

// 使用 Swagger 的 Tag 注解为该控制器添加标签，名称为 "管理后台 - 门票订单信息"
@Tag(name = "管理后台 - 门票订单信息")
// 使用 Spring 的 RestController 注解，表明该类是一个 RESTful 风格的控制器
@RestController
// 使用 RequestMapping 注解，设置该控制器的请求路径前缀为 "/ticket/order/ticket-order-info"
@RequestMapping("/ticket/order/ticket-order-info")
// 使用 Validated 注解，开启参数校验功能
@Validated
public class TicketOrderInfoController {

    // 使用 Resource 注解，按名称自动注入 TicketOrderInfoService 类型的 Bean
    @Resource
    private TicketOrderInfoService ticketOrderInfoService;

    /**
     * 创建门票订单信息
     *
     * @param createReqVO 创建门票订单信息的请求参数对象
     * @return 返回包含创建成功后的订单 ID 的 CommonResult 对象
     */
    @PostMapping("/create")
    @Operation(summary = "创建门票订单信息")
    @PreAuthorize("@ss.hasPermission('order:ticket-order-info:create')")
    public CommonResult&lt;Long&gt; createTicketOrderInfo(@Valid @RequestBody TicketOrderInfoSaveReqVO createReqVO) {
        return success(ticketOrderInfoService.createTicketOrderInfo(createReqVO));
    }

    /**
     * 更新门票订单信息
     *
     * @param updateReqVO 更新门票订单信息的请求参数对象
     * @return 返回表示更新是否成功的 CommonResult 对象
     */
    @PutMapping("/update")
    @Operation(summary = "更新门票订单信息")
    @PreAuthorize("@ss.hasPermission('order:ticket-order-info:update')")
    public CommonResult&lt;Boolean&gt; updateTicketOrderInfo(@Valid @RequestBody TicketOrderInfoSaveReqVO updateReqVO) {
        ticketOrderInfoService.updateTicketOrderInfo(updateReqVO);
        return success(true);
    }

    /**
     * 删除门票订单信息
     *
     * @param id 要删除的订单信息的 ID
     * @return 返回表示删除是否成功的 CommonResult 对象
     */
    @DeleteMapping("/delete")
    @Operation(summary = "删除门票订单信息")
    @Parameter(name = "id", description = "编号", required = true)
    @PreAuthorize("@ss.hasPermission('order:ticket-order-info:delete')")
    public CommonResult&lt;Boolean&gt; deleteTicketOrderInfo(@RequestParam("id") Long id) {
        ticketOrderInfoService.deleteTicketOrderInfo(id);
        return success(true);
    }

    /**
     * 根据 ID 获取门票订单信息
     *
     * @param id 要获取的订单信息的 ID
     * @return 返回包含订单信息的 CommonResult 对象
     */
    @GetMapping("/get")
    @Operation(summary = "获得门票订单信息")
    @Parameter(name = "id", description = "编号", required = true, example = "1024")
    @PreAuthorize("@ss.hasPermission('order:ticket-order-info:query')")
    public CommonResult&lt;TicketOrderInfoRespVO&gt; getTicketOrderInfo(@RequestParam("id") Long id) {
        TicketOrderInfoDO ticketOrderInfo = ticketOrderInfoService.getTicketOrderInfo(id);
        return success(BeanUtils.toBean(ticketOrderInfo, TicketOrderInfoRespVO.class));
    }

    /**
     * 获取门票订单信息分页列表
     *
     * @param pageReqVO 分页查询的请求参数对象
     * @return 返回包含分页结果的 CommonResult 对象
     */
    @GetMapping("/page")
    @Operation(summary = "获得门票订单信息分页")
    @PreAuthorize("@ss.hasPermission('order:ticket-order-info:query')")
    public CommonResult&lt;PageResult&lt;TicketOrderInfoRespVO&gt;&gt; getTicketOrderInfoPage(@Valid TicketOrderInfoPageReqVO pageReqVO) {
        PageResult&lt;TicketOrderInfoDO&gt; pageResult = ticketOrderInfoService.getTicketOrderInfoPage(pageReqVO);
        return success(BeanUtils.toBean(pageResult, TicketOrderInfoRespVO.class));
    }

    /**
     * 导出门票订单信息的 Excel 文件
     *
     * @param pageReqVO 分页查询的请求参数对象，用于指定要导出的数据范围
     * @param response  HTTP 响应对象，用于将生成的 Excel 文件返回给客户端
     * @throws IOException 如果在导出过程中发生 I/O 错误，则抛出该异常
     */
    @GetMapping("/export-excel")
    @Operation(summary = "导出门票订单信息 Excel")
    @PreAuthorize("@ss.hasPermission('order:ticket-order-info:export')")
    @ApiAccessLog(operateType = EXPORT)
    public void exportTicketOrderInfoExcel(@Valid TicketOrderInfoPageReqVO pageReqVO,
                                           HttpServletResponse response) throws IOException {
        // 设置每页显示条数为 -1，表示获取所有数据
        pageReqVO.setPageSize(PageParam.PAGE_SIZE_NONE);
        // 获取分页结果中的数据列表
        List&lt;TicketOrderInfoDO&gt; list = ticketOrderInfoService.getTicketOrderInfoPage(pageReqVO).getList();
        // 使用 ExcelUtils 工具类将数据写入 Excel 文件并返回给客户端
        ExcelUtils.write(response, "门票订单信息.xls", "数据", TicketOrderInfoRespVO.class,
                BeanUtils.toBean(list, TicketOrderInfoRespVO.class));
    }

    /**
     * 导入门票订单信息的 Excel 文件
     *
     * @param file           上传的 Excel 文件
     * @param updateSupport  是否支持更新，默认为 false
     * @return 返回包含导入结果的 CommonResult 对象
     * @throws Exception 如果在导入过程中发生异常，则抛出该异常
     */
    @PostMapping("/import")
    @Operation(summary = "导入门票")
    @Parameters({
            @Parameter(name = "file", description = "Excel 文件", required = true),
            @Parameter(name = "updateSupport", description = "是否支持更新，默认为 false", example = "true")
    })
    @PreAuthorize("@ss.hasPermission('order:child-ticket-order-info:import')")
    public CommonResult&lt;TicketImportRespVo&gt; importExcel(@RequestParam("file") MultipartFile file,
                                                        @RequestParam(value = "updateSupport", required = false, defaultValue = "false") Boolean updateSupport) throws Exception {
        // 使用 ExcelUtils 工具类读取上传的 Excel 文件，转换为 TicketImportVo 对象列表
        List&lt;TicketImportVo&gt; list = ExcelUtils.read(file, TicketImportVo.class);
        // 调用服务层方法处理导入的数据，并返回结果
        return success(ticketOrderInfoService.importTicketList(list, updateSupport));
    }

    /**
     * 获取门票导入的 Excel 模板文件
     *
     * @param response HTTP 响应对象，用于将生成的模板文件返回给客户端
     * @throws IOException 如果在生成或返回模板文件过程中发生 I/O 错误，则抛出该异常
     */
    @GetMapping("/get-ticket-import-template")
    @Operation(summary = "获取门票导入模板")
    public void TicketImportTemplate(HttpServletResponse response) throws IOException {
        // 使用 ExcelUtils 工具类生成模板文件并返回给客户端
        ExcelUtils.write(response, "门票导入模板.xlsx", "门票列表", TicketImportVo.class, null);
    }
}</code></pre>
    <p id="u31294bc0">
    </p>
    <p id="udc853ae4">
    </p>
    <p id="u1c9e3697">
    </p>
    <p id="u0305909b">
    </p>
    <p id="ud73a868c">
     以下是
     <code>
      &lt;mcfile name="TicketOrderInfoController.java" path="c:\project\centralservice\central-module-ticket\central-module-ticket-biz\src\main\java\cn\iocoder\central\module\ticket\controller\admin\TicketOrderInfoController.java"&gt;&lt;/mcfile&gt;
     </code>
     的模块解析：
    </p>
    <h6 id="R1M4e">
     1. 类声明部分
    </h6>
    <pre id="BbVNj"><code>@Tag(name = "管理后台 - 门票订单信息")
@RestController
@RequestMapping("/ticket/order/ticket-order-info")
@Validated
public class TicketOrderInfoController {<!-- --></code></pre>
    <ul>
     <li id="ued49c7e9">
      <code>
       @Tag
      </code>
      ：OpenAPI 文档分组标识（Swagger 文档分类）
     </li>
     <li id="uc011b884">
      <code>
       @RestController
      </code>
      ：声明为 RESTful 控制器（自动处理 JSON 序列化）
     </li>
     <li id="ub83b5234">
      <code>
       @RequestMapping
      </code>
      ：定义基础请求路径为
      <code>
       /ticket/order/ticket-order-info
      </code>
     </li>
     <li id="udd5d0989">
      <code>
       @Validated
      </code>
      ：启用 Spring 参数校验机制
     </li>
    </ul>
    <h6 id="z5EHp">
     2. 服务注入
    </h6>
    <pre id="uLv56"><code>@Resource
private TicketOrderInfoService ticketOrderInfoService;</code></pre>
    <ul>
     <li id="ue41e5127">
      通过
      <code>
       @Resource
      </code>
      注入
      <code>
       &lt;mcsymbol name="TicketOrderInfoService" filename="TicketOrderInfoService.java" path="c:\project\centralservice\central-module-ticket\central-module-ticket-biz\src\main\java\cn\iocoder\central\module\ticket\service\ticketinfo\TicketOrderInfoService.java" startline="19" type="interface"&gt;&lt;/mcsymbol&gt;
      </code>
      服务接口
     </li>
    </ul>
    <h6 id="JrGSV">
     3. 核心接口解析
    </h6>
    <h6 id="l9Fwr">
     3.1 创建接口
    </h6>
    <pre id="UCImT"><code>@PostMapping("/create")
@Operation(summary = "创建门票订单信息")
@PreAuthorize("@ss.hasPermission('order:ticket-order-info:create')")
public CommonResult&lt;Long&gt; createTicketOrderInfo(@Valid @RequestBody TicketOrderInfoSaveReqVO createReqVO) {
    return success(ticketOrderInfoService.createTicketOrderInfo(createReqVO));
}</code></pre>
    <ul>
     <li id="ud806156c">
      <code>
       @PostMapping
      </code>
      ：处理 HTTP POST 请求
     </li>
     <li id="u447fed7a">
      <code>
       @PreAuthorize
      </code>
      ：权限校验（需要
      <code>
       order:ticket-order-info:create
      </code>
      权限）
     </li>
     <li id="u2fe83c52">
      <code>
       @Valid
      </code>
      ：触发
      <code>
       &lt;mcsymbol name="TicketOrderInfoSaveReqVO" filename="TicketOrderInfoSaveReqVO.java" path="c:\project\centralservice\central-module-ticket\central-module-ticket-biz\src\main\java\cn\iocoder\central\module\ticket\controller\admin\vo\TicketOrderInfoSaveReqVO.java" startline="11" type="class"&gt;&lt;/mcsymbol&gt;
      </code>
      的参数校验
     </li>
    </ul>
    <h6 id="iwflN">
     3.2 分页查询接口
    </h6>
    <pre id="B3Sey"><code>@GetMapping("/page")
@Operation(summary = "获得门票订单信息分页")
public CommonResult&lt;PageResult&lt;TicketOrderInfoRespVO&gt;&gt; getTicketOrderInfoPage(...) {
    PageResult&lt;TicketOrderInfoDO&gt; pageResult = ticketOrderInfoService.getTicketOrderInfoPage(pageReqVO);
    return success(BeanUtils.toBean(pageResult, TicketOrderInfoRespVO.class));
}</code></pre>
    <ul>
     <li id="uac56219b">
      <strong>
       数据转换
      </strong>
      ：使用
      <code>
       BeanUtils.toBean
      </code>
      将 DO 对象转换为
      <code>
       &lt;mcsymbol name="TicketOrderInfoRespVO" filename="TicketOrderInfoRespVO.java" path="c:\project\centralservice\central-module-ticket\central-module-ticket-biz\src\main\java\cn\iocoder\central\module\ticket\controller\admin\vo\TicketOrderInfoRespVO.java" startline="12" type="class"&gt;&lt;/mcsymbol&gt;
      </code>
      响应对象
     </li>
     <li id="u2eafdb3d">
      <strong>
       分页机制
      </strong>
      ：继承自
      <code>
       &lt;mcsymbol name="PageParam" filename="PageParam.java" path="c:\project\centralservice\common\yudao-spring-boot-starter-web\src\main\java\cn\iocoder\yudao\framework\common\pojo\PageParam.java" startline="14" type="class"&gt;&lt;/mcsymbol&gt;
      </code>
      的分页基类
     </li>
    </ul>
    <h6 id="P0hxH">
     3.3 导入/导出功能
    </h6>
    <pre id="SsRqW"><code>// 导出 Excel
@GetMapping("/export-excel")
public void exportTicketOrderInfoExcel(...) throws IOException {
    ExcelUtils.write(response, "门票订单信息.xls", "数据", TicketOrderInfoRespVO.class, ...);
}

// 导入 Excel
@PostMapping("/import")
public CommonResult&lt;TicketImportRespVo&gt; importExcel(...) throws Exception {
    List&lt;TicketImportVo&gt; list = ExcelUtils.read(file, TicketImportVo.class);
    return success(ticketOrderInfoService.importTicketList(list, updateSupport));
}</code></pre>
    <ul>
     <li id="u417c71c2">
      <strong>
       Excel 工具
      </strong>
      ：使用
      <code>
       &lt;mcsymbol name="ExcelUtils" filename="ExcelUtils.java" path="c:\project\centralservice\common\yudao-spring-boot-starter-excel\src\main\java\cn\iocoder\yudao\framework\excel\core\util\ExcelUtils.java" startline="24" type="class"&gt;&lt;/mcsymbol&gt;
      </code>
      处理表格数据
     </li>
     <li id="u5079bf67">
      <strong>
       文件操作
      </strong>
      ：
      <code>
       MultipartFile
      </code>
      处理上传文件，
      <code>
       HttpServletResponse
      </code>
      处理下载响应
     </li>
    </ul>
    <h6 id="DcqzB">
     4. 安全控制
    </h6>
    <pre id="EEh8S"><code>@PreAuthorize("@ss.hasPermission('order:ticket-order-info:create')")</code></pre>
    <ul>
     <li id="ua630c264">
      <strong>
       权限模型
      </strong>
      ：使用 Spring Security 表达式控制访问权限
     </li>
     <li id="uccdd18d8">
      <strong>
       权限标识
      </strong>
      ：格式为
      <code>
       模块:功能:操作
      </code>
      （如
      <code>
       order:ticket-order-info:create
      </code>
      ）
     </li>
    </ul>
    <h6 id="XEcBw">
     5. 日志记录
    </h6>
    <pre id="DhJZr"><code>@ApiAccessLog(operateType = EXPORT)</code></pre>
    <ul>
     <li id="u37cabd9b">
      <strong>
       操作日志
      </strong>
      ：通过
      <code>
       &lt;mcsymbol name="ApiAccessLog" filename="ApiAccessLog.java" path="c:\project\centralservice\common\yudao-spring-boot-starter-api-log\src\main\java\cn\iocoder\yudao\framework\apilog\core\annotation\ApiAccessLog.java" startline="14" type="annotation"&gt;&lt;/mcsymbol&gt;
      </code>
      记录导出操作日志
     </li>
    </ul>
    <p id="u0b9933ba">
    </p>
    <h6 id="Q0yrP">
     6. 异常处理机制
    </h6>
    <pre id="C9Tdy"><code>public CommonResult&lt;TicketImportRespVo&gt; importExcel(...) throws Exception {
    // 隐式依赖全局异常处理器（GlobalExceptionHandler）
}</code></pre>
    <ul>
     <li id="ue75ebacc">
      <strong>
       统一异常处理
      </strong>
      ：通过
      <code>
       CommonResult
      </code>
      统一包装响应结果
     </li>
     <li id="ubb571b6e">
      <strong>
       错误传递
      </strong>
      ：Service 层抛出的异常会通过 Spring 的
      <code>
       @ControllerAdvice
      </code>
      拦截处理
     </li>
    </ul>
    <h5 id="eMpw6">
     架构特点
    </h5>
    <ol>
     <li id="u58bf5dd8">
      <strong>
       分层清晰
      </strong>
      ：严格遵循 Controller -&gt; Service -&gt; Mapper 调用链
     </li>
     <li id="u92cfbce0">
      <strong>
       DTO 隔离
      </strong>
      ：使用 VO 对象进行参数传递（
      <code>
       ...ReqVO
      </code>
      /
      <code>
       ...RespVO
      </code>
      ）
     </li>
     <li id="u407f2568">
      <strong>
       组件复用
      </strong>
      ：继承 common 模块中的基础组件（如
      <code>
       PageParam
      </code>
      、
      <code>
       ExcelUtils
      </code>
      ）
     </li>
     <li id="ub7b69ad2">
      <strong>
       文档集成
      </strong>
      ：通过 Swagger 注解实现 API 文档自动生成
     </li>
    </ol>
    <p id="u5c1581da">
    </p>
    <p id="ub2469272">
    </p>
    <p id="ub159716f">
    </p>
    <p id="ubd6337d2">
    </p>
    <p id="uc00ebcd7">
    </p>
    <h4 id="KfApM">
     5. 映射层（Mapper Layer）
    </h4>
    <ul>
     <li id="uc6eb6e8d">
      <strong>
       功能与技术点实现
      </strong>
      ：存放 MyBatis 的映射文件，定义 SQL 语句与 Java 方法的映射关系，实现数据库操作结果与 Java 对象的相互转换。
     </li>
    </ul>
    <ul>
     <li>
      <ul>
       <li id="u2e655c55">
        <strong>
         MyBatis Mapper
        </strong>
        ：通过 XML 文件或注解定义 SQL 映射，支持动态 SQL 和结果集映射。
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li id="u0b586ce3">
      <strong>
       联动方式实现
      </strong>
      ：映射层的 Mapper 接口与 DAL 层的 DAO 类进行交互。DAO 类通过注入 Mapper 接口来执行 SQL 语句，完成数据的持久化操作或数据查询。MyBatis 会根据映射文件或注解中的配置，将 Java 对象转换为数据库操作所需的参数，或者将数据库查询结果映射为 Java 对象返回给 DAL 层。
     </li>
    </ul>
    <p id="u71525a9a">
     通过以上分层架构设计，各层之间通过依赖注入、接口调用、配置文件等方式实现松耦合的联动，共同构建了一个高可用、安全、可扩展且性能优化的门票微服务系统。
    </p>
    <p id="u478705ce">
    </p>
    <p id="u03682ae4">
    </p>
    <p class="img-center">
     <img alt="" height="203" id="u2be852f6" src="https://i-blog.csdnimg.cn/img_convert/82da329370e4322df1cecacfb5e2663b.png" width="342"/>
    </p>
    <p id="u75e69f76">
    </p>
    <h3 id="ef335">
    </h3>
    <h5 id="YFkj3">
     一、核心 Mapper 文件解析
    </h5>
    <h6 id="VKWy9">
     1. TicketOrderInfoMapper.xml
    </h6>
    <pre id="Lf5DE"><code>&lt;!-- 动态查询条件 --&gt;
&lt;select id="selectPageUseXML" resultMap="OrderTicketOrderInfoResultMap"&gt;
    &lt;include refid="selectOrderTicketOrderInfo"/&gt;
    &lt;if test="reqVO.orderCode != null and reqVO.orderCode != ''"&gt;
        AND order_code LIKE CONCAT('%', #{reqVO.orderCode}, '%')
    &lt;/if&gt;
    &lt;if test="reqVO.cenicSpotsName != null and reqVO.cenicSpotsName != ''"&gt;
        AND cenic_spots_name LIKE CONCAT('%', #{reqVO.cenicSpotsName}, '%')
    &lt;/if&gt;
&lt;/select&gt;
&lt;!-- 结果映射 --&gt;
&lt;resultMap id="OrderTicketOrderInfoResultMap" type="TicketOrderInfoRespVO"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="cenicSpotsName" column="cenic_spots_name"/&gt;
    &lt;result property="ticketName" column="ticket_name"/&gt;
    ...
&lt;/resultMap&gt;
</code></pre>
    <h5 id="bMxfS">
     核心功能：
    </h5>
    <ol>
     <li id="uf7709e82">
      <strong>
       动态条件拼接
      </strong>
      ：通过
      <code>
       &lt;if&gt;
      </code>
      标签实现条件过滤
     </li>
     <li id="u6c0d57aa">
      <strong>
       结果集映射
      </strong>
      ：定义数据库字段到 VO 对象的映射关系
     </li>
     <li id="u91c03c5e">
      <strong>
       分页查询支持
      </strong>
      ：与
      <code>
       &lt;mcsymbol name="TicketOrderInfoMapper.selectPage"&gt;&lt;/mcsymbol&gt;
      </code>
      接口方法配合实现分页
     </li>
    </ol>
    <h6 id="N80ON">
     2. ChildTicketOrderInfoMapper.xml
    </h6>
    <pre id="v39cR"><code>&lt;resultMap id="ChildTicketOrderInfoResultMap" type="ChildTicketOrderInfoRespVO"&gt;
    &lt;id property="orderId" column="order_id"/&gt;
    &lt;result property="productName" column="product_name"/&gt;
    &lt;result property="ticketCount" column="ticket_count"/&gt;
    ...
&lt;/resultMap&gt;
</code></pre>
    <p id="u32023fbe">
     <strong>
      功能特点
     </strong>
     ：
    </p>
    <ul>
     <li id="u7f936222">
      处理子订单的复杂字段映射
     </li>
     <li id="u25954552">
      包含金额计算字段（actual_amount 等）
     </li>
     <li id="uc9118e36">
      关联父订单信息的字段映射
     </li>
    </ul>
    <h5 id="sM8g7">
     二、Mapper 接口分析
    </h5>
    <pre id="pBOUP"><code>public interface TicketOrderInfoMapper extends BaseMapperX&lt;TicketOrderInfoDO&gt; {
    
    default PageResult&lt;TicketOrderInfoDO&gt; selectPage(TicketOrderInfoPageReqVO reqVO) {
        return selectPage(reqVO, new LambdaQueryWrapperX&lt;TicketOrderInfoDO&gt;()
            .eqIfPresent(TicketOrderInfoDO::getCenicSpotsId, reqVO.getCenicSpotsId())
            .likeIfPresent(TicketOrderInfoDO::getCenicSpotsName, reqVO.getCenicSpotsName())
            ...);
    }
}</code></pre>
    <h5 id="KZrGg">
     实现机制：
    </h5>
    <ol>
     <li id="u96c0a8b8">
      <strong>
       继承链
      </strong>
      ：
      <code>
       BaseMapperX
      </code>
      →
      <code>
       BaseMapper
      </code>
      （MyBatis-Plus）
     </li>
     <li id="u08f2ef7c">
      <strong>
       动态条件构建
      </strong>
      ：使用 LambdaQueryWrapperX 的链式调用
     </li>
     <li id="u571d7dd6">
      <strong>
       方法命名规范
      </strong>
      ：
     </li>
    </ol>
    <ul>
     <li>
      <ul>
       <li id="ued04453b">
        <code>
         eqIfPresent
        </code>
        ：相等条件（参数非空时生效）
       </li>
       <li id="u3ebf58ba">
        <code>
         likeIfPresent
        </code>
        ：模糊查询条件
       </li>
       <li id="u67b2eb29">
        <code>
         betweenIfPresent
        </code>
        ：范围查询条件
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="xCzsW">
     三、架构特点分析
    </h5>
    <h6 id="xG7u9">
     1. 双模式查询支持
    </h6>
    <table id="P4xQw">
     <tbody>
      <tr>
       <td>
        <p id="u8d1a00b7">
         模式
        </p>
       </td>
       <td>
        <p id="u5aa58de5">
         适用场景
        </p>
       </td>
       <td>
        <p id="u11f10fde">
         示例文件
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u1d05ae7c">
         XML 动态 SQL
        </p>
       </td>
       <td>
        <p id="u2bd866d0">
         复杂多表关联查询
        </p>
       </td>
       <td>
        <p id="uc111904f">
         TicketOrderInfoMapper.xml 中的多条件查询
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="uf9283f0c">
         Java 链式 API
        </p>
       </td>
       <td>
        <p id="u6123ab48">
         简单单表查询
        </p>
       </td>
       <td>
        <p id="u65934fc2">
         TicketOrderInfoMapper.java 中的 selectPage 方法
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h6 id="SosUd">
     2. 性能优化点
    </h6>
    <pre id="qAQsi"><code>&lt;!-- 索引优化示例 --&gt;
&lt;if test="reqVO.orderCode != null and reqVO.orderCode != ''"&gt;
    AND order_code LIKE CONCAT('%', #{reqVO.orderCode}, '%') 
&lt;/if&gt;
</code></pre>
    <ul>
     <li id="uc48defb9">
      对
      <code>
       order_code
      </code>
      字段建议添加普通索引
     </li>
     <li id="u753a8988">
      对
      <code>
       cenic_spots_name
      </code>
      建议添加全文索引
     </li>
    </ul>
    <h6 id="sk9L6">
     3. 安全机制
    </h6>
    <pre id="XQ5m8"><code>&lt;!-- SQL 注入防护 --&gt;
&lt;select id="selectPageUseXML" resultMap="OrderTicketOrderInfoResultMap"&gt;
    SELECT * FROM ticket_order_info 
    WHERE 1=1
    &lt;if test="reqVO.orderCode != null"&gt;
        AND order_code = #{reqVO.orderCode} &lt;!-- 使用预编译语句 --&gt;
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
    <h5 id="MJjlF">
     四、数据流向示意图
    </h5>
    <p class="img-center">
     <img alt="" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F__mermaid_v3%2F83f852a56017de7006c1b972c11c4000.svg&amp;pos_id=Klc2P90E" width="534"/>
    </p>
    <h4 id="cMA1q">
    </h4>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f7368616f7a68656e67303530332f:61727469636c652f64657461696c732f313436323936353033" class_="artid" style="display:none">
 </p>
</div>


