---
layout: post
title: "C的内存管理"
date: 2025-03-09 21:01:59 +0800
description: "如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常， malloc会返回NULL。1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请。1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理。____* pChar3在哪里？"
keywords: "C++的内存管理"
categories: ['C']
tags: ['开发语言', 'C']
artid: "146132369"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146132369
    alt: "C的内存管理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146132369
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146132369
cover: https://bing.ee123.net/img/rand?artid=146132369
image: https://bing.ee123.net/img/rand?artid=146132369
img: https://bing.ee123.net/img/rand?artid=146132369
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++的内存管理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <span style="color:#1a439c">
      1. C/C++内存分布
     </span>
    </h2>
    <p>
     我们先来看下面的一段代码和相关问题
     <br/>
    </p>
    <pre><code class="language-cpp">int globalVar = 1;
static int staticGlobalVar = 1;
void Test()
{
	static int staticVar = 1;
	int localVar = 1;
	int num1[10] = { 1, 2, 3, 4 };
	char char2[] = "abcd";
	const char* pChar3 = "abcd";
	int* ptr1 = (int*)malloc(sizeof(int) * 4);
	int* ptr2 = (int*)calloc(4, sizeof(int));
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
	free(ptr1);
	free(ptr3);
}
</code></pre>
    <p>
     1. 选择题：
     <br/>
     选项 : A.栈 B.堆 C.数据段(静态区) D.代码段(常量区)
     <br/>
     globalVar在哪里？____ staticGlobalVar在哪里？____
     <br/>
     staticVar在哪里？____ localVar在哪里？____
     <br/>
     num1 在哪里？____
     <br/>
     char2在哪里？____* char2在哪里？___
     <br/>
     pChar3在哪里？____* pChar3在哪里？____
    </p>
    <p>
     2. 填空题： sizeof(num1) = ____;
     <br/>
     sizeof(char2) = ____; strlen(char2) = ____;
     <br/>
     sizeof(pChar3) = ____; strlen(pChar3) = ____;
     <br/>
     sizeof(ptr1) = ____;
    </p>
    <p>
     3. sizeof 和 strlen 区别？
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ef171ff78ef74634a104fe73d61725ed.png"/>
    </p>
    <p>
     【说明】
    </p>
    <blockquote>
     <p>
      1.
      <strong>
       栈
      </strong>
      又叫堆栈--非静态局部变量/函数参数/返回值等等，栈是向下增长的。
     </p>
     <p>
      2.
      <strong>
       内存映射段
      </strong>
      是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下）
     </p>
     <p>
      3.
      <strong>
       堆
      </strong>
      用于程序运行时动态内存分配，堆是可以上增长的。
     </p>
     <p>
      4. 数据段--存储全局数据和静态数据。
     </p>
     <p>
      5.
      <strong>
       代码段
      </strong>
      --可执行的代码/只读常量。
     </p>
    </blockquote>
    <h2>
     <span style="color:#1a439c">
      2. C语言中动态内存管理方式：malloc/calloc/realloc/free
     </span>
    </h2>
    <pre><code class="language-cpp">void Test()
{
	int* p1 = (int*)malloc(sizeof(int));
	free(p1);
	// 1.malloc/calloc/realloc的区别是什么？
	int* p2 = (int*)calloc(4, sizeof(int));
	int* p3 = (int*)realloc(p2, sizeof(int) * 10);
	// 这里需要free(p2)吗？
	free(p3);
}</code></pre>
    <h2>
     <span style="color:#1a439c">
      3. C++内存管理方式
     </span>
    </h2>
    <p>
     C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力，而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：
     <strong>
      通过new和delete操作符进行动态内存管理。
     </strong>
    </p>
    <h3>
     <span style="color:#6eaad7">
      3.1 new/delete操作内置类型
     </span>
    </h3>
    <pre><code class="language-cpp">void Test()
{
	// 动态申请一个int类型的空间
	int* ptr4 = new int;
	// 动态申请一个int类型的空间并初始化为10
	int* ptr5 = new int(10);
	// 动态申请10个int类型的空间
	int* ptr6 = new int[10];
	delete ptr4;
	delete ptr5;
	delete[] ptr6;
}</code></pre>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2c9ecbc9dbe34ba783791a699dcac2a0.png"/>
    </p>
    <p>
     注意：
     <strong>
      申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]
     </strong>
     ，注意：匹配起来使用。
    </p>
    <h3>
     <span style="color:#6eaad7">
      3.2 new和delete操作自定义类型
     </span>
    </h3>
    <pre><code class="language-cpp">class A
{
	public :
	A(int a = 0)
		: _a(a)
	{
		cout &lt;&lt; "A():" &lt;&lt; this &lt;&lt; endl;
	} ~
		A()
	{
		cout &lt;&lt; "~A():" &lt;&lt; this &lt;&lt; endl;
	}
private:
	int _a;
};
int main()
{
	// new/delete 和 malloc/free最大区别是 new/delete对于【自定义类型】除了开空间还会调用构
	//造函数和析构函数
		A* p1 = (A*)malloc(sizeof(A));
	A* p2 = new A(1);
	free(p1);
	delete p2;
	// 内置类型是几乎是一样的
	int* p3 = (int*)malloc(sizeof(int)); // C
	int* p4 = new int;
	free(p3);
	delete p4;
	A* p5 = (A*)malloc(sizeof(A) * 10);
	A* p6 = new A[10];
	free(p5);
	delete[] p6;
	return 0;
}</code></pre>
    <p>
     <strong>
      注意：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与free不会
     </strong>
     。
    </p>
    <h2>
     <span style="color:#1a439c">
      4. operator new与operator delete函数（重要点进行讲解）
     </span>
    </h2>
    <h3>
     <span style="color:#6eaad7">
      4.1 operator new与operator delete函数（重点）
     </span>
    </h3>
    <p>
     <span style="color:null">
      <strong>
       new和delete
      </strong>
      是用户进行
      <strong>
       动态内存申请和释放的操作符
      </strong>
      ，
      <strong>
       operator new 和operator delete是系统提供的全局函数
      </strong>
      ，
      <strong>
       new在底层调用operator new全局函数来申请空间
      </strong>
      ，
      <strong>
       delete在底层通过operator delete全局函数来释放空间
      </strong>
      。
     </span>
     <br/>
    </p>
    <pre><code class="language-cpp">//operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，
//尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。

void* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)
{
	// try to allocate size bytes
	void* p;
	while ((p = malloc(size)) == 0)
		if (_callnewh(size) == 0)
		{
			// report no memory
			// 如果申请内存失败了，这里会抛出bad_alloc 类型异常
			static const std::bad_alloc nomem;
			_RAISE(nomem);
		}
	return (p);
} 

//operator delete: 该函数最终是通过free来释放空间的
//* /
void operator delete(void* pUserData)
{
	_CrtMemBlockHeader* pHead;
	RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
	if (pUserData == NULL)
		return;
	_mlock(_HEAP_LOCK); /* block other threads */
	__TRY
		/* get a pointer to memory block header */
		pHead = pHdr(pUserData);
	/* verify block type */
	_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));
	_free_dbg(pUserData, pHead-&gt;nBlockUse);
	__FINALLY
		_munlock(_HEAP_LOCK); /* release other threads */
	__END_TRY_FINALLY
		return;
} /
*
free的实现
* /
#define free(p) _free_dbg(p, _NORMAL_BLOCK)</code></pre>
    <p>
     通过上述两个全局函数的实现知道，
     <strong>
      operator new
     </strong>
     <strong>
      实际也是通过malloc来申请空间
     </strong>
     ，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。
     <strong>
      operator delete 最终是通过free来释放空间的。
     </strong>
    </p>
    <h2>
     <span style="color:#1a439c">
      5. new和delete的实现原理
     </span>
    </h2>
    <h3>
     <span style="color:#6eaad7">
      5.1 内置类型
     </span>
    </h3>
    <p>
     如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常， malloc会返回NULL。
    </p>
    <blockquote>
     <p>
      new的原理
     </p>
     <p>
      1. 调用operator new函数申请空间
     </p>
     <p>
      2. 在申请的空间上执行构造函数，完成对象的构造
     </p>
    </blockquote>
    <blockquote>
     <p>
      delete的原理
     </p>
     <p>
      1. 在空间上执行析构函数，完成对象中资源的清理工作
     </p>
     <p>
      2. 调用operator delete函数释放对象的空间
     </p>
    </blockquote>
    <blockquote>
     <p>
      new T[N]的原理
     </p>
     <p>
      1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请
     </p>
     <p>
      2. 在申请的空间上执行N次构造函数
      <br/>
     </p>
    </blockquote>
    <blockquote>
     <p>
      delete[]的原理
     </p>
     <p>
      1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理
     </p>
     <p>
      2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间
     </p>
    </blockquote>
    <h2>
     <span style="color:#1a439c">
      6. 定位new表达式(placement-new) （了解）
     </span>
    </h2>
    <p>
     定位new表达式是在
     <strong>
      已分配的原始内存空间中调用构造函数初始化一个对象
     </strong>
     。
    </p>
    <p>
     使用格式：
    </p>
    <p>
     <strong>
      new (place_address) type或者new (place_address) type(initializer-list) place_address必须是一个指针，initializer-list是类型的初始化列表
     </strong>
    </p>
    <p>
     使用场景：
    </p>
    <blockquote>
     <p>
      定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。
     </p>
    </blockquote>
    <pre><code class="language-cpp">class A
{
	p
		ublic :
	A(int a = 0)
		: _a(a)
	{
		cout &lt;&lt; "A():" &lt;&lt; this &lt;&lt; endl;
	} ~
		A()
	{
		cout &lt;&lt; "~A():" &lt;&lt; this &lt;&lt; endl;
	}
private:
	int _a;
};
// 定位new/replacement new
int main()
{
	// p1现在指向的只不过是与A对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行
	A* p1 = (A*)malloc(sizeof(A));
	new(p1)A; // 注意：如果A类的构造函数有参数时，此处需要传参
	p1-&gt;~A();
	free(p1);
	A* p2 = (A*)operator new(sizeof(A));
	new(p2)A(10);
	p2-&gt;~A();
	operator delete(p2);
	return 0;
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393639373332362f:61727469636c652f64657461696c732f313436313332333639" class_="artid" style="display:none">
 </p>
</div>


