---
layout: post
title: "音视频入门基础RTP专题19FFmpeg源码中,获取RTP的音频信息的实现下"
date: 2025-03-15 10:15:26 +0800
description: "FFmpeg源码中，获取RTP的音频信息的实现（下）"
keywords: "音视频入门基础：RTP专题（19）——FFmpeg源码中，获取RTP的音频信息的实现（下）"
categories: ['音视频技术', 'Ffmpeg']
tags: ['音视频', 'Ffmpeg']
artid: "146253416"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146253416
    alt: "音视频入门基础RTP专题19FFmpeg源码中,获取RTP的音频信息的实现下"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146253416
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146253416
cover: https://bing.ee123.net/img/rand?artid=146253416
image: https://bing.ee123.net/img/rand?artid=146253416
img: https://bing.ee123.net/img/rand?artid=146253416
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     音视频入门基础：RTP专题（19）——FFmpeg源码中，获取RTP的音频信息的实现（下）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     本文接着《
     <a class="link-info" href="https://blog.csdn.net/u014552102/article/details/146157021?sharetype=blogdetail&amp;sharerId=146157021&amp;sharerefer=PC&amp;sharesource=u014552102&amp;spm=1011.2480.3001.8118" title="音视频入门基础：RTP专题（18）——FFmpeg源码中，获取RTP的音频信息的实现（上）">
      音视频入门基础：RTP专题（18）——FFmpeg源码中，获取RTP的音频信息的实现（上）
     </a>
     》，继续讲解FFmpeg获取SDP描述的RTP流的音频信息到底是从哪个地方获取的。本文的一级标题从“四”开始。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     四、音频采样率
    </h2>
    <p>
     SDP协议中，a=rtpmap属性和a=fmtp属性中的config参数都会包含音频采样率信息。FFmpeg源码中首先会判断config参数中是否存在音频信息，如果存在，那就会从config参数（config是《ISO/IEC 14496-3》中定义的音频对象类型特定解码器配置数据 AudioSpecificConfig）中获取音频采样率；如果不存在，则会从a=rtpmap属性中获取音频采样率：
    </p>
    <p>
     <img alt="" height="501" src="https://i-blog.csdnimg.cn/direct/bc9e9a27ad244a9594cb56d5e4510bbb.png" width="1327"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     由《
     <a href="https://blog.csdn.net/u014552102/article/details/143202232?spm=1001.2014.3001.5502" title="音视频入门基础：AAC专题（11）——AudioSpecificConfig简介">
      音视频入门基础：AAC专题（11）——AudioSpecificConfig简介
     </a>
     》可以知道，AudioSpecificConfig中存在一个占4位的samplingFrequencyIndex属性，表示音频的采样频率：
    </p>
    <p>
     <img alt="" height="625" src="https://i-blog.csdnimg.cn/direct/f85f6c0986024c6c9f1e6d8dc6758ad2.png" width="1080"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     FFmpeg源码的aac_decode_init函数中，会判断avctx-&gt;extradata_size是否大于0（avctx-&gt;extradata_size为SDP协议中config参数携带的内容的长度），大于0才表示config参数携带信息，才会执行decode_audio_specific_config函数：
    </p>
    <pre><code class="language-cpp">static av_cold int aac_decode_init(AVCodecContext *avctx)
{
//...
    if (avctx-&gt;extradata_size &gt; 0) {
        if ((ret = decode_audio_specific_config(ac, ac-&gt;avctx, &amp;ac-&gt;oc[1].m4ac,
                                                avctx-&gt;extradata,
                                                avctx-&gt;extradata_size * 8LL,
                                                1)) &lt; 0)
            return ret;
    } 
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     decode_audio_specific_config函数内部会调用decode_audio_specific_config_gb函数：
    </p>
    <pre><code class="language-cpp">static int decode_audio_specific_config(AACDecContext *ac,
                                        AVCodecContext *avctx,
                                        MPEG4AudioConfig *m4ac,
                                        const uint8_t *data, int64_t bit_size,
                                        int sync_extension)
{
//...
    return decode_audio_specific_config_gb(ac, avctx, m4ac, &amp;gb, 0,
                                           sync_extension);
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     由《
     <a href="https://blog.csdn.net/u014552102/article/details/143277399?sharetype=blogdetail&amp;sharerId=143277399&amp;sharerefer=PC&amp;sharesource=u014552102&amp;spm=1011.2480.3001.8118" title="音视频入门基础：AAC专题（12）——FFmpeg源码中，解码AudioSpecificConfig的实现">
      音视频入门基础：AAC专题（12）——FFmpeg源码中，解码AudioSpecificConfig的实现
     </a>
     》可以知道，
    </p>
    <p>
     ff_mpeg4audio_get_config_gb函数中，通过语句：c-&gt;sample_rate = get_sample_rate(gb, &amp;c-&gt;sampling_index)获取AudioSpecificConfig的samplingFrequencyIndex属性。执行decode_audio_specific_config_gb函数后，m4ac指向的变量会得到从AudioSpecificConfig中解码出来的属性：
    </p>
    <pre><code class="language-cpp">static inline int get_sample_rate(GetBitContext *gb, int *index)
{
    *index = get_bits(gb, 4);
    return *index == 0x0f ? get_bits(gb, 24) :
        ff_mpeg4audio_sample_rates[*index];
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在decode_audio_specific_config_gb函数外部，通过aac_decode_frame_int函数将上一步得到的samplingFrequencyIndex属性赋值给AVCodecContext的sample_rate：
    </p>
    <pre><code class="language-cpp">static int aac_decode_frame_int(AVCodecContext *avctx, AVFrame *frame,
                                int *got_frame_ptr, GetBitContext *gb,
                                const AVPacket *avpkt)
{
//...
    if (ac-&gt;oc[1].status &amp;&amp; audio_found) {
        avctx-&gt;sample_rate = ac-&gt;oc[1].m4ac.sample_rate &lt;&lt; multiplier;
        avctx-&gt;frame_size = samples;
        ac-&gt;oc[1].status = OC_LOCKED;
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在dump_stream_format函数中，通过avcodec_string函数中的语句：av_bprintf(&amp;bprint, "%d Hz, ", enc-&gt;sample_rate)拿到上一步中得到的AVCodecContext的sample_rate。最后再在dump_stream_format函数中将profile打印出来：
    </p>
    <pre><code class="language-cpp">void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
{
//...
    switch (enc-&gt;codec_type) {
    case AVMEDIA_TYPE_AUDIO:
        av_bprintf(&amp;bprint, "%s", separator);
 
        if (enc-&gt;sample_rate) {
            av_bprintf(&amp;bprint, "%d Hz, ", enc-&gt;sample_rate);
        }
//...
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     五、音频声道数
    </h2>
    <p>
     FFmpeg获取SDP描述的RTP流的音频声道数，是从SDP的a=rtpmap属性获取的。比如SDP中某一行的内容为：
    </p>
    <pre><code class="language-bash">a=rtpmap:97 MPEG4-GENERIC/48000/2</code></pre>
    <p>
     该例子中，该行的“48000”后面的那个“2”就是音频声道数，表示是双声道（立体声）。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     当识别到上述“a=rtpmap”这个&lt;type&gt;后，sdp_parse_line函数中会调用sdp_parse_rtpmap函数：
    </p>
    <pre><code class="language-cpp">else if (av_strstart(p, "rtpmap:", &amp;p) &amp;&amp; s-&gt;nb_streams &gt; 0) {
            /* NOTE: rtpmap is only supported AFTER the 'm=' tag */
            get_word(buf1, sizeof(buf1), &amp;p);
            payload_type = atoi(buf1);
            rtsp_st = rt-&gt;rtsp_streams[rt-&gt;nb_rtsp_streams - 1];
            if (rtsp_st-&gt;stream_index &gt;= 0) {
                st = s-&gt;streams[rtsp_st-&gt;stream_index];
                sdp_parse_rtpmap(s, st, rtsp_st, payload_type, p);
            }
            s1-&gt;seen_rtpmap = 1;
            if (s1-&gt;seen_fmtp) {
                parse_fmtp(s, rt, payload_type, s1-&gt;delayed_fmtp);
            }
        } </code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     sdp_parse_rtpmap函数中会把a=rtpmap属性中的音频通道数提取出来，并通过语句：av_channel_layout_default(&amp;par-&gt;ch_layout, i)把音频声道数赋值给par-&gt;ch_layout。par-&gt;ch_layout为指向一个AVCodecParameters类型变量的指针：
    </p>
    <pre><code class="language-cpp">/* parse the rtpmap description: &lt;codec_name&gt;/&lt;clock_rate&gt;[/&lt;other params&gt;] */
static int sdp_parse_rtpmap(AVFormatContext *s,
                            AVStream *st, RTSPStream *rtsp_st,
                            int payload_type, const char *p)
{
//...
    switch (par-&gt;codec_type) {
    case AVMEDIA_TYPE_AUDIO:
    //...
        par-&gt;ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;
        if (i &gt; 0) {
            par-&gt;sample_rate = i;
            avpriv_set_pts_info(st, 32, 1, par-&gt;sample_rate);
            get_word_sep(buf, sizeof(buf), "/", &amp;p);
            i = atoi(buf);
            if (i &gt; 0)
                av_channel_layout_default(&amp;par-&gt;ch_layout, i);
        }
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在sdp_parse_rtpmap函数外部，通过avcodec_parameters_to_context函数将AVCodecParameters的ch_layout赋值给AVCodecContext的ch_layout：
    </p>
    <pre><code class="language-cpp">int avcodec_parameters_to_context(AVCodecContext *codec,
                                  const AVCodecParameters *par)
{
//...
    switch (par-&gt;codec_type) {
    case AVMEDIA_TYPE_AUDIO:
        ret = av_channel_layout_copy(&amp;codec-&gt;ch_layout, &amp;par-&gt;ch_layout);
        //....
        break;
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     然后在dump_stream_format函数中，通过avcodec_string函数中的语句:av_channel_layout_describe_bprint(&amp;enc-&gt;ch_layout, &amp;bprint)拿到AVCodecContext的ch_layout对应的音频声道数目。最后再在dump_stream_format函数中将音频声道数目打印出来：
    </p>
    <pre><code class="language-cpp">void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
{
//...
    switch (enc-&gt;codec_type) {
    case AVMEDIA_TYPE_AUDIO:
        av_channel_layout_describe_bprint(&amp;enc-&gt;ch_layout, &amp;bprint);
        //...
        break;
    }
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     所以FFmpeg获取SDP描述的RTP流的音频声道数，是从SDP的a=rtpmap属性获取的：
    </p>
    <p>
     <img alt="" height="542" src="https://i-blog.csdnimg.cn/direct/6d8abb5ce9794f9eaf4befaf9f782840.png" width="1329"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     六、Bit depth
    </h2>
    <p>
     如果SDP描述的RTP流的音频压缩编码格式为AAC，FFmpeg会强制把Bit depth设置为fltp。这是因为对于有损压缩编解码器（如MP3和AAC），Bit depth是在编码期间计算的，并且可以因采样而异，Bit depth只对PCM数字信号有意义。具体可以参考：《
     <a href="https://blog.csdn.net/u014552102/article/details/142200113?spm=1001.2014.3001.5502" title="音视频入门基础：AAC专题（3）——AAC的ADTS格式简介">
      音视频入门基础：AAC专题（3）——AAC的ADTS格式简介
     </a>
     》。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     可以看到在aac_decode_init函数中（该函数定义在libavcodec/aacdec_template.c），强制把音频采样格式设置成了AV_SAMPLE_FMT_FLTP：
    </p>
    <pre><code class="language-cpp">static av_cold int aac_decode_init(AVCodecContext *avctx)
{
//...
    avctx-&gt;sample_fmt = AV_SAMPLE_FMT_FLTP;
//...
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     所以如果SDP描述的RTP流的音频压缩编码格式为AAC，通过“ffmpeg -protocol_whitelist "file,rtp,udp" -i XXX.sdp命令”获取到的音频采样格式固定为fltp，该值没有意义：
    </p>
    <p>
     <img alt="" height="482" src="https://i-blog.csdnimg.cn/direct/5f483e01270742499973ed1a6ba8c526.png" width="1324"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031343535323130322f:61727469636c652f64657461696c732f313436323533343136" class_="artid" style="display:none">
 </p>
</div>


