---
layout: post
title: "Qt中的锁和条件变量和信号量"
date: 2025-08-30T22:03:22+0800
description: "有时在多线程编程中，需要确保多个线程可以相应的访问⼀个数量有限的相同资源。例如，运⾏程序的设备可能是⾮常有限的内存，因此我们更希望需要⼤量内存的线程将这⼀事实考虑在内，并根据可⽤的内存数量进⾏相关操作，多线程编程中类似问题通常⽤信号量来处理。信号量类似于增强的互斥锁，不仅能完成上锁和解锁操作，⽽且可以跟踪可⽤资源的数量。特点：QSemaphore 是 Qt 框架提供的计数信号量类，⽤于控制同时访问共享资源的线程数量。⽤途：限制并发线程数量，⽤于解决⼀些资源有限的问题。"
keywords: "Qt中的锁和条件变量和信号量"
categories: ['未分类']
tags: ['开发语言', 'Qt', 'Java']
artid: "151026824"
arturl: "https://blog.csdn.net/Mr_Xuhhh/article/details/151026824"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151026824
    alt: "Qt中的锁和条件变量和信号量"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151026824
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151026824
cover: https://bing.ee123.net/img/rand?artid=151026824
image: https://bing.ee123.net/img/rand?artid=151026824
img: https://bing.ee123.net/img/rand?artid=151026824
---



# Qt中的锁和条件变量和信号量

## Qt中的锁和条件变量和信号量

C++11中引入智能指针用来解决锁忘记释放的问题

代码如下：

```C++
void Thread::run()
{
    for(int i=0;i<50000;i++)
    {
        QMutexLocker locker(&mutex);
        //mutex.lock();
        num++;
        //mutex.unlock();
    }
}

```

大括号结束的时候，生命周期踩结束，会在析构函数里面进行解锁

多个线程之间的调度是无序的，所以需要条件变量来干预顺序

```C++
1QMutex mutex;
2 QWaitCondition condition;
3
4 //在等待线程中
5 mutex.lock();
6
7 //检查条件是否满⾜，若不满⾜则等待
8
9 while (!conditionFullfilled()) 
10 {
11 condition.wait(&mutex); //等待条件满⾜并释放锁
12 }
13
14 //条件满⾜后继续执⾏
15 //...
16
17 mutex.unlock();
18
19 //在改变条件的线程中
20 mutex.lock();
21
22 //改变条件
23 changeCondition();
24 condition.wakeAll(); //唤醒等待的线程
25
26 mutex.unlock();

```

信号量

有时在多线程编程中，需要确保多个线程可以相应的访问⼀个数量有限的相同资源。例如，运⾏程序的设备可能是⾮常有限的内存，因此我们更希望需要⼤量内存的线程将这⼀事实考虑在内，并根据可⽤的内存数量进⾏相关操作，多线程编程中类似问题通常⽤信号量来处理。信号量类似于增强的互斥锁，不仅能完成上锁和解锁操作，⽽且可以跟踪可⽤资源的数量。

特点：QSemaphore 是 Qt 框架提供的计数信号量类，⽤于控制同时访问共享资源的线程数量。

⽤途：限制并发线程数量，⽤于解决⼀些资源有限的问题。

```C++
QSemaphore semaphore(2); //同时允许两个线程访问共享资源
//在需要访问共享资源的线程中
semaphore.acquire(); //尝试获取信号量，若已满则阻塞
//访问共享资源
//...
semaphore.release(); //释放信号量
//在另⼀个线程中进⾏类似操作

```



