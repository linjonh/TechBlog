---
layout: post
title: "深入理解HTTP与HTTPS协议原理与C实战指南"
date: 2025-03-14 09:59:23 +0800
description: "适合内网通信、不敏感数据（如天气API）"
keywords: "深入理解HTTP与HTTPS：协议原理与C++实战指南"
categories: ['未分类']
tags: ['Https', 'Http', 'C']
artid: "146249030"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146249030
    alt: "深入理解HTTP与HTTPS协议原理与C实战指南"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146249030
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146249030
cover: https://bing.ee123.net/img/rand?artid=146249030
image: https://bing.ee123.net/img/rand?artid=146249030
img: https://bing.ee123.net/img/rand?artid=146249030
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深入理解HTTP与HTTPS：协议原理与C++实战指南
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5 style="background-color:transparent">
     <strong>
      一、引言：HTTP与HTTPS是什么？
     </strong>
    </h5>
    <p>
     <strong>
      HTTP（HyperText Transfer Protocol）
     </strong>
     是互联网上应用最广泛的协议之一，用于客户端（如浏览器）与服务器之间的通信。它基于明文传输，简单高效，但缺乏安全性。
     <br/>
     <strong>
      HTTPS（HTTP Secure）
     </strong>
     则是HTTP的安全版本，通过SSL/TLS协议对通信内容进行加密，确保数据在传输过程中不被窃取或篡改，广泛应用于支付、登录等敏感场景。
    </p>
    <p>
     用一个生活化的比喻来理解：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        HTTP
       </strong>
       就像寄送明信片——内容公开，任何人都能看到和修改。
      </p>
     </li>
     <li>
      <p>
       <strong>
        HTTPS
       </strong>
       则像用加密保险箱寄送机密文件——只有收件人有钥匙，确保内容安全。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      二、核心区别：HTTP vs HTTPS
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        HTTP
       </th>
       <th>
        HTTPS
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         加密
        </strong>
       </td>
       <td>
        无
       </td>
       <td>
        对称加密 + 非对称加密（SSL/TLS）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         默认端口
        </strong>
       </td>
       <td>
        80
       </td>
       <td>
        443
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         证书
        </strong>
       </td>
       <td>
        无需证书
       </td>
       <td>
        需CA机构颁发的数字证书
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据安全
        </strong>
       </td>
       <td>
        易被窃听、篡改
       </td>
       <td>
        防窃听、防篡改、身份验证
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         性能
        </strong>
       </td>
       <td>
        低延迟
       </td>
       <td>
        略高延迟（加密/解密开销）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      三、协议格式详解
     </strong>
    </h4>
    <p>
     无论是HTTP还是HTTPS，应用层的数据格式是相同的，但HTTPS会在传输前加密数据。
    </p>
    <h5>
     <strong>
      1. HTTP请求格式
     </strong>
    </h5>
    <pre><code class="language-bash">POST /api/data HTTP/1.1          ← 请求行（方法 + 路径 + 协议版本）
Host: www.example.com             ← 头部字段（键值对）
Content-Type: application/json
Content-Length: 23                ← 必须声明正文长度

{"data": "hello world"}           ← 正文（Body）</code></pre>
    <h5>
     <strong>
      2. HTTP响应格式
     </strong>
    </h5>
    <pre><code class="language-html">HTTP/1.1 200 OK                   ← 状态行（版本 + 状态码 + 原因短语）
Content-Type: text/html
Content-Length: 34

&lt;html&gt;Welcome to example.com&lt;/html&gt;</code></pre>
    <h5>
     <strong>
      3. HTTPS加密后的数据包结构
     </strong>
    </h5>
    <p>
     复制
    </p>
    <pre>+---------------------+---------------------+
|   TLS Record Header |   Encrypted Data    |
+---------------------+---------------------+
|  TLS版本、类型、长度 | 加密后的HTTP原始数据 |</pre>
    <ul>
     <li>
      <p>
       <strong>
        加密过程
       </strong>
       ：通过TLS握手协商对称密钥，后续通信使用对称加密（如AES）保护数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关键点
       </strong>
       ：加密后的数据在传输层（TCP）不可读 ；只有通过TLS握手建立的对称密钥才能解密。
      </p>
     </li>
    </ul>
    <h5>
     4.
     <strong>
      关键字段说明
     </strong>
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        字段名
       </th>
       <th>
        作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         Content-Length
        </code>
       </td>
       <td>
        正文长度（字节）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Transfer-Encoding
        </code>
       </td>
       <td>
        分块传输（chunked）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Connection
        </code>
       </td>
       <td>
        Keep-Alive 或 Close
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Cookie
        </code>
       </td>
       <td>
        客户端携带的Cookie数据
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <strong>
      四、关键协议细节
     </strong>
    </h4>
    <h5>
     1.
     <strong>
      分块传输编码（Chunked Encoding）
     </strong>
    </h5>
    <p>
     当响应长度未知时使用：
    </p>
    <pre><code class="language-html">HTTP/1.1 200 OK
Transfer-Encoding: chunked

7\r\n        ← 第一个块的长度（十六进制）
Chunk1\r\n
3\r\n
End\r\n
0\r\n        ← 结束标志
\r\n</code></pre>
    <h5>
     2.
     <strong>
      状态码分类
     </strong>
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        范围
       </th>
       <th>
        类别
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1xx
       </td>
       <td>
        信息响应
       </td>
       <td>
        100 Continue
       </td>
      </tr>
      <tr>
       <td>
        2xx
       </td>
       <td>
        成功
       </td>
       <td>
        200 OK
       </td>
      </tr>
      <tr>
       <td>
        3xx
       </td>
       <td>
        重定向
       </td>
       <td>
        301 Moved Permanently
       </td>
      </tr>
      <tr>
       <td>
        4xx
       </td>
       <td>
        客户端错误
       </td>
       <td>
        404 Not Found
       </td>
      </tr>
      <tr>
       <td>
        5xx
       </td>
       <td>
        服务器错误
       </td>
       <td>
        503 Service Unavailable
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
    </h4>
    <hr/>
    <h4 style="background-color:transparent">
     <strong>
      五、C++代码示例：手动解析HTTP请求
     </strong>
    </h4>
    <p>
     以下代码模拟解析原始HTTP请求数据：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;

// 解析HTTP请求的简单实现
void parse_http_request(const std::string&amp; raw_data) {
    std::istringstream stream(raw_data);
    std::string line;
    
    // 1. 解析请求行
    std::getline(stream, line);
    std::cout &lt;&lt; "Request Line: " &lt;&lt; line &lt;&lt; std::endl;

    // 2. 解析头部
    std::map&lt;std::string, std::string&gt; headers;
    while (std::getline(stream, line) {
        if (line.empty() || line == "\r") break; // 头部结束
        size_t colon_pos = line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = line.substr(0, colon_pos);
            std::string value = line.substr(colon_pos + 2); // 跳过": "
            headers[key] = value;
        }
    }

    // 3. 输出头部
    std::cout &lt;&lt; "\nHeaders:" &lt;&lt; std::endl;
    for (const auto&amp; [key, value] : headers) {
        std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl;
    }

    // 4. 解析正文
    size_t body_start = raw_data.find("\r\n\r\n");
    if (body_start != std::string::npos) {
        std::string body = raw_data.substr(body_start + 4);
        std::cout &lt;&lt; "\nBody:\n" &lt;&lt; body &lt;&lt; std::endl;
    }
}

int main() {
    // 模拟原始HTTP请求数据
    std::string http_request = 
        "POST /api/login HTTP/1.1\r\n"
        "Host: www.example.com\r\n"
        "User-Agent: C++Parser/1.0\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: 27\r\n"
        "\r\n"
        "{\"user\":\"admin\",\"pass\":\"123\"}";

    parse_http_request(http_request);
    return 0;
}</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：
    </p>
    <h4 style="background-color:transparent">
     <strong>
      六、C++代码示例：主流开源库代码
     </strong>
    </h4>
    <p>
     我们将使用两个流行的开源库演示：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        libcurl
       </strong>
       （简单易用）
      </p>
     </li>
     <li>
      <p>
       <strong>
        Boost.Beast
       </strong>
       （高性能、底层控制）
      </p>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      示例1：使用libcurl发送HTTP/HTTPS请求
     </strong>
    </h5>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;curl/curl.h&gt;

// 回调函数，处理接收到的数据
size_t write_callback(char* ptr, size_t size, size_t nmemb, void* userdata) {
    std::string* response = (std::string*)userdata;
    response-&gt;append(ptr, size * nmemb);
    return size * nmemb;
}

int main() {
    CURL* curl = curl_easy_init();
    std::string response;

    if (curl) {
        // 设置目标URL（HTTP或HTTPS）
        curl_easy_setopt(curl, CURLOPT_URL, "https://www.example.com");
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;response);

        // 针对HTTPS的额外配置
#ifdef SKIP_PEER_VERIFICATION
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); // 不验证证书（危险！仅用于测试）
#endif

        CURLcode res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            std::cerr &lt;&lt; "Curl failed: " &lt;&lt; curl_easy_strerror(res) &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "Response:\n" &lt;&lt; response &lt;&lt; std::endl;
        }

        curl_easy_cleanup(curl);
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      编译命令
     </strong>
     （Linux）：
    </p>
    <pre><code class="language-bash">g++ -o curl_example curl_example.cpp -lcurl</code></pre>
    <hr/>
    <h5>
     <strong>
      示例2：使用Boost.Beast实现HTTPS客户端
     </strong>
    </h5>
    <pre><code class="language-cpp">#include &lt;boost/beast.hpp&gt;
#include &lt;boost/beast/ssl.hpp&gt;
#include &lt;boost/asio/connect.hpp&gt;
#include &lt;boost/asio/ip/tcp.hpp&gt;
#include &lt;boost/asio/ssl/stream.hpp&gt;
#include &lt;iostream&gt;

namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
namespace ssl = net::ssl;

int main() {
    try {
        // 1. 初始化SSL上下文
        ssl::context ctx(ssl::context::tlsv12_client);
        ctx.set_default_verify_paths(); // 加载系统证书

        // 2. 创建IO上下文和SSL流
        net::io_context ioc;
        ssl::stream&lt;net::ip::tcp::socket&gt; stream(ioc, ctx);
        
        // 3. 解析域名
        net::ip::tcp::resolver resolver(ioc);
        auto const results = resolver.resolve("www.example.com", "443");

        // 4. 建立连接
        net::connect(stream.next_layer(), results.begin(), results.end());
        stream.handshake(ssl::stream_base::client);

        // 5. 构造HTTP请求
        http::request&lt;http::string_body&gt; req{http::verb::get, "/", 11};
        req.set(http::field::host, "www.example.com");
        req.set(http::field::user_agent, "Boost.Beast HTTPS Example");

        // 6. 发送请求并读取响应
        http::write(stream, req);
        beast::flat_buffer buffer;
        http::response&lt;http::dynamic_body&gt; res;
        http::read(stream, buffer, res);

        // 7. 输出结果
        std::cout &lt;&lt; "Response Code: " &lt;&lt; res.result_int() &lt;&lt; std::endl;
        std::cout &lt;&lt; "Body:\n" &lt;&lt; beast::make_printable(res.body().data()) &lt;&lt; std::endl;

    } catch (std::exception const&amp; e) {
        std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    return 0;
}</code></pre>
    <p>
     <strong>
      编译命令
     </strong>
     （需要安装Boost和OpenSSL）：
    </p>
    <pre><code class="language-bash">g++ -o beast_https beast_https.cpp -lboost_system -lssl -lcrypto</code></pre>
    <hr/>
    <h4 style="background-color:transparent">
     <strong>
      七、性能对比
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        场景
       </th>
       <th>
        HTTP延迟
       </th>
       <th>
        HTTPS延迟
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        短连接
       </td>
       <td>
        100ms
       </td>
       <td>
        200ms
       </td>
      </tr>
      <tr>
       <td>
        长连接
       </td>
       <td>
        持续低
       </td>
       <td>
        初始高，后续低
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      优化建议
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       启用HTTP/2（多路复用）
      </p>
     </li>
     <li>
      <p>
       会话复用（TLS Session Resumption）
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      八、总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        HTTP
       </strong>
       ：适合内网通信、不敏感数据（如天气API）
      </p>
     </li>
     <li>
      <p>
       <strong>
        HTTPS
       </strong>
       ：必须用于登录、支付等敏感场景
      </p>
     </li>
     <li>
      <p>
       <strong>
        C++实现
       </strong>
       ：优先使用成熟库（libcurl/Boost.Beast），避免手写加密逻辑
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343732373531372f:61727469636c652f64657461696c732f313436323439303330" class_="artid" style="display:none">
 </p>
</div>


