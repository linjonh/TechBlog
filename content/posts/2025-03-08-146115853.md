---
layout: post
title: "探索stdthread,让-C-程序-火力全开"
date: 2025-03-08 16:08:51 +0800
description: "在 C++ 编程领域，多线程编程是提升程序性能和实现高效并发的关键手段。它允许程序同时执行多个任务，充分利用多核处理器的优势，在诸如游戏开发、服务器端编程、数据分析等诸多场景中发挥着重要作用。接下来，让我们一同学习线程的的相关知识。"
keywords: "探索std::thread，让 C++ 程序 “火力全开”"
categories: ['未分类']
tags: ['开发语言', 'C']
artid: "146115853"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146115853
    alt: "探索stdthread,让-C-程序-火力全开"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146115853
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146115853
cover: https://bing.ee123.net/img/rand?artid=146115853
image: https://bing.ee123.net/img/rand?artid=146115853
img: https://bing.ee123.net/img/rand?artid=146115853
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     探索std::thread，让 C++ 程序 “火力全开”
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在 C++ 编程领域，多线程编程是提升程序性能和实现高效并发的关键手段。它允许程序同时执行多个任务，充分利用多核处理器的优势，在诸如游戏开发、服务器端编程、数据分析等诸多场景中发挥着重要作用。接下来，让我们一同学习线程的
     <code>
      std::thread
     </code>
     的相关知识。
    </p>
    <h2>
     <a id="_1">
     </a>
     一、线程的创建与启动
    </h2>
    <ul>
     <li>
      <strong>
       函数指针作为线程入口
      </strong>
      <br/>
      通过
      <code>
       std::thread
      </code>
      构造函数传递函数指针或可调用对象,在传递参数时，默认是
      <strong>
       按值传递
      </strong>
      的。若需要传递引用类型的参数，则必须使用std::ref或std::cref
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 按引用传递</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <strong>
       类成员函数作为线程入口
      </strong>
      <br/>
      需要传递成员函数的指针、类对象的指针以及成员函数所需的参数
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Working with value: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    MyClass obj<span class="token punctuation">;</span>
    <span class="token keyword">int</span> param <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建线程，以类的成员函数作为入口</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>MyClass<span class="token double-colon punctuation">::</span>work<span class="token punctuation">,</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <strong>
       以Lambda表达式作为线程入口
      </strong>
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用 Lambda 表达式创建线程</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data from Lambda thread: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <strong>
       函数对象作为入口
      </strong>
      <br/>
      需重载 operator()，对象会被复制到线程存储空间
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">Task</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">operator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Task executed"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
   		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
   Task task<span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//调用task的operator</span>
   t<span class="token punctuation">.</span>join<span class="token punctuation">;</span>
   <span class="token keyword">return</span>  <span class="token number">0</span>；
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="_67">
     </a>
     二、线程生命周期管理
    </h2>
    <p>
     线程在
     <code>
      std::thread
     </code>
     对象构造时立即启动，而非调用
     <code>
      join()
     </code>
     时才开始执行
    </p>
    <h4>
     <a id="1_join_69">
     </a>
     1. join()
    </h4>
    <p>
     join() 方法会阻塞当前线程，直到被调用的线程执行完毕。调用 join() 后，线程对象不再关联任何线程，即该线程对象不再可连接（joinable() 返回 false）
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread is working..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//主线程等待t完成</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread has finished."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="2_detach_88">
     </a>
     2. detach（）
    </h4>
    <p>
     detach() 方法将线程分离，使其在后台独立运行，当前线程不再对其进行控制。分离后的线程在执行完毕后会自动释放资源。一旦调用 detach()，线程对象也不再可连接。
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Detached thread has finished."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//主线程t分离</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread continues..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <em>
      注意：使用 detach() 时要确保线程访问的资源在其执行期间不会被销毁，否则会导致未定义行为
     </em>
    </p>
    <h4>
     <a id="3joinable_109">
     </a>
     3.joinable()
    </h4>
    <ol>
     <li>
      <p>
       作用：
       <code>
        joinable()
       </code>
       用于检查线程对象是否处于
       <strong>
        可结合状态
       </strong>
       （即是否可以调用
       <code>
        join()
       </code>
       或
       <code>
        detach()
       </code>
       ）。其返回值为布尔类型：
      </p>
      <ul>
       <li>
        <strong>
         <code>
          true
         </code>
        </strong>
        ：线程已启动且未调用过
        <code>
         join()
        </code>
        或
        <code>
         detach()
        </code>
        ，仍持有底层线程资源。
       </li>
       <li>
        <code>
         false
        </code>
        ：线程不可结合，可能因以下原因：
        <ol>
         <li>
          默认构造（未关联任何线程）。
         </li>
         <li>
          已被移动（资源所有权转移至其他对象）
         </li>
         <li>
          已调用
          <code>
           join()
          </code>
          或
          <code>
           detach()
          </code>
          （资源已释放或分离）
         </li>
        </ol>
       </li>
      </ul>
     </li>
     <li>
      <p>
       使用场景：
      </p>
      <ol>
       <li>
        <p>
         <strong>
          安全调用
          <code>
           join()
          </code>
          或
          <code>
           detach()
          </code>
         </strong>
         在调用
         <code>
          join()
         </code>
         或
         <code>
          detach()
         </code>
         前检查
         <code>
          joinable()
         </code>
         ，避免重复操作导致的未定义行为；
        </p>
       </li>
       <li>
        <p>
         <strong>
          异常处理与资源管理
         </strong>
         若线程未正确处理，析构时可能导致程序终止（
         <code>
          std::terminate()
         </code>
         ）。通过
         <code>
          joinable()
         </code>
         确保析构前正确处理线程
        </p>
       </li>
       <li>
        <p>
         <strong>
          移动语义与线程所有权转移
         </strong>
         当线程对象被移动后，原对象变为不可结合
        </p>
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     <a id="4_124">
     </a>
     4.线程的移动语义
    </h4>
    <p>
     <code>
      std::thread
     </code>
     类支持移动语义，但不支持复制语义。这意味着可以将一个线程的所有权从一个
     <code>
      std::thread
     </code>
     对象转移到另一个对象。
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread is working..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 转移线程所有权</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在上述代码中，
     <code>
      std::move(t1)
     </code>
     将线程的所有权从
     <code>
      t1
     </code>
     转移到
     <code>
      t2
     </code>
     ，转移后
     <code>
      t1
     </code>
     不再关联任何线程。
    </p>
    <h4>
     <a id="5RAIIResource_Acquisition_Is_Initialization_146">
     </a>
     5.RAII(Resource Acquisition Is Initialization，资源获取即初始化)管理线程
    </h4>
    <p>
     RAII 的核心思想是将资源的获取和释放与对象的生命周期绑定。当对象被创建时，资源被获取；当对象离开其作用域时，析构函数被自动调用，资源被释放。在多线程编程中，我们可以创建一个自定义的类(如
     <code>
      ThreadGuard
     </code>
     )，在其构造函数中接收一个
     <code>
      std::thread
     </code>
     对象，在析构函数中确保线程被正确处理（如调用
     <code>
      join()
     </code>
     ）
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token comment">// 使用 RAII 管理线程的类</span>
<span class="token keyword">class</span> <span class="token class-name">ThreadGuard</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数，接收一个 std::thread 对象的引用</span>
    <span class="token keyword">explicit</span> <span class="token function">ThreadGuard</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">thread_</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">// 析构函数，确保线程在对象销毁时被正确处理</span>
    <span class="token operator">~</span><span class="token function">ThreadGuard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>thread_<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            thread_<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 禁用拷贝构造函数和拷贝赋值运算符，防止线程对象被意外复制</span>
    <span class="token function">ThreadGuard</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadGuard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    ThreadGuard<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadGuard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> thread_<span class="token punctuation">;</span>  <span class="token comment">// 引用存储传入的线程对象</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 线程执行的函数</span>
<span class="token keyword">void</span> <span class="token function">threadFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread is running..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>threadFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建一个新线程</span>
    ThreadGuard <span class="token function">guard</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 ThreadGuard 管理线程</span>

    <span class="token comment">// 主线程继续执行其他任务</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread is doing other work..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 当 guard 对象离开作用域时，析构函数会自动调用，确保线程被正确处理</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="_189">
     </a>
     三、线程同步与数据安全
    </h2>
    <h4>
     <a id="1_Mutex_190">
     </a>
     1. 互斥量（Mutex）
    </h4>
    <ul>
     <li>
      <strong>
       std::lock_guard
      </strong>
      <br/>
      <code>
       std::lock_guard
      </code>
      是一种 RAII 风格的锁，它在构造时自动加锁，在析构时自动解锁，大大简化了锁的管理。例如：
     </li>
    </ul>
    <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">safe_increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_data<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//std::lock_guard&lt;std::mutex&gt; lock(mtx)在进入safe_increment函数时自动对mtx互斥量加锁，当函数执行完毕，lock对象析构时自动解锁，确保了shared_data++操作的线程安全性。</span>
</code></pre>
    <ul>
     <li>
      <strong>
       std::unique_lock
      </strong>
      <br/>
      <code>
       std::unique_lock
      </code>
      相较于
      <code>
       std::lock_guard
      </code>
      更加灵活，它支持手动控制锁的加锁和解锁，尤其适用于与条件变量配合使用的场景。例如：
     </li>
    </ul>
    <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>defer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 手动加锁</span>
<span class="token comment">//这里，std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock)创建了一个unique_lock对象，但并不立即加锁（std::defer_lock参数指定了延迟加锁），随后通过lock.lock()手动对互斥量mtx加锁。</span>
</code></pre>
    <h4>
     <a id="2_Condition_Variable_208">
     </a>
     2. 条件变量（Condition Variable）
    </h4>
    <p>
     条件变量通常与互斥锁（如 std::mutex）一起使用。当一个线程需要等待某个条件成立时，它会先获取互斥锁，检查条件是否满足。如果条件不满足，线程会释放互斥锁并进入等待状态；当其他线程修改了共享状态并使条件满足时，它可以通过条件变量通知等待的线程。等待的线程在收到通知后会重新获取互斥锁并继续执行。
     <br/>
     <strong>
      1. 头文件和类型
     </strong>
     <br/>
     要使用条件变量，需要包含
     <code>
      &lt;condition_variable&gt;
     </code>
     头文件。C++ 标准库提供了两种条件变量类型：
    </p>
    <ul>
     <li>
      <code>
       std::condition_variable
      </code>
      ：只能与
      <code>
       std::unique_lock&lt;std::mutex&gt;
      </code>
      一起使用。
     </li>
     <li>
      <code>
       std::condition_variable_any
      </code>
      ：可以与任何满足锁类型要求的锁一起使用，但通常会有一些额外的开销。
     </li>
    </ul>
    <p>
     <strong>
      2. 常用成员函数
     </strong>
    </p>
    <ul>
     <li>
      wait()
      <br/>
      wait() 函数用于让线程等待条件变量的通知。它有两种重载形式：
      <br/>
      <code>
       void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock)
      </code>
      ：线程会释放锁并进入等待状态，直到收到通知。收到通知后，线程会重新获取锁。
      <br/>
      <code>
       template&lt; class Predicate &gt; void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred);
      </code>
      ：线程会先检查 pred 条件是否为 true，如果为 false，则释放锁并进入等待状态。收到通知后，线程会重新获取锁并再次检查 pred 条件，直到条件为 true 才会继续执行。
     </li>
     <li>
      <code>
       notify_one()
      </code>
      : 函数用于通知一个正在等待该条件变量的线程。如果有多个线程在等待，只会选择其中一个线程进行通知。
     </li>
     <li>
      <code>
       notify_all()
      </code>
      : 函数用于通知所有正在等待该条件变量的线程。
     </li>
    </ul>
    <p>
     <strong>
      3.案例
     </strong>
     <br/>
     下面是一个使用条件变量实现生产者 - 消费者模型的案例：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>

std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> dataQueue<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span>
<span class="token keyword">bool</span> isProducing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// 生产者线程函数</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模拟生产时间</span>

        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Produced: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知消费者有新数据</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        isProducing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cv<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知所有消费者生产结束</span>
<span class="token punctuation">}</span>

<span class="token comment">// 消费者线程函数</span>
<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待新数据或生产结束的通知</span>
        cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span><span class="token operator">!</span>dataQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span><span class="token operator">!</span>isProducing<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dataQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> value <span class="token operator">=</span> dataQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            dataQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Consumed: "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isProducing<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 生产结束且队列为空，退出循环</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">producerThread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">consumerThread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>

    producerThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    consumerThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393936353235362f:61727469636c652f64657461696c732f313436313135383533" class_="artid" style="display:none">
 </p>
</div>


