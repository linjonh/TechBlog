---
layout: post
title: "全栈开发-一文掌握-Websocket-原理,并用-Django-框架实现"
date: 2025-03-05 20:56:10 +0800
description: "WebSocket是一种先进的通信协议，旨在通过单个长时间运行的连接实现实时双向数据交换，极大地提升了Web应用程序的交互性和响应速度。不同于传统的HTTP请求-响应模型，WebSocket在客户端与服务器之间开启了一个持久化的连接，使得双方可以随时发送文本或二进制数据，无需为每次通信重新建立连接，从而减少了延迟并提高了效率。这种特性特别适用于需要实时更新的应用场景，如在线游戏、即时通讯、金融交易监控等。"
keywords: "【全栈开发】---- 一文掌握 Websocket 原理，并用 Django 框架实现"
categories: ['全栈开发']
tags: ['网络协议', '网络', 'Websocket']
artid: "146001006"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146001006
    alt: "全栈开发-一文掌握-Websocket-原理,并用-Django-框架实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146001006
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146001006
cover: https://bing.ee123.net/img/rand?artid=146001006
image: https://bing.ee123.net/img/rand?artid=146001006
img: https://bing.ee123.net/img/rand?artid=146001006
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【全栈开发】---- 一文掌握 Websocket 原理，并用 Django 框架实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%BB%8B%E7%BB%8D" name="%E4%BB%8B%E7%BB%8D">
     介绍
    </h2>
    <p>
     WebSocket是一种先进的通信协议，旨在通过单个长时间运行的连接实现实时双向数据交换，极大地提升了Web应用程序的交互性和响应速度。不同于传统的HTTP请求-响应模型，WebSocket在客户端与服务器之间开启了一个持久化的连接，使得双方可以随时发送文本或二进制数据，无需为每次通信重新建立连接，从而减少了延迟并提高了效率。这种特性特别适用于需要实时更新的应用场景，如在线游戏、即时通讯、金融交易监控等。WebSocket协议不仅简化了开发流程，还确保了更高效的数据传输，支持更高的并发量和更低的资源消耗，成为现代Web开发中不可或缺的技术之一。此外，随着互联网技术的发展，WebSocket正逐渐成为构建高度互动和动态Web应用的标准选择，为企业提供前所未有的用户体验改进机会。
    </p>
    <h2 id="%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" name="%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">
     底层原理
    </h2>
    <p>
     <span style="color:#4da8ee">
      http 协议：
     </span>
    </p>
    <blockquote>
     <p>
      <strong>
       。连接
      </strong>
     </p>
     <p>
      <strong>
       。数据传输（请求和响应）
      </strong>
     </p>
     <p>
      <strong>
       。断开连接
      </strong>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      websocket 协议：
     </span>
    </p>
    <blockquote>
     <p>
      <span style="color:null">
       <strong>
        。连接，客户端发起
       </strong>
      </span>
     </p>
     <p>
      <span style="color:null">
       <strong>
        。握手（验证），客户端发送一个消息，服务端接收到消息后做一些特殊处理并返回。服务端支持 websocket 协议
       </strong>
      </span>
     </p>
     <p>
      <span style="color:null">
       <strong>
        。收发数据（加密）
       </strong>
      </span>
     </p>
     <p>
      <span style="color:null">
       <strong>
        。断开连接
       </strong>
      </span>
     </p>
    </blockquote>
    <h3 id="%E6%8F%A1%E6%89%8B%E7%8E%AF%E8%8A%82%E8%AF%A6%E8%A7%A3%EF%BC%9A" name="%E6%8F%A1%E6%89%8B%E7%8E%AF%E8%8A%82%E8%AF%A6%E8%A7%A3%EF%BC%9A">
     握手环节详解：
    </h3>
    <p>
     创建完链接后，客户端会自己生成一串随机字符串，并且加密后以密文的形式存储到客户端，以明文发送给服务端，服务端加密后发送给客户端，客户端比较自己加密算法得到的密文与服务端发送过来的密文是否相同，若相同，则服务端支持 websocket 协议，即握手成功，可以进行下一步操作，否则则不支持。
    </p>
    <p>
     客户端发送给服务端的是这玩意：
    </p>
    <blockquote>
     <p>
      <strong>
       <code>
        GET
       </code>
       <code>
        /
       </code>
       <code>
        chatsocket HTTP
       </code>
       <code>
        /
       </code>
       <code>
        1.1
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Host:
       </code>
       <code>
        127.0
       </code>
       <code>
        .
       </code>
       <code>
        0.1
       </code>
       <code>
        :
       </code>
       <code>
        8002
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Connection: Upgrade
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Pragma: no
       </code>
       <code>
        -
       </code>
       <code>
        cache
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Cache
       </code>
       <code>
        -
       </code>
       <code>
        Control: no
       </code>
       <code>
        -
       </code>
       <code>
        cache
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Upgrade: websocket
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Origin: http:
       </code>
       <code>
        /
       </code>
       <code>
        /
       </code>
       <code>
        localhost:
       </code>
       <code>
        63342
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Sec
       </code>
       <code>
        -
       </code>
       <code>
        WebSocket
       </code>
       <code>
        -
       </code>
       <code>
        Version:
       </code>
       <code>
        13
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Sec
       </code>
       <code>
        -
       </code>
       <code>
        WebSocket
       </code>
       <code>
        -
       </code>
       <code>
        Key: mnwFxiOlctXFN
       </code>
       <code>
        /
       </code>
       <code>
        DeMt1Amg
       </code>
       <code>
        =
       </code>
       <code>
        =
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        Sec
       </code>
       <code>
        -
       </code>
       <code>
        WebSocket
       </code>
       <code>
        -
       </code>
       <code>
        Extensions: permessage
       </code>
       <code>
        -
       </code>
       <code>
        deflate; client_max_window_bits
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        ...
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        ...
       </code>
      </strong>
     </p>
     <p>
      <strong>
       \r\n\r\n
      </strong>
     </p>
    </blockquote>
    <p>
     服务端真正接收的是
     <strong>
      <code>
       Sec
      </code>
      <code>
       -
      </code>
      <code>
       WebSocket
      </code>
      <code>
       -
      </code>
      <code>
       Key
      </code>
     </strong>
     ：
    </p>
    <blockquote>
     <p>
      <strong>
       <code>
        mnwFxiOlctXFN
       </code>
       <code>
        /
       </code>
       <code>
        DeMt1Amg
       </code>
       <code>
        =
       </code>
       <code>
        =
       </code>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     然后将服务端将
     <strong>
      <code>
       Sec-WebSocket-Key 与
      </code>
      magic_string
     </strong>
     进行字符串拼接
    </p>
    <p>
     <strong>
      magic_string 有个固定值：
     </strong>
     258EAFA5-E914-47DA-95CA-C5AB0DC85B11
    </p>
    <p>
     再将拼接的字符串进行
     <strong>
      hmac1
     </strong>
     加密，再进行
     <strong>
      base64
     </strong>
     加密
    </p>
    <p>
     服务端将最后加密得到的结果返还给客户端，返还新式如下：
    </p>
    <blockquote>
     <p>
      <strong>
       <code>
        "HTTP/1.1 101 Switching Protocols\r\n"
       </code>
       <code>
        \
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        "Upgrade:websocket\r\n"
       </code>
       <code>
        \
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        "Connection: Upgrade\r\n"
       </code>
       <code>
        \
       </code>
      </strong>
     </p>
     <p>
      <strong>
       <code>
        "Sec-WebSocket-Accept: 最终密文
       </code>
      </strong>
     </p>
    </blockquote>
    <p>
     然后客户端将服务端发送的密文和客户端自己产生的密文进行比较，相同则牵手成功。
    </p>
    <h3 id="%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89" name="%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89">
     收发数据（加密）
    </h3>
    <p>
    </p>
    <p>
     收发数据加密我看不懂，也不想去懂，大家可以自己搜搜视频看看。
    </p>
    <p>
    </p>
    <h2 id="Django%20%E4%B8%AD%E9%85%8D%E7%BD%AE%20channels" name="Django%20%E4%B8%AD%E9%85%8D%E7%BD%AE%20channels">
     Django 中配置 channels
    </h2>
    <p>
     django 默认不支持 websocket ，需要安装组件：
    </p>
    <blockquote>
     <p>
      <strong>
       pip install channels
      </strong>
     </p>
    </blockquote>
    <p>
     配置
    </p>
    <h3 id="1%E3%80%81%E6%B3%A8%E5%86%8C%20channels" name="1%E3%80%81%E6%B3%A8%E5%86%8C%20channels">
     1、注册
     <strong>
      channels
     </strong>
    </h3>
    <pre><code class="language-python">INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "app01.apps.App01Config",
    "channels",
]</code></pre>
    <h3 id="2%E3%80%81%E5%9C%A8%20settings.py%20%E4%B8%AD%E6%B7%BB%E5%8A%A0%20asgi_application" name="2%E3%80%81%E5%9C%A8%20settings.py%20%E4%B8%AD%E6%B7%BB%E5%8A%A0%20asgi_application">
     2、在
     <strong>
      settings.py
     </strong>
     中添加
     <strong>
      asgi_application
     </strong>
    </h3>
    <pre><code class="language-python">ASGI_APPLICATTON = "lang_poll.asgi.application"</code></pre>
    <p>
     这里的
     <strong>
      lang_poll
     </strong>
     是自己的
     <strong>
      Django
     </strong>
     项目名称
    </p>
    <h3 id="3%E3%80%81%E4%BF%AE%E6%94%B9%20asgi.py%20%E6%96%87%E4%BB%B6" name="3%E3%80%81%E4%BF%AE%E6%94%B9%20asgi.py%20%E6%96%87%E4%BB%B6">
     3、修改
     <strong>
      asgi.py
     </strong>
     文件
    </h3>
    <p>
     原来的
     <strong>
      asgi.py
     </strong>
     文件只能处理
     <strong>
      http
     </strong>
     请求，现在加入
     <strong>
      websocket
     </strong>
     后需要修改：
    </p>
    <pre><code class="language-python">"""
ASGI config for lang_poll project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter,URLRouter
from . import  routing

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "lang_poll.settings")
# application = get_asgi_application()

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": URLRouter(routing.websocket_urlpatterns),
})
</code></pre>
    <h3 id="4%E3%80%81routing%C2%A0" name="4%E3%80%81routing%C2%A0">
     4、
     <strong>
      routing
     </strong>
    </h3>
    <p>
     <strong>
      asgi.py
     </strong>
     中的
     <strong>
      routing
     </strong>
     是自己编写的文件，相当于
     <strong>
      http
     </strong>
     中的
     <strong>
      urls.py
     </strong>
     ，创建在
     <strong>
      asgi.py
     </strong>
     相同目录中：
    </p>
    <pre><code class="language-python">from django.urls import re_path
from app01 import consumers

websocket_urlpatterns = [
    re_path(r'ws/(?P&lt;group&gt;\w+)/$', consumers.ChatConsumer.as_asgi()),
]</code></pre>
    <h3 id="5%E3%80%81consumers" name="5%E3%80%81consumers">
     5、consumers
    </h3>
    <p>
     这里的
     <strong>
      consumers
     </strong>
     也得自己创建，放在
     <strong>
      app01
     </strong>
     目录下，相当于
     <strong>
      views.py
     </strong>
     ，用来编写
     <strong>
      websocket
     </strong>
     请求的响应逻辑：
    </p>
    <pre><code class="language-python">from channels.generic.websocket import WebsocketConsumer
from channels.exceptions import StopConsumer

class ChatConsumer(WebsocketConsumer):
    def websocket_connect(self,message):
        # 客户端发送 websocket请求时，会自动触发这个函数
        # accept 函数允许客户端与服务端建立联系
        self.accept()

    def websocket_receive(self,message):
        # 客户端向服务端基于 websocket发送数据时，会自动触发该函数，并接收消息
        self.send("不要回复")
        # self.close()  是服务端主动断开连接

    def websocket_disconnect(self,message):
        # 客户端与服务端断开连接时，自动触发
        print("断开连接")
        raise StopConsumer()</code></pre>
    <h2 id="%E5%AE%9E%E7%8E%B0%20%E8%81%8A%E5%A4%A9%E5%AE%A4" name="%E5%AE%9E%E7%8E%B0%20%E8%81%8A%E5%A4%A9%E5%AE%A4">
     实现 聊天室
    </h2>
    <p>
    </p>
    <p>
     前端页面可就用之前轮询的：
    </p>
    <pre><code class="language-python">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .message{
            width: 200px;
            height: 300px;
            border: 1px solid orangered;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="message" id="message"&gt;&lt;/div&gt;
&lt;div class="input"&gt;
    &lt;input type="text" placeholder="请输入" id="txt"&gt;
    &lt;input type="button" value="发送"&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
    <p>
     因为博主最近事比较多，聊天功能就不实现了，请见谅，后期会补回来的。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430335f38333138323638322f:61727469636c652f64657461696c732f313436303031303036" class_="artid" style="display:none">
 </p>
</div>


