---
layout: post
title: "每日算法力扣343.整数差分动态规划"
date: 2025-03-10 14:21:43 +0800
description: "那么，从4开始，我们就需要开始差分了，并且，将每次的最大值保存到数组中，那么很显然，如果当前的j*（i-j）不是最大值，难么(i-j)这个数的最大值就被保存在dp[i-j]这个下标的数组中，因此我们可以取j*dp[i-j];然后，取最大值，则有 dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));显然，当数比较小时，这样一般是对的，但是当数比较大时呢？分析：根据题目要求，一个数可被差分为它的子数，然后子数乘积中取最大值。则当j <= i 时，有 i = j * (i-j);"
keywords: "每日算法：力扣343.整数差分（动态规划）"
categories: ['未分类']
tags: ['算法', '动态规划', 'Leetcode']
artid: "146153362"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146153362
    alt: "每日算法力扣343.整数差分动态规划"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146153362
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146153362
cover: https://bing.ee123.net/img/rand?artid=146153362
image: https://bing.ee123.net/img/rand?artid=146153362
img: https://bing.ee123.net/img/rand?artid=146153362
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     每日算法：力扣343.整数差分（动态规划）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     题目：
    </p>
    <p>
     给定一个正整数
     <code>
      n
     </code>
     ，将其拆分为
     <code>
      k
     </code>
     个
     <strong>
      正整数
     </strong>
     的和（
     <code>
      k &gt;= 2
     </code>
     ），并使这些整数的乘积最大化。
    </p>
    <p>
     返回
     <em>
      你可以获得的最大乘积
     </em>
     。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1:
     </strong>
    </p>
    <pre><strong>输入: </strong>n = 2
<strong>输出: </strong>1
<strong>解释: </strong>2 = 1 + 1, 1 × 1 = 1。</pre>
    <p>
     <strong>
      示例 2:
     </strong>
    </p>
    <pre><strong>输入: </strong>n = 10
<strong>输出: </strong>36
<strong>解释: </strong>10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</pre>
    <p>
    </p>
    <p>
     <strong>
      提示:
     </strong>
    </p>
    <ul>
     <li>
      <code>
       2 &lt;= n &lt;= 58
      </code>
     </li>
    </ul>
    <p>
     分析：根据题目要求，一个数可被差分为它的子数，然后子数乘积中取最大值。
    </p>
    <p>
     则当j &lt;= i 时，有 i = j * (i-j);
    </p>
    <p>
     那么，这样就是最优解了吗？显然，当数比较小时，这样一般是对的，但是当数比较大时呢？
    </p>
    <p>
     那么，我们可以先从小的开始分析：
    </p>
    <p>
     我们先设立一个dp数组，数组中用于存放每个数子数乘积的最大值。
    </p>
    <p>
     则最小子问题为：
    </p>
    <p>
     dp[1] = 1;
    </p>
    <p>
     dp[2] = 1;
    </p>
    <p>
     dp[3] = 2;
    </p>
    <p>
     那么，从4开始，我们就需要开始差分了，并且，将每次的最大值保存到数组中，那么很显然，如果当前的j*（i-j）不是最大值，难么(i-j)这个数的最大值就被保存在dp[i-j]这个下标的数组中，因此我们可以取j*dp[i-j];然后，取最大值，则有 dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));
    </p>
    <p>
     至此，状态转移方程推导完毕。
    </p>
    <p>
     代码：
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int dp[100];
    int integerBreak(int n) {
    //预处理最小子问题
        dp[1] = 1;    
        dp[2] = 1;
        dp[3] = 2;
        for(int i = 4;i &lt;= n;i++){//第一层循环，遍历1-n的所有数
            for(int j = 1;j &lt;= i;j++){//第二层循环，遍历这个数可被差分的数
                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));//比较：当前的子数乘积和其继续差分的乘积，取最大值 
            }
        }
        return dp[n];
    }
};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313239343730302f:61727469636c652f64657461696c732f313436313533333632" class_="artid" style="display:none">
 </p>
</div>


