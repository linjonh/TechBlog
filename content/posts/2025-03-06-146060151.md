---
layout: post
title: "96.在-Vue-3-中使用-OpenLayers-探究加载-PointPolygon-的极限"
date: 2025-03-06 10:00:51 +0800
description: "在前端 GIS（地理信息系统）开发中，OpenLayers 作为一个功能强大的 Web 地图库，广泛用于加载地图、渲染矢量数据（点、线、面）、叠加图层等场景。然而，当涉及到。"
keywords: "openlayers绘制多个面太卡怎么优化"
categories: ['Openlayers']
tags: ['前端框架', '前端', 'Vue', 'Openlayers', 'Javascript', 'Ecmascript']
artid: "146060151"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146060151
    alt: "96.在-Vue-3-中使用-OpenLayers-探究加载-PointPolygon-的极限"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146060151
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146060151
cover: https://bing.ee123.net/img/rand?artid=146060151
image: https://bing.ee123.net/img/rand?artid=146060151
img: https://bing.ee123.net/img/rand?artid=146060151
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     96.在 Vue 3 中使用 OpenLayers 探究加载 Point、Polygon 的极限
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
    </h4>
    <blockquote>
     <p>
      🚀
      <em>
       本篇文章将介绍如何在 Vue 3 中使用 OpenLayers 加载大量 Point（点）和 Polygon（多边形），并探究其渲染性能的极限。
      </em>
     </p>
    </blockquote>
    <hr/>
    <h3>
     效果图
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9cdb95c1c63a4c1bab398044ecfc7778.gif"/>
    </p>
    <h3>
     <strong>
      1. 前言
     </strong>
    </h3>
    <p>
     在前端 GIS（地理信息系统）开发中，OpenLayers 作为一个功能强大的 Web 地图库，广泛用于加载地图、渲染矢量数据（点、线、面）、叠加图层等场景。然而，当涉及到
     <strong>
      大量 Point（点）或 Polygon（多边形）
     </strong>
     时，渲染性能往往成为瓶颈。因此，本文将基于 Vue 3，探讨 OpenLayers 在
     <strong>
      大规模点、面数据
     </strong>
     加载上的极限性能。
    </p>
    <hr/>
    <h3>
     <strong>
      2. 技术选型
     </strong>
    </h3>
    <p>
     本次实现基于：
    </p>
    <ul>
     <li>
      <strong>
       Vue 3
      </strong>
      组合式 API（Composition API）
     </li>
     <li>
      <strong>
       Vite 5.x
      </strong>
      （更快的构建工具）
     </li>
     <li>
      <strong>
       OpenLayers
      </strong>
      作为地图引擎
     </li>
     <li>
      <strong>
       Element Plus
      </strong>
      提供 UI 交互按钮
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      3. 项目初始化
     </strong>
    </h3>
    <h4>
     <strong>
      （1）创建 Vue 3 + Vite 项目
     </strong>
    </h4>
    <p>
     如果你还没有 Vue 3 项目，可以使用 Vite 快速初始化：
    </p>
    <p>
     <code>
      npm create vite@latest vue-openlayers-test --template vue cd vue-openlayers-test npm install
     </code>
    </p>
    <h4>
     <strong>
      （2）安装 OpenLayers
     </strong>
    </h4>
    <p>
     <code>
      npm install ol
     </code>
    </p>
    <hr/>
    <h3>
     <strong>
      4. 代码实现
     </strong>
    </h3>
    <h4>
     <strong>
      （1）
      <code>
       App.vue
      </code>
      代码
     </strong>
    </h4>
    <pre><code class="language-javascript">&lt;!--
 * @Author: 彭麒
 * @Date: 2025/3/6
 * @Email: 1062470959@qq.com
 * @Description: 此源码版权归吉檀迦俐所有，可供学习和借鉴或商用。
 --&gt;
&lt;template&gt;
  &lt;div class="container"&gt;
    &lt;div class="w-full flex justify-center flex-wrap"&gt;
      &lt;div class="font-bold text-[24px]"&gt;在Vue3中使用OpenLayers探究加载 point、polygon 的极限&lt;/div&gt;
    &lt;/div&gt;
    &lt;h4&gt;
      &lt;el-button type="primary" size="small" @click="showPoint"&gt;显示点&lt;/el-button&gt;
      &lt;el-button type="primary" size="small" @click="showPolygon"&gt;显示多边形&lt;/el-button&gt;
      &lt;el-button type="primary" size="small" @click="clearLayer"&gt;清除图层&lt;/el-button&gt;
    &lt;/h4&gt;
    &lt;div id="vue-openlayers"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue';
import 'ol/ol.css';
import { Map, View } from 'ol';
import TileLayer from 'ol/layer/Tile';
import VectorLayer from 'ol/layer/Vector';
import VectorSource from 'ol/source/Vector';
import OSM from 'ol/source/OSM';
import Feature from 'ol/Feature';
import { Point, Polygon } from 'ol/geom';
import Style from 'ol/style/Style';
import Fill from 'ol/style/Fill';
import Stroke from 'ol/style/Stroke';
import CircleStyle from 'ol/style/Circle';

// **状态管理**
const map = ref(null);
const dataSource = ref(new VectorSource({ wrapX: false }));

// **初始化地图**
const initMap = () =&gt; {
  const OSM_Layer = new TileLayer({
    source: new OSM(),
  });

  const feature_Layer = new VectorLayer({
    source: dataSource.value,
    style: featureStyle(), // 统一设置 vector 样式
  });

  map.value = new Map({
    target: 'vue-openlayers',
    layers: [OSM_Layer, feature_Layer],
    view: new View({
      projection: 'EPSG:4326',
      center: [45, 45],
      zoom: 3,
    }),
  });
};

// **设置 vector 样式**
const featureStyle = () =&gt; {
  return new Style({
    stroke: new Stroke({
      width: 1,
      color: '#0f0',
    }),
    image: new CircleStyle({
      radius: 2,
      fill: new Fill({
        color: '#ff0000',
      }),
    }),
  });
};

// **清除 vector 数据源**
const clearLayer = () =&gt; {
  dataSource.value.clear();
};

// **生成随机点**
const showPoint = () =&gt; {
  for (let i = 0; i &lt; 2000; i++) {
    let a = Math.random() * 100;
    let b = Math.random() * 90;
    let pointFeature = new Feature({
      geometry: new Point([a, b]),
    });
    dataSource.value.addFeature(pointFeature);
  }
};

// **生成随机多边形**
const showPolygon = () =&gt; {
  let data = [];
  for (let i = 0; i &lt; 2000; i++) {
    let a = Math.random() * 180;
    let b = Math.random() * 90;
    data.push([a, b]);
  }
  let arr = data.concat([data[0]]); // 闭合多边形

  let polygonFeature = new Feature({
    geometry: new Polygon([arr]),
  });
  dataSource.value.addFeature(polygonFeature);
};

// **在组件挂载后初始化地图**
onMounted(() =&gt; {
  initMap();
});
&lt;/script&gt;

&lt;style scoped&gt;
.container {
  width: 840px;
  height: 570px;
  margin: 50px auto;
  border: 1px solid #42B983;
}

#vue-openlayers {
  width: 800px;
  height: 400px;
  margin: 0 auto;
  border: 1px solid #42B983;
  position: relative;
}
&lt;/style&gt;
</code></pre>
    <hr/>
    <h3>
     <strong>
      6. 性能测试
     </strong>
    </h3>
    <h4>
     <strong>
      测试 1：加载 2000 个点
     </strong>
    </h4>
    <p>
     ✅ 地图可以流畅渲染，无明显卡顿。
    </p>
    <h4>
     <strong>
      测试 2：加载 2000 个多边形
     </strong>
    </h4>
    <p>
     ⚠️
     <strong>
      出现轻微卡顿
     </strong>
     ，说明 OpenLayers 在大规模面数据上渲染性能较点数据差。
    </p>
    <h4>
     <strong>
      测试 3：同时加载 4000 个点 + 2000 个多边形
     </strong>
    </h4>
    <p>
     ❌
     <strong>
      页面开始卡顿
     </strong>
     ，性能瓶颈显现，建议：
    </p>
    <ul>
     <li>
      <strong>
       优化矢量渲染
      </strong>
      （使用 WebGL 方式）
     </li>
     <li>
      <strong>
       使用 Cluster 点聚合
      </strong>
     </li>
     <li>
      <strong>
       降低复杂多边形的点数
      </strong>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      7. 总结
     </strong>
    </h3>
    <p>
     在 Vue 3 + OpenLayers 的开发中： ✅
     <strong>
      点数据的渲染性能较好
     </strong>
     ，即使 2000+ 也不会明显卡顿。
     <br/>
     ❌
     <strong>
      多边形数据的渲染性能较差
     </strong>
     ，大量复杂多边形会降低 FPS。
    </p>
    <p>
     如果要进一步优化，可以：
    </p>
    <ul>
     <li>
      <strong>
       采用 WebGL 层
      </strong>
     </li>
     <li>
      <strong>
       使用点聚合
      </strong>
     </li>
     <li>
      <strong>
       减少不必要的矢量对象
      </strong>
     </li>
    </ul>
    <p>
     📌
     <strong>
      希望这篇文章能帮助你在 Vue 3 项目中更高效地使用 OpenLayers！
     </strong>
     🚀
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f4d696c6c65723737375f2f:61727469636c652f64657461696c732f313436303630313531" class_="artid" style="display:none">
 </p>
</div>


