---
layout: post
title: "单元测试覆盖率"
date: 2025-01-08 18:05:46 +0800
description: "什么是单元测试覆盖率？关于其定义，先来看一下维基百科上的一段描述：简单来理解，就是单元测试中代码执行"
keywords: "单元测试覆盖率"
categories: ['Java']
tags: ['单元测试', 'Java']
artid: "125440949"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=125440949
    alt: "单元测试覆盖率"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=125440949
featuredImagePreview: https://bing.ee123.net/img/rand?artid=125440949
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     单元测试覆盖率
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     什么是单元测试覆盖率？
    </p>
    <p>
     关于其定义，先来看一下维基百科上的一段描述：
    </p>
    <blockquote>
     <p>
      <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E4%25BB%25A3%25E7%25A2%25BC%25E8%25A6%2586%25E8%2593%258B%25E7%258E%2587" rel="nofollow" title="代码覆盖（Code coverage）">
       代码覆盖（Code coverage）
      </a>
      是软件测试中的一种度量，描述程序中源代码被测试的比例和程度，所得比例称为代码覆盖率。
     </p>
    </blockquote>
    <p>
     简单来理解，就是单元测试中代码执行量与代码总量之间的比率。
    </p>
    <p>
     以一个最简单的例子来直观感受一下：
    </p>
    <p>
     Service服务类：
    </p>
    <pre><code>public class NumToStringServiceImpl implements NumToStringService {
    @Override
    public String num2Str(Integer i) {
        String str = "";
        switch (i) {
            case 1:
                str = "one";
                break;
            case 2:
                str = "two";
                break;
            default:
                str = "none";
        }
        return str;
    }
}</code></pre>
    <p>
     单元测试类：
    </p>
    <pre><code>public class NumToStringServiceTest {

    @Autowired
    NumToStringService numToStringService;

    @Test
    void testNum2Str() {
        String str1 = numToStringService.num2Str(1);
        assertThat(str1, is("one"));
        String str2 = numToStringService.num2Str(2);
        assertThat(str2, is("two"));
    }
}</code></pre>
    <p>
     从上面的代码中能看出，单元测试方法
     <code>
      testNum2Str
     </code>
     能够覆盖到服务类
     <code>
      num2Str
     </code>
     方法的
     <code>
      case 1
     </code>
     和
     <code>
      case 2
     </code>
     两个分支，覆盖不到
     <code>
      default
     </code>
     分支。那么覆盖率就是
     <code>
      num2Str
     </code>
     方法
     <code>
      case 1
     </code>
     和
     <code>
      case 2
     </code>
     分支的代码量除以方法的总代码量。
    </p>
    <p>
     单元测试覆盖率框架
    </p>
    <p>
     单元测试覆盖率常用的框架有
     <strong>
      <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.eclemma.org%2Fjacoco%2F" rel="nofollow" title="JaCoCo">
       JaCoCo
      </a>
     </strong>
     、
     <strong>
      <a href="https://links.jianshu.com/go?to=http%3A%2F%2Femma.sourceforge.net%2F" rel="nofollow" title="EMMA">
       EMMA
      </a>
     </strong>
     和
     <strong>
      <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcobertura.sourceforge.net%2F" rel="nofollow" title="Cobertura">
       Cobertura
      </a>
     </strong>
     。我们目前（在Jenkins中）使用的是JaCoCo。
    </p>
    <p>
     JaCoCo可以统计的
     <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.jacoco.org%2Fjacoco%2Ftrunk%2Fdoc%2Fcounters.html" rel="nofollow" title="指标">
      指标
     </a>
     有：
    </p>
    <ol>
     <li>
      <strong>
       指令（C0 Coverage）
      </strong>
      ：JaCoCo计数的最小单元是单一的Java字节码指令。指令覆盖率提供了关于字节码执行数量、未执行数量的信息。
     </li>
     <li>
      <strong>
       分支（C1 Coverage）
      </strong>
      ：对所有的
      <code>
       if
      </code>
      和
      <code>
       switch
      </code>
      语句计算分支覆盖率。统计在方法中分支执行数量、未执行数量的信息。但要注意，异常处理不在此计算范围内。
     </li>
     <li>
      <strong>
       圈复杂度（Cyclomatic Complexity）
      </strong>
      ：对非抽象方法计算圈复杂度，并汇总类、包和组的（圈）复杂度。这个值可以做为单元测试用例是否完全覆盖的参考。
     </li>
     <li>
      <strong>
       行（Lines）
      </strong>
      ：一行可能包含一条或多条指令，如果至少有一条指令被执行了，那么该行就算作是被执行了。
     </li>
     <li>
      <strong>
       方法（Methods）
      </strong>
      ：每个非抽象方法至少包含一条指令。如果至少有一条指令被执行了，那么该方法就算作是被执行了。
     </li>
     <li>
      <strong>
       类（Classes）
      </strong>
      ：如果类中至少有一个方法被执行了，那么该类就算作是被执行了。
     </li>
    </ol>
    <blockquote>
     <p>
      注：个人认为，最需要关注的指标是
      <strong>
       行
      </strong>
      （Lines）和
      <strong>
       分支
      </strong>
      （C1 Coverage），其次是
      <strong>
       方法
      </strong>
      （Methods）和
      <strong>
       类
      </strong>
      （Classes），
      <strong>
       指令
      </strong>
      （C0 Coverage）和
      <strong>
       圈复杂度
      </strong>
      （Cyclomatic Complexity）可以不用关注，因为跟
      <strong>
       行
      </strong>
      （Lines）和
      <strong>
       分支
      </strong>
      （C1 Coverage）其实是差不多的，只不过多了一种参考维度。
     </p>
    </blockquote>
    <p>
     查看单元测试覆盖率
    </p>
    <p>
     在IntelliJ IDEA中已经内置了JaCoCo插件，因此研发可以在本机运行单元测试来查看覆盖率：
    </p>
    <p>
    </p>
    <p>
     1、点击IDE右上侧的"Edit Configurations..."：
     <br/>
     <img alt="" height="255" src="https://i-blog.csdnimg.cn/blog_migrate/a7f3c4102f8b1981ab7a1c484ef724c3.png" width="843"/>
    </p>
    <p>
     2、在"Choose coverage runner"中选择JaCoCo：
    </p>
    <p>
     <img alt="" height="929" src="https://i-blog.csdnimg.cn/blog_migrate/2c228d6b7dc92b0dcb123fbce3b4b8d7.png" width="1200"/>
    </p>
    <p>
     3、点击"Run ... with Coverage"运行：
    </p>
    <p>
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/blog_migrate/392dd2e0d3a368e87617f873a4eccd15.png" width="1200"/>
    </p>
    <p>
     4、运行完成后会展示
     <strong>
      分支
     </strong>
     （C1 Coverage）、
     <strong>
      行
     </strong>
     （Lines）、
     <strong>
      方法
     </strong>
     （Methods）、
     <strong>
      类
     </strong>
     （Classes）这四个指标：
    </p>
    <p>
     <img alt="" height="705" src="https://i-blog.csdnimg.cn/blog_migrate/313c8850245a9a18f6f812f755ca4119.png" width="1200"/>
    </p>
    <p>
     5、点击"Generate Coverage Report"可以生成一份html版的所有指标的报告：
    </p>
    <p>
     <img alt="" height="320" src="https://i-blog.csdnimg.cn/blog_migrate/a4693a695521abcc0f1a39652e611f4d.png" width="1200"/>
    </p>
    <p>
    </p>
    <p>
     JaCoCo与持续集成
    </p>
    <p>
     1、需要在项目的
     <code>
      &lt;plugins&gt;
     </code>
     中加入JaCoCo插件：
    </p>
    <pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.jacoco&lt;/groupId&gt;
    &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;0.8.5&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;default-prepare-agent&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;prepare-agent&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;default-report&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;report&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
    <p>
     目前发现如果项目中不加以上配置，而是在Jenkinsfile中
    </p>
    <p>
     <img alt="" height="207" src="https://i-blog.csdnimg.cn/blog_migrate/07c8480e75a66cfb037c896594d69ff7.png" width="1200"/>
    </p>
    <p>
     以命令的方式去应用JaCoCo，会导致不能生成
     <code>
      jacoco.exec
     </code>
     ，进而无法运行覆盖率测试。
    </p>
    <p>
     2、在Jenkinsfile中加入
    </p>
    <p>
     <img alt="" height="479" src="https://i-blog.csdnimg.cn/blog_migrate/fe9ecc4b2da26feaf74d95d72a0bc7be.png" width="1200"/>
    </p>
    <p>
    </p>
    <pre><code>exclusionPattern: '**/controller/*.class', sourceExclusionPattern: '**/controller/*.java'</code></pre>
    <p>
     可以过滤掉controller层的检测。因为目前我们的单元测试主要是针对service层的，如果把controller层的类引入进来，会使单元测试覆盖率的值变低。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     3、可以在Jenkins（http://${ip}:${port}/job/${your_project}/lastBuild/jacoco/）中查看生成的单元测试覆盖率报告：
     <br/>
     <br/>
     <img alt="" height="937" src="https://i-blog.csdnimg.cn/blog_migrate/ea1617648e681efc807bec5deb57f695.png" width="1200"/>
    </p>
    <p>
    </p>
    <p>
     该报告与IntelliJ IDEA中的报告都是JaCoCo原生的，是准确的。
    </p>
    <blockquote>
     <p>
      目前发现SonarQube中的报告一是不准，二是指标不全，建议不要查看SonarQube的报告。
     </p>
    </blockquote>
    <p>
     题外话
    </p>
    <p>
     覆盖率作为衡量单元测试质量的
     <strong>
      唯一标准是不合理的
     </strong>
     。比如下面这个例子：
    </p>
    <pre><code>public double cal(double a, double b) {
  if (b != 0) {
    return a / b;
  }
}</code></pre>
    <p>
     <br/>
     仅一个测试用例就可以做到100%的覆盖率，比如cal(10.0, 2.0)，但并不代表测试足够全面了，还需要考虑当除数等于0的情况下，代码执行是否符合预期。
    </p>
    <p>
    </p>
    <p>
     引用文章：
    </p>
    <p>
     <a href="https://www.jianshu.com/p/cc4a3b5ee0b2" rel="nofollow" title="单元测试覆盖率 - 简书">
      单元测试覆盖率 - 简书
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f33373537303439342f:61727469636c652f64657461696c732f313235343430393439" class_="artid" style="display:none">
 </p>
</div>


