---
layout: post
title: "spring-设计模式"
date: 2025-03-16 22:24:00 +0800
description: "【代码】spring-设计模式。"
keywords: "spring-设计模式"
categories: ['Springboot']
tags: ['Spring', 'Boot']
artid: "146302673"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146302673
    alt: "spring-设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146302673
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146302673
cover: https://bing.ee123.net/img/rand?artid=146302673
image: https://bing.ee123.net/img/rand?artid=146302673
img: https://bing.ee123.net/img/rand?artid=146302673
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     spring-设计模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     创建型模式
    </h2>
    <h2>
     结构型模式
    </h2>
    <h2>
     行为型模式
    </h2>
    <h4>
     策略模式
    </h4>
    <p>
     首先，定义一个策略接口：
    </p>
    <pre><code class="language-java">public interface Strategy {
    public void draw(int radius, int x, int y);
}</code></pre>
    <p>
     然后定义具体的几个策略：
    </p>
    <pre><code class="language-java">public class RedPen implements Strategy {
    @Override
    public void draw() {
        System.out.println("red pen");
    }
}

public class YellowPen implements Strategy {
    @Override
    public void draw() {
        System.out.println("yellow pen");
    }
}

public class BluePen implements Strategy {
    @Override
    public void draw() {
        System.out.println("blue pen");
    }
}</code></pre>
    <p>
     使用策略的类：
    </p>
    <pre><code class="language-java">public class Context {
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public int excuteDraw(int radius, int x, int y) {
        return strategy.drwa(radius, x, y);
    }
}</code></pre>
    <p>
     客户端演示：
    </p>
    <pre><code class="language-java">public static void main(String[] args) {
    
    // 使用蓝笔画画
    Context context = new Context(new BluePen());
    context.excuteDraw(84, 62, 063);
}</code></pre>
    <p>
     图示：
    </p>
    <p>
     <img alt="" height="1156" src="https://i-blog.csdnimg.cn/direct/3a2c13a7d71244b0a5706580345ae702.png" width="1544"/>
    </p>
    <h4>
    </h4>
    <h4 style="background-color:transparent">
     观察者模式
    </h4>
    <p>
     首先，定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：
    </p>
    <pre><code class="language-java">public Class Subject {
    private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;();
    private int state;
    
    public int getState() {
        return state;
    }
    public void setState(int state) {
        this.state = state;

        // 数据变更 通知观察者们
        notifyAll();
    }
    
    // 注册观察者
    public void addObserver(Observer observer) {
        observerList.add(observer);
    }
    
    // 通知观察者们
    public void notifyAll() {
        for (Observer observer : observerList) {
            observer.update();
        }
    }
}</code></pre>
    <p>
     定义观察者接口：
    </p>
    <pre><code class="language-java">public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}</code></pre>
    <p>
     定义具体的2个观察者类：
    </p>
    <pre><code class="language-java">// 二进制观察者
public class BinaryObserver extends Observer {

    public BinaryObserver(Subject subject) {
        this.subject = subject;
        this.subject.addObserver(this);
    }
    
    // 本方法由主题类在数据变更时进行调用
    @Override
    public void update() {
        System.out.println("数据变化！对应的二进制变为：result");
    }
    
}


// 十六进制观察者
public class HexaObserver extends Observer {

    public HexaObserver(Subject subject) {
        this.subject = subject;
        this.subject.addObserver(this);
    }

    @Override
    public void update() {
        System.out.println("数据变化！对应的十六进制变为：result");
    }

}</code></pre>
    <p>
     客户端演示：
    </p>
    <pre><code class="language-java">public static void main(String[] args) {
    
    // 先定义一个主题
    Subject subject = new Subject();
    
    // 定义观察者
    new BinaryObserver(subject);
    new HexaObserver(subject);
    
    // 模拟数据变更 这个时候 观察者们的uodate方法会被调用
    subject.setState(8462063);
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35313538313536322f:61727469636c652f64657461696c732f313436333032363733" class_="artid" style="display:none">
 </p>
</div>


