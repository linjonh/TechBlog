---
layout: post
title: "原型链的故事JavaScript-对象模型的秘密"
date: 2025-03-08 22:47:11 +0800
description: "当访问对象的属性或方法时，JavaScript 会先在对象自身查找，如果找不到，则沿着原型链向上查找，直到找到或到达原型链的顶端（是 JavaScript 中实现继承的核心机制。每个对象都有一个内部属性。通过原型链，对象可以访问其原型对象的属性和方法。属性，指向一个对象（称为原型对象）。通过原型链，可以实现对象之间的继承。关键字创建实例时，实例的。向上查找，直到找到或到达。访问），指向其原型对象。"
keywords: "《原型链的故事：JavaScript 对象模型的秘密》"
categories: ['面试精选']
tags: ['原型模式', 'Javascript']
artid: "146124437"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146124437
    alt: "原型链的故事JavaScript-对象模型的秘密"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146124437
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146124437
cover: https://bing.ee123.net/img/rand?artid=146124437
image: https://bing.ee123.net/img/rand?artid=146124437
img: https://bing.ee123.net/img/rand?artid=146124437
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     《原型链的故事：JavaScript 对象模型的秘密》
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     <img alt="" height="1749" src="https://i-blog.csdnimg.cn/direct/47894f9c3fca4d0db56051855e2fb548.png" width="1312">
      <strong>
       原型链（Prototype Chain）
      </strong>
      是 JavaScript 中实现继承的核心机制。每个对象都有一个内部属性
      <code>
       [[Prototype]]
      </code>
      （可以通过
      <code>
       __proto__
      </code>
      访问），指向其原型对象。
      <strong>
       每个对象都有一个原型，
      </strong>
      <strong>
       原型本身也是一个对象
      </strong>
      ，
      <strong>
       因此它也有自己的原型
      </strong>
      。通过原型链，对象可以访问其原型对象的属性和方法。以下是原型链的详细说明：
     </img>
    </p>
    <h3>
     <strong>
      获取原型的方法
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         方法
        </strong>
       </th>
       <th>
        <strong>
         说明
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         obj.__proto__
        </code>
       </td>
       <td>
        非标准方法，直接访问对象的原型。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Object.getPrototypeOf(obj)
        </code>
       </td>
       <td>
        标准方法，推荐使用。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Object.prototype.isPrototypeOf(obj)
        </code>
       </td>
       <td>
        检查对象是否在原型链上。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         obj.constructor.prototype
        </code>
       </td>
       <td>
        通过构造函数获取原型。
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <strong>
      1. 原型对象
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       每个函数都有一个
       <code>
        prototype
       </code>
       属性，指向一个对象（称为原型对象）。
      </p>
     </li>
     <li>
      <p>
       当使用
       <code>
        new
       </code>
       关键字创建实例时，实例的
       <code>
        __proto__
       </code>
       会指向构造函数的
       <code>
        prototype
       </code>
       。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      示例
     </strong>
    </h4>
    <pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

// 在原型对象上添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const person1 = new Person('Alice');
person1.sayHello(); // 输出: Hello, my name is Alice</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         person1.__proto__
        </code>
       </strong>
       指向
       <code>
        Person.prototype
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         Person.prototype.constructor
        </code>
       </strong>
       指向
       <code>
        Person
       </code>
       函数。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      2. 原型链
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       当访问对象的属性或方法时，JavaScript 会先在对象自身查找，如果找不到，则沿着原型链向上查找，直到找到或到达原型链的顶端（
       <code>
        null
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       原型链的顶端是
       <code>
        Object.prototype
       </code>
       ，其
       <code>
        __proto__
       </code>
       为
       <code>
        null
       </code>
       。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      示例
     </strong>
    </h4>
    <pre><code class="language-javascript">console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true</code></pre>
    <h3>
     <strong>
      3. 继承
     </strong>
    </h3>
    <p>
     通过原型链，可以实现对象之间的继承。
    </p>
    <h4>
     <strong>
      （1）构造函数继承
     </strong>
    </h4>
    <pre><code class="language-javascript">function Parent(name) {
  this.name = name;
}
Parent.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

function Child(name, age) {
  Parent.call(this, name); // 调用父类构造函数
  this.age = age;
}

// 设置原型链
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const child = new Child('Bob', 10);
child.sayHello(); // 输出: Hello, my name is Bob</code></pre>
    <h4>
     <strong>
      （2）ES6 类继承
     </strong>
    </h4>
    <pre><code class="language-javascript">class Parent {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name); // 调用父类构造函数
    this.age = age;
  }
}

const child = new Child('Bob', 10);
child.sayHello(); // 输出: Hello, my name is Bob</code></pre>
    <h3>
     <strong>
      4. 原型链的查找过程
     </strong>
    </h3>
    <p>
     当访问对象的属性或方法时，JavaScript 会按照以下顺序查找：
    </p>
    <ol>
     <li>
      <p>
       在对象自身查找。
      </p>
     </li>
     <li>
      <p>
       如果找不到，沿着
       <code>
        __proto__
       </code>
       向上查找，直到找到或到达
       <code>
        null
       </code>
       。
      </p>
     </li>
    </ol>
    <h4>
     <strong>
      示例
     </strong>
    </h4>
    <pre><code class="language-javascript">const obj = { a: 1 };
console.log(obj.toString()); // 输出: [object Object]</code></pre>
    <ul>
     <li>
      <p>
       <code>
        obj
       </code>
       自身没有
       <code>
        toString
       </code>
       方法。
      </p>
     </li>
     <li>
      <p>
       查找
       <code>
        obj.__proto__
       </code>
       （即
       <code>
        Object.prototype
       </code>
       ），找到
       <code>
        toString
       </code>
       方法。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      5. 修改原型链
     </strong>
    </h3>
    <p>
     可以通过修改
     <code>
      __proto__
     </code>
     或
     <code>
      prototype
     </code>
     来改变原型链。
    </p>
    <h4>
     <strong>
      示例
     </strong>
    </h4>
    <pre><code class="language-javascript">const parent = { name: 'Parent' };
const child = { age: 10 };

// 设置 child 的原型为 parent
child.__proto__ = parent;

console.log(child.name); // 输出: Parent</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393839363437302f:61727469636c652f64657461696c732f313436313234343337" class_="artid" style="display:none">
 </p>
</div>


