---
layout: post
title: "P1443-马的遍历BFS"
date: 2025-03-06 22:39:57 +0800
description: "该题目的关键在于利用 BFS 遍历整个棋盘，同时利用合理的数组下标控制和边界检查，确保每个合法位置都被正确计算最短步数。BFS 能够在无权图中保证最短路径的正确性，是解决这类问题的经典算法。代码简洁高效，适合用在类似的棋盘遍历问题中。"
keywords: "P1443 马的遍历(BFS)"
categories: ['未分类']
tags: ['算法', '宽度优先']
artid: "146082109"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146082109
    alt: "P1443-马的遍历BFS"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146082109
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146082109
cover: https://bing.ee123.net/img/rand?artid=146082109
image: https://bing.ee123.net/img/rand?artid=146082109
img: https://bing.ee123.net/img/rand?artid=146082109
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     P1443 马的遍历(BFS)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="P1443__0">
     </a>
     P1443 马的遍历
    </h2>
    <h3>
     <a id="_3">
     </a>
     题目描述
    </h3>
    <p>
     有一个
     <em>
      n
     </em>
     ×
     <em>
      m
     </em>
     的棋盘，在某个点 (
     <em>
      x
     </em>
     ,
     <em>
      y
     </em>
     ) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。
    </p>
    <h3>
     <a id="_7">
     </a>
     输入格式
    </h3>
    <p>
     输入只有一行四个整数，分别为
     <em>
      n
     </em>
     ,
     <em>
      m
     </em>
     ,
     <em>
      x
     </em>
     ,
     <em>
      y
     </em>
     。
    </p>
    <h3>
     <a id="_11">
     </a>
     输出格式
    </h3>
    <p>
     一个
     <em>
      n
     </em>
     ×
     <em>
      m
     </em>
     的矩阵，代表马到达某个点最少要走几步（不能到达则输出 −1）。
    </p>
    <h3>
     <a id="_15">
     </a>
     输入输出样例
    </h3>
    <p>
     <strong>
      输入
     </strong>
    </p>
    <pre><code>3 3 1 1
</code></pre>
    <p>
     <strong>
      输出
     </strong>
    </p>
    <pre><code>0    3    2    
3    -1   1    
2    1    4    
</code></pre>
    <h3>
     <a id="_31">
     </a>
     说明/提示
    </h3>
    <h4>
     <a id="_33">
     </a>
     数据规模与约定
    </h4>
    <p>
     对于全部的测试点，保证 1≤
     <em>
      x
     </em>
     ≤
     <em>
      n
     </em>
     ≤400，1≤
     <em>
      y
     </em>
     ≤
     <em>
      m
     </em>
     ≤400。
    </p>
    <h4>
     <a id="_37">
     </a>
     代码：
    </h4>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">410</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储每个格子到起点的最短步数，未访问的位置初始化为 -1</span>
<span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> PII<span class="token punctuation">;</span>
PII q<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 模拟队列，用于广度优先搜索 (BFS)，存储棋盘中各个点的坐标</span>
<span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 马在水平方向上的移动偏移量（8个可能的走法）</span>
<span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 马在垂直方向上的移动偏移量（8个可能的走法）</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span> <span class="token comment">// 棋盘的行数和列数（输入的规模）</span>

<span class="token comment">// 从点 (x, y) 开始执行广度优先搜索</span>
<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 将所有位置的距离初始化为 -1，表示尚未访问</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将起点 (x, y) 入队</span>
    q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 起点距离为 0</span>
    dist<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 队首指针</span>
    <span class="token keyword">int</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 队尾指针（初始时队中已有一个元素，所以 tt = 0）</span>
    
    <span class="token comment">// 当队列不为空时，继续取出队首元素进行扩展</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 取出当前队首元素并将队首指针后移</span>
        <span class="token keyword">auto</span> t <span class="token operator">=</span> q<span class="token punctuation">[</span>hh<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 枚举马的八个可能走法</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> t<span class="token punctuation">.</span>first <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 新位置的行坐标</span>
            <span class="token keyword">int</span> b <span class="token operator">=</span> t<span class="token punctuation">.</span>second <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 新位置的列坐标</span>
            <span class="token comment">// 检查新位置是否超出棋盘边界</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> a <span class="token operator">&gt;</span> n <span class="token operator">||</span> b <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> b <span class="token operator">&gt;</span> m<span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果新位置已经访问过，则跳过</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token comment">// 更新新位置的距离为当前距离加 1</span>
            dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">.</span>second<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// 将新位置加入队列中</span>
            q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 定义马的起始点坐标</span>
    <span class="token keyword">int</span> x0<span class="token punctuation">,</span> y0<span class="token punctuation">;</span>
    <span class="token comment">// 从标准输入读取棋盘的行数 n、列数 m 以及马的起始坐标 (x0, y0)</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x0<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过 BFS 计算从起点到棋盘上每个点的最短步数</span>
    <span class="token function">bfs</span><span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出棋盘上每个位置的最短步数，如果某个点无法到达则输出 -1</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5d"</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 以宽度为 5 的格式输出，保证矩阵对齐</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <h4>
     <a id="_100">
     </a>
     题目解析与解题思路
    </h4>
    <h5>
     <a id="1__102">
     </a>
     1. 题目背景
    </h5>
    <p>
     题目要求在一个
     <em>
      n
     </em>
     ×
     <em>
      m
     </em>
     的棋盘上，给定一个马的初始位置 (
     <em>
      x
     </em>
     ,
     <em>
      y
     </em>
     )，计算出马走到棋盘上任意一个点的最少步数。如果某个点不可达，则输出 -1。这是一道典型的最短路径问题，适用于无权图的广度优先搜索（BFS）。
    </p>
    <h5>
     <a id="2__106">
     </a>
     2. 数据规模
    </h5>
    <ul>
     <li>
      棋盘尺寸：最多 400×400，即最多 160,000 个格子。
     </li>
     <li>
      马的走法：每步有最多 8 个可能的移动方向。
     </li>
    </ul>
    <p>
     数据规模较大但由于每个格子仅访问一次，BFS 的时间复杂度为 O(n*m) 是完全可以接受的。
    </p>
    <h5>
     <a id="3__113">
     </a>
     3. 算法思路
    </h5>
    <ul>
     <li>
      <strong>
       使用 BFS 搜索最短路径：
      </strong>
      <br/>
      由于棋盘中每一步的代价均为 1，且每次移动都是马的合法走法，使用 BFS 能确保第一次访问到某个格子时所记录的步数即为最短步数。
     </li>
     <li>
      <strong>
       初始化：
      </strong>
      <br/>
      用二维数组
      <code>
       dist
      </code>
      记录每个格子到起点的最短步数。初始时所有位置的值设为 -1，表示未访问。将起始点的步数设为 0，并将其入队。
     </li>
     <li>
      <strong>
       队列操作：
      </strong>
      <br/>
      使用一个数组
      <code>
       q
      </code>
      模拟队列。使用两个指针
      <code>
       hh
      </code>
      （队首）和
      <code>
       tt
      </code>
      （队尾）来管理队列。队列中存储的是每个已访问位置的坐标。
     </li>
     <li>
      <strong>
       扩展过程：
      </strong>
      <br/>
      当队列不为空时，从队列中取出一个点，然后依次检查马的八个可能走法所到达的新位置。对于每个新位置：
      <ul>
       <li>
        检查是否在棋盘范围内。
       </li>
       <li>
        检查该位置是否未被访问（
        <code>
         dist
        </code>
        值仍为 -1）。
       </li>
       <li>
        如果满足条件，则更新新位置的步数（为当前位置步数 + 1），并将该位置加入队列。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       结束条件：
      </strong>
      <br/>
      BFS 遍历完所有能到达的点后结束。此时，
      <code>
       dist
      </code>
      数组中记录了从起点到各个格子的最短步数（或 -1 表示不可达）。
     </li>
     <li>
      <strong>
       输出：
      </strong>
      <br/>
      最后按行列遍历棋盘，将
      <code>
       dist
      </code>
      数组中的值按格式输出，保证矩阵排列整齐。
     </li>
    </ul>
    <h5>
     <a id="4__131">
     </a>
     4. 代码细节
    </h5>
    <ul>
     <li>
      <strong>
       数组下标从 1 开始：
      </strong>
      <br/>
      题目中棋盘行列的范围从 1 开始，所以代码中所有下标均从 1 到 n 或 m。
     </li>
     <li>
      <strong>
       马的移动偏移量：
      </strong>
      <br/>
      使用两个数组
      <code>
       dx
      </code>
      和
      <code>
       dy
      </code>
      分别存储马横向和纵向的移动偏移量，确保能够枚举出所有可能的 8 种走法。
     </li>
     <li>
      <strong>
       队列实现：
      </strong>
      <br/>
      代码中使用数组
      <code>
       q
      </code>
      和两个指针
      <code>
       hh
      </code>
      和
      <code>
       tt
      </code>
      来模拟队列操作，避免使用 STL 中的队列以提高效率。
     </li>
     <li>
      <strong>
       格式化输出：
      </strong>
      <br/>
      使用
      <code>
       printf("%-5d", ...)
      </code>
      保证输出时每个数字占据固定宽度，有利于矩阵效果的展示。
     </li>
    </ul>
    <h5>
     <a id="5__142">
     </a>
     5. 总结
    </h5>
    <p>
     该题目的关键在于利用 BFS 遍历整个棋盘，同时利用合理的数组下标控制和边界检查，确保每个合法位置都被正确计算最短步数。BFS 能够在无权图中保证最短路径的正确性，是解决这类问题的经典算法。代码简洁高效，适合用在类似的棋盘遍历问题中。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f736a736e5f7a2f:61727469636c652f64657461696c732f313436303832313039" class_="artid" style="display:none">
 </p>
</div>


