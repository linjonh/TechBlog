---
layout: post
title: "DockerFlask-实战打造高并发微服务架构"
date: 2025-03-11 16:10:28 +0800
description: "在微服务架构风靡的今天，如何快速构建高效稳定的 Web 服务？本文以 Docker 与 Flask 为核心，通过多阶段构建、Gunicorn+Gevent 并发优化、Nginx 反向代理等实战技巧，教你将镜像体积压缩 40%，QPS 突破。从开发到部署全流程自动化，揭秘大厂如何实现 “代码提交即上线”。无论你是 DevOps 新手还是架构师，都能掌握容器化部署的黄金法则，让应用在云端轻装上阵。"
keywords: "flask docker上线"
categories: ['服务器容器', 'Linux']
tags: ['运维', '架构', '微服务', '容器', 'Docker']
artid: "146181753"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146181753
    alt: "DockerFlask-实战打造高并发微服务架构"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146181753
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146181753
cover: https://bing.ee123.net/img/rand?artid=146181753
image: https://bing.ee123.net/img/rand?artid=146181753
img: https://bing.ee123.net/img/rand?artid=146181753
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Docker+Flask 实战：打造高并发微服务架构
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="DockerFlask__0">
     </a>
     <strong>
      Docker+Flask 实战：打造高并发微服务架构
     </strong>
    </h3>
    <p>
     今天我们要深入探讨一个非常热门且实用的主题：基于 Docker 部署 Python Flask 应用。Docker 作为当下最流行的容器化技术，已经广泛应用于各种开发和部署场景，尤其是在微服务架构中。而 Flask 作为 Python 世界里轻量级的 Web 框架，同样备受开发者青睐。将二者结合，能极大地提高我们应用的部署效率和可移植性。接下来，我们就一起通过一个完整的实例来学习如何实现这个过程。
    </p>
    <h4>
     <a id="_4">
     </a>
     测试虚拟机环境介绍
    </h4>
    <p>
     在开始之前，先给大家介绍一下我们使用的测试虚拟机环境。我们使用的是 VMware，配置为 4G 内存和 2 核心。这样的配置对于我们今天的演示来说是足够的，当然在实际生产环境中，你可能需要根据具体的应用需求来调整硬件资源。
    </p>
    <h4>
     <a id="Docker__Flask__8">
     </a>
     Docker + Flask 部署实例
    </h4>
    <h5>
     <a id="1__10">
     </a>
     1. 项目代码
    </h5>
    <p>
     首先，我们来看一下 Flask 应用的代码，它在
     <code>
      app.py
     </code>
     文件中。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"Hello Docker World!"</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">5000</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     这段代码非常简单，我们导入了 Flask 框架，创建了一个 Flask 应用实例，然后定义了一个路由
     <code>
      /
     </code>
     ，当访问这个路由时，会返回一个简单的字符串。最后，我们通过
     <code>
      app.run
     </code>
     方法启动了这个应用，并将其监听在
     <code>
      0.0.0.0:5000
     </code>
     上，这样容器内的服务就能监听所有网络接口，而不仅仅是本地环回地址。
    </p>
    <h5>
     <a id="2_Dockerfile__28">
     </a>
     2. Dockerfile 配置
    </h5>
    <p>
     接下来，我们要在项目根目录创建一个
     <code>
      Dockerfile
     </code>
     。
    </p>
    <pre><code class="prism language-Dockerfile"># 使用轻量级 Python 基础镜像
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 代码到容器
COPY . .

# 安装依赖（使用国内镜像加速）
RUN pip install --no-cache-dir -r requirements.txt

# 暴露端口
EXPOSE 5000

# 启动命令
CMD ["python", "app.py"]
</code></pre>
    <p>
     这里面有几个关键的指令需要大家注意。首先是
     <code>
      FROM python:3.10-slim
     </code>
     ，我们使用的是官方的轻量级 Python 镜像，它的体积只有约 127MB，相比
     <code>
      centos
     </code>
     镜像更加高效，这对于我们构建和部署镜像来说可以节省很多时间和存储空间。然后是
     <code>
      --no-cache-dir
     </code>
     这个参数，它的作用是避免缓存依赖，确保每次构建时都能安装最新版本的依赖。
     <code>
      EXPOSE 5000
     </code>
     声明了容器暴露的端口，不过需要注意的是，这只是一个声明，实际运行容器时还需要结合
     <code>
      -p
     </code>
     参数将容器端口映射到宿主机上。最后，
     <code>
      CMD
     </code>
     指令定义了容器启动时要执行的命令。
    </p>
    <h5>
     <a id="3__54">
     </a>
     3. 依赖管理
    </h5>
    <p>
     我们还需要创建一个
     <code>
      requirements.txt
     </code>
     文件，用来列出所有的依赖。
    </p>
    <pre><code>Flask==3.0.0
</code></pre>
    <p>
     明确指定依赖的版本号是非常重要的，这样可以避免依赖冲突。建议大家在本地使用虚拟环境进行测试，确保所有依赖都能正常工作后，再进行打包。
    </p>
    <h5>
     <a id="4__64">
     </a>
     4. 构建镜像
    </h5>
    <p>
     在项目目录下执行以下命令来构建镜像：
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> build --no-cache <span class="token parameter variable">-t</span> my-flask-app <span class="token builtin class-name">.</span>
</code></pre>
    <p>
     这里的
     <code>
      --no-cache
     </code>
     参数是强制重新构建镜像，避免缓存导致依赖未更新。
    </p>
    <h5>
     <a id="5__74">
     </a>
     5. 运行容器
    </h5>
    <p>
     构建好镜像后，我们就可以启动容器并映射端口了。
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> flask-container <span class="token parameter variable">-p</span> <span class="token number">8080</span>:5000 my-flask-app
</code></pre>
    <p>
     <code>
      -d
     </code>
     参数表示后台运行容器，
     <code>
      -p 8080:5000
     </code>
     是将宿主机的 8080 端口映射到容器的 5000 端口，
     <code>
      --name
     </code>
     则是为容器指定一个名称，方便我们后续管理。
    </p>
    <h5>
     <a id="6__84">
     </a>
     6. 测试访问
    </h5>
    <p>
     我们可以通过浏览器或终端来访问我们的应用：
    </p>
    <pre><code class="prism language-bash"><span class="token function">curl</span> http://localhost:8080
<span class="token comment"># 或</span>
http://127.0.0.1:8080
</code></pre>
    <p>
     如果一切正常，你应该能看到
     <code>
      Hello Docker World!
     </code>
     这个输出。
    </p>
    <h5>
     <a id="7__96">
     </a>
     7. 调试与维护
    </h5>
    <p>
     在实际开发过程中，调试和维护是非常重要的。我们可以通过以下命令来查看容器的日志：
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> logs flask-container
</code></pre>
    <p>
     如果需要进入容器的终端进行一些操作，可以使用：
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> flask-container /bin/bash
</code></pre>
    <p>
     当我们修改了
     <code>
      app.py
     </code>
     中的代码后，需要重新执行
     <code>
      docker build
     </code>
     和
     <code>
      docker run
     </code>
     命令，或者使用
     <code>
      docker-compose
     </code>
     来简化这个流程。
    </p>
    <h4>
     <a id="_112">
     </a>
     完整高级优化实例
    </h4>
    <h5>
     <a id="_114">
     </a>
     文件结构
    </h5>
    <p>
     下面我们来看一个更高级的优化实例，首先看一下文件结构：
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">.</span>
├── docker-compose.yml      <span class="token comment"># 编排配置</span>
├── Dockerfile              <span class="token comment"># 多阶段构建</span>
├── app
│   ├── app.py             <span class="token comment"># Flask 主程序</span>
│   └── requirements.txt   <span class="token comment"># 精确依赖</span>
└── nginx
    └── nginx.conf         <span class="token comment"># 反向代理配置</span>
</code></pre>
    <h5>
     <a id="Dockerfile_129">
     </a>
     Dockerfile（含多阶段构建）
    </h5>
    <pre><code class="prism language-Dockerfile"># 构建阶段
FROM python:3.11-slim-bullseye AS builder
WORKDIR /build
COPY app/requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# 运行阶段
FROM python:3.11-slim-bullseye
WORKDIR /app

# 安全配置
RUN adduser --disabled-password --gecos '' appuser &amp;&amp; chown -R appuser:appuser /app
USER appuser

# 依赖安装
# 这里要注意的是 /root/.local 不要写成 /home/appuser/.local，因为你的系统内没有这个目录
# 我是在 root 用户下执行的操作，所以是/root/.local
COPY --from=builder /root/.local /home/appuser/.local  
ENV PATH=/home/appuser/.local/bin:$PATH

# 应用代码
COPY app .

# 健康检查
HEALTHCHECK --interval=30s --timeout=5s CMD curl -f http://localhost:5000/health || exit 1
# 启动命令
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "9", "--worker-class", "gevent", "app:app"]
</code></pre>
    <p>
     这里使用了多阶段构建的方式，在构建阶段我们只安装依赖，然后在运行阶段将依赖复制过来，并使用非 root 用户运行应用，提高了容器的安全性。同时，我们还添加了健康检查，确保容器内的服务正常运行。启动命令使用了
     <code>
      gunicorn
     </code>
     作为 WSGI 服务器，并使用
     <code>
      gevent
     </code>
     作为工作类，提高了应用的并发性能。
    </p>
    <h5>
     <a id="appapppy_163">
     </a>
     app/app.py（含监控端点）
    </h5>
    <pre><code class="prism language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
<span class="token keyword">from</span> prometheus_client <span class="token keyword">import</span> generate_latest<span class="token punctuation">,</span> Counter

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
REQUEST_COUNTER <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token string">'http_requests_total'</span><span class="token punctuation">,</span> <span class="token string">'Total HTTP Requests'</span><span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    REQUEST_COUNTER<span class="token punctuation">.</span>inc<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">"Hello Production Docker World!"</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/health'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">health</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"OK"</span><span class="token punctuation">,</span> <span class="token number">200</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/metrics'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">metrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> generate_latest<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     在这个
     <code>
      app.py
     </code>
     中，我们添加了一些监控端点。
     <code>
      /health
     </code>
     端点用于健康检查，
     <code>
      /metrics
     </code>
     端点用于提供 Prometheus 监控数据，这样我们就能更好地监控应用的运行状态。
    </p>
    <h5>
     <a id="apprequirementstxt_188">
     </a>
     app/requirements.txt（精确版本控制）
    </h5>
    <pre><code>Flask==3.0.0
gunicorn==21.2.0
gevent==23.9.1
prometheus-client==0.20.0
</code></pre>
    <p>
     精确控制依赖的版本号可以避免因依赖版本不一致而导致的问题。
    </p>
    <h5>
     <a id="dockercomposeyml_199">
     </a>
     docker-compose.yml（生产编排）
    </h5>
    <pre><code class="prism language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.11'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">'2.0'</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1GB
    <span class="token key atrule">logging</span><span class="token punctuation">:</span>
      <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"json-file"</span>
      <span class="token key atrule">options</span><span class="token punctuation">:</span>
        <span class="token key atrule">max-size</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>

  <span class="token key atrule">nginx</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span><span class="token number">1.25</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"80:80"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./nginx/nginx.conf<span class="token punctuation">:</span>/etc/nginx/nginx.conf
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> web
</code></pre>
    <p>
     <code>
      docker-compose.yml
     </code>
     是用于生产编排的，我们可以通过它来定义多个服务，并进行资源管控和日志配置。这里我们定义了
     <code>
      web
     </code>
     和
     <code>
      nginx
     </code>
     两个服务，
     <code>
      web
     </code>
     服务构建我们的 Flask 应用，
     <code>
      nginx
     </code>
     服务作为反向代理，将请求转发到
     <code>
      web
     </code>
     服务上。
    </p>
    <h5>
     <a id="nginxnginxconf_231">
     </a>
     nginx/nginx.conf（反向代理配置）
    </h5>
    <pre><code class="prism language-nginx">worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream flask {
        server web:5000;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://flask;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
</code></pre>
    <p>
     这个
     <code>
      nginx.conf
     </code>
     文件配置了反向代理，将所有请求转发到
     <code>
      web
     </code>
     服务的 5000 端口上。
    </p>
    <h5>
     <a id="_259">
     </a>
     部署流程
    </h5>
    <pre><code class="prism language-bash"><span class="token comment"># 构建镜像</span>
<span class="token function">docker-compose</span> build

<span class="token comment"># 启动集群</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>

<span class="token comment"># 验证部署</span>
<span class="token function">curl</span> http://localhost/health
</code></pre>
    <p>
     通过这几个简单的命令，我们就可以完成整个应用的部署和验证。
    </p>
    <h5>
     <a id="_274">
     </a>
     关键优化点说明
    </h5>
    <p>
     最后，我们来看一下这个高级优化实例的关键优化点：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        优化方向
       </th>
       <th>
        实现方案
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ‌
        <strong>
         镜像体积
        </strong>
        ‌
       </td>
       <td>
        多阶段构建（162MB 镜像）
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         并发性能
        </strong>
        ‌
       </td>
       <td>
        Gunicorn + Gevent（9 workers）
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         安全基线
        </strong>
        ‌
       </td>
       <td>
        非 root 用户运行 + 文件权限控制
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         可观测性
        </strong>
        ‌
       </td>
       <td>
        Prometheus 监控端点 + 健康检查
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         资源管控
        </strong>
        ‌
       </td>
       <td>
        CPU/内存限制 + 日志滚动策略
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     我们还进行了压力测试，所有参数均通过
     <code>
      wrk -t12 -c400 -d30s http://localhost/
     </code>
     压力测试验证，QPS 为1125，可能是虚拟机的原因吧。
    </p>
    <p>
     下面的几个版本的对比：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        镜像
       </th>
       <th>
        组件
       </th>
       <th>
        镜像大小
       </th>
       <th>
        QPS
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        flask-app:v1
       </td>
       <td>
        Python:3.11 +Flask3.0
       </td>
       <td>
        138MB
       </td>
       <td>
        1000.95
       </td>
      </tr>
      <tr>
       <td>
        flask-app:v2
       </td>
       <td>
        Python:3.11-alpine +Flask3.0
       </td>
       <td>
        58.6MB
       </td>
       <td>
        899.78
       </td>
      </tr>
      <tr>
       <td>
        flask-nginx-web:v1
       </td>
       <td>
        Python:3.11-slim-bullseye +Flask3.0+gunicorn21.2.0+
        <br/>
        gevent23.9.1+prometheus-client0.20.0
       </td>
       <td>
        162MB
       </td>
       <td>
        1125.04
       </td>
      </tr>
      <tr>
       <td>
        flask-nginx-web:v2
       </td>
       <td>
        Python:3.11-alpine +Flask3.0+gunicorn21.2.0+
        <br/>
        gevent23.9.1+prometheus-client0.20.0
       </td>
       <td>
        92.7MB
       </td>
       <td>
        1049.89
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     alpin镜像确实小，从QPS的角度来看，并不是什么都用alpin镜像就好的。
    </p>
    <h4>
     <a id="_299">
     </a>
     总结
    </h4>
    <p>
     今天我们学习了如何基于 Docker 部署 Python Flask 应用，从简单的实例到高级优化实例，希望大家能对 Docker 的使用有更深入的理解。在实际开发中，大家可以根据自己的需求进行调整和优化，充分发挥 Docker 的优势。如果大家有任何问题，欢迎随时提问。谢谢大家！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f7369646f3737372f:61727469636c652f64657461696c732f313436313831373533" class_="artid" style="display:none">
 </p>
</div>


