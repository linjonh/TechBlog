---
layout: post
title: "数据结构AVL树平衡二叉树"
date: 2025-03-05 17:49:49 +0800
description: "AVL树的出现主要是解决在一些特定情况下的搜索二叉树出现的效率低的问题，因为在一些极端情况下，搜索二叉树的形况可能会发生一些变异，例如下面的情况。从而影响整个数据结构的效率；AVL树通过在节点中引出平衡因子，再插入过程中自适应调节平衡因子，从而使树达到平衡状态。平衡因子的定义：一个根节点的平衡因子=右子树的高度-左子树的高度；AVL树的要求是每一个节点的平衡因子只能是（-1/0/1）；如果平衡因子发生变化，那么就要进行自适应调整。"
keywords: "数据结构【AVL树（平衡二叉树）】"
categories: ['数据结构']
tags: ['数据结构']
artid: "146045314"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146045314
    alt: "数据结构AVL树平衡二叉树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146045314
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146045314
cover: https://bing.ee123.net/img/rand?artid=146045314
image: https://bing.ee123.net/img/rand?artid=146045314
img: https://bing.ee123.net/img/rand?artid=146045314
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构【AVL树（平衡二叉树）】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     AVL树的出现主要是解决在一些特定情况下的搜索二叉树出现的效率低的问题，因为在一些极端情况下，搜索二叉树的形况可能会发生一些变异，例如下面的情况。从而影响整个数据结构的效率；
    </p>
    <p class="img-center">
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/cca178273f534eb1b0ab64b7ea4fc689.png" width="548"/>
    </p>
    <p>
     AVL树通过在节点中引出平衡因子，再插入过程中自适应调节平衡因子，从而使树达到平衡状态 。平衡因子的定义：一个根节点的平衡因子=右子树的高度-左子树的高度；AVL树的要求是每一个节点的平衡因子只能是（-1/0/1）；如果平衡因子发生变化，那么就要进行自适应调整。
    </p>
    <h2>
     1、节点的设计
    </h2>
    <pre><code class="language-cpp">template&lt;class K, class V&gt;
struct AVLTreeNode
{
	pair&lt;K, V&gt; _kv;
	AVLTreeNode&lt;K,V&gt;* _left;
	AVLTreeNode&lt;K, V&gt;* _right;
	AVLTreeNode&lt;K, V&gt;* _parent;
	int _bf;

	AVLTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_kv(kv)
		,_left(nullptr)
		,_right(nullptr)
		,_parent(nullptr)
		,_bf(0)
	{}

};</code></pre>
    <p>
     节点内部存放是键对，仿照STL标准库的设计。_bf(balance factor)为该节点的饿平衡因子；
    </p>
    <p>
     数中引入_parent，主要是将节点设计成三叉链的形式，便于后面的平衡因子的更新。
    </p>
    <h2>
     2、节点的插入
    </h2>
    <p>
     节点的插入部分前面类似于搜索二叉树的插入，只不过就是要在插入之后进行平衡因子的控制；这里给出插入的一般逻辑：
    </p>
    <pre><code class="language-cpp">template&lt;class K,class V&gt;
class AVLTree
{
	typedef AVLTreeNode&lt;K, V&gt; Node;
public:
	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			return true;
		}

		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(kv);
		if (parent-&gt;_kv.first &gt; kv.first)
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}
		cur-&gt;_parent = parent;

		//控制平衡...

		return true;
	}



	  
private:
	Node* _root = nullptr;
};</code></pre>
    <h3>
     <strong>
      1、下面需要着重讨论怎么去控制平衡问题：
     </strong>
    </h3>
    <p>
     首先需要明确的是，插入的节点的平衡因子一定为0，它的父节点的平衡因子是一定要进行更新的。问题是，父节点的更新之后要不要沿着祖先的路径接着向上继续更新呢？
    </p>
    <p>
     <img alt="" height="417" src="https://i-blog.csdnimg.cn/direct/961cedf6cb6a4432b92bf3fccd8f5d6d.png" width="1026"/>
    </p>
    <p>
     就像上面的情况，当更新到父亲节点的平衡因子为0是就可以停止了。这是因为如果一个父节点的平衡因子为0，那就说明在插入新的节点之后，它的左右子树的高度没有发生变化。所以它不会影响他的父亲节点的平衡因子。因此这种情况下就可以直接停止更新行为；
    </p>
    <h3>
     <strong>
      2、平衡因子需要更新这点很清楚，那么怎么去更新呢？
     </strong>
    </h3>
    <p>
     我们可以发现，平衡因子的定义为右子树减去左子树的高度，也就是说当右子树的高度增加之后，平衡因子就会+1，左子树的高高度增加之后，平衡因子就会-1；通过这个特性进行平衡因子的更新。这里肯定需要用到循环，那么最坏的情况下父亲节点走到根节点的位置更新之后就不用更新了，也就说父节点一旦为空更新就终止了；
    </p>
    <h3>
     <strong>
      3、下面探讨更新的几种情况：
     </strong>
    </h3>
    <p>
     <strong>
      如果父节点的_bf == 1 || _bf == -1时需要沿着祖先的位置进行迭代更新,(直到父节点的_bf == 0);
     </strong>
    </p>
    <p>
     <strong>
      如果父节点的_bf == 2 || _bf == -2时，这时就需要进
      <span style="color:#fe2c24">
       旋转
      </span>
      ；这里需要进行分类讨论：
     </strong>
    </p>
    <h4>
     <span style="color:#fe2c24">
      <strong>
       3.1、左单旋（父节点的平衡因子为2 且 当前节点的平衡因子为1）
      </strong>
     </span>
    </h4>
    <p>
     <img alt="" height="730" src="https://i-blog.csdnimg.cn/direct/602edd7d1d7540cdbba17eaa3987fca2.png" width="1803"/>
    </p>
    <p>
     像上面的情况其实是众多情况下的一种具象话实例，要进行左单旋就意味着当前节点的右子树高度明显高于左子树的高度，此时就需要进行调整，达到树的平衡。
     <strong>
      问题是怎么进行调整呢？？
     </strong>
    </p>
    <p>
     下面，请看图说话：进行左单旋时主要是对粉色的节点进行链接关系的修改；
    </p>
    <p>
     <img alt="" height="709" src="https://i-blog.csdnimg.cn/direct/9fd4d774d44b43ed98cd3e345d1799b7.png" width="1784"/>
    </p>
    <p>
     左单旋完成之后的位置关系：
    </p>
    <p>
     <img alt="" height="601" src="https://i-blog.csdnimg.cn/direct/0f8515a2172f4adcbe40de2826e275c7.png" width="1739"/>
    </p>
    <p>
     我们可以看到实际上就是将cur的左节点链接到parent的右节点上，再将cur的左节点链接到parent上，这样一来，cur和parent的平衡因子自然而然的就达到了平衡条件。所以只需要在左单旋之后对cur和parent的平衡因子直接进行修改即可。
     <strong>
      前面我们在节点中定义的是三叉链，所以在左单旋的过程中也要对每个节点的父亲节点进行更新。
     </strong>
    </p>
    <pre><code class="language-cpp">void RotateL(Node* parent)
{
	Node* cur = parent-&gt;_right;
	Node* curLeft = cur-&gt;_left;//可能为空，后面需要判断；
	Node* ppNode = parent-&gt;_parent;

	parent-&gt;_right = curLeft;
	if (curLeft)
	{
		curLeft-&gt;_parent = parent;
	}
	
	cur-&gt;_left = parent;    
	parent-&gt;_parent = cur;

	parent-&gt;_bf = cur-&gt;_bf = 0;

	if (parent == _root)
	{
		_root = cur;
		cur-&gt;_parent = nullptr;
	}
	else
	{
        //第三种情况，parent上面还有其他节点
		if (ppNode-&gt;_left == parent)
		{
			ppNode-&gt;_left = cur;
		}
		else
		{
			ppNode-&gt;_right = cur;
		}
		cur-&gt;_parent = ppNode;
	}
}</code></pre>
    <h4>
     <strong>
      <span style="color:#fe2c24">
       3.2 右单旋
      </span>
     </strong>
     <span style="color:#fe2c24">
      <strong>
       （父节点的平衡因子为-2 且 当前节点的平衡因子为-1）
      </strong>
     </span>
    </h4>
    <p>
     <span style="color:#fe2c24">
      <strong>
      </strong>
     </span>
     <strong>
      <span style="color:#0d0016">
       右单旋是因为左子树的高度大于右子树的高度。所以要进行右单旋；
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="722" src="https://i-blog.csdnimg.cn/direct/b6a68bc085d14532af3ffda335eadecd.png" width="1769"/>
    </p>
    <p>
     右单旋之后的节点关系：
    </p>
    <p>
     <img alt="" height="705" src="https://i-blog.csdnimg.cn/direct/473c40d972b643cbae6bcb087adebcab.png" width="1760"/>
    </p>
    <p>
     我们可以看到，其实就是将cur的右子树连接到parent的左子树上，再将parent链接到cur的右子树上，同样就自然而然地 满足cur和parent的平衡因子为0、同样我们在右旋过程中需要更新各个节点的父亲节点；
    </p>
    <h4>
     <span style="color:#fe2c24">
      <strong>
       3.3 右左双旋（父节点的平衡因子为2 且 当前节点的平衡因子为-1）
      </strong>
     </span>
    </h4>
    <p>
     <strong>
      主要原因是父节点的右子树高于左子树，而当前节点间的左子树高于右子树；
     </strong>
    </p>
    <p>
     <strong>
      假设新插入的节点在9这个节点的左边：
     </strong>
    </p>
    <p>
     <img alt="" height="596" src="https://i-blog.csdnimg.cn/direct/f9d385a953e847ddbb247510adee85c3.png" width="1719"/>
    </p>
    <p>
     <strong>
      其实这里就是先进行右旋再进行左旋，只是在旋转之后需要对平衡因子进行更新，这里会有一个问题，就是说在左右旋之后会将三个节点的平衡因子都改为0，但是上面的cur的平衡因子明显为1；
     </strong>
    </p>
    <p>
     <strong>
      再看下面的情况：
     </strong>
    </p>
    <p>
     <img alt="" height="595" src="https://i-blog.csdnimg.cn/direct/a2ab526adfe64f78a63ac4041fb5b82d.png" width="1712"/>
    </p>
    <p>
     当新插入节点在9的右侧时，最后parent的平衡因子就会变为-1，而其他两个节点的平衡因子为0；
    </p>
    <p>
     <img alt="" height="548" src="https://i-blog.csdnimg.cn/direct/8ddf5ece9db743999de495edde7b2737.png" width="1407"/>
    </p>
    <p>
     代码如下：
    </p>
    <pre><code class="language-cpp">	void RotateRL(Node* parent)
	{
		Node* cur = parent-&gt;_right;
		Node* curLeft = cur-&gt;_left;
		int bf = curLeft-&gt;_bf;
		RotateR(parent-&gt;_right);
		RotateL(parent);
		if (bf == 0)
		{
			parent-&gt;_bf = 0;
			cur-&gt;_bf = 0;
			curLeft-&gt;_bf = 0;
		}
		else if (bf == 1)
		{
			parent-&gt;_bf = -1;
			cur-&gt;_bf = 0;
			curLeft-&gt;_bf = 0;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 0;
			cur-&gt;_bf = 1;
			curLeft-&gt;_bf = 0;
		}
		else
		{
			assert(false);
		}
	}</code></pre>
    <p>
     <span style="color:#fe2c24">
      <strong>
       3.3 左右双旋（父节点的平衡因子为-2 且 当前节点的平衡因子为1）
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       待续...
      </strong>
     </span>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37303139393038322f:61727469636c652f64657461696c732f313436303435333134" class_="artid" style="display:none">
 </p>
</div>


