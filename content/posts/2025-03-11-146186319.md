---
layout: post
title: "vue2双向绑定解析"
date: 2025-03-11 18:55:56 +0800
description: "Vue 2 的双向绑定原理基于，核心源码在目录中。"
keywords: "vue2双向绑定解析"
categories: ['未分类']
tags: ['前端', 'Vue', 'Javascript']
artid: "146186319"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146186319
    alt: "vue2双向绑定解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146186319
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146186319
cover: https://bing.ee123.net/img/rand?artid=146186319
image: https://bing.ee123.net/img/rand?artid=146186319
img: https://bing.ee123.net/img/rand?artid=146186319
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     vue2双向绑定解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Vue 2 的双向绑定原理基于
     <strong>
      Object.defineProperty
     </strong>
     ，核心源码在
     <code>
      src/core/observer
     </code>
     目录中。
    </p>
    <p>
    </p>
    <h4>
     1. 核心模块：
     <code>
      observer
     </code>
    </h4>
    <p>
     <code>
      observer
     </code>
     模块负责将普通对象转换为响应式对象，主要包括以下文件：
    </p>
    <ul>
     <li>
      <code>
       index.js
      </code>
      ：定义
      <code>
       Observer
      </code>
      类，用于将对象转换为响应式。
     </li>
     <li>
      <code>
       dep.js
      </code>
      ：定义
      <code>
       Dep
      </code>
      类，用于管理依赖（订阅者）。
     </li>
     <li>
      <code>
       watcher.js
      </code>
      ：定义
      <code>
       Watcher
      </code>
      类，用于监听数据变化并触发更新。
     </li>
    </ul>
    <h4>
    </h4>
    <h4>
     2.
     <code>
      Observer
     </code>
     类
    </h4>
    <p>
     <code>
      Observer
     </code>
     类是 Vue 2 响应式系统的核心，它通过
     <code>
      Object.defineProperty
     </code>
     将对象的属性转换为
     <code>
      getter
     </code>
     和
     <code>
      setter
     </code>
     ，从而实现依赖收集和派发更新。
    </p>
    <p>
     源码位置：
     <code>
      src/core/observer/index.js
     </code>
    </p>
    <pre><code class="language-javascript">export class Observer {
  value: any;
  dep: Dep;
  vmCount: number;

  constructor(value: any) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this); // 将 Observer 实例挂载到对象的 __ob__ 属性上
    if (Array.isArray(value)) {
      // 处理数组
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      // 处理对象
      this.walk(value);
    }
  }

  walk(obj: Object) {
    const keys = Object.keys(obj);
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  }

  observeArray(items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i]);
    }
  }
}</code></pre>
    <ul>
     <li>
      <code>
       Observer
      </code>
      类会递归地将对象的属性转换为响应式。
     </li>
     <li>
      对于数组，Vue 2 通过重写数组的变异方法（如
      <code>
       push
      </code>
      、
      <code>
       pop
      </code>
      等）来实现响应式。
     </li>
    </ul>
    <h4>
     3.
     <code>
      defineReactive
     </code>
     函数
    </h4>
    <p>
     <code>
      defineReactive
     </code>
     是 Vue 2 实现响应式的核心函数，它通过
     <code>
      Object.defineProperty
     </code>
     定义属性的
     <code>
      getter
     </code>
     和
     <code>
      setter
     </code>
     。
    </p>
    <p>
     源码位置：
     <code>
      src/core/observer/index.js
     </code>
    </p>
    <pre><code class="language-javascript">export function defineReactive(
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep(); // 每个属性都有一个 Dep 实例，用于管理依赖

  const getter = property &amp;&amp; property.get;
  const setter = property &amp;&amp; property.set;
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key];
  }

  let childOb = !shallow &amp;&amp; observe(val); // 递归处理嵌套对象
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      const value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend(); // 收集依赖
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      const value = getter ? getter.call(obj) : val;
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return;
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow &amp;&amp; observe(newVal); // 对新值进行响应式处理
      dep.notify(); // 通知依赖更新
    },
  });
}</code></pre>
    <ul>
     <li>
      <code>
       getter
      </code>
      ：在访问属性时，调用
      <code>
       dep.depend()
      </code>
      收集依赖。
     </li>
     <li>
      <code>
       setter
      </code>
      ：在修改属性时，调用
      <code>
       dep.notify()
      </code>
      通知依赖更新。
     </li>
    </ul>
    <h4>
     4.
     <code>
      Dep
     </code>
     类
    </h4>
    <p>
     <code>
      Dep
     </code>
     类是依赖管理器，用于存储和管理
     <code>
      Watcher
     </code>
     实例。
    </p>
    <p>
     源码位置：
     <code>
      src/core/observer/dep.js
     </code>
    </p>
    <pre><code class="language-javascript">export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor() {
    this.id = uid++;
    this.subs = [];
  }

  addSub(sub: Watcher) {
    this.subs.push(sub);
  }

  removeSub(sub: Watcher) {
    remove(this.subs, sub);
  }

  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }

  notify() {
    const subs = this.subs.slice();
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update();
    }
  }
}</code></pre>
    <ul>
     <li>
      <code>
       Dep.target
      </code>
      ：当前正在计算的
      <code>
       Watcher
      </code>
      实例。
     </li>
     <li>
      <code>
       subs
      </code>
      ：存储所有订阅了该属性的
      <code>
       Watcher
      </code>
      实例。
     </li>
     <li>
      <code>
       notify
      </code>
      ：通知所有订阅者更新。
     </li>
    </ul>
    <h4>
     5.
     <code>
      Watcher
     </code>
     类
    </h4>
    <p>
     <code>
      Watcher
     </code>
     类是 Vue 2 中用于监听数据变化的订阅者，它会在数据变化时触发回调函数。
    </p>
    <p>
     源码位置：
     <code>
      src/core/observer/watcher.js
     </code>
    </p>
    <pre><code class="language-javascript">export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deps: Array&lt;Dep&gt;;
  newDeps: Array&lt;Dep&gt;;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  getter: Function;
  value: any;

  constructor(
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm;
    this.cb = cb;
    this.id = ++uid; // uid for batching
    this.deps = [];
    this.newDeps = [];
    this.depIds = new Set();
    this.newDepIds = new Set();
    this.getter = parsePath(expOrFn);
    this.value = this.get();
  }

  get() {
    pushTarget(this); // 将当前 Watcher 设置为 Dep.target
    let value;
    const vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      // 处理错误
    } finally {
      popTarget(); // 恢复之前的 Watcher
      this.cleanupDeps();
    }
    return value;
  }

  update() {
    queueWatcher(this); // 将 Watcher 加入队列，等待批量更新
  }

  run() {
    const value = this.get();
    if (value !== this.value || isObject(value)) {
      const oldValue = this.value;
      this.value = value;
      this.cb.call(this.vm, value, oldValue); // 执行回调
    }
  }
}</code></pre>
    <ul>
     <li>
      <code>
       Watcher
      </code>
      实例会在初始化时调用
      <code>
       get
      </code>
      方法，触发属性的
      <code>
       getter
      </code>
      ，从而收集依赖。
     </li>
     <li>
      当数据变化时，
      <code>
       Watcher
      </code>
      的
      <code>
       update
      </code>
      方法会被调用，最终触发回调函数。
     </li>
    </ul>
    <p>
     Vue 2 的双向绑定原理基于
     <code>
      Object.defineProperty
     </code>
     ，通过以下步骤实现：
    </p>
    <ol>
     <li>
      <strong>
       响应式化
      </strong>
      ：
      <code>
       Observer
      </code>
      类将对象的属性转换为
      <code>
       getter
      </code>
      和
      <code>
       setter
      </code>
      。
     </li>
     <li>
      <strong>
       依赖收集
      </strong>
      ：在
      <code>
       getter
      </code>
      中调用
      <code>
       dep.depend()
      </code>
      ，将当前
      <code>
       Watcher
      </code>
      添加到依赖列表中。
     </li>
     <li>
      <strong>
       派发更新
      </strong>
      ：在
      <code>
       setter
      </code>
      中调用
      <code>
       dep.notify()
      </code>
      ，通知所有依赖的
      <code>
       Watcher
      </code>
      更新。
     </li>
     <li>
      <strong>
       批量更新
      </strong>
      ：
      <code>
       Watcher
      </code>
      的更新会被加入队列，异步执行，以提高性能。
     </li>
    </ol>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33333839343138362f:61727469636c652f64657461696c732f313436313836333139" class_="artid" style="display:none">
 </p>
</div>


