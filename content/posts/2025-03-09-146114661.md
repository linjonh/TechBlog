---
layout: post
title: "JVM常见面试题"
date: 2025-03-09 14:56:21 +0800
description: "JVM的内存区分为虚拟机栈、本地方法栈、程序计数器、堆、方法区。其中，虚拟机栈、本地方法栈、程序计数器是每个线程独占区，堆、方法区是所有线程共享的内存区域。：每个线程在运行时都会创建一个虚拟机栈。栈中存储的是栈帧（Stack Frame），每个方法调用都会创建一个栈帧，并将其压入栈中。为执行本地native方法（如C/C++代码）提供支持。:记录当前线程所执行的字节码指令地址。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；"
keywords: "JVM常见面试题"
categories: ['面试专题']
tags: ['Jvm']
artid: "146114661"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146114661
    alt: "JVM常见面试题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146114661
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146114661
cover: https://bing.ee123.net/img/rand?artid=146114661
image: https://bing.ee123.net/img/rand?artid=146114661
img: https://bing.ee123.net/img/rand?artid=146114661
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM常见面试题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、JVM的内存区
    </h2>
    <p>
     JVM的内存区分为虚拟机栈、本地方法栈、程序计数器、堆、方法区。
    </p>
    <p>
     其中，虚拟机栈、本地方法栈、程序计数器是每个线程独占区，堆、方法区是所有线程共享的内存区域。
    </p>
    <p>
     <img alt="" height="374" src="https://i-blog.csdnimg.cn/direct/57808e2045174de2bdb3ea679f7e82c6.png" width="741"/>
    </p>
    <p>
     <strong>
      虚拟机栈
     </strong>
     ：每个线程在运行时都会创建一个虚拟机栈。栈中存储的是栈帧（Stack Frame），每个方法调用都会创建一个栈帧，并将其压入栈中。
    </p>
    <p>
     特点：
    </p>
    <ul>
     <li>
      每个线程都有自己独立的虚拟机栈。
     </li>
     <li>
      栈帧包含局部变量表、操作数栈、动态链接、方法出口等信息。
     </li>
     <li>
      生命周期与线程相同。
     </li>
    </ul>
    <p>
     <strong>
      本地方法栈：
     </strong>
     为执行本地native方法（如C/C++代码）提供支持。
    </p>
    <p>
     特点：
    </p>
    <ul>
     <li>
      类似于虚拟机栈，但专门用于本地方法调用。
     </li>
     <li>
      每个线程有自己的本地方法栈。
     </li>
    </ul>
    <p>
     <strong>
      程序计数器
     </strong>
     :记录当前线程所执行的字节码指令地址。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值为空（Undefined）。
    </p>
    <p>
     特点：
    </p>
    <ul>
     <li>
      每个线程都有自己的程序计数器。
     </li>
     <li>
      保证线程切换后能恢复到正确的执行位置
     </li>
    </ul>
    <p>
     <strong>
      堆：
     </strong>
     所有对象实例以及数组都要在堆上分配
    </p>
    <p>
     特点：
    </p>
    <ul>
     <li>
      垃圾回收的主要区域。
     </li>
     <li>
      可细分为年轻代（Young Generation）和老年代（Old Generation）。
     </li>
    </ul>
    <p>
     <strong>
      方法区：
     </strong>
     存储已被虚拟机加载的
     <span style="color:#fe2c24">
      类信息
     </span>
     、
     <span style="color:#fe2c24">
      常量
     </span>
     、
     <span style="color:#fe2c24">
      静态变量
     </span>
     、即时编译器编译后的代码缓存等数据。
    </p>
    <p>
     特点：
    </p>
    <ul>
     <li>
      在HotSpot虚拟机中，方法区的实现称为“永久代”（PermGen，在JDK 8之前）或“元空间”（Metaspace，在JDK 8及之后）。
     </li>
    </ul>
    <p>
     <strong>
      运⾏时常量池：
     </strong>
     运行时常量池是方法区的一部分。JDK 8之前位于永久代（堆内存）中，在JDK 8及之后位于元空间（本地内存）中。
    </p>
    <h2>
     二、垃圾回收算法
    </h2>
    <h3>
     1、垃圾回收的基本概念
    </h3>
    <p>
     （1）
     <strong>
      对象可达性分析：
     </strong>
     JVM通过一系列称为“根节点（Roots）”的对象开始，遍历所有引用链，找到所有可达的对象。所有不可达的对象被认为是垃圾，可以被回收。
    </p>
    <p>
     （2）
     <strong>
      根节点（Roots）：
     </strong>
    </p>
    <ul>
     <li>
      虚拟机栈中引⽤的对象（本地变量表）
     </li>
     <li>
      本地方法栈中引⽤的对象
     </li>
     <li>
      方法区中静态属性引⽤的对象
     </li>
     <li>
      方法区中常量引⽤的对象
     </li>
    </ul>
    <h3>
     2、主要的垃圾回收算法
    </h3>
    <p>
     <strong>
      （1）标记-清除算法：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       标记阶段
      </strong>
      ：从根节点开始遍历所有对象，并标记所有不可达的对象。
     </li>
     <li>
      <strong>
       清除阶段
      </strong>
      ：扫描整个堆，回收被标记的对象（即垃圾对象）。
     </li>
    </ul>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      容易产生内存碎片，导致后续分配大对象时可能失败。
     </li>
     <li>
      标记和清除过程需要遍历整个堆，效率较低。
     </li>
    </ul>
    <p>
     （2）
     <strong>
      标记-整理算法
     </strong>
    </p>
    <p>
     类似于标记-清除，但在清除阶段，会将存活的对象移动到堆的一端，然后清理剩余部分。
    </p>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      移动对象的过程较为复杂，耗时较长。
     </li>
    </ul>
    <p>
     （3）
     <strong>
      复制算法
     </strong>
    </p>
    <p>
     将堆分成两个区域，每次只使用一个区域，当一个区域满了，将存活的对象复制到另一个区域，并清理当前区域。
    </p>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      需要额外的空间来存储对象的副本。
     </li>
     <li>
      适用于年轻代（Young Generation），因为大多数对象生命周期较短。
     </li>
    </ul>
    <p>
     （4）
     <strong>
      分代回收算法
     </strong>
    </p>
    <p>
     基于大多数对象生命周期较短的观察，JVM将内存划分为新生代和老年代。分配的依据是对象的经历的GC次数。对象创建时，一般在新生代的
     <strong>
      Eden Space
     </strong>
     申请内存，当经历一次GC之后对象还存活，那么对象的年龄+1，当对象年龄超过一定值（默认值为 15），对象就会进入老年代，当然有足够大的对象，即使年龄未达到阈值，这些对象也可能被直接晋升到老年代，因为复制一个大对象耗时。
    </p>
    <h2>
     三、新生代和老年代的区别
    </h2>
    <p>
     对象特性：大多数新创建的对象会被分配到新生代，这些对象的生命周期通常较短，很多对象在创建后不久就不再使用，成为垃圾对象等待回收。而老年代存储的是经过多次垃圾回收仍然存活的对象。
    </p>
    <p class="img-center">
     <img alt="" height="231" src="https://i-blog.csdnimg.cn/direct/0c2d69753f3b4f43aaeb4b5f07f295ac.png" width="335"/>
    </p>
    <p>
     垃圾回收算法的区别：新生代主要使用
     <strong>
      复制算法
     </strong>
     进行垃圾回收。新生代内存被分为一个大的Eden区和两个小的Survivor区。新对象优先分配在Eden区，当Eden区满时，触发
     <strong>
      Minor GC
     </strong>
     （新生代垃圾回收），将Eden区和一个Survivor区中存活的对象复制到另一个Survivor区，然后清空Eden区和之前使用过Survivor区。经过多次Minor GC后仍存活的对象被晋升到老年代。老年代一般采用
     <strong>
      标记-清除算法
     </strong>
     或者
     <strong>
      标记-整理算法。
     </strong>
     老年代的垃圾回收成为
     <strong>
      Major GC
     </strong>
     或
     <strong>
      Full GC
     </strong>
     。
    </p>
    <h2>
     四、主要的垃圾回收机制
    </h2>
    <p>
     <strong>
      Serial收集器：
     </strong>
     新生代，单线程，简单高效，适合单核处理器和小内存环境
    </p>
    <p>
     <strong>
      ParNew收集器：
     </strong>
     新生代，并行执行，减少停顿时间，适合多核处理器
    </p>
    <p>
     <strong>
      Parallel Scavenge收集器：
     </strong>
     新生代，高吞吐量，减少垃圾回收时间，适合后台处理
    </p>
    <p>
     <strong>
      CMS收集器：
     </strong>
     老年代，并发执行，减少停顿时间，适合对响应时间要求高的应用
    </p>
    <p>
     <strong>
      G1收集器：
     </strong>
     新生代+老年代，分区管理，优先回收垃圾最多的区域，适合大堆内存和低延迟需求
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363233313739342f:61727469636c652f64657461696c732f313436313134363631" class_="artid" style="display:none">
 </p>
</div>


