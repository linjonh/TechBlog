---
layout: post
title: "openssl使用SM2进行数据加密和数据解密"
date: 2025-08-31T15:34:34+0800
description: "本文介绍了在Linux环境下使用OpenSSL实现SM2算法的完整流程。首先需要安装libssl-dev依赖并确认OpenSSL版本（1.1.1或3.0+）。C语言示例代码演示了如何生成SM2密钥对，使用公钥加密明文，再用私钥解密恢复明文，其中SM3作为默认哈希函数。编译时需链接crypto库，运行后会输出密钥生成成功、密文长度和解密结果。总结指出关键函数：EVP_PKEY_keygen()生成密钥对、SM2_encrypt()加密和SM2_decrypt()解密，推荐使用SM2+SM3+SM4的国密算法组"
keywords: "openssl sm2"
categories: ['Openssl']
tags: ['服务器', 'Openssl', 'Linux']
artid: "151047132"
arturl: "https://blog.csdn.net/m0_49476241/article/details/151047132"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151047132
    alt: "openssl使用SM2进行数据加密和数据解密"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151047132
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151047132
cover: https://bing.ee123.net/img/rand?artid=151047132
image: https://bing.ee123.net/img/rand?artid=151047132
img: https://bing.ee123.net/img/rand?artid=151047132
---



# openssl使用SM2进行数据加密和数据解密



---

### 一、准备工作

#### 1. 安装依赖

```bash
sudo apt-get update
sudo apt-get install libssl-dev

```

#### 2. 确认 OpenSSL 版本

```bash
openssl version

```

如果是 **1.1.1** 或 **3.0+**，就支持 **SM2/SM3/SM4**。

---

### 二、C 语言示例代码

这个程序会：

1. 生成 SM2 密钥对
2. 使用公钥加密一段明文
3. 使用私钥解密恢复明文

```c
#include <stdio.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/sm2.h>
#include <openssl/pem.h>

int main() {
    EVP_PKEY_CTX *pctx = NULL;
    EVP_PKEY *pkey = NULL;

    // ========== 1. 生成 SM2 密钥对 ==========
    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SM2, NULL);
    if (!pctx) {
        printf("EVP_PKEY_CTX_new_id failed\n");
        return -1;
    }

    if (EVP_PKEY_keygen_init(pctx) <= 0) {
        printf("EVP_PKEY_keygen_init failed\n");
        return -1;
    }

    if (EVP_PKEY_keygen(pctx, &pkey) <= 0) {
        printf("EVP_PKEY_keygen failed\n");
        return -1;
    }
    EVP_PKEY_CTX_free(pctx);

    printf("SM2 KeyPair generated successfully!\n");

    // ========== 2. 加密 ==========
    const char *plaintext = "Hello, SM2 Encryption!";
    size_t plaintext_len = strlen(plaintext);

    size_t ciphertext_len = 0;
    unsigned char *ciphertext = NULL;

    if (!SM2_encrypt(EVP_sm3(), (const unsigned char*)plaintext, plaintext_len,
                     NULL, &ciphertext_len, pkey)) {
        printf("SM2_encrypt (get length) failed\n");
        return -1;
    }

    ciphertext = OPENSSL_malloc(ciphertext_len);
    if (!ciphertext) {
        printf("malloc failed\n");
        return -1;
    }

    if (!SM2_encrypt(EVP_sm3(), (const unsigned char*)plaintext, plaintext_len,
                     ciphertext, &ciphertext_len, pkey)) {
        printf("SM2_encrypt failed\n");
        return -1;
    }

    printf("Ciphertext length = %zu\n", ciphertext_len);

    // ========== 3. 解密 ==========
    unsigned char *decrypted = OPENSSL_malloc(ciphertext_len);
    size_t decrypted_len = 0;

    if (!SM2_decrypt(EVP_sm3(), ciphertext, ciphertext_len,
                     decrypted, &decrypted_len, pkey)) {
        printf("SM2_decrypt failed\n");
        return -1;
    }

    decrypted[decrypted_len] = '\0'; // 末尾加字符串结束符
    printf("Decrypted text: %s\n", decrypted);

    // ========== 4. 释放资源 ==========
    OPENSSL_free(ciphertext);
    OPENSSL_free(decrypted);
    EVP_PKEY_free(pkey);

    return 0;
}

```

---

### 三、编译与运行

#### 1. 编译

```bash
gcc sm2_enc_dec.c -o sm2_enc_dec -lcrypto

```

#### 2. 运行

```bash
./sm2_enc_dec

```

#### 3. 可能的输出

```
SM2 KeyPair generated successfully!
Ciphertext length = 115
Decrypted text: Hello, SM2 Encryption!

```

---

### 四、总结

* `EVP_PKEY_keygen()` 生成 **SM2 密钥对**
* `SM2_encrypt()` 使用公钥加密
* `SM2_decrypt()` 使用私钥解密
* 这里默认使用 **SM3** 作为哈希函数（推荐国密组合：SM2+SM3+SM4）

---



