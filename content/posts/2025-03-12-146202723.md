---
layout: post
title: "leetcode面试经典150系列一"
date: 2025-03-12 20:23:26 +0800
description: "算法解析"
keywords: "leetcode【面试经典150系列】（一）"
categories: ['算法']
tags: ['算法', '数据结构']
artid: "146202723"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146202723
    alt: "leetcode面试经典150系列一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146202723
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146202723
cover: https://bing.ee123.net/img/rand?artid=146202723
image: https://bing.ee123.net/img/rand?artid=146202723
img: https://bing.ee123.net/img/rand?artid=146202723
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     leetcode【面试经典150系列】（一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr/>
    <h3 id="121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA" name="121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">
     121.买卖股票最佳时机
    </h3>
    <h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" name="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">
     <strong>
      题目描述
     </strong>
    </h4>
    <p>
     给定一个数组
     <strong>
      prices
     </strong>
     ，它的第
     <strong>
      i
     </strong>
     个元素
     <strong>
      prices[i]
     </strong>
     表示一支给定股票第
     <strong>
      i
     </strong>
     天的价格。
    </p>
    <p>
     你只能选择
     <strong>
      某一天
     </strong>
     买入这只股票，并选择在
     <strong>
      未来的某一个不同的日子
     </strong>
     卖出该股票。设计一个算法来计算你所能获取的最大利润。
    </p>
    <p>
     返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回
     <strong>
      0
     </strong>
     。
    </p>
    <h4 id="%E7%A4%BA%E4%BE%8B" name="%E7%A4%BA%E4%BE%8B">
     <strong>
      示例
     </strong>
    </h4>
    <blockquote>
     <p>
      <strong>
       输入：
      </strong>
      <span style="color:#7b7f82">
       [7,1,5,3,6,4]
      </span>
      <br/>
      <strong>
       输出：
      </strong>
      <span style="color:#7b7f82">
       5
      </span>
      <br/>
      <strong>
       解释：
      </strong>
      <span style="color:#7b7f82">
       在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
       <br/>
       注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
      </span>
     </p>
    </blockquote>
    <p id="">
     这个问题实际上是利用了“贪心算法”的思想。
    </p>
    <h4 id="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" name="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">
     <strong>
      算法分析
     </strong>
    </h4>
    <p id="">
     这个算法的目的是找出股票交易中的最大利润，即买入和卖出股票的最佳时机。算法的核心思想是：
    </p>
    <ol>
     <li>
      <strong>
       维护一个最小值（mn）
      </strong>
      ：这个变量用于记录遍历过的价格中的最小值。这相当于我们在寻找买入股票的最佳时机（即价格最低的时候）。
     </li>
     <li>
      <strong>
       计算利润（ans）
      </strong>
      ：对于每一个价格，我们计算如果在这个价格卖出股票，那么利润是多少（即当前价格减去之前记录的最小值）。然后，我们更新记录的最大利润（ans）。
     </li>
    </ol>
    <p>
     <strong>
      为什么说是贪心算法？
     </strong>
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        局部最优选择
       </strong>
       ：在每一步，我们都选择到目前为止看到的最小值作为可能的买入点，这是一个局部最优选择，因为我们假设在这一点上买入可以最大化后续可能的利润。
      </li>
      <li>
       <strong>
        无回溯
       </strong>
       ：一旦我们选择了某个点作为“可能的买入点”，我们就不会回头去改变这个选择（除非遇到一个更低的价格）。这符合贪心算法“一旦做出选择，不再更改”的特点。
      </li>
     </ul>
    </blockquote>
    <h4 id="%E4%BB%A3%E7%A0%81(python3)" name="%E4%BB%A3%E7%A0%81(python3)">
     代码(python3)
    </h4>
    <pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        # mn用来记录前n个最小的值
        mn = prices[0]
        # ans用来记录前n个最小的值与当前值的差值的最大值
        ans = 0
        for x in prices:
            mn = min(mn,x)
            ans = max(ans,x-mn)
        return ans</code></pre>
    <h3 id="122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII" name="122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII">
     122.买卖股票最佳时机II
    </h3>
    <h4 id="%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" name="%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">
     题目描述
    </h4>
    <p>
     给你一个整数数组
     <strong>
      prices
     </strong>
     ，其中
     <strong>
      prices[i]
     </strong>
     表示某支股票第
     <strong>
      i
     </strong>
     天的价格。
    </p>
    <p>
     在每一天，你可以决定是否购买和/或出售股票。你在任何时候
     <strong>
      最多
     </strong>
     只能持有
     <strong>
      一股
     </strong>
     股票。你也可以先购买，然后在
     <strong>
      同一天
     </strong>
     出售。
    </p>
    <p>
     返回 你能获得的
     <strong>
      最大
     </strong>
     利润
    </p>
    <h4 id="%E7%A4%BA%E4%BE%8B" name="%E7%A4%BA%E4%BE%8B">
     示例
    </h4>
    <blockquote>
     <p>
      <strong>
       输入
      </strong>
      ：prices = [7,1,5,3,6,4]
      <br/>
      <strong>
       输出
      </strong>
      ：7
      <br/>
      <strong>
       解释
      </strong>
      ：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
      <br/>
      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
      <br/>
      最大总利润为 4 + 3 = 7 。
     </p>
    </blockquote>
    <h4 id="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" name="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">
     算法分析
    </h4>
    <p>
     遍历数组，如果当天买入第二天会涨，就在第二天卖出。否则当天就不买入。这个方法，最终利润是最大的。
    </p>
    <h4 id="%E4%BB%A3%E7%A0%81%EF%BC%88python3%EF%BC%89" name="%E4%BB%A3%E7%A0%81%EF%BC%88python3%EF%BC%89">
     代码（python3）
    </h4>
    <pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        profit = 0
        for i in range(1, len(prices)):
            tmp = prices[i] - prices[i - 1]
            if tmp &gt; 0:
                profit += tmp
        return profit</code></pre>
    <h3 id="55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F" name="55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">
     55.跳跃游戏
    </h3>
    <h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" name="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">
     题目描述
    </h4>
    <p>
     给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
    </p>
    <p>
     判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
    </p>
    <h4 id="%E7%A4%BA%E4%BE%8B" name="%E7%A4%BA%E4%BE%8B">
     示例
    </h4>
    <blockquote>
     <p>
      <strong>
       输入
      </strong>
      ：nums = [2,3,1,1,4]
      <br/>
      <strong>
       输出
      </strong>
      ：true
      <br/>
      <strong>
       解释
      </strong>
      ：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
     </p>
    </blockquote>
    <h4 id="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" name="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">
     算法分析
    </h4>
    <p>
     遍历每一项,如果当前位置能到达并且大于前面所能到达的最大位置，就更新最大位置
    </p>
    <h4 id="%E4%BB%A3%E7%A0%81" name="%E4%BB%A3%E7%A0%81">
     代码
    </h4>
    <pre><code class="language-python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        # 遍历每一项
        max_i = 0
        for i,jump in enumerate(nums):
            # 如果当前位置能到达并且大于前面所能到达的最大位置，就更新最大位置
            if max_i&gt;=i and i+jump&gt;max_i:
                max_i = i+jump
        return max_i&gt;=len(nums)-1</code></pre>
    <h3 id="45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII" name="45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII">
     45.跳跃游戏II
    </h3>
    <h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" name="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">
     题目描述
    </h4>
    <p>
     给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
     <br/>
     每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
    </p>
    <p>
     • 0 &lt;= j &lt;= nums[i]
     <br/>
     • i + j &lt; n
     <br/>
     返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
    </p>
    <h4 id="%E7%A4%BA%E4%BE%8B" name="%E7%A4%BA%E4%BE%8B">
     示例
    </h4>
    <blockquote>
     <pre><strong>输入:</strong> nums = [2,3,1,1,4]
<strong>输出:</strong> 2
<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是2，从下标为 0 跳到下标为 1 的位置，跳 1步，然后跳3步到达数组的最后一个位置。
</pre>
    </blockquote>
    <h4 id="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" name="%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">
     算法分析
    </h4>
    <p>
     想象有一条河，0和m一1分别是河的两岸。一开始，你在0，要到n-1。
    </p>
    <p>
     把区间[i,i+nums[i]]视作一座桥。一开始只能建一座桥，也就是[0，nums[0]]。比如建造了一座从0到4的桥。
    </p>
    <p>
     下一座桥要选哪个呢？
    </p>
    <p>
     在可以选的桥中，选择右端点最大的桥。它会让你走的更远。
    </p>
    <p>
     重复该过程，到达n-1时退出循环。修建的桥的数量就是答案。
    </p>
    <h4 id="%E4%BB%A3%E7%A0%81" name="%E4%BB%A3%E7%A0%81">
     代码
    </h4>
    <pre><code class="language-python">class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        ans = 0
        cur_right = 0  # 已建造的桥的右端点
        next_right = 0  # 下一座桥的右端点的最大值
        for i in range(len(nums) - 1):
            # 遍历的过程中，记录下一座桥的最远点
            next_right = max(next_right, i + nums[i])
            if i == cur_right:  # 无路可走，必须建桥
                cur_right = next_right  # 建桥后，最远可以到达 next_right
                ans += 1
        return ans</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313738313835322f:61727469636c652f64657461696c732f313436323032373233" class_="artid" style="display:none">
 </p>
</div>


