---
layout: post
title: "Java网络原理3网络编程续"
date: 2025-03-09 17:13:31 +0800
description: "哈喽大家好，今天继续进行计算机网络的初阶学习，今天学习的是tcp回显服务器的实现，正文开始。"
keywords: "Java【网络原理】（3）网络编程续"
categories: ['未分类']
tags: ['运维', '网络', '服务器', 'Java']
artid: "146089636"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146089636
    alt: "Java网络原理3网络编程续"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146089636
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146089636
cover: https://bing.ee123.net/img/rand?artid=146089636
image: https://bing.ee123.net/img/rand?artid=146089636
img: https://bing.ee123.net/img/rand?artid=146089636
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java【网络原理】（3）网络编程续
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" height="284" src="https://i-blog.csdnimg.cn/direct/acc5dbd919d84868af6c674e28f2c2f0.jpeg" width="358"/>
    </p>
    <hr/>
    <hr id="hr-toc" name="tableOfContents"/>
    <h2>
     1.前言
    </h2>
    <p>
     哈喽大家好，今天继续进行计算机网络的初阶学习，今天学习的是tcp回显服务器的实现，正文开始
    </p>
    <h2 id="2.%E6%AD%A3%E6%96%87" name="2.%E6%AD%A3%E6%96%87">
     2.正文
    </h2>
    <p>
     在正式讲解Tcp回显服务器，还要介绍两个包，一个是ServerSocket包，这个包是专门给服务器用的，Socket包是服务器和客户端都会用，下文详解。
    </p>
    <h3 id="2.1ServerSocket%E7%B1%BB" name="2.1ServerSocket%E7%B1%BB" style="background-color:transparent">
     2.1ServerSocket类
    </h3>
    <p>
     Java中的
     <code>
      ServerSocket
     </code>
     类是用于在服务器端监听客户端连接请求的核心类，属于
     <code>
      java.net
     </code>
     包。它允许服务器应用程序在指定端口上等待客户端的连接，并为每个连接创建一个
     <code>
      Socket
     </code>
     对象进行通信。
    </p>
    <hr/>
    <blockquote>
     <p>
     </p>
     <p>
      <strong>
       核心作用
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         监听端口
        </strong>
        ：绑定到特定端口，等待客户端连接。
       </p>
      </li>
      <li>
       <p>
        <strong>
         接受连接
        </strong>
        ：通过
        <code>
         accept()
        </code>
        方法阻塞等待客户端连接，返回代表客户端的
        <code>
         Socket
        </code>
        对象。
       </p>
      </li>
      <li>
       <p>
        <strong>
         管理连接队列
        </strong>
        ：通过
        <code>
         backlog
        </code>
        参数设置等待连接队列的最大长度。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       关键方法
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         构造方法
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           ServerSocket(int port)
          </code>
          ：绑定到指定端口。
         </p>
        </li>
        <li>
         <p>
          <code>
           ServerSocket(int port, int backlog)
          </code>
          ：指定端口和连接队列长度。
         </p>
        </li>
        <li>
         <p>
          <code>
           ServerSocket(int port, int backlog, InetAddress bindAddr)
          </code>
          ：绑定到特定IP地址的端口。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         核心方法
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           Socket accept()
          </code>
          ：阻塞等待客户端连接，返回连接的
          <code>
           Socket
          </code>
          对象。
         </p>
        </li>
        <li>
         <p>
          <code>
           void bind(SocketAddress endpoint)
          </code>
          ：绑定到指定地址和端口。
         </p>
        </li>
        <li>
         <p>
          <code>
           void close()
          </code>
          ：关闭服务器套接字。
         </p>
        </li>
        <li>
         <p>
          <code>
           int getLocalPort()
          </code>
          ：获取监听的端口号。
         </p>
        </li>
        <li>
         <p>
          <code>
           void setSoTimeout(int timeout)
          </code>
          ：设置
          <code>
           accept()
          </code>
          的超时时间（毫秒）。
         </p>
        </li>
       </ul>
      </li>
     </ol>
     <p>
      <strong>
       使用流程
      </strong>
     </p>
     <ol>
      <li>
       <p>
        创建
        <code>
         ServerSocket
        </code>
        并绑定端口。
       </p>
      </li>
      <li>
       <p>
        循环调用
        <code>
         accept()
        </code>
        接受客户端连接。
       </p>
      </li>
      <li>
       <p>
        为每个连接的
        <code>
         Socket
        </code>
        启动新线程处理请求。
       </p>
      </li>
      <li>
       <p>
        处理完成后关闭资源。
       </p>
      </li>
     </ol>
    </blockquote>
    <h3 id="2.2Socket%E7%B1%BB" name="2.2Socket%E7%B1%BB">
     2.2Socket类
    </h3>
    <p>
     Java中的
     <code>
      Socket
     </code>
     类是用于实现网络通信的核心类，属于
     <code>
      java.net
     </code>
     包。它代表客户端与服务器之间的一个连接，允许通过输入流和输出流进行双向数据传输。
     <code>
      Socket
     </code>
     类通常与
     <code>
      ServerSocket
     </code>
     类配合使用，实现客户端-服务器模型的通信。
    </p>
    <hr/>
    <blockquote>
     <p>
     </p>
     <p>
      <strong>
       核心作用
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         建立连接
        </strong>
        ：连接到服务器端的指定IP地址和端口。
       </p>
      </li>
      <li>
       <p>
        <strong>
         数据传输
        </strong>
        ：通过输入流（
        <code>
         InputStream
        </code>
        ）和输出流（
        <code>
         OutputStream
        </code>
        ）进行数据交换。
       </p>
      </li>
      <li>
       <p>
        <strong>
         关闭连接
        </strong>
        ：释放资源并终止通信。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       关键方法
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         构造方法
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           Socket(String host, int port)
          </code>
          ：连接到指定主机和端口。
         </p>
        </li>
        <li>
         <p>
          <code>
           Socket(InetAddress address, int port)
          </code>
          ：使用
          <code>
           InetAddress
          </code>
          对象连接到指定主机和端口。
         </p>
        </li>
        <li>
         <p>
          <code>
           Socket(String host, int port, InetAddress localAddr, int localPort)
          </code>
          ：绑定到本地地址和端口，同时连接到远程主机。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         核心方法
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           InputStream getInputStream()
          </code>
          ：获取输入流，用于读取服务器发送的数据。
         </p>
        </li>
        <li>
         <p>
          <code>
           OutputStream getOutputStream()
          </code>
          ：获取输出流，用于向服务器发送数据。
         </p>
        </li>
        <li>
         <p>
          <code>
           void close()
          </code>
          ：关闭套接字，释放资源。
         </p>
        </li>
        <li>
         <p>
          <code>
           void shutdownInput()
          </code>
          ：关闭输入流。
         </p>
        </li>
        <li>
         <p>
          <code>
           void shutdownOutput()
          </code>
          ：关闭输出流。
         </p>
        </li>
        <li>
         <p>
          <code>
           boolean isConnected()
          </code>
          ：检查是否已连接。
         </p>
        </li>
        <li>
         <p>
          <code>
           boolean isClosed()
          </code>
          ：检查是否已关闭。
         </p>
        </li>
       </ul>
      </li>
     </ol>
     <p>
      <strong>
       使用流程
      </strong>
     </p>
     <ol>
      <li>
       <p>
        创建
        <code>
         Socket
        </code>
        对象并连接到服务器。
       </p>
      </li>
      <li>
       <p>
        获取输入流和输出流进行数据交换。
       </p>
      </li>
      <li>
       <p>
        处理数据并完成通信。
       </p>
      </li>
      <li>
       <p>
        关闭
        <code>
         Socket
        </code>
        和相关资源。
       </p>
      </li>
     </ol>
    </blockquote>
    <h3 id="2.3Tcp%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8" name="2.3Tcp%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8">
     2.3Tcp回显服务器
    </h3>
    <h4 id="2.3.1TcpEchoServer" name="2.3.1TcpEchoServer" style="background-color:transparent">
     2.3.1TcpEchoServer
    </h4>
    <pre><code class="language-java">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * TCP回显服务器实现类
 * 功能：接收客户端消息并原样返回（回显）
 */
public class TcpEchoServer {
    private ServerSocket serverSocket = null;  // 服务器套接字对象

    // 构造方法：初始化服务器并绑定端口
    public TcpEchoServer(int port) throws IOException {
        serverSocket = new ServerSocket(port);  // 创建ServerSocket并绑定指定端口
    }

    /**
     * 启动服务器核心逻辑
     */
    public void start() throws IOException {
        System.out.println("启动服务器");
        
        // 创建线程池（动态调整线程数量，适合短任务）
        ExecutorService executorService = Executors.newCachedThreadPool();

        // 持续监听客户端连接
        while (true) {
            // 阻塞等待客户端连接
            Socket clientSocket = serverSocket.accept();
            
            // 将客户端连接提交给线程池处理
            executorService.submit(() -&gt; {
                try {
                    processConnection(clientSocket);  // 处理单个客户端连接
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }

    /**
     * 处理单个客户端连接的完整生命周期
     * @param clientSocket 客户端套接字对象
     */
    private void processConnection(Socket clientSocket) throws IOException {
        // 打印客户端连接信息
        System.out.printf("[%s:%d] 客户端上线!\n", 
                         clientSocket.getInetAddress(), 
                         clientSocket.getPort());
        
        // 使用try-with-resources自动关闭流
        try (InputStream inputStream = clientSocket.getInputStream();
             OutputStream outputStream = clientSocket.getOutputStream()) {
            
            // 使用Scanner和PrintWriter包装流对象
            Scanner scanner = new Scanner(inputStream);    // 输入流扫描器
            PrintWriter printWriter = new PrintWriter(outputStream);  // 输出流写入器

            // 持续处理客户端请求
            while (true) {
                // 1. 检测连接状态（若输入流中没有数据，说明客户端断开）
                if (!scanner.hasNext()) {
                    System.out.printf("[%s:%d] 客户端下线!\n", 
                                    clientSocket.getInetAddress(), 
                                    clientSocket.getPort());
                    break;
                }
                
                // 2. 读取请求并处理
                String request = scanner.next();    // 读取客户端请求（空格分隔）
                String response = process(request); // 处理请求生成响应

                // 3. 返回响应给客户端
                printWriter.println(response);  // 写入响应
                printWriter.flush();            // 强制刷新缓冲区
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                clientSocket.close();  // 确保关闭客户端套接字
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * 处理请求的核心逻辑（示例为简单回显）
     * @param request 客户端请求内容
     * @return 返回与请求相同的字符串
     */
    private String process(String request) {
        // 此处可添加业务逻辑（示例直接返回原内容）
        return request;
    }

    /**
     * 主方法：启动服务器实例
     */
    public static void main(String[] args) throws IOException {
        TcpEchoServer tcpEchoServer = new TcpEchoServer(9090);  // 创建服务器实例（端口9090）
        tcpEchoServer.start();  // 启动服务器
    }
}</code></pre>
    <blockquote>
     <p>
      核心思路讲解：
     </p>
     <hr/>
     <p>
      <strong>
       整体架构设计：
      </strong>
     </p>
     <p>
      该代码实现了一个
      <strong>
       多线程TCP回显服务器
      </strong>
      ，核心功能是接收客户端发送的文本消息，并将消息原样返回（回显）。其架构设计遵循经典
      <strong>
       客户端-服务器模型
      </strong>
      ，核心特点包括：
     </p>
     <ul>
      <li>
       <p>
        <strong>
         多线程处理
        </strong>
        ：通过线程池动态分配线程，避免单线程阻塞导致的性能瓶颈。
       </p>
      </li>
      <li>
       <p>
        <strong>
         资源自动管理
        </strong>
        ：利用
        <code>
         try-with-resources
        </code>
        确保流和套接字的自动释放。
       </p>
      </li>
      <li>
       <p>
        <strong>
         松耦合设计
        </strong>
        ：将连接处理（
        <code>
         processConnection
        </code>
        ）与业务逻辑（
        <code>
         process
        </code>
        ）分离，便于扩展。
       </p>
      </li>
     </ul>
     <hr/>
     <p>
      <strong>
       核心组件解析：
      </strong>
     </p>
     <p>
      <strong>
       (1) ServerSocket 的职责
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         端口监听
        </strong>
        ：绑定到指定端口（如9090），通过
        <code>
         accept()
        </code>
        阻塞等待客户端连接。
       </p>
      </li>
      <li>
       <p>
        <strong>
         连接队列管理
        </strong>
        ：默认使用操作系统提供的连接队列（通过
        <code>
         backlog
        </code>
        参数可调整队列长度）。
       </p>
      </li>
      <li>
       <p>
        <strong>
         生命周期控制
        </strong>
        ：服务器运行时持续监听，直到进程终止（代码中未实现优雅关闭逻辑）。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       (2) Socket 连接处理
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         双向通信
        </strong>
        ：每个客户端连接对应一个
        <code>
         Socket
        </code>
        对象，通过其输入流（
        <code>
         InputStream
        </code>
        ）和输出流（
        <code>
         OutputStream
        </code>
        ）实现数据交换。
       </p>
      </li>
      <li>
       <p>
        <strong>
         连接状态检测
        </strong>
        ：通过
        <code>
         scanner.hasNext()
        </code>
        判断客户端是否断开（输入流关闭时返回
        <code>
         false
        </code>
        ）。
       </p>
      </li>
     </ul>
     <p>
      <strong>
       (3) 线程池的作用
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         动态资源分配
        </strong>
        ：
        <code>
         Executors.newCachedThreadPool()
        </code>
        创建的线程池会根据任务量自动扩展/收缩：
       </p>
       <ul>
        <li>
         <p>
          空闲线程默认存活60秒后被回收。
         </p>
        </li>
        <li>
         <p>
          适合
          <strong>
           短生命周期任务
          </strong>
          （如HTTP请求）。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         避免线程爆炸
        </strong>
        ：相比为每个连接直接创建
        <code>
         new Thread()
        </code>
        ，线程池能有效控制系统资源占用。
       </p>
      </li>
     </ul>
     <hr/>
     <p>
      <strong>
       3. 关键流程详解：
      </strong>
     </p>
     <p>
      <strong>
       (1) 启动阶段
      </strong>
     </p>
     <ol>
      <li>
       <p>
        初始化
        <code>
         ServerSocket
        </code>
        并绑定端口。
       </p>
      </li>
      <li>
       <p>
        创建线程池，进入无限循环等待连接。
       </p>
      </li>
     </ol>
     <p>
      <strong>
       (2) 连接处理阶段
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         接受连接
        </strong>
        ：
        <code>
         accept()
        </code>
        返回客户端
        <code>
         Socket
        </code>
        对象。
       </p>
      </li>
      <li>
       <p>
        <strong>
         提交任务
        </strong>
        ：将
        <code>
         processConnection
        </code>
        方法包装为任务提交到线程池。
       </p>
      </li>
      <li>
       <p>
        <strong>
         处理请求
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          通过
          <code>
           Scanner
          </code>
          逐词读取客户端请求（空格分隔）。
         </p>
        </li>
        <li>
         <p>
          调用
          <code>
           process()
          </code>
          生成响应（此处简单回显）。
         </p>
        </li>
        <li>
         <p>
          通过
          <code>
           PrintWriter
          </code>
          写回响应并强制刷新缓冲区。
         </p>
        </li>
       </ul>
      </li>
     </ol>
     <p>
      <strong>
       (3) 连接终止
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         客户端主动断开
        </strong>
        ：
        <code>
         scanner.hasNext()
        </code>
        检测到输入流结束，跳出循环关闭连接。
       </p>
      </li>
      <li>
       <p>
        <strong>
         异常处理
        </strong>
        ：捕获
        <code>
         IOException
        </code>
        并关闭套接字，防止资源泄漏。
       </p>
      </li>
     </ol>
    </blockquote>
    <h4 id="2.3.2TcpEchoClient" name="2.3.2TcpEchoClient">
     2.3.2TcpEchoClient
    </h4>
    <pre><code class="language-java">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class TcpEchoClient {
    // 定义一个Socket对象，用于与服务器建立连接
    private Socket socket = null;

    // 构造函数，用于初始化客户端并连接到指定的服务器IP和端口
    private TcpEchoClient(String serverIp, int serverPort) throws IOException {
        // 创建一个Socket对象，连接到指定的服务器IP和端口
        socket = new Socket(serverIp, serverPort);
    }

    // 启动客户端，开始与服务器进行通信
    public void start() {
        // 创建一个Scanner对象，用于从控制台读取用户输入
        Scanner scanner = new Scanner(System.in);
        try (
            // 获取Socket的输入流，用于接收服务器发送的数据
            InputStream inputStream = socket.getInputStream();
            // 获取Socket的输出流，用于向服务器发送数据
            OutputStream outputStream = socket.getOutputStream()
        ) {
            // 创建一个Scanner对象，用于从输入流中读取服务器发送的数据
            Scanner scannerNet = new Scanner(inputStream);
            // 创建一个PrintWriter对象，用于向输出流中写入数据
            PrintWriter writer = new PrintWriter(outputStream);

            // 进入一个无限循环，持续与服务器进行通信
            while (true) {
                // 从控制台读取用户输入的数据
                String request = scanner.next();
                // 将用户输入的数据发送到服务器
                writer.println(request);
                // 刷新输出流，确保数据被发送
                writer.flush();
                // 从服务器读取响应数据
                String response = scannerNet.next();
                // 将服务器返回的响应数据打印到控制台
                System.out.println(response);
            }
        } catch (IOException e) {
            // 如果发生IO异常，抛出运行时异常
            throw new RuntimeException(e);
        }
    }

    // 主函数，程序的入口
    public static void main(String[] args) throws IOException {
        // 创建一个TcpEchoClient对象，连接到本地服务器的9090端口
        TcpEchoClient client = new TcpEchoClient("127.0.0.1", 9090);
        // 启动客户端，开始与服务器通信
        client.start();
    }
}</code></pre>
    <blockquote>
     <p>
      <strong>
       核心思路讲解：
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         Socket连接
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          在
          <code>
           TcpEchoClient
          </code>
          的构造函数中，通过
          <code>
           new Socket(serverIp, serverPort)
          </code>
          创建一个Socket对象，连接到指定的服务器IP和端口。这个Socket对象将用于后续的通信。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         输入输出流
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          在
          <code>
           start
          </code>
          方法中，通过
          <code>
           socket.getInputStream()
          </code>
          和
          <code>
           socket.getOutputStream()
          </code>
          分别获取Socket的输入流和输出流。输入流用于接收服务器发送的数据，输出流用于向服务器发送数据。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         用户输入与服务器通信
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          使用
          <code>
           Scanner
          </code>
          从控制台读取用户输入的数据，并通过
          <code>
           PrintWriter
          </code>
          将数据发送到服务器。
         </p>
        </li>
        <li>
         <p>
          使用
          <code>
           Scanner
          </code>
          从输入流中读取服务器返回的响应数据，并将其打印到控制台。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         循环通信
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          通过一个无限循环
          <code>
           while (true)
          </code>
          ，客户端可以持续与服务器进行通信。每次循环中，客户端都会读取用户输入，发送到服务器，并等待服务器的响应。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         异常处理
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          如果在通信过程中发生IO异常，代码会捕获该异常并抛出运行时异常。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         主函数
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          在
          <code>
           main
          </code>
          函数中，创建一个
          <code>
           TcpEchoClient
          </code>
          对象，并连接到本地服务器的9090端口。然后调用
          <code>
           start
          </code>
          方法，启动客户端与服务器的通信。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h2 id="3.%E5%B0%8F%E7%BB%93" name="3.%E5%B0%8F%E7%BB%93">
     3.小结
    </h2>
    <p>
     今天的分享到这里就结束了，喜欢的小伙伴不要忘记点点赞点个关注，你的鼓励就是对我最大的支持，加油！
    </p>
    <p>
    </p>
   </div>
  </div>
  <div class="blog-vote-box" id="blogVoteBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313037333331372f:61727469636c652f64657461696c732f313436303839363336" class_="artid" style="display:none">
 </p>
</div>


