---
layout: post
title: "SpringMVC六异常全局捕获与错误响应"
date: 2025-03-16 11:34:48 +0800
description: "声明式异常处理是通过 配置或注解 将异常处理逻辑与业务代码解耦，通常由框架统一管理。例如，在 Spring 中通过 @ControllerAdvice 和 @ExceptionHandler 实现全局异常处理。"
keywords: "SpringMVC（六）异常：全局捕获与错误响应"
categories: ['Ssm']
tags: ['数据库', 'Spring', 'Java']
artid: "146278271"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146278271
    alt: "SpringMVC六异常全局捕获与错误响应"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146278271
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146278271
cover: https://bing.ee123.net/img/rand?artid=146278271
image: https://bing.ee123.net/img/rand?artid=146278271
img: https://bing.ee123.net/img/rand?artid=146278271
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringMVC（六）异常：全局捕获与错误响应
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" name="%E4%B8%80%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">
     一编程式异常处理
    </h2>
    <p>
     编程式异常处理是通过在代码中
     <strong>
      显式编写异常捕获逻辑
     </strong>
     （如
     <code>
      try-catch
     </code>
     块）来管理异常的方式。开发者需要手动处理每一个可能抛出异常的代码段。
    </p>
    <p>
     代码实现：
    </p>
    <p>
     <img alt="" height="80" src="https://i-blog.csdnimg.cn/direct/6b780530461d4d7889d8be70635f3117.png" width="377"/>
    </p>
    <pre><code class="language-java">package org.example.springmvc.controller;

import org.example.springmvc.common.R;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class helloController {

    @GetMapping(value = "/hello")
    public R hello() {

        // 编程式的异常处理
        try {
            int i = 1 / 0;
            return R.ok(i);
        } catch (Exception e) {
            return R.error(100, "执行异常");
        }

    }
}
</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" height="1477" src="https://i-blog.csdnimg.cn/direct/5a69866fd4324e28aecfb33383bdd16c.png" width="2067"/>
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" name="%E4%BA%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">
     二声明式异常处理
    </h2>
    <p>
     声明式异常处理是通过
     <strong>
      配置或注解
     </strong>
     将异常处理逻辑与业务代码解耦，通常由框架统一管理。例如，在 Spring 中通过
     <code>
      @ControllerAdvice
     </code>
     和
     <code>
      @ExceptionHandler
     </code>
     实现全局异常处理。
    </p>
    <p>
     代码实现：
    </p>
    <pre><code class="language-java">package org.example.springmvc.controller;

import org.example.springmvc.common.R;
import org.springframework.web.bind.annotation.*;

@RestController
public class HelloController {
    @GetMapping(value = "/hello")
    public R hello(@RequestParam(value = "i", defaultValue = "0") Integer i) {
        int j = 1 / i;
        return R.ok(j);
    }

    /**
     * 如果Controller本类出现异常，会自动在本类中寻找有没有@ExceptionHandler注解的方法，如果有，则执行
     * 可以根据需求添加多个@ExceptionHandler注解的方法
     * .@ExceptionHandler注解接收多个参数，表示可以拦截多个异常类型
     *
     */
    @ExceptionHandler(ArithmeticException.class)
    public R handleArithmeticException(ArithmeticException e) {
        return R.error(100, "是执行异常" + e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public R handleException(Exception e) {
        return R.error(200, "异常" + e.getMessage());
    }

}
</code></pre>
    <p>
     <strong>
      改进：
     </strong>
    </p>
    <p>
     <strong>
      单一的@ExceptionHandler注解只会处理当前类 @ExceptionHandler+@ControllerAdvice注解可以完成全局统一处理
     </strong>
    </p>
    <p>
     <strong>
      处理优先级：本类大于外类，精确大于全局
     </strong>
    </p>
    <p>
     <strong>
      SpringBoot底层对SpringMVC有兜底处理机制（没有写这个异常处理逻辑）
     </strong>
    </p>
    <pre><code class="language-java">package org.example.springmvc.advice;

import org.example.springmvc.common.R;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

//@ResponseBody
//@ControllerAdvice
@RestControllerAdvice//合成注解
public class GlobalExceptionHandler {

    @ExceptionHandler(ArithmeticException.class)
    public R handleArithmeticException(ArithmeticException e) {
        return R.error(100, "是执行异常" + e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public R handleException(Exception e) {
        return R.error(200, "异常" + e.getMessage());
    }

}
</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" height="862" src="https://i-blog.csdnimg.cn/direct/ae791164a1f24fe59b20006fabe7f9b6.png" width="1381"/>
    </p>
    <p>
     <img alt="" height="1501" src="https://i-blog.csdnimg.cn/direct/200123f64a984cf484112c0e7fd9ff41.png" width="2051"/>
    </p>
    <h2 id="%E4%B8%89%20%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89" name="%E4%B8%89%20%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89">
     三 实际场景（拓展）
    </h2>
    <p>
     <em>
      问题场景：
     </em>
    </p>
    <pre><strong>Controller层业务逻辑感知异常，被全局异常处理器捕获，然后调用异常对象的构造方法，使用业务枚举类将异常码和异常原因传递给异常对象，最终被全局处理器解决</strong>
</pre>
    <p>
     <em>
      业务抛出：
     </em>
    </p>
    <pre><code class="language-java">throw new BizException(BizExceptionEnum.ORDER_NOT_EXIST);</code></pre>
    <h4 id="1%20BizExceptionEnum%E5%B0%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84code%E4%B8%8Emsg%E6%9E%9A%E4%B8%BE%E5%B0%81%E8%A3%85" name="1%20BizExceptionEnum%E5%B0%86%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84code%E4%B8%8Emsg%E6%9E%9A%E4%B8%BE%E5%B0%81%E8%A3%85">
     1 业务枚举类BizExceptionEnum 将所有可能出现的code与msg枚举封装
    </h4>
    <pre><code class="language-java">package org.example.springmvc.exception;

public enum BizExceptionEnum {
    //ORDER订单模块
    ORDER_NOT_EXIST(10001, "订单不存在"),
    ORDER_STATUS_ERROR(10002, "订单状态错误"),
    ORDER_PAID(10003, "订单已支付"),
    ORDER_CANCEL_FAIL(10004, "订单取消失败"),
    ORDER_PAY_FAIL(10005, "订单支付失败"),
    //PRODUCT商品模块
    PRODUCT_STOCK_NOT_ENOUGH(20001, "商品库存不足"),
    PRODUCT_OFF_SALE_OR_DELETE(20002, "商品下架或删除"),
    PRODUCT_NOT_EXIST(20003, "商品不存在"),
    PRODUCT_STOCK_ERROR(20004, "商品库存有误"),
    //USER用户模块
    USER_NOT_EXIST(30001, "用户不存在"),
    USER_PASSWORD_ERROR(30002, "密码错误"),
    USER_ACCOUNT_ERROR(30003, "账号错误"),
    USER_ACCOUNT_LOCK(30004, "账号已被锁定"),
    USER_LOGIN_FAIL(30005, "用户名或密码错误"),
    USER_ACCOUNT_FORBIDDEN(30006, "账号已被禁用"),
    //OTHER其他模块
    OTHER_ERROR(40001, "其他错误"),
    ;

    private final int code;
    private final String msg;

    BizExceptionEnum(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

}
</code></pre>
    <h4 id="2%20BizException%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BD%93%E4%B8%AD%E6%8E%A5%E6%94%B6BizExceptionEnum%E5%B0%81%E8%A3%85%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E3%80%82" name="2%20BizException%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BD%93%E4%B8%AD%E6%8E%A5%E6%94%B6BizExceptionEnum%E5%B0%81%E8%A3%85%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E3%80%82">
     2 业务异常类（BizException）在这个方法当中接收BizExceptionEnum封装的信息，使用构造方法接收。
    </h4>
    <pre><code class="language-java">package org.example.springmvc.exception;

public class BizException extends RuntimeException{

    //业务异常码，业务异常原因
    private final Integer code;
    private final String msg;

    public BizException(Integer code, String msg) {
        super(msg);
        this.code = code;
        this.msg = msg;
    }

    //Controller感知异常，被全局异常处理器捕获，然后调用异常对象的构造方法，将异常码和异常原因传递给异常对象，
    //通过这个构造方法，可以将BizExceptionEnum枚举对象 传给 BizException，然后抛出异常
    public BizException(BizExceptionEnum bizExceptionEnum) {
        super(bizExceptionEnum.getMsg());
        this.code = bizExceptionEnum.getCode();
        this.msg = bizExceptionEnum.getMsg();
    }


    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
</code></pre>
    <h4 id="3%20%E6%9C%80%E7%BB%88%E5%9C%A8controller%E5%B1%82%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%97%B6%E5%80%99controller%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82" name="3%20%E6%9C%80%E7%BB%88%E5%9C%A8controller%E5%B1%82%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%97%B6%E5%80%99controller%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82">
     3 全局异常处理器GlobalExceptionHandle：最终在controller层处理业务逻辑的时候controller调用的是全局异常处理器的方法。
    </h4>
    <pre><code class="language-java">package org.example.springmvc.advice;

import org.example.springmvc.common.R;
import org.example.springmvc.exception.BizException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

//@ResponseBody
//@ControllerAdvice
@RestControllerAdvice//合成注解
public class GlobalExceptionHandler {

    @ExceptionHandler(ArithmeticException.class)
    public R handleArithmeticException(ArithmeticException e) {
        return R.error(100, "是执行异常" + e.getMessage());
    }

    @ExceptionHandler(BizException.class)//这里传递的e已经提前封装好了
    public R HandleBizException(BizException e) {
        return R.error(e.getCode(), e.getMsg());
    }

    @ExceptionHandler(Throwable.class)
    public R handleThrowable(Throwable e) {
        return R.error(500, "异常" + e.getMessage());
    }

}
</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37393834373833312f:61727469636c652f64657461696c732f313436323738323731" class_="artid" style="display:none">
 </p>
</div>


