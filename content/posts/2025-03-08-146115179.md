---
layout: post
title: "MYOJ_4204迷宫图论-网格图基础,dfs,bfs在网格图中应用"
date: 2025-03-08 14:26:44 +0800
description: "(P.S.以后的网格图若没有特殊说明都是要用到这个的，以后就不说了~~~)STEP 2:dfs，先把。"
keywords: "MYOJ_4204:迷宫(图论-网格图基础，dfs,bfs在网格图中应用)"
categories: ['图论', 'Dfs', 'Bfs']
tags: ['深度优先', '数据结构', '广度优先', '图论', 'C']
artid: "146115179"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146115179
    alt: "MYOJ_4204迷宫图论-网格图基础,dfs,bfs在网格图中应用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146115179
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146115179
cover: https://bing.ee123.net/img/rand?artid=146115179
image: https://bing.ee123.net/img/rand?artid=146115179
img: https://bing.ee123.net/img/rand?artid=146115179
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MYOJ_4204:迷宫(图论-网格图基础，dfs,bfs在网格图中应用)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <h5>
      题目描述
     </h5>
    </blockquote>
    <p>
     一天 Extense 在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由 n×n 的格点组成，每个格点只有 2 种状态，. 和 #，前者表示可以通行后者表示不能通行。
     <br/>
     同时当 Extense 处在某个格点时，他只能移动到东南西北（或者说上下左右）四个方向之一的相邻格点上。
     <br/>
     Extense 想要从点 A 走到点 B，问在不走出迷宫的情况下能不能办到。如果起点或者终点有一个不能通行（为 #），则看成无法办到。
    </p>
    <blockquote>
     <h5>
      输入
     </h5>
    </blockquote>
    <p>
    </p>
    <p>
     第 1 行是测试数据的组数 k，后面跟着 k 组输入。
     <br/>
     每组测试数据的第 1 行是一个正整数 n (1≤n≤100)，表示迷宫的规模是 n×n 的。
     <br/>
     接下来是一个 n×n 的矩阵，矩阵中的元素为 . 或者 # 。
     <br/>
     再接下来一行是 4 个整数 ha, la, hb, lb，描述 A 处在第 ha 行，第 la 列，B 处在第 hb 行，第 lb 列。注意到 ha, la, hb, lb 全部是从 0 开始计数的。
    </p>
    <blockquote>
     <h5>
      输出
     </h5>
    </blockquote>
    <p>
    </p>
    <p>
     k 行，每行输出对应一个输入。
     <br/>
     能办到则输出 YES，否则输出 NO。
    </p>
    <blockquote>
     <h5>
      输入输出样例
     </h5>
    </blockquote>
    <p>
     输入：
    </p>
    <p>
     2
     <br/>
     3
     <br/>
     .##
     <br/>
     ..#
     <br/>
     #..
     <br/>
     0 0 2 2
     <br/>
     5
     <br/>
     .....
     <br/>
     ###.#
     <br/>
     ..#..
     <br/>
     ###..
     <br/>
     ...#.
     <br/>
     0 0 4 0
     <br/>
     输出：
    </p>
    <p>
     YES
     <br/>
     NO
     <br/>
    </p>
    <blockquote>
     <h5>
      思路：
     </h5>
    </blockquote>
    <p>
     有概念还是很容易炫的(我指的是dfs)，但是bfs就不是那么好写
    </p>
    <p>
     先讲简单的~~~
    </p>
    <blockquote>
     <h6>
      方法1：dfs
     </h6>
    </blockquote>
    <p>
     <strong>
      STEP 1:定义方向数组，顺序无所谓，99%的网格图都会用到这个；m用于存储网格图上每个字符；vis记录是否被访问。
      <span style="color:#fe2c24">
       (P.S.以后的网格图若没有特殊说明都是要用到这个的，以后就不说了~~~)
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:null">
       STEP 2:dfs，先把
      </span>
      传进来的地址标记为访问过，然后遍历方向数组的四个方向，计算下一个格子坐标，如果满足下一个格子是否在网格范围内、未被访问过且可以通过，就递归继续以此点搜索。
     </strong>
    </p>
    <p>
     <strong>
      STEP 3:输入测试样例数，读取网格大小及内容。
     </strong>
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       <span style="background-color:#fe2c24">
        STEP 4:由于dfs需要，输入起点和终点的坐标后，需要将坐标全部加1，否则over
       </span>
      </strong>
     </span>
    </p>
    <p>
     <strong>
      <span style="color:null">
       <span style="background-color:null">
        STEP 5:从起点开始DFS，完成后根据重点是否被访问，输出YES或NO
       </span>
      </span>
     </strong>
    </p>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int k,n,xa,ya,xb,yb,dir[4][2]={<!-- -->{0,-1},{0,1},{1,0},{-1,0}};
char m[101][101];
bool vis[101][101];
void dfs(int sx,int sy)
{
    vis[sx][sy]=true;
    for(int i=0;i&lt;4;i++)
    {
        int x=sx+dir[i][0],y=sy+dir[i][1];
        if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n&amp;&amp;!vis[x][y]&amp;&amp;m[x][y]=='.')
        {
            dfs(x,y);
        }
    }
}
int main() 
{
    scanf("%d",&amp;k);
    while(k--)
    {
        scanf("%d",&amp;n);
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=n;j++)
            {
                cin&gt;&gt;m[i][j];
            }
        }
        scanf("%d%d%d%d",&amp;xa,&amp;ya,&amp;xb,&amp;yb);
        xa++,xb++,ya++,yb++;
        memset(vis,0,sizeof(vis));
        dfs(xa,ya);
        cout&lt;&lt;(vis[xb][yb]==true?"YES\n":"NO\n");
    } 
}</code></pre>
    <p>
     <img alt="" height="72" src="https://i-blog.csdnimg.cn/direct/236ddeb698a94818967366f5d86f905d.png" width="2099">
     </img>
    </p>
    <blockquote>
     <h6>
      方法2：bfs
     </h6>
    </blockquote>
    <p>
     这个难一点，不过高手在民间，在座各位应该都能炫吧~
    </p>
    <p>
     <strong>
      STEP 1:定义node结构体在bfs使用
     </strong>
    </p>
    <p>
     <strong>
      STEP 2:bfs,先定义一个队列，用于存储待访问的格子，然后标记起点为已访问并加入队列，当队列不为空时，搜索：搜索时取出队列中的第一个格子并从队列中移除，遍历四个方向，计算下一个格子的坐标，检查这个格子是否在网格范围内、未被访问过且可以通过，如果都满足，就标记该格子为已访问并加入队列
     </strong>
    </p>
    <p>
     <strong>
      下面和dfs一样，把函数名改了就行
     </strong>
    </p>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct Node
{
    int x,y;
};
int n,k,xa,ya,xb,yb,dir[4][2]={<!-- -->{0,-1},{0,1},{1,0},{-1,0}};
char m[101][101];
bool vis[101][101];
void bfs(int stx,int sty)
{
    queue&lt;Node&gt;q;
    vis[stx][sty]=true;
    q.push(Node{stx,sty});
    while(!q.empty())
    {
        int sx=q.front().x,sy=q.front().y;
        q.pop();
        for(int i=0;i&lt;4;i++)
        {
            int x=sx+dir[i][0],y=sy+dir[i][1];
            if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n&amp;&amp;!vis[x][y]&amp;&amp;m[x][y]=='.')
            {
                vis[x][y]=true;
                q.push(Node{x,y});
            }
        }
    }
}
int main() 
{
    scanf("%d",&amp;k);
    while(k--)
    {
        scanf("%d",&amp;n);
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=n;j++)
            {
                cin&gt;&gt;m[i][j];
            }
        }
        scanf("%d%d%d%d",&amp;xa,&amp;ya,&amp;xb,&amp;yb);
        xa++,xb++,ya++,yb++;
        memset(vis,0,sizeof(vis));
        bfs(xa,ya);
        cout&lt;&lt;(vis[xb][yb]==true?"YES\n":"NO\n");
    } 
}</code></pre>
    <p>
     <img alt="" height="77" src="https://i-blog.csdnimg.cn/direct/100a60b0ea914b09a30faf61db91dac6.png" width="1352"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f72737479647569667564672f:61727469636c652f64657461696c732f313436313135313739" class_="artid" style="display:none">
 </p>
</div>


