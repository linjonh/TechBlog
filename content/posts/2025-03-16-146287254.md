---
layout: post
title: "Redis复制replica主从模式"
date: 2025-03-16 14:57:05 +0800
description: "redis主从模式"
keywords: "Redis复制（replica）主从模式"
categories: ['Redis']
tags: ['缓存', '数据库', 'Redis']
artid: "146287254"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146287254
    alt: "Redis复制replica主从模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146287254
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146287254
cover: https://bing.ee123.net/img/rand?artid=146287254
image: https://bing.ee123.net/img/rand?artid=146287254
img: https://bing.ee123.net/img/rand?artid=146287254
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis复制（replica）主从模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="Redis_0">
     </a>
     Redis主从复制
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f2b0affe47e34ce0b7710099eface8bb.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8fe8163cc1f14880a1921ee8f49fcbcc.png">
      <br/>
      Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中
      <strong>
       被复制的服务器为主服务器（master）
      </strong>
      ，而
      <strong>
       通过复制创建出来的服务器复制品则为从服务器（slave）
      </strong>
      。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，
      <strong>
       主服务器就会一直将发生在自己身上的数据更新同步给从服务器
      </strong>
      ，从而一直保证主从服务器的数据相同。
      <br/>
      一句话：就是主从复制，master以写为主，slave以读为主。当master数据变化的时候，自动将新的数据
      <strong>
       异步同步
      </strong>
      到其他slavve数据库。
      <br/>
      <strong>
       主从复制的作用
      </strong>
     </img>
    </p>
    <ul>
     <li>
      读写分离
     </li>
     <li>
      容灾恢复
     </li>
     <li>
      数据备份
     </li>
     <li>
      水平扩容支持高并发
     </li>
    </ul>
    <p>
     <strong>
      利用docker搭建一主两从的redis集群
     </strong>
    </p>
    <p>
     docker-compose.yml的配置信息
    </p>
    <pre><code class="prism language-bash">version: <span class="token string">'3.8'</span>
services:
  master:
    image: docker.1ms.run/library/redis:7.0.0
    container_name: redis-master
    ports:
      - <span class="token string">"6379:6379"</span>
    command: redis-server --protected-mode no <span class="token parameter variable">--requirepass</span> root  <span class="token comment"># 主节点密码</span>
  slave1:
    image: docker.1ms.run/library/redis:7.0.0
    container_name: redis-slave1
    ports:
      - <span class="token string">"6380:6379"</span>
    command: 
      - redis-server 
      - --protected-mode no 
      - <span class="token parameter variable">--replicaof</span> redis-master <span class="token number">6379</span> 
      - <span class="token parameter variable">--masterauth</span> root   <span class="token comment"># 从节点连接主节点的密码</span>
      - <span class="token parameter variable">--requirepass</span> root  <span class="token comment"># 从节点自身的密码（可选，但建议与主节点一致）</span>
  slave2:
    image: docker.1ms.run/library/redis:7.0.0
    container_name: redis-slave2
    ports:
      - <span class="token string">"6381:6379"</span>
    command: 
      - redis-server 
      - --protected-mode no 
      - <span class="token parameter variable">--replicaof</span> redis-master <span class="token number">6379</span> 
      - <span class="token parameter variable">--masterauth</span> root 
      - <span class="token parameter variable">--requirepass</span> root

</code></pre>
    <p>
     其中在每个从节点上需要配置master主节点的密码，–masterauth 的参数指定。以及–replicaof指定主节点的地址
    </p>
    <p>
     docker-compose up -d启动后
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4dab4bae2abc43b2a23fe53d107290c3.png">
      <br/>
      在master主节点上执行以下命令进入主节点的redis环境
     </img>
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-master redis-cli <span class="token parameter variable">-a</span> root
</code></pre>
    <p>
     在redis从节点上执行以下命令进入从节点的redis环境
    </p>
    <pre><code class="prism language-bash"> <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-slave1 redis-cli <span class="token parameter variable">-a</span> root
</code></pre>
    <p>
     进入redis集群后，可以执行info replication的命令查看节点的状态信息
    </p>
    <pre><code class="prism language-bash">info replication
</code></pre>
    <p>
     主节点的信息
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3ec3aec542c84b149d8952c961c9926f.png">
      <br/>
      从节点的信息
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a516f9a17fda46f1a9727bdc6cbe5583.png">
       <br/>
       主从同步的演示，在主节点上写入值，从节点可以读取到相关的值
       <br/>
       主节点写入值：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/79c349c12934462984da693520aea2c2.png">
        <br/>
        从节点读取值
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c77ae38f86144d6d8726f5eaa106236f.png">
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/64950a7f45ef4532bda3eaef14a05720.png">
          <br/>
          <strong>
           从节点可以执行写命令么？
          </strong>
          <br/>
          从节点不可以写
         </img>
        </img>
       </img>
      </img>
     </img>
    </p>
    <pre><code class="prism language-bash"><span class="token punctuation">(</span>error<span class="token punctuation">)</span> READONLY You can't <span class="token function">write</span> against a <span class="token builtin class-name">read</span> only replica.
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0704c79e5fae4e2ba72484d32d7a4d1d.png"/>
     <br/>
     第三个节点挂了，前两个节点还是正常的，再往主机写入多个值，第三个节点然后再启动，数据会同步过来么？
     <br/>
     第三个节点挂了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/dd547154e72f4fc98bd622e048379df0.png"/>
     <br/>
     往第一个节点写入多个值
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d83cc77444574745bf7dfa599d8c1044.png"/>
     <br/>
     查看第二个节点的数据，数据正常同步
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9f14647f3c6643c59d340b64473f32b9.png"/>
     <br/>
     启动第三个节点
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/54da45e1e5fd4d85ba904f7cd62bd3b5.png"/>
     <br/>
     查看第三个节点的数据信息，数据正常同步过来
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fbdeb6501d354dc2b5bc6ee9c09c9195.png"/>
     <br/>
     <strong>
      主节点shutdown后，从节点是否会上位？
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0cccaf2f09e240deaa879bee4e44eb6f.png"/>
     <br/>
     读取从机的值，数据并没有丢，身份也没有变
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/26d887345a394068b0823dbe81bfe33d.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a4a339091ab84d1daf5bb4644e37df3b.png"/>
     <br/>
     <strong>
      主机shutdown后，重启后主从关系还在吗？从机还能否顺利复制？
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c1a5d453d7a64c7fbc05c11b14e68db1.png"/>
     <br/>
     主节点再设置值
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/175f730ce2d04b35b8e5076c212dc93a.png"/>
     <br/>
     从节点再去读取值
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/13b857812dee46dfbb286782500c06fa.png"/>
     <br/>
     某台从机down后，master继续，从机重启后他能跟上大部队么？答：能
     <br/>
     除了从配置文件的角度设置持久有效的主从关系外，
     <strong>
      还可以通过命令salveof 主机ip以及端口号指定主机的挂载，但是临时有效
     </strong>
     ，当redis重启中，主从关系将不复存在。
     <br/>
     <strong>
      薪火相传的架构演示
     </strong>
     <br/>
     类似于爷爷-&gt;爸爸-&gt; 儿子的主从关系
     <br/>
     slaveof 新主库IP 新主库端口
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e63fb9a5d3704560afef58b46958c491.png"/>
     <br/>
     第三个节点选取第二个节点作为master节点
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7ffdd16e6c824876b0be3615736f290c.png"/>
     <br/>
     第一个爷爷级别的主节点信息变化
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ae1da5f0564446c79e3a896d5edd10c6.png"/>
     <br/>
     第二个中间爸爸级别的节点信息变化
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9024d4736d0d49b0a26372e4bf95b19d.png"/>
     <br/>
     中间的爸爸节点，仅仅是数据的同步方向的指定，仍然不可以执行写入操作的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/90ef6af81ed04853a0ad7f0227773715.png"/>
    </p>
    <p>
     上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻主master的写压力。
     <br/>
     中途变更转向：会清除之前的数据，重新建立拷贝最新的。
     <br/>
     <strong>
      反客为主
     </strong>
     <br/>
     使用命令:
     <strong>
      slaveof no one
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/25fe81f21c8d4d3e9dc5f31f928e0aae.png"/>
     <br/>
     写入数据
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5b96bb9b9a3e4749ba849bd156cc3fa2.png"/>
     <br/>
     <strong>
      主从复制原理和工作流程
     </strong>
    </p>
    <ul>
     <li>
      salve启动，同步初请（slave启动成功连接到master会发送一个sync命令，slav
      <strong>
       e首次全新连接master
      </strong>
      ,一次完全同步（全量复制）将被自动执行，
      <strong>
       slave自身原有数据会被master数据覆盖清除
      </strong>
      ）
     </li>
     <li>
      首次连接，全量复制（master节点收到sync命令后会开始在后台保存快照（即RDB持久化，主从复制时会触发RDB），同时收集所有接收到的用于修改数据集命令缓存起来，master节点执行RDB持久化完成后，master将RDB快照文件和所有缓存的命令发送到所有slave,以完成一次完全同步。而slave服务在接收到数据库文件后，将其存盘并加载到内存中，从而完成复制初始化）
     </li>
     <li>
      心跳持续，保持通信（master发出PING包的周期，默认10s。
      <strong>
       repl-ping-replica-period 10
      </strong>
      ）
     </li>
     <li>
      进入平稳，增量复制（master继续将新的所有收集到的修改命令自动依次传递给slave,完成同步）
     </li>
     <li>
      从机下线，重连续传（master会检查backlog里面的offset,master和slave都会保存一个复制的offset还有一个masterId,
      <strong>
       offset是保存在backlog中的
      </strong>
      ，
      <strong>
       Master只会把已复制的offset后面的数据复制给slave,类似断点续传
      </strong>
      ）
     </li>
    </ul>
    <p>
     <strong>
      主从复制的缺点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       复制延时，信号衰减
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1fd1c2e484d64c76b86dcab9c92751e4.png"/>
      </p>
     </li>
     <li>
      <p>
       master挂了，如何办？（
       <strong>
        默认情况下，不会在slave节点中自动重选一个master
       </strong>
       ,那每次人工选举？？
       <strong>
        无人值守安装成为刚需 哨兵模式
       </strong>
       ）
      </p>
     </li>
    </ul>
    <p>
     参考视频
     <br/>
     <a href="https://www.bilibili.com/video/BV13R4y1v7sP?spm_id_from=333.788.player.switch&amp;vd_source=446808d568eabd207183c529fd2fb129&amp;p=63" rel="nofollow">
      Redis 集群架构
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32363634313133372f:61727469636c652f64657461696c732f313436323837323534" class_="artid" style="display:none">
 </p>
</div>


