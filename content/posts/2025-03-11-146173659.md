---
layout: post
title: "面试题系列-Redis-核心面试题二答案"
date: 2025-03-11 11:27:09 +0800
description: "本文主要介绍Redis 的面试题，涵盖持久化、集群、缓存策略、事务等方面"
keywords: "redis aof考题"
categories: ['面试题系列']
tags: ['缓存', '数据库', 'Redis']
artid: "146173659"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146173659
    alt: "面试题系列-Redis-核心面试题二答案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146173659
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146173659
cover: https://bing.ee123.net/img/rand?artid=146173659
image: https://bing.ee123.net/img/rand?artid=146173659
img: https://bing.ee123.net/img/rand?artid=146173659
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【面试题系列】 Redis 核心面试题(二)&amp;答案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/578b1dbbe1e24e9ea142bdc170272173.png#pic_center"/>
    </p>
    <blockquote>
     <p>
      本文主要介绍Redis 的面试题，涵盖持久化、集群、缓存策略、事务等方面
     </p>
    </blockquote>
    <h3>
     <a id="_6">
     </a>
     <strong>
      一、持久化机制
     </strong>
    </h3>
    <h4>
     <a id="1_RDB__AOF__7">
     </a>
     1. RDB 与 AOF 的核心区别及适用场景？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         特性
        </strong>
       </th>
       <th>
        <strong>
         RDB
        </strong>
       </th>
       <th>
        <strong>
         AOF
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         存储内容
        </strong>
       </td>
       <td>
        内存快照（二进制文件）
       </td>
       <td>
        写命令日志（文本格式）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据完整性
        </strong>
       </td>
       <td>
        可能丢失最后一次快照后的数据
       </td>
       <td>
        可配置
        <code>
         everysec
        </code>
        保证秒级丢失
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         恢复速度
        </strong>
       </td>
       <td>
        快（直接加载二进制文件）
       </td>
       <td>
        慢（需重放所有命令）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         文件大小
        </strong>
       </td>
       <td>
        小（压缩）
       </td>
       <td>
        大（未压缩）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        定期全量备份，快速恢复
       </td>
       <td>
        实时备份，数据完整性要求高
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      混合持久化（Redis 4.0+）：
     </strong>
     <br/>
     AOF 重写时会将 RDB 快照写入文件开头，结合两者优势。
    </p>
    <h4>
     <a id="2_RDB__21">
     </a>
     2. RDB 快照触发机制有哪些？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       自动触发
      </strong>
      ：
      <ul>
       <li>
        满足
        <code>
         save
        </code>
        配置条件（如
        <code>
         save 60 1000
        </code>
        ）。
       </li>
       <li>
        执行
        <code>
         flushall
        </code>
        命令。
       </li>
       <li>
        主从复制时主节点生成快照。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       手动触发
      </strong>
      ：
      <ul>
       <li>
        <code>
         SAVE
        </code>
        （阻塞主线程）。
       </li>
       <li>
        <code>
         BGSAVE
        </code>
        （后台 fork 子进程生成快照）。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_32">
     </a>
     <strong>
      二、集群与高可用
     </strong>
    </h3>
    <h4>
     <a id="3_Redis_Cluster__33">
     </a>
     3. Redis Cluster 节点通信机制是什么？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Gossip 协议
      </strong>
      ：节点通过周期性广播
      <code>
       PING/PONG
      </code>
      消息同步集群状态。
     </li>
     <li>
      <strong>
       消息类型
      </strong>
      ：
      <ul>
       <li>
        <code>
         MEET
        </code>
        ：邀请新节点加入集群。
       </li>
       <li>
        <code>
         PONG
        </code>
        ：响应请求或广播自身状态。
       </li>
       <li>
        <code>
         FAIL
        </code>
        ：标记节点为下线。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       节点握手
      </strong>
      ：新节点加入时需与至少一个已知节点通信，逐步同步整个集群的槽位映射。
     </li>
    </ul>
    <h4>
     <a id="4_Redis_Sentinel__43">
     </a>
     4. Redis Sentinel 如何实现故障转移？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       监控
      </strong>
      ：Sentinel 定期向主从节点发送
      <code>
       PING
      </code>
      检测存活状态。
     </li>
     <li>
      <strong>
       主观下线（SDOWN）
      </strong>
      ：若节点超时未响应，标记为 SDOWN。
     </li>
     <li>
      <strong>
       客观下线（ODOWN）
      </strong>
      ：半数以上 Sentinel 确认节点不可达时，标记为 ODOWN。
     </li>
     <li>
      <strong>
       选举领导者
      </strong>
      ：Sentinel 通过 Raft 协议选举主节点。
     </li>
     <li>
      <strong>
       故障转移
      </strong>
      ：
      <ul>
       <li>
        提升某个从节点为主节点。
       </li>
       <li>
        其他从节点重新指向新主节点。
       </li>
       <li>
        通知客户端新主节点地址。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_55">
     </a>
     <strong>
      三、缓存策略
     </strong>
    </h3>
    <h4>
     <a id="5__56">
     </a>
     5. 缓存穿透、缓存雪崩、缓存击穿的区别与解决方案？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         问题
        </strong>
       </th>
       <th>
        <strong>
         描述
        </strong>
       </th>
       <th>
        <strong>
         解决方案
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         穿透
        </strong>
       </td>
       <td>
        查询不存在的数据，直接打到数据库
       </td>
       <td>
        布隆过滤器、空值缓存（设置短过期时间）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         雪崩
        </strong>
       </td>
       <td>
        大量缓存同时过期，数据库压力激增
       </td>
       <td>
        随机过期时间、加锁限流、二级缓存
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         击穿
        </strong>
       </td>
       <td>
        热点数据过期瞬间，大量请求打到数据库
       </td>
       <td>
        互斥锁（
        <code>
         SETNX
        </code>
        ）、永不过期（异步更新）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      Java 示例（布隆过滤器）：
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token class-name">BloomFilter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> bloomFilter <span class="token operator">=</span> <span class="token class-name">BloomFilter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>
    <span class="token class-name">Funnels</span><span class="token punctuation">.</span><span class="token function">stringFunnel</span><span class="token punctuation">(</span><span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100万容量，误差率1%</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 直接返回，避免查数据库</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="6_Redis__LRU__LFU__75">
     </a>
     6. Redis 内存淘汰策略中 LRU 和 LFU 的区别？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       LRU（Least Recently Used）
      </strong>
      ：淘汰最久未使用的键。
     </li>
     <li>
      <strong>
       LFU（Least Frequently Used）
      </strong>
      ：淘汰访问频率最低的键。
     </li>
     <li>
      <strong>
       Redis 实现
      </strong>
      ：
      <ul>
       <li>
        LRU 使用近似算法（随机采样+淘汰最旧）。
       </li>
       <li>
        LFU 通过
        <code>
         logc（访问频率）
        </code>
        和
        <code>
         lru（最近访问时间）
        </code>
        综合判断。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：
      <ul>
       <li>
        LRU 适合热点数据不明显的场景。
       </li>
       <li>
        LFU 适合长期低频但短期高频的键（如促销活动商品）。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_87">
     </a>
     <strong>
      四、事务与并发控制
     </strong>
    </h3>
    <h4>
     <a id="7_Redis__88">
     </a>
     7. Redis 事务的原子性如何保证？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis 事务
     <strong>
      不保证原子性
     </strong>
     ，但通过以下机制提供部分保证：
    </p>
    <ol>
     <li>
      <strong>
       入队阶段
      </strong>
      ：所有命令先放入队列，若语法错误则整个事务被取消。
     </li>
     <li>
      <strong>
       执行阶段
      </strong>
      ：命令按顺序执行，中途出错不回滚，但后续命令仍执行。
     </li>
     <li>
      <strong>
       WATCH 机制
      </strong>
      ：通过乐观锁监控键变化，若被修改则事务失败。
     </li>
    </ol>
    <p>
     <strong>
      示例（WATCH 实现 CAS）：
     </strong>
    </p>
    <pre><code class="prism language-java">jedis<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> balance <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>balance<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Transaction</span> tx <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    tx<span class="token punctuation">.</span><span class="token function">decrBy</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 数据被修改，重试逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
jedis<span class="token punctuation">.</span><span class="token function">unwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="8_Redis__111">
     </a>
     8. Redis 如何实现乐观锁？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       WATCH/MULTI/EXEC
      </strong>
      ：
      <ul>
       <li>
        监控指定键，若事务执行前键被修改，
        <code>
         EXEC
        </code>
        返回
        <code>
         null
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       Check-and-Set（CAS）
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         GETSET
        </code>
        或
        <code>
         SET key value NX
        </code>
        实现条件更新。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       版本号机制
      </strong>
      ：
      <ul>
       <li>
        对每个键维护版本号，更新时校验版本号是否匹配。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_121">
     </a>
     <strong>
      五、实战优化
     </strong>
    </h3>
    <h4>
     <a id="9_Redis__122">
     </a>
     9. Redis 连接池的配置参数有哪些？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       MaxTotal
      </strong>
      ：最大连接数（默认 8）。
     </li>
     <li>
      <strong>
       MaxIdle
      </strong>
      ：最大空闲连接数（默认 8）。
     </li>
     <li>
      <strong>
       MinIdle
      </strong>
      ：最小空闲连接数（默认 0）。
     </li>
     <li>
      <strong>
       MaxWaitMillis
      </strong>
      ：获取连接的最大等待时间（默认 -1，无限等待）。
     </li>
     <li>
      <strong>
       TestOnBorrow
      </strong>
      ：获取连接时是否测试连通性（默认
      <code>
       false
      </code>
      ）。
     </li>
    </ul>
    <p>
     <strong>
      Java 配置示例（JedisPoolConfig）：
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token class-name">JedisPoolConfig</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">JedisPool</span> jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="10__Redis__140">
     </a>
     10. 如何监控 Redis 的内存使用情况？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       命令行工具
      </strong>
      ：
      <ul>
       <li>
        <code>
         INFO memory
        </code>
        ：查看内存使用统计。
       </li>
       <li>
        <code>
         MEMORY USAGE key
        </code>
        ：查看单个键的内存占用。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       可视化工具
      </strong>
      ：
      <ul>
       <li>
        RedisInsight、Prometheus + Grafana。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       关键指标
      </strong>
      ：
      <ul>
       <li>
        <code>
         used_memory
        </code>
        ：已使用内存。
       </li>
       <li>
        <code>
         mem_fragmentation_ratio
        </code>
        ：内存碎片率（理想值 1.0-1.5）。
       </li>
       <li>
        <code>
         evicted_keys
        </code>
        ：被淘汰的键数量。
       </li>
      </ul>
     </li>
    </ul>
    <h2>
     <a id="_153">
     </a>
     总结
    </h2>
    <p>
     Redis 的核心设计理念（单线程、内存优先、异步持久化）是理解其高性能的关键。面试中需结合具体场景分析问题，如缓存策略需区分穿透/雪崩/击穿的不同解决方案，集群需掌握节点通信和故障转移原理。建议通过
     <code>
      Redis-cli
     </code>
     实操和源码阅读加深理解。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33363735353533352f:61727469636c652f64657461696c732f313436313733363539" class_="artid" style="display:none">
 </p>
</div>


