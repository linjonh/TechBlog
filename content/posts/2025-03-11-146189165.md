---
layout: post
title: "数据结构堆"
date: 2025-03-11 21:27:07 +0800
description: "对于一个节点，我们判断其节点值与左右节点的值相比较，如果当前节点的值不满足都小于或等于其左右孩子结点的值， 那么我们将节点与左右节点中较小的那个进行交换操作，由于进行了交换，故当前这棵子树中满足了小顶堆的特点，但由于交换了位置，故需要判断被交换位置后的子树位置此时的节点与其新左右孩子的节点值是否满足小顶堆。源文件 heap.c。1.下沉操作down。"
keywords: "数据结构——堆"
categories: ['未分类']
tags: ['算法', '数据结构']
artid: "146189165"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146189165
    alt: "数据结构堆"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146189165
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146189165
cover: https://bing.ee123.net/img/rand?artid=146189165
image: https://bing.ee123.net/img/rand?artid=146189165
img: https://bing.ee123.net/img/rand?artid=146189165
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——堆
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      定义：堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 故通常我们用完全二叉树来维护一个一维数组。
     </strong>
    </p>
    <p>
     <strong>
      分类 : 按照堆的特点可以把堆分为大根堆和小根堆
      <br/>
      大根堆：每个结点的值都大于或等于其左右孩子结点的值
      <br/>
      小根堆：每个结点的值都小于或等于其左右孩子结点的值
     </strong>
    </p>
    <p>
     <strong>
      二叉树的性质：
     </strong>
    </p>
    <p>
     对于具有 n 个结点的完全⼆叉树，如果按照从上⾄下从左⾄右的数组顺序对所有结点从 0 开始编号，则对于序号为 i 的结点有：                                                                                                          1. 若 i&gt;0 ， i 位置结点的双亲序号： (i-1)/2 ； i=0 ， i 为根结点编号，⽆双亲结点                           2. 若 2i+1 &lt; n, 则左孩子编号：2*i + 1.                                                                                               3. 若 2i+2 &lt; n, 则右孩子编号：2*i + 2。
    </p>
    <p>
     <strong>
      堆的关键操作
     </strong>
     ：（以小根堆为例）
    </p>
    <p>
     1.下沉操作down
     <br/>
     对于一个节点，我们判断其节点值与左右节点的值相比较，如果当前节点的值不满足都小于或等于其左右孩子结点的值， 那么我们将节点与左右节点中较小的那个进行交换操作，由于进行了交换，故当前这棵子树中满足了小顶堆的特点，但由于交换了位置，故需要判断被交换位置后的子树位置此时的节点与其新左右孩子的节点值是否满足小顶堆。
    </p>
    <p>
     2.上浮操作up
     <br/>
     对于一个节点我们与其父节点进行比较，如果当前的父节点比其节点值大，则不满足小顶堆的条件，故此时这两个节点需要进行交互，交换完毕后的成为新的父节点，此时由于位置变动，其需要继续与原本父节点的父节点进行比较，直到都满足堆条件为止。
    </p>
    <p>
     <strong>
      堆的实现：
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       头文件 heap.h
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int HPDataType;
typedef struct Heap
{
	HPDataType* arr;
	int size;
	int capacity;
}Heap;

//初始化
void HeapInit(Heap* hp);

//销毁
void HeapDestroy(Heap* hp);

//插入
void HeapPush(Heap* hp, HPDataType x);

//打印
void HeapPrint(Heap* hp);

//删除堆顶
void HeapPop(Heap* hp);

//取堆顶元素
int HeapTop(Heap* hp);

//数据个数
int HeapSize(Heap* hp);

//堆的判空
bool HeapEmpty(Heap* hp);

void Swap(HPDataType* x, HPDataType* y);
void Up(HPDataType* arr, int child);
void Down(HPDataType* arr, int parent, int n);</code></pre>
    <blockquote>
     <p>
      源文件 heap.c
     </p>
    </blockquote>
    <pre><code class="language-cpp">#include"heap.h"

//初始化
void HeapInit(Heap* hp)
{
	assert(hp);
	hp-&gt;arr = NULL;
	hp-&gt;size = hp-&gt;capacity = 0;
}

//销毁
void HeapDestroy(Heap* hp)
{
	assert(hp);
	if (hp-&gt;arr)
		free(hp-&gt;arr);
	hp-&gt;arr = NULL;
	hp-&gt;size = hp-&gt;capacity = 0;
}

//打印
void HeapPrint(Heap* hp)
{
	assert(hp);
	for (int i = 0; i &lt; hp-&gt;size; i++)
	{
		printf("%d ", hp-&gt;arr[i]);
	}
	printf("\n");
}

//交换两数
void Swap(HPDataType* x, HPDataType* y)
{
	HPDataType tmp = *x;
	*x = *y;
	*y = tmp;
}

//向上调整
void Up(HPDataType* arr, int child)
{
	int parent = (child - 1) / 2;
	while (child)
	{
		//大根堆: &gt;   ,  小根堆：&lt;
		if (arr[child] &lt; arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

//插入
void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;size == hp-&gt;capacity)//空间不足
	{
		int newcapacity = hp-&gt;capacity == 0 ? 4 : 2 * hp-&gt;capacity;
		HPDataType* tmp = (HPDataType*)realloc(hp-&gt;arr, newcapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("realloc");
			exit(1);
		}
		hp-&gt;arr = tmp;
		hp-&gt;capacity = newcapacity;//扩容成功
	}
	hp-&gt;arr[hp-&gt;size] = x;
	Up(hp-&gt;arr, hp-&gt;size);
	hp-&gt;size++;
}

//数据个数
int HeapSize(Heap* hp)
{
	assert(hp);
	return hp-&gt;size;
}

//堆的判空
bool HeapEmpty(Heap* hp)
{
	assert(hp);
	return hp-&gt;size == 0;
}

//向下调整
void Down(HPDataType* arr, int parent, int n)
{
	int child = 2 * parent + 1;
	while (child &lt; n)
	{
		//大根堆: &lt; ,  小根堆: &gt;
		if (child + 1 &lt; n &amp;&amp; arr[child] &gt; arr[child + 1])
		{
			child++;
		}
		//大根堆: &gt;,  小根堆:  &lt; 
		if (arr[child] &lt; arr[parent])
		{
			Swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
		{
			break;
		}
	}
}

//删除堆顶
void HeapPop(Heap* hp)
{
	assert(!HeapEmpty(hp));
	Swap(&amp;hp-&gt;arr[0], &amp;hp-&gt;arr[hp-&gt;size - 1]);
	hp-&gt;size--;
	Down(hp-&gt;arr, 0, hp-&gt;size);
}

//取堆顶元素
int HeapTop(Heap* hp)
{
	assert(!HeapEmpty(hp));
	return hp-&gt;arr[0];
}</code></pre>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f435f433236333678797a2f:61727469636c652f64657461696c732f313436313839313635" class_="artid" style="display:none">
 </p>
</div>


