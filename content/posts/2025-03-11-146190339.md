---
layout: post
title: "slab分配器3slab内存申请和释放"
date: 2025-03-11 22:02:10 +0800
description: "ref：内存管理之slub"
keywords: "slab分配器（3）：slab内存申请和释放"
categories: ['Linux']
tags: ['Linux']
artid: "146190339"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146190339
    alt: "slab分配器3slab内存申请和释放"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146190339
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146190339
cover: https://bing.ee123.net/img/rand?artid=146190339
image: https://bing.ee123.net/img/rand?artid=146190339
img: https://bing.ee123.net/img/rand?artid=146190339
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     slab分配器（3）：slab内存申请和释放
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <pre><code class="language-cpp">void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)
{
	void *ret = slab_alloc(s, gfpflags, _RET_IP_);

	trace_kmem_cache_alloc(_RET_IP_, ret, s-&gt;object_size,
				s-&gt;size, gfpflags);

	return ret;
}


static __always_inline void *slab_alloc(struct kmem_cache *s,
		gfp_t gfpflags, unsigned long addr)
{
	return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);
}</code></pre>
    <p>
    </p>
    <p>
     <a href="https://elixir.bootlin.com/linux/v5.4.285/source/mm/slub.c#L2822" rel="nofollow" title="https://elixir.bootlin.com/linux/v5.4.285/source/mm/slub.c#L2822">
      https://elixir.bootlin.com/linux/v5.4.285/source/mm/slub.c#L2822
     </a>
    </p>
    <p>
    </p>
    <p>
     可以看到，核心函数是
    </p>
    <p>
     <a href="https://elixir.bootlin.com/linux/v5.4.285/source/mm/slub.c#L2727" rel="nofollow" title="https://elixir.bootlin.com/linux/v5.4.285/source/mm/slub.c#L2727">
      https://elixir.bootlin.com/linux/v5.4.285/source/mm/slub.c#L2727
     </a>
    </p>
    <h4>
     二、关键代码逻辑分解
    </h4>
    <p>
     struct kmem_cache用s表示
    </p>
    <p>
     struct kmem_cache_cpu用c表示
    </p>
    <p>
     struct kmem_cache_node用n表示
    </p>
    <p>
     slub内存申请逻辑包括快速通道和慢速通道。我们把slub的申请速度由快到慢分为以下5个速度级别，L1速度最快，L5速度最慢。
    </p>
    <ol>
     <li>
      <strong>
       从c-&gt;freelist获取obj为L1
      </strong>
     </li>
     <li>
      <strong>
       从c-&gt;page
       <strong>
        获取obj
       </strong>
       为L2
      </strong>
     </li>
     <li>
      <strong>
       从c-&gt;partial
       <strong>
        获取obj
       </strong>
       为L3
      </strong>
     </li>
     <li>
      <strong>
       从n-&gt;parital
       <strong>
        获取obj
       </strong>
       为L4
      </strong>
     </li>
     <li>
      <strong>
       从alloc_pages中
       <strong>
        获取obj
       </strong>
       为L5
      </strong>
     </li>
    </ol>
    <p>
     下面结合源码依次分析slub的申请流程:
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="667" src="https://i-blog.csdnimg.cn/img_convert/fb116556a1b7fa5864e932d1263f2638.png" width="840"/>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        L5路径
       </strong>
      </p>
     </li>
    </ul>
    <p>
     刚开始无slub缓存，走慢速路径，最慢速的路径只能从伙伴系统中申请一个slub。会调用new_slab函数申请一个slab，并填充page中freelist=start，page-&gt;inuse=page-&gt;objects，page-&gt;frozen=1;同时填充obj为单向链表，然后迁移到c-&gt;freelist中，同时page-&gt;freelist=NULL,然后返回第一个空闲的object。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="375" src="https://i-blog.csdnimg.cn/img_convert/69bc93af8ac182732224ddd766d21ffa.png" width="825"/>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="429" src="https://i-blog.csdnimg.cn/img_convert/55f9c5c9d04327ab676a68a7f3f4c659.png" width="1080"/>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        L1路径
       </strong>
      </p>
     </li>
    </ul>
    <p>
     L1路径即c-&gt;freelist!=NULL，则直接从c-&gt;freelist拿一个obj。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="379" src="https://i-blog.csdnimg.cn/img_convert/06b49c4a1a462a782fedf9349a4dc32c.png" width="1074"/>
    </p>
    <p>
     如果第一个slub通过慢慢申请殆尽，需要重新申请个slub，
     <span style="color:#fe2c24">
      老的slub游离
     </span>
     ，同时把该slub的page-&gt;frozen=0
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="429" src="https://i-blog.csdnimg.cn/img_convert/7afebe71ed816748b0b5049db98fb1a2.png" width="1080"/>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        L2路径
       </strong>
      </p>
     </li>
    </ul>
    <p>
     随着slub中的object申请释放，c-&gt;freelist的object为NULL，而c-&gt;page!=NULL，此时需要从c-&gt;page-&gt;freelist迁移到c-&gt;freelist中，在slab_alloc_node函数中判断c-&gt;freelist为NULL，未关中断，则进入__slab_alloc函数中，在此函数中local_irq_save关中断，此时有可能c-&gt;freelist被释放了，因此在___slab_alloc函数中判断c-&gt;page不为空，此时还需要判断c-&gt;freelist，如果不为空，则从c-&gt;freelist中获取obj，如果为空，则通过freelist =get_freelist(s, page)函数获取。重点看下get_freelist函数
    </p>
    <p>
    </p>
    <p>
    </p>
    <h5>
     1. ​
     <strong>
      预处理与事务同步
     </strong>
    </h5>
    <pre><code class="language-cpp">s = slab_pre_alloc_hook(s, gfpflags);</code></pre>
    <ul>
     <li>
      ​
      <strong>
       作用
      </strong>
      ：调用预处理钩子函数，可能涉及内存控制组（memcg）的检查或调试功能（如KASAN）
     </li>
     <li>
      ​
      <strong>
       返回值
      </strong>
      ：若缓存无效（如被销毁），则直接返回
      <code>
       NULL
      </code>
      。
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      事务ID与CPU缓存同步
     </strong>
    </h5>
    <pre><code class="language-cpp">do {
    tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);
    c = raw_cpu_ptr(s-&gt;cpu_slab);
} while (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp; unlikely(tid != READ_ONCE(c-&gt;tid)));</code></pre>
    <ul>
     <li>
      ​
      <strong>
       关键机制
      </strong>
      ：
      <ul>
       <li>
        ​
        <strong>
         事务ID（
         <code>
          tid
         </code>
         ）​
        </strong>
        ：全局唯一性标识，用于检测并发操作（如抢占导致缓存状态变化）
       </li>
       <li>
        ​
        <strong>
         循环检查
        </strong>
        ：在启用抢占（
        <code>
         CONFIG_PREEMPT
        </code>
        ）时，确保读取的
        <code>
         tid
        </code>
        与当前CPU缓存的
        <code>
         tid
        </code>
        一致，避免因线程切换导致数据不一致
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     3. ​
     <strong>
      内存屏障与操作顺序保证
     </strong>
    </h5>
    <pre><code class="language-cpp">barrier();</code></pre>
    <ul>
     <li>
      ​
      <strong>
       作用
      </strong>
      ：确保在读取
      <code>
       c-&gt;freelist
      </code>
      和
      <code>
       c-&gt;page
      </code>
      前，
      <code>
       tid
      </code>
      的加载操作已完成，防止乱序执行引发竞态条件
     </li>
    </ul>
    <hr/>
    <h4>
    </h4>
    <hr/>
    <h5>
     <strong>
      4、后处理与安全性
     </strong>
    </h5>
    <pre><code class="language-cpp">maybe_wipe_obj_freeptr(s, object);
if (unlikely(slab_want_init_on_alloc(...)))
    memset(object, 0, s-&gt;object_size);
slab_post_alloc_hook(s, gfpflags, 1, &amp;object);</code></pre>
    <ul>
     <li>
      ​
      <strong>
       关键操作
      </strong>
      ：
      <ul>
       <li>
        ​
        <strong>
         擦除空闲指针
        </strong>
        ：防止信息泄漏（如KASAN检测）
       </li>
       <li>
        ​
        <strong>
         对象初始化
        </strong>
        ：根据
        <code>
         __GFP_ZERO
        </code>
        标志清零对象内存。
       </li>
       <li>
        ​
        <strong>
         后处理钩子
        </strong>
        ：更新内存统计、调试信息或触发内存回收
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
     ref：
    </p>
    <p>
     <a href="https://mp.weixin.qq.com/s?__biz=MzUxNTY5NzAyNQ==&amp;mid=2247483952&amp;idx=1&amp;sn=d61879cee4158565258494005a7c04fd&amp;chksm=f8a3668f19aceca993352d9fa91d686ddfc723eb6876e2f936dc9c909e350bb53b64b81ade9d#rd" rel="nofollow" title="内存管理之slub">
      内存管理之slub
     </a>
    </p>
    <p>
     <a href="http://www.wowotech.net/memory_management/426.html" rel="nofollow" title="图解slub">
      图解slub
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7777776c796a3132333332312f:61727469636c652f64657461696c732f313436313930333339" class_="artid" style="display:none">
 </p>
</div>


