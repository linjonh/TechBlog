---
layout: post
title: "Redis持久化RDB和AOF和事务"
date: 2025-03-10 19:16:21 +0800
description: "对于数据的存储而言，为保证速度快，数据得在内存中，但为了持久，数据还得存在硬盘之中，Redis 的持久化机制是其高可靠性的核心，主要用于在重启或崩溃后恢复数据。和，以及从 4.0 版本开始支持的。"
keywords: "【Redis】持久化(RDB和AOF)和事务"
categories: ['中间件企业级中间件剖析']
tags: ['混合持久化', '数据库', '学习', '事务', 'Redis', 'Rdb', 'Aof']
artid: "146076273"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146076273
    alt: "Redis持久化RDB和AOF和事务"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146076273
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146076273
cover: https://bing.ee123.net/img/rand?artid=146076273
image: https://bing.ee123.net/img/rand?artid=146076273
img: https://bing.ee123.net/img/rand?artid=146076273
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Redis】持久化(RDB和AOF)和事务
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" height="140" src="https://img-blog.csdnimg.cn/direct/2b890d64512e4255b4419b4ec36be3a2.png" width="407"/>
    </p>
    <p class="img-center">
     <img alt="" height="80" src="https://img-blog.csdnimg.cn/direct/978cee77d6a54aa684bc0ab6be5a4023.png" width="640"/>
    </p>
    <p style="text-align:center">
     🔥个人主页：
     <a href="https://blog.csdn.net/2302_79806056?spm=1000.2115.3001.5343" title="中草药">
      中草药
     </a>
    </p>
    <p style="text-align:center">
     🔥专栏：
     <a href="https://blog.csdn.net/2302_79806056/category_12906397.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12906397&amp;sharerefer=PC&amp;sharesource=2302_79806056&amp;sharefrom=from_link" title="【中间件】企业级中间件剖析">
      【中间件】企业级中间件剖析
     </a>
    </p>
    <hr/>
    <h2 style="background-color:transparent">
     一、持久化
    </h2>
    <p>
     对于数据的存储而言，为保证速度快，数据得在内存中，但为了持久，数据还得存在硬盘之中，Redis 的持久化机制是其高可靠性的核心，主要用于在重启或崩溃后恢复数据。它提供两种主要持久化方式：
     <strong>
      RDB（Redis Database）
     </strong>
     和
     <strong>
      AOF（Append-Only File）
     </strong>
     ，以及从 4.0 版本开始支持的
     <strong>
      混合持久化
     </strong>
     。
    </p>
    <h3>
     RDB（
     <strong>
      Redis Database
     </strong>
     快照持久化）
    </h3>
    <p>
     <strong>
      工作原理
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        基于快照
       </strong>
       ：RDB 通过定期生成内存数据的二进制快照（Snapshot）保存到磁盘（默认文件为
       <code>
        dump.rdb
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        触发机制
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          手动触发
         </strong>
         ：通过
         <code>
          SAVE
         </code>
         （执行时，Redis会阻塞主线程，可能会导致keys *的效果，一般不建议使用）
         <code>
          BGSAVE
         </code>
         （BackGround ，非阻塞，Redis通过后台子进程处理）命令。
        </p>
       </li>
       <li>
        <p>
         <strong>
          自动触发
         </strong>
         ：根据配置文件中的
         <code>
          save
         </code>
         规则（如
         <code>
          save 900 1
         </code>
         表示 900 秒内至少 1 个键被修改时触发）。（生成快照是一个成本比较高的操作，不能让这个操作频繁执行）
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      自动触发除此之外有以下这几种方式：
     </p>
     <p>
      1、正常流程重新启动redis服务器，通过shutdown命令（redis里的一个命令）关闭服务器，也会触发（service redis-server restart），但异常重启（kill -9 或 服务器掉电）来不及生成RDB，会出现数据丢失
     </p>
     <p>
      2、redis进行主从复制的时候，主节点也会自动生成RDB快照，然后把rdb文件内容传输给节点
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       <strong>
        bgsave
       </strong>
       ：使用
       <code>
        BGSAVE
       </code>
       时，Redis 首先会判定当前是否存在其他正在工作的子进程，如果没有主进程会 fork 一个子进程，子进程负责将内存数据写入临时 RDB 文件生成快照，父进程将继续接受客户端的请求，继续正常提供服务，子进程完成整体的持久化过程后替换旧文件，并通知父进程，父进程更新一些统计信息，子进程结束销毁
      </p>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="311" src="https://i-blog.csdnimg.cn/direct/535117164b184ac0adcad5a5150369c5.png" width="490"/>
    </p>
    <blockquote>
     <p>
      <strong>
       fork
      </strong>
     </p>
     <p>
      Linux 的
      <code>
       fork()
      </code>
      是创建新进程的核心系统调用，它会创建一个与父进程几乎完全相同的子进程，包括代码段、数据段、堆栈、文件描述符、信号处理等。
     </p>
     <p>
      子进程拥有
      <strong>
       独立的进程空间
      </strong>
      ，但初始时与父进程共享物理内存（通过
      <strong>
       写时复制，Copy-On-Write, COW
      </strong>
      技术优化性能）。
     </p>
    </blockquote>
    <p>
     redis生成的rdb文件，是存放在 redis 的工作目录之中，可在 redis 的工作目录
    </p>
    <p class="img-center">
     <img alt="" height="208" src="https://i-blog.csdnimg.cn/direct/d508a5ef1b484de795cbcb73774f3521.png" width="792"/>
    </p>
    <p>
     rdb的镜像文件
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/439e4396ae1146fdb9622fca95b86476.png" width="691"/>
    </p>
    <p>
     redis提供了检查rdb文件的工具
    </p>
    <p>
     <img alt="" height="397" src="https://i-blog.csdnimg.cn/direct/5a3f559522b34facadd69b7cd13c4574.png" width="1056">
      <strong>
       优点
      </strong>
     </img>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        紧凑高效
       </strong>
       ：RDB是一个紧凑压缩的二进制文件，体积小，适合备份、全量复制和灾难恢复。
      </p>
     </li>
     <li>
      <p>
       <strong>
        快速恢复
       </strong>
       ：加载 RDB 文件的速度远快于 AOF。
      </p>
     </li>
     <li>
      <p>
       <strong>
        低性能影响
       </strong>
       ：生成快照由子进程处理，主进程几乎不受影响（除 fork 时的短暂延迟）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        数据丢失风险
       </strong>
       ：若两次快照间发生故障，会丢失最后一次快照后的数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        大内存开销
       </strong>
       ：RDB无法做到实时持久化，秒级持久化，fork 子进程时，属于重量级操作，若数据集过大，可能导致主进程短暂阻塞（尤其在虚拟内存不足时）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        兼容性风险
       </strong>
       ：RDB文件使用特定的二进制格式保存，Redis版本演进过程中有过多个RDB版本，兼容性存在风险
      </p>
     </li>
    </ul>
    <p>
     <strong>
      配置示例
     </strong>
    </p>
    <p>
     修改配置后，需要重新启动服务器 service redis-server restart
    </p>
    <pre><code class="language-bash">save 900 1      # 900秒内至少1个键修改则触发
save 300 10     # 300秒内至少10个键修改
save 60 10000   # 60秒内至少10000个键修改
save ""         # 关闭自动生成快照
stop-writes-on-bgsave-error yes  # 快照失败时停止写入
rdbcompression yes               # 压缩RDB文件
rdbchecksum yes                  # 校验数据完整性</code></pre>
    <blockquote>
     <p>
      rdb文件时二进制的，如果redis在启动时使用这个文件，造成的后果是不可预期的，可能redis的服务器可以启动，得到的数据可能正确，也可能有问题，也有更大的可能redis服务器直接启动失败。这时我们需要用到redis提供的检查rdb文件的工具redis-check-rdb
     </p>
    </blockquote>
    <hr/>
    <h3>
     AOF（Append Only File 日志追加持久化）
    </h3>
    <p>
     <strong>
      工作原理
     </strong>
    </p>
    <p>
     AOF默认一般是关闭状态，当AOF启动的时候，redis不再读取 RDB 的内容，手动修改配置文件打开
    </p>
    <p>
     <img alt="" height="370" src="https://i-blog.csdnimg.cn/direct/d12cc263e1874355ae3cb26e24fbef3f.png" width="1081"/>
    </p>
    <blockquote>
     <p>
      引入AOF操作之后，即使既要写内存也要写硬盘，也并没有影响到redis处理请求的速度
     </p>
     <p>
      1、AOF机制并非直接让工作线程把数据写入硬盘，而是先写入一个内存中的缓冲区（因此，如果缓冲区没来得及写入硬盘，也会发生数据丢失），积累一波后，再统一写入硬盘之中，降低写硬盘的次数
     </p>
     <p>
      2、AOF append是每次把新的操作写入原有文件的末尾，属于顺序写入，在硬盘上读写数据，顺序读写速度相对较快，随机访问的速度比较慢
     </p>
    </blockquote>
    <p>
     <strong>
      记录写操作
     </strong>
     ：以
     <strong>
      文本
     </strong>
     日志形式记录
     <strong>
      所有
     </strong>
     写命令（如
     <code>
      SET
     </code>
     、
     <code>
      DEL
     </code>
     ），保存到
     <code>
      appendonly.aof
     </code>
     文件。
    </p>
    <p>
     <strong>
      同步策略
     </strong>
     ：
    </p>
    <p>
     频率越高，数据可靠性越高，性能越低
    </p>
    <ul>
     <li>
      <p>
       <strong>
        always
       </strong>
       ：每次写命令都同步到磁盘（最安全，性能最低）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        everysec
       </strong>
       ：每秒同步一次（默认，平衡安全与性能）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        no
       </strong>
       ：由操作系统决定同步时机（性能最高，风险最大）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      AOF 重写机制
     </strong>
     （Rewrite）：
    </p>
    <ul>
     <li>
      <p>
       解决 AOF 文件膨胀问题。通过生成新 AOF 文件，删除冗余命令（如多次修改同一键，仅保留最终状态）到达给文件瘦身的目的。
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       触发方式：手动执行
       <code>
        BGREWRITEAOF
       </code>
       或根据配置自动触发如
       <code>
        auto-aof-rewrite-percentage 100
       </code>
       表示文件增长 100% 时触发
       <code>
        auto-aof-rewrite-min-size 64mb
       </code>
       表示触发重写时AOF最小文件大小）。
       <img alt="" height="151" src="https://i-blog.csdnimg.cn/direct/4a97de6e0bfc469ea8eef27f6825d4c3.png" width="889"/>
      </p>
     </li>
     <li>
      <p>
       <strong>
        重写流程
       </strong>
       :重写时，不关心aof文件原本有什么，只关心内存中最终的数据状态（此时的状态已经相当于AOF文件结果整理后的摸样）再fork之后，父进程会把新来的请求同时写入两个缓冲区，其中的aof_rewrite_buf缓冲区，专门放fork之后的数据，子进程这边，把aof数据写完之后，会通过信号通知一下进程，父进程会把aof_rewrite_buf缓冲区的内容写进新的AOF文件（父进程同时往旧的AOF文件写数据是因为考虑到极端情况，保证数据的完整性）
      </p>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="338" src="https://i-blog.csdnimg.cn/direct/68ee8a091aa04c378a05ae3530f00f3e.png" width="399"/>
    </p>
    <blockquote>
     <p>
      如果在执行
      <code>
       BGREWRITEAOF
      </code>
      操作时，发现redis已经在进行AOF重写了，此时不会再执行操作而是直接返回，而如果此时redis正在生成RDB快照，aof重写操作就会等待，等待RDB快照生成完毕之后，再执行AOF重写
     </p>
    </blockquote>
    <p>
     <strong>
      优点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        数据更安全
       </strong>
       ：最多丢失 1 秒数据（默认
       <code>
        everysec
       </code>
       策略）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        可读性强
       </strong>
       ：AOF 文件为文本格式，便于人工分析。
      </p>
     </li>
     <li>
      <p>
       <strong>
        灵活恢复
       </strong>
       ：支持修复损坏的 AOF 文件（如使用
       <code>
        redis-check-aof
       </code>
       工具）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        文件体积大
       </strong>
       ：AOF 文件通常比 RDB 大。
      </p>
     </li>
     <li>
      <p>
       <strong>
        恢复速度慢
       </strong>
       ：重放所有命令恢复数据，耗时长。
      </p>
     </li>
     <li>
      <p>
       <strong>
        写性能开销
       </strong>
       ：高频写入场景下，AOF 可能影响吞吐量。
      </p>
     </li>
    </ul>
    <p>
     当redis上同时存在aof文件和rdb快照时，以rdb快照为主
    </p>
    <p class="img-center">
     <img alt="" height="311" src="https://i-blog.csdnimg.cn/direct/2433e95c1c3742389f68b2a124308ef7.png" width="242"/>
    </p>
    <hr/>
    <h3>
     混合持久化（Redis 4.0+）
    </h3>
    <p>
     <strong>
      工作原理
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        结合 RDB 和 AOF
       </strong>
       ：在 AOF 重写时，新生成的 AOF 文件前半部分是 RDB 格式的快照数据，后半部分是增量 AOF 命令。
      </p>
     </li>
     <li>
      <p>
       <strong>
        恢复流程
       </strong>
       ：先加载 RDB 快照，再执行后续 AOF 命令，兼顾速度和数据完整性。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      配置
     </strong>
    </p>
    <pre><code class="language-bash">aof-use-rdb-preamble yes  # 启用混合持久化（需同时启用AOF）</code></pre>
    <p>
     <strong>
      优点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        快速恢复
       </strong>
       ：RDB 快照加速数据加载。
      </p>
     </li>
     <li>
      <p>
       <strong>
        低数据丢失
       </strong>
       ：AOF 记录增量命令，保障数据安全。
      </p>
     </li>
    </ul>
    <hr/>
    <h2>
     二、事务
    </h2>
    <p>
     Redis的事务机制提供了一种将多个命令打包并按顺序执行的途径，但其实现与传统关系型数据库的事务（如ACID特性）有显著差异。以下是对Redis事务的详细解析：
    </p>
    <hr/>
    <h3>
     <strong>
      与传统数据库事务的对比
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         特性
        </strong>
       </th>
       <th>
        <strong>
         Redis事务
        </strong>
       </th>
       <th>
        <strong>
         传统数据库（如MySQL）
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         原子性
        </strong>
       </td>
       <td>
        部分保证（运行时错误不中断）
       </td>
       <td>
        完全保证（ACID）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         隔离性
        </strong>
       </td>
       <td>
        不涉及隔离性，单线程保证指令操作
        <strong>
         串行化
        </strong>
        执行
       </td>
       <td>
        支持多种隔离级别（如读提交、可重复读）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         回滚机制
        </strong>
       </td>
       <td>
        不支持
       </td>
       <td>
        支持通过ROLLBACK回滚
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         错误处理
        </strong>
       </td>
       <td>
        分语法错误（拒绝执行）和运行时错误（继续执行）
       </td>
       <td>
        事务内错误触发回滚
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      原子性
     </strong>
     ：Redis事务的原子性较
     <strong>
      弱
     </strong>
     。命令队列在
     <code>
      EXEC
     </code>
     时整体执行（中途不会穿插其他命令），但运行时错误不会回滚。
    </p>
    <p>
     <strong>
      隔离性
     </strong>
     ：由于Redis单线程模型，事务执行期间不会被其他命令打断，具备隔离性（类似可串行化）。
    </p>
    <p>
     <strong>
      无回滚机制
     </strong>
     ：设计哲学追求
     <strong>
      简单高效
     </strong>
     ，故不支持回滚，需开发者自行处理错误。
    </p>
    <blockquote>
     <p>
      提到Redis的原子性是存在争议的，由于MySQL存在回滚，他能保证多个操作打包在一起，要不全都执行
      <strong>
       成功，
      </strong>
      要么全都不执行，当事务中存在操作执行失败，进行回滚。而Redis只能保证将多个操作按事务的方式执行，如果出现失败也不会发生回滚的操作。所以存在说法Redis不具备原子性
     </p>
    </blockquote>
    <p>
     <strong>
      基本命令
     </strong>
    </p>
    <p>
     Redis事务通过以下命令管理：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        MULTI
       </strong>
       ：开启事务，之后的命令被放入队列，直到执行EXEC或DISCARD。
      </p>
     </li>
     <li>
      <p>
       <strong>
        EXEC
       </strong>
       ：执行事务队列中的所有命令。
      </p>
     </li>
     <li>
      <p>
       <strong>
        DISCARD
       </strong>
       ：取消事务，清空队列中的命令。（若开启事务,发生服务器的重启，效果等同于discard）
      </p>
     </li>
     <li>
      <p>
       <strong>
        WATCH
       </strong>
       ：监视一个或多个键，用于实现
       <strong>
        乐观锁
       </strong>
       （CAS操作）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        UNWATCH
       </strong>
       ：取消对所有键的监视。
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="148" src="https://i-blog.csdnimg.cn/direct/f834a15a766f444dbf11985d395b859a.png" width="436"/>
    </p>
    <p>
     <strong>
      示例流程
     </strong>
     ：
    </p>
    <pre><code class="language-bash">&gt; WATCH key1       # 监视键key1
&gt; MULTI            # 开启事务
&gt; SET key1 value1  # 命令入队
&gt; GET key1         # 命令入队
&gt; EXEC             # 执行事务</code></pre>
    <p>
     若在
     <code>
      WATCH
     </code>
     后
     <code>
      EXEC
     </code>
     前，
     <code>
      key1
     </code>
     被其他客户端修改，事务将失败，返回
     <code>
      (nil)
     </code>
     。
    </p>
    <hr/>
    <h3 style="background-color:transparent">
     <strong>
      WATCH与乐观锁
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：
       <code>
        WATCH
       </code>
       监视键，若事务执行前这些键被修改，事务将失败。需结合重试机制实现乐观锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        典型应用场景
       </strong>
       ：余额扣减。
      </p>
     </li>
    </ul>
    <p>
     乐观锁预期锁冲突概率低，假设在大多数情况下，并发操作不会发生冲突，只有在更新数据时才去检查是否有冲突。就好像它总是乐观地认为大家都能 “和平共处”，不会出现数据争抢的情况。
    </p>
    <p>
     <strong>
      客户端调用
      <code>
       WATCH
      </code>
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       例如
       <code>
        WATCH balance
       </code>
       ，客户端将
       <code>
        balance
       </code>
       的当前版本号保存到自己的监视列表中。
      </p>
     </li>
     <li>
      <p>
       Redis 服务端会将该客户端加入
       <code>
        balance
       </code>
       键的
       <strong>
        监视者列表
       </strong>
       （一个链表结构，记录所有监视该键的客户端）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      客户端开启事务（
      <code>
       MULTI
      </code>
      ）
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       后续所有命令会缓存在事务队列中，但不会立即执行。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      其他客户端的操作
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       如果在事务提交前，其他客户端修改了
       <code>
        balance
       </code>
       （如
       <code>
        SET balance 100
       </code>
       ），
       <code>
        balance
       </code>
       的版本号会递增。
      </p>
     </li>
     <li>
      <p>
       Redis 会遍历
       <code>
        balance
       </code>
       的监视者列表，标记所有监视该键的客户端的事务为
       <strong>
        失效
       </strong>
       （即事务提交时会失败）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      客户端提交事务（
      <code>
       EXEC
      </code>
      ）
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       校验阶段：Redis 检查该客户端所有
       <code>
        WATCH
       </code>
       的键的当前版本号是否与最初记录的版本号一致。
      </p>
      <ul>
       <li>
        <p>
         一致：执行事务队列中的命令，更新键的版本号，并返回所有命令的结果。
        </p>
       </li>
       <li>
        <p>
         不一致：直接放弃事务，返回
         <code>
          nil
         </code>
         （事务失败）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      这样的设定思想有点类似于CAS里面的ABA问题
     </p>
    </blockquote>
    <hr/>
    <blockquote>
     <p>
      烈火试真金，逆境试强者。--塞内加
     </p>
    </blockquote>
    <p>
     🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀
    </p>
    <p>
     以上，就是本期的全部内容啦，若有错误疏忽希望各位大佬及时指出💐
    </p>
    <p>
     制作不易，希望能对各位提供微小的帮助，可否留下你免费的赞呢🌸
    </p>
    <h4>
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37393830363035362f:61727469636c652f64657461696c732f313436303736323733" class_="artid" style="display:none">
 </p>
</div>


