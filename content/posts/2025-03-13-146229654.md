---
layout: post
title: "数据结构-哈夫曼树以及其应用"
date: 2025-03-13 14:45:57 +0800
description: "哈夫曼树（Huffman Tree）是一种，常用于数据压缩和最优前缀编码。其目标是使得。在信息论和计算机科学中，哈夫曼编码是一种，用于构造哈夫曼树，以实现。"
keywords: "【数据结构】-哈夫曼树以及其应用"
categories: ['未分类']
tags: ['霍夫曼树', '数据结构', '数据压缩']
artid: "146229654"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146229654
    alt: "数据结构-哈夫曼树以及其应用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146229654
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146229654
cover: https://bing.ee123.net/img/rand?artid=146229654
image: https://bing.ee123.net/img/rand?artid=146229654
img: https://bing.ee123.net/img/rand?artid=146229654
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【数据结构】-哈夫曼树以及其应用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Huffman_Tree_0">
     </a>
     哈夫曼树（Huffman Tree）
    </h2>
    <h3>
     <a id="1__2">
     </a>
     1. 哈夫曼树的定义
    </h3>
    <p>
     哈夫曼树（Huffman Tree）是一种
     <strong>
      带权路径长度最短的二叉树
     </strong>
     ，常用于数据压缩和最优前缀编码。其目标是使得
     <strong>
      带权路径长度（WPL）最小
     </strong>
     。
    </p>
    <p>
     在信息论和计算机科学中，哈夫曼编码是一种
     <strong>
      贪心算法
     </strong>
     ，用于构造哈夫曼树，以实现
     <strong>
      最优前缀编码
     </strong>
     。
    </p>
    <h3>
     <a id="2__8">
     </a>
     2. 哈夫曼树的构造步骤
    </h3>
    <p>
     构造哈夫曼树的基本思想是
     <strong>
      每次选择当前权值最小的两个节点合并，形成新的节点，并重复该过程
     </strong>
     ，直到形成一棵树。
    </p>
    <h4>
     <a id="_1_12">
     </a>
     <strong>
      步骤 1：确定权值
     </strong>
    </h4>
    <p>
     假设有如下字符及其权重（频率）：
    </p>
    <pre><code>A(5)  B(9)  C(12)  D(13)  E(16)  F(45)
</code></pre>
    <h4>
     <a id="_2_20">
     </a>
     <strong>
      步骤 2：构造哈夫曼树
     </strong>
    </h4>
    <p>
     按照如下过程构造哈夫曼树：
    </p>
    <ol>
     <li>
      选取权值最小的两个节点
      <code>
       A(5)
      </code>
      和
      <code>
       B(9)
      </code>
      ，合并形成新节点
      <code>
       AB(14)
      </code>
      。
     </li>
     <li>
      选取权值最小的两个节点
      <code>
       C(12)
      </code>
      和
      <code>
       D(13)
      </code>
      ，合并形成新节点
      <code>
       CD(25)
      </code>
      。
     </li>
     <li>
      选取权值最小的两个节点
      <code>
       AB(14)
      </code>
      和
      <code>
       E(16)
      </code>
      ，合并形成新节点
      <code>
       ABE(30)
      </code>
      。
     </li>
     <li>
      选取权值最小的两个节点
      <code>
       CD(25)
      </code>
      和
      <code>
       ABE(30)
      </code>
      ，合并形成新节点
      <code>
       CDEAB(55)
      </code>
      。
     </li>
     <li>
      选取最后两个节点
      <code>
       CDEAB(55)
      </code>
      和
      <code>
       F(45)
      </code>
      ，合并形成最终的哈夫曼树
      <code>
       Root(100)
      </code>
      。
     </li>
    </ol>
    <h4>
     <a id="_3_30">
     </a>
     <strong>
      步骤 3：生成哈夫曼树
     </strong>
    </h4>
    <p>
     最终形成的哈夫曼树如下：
    </p>
    <pre><code>         (100)
        /      \
     F(45)     (55)
              /     \
           (25)     (30)
          /    \    /    \
       C(12) D(13) (14) E(16)
                 /    \
              A(5)   B(9)
</code></pre>
    <h3>
     <a id="3__46">
     </a>
     3. 哈夫曼编码
    </h3>
    <p>
     使用哈夫曼树生成哈夫曼编码：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        字符
       </th>
       <th>
        编码
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        A
       </td>
       <td>
        1100
       </td>
      </tr>
      <tr>
       <td>
        B
       </td>
       <td>
        1101
       </td>
      </tr>
      <tr>
       <td>
        C
       </td>
       <td>
        100
       </td>
      </tr>
      <tr>
       <td>
        D
       </td>
       <td>
        101
       </td>
      </tr>
      <tr>
       <td>
        E
       </td>
       <td>
        111
       </td>
      </tr>
      <tr>
       <td>
        F
       </td>
       <td>
        0
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     哈夫曼编码的特点：
    </p>
    <ul>
     <li>
      <strong>
       前缀编码
      </strong>
      ：任何一个编码都不是另一个编码的前缀。
     </li>
     <li>
      <strong>
       变长编码
      </strong>
      ：高频字符使用短编码，低频字符使用长编码。
     </li>
    </ul>
    <h3>
     <a id="4_C__64">
     </a>
     4. C 语言实现
    </h3>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Node<span class="token punctuation">;</span>

Node<span class="token operator">*</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Node<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printHuffmanTree</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> code<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        code<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c: %s\n"</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> code<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span> <span class="token function">printHuffmanTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> code<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> code<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'1'</span><span class="token punctuation">;</span> <span class="token function">printHuffmanTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> code<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="5__95">
     </a>
     5. 哈夫曼树的性质
    </h3>
    <p>
     哈夫曼树具有以下重要性质：
    </p>
    <ol>
     <li>
      <strong>
       最优性
      </strong>
      ：哈夫曼树保证了最短的带权路径长度（WPL），即它是最优二叉树。
     </li>
     <li>
      <strong>
       唯一性
      </strong>
      ：给定相同的权值集合，构造的哈夫曼树是唯一的（可能存在等权子树的不同组合）。
     </li>
     <li>
      <strong>
       前缀编码
      </strong>
      ：哈夫曼编码不含有歧义，因为不会出现某个编码是另一个编码的前缀。
     </li>
     <li>
      <strong>
       贪心策略
      </strong>
      ：哈夫曼算法使用贪心策略，每次合并权值最小的两个节点，确保局部最优，从而达到全局最优。
     </li>
    </ol>
    <h3>
     <a id="6__104">
     </a>
     6. 哈夫曼树的应用
    </h3>
    <p>
     哈夫曼树广泛应用于
     <strong>
      数据压缩、最优前缀编码、图像和音频压缩
     </strong>
     等场景。
    </p>
    <ul>
     <li>
      <strong>
       数据压缩
      </strong>
      ：如 ZIP、PNG、MP3 等使用哈夫曼编码减少存储空间。
     </li>
     <li>
      <strong>
       信息编码
      </strong>
      ：在通信系统中，哈夫曼编码可用于最优数据传输。
     </li>
     <li>
      <strong>
       霍夫曼解码
      </strong>
      ：使用哈夫曼树可以有效地解码压缩数据。
     </li>
     <li>
      <strong>
       网络传输
      </strong>
      ：在数据传输过程中，哈夫曼编码减少了带宽消耗，提高传输效率。
     </li>
     <li>
      <strong>
       AI 和机器学习
      </strong>
      ：在特征编码、模式识别等领域，哈夫曼树也被广泛应用。
     </li>
    </ul>
    <h2>
     <a id="_116">
     </a>
     哈夫曼编码进行数据压缩的具体细节
    </h2>
    <p>
     哈夫曼编码用于
     <strong>
      数据压缩
     </strong>
     的核心思想是利用
     <strong>
      变长编码
     </strong>
     来减少数据存储空间，高频字符用
     <strong>
      短编码
     </strong>
     ，低频字符用
     <strong>
      长编码
     </strong>
     ，从而降低平均编码长度。以下是具体细节：
    </p>
    <hr/>
    <h3>
     <a id="1__122">
     </a>
     <strong>
      1. 哈夫曼编码压缩的基本流程
     </strong>
    </h3>
    <p>
     哈夫曼编码压缩数据的流程主要包括
     <strong>
      构造哈夫曼树、生成哈夫曼编码、编码数据、存储或传输、解码数据
     </strong>
     等步骤。
    </p>
    <h4>
     <a id="1_125">
     </a>
     <strong>
      （1）统计字符频率
     </strong>
    </h4>
    <p>
     在进行压缩前，首先统计输入数据中各字符的出现次数。例如，对于字符串
     <code>
      ABRACADABRA
     </code>
     ，统计出现频率如下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        字符
       </th>
       <th>
        频率
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        A
       </td>
       <td>
        5
       </td>
      </tr>
      <tr>
       <td>
        B
       </td>
       <td>
        2
       </td>
      </tr>
      <tr>
       <td>
        R
       </td>
       <td>
        2
       </td>
      </tr>
      <tr>
       <td>
        C
       </td>
       <td>
        1
       </td>
      </tr>
      <tr>
       <td>
        D
       </td>
       <td>
        1
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="2_138">
     </a>
     <strong>
      （2）构造哈夫曼树
     </strong>
    </h4>
    <ol>
     <li>
      将所有字符按照频率构建成
      <strong>
       叶子节点
      </strong>
      。
     </li>
     <li>
      选取频率最小的两个节点合并为一个新节点，并将其频率设为两个子节点的频率之和。
     </li>
     <li>
      重复该过程，直到所有节点合并成一棵完整的二叉树。
     </li>
    </ol>
    <p>
     示例（简化版）哈夫曼树：
    </p>
    <pre><code>        (11)
       /    \
     A(5)   (6)
          /     \
        B(2)    (4)
              /     \
            R(2)   (2)
                  /    \
                C(1)   D(1)
</code></pre>
    <hr/>
    <h4>
     <a id="3_159">
     </a>
     <strong>
      （3）生成哈夫曼编码
     </strong>
    </h4>
    <p>
     按照哈夫曼树，给左子树赋
     <code>
      0
     </code>
     ，右子树赋
     <code>
      1
     </code>
     ，得到各字符的编码：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        字符
       </th>
       <th>
        哈夫曼编码
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        A
       </td>
       <td>
        0
       </td>
      </tr>
      <tr>
       <td>
        B
       </td>
       <td>
        10
       </td>
      </tr>
      <tr>
       <td>
        R
       </td>
       <td>
        110
       </td>
      </tr>
      <tr>
       <td>
        C
       </td>
       <td>
        1110
       </td>
      </tr>
      <tr>
       <td>
        D
       </td>
       <td>
        1111
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="4_172">
     </a>
     <strong>
      （4）编码数据
     </strong>
    </h4>
    <p>
     将输入数据转换为哈夫曼编码。例如：
    </p>
    <pre><code>原始字符串: ABRACADABRA
哈夫曼编码: 0 10 110 0 1110 0 1111 0 10 110 0
</code></pre>
    <p>
     假设原始数据每个字符占
     <strong>
      8-bit
     </strong>
     ，共
     <strong>
      11 个字符
     </strong>
     ，总共
     <strong>
      88-bit
     </strong>
     。
     <br/>
     哈夫曼编码后，压缩后数据长度为
     <strong>
      26-bit
     </strong>
     ，压缩率 =
     <strong>
      26/88 ≈ 29.5%
     </strong>
     ，大大减少了存储空间。
    </p>
    <hr/>
    <h4>
     <a id="5_185">
     </a>
     <strong>
      （5）存储或传输压缩数据
     </strong>
    </h4>
    <p>
     编码后的数据需要存储或传输。由于哈夫曼编码是
     <strong>
      变长编码
     </strong>
     ，解码时需要哈夫曼树，因此通常会
     <strong>
      存储哈夫曼树结构
     </strong>
     或者
     <strong>
      编码表
     </strong>
     ，以便解码。
    </p>
    <hr/>
    <h3>
     <a id="2__190">
     </a>
     <strong>
      2. 哈夫曼解码的过程
     </strong>
    </h3>
    <p>
     解码时，只需要从
     <strong>
      哈夫曼树根节点
     </strong>
     出发，按
     <strong>
      二进制流
     </strong>
     遍历，遇到叶子节点时即可确定对应字符。例如，解码
     <code>
      01011001110
     </code>
     ：
    </p>
    <pre><code>0    -&gt; A  
10   -&gt; B  
110  -&gt; R  
0    -&gt; A  
1110 -&gt; C  
</code></pre>
    <p>
     还原出的字符串为
     <code>
      ABRAC
     </code>
     。
    </p>
    <hr/>
    <h3>
     <a id="3__204">
     </a>
     <strong>
      3. 哈夫曼编码在数据压缩中的应用
     </strong>
    </h3>
    <p>
     哈夫曼编码在实际应用中广泛用于无损数据压缩，包括：
    </p>
    <ul>
     <li>
      <strong>
       文件压缩
      </strong>
      ：ZIP、RAR 使用哈夫曼编码作为部分压缩算法。
     </li>
     <li>
      <strong>
       图片压缩
      </strong>
      ：PNG 使用哈夫曼编码进行无损压缩。
     </li>
     <li>
      <strong>
       音频压缩
      </strong>
      ：MP3、FLAC 采用哈夫曼编码减少数据存储量。
     </li>
     <li>
      <strong>
       视频编码
      </strong>
      ：H.264、JPEG 使用哈夫曼编码压缩像素信息。
     </li>
     <li>
      <strong>
       网络传输
      </strong>
      ：HTTP/2 采用 HPACK 算法，其中使用哈夫曼编码来压缩头部数据，提高传输效率。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="4__215">
     </a>
     <strong>
      4. 哈夫曼编码数据压缩的优缺点
     </strong>
    </h3>
    <h4>
     <a id="_216">
     </a>
     <strong>
      优点：
     </strong>
    </h4>
    <p>
     ✔
     <strong>
      最优前缀编码
     </strong>
     ，不会产生歧义。
     <br/>
     ✔
     <strong>
      无损压缩
     </strong>
     ，数据不会损坏或丢失。
     <br/>
     ✔
     <strong>
      动态适应不同字符频率
     </strong>
     ，比固定长度编码更高效。
    </p>
    <h4>
     <a id="_221">
     </a>
     <strong>
      缺点：
     </strong>
    </h4>
    <p>
     ❌ 需要
     <strong>
      存储哈夫曼树
     </strong>
     ，否则无法解码。
     <br/>
     ❌ 如果字符频率差别不大，压缩效果不明显（如均匀分布的 ASCII 文本）。
     <br/>
     ❌
     <strong>
      编码和解码速度相对较慢
     </strong>
     ，尤其是在大规模数据上。
    </p>
    <hr/>
    <h3>
     <a id="5__228">
     </a>
     <strong>
      5. 结论
     </strong>
    </h3>
    <p>
     哈夫曼编码是一种高效的
     <strong>
      无损压缩
     </strong>
     算法，在文件、图片、音视频等领域被广泛使用。其
     <strong>
      核心原理是贪心策略构造最优前缀编码
     </strong>
     ，使高频数据占用更少存储空间，提高压缩效率。然而，在某些均匀分布的数据集中，其压缩率可能不如更先进的算法（如 LZ77、LZ78 或 BWT 压缩）。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35333136323237392f:61727469636c652f64657461696c732f313436323239363534" class_="artid" style="display:none">
 </p>
</div>


