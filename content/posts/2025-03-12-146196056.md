---
layout: post
title: "flutter-如何与原生框架通讯安卓-和-ios-"
date: 2025-03-12 09:20:01 +0800
description: "1. 打开 `android/app/src/main/kotlin/com/example/your_app/MainActivity.kt`（或 `.java` 文件）。在上面的代码中，我们创建了一个名为 `com.example/native` 的通道，并定义了一个方法 `getNativeData`，它将调用原生代码。在 Flutter 中，平台通道的调用是异步的，因此您可以使用 `Future` 和 `async/await` 来处理结果。首先，在 Flutter 项目中创建一个平台通道。"
keywords: "flutter 如何与原生框架通讯安卓 和 ios "
categories: ['未分类']
tags: ['Flutter', 'Flutter']
artid: "146196056"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146196056
    alt: "flutter-如何与原生框架通讯安卓-和-ios-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146196056
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146196056
cover: https://bing.ee123.net/img/rand?artid=146196056
image: https://bing.ee123.net/img/rand?artid=146196056
img: https://bing.ee123.net/img/rand?artid=146196056
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     flutter 如何与原生框架通讯安卓 和 ios
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Flutter 中与原生框架（Android 和 iOS）进行通信的主要方式是通过 **平台通道（Platform Channels）**。平台通道允许 Flutter 代码与原生代码进行双向通信。以下是详细的步骤和示例，说明如何在 Flutter 中与 Android 和 iOS 原生代码进行通信。
    </p>
    <p>
     ### 1. 平台通道的基本概念
    </p>
    <p>
     平台通道是 Flutter 提供的一种机制，允许 Dart 代码与原生代码（Java/Kotlin for Android 和 Objective-C/Swift for iOS）进行交互。通过平台通道，您可以发送消息并接收响应。
    </p>
    <p>
     ### 2. 创建平台通道
    </p>
    <p>
     #### 2.1 在 Flutter 中创建平台通道
    </p>
    <p>
     首先，在 Flutter 项目中创建一个平台通道。您可以在 Dart 代码中使用 `MethodChannel` 来实现。
    </p>
    <p>
     ```dart
     <br/>
     import 'package:flutter/services.dart';
    </p>
    <p>
     class NativeCommunication {
     <!-- -->
     <br/>
     static const MethodChannel _channel = MethodChannel('com.example/native');
    </p>
    <p>
     // 调用原生方法
     <br/>
     Future&lt;String&gt; getNativeData() async {
     <!-- -->
     <br/>
     final String result = await _channel.invokeMethod('getNativeData');
     <br/>
     return result;
     <br/>
     }
     <br/>
     }
     <br/>
     ```
    </p>
    <p>
     在上面的代码中，我们创建了一个名为 `com.example/native` 的通道，并定义了一个方法 `getNativeData`，它将调用原生代码。
    </p>
    <p>
     #### 2.2 在 Android 中实现原生代码
    </p>
    <p>
     在 Android 项目中，您需要在 `MainActivity` 中实现与 Flutter 的通信。
    </p>
    <p>
     1. 打开 `android/app/src/main/kotlin/com/example/your_app/MainActivity.kt`（或 `.java` 文件）。
     <br/>
     2. 在 `MainActivity` 中添加以下代码：
    </p>
    <p>
     ```kotlin
     <br/>
     package com.example.your_app
    </p>
    <p>
     import android.os.Bundle
     <br/>
     import io.flutter.embedding.android.FlutterActivity
     <br/>
     import io.flutter.plugin.common.MethodChannel
    </p>
    <p>
     class MainActivity: FlutterActivity() {
     <!-- -->
     <br/>
     private val CHANNEL = "com.example/native"
    </p>
    <p>
     override fun onCreate(savedInstanceState: Bundle?) {
     <!-- -->
     <br/>
     super.onCreate(savedInstanceState)
    </p>
    <p>
     MethodChannel(flutterEngine?.dartExecutor?.binaryMessenger, CHANNEL).setMethodCallHandler {
     <!-- -->
     <br/>
     call, result -&gt;
     <br/>
     if (call.method == "getNativeData") {
     <!-- -->
     <br/>
     val nativeData = getNativeData() // 调用原生方法
     <br/>
     result.success(nativeData) // 返回结果
     <br/>
     } else {
     <!-- -->
     <br/>
     result.notImplemented() // 方法未实现
     <br/>
     }
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     private fun getNativeData(): String {
     <!-- -->
     <br/>
     return "Hello from Android!" // 返回原生数据
     <br/>
     }
     <br/>
     }
     <br/>
     ```
    </p>
    <p>
     在上面的代码中，我们创建了一个 `MethodChannel`，并在 `onCreate` 方法中设置了一个方法调用处理程序。当 Flutter 调用 `getNativeData` 方法时，我们将返回一个字符串。
    </p>
    <p>
     #### 2.3 在 iOS 中实现原生代码
    </p>
    <p>
     在 iOS 项目中，您需要在 `AppDelegate` 中实现与 Flutter 的通信。
    </p>
    <p>
     1. 打开 `ios/Runner/AppDelegate.swift`。
     <br/>
     2. 在 `AppDelegate` 中添加以下代码：
    </p>
    <p>
     ```swift
     <br/>
     import UIKit
     <br/>
     import Flutter
    </p>
    <p>
     @UIApplicationMain
     <br/>
     class AppDelegate: FlutterAppDelegate {
     <!-- -->
     <br/>
     override func application(
     <br/>
     _ application: UIApplication,
     <br/>
     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
     <br/>
     ) -&gt; Bool {
     <!-- -->
     <br/>
     let controller: FlutterViewController = window?.rootViewController as! FlutterViewController
     <br/>
     let channel = FlutterMethodChannel(name: "com.example/native",
     <br/>
     binaryMessenger: controller.binaryMessenger)
    </p>
    <p>
     channel.setMethodCallHandler { (call, result) in
     <br/>
     if call.method == "getNativeData" {
     <!-- -->
     <br/>
     let nativeData = self.getNativeData() // 调用原生方法
     <br/>
     result(nativeData) // 返回结果
     <br/>
     } else {
     <!-- -->
     <br/>
     result(FlutterMethodNotImplemented) // 方法未实现
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     return super.application(application, didFinishLaunchingWithOptions: launchOptions)
     <br/>
     }
    </p>
    <p>
     private func getNativeData() -&gt; String {
     <!-- -->
     <br/>
     return "Hello from iOS!" // 返回原生数据
     <br/>
     }
     <br/>
     }
     <br/>
     ```
    </p>
    <p>
     在上面的代码中，我们创建了一个 `FlutterMethodChannel`，并在 `setMethodCallHandler` 中处理 Flutter 的方法调用。
    </p>
    <p>
     ### 3. 使用平台通道
    </p>
    <p>
     现在，您可以在 Flutter 中调用原生代码并获取结果。
    </p>
    <p>
     ```dart
     <br/>
     import 'package:flutter/material.dart';
    </p>
    <p>
     void main() {
     <!-- -->
     <br/>
     runApp(MyApp());
     <br/>
     }
    </p>
    <p>
     class MyApp extends StatelessWidget {
     <!-- -->
     <br/>
     @override
     <br/>
     Widget build(BuildContext context) {
     <!-- -->
     <br/>
     return MaterialApp(
     <br/>
     home: Scaffold(
     <br/>
     appBar: AppBar(title: Text('Flutter Native Communication')),
     <br/>
     body: Center(
     <br/>
     child: FutureBuilder&lt;String&gt;(
     <br/>
     future: NativeCommunication().getNativeData(),
     <br/>
     builder: (context, snapshot) {
     <!-- -->
     <br/>
     if (snapshot.connectionState == ConnectionState.waiting) {
     <!-- -->
     <br/>
     return CircularProgressIndicator();
     <br/>
     } else if (snapshot.hasError) {
     <!-- -->
     <br/>
     return Text('Error: ${snapshot.error}');
     <br/>
     } else {
     <!-- -->
     <br/>
     return Text('Native Data: ${snapshot.data}');
     <br/>
     }
     <br/>
     },
     <br/>
     ),
     <br/>
     ),
     <br/>
     ),
     <br/>
     );
     <br/>
     }
     <br/>
     }
     <br/>
     ```
    </p>
    <p>
     ### 4. 处理异步通信
    </p>
    <p>
     在 Flutter 中，平台通道的调用是异步的，因此您可以使用 `Future` 和 `async/await` 来处理结果。
    </p>
    <p>
     ### 5. 发送参数到原生代码
    </p>
    <p>
     如果您需要将参数发送到原生代码，可以在 `invokeMethod` 中传递参数。例如：
    </p>
    <p>
     ```dart
     <br/>
     Future&lt;String&gt; sendDataToNative(String data) async {
     <!-- -->
     <br/>
     final String result = await _channel.invokeMethod('sendData', {'data': data});
     <br/>
     return result;
     <br/>
     }
     <br/>
     ```
    </p>
    <p>
     在 Android 和 iOS 中，您可以通过 `call.arguments` 获取传递的参数。
    </p>
    <p>
     ### 6. 处理返回值
    </p>
    <p>
     在原生代码中，您可以通过 `result.success()` 或 `result.error()` 返回结果或错误。
    </p>
    <p>
     ### 7. 处理错误
    </p>
    <p>
     确保在 Dart 代码中处理可能的错误，例如：
    </p>
    <p>
     ```dart
     <br/>
     try {
     <!-- -->
     <br/>
     final String result = await NativeCommunication().getNativeData();
     <br/>
     print(result);
     <br/>
     } catch (e) {
     <!-- -->
     <br/>
     print('Error: $e');
     <br/>
     }
     <br/>
     ```
    </p>
    <p>
     ### 8. 其他通信方式
    </p>
    <p>
     除了 `MethodChannel`，Flutter 还支持其他类型的通道：
    </p>
    <p>
     - **EventChannel**：用于从原生代码向 Flutter 发送事件流。
     <br/>
     - **BasicMessageChannel**：用于发送简单的消息。
    </p>
    <p>
     ### 9. 总结
    </p>
    <p>
     通过平台通道，Flutter 可以轻松地与 Android 和 iOS 原生代码进行通信。您可以使用 `MethodChannel` 进行方法调用，使用 `EventChannel` 处理事件流，使用 `BasicMessageChannel` 发送简单消息。通过这些机制，您可以充分利用原生平台的功能，同时保持 Flutter 的灵活性和高效性。
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7a68616e67796968753332312f:61727469636c652f64657461696c732f313436313936303536" class_="artid" style="display:none">
 </p>
</div>


