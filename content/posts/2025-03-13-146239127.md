---
layout: post
title: "MOEFeedForward-模块"
date: 2025-03-13 18:40:11 +0800
description: "这是一个典型的 MoE（Mixture of Experts）实现，用于大型语言模型中提高模型容量和计算效率。包含多个专家（FeedForward）和一个门控网络（MoEGate）"
keywords: "MOEFeedForward 模块"
categories: ['深度学习模块']
tags: ['深度学习', 'Pytorch', 'Python']
artid: "146239127"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146239127
    alt: "MOEFeedForward-模块"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146239127
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146239127
cover: https://bing.ee123.net/img/rand?artid=146239127
image: https://bing.ee123.net/img/rand?artid=146239127
img: https://bing.ee123.net/img/rand?artid=146239127
---

# MOEFeedForward 模块
### 代码
class FeedForward(nn.Module):
def \_\_init\_\_(self, config: LMConfig):
super().\_\_init\_\_()
if config.hidden\_dim is None:
hidden\_dim = 4 \* config.dim
hidden\_dim = int(2 \* hidden\_dim / 3)
config.hidden\_dim = config.multiple\_of \* ((hidden\_dim + config.multiple\_of - 1) // config.multiple\_of)
self.w1 = nn.Linear(config.dim, config.hidden\_dim, bias=False)
self.w2 = nn.Linear(config.hidden\_dim, config.dim, bias=False)
self.w3 = nn.Linear(config.dim, config.hidden\_dim, bias=False)
self.dropout = nn.Dropout(config.dropout)
def forward(self, x):
return self.dropout(self.w2(F.silu(self.w1(x)) \* self.w3(x)))
class MoEGate(nn.Module):
def \_\_init\_\_(self, config: LMConfig):
super().\_\_init\_\_()
self.config = config
self.top\_k = config.num\_experts\_per\_tok
self.n\_routed\_experts = config.n\_routed\_experts
self.scoring\_func = config.scoring\_func
self.alpha = config.aux\_loss\_alpha
self.seq\_aux = config.seq\_aux
self.norm\_topk\_prob = config.norm\_topk\_prob
self.gating\_dim = config.dim
self.weight = nn.Parameter(torch.empty((self.n\_routed\_experts, self.gating\_dim)))
self.reset\_parameters()
def reset\_parameters(self) -> None:
import torch.nn.init as init
init.kaiming\_uniform\_(self.weight, a=math.sqrt(5))
def forward(self, hidden\_states):
bsz, seq\_len, h = hidden\_states.shape
hidden\_states = hidden\_states.view(-1, h)
logits = F.linear(hidden\_states, self.weight, None)
if self.scoring\_func == 'softmax':
scores = logits.softmax(dim=-1)
else:
raise NotImplementedError(f'insupportable scoring function for MoE gating: {self.scoring\_func}')
topk\_weight, topk\_idx = torch.topk(scores, k=self.top\_k, dim=-1, sorted=False)
if self.top\_k > 1 and self.norm\_topk\_prob:
denominator = topk\_weight.sum(dim=-1, keepdim=True) + 1e-20
topk\_weight = topk\_weight / denominator
if self.training and self.alpha > 0.0:
scores\_for\_aux = scores
aux\_topk = self.top\_k
topk\_idx\_for\_aux\_loss = topk\_idx.view(bsz, -1)
if self.seq\_aux:
scores\_for\_seq\_aux = scores\_for\_aux.view(bsz, seq\_len, -1)
ce = torch.zeros(bsz, self.n\_routed\_experts, device=hidden\_states.device)
ce.scatter\_add\_(1, topk\_idx\_for\_aux\_loss,
torch.ones(bsz, seq\_len \* aux\_topk, device=hidden\_states.device)).div\_(
seq\_len \* aux\_topk / self.n\_routed\_experts)
aux\_loss = (ce \* scores\_for\_seq\_aux.mean(dim=1)).sum(dim=1).mean() \* self.alpha
else:
mask\_ce = F.one\_hot(topk\_idx\_for\_aux\_loss.view(-1), num\_classes=self.n\_routed\_experts)
ce = mask\_ce.float().mean(0)
Pi = scores\_for\_aux.mean(0)
fi = ce \* self.n\_routed\_experts
aux\_loss = (Pi \* fi).sum() \* self.alpha
else:
aux\_loss = 0
return topk\_idx, topk\_weight, aux\_loss
class MOEFeedForward(nn.Module):
def \_\_init\_\_(self, config: LMConfig):
super().\_\_init\_\_()
self.config = config
self.experts = nn.ModuleList([
FeedForward(config)
for \_ in range(config.n\_routed\_experts)
])
self.gate = MoEGate(config)
if config.n\_shared\_experts is not None:
self.shared\_experts = FeedForward(config)
def forward(self, x):
identity = x
orig\_shape = x.shape
bsz, seq\_len, \_ = x.shape
# 使用门控机制选择专家
topk\_idx, topk\_weight, aux\_loss = self.gate(x)
x = x.view(-1, x.shape[-1])
flat\_topk\_idx = topk\_idx.view(-1)
if self.training:
# 训练模式下，重复输入数据
x = x.repeat\_interleave(self.config.num\_experts\_per\_tok, dim=0)
y = torch.empty\_like(x, dtype=torch.float16)
for i, expert in enumerate(self.experts):
y[flat\_topk\_idx == i] = expert(x[flat\_topk\_idx == i]).to(y.dtype) # 确保类型一致
y = (y.view(\*topk\_weight.shape, -1) \* topk\_weight.unsqueeze(-1)).sum(dim=1)
y = y.view(\*orig\_shape)
else:
# 推理模式下，只选择最优专家
y = self.moe\_infer(x, flat\_topk\_idx, topk\_weight.view(-1, 1)).view(\*orig\_shape)
if self.config.n\_shared\_experts is not None:
y = y + self.shared\_experts(identity)
self.aux\_loss = aux\_loss
return y
@torch.no\_grad()
def moe\_infer(self, x, flat\_expert\_indices, flat\_expert\_weights):
expert\_cache = torch.zeros\_like(x)
idxs = flat\_expert\_indices.argsort()
tokens\_per\_expert = flat\_expert\_indices.bincount().cpu().numpy().cumsum(0)
token\_idxs = idxs // self.config.num\_experts\_per\_tok
# 例如当tokens\_per\_expert=[6, 15, 20, 26, 33, 38, 46, 52]
# 当token\_idxs=[3, 7, 19, 21, 24, 25, 4, 5, 6, 10, 11, 12...]
# 意味着当token\_idxs[:6] -> [3, 7, 19, 21, 24, 25, 4]位置的token都由专家0处理，token\_idxs[6:15]位置的token都由专家1处理......
for i, end\_idx in enumerate(tokens\_per\_expert):
start\_idx = 0 if i == 0 else tokens\_per\_expert[i - 1]
if start\_idx == end\_idx:
continue
expert = self.experts[i]
exp\_token\_idx = token\_idxs[start\_idx:end\_idx]
expert\_tokens = x[exp\_token\_idx]
expert\_out = expert(expert\_tokens).to(expert\_cache.dtype)
expert\_out.mul\_(flat\_expert\_weights[idxs[start\_idx:end\_idx]])
# 使用 scatter\_add\_ 进行 sum 操作
expert\_cache.scatter\_add\_(0, exp\_token\_idx.view(-1, 1).repeat(1, x.shape[-1]), expert\_out)
return expert\_cache
### 代码解释
解释一下这段代码的主要组成部分：
1. `FeedForward` 类：
\* 实现了一个基础的前馈网络
\* 使用 SwiGLU 激活函数（`F.silu(self.w1(x)) \* self.w3(x)`）
\* 包含三个线性层（w1、w2、w3）和一个 dropout 层
2. `MoEGate` 类（门控机制）：
\* 负责决定每个 token 应该由哪些专家处理
\* 主要步骤：
1. 计算每个 token 对应每个专家的分数（使用 softmax）
2. 选择 top-k 个最高分的专家
3. 计算辅助损失（aux\_loss）来平衡专家的使用
3. `MOEFeedForward` 类（混合专家系统）：
\* 包含多个专家（FeedForward）和一个门控网络（MoEGate）
\* 训练模式：
1. 使用门控网络选择每个 token 的专家
2. 将输入数据复制多份，分发给不同专家
3. 专家并行处理数据
4. 根据门控权重合并结果
\* 推理模式（`moe\_infer`）：
1. 对专家索引排序，将相同专家的 token 批量处理
2. 使用 `scatter\_add\_` 将专家输出累加到正确位置
3. 更高效的推理实现，避免了数据重复
4. 特殊功能：
\* 支持共享专家（`n\_shared\_experts`）
\* 实现了专家负载均衡（通过辅助损失）
\* 支持每个 token 选择多个专家（`num\_experts\_per\_tok`）
这是一个典型的 MoE（Mixture of Experts）实现，用于大型语言模型中提高模型容量和计算效率。
### 示例
# 创建 MoE 实例
dim = 512 # 输入维度
n\_routed\_experts = 4 # 专家数量
num\_experts\_per\_tok = 2 # 每个token选择的专家数量
moe = MOEFeedForward(
dim=dim,
n\_routed\_experts=n\_routed\_experts,
num\_experts\_per\_tok=num\_experts\_per\_tok,
hidden\_dim=None, # FFN隐藏层维度，None时自动计算
dropout=0.1 # dropout比率
)
# 创建示例输入
batch\_size = 2
seq\_len = 10
x = torch.randn(batch\_size, seq\_len, dim) # 形状: [2, 10, 512]
moe(x)
输出
After gate - topk\_idx.shape: torch.Size([20, 2]), topk\_weight.shape: torch.Size([20, 2])
After view - x.shape: torch.Size([20, 512]), flat\_topk\_idx.shape: torch.Size([40])
After repeat\_interleave - x.shape: torch.Size([40, 512])
Empty y tensor shape: torch.Size([40, 512])
Expert 0 - input shape: torch.Size([9, 512])
Expert 0 - output shape: torch.Size([9, 512])
Expert 1 - input shape: torch.Size([13, 512])
Expert 1 - output shape: torch.Size([13, 512])
Expert 2 - input shape: torch.Size([11, 512])
Expert 2 - output shape: torch.Size([11, 512])
Expert 3 - input shape: torch.Size([7, 512])
Expert 3 - output shape: torch.Size([7, 512])
Before view - y.shape: torch.Size([40, 512])
topk\_weight.shape: torch.Size([20, 2])
After view and sum - y.shape: torch.Size([20, 512])
Final y.shape: torch.Size([2, 10, 512])
### 相应的torch函数
import torch
# empty: 创建未初始化的张量
x = torch.empty((2, 3)) # 创建形状为 2x3 的未初始化张量
# zeros\_like: 创建与输入相同形状的全零张量
a = torch.tensor([[1, 2], [3, 4]])
b = torch.zeros\_like(a) # 创建形状为 2x2 的全零张量
print(b) # tensor([[0, 0], [0, 0]])
tensor([[0, 0],
[0, 0]])
import torch.nn.functional as F
x = torch.tensor([[1, 2, 3, 4], [5, 6, 7, 8]])
# view: 改变张量形状
y = x.view(-1) # 展平为一维
print(y) # tensor([1, 2, 3, 4, 5, 6, 7, 8])
# -1 表示自动计算该维度大小
z = x.view(-1, 2) # 重塑为 4x2
print(z) # tensor([[1, 2], [3, 4], [5, 6], [7, 8]])
tensor([1, 2, 3, 4, 5, 6, 7, 8])
tensor([[1, 2],
[3, 4],
[5, 6],
[7, 8]])
# linear: 线性变换 y = xA^T + b
input = torch.randn(2, 3) # 2个样本，每个3维
weight = torch.randn(4, 3) # 输出4维
output = F.linear(input, weight) # 形状变为 [2, 4]
# softmax: 将数值转换为概率分布
logits = torch.tensor([1.0, 2.0, 3.0])
probs = F.softmax(logits, dim=0)
print(probs) # tensor([0.0900, 0.2447, 0.6652])
tensor([0.0900, 0.2447, 0.6652])
# 找出最大的k个值及其索引
x = torch.tensor([1, 5, 2, 8, 3])
values, indices = torch.topk(x, k=2)
print(values) # tensor([8, 5])
print(indices) # tensor([3, 1])
tensor([8, 5])
tensor([3, 1])
x = torch.tensor([1, 2, 3])
# 每个元素重复2次
y = x.repeat\_interleave(2)
print(y) # tensor([1, 1, 2, 2, 3, 3])
tensor([1, 1, 2, 2, 3, 3])
# 统计每个数字出现的次数
x = torch.tensor([1, 1, 2, 3, 1, 2])
counts = x.bincount()
print(counts) # tensor([0, 3, 2, 1]) # 0出现0次，1出现3次，2出现2次，3出现1次
tensor([0, 3, 2, 1])
# 在指定位置累加值
src = torch.tensor([[1, 2], [3, 4]], dtype=torch.float) # 指定数据类型为 float
index = torch.tensor([[0, 1], [0, 1]])
out = torch.zeros(2, 2, dtype=torch.float) # 确保与 src 的数据类型相同
out.scatter\_add\_(0, index, src)
print(out)
tensor([[4., 0.],
[0., 6.]])
# 返回排序后的索引
x = torch.tensor([3, 1, 4, 1, 5])
indices = x.argsort()
print(indices) # tensor([1, 3, 0, 2, 4]) # 最小值在位置1和3，然后是0,2,4
tensor([1, 3, 0, 2, 4])