---
layout: post
title: "定时器Tim输出比较output-compare"
date: 2025-03-08 12:44:40 +0800
description: "PSC（预分频器）：719ARR（自动重装载值）：99CCR（捕获/比较值）：0到99（根据需要调节占空比）这样配置后，你将得到一个频率为1kHz，分辨率为0.01，占空比可调的PWM波形。确保在实际应用中，定时器的时钟源配置正确，以匹配CK_PSC的假设值。"
keywords: "tim的输出比较compare怎么"
categories: ['学习日记']
tags: ['嵌入式硬件', '单片机']
artid: "146113720"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146113720
    alt: "定时器Tim输出比较output-compare"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146113720
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146113720
cover: https://bing.ee123.net/img/rand?artid=146113720
image: https://bing.ee123.net/img/rand?artid=146113720
img: https://bing.ee123.net/img/rand?artid=146113720
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     定时器Tim输出比较（output compare）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     输出比较OC(Output Compare)
    </h2>
    <p>
     <br/>
     输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形
     <br/>
     每个高级定时器和通用定时器都拥有4个输出比较通道，高级定时器的前3个通道额外拥有死区生成和互补输出的功能
    </p>
    <p>
     在通用定时器的这个位置：
    </p>
    <p>
     <img alt="" height="659" src="https://i-blog.csdnimg.cn/direct/7edb0ad8ae5447a4985cfdb69749cca2.png" width="809"/>
    </p>
    <h2>
     PWM（Pulse Width Modulation）脉冲宽度调制波形
    </h2>
    <h4>
     PWM呼吸灯
    </h4>
    <p>
     PWM呼吸灯是通过调节LED的亮度来实现呼吸效果的一种应用。通过改变PWM信号的占空比，可以控制LED的亮度，从而实现从亮到暗再到亮的循环变化。例如，在STM32中，可以通过设置定时器的捕获/比较寄存器（CCR）的值来改变占空比，从而实现呼吸灯效果。通过在运行中更改CCR的值，可以使LED的亮度发生变化，从而实现呼吸灯效果
    </p>
    <h4>
     驱动电机原理
    </h4>
    <p>
     电机驱动的基本原理是利用电流通过电机的线圈产生磁场，与永磁体或其他磁场互相作用，从而产生转矩和旋转运动。常见的电机驱动方式包括直流电机驱动和交流电机驱动。直流电机驱动器通过调节直流电机的输入电流，从而控制电机的转速和转矩。它主要由电源、控制器、驱动器和电机组成。控制器根据输入信号发出控制指令，驱动器根据指令调节电机的电流，进而控制电机的运动
    </p>
    <p>
     <img alt="" height="575" src="https://i-blog.csdnimg.cn/direct/0f1ab772781946938c6ff5705e5cb20d.png" width="991"/>
    </p>
    <p>
     Ton表示高电平时间，Toff表示低电平时间，Ts是一个周期的时间
    </p>
    <p>
     占空比决定了PWM等效出来的模拟电压的大小，占空比越大，那等效的模拟电压就越趋近于高电平，反之。
    </p>
    <p>
     <img alt="" height="330" src="https://i-blog.csdnimg.cn/direct/a29596975fa7427e97ba906b3df69713.png" width="642"/>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        输入信号
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          ETRF
         </strong>
         ：外部触发输入，用于同步定时器。
        </p>
       </li>
       <li>
        <p>
         <strong>
          TIMx_CCR1
         </strong>
         和
         <strong>
          TIMx_CCR1
         </strong>
         ：捕获/比较寄存器，用于存储比较值。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        输出模式控制器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         该模块负责根据捕获/比较寄存器的值和定时器的计数值来控制输出信号。
        </p>
       </li>
       <li>
        <p>
         <strong>
          OC1ref
         </strong>
         ：输出比较参考信号，这是最终输出到外部引脚的信号。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        至主模式控制器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         该部分负责将输出比较信号传递给主模式控制器，用于进一步处理。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        输出使能电路
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          CC1P
         </strong>
         和
         <strong>
          CC1E
         </strong>
         ：这些是控制输出极性和输出使能的位。
        </p>
        <ul>
         <li>
          <p>
           <strong>
            CC1P
           </strong>
           ：控制输出极性。当该位为1时，输出为反相；为0时，输出为正相。
          </p>
         </li>
         <li>
          <p>
           <strong>
            CC1E
           </strong>
           ：控制输出使能。当该位为1时，输出使能；为0时，输出禁用。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        输出引脚（OC1）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         最终的输出信号通过OC1引脚输出到外部设备。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        TIMx_CCER寄存器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         该寄存器用于配置输出极性和输出使能。
        </p>
       </li>
       <li>
        <p>
         <strong>
          CC1P
         </strong>
         和
         <strong>
          CC1E
         </strong>
         ：如上所述，分别控制输出极性和输出使能。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        TIMx_CCMR1寄存器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         该寄存器用于配置输出模式。
        </p>
       </li>
       <li>
        <p>
         <strong>
          OC1M[2:0]
         </strong>
         ：输出模式选择位，用于选择不同的输出模式（如模式1、模式2等）。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     输出模式
    </h4>
    <p>
     STM32定时器提供多种输出模式，常见的有：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        模式1（Toggle）
       </strong>
       ：当定时器计数值等于捕获/比较寄存器的值时，输出引脚状态翻转。
      </p>
     </li>
     <li>
      <p>
       <strong>
        模式2（Inverted）
       </strong>
       ：当定时器计数值等于捕获/比较寄存器的值时，输出引脚状态取反。
      </p>
     </li>
     <li>
      <p>
       <strong>
        模式3（Set）
       </strong>
       ：当定时器计数值等于捕获/比较寄存器的值时，输出引脚置高。
      </p>
     </li>
     <li>
      <p>
       <strong>
        模式4（Reset）
       </strong>
       ：当定时器计数值等于捕获/比较寄存器的值时，输出引脚置低。
      </p>
     </li>
    </ul>
    <h4>
     应用示例
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        PWM输出
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过配置捕获/比较寄存器的值和定时器的自动重装载值，可以生成PWM信号，用于控制LED亮度或电机速度。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        单稳态输出
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过配置输出模式和捕获/比较寄存器的值，可以生成单稳态信号，用于定时控制。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        边缘触发输出
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过配置输出模式和捕获/比较寄存器的值，可以生成边缘触发信号，用于同步外部设备。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     输出控制器的逻辑
    </p>
    <p>
     一般使用PWN模式1向上计数
    </p>
    <p>
     <img alt="" height="381" src="https://i-blog.csdnimg.cn/direct/1526bb48a729414fb28436ad2319bb2e.png" width="710"/>
    </p>
    <p>
     <img alt="" height="367" src="https://i-blog.csdnimg.cn/direct/00ce1bf1addc4cadb8f11db54428abcb.png" width="674"/>
    </p>
    <p>
     <img alt="" height="391" src="https://i-blog.csdnimg.cn/direct/cf0fdbc6fa4c4f2c8930b959c2d8d305.png" width="632"/>
    </p>
    <p>
     用这个公式，要求输出频率为1khz，占空比可任意调节，分辨率为百分之一的pwm波形怎么计算呢？
    </p>
    <ul>
     <li>
      <p>
       输出频率（Freq）为1kHz
      </p>
     </li>
     <li>
      <p>
       占空比（Duty）可任意调节
      </p>
     </li>
     <li>
      <p>
       分辨率（Reso）为百分之一，即0.01
      </p>
     </li>
    </ul>
    <p>
     根据图中的公式：
    </p>
    <ul>
     <li>
      <p>
       PWM频率（Freq）= CK_PSC / (PSC + 1) / (ARR + 1)
      </p>
     </li>
     <li>
      <p>
       PWM占空比（Duty）= CCR / (ARR + 1)
      </p>
     </li>
     <li>
      <p>
       PWM分辨率（Reso）= 1 / (ARR + 1)
      </p>
     </li>
    </ul>
    <h4>
     步骤1：计算ARR值
    </h4>
    <p>
     首先，我们需要根据分辨率要求计算ARR的值。分辨率为百分之一，即0.01，这意味着： Reso=ARR+11​=0.01 ARR+1=100 ARR=99
    </p>
    <h4>
     步骤2：计算PWM频率
    </h4>
    <p>
     接下来，我们需要计算PWM频率。假设CK_PSC（定时器时钟频率）为72MHz（一个常见的STM32时钟频率），我们希望频率为1kHz。72MHz=72×10^6Hz=72,000,000Hz
    </p>
    <p>
     <img alt="" height="177" src="https://i-blog.csdnimg.cn/direct/6be12dbbbc57445aa39981c7f8690cb3.png" width="210"/>
    </p>
    <p>
    </p>
    <h4>
     步骤3：配置CCR
    </h4>
    <p>
    </p>
    <p>
     由于占空比需要可任意调节，CCR的值可以在0到ARR的范围内变化。在本例中，ARR为99，所以CCR可以从0变化到99，以实现从0%到100%的占空比。
    </p>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        PSC（预分频器）
       </strong>
       ：719
      </p>
     </li>
     <li>
      <p>
       <strong>
        ARR（自动重装载值）
       </strong>
       ：99
      </p>
     </li>
     <li>
      <p>
       <strong>
        CCR（捕获/比较值）
       </strong>
       ：0到99（根据需要调节占空比）
      </p>
     </li>
    </ul>
    <p>
     这样配置后，你将得到一个频率为1kHz，分辨率为0.01，占空比可调的PWM波形。确保在实际应用中，定时器的时钟源配置正确，以匹配CK_PSC的假设值。
    </p>
    <h2>
     舵机、直流电机以及驱动
    </h2>
    <p>
     <img alt="" height="416" src="https://i-blog.csdnimg.cn/direct/798ba7543d914d21bbe10e9afc5416af.png" width="711"/>
    </p>
    <p>
     <img alt="" height="442" src="https://i-blog.csdnimg.cn/direct/58050bb3682e4ebbbf1b27b432a9c9a9.png" width="822"/>
    </p>
    <p>
     <img alt="" height="379" src="https://i-blog.csdnimg.cn/direct/035e9a7c136745a89100524133a2d004.png" width="690"/>
    </p>
    <p>
     <img alt="" height="386" src="https://i-blog.csdnimg.cn/direct/c28a069ce3bb4f258de406d494560607.png" width="659"/>
    </p>
    <p>
     反转：IN1低电平，IN2高电平，PWN高反转低不转
    </p>
    <p>
     正转：IN1高电平，IN2低电平，PWN高正转低不转
    </p>
    <p>
     如果PWM频率足够快，点击就是连续稳定的转了，速度取决于PWM信号的占空比。
    </p>
    <h2>
     实验：
    </h2>
    <p>
     实验1：呼吸灯
    </p>
    <p>
     <img alt="" height="3968" src="https://i-blog.csdnimg.cn/direct/1ddedf9fd4994449be435ddd3a1e8676.jpeg" width="8922"/>
    </p>
    <p>
     led正极接PA0引脚，负极接在GND的驱动方法，高电平点亮，这样的话就是占空比越大，led越亮，反之。
    </p>
    <p>
     第一步:RCC开启时钟，把我们要用的TIM外设和GPIO外设打开
    </p>
    <p>
     第二步：配置时基单元，时钟源选择
    </p>
    <p>
     第三步：配置输出比较单元，CCR的值，输出比较模式，极性选择，输出使能
    </p>
    <p>
     第四部：配置GPIO，初始化为复用推挽模式
    </p>
    <p>
     第五步：运行控制，启用计数器，这样就能输出PWM了
    </p>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header

/**
  * 函    数：PWM初始化
  * 参    数：无
  * 返 回 值：无
  */
void PWM_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			//开启TIM2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			//开启GPIOA的时钟
	
	/*GPIO重映射*/
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);			//开启AFIO的时钟，重映射必须先开启AFIO的时钟
//	GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);			//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册
//	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);		//将JTAG引脚失能，作为普通GPIO引脚使用
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		//GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							//将PA0引脚初始化为复用推挽输出	
																	//受外设控制的引脚，均需要配置为复用模式		
	
	/*配置时钟源*/
	TIM_InternalClockConfig(TIM2);		//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟
	
	/*时基单元初始化*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				//定义结构体变量
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;					//计数周期，即ARR的值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;				//预分频器，即PSC的值
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);             //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元
	
	/*输出比较初始化*/
	TIM_OCInitTypeDef TIM_OCInitStructure;							//定义结构体变量
	TIM_OCStructInit(&amp;TIM_OCInitStructure);							//结构体初始化，若结构体没有完整赋值
																	//则最好执行此函数，给结构体所有成员都赋一个默认值
																	//避免结构体初值不确定的问题
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;				//输出比较模式，选择PWM模式1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;		//输出极性，选择为高，若选择极性为低，则输出高低电平取反
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	//输出使能
	TIM_OCInitStructure.TIM_Pulse = 0;								//初始的CCR值
	TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);						//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1
	
	/*TIM使能*/
	TIM_Cmd(TIM2, ENABLE);			//使能TIM2，定时器开始运行
}

/**
  * 函    数：PWM设置CCR
  * 参    数：Compare 要写入的CCR的值，范围：0~100
  * 返 回 值：无
  * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比
  *           占空比Duty = CCR / (ARR + 1)
  */
void PWM_SetCompare1(uint16_t Compare)
{
	TIM_SetCompare1(TIM2, Compare);		//设置CCR1的值
}
</code></pre>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"

uint8_t i;			//定义for循环的变量

int main(void)
{
	/*模块初始化*/
	OLED_Init();		//OLED初始化
	PWM_Init();			//PWM初始化
	
	while (1)
	{
		for (i = 0; i &lt;= 100; i++)
		{
			PWM_SetCompare1(i);			//依次将定时器的CCR寄存器设置为0~100，PWM占空比逐渐增大，LED逐渐变亮
			Delay_ms(10);				//延时10ms
		}
		for (i = 0; i &lt;= 100; i++)
		{
			PWM_SetCompare1(100 - i);	//依次将定时器的CCR寄存器设置为100~0，PWM占空比逐渐减小，LED逐渐变暗
			Delay_ms(10);				//延时10ms
		}
	}
}
</code></pre>
    <p>
     <img alt="" height="394" src="https://i-blog.csdnimg.cn/direct/e4b744b5df0d4cea9034cfbe78cf8e44.png" width="722"/>
    </p>
    <p>
     实验二：驱动舵机
    </p>
    <p>
     <img alt="" height="4122" src="https://i-blog.csdnimg.cn/direct/2d1739526c3149db8c63f56cc13cfd8c.jpeg" width="9176"/>
    </p>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header

/**
  * 函    数：PWM初始化
  * 参    数：无
  * 返 回 值：无
  */
void PWM_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			//开启TIM2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							//将PA1引脚初始化为复用推挽输出	
																	//受外设控制的引脚，均需要配置为复用模式
	
	/*配置时钟源*/
	TIM_InternalClockConfig(TIM2);		//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟
	
	/*时基单元初始化*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				//定义结构体变量
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 20000 - 1;				//计数周期，即ARR的值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;				//预分频器，即PSC的值
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);             //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元
	
	/*输出比较初始化*/ 
	TIM_OCInitTypeDef TIM_OCInitStructure;							//定义结构体变量
	TIM_OCStructInit(&amp;TIM_OCInitStructure);                         //结构体初始化，若结构体没有完整赋值
	                                                                //则最好执行此函数，给结构体所有成员都赋一个默认值
	                                                                //避免结构体初值不确定的问题
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;               //输出比较模式，选择PWM模式1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;       //输出极性，选择为高，若选择极性为低，则输出高低电平取反
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;   //输出使能
	TIM_OCInitStructure.TIM_Pulse = 0;								//初始的CCR值
	TIM_OC2Init(TIM2, &amp;TIM_OCInitStructure);                        //将结构体变量交给TIM_OC2Init，配置TIM2的输出比较通道2
	
	/*TIM使能*/
	TIM_Cmd(TIM2, ENABLE);			//使能TIM2，定时器开始运行
}

/**
  * 函    数：PWM设置CCR
  * 参    数：Compare 要写入的CCR的值，范围：0~100
  * 返 回 值：无
  * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比
  *           占空比Duty = CCR / (ARR + 1)
  */
void PWM_SetCompare2(uint16_t Compare)
{
	TIM_SetCompare2(TIM2, Compare);		//设置CCR2的值
}
</code></pre>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header
#include "PWM.h"

/**
  * 函    数：舵机初始化
  * 参    数：无
  * 返 回 值：无
  */
void Servo_Init(void)
{
	PWM_Init();									//初始化舵机的底层PWM
}

/**
  * 函    数：舵机设置角度
  * 参    数：Angle 要设置的舵机角度，范围：0~180
  * 返 回 值：无
  */
void Servo_SetAngle(float Angle)
{
	PWM_SetCompare2(Angle / 180 * 2000 + 500);	//设置占空比
												//将角度线性变换，对应到舵机要求的占空比范围上
}
</code></pre>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Servo.h"
#include "Key.h"

uint8_t KeyNum;			//定义用于接收键码的变量
float Angle;			//定义角度变量

int main(void)
{
	/*模块初始化*/
	OLED_Init();		//OLED初始化
	Servo_Init();		//舵机初始化
	Key_Init();			//按键初始化
	
	/*显示静态字符串*/
	OLED_ShowString(1, 1, "Angle:");	//1行1列显示字符串Angle:
	
	while (1)
	{
		KeyNum = Key_GetNum();			//获取按键键码
		if (KeyNum == 1)				//按键1按下
		{
			Angle += 30;				//角度变量自增30
			if (Angle &gt; 180)			//角度变量超过180后
			{
				Angle = 0;				//角度变量归零
			}
		}
		Servo_SetAngle(Angle);			//设置舵机的角度为角度变量
		OLED_ShowNum(1, 7, Angle, 3);	//OLED显示角度变量
	}
}
</code></pre>
    <p>
     <img alt="" height="434" src="https://i-blog.csdnimg.cn/direct/d9b22886aea1451f9c9a71e3f86ad8e8.png" width="710"/>
    </p>
    <p>
     <img alt="" height="232" src="https://i-blog.csdnimg.cn/direct/00dff31c3ae24fc8aa3c22a3f961ce06.png" width="241"/>
    </p>
    <p>
     有人知道为什么下面的跟图不一样嘛？？
    </p>
    <h4>
     常见的舵机控制参数
    </h4>
    <p>
     在许多舵机中，常见的控制参数如下：
    </p>
    <ul>
     <li>
      <p>
       0.5ms（500微秒）的高电平对应 0°
      </p>
     </li>
     <li>
      <p>
       1.5ms（1500微秒）的高电平对应 90°
      </p>
     </li>
     <li>
      <p>
       2.5ms（2500微秒）的高电平对应 180°
      </p>
     </li>
    </ul>
    <p>
     舵机的控制通常依赖于PWM信号，其中0°对应500微秒的高电平时长，180°对应2500微秒的高电平时长。这种对应关系是舵机控制的一种行业标准，用于在0°到180°之间精确控制舵机的角度
    </p>
    <p>
     至于
     <code>
      setcompare()
     </code>
     函数，它通常用于设置定时器的比较寄存器值，即设定一个时间基准，当计数器达到该值时，就会引发一个定时器溢出中断或者定时事件。在STM32系列微控制器中，这个函数可以用来精确地控制设备的工作周期，比如定时器超时、延时操作或者是脉冲宽度调制（PWM）的占空比设置。例如，在舵机控制中，通过调用
     <code>
      setcompare()
     </code>
     函数并传入相应的参数，可以生成对应角度的PWM信号，从而控制舵机转动到指定的角度
    </p>
    <p>
     <img alt="" height="196" src="https://i-blog.csdnimg.cn/direct/ec6b3d406a0c49e8afc1cd33df092669.png" width="700"/>
    </p>
    <p>
     舵机要求周期20ms，PWM频率就是1/20ms =50hz
    </p>
    <p>
     输出高电平的时间：
    </p>
    <p>
     高电平时间=周期×占空比
    </p>
    <p>
     duty = ccr/（arr+1）=50/20000= 0.025
    </p>
    <p>
     高电平时间 = 20ms ×0.025 = 0.5ms
    </p>
    <p>
     ccr设置500就是0.5ms，设置2500就是2.5ms
    </p>
    <p>
     0° -500，180° -2500
    </p>
    <p>
     实验三：PWM驱动直流电机
    </p>
    <p>
     <img alt="" height="4128" src="https://i-blog.csdnimg.cn/direct/5ebd5dd64eeb4cde8ddef9e44646738e.jpeg" width="9199"/>
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header

/**
  * 函    数：PWM初始化
  * 参    数：无
  * 返 回 值：无
  */
void PWM_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			//开启TIM2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							//将PA2引脚初始化为复用推挽输出	
																	//受外设控制的引脚，均需要配置为复用模式
	
	/*配置时钟源*/
	TIM_InternalClockConfig(TIM2);		//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟
	
	/*时基单元初始化*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				//定义结构体变量
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;                 //计数周期，即ARR的值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 36 - 1;               //预分频器，即PSC的值
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);             //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元
	
	/*输出比较初始化*/ 
	TIM_OCInitTypeDef TIM_OCInitStructure;							//定义结构体变量
	TIM_OCStructInit(&amp;TIM_OCInitStructure);                         //结构体初始化，若结构体没有完整赋值
	                                                                //则最好执行此函数，给结构体所有成员都赋一个默认值
	                                                                //避免结构体初值不确定的问题
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;               //输出比较模式，选择PWM模式1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;       //输出极性，选择为高，若选择极性为低，则输出高低电平取反
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;   //输出使能
	TIM_OCInitStructure.TIM_Pulse = 0;								//初始的CCR值
	TIM_OC3Init(TIM2, &amp;TIM_OCInitStructure);                        //将结构体变量交给TIM_OC3Init，配置TIM2的输出比较通道3
	
	/*TIM使能*/
	TIM_Cmd(TIM2, ENABLE);			//使能TIM2，定时器开始运行
}

/**
  * 函    数：PWM设置CCR
  * 参    数：Compare 要写入的CCR的值，范围：0~100
  * 返 回 值：无
  * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比
  *           占空比Duty = CCR / (ARR + 1)
  */
void PWM_SetCompare3(uint16_t Compare)
{
	TIM_SetCompare3(TIM2, Compare);		//设置CCR3的值
}
</code></pre>
    <p>
    </p>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header
#include "PWM.h"

/**
  * 函    数：直流电机初始化
  * 参    数：无
  * 返 回 值：无
  */
void Motor_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);		//开启GPIOA的时钟
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);						//将PA4和PA5引脚初始化为推挽输出	
	
	PWM_Init();													//初始化直流电机的底层PWM
}

/**
  * 函    数：直流电机设置速度
  * 参    数：Speed 要设置的速度，范围：-100~100
  * 返 回 值：无
  */
void Motor_SetSpeed(int8_t Speed)
{
	if (Speed &gt;= 0)							//如果设置正转的速度值
	{
		GPIO_SetBits(GPIOA, GPIO_Pin_4);	//PA4置高电平
		GPIO_ResetBits(GPIOA, GPIO_Pin_5);	//PA5置低电平，设置方向为正转
		PWM_SetCompare3(Speed);				//PWM设置为速度值
	}
	else									//否则，即设置反转的速度值
	{
		GPIO_ResetBits(GPIOA, GPIO_Pin_4);	//PA4置低电平
		GPIO_SetBits(GPIOA, GPIO_Pin_5);	//PA5置高电平，设置方向为反转
		PWM_SetCompare3(-Speed);			//PWM设置为负的速度值，因为此时速度值为负数，而PWM只能给正数
	}
}
</code></pre>
    <p>
     <img alt="" height="96" src="https://i-blog.csdnimg.cn/direct/e09e24b6c0f046a98050f323379c041f.png" width="231"/>
    </p>
    <pre><code class="language-cpp">#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Motor.h"
#include "Key.h"

uint8_t KeyNum;		//定义用于接收按键键码的变量
int8_t Speed;		//定义速度变量

int main(void)
{
	/*模块初始化*/
	OLED_Init();		//OLED初始化
	Motor_Init();		//直流电机初始化
	Key_Init();			//按键初始化
	
	/*显示静态字符串*/
	OLED_ShowString(1, 1, "Speed:");		//1行1列显示字符串Speed:
	
	while (1)
	{
		KeyNum = Key_GetNum();				//获取按键键码
		if (KeyNum == 1)					//按键1按下
		{
			Speed += 20;					//速度变量自增20
			if (Speed &gt; 100)				//速度变量超过100后
			{
				Speed = -100;				//速度变量变为-100
											//此操作会让电机旋转方向突然改变，可能会因供电不足而导致单片机复位
											//若出现了此现象，则应避免使用这样的操作
			}
		}
		Motor_SetSpeed(Speed);				//设置直流电机的速度为速度变量
		OLED_ShowSignedNum(1, 7, Speed, 3);	//OLED显示速度变量
	}
}
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f79616e6779616e67796979616e675f2f:61727469636c652f64657461696c732f313436313133373230" class_="artid" style="display:none">
 </p>
</div>


