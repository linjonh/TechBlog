---
layout: post
title: "代理Delegate闭包ClosureNotification通知中心-和-swift_event_bus适用场景和工作方式"
date: 2025-03-11 22:07:59 +0800
description: "在 Swift 开发中，在 Swift 开发中，代理（Delegate）、闭包（Closure）、Notification（通知中心） 和 swift_event_bus 主要用于。代理对象（即最后设置的那个），所以如果 PlaylistViewController 先设置了代理，而 HomeViewController 后设置代理，就会覆盖之前的代理。​\t•\t类似 NotificationCenter，但更轻量级，支持异步和线程调度。​\t•\t可能导致代码难以跟踪，容易造成资源泄漏（监听后需移除）。"
keywords: "代理（Delegate）、闭包（Closure）、Notification（通知中心） 和 swift_event_bus适用场景和工作方式"
categories: ['App']
tags: ['开发语言', 'Swift', 'Ios']
artid: "146190448"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146190448
    alt: "代理Delegate闭包ClosureNotification通知中心-和-swift_event_bus适用场景和工作方式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146190448
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146190448
cover: https://bing.ee123.net/img/rand?artid=146190448
image: https://bing.ee123.net/img/rand?artid=146190448
img: https://bing.ee123.net/img/rand?artid=146190448
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     代理（Delegate）、闭包（Closure）、Notification（通知中心） 和 swift_event_bus适用场景和工作方式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在 Swift 开发中，在 Swift 开发中，代理（Delegate）、闭包（Closure）、Notification（通知中心） 和 swift_event_bus 主要用于
     <strong>
      组件之间的通信
     </strong>
     ，但它们的适用场景和工作方式有所不同。以下是它们的区别：
    </p>
    <p>
     <strong>
      1. 代理（Delegate）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对一
     </strong>
     通信，通常用于传递事件或回调，例如 UITableViewDelegate。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：使用
     <strong>
      协议（Protocol）
     </strong>
     定义代理方法，调用方实现代理协议并传递代理对象。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 强类型检查，编译时安全。
    </p>
    <p>
     ​ • 适用于长期存在的关系（如 UITableView 和 UITableViewDelegate）。
    </p>
    <p>
     ​ • 需要显式声明代理，并手动设置代理对象。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>protocol PlayerDelegate: AnyObject {
    func didFinishPlaying()
}

class MusicPlayer {
    weak var delegate: PlayerDelegate?

    func play() {
        // 模拟播放完成
        delegate?.didFinishPlaying()
    }
}

class ViewController: PlayerDelegate {
    let player = MusicPlayer()

    init() {
        player.delegate = self
        player.play()
    }

    func didFinishPlaying() {
        print("播放完成")
    }
}
</code></pre>
    <p>
     一个 protocol
     <strong>
      可以在多个控制器中实现
     </strong>
     ，这正是 Swift 协议的强大之处。协议（protocol）定义了一组方法和属性，
     <strong>
      任何类、结构体或枚举都可以遵循并实现这个协议
     </strong>
     ，这允许你在多个 UIViewController 中实现相同的协议逻辑。
    </p>
    <p>
     <strong>
      示例：一个协议在多个控制器中实现
     </strong>
    </p>
    <p>
     假设你的 myMusic 项目中有一个播放器，你希望不同的控制器（比如 HomeViewController 和 PlaylistViewController）都能够监听播放器的播放完成事件，你可以这样做：
    </p>
    <p>
     <strong>
      1. 定义一个协议
     </strong>
    </p>
    <pre><code>protocol MusicPlayerDelegate: AnyObject {
    func didFinishPlaying(song: String)
}
</code></pre>
    <p>
     <strong>
      2. 在多个控制器中实现协议
     </strong>
    </p>
    <p>
     <strong>
      第一个控制器：HomeViewController
     </strong>
    </p>
    <pre><code>class HomeViewController: UIViewController, MusicPlayerDelegate {
    override func viewDidLoad() {
        super.viewDidLoad()
        MusicPlayer.shared.delegate = self
    }

    func didFinishPlaying(song: String) {
        print("HomeViewController: \(song) 播放完成，更新 UI")
    }
}
</code></pre>
    <p>
     <strong>
      第二个控制器：PlaylistViewController
     </strong>
    </p>
    <pre><code>class PlaylistViewController: UIViewController, MusicPlayerDelegate {
    override func viewDidLoad() {
        super.viewDidLoad()
        MusicPlayer.shared.delegate = self
    }

    func didFinishPlaying(song: String) {
        print("PlaylistViewController: \(song) 播放完成，刷新播放列表")
    }
}
</code></pre>
    <p>
     <strong>
      问题：协议的 delegate 只能有一个对象
     </strong>
    </p>
    <p>
     上面代码的
     <strong>
      问题
     </strong>
     是 MusicPlayer.shared.delegate 只能存储
     <strong>
      一个
     </strong>
     代理对象（即最后设置的那个），所以如果 PlaylistViewController 先设置了代理，而 HomeViewController 后设置代理，就会覆盖之前的代理。
    </p>
    <p>
     <strong>
      解决方案 1：使用数组存储多个代理
     </strong>
    </p>
    <p>
     如果你希望
     <strong>
      多个控制器
     </strong>
     都能监听播放器事件，可以改进 MusicPlayer，让它支持多个代理：
    </p>
    <pre><code>class MusicPlayer {
    static let shared = MusicPlayer()
    private var delegates = [MusicPlayerDelegate]()

    func addDelegate(_ delegate: MusicPlayerDelegate) {
        delegates.append(delegate)
    }

    func removeDelegate(_ delegate: MusicPlayerDelegate) {
        delegates.removeAll { $0 === delegate }
    }

    func play() {
        // 模拟播放完成
        notifyDelegates(song: "My Favorite Song")
    }

    private func notifyDelegates(song: String) {
        for delegate in delegates {
            delegate.didFinishPlaying(song: song)
        }
    }
}
</code></pre>
    <p>
     <strong>
      使用方式
     </strong>
    </p>
    <pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    MusicPlayer.shared.addDelegate(self)
}
</code></pre>
    <p>
     <strong>
      解决方案 2：使用 NotificationCenter（适用于全局事件）
     </strong>
    </p>
    <p>
     如果你不想手动管理多个代理数组，可以用 NotificationCenter 代替：
    </p>
    <pre><code>class MusicPlayer {
    static let shared = MusicPlayer()

    func play() {
        // 模拟播放完成，发送通知
        NotificationCenter.default.post(name: .musicFinished, object: nil, userInfo: ["song": "My Favorite Song"])
    }
}

extension Notification.Name {
    static let musicFinished = Notification.Name("musicFinished")
}
</code></pre>
    <p>
     <strong>
      在多个控制器中监听
     </strong>
    </p>
    <pre><code>NotificationCenter.default.addObserver(self, selector: #selector(musicFinished(_:)), name: .musicFinished, object: nil)

@objc func musicFinished(_ notification: Notification) {
    if let song = notification.userInfo?["song"] as? String {
        print("收到通知：\(song) 播放完成")
    }
}
</code></pre>
    <p>
     <strong>
      总结
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         方法
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
       <th>
        <strong>
         优点
        </strong>
       </th>
       <th>
        <strong>
         缺点
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        Delegate 单个对象
       </td>
       <td>
        <strong>
         一对一通信
        </strong>
       </td>
       <td>
        类型安全，编译时检查
       </td>
       <td>
        只能有一个代理
       </td>
      </tr>
      <tr>
       <td>
        Delegate 多个对象
       </td>
       <td>
        <strong>
         多个对象监听
        </strong>
       </td>
       <td>
        所有监听者都能收到回调
       </td>
       <td>
        需要手动管理代理数组
       </td>
      </tr>
      <tr>
       <td>
        NotificationCenter
       </td>
       <td>
        <strong>
         全局事件
        </strong>
       </td>
       <td>
        解耦，不限监听者数量
       </td>
       <td>
        运行时检查，代码可读性略低
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     如果希望
     <strong>
      多个控制器
     </strong>
     监听同一事件：
    </p>
    <p>
     ​ • 需要
     <strong>
      强类型回调
     </strong>
     → 用
     <strong>
      多个 delegate（数组方式）
     </strong>
    </p>
    <p>
     ​ • 需要
     <strong>
      全局广播
     </strong>
     → 用
     <strong>
      NotificationCenter
     </strong>
    </p>
    <p>
     <strong>
      2. 闭包（Closure）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对一
     </strong>
     或
     <strong>
      临时性
     </strong>
     事件回调，例如网络请求完成后回调。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：将
     <strong>
      函数作为参数
     </strong>
     传递，通常用于短生命周期的任务，如异步操作或 UI 交互。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 代码简洁，适合短期任务。
    </p>
    <p>
     ​ • 避免定义额外的协议和类。
    </p>
    <p>
     ​ • 容易导致循环引用（需注意 [weak self]）。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>class MusicPlayer {
    var onFinishPlaying: (() -&gt; Void)?

    func play() {
        // 模拟播放完成
        onFinishPlaying?()
    }
}

let player = MusicPlayer()
player.onFinishPlaying = {
    print("播放完成")
}
player.play()
</code></pre>
    <p>
     <strong>
      3. Notification（通知中心）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对多
     </strong>
     通信，例如全局状态变化、系统广播（如键盘弹出）。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：使用 NotificationCenter 发送和监听通知。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 解耦性高，不需要直接引用发送者。
    </p>
    <p>
     ​ • 适用于全局事件，如应用生命周期、网络状态变化等。
    </p>
    <p>
     ​ • 可能导致代码难以跟踪，容易造成资源泄漏（监听后需移除）。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>// 发送通知
NotificationCenter.default.post(name: NSNotification.Name("MusicFinished"), object: nil)

// 监听通知
NotificationCenter.default.addObserver(self, selector: #selector(musicFinished), name: NSNotification.Name("MusicFinished"), object: nil)

@objc func musicFinished() {
    print("播放完成")
}
</code></pre>
    <p>
     <strong>
      4. swift_event_bus（事件总线）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对多
     </strong>
     或
     <strong>
      多对多
     </strong>
     事件传递，通常用于解耦模块间的通信。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：通过 SwiftEventBus 发布和订阅事件。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 类似 NotificationCenter，但更轻量级，支持异步和线程调度。
    </p>
    <p>
     ​ • 适用于模块化架构，如 MVVM、VIPER。
    </p>
    <p>
     ​ • 易用性比 NotificationCenter 更高，但不如 delegate 和 closure 类型安全。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>import SwiftEventBus

// 订阅事件
SwiftEventBus.onMainThread(self, name: "MusicFinished") { result in
    print("播放完成")
}

// 发送事件
SwiftEventBus.post("MusicFinished")
</code></pre>
    <p>
     <strong>
      总结对比
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         方式
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
       <th>
        <strong>
         关系类型
        </strong>
       </th>
       <th>
        <strong>
         适用范围
        </strong>
       </th>
       <th>
        <strong>
         代码复杂度
        </strong>
       </th>
       <th>
        <strong>
         解耦性
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         代理（Delegate）
        </strong>
       </td>
       <td>
        长期一对一通信
       </td>
       <td>
        一对一
       </td>
       <td>
        UI 组件、数据回调
       </td>
       <td>
        高
       </td>
       <td>
        低
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         闭包（Closure）
        </strong>
       </td>
       <td>
        短期回调
       </td>
       <td>
        一对一
       </td>
       <td>
        异步任务、临时事件
       </td>
       <td>
        低
       </td>
       <td>
        低
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Notification
        </strong>
       </td>
       <td>
        一对多通信
       </td>
       <td>
        一对多
       </td>
       <td>
        全局事件、广播
       </td>
       <td>
        中
       </td>
       <td>
        高
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         swift_event_bus
        </strong>
       </td>
       <td>
        模块间解耦
       </td>
       <td>
        一对多/多对多
       </td>
       <td>
        事件驱动架构
       </td>
       <td>
        低
       </td>
       <td>
        高
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      选择建议
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      一对一且长期的关系
     </strong>
     （如 UITableView）→
     <strong>
      Delegate
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      一对一且是短期任务
     </strong>
     （如异步回调）→
     <strong>
      Closure
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      一对多或全局事件
     </strong>
     （如 App 生命周期）→
     <strong>
      NotificationCenter
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      解耦多个模块的通信
     </strong>
     （如 MVVM）→
     <strong>
      swift_event_bus
     </strong>
    </p>
    <p>
     你目前的 myMusic 项目如果涉及 UI 组件间的通信，比如播放器状态更新，建议：
    </p>
    <p>
     ​ •
     <strong>
      使用 Delegate
     </strong>
     处理播放器的状态回调。
    </p>
    <p>
     ​ •
     <strong>
      使用 Closure
     </strong>
     处理网络请求回调。
    </p>
    <p>
     ​ •
     <strong>
      使用 NotificationCenter 或 swift_event_bus
     </strong>
     处理全局事件（如登录成功、歌曲切换）。
    </p>
    <p>
     主要用于
     <strong>
      组件之间的通信
     </strong>
     ，但它们的适用场景和工作方式有所不同。以下是它们的区别：
    </p>
    <p>
     <strong>
      1. 代理（Delegate）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对一
     </strong>
     通信，通常用于传递事件或回调，例如 UITableViewDelegate。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：使用
     <strong>
      协议（Protocol）
     </strong>
     定义代理方法，调用方实现代理协议并传递代理对象。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 强类型检查，编译时安全。
    </p>
    <p>
     ​ • 适用于长期存在的关系（如 UITableView 和 UITableViewDelegate）。
    </p>
    <p>
     ​ • 需要显式声明代理，并手动设置代理对象。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>protocol PlayerDelegate: AnyObject {
    func didFinishPlaying()
}

class MusicPlayer {
    weak var delegate: PlayerDelegate?

    func play() {
        // 模拟播放完成
        delegate?.didFinishPlaying()
    }
}

class ViewController: PlayerDelegate {
    let player = MusicPlayer()

    init() {
        player.delegate = self
        player.play()
    }

    func didFinishPlaying() {
        print("播放完成")
    }
}
</code></pre>
    <p>
     <strong>
      2. 闭包（Closure）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对一
     </strong>
     或
     <strong>
      临时性
     </strong>
     事件回调，例如网络请求完成后回调。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：将
     <strong>
      函数作为参数
     </strong>
     传递，通常用于短生命周期的任务，如异步操作或 UI 交互。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 代码简洁，适合短期任务。
    </p>
    <p>
     ​ • 避免定义额外的协议和类。
    </p>
    <p>
     ​ • 容易导致循环引用（需注意 [weak self]）。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>class MusicPlayer {
    var onFinishPlaying: (() -&gt; Void)?

    func play() {
        // 模拟播放完成
        onFinishPlaying?()
    }
}

let player = MusicPlayer()
player.onFinishPlaying = {
    print("播放完成")
}
player.play()
</code></pre>
    <p>
     <strong>
      3. Notification（通知中心）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对多
     </strong>
     通信，例如全局状态变化、系统广播（如键盘弹出）。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：使用 NotificationCenter 发送和监听通知。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 解耦性高，不需要直接引用发送者。
    </p>
    <p>
     ​ • 适用于全局事件，如应用生命周期、网络状态变化等。
    </p>
    <p>
     ​ • 可能导致代码难以跟踪，容易造成资源泄漏（监听后需移除）。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>// 发送通知
NotificationCenter.default.post(name: NSNotification.Name("MusicFinished"), object: nil)

// 监听通知
NotificationCenter.default.addObserver(self, selector: #selector(musicFinished), name: NSNotification.Name("MusicFinished"), object: nil)

@objc func musicFinished() {
    print("播放完成")
}
</code></pre>
    <p>
     <strong>
      4. swift_event_bus（事件总线）
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      适用场景
     </strong>
     ：适用于
     <strong>
      一对多
     </strong>
     或
     <strong>
      多对多
     </strong>
     事件传递，通常用于解耦模块间的通信。
    </p>
    <p>
     ​ •
     <strong>
      实现方式
     </strong>
     ：通过 SwiftEventBus 发布和订阅事件。
    </p>
    <p>
     ​ •
     <strong>
      特点
     </strong>
     ：
    </p>
    <p>
     ​ • 类似 NotificationCenter，但更轻量级，支持异步和线程调度。
    </p>
    <p>
     ​ • 适用于模块化架构，如 MVVM、VIPER。
    </p>
    <p>
     ​ • 易用性比 NotificationCenter 更高，但不如 delegate 和 closure 类型安全。
    </p>
    <p>
     <strong>
      代码示例：
     </strong>
    </p>
    <pre><code>import SwiftEventBus

// 订阅事件
SwiftEventBus.onMainThread(self, name: "MusicFinished") { result in
    print("播放完成")
}

// 发送事件
SwiftEventBus.post("MusicFinished")
</code></pre>
    <p>
     <strong>
      总结对比
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         方式
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
       <th>
        <strong>
         关系类型
        </strong>
       </th>
       <th>
        <strong>
         适用范围
        </strong>
       </th>
       <th>
        <strong>
         代码复杂度
        </strong>
       </th>
       <th>
        <strong>
         解耦性
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         代理（Delegate）
        </strong>
       </td>
       <td>
        长期一对一通信
       </td>
       <td>
        一对一
       </td>
       <td>
        UI 组件、数据回调
       </td>
       <td>
        高
       </td>
       <td>
        低
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         闭包（Closure）
        </strong>
       </td>
       <td>
        短期回调
       </td>
       <td>
        一对一
       </td>
       <td>
        异步任务、临时事件
       </td>
       <td>
        低
       </td>
       <td>
        低
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Notification
        </strong>
       </td>
       <td>
        一对多通信
       </td>
       <td>
        一对多
       </td>
       <td>
        全局事件、广播
       </td>
       <td>
        中
       </td>
       <td>
        高
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         swift_event_bus
        </strong>
       </td>
       <td>
        模块间解耦
       </td>
       <td>
        一对多/多对多
       </td>
       <td>
        事件驱动架构
       </td>
       <td>
        低
       </td>
       <td>
        高
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      选择建议
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      一对一且长期的关系
     </strong>
     （如 UITableView）→
     <strong>
      Delegate
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      一对一且是短期任务
     </strong>
     （如异步回调）→
     <strong>
      Closure
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      一对多或全局事件
     </strong>
     （如 App 生命周期）→
     <strong>
      NotificationCenter
     </strong>
    </p>
    <p>
     ​ •
     <strong>
      解耦多个模块的通信
     </strong>
     （如 MVVM）→
     <strong>
      swift_event_bus
     </strong>
    </p>
    <p>
     你目前的 myMusic 项目如果涉及 UI 组件间的通信，比如播放器状态更新，建议：
    </p>
    <p>
     ​ •
     <strong>
      使用 Delegate
     </strong>
     处理播放器的状态回调。
    </p>
    <p>
     ​ •
     <strong>
      使用 Closure
     </strong>
     处理网络请求回调。
    </p>
    <p>
     ​ •
     <strong>
      使用 NotificationCenter 或 swift_event_bus
     </strong>
     处理全局事件（如登录成功、歌曲切换）。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f556e6c696d697465645f63692f:61727469636c652f64657461696c732f313436313930343438" class_="artid" style="display:none">
 </p>
</div>


