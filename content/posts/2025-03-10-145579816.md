---
layout: post
title: "STM32-CAN模块原理与应用详解"
date: 2025-03-10 10:17:10 +0800
description: "CAN模块（Controller Area Network）是一种面向现场总线通信的串行通信协议，通过CAN总线可以连接多个控制器和设备，实现实时的数据通信。在STM32微控制器中，CAN模块通常由以下几个主要部分组成：CAN控制器（CAN Controller），CAN收发器（CAN Transceiver），CAN过滤器（CAN Filter）。本文详细介绍STM32 CAN模块实现原理与应用方法。"
keywords: "STM32 CAN模块原理与应用详解"
categories: ['Stm']
tags: ['嵌入式硬件', '单片机', 'Stm']
artid: "145579816"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145579816
    alt: "STM32-CAN模块原理与应用详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145579816
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145579816
cover: https://bing.ee123.net/img/rand?artid=145579816
image: https://bing.ee123.net/img/rand?artid=145579816
img: https://bing.ee123.net/img/rand?artid=145579816
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     STM32 CAN模块原理与应用详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E6%A6%82%E8%BF%B0" name="%E6%A6%82%E8%BF%B0">
     概述
    </h2>
    <p>
     CAN模块（Controller Area Network）是一种面向现场总线通信的串行通信协议，通过CAN总线可以连接多个控制器和设备，实现实时的数据通信。在STM32微控制器中，CAN模块通常由以下几个主要部分组成：CAN控制器（CAN Controller），CAN收发器（CAN Transceiver），CAN过滤器（CAN Filter）。本文详细介绍STM32 CAN模块实现原理与应用方法。
    </p>
    <h2 id="%E4%B8%80%E3%80%81CAN%E6%A8%A1%E5%9D%97%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86" name="%E4%B8%80%E3%80%81CAN%E6%A8%A1%E5%9D%97%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">
     <strong>
      一、CAN模块核心原理
     </strong>
    </h2>
    <h3 id="1.%20CAN%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80" name="1.%20CAN%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80">
     <strong>
      1. CAN协议基础
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        多主架构
       </strong>
       ：任意节点可主动发送，通过仲裁机制解决冲突
      </p>
     </li>
     <li>
      <p>
       <strong>
        差分信号
       </strong>
       ：CAN_H与CAN_L电压差表示逻辑（显性电平≈2V，隐性≈0V）
      </p>
     </li>
     <li>
      <p>
       <strong>
        帧类型
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          数据帧
         </strong>
         ：携带应用数据（标准帧11位ID，扩展帧29位ID）
        </p>
       </li>
       <li>
        <p>
         <strong>
          远程帧
         </strong>
         ：请求数据发送
        </p>
       </li>
       <li>
        <p>
         <strong>
          错误帧
         </strong>
         ：节点检测错误时发送
        </p>
       </li>
       <li>
        <p>
         <strong>
          过载帧
         </strong>
         ：延迟下一帧发送
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="2.%20STM32%20CAN%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84" name="2.%20STM32%20CAN%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84">
     <strong>
      2. STM32 CAN控制器结构
     </strong>
    </h3>
    <pre><code class="language-cpp">

typedef struct {
  __IO uint32_t MCR;     // 主控制寄存器
  __IO uint32_t MSR;     // 主状态寄存器
  __IO uint32_t TSR;     // 发送状态寄存器
  __IO uint32_t RF0R;    // 接收FIFO0寄存器
  __IO uint32_t RF1R;    // 接收FIFO1寄存器
  __IO uint32_t IER;     // 中断使能寄存器
  // ... 其他寄存器
} CAN_TypeDef;</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        双接收FIFO
       </strong>
       ：FIFO0和FIFO1各3级缓存
      </p>
     </li>
     <li>
      <p>
       <strong>
        3个发送邮箱
       </strong>
       ：支持优先级排序发送
      </p>
     </li>
     <li>
      <p>
       <strong>
        过滤器组
       </strong>
       ：最多28组（F4系列），可配置为屏蔽或列表模式
      </p>
     </li>
    </ul>
    <h3 id="3.%20%E6%B3%A2%E7%89%B9%E7%8E%87%E9%85%8D%E7%BD%AE" name="3.%20%E6%B3%A2%E7%89%B9%E7%8E%87%E9%85%8D%E7%BD%AE">
     <strong>
      3. 波特率配置
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        计算公式
       </strong>
       ：
      </p>
      <pre><code class="language-bash">BaudRate = CAN Clock(Prescaler)×(BS1+BS2+1)BaudRate=(Prescaler)×(BS1+BS2+1)CAN Clock​</code></pre>
     </li>
     <li>
      <p>
       <strong>
        典型配置
       </strong>
       （500kbps，APB1时钟42MHz）：
      </p>
      <pre><code class="language-cpp">hcan.Init.Prescaler = 6;
hcan.Init.TimeSeg1 = CAN_BS1_13TQ; // BS1 = 13 Tq
hcan.Init.TimeSeg2 = CAN_BS2_2TQ;  // BS2 = 2 Tq
hcan.Init.SJW = CAN_SJW_1TQ;       // 同步跳转宽度</code></pre>
     </li>
    </ul>
    <hr/>
    <h2 id="%E4%BA%8C%E3%80%81CAN%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%9F%BA%E4%BA%8EHAL%E5%BA%93%EF%BC%89" name="%E4%BA%8C%E3%80%81CAN%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%9F%BA%E4%BA%8EHAL%E5%BA%93%EF%BC%89">
     <strong>
      二、CAN模块配置步骤（基于HAL库）
     </strong>
    </h2>
    <h3 id="1.%20%E5%88%9D%E5%A7%8B%E5%8C%96CAN%E5%A4%96%E8%AE%BE" name="1.%20%E5%88%9D%E5%A7%8B%E5%8C%96CAN%E5%A4%96%E8%AE%BE">
     <strong>
      1. 初始化CAN外设
     </strong>
    </h3>
    <pre><code class="language-cpp">
CAN_HandleTypeDef hcan;

void CAN_Init(void)
{
  hcan.Instance = CAN1;
  hcan.Init.Mode = CAN_MODE_NORMAL;       // 正常模式
  hcan.Init.AutoBusOff = ENABLE;          // 自动总线关闭恢复
  hcan.Init.AutoWakeUp = DISABLE;         // 禁止自动唤醒
  hcan.Init.AutoRetransmission = ENABLE;  // 自动重传
  hcan.Init.ReceiveFifoLocked = DISABLE;  // FIFO不锁定
  hcan.Init.TimeTriggeredMode = DISABLE;  // 非时间触发模式
  
  if (HAL_CAN_Init(&amp;hcan) != HAL_OK) {
    Error_Handler();
  }
}</code></pre>
    <h3 id="2.%20%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8" name="2.%20%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8">
     <strong>
      2. 配置过滤器
     </strong>
    </h3>
    <pre><code class="language-cpp">

CAN_FilterTypeDef filter;

void CAN_Filter_Config(void) 
{
  filter.FilterBank = 0;                   // 使用过滤器组0
  filter.FilterMode = CAN_FILTERMODE_IDMASK; // 屏蔽模式
  filter.FilterScale = CAN_FILTERSCALE_32BIT;
  filter.FilterIdHigh = 0x123 &lt;&lt; 5;        // 标准ID 0x123，左移5位对齐
  filter.FilterIdLow = 0x0000;
  filter.FilterMaskIdHigh = 0x7FF &lt;&lt; 5;    // 检查所有标准ID位
  filter.FilterMaskIdLow = 0x0000;
  filter.FilterFIFOAssignment = CAN_FILTER_FIFO0; // 匹配的报文存入FIFO0
  filter.FilterActivation = ENABLE;
  filter.SlaveStartFilterBank = 14;        // 双CAN时分配过滤器组

  HAL_CAN_ConfigFilter(&amp;hcan, &amp;filter);
}</code></pre>
    <h3 id="3.%20%E5%90%AF%E5%8A%A8CAN%E9%80%9A%E4%BF%A1" name="3.%20%E5%90%AF%E5%8A%A8CAN%E9%80%9A%E4%BF%A1">
     <strong>
      3. 启动CAN通信
     </strong>
    </h3>
    <pre><code class="language-cpp">

HAL_CAN_Start(&amp;hcan);
HAL_CAN_ActivateNotification(&amp;hcan, CAN_IT_RX_FIFO0_MSG_PENDING); // 使能接收中断</code></pre>
    <hr/>
    <h2 id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E5%AE%9E%E7%8E%B0" name="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E5%AE%9E%E7%8E%B0">
     <strong>
      三、数据收发实现
     </strong>
    </h2>
    <h3 id="1.%20%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%B8%A7" name="1.%20%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%B8%A7">
     <strong>
      1. 发送数据帧
     </strong>
    </h3>
    <pre><code class="language-cpp">

CAN_TxHeaderTypeDef tx_header;
uint8_t tx_data[8] = {0x01, 0x02, 0x03, 0x04};
uint32_t tx_mailbox;

void CAN_SendMessage(void) 
{
  tx_header.StdId = 0x123;              // 标准ID
  tx_header.ExtId = 0x00;               // 扩展ID（标准帧时设为0）
  tx_header.RTR = CAN_RTR_DATA;         // 数据帧
  tx_header.IDE = CAN_ID_STD;           // 标准ID格式
  tx_header.DLC = 4;                    // 数据长度4字节
  tx_header.TransmitGlobalTime = DISABLE;

  if (HAL_CAN_AddTxMessage(&amp;hcan, &amp;tx_header, tx_data, &amp;tx_mailbox) != HAL_OK) {
    // 处理发送失败
  }
}</code></pre>
    <h3 id="2.%20%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%B8%A7%EF%BC%88%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%EF%BC%89" name="2.%20%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%B8%A7%EF%BC%88%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%EF%BC%89">
     <strong>
      2. 接收数据帧（中断方式）
     </strong>
    </h3>
    <pre><code class="language-cpp">

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) 
{
  CAN_RxHeaderTypeDef rx_header;
  uint8_t rx_data[8];
  
  HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;rx_header, rx_data);
  
  if(rx_header.StdId == 0x123) { // 检查ID
    // 处理接收数据
  }
}</code></pre>
    <hr/>
    <h2 id="%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" name="%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">
     <strong>
      四、高级应用场景
     </strong>
    </h2>
    <h3 id="1.%20CANopen%E5%8D%8F%E8%AE%AE%E9%9B%86%E6%88%90" name="1.%20CANopen%E5%8D%8F%E8%AE%AE%E9%9B%86%E6%88%90">
     <strong>
      1. CANopen协议集成
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        对象字典映射
       </strong>
       ：将CAN ID与PDO/SDO映射
      </p>
      <pre><code class="language-cpp">// PDO通信参数配置
CO_OD_configure(CO-&gt;SDO, 0x1400, 0x01, 0x00000200 + 0x123); // PDO1映射到ID 0x123</code></pre>
     </li>
     <li>
      <p>
       <strong>
        心跳管理
       </strong>
       ：周期性发送节点状态
      </p>
      <pre><code class="language-cpp">void Send_Heartbeat(void) 
{
     uint8_t hb_msg[1] = {0x05}; // 运行状态
     CAN_SendMessage(0x700 + node_id, hb_msg, 1);
}</code></pre>
     </li>
    </ul>
    <h3 id="2.%20%E5%8F%8CCAN%E5%86%97%E4%BD%99%E8%AE%BE%E8%AE%A1" name="2.%20%E5%8F%8CCAN%E5%86%97%E4%BD%99%E8%AE%BE%E8%AE%A1">
     <strong>
      2. 双CAN冗余设计
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        硬件连接
       </strong>
       ：两个CAN控制器并联，共用总线
      </p>
     </li>
     <li>
      <p>
       <strong>
        故障切换逻辑
       </strong>
       ：
      </p>
      <pre><code class="language-cpp">

if(CAN1_Status == ERROR) {
  HAL_CAN_Stop(&amp;hcan1);
  HAL_CAN_Start(&amp;hcan2); // 切换到CAN2
}</code></pre>
     </li>
    </ul>
    <h3 id="3.%20%E6%80%BB%E7%BA%BF%E8%AF%8A%E6%96%AD%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" name="3.%20%E6%80%BB%E7%BA%BF%E8%AF%8A%E6%96%AD%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">
     <strong>
      3. 总线诊断与错误处理
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        错误计数器监控
       </strong>
       ：
      </p>
      <pre><code class="language-cpp">uint32_t err_code = hcan.Instance-&gt;ESR;
uint8_t rec = (err_code &amp; CAN_ESR_REC) &gt;&gt; 24; // 接收错误计数器
uint8_t tec = (err_code &amp; CAN_ESR_TEC) &gt;&gt; 16; // 发送错误计数器</code></pre>
     </li>
     <li>
      <p>
       <strong>
        总线状态判断
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Error Active
         </strong>
         ：TEC/REC &lt; 128
        </p>
       </li>
       <li>
        <p>
         <strong>
          Error Passive
         </strong>
         ：TEC/REC ≥ 128
        </p>
       </li>
       <li>
        <p>
         <strong>
          Bus Off
         </strong>
         ：TEC ≥ 256
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h2 id="%E4%BA%94%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7" name="%E4%BA%94%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7">
     <strong>
      五、调试与优化技巧
     </strong>
    </h2>
    <h3 id="1.%20%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95%E8%A6%81%E7%82%B9" name="1.%20%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95%E8%A6%81%E7%82%B9">
     <strong>
      1. 硬件调试要点
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        终端电阻
       </strong>
       ：总线两端需接120Ω电阻
      </p>
     </li>
     <li>
      <p>
       <strong>
        信号质量检测
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         示波器测量CAN_H与CAN_L差分信号
        </p>
       </li>
       <li>
        <p>
         确保显性电平1.5-3V，隐性电平&lt;0.5V
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="2.%20%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7" name="2.%20%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7">
     <strong>
      2. 软件调试工具
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        CAN分析仪
       </strong>
       ：使用PCAN-USB或周立功CAN卡捕获报文
      </p>
     </li>
     <li>
      <p>
       <strong>
        STM32CubeMonitor
       </strong>
       ：实时监控CAN总线负载率
      </p>
     </li>
    </ul>
    <h3 id="3.%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" name="3.%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5">
     <strong>
      3. 性能优化策略
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        DMA传输
       </strong>
       ：使用DMA处理大批量数据
      </p>
      <pre><code class="language-cpp">HAL_CAN_Start_DMA(&amp;hcan, CAN_RX_FIFO0);</code></pre>
     </li>
     <li>
      <p>
       <strong>
        邮箱优先级
       </strong>
       ：重要数据使用高优先级邮箱发送
      </p>
      <pre><code class="language-cpp">tx_header.TxPriority = CAN_TXPRIORITY_HIGH; // 设置发送优先级</code></pre>
     </li>
    </ul>
    <hr/>
    <h2 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93">
     <strong>
      总结
     </strong>
    </h2>
    <p>
     STM32 CAN模块为工业控制、汽车电子等场景提供可靠通信解决方案，开发时需注意：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        正确配置波特率
       </strong>
       ：
       <span style="background-color:#a2e043">
        确保所有节点时钟参数
       </span>
       一致
      </p>
     </li>
     <li>
      <p>
       <strong>
        合理使用过滤器
       </strong>
       ：减少CPU中断负载
      </p>
     </li>
     <li>
      <p>
       <strong>
        错误处理机制
       </strong>
       ：监控ESR寄存器，实现故障恢复
      </p>
     </li>
     <li>
      <p>
       <strong>
        协议栈集成
       </strong>
       ：结合CANopen等高层协议提升开发效率
      </p>
     </li>
    </ul>
    <p>
     示例代码基于STM32 HAL库实现，实际开发中需根据具体型号调整寄存器配置。对于高实时性要求场景，可结合FreeRTOS任务管理CAN通信，确保关键报文及时处理。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f6d6674616e672f:61727469636c652f64657461696c732f313435353739383136" class_="artid" style="display:none">
 </p>
</div>


