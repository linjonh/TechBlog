---
layout: post
title: "Java,Golang,Rust-泛型的大体对比小记"
date: 2025-03-06 14:28:21 +0800
description: "在我重构JVM尝试实现泛型时，在阅读《深入理解JVM》这本书时，对Java泛型的实现原因和应用场景有了一定了解，书中也将其与C#泛型进行了简单对比。当我去年在学习Golang时，也发现了Golang在1.8后才提供了泛型，并不是原生自带而是与Java类似在中间版本加入的特性，网上也有众多言论在抨击Golang泛型 \"代码丑陋\"，\"使用别扭\"。"
keywords: "Java，Golang，Rust 泛型的大体对比小记"
categories: ['学习问题解决']
tags: ['Rust', 'Java', 'Golang']
artid: "146063885"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146063885
    alt: "Java,Golang,Rust-泛型的大体对比小记"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146063885
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146063885
cover: https://bing.ee123.net/img/rand?artid=146063885
image: https://bing.ee123.net/img/rand?artid=146063885
img: https://bing.ee123.net/img/rand?artid=146063885
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java，Golang，Rust 泛型的大体对比小记
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     引子
    </h2>
    <p>
     在我重构JVM尝试实现泛型时，在阅读《深入理解JVM》这本书时，对Java泛型的实现原因和应用场景有了一定了解，书中也将其与C#泛型进行了简单对比。当我去年在学习Golang时，也发现了Golang在1.8后才提供了泛型，并不是原生自带而是与Java类似在中间版本加入的特性，网上也有众多言论在抨击Golang泛型 "代码丑陋"，"使用别扭"。在近期我学习完Rust的泛型和trait后，对Rust泛型的 zero_abstract 也有了一定的理解，所以基于这个背景条件，我对三者进行了比对学习，并且总结成这篇小记。
    </p>
    <p>
    </p>
    <h2>
     一，Java的泛型
    </h2>
    <p>
     在java中，泛型的实现方式叫 “
     <strong>
      类型擦除式泛型
     </strong>
     ”(Type Erasure Generics)，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替代为原来的
     <strong>
      裸类型
     </strong>
     ，所以对于 ArrayList&lt;Integer&gt; 和 ArrayList&lt;String&gt; 来说他们都时一个类型(Raw Tyoe， 裸类型)。而C#则采取的是 “
     <strong>
      具现化式类型
     </strong>
     ”， 即泛型在源码以及编译后的中间语言中或是在运行时都是存在的。举例：即我们不能使用 instanceof 对泛型进行实例判断，但是C#可以。
    </p>
    <p>
     Java 5.0 引入泛型时，可以采取两种做法：
    </p>
    <ul>
     <li>
      需要泛型化的类型，以前有的就不办，平行的添加一套泛型化版本的新类型。
     </li>
     <li>
      直接把已有的类型泛型化。
     </li>
    </ul>
    <p>
     考虑到Java在当时已经是诞生的第10年，遗留代码量极大，再加之Java已经存在了2套容器，如Vector和Arraylist，所以如果再添加一套会让语言显得特别臃肿。所以开发者采取了第二种方式。
    </p>
    <p>
     本质上，Java的类型擦除是将所有的泛型设置为裸类型(所有泛化类型的共同父类型)，在编译时将类似于ArrayList&lt;Integer&gt;或者ArrayList&lt;String&gt;粗暴的转化为ArrayList类型，在元素访问时插入了从Object到Integer或者String的强制转型代码。在运行时进行了所有的类型操作。
    </p>
    <h2>
     二. Rust 泛型
    </h2>
    <p>
     Rust的泛型是语言原生支持的，实现方式为 “
     <strong>
      单态化
     </strong>
     ”，使得 Rust 在性能上具有
     <strong>
      零成本抽象
     </strong>
     （zero-cost abstraction）。可以对特征(trait)对泛型进行约束：
    </p>
    <pre><code class="language-rust">trait Stack&lt;T&gt; {
    fn push(&amp;mut self, item: T);
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;
}
</code></pre>
    <p>
     零成本抽象的实现，其实本质上就是在编译时期，Rust就会生成对应调用版本的代码，比如我希望实现一个 fn add(i: T, j:T) -&gt; T{} ，在调用时，我传入的时i32，那么在编译时Rust就会自动生成其对应的代码(即
     <strong>
      元编程
     </strong>
     )，在运行时就不需要和Java一样进行类型擦除和强转，所以其效率是极高的。
    </p>
    <p>
     但是这样做也会有缺陷——
     <strong>
      代码膨胀
     </strong>
    </p>
    <h2>
     <strong>
      三. Golang 泛型
     </strong>
    </h2>
    <p>
     Golang 采用
     <strong>
      字节码共享
     </strong>
     （monomorphization + type erasure）的方式处理泛型：
    </p>
    <ul>
     <li>
      <strong>
       部分类型（如
       <code>
        int
       </code>
       、
       <code>
        float64
       </code>
       ）会进行代码展开
      </strong>
      （类似 C++ 模板）。
     </li>
     <li>
      <strong>
       但大多数类型在编译时仍使用
       <code>
        interface{}
       </code>
       实现
      </strong>
      （类似 Java 泛型的类型擦除）。
     </li>
    </ul>
    <p>
     这导致泛型代码的性能
     <strong>
      有时不如直接用
      <code>
       interface{}
      </code>
     </strong>
     ，因为 Go 需要在运行时做类型转换。
    </p>
    <p>
     在大家诟病Golang泛型的几大原因：
    </p>
    <p>
    </p>
    <ol>
     <li>
      其采用的表示方式为 `[ ]` 而不是大家一直以来熟悉的 `&lt; &gt;`在潜意识里 `[ ]` 会被我们和数组联系起来，所以不太直观。
     </li>
     <li>
      <p>
       Go 泛型
       <strong>
        无法
       </strong>
       直接用于接口类型，而只能通过普通的
       <code>
        struct
       </code>
       组合使用：
      </p>
      <pre><code class="language-Go">// ❌ 错误，Go 不支持泛型接口
type Stack[T any] interface { 
    Push(T)
    Pop() T
}

// ✅ 正确
type Stack[T any] struct {
    items []T
}
</code></pre>
     </li>
     <li>
      Golang 泛型也不能用于方法的
      <strong>
       类型接收者
      </strong>
      ，而是只能用指针接收者：
      <pre><code class="language-Go">​
type MyType[T any] struct {
    value T
}

// ❌ 不能这样写
func (m MyType[T]) Get() T {
    return m.value
}

func (m *MyType[T]) Get() T { // ✅ 只能用指针接收者
    return m.value
}

​</code></pre>
     </li>
     <li>
      泛型不支持运算符重载
     </li>
    </ol>
    <h2>
     四. 小结
    </h2>
    <p>
     为什么Golang泛型被喷，我想大概还是因为其实现方式的妥协，作为一个追求高性能的编程语言，在泛型的实现中并没有保持语言本身的追求，而是采取了妥协中庸的解决办法，杂糅了Rust和Java的泛型，导致其不仅仅在语法习惯上让广大码农感觉不适。同时由于在某些条件下其采用了类型擦除式泛型的实现，也让其性能不如其对标的c/cpp。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37343738333739322f:61727469636c652f64657461696c732f313436303633383835" class_="artid" style="display:none">
 </p>
</div>


