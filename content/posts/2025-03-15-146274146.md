---
layout: post
title: "C-NX二次开发在多个体的模型中如何实现拉伸操作布尔减"
date: 2025-03-15 20:06:49 +0800
description: "​大家好，今天接着上一篇拉伸文章去讲。UF_MODL_create_extruded1 (view source)uf_list_p_t\tobjects\tInput\tList of objects to be extruded.char *\ttaper_angle\tInput\tTaper angle (in degrees).char *\tlimit [ 2 ]\tInput\tLimit of extrusion. This is declared as:char limit[2]. Th"
keywords: "C# NX二次开发：在多个体的模型中如何实现拉伸操作布尔减"
categories: ['Nx']
tags: ['服务器', '开发语言', 'C']
artid: "146274146"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146274146
    alt: "C-NX二次开发在多个体的模型中如何实现拉伸操作布尔减"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146274146
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146274146
cover: https://bing.ee123.net/img/rand?artid=146274146
image: https://bing.ee123.net/img/rand?artid=146274146
img: https://bing.ee123.net/img/rand?artid=146274146
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# NX二次开发：在多个体的模型中如何实现拉伸操作布尔减
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     大家好，今天接着上一篇拉伸文章去讲。
    </p>
    <p>
     UF_MODL_create_extruded1
     <a href="uf_modl_sweep.html#UF_MODL_create_extruded1" rel="nofollow">
      (view source)
     </a>
    </p>
    <p>
     <img alt="" height="528" src="https://i-blog.csdnimg.cn/direct/af1940bf2abd4b53a6d5792c2ea5b95c.png" width="560"/>
    </p>
    <table cellpadding="10" id="proto">
     <tbody>
      <tr id="proto">
       <td id="proto1">
        <a rel="nofollow">
         uf_list_p_t
        </a>
       </td>
       <td id="proto2">
        objects
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        List of objects to be extruded.
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        char *
       </td>
       <td id="proto2">
        taper_angle
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        Taper angle (in degrees).
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        char *
       </td>
       <td id="proto2">
        limit [ 2 ]
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        Limit of extrusion. This is declared as:
        <br/>
        char limit[2]. The first value is the start value of
        <br/>
        the extrusion and the second value is the end of the
        <br/>
        extrusion (see the example program).
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        double
       </td>
       <td id="proto2">
        point [ 3 ]
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        not used
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        double
       </td>
       <td id="proto2">
        direction [ 3 ]
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        Extrusion axis.
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        <a rel="nofollow">
         UF_FEATURE_SIGN
        </a>
       </td>
       <td id="proto2">
        sign
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        The sign of the operation to be performed.
        <br/>
        UF_NULLSIGN = create new target solid
        <br/>
        UF_POSITIVE = add to target solid
        <br/>
        UF_NEGATIVE = subtract from target solid
        <br/>
        UF_UNSIGNED = intersect with target solid
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        <a rel="nofollow">
         tag_t
        </a>
       </td>
       <td id="proto2">
        target_body
       </td>
       <td id="proto3">
        Input
       </td>
       <td id="proto4">
        Target body to perform Boolean
       </td>
      </tr>
      <tr id="proto">
       <td id="proto1">
        <a rel="nofollow">
         uf_list_p_t *
        </a>
       </td>
       <td id="proto2">
        features
       </td>
       <td id="proto3">
        Output to UF_*free*
       </td>
       <td id="proto4">
        List of feature identifiers created. This list
        <br/>
        must be freed by calling UF_MODL_delete_list.
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     可能大家也注意到了这里面多了一个传入目标体的参数，这个时候大家可能以为这就是解决了上面所说的那个问题了，我当时也是这样认为的，可到了使用的时候才知道，你传入的Tag值也不起作用，这个API是有问题的。
    </p>
    <p>
     上一篇文章讲到这有问题的，现在来讲如果想要实现标题中想要的效果怎么解决。
    </p>
    <p>
     直接上代码就不来虚的了：
    </p>
    <p>
     /// &lt;summary&gt;
     <br/>
     /// 使用NXOPEN来创建拉伸操作并且返回特征的tag值
     <br/>
     /// &lt;/summary&gt;
     <br/>
     /// &lt;returns&gt;&lt;/returns&gt;
     <br/>
     public Tag NXopenCreateExtrude(string endextend, Feature feature, Sketch sketch,Body body)
     <br/>
     {
     <!-- -->
     <br/>
     NXOpen.Features.Feature nullNXOpen_Features_Feature = null;
     <br/>
     NXOpen.Features.ExtrudeBuilder extrudeBuilder1;
     <br/>
     extrudeBuilder1 = workPart.Features.CreateExtrudeBuilder(nullNXOpen_Features_Feature);
     <br/>
     NXOpen.Section section1;
     <br/>
     section1 = workPart.Sections.CreateSection(0.00095, 0.001, 0.050000000000000003);
     <br/>
     extrudeBuilder1.Section = section1;
     <br/>
     extrudeBuilder1.AllowSelfIntersectingSection(true);
     <br/>
     NXOpen.Unit unit1;
     <br/>
     unit1 = extrudeBuilder1.Draft.FrontDraftAngle.Units;
     <br/>
     extrudeBuilder1.BooleanOperation.Type = NXOpen.GeometricUtilities.BooleanOperation.BooleanType.Create;
     <br/>
     NXOpen.Body[] targetBodies1 = new NXOpen.Body[1];
     <br/>
     NXOpen.Body nullNXOpen_Body = null;
     <br/>
     targetBodies1[0] = nullNXOpen_Body;
     <br/>
     extrudeBuilder1.BooleanOperation.SetTargetBodies(targetBodies1);
     <br/>
     extrudeBuilder1.Limits.StartExtend.Value.SetFormula("0");
     <br/>
     extrudeBuilder1.Limits.EndExtend.Value.SetFormula(endextend);
     <br/>
     extrudeBuilder1.BooleanOperation.Type = NXOpen.GeometricUtilities.BooleanOperation.BooleanType.Subtract;
     <br/>
     NXOpen.Body[] targetBodies2 = new NXOpen.Body[1];
     <br/>
     targetBodies2[0] = nullNXOpen_Body;
     <br/>
     extrudeBuilder1.BooleanOperation.SetTargetBodies(targetBodies2);
     <br/>
     NXOpen.GeometricUtilities.SmartVolumeProfileBuilder smartVolumeProfileBuilder1;
     <br/>
     smartVolumeProfileBuilder1 = extrudeBuilder1.SmartVolumeProfile;
     <br/>
     smartVolumeProfileBuilder1.OpenProfileSmartVolumeOption = false;
     <br/>
     smartVolumeProfileBuilder1.CloseProfileRule = NXOpen.GeometricUtilities.SmartVolumeProfileBuilder.CloseProfileRuleType.Fci;
     <br/>
     section1.SetAllowedEntityTypes(NXOpen.Section.AllowTypes.OnlyCurves);
     <br/>
     NXOpen.Features.Feature[] features1 = new NXOpen.Features.Feature[1];
     <br/>
     //NXOpen.Features.SketchFeature sketchFeature1 = ((NXOpen.Features.SketchFeature)workPart.Features.FindObject("SKETCH(490)"));
     <br/>
     features1[0] = feature;
     <br/>
     NXOpen.CurveFeatureRule curveFeatureRule1;
     <br/>
     curveFeatureRule1 = workPart.ScRuleFactory.CreateRuleCurveFeature(features1);
     <br/>
     section1.AllowSelfIntersection(true);
     <br/>
     NXOpen.SelectionIntentRule[] rules1 = new NXOpen.SelectionIntentRule[1];
     <br/>
     rules1[0] = curveFeatureRule1;
     <br/>
     NXOpen.NXObject nullNXOpen_NXObject = null;
     <br/>
     NXOpen.Point3d helpPoint1 = new NXOpen.Point3d(0.0, 0.0, 0.0);
     <br/>
     section1.AddToSection(rules1, nullNXOpen_NXObject, nullNXOpen_NXObject, nullNXOpen_NXObject, helpPoint1, NXOpen.Section.Mode.Create, false);
     <br/>
     NXOpen.Sketch sketch1 = sketch;
     <br/>
     NXOpen.Direction direction1;
     <br/>
     direction1 = workPart.Directions.CreateDirection(sketch1, NXOpen.Sense.Forward, NXOpen.SmartObject.UpdateOption.WithinModeling);
     <br/>
     extrudeBuilder1.Direction = direction1;
     <br/>
     NXOpen.Unit unit2;
     <br/>
     unit2 = extrudeBuilder1.Offset.StartOffset.Units;
     <br/>
     //NXOpen.Expression expression2;
     <br/>
     //expression2 = workPart.Expressions.CreateSystemExpressionWithUnits("0", unit2);
     <br/>
     extrudeBuilder1.BooleanOperation.Type = NXOpen.GeometricUtilities.BooleanOperation.BooleanType.Subtract;
     <br/>
     NXOpen.Body[] targetBodies3 = new NXOpen.Body[1];
     <br/>
     NXOpen.Body body1 = body;
     <br/>
     targetBodies3[0] = body1;
     <br/>
     extrudeBuilder1.BooleanOperation.SetTargetBodies(targetBodies3);
     <br/>
     extrudeBuilder1.ParentFeatureInternal = false;
     <br/>
     NXOpen.Features.Feature feature1;
     <br/>
     feature1 = extrudeBuilder1.CommitFeature();
     <br/>
     NXOpen.Expression expression3 = extrudeBuilder1.Limits.StartExtend.Value;
     <br/>
     NXOpen.Expression expression4 = extrudeBuilder1.Limits.EndExtend.Value;
     <br/>
     extrudeBuilder1.Destroy();
     <br/>
     //workPart.Expressions.Delete(expression2);
     <br/>
     return feature1.Tag;
     <br/>
     }
    </p>
    <p>
     解决方法是我采用了NXOPEN重新封装了一个方法，然后这些入参都是我试验过的，需要的小伙伴直接拿去用就行了。
     <br/>
     实验效果也是达到了我们想要的预期效果，非常nice。
    </p>
    <p>
     今天要讲的就这么多，我们下篇文章再见。
    </p>
    <p>
     散会
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35333130343033332f:61727469636c652f64657461696c732f313436323734313436" class_="artid" style="display:none">
 </p>
</div>


