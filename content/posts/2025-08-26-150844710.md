---
layout: post
title: "数据结构C语言篇一算法复杂度"
date: 2025-08-26T13:06:42+0800
description: "本文介绍了算法复杂度分析的关键概念。时间复杂度衡量算法执行时间随输入规模增长的变化趋势，空间复杂度反映算法内存占用情况。文章详细讲解了如何通过大O渐进表示法计算复杂度，包括保留最高阶项、去除常数系数等规则，并通过多个代码示例演示了常见时间复杂度（如O(1)、O(n)、O(n²)、O(logn)）的计算方法。同时指出实际应用中主要关注最坏情况时间复杂度，并简要介绍了空间复杂度的分析思路。最后通过旋转数组题目展示了不同复杂度算法的实现对比。"
keywords: "c语言中复杂运算"
categories: ['数据结构']
tags: ['算法', '空间复杂度', '时间复杂度', '数据结构', '学习笔记', '复杂度', 'C']
artid: "150844710"
arturl: "https://blog.csdn.net/2301_79248256/article/details/150844710"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150844710
    alt: "数据结构C语言篇一算法复杂度"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150844710
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150844710
cover: https://bing.ee123.net/img/rand?artid=150844710
image: https://bing.ee123.net/img/rand?artid=150844710
img: https://bing.ee123.net/img/rand?artid=150844710
---



# 数据结构（C语言篇）：（一）算法复杂度



## **目录**































---

## 前言

>         在计算机科学中，算法复杂度是衡量算法效率的核心指标，直接影响程序的性能与资源消耗。时间复杂度描述算法执行时间随输入规模增长的变化趋势，而空间复杂度则反映算法对内存的占用情况。通过分析复杂度，可以优化算法设计，避免不必要的计算浪费，尤其在处理大规模数据时，高效的算法能显著提升系统响应速度与资源利用率。理解算法复杂度不仅是理论研究的基础，更是工程实践中不可或缺的技能。下面话不多说，就让我们正式开始吧！

---

## 一、数据结构前言

### 1.1  数据结构是什么？

**数据结构（Data Structure）**是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。没有一种单一的数据结构对所有用途都有用，所以我们要学各式各样的数据结构，如：线性表、树、图、哈希等。

### 1.2  算法

**算法（Algorithm）**就是定义良好的计算过程，它取一个或一组的值作为输入，并产出一个或一组的值作为输出。简单来说算法就是一系列的计算过程，用来将输入的数据转化为输出结果。

## 二、算法效率

        了解了算法是什么之后，我们又应该如何衡量一个算法的好坏呢？

### 2.1  复杂度的概念

        算法在编写成可执行程序之后，运行时需要耗费一定的时间资源和空间（内存）资源。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即**时间复杂度和空间复杂度**。

**时间复杂度主要衡量的是一个算法的运行快慢，而空间复杂度则主要衡量一个算法运行所需要的额外空间。**在计算机发展的早期，计算机的存储容量很小，所以空间复杂度就很重要了。但是经过计算机行业的迅速发展，计算机的存储容量已经打到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。

### 2.2  复杂度的重要性

        复杂度在校招中的考察是很常见的，如下所示：

![](https://i-blog.csdnimg.cn/direct/f71bccd16d3b4580a371b939160986d8.png)

## 三、时间复杂度

        定义：在计算机科学中，**算法的时间复杂度是一个函数式T（N）**，它定量描述了该算法的运行时间。时间复杂度是衡量程序的时间效率，那么为什么不去计算程序的运行时间呢？

> 1. 因为程序运行时间和编译环境与运行机器的配置都有关系，比如同一个算法程序，用一个老编译器进行编译和新编译器编译，在同样机器下运行时间不同。
> 2. 同一个算法程序，用同一个老低配置机器和新高配置机器，运行时间也不同。
> 3. 并且时间复杂度只能在程序写好后进行测试，不能在写程序之前通过理论思想计算评估。

        那么算法的时间复杂度的一个函数式T（N）到底是什么呢？这个函数式计算了程序的执行次数。通过C语言编译链接相关知识的学习，我们知道算法程序被编译后会生成二进制指令，程序运行就是CPU执行这些编译好的指令。

        那么我们通过程序代码或者理论思想计算出程序的执行次数的函数式T（N），假设每句指令执行时间基本一样（实际中是有差别的，但是微乎其微），那么执行次数和运行时间就是等比正相关，这样也脱离了具体的编译运行环境。于是执行次数就可以表示程序时间效率的优劣。比如解决一个问题的算法a所对应的程序T（N）= N，算法b程序T（N）= N ^ 2，那么算法a的效率一定是优于算法b的。

        下面我们来看一个案例：

```
// 请计算⼀下Func1中++count语句总共执⾏了多少次？
void Func1(int N)
{
    int count = 0;
    for (int i = 0; i < N ; ++ i)
    {
        for (int j = 0; j < N ; ++ j)
        {
            ++count;
        }
    } 
    
    for (int k = 0; k < 2 * N ; ++ k)
    {
        ++count;
    } 
    int M = 10;
    while (M--)
    {
        ++count;
    }
}
```

        Func1执行的基本操作次数如下：

![T\left ( N \right )=N^{2}+2*N+10](https://latex.csdn.net/eq?T%5Cleft%20%28%20N%20%5Cright%20%29%3DN%5E%7B2%7D&plus;2*N&plus;10)

* N = 10 时，T(N) = 130
* N = 100时，T(N) = 10210
* N = 1000时，T(N) = 1002010

        通过对N的取值分析可知，对结果影响最大的一项是![N^{2}](https://latex.csdn.net/eq?N%5E%7B2%7D)

        实际中我们在计算时间复杂度时，计算的也不是程序的精确的执行次数，精确执行次数计算起来还是很麻烦的（不同的一句程序代码，编译出的指令条数都是不一样的），计算出精确的执行次数意义也不大，因为我们计算时间复杂度只是想比较算法程序的增长量级，也就是当N不断变大时T(N)的差别，上面我们已经看到了当N不断变大时常数和低阶项对结果的影响很小，所以我们只需要**计算程序能代表增长量级的大概执行次数，复杂度的表示通常使用大O的渐进表示法。**

### 3.1  大O的渐进表示法

        大O符号（Big O Notation）：是用于描述函数渐进行为的数学符号。

> 💡  **推导大O阶规则**
>
> 1. 时间复杂度函数式T(N)中，只保留最高阶项，去掉那些低阶项，因为当N不断变大时，低阶项对结果的影响越来越小，当N无穷大的时候，就可以忽略不计了。
> 2. 如果最高阶项存在且不是1，则去除这个项目的常数系数，因为当N不断变大时，这个系数对结果的影响越来越小，当N无穷大的时候，就可以忽略不计了。
> 3. T(N)中如果没有N相关的项目，而只有常数项，那么用常数1取代所有的加法常数。

        通过以上方法的计算，我们最终就可以得到Func1的时间复杂度为：![O(N^{2})](https://latex.csdn.net/eq?O%28N%5E%7B2%7D%29)

### 3.2  时间复杂度计算示例

#### 3.2.1  示例1

```
// 计算Func2的时间复杂度？
void Func2(int N)
{
    int count = 0;
    for (int k = 0; k < 2 * N ; ++ k)
    {
        ++count;
    } 
    int M = 10;
    while (M--)
    {
        ++count;
    } 
    printf("%d\n", count);
}
```

**Func2执行的基本操作次数：![T(N)=2N+10](https://latex.csdn.net/eq?T%28N%29%3D2N&plus;10)**

        根据推导规则第三条可以得出，Func的时间复杂度为：![O(N)](https://latex.csdn.net/eq?O%28N%29)

#### 3.2.2  示例2

```
// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
    int count = 0;
    for (int k = 0; k < M; ++ k)
    {
        ++count;
    } 
    for (int k = 0; k < N ; ++k)    
    {
        ++count;
    } 
    printf("%d\n", count);
}
```

**Func3执行的基本操作次数：**![T(N)=M+N](https://latex.csdn.net/eq?T%28N%29%3DM&plus;N)

        因此Func3的时间复杂度为：![O(N)](https://latex.csdn.net/eq?O%28N%29)

#### 3.2.3  示例3

```
// 计算Func4的时间复杂度？
void Func4(int N)
{
    int count = 0;
    for (int k = 0; k < 100; ++ k)
    {
    ++count;
    }
    printf("%d\n", count);
}
```

         T(N)=100，则根据推导规则第一条可以得出，Func4的时间复杂度为：![O(1)](https://latex.csdn.net/eq?O%281%29)

#### 3.2.4  示例4

```
// 计算strchr的时间复杂度？
const char * strchr ( const char* str, int character)
{
    const char* p_begin = s;
    while (*p_begin != character)
    { 
        if (*p_begin == '\0')
            return NULL;
        p_begin++;
    }
    return p_begin;
}
```

**strstr执行的基本操作次数：**

        1）若要查找的字符在字符串第一个位置，则：![T(N)=1](https://latex.csdn.net/eq?T%28N%29%3D1)

        2）若要查找的字符在字符串最后的一个位置，则：![T(N)=N](https://latex.csdn.net/eq?T%28N%29%3DN)

        3）若要查找的字符在字符串中间位置，则：![T(N)=\frac{N}{2}](https://latex.csdn.net/eq?T%28N%29%3D%5Cfrac%7BN%7D%7B2%7D)

        因此，strstr的时间复杂度分为三种情况：

* 最好情况：![O(1)](https://latex.csdn.net/eq?O%281%29)
* 最坏情况：![O(N)](https://latex.csdn.net/eq?O%28N%29)
* 平均情况：![O(N)](https://latex.csdn.net/eq?O%28N%29)

>         💡  **总结**  
>          通过上面的介绍我们可以发现，有些算法的时间复杂度存在最好、平均和最坏情况。
>
>         最坏情况：任意输入规模的最大运行次数（上界）
>
>         平均情况：任意输入规模的期望运行次数
>
>         最好情况：任意输入规模的最小运行次数（下界）
>
>         **大O的渐进表示法在实际中一般情况关注的是算法的上界，也就是最坏运行情况。**

#### 3.2.5  示例5

```
// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
    assert(a);
    for (size_t end = n; end > 0; --end)
    {
        int exchange = 0;
        for (size_t i = 1; i < end; ++i)
        {
            if (a[i-1] > a[i])
            {
                Swap(&a[i-1], &a[i]);
                exchange = 1;
            }
        } 
        if (exchange == 0)
            break;
    }
}
```

        1）若数组有序，则：![T(N)=N](https://latex.csdn.net/eq?T%28N%29%3DN)

        2）若数组有序且为降序，则：![T(N)=\frac{N\cdot (N+1)}{2}](https://latex.csdn.net/eq?T%28N%29%3D%5Cfrac%7BN%5Ccdot%20%28N&plus;1%29%7D%7B2%7D)

        3）若要查找的字符在字符串中间位置，则：![T(N)=N^{2}](https://latex.csdn.net/eq?T%28N%29%3DN%5E%7B2%7D)

        因此，BubbleSort的时间复杂度取最差情况为：![O(N^{2})](https://latex.csdn.net/eq?O%28N%5E%7B2%7D%29)

#### 3.2.6  示例6

```
void func5(int n)
{
    int cnt = 1;
    while (cnt < n)
    {
        cnt *= 2;
    }
}
```

        当n = 2时，执行次数为1；当n = 4时，执行次数为2；当n = 16时，执行次数为4。

        假设执行次数为x，那么![2^{x}=n](https://latex.csdn.net/eq?2%5E%7Bx%7D%3Dn)，因此执行次数为：![x=\log n](https://latex.csdn.net/eq?x%3D%5Clog%20n)。

        因此：func5的时间复杂嘟取最差情况为：![O(\log_{2}n)](https://latex.csdn.net/eq?O%28%5Clog_%7B2%7Dn%29)

**注意：**当n接近于无穷大时，底数的大小对结果影响不大。因此，一般情况下不论底数是多少都可以省略不写，即可以表示为![\log n](https://latex.csdn.net/eq?%5Clog%20n)。

#### 3.2.7  示例7

```
// 计算阶乘递归Fac的时间复杂度？
long long Fac(size_t N)
{
    if(0 == N)
        return 1;
    return Fac(N-1)*N;
}
```

        调用一次Fac函数的时间复杂度为![O(1)](https://latex.csdn.net/eq?O%281%29)，而在Fac函数中，存在n次递归调用Fac函数。

        因此阶乘递归的时间复杂度为：![O(N)](https://latex.csdn.net/eq?O%28N%29)

## 四、空间复杂度

        空间复杂度也是一个数学表达式，是对一个算法在运行过程中因为算法的需要**临时开辟的空间。**

        空间复杂度不是程序占用了多少bytes的空间，因为常规情况每个对象大小差异不会很大，所以空间复杂度算的是变量的个数。

        空间复杂度计算规则基本跟时间复杂度类似，也使用**大O渐进表示法**。

        注意：**函数运行时所需要的栈空间（存储参数、局部变量、一些寄存器信息等）在编译期间已经确定好了，因此空间复杂度主要通过函数在运行的时候显示申请的额外空间来确定。**

### 4.1  空间复杂度计算示例

#### 4.1.1  示例1

```
// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
    assert(a);
    for (size_t end = n; end > 0; --end)
    {
        int exchange = 0;
        for (size_t i = 1; i < end; ++i)
        {
            if (a[i-1] > a[i])
            {
                Swap(&a[i-1], &a[i]);
                exchange = 1;
            }
        } 
        if (exchange == 0)
            break;
    }
}
```

        函数栈帧在编译期间就已经确定好了，因此我们只需要关注函数在运行时额外申请的空间。

        BubbleSort额外申请的空间有exchange等有限个局部变量，使用了常数个额外空间。

        因此上述代码的空间复杂度为![O(1)](https://latex.csdn.net/eq?O%281%29)。

#### 4.1.2  示例2

```
// 计算阶乘递归Fac的空间复杂度？
long long Fac(size_t N)
{
    if(N == 0)
        return 1;

    return Fac(N-1)*N;
}
```

        在上述示例中，Fac递归调用了N次，额外开辟了N个函数栈帧，每个栈帧都使用了常数个空间。因此空间复杂度为![O(N)](https://latex.csdn.net/eq?O%28N%29)。

## 五、常见复杂度对比

        几种复杂度的增长情况对比如下所示：![](https://i-blog.csdnimg.cn/direct/774a2186c76a48bf85780a3490f4ca79.png)

![](https://i-blog.csdnimg.cn/direct/24bf8e814c1b422e9644eb791d9ad396.png)

## 六、复杂度算法题

### 6.1  旋转数组

![](https://i-blog.csdnimg.cn/direct/30d3c4a2726a47b0aac5f62fb638939f.png)

[https://leetcode.cn/problems/rotate-array/description/](https://leetcode.cn/problems/rotate-array/description/ "https://leetcode.cn/problems/rotate-array/description/")  
         这里我们给出三种思路：

#### 思路1：

>         时间复杂度：![O(n^{2})](https://latex.csdn.net/eq?O%28n%5E%7B2%7D%29)
>
>         循环K次将数组所有元素向后移动一位（代码不通过）

```
void rotate(int* nums, int numsSize, int k) {
while(k--)
{
    int end = nums[numsSize-1];
    for(int i = numsSize - 1;i > 0 ;i--)
    {
        nums[i] = nums[i-1];
    } 
    nums[0] = end;
}
```

#### 思路2：

>         空间复杂度：![O(n)](https://latex.csdn.net/eq?O%28n%29)
>
>         申请新数组空间，先将后K个数据放到新数组中，再将剩下的数组挪到新数组中。

```
void rotate(int* nums, int numsSize, int k)
{
    int newArr[numsSize];
    for (int i = 0; i < numsSize; ++i)
    {
        newArr[(i + k) % numsSize] = nums[i];
    } 

    for (int i = 0; i < numsSize; ++i)
    {
        nums[i] = newArr[i];
    }
}
```

#### 思路3：

>         空间复杂度：![O(1)](https://latex.csdn.net/eq?O%281%29)
>
> * 前n-k个逆置：4 3 2 1 5 6 7
> * 后k个逆置：4 3 2 1 7 6 5
> * 整体逆置：5 6 7 1 2 3 4

```
void reverse(int* nums,int begin,int end)
{
    while(begin<end){
    int tmp = nums[begin];
    nums[begin] = nums[end];
    nums[end] = tmp;
    begin++;
    end--;
    }
}

void rotate(int* nums, int numsSize, int k)
{
    k = k%numsSize;
    reverse(nums,0,numsSize-k-1);
    reverse(nums,numsSize-k,numsSize-1);
    reverse(nums,0,numsSize-1);
}
```

        后续我会为大家介绍更多数据结构相关的算法OJ题，请大家持续关注~

---

## 总结

>         以上就是数据结构第一期博客的全部内容啦，下期开始我将为大家正式开始介绍各种数据结构，请大家多多关注！



