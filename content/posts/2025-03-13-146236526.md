---
layout: post
title: "Android子线程更新View的方法原理"
date: 2025-03-13 17:25:47 +0800
description: "ViewRootImpl在UI线程中被创建，并在构造方法中保存了当前线程的引用(mThread)。在每次更新View时，通过调用View的invalidate方法或requestLayout方法触发ViewRootImpl的checkThread方法，验证调用线程是否与mThread一致。"
keywords: "Android子线程更新View的方法原理"
categories: ['未分类']
tags: ['Android']
artid: "146236526"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146236526
    alt: "Android子线程更新View的方法原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146236526
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146236526
cover: https://bing.ee123.net/img/rand?artid=146236526
image: https://bing.ee123.net/img/rand?artid=146236526
img: https://bing.ee123.net/img/rand?artid=146236526
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android子线程更新View的方法原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     对于所有的Android开发者来说，“View的更新必须在UI线程中进行”是一项最基本常识。
    </p>
    <p>
     如果不在UI线程中更新View，系统会抛出CalledFromWrongThreadException异常。那么有没有什么办法可以不在UI线程中更新View？答案当然是有的！
    </p>
    <h2>
     <a id="ViewRootImpl_4">
     </a>
     一.ViewRootImpl渲染体系
    </h2>
    <p>
     在Android系统中，ViewRootImpl负责View的绘制调度、事件分发、窗口管理等功能。
    </p>
    <p>
     各层级View遵循单一父View对应多个子View的关系，通过嵌套形成树形结构。
    </p>
    <p>
     由于ViewRootImpl不是真正的View，因此ViewRootImpl只是View调度的根节点，并不是View树的根节点。View树真正的根节点是DecorView。DecorView继承自FrameLayout，是真正的View容器。ViewRootImpl通过管理DecorView，间接统筹管理所有层级的View。
    </p>
    <h3>
     <a id="1DecorView_10">
     </a>
     1.DecorView的创建
    </h3>
    <p>
     当启动Activity时，系统会调用ActivityThread的handleLaunchActivity方法处理Activity的启动流程。
    </p>
    <p>
     在ActivityThread的handleLaunchActivity方法中，会分别调用performLaunchActivity方法、handleStartActivity方法、handleResumeActivity方法，反射创建Activity，并回调Activity的生命周期，如下图所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b9bba3cae93f46948daa17f3fcdb2954.jpeg#pic_center">
      <br/>
      在实际的开发过程中，通常会在Activity的onCreate方法中，调用setContentView方法，为Activity设置对应的View。在setContentView方法中，会调用installDecor方法，创建DecorView，如下图所示：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4e102f308f0a4a1ca9db648d0e00d0e3.jpeg#pic_center"/>
     </img>
    </p>
    <h3>
     <a id="2ViewRootImpl_17">
     </a>
     2.ViewRootImpl的创建
    </h3>
    <p>
     在ActivityThread的handleResumeActivity方法中，主要做了两件事：
    </p>
    <p>
     1）回调Activity的onResume方法，切换生命周期。
    </p>
    <p>
     2）调用Activity的makeVisible方法，创建ViewRootImpl与DecorView进行绑定。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/27ab5aea172b4334bb7893892557a79e.jpeg#pic_center">
      <br/>
      在Activity的makeVisible方法中，会通过WindowManager创建ViewRootImpl对象，并与DecorView进行绑定，如下图所示：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/af3c1ac6bf484f28ad1d55ab264763c9.jpeg#pic_center">
       <br/>
       在ViewRootImpl的setView方法中，ViewRootImpl会与DecorView进行双向绑定，如下图所示：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2888897656534881aaf376a5dfccfc6e.jpeg#pic_center"/>
      </img>
     </img>
    </p>
    <h3>
     <a id="3_28">
     </a>
     3.渲染体系与生命周期
    </h3>
    <p>
     在Activity的首次启动过程中：
    </p>
    <ul>
     <li>
      <strong>
       回调onCreate方法时
      </strong>
      ：调用setContentView方法，触发DecorView的创建。
     </li>
     <li>
      <strong>
       回调onStart方法时
      </strong>
      ：DecorView完成创建，ViewRootImpl未创建。
     </li>
     <li>
      <strong>
       回调onResume方法时
      </strong>
      ：DecorView完成创建，ViewRootImpl未创建。回调后立刻创建ViewRootImpl，并与DecorView完成绑定。
     </li>
    </ul>
    <h2>
     <a id="_34">
     </a>
     二.线程检测机制
    </h2>
    <h3>
     <a id="1_35">
     </a>
     1.异常产生
    </h3>
    <p>
     CalledFromWrongThreadException异常的抛出发生在ViewRootImpl类的checkThread方法中。当对View进行更新时，最终都会调用ViewRootImpl类的checkThread方法进行线程检测，代码如下：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">checkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mThread <span class="token operator">!=</span> current<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CalledFromWrongThreadException</span><span class="token punctuation">(</span>
                <span class="token string">"Only the original thread that created a view hierarchy can touch its views."</span>
                        <span class="token operator">+</span> <span class="token string">" Expected: "</span> <span class="token operator">+</span> mThread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token operator">+</span> <span class="token string">" Calling: "</span> <span class="token operator">+</span> current<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     当判断调用checkThread方法的线程和mThread不一致时，会抛出CalledFromWrongThreadException异常。
    </p>
    <h3>
     <a id="2_50">
     </a>
     2.检测路径
    </h3>
    <p>
     在ViewRootImpl中，共有13个方法在执行时会进行线程检测。如下所示：
    </p>
    <ul>
     <li>
      <strong>
       requestFitSystemWindows
      </strong>
      ：请求调整View的布局以适应系统窗口。
     </li>
     <li>
      <strong>
       requestLayout
      </strong>
      ：请求重新对View布局。
     </li>
     <li>
      <strong>
       invalidateChildInParent
      </strong>
      ：通知父View某个子View需要重绘。
     </li>
     <li>
      <strong>
       setWindowStopped
      </strong>
      ：设置Window的停止状态。
     </li>
     <li>
      <strong>
       requestTransparentRegion
      </strong>
      ：请求计算View的透明区域。
     </li>
     <li>
      <strong>
       requestChildFocus
      </strong>
      ：请求将焦点设置到某个子View上。
     </li>
     <li>
      <strong>
       clearChildFocus
      </strong>
      ：清除子View焦点。
     </li>
     <li>
      <strong>
       focusableViewAvailable
      </strong>
      ：通知父View某个子View可以获取焦点。
     </li>
     <li>
      <strong>
       recomputeViewAttributes
      </strong>
      ：重新计算View的属性。
     </li>
     <li>
      <strong>
       playSoundEffect
      </strong>
      ：播放与View交互相关的音效。
     </li>
     <li>
      <strong>
       focusSearch
      </strong>
      ：在View树中搜索下一个可以获取焦点的View。
     </li>
     <li>
      <strong>
       keyboardNavigationClusterSearch
      </strong>
      ：在键盘导航集群中搜索下一个可以获取焦点的View。
     </li>
     <li>
      <strong>
       doDie
      </strong>
      ：销毁当前的ViewRootImpl。
     </li>
    </ul>
    <p>
     但与View更新最为密切的是requestLayout方法和invalidateChildInParent方法。
    </p>
    <p>
     在Android系统中，任何对View的更新操作，最终都要直接或间接调用View的invalidate方法或requestLayout方法。这两个方法会触发ViewRootImpl中的相应逻辑，在绘制调度前进行线程检测。
    </p>
    <p>
     View的invalidate方法和requestLayout方法都会触发ViewRootImpl对View重新进行绘制调度(measure、layout、draw)，但二者的区别在于：
    </p>
    <ul>
     <li>
      <strong>
       invalidate方法
      </strong>
      ：标记当前区域为dirty，表示需要重新绘制，并在下一次绘制调度中触发draw流程，不会触发measure流程和layout流程。
     </li>
     <li>
      <strong>
       requestLayout方法
      </strong>
      ：清除已经测量的数据，并在下一次绘制调度中触发measure流程和layout流程，如果在layout过程中发现View的大小发生变化，则会通过调用setFrame方法，间接触发调用一次invalidate方法，并在下一次绘制调度中触发draw流程。
     </li>
    </ul>
    <h4>
     <a id="1invalidate_74">
     </a>
     1）invalidate方法触发线程检测
    </h4>
    <p>
     当调用View的invalidate方法时，invalidate方法内部会调用父View的invalidateChild方法，通过循环的方式，一层一层的获取父View，通知重新绘制，最终通知到ViewRootImpl，如下图所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d0e54a3adda64728b3e2dd9a16e0a425.jpeg#pic_center">
      <br/>
      在ViewRootImpl的invalidateChildInParent方法中，会进行线程检测，代码如下：
     </img>
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ViewParent</span> <span class="token function">invalidateChildInParent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> location<span class="token punctuation">,</span> <span class="token class-name">Rect</span> dirty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 线程检测</span>
    <span class="token function">checkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="2requestLayout_88">
     </a>
     2）requestLayout方法触发线程检测
    </h4>
    <p>
     当调用View的requestLayout方法时，会调用父View的requestLayout方法。通过一层一层的递归调用向上通知，最终通知到ViewRootImpl，如下图所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/36014dc31abe4606915c89ccf9e06f55.jpeg#pic_center">
      <br/>
      在ViewRootImpl的requestLayout方法中，会进行线程检测，代码如下：
     </img>
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mHandlingLayoutInLayoutRequest<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 线程检测</span>
        <span class="token function">checkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mLayoutRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">scheduleTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="View_103">
     </a>
     三.子线程更新View
    </h2>
    <p>
     子线程更新View的方式分为两种：基于独立渲染体系和基于ViewRootImpl渲染体系。需要注意的是，尽管ViewRootImpl渲染体系支持在子线程更新View，但为了保证View状态的一致性，还是建议在UI线程更新View。
    </p>
    <h3>
     <a id="1_106">
     </a>
     1.基于独立渲染体系
    </h3>
    <h4>
     <a id="1SurfaceView_107">
     </a>
     1）使用SurfaceView绘制
    </h4>
    <p>
     SurfaceView依靠自身维护BLASTBufferQueue获取Surface，在SurfaceFlinger中拥有独立的Layer。在绘制时不经过ViewRootImpl，详情参考：
     <a href="https://blog.csdn.net/LeeDuoZuiShuai/article/details/139277350?spm=1001.2014.3001.5502">
      SurfaceView与TextureView的绘制渲染
     </a>
     ，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>
        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_activity_test<span class="token punctuation">)</span>
        <span class="token comment">// 获取SurfaceView</span>
        <span class="token keyword">val</span> view <span class="token operator">=</span> findViewById<span class="token operator">&lt;</span>SurfaceView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>surface_view<span class="token punctuation">)</span>
        <span class="token comment">// 创建调度器为IO线程的协程作用域</span>
        <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
        
        <span class="token comment">// 监听Surface变化</span>
        view<span class="token punctuation">.</span>holder<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> SurfaceHolder<span class="token punctuation">.</span><span class="token function">Callback</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceCreated</span><span class="token punctuation">(</span>holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// Surface创建时启动运行在IO线程的协程</span>
                scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 每隔100ms绘制一次背景</span>
                        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
                        <span class="token keyword">val</span> canvas <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">lockCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        canvas<span class="token punctuation">.</span><span class="token function">drawColor</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>
                        holder<span class="token punctuation">.</span><span class="token function">unlockCanvasAndPost</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceChanged</span><span class="token punctuation">(</span>
                holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">,</span>
                format<span class="token operator">:</span> Int<span class="token punctuation">,</span>
                width<span class="token operator">:</span> Int<span class="token punctuation">,</span>
                height<span class="token operator">:</span> Int
            <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceDestroyed</span><span class="token punctuation">(</span>holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// Surface销毁时取消作用域内的协程</span>
                scope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="2TextureView_151">
     </a>
     2）使用TextureView绘制
    </h4>
    <p>
     TextureView依靠自身维护的SurfaceTexture获取Surface，在绘制时不经过ViewRootImpl。
    </p>
    <p>
     但与SurfaceView不同的是，通过TextureView的Surface绘制后的内容，不会直接提交到SurfaceFlinger，而是通过回调的方式触发调用一次invalidate方法，并在下一次绘制时通过硬件加速层的方式挂在View树下一起绘制，详情参考：
     <a href="https://blog.csdn.net/LeeDuoZuiShuai/article/details/139277350?spm=1001.2014.3001.5502">
      SurfaceView与TextureView的绘制渲染
     </a>
     ，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>
        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_activity_test<span class="token punctuation">)</span>

        <span class="token comment">// 获取TextureView</span>
        <span class="token keyword">val</span> view <span class="token operator">=</span> findViewById<span class="token operator">&lt;</span>TextureView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>texture_view<span class="token punctuation">)</span>
        <span class="token comment">// 创建调度器为IO线程的协程作用域</span>
        <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>

        <span class="token comment">// 监听SurfaceTexture变化</span>
        view<span class="token punctuation">.</span>surfaceTextureListener <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> TextureView<span class="token punctuation">.</span><span class="token function">SurfaceTextureListener</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSurfaceTextureAvailable</span><span class="token punctuation">(</span>
                surface<span class="token operator">:</span> SurfaceTexture<span class="token punctuation">,</span>
                width<span class="token operator">:</span> Int<span class="token punctuation">,</span>
                height<span class="token operator">:</span> Int
            <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// SurfaceTexture创建时启动运行在IO线程的协程</span>
                scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 每隔100ms绘制一次背景</span>
                        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
                        <span class="token keyword">val</span> canvas <span class="token operator">=</span> view<span class="token punctuation">.</span><span class="token function">lockCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token keyword">continue</span>
                        canvas<span class="token punctuation">.</span><span class="token function">drawColor</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>
                        view<span class="token punctuation">.</span><span class="token function">unlockCanvasAndPost</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSurfaceTextureSizeChanged</span><span class="token punctuation">(</span>
                surface<span class="token operator">:</span> SurfaceTexture<span class="token punctuation">,</span>
                width<span class="token operator">:</span> Int<span class="token punctuation">,</span>
                height<span class="token operator">:</span> Int
            <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSurfaceTextureDestroyed</span><span class="token punctuation">(</span>surface<span class="token operator">:</span> SurfaceTexture<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// SurfaceTexture销毁时取消作用域内的协程</span>
                scope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSurfaceTextureUpdated</span><span class="token punctuation">(</span>surface<span class="token operator">:</span> SurfaceTexture<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="3ViewRootImplSurface_207">
     </a>
     3）接管ViewRootImpl的Surface
    </h4>
    <p>
     当在Activity中调用Window的takeSurface方法，会接管ViewRootImpl的Surface，Activity的渲染会脱离ViewRootImpl渲染体系，相当于整个Activity都变成了SurfaceView，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>

        <span class="token comment">// 创建调度器为IO线程的协程作用域</span>
        <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>

        <span class="token comment">// 接管ViewRootImpl的Surface</span>
        window<span class="token punctuation">.</span><span class="token function">takeSurface</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> SurfaceHolder<span class="token punctuation">.</span><span class="token function">Callback2</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceCreated</span><span class="token punctuation">(</span>holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// Surface创建时启动运行在IO线程的协程</span>
                scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 每隔100ms绘制一次背景</span>
                        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
                        <span class="token keyword">val</span> canvas <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">lockCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        canvas<span class="token punctuation">.</span><span class="token function">drawColor</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>
                        holder<span class="token punctuation">.</span><span class="token function">unlockCanvasAndPost</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceChanged</span><span class="token punctuation">(</span>
                holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">,</span>
                format<span class="token operator">:</span> Int<span class="token punctuation">,</span>
                width<span class="token operator">:</span> Int<span class="token punctuation">,</span>
                height<span class="token operator">:</span> Int
            <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceDestroyed</span><span class="token punctuation">(</span>holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// Surface销毁时取消作用域内的协程</span>
                scope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">surfaceRedrawNeeded</span><span class="token punctuation">(</span>holder<span class="token operator">:</span> SurfaceHolder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="2ViewRootImpl_253">
     </a>
     2.基于ViewRootImpl渲染体系
    </h3>
    <h4>
     <a id="1ViewRootImpl_254">
     </a>
     1）ViewRootImpl渲染体系形成前
    </h4>
    <p>
     当Activity首次启动并在onCreate方法内调用setContentView方法后，在onCreate方法、onStart方法、onResume方法中，使用非UI线程更新View，不会触发线程检测，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建调度器为IO线程的协程作用域</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
    <span class="token comment">// 标记在onResume方法中执行一次</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> firstResume <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// 标记在onStart方法中执行一次</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> firstStart <span class="token operator">=</span> <span class="token boolean">true</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>
        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_activity_test<span class="token punctuation">)</span>
        <span class="token comment">// onCreate方法中，启动运行在IO线程的协程</span>
        scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 更新TextView的文字内容</span>
            findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_view<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"hello world"</span></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 使用标志位，确保只在首次调用onStart时执行</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>firstStart<span class="token punctuation">)</span> <span class="token keyword">return</span>
        firstStart <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token comment">// onStart方法中，启动运行在IO线程的协程</span>
        scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 更新TextView的文字内容</span>
            findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_view<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"hello world !"</span></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 使用标志位，确保只在首次调用onResume时执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>firstResume<span class="token punctuation">)</span> <span class="token keyword">return</span>
        firstResume <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token comment">// onResume方法中，启动运行在IO线程的协程</span>
        scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 更新TextView的文字内容</span>
            findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_view<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"hello world !!"</span></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="2ViewRootImpl_301">
     </a>
     2）绑定ViewRootImpl渲染体系前
    </h4>
    <p>
     当动态创建完View后，在没有添加到与ViewRootImpl有关联的ViewGroup前，在非UI线程更新View，不会触发线程检测，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建调度器为IO线程的协程作用域</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>
        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_activity_test<span class="token punctuation">)</span>
        
        <span class="token comment">// 获取TextView，监听点击事件</span>
        findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_view<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 当点击TextView时，启动运行在IO线程的协程</span>
            scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 创建一个TextView</span>
                <span class="token keyword">val</span> view <span class="token operator">=</span> <span class="token function">TextView</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token label symbol">@TestActivity</span><span class="token punctuation">)</span>
                <span class="token comment">// 设置文本内容</span>
                view<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"hello world"</span></span>

                <span class="token comment">// 切换到UI线程</span>
                <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 添加到DecorView中</span>
                    <span class="token keyword">this</span><span class="token label symbol">@TestActivity</span><span class="token punctuation">.</span><span class="token function">addContentView</span><span class="token punctuation">(</span>
                        view<span class="token punctuation">,</span> ViewGroup<span class="token punctuation">.</span><span class="token function">LayoutParams</span><span class="token punctuation">(</span>
                            ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">,</span>
                            ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>MATCH_PARENT
                        <span class="token punctuation">)</span>
                    <span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="4invalidate_337">
     </a>
     4）硬件渲染模式下的invalidate方法
    </h4>
    <p>
     在软件渲染模式下，当调用View的invalidate方法时，会调用父类的invalidateChild方法。但在硬件渲染模式下，为了防止循环遍历耗时，会直接调用onDescendantInvalidated方法，代码如下：
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">invalidateChild</span><span class="token punctuation">(</span><span class="token class-name">View</span> child<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Rect</span> dirty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">final</span> <span class="token class-name">AttachInfo</span> attachInfo <span class="token operator">=</span> mAttachInfo<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>attachInfo <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> attachInfo<span class="token punctuation">.</span>mHardwareAccelerated<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// HW accelerated fast path</span>
        <span class="token function">onDescendantInvalidated</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在ViewGroup的onDescendantInvalidated方法中，会通过递归调用的方式，最终调用ViewRootImpl的onDescendantInvalidated方法，如下图所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e627fdecdda74703b5ae7145f6db55a8.jpeg#pic_center"/>
     <br/>
     在ViewRootImpl的onDescendantInvalidated方法中，会直接调用invalidate方法，跳过线程检查，代码如下：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> sToolkitEnableInvalidateCheckThreadFlagValue <span class="token operator">=</span>
    <span class="token class-name">Flags</span><span class="token punctuation">.</span><span class="token function">enableInvalidateCheckThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDescendantInvalidated</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> <span class="token class-name">View</span> child<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> <span class="token class-name">View</span> descendant<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Android Tool Kit为debug留的开关，默认为false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sToolkitEnableInvalidateCheckThreadFlagValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">checkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>descendant<span class="token punctuation">.</span>mPrivateFlags <span class="token operator">&amp;</span> <span class="token constant">PFLAG_DRAW_ANIMATION</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        mIsAnimating <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">invalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@UnsupportedAppUsage</span>
<span class="token keyword">void</span> <span class="token function">invalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    mDirty<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mWidth<span class="token punctuation">,</span> mHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mWillDrawSoon<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 启动绘制流程</span>
        <span class="token function">scheduleTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     Android系统默认的渲染模式为硬件渲染，这里在AndroidManifest中再手动声明一下，代码如下：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>
    <span class="token attr-name">package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.test.ui<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    
    ...

    <span class="token comment">&lt;!-- 启动应用级别的硬件渲染模式 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name"><span class="token namespace">android:</span>hardwareAccelerated</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        
        ...
        
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">&gt;</span></span>
    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     在代码使用上，硬件渲染与软件渲染基本没有差别。当开启硬件渲染模式后，在子线程直接或间接调用View的invalidate方法不会产生崩溃，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建调度器为IO线程的协程作用域</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
    <span class="token comment">// 文字大小</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> size <span class="token operator">=</span> <span class="token number">30f</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>
        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_activity_test<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 每次onResume时，启动一个运行在IO线程的协程</span>
        scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 更新文字大小</span>
            size <span class="token operator">+=</span> <span class="token number">10f</span>
            <span class="token comment">// 获取TextView，设置文字大小</span>
            findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_view<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>textSize <span class="token operator">=</span> size
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5ViewRootImpl_426">
     </a>
     5）子线程中创建ViewRootImpl
    </h4>
    <p>
     实际上，Android系统并未要求View的更新必须在UI线程中进行。
    </p>
    <p>
     通过分析CalledFromWrongThreadException异常抛出时的提示可以知道：View的更新必须在original thread中。而original thread就是ViewRootImpl中mThread字段保存的线程。
    </p>
    <pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">checkThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mThread <span class="token operator">!=</span> current<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CalledFromWrongThreadException</span><span class="token punctuation">(</span>
                <span class="token string">"Only the original thread that created a view hierarchy can touch its views."</span>
                        <span class="token operator">+</span> <span class="token string">" Expected: "</span> <span class="token operator">+</span> mThread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token operator">+</span> <span class="token string">" Calling: "</span> <span class="token operator">+</span> current<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在ViewRootImpl的构造方法中，会对mThread进行初始化，代码如下：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ViewRootImpl</span><span class="token punctuation">(</span>
        <span class="token annotation punctuation">@UiContext</span> <span class="token class-name">Context</span> context<span class="token punctuation">,</span>
        <span class="token class-name">Display</span> display<span class="token punctuation">,</span>
        <span class="token class-name">IWindowSession</span> session<span class="token punctuation">,</span>
        <span class="token class-name">WindowLayout</span> windowLayout<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 获取当前的线程并保存</span>
    mThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     因此，Android系统要求View更新必须在UI线程执行，本质上是因为ViewRootImpl在UI线程被创建，并在构造方法中保存当前线程引用(mThread)，并在每次操作时通过checkThread方法验证调用线程是否与mThread一致。
    </p>
    <p>
     由于Activity的启动需要系统调度，系统会将Activity的启动安排在UI线程中进行，这也就导致无法在子线程中启动Activity，进而无法在子线程中创建ViewRootImpl。
    </p>
    <p>
     但是在Android系统中，不仅Activity拥有ViewRootImpl，Dialog和PopupWindow等组件也各自拥有独立的ViewRootImpl。
    </p>
    <p>
     如果在子线程中创建了Dialog或PopupWindow，那么后续对Dialog或PopupWindow中View的更新也必须在该子线程中进行，代码如下：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> TestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建HandlerThread，并启动子线程update</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> handleThread <span class="token operator">=</span> <span class="token function">HandlerThread</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"update"</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{<!-- --></span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span>
        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_activity_test<span class="token punctuation">)</span>
        <span class="token comment">// 创建子线程Handler，并向子线程update中提交一个任务</span>
        <span class="token function">Handler</span><span class="token punctuation">(</span>handleThread<span class="token punctuation">.</span>looper<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 获取容器View</span>
            <span class="token keyword">val</span> parent <span class="token operator">=</span> findViewById<span class="token operator">&lt;</span>ViewGroup<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>container<span class="token punctuation">)</span>
            <span class="token comment">// 通过加载XML的方式，创建一个子View</span>
            <span class="token keyword">val</span> view <span class="token operator">=</span> LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>layout_test_popup_window<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
            <span class="token comment">// 创建PopupWindow，并将子View添加进去</span>
            <span class="token keyword">val</span> popupWindow <span class="token operator">=</span> <span class="token function">PopupWindow</span><span class="token punctuation">(</span>
                view<span class="token punctuation">,</span>
                ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">,</span>
                ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>MATCH_PARENT
            <span class="token punctuation">)</span>
            <span class="token comment">// 从子View中获取TextView</span>
            <span class="token keyword">val</span> textView <span class="token operator">=</span> popupWindow<span class="token punctuation">.</span>contentView<span class="token punctuation">.</span>findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>pop_text<span class="token punctuation">)</span>
            <span class="token comment">// 监听TextView的点击事件</span>
            textView<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 更新TextView的文字内容，</span>
                <span class="token comment">// 这里注意点击事件的回调线程变成了子线程update</span>
                textView<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span>
                
                <span class="token comment">// 这里会产生CalledFromWrongThreadException异常</span>
                <span class="token comment">// 因为没有在子线程update中更新</span>
                window<span class="token punctuation">.</span>decorView<span class="token punctuation">.</span><span class="token function">post</span> <span class="token punctuation">{<!-- --></span> textView<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 这里先将任务提交到UI线程执行</span>
            <span class="token comment">// 因为在onCreate方法中，容器View对应的Window还未创建好</span>
            <span class="token comment">// 获取不到Window的Token，会产生异常</span>
            window<span class="token punctuation">.</span>decorView<span class="token punctuation">.</span><span class="token function">post</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 切换到子线程，创建子线程Handler，并向子线程update中提交一个任务</span>
                <span class="token function">Handler</span><span class="token punctuation">(</span>handleThread<span class="token punctuation">.</span>looper<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 子线程中展示popupWindow，会触发ViewRootImpl在子线程update中创建</span>
                    popupWindow<span class="token punctuation">.</span><span class="token function">showAtLocation</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> Gravity<span class="token punctuation">.</span>CENTER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="_511">
     </a>
     三.总结
    </h2>
    <h3>
     <a id="1ViewUI_512">
     </a>
     1.View的更新必须在UI线程进行的原因
    </h3>
    <p>
     ViewRootImpl在UI线程中被创建，并在构造方法中保存了当前线程的引用(mThread)。在每次更新View时，通过调用View的invalidate方法或requestLayout方法触发ViewRootImpl的checkThread方法，验证调用线程是否与mThread一致。
    </p>
    <h3>
     <a id="2Activity_514">
     </a>
     2.Activity启动流程中渲染体系的创建
    </h3>
    <ul>
     <li>
      <strong>
       回调onCreate方法时
      </strong>
      ：调用setContentView方法，触发DecorView的创建。
     </li>
     <li>
      <strong>
       回调onStart方法时
      </strong>
      ：DecorView完成创建，ViewRootImpl未创建。
     </li>
     <li>
      <strong>
       回调onResume方法时
      </strong>
      ：DecorView完成创建，ViewRootImpl未创建。回调后立刻创建ViewRootImpl，并与DecorView完成绑定。
     </li>
    </ul>
    <h3>
     <a id="3invalidaterequestLayout_518">
     </a>
     3.invalidate方法与requestLayout方法的区别
    </h3>
    <p>
     View的invalidate方法和requestLayout方法都会触发ViewRootImpl对View重新进行绘制调度(measure、layout、draw)，但二者的区别在于：
    </p>
    <ul>
     <li>
      <strong>
       invalidate方法
      </strong>
      ：标记当前区域为dirty，表示需要重新绘制，并在下一次绘制调度中触发draw流程，不会触发measure流程和layout流程。
     </li>
     <li>
      <strong>
       requestLayout方法
      </strong>
      ：清除已经测量的数据，并在下一次绘制调度中触发measure流程和layout流程，如果在layout过程中发现View的大小发生变化，则会通过调用setFrame方法，间接触发调用一次invalidate方法，并在下一次绘制调度中触发draw流程。
     </li>
    </ul>
    <h3>
     <a id="4View_523">
     </a>
     4.子线程更新View的方法
    </h3>
    <ul>
     <li>
      <strong>
       基于独立渲染体系
      </strong>
      <ul>
       <li>
        使用SurfaceView，直接对Surface进行绘制。
       </li>
       <li>
        使用TextureView，直接对Surface进行绘制。
       </li>
       <li>
        接管ViewRootImpl的Surface，直接对Surface进行绘制。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       基于ViewRootImpl渲染体系
      </strong>
      <ul>
       <li>
        在ViewRootImpl渲染体系形成前，使用子线程更新View。
       </li>
       <li>
        在绑定ViewRootImpl渲染体系前，使用子线程更新View。
       </li>
       <li>
        硬件渲染模式下，子线程直接或间接调用View的invalidate方法。
       </li>
       <li>
        对于独立拥有ViewRootImpl的组件，在子线程中触发组件创建ViewRootImpl，并在对应的子线程中更新View。
       </li>
      </ul>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f4c656544756f5a756953687561692f:61727469636c652f64657461696c732f313436323336353236" class_="artid" style="display:none">
 </p>
</div>


