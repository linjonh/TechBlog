---
layout: post
title: "数据结构四栈和队列"
date: 2025-03-05 20:05:23 +0800
description: "队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表。栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。入队列：进行插入操作的一端称为队尾。出队列：进行删除操作的一端称为队头。"
keywords: "数据结构（四）栈和队列"
categories: ['未分类']
tags: ['数据结构']
artid: "146026536"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146026536
    alt: "数据结构四栈和队列"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146026536
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146026536
cover: https://bing.ee123.net/img/rand?artid=146026536
image: https://bing.ee123.net/img/rand?artid=146026536
img: https://bing.ee123.net/img/rand?artid=146026536
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构（四）栈和队列
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     栈的概念及结构
    </h3>
    <p>
     栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作
    </p>
    <p>
     进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底
    </p>
    <p>
     栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则
    </p>
    <p>
     压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶
    </p>
    <p>
     出栈：栈的删除操作叫做出栈
    </p>
    <p>
     出数据也在栈顶
     <span style="color:#fe2c24">
      后进先出
     </span>
    </p>
    <h3>
     栈的实现
    </h3>
    <h4>
     头文件
    </h4>
    <p>
     声明
    </p>
    <pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

//创建栈
typedef int STDataType;
typedef struct Stack
{
	int* a;
	int top;
	int capacity;
}ST;

//栈的初始化和销毁
void STInit(ST* ps);
void STDestroy(ST* ps);

//插入
void STPush(ST* ps, STDataType x);

//删除
void STPop(ST* ps);

//计算栈的大小
int STSize(ST* ps);

//判断是否为空
bool STEmpty(ST* ps);
STDataType STTop(ST* ps);</code></pre>
    <p>
    </p>
    <h4>
     源文件
    </h4>
    <p>
     实现
    </p>
    <pre><code>#include"Stack.h"


void STInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);
	if (ps-&gt;a == NULL)
	{
		perror("malloc fail");
		return;
	}
	ps-&gt;capacity = 4;
	ps -&gt; top = 0;	//top是栈顶元素下一个位置
  //ps -&gt;top = -1;	  top是栈顶元素位置
}


void STDestroy(ST* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}


void STPush(ST* ps, STDataType x)
{
	assert(ps);
	//满了扩容
	if (ps-&gt;top == ps-&gt;capacity)
	{
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * ps-&gt;capacity*2);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		ps-&gt;a = tmp;
		ps-&gt;capacity *= 2;
	}
	//没满把数据放进去，top++
	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;
}


void STPop(ST* ps)
{
	assert(ps);
	assert(!STEmpty(ps));//暴力检查
	ps-&gt;top--;

}


int STSize(ST* ps)
{
	assert(ps);
	return ps-&gt;top;
	//给0的时候是top
	//给-1的时候是top+1
}


bool STEmpty(ST* ps)
{
	assert(ps);
	return ps-&gt;top == 0;
}


STDataType STTop(ST* ps)
{
	assert(ps);
	assert(!STEmpty(ps));
	return ps-&gt;a[ps-&gt;top-1];
}</code></pre>
    <h3>
     队列的概念及结构
    </h3>
    <p>
     队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表
    </p>
    <p>
     队列具有先进先出 FIFO(First In First Out) 的特点
    </p>
    <p>
     入队列：进行插入操作的一端称为队尾
    </p>
    <p>
     出队列：进行删除操作的一端称为队头
    </p>
    <h3>
     队列的实现
    </h3>
    <p>
     队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出
    </p>
    <p>
     队列在数组头上出数据，效率会比较低
    </p>
    <h4 style="background-color:transparent">
     头文件
    </h4>
    <p>
     声明
    </p>
    <pre><code class="hljs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

//链式结构：表示队列
typedef int QDatatype;
typedef struct QueueNode
{
	struct	QueueNode* next;
	QDatatype data;
}QNode;


//队列的结构
typedef struct Queue
{
	QNode* head;
	QNode* tail;
	int size;
}Queue;

// 队列的初始化和销毁
void QueueInit(Queue* pq);
void QueueDestroy(Queue* pq);

//队尾入队列
void QueuePush(Queue* pq,QDatatype x);

//队头出队列
void QueuePop(Queue* pq);

//获取队列中有效元素个数
int QueueSize(Queue* pq);

//检测队列是否为空
bool QueueEmpty(Queue* pq);

//获取队列头部元素
QDatatype QueueFront(Queue* pq);

//获取队列队尾元素
QDatatype QueueBack(Queue* pq);</code></pre>
    <h4 style="background-color:transparent">
     源文件
    </h4>
    <p>
     实现
    </p>
    <pre><code class="hljs">#include"queue.h"


void QueueInit(Queue* pq)
{
	assert(pq);
	pq-&gt;head = pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}


void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq-&gt;head;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;head = pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}


void QueuePush(Queue* pq, QDatatype x)
{
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	if (pq-&gt;head == NULL)
	{
		assert(pq-&gt;tail == NULL);
		pq-&gt;head = pq-&gt;tail = newnode;
	}
	else
	{
		pq-&gt;tail-&gt;next = newnode;
		pq-&gt;tail = newnode;
	}
	pq-&gt;size++;
}


void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;head != NULL);
	//法一
	QNode* next = pq-&gt;head-&gt;next;
	free(pq-&gt;head);
	pq-&gt;head= next;
	if (pq-&gt;head == NULL)
		pq-&gt;tail = NULL;
	pq-&gt;size--;

	/*法二
	if (pq-&gt;head-&gt;next == NULL)
	{
		free(pq-&gt;head);
		pq-&gt;head = pq-&gt;tail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;head-&gt;next;
		free(pq-&gt;head);
		pq-&gt;head = next;
	}*/

}


int QueueSize(Queue* pq)
{
	assert(pq);
	return pq-&gt;size;
}


bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq-&gt;size == 0;
}


QDatatype QueueFront(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));//因为这个QueueEmpty是一个函数，所以需要调用
	return pq-&gt;head-&gt;data;
}


QDatatype QueueBack(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));
	return pq-&gt;tail-&gt;data;
}
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f636c6f75645f6469737370617465642f:61727469636c652f64657461696c732f313436303236353336" class_="artid" style="display:none">
 </p>
</div>


