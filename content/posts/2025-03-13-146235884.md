---
layout: post
title: "游戏引擎学习第155天"
date: 2025-03-13 16:55:08 +0800
description: "不使用任何游戏引擎或新库，只有我们自己，展示游戏开发的完整过程，从构成游戏画面的小小像素到控制角色的AI，或者介于其中的任何内容，我们都会展示如何实现。现在，我们正处于一个转折点。昨天我们完成了资产包文件的制作，感觉非常棒。考虑到我们没有花太多时间就完成了这些文件，而且它们现在非常强大，我对这点感到非常兴奋。接下来，我们有两件事可以做——昨天我提到的，实际上现在有三件事情可以做。在讨论粒子系统之前，我们先来回顾一下游戏图形的一些基本概念。"
keywords: "游戏引擎学习第155天"
categories: ['游戏引擎学习']
tags: ['游戏引擎', '学习']
artid: "146235884"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146235884
    alt: "游戏引擎学习第155天"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146235884
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146235884
cover: https://bing.ee123.net/img/rand?artid=146235884
image: https://bing.ee123.net/img/rand?artid=146235884
img: https://bing.ee123.net/img/rand?artid=146235884
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     游戏引擎学习第155天
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      仓库:
      <a href="https://gitee.com/mrxiao_com/2d_game_3" rel="nofollow">
       https://gitee.com/mrxiao_com/2d_game_3
      </a>
     </strong>
    </p>
    <h2>
     <a id="_1">
     </a>
     总结回顾
    </h2>
    <p>
     不使用任何游戏引擎或新库，只有我们自己，展示游戏开发的完整过程，从构成游戏画面的小小像素到控制角色的AI，或者介于其中的任何内容，我们都会展示如何实现。
    </p>
    <p>
     现在，我们正处于一个转折点。昨天我们完成了资产包文件的制作，感觉非常棒。考虑到我们没有花太多时间就完成了这些文件，而且它们现在非常强大，我对这点感到非常兴奋。
    </p>
    <p>
     接下来，我们有两件事可以做——昨天我提到的，实际上现在有三件事情可以做。
    </p>
    <h2>
     <a id="_8">
     </a>
     今天的三个可能主题
    </h2>
    <p>
     我们现在有几个选择要做。首先，可以回顾一下资产包文件的内容，看看是否有需要添加的新功能，或者是否有些地方我们想做些调整。例如，我们之前讨论过，是否要加入一个功能，允许从其他包文件中抑制资源，这样可以在需要时进行修补或者做其他操作，我们可以选择做这件事。
    </p>
    <p>
     第二个选择是，开始处理资产的内存管理。这是一个相对较大的任务，因为它是整个项目中最具挑战性的内存管理问题之一。我们需要设计一个虚拟内存系统，来有效管理游戏资产数据的内存使用。这个系统会根据每个场景中的需求来决定哪些资源需要加载，哪些可以被替换。尽管我们不期望能做到极致的优化，但目标是有效地管理游戏资源。这个任务可能需要花费更多的时间，且会涉及到很多细节问题，所以可能更适合在下周一开始处理，而不是这周的最后两天。
    </p>
    <p>
     接下来，我们会看看待办事项列表，看看是否有两天内可以完成的任务，或者是否有其他值得做的事情。我们已经做完了一些任务，包括处理一些音频问题以及重载系统的修复。重载系统中，我们原本计划在重定位之前刷新线程队列，以避免可能发生的崩溃问题，但实际上我们还没有遇到这个问题，所以不一定是个问题。
    </p>
    <p>
     目前看起来，我们已经完成了很多任务，所以没有急需处理的紧急事项。接下来，我们可能会探索一些新的内容，比如游戏存档的管理，或者其他一些开发架构相关的任务。
    </p>
    <h2>
     <a id="_17">
     </a>
     开始讲解粒子系统！
    </h2>
    <p>
     我们现在可以做点有趣的事情，可能会选一个轻松又有趣的任务，做两天。虽然目前没有特别明显的选择，但我觉得“粒子系统”可能是一个不错的选择。粒子系统实际上是比较简单的东西，虽然它可能看起来有点复杂，但本质上并不难实现。而且，它也许能给我们带来一些有趣的观察，特别是在渲染方面。比如，当我们使用粒子系统时，可能会对渲染造成一些性能影响，特别是在大量粒子的情况下。所以，探索一下粒子系统对渲染的影响，并尝试通过更有效的方式实现它，可能会是一个很好的实验。
    </p>
    <p>
     我们可以尝试花两天时间做这个，看看粒子系统如何工作，可能也会给我们一些关于性能优化的启发。然后，明天我们再开始着手处理资产内存管理的问题。
    </p>
    <p>
     接下来，我会在黑板上画一个简单的粒子系统示意图，展示它的工作原理。为了开始这个工作，我会打开一个软件，尝试加载黑板内容。现在，加载有点慢，可能是因为文件太大了。不过，加载完成后，我们可以继续探讨如何实现粒子系统。
    </p>
    <h2>
     <a id="_24">
     </a>
     粒子系统介绍（黑板展示）
    </h2>
    <p>
     在讨论粒子系统之前，我们先来回顾一下游戏图形的一些基本概念。一般来说，在游戏图形中，我们会将不同类型的内容分到几个不同的类别，这取决于我们要绘制的内容是什么。
    </p>
    <p>
     以2D游戏为例，我们已经实现了两种基本的内容类型，分别是地面瓦片和精灵（Sprites）。这些内容我们在构建游戏引擎的过程中已经用过，它们在渲染中起到了重要作用。地面瓦片是通过将游戏世界划分为多个瓦片来实现的。每个瓦片代表一个区域，而我们只会在屏幕上绘制玩家能够看到的部分。瓦片的绘制方式是固定的，而为了避免重复，我们尽量确保地面纹理看起来是唯一的。这样做的目的是让地面看起来像一个连续的、无限扩展的世界，而不是简单的草地拼接，这样可以让游戏世界的表现更加自然。我们通过虚拟画布的方式来绘制这些地面，实际上我们只会填充玩家能够看到的部分，因为生成整个地面会非常不实际。
    </p>
    <p>
     另一个我们使用的工具是精灵。精灵是由多个矩形图像（通常包含透明通道）组成的，它们可以表示游戏中的各种角色和物体。比如，角色的头部、身体、四肢等都是通过不同的精灵图像拼接在一起的。在游戏中，我们会将这些精灵渲染出来，通过它们来表现角色和其他物体。精灵的优点在于它们非常适合用来构建2D游戏，它们不仅可以表达许多信息，还能够很好地展示艺术资源，将设计师创作的静态图像带入到游戏中。
    </p>
    <p>
     精灵是2D游戏中的基础工具，它们非常适合表现人物、物体等内容。在许多3D游戏中也能看到精灵的使用，它们是2D游戏的核心工具，甚至在一些3D游戏中也能看到它们的身影。因此，精灵在游戏开发中扮演了非常重要的角色。
    </p>
    <h2>
     <a id="_33">
     </a>
     粒子系统用于表示没有特定形状的物体
    </h2>
    <p>
     在游戏开发中，除了可以用精灵和瓦片来表示有明确形状的物体之外，还有一些现象是没有特定形状的。我们可以将这些现象称为“现象”（phenomena），比如液体、气体、雾气等。这些现象是非常难以用传统的方式表示的，因为它们不像角色或物体那样具有固定的形状。艺术家通常难以绘制出像液体、气体或雾气这样自由流动、弯曲变化的物体，它们的形状会不断地变形，无法用简单的图形来表达。
    </p>
    <p>
     这些现象的表现通常不适合使用精灵或者瓦片的方式，因为它们是动态变化的，且具有一定的流动性。比如，烟雾、爆炸效果等，都是常见的需要表达的现象。在射击类游戏中，爆炸和烟雾效果是非常常见的。
    </p>
    <p>
     对于这些没有固定形状的现象，我们通常使用“粒子系统”来处理。粒子系统正如其名字所示，它是一系列小的粒子集合，这些粒子共同作用，形成一个系统，这个系统代表了某种现象。比如，如果我们想要表现一团火焰或一阵烟雾，我们就可以通过粒子系统来捕捉这种火焰或烟雾的感觉，从而解决这一问题。
    </p>
    <p>
     粒子系统的复杂性有很多层次，通常根据需求的不同，粒子系统可以有不同的实现方式。在一些效果制作的场景中，粒子系统也常用于表现各种特效，这些效果可以在好莱坞电影中看到，也可以在游戏中看到。粒子系统不仅仅是一个简单的工具，它可以根据需要进行调整和优化，以达到更好的效果。
    </p>
    <h2>
     <a id="_42">
     </a>
     发射器和粒子行为
    </h2>
    <p>
     在粒子系统中，通常会有一个叫做“发射器”（emitter）的元素，正如其名称所示，它的作用是“发射”粒子。发射器本身会定义一个形状，可以是任何形状，用来表示粒子将从中发射出来的位置和区域。比如说，我们想要在地面上的一根木头上做火焰效果，那么就会将一个火焰粒子的发射器放置在木头的位置。
    </p>
    <p>
     发射器有一些参数来控制粒子的行为，比如它的形状、粒子从哪里开始发射等。基本的思路是，发射器会在其定义的形状内生成一些小点，这些小点就是粒子，它们在空间中是没有固定形状的点。
    </p>
    <p>
     这些粒子生成之后，会有一个简单的模拟过程来控制它们的行为。例如，粒子可能会被指示朝着某个向上的锥形区域内随机方向飞出，它们会朝上飘动，可能会有一些轻微的晃动等。随着粒子上升，它们的行为会发生变化，粒子可能会从接近地面的位置开始表现出一种方式，而在上升到空中的位置时，它们的表现则会有所不同。
    </p>
    <p>
     接下来，粒子在每一帧中都会根据模拟的结果更新位置。因此，在每一帧结束时，粒子的位置都会被更新，粒子继续朝着特定方向运动。新的粒子会继续生成并运动，从而形成一个持续的效果。例如，火焰的粒子系统会不断生成新的粒子，这些粒子会模拟出火焰的上升、扩散等效果，最终呈现出动态的火焰效果。
    </p>
    <h2>
     <a id="_51">
     </a>
     粒子的形状
    </h2>
    <p>
     在渲染粒子时，通常会采用一种模糊的、带有柔和边缘的形状覆盖在粒子上。这种形状的中心部分可能会比较深，而边缘部分则逐渐变得透明或更弱。这样做的目的是为了形成一种模糊、不规则的形状，这种效果非常适合表现火焰、气体或液体等自然现象。
    </p>
    <p>
     通过这种方式，粒子系统的形状不再有明确的边界，而是呈现出一种“流动”的效果。例如，火焰或者烟雾就会通过这种渐变的渲染方式，展现出不规则、不断变化的外观。这种处理方式使得粒子系统看起来更加自然，并且避免了硬边缘的出现，从而让粒子之间的过渡更加平滑，给人一种柔和、动态的视觉感受。
    </p>
    <h2>
     <a id="_56">
     </a>
     简单粒子系统实现概览
    </h2>
    <p>
     粒子系统的实现其实并不复杂，如果按照之前的思路来理解。实际上，粒子系统的实现只需要几个基本的元素：
    </p>
    <ol>
     <li>
      <strong>
       粒子列表
      </strong>
      ：首先，需要有一个存储粒子的列表，用来追踪每个粒子的状态。
     </li>
     <li>
      <strong>
       粒子运动
      </strong>
      ：对于每一帧，模拟粒子的运动。类似之前实现的物理方程，粒子的运动可以通过一些简单的数学公式来计算。
     </li>
     <li>
      <strong>
       渲染
      </strong>
      ：渲染粒子是最复杂的一部分。开始时，可以非常简单地使用一个充满色彩的圆形精灵（sprite）来代表粒子，并把这个精灵绘制在粒子的位置。
     </li>
    </ol>
    <p>
     最重要的是不要过度思考。在开发粒子系统时，首先关注如何将最简单的东西呈现出来，而不需要考虑复杂的特效或高级的渲染技术。比如，开始时可以让粒子只是一个简单的点或圆形，这样可以帮助理解粒子系统的基本概念。一旦理解了最基本的实现方法，再逐步扩展和完善它。
    </p>
    <p>
     开发时的核心理念是：从最简单的方式开始，逐步构建出更加复杂和通用的组件。在实现的过程中，会逐渐清晰地看到如何将粒子系统集成到整个引擎中，使其成为一个更完善的部分。
    </p>
    <h2>
     <a id="_67">
     </a>
     粒子结构体
    </h2>
    <p>
     为了实现粒子系统，首先我们要做的就是定义一个粒子对象。首先，设定一个粒子系统，建立一个粒子的列表。粒子的数量暂时可以先不确定，直接设定为64个，这样就有了一个初步的粒子集合，用于开始实现。
    </p>
    <p>
     接着，在粒子对象中，我们需要定义几个基本的属性：
    </p>
    <ol>
     <li>
      <strong>
       位置（Position）
      </strong>
      ：记录粒子所在的位置。
     </li>
     <li>
      <strong>
       速度（Velocity）
      </strong>
      ：记录粒子的移动速度。
     </li>
     <li>
      <strong>
       颜色（Color）
      </strong>
      ：粒子的颜色。
     </li>
    </ol>
    <p>
     这些是粒子最基础的属性，可以让我们实现一个简单的粒子系统，能够在屏幕上显示并且让粒子移动。
    </p>
    <p>
     接下来，进入代码实现部分。在游戏主循环的更新和渲染部分，我们会把粒子系统的代码插入进去。由于当前的代码还没有完全成熟，很多功能还未分离成独立的模块，因此粒子系统的代码会放在一个测试区域中。这是为了先实现简单的粒子显示功能，等后续功能更完善时再进行重构。
    </p>
    <p>
     在游戏的更新和渲染代码之间，插入一个用于测试粒子系统的代码块。初步测试时，不需要做太多复杂的功能，目标只是让粒子出现在屏幕上并且做出简单的运动效果。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/81633732a391418e994f27acbe395865.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2e7023933369433597180043bbd0bd37.png#pic_center"/>
    </p>
    <h2>
     <a id="_85">
     </a>
     编写粒子系统测试循环
    </h2>
    <p>
     首先，目标是要遍历所有粒子。在实现时，首先从第一个粒子开始，到粒子列表的末尾。通过粒子数组的索引，逐个粒子进行遍历。这是一个非常简单的操作，不涉及任何复杂的优化或考虑性能，只是一个基础的迭代过程。
    </p>
    <p>
     在遍历每个粒子时，首先需要
     <strong>
      模拟粒子
     </strong>
     的行为。即根据预设的运动规则，更新粒子的位置、速度等属性，使其在时间中不断前进。这是粒子系统的核心部分，目的是让每个粒子按照设定的方式运动。
    </p>
    <p>
     其次，在模拟粒子后，需要进行
     <strong>
      渲染
     </strong>
     。每个粒子的渲染可以有两种方式，具体的渲染方法会根据后续需要的效果来选择。在这个阶段，首先我们只关注最基础的操作，保持简单并确保粒子能够正常显示并模拟。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1cb0482401cf4f3db7728893191758b9.png#pic_center"/>
    </p>
    <h2>
     <a id="_VS__94">
     </a>
     渲染然后模拟 VS 先模拟再渲染
    </h2>
    <p>
     在渲染粒子的过程中，有两种方式可以选择，首先是先渲染粒子，然后再进行模拟；第二种是先模拟粒子，然后再进行渲染。前者的优点是粒子在被渲染时会显示在它们生成的位置，而不会立刻根据模拟的结果进行位置更新。这意味着当粒子生成时，它们的位置已经是静止的，直到下一帧才会根据模拟的结果进行移动。但缺点是，如果粒子是由用户输入触发的，用户的操作只会在下一帧看到效果，而不是当前帧。
    </p>
    <p>
     为了避免这种问题，决定选择第二种方式，即先模拟粒子，然后再渲染它们。这样可以确保粒子的运动在当前帧中就能反映出来。
    </p>
    <p>
     在渲染粒子时，首先考虑的是利用现有的绘制函数，特别是通过调用已有的
     <code>
      PushBitmap
     </code>
     函数来将粒子渲染出来。为了实现这一点，首先要创建一个用于测试的粒子位图（
     <code>
      TestParticles
     </code>
     ）。这个位图将被传递给渲染系统，用于显示粒子。
    </p>
    <p>
     在实现中，首先会创建并使用一个标准的渲染组，而不是将粒子渲染到一个单独的测试图层。这样，粒子的渲染会被直接输出到游戏的渲染缓冲区，确保渲染效果正常。
    </p>
    <p>
     在测试过程中，遇到了一些小的错误或疏忽，比如将渲染输出错误地传递到测试图层，而不是标准的渲染输出。这个问题通过调整后修正，确保粒子最终会渲染到正确的输出上。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/29cbf2a6f32445248b433fa962b6eec5.png#pic_center"/>
    </p>
    <h2>
     <a id="_107">
     </a>
     渲染粒子
    </h2>
    <p>
     在渲染粒子时，首先需要决定粒子的大小。为了简化处理，选择将粒子的大小设置为一个小值，例如0.1米。粒子的偏移量一般来说不需要调整，但为了适应粒子的实际位置，决定传递粒子的具体位置，而不使用整个变换系统来处理每个粒子。
    </p>
    <p>
     接着，需要指定粒子的颜色。粒子的颜色通过参数传递给渲染系统，用来确定粒子的显示颜色。渲染时，粒子会以指定位置和颜色呈现。
    </p>
    <p>
     在实现渲染时，考虑到我们已经有了一个用于测试的球体模型（在之前的法线贴图中使用过），因此可以尝试直接使用现有的球体模型来渲染粒子，而不需要额外创建新的测试粒子。如果现有的球体贴图效果符合预期，可以直接利用它来渲染粒子形状，因为球体的外观能够呈现出一种模糊、圆润的形态，符合粒子需要的效果。
    </p>
    <p>
     通过这样的方式，可以避免不必要的额外工作，并且利用已经存在的资源来测试粒子的渲染效果。若球体贴图的效果不合适，再考虑是否需要自定义粒子模型或创建新的粒子图像。
    </p>
    <p>
     在实现过程中，渲染函数需要传递以下参数：渲染组（
     <code>
      RenderGroup
     </code>
     ），粒子位图（
     <code>
      bitmap
     </code>
     ）
     <code>
      TestDiffuse
     </code>
     ，粒子的三维坐标（使用
     <code>
      float
     </code>
     类型的
     <code>
      Offset
     </code>
     ），以及粒子的大小和颜色。最终，粒子将以三维形式渲染出来，使它们能够在空间中随意运动，包含X、Y、Z轴的运动。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/33a82ae6a5bf414582e5e8b8b50f45d9.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5fcd767d95c442b5aac575c1800c7745.png#pic_center"/>
    </p>
    <h2>
     <a id="_122">
     </a>
     模拟粒子
    </h2>
    <p>
     在模拟粒子的运动时，首先需要考虑粒子的速度和位置。由于当前没有涉及加速度，因此模拟变得非常简化。为了更新粒子的位置，我们只需要跟踪每个粒子的速度，并通过以下步骤进行更新：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        速度更新
       </strong>
       ：粒子的速度是一个固定值，表示它在单位时间内的位移量。为了更新粒子的位置，我们需要将粒子的速度乘以时间步长（
       <code>
        dt
       </code>
       ），即每一帧与上一帧之间的时间差。
      </p>
     </li>
     <li>
      <p>
       <strong>
        位置更新
       </strong>
       ：通过将粒子的速度与时间步长相乘，得到粒子在当前帧移动的距离，然后更新粒子的位置。
      </p>
     </li>
    </ol>
    <p>
     这个过程实际上是在模拟粒子的运动状态：每个粒子根据其当前的速度和经过的时间更新位置。这是最简单的粒子更新方式，因为此时没有涉及复杂的加速度或外力的影响。
    </p>
    <p>
     简而言之，每次更新粒子时，都会根据其当前速度和时间步长更新位置。这种方法不考虑粒子受到的外部影响，因此更新非常直接和高效。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a79f5e5570e84d9e8e9332a7c677ddfc.png#pic_center"/>
    </p>
    <h2>
     <a id="_135">
     </a>
     粒子的位置
    </h2>
    <p>
     目前，粒子的位置还没有被正确设置到世界中，它们会始终被渲染在原点（0,0,0）。这导致了粒子看起来并没有被正确显示，因此需要解决粒子的位置问题。同时，目前粒子的颜色没有设置，它们的颜色值为（0,0,0,0），也就是完全透明的，这也使得粒子无法显示。
    </p>
    <p>
     为了确保粒子能够显示出来，首先需要验证当前渲染状态，检查是否正确绘制了粒子。可以尝试强制设置一个颜色，确保粒子能够被渲染出来，尽管这样做并不能解决位置问题。粒子的透明度需要调整，或者可能需要强制设置颜色和其他渲染参数，以便确保粒子是可见的。
    </p>
    <p>
     接下来，要确保渲染的状态和变换设置正确。之前渲染敌人等对象时，已经对渲染变换进行了设置，但对于粒子系统并未进行类似的设置。渲染变换是决定粒子如何在屏幕上显示的位置和形态的关键，因此需要为粒子设置渲染变换。
    </p>
    <p>
     此外，还需要确保所有渲染状态（如全局透明度等）在渲染粒子之前已经正确设置。为了避免受到其他旧代码的影响，建议清除之前可能影响渲染的任何残余设置，并确保粒子的渲染环境是干净的。
    </p>
    <p>
     最后，要关注音频的控制，虽然已经实现了音频播放，但并没有实现停止音频的功能。需要实现一个停止音频的机制，以便在需要时可以停止播放。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/38f1b5da65f941cb96e03080dc315b75.png#pic_center"/>
    </p>
    <h2>
     <a id="_148">
     </a>
     检查粒子系统的模拟和绘制
    </h2>
    <p>
     现在，我们将进入代码调试，确保我们正在正确地执行各项操作。首先，我会查看粒子系统中的每个粒子的值，预期它们应该全是零，检查一下结果是否符合预期，确保粒子的位置、速度等都没有意外的值，确实是零。
    </p>
    <p>
     接着，我们会检查测试时使用的"TestDiffuse"是否是一个有效的纹理或位图，因为之前并没有确认这一点，可能它并不是一个有效的图像资源。因此，我们需要验证这个位图是否可以正确绘制出来，确保渲染过程中的资源是有效且正确的。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4d23a268d3c4405ab571dd192043e012.png#pic_center"/>
    </p>
    <h2>
     <a id="_155">
     </a>
     使用阴影资源绘制粒子
    </h2>
    <p>
     目前，我们考虑了一种方法，直接绘制阴影，因为已经确认这个功能是正常的，这样就不需要再回去检查测试用的纹理了，毕竟我们之前主要是为了测试光照效果才用到这些纹理。如果渲染出来的阴影仍然没有显示，就说明我们可能有一个定位错误，需要去修复这个问题。
    </p>
    <p>
     为了确保可以看到渲染效果，我们还可以调整粒子组的大小，使其非常大，这样就没有机会不显示。我们应该能够看到一个显示的对象，可能是一个简单的阴影或其他图形。因此，下一步是深入查看推送位图的代码，看看它是如何获取位图并将其放到渲染栈中的。
    </p>
    <p>
     在这部分代码中，我们首先查看了位图的大小，计算出来的大小看起来是合理的。接着进行了一些对齐操作，这些操作的结果看起来也很正常。接下来，检查了变换（transform）的过程，看起来是标准的透视变换，使用的标志也设置为零，偏移量为零，比例是1:1。这一切看起来都符合预期，似乎没有问题。
    </p>
    <p>
     但是，在调试过程中，发现可能会存在一个隐藏问题：我们没法确认元素是否正确地位于屏幕上，特别是如果我们中心点是（0,0）的话。因为屏幕分辨率是1920x1080，如果粒子图形的位置设置为零，可能会导致它实际上显示在屏幕之外。所以，下一步就是检查绘制代码，确认粒子是否真的处于预期的位置。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/dd0899dcdf044d3aaaced02ecc91c5f1.png#pic_center"/>
    </p>
    <h2>
     <a id="_166">
     </a>
     英雄现在是发射器
    </h2>
    <p>
     现在，系统已经开始渲染粒子，并且我们已经看到了它们在屏幕上的位置。我们想要做的是确保粒子可以被正确地生成并且具有生命力，而不仅仅是停留在一个固定的地方。所以，下一步是给粒子添加颜色，并且让粒子开始动起来。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f6029680a22246fd8710c27d56dc6ba4.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/27ba8371cc8e4ac2984697d0d966ada9.png#pic_center"/>
    </p>
    <p>
     为此，我们计划每一帧生成一些新的粒子。首先，我们通过一个“循环缓冲区”机制来管理粒子生成的顺序，每生成一个粒子，便将其放入一个粒子数组中，直到数组末尾，然后再从头开始覆盖旧的粒子。这种方法会不断地替换掉已经死亡或者到期的粒子，确保新粒子的持续生成。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7f5d1b7dad144d2bb2b4b6da33dda997.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a69cb70abad141539c985e4368c9cdfa.png#pic_center"/>
    </p>
    <p>
     生成粒子时，粒子的初始状态包括位置、速度和颜色。在这一阶段，我们将粒子的速度设置为朝上移动，并且给粒子赋予一个默认的颜色。通过这种方式，我们可以看到粒子开始向上运动，尽管它们移动的速度可能比较快，也没有任何变化或随机性，所以它们的排列可能会显得很整齐。
    </p>
    <p>
     为了让系统更接近一个真实的粒子系统，我们还希望实现粒子的逐渐消失效果。也就是说，每个粒子在存在一段时间后会逐渐消失，而不是在某一时刻突然消失。这样可以增加粒子的自然性和动态感。
    </p>
    <p>
     除此之外，背景音乐的问题也需要解决。为了避免音乐一直播放下去，我们加入了一个功能，可以让背景音乐在需要时停止，或者在某些情况下就不播放。这意味着我们可以通过代码控制音量，甚至使音乐停止播放。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b1ff6301c594497ebb768b604ed06f08.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3d19e8ed4b294557a5090c62deaf0b06.png#pic_center"/>
    </p>
    <p>
     总的来说，接下来的任务包括：
    </p>
    <ol>
     <li>
      为粒子系统增加渐变消失效果，让粒子在存在一段时间后逐渐消失。
     </li>
     <li>
      对生成粒子的颜色和速度进行调控，增加粒子的随机性和自然感。
     </li>
     <li>
      解决背景音乐的控制问题，确保在不需要时可以停止或静音音乐。
     </li>
    </ol>
    <h2>
     <a id="_192">
     </a>
     改变颜色
    </h2>
    <p>
     我们尝试让粒子的颜色也具有“速度”概念，就像它们的运动一样。换句话说，每个粒子不仅有一个位置的变化速率（velocity），还应该有一个颜色的变化速率（dColor）。这样，我们可以给粒子设置一个负的 alpha 变化速率，让它们在一秒内从完全可见逐渐消失。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/23d3ff7f2b7a42d68552e093ddddb62f.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/df2168c85b7f477ca225fd844ab2e40d.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a86e12955f1840ea937d281c7c4becc2.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/31cf3bd2d74947d1a850c5013737510b.png#pic_center"/>
    </p>
    <p>
     在实现这个功能后，我们发现渲染器并不会自动对颜色值进行裁剪（clamping），也就是说，颜色可能会超出 0 到 1 的范围，导致渲染出意想不到的结果。因此，我们需要手动对颜色值进行裁剪。为了优化，我们在代码中加入了一个
     <code>
      clamp(0, 1)
     </code>
     函数，确保颜色值始终保持在合理的范围内。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e4575e2315154b16ad5f6ec8215d510e.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5533c41bd256407b8d1a3023dedcd926.png#pic_center"/>
    </p>
    <p>
     在进行测试时，我们可以看到粒子的淡出效果开始生效，但是速度似乎有些过快。因此，我们调整了衰减速率，让粒子存在更长的时间后再开始消失。这样，粒子会从角色脚下生成，向上漂浮，到达一定高度后慢慢消失，看上去更自然。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3c4bcf548e844d3db9aa300f3e250b40.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/db9d2d08044e4d378bc361a430657b3b.png#pic_center"/>
    </p>
    <p>
     除此之外，我们还考虑让粒子变得更具扩散感。目前，粒子生成后是相对整齐的一条直线，为了让它们更接近真实的烟雾或尘埃效果，我们尝试使用一个“测试漫射形状（test diffuse shape）”，看看是否能让粒子呈现出更自然的分布。然而，这个方法似乎没有带来明显的变化，因此我们暂时保留原来的阴影效果，并计划未来向资产库中添加更多的粒子精灵（sprite）。
    </p>
    <p>
     接着，我们对颜色变化机制进行了进一步优化。原本我们在每一帧直接裁剪粒子的颜色值，这样会导致某些颜色调整失效。例如，如果某个颜色值在计算时超过 1，但立即被裁剪到 1，我们就无法通过数值调整来影响它的最终变化效果。因此，我们引入了一个“合成颜色变量”（synthetic color variable），用于存储原始计算值，而不是直接修改粒子的颜色值。然后，在渲染时，我们才对这个合成变量进行裁剪，并传递给渲染器。这样，我们可以先让粒子的亮度保持更长时间，然后再开始淡出，而不会因为提前裁剪导致不自然的过渡。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8e0a0d80549c48d3bcdfea694611c299.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7528cd48ec894197800880641a102ca1.png#pic_center"/>
    </p>
    <p>
     整体而言，我们的粒子系统已经具备了最基础的功能：
    </p>
    <ol>
     <li>
      <strong>
       循环缓冲区（circular buffer）
      </strong>
      机制，确保粒子不断生成并替换旧粒子。
     </li>
     <li>
      <strong>
       颜色渐变
      </strong>
      机制，使粒子随着时间淡出。
     </li>
     <li>
      <strong>
       初步的运动模型
      </strong>
      ，粒子从角色脚下生成，并向上飘动。
     </li>
    </ol>
    <p>
     接下来，我们的目标是让粒子的运动更具“混乱感”——目前它们的轨迹过于规律，因此我们需要加入一定的随机性，使其运动更符合现实世界的物理效果。粒子系统的基础框架已经搭建完毕，接下来可以进一步优化，让粒子模拟更具真实性和美观度。
    </p>
    <h2>
     <a id="_230">
     </a>
     引入粒子速度的随机性
    </h2>
    <p>
     我们现在需要为粒子系统引入一定的
     <strong>
      随机性
     </strong>
     ，因为只有在加入随机性之后，粒子系统才会真正开始变得有用，并且整体效果才能更加自然。当前的粒子运动轨迹过于规则，因此我们需要使其更具随机变化，以模拟更真实的效果。同时，我们还需要一个合适的粒子精灵（particle sprite），但这部分稍后再考虑。
    </p>
    <h4>
     <a id="_233">
     </a>
     <strong>
      引入随机性的必要性
     </strong>
    </h4>
    <p>
     目前，粒子运动是完全按照固定的方向和速度进行的，这使得它们在屏幕上呈现出一种过于整齐的模式，缺乏自然的扩散效果。如果要让粒子系统看起来更真实，我们需要让每个粒子的初始速度、颜色变化速率等参数都具有一定的随机性，使其更加接近现实中的烟雾、火焰或尘埃效果。
    </p>
    <h4>
     <a id="_236">
     </a>
     <strong>
      如何实现随机性
     </strong>
    </h4>
    <p>
     为了给粒子加入随机性，我们需要检查并确保代码中已经初始化了随机数生成器（random number generator）。我们应该有一个用于生成随机数的序列（series），但需要回顾并确认这个序列是否正确初始化了。如果没有，我们需要补充这部分逻辑，使其能够正确生成符合需求的随机数。
    </p>
    <p>
     下一步，我们可以利用这个随机数生成器来：
    </p>
    <ol>
     <li>
      <strong>
       扰动粒子的初始位置
      </strong>
      ，让它们在一定范围内随机分布，而不是全部集中在一个点上。
     </li>
     <li>
      <strong>
       随机化粒子的初始速度
      </strong>
      ，让它们的运动方向稍有不同，而不是完全一致地朝着固定方向运动。
     </li>
     <li>
      <strong>
       调整颜色变化的随机性
      </strong>
      ，让粒子衰减的速度有所不同，使其消失的过程更加自然。
     </li>
    </ol>
    <h2>
     <a id="_244">
     </a>
     为效果使用新的随机序列
    </h2>
    <h4>
     <a id="_245">
     </a>
     <strong>
      引入随机数序列以增强粒子系统的随机性
     </strong>
    </h4>
    <p>
     当前的代码中，我们可能没有一个专门的随机数序列在使用，因此我们需要创建一个专门用于粒子系统的随机数生成器。这一随机数序列主要用于
     <strong>
      特效（effects）
     </strong>
     ，而不是影响游戏核心逻辑的数据，以确保游戏性不受干扰。
    </p>
    <hr/>
    <h4>
     <a id="1__251">
     </a>
     <strong>
      1. 引入特效随机数序列
     </strong>
    </h4>
    <p>
     我们需要一个新的随机数序列作为
     <strong>
      熵（entropy）
      <strong>
       的来源，以便在粒子系统等特效中使用。由于
      </strong>
      粒子系统的随机数生成不需要严格的随机性
     </strong>
     ，即便有一些偏差或者非均匀分布也无所谓，所以将其与影响游戏核心逻辑的随机数分开存储是一个好的做法。
    </p>
    <p>
     我们创建一个新的随机数序列，命名为
     <code>
      EffectsEntropy
     </code>
     ，用于粒子特效的熵来源。这使得
     <strong>
      特效的随机性
     </strong>
     不会影响游戏的核心逻辑，比如地图生成、AI行为等需要更严格随机性的地方。
    </p>
    <hr/>
    <h4>
     <a id="2__258">
     </a>
     <strong>
      2. 代码中的调整
     </strong>
    </h4>
    <p>
     在初始化游戏状态时，我们检查现有的熵值生成方式，发现已经有一个
     <code>
      GeneralEntropy
     </code>
     ，但是其命名不太清晰，因此我们更改名称，使其更具可读性。
    </p>
    <ul>
     <li>
      <strong>
       调整
       <code>
        GeneralEntropy
       </code>
       的名称，使其明确区分为
       <code>
        EffectsEntropy
       </code>
      </strong>
     </li>
     <li>
      <strong>
       确保
       <code>
        EffectsEntropy
       </code>
       不会影响游戏核心逻辑，而仅仅用于特效
      </strong>
     </li>
     <li>
      <strong>
       更新所有涉及
       <code>
        GeneralEntropy
       </code>
       的代码，使其使用新的
       <code>
        EffectsEntropy
       </code>
      </strong>
     </li>
    </ul>
    <p>
     在修改完毕后，我们确认粒子系统仍然正常运行，没有受到这些调整的影响。
    </p>
    <hr/>
    <h4>
     <a id="3__269">
     </a>
     <strong>
      3. 应用随机数到粒子系统
     </strong>
    </h4>
    <p>
     现在，我们可以正式使用
     <code>
      EffectsEntropy
     </code>
     来
     <strong>
      增加粒子的随机运动
     </strong>
     。接下来，我们将：
    </p>
    <ol>
     <li>
      <strong>
       随机化粒子的初始位置
      </strong>
      ，让它们在一定范围内生成，而不是固定在某一点
     </li>
     <li>
      <strong>
       随机化粒子的初始速度
      </strong>
      ，使得它们的运动方向有所变化，而不是统一向上
     </li>
     <li>
      <strong>
       随机化粒子的颜色和透明度
      </strong>
      ，让它们的衰减过程更加自然
     </li>
    </ol>
    <p>
     通过这些调整，我们的粒子系统将更加动态化，呈现更自然的视觉效果。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/cfbc4fd4ca7c4038a60ffee68fc7ab07.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/29acdada984143edb9ba5670033fd0dc.png#pic_center"/>
    </p>
    <h2>
     <a id="_281">
     </a>
     微调速度
    </h2>
    <h4>
     <a id="_282">
     </a>
     <strong>
      继续优化粒子系统，引入更多随机性
     </strong>
    </h4>
    <p>
     为了让粒子效果更加自然，我们进一步引入了
     <strong>
      随机性
     </strong>
     ，使得粒子在空间中的分布更加动态化。通过调整
     <strong>
      粒子的速度、初始生成位置以及上升速度
     </strong>
     ，我们逐步改善了粒子系统的表现。
    </p>
    <hr/>
    <h4>
     <a id="1_X_288">
     </a>
     <strong>
      1. 给粒子添加随机的X轴速度
     </strong>
    </h4>
    <p>
     我们为粒子施加了一些
     <strong>
      随机的横向速度
     </strong>
     ，以打破原本严格向上的运动模式。这一步的核心实现是：
    </p>
    <ul>
     <li>
      <strong>
       使用
       <code>
        EffectsEntropy
       </code>
       生成随机数
      </strong>
     </li>
     <li>
      <strong>
       将X轴速度设置为
       <code>
        -1
       </code>
       到
       <code>
        1
       </code>
       之间的随机值
      </strong>
     </li>
     <li>
      <strong>
       使粒子运动时略微向左右扩散
      </strong>
      ，而不是全部笔直上升
     </li>
    </ul>
    <p>
     在可视化结果中，我们可以看到粒子开始沿着X轴
     <strong>
      向两侧扩散
     </strong>
     ，使得整个效果更具动态感。但由于扩散范围过大，效果显得有些“杂乱无章”，因此我们对范围进行了缩小，以使其更加协调。
    </p>
    <hr/>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6f4a72d3873746af8ac5da0f90961a0a.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/75d25b3b718646fb935ad4244ccd27fa.png#pic_center"/>
    </p>
    <h4>
     <a id="2__302">
     </a>
     <strong>
      2. 调整粒子的生成范围
     </strong>
    </h4>
    <p>
     除了调整速度，我们还修改了
     <strong>
      粒子的初始位置
     </strong>
     ，让它们的生成位置具有一定的随机性，而不是严格固定在某一点上。
    </p>
    <ul>
     <li>
      <strong>
       减少横向扩散的范围
      </strong>
      ，避免粒子系统显得过于凌乱
     </li>
     <li>
      <strong>
       将粒子生成区域限定在角色的脚下
      </strong>
      ，模拟角色踏地时产生的效果
     </li>
     <li>
      <strong>
       使粒子具有一定的向上漂浮特性
      </strong>
      ，避免它们看起来像是在地面上扩散
     </li>
    </ul>
    <p>
     调整后，我们可以看到粒子系统的效果开始变得更有层次感，仿佛
     <strong>
      从角色脚下向上飘散
     </strong>
     ，这与很多游戏中的魔法、烟雾、尘土等特效类似。
    </p>
    <hr/>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b86cc665764f467f874c43f0a9ca034d.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/046f40d7920847e78fbc69281fc1af5b.png#pic_center"/>
    </p>
    <h4>
     <a id="3__317">
     </a>
     <strong>
      3. 调整粒子的上升速度
     </strong>
    </h4>
    <p>
     尽管所有粒子都是向上移动的，但我们引入了
     <strong>
      不同的上升速度
     </strong>
     ，使每个粒子都有略微不同的运动轨迹。这使得整体效果更加自然，而不会显得呆板或机械化。
    </p>
    <ul>
     <li>
      <strong>
       给每个粒子的上升速度增加随机性
      </strong>
     </li>
     <li>
      <strong>
       让部分粒子上升得更快，部分粒子上升得更慢
      </strong>
     </li>
     <li>
      <strong>
       让粒子在初始阶段停留片刻后再开始衰减，制造“漂浮感”
      </strong>
     </li>
    </ul>
    <p>
     通过这些改动，粒子系统的表现更加
     <strong>
      生动有趣
     </strong>
     ，每个粒子的运动轨迹都略有不同，使其整体效果更具真实感和层次感。
    </p>
    <hr/>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d489860758154da59a76ab4ff4d318d3.png#pic_center"/>
    </p>
    <h4>
     <a id="4__330">
     </a>
     <strong>
      4. 继续优化与探索
     </strong>
    </h4>
    <p>
     在观察粒子的运动效果时，我们发现了一些与渲染相关的问题，例如Z轴似乎没有对粒子位置产生影响。这可能与当前渲染方式或深度处理逻辑有关，我们可能需要后续对渲染器进行优化，以更好地支持不同层级的粒子效果。
    </p>
    <p>
     此外，我们还可以进一步改进粒子系统，例如：
    </p>
    <ul>
     <li>
      <strong>
       使用更好的粒子纹理
      </strong>
      ，让效果更加精细
     </li>
     <li>
      <strong>
       调整粒子的颜色和透明度变化
      </strong>
      ，使其衰减过程更自然
     </li>
     <li>
      <strong>
       增加其他运动模式，例如旋转、缩放等
      </strong>
      ，增强视觉表现
     </li>
    </ul>
    <p>
     目前，我们的粒子系统已经基本实现了一个
     <strong>
      基础的粒子运动框架
     </strong>
     ，接下来，我们将继续优化其表现，使其更加符合实际需求。
    </p>
    <h2>
     <a id="_340">
     </a>
     选择不同的精灵
    </h2>
    <h4>
     <a id="_341">
     </a>
     <strong>
      优化粒子效果：更换精灵贴图
     </strong>
    </h4>
    <p>
     在对粒子系统的
     <strong>
      运动轨迹
     </strong>
     和
     <strong>
      随机性
     </strong>
     进行调整之后，我们开始思考如何
     <strong>
      提升视觉效果
     </strong>
     ，让粒子系统更加生动有趣。其中一个直观的改进方式是
     <strong>
      更换粒子的精灵贴图
     </strong>
     ，尝试不同的视觉风格，以寻找最适合的效果。
    </p>
    <hr/>
    <h4>
     <a id="1__347">
     </a>
     <strong>
      1. 尝试替换粒子精灵贴图
     </strong>
    </h4>
    <p>
     当前使用的粒子精灵贴图可能过于单调，因此我们测试了
     <strong>
      使用不同的精灵作为粒子
     </strong>
     ，比如：
    </p>
    <ul>
     <li>
      <strong>
       角色的头部
      </strong>
      （Head）
     </li>
     <li>
      <strong>
       角色的身体或躯干部分
      </strong>
      （Torso）
     </li>
    </ul>
    <p>
     这些替换带来了更加独特的视觉效果。例如，
     <strong>
      喷射出一堆角色头部
     </strong>
     ，看起来既搞笑又怪异，而
     <strong>
      喷射躯干
     </strong>
     则让粒子效果更具动态感。
    </p>
    <p>
     在测试过程中，我们发现粒子在
     <strong>
      地面上的偏移
     </strong>
     明显可见，这是因为精灵本身的热点（Hotspot）位置导致的。因此，我们需要考虑如何调整偏移量，使其在视觉上更自然。
    </p>
    <hr/>
    <h4>
     <a id="2__358">
     </a>
     <strong>
      2. 观察渲染器的表现
     </strong>
    </h4>
    <p>
     在测试不同粒子精灵的过程中，我们对
     <strong>
      渲染器的性能
     </strong>
     进行了观察。令人惊喜的是，
     <strong>
      渲染器能够毫无压力地处理大量粒子
     </strong>
     ，即使喷射出多个躯干或头部，它仍然能够保持高效的渲染，不出现明显的性能下降。这表明当前的渲染架构在粒子系统的处理上
     <strong>
      表现良好
     </strong>
     ，可以承载更多复杂的效果。
    </p>
    <p>
     我们可以利用这一优势，在未来的优化中加入：
    </p>
    <ul>
     <li>
      <strong>
       更多种类的粒子效果
      </strong>
      （如光效、火焰、烟雾等）
     </li>
     <li>
      <strong>
       更高质量的粒子纹理
      </strong>
      （如动态变化的贴图）
     </li>
     <li>
      <strong>
       增加粒子的旋转、缩放等动画
      </strong>
      ，增强视觉层次
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="3__368">
     </a>
     <strong>
      3. 还原之前的粒子精灵
     </strong>
    </h4>
    <p>
     在进行各种测试后，我们暂时恢复了原本的粒子精灵。虽然“喷射头部”或“喷射躯干”带来了有趣的视觉实验，但它们并不适用于当前的粒子效果目标。因此，我们会
     <strong>
      继续探索更合适的粒子贴图
     </strong>
     ，以确保最终效果既符合游戏风格，又能展现良好的视觉表现。
    </p>
    <hr/>
    <h4>
     <a id="_373">
     </a>
     <strong>
      下一步优化方向
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       调整粒子的热点位置
      </strong>
      ，确保它们与地面正确对齐
     </li>
     <li>
      <strong>
       设计更加合适的粒子精灵
      </strong>
      ，提升粒子系统的整体观感
     </li>
     <li>
      <strong>
       结合现有的运动逻辑，让粒子效果更加自然和生动
      </strong>
     </li>
    </ul>
    <p>
     目前，粒子系统已经初步成型，但仍有许多可以优化和拓展的空间。接下来，我们将继续尝试
     <strong>
      更复杂的粒子效果
     </strong>
     ，使其更加符合游戏的视觉需求。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3db96b88a3ea439ab70b3943e59b29f4.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3eaa504763aa40ee80b7db4ab6da83f6.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8b14b684b1eb43918cad13e96911ba96.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5d9098f23f1c4824ae4c4e84eef4a39e.png#pic_center"/>
    </p>
    <h2>
     <a id="_390">
     </a>
     颜色随机化
    </h2>
    <h4>
     <a id="_391">
     </a>
     <strong>
      优化粒子系统：颜色、透明度与粒子数量
     </strong>
    </h4>
    <p>
     在对粒子系统的基础
     <strong>
      运动逻辑
     </strong>
     进行调整后，我们进一步
     <strong>
      优化了粒子的视觉表现
     </strong>
     ，以提升整体效果，使其更加自然和生动。
    </p>
    <hr/>
    <h4>
     <a id="1__397">
     </a>
     <strong>
      1. 引入颜色随机化
     </strong>
    </h4>
    <p>
     为了增加粒子效果的多样性，我们决定
     <strong>
      为粒子赋予随机颜色
     </strong>
     ，在
     <strong>
      RGB 颜色通道
     </strong>
     中引入随机性，使粒子不再单一，而是带有微妙的色彩变化。这样一来，粒子系统整体上看起来会更加丰富，而不是单调的单色粒子。
    </p>
    <p>
     随机化的颜色变化很小，仅仅是在原有颜色的基础上
     <strong>
      增加轻微的随机偏差
     </strong>
     ，从而形成
     <strong>
      更具层次感
     </strong>
     的视觉效果，而不会影响粒子的整体风格。
    </p>
    <hr/>
    <h4>
     <a id="2_Alpha_404">
     </a>
     <strong>
      2. 透明度（Alpha）调整
     </strong>
    </h4>
    <p>
     在颜色随机化的基础上，我们
     <strong>
      降低了粒子的透明度
     </strong>
     ，并且
     <strong>
      引入了随机透明度变化
     </strong>
     ，从而使粒子在生成时不会显得过于突兀，而是更加自然地融入场景。
    </p>
    <p>
     调整后可以观察到：
    </p>
    <ul>
     <li>
      粒子产生的整体效果更具
      <strong>
       云雾感
      </strong>
      ，不像原本那样突兀
     </li>
     <li>
      由于透明度的随机性，每个粒子看起来都略有不同，避免了
      <strong>
       视觉上的重复感
      </strong>
     </li>
     <li>
      使粒子系统更加轻盈，减少“硬边”效果，使其更接近现实中的烟雾或魔法效果
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="3__414">
     </a>
     <strong>
      3. 增加粒子数量，形成更自然的效果
     </strong>
    </h4>
    <p>
     为了更好地观察和优化粒子效果，我们将粒子数量
     <strong>
      提升至 256 个
     </strong>
     ，是原来的
     <strong>
      四倍
     </strong>
     。这使得粒子更加密集，并且当它们叠加在一起时，开始呈现出一种更
     <strong>
      平滑和连续的形态
     </strong>
     ，接近
     <strong>
      烟雾、魔法能量或者其他柔和的视觉效果
     </strong>
     。
    </p>
    <p>
     此外，我们还
     <strong>
      延长了粒子的存活时间
     </strong>
     ，使其存在的时间更久，避免了粒子消失过快导致的“断裂”感。
    </p>
    <hr/>
    <h4>
     <a id="4__421">
     </a>
     <strong>
      4. 形成“云雾”或“魔法能量”效果
     </strong>
    </h4>
    <p>
     通过
     <strong>
      增加粒子数量、降低透明度、引入颜色随机化
     </strong>
     ，我们逐渐开始形成了一种类似
     <strong>
      云雾、魔法能量
     </strong>
     的视觉效果。这种效果在实际应用中可以用于：
    </p>
    <ul>
     <li>
      <strong>
       魔法技能释放的粒子效果
      </strong>
      （如火焰、能量波、冰霜等）
     </li>
     <li>
      <strong>
       环境特效
      </strong>
      （如雾气、烟雾、尘土）
     </li>
     <li>
      <strong>
       角色特殊效果
      </strong>
      （如幽灵般的能量环绕）
     </li>
    </ul>
    <p>
     当然，目前的粒子形态仍然
     <strong>
      相对简单
     </strong>
     ，仍然可以通过
     <strong>
      添加更多动态特性
     </strong>
     来进一步优化，比如
     <strong>
      粒子加速度、引力模拟、力场影响
     </strong>
     等。
    </p>
    <hr/>
    <h4>
     <a id="5__431">
     </a>
     <strong>
      5. 未来优化方向：加入粒子加速度与力场控制
     </strong>
    </h4>
    <p>
     在未来的优化中，我们可以
     <strong>
      引入粒子的加速度
     </strong>
     ，例如：
    </p>
    <ul>
     <li>
      <strong>
       受重力影响的粒子
      </strong>
      ：模拟自然落体运动，使粒子更符合现实物理规律
     </li>
     <li>
      <strong>
       向特定方向移动的粒子
      </strong>
      ：如魔法冲击波的扩散、火焰燃烧时的上升气流
     </li>
     <li>
      <strong>
       受力场影响的粒子
      </strong>
      ：可以创建漩涡、风场等独特的粒子效果
     </li>
    </ul>
    <p>
     尽管这些优化涉及到更
     <strong>
      复杂的物理计算
     </strong>
     ，但它们能够进一步提升粒子效果的真实感，使其更具
     <strong>
      动态感和层次感
     </strong>
     。
    </p>
    <hr/>
    <h4>
     <a id="_441">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       增加了粒子的颜色随机化
      </strong>
      ，使粒子更加丰富多彩
     </li>
     <li>
      <strong>
       调整透明度，使粒子过渡更加自然
      </strong>
      ，减少突兀感
     </li>
     <li>
      <strong>
       提升粒子数量，并延长存活时间
      </strong>
      ，形成更平滑、连续的视觉效果
     </li>
     <li>
      <strong>
       开始接近云雾、魔法能量的视觉表现
      </strong>
      ，但仍有优化空间
     </li>
     <li>
      <strong>
       未来可以加入粒子加速度、力场控制等更高级的物理模拟
      </strong>
     </li>
    </ul>
    <p>
     随着粒子系统的不断优化，它将能够用于更
     <strong>
      复杂的特效场景
     </strong>
     ，并在游戏中发挥更大的作用。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ca928a470f95452984e4a48438706a4b.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2f1195dda12340c2ac502987b2610085.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8951dfe5d7f8432dbeb1bbea3006ee28.png#pic_center"/>
    </p>
    <p>
     检查DrawRectangleQuickly 中颜色得alpha值
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a26586353bd349c289f45c79f536f47b.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2c5161766eba4a57bfd3d46c01463f9a.png#pic_center"/>
    </p>
    <h2>
     <a id="_462">
     </a>
     更明确的颜色渐变方式
    </h2>
    <h4>
     <a id="_463">
     </a>
     <strong>
      优化粒子颜色渐变及透明度控制
     </strong>
    </h4>
    <p>
     在优化粒子系统的过程中，我们发现
     <strong>
      单纯使用颜色变化来制造视觉效果往往是不够的
     </strong>
     。直接改变颜色的方式在某些情况下缺乏层次感，使得粒子系统的表现力受限。因此，我们引入了一种
     <strong>
      颜色渐变（Color Ramp）
     </strong>
     的方式，使粒子能够平滑地从不可见状态
     <strong>
      逐渐显现
     </strong>
     ，然后
     <strong>
      再淡出消失
     </strong>
     ，从而避免突兀的“粒子突然出现”现象。
    </p>
    <hr/>
    <h4>
     <a id="1__Color_Ramp__469">
     </a>
     <strong>
      1. 颜色渐变 (Color Ramp) 的重要性
     </strong>
    </h4>
    <p>
     在粒子系统中，单独使用随机颜色虽然能增加变化性，但如果没有
     <strong>
      合适的渐变控制
     </strong>
     ，粒子会直接以某个固定的颜色和透明度出现，导致粒子
     <strong>
      在某些情况下会显得突兀
     </strong>
     ，尤其是当它们从无到有时，会给人一种突然“弹出”的感觉。
    </p>
    <p>
     为了解决这个问题，我们希望粒子能够
     <strong>
      通过一系列颜色渐变逐步显现
     </strong>
     ，并且在消失时也
     <strong>
      逐渐淡出
     </strong>
     ，形成更加平滑的视觉过渡。这种渐变可以通过一个
     <strong>
      颜色插值曲线（Color Ramp）
     </strong>
     来实现。
    </p>
    <hr/>
    <h4>
     <a id="2__Alpha_Curve__476">
     </a>
     <strong>
      2. 透明度曲线 (Alpha Curve) 的应用
     </strong>
    </h4>
    <p>
     为了实现粒子的逐渐显现和消失，我们需要让透明度（Alpha 值）按照一定的规律
     <strong>
      从 0 逐步增大到最大值
     </strong>
     ，然后在消失前
     <strong>
      逐步降低回 0
     </strong>
     ，这样粒子就不会在屏幕上突然出现或消失，而是形成一个
     <strong>
      平滑的“淡入-淡出”
     </strong>
     过渡效果。
    </p>
    <p>
     <strong>
      具体实现方式如下
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       粒子刚生成时的透明度为 0（完全不可见）
      </strong>
     </li>
     <li>
      <strong>
       在粒子生命周期的早期阶段，透明度快速上升
      </strong>
      ，使粒子逐渐变得清晰可见
     </li>
     <li>
      <strong>
       在粒子生命周期的后期阶段，透明度缓慢下降
      </strong>
      ，直到完全消失
     </li>
     <li>
      <strong>
       使用插值函数或曲线映射来平滑控制透明度
      </strong>
      ，使过渡更加自然
     </li>
    </ol>
    <p>
     为此，我们可以将透明度的变化映射到一个曲线（curve）上。例如，我们可以创建一个
     <strong>
      映射函数 (Map To Range)
     </strong>
     ，将粒子生命周期中的透明度控制在 0-1 之间，并在特定区间内进行调整，使透明度的变化更加平滑。
    </p>
    <hr/>
    <h4>
     <a id="3__489">
     </a>
     <strong>
      3. 使用映射函数优化透明度变化
     </strong>
    </h4>
    <p>
     为了实现上述
     <strong>
      透明度曲线
     </strong>
     ，我们使用了一个
     <strong>
      数值映射 (Map To Range)
     </strong>
     方法，该方法可以将一个范围内的数值映射到新的区间。例如，我们希望在透明度范围
     <strong>
      0.9 到 1.0
     </strong>
     之间执行透明度衰减，可以使用如下方法：
    </p>
    <ul>
     <li>
      <strong>
       先获取当前的透明度值 A
      </strong>
     </li>
     <li>
      <strong>
       如果 A 处于 0.9 到 1.0 之间，则执行映射，使其在该区间内平滑过渡
      </strong>
     </li>
     <li>
      <strong>
       使用
       <code>
        1.0 - A
       </code>
       计算新的透明度值，使其逐渐变淡
      </strong>
     </li>
    </ul>
    <p>
     实现后，可以观察到粒子的
     <strong>
      透明度变化更加平滑
     </strong>
     ，并且消失时不会有明显的“断裂”感，而是更自然地融入场景。
    </p>
    <hr/>
    <h4>
     <a id="4__500">
     </a>
     <strong>
      4. 进一步优化：粒子加速度与动态效果
     </strong>
    </h4>
    <p>
     除了透明度变化外，我们还可以进一步优化粒子系统，使其更加自然。例如：
    </p>
    <ol>
     <li>
      <strong>
       引入粒子的加速度控制
      </strong>
      <ul>
       <li>
        让粒子在生命周期内呈现
        <strong>
         缓慢加速或减速
        </strong>
        的状态，而不是以固定速度运动
       </li>
       <li>
        可以模拟
        <strong>
         重力、上升气流、风场等物理效果
        </strong>
        ，增加真实感
       </li>
      </ul>
     </li>
     <li>
      <strong>
       使用更复杂的力场（Field Effect）
      </strong>
      <ul>
       <li>
        可以模拟
        <strong>
         漩涡、爆炸冲击波、磁场引力
        </strong>
        等效果
       </li>
       <li>
        让粒子不只是简单的直线移动，而是具备更复杂的运动模式
       </li>
      </ul>
     </li>
     <li>
      <strong>
       结合颜色变化，创造更丰富的视觉层次
      </strong>
      <ul>
       <li>
        例如，粒子在诞生时是
        <strong>
         红色
        </strong>
        ，然后逐渐变为
        <strong>
         黄色
        </strong>
        ，最后淡出时变成
        <strong>
         白色
        </strong>
        ，可以模拟火焰燃烧的过程
       </li>
       <li>
        可以根据粒子的速度、存活时间、位置等因素，动态调整颜色
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="5__514">
     </a>
     <strong>
      5. 其他问题排查
     </strong>
    </h4>
    <p>
     在测试过程中，我们还尝试解决了一些
     <strong>
      技术问题
     </strong>
     ，例如：
    </p>
    <ul>
     <li>
      由于日志文件的缓存问题，导致调试工具无法正常工作，我们
      <strong>
       清理了旧日志
      </strong>
      ，并尝试删除缓存数据，使系统能够重新运行
     </li>
     <li>
      通过调整粒子透明度的控制逻辑，我们
      <strong>
       优化了粒子淡入淡出的过程
      </strong>
      ，并确保透明度变化更加自然
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="6__521">
     </a>
     <strong>
      6. 未来优化方向
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       加入更精细的颜色渐变控制
      </strong>
      ，例如使用
      <strong>
       HSL 色彩空间插值
      </strong>
      ，让粒子颜色变化更加平滑
     </li>
     <li>
      <strong>
       优化粒子的运动轨迹
      </strong>
      ，如加入随机扰动、风场模拟等，使粒子更加具有动态感
     </li>
     <li>
      <strong>
       探索更复杂的粒子交互
      </strong>
      ，如粒子之间的吸引、碰撞、融合等，使系统更加真实
     </li>
    </ul>
    <p>
     目前的优化已经
     <strong>
      大幅提升了粒子系统的表现力
     </strong>
     ，但仍有
     <strong>
      许多可以改进的地方
     </strong>
     ，未来可以继续优化粒子的
     <strong>
      颜色、透明度、动态特性
     </strong>
     ，以实现更高级的视觉效果。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0cf9ff0632424f35a5698a60b832c2df.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0cc38c8d672c4aaa93640462a18e8679.png#pic_center"/>
    </p>
    <h2>
     <a id="_RGB__YCrCb__LAB__YCrCb__RGB__532">
     </a>
     我一直觉得在 RGB 中插值粒子颜色会导致颜色显得暗淡和浑浊。我一直想尝试 YCrCb 或者 LAB 色彩空间。虽然 YCrCb 只是一个线性转换，但我认为仍然有不少失真。我想如果通过 RGB 曲线插值，虽然可以补偿，但会经常需要调整才能得到更好的效果。
    </h2>
    <h4>
     <a id="_533">
     </a>
     <strong>
      关于粒子颜色插值与颜色空间的优化
     </strong>
    </h4>
    <p>
     在讨论粒子系统的颜色插值时，我们发现
     <strong>
      直接在 RGB 颜色空间内进行插值
     </strong>
     往往会导致粒子颜色变得
     <strong>
      暗淡、混浊（dull and muddy）
     </strong>
     。因此，我们考虑使用
     <strong>
      不同的颜色空间
     </strong>
     ，如
     <strong>
      YCbCr
     </strong>
     或
     <strong>
      HSV
     </strong>
     ，以获得更自然、更丰富的颜色变化效果。
    </p>
    <hr/>
    <h4>
     <a id="1_RGB__539">
     </a>
     <strong>
      1. RGB 颜色插值的问题
     </strong>
    </h4>
    <p>
     在传统的粒子系统中，颜色插值通常是在
     <strong>
      RGB（红绿蓝）
     </strong>
     颜色空间内进行。然而，RGB 颜色空间的特点使得简单的线性插值可能会导致
     <strong>
      颜色变得灰暗或不自然
     </strong>
     ，主要原因如下：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        RGB 不是感知均匀的颜色空间
       </strong>
      </p>
      <ul>
       <li>
        在 RGB 颜色空间内，人眼对不同颜色通道的变化感知程度不同。例如，在绿色通道上的变化可能比红色通道更显著，因此直接在 RGB 空间内插值时，某些颜色的过渡可能会显得不平滑或失真。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        RGB 线性插值可能导致不自然的颜色过渡
       </strong>
      </p>
      <ul>
       <li>
        例如，如果我们在红色 (255, 0, 0) 和蓝色 (0, 0, 255) 之间进行线性插值，RGB 计算出的中间色将是 (127, 0, 127)，即紫色。然而，这种紫色往往是
        <strong>
         暗淡的
        </strong>
        ，而不是我们期望的鲜艳颜色。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        补偿 RGB 插值需要大量微调
       </strong>
      </p>
      <ul>
       <li>
        为了弥补 RGB 颜色插值的问题，通常需要进行大量的
        <strong>
         手动调整（tweaking）
        </strong>
        ，如调整色彩亮度、对比度或手动增加某些颜色分量，使其看起来更加鲜艳。这种方式虽然可行，但会增加开发工作量，并且不够直观。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="2_YCbCr__553">
     </a>
     <strong>
      2. YCbCr 颜色空间的潜在优势
     </strong>
    </h4>
    <p>
     YCbCr 颜色空间是
     <strong>
      一种亮度（Y）和色度（Cb、Cr）分离的颜色空间
     </strong>
     ，相比 RGB，它有几个潜在优势：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        亮度（Y）和色彩信息（CbCr）分离
       </strong>
       ：
      </p>
      <ul>
       <li>
        由于 Y 分量独立控制亮度，在 YCbCr 颜色空间中调整颜色时，可以单独控制亮度，而不会影响色彩本身的饱和度或色调。
       </li>
       <li>
        这可能会使粒子的颜色变化更加自然，避免 RGB 插值可能导致的灰暗问题。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        更适合感知均匀的插值
       </strong>
       ：
      </p>
      <ul>
       <li>
        由于人眼对亮度的敏感度高于色彩变化，YCbCr 颜色空间的插值可能会让颜色变化更加符合人眼的感知，使粒子颜色过渡更加平滑。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        YCbCr 只是一种线性变换，计算开销低
       </strong>
       ：
      </p>
      <ul>
       <li>
        颜色从 RGB 转换到 YCbCr 只需要简单的矩阵运算，因此在 CPU 或 GPU 上计算都不会带来太大额外开销。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     尽管如此，我们目前还没有尝试在粒子系统中使用 YCbCr 进行插值，未来可能会进行测试，以评估它是否能有效改善粒子颜色表现。
    </p>
    <hr/>
    <h4>
     <a id="3_HSV__570">
     </a>
     <strong>
      3. HSV 颜色空间的应用及优势
     </strong>
    </h4>
    <p>
     HSV（色相 Hue、饱和度 Saturation、明度 Value）是一种常用于
     <strong>
      颜色调整和特效
     </strong>
     的颜色空间，相较于 RGB，它具有以下几个优势：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        HSV 更容易生成特定的颜色渐变效果
       </strong>
      </p>
      <ul>
       <li>
        由于 HSV 直接使用
        <strong>
         色相（H）
        </strong>
        来表示颜色，因此可以通过简单地调整 H 值，快速生成
        <strong>
         彩虹渐变
        </strong>
        、
        <strong>
         光晕特效
        </strong>
        等视觉效果，而无需手动调整 RGB 颜色通道。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        HSV 变换的计算开销并不高
       </strong>
      </p>
      <ul>
       <li>
        在现代 CPU（如 SSE 指令集）或 GPU（着色器）上，HSV 变换所需的数学运算相对较少，
        <strong>
         转换开销可以忽略不计
        </strong>
        。
       </li>
       <li>
        因此，在不影响性能的情况下，可以考虑使用 HSV 进行粒子颜色处理。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        粒子颜色的控制更加直观
       </strong>
      </p>
      <ul>
       <li>
        通过调整
        <strong>
         饱和度（S）
        </strong>
        和
        <strong>
         明度（V）
        </strong>
        ，可以很容易地控制粒子的视觉表现，例如：
        <ul>
         <li>
          <strong>
           降低饱和度
          </strong>
          → 使粒子颜色更接近白色，增强发光感
         </li>
         <li>
          <strong>
           降低明度
          </strong>
          → 让粒子逐渐消失，而不是突然变暗
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     我们已经在某些项目中尝试过 HSV 颜色空间，并发现它在
     <strong>
      粒子系统中的效果非常出色
     </strong>
     ，尤其是在
     <strong>
      制造彩虹渐变、能量波动、光晕等特效
     </strong>
     时，HSV 能够提供比 RGB 更自然的颜色变化。
    </p>
    <hr/>
    <h4>
     <a id="4__589">
     </a>
     <strong>
      4. 性能与应用场景的权衡
     </strong>
    </h4>
    <p>
     尽管 HSV 颜色空间在粒子系统中表现良好，但仍然需要考虑性能问题。在高性能要求的场景中，我们可能仍然会选择
     <strong>
      使用 RGB
     </strong>
     ，因为：
    </p>
    <ul>
     <li>
      <strong>
       RGB 插值计算最简单，速度最快
      </strong>
     </li>
     <li>
      <strong>
       粒子系统通常需要大规模并行处理
      </strong>
      ，RGB 计算可以减少额外的转换开销
     </li>
     <li>
      <strong>
       某些 GPU 优化管线可能更适合直接处理 RGB 颜色
      </strong>
     </li>
    </ul>
    <p>
     然而，如果粒子系统对视觉效果要求较高（例如光晕、魔法特效等），那么使用
     <strong>
      HSV 或其他更合适的颜色空间
     </strong>
     可能会带来更好的表现。
    </p>
    <hr/>
    <h4>
     <a id="5__600">
     </a>
     <strong>
      5. 未来可能的优化方向
     </strong>
    </h4>
    <p>
     根据目前的讨论，未来可以尝试以下几种优化方式，以提升粒子颜色插值的质量：
    </p>
    <ol>
     <li>
      <strong>
       实现 YCbCr 颜色空间插值，并对比 RGB 和 HSV 的实际表现
      </strong>
     </li>
     <li>
      <strong>
       优化 HSV 颜色空间转换，使用 SIMD 指令或 GPU 着色器加速计算
      </strong>
     </li>
     <li>
      <strong>
       探索其他颜色空间（如 LAB、XYZ 等），寻找最适合粒子渲染的颜色表示方式
      </strong>
     </li>
     <li>
      <strong>
       在不同颜色空间中进行插值，并动态调整粒子颜色，使其更加符合视觉预期
      </strong>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="6__610">
     </a>
     <strong>
      6. 总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       RGB 颜色插值容易导致颜色灰暗和不自然的过渡
      </strong>
     </li>
     <li>
      <strong>
       YCbCr 颜色空间可以减少颜色失真，但仍需要进一步测试
      </strong>
     </li>
     <li>
      <strong>
       HSV 颜色空间在粒子效果中表现良好，尤其适用于彩虹渐变、光晕等特效
      </strong>
     </li>
     <li>
      <strong>
       不同颜色空间各有优劣，具体应用需要根据需求和性能权衡
      </strong>
     </li>
    </ul>
    <p>
     未来，我们将进一步优化粒子的颜色插值算法，探索更优的颜色空间，以提升粒子系统的视觉效果和表现力。
    </p>
    <h2>
     <a id="_618">
     </a>
     粒子预加热会被支持吗？
    </h2>
    <h4>
     <a id="PreWarming_619">
     </a>
     <strong>
      关于粒子系统的预热（Pre-Warming）支持
     </strong>
    </h4>
    <p>
     在讨论粒子系统时，我们考虑了
     <strong>
      预热（Pre-Warming）
     </strong>
     的问题。粒子系统在刚刚启动时，往往需要一定时间才能演变到其
     <strong>
      稳定状态
     </strong>
     。
    </p>
    <p>
     例如，当前的粒子系统在运行一段时间后，会形成一个完整的视觉效果。但是，如果
     <strong>
      游戏刚启动
     </strong>
     ，粒子系统的初始状态通常是
     <strong>
      空的
     </strong>
     ，然后逐渐填充、增长，最终达到预期的视觉效果。
    </p>
    <hr/>
    <h4>
     <a id="1__627">
     </a>
     <strong>
      1. 预热的必要性：何时需要？
     </strong>
    </h4>
    <p>
     预热主要适用于
     <strong>
      持续循环的粒子特效
     </strong>
     ，而非
     <strong>
      一次性触发的粒子效果
     </strong>
     。
    </p>
    <h5>
     <a id="1_630">
     </a>
     <strong>
      （1）哪些情况不需要预热？
     </strong>
    </h5>
    <p>
     如果粒子效果是
     <strong>
      一次性触发
     </strong>
     的，例如
     <strong>
      爆炸、火焰喷射、魔法攻击
     </strong>
     等，它们的效果是
     <strong>
      即时的
     </strong>
     ，不需要预热。因为这些效果本身就是从零开始发展，不存在“逐渐填充”的问题。
    </p>
    <h5>
     <a id="2_633">
     </a>
     <strong>
      （2）哪些情况需要预热？
     </strong>
    </h5>
    <p>
     对于
     <strong>
      持续播放的粒子系统
     </strong>
     ，如果不进行预热，可能会在游戏启动时出现
     <strong>
      不自然的视觉效果
     </strong>
     。例如：
    </p>
    <ul>
     <li>
      <strong>
       瀑布
      </strong>
      ：如果游戏刚加载时，瀑布的粒子从顶部开始生成，而不是一个已经在流动的状态，玩家会看到水流突然出现，而非持续的流水效果。
     </li>
     <li>
      <strong>
       火焰、烟雾
      </strong>
      ：如果粒子系统的初始状态是空的，火焰或烟雾的视觉效果可能需要
      <strong>
       数秒时间
      </strong>
      才能达到正确的密度。
     </li>
     <li>
      <strong>
       云雾、风沙、星空
      </strong>
      ：如果没有预热，刚进入游戏时，这些效果可能会显得稀疏或不完整。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="2__641">
     </a>
     <strong>
      2. 预热的可能解决方案
     </strong>
    </h4>
    <p>
     预热的核心目标是
     <strong>
      让粒子系统在游戏开始时，就直接处于稳定状态，而不是从零开始演化
     </strong>
     。有几种方法可以解决这个问题：
    </p>
    <h5>
     <a id="1Simulated_Time_644">
     </a>
     <strong>
      （1）运行模拟时间（Simulated Time）
     </strong>
    </h5>
    <ul>
     <li>
      在粒子系统初始化时，
      <strong>
       手动运行几帧或几秒的粒子更新逻辑
      </strong>
      ，让它们进入稳定状态，然后再让它们开始正常运行。
     </li>
     <li>
      例如，可以在游戏启动时，运行
      <code>
       UpdateParticles(deltaTime)
      </code>
      <strong>
       多次
      </strong>
      ，模拟粒子系统运行一段时间，确保粒子分布符合预期。
     </li>
     <li>
      适用于
      <strong>
       任何粒子系统
      </strong>
      ，但可能会增加初始化计算量。
     </li>
    </ul>
    <h5>
     <a id="2PreGenerated_State_649">
     </a>
     <strong>
      （2）记录并加载预热状态（Pre-Generated State）
     </strong>
    </h5>
    <ul>
     <li>
      预先计算并存储粒子系统在
      <strong>
       稳定状态
      </strong>
      时的状态，并在游戏启动时直接加载该状态，而不是让粒子系统从零开始运行。
     </li>
     <li>
      适用于
      <strong>
       特定、重复使用的粒子系统
      </strong>
      （如瀑布、火焰）。
     </li>
     <li>
      可能会增加内存消耗，但可以减少 CPU 计算开销。
     </li>
    </ul>
    <h5>
     <a id="3Spawn_Offset_654">
     </a>
     <strong>
      （3）调整粒子生命周期（Spawn Offset）
     </strong>
    </h5>
    <ul>
     <li>
      让粒子在生成时就具有
      <strong>
       随机的生命周期偏移量
      </strong>
      ，而不是所有粒子都从
      <code>
       t=0
      </code>
      开始。
     </li>
     <li>
      例如，在初始化时，不是所有粒子都从诞生状态开始，而是部分粒子已经接近生命周期结束，这样就能快速填充整个效果。
     </li>
     <li>
      适用于
      <strong>
       大规模持续特效
      </strong>
      （如烟雾、雨滴、风沙）。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="3__661">
     </a>
     <strong>
      3. 何时实现预热？
     </strong>
    </h4>
    <p>
     目前，我们还不确定是否需要在当前的粒子系统中加入预热功能。因为
     <strong>
      是否存在明显的“初始状态异常”
     </strong>
     取决于
     <strong>
      具体的粒子效果
     </strong>
     。
    </p>
    <ul>
     <li>
      如果发现某些持续特效（如瀑布）在游戏启动时有明显的**“粒子填充延迟”**，那么可能需要加入预热机制。
     </li>
     <li>
      但如果所有粒子效果在启动时都能较快进入正常状态，预热可能就不是必要的优化。
     </li>
    </ul>
    <p>
     在未来的开发过程中，我们会根据实际需要，决定是否引入预热机制，并选择合适的方法来优化粒子系统的初始化表现。
    </p>
    <h2>
     <a id="_Z__669">
     </a>
     当你调整 Z 方向时，感觉有点像是地上的水坑
    </h2>
    <p>
     在调整 Z 方向的参数时，观察到粒子系统的效果更像是滞留在地面上的一滩液体。当 Y 方向上没有任何运动时，粒子表现得像一个平铺在地面的“水坑”状结构，缺乏立体感和动态变化。这种情况可能是因为粒子在 Z 方向上的运动没有足够的高度变化，使得整体效果显得较为扁平，没有预期中的立体层次感。
    </p>
    <p>
     如果希望粒子系统呈现更自然的扩散效果，而不是像滞留在地面上的液体，可以考虑增加 Y 方向上的随机运动，或者在生成时加入更多的高度偏移，让粒子能够更自由地在三维空间中分布。这种方式有助于增强粒子效果的层次感，使其更具立体感和动态表现力。
    </p>
    <h2>
     <a id="_674">
     </a>
     你有没有尝试过使用无状态系统来做这些事情？比如一个由另一个函数参数化的函数？
    </h2>
    <p>
     曾经尝试过使用一种状态系统来让一个函数的参数由另一个函数决定吗？是的，曾经尝试过这种方式，但并不特别喜欢。我发现这种方法会过多限制粒子的表现。很多想要实现的粒子效果，尤其是较复杂的效果，并不适合这种方式，除非粒子的更新非常慢。因为粒子系统涉及的变量和状态非常庞大，所以如果采用这种方式来控制，会显得过于僵化，不够灵活。
    </p>
    <h2>
     <a id="_677">
     </a>
     雨是粒子系统吗？
    </h2>
    <p>
     是的，雨通常会作为粒子系统来实现。粒子系统非常适合模拟雨滴的效果，因为雨滴是一个大量的小物体，具有一定的随机性和运动规律。通过粒子系统，可以控制雨滴的生成、下落速度、大小、透明度等特性，从而实现真实或艺术化的雨景效果。
    </p>
    <h2>
     <a id="_680">
     </a>
     我在想，像这种头部粒子是否可以用于游戏中……例如作为魔法效果的一部分，像是当你解开“超级鱼”的伪装时。
    </h2>
    <p>
     可以考虑将这种粒子效果应用到游戏中，例如作为与魔法相关的效果，特别是在伪装或消失的场景中。例如，当某个角色消失时，可以使用这种粒子效果，让角色逐渐溶解或变得不明显，从而增强魔法效果的表现力。这种效果通过粒子系统能够创建非常细致且具有视觉冲击力的消失过程，增加游戏的沉浸感和幻想感。
    </p>
    <h2>
     <a id="RGB__683">
     </a>
     RGB 可能太晚改了，但我们并不依赖于粒子。
    </h2>
    <p>
     在讨论粒子系统时，提到的RGB颜色空间可能并不是最理想的选择，尤其是在一些游戏中，可能没有必要依赖这种方式。比如在一些游戏里，粒子系统的使用并没有强调颜色的变化，特别是在游戏《见证者》这类作品中，并没有感觉到粒子系统需要使用HSV（色相、饱和度、亮度）来进行颜色变换。
    </p>
    <p>
     HSV更多的是用来做彩虹效果等特定的颜色过渡，它适用于那些需要通过颜色饱和度和亮度变化的效果。对于大多数粒子系统来说，如果没有特定的颜色变化需求，HSV的优势就显得不那么明显。因此，HSV主要是为了在游戏中创建某些颜色过渡效果，比如在处理彩虹等颜色渐变效果时会比较有用。但如果并不涉及到颜色的变化或颜色饱和度的过渡，这样的粒子系统就没有太大用处。
    </p>
    <p>
     总之，HSV是一个比较有限的工具，主要在需要颜色过渡和变化的效果中才会发挥作用。如果只是简单的颜色变化，可能就不需要依赖HSV了。
    </p>
    <h2>
     <a id="Z__690">
     </a>
     Z 现在指向屏幕
    </h2>
    <p>
     在讨论渲染时，提到的技能点朝屏幕的方向看起来是对的，但仍然存在一些问题。最后一次渲染的检查清单上还有一些待完成的工作。当前情况是，渲染效果还不完全正确，特别是在层叠效果上，地面层的堆叠和其他细节还没有完全到位。虽然效果看起来正确，但地面层的堆叠和排列仍然不够精确，因此需要进一步调整和整理，确保所有的层级都正确地堆叠并呈现。
    </p>
    <h2>
     <a id="_Z__693">
     </a>
     有没有人用过层？还是只是用 Z 排序？
    </h2>
    <p>
     在讨论新的目标时，提到是否有使用“层”（layers），还是只是依赖于“排序”来处理层级问题。对层的具体含义不太清楚，因此需要进一步澄清“层”指的是什么。可能是在问是否使用了传统的图层系统来管理不同的渲染层，还是仅仅通过排序来决定物体的绘制顺序。
    </p>
    <h2>
     <a id="_Galaga__HSV_696">
     </a>
     也许为了 Galaga 游戏我会切换到 HSV……
    </h2>
    <p>
     如果是银河游戏，可能会考虑切换到 HSV 色彩模式。然而，另一方表示，在游戏中没有“奖励回合”时，就不想再听到关于银河游戏的讨论了。强调“奖励回合”是经典游戏《Gallagher》的关键特色之一，缺少了奖励回合，游戏就失去了它的独特性，甚至觉得游戏变得像《太空侵略者》一样，失去了原本的魅力。因此，若游戏中没有“奖励回合”机制，他甚至不想再继续玩这个银河游戏。
    </p>
    <h2>
     <a id="_C__C__699">
     </a>
     这些视频能帮助那些完全没有经验的人学习 C 和 C++ 吗？
    </h2>
    <p>
     这些视频对于完全没有编程经验的人学习 C 和 C++ 并不完全足够。虽然曾经制作过一些简单的教程，比如在 Windows 上的 C 语言入门课程，但这些内容并不全面，只是简单地介绍了一些基础知识。尽管如此，未来计划制作一个更完整的课程，专为零基础的人设计，帮助他们从完全不了解编程开始，到掌握基本的编程技能，并最终能够进行像《游戏英雄》这样的项目开发。这个计划的目标是为那些完全不了解编程的人提供从入门到掌握 C 语言的完整学习路径。
    </p>
    <p>
     目前的教学内容更多是针对那些已经具备一定编程基础的人，因此如果目标是帮助零基础的学习者，现有的教程可能还不够系统和深入。
    </p>
    <h2>
     <a id="_704">
     </a>
     你会解释一下着色器是怎么工作的吗？
    </h2>
    <p>
     我们已经编写了自己的渲染器，并且也写了自己的着色器部分的代码。所以，实际上我们已经涵盖了如何实现渲染器的部分内容。但如果你是指如何编写 OpenGL 着色器，或者是关于该语言的语法，我们还没有专门讲解这些内容。我们可能会在以后轻微地涉及这些内容，特别是在将项目迁移到 OpenGL 或 Vulkan 等其他平台时，可能会有相关的讲解。
    </p>
    <h2>
     <a id="_707">
     </a>
     这些粒子会对像碰撞这样的事件做出反应吗？
    </h2>
    <p>
     粒子系统是可以对像冲击这样的事件做出反应的。之所以不喜欢将粒子做成封闭形式的函数，是因为希望粒子系统能够像普通的物理对象一样进行模拟。这样，你可以让粒子系统根据不同的游戏情境，比如爆炸、风力等，进行反应，并且不需要担心如何将这些变化强行适配到某个固定的封闭形式中。通过这种方式，可以更加灵活地让粒子与游戏中的动态环境互动。
    </p>
    <h2>
     <a id="_710">
     </a>
     目前有多少粒子？
    </h2>
    <p>
     目前系统中大约有26个粒子在不断地喷发出来。这些粒子正在以一定的方式从系统中释放出来。
    </p>
    <h2>
     <a id="_713">
     </a>
     多少粒子才会导致明显的性能下降？
    </h2>
    <p>
     目前对于粒子数量的性能影响尚不确定，因为还有一些其他的因素和时间因素需要考虑。首先，当前的渲染方式并不是最优的。每个粒子调用
     <code>
      push_to_map
     </code>
     进行处理并不是理想的做法。
    </p>
    <p>
     如果我们想要优化粒子效果的处理，当我们决定实现一个复杂的粒子系统时，可能会使用更高效的处理方式，而不仅仅是增加粒子的数量。现阶段，最可能影响性能的是粒子的渲染，特别是“头部”部分的渲染，这会消耗大量的时间。影响性能的因素不仅是粒子的数量，粒子的大小也会有很大影响。例如，如果粒子的“头部”变大，渲染时会出现大量的重绘，造成性能下降。
    </p>
    <p>
     可以观察到，随着粒子头部变大，系统已经开始变慢，原因就是过度绘制的现象非常明显。这会对渲染产生较大的压力，影响性能。但并不是要极力避免高粒子数量的展示，我们可以根据硬件进行优化，确保硬件加速粒子的渲染。
    </p>
    <p>
     另外，即使在软件渲染的情况下，也有一些方法可以提高粒子系统的性能，可以在软件中实现相对高效的粒子系统。虽然这可能不会是最实际的做法，但作为教育性的实验，探索这些技术依然是有趣且值得尝试的。
    </p>
    <h2>
     <a id="_722">
     </a>
     你打算什么时候实现调整个别粒子位置的功能，当实体移动时？
    </h2>
    <p>
     关于调整粒子位置以便与实体一起移动的问题，其实并不一定必须要做得那么复杂。粒子的位置通常可以通过外部控制来调整，而不必强行将其嵌入到粒子系统内部。关键是要确定如何设置粒子的锚点位置，这是粒子系统的一大难题。
    </p>
    <p>
     在处理粒子时，我们需要决定如何对粒子进行定位。一种方式是将粒子锚定在世界坐标系中，这样它们的位置和运动就能根据世界的变化来调整。另一种方式是使用屏幕空间坐标，这样粒子会跟随屏幕上的视角而调整位置。至于具体使用哪种方法，还需要根据具体情况和需求来决定，因为两者都有各自的优缺点。
    </p>
    <h2>
     <a id="_C__C_727">
     </a>
     为什么你选择了 C++ 而不是 C#？
    </h2>
    <p>
     选择C++而不是C#的原因主要是因为C#是为编写其他程序而设计的语言，它运行在虚拟机上，具有垃圾回收等机制。而C++则是一种直接编译为汇编代码的语言，能够更直接地展示计算机如何执行代码。这样可以让人更清晰地看到编写的代码与计算机执行之间的直接关系。
    </p>
    <p>
     在这个项目中，目的是展示如何编程计算机，所以需要选择一种能够直接控制硬件的语言。C++提供了这种能力，可以直接生成底层代码，而C#更侧重于通过虚拟机层进行操作，适合的是开发高层应用程序，而不是直接与计算机硬件交互。所以，C++更符合这个目标。
    </p>
    <h2>
     <a id="_732">
     </a>
     你会用曲线调整哪些参数？缩放、位置、颜色、旋转、外部力等。曲线只会依赖时间吗？
    </h2>
    <p>
     粒子系统通常是根据需要随时调整的，而不是预先定义的。除非你在做一个大型的游戏引擎，比如Epic或Unity那样需要一个通用的粒子系统，能够应对各种不同类型的游戏，否则很少会提前设计好一个完美的通用粒子系统。对于大多数情况来说，粒子系统需要应对很多复杂多变的需求，但很难做到完全支持所有情况。
    </p>
    <p>
     在这种情况下，粒子系统是根据游戏开发中的需求来编写的。因为游戏是手写的，所以可以根据需要灵活调整。遇到需要粒子效果的地方时，可以直接编写相应的粒子代码，而不需要提前思考所有可能的情况。这样，当游戏大致完成并且转入游戏代码的开发时，如果某个地方需要加入粒子效果，便可以根据具体情况来添加和调整粒子效果的实现。
    </p>
    <h2>
     <a id="_737">
     </a>
     你能解释一下什么是程序化关卡生成吗？还有其他类型的生成方法吗？它们有什么区别？
    </h2>
    <p>
     程序化关卡生成是指通过算法在每次启动游戏时动态生成关卡，而不是由关卡设计师手工设计并固定每个元素的位置。简单来说，程序化关卡生成就是使用代码来决定关卡的布局，这样每次进入游戏时，关卡都会有所不同，而不是每次都是同样的设计。
    </p>
    <p>
     与之相对的传统关卡设计是通过关卡设计师手动布置元素，比如敌人、障碍物等，确保关卡的每个细节都按预定的方式出现。这种方法是固定的，关卡一旦设计完成，就不会发生变化。
    </p>
    <p>
     程序化生成的主要优势是可以大大提高关卡的多样性和重玩价值，因为每次玩家体验时，生成的关卡都有可能是不同的，增加了游戏的变化性和挑战性。
    </p>
    <h2>
     <a id="_Unity__744">
     </a>
     你怎么看使用 Unity 作为平台层，并使用你自己的逻辑？
    </h2>
    <p>
     对于使用 Unity 作为平台层，并在其基础上使用自己的逻辑来开发，我并没有特别的看法，因为我从未考虑过这样做。唯一的想法是，我不喜欢 C#，也不愿意在 Unity 中使用 C# 作为逻辑层，因为 Unity 本身就是为了支持 C# 来进行编程。所以，这对我来说是一个自动的“否”。
    </p>
    <p>
     我习惯从零开始编写自己的引擎，所以我不需要考虑使用 Unity 或其他类似工具来开发。我从不去看 Unity 是怎么做某件事的，因为我知道自己会更喜欢使用自己写的代码。因此，我总是选择使用自己的代码进行开发，而不是依赖外部的工具或引擎。
    </p>
    <h2>
     <a id="_game_Hero__749">
     </a>
     你会为 game Hero 制作开发工具吗，比如地图编辑器？
    </h2>
    <p>
     我们没有制作像地图编辑器这样的开发工具，因为游戏中的地图是通过程序生成的。每次生成的地图都是不同的，所以并不需要手工制作的地图编辑器。
    </p>
    <h2>
     <a id="_DLL_Rust__752">
     </a>
     你可以使用 DLL。我曾经用 Rust 做过这个！
    </h2>
    <p>
     我不太明白你所说的“平台层”是什么意思。你提到用 Unity 作为平台层，然后通过编译的 DLL 来驱动它，但是这样的话，如果你在 Windows 上编译了 DLL，如何在其他平台上运行呢？比如，你不能直接把 Windows 上编译的 DLL 加载到 Android 上。因此，我不太理解你所说的“平台层”是什么意思。如果你指的是 DLL，那么它通常只能在 Windows 和有时在 Mac 上使用，但其他平台就不行了。所以我不太明白你在这个情况下所说的“平台层”具体指的是什么。
    </p>
    <h2>
     <a id="_755">
     </a>
     现在粒子的流动方向是从下往上。感觉如果从左到右做是不是也很简单？
    </h2>
    <p>
     粒子的运动方向是由其速度向量决定的。如果你想让粒子朝某个特定方向移动，其实只需要调整这个速度向量即可。速度向量可以指向任何方向，从而控制粒子的运动轨迹。比如，如果想让粒子沿着某个方向喷射，只需要改变速度向量的方向。如果想让粒子的运动带有一些混乱，比如在上下方向上喷射，同时也有一些横向的运动，这也可以通过调整速度向量来实现。
    </p>
    <p>
     总的来说，粒子的运动方向非常灵活，完全可以根据需求调整，只要修改它们的速度向量即可。这是粒子系统中比较直接和简单的一部分。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f544d313639353634383136342f:61727469636c652f64657461696c732f313436323335383834" class_="artid" style="display:none">
 </p>
</div>


