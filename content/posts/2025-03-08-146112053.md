---
layout: post
title: "数据结构链式表"
date: 2025-03-08 11:13:32 +0800
description: "/令s中的传递指针指向原第i个元素的传递传递指针。//非删除起始位置，先找到i-1的位置。else if(p->next == NULL)   //i-1的位置存在，但i位置不存在。//不在起始位置，先找到i-1的位置。list delete(int i, list ptrl)    //删除对象的序号传入。//修改p（第i-1个结点）的传递指针。//修改起始位置指针。if(p == NULL)   //如果i-1位置不存在，那i的位置一定不存在。if(i == 1)   //考虑放在起始位置的情况。"
keywords: "数据结构链式表"
categories: ['未分类']
tags: ['数据结构']
artid: "146112053"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146112053
    alt: "数据结构链式表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146112053
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146112053
cover: https://bing.ee123.net/img/rand?artid=146112053
image: https://bing.ee123.net/img/rand?artid=146112053
img: https://bing.ee123.net/img/rand?artid=146112053
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构链式表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     1.线性表的链式存储实现
     <img alt="" height="195" src="https://i-blog.csdnimg.cn/direct/f64a9cd2cc6b4328b2982005ab6519a0.png" width="1072">
      <img alt="" height="148" src="https://i-blog.csdnimg.cn/direct/8a0f098885464605a627aa6165f7228c.png" width="1059">
       2.如何访问序号为i的元素？
      </img>
     </img>
    </p>
    <p>
     3.如何求线性表的长度？
    </p>
    <p>
     4.插入操作：
    </p>
    <p>
     <img alt="" height="249" src="https://i-blog.csdnimg.cn/direct/51ae64c96d884a91a0f05edfd2088e69.png" width="600"/>
    </p>
    <p>
    </p>
    <p>
     5.删除操作：（删除链表的第i（1&lt;=i&lt;=n）个位置上的结点）
    </p>
    <p>
     （1）先找到链表的第i-1个结点，用p指向；
    </p>
    <p>
     （2）再用指针s指向要被删除的结点（p的下一个节点）
    </p>
    <p>
     （3）然后修改指针，删除s所指节点；
    </p>
    <p>
     （4）释放s所指结点的空间；
    </p>
    <p>
     <img alt="" height="356" src="https://i-blog.csdnimg.cn/direct/63a1a82eef794eb29d3daf85b9e3c9a5.png" width="970"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     #include &lt;stdio.h&gt;
     <br/>
     #include &lt;stdlib.h&gt;
    </p>
    <p>
     typedef struct lnode* list;
     <br/>
     struct lnode
     <br/>
     {
     <!-- -->
     <br/>
     elementtype data;   //输入数据；存于结构体中；
     <br/>
     list next;   //定义一个指针，指向下一个结点；
     <br/>
     };
     <br/>
     struct lnode l;  //定义一个结构体对象
     <br/>
     list ptrl;  //定义一个结构体指针
    </p>
    <p>
     int length(list ptrl)  //求链表长度，传入起始结构体对象的指针
     <br/>
     {
     <!-- -->
     <br/>
     list p = ptrl;    //p来表示起始指针
     <br/>
     int j = 0;   //用j来计数
     <br/>
     while(p)   //循环直到p为空
     <br/>
     {
     <!-- -->
     <br/>
     p = p-&gt;next;  //往后传递
     <br/>
     j++;  //计数增加
     <br/>
     }
     <br/>
     return j;   // 返回计数值，时间性能O(n)。
     <br/>
     }
    </p>
    <p>
     //按序号查找：
     <br/>
     list findkth(int k, list ptrl)   //传入序号与起始指针
     <br/>
     {
     <!-- -->
     <br/>
     list p = ptrl;   //中间量
     <br/>
     int i = 1;
     <br/>
     while(p != NULL &amp;&amp; i&lt;k)
     <br/>
     {
     <!-- -->
     <br/>
     p = p-&gt;next;
     <br/>
     i++;
     <br/>
     }
     <br/>
     if(i == k)
     <br/>
     return p;
     <br/>
     else
     <br/>
     return NULL;
     <br/>
     }
    </p>
    <p>
     //按值查找：
    </p>
    <p>
     list find(elementtype x, list ptrl)
     <br/>
     {
     <!-- -->
     <br/>
     list p = ptrl;
     <br/>
     while(p != NULL &amp;&amp; p-&gt;data != x)
     <br/>
     p = p-&gt;next;
     <br/>
     return p;
     <br/>
     }
    </p>
    <p>
     <br/>
     list insert(elementtype x, int i, list ptrl)
     <br/>
     {
     <!-- -->
     <br/>
     list p,s;
     <br/>
     if(i == 1)   //考虑放在起始位置的情况
     <br/>
     {
     <!-- -->
     <br/>
     s = (list)malloc(sizeof(struct lnode));
     <br/>
     s-&gt;data = x;
     <br/>
     s-&gt;next = ptrl;
     <br/>
     return s;
     <br/>
     }
     <br/>
     p = findkth(i-1, ptrl);   //不在起始位置，先找到i-1的位置
     <br/>
     if(p == NULL)
     <br/>
     {
     <!-- -->
     <br/>
     printf("参数i错")；
     <br/>
     return NULL;
     <br/>
     <br/>
     }
     <br/>
     else
     <br/>
     {
     <!-- -->
     <br/>
     s = (list)malloc(sizeof(struct lnode));
     <br/>
     s-&gt;data = x;
     <br/>
     s-&gt;next = p-&gt;next;      //令s中的传递指针指向原第i个元素的传递传递指针
     <br/>
     p-&gt;next = s;    //修改p（第i-1个结点）的传递指针
     <br/>
     return ptrl;
     <br/>
     }
     <br/>
     <br/>
     }
    </p>
    <p>
     <br/>
     list delete(int i, list ptrl)    //删除对象的序号传入
     <br/>
     {
     <!-- -->
     <br/>
     list p, s;
     <br/>
     if(i == 1)   //删除起始位置的情况
     <br/>
     {
     <!-- -->
     <br/>
     s = ptrl;
     <br/>
     if(ptrl != NULL)
     <br/>
     ptrl = ptrl-&gt;next;   //修改起始位置指针
     <br/>
     else return NULL;
     <br/>
     free(s);
     <br/>
     return ptrl;
     <br/>
     }
     <br/>
     p = findkth(i-1, ptrl);   //非删除起始位置，先找到i-1的位置
     <br/>
     if(p == NULL)   //如果i-1位置不存在，那i的位置一定不存在
     <br/>
     {
     <!-- -->
     <br/>
     printf("第%d个结点不存在",i-1);
     <br/>
     return NULL;
     <br/>
     }
     <br/>
     else if(p-&gt;next == NULL)   //i-1的位置存在，但i位置不存在
     <br/>
     {
     <!-- -->
     <br/>
     printf("第%d个结点不存在", i);
     <br/>
     return NULL;
     <br/>
     }
     <br/>
     else
     <br/>
     {
     <!-- -->
     <br/>
     s = p-&gt;next;
     <br/>
     p-&gt;next = s-&gt;next;
     <br/>
     free(s);
     <br/>
     return ptrl;
     <br/>
     }
     <br/>
     }
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38383837363830352f:61727469636c652f64657461696c732f313436313132303533" class_="artid" style="display:none">
 </p>
</div>


