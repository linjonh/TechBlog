---
layout: post
title: "Python-数据结构-11.二叉搜索树"
date: 2025-03-09 11:54:07 +0800
description: "二叉搜索树(又称为二叉排序树，二叉查找树)，它满足如下四点性质:1)空树是二叉搜索树;2) 若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值;3) 若它的右子树不为空，则右子树上所有结点的值均大于它根结点的值;4) 它的左右子树均为二叉搜索树;如图所示，对于任何一颗子树而言，它的根结点的值一定大于左子树所有结点的值，且一定小于右子树所有结点的值纵观二叉搜索树的查找、插入 和 删除。完全取决于二叉搜索树的形状，如果是完全二叉树。"
keywords: "【Python 数据结构 11.二叉搜索树】"
categories: ['Python']
tags: ['算法', '数据结构']
artid: "146123343"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123343
    alt: "Python-数据结构-11.二叉搜索树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123343
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123343
cover: https://bing.ee123.net/img/rand?artid=146123343
image: https://bing.ee123.net/img/rand?artid=146123343
img: https://bing.ee123.net/img/rand?artid=146123343
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Python 数据结构 11.二叉搜索树】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      <span style="color:#956fe7">
       <strong>
        人永远在原谅自己，以为这样就可以有重来的余地
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#956fe7">
       <strong>
        —— 25.3.9
       </strong>
      </span>
     </p>
    </blockquote>
    <h2>
     一、二叉搜索树的基本概念
    </h2>
    <h3>
     1.二叉搜索树的概念
    </h3>
    <h4>
     Ⅰ、定义
    </h4>
    <p>
     二叉搜索树(又称为二叉排序树，二叉查找树)，它满足如下四点性质:
    </p>
    <p>
     1)
     <span style="color:#fe2c24">
      空树
     </span>
     是二叉搜索树;
    </p>
    <p>
     2) 若它的左子树不为空，则
     <span style="color:#fe2c24">
      左
     </span>
     子树上所有结点的值
     <span style="color:#38d8f0">
      均小于
     </span>
     它
     <span style="color:#fe2c24">
      根
     </span>
     结点的值;
    </p>
    <p>
     3) 若它的右子树不为空，则
     <span style="color:#fe2c24">
      右
     </span>
     子树上所有结点的值
     <span style="color:#38d8f0">
      均大于
     </span>
     它
     <span style="color:#fe2c24">
      根
     </span>
     结点的值;
    </p>
    <p>
     4) 它的
     <span style="color:#38d8f0">
      左右子树
     </span>
     均为
     <span style="color:#fe2c24">
      二叉搜索树;
     </span>
    </p>
    <p>
     <img alt="" height="274" src="https://i-blog.csdnimg.cn/direct/4213da96fffe444abe671d5e12618997.png" width="382"/>
    </p>
    <p>
     如图所示，对于任何一颗子树而言，它的
     <span style="color:#fe2c24">
      根
     </span>
     结点的值一定
     <span style="color:#38d8f0">
      大于
     </span>
     <span style="color:#fe2c24">
      左
     </span>
     子树所有结点的值，且一定
     <span style="color:#38d8f0">
      小于
     </span>
     <span style="color:#fe2c24">
      右
     </span>
     子树所有结点的值
    </p>
    <hr/>
    <h4>
     Ⅱ、用途
    </h4>
    <p>
     从二叉搜索树的定义可知，它的前提是
     <span style="color:#fe2c24">
      二叉树
     </span>
     ，并且采用了递归的方式进行定义，它的结点间
     <span style="color:null">
      满足一个
     </span>
     <span style="color:#fe2c24">
      偏序关系：左子树根
     </span>
     结点的值一定比
     <span style="color:#38d8f0">
      父结点小
     </span>
     ，
     <span style="color:#fe2c24">
      右子树根
     </span>
     结点的值一定比
     <span style="color:#38d8f0">
      父结点大
     </span>
     。
    </p>
    <p>
     正如它的名字所说，构造这样一棵树的目的是为了
     <span style="color:#38d8f0">
      提高搜索的速度
     </span>
     ，如果对二叉搜索树进行
     <strong>
      中序
     </strong>
     遍历，我们可以发现，得到的序列是一个
     <strong>
      <span style="color:#38d8f0">
       递增
      </span>
     </strong>
     序列。
    </p>
    <p>
     <img alt="" height="283" src="https://i-blog.csdnimg.cn/direct/38a2be6db312482692240aa484a79539.png" width="391"/>
    </p>
    <hr/>
    <h3>
     2.二叉搜索树的链式存储
    </h3>
    <p>
     我们一般用
     <span style="color:#fe2c24">
      孩子表示法
     </span>
     来定义一棵二叉搜索树的结点。
    </p>
    <p>
     (1) 二叉搜索树需要有一个结点值，也就是数据域，
     <span style="color:#fe2c24">
      <strong>
       注意：
      </strong>
     </span>
     这里的类型其实可以是任意类型，只要这种类型支持
     <span style="color:#38d8f0">
      关系运算符
     </span>
     的比较即可
    </p>
    <p>
     (2) 二叉搜索树结点的
     <span style="color:#4da8ee">
      左儿子结点
     </span>
     的指针，没有左儿子结点时，置为空;
    </p>
    <p>
     (3) 二叉搜索树结点的
     <span style="color:#4da8ee">
      右儿子结点
     </span>
     的指针，没有右儿子结点时，置为空;
    </p>
    <hr/>
    <h3>
     3.二叉搜索树的结点查找
    </h3>
    <h4>
     Ⅰ、节点查找的概念
    </h4>
    <p>
     二叉搜索树的查找指的是：在树上查找
     <span style="color:#fe2c24">
      某个数是否存在
     </span>
     ，存在返回 true ，不存在返回 false
    </p>
    <p>
     如图所示，代表的是从一个二叉搜索树中查找出一个值为 3 的结点。一开始，3 比根节点 5 小，于是递归访问左子树；并且比子树的根节点 4 小，于是继续递归访问左子树；这时候比根节点 2 大，于是递归访问右子树，正好找到值为 3 的查找，回溯结束查找
    </p>
    <p>
     <img alt="" height="288" src="https://i-blog.csdnimg.cn/direct/3ae480b7affd4454aa5da39cfa6b1d5e.png" width="417"/>
    </p>
    <hr/>
    <h4>
     Ⅱ、结点查找的步骤
    </h4>
    <p>
     对于要查找的数 val，从根结点出发，总共四种情况依次判断：
    </p>
    <p>
     <strong>
      第1步：
     </strong>
     若为空树，直接返回 false;
    </p>
    <p>
     <strong>
      第2步：
     </strong>
     val 的值
     <span style="color:#38d8f0">
      小于
     </span>
     树根结点的值，说明 val 对应的结点不在根结点，也不在右子树上，则递归返回左子树的 查找 结果;
    </p>
    <p>
     <strong>
      第3步：
     </strong>
     val 的值
     <span style="color:#38d8f0">
      大于
     </span>
     树根结点的值，说明 val 对应的结点不在根结点，也不在左子树上，则递归返回右子树的 查找 结果;
    </p>
    <p>
     <strong>
      第4步：
     </strong>
     <span style="color:#38d8f0">
      直接
     </span>
     返回 true(无须等于判定，因为不小于、不大于必然是等于);
    </p>
    <hr/>
    <h3>
     4.二叉搜索树的结点插入
    </h3>
    <h4>
     Ⅰ、结点插入的概念
    </h4>
    <p>
     二叉搜索树的插入指的是将给定的值生成结点后，插入到树上的某个位置，并且
     <span style="color:#fe2c24">
      保持
     </span>
     这棵树还是二叉搜索树。
    </p>
    <p>
     如图所示，代表将一个值为 3 的结点插入到一个二叉搜索树中。一开始，3 比 根节点 5 小，于是递归插入左子树；还是比子树的根节点 4 小，于是继续递归插入左子树；这时候比根节点 2 大，于是递归插入右子树，右子树为空，则直接生成一个值为 3 的结点，回溯结束插入
    </p>
    <p>
     <img alt="" height="318" src="https://i-blog.csdnimg.cn/direct/3eb863a5f982451ca557faf0613c37ef.png" width="433"/>
    </p>
    <hr/>
    <h4>
     Ⅱ、结点插入的步骤
    </h4>
    <p>
     对于要插入的数 val ，从根结点出发，总共四种情况依次判断：
    </p>
    <p>
     <strong>
      第1步：
     </strong>
     若为空树，则创建一个值为 val 的结点并且返回；
    </p>
    <p>
     <strong>
      第2步：
     </strong>
     val 的值
     <span style="color:#38d8f0">
      小于
     </span>
     树根结点的值，那么插入位置一定在
     <span style="color:#fe2c24">
      左子树
     </span>
     ，
     <span style="color:#38d8f0">
      递归
     </span>
     执行插入左子树的过程，并且返回插入结果作为新的左子树;
    </p>
    <p>
     <strong>
      第3步：
     </strong>
     val 的值
     <span style="color:#38d8f0">
      大于
     </span>
     树根结点的值，那么插入位置一定在
     <span style="color:#fe2c24">
      右子树
     </span>
     ，
     <span style="color:#38d8f0">
      递归
     </span>
     执行插入右子树的过程，并且返回插入结果作为新的右子树;
    </p>
    <p>
     <strong>
      第4步：
     </strong>
     直接返回当前树的根结点;
    </p>
    <hr/>
    <h3>
     5.二叉搜索树的结点删除
    </h3>
    <h4>
     Ⅰ、结点删除的概念
    </h4>
    <p>
     二叉搜索树的删除指的是在树上删除
     <span style="color:#fe2c24">
      给定值
     </span>
     的结点
    </p>
    <p>
     如图所示，从这棵树删除根节点 5 的过程。首先，由于它有左右儿子结点，所以这个过程，根结点并不是真正地删除。而是从
     <span style="color:#fe2c24">
      右子树中找到最小的结点
     </span>
     6，替换根结点，并且从根节点为 7 的子树中删除 6 的过程，由于 6 没有子节点，所以这个过程结束了
    </p>
    <p>
     <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/4c4e5e2190b7489b927efb1e2f4d0d32.png" width="308">
      <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/1de099230ec94805956cecee10dbde8b.png" width="348"/>
     </img>
    </p>
    <hr/>
    <h4>
     Ⅱ、结点删除的步骤
    </h4>
    <p>
     <span style="color:#fe2c24">
      删除
     </span>
     值为 val 的结点的过程，从
     <span style="color:#fe2c24">
      根结点
     </span>
     出发，总共七种情况依次判断：
    </p>
    <p>
     <strong>
      第1步：
     </strong>
     如果当前结点为
     <span style="color:#38d8f0">
      空
     </span>
     ，则直接返回
     <span style="color:#fe2c24">
      空树
     </span>
    </p>
    <p>
     <strong>
      第2步：
     </strong>
     如果要删除的值
     <span style="color:#38d8f0">
      小于
     </span>
     当前结点的值，则
     <span style="color:#fe2c24">
      递归调用左子树
     </span>
     进行结点的删除
    </p>
    <p>
     <strong>
      第3步：
     </strong>
     如果要删除的值
     <span style="color:#38d8f0">
      大于
     </span>
     当前结点的值，则递
     <span style="color:#fe2c24">
      归调用右子树
     </span>
     进行结点的删除
    </p>
    <p>
     <strong>
      第4步：
     </strong>
     如果当前结点是一个
     <span style="color:#38d8f0">
      叶子结点
     </span>
     ，即它没有左子树和右子树，那么删除该结点，并且
     <span style="color:#fe2c24">
      返
      <br/>
      回空树
     </span>
    </p>
    <p>
     <strong>
      第5步：
     </strong>
     如果当前结点
     <span style="color:#38d8f0">
      只有右子树
     </span>
     而没有左子树，那么删除当前结点并
     <span style="color:#fe2c24">
      将右子树返回
     </span>
    </p>
    <p>
     <strong>
      第6步：
     </strong>
     如果当前结点
     <span style="color:#38d8f0">
      只有左子树
     </span>
     而没有右子树，那么删除当前结点并
     <span style="color:#fe2c24">
      将左子树返回
     </span>
    </p>
    <p>
     <strong>
      第7步：
     </strong>
     如果当前结点
     <span style="color:#38d8f0">
      既有左子树又有右子树
     </span>
     ，那么找到当前结点
     <span style="color:#fe2c24">
      右子树中的最小值结点
     </span>
     (即最左边的结点)，将当前结点的值
     <span style="color:#fe2c24">
      替换
     </span>
     为这个最小值结点的值，然后递归地
     <span style="color:#fe2c24">
      删除右子树中该最小值结点。
     </span>
    </p>
    <hr/>
    <h3>
     6.二叉搜索树的总结
    </h3>
    <p>
     纵观二叉搜索树的查找、插入 和 删除。完全取决于
     <span style="color:#fe2c24">
      二叉搜索树的形状
     </span>
     ，如果是
     <span style="color:#ff9900">
      完全二叉树
     </span>
     或者
     <span style="color:#ff9900">
      接近完全二叉树
     </span>
     ，则这三个过程都是
     <span style="color:#ff9900">
      (logn)
     </span>
     的，如果是
     <span style="color:#38d8f0">
      斜树
     </span>
     ，则三个过程近似操作线性表为
     <span style="color:#38d8f0">
      O(n)
     </span>
    </p>
    <hr/>
    <h2>
     二、Python中的二叉搜索树
    </h2>
    <h3>
     1.定义二叉搜索树结点类
    </h3>
    <p>
     <span style="color:#fe2c24">
      <strong>
       val：
      </strong>
     </span>
     存储树结点的索引
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       left：
      </strong>
     </span>
     存储树结点的左孩子
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       right：
      </strong>
     </span>
     存储树结点的右孩子
    </p>
    <pre><code class="language-python">class TreeNode:
    def __init__(self, val=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>
    <hr/>
    <h3>
     2.定义二叉搜索树类
    </h3>
    <h4>
     Ⅰ、树初始化
    </h4>
    <p>
     只需要初始化一个根结点为空值 None
    </p>
    <pre><code class="language-python">class BinarySearchTree:
    def __init__(self):
        self.root = None
</code></pre>
    <hr/>
    <h4>
     Ⅱ、 添加结点
    </h4>
    <p>
     传入根结点和要添加结点的val，比较二者大小关系，递归插入
    </p>
    <pre><code class="language-python">    # 增
    def insertNode(self, node, val):
        # 递归终止条件
        if node is None:
            return TreeNode(val)
        if val &lt; node.val:
            node.left = self.insertNode(node.left, val)
        elif val &gt; node.val:
            node.right = self.insertNode(node.right, val)
        return node

    def insert(self, val):
        self.root = self.insertNode(self.root, val)</code></pre>
    <hr/>
    <h4>
     Ⅲ、删除结点
    </h4>
    <p>
     递归删除，递归过程如下图：
    </p>
    <p>
     <img alt="" height="1080" src="https://i-blog.csdnimg.cn/direct/2feacc3342604954be94814d7380b69b.jpeg" width="1760"/>
    </p>
    <pre><code class="language-python">    # 删
    def removeNode(self, node, val):
        if node is None:
            return None
        if val &lt; node.val:
            node.left = self.removeNode(node.left, val)
        elif val &gt; node.val:
            node.right = self.removeNode(node.right, val)
        else:
            if node.left is None and node.right is None:
                return None
            elif node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                replacement = node.right
                while replacement.left:
                    replacement = replacement.left
                node.val = replacement.val
                node.right = self.removeNode(node.right, replacement.val)
        return node

    def remove(self, val):
        self.root = self.removeNode(self.root, val)</code></pre>
    <hr/>
    <h4>
     Ⅳ、查找结点
    </h4>
    <p>
     判断传入结点的val值与要查找的val值大小关系，已知二叉搜索树结点间的相互关系，遍历推断所查找结点的位置
    </p>
    <pre><code class="language-python">    # 查
    def searchNode(self, node, val):
        if node is None:
            return False
        if val &lt; node.val:
            return self.searchNode(node.left, val)
        elif val &gt; node.val:
            return self.searchNode(node.right, val)
        return True

    def search(self, val):
        return self.searchNode(self.root, val)</code></pre>
    <hr/>
    <h4>
     Ⅴ、中序遍历
    </h4>
    <p>
     已知中序遍历的顺序是：左 - 根 - 右，而结合二叉搜索树结点间的相互关系，进行中序遍历的结果恰好应该是一个递增序列
    </p>
    <pre><code class="language-python">    # 中序遍历
    def inOrder(self, node):
        if node is None:
            return
        self.inOrder(node.left)
        print(node.val, end=",")
        self.inOrder(node.right)

    def inOrderTraversal(self):
        self.inOrder(self.root)
        print("")</code></pre>
    <hr/>
    <h4>
     Ⅵ、代码测试
    </h4>
    <p>
     <span style="color:#fe2c24">
      添加结点后
     </span>
     的二叉搜索树：
     <img alt="" height="149" src="https://i-blog.csdnimg.cn/direct/ea7f97f2c9ac4fdca356723b4c537c82.jpeg" width="167"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      删除结点 5 后
     </span>
     的二叉搜索树：
     <img alt="" height="139" src="https://i-blog.csdnimg.cn/direct/ad7d843dca7846dd9e03c8eda0a8d557.jpeg" width="168"/>
    </p>
    <pre><code class="language-python">def Test():
    bst = BinarySearchTree()

    bst.insert(5)
    bst.insert(3)
    bst.insert(7)
    bst.insert(2)
    bst.insert(4)
    bst.insert(6)
    bst.insert(8)
    bst.inOrderTraversal()
    bst.remove(5)
    bst.inOrderTraversal()
    print(bst.search(4))
    print(bst.search(9))

Test()
</code></pre>
    <p>
     <img alt="" height="141" src="https://i-blog.csdnimg.cn/direct/93dc9fe1c25b47208f8f154256665538.png" width="450"/>
    </p>
    <hr/>
    <h2>
     三、实战
    </h2>
    <h3>
     1.
     <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" rel="nofollow" title="108. 将有序数组转换为二叉搜索树">
      108. 将有序数组转换为二叉搜索树
     </a>
    </h3>
    <blockquote>
     <p>
      给你一个整数数组
      <code>
       nums
      </code>
      ，其中元素已经按
      <strong>
       升序
      </strong>
      排列，请你将其转换为一棵 平衡 二叉搜索树。
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/d000a876410a14f02398da2f66973a6d.jpeg" width="302"/>
     </p>
     <pre><strong>输入：</strong>nums = [-10,-3,0,5,9]
<strong>输出：</strong>[0,-3,9,-10,null,5]
<strong>解释：</strong>[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</pre>
     <p class="img-center">
      <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/5064985cd6af7a7a054d6d6887b8c6ac.jpeg" width="302"/>
     </p>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="142" src="https://i-blog.csdnimg.cn/img_convert/93a3144fa9796a5df5f916e9d57f61c4.jpeg" width="342"/>
     </p>
     <pre><strong>输入：</strong>nums = [1,3]
<strong>输出：</strong>[3,1]
<strong>解释：</strong>[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       <code>
        1 &lt;= nums.length &lt;= 104
       </code>
      </li>
      <li>
       <code>
        -104 &lt;= nums[i] &lt;= 104
       </code>
      </li>
      <li>
       <code>
        nums
       </code>
       按
       <strong>
        严格递增
       </strong>
       顺序排列
      </li>
     </ul>
    </blockquote>
    <h4>
     方法一、递归
    </h4>
    <h5>
     <span style="color:#38d8f0">
      思路与算法
     </span>
    </h5>
    <p>
     ​
     <strong>
      递归终止条件
     </strong>
     ：如果左边界
     <code>
      l
     </code>
     大于右边界
     <code>
      r
     </code>
     ，说明当前子数组为空，返回
     <code>
      None
     </code>
     。
    </p>
    <p>
     ​
     <strong>
      选择根节点
     </strong>
     ：计算当前子数组的中间位置
     <code>
      mid = (l + r) // 2
     </code>
     。以
     <code>
      nums[mid]
     </code>
     作为根节点的值，创建一个
     <code>
      TreeNode
     </code>
     。
    </p>
    <p>
     ​
     <strong>
      递归构建左子树和右子树
     </strong>
     ：左子树的范围是
     <code>
      [l, mid - 1]
     </code>
     ，递归调用
     <code>
      inOrder
     </code>
     构建左子树。右子树的范围是
     <code>
      [mid + 1, r]
     </code>
     ，递归调用
     <code>
      inOrder
     </code>
     构建右子树。
    </p>
    <p>
     <strong>
      返回根节点
     </strong>
     ：返回当前构建的根节点。
    </p>
    <pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inOrder(self, nums, l, r):
        if l &gt; r:
            return None
        mid = (l + r) // 2
        root = TreeNode(nums[mid])
        root.left = self.inOrder(nums, l, mid - 1)
        root.right = self.inOrder(nums, mid + 1, r)
        return root

    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:
        root = nums[0]
        return self.inOrder(nums, 0, len(nums) - 1)</code></pre>
    <p>
     <img alt="" height="954" src="https://i-blog.csdnimg.cn/direct/c130eb69cd0f43069a6600eb1cd6d020.png" width="1912"/>
    </p>
    <hr/>
    <h3>
     2.
     <a href="https://leetcode.cn/problems/validate-binary-search-tree/" rel="nofollow" title="98. 验证二叉搜索树">
      98. 验证二叉搜索树
     </a>
    </h3>
    <blockquote>
     <p>
      给你一个二叉树的根节点
      <code>
       root
      </code>
      ，判断其是否是一个有效的二叉搜索树。
     </p>
     <p>
      <strong>
       有效
      </strong>
      二叉搜索树定义如下：
     </p>
     <ul>
      <li>
       节点的左子树只包含
       <strong>
        小于
       </strong>
       当前节点的数。
      </li>
      <li>
       节点的右子树只包含
       <strong>
        大于
       </strong>
       当前节点的数。
      </li>
      <li>
       所有左子树和右子树自身必须也是二叉搜索树。
      </li>
     </ul>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="182" src="https://i-blog.csdnimg.cn/img_convert/ad996833d9bd600b909fe7304a535782.jpeg" width="302"/>
     </p>
     <pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>true
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="292" src="https://i-blog.csdnimg.cn/img_convert/a4c0f5212298a2f8f22abd86028ceace.jpeg" width="422"/>
     </p>
     <pre><strong>输入：</strong>root = [5,1,4,null,null,3,6]
<strong>输出：</strong>false
<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中节点数目范围在
       <code>
        [1, 104]
       </code>
       内
      </li>
      <li>
       <code>
        -231 &lt;= Node.val &lt;= 231 - 1
       </code>
      </li>
     </ul>
    </blockquote>
    <h4>
     方法一 根据二叉搜索树中序遍历的性质判断
    </h4>
    <h5>
     <span style="color:#38d8f0">
      思路与算法
     </span>
    </h5>
    <p>
     ​
     <strong>
      中序遍历
     </strong>
     ：使用递归方法
     <code>
      inorder
     </code>
     对二叉树进行中序遍历，将节点值按顺序存储在
     <code>
      self.list
     </code>
     中。
    </p>
    <p>
     <span style="color:#fe2c24">
      中序遍历的顺序是：左子树 -&gt; 根节点 -&gt; 右子树。
     </span>
     ​
    </p>
    <p>
     <strong>
      检查递增性
     </strong>
     ：遍历
     <code>
      self.list
     </code>
     ，检查每个元素是否大于前一个元素。如果发现某个元素小于或等于前一个元素，则返回
     <code>
      False
     </code>
     ，说明不是有效的二叉搜索树。​
    </p>
    <p>
     <strong>
      返回结果
     </strong>
     ：如果列表严格递增，返回
     <code>
      True
     </code>
     ，说明是有效的二叉搜索树。
    </p>
    <pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorder(self, root):
        if root:
            self.inorder(root.left)
            self.list.append(root.val)
            self.inorder(root.right)

    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:
        self.list = []
        self.inorder(root)
        for i in range(1, len(self.list)):
            if self.list[i] &lt;= self.list[i - 1]:
                return False
        return True</code></pre>
    <p>
     <img alt="" height="954" src="https://i-blog.csdnimg.cn/direct/ef51c8f1433f4210a2e10f06cd025801.png" width="1912"/>
    </p>
    <hr/>
    <h3>
     3.
     <a href="https://leetcode.cn/problems/legal-binary-search-tree-lcci/" rel="nofollow" title="面试题 04.05. 合法二叉搜索树">
      面试题 04.05. 合法二叉搜索树
     </a>
    </h3>
    <blockquote>
     <p>
      实现一个函数，检查一棵二叉树是否为二叉搜索树。
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <pre><strong>输入：</strong>
    2
   / \
  1   3
<strong>输出：</strong>true
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>
    5
   / \
  1   4
     / \
    3   6
<strong>输出：</strong>false
<strong>解释：</strong>输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。</pre>
    </blockquote>
    <h4>
     方法一 递归
    </h4>
    <h5>
     <span style="color:#38d8f0">
      思路与算法
     </span>
    </h5>
    <p>
     ​
     <strong>
      递归终止条件
     </strong>
     ：如果当前节点为空，返回
     <code>
      True
     </code>
     ，因为空树是有效的二叉搜索树。
    </p>
    <p>
     <strong>
      检查当前节点
     </strong>
     ：如果当前节点的值不在
     <code>
      (min, max)
     </code>
     范围内，返回
     <code>
      False
     </code>
     。​
    </p>
    <p>
     <strong>
      递归检查左子树和右子树
     </strong>
     ：左子树的范围是
     <code>
      (min, root.val)
     </code>
     ，因为左子树的所有节点值必须小于当前节点的值。右子树的范围是
     <code>
      (root.val, max)
     </code>
     ，因为右子树的所有节点值必须大于当前节点的值。
    </p>
    <p>
     ​
     <strong>
      返回结果
     </strong>
     ：如果左子树和右子树都满足条件，返回
     <code>
      True
     </code>
     ，否则返回
     <code>
      False
     </code>
     。
    </p>
    <pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def checkTree(self, root, min, max):
        if not root:
            return True
        if root.val &gt;= max or root.val &lt;= min:
            return False
        return self.checkTree(root.left, min, root.val) and self.checkTree(root.right, root.val, max)

    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:
        return self.checkTree(root, -inf, inf)</code></pre>
    <p>
     <img alt="" height="954" src="https://i-blog.csdnimg.cn/direct/730dee4cb99d402a8c55121065c9bb9e.png" width="1912"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333938333730372f:61727469636c652f64657461696c732f313436313233333433" class_="artid" style="display:none">
 </p>
</div>


