---
layout: post
title: "Django-ORM自定义排序的实用示例"
date: 2025-03-11 12:31:55 +0800
description: "有时候，内置的排序功能可能无法满足我们的需求。例如，假设我们希望根据某个计算得出的值进行排序，或者根据某个复杂的条件来排序。这时候，我们可以使用Django的annotate()和F()表达式。假设我们有一个Product模型，里面有price和discount字段。我们想要根据实际价格（即价格减去折扣）进行排序。可以使用annotate()在这个例子中，是一个动态生成的字段，表示折扣后的价格。通过这种方式，我们就可以根据计算出的值进行排序了。"
keywords: "Django ORM自定义排序的实用示例"
categories: ['技术分享']
tags: ['数据库', 'Sqlite', 'Django']
artid: "146175541"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146175541
    alt: "Django-ORM自定义排序的实用示例"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146175541
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146175541
cover: https://bing.ee123.net/img/rand?artid=146175541
image: https://bing.ee123.net/img/rand?artid=146175541
img: https://bing.ee123.net/img/rand?artid=146175541
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Django ORM自定义排序的实用示例
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在使用Django进行开发时，ORM（对象关系映射）是一个非常强大的工具。它让我们可以用Python代码直接操作数据库，而不需要写SQL语句。当我们需要对数据进行排序时，Django ORM同样提供了丰富的功能。今天，我们就来聊聊如何在Django中实现自定义排序，帮助你更好地管理和展示数据！
    </p>
    <h4>
     <a id="Django_ORM_4">
     </a>
     理解Django ORM的排序功能
    </h4>
    <p>
     Django ORM提供了
     <code>
      order_by()
     </code>
     方法，允许我们对查询集进行排序。这个方法可以接受一个或多个字段名作为参数，字段名可以是模型中定义的任何属性。需要注意的是，我们可以在字段名前加上负号（
     <code>
      -
     </code>
     ），表示降序排序。
    </p>
    <p>
     例如，假设我们有一个
     <code>
      Book
     </code>
     模型，里面有
     <code>
      title
     </code>
     和
     <code>
      published_date
     </code>
     这两个字段。想要按出版日期升序排列书籍，只需要这样：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'published_date'</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     如果想按出版日期降序排列，代码就变成了：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'-published_date'</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     看起来很简单吧？但如果需要更复杂的排序，比如根据多个字段排序，那就需要一点技巧了。
    </p>
    <h4>
     <a id="_22">
     </a>
     多字段排序的实践
    </h4>
    <p>
     假设我们想要按
     <code>
      published_date
     </code>
     升序排序，同时如果出版日期相同，则按
     <code>
      title
     </code>
     字母顺序排序。这可以通过将多个字段传递给
     <code>
      order_by()
     </code>
     实现：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'published_date'</span><span class="token punctuation">,</span> <span class="token string">'title'</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     这样，系统就会先按出版日期排序，再按书名排序。还记得我们提到的负号吗？如果我们想要出版日期降序，但书名升序，可以这样写：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'-published_date'</span><span class="token punctuation">,</span> <span class="token string">'title'</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     灵活运用这些排序规则能够让数据展示更加清晰，用户体验也会更好！
    </p>
    <h4>
     <a id="_38">
     </a>
     自定义排序逻辑的引入
    </h4>
    <p>
     有时候，内置的排序功能可能无法满足我们的需求。例如，假设我们希望根据某个计算得出的值进行排序，或者根据某个复杂的条件来排序。这时候，我们可以使用Django的
     <code>
      annotate()
     </code>
     和
     <code>
      F()
     </code>
     表达式。
    </p>
    <p>
     假设我们有一个
     <code>
      Product
     </code>
     模型，里面有
     <code>
      price
     </code>
     和
     <code>
      discount
     </code>
     字段。我们想要根据实际价格（即价格减去折扣）进行排序。可以使用
     <code>
      annotate()
     </code>
     来计算出一个新的字段，然后再进行排序：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db<span class="token punctuation">.</span>models <span class="token keyword">import</span> F

products <span class="token operator">=</span> Product<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span>final_price<span class="token operator">=</span>F<span class="token punctuation">(</span><span class="token string">'price'</span><span class="token punctuation">)</span> <span class="token operator">-</span> F<span class="token punctuation">(</span><span class="token string">'discount'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'final_price'</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     在这个例子中，
     <code>
      final_price
     </code>
     是一个动态生成的字段，表示折扣后的价格。通过这种方式，我们就可以根据计算出的值进行排序了。
    </p>
    <h4>
     <a id="Q_52">
     </a>
     结合Q对象实现复杂条件排序
    </h4>
    <p>
     在某些情况下，排序的条件可能会更加复杂。这时可以利用
     <code>
      Q
     </code>
     对象来构建复杂的查询条件。比如，我们想要根据某个条件来选择排序的字段，可以这样做：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db<span class="token punctuation">.</span>models <span class="token keyword">import</span> Q

products <span class="token operator">=</span> Product<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span>
    final_price<span class="token operator">=</span>F<span class="token punctuation">(</span><span class="token string">'price'</span><span class="token punctuation">)</span> <span class="token operator">-</span> F<span class="token punctuation">(</span><span class="token string">'discount'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span>
    Q<span class="token punctuation">(</span>some_condition<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token string">'final_price'</span> <span class="token keyword">or</span> <span class="token string">'-final_price'</span>
<span class="token punctuation">)</span>
</code></pre>
    <p>
     在这个例子中，
     <code>
      some_condition
     </code>
     可以是任何布尔条件，依赖于它的值，我们可以选择升序或降序。这个方法的灵活性很高，能够适应各种复杂的排序需求。
    </p>
    <h4>
     <a id="Raw_SQL_68">
     </a>
     使用Raw SQL进行自定义排序
    </h4>
    <p>
     有时候，ORM的功能可能仍然不够强大，特别是在需要实现非常特定的排序逻辑时。这种情况下，可以考虑使用原生SQL查询。Django提供了
     <code>
      raw()
     </code>
     方法，可以让你直接执行SQL语句。
    </p>
    <p>
     例如，假设我们需要根据某种复杂算法计算出的值进行排序，可以这样做：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> connection

query <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
    SELECT * FROM app_product
    ORDER BY &lt;your_custom_logic&gt;
"""</span>
products <span class="token operator">=</span> Product<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>raw<span class="token punctuation">(</span>query<span class="token punctuation">)</span>
</code></pre>
    <p>
     不过，使用原生SQL时要小心，确保你的查询不会引发SQL注入等安全问题。
    </p>
    <h4>
     <a id="_86">
     </a>
     实际应用中的排序示例
    </h4>
    <p>
     想象一下，你正在开发一个图书管理系统，用户可以按不同标准排序书籍。你可以让用户选择排序方式，比如按出版日期、按书名、甚至按作者名字。通过结合上述的
     <code>
      order_by()
     </code>
     、
     <code>
      annotate()
     </code>
     和
     <code>
      Q
     </code>
     对象，能够实现更多样化的排序功能。
    </p>
    <p>
     例如，用户选择按作者升序、然后按出版日期降序排序，你可以这样实现：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">,</span> <span class="token string">'-published_date'</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     这种灵活的排序功能不仅提升了用户体验，还能帮助用户更快速地找到他们感兴趣的书籍。
    </p>
    <h4>
     <a id="_98">
     </a>
     小结
    </h4>
    <p>
     Django的ORM提供了非常强大的排序功能，能够满足大多数需求。从简单的字段排序到复杂的自定义排序逻辑，使用
     <code>
      order_by()
     </code>
     、
     <code>
      annotate()
     </code>
     、
     <code>
      F()
     </code>
     和
     <code>
      Q
     </code>
     对象，可以轻松实现各种排序需求。即便是比较复杂的排序场景，借助原生SQL也能找到解决方案。
    </p>
    <p>
     通过本文的讲解，希望你对Django ORM的自定义排序有了更深的理解和应用能力！在开发过程中，灵活运用这些技巧，将大大提升你的开发效率和用户体验，快去试试吧！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32343733343331312f:61727469636c652f64657461696c732f313436313735353431" class_="artid" style="display:none">
 </p>
</div>


