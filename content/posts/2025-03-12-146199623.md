---
layout: post
title: "c语言闯算法-常用技巧"
date: 2025-03-12 20:51:52 +0800
description: "【代码】c语言闯算法--常用技巧。"
keywords: "c语言闯算法--常用技巧"
categories: ['算法', 'C']
tags: ['算法', '数据结构', 'C']
artid: "146199623"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146199623
    alt: "c语言闯算法-常用技巧"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146199623
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146199623
cover: https://bing.ee123.net/img/rand?artid=146199623
image: https://bing.ee123.net/img/rand?artid=146199623
img: https://bing.ee123.net/img/rand?artid=146199623
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     c语言闯算法--常用技巧
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     双指针
    </h2>
    <blockquote>
     <p>
      类别：
     </p>
     <ul>
      <li>
       同向快慢指针
       <ul>
        <li>
         异常情况，慢指针才动
        </li>
       </ul>
      </li>
      <li>
       双向指针
       <ul>
        <li>
         视情况，左右指针动
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h3>
     <a class="link-info" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" title="最长无重复子串">
      最长无重复子串
     </a>
    </h3>
    <pre><code class="language-objectivec">int max(int a, int b){
    if(a &lt; b){
        return b;
    }else{
        return a;
    }
}
int lengthOfLongestSubstring(char* s) {
    int count[300];
    for(int i = 0; i &lt; 300; i++){
        count[i] = 0;
    }

    int l = 0;
    // printf("%d", strlen(s));

    int res = 0;
    int len = strlen(s);
    for(int i = 0; i &lt; len; i++){
        count[s[i] - ' ']++;
        while(count[s[i] - ' '] &gt; 1){
            count[s[l] - ' ']--;
            l++;
            // printf("%d---\n", l);
        }
        // printf("%d\n", i - l + 1);

        res = max(res, i - l + 1);
    }

    return res;
}</code></pre>
    <h3>
     <a class="link-info" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" title="字符串字母异位词">
      字符串字母异位词
     </a>
    </h3>
    <pre><code class="language-objectivec">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findAnagrams(char* s, char* p, int* returnSize) {
    //有返回，先定义
    int lenS = strlen(s);
    int* res = malloc(lenS * sizeof(int));
    *returnSize = 0;

    //字母异位词就是：找词频一样的
    int cntP[26];
    int cntS[26];
    
    for(int i = 0; i &lt; 26; i++){
        cntP[i] = 0;
        cntS[i] = 0;
    }
    //先统计p中的词频
    int lenP = strlen(p);
    for(int i = 0; i &lt; lenP; i++){
        cntP[p[i] - 'a']++;
    }
    for(int i = 0; i &lt; 26; i++){
        printf("%d ",cntP[i]);
    }

    //滑动窗口统计s中的
    int l = 0;
    for(int r = 0; r &lt; lenS; r++){
        cntS[s[r] - 'a']++;

        if(r - l + 1 == lenP){
            //现在窗口大小一致
            bool flag = true;
            for(int i = 0; i &lt; 26; i++){
                if(cntP[i] != cntS[i]) flag = false;
            }
            if(flag){
                res[(*returnSize)++] = l;
            }
        }

        // cntS[s[l] - 'a']--;
        //只有窗口大小超过才需要减掉左边
        if(r - l + 1 &gt;= lenP){
            cntS[s[l] - 'a']--;
            l++;
        }
    }

    return res;


}</code></pre>
    <h3>
     <a class="link-info" href="https://www.acwing.com/problem/content/801/" rel="nofollow" title="最长不重复子序列">
      最长不重复子序列
     </a>
    </h3>
    <pre><code class="language-objectivec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define N 100010

int cnt[N];//模拟哈希表，记录词频

int max(int a, int b){
    if(a &gt; b){
        return a;
    }else{
        return b;
    }
}

int main(){
    int n; 
    scanf("%d", &amp;n);
    
    int* tmp = malloc((n + 1) * sizeof(int));
    
    int x;
    for(int i = 0; i &lt; n; i++){
        scanf("%d", &amp;x);
        tmp[i] = x;
    }
    
    int l = 0; int r = 0;
    int res = 0;
    
    for(; r &lt; n; r++){
        cnt[tmp[r] - 1]++;
        
        while(l &lt;= r &amp;&amp; cnt[tmp[r] - 1] &gt; 1){
            cnt[tmp[l] - 1]--;
            l++;
        }
        
        res = max(res, r - l + 1);
    }
    
    
    printf("%d", res);
    
    
    return 0;
}</code></pre>
    <h3>
     <a class="link-info" href="https://www.acwing.com/problem/content/802/" rel="nofollow" title="数组元素的目标和">
      数组元素的目标和
     </a>
    </h3>
    <pre><code class="language-objectivec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(){
    int n, m, x;
    scanf("%d %d %d", &amp;n, &amp;m, &amp;x);
    
    int* A = malloc((n + 1) * sizeof(int));
    int* B = malloc((m + 1) * sizeof(int));
    
    int tmp;
    for(int i = 0; i &lt; n; i++){
        scanf("%d", &amp;tmp);
        A[i] = tmp;
    }
    for(int i = 0; i &lt; m; i++){
        scanf("%d", &amp;tmp);
        B[i] = tmp;
    }
    
    int l = 0; int r = m - 1;
    int sum;
    
    while(l &lt; n &amp;&amp; r &gt;= 0){
        sum = A[l] + B[r];
        if(sum &gt; x){
            r--;
        }else if(sum &lt; x){
            l++;
        }else{
            printf("%d %d", l , r);
            break;
        }
    }
    
    return 0;
}</code></pre>
    <h3>
     <a class="link-info" href="https://www.acwing.com/problem/content/2818/" rel="nofollow" title="判断子序列">
      判断子序列
     </a>
    </h3>
    <pre><code class="language-objectivec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(){
    int n, m;
    scanf("%d %d", &amp;n, &amp;m);
    
    int* a = malloc((n + 1) * sizeof(int));
    int* b = malloc((m + 1) * sizeof(int));
    
    int x;
    for(int i = 0; i &lt; n; i++){
        scanf("%d", &amp;x);
        a[i] = x;
    }
    for(int i = 0; i &lt; m; i++){
        scanf("%d", &amp;x);
        b[i] = x;
    }
    
    int cnt = 0;
    
    //b数组更长
    for(int i = 0; i &lt; m; i++){
        if(cnt &lt; n &amp;&amp; b[i] == a[cnt]){
            cnt++;
        }
    }
    
    if(cnt == n){
        printf("Yes");
    }else{
        printf("No");
    }
    
    
    return 0;
}</code></pre>
    <h2>
     并查集
    </h2>
    <h3>
     <a class="link-info" href="https://www.acwing.com/problem/content/838/" rel="nofollow" title="合并集合">
      合并集合
     </a>
    </h3>
    <pre><code class="language-objectivec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define N 100010

int f[N];

int find(int a){
    if(a != f[a]) f[a] = find(f[a]);
    
    return f[a];
}

int main(){
    int n, m;
    scanf("%d %d", &amp;n, &amp;m);
    
    //并查集初始化
    for(int i = 1; i &lt;= n; i++){
        f[i] = i;
    }
    
    for(int i = 0; i &lt; m; i++){
        char op[2];
        scanf("%s", op);
        
        if(op[0] == 'M'){
            int a, b;
            scanf("%d %d", &amp;a, &amp;b);
            int f1 = find(a);
            int f2 = find(b);
            
            if(f1 != f2){
                f[f1] = f2;
            }
        }else{
            int a, b;
            scanf("%d %d", &amp;a, &amp;b);
            if(find(a) != find(b)){
                printf("No\n");
            }else{
                printf("Yes\n");
            }
        }
    }
    return 0;
}</code></pre>
    <h2>
     <a class="link-info" href="https://www.acwing.com/problem/content/839/" rel="nofollow" title="连通块的数量">
      连通块的数量
     </a>
    </h2>
    <pre><code class="language-objectivec">#include&lt;stdio.h&gt;

#define N 100010

int f[N];
int cnt[N];

int find(int a){
    if(a != f[a]) f[a] = find(f[a]);
    
    return f[a];
}

int main(){
    int n, m;
    scanf("%d %d", &amp;n, &amp;m);
    
    for(int i = 1; i &lt;= n; i++){
        f[i] = i;
        cnt[i] = 1;
    }
    
    for(int i = 0; i &lt; m; i++){
        char op[3];
        scanf("%s", op);
        if(op[0] == 'C'){
            int a, b;
            scanf("%d %d", &amp;a, &amp;b);
            
            int f1 = find(a);
            int f2 = find(b);
            if(f1 != f2){
                cnt[f2] += cnt[f1];
                f[f1] = f2;
            }
        }else if(op[0] == 'Q' &amp;&amp; op[1] == '1'){
            int a, b;
            scanf("%d %d", &amp;a, &amp;b);
            int f1 = find(a);
            int f2 = find(b);
            if(f1 != f2){
                printf("No\n");
            }else{
                printf("Yes\n");
            }
        }else{
            int a;
            scanf("%d", &amp;a);
            
            printf("%d\n", cnt[find(a)]);
        }
    }
    
    return 0;
}</code></pre>
    <h2>
     Tire树
    </h2>
    <h3>
     <a class="link-info" href="https://www.acwing.com/problem/content/description/837/" rel="nofollow" title="Trie字符串统计">
      Trie字符串统计
     </a>
    </h3>
    <pre><code class="language-objectivec">#include&lt;stdio.h&gt;

#define N 200100

//模拟树
int t[N][26];
int idx;

//记录单词数
int cnt[N];

//记录每次的字符串
char str[N];

void insert(){
    int p = 0; //表示根节点
    for(int i = 0; str[i] != '\0'; i++){
        //遍历整个字符串
        int x = str[i] - 'a';
        if(!t[p][x]) t[p][x] = ++idx;//节点不存在，创建
        
        p = t[p][x];//让指针往下走，遍历完字符串
    }
    
    //到达最终的节点
    cnt[p]++;//表示以此节点为结束的字符串个数
}

void query(){
    int p = 0;
    for(int i = 0; str[i] != '\0'; i++){
        int x = str[i] - 'a';
        // if(!t[p][x]) break;//不存在
        if(!t[p][x]) {//不能break,否则还是会输出打印
            printf("0\n");
            return;
        }
        
        p = t[p][x];
    }
    
    //最终找到了
    printf("%d\n", cnt[p]);
}

int main(){
    int n;
    scanf("%d", &amp;n);
    
    char op[2];
    
    for(int i = 0; i &lt; n; i++){
        scanf("%s", op);
        scanf("%s", str);
        
        if(op[0] == 'I'){
            insert();
        }else{
            query();
        }
    }
    
    return 0;
}</code></pre>
    <h3>
     <a class="link-info" href="https://www.acwing.com/problem/content/description/145/" rel="nofollow" title="异或最大值">
      异或最大值
     </a>
    </h3>
    <pre><code class="language-objectivec">//trie树不仅可以存字符串，还可以存二进制数

#include&lt;stdio.h&gt;

#define  N 100010

int a[N];

//模拟树
int t[N * 32][2];
int idx;

int max(int a, int b){
    if(a &gt; b){
        return a;
    }else{
        return b;
    }
}

void insert(int a){
    int p = 0; 
    for(int i = 31; i &gt;= 0; i--){
        //存二进制需要从高位开始
        int x = a &gt;&gt; i &amp; 1;
        if(!t[p][x]) t[p][x] = ++idx;
        
        p = t[p][x];
    }
}

int query(int a){
    int p = 0; 
    int res = 0;
    for(int i = 31; i &gt;= 0; i--){
        int x = a &gt;&gt; i &amp; 1;
        if(t[p][!x]){
            //要求异或值最大，所以每一次都需要找相反值
            p = t[p][!x];
            res += 1 &lt;&lt; i;//有相反值，异或得1
        }else{
            p = t[p][x];//不存在相反之，异或得0
        }
    }
    
    return res;
}

int main(){
    int n; 
    scanf("%d", &amp;n);
    
    int x;
    for(int i = 0; i &lt; n; i++){
        scanf("%d", &amp;x);
        a[i] = x;
        insert(a[i]);
    }
    
    int res = 0; 
    
    //遍历每一个数的异或值，取最大
    for(int i = 0; i &lt; n; i++){
        res = max(res, query(a[i]));
    }
    
    printf("%d", res);
    
    return 0;
}</code></pre>
    <h3>
     <a class="link-info" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" title="实现trie">
      实现trie
     </a>
    </h3>
    <pre><code class="language-objectivec">#define N 100010

typedef struct {
    int t[N][26];
    bool flag[N];
    int idx;
} Trie;


Trie* trieCreate() {
    Trie* t = malloc(sizeof(Trie));
    memset(t, 0, sizeof(Trie));  // 初始化所有值为 0

    return t;
}

void trieInsert(Trie* obj, char* word) {
    int p = 0;
    for(int i = 0; word[i] != '\0'; i++){
        int x = word[i] - 'a';
        if(!(obj-&gt;t[p][x])) obj-&gt;t[p][x] = ++(obj-&gt;idx);

        p = obj-&gt;t[p][x];
    }

    obj-&gt;flag[p] = true;
}

bool trieSearch(Trie* obj, char* word) {
    int p = 0;
    for(int i = 0; word[i] != '\0'; i++){
        int x = word[i] - 'a';
        if(!obj-&gt;t[p][x]) return false;

        p = obj-&gt;t[p][x];
    }
    
    return obj-&gt;flag[p];
}

bool trieStartsWith(Trie* obj, char* prefix) {
    int p = 0;
    for(int i = 0; prefix[i] != '\0'; i++){
        int x = prefix[i] - 'a';
        if(!obj-&gt;t[p][x]) return false;

        p = obj-&gt;t[p][x];
    }
    
    return true;
}

void trieFree(Trie* obj) {
    free(obj);
}

/**
 * Your Trie struct will be instantiated and called as such:
 * Trie* obj = trieCreate();
 * trieInsert(obj, word);
 
 * bool param_2 = trieSearch(obj, word);
 
 * bool param_3 = trieStartsWith(obj, prefix);
 
 * trieFree(obj);
*/</code></pre>
    <h2>
    </h2>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36343431313238372f:61727469636c652f64657461696c732f313436313939363233" class_="artid" style="display:none">
 </p>
</div>


