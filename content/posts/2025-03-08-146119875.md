---
layout: post
title: "在-Python-异步编程中使用-awaitable-对象"
date: 2025-03-08 17:57:39 +0800
description: "awaitable。"
keywords: "在 Python 异步编程中使用 `awaitable` 对象"
categories: ['未分类']
tags: ['开发语言', 'Python']
artid: "146119875"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146119875
    alt: "在-Python-异步编程中使用-awaitable-对象"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146119875
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146119875
cover: https://bing.ee123.net/img/rand?artid=146119875
image: https://bing.ee123.net/img/rand?artid=146119875
img: https://bing.ee123.net/img/rand?artid=146119875
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     在 Python 异步编程中使用 `awaitable` 对象
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_Python__awaitable__2">
     </a>
     在 Python 异步编程中使用
     <code>
      awaitable
     </code>
     对象
    </h2>
    <p>
     在
     <code>
      awaitable
     </code>
     对象上，我们可以应用
     <code>
      await
     </code>
     语句。
     <code>
      asyncio
     </code>
     中的大部分函数和模块被设计为可以与
     <code>
      awaitable
     </code>
     对象一起使用。但是大部分 Python 对象和第三方库，不是为异步编程构建的。当构建异步应用程序时，有一点非常重要，那就是选择提供可用
     <code>
      awaitble
     </code>
     对象的兼容库。
    </p>
    <p>
     <code>
      awaitalbe
     </code>
     对象主要被分成三种类型：协程、任务和期物 (Futures)。我们已经讨论过了协程和任务。期物是一种低层次对象，像一种回调机制，用来处理来自于
     <code>
      async/await
     </code>
     的结果。期物对象通常不会暴露于用户级编程。
    </p>
    <h3>
     <a id="_8">
     </a>
     并发运行任务
    </h3>
    <p>
     如果我们一定要并行运行多个任务，我们可以使用
     <code>
      await
     </code>
     关键字，就像我们在之前的例子中做的那样。但是有一种更好的方法做这件事，就是使用
     <code>
      gather
     </code>
     函数。这个函数会按提供的序列运行
     <code>
      awaitable
     </code>
     对象。如果任何
     <code>
      awaitable
     </code>
     对象是协程，它将被调度为任务。后面的例子中我们会演示
     <code>
      gather
     </code>
     函数的使用。
    </p>
    <h2>
     <a id="_12">
     </a>
     使用队列分发任务
    </h2>
    <p>
     <code>
      asyncio
     </code>
     包中的
     <code>
      Queue
     </code>
     队列和
     <code>
      Queue
     </code>
     模块类似，但是不是线程安全的。但是
     <code>
      asyncio
     </code>
     模块提供了多种队列实现，比如
     <code>
      FIFO
     </code>
     队列、优先级队列和
     <code>
      LIFO
     </code>
     队列。
     <code>
      asyncio
     </code>
     模块中的队列可以用来把工作负载发布为任务。
    </p>
    <p>
     为了演示任务对列的使用，我们会写一个小程序，通过随机休眠一段时间来模拟实际函数的执行时间。为 10 次这样的执行计算随机休眠时间，并且由主进程作为工作项添加到
     <code>
      Queue
     </code>
     对象中。
     <code>
      Queue
     </code>
     队列被传递到一个有三个任务的池中。任务池中的每一个任务执行给定的协程，协程会消费每一个对它可见的队列记录中的执行时间（该协程根据其可用的队列条目消耗执行时间）。下面是完整的代码示例：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> time

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">executer</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        exec_time <span class="token operator">=</span> <span class="token keyword">await</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>exec_time<span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    myqueue <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    calc_execution_time <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        sleep_for <span class="token operator">=</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span>
        calc_execution_time <span class="token operator">+=</span> sleep_for
        myqueue<span class="token punctuation">.</span>put_nowait<span class="token punctuation">(</span>sleep_for<span class="token punctuation">)</span>

    tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token builtin">id</span> <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>executer<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'任务-</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">id</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">,</span> myqueue<span class="token punctuation">)</span><span class="token punctuation">)</span>
        tasks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>task<span class="token punctuation">)</span>

    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>monotonic<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> myqueue<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
    total_exec_time <span class="token operator">=</span> time<span class="token punctuation">.</span>monotonic<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time

    <span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>
        task<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">,</span> return_exceptions<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"执行时间：</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>calc_execution_time<span class="token punctuation">:</span><span class="token format-spec">0.2f</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"实际执行时间：</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>total_exec_time<span class="token punctuation">:</span><span class="token format-spec">0.2f</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>


asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     我们使用
     <code>
      Queue
     </code>
     队列的
     <code>
      put_nowait
     </code>
     函数，因为它是一个非阻塞操作。上面的代码的执行结果是：
    </p>
    <pre><code>执行时间：6.22
实际执行时间：2.40
</code></pre>
    <p>
     这清晰的演示了任务是并行执行的，执行时间是顺序执行的近三分之一。
    </p>
    <p>
     &lt;完&gt;
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f646f7768696c6570726f6772616d6d696e672f:61727469636c652f64657461696c732f313436313139383735" class_="artid" style="display:none">
 </p>
</div>


