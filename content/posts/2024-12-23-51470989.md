---
layout: post
title: "java-通过代码实现动态选择数据源"
date: 2024-12-23 11:11:34 +0800
description: "类注解import java.lang.annotation.Docu"
keywords: "java点击按钮选择数据源"
categories: ['Java']
tags: ['基础', 'Spring', 'Mybatis']
artid: "51470989"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51470989
    alt: "java-通过代码实现动态选择数据源"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51470989
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51470989
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java 通过代码实现动态选择数据源
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     类注解
    </h2>
    <div>
     <pre><code class="language-java">import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Specify DataSource (指定数据源，用于执行事物切面时，指定其他数据源)&lt;br&gt;
 * 注意：&lt;br&gt;
 * {@code @SpecifyDS}放在类级别上等同于该类的每个公有方法都放上了{@code @SpecifyDS}&lt;br&gt;
 * {@code @SpecifyDS}只对公有法有效（与Spring的{@code @Transactional}只对公有方法有效道理是一样的，因为都是Spring AOP代理）
 * 
 */
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface SpecifyDS {
    String value();
}</code></pre>
     <h2>
      线程独享的数据源对象
     </h2>
    </div>
    <div>
     <pre>public class DataSourceHolder {
    
    public static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;();


    public static void setDataSource(String name) {
        holder.set(name);
    }


    public static String getDataSouce() {
        return holder.get();
    }


}
</pre>
     <h2>
      动态设置数据源
     </h2>
    </div>
    <div>
     <pre><code class="language-java">import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

/**
 * 获取当前ThreadLocal设置的dataSource （动态设置的dataSource）
 */
public class DynamicDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceHolder.getDataSouce();
    }

}</code></pre>
     <h2>
      数据源自动选择的切面类
     </h2>
     <pre><code class="language-java">import java.lang.reflect.Method;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.transaction.annotation.Transactional;

public class DataSourceAspect implements org.springframework.core.Ordered {
    
    private static final String READ_ONLY_METHOD_PREFFIX = "select";
    private static final String DEFAULT_MASTER_SUFFIX = "MasterDataSource";
    private static final String DEFAULT_SLAVE_SUFFIX = "SlaveDataSource";
    private static final int DEFAULT_ORDER = -1;
    
    /**
     * CUD【创建（Create）、更新（Update）和删除（Delete）】所使用的数据源
     * &lt;br&gt;默认使用 {主库}
     */
    private String cudDBSuffix = DEFAULT_MASTER_SUFFIX;
    
    /**
     * R【读取（Read）】所使用的数据源
     * &lt;br&gt;默认使用 {从库}
     */
    private String readDBSuffix = DEFAULT_SLAVE_SUFFIX;
    
    /**
     * Spring Aspect的顺序，如果一个方法上有多个切面，则值越小的先执行。
     */
    private int order = DEFAULT_ORDER;
    
    /**
     * 执行事物切面时默认使用的数据源（通常配置为项目的主数据库的主库）
     */
    private String defaultTransDb;
    
    public void before(JoinPoint point) {
        if (DataSourceHolder.getDataSouce() == null) {
            // 根据包路径名 获取dataSource的key前缀，这样效率太低，改成根据Mapper前缀来获取
            Class&lt;?&gt;[] classz = point.getTarget().getClass().getInterfaces();
            String interfacePath = classz[0].getName();
            // 获取dao和mapper之间的包名，这儿包名与xml的dataSource的key前缀相同
            int daoIndex = interfacePath.indexOf("dao");
            int mapperIndex = interfacePath.indexOf("mapper");
            String packet = interfacePath.substring(daoIndex + 4, mapperIndex - 1);

            if (point.getSignature().getName().indexOf(READ_ONLY_METHOD_PREFFIX) != -1) {
                DataSourceHolder.setDataSource(packet + readDBSuffix);
            } else {
                DataSourceHolder.setDataSource(packet + cudDBSuffix);
            }
        }
    }
    
    public void beforeTrans(JoinPoint point) {
        Signature signature = point.getSignature();
        MethodSignature methodSignature = (MethodSignature) signature;
        Method method = methodSignature.getMethod();
        // 获取目标类
        Class&lt;?&gt; target = point.getTarget().getClass();
        Method targetMethod = null;
        try {
            targetMethod = target.getMethod(method.getName(), method.getParameterTypes());
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        // 根据目标类方法中的注解，选择数据源
        if (targetMethod != null) {
            Transactional transactional = targetMethod.getAnnotation(Transactional.class);
            if (transactional != null) {
                SpecifyDS specifyDSCls = target.getAnnotation(SpecifyDS.class);
                SpecifyDS specifyDS = targetMethod.getAnnotation(SpecifyDS.class);
                if (specifyDS != null) {
                    DataSourceHolder.setDataSource(specifyDS.value());
                } else if (specifyDSCls != null) {
                    DataSourceHolder.setDataSource(specifyDSCls.value());
                } else {
                    DataSourceHolder.setDataSource(defaultTransDb);
                }
            }
        }
    }

    public void after() {
        DataSourceHolder.setDataSource(null);
    }
    
    
    @Override
    public int getOrder() {
        return order;
    }
    
    public void setOrder(int order){
        this.order = order;
    }


    /**
     * @return the cudDBSuffix
     */
    public String getCudDBSuffix() {
        return cudDBSuffix;
    }

    /**
     * @param cudDBSuffix the cudDBSuffix to set
     */
    public void setCudDBSuffix(String cudDBSuffix) {
        this.cudDBSuffix = cudDBSuffix;
    }

    /**
     * @return the readDBSuffix
     */
    public String getReadDBSuffix() {
        return readDBSuffix;
    }

    /**
     * @param readDBSuffix the readDBSuffix to set
     */
    public void setReadDBSuffix(String readDBSuffix) {
        this.readDBSuffix = readDBSuffix;
    }

    /**
     * @return the defaultTransDb
     */
    public String getDefaultTransDb() {
        return defaultTransDb;
    }

    /**
     * @param defaultTransDb the defaultTransDb to set
     */
    public void setDefaultTransDb(String defaultTransDb) {
        this.defaultTransDb = defaultTransDb;
    }

}
</code></pre>
     <br/>
     <h2>
      JDBC配置文件
     </h2>
    </div>
    <div>
     <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:aop="http://www.springframework.org/schema/aop"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
	http://www.springframework.org/schema/tx 
	http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
  	http://www.springframework.org/schema/aop 
  	http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"
	   default-autowire="byName"&gt;


	&lt;!--druid--&gt;
	&lt;bean id="MasterDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
		&lt;property name="driverClassName" value="${jdbc.driverClass}"/&gt;
		&lt;property name="url" value="${jdbc.map.master.url}"/&gt;
		&lt;property name="username" value="${jdbc.map.master.username}"/&gt;
		&lt;property name="password" value="${jdbc.map.master.password}"/&gt;
		&lt;property name="initialSize" value="5"/&gt;
		&lt;property name="minIdle" value="5"/&gt;
		&lt;property name="maxActive" value="10"/&gt;
		&lt;property name="timeBetweenEvictionRunsMillis" value="5000"/&gt;
		&lt;property name="minEvictableIdleTimeMillis" value="60000"/&gt;
		&lt;property name="validationQuery" value="SELECT 'x'"/&gt;
		&lt;property name="testWhileIdle" value="true"/&gt;
		&lt;property name="testOnBorrow" value="false"/&gt;
		&lt;property name="testOnReturn" value="false"/&gt;
		&lt;property name="removeAbandoned" value="true"/&gt;
		&lt;property name="removeAbandonedTimeout" value="1800"/&gt;
		&lt;property name="logAbandoned" value="true"/&gt;
		&lt;property name="filters" value="stat"/&gt;
		&lt;property name="connectionProperties" value="druid.stat.slowSqlMillis=100"/&gt;
	&lt;/bean&gt;
	&lt;bean id="SlaveDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
	&lt;property name="driverClassName" value="${jdbc.driverClass}"/&gt;
		&lt;property name="url" value="${jdbc.map.slave.url}"/&gt;
		&lt;property name="username" value="${jdbc.map.slave.username}"/&gt;
		&lt;property name="password" value="${jdbc.map.slave.password}"/&gt;

		&lt;property name="initialSize" value="5"/&gt;
		&lt;property name="minIdle" value="5"/&gt;
		&lt;property name="maxActive" value="10"/&gt;
		&lt;property name="timeBetweenEvictionRunsMillis" value="5000"/&gt;
		&lt;property name="minEvictableIdleTimeMillis" value="30000"/&gt;
		&lt;property name="validationQuery" value="SELECT 'x'"/&gt;
		&lt;property name="testWhileIdle" value="true"/&gt;
		&lt;property name="testOnBorrow" value="false"/&gt;
		&lt;property name="testOnReturn" value="false"/&gt;
		&lt;property name="removeAbandoned" value="true"/&gt;
		&lt;property name="removeAbandonedTimeout" value="1800"/&gt;
		&lt;property name="logAbandoned" value="true"/&gt;
		&lt;property name="filters" value="stat"/&gt;
		&lt;property name="connectionProperties" value="druid.stat.slowSqlMillis=100"/&gt;
	&lt;/bean&gt;

    &lt;!-- 配置DynamicDataSource代替普通dataSource，将实际数据源的DataSource赋值给它 --&gt;
	&lt;bean id="dataSource" class="com.groupname.commons.db.DynamicDataSource"&gt;
		&lt;property name="targetDataSources"&gt;
			&lt;map key-type="java.lang.String"&gt;
				&lt;entry key="MasterDataSource" value-ref="MasterDataSource"/&gt;
				&lt;entry key="SlaveDataSource" value-ref="SlaveDataSource"/&gt;
			&lt;/map&gt;
		&lt;/property&gt;
  
        &lt;!-- 默认主库 --&gt;
		&lt;property name="defaultTargetDataSource" ref="MasterDataSource"/&gt;
	&lt;/bean&gt;

	&lt;!-- 配置数据库注解aop,mapper层选择数据源 --&gt;
	&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
 
    &lt;bean id="multiDataSourceAspect" class="com.groupname.commons.db.DataSourceAspect"&gt;
        &lt;!-- 执行事物切面时默认使用的数据源（通常配置为项目的主数据库的主库）。如果不配置，将默认使用上面的defaultTargetDataSource --&gt;
        &lt;property name="defaultTransDb" value="mapMasterDataSource" /&gt;
        &lt;!-- 以下是默认配置，一般无需修改 --&gt;
        &lt;!-- CUD【创建（Create）、更新（Update）和删除（Delete）】所使用的数据源。默认使用 {主库} --&gt;
        &lt;!-- &lt;property name="cudDBSuffix" value="MasterDataSource" /&gt; --&gt;
        &lt;!-- R【读取（Read）】所使用的数据源。默认使用 {从库} --&gt;
        &lt;!-- &lt;property name="readDBSuffix" value="SlaveDataSource" /&gt; --&gt;
    &lt;/bean&gt;
    
	&lt;aop:config&gt;
		&lt;aop:aspect ref="multiDataSourceAspect" &gt;
            &lt;!-- 为DAO层的Mapper自动选择数据源：默认规则是select开头的方法选择从库，其他像update、insert等方法选择主库。
                 可更改multiDataSourceAspect的slaveSuffix的值来改变默认策略 --&gt;
			&lt;aop:pointcut id="daoDataSourceAutoSelect" expression="execution(* com.groupname.*.center.dao.*.mapper.*.*(..))"/&gt;
			&lt;aop:before pointcut-ref="daoDataSourceAutoSelect" method="before"/&gt;
			&lt;aop:after pointcut-ref="daoDataSourceAutoSelect" method="after"/&gt;
            
            &lt;!-- 为事务控制自动选择数据源：扫描有@Transactional注解的service方法，默认切换到上面配置的defaultTransDb数据源去执行事务。
                 如果要切换其他数据源，可以在方法上再加一个@SpecifyDS({value})，在value中注明是哪个数据源ID --&gt;
            &lt;aop:pointcut id="transDataSourceAutoSelect" expression="execution(* com.groupname.*.center.service.*.*(..))||execution(* com.groupname.*.manager.service.biz.*.*(..))"/&gt;
            &lt;aop:before pointcut-ref="transDataSourceAutoSelect" method="beforeTrans"/&gt;
            &lt;aop:after pointcut-ref="transDataSourceAutoSelect" method="after"/&gt;
		&lt;/aop:aspect&gt;
	&lt;/aop:config&gt;

	&lt;!-- 定义事务管理器  --&gt;
	&lt;bean id="transactionManager"
		  class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
		&lt;property name="dataSource" ref="dataSource" /&gt;
	&lt;/bean&gt;
	&lt;!-- 事务支持注解  --&gt;
	&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;
	&lt;!--编程式事务使用--&gt;
	&lt;bean id="txDefinition" class="org.springframework.transaction.support.DefaultTransactionDefinition"&gt;&lt;/bean&gt;
&lt;/beans&gt;</code></pre>
     <br/>
     <br/>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6a7a6831393838393033:2f61727469636c652f64657461696c732f3531343730393839" class_="artid" style="display:none">
 </p>
</div>


