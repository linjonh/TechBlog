---
layout: post
title: "使用Dockerfile打包java项目生成镜像部署到Linux_java项目打docker镜像的dockerfile"
date: 2025-02-04 11:19:16 +0800
description: "比起容器、镜像来说，非常普通，它就是一个纯文本，里面记录了一系列的构建指令，比如选择基础镜像、拷贝文件、运行脚本等等，每个指令都会生成一个 Layer，而 Docker 顺序执行这个文件里的所有步骤，最后就会创建出一个新的镜像出来。"
keywords: "dockerfile java"
categories: ['未分类']
tags: ['Linux', 'Java', 'Docker']
artid: "145438505"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145438505
    alt: "使用Dockerfile打包java项目生成镜像部署到Linux_java项目打docker镜像的dockerfile"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145438505
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145438505
cover: https://bing.ee123.net/img/rand?artid=145438505
image: https://bing.ee123.net/img/rand?artid=145438505
img: https://bing.ee123.net/img/rand?artid=145438505
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     使用Dockerfile打包java项目生成镜像部署到Linux_java项目打docker镜像的dockerfile
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     比起容器、镜像来说，
     <strong>
      Dockerfile
     </strong>
     非常普通，它就是一个纯文本，里面记录了一系列的构建指令，比如选择基础镜像、拷贝文件、运行脚本等等，每个指令都会生成一个 Layer，而 Docker 顺序执行这个文件里的所有步骤，最后就会创建出一个新的镜像出来。
    </p>
    <h4>
     <a id="2javaDockerfile_3">
     </a>
     2、编写java项目对应的Dockerfile
    </h4>
    <pre><code># 使用 OpenJDK 8 作为基础镜像
FROM openjdk:8-jdk-alpine

# 作者信息
LABEL maintainer="flgb"

# 设置环境变量
ENV SPRING\_OUTPUT\_ANSI\_ENABLED=ALWAYS \
    JAVA\_OPTS="-Xms2048m -Xmx2048m -Dspring.profiles.active=prod -Dserver.port=6088"\
    PORT=6088
# spring-boot-admin.jar相对于Dockerfile的路径
COPY /spring-boot-admin.jar /spring-admin.jar

# sh shell -c 执行后面命令
ENTRYPOINT ["sh", "-c", "java $JAVA\_OPTS -jar /spring-admin.jar"]

#通过 EXPOSE 命令暴露外部访问容器端口
EXPOSE $PORT

</code></pre>
    <p>
     <strong>
      注意点
     </strong>
    </p>
    <h5>
     <a id="ADD_COPY__32">
     </a>
     ADD 和COPY 的区别
    </h5>
    <p>
     COPY 和 ADD 都是用于将文件从主机复制到 Docker 容器内部的命令，但它们之间有一些区别：
    </p>
    <ol>
     <li>
      COPY 命令只能复制本地主机上的文件或目录到容器内部，不能从 URL 或者其他网络资源复制文件。而 ADD 命令可以从本地主机、URL
      <br/>
      或者其他网络资源复制文件。
     </li>
     <li>
      ADD 命令支持自动解压缩 tar 类型的文件（如压缩文件
      <br/>
      .tar、.tar.gz、.tar.bz2、.tar.xz），并将解压后的内容复制到容器内。而 COPY
      <br/>
      命令则只是简单地复制文件，不会自动解压缩。
     </li>
     <li>
      由于 ADD 命令的功能更多，因此在复制文件时，建议优先使用 COPY 命令，除非需要 ADD 的特殊功能。
     </li>
    </ol>
    <h5>
     <a id="CMD__ENTRYPOINT_46">
     </a>
     CMD 和 ENTRYPOINT的区别
    </h5>
    <p>
     <strong>
      CMD 指令
     </strong>
     ：
    </p>
    <ul>
     <li>
      CMD 用于指定容器启动时要执行的命令。
     </li>
     <li>
      可以有多个 CMD 指令，但只有最后一个生效。
     </li>
     <li>
      如果 Dockerfile 中没有 CMD 指令，则默认会执行容器启动时所用的镜像的 CMD 命令。
     </li>
     <li>
      CMD 指令可以被 Docker run 命令中的参数覆盖。
     </li>
    </ul>
    <p>
     <strong>
      ENTRYPOINT 指令
     </strong>
     ：
    </p>
    <ul>
     <li>
      ENTRYPOINT 用于指定容器启动时要执行的可执行文件或脚本。
      <br/>
      只需要运行该镜像，就会自动执行 ENTRYPOINT 指定的命令
     </li>
     <li>
      如果 Dockerfile 中存在多个 ENTRYPOINT 指令，则只有最后一个生效。
     </li>
     <li>
      在运行容器时，可以通过在 docker run 命令中指定参数来覆盖 ENTRYPOINT 中的内容。
     </li>
     <li>
      如果 Dockerfile 中同时存在 ENTRYPOINT 和 CMD 指令，则 CMD 的内容会被作为参数传递给 ENTRYPOINT
      <br/>
      所指定的可执行文件或脚本。
     </li>
    </ul>
    <h4>
     <a id="3java_69">
     </a>
     3、构建java项目镜像
    </h4>
    <pre><code>docker build [OPTIONS] PATH | URL | -

</code></pre>
    <p>
     其中，PATH 可以是本地文件系统上 Dockerfile 文件所在的路径，也可以是 URL，或者是 -（表示使用标准输入）。OPTIONS 是一些可选参数，常用的参数包括：
    </p>
    <ul>
     <li>
      -t, --tag：为镜像设置一个标签，格式为 :。例如，-t myimage:1.0。
     </li>
     <li>
      -f, --file：指定要使用的 Dockerfile 文件的路径。如果不指定，默认为当前目录下的 Dockerfile 文件。
     </li>
     <li>
      其他选项包括 --build-arg、–pull、–no-cache 等，可以根据需要进行设置。
     </li>
    </ul>
    <p>
     例如，如果 Dockerfile 文件位于当前目录下，可以使用以下命令构建镜像并设置标签：
    </p>
    <pre><code>docker build -t spring-boot:1.0 .


</code></pre>
    <p>
     上传dockerfile和spring-boot-admin jar到对应路径/data/java/spring-boot下
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/direct/fcaa6b5a3b234a458ad37fc2c5544569.png"/>
    </p>
    <h5>
     <a id="_102">
     </a>
     构建镜像
    </h5>
    <pre><code>docker build -t spring-boot:1.0 

</code></pre>
    <h5>
     <a id="Build_111">
     </a>
     Build的路径问题
    </h5>
    <pre><code>经常会遇到如下报错：

</code></pre>
    <pre><code>COPY failed: stat xxxx: no such file or directory

</code></pre>
    <p>
     <strong>
      1、Dockerfile 文件查找不到
     </strong>
     <br/>
     如果dockerfile不在当前目录，则需要指定dockerfile 目录构建
    </p>
    <pre><code>docker build -f "/data/java/spring-boot/Dockerfile" -t spring-boot:1.0 

</code></pre>
    <p>
     <strong>
      2、Copy /spring-boot-admin.jar文件找不到的问题
     </strong>
    </p>
    <p>
     <strong>
      COPY 命令中指定的源路径应该是相对于 Dockerfile 的路径
     </strong>
     。
    </p>
    <ul>
     <li>
      如果 spring-boot-admin.jar 文件位于与 Dockerfile 同级的目录下，应该将 COPY 命令修改为：
     </li>
    </ul>
    <pre><code>COPY spring-boot-admin.jar /spring-admin.jar

</code></pre>
    <ul>
     <li>
      如果 spring-boot-admin.jar 文件位于 Dockerfile 的上级目录中，可以使用 … 来指定父级目录
     </li>
    </ul>
    <pre><code>COPY ../spring-boot-admin.jar /spring-admin.jar


</code></pre>
    <ul>
     <li>
      PS:一开始把COPY 的路径设置成了/data/java/spring-boot/spring-boot-admin.jar一直找不到，报错：
     </li>
     <li>
     </li>
    </ul>
    <pre><code>failed to walk /var/lib/docker/tmp/buildkit-mount2576932656/data/java/spring-boot: lstat /var/lib/docker/tmp/buildkit-mount2576932656/data/java/spring-boot: no such file or directory


</code></pre>
    <h5>
     <a id="_172">
     </a>
     查看已经构建成功的镜像
    </h5>
    <pre><code>docker images

</code></pre>
    <h4>
     <a id="4_181">
     </a>
     4、生成容器
    </h4>
    <ul>
     <li>
      执行命令
     </li>
    </ul>
    <pre><code>docker run -p 6088:6088 --name springboot --restart always \
&gt; -d spring-boot:1.0


</code></pre>
    <p>
     查看项目启动日志，启动成功
    </p>
    <pre><code>docker log 容器id
#动态更细查看日志
docker log -f 容器id

</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/direct/0722639375a04056a5f27fa3a4182a2b.png"/>
    </p>
    <h4>
     <a id="5docker__209">
     </a>
     5、docker 应用日志映射到本地
    </h4>
    <p>
     <strong>
      进入容器里面查看日志
     </strong>
    </p>
    <pre><code>#查看对应容器id
docker ps 
#进入容器
docker exec -it container_id bash
#如果没装对应的bash命令，使用sh进入
docker exec -it container_id sh
#查看目录
ls
#退出容器
exit

</code></pre>
    <p>
     #
     <strong>
      进入logback配置的输出log地址，查看日志文件
     </strong>
     <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/direct/0855f0c665ff48e5bfe37ce192b37e0d.png"/>
    </p>
    <pre><code>#停止容器
docker stop id
#删除容器
docker rm id
#重新生成挂在日志到本地目录的容器
docker run -p 6088:6088 --name spring-boot --restart always \
-v /home/spring-boot/logs:/home/spring-boot/logs \
-d spring-boot:1.0


</code></pre>
    <p>
     <strong>
      同步查看本地目录
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/direct/41383c652ec841c7bac9c95da8ee2793.png"/>
    </p>
    <h4>
     <a id="6docker_easyExcel_251">
     </a>
     6、docker环境下 easyExcel导出错误
    </h4>
    <pre><code>java.lang.NullPointerException: null
	at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264)
	at sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219)
	at sun.awt.FontConfiguration.init(FontConfiguration.java:107)
	at sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774)
	at sun.font.SunFontManager$2.run(SunFontManager.java:431)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376)
	at sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35)
	at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at java.lang.Class.newInstance(Class.java:442)
	at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74)
	at java.awt.Font.getFont2D(Font.java:491)
	at java.awt.Font.canDisplayUpTo(Font.java:2060)
	at java.awt.font.TextLayout.singleFont(TextLayout.java:470)
	at java.awt.font.TextLayout.&lt;init&gt;(TextLayout.java:531)
	at org.apache.poi.ss.util.SheetUtil.getDefaultCharWidth(SheetUtil.java:273)
	at org.apache.poi.xssf.streaming.AutoSizeColumnTracker.&lt;init&gt;(AutoSizeColumnTracker.java:117)
	at org.apache.poi.xssf.streaming.SXSSFSheet.&lt;init&gt;(SXSSFSheet.java:82)
	at org.apache.poi.xssf.streaming.SXSSFWorkbook.createAndRegisterSXSSFSheet(SXSSFWorkbook.java:684)
	at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:705)


</code></pre>
    <h5>
     <a id="dockeropenjdk_287">
     </a>
     因为docker的基础镜像openjdk缺少字体。
    </h5>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323530315f39303433333233322f:61727469636c652f64657461696c732f313435343338353035" class_="artid" style="display:none">
 </p>
</div>


