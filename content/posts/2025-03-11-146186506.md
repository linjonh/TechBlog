---
layout: post
title: "SpringMVC"
date: 2025-03-11 18:55:19 +0800
description: "MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。模型（Model）：负责封装业务数据和业务逻辑，通常是 JavaBean 或领域对象，可从数据库、文件等数据源获取数据。视图（View）：负责将模型中的数据呈现给用户，常见形式有 JSP、Thymeleaf、FreeMarker 模板等。控制器（Controller）：负责接收用户请求，调用模型处理业务逻辑，然后选择合适的视图将结果展示给用户。"
keywords: "SpringMVC"
categories: ['未分类']
tags: ['学习', 'Java']
artid: "146186506"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146186506
    alt: "SpringMVC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146186506
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146186506
cover: https://bing.ee123.net/img/rand?artid=146186506
image: https://bing.ee123.net/img/rand?artid=146186506
img: https://bing.ee123.net/img/rand?artid=146186506
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringMVC
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="SpringMVC_1">
     </a>
     SpringMVC的概述
    </h2>
    <h3>
     <a id="MVC_3">
     </a>
     MVC模型
    </h3>
    <ol>
     <li>
      MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。
     </li>
     <li>
      <strong>
       模型（Model）
      </strong>
      ：负责封装业务数据和业务逻辑，通常是 JavaBean 或领域对象，可从数据库、文件等数据源获取数据。
     </li>
     <li>
      <strong>
       视图（View）
      </strong>
      ：负责将模型中的数据呈现给用户，常见形式有 JSP、Thymeleaf、FreeMarker 模板等。
     </li>
     <li>
      <strong>
       控制器（Controller）
      </strong>
      ：负责接收用户请求，调用模型处理业务逻辑，然后选择合适的视图将结果展示给用户。
     </li>
    </ol>
    <h2>
     <a id="SpringMVC_12">
     </a>
     SpringMVC组件解析
    </h2>
    <h3>
     <a id="SpringMVC_14">
     </a>
     SpringMVC处理请求的执行流程
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ba7c3fd3fcdf48c495ae770e0c0c6b27.png"/>
    </p>
    <ol>
     <li>
      <strong>
       DispatcherServlet 接收请求
      </strong>
      ：请求进入 SpringMVC 应用，首先被 DispatcherServlet（前端控制器）拦截，它是整个请求处理的核心枢纽。
     </li>
     <li>
      <strong>
       HandlerMapping 映射处理器
      </strong>
      ：DispatcherServlet 调用 HandlerMapping（处理器映射器），根据请求的 URL、请求方法等信息，在已配置的映射关系中查找对应的处理器（Controller）。比如根据 @RequestMapping 注解配置的映射规则，找到处理该请求的具体 Controller 类和方法，HandlerMapping 返回一个包含处理器和拦截器的 HandlerExecutionChain 对象。
     </li>
     <li>
      <strong>
       HandlerAdapter 调用处理器
      </strong>
      ：DispatcherServlet 拿到 HandlerExecutionChain 后，通过 HandlerAdapter（处理器适配器）来调用处理器。由于处理器类型可能不同，HandlerAdapter 负责适配不同的处理器，确保 DispatcherServlet 能以统一方式调用。
     </li>
     <li>
      <strong>
       拦截器预处理（可选）
      </strong>
      ：在处理器执行前，HandlerExecutionChain 中配置的拦截器会依次执行预处理方法（preHandle），可用于权限验证、日志记录等操作。若拦截器返回 false，请求处理流程将被中断，不会继续执行处理器。
     </li>
     <li>
      <strong>
       处理器处理请求
      </strong>
      ：处理器（Controller）被调用，接收请求参数，调用业务逻辑层（Service 层）的方法处理业务，如查询数据库、计算数据等。处理完成后，处理器返回一个 ModelAndView 对象，包含处理结果数据（Model）和逻辑视图名（View）。
     </li>
     <li>
      <strong>
       拦截器后处理（可选）
      </strong>
      ：处理器执行完成后，拦截器会依次执行后处理方法（postHandle），可以对 ModelAndView 对象进行进一步处理，如添加额外数据等。
     </li>
     <li>
      <strong>
       ViewResolver 解析视图
      </strong>
      ：DispatcherServlet 将 ModelAndView 对象传递给 ViewResolver（视图解析器），视图解析器根据逻辑视图名，找到对应的实际视图，如 JSP、Thymeleaf 模板等，并返回视图对象。
     </li>
     <li>
      <strong>
       视图渲染
      </strong>
      ：DispatcherServlet 将模型数据传递给视图对象，视图将数据渲染成最终的响应内容，如生成 HTML 页面、JSON 数据等。
     </li>
     <li>
      <strong>
       返回响应
      </strong>
      ：响应内容通过 ServletResponse 对象返回给 Tomcat 服务器，Tomcat 再将响应发送回浏览器，浏览器解析并展示响应内容。
     </li>
    </ol>
    <h3>
     <a id="_29">
     </a>
     组件解析
    </h3>
    <ol>
     <li>
      <p>
       前端控制器（DispatcherServlet）
      </p>
     </li>
     <li>
      <p>
       处理器映射器（HandlerMapping）
      </p>
     </li>
     <li>
      <p>
       处理器（Handler）
      </p>
     </li>
     <li>
      <p>
       处理器适配器（HandlAdapter）
      </p>
     </li>
     <li>
      <p>
       视图解析器（View Resolver）
      </p>
     </li>
     <li>
      <p>
       视图（View）
      </p>
     </li>
     <li>
      <p>
       前端控制器（DispatcherServlet）
      </p>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：作为 Spring MVC 的核心入口点，它接收所有客户端的 HTTP 请求，并负责协调其他组件来处理请求，最后将处理结果返回给客户端。可以将其看作是整个 Web 应用请求处理的调度中心。
       </li>
       <li>
        <strong>
         工作原理
        </strong>
        ：在 Web 应用启动时，DispatcherServlet 会被初始化，并读取配置文件（如 Spring 的配置文件）来了解如何处理请求。当有请求到达时，它会依次调用处理器映射器、处理器适配器等组件，按照预定的流程处理请求。
       </li>
      </ul>
     </li>
     <li>
      <p>
       处理器映射器（HandlerMapping）
      </p>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：根据客户端请求的 URL、HTTP 方法等信息，查找匹配的处理器（Handler）。它维护了请求和处理器之间的映射关系，将请求准确地路由到相应的处理器上。
       </li>
       <li>
        <strong>
         工作原理
        </strong>
        ：常见的处理器映射器实现如 RequestMappingHandlerMapping，它会扫描应用中带有 @RequestMapping 等注解的控制器方法，建立请求 URL 和处理器方法之间的映射。当 DispatcherServlet 调用它时，它会根据请求信息找到对应的处理器，并返回一个包含处理器和拦截器的 HandlerExecutionChain 对象。
       </li>
      </ul>
     </li>
     <li>
      <p>
       处理器（Handler）
      </p>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：也称为控制器（Controller），是处理具体业务逻辑的组件。它接收请求参数，调用业务逻辑层（如 Service 层）的方法进行处理，然后返回一个 ModelAndView 对象，其中包含了处理结果数据（Model）和逻辑视图名（View）。
       </li>
       <li>
        <strong>
         工作原理
        </strong>
        ：开发人员通过编写控制器类和方法来实现具体的业务逻辑。例如，一个处理用户登录的控制器方法会接收用户名和密码参数，调用用户服务进行验证，然后根据验证结果返回相应的视图和数据。
       </li>
      </ul>
     </li>
     <li>
      <p>
       处理器适配器（HandlerAdapter）
      </p>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：由于处理器（Handler）的类型可能多种多样（不同的框架或自定义的处理器类型），HandlerAdapter 的作用是为 DispatcherServlet 提供一种统一的方式来调用不同类型的处理器。它负责适配处理器的调用方式，确保 DispatcherServlet 能够顺利调用处理器并获取处理结果。
       </li>
       <li>
        <strong>
         工作原理
        </strong>
        ：HandlerAdapter 会检查处理器的类型，然后调用相应的方法来执行处理器。例如，对于基于注解的控制器，它会调用控制器方法并传递请求参数，最后将处理器返回的 ModelAndView 对象传递给 DispatcherServlet。
       </li>
      </ul>
     </li>
     <li>
      <p>
       视图解析器（View Resolver）
      </p>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：根据处理器返回的逻辑视图名，解析出实际的视图对象（如 JSP 视图、Thymeleaf 视图等），并将模型数据填充到视图中，最终生成可供客户端显示的响应内容。
       </li>
       <li>
        <strong>
         工作原理
        </strong>
        ：常见的视图解析器如 InternalResourceViewResolver，它会根据配置的前缀和后缀，将逻辑视图名转换为实际的视图资源路径。例如，逻辑视图名 “userList”，在配置了前缀 “/WEB-INF/views/” 和后缀 “.jsp” 的情况下，会被解析为 “/WEB-INF/views/userList.jsp”，然后创建相应的视图对象并返回。
       </li>
      </ul>
     </li>
     <li>
      <p>
       视图（View）
      </p>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：负责将模型数据渲染成最终的响应结果，如生成 HTML 页面、JSON 数据、XML 数据等，然后将其返回给客户端进行显示。
       </li>
       <li>
        <strong>
         工作原理
        </strong>
        ：不同类型的视图（如 JSP 视图会使用 Java 代码和 HTML 标签结合的方式，Thymeleaf 视图使用模板引擎语法）根据模型数据和自身的渲染规则生成响应内容。例如，JSP 视图会将模型中的数据插入到 HTML 页面的相应位置，生成完整的 HTML 页面返回给客户端。
       </li>
      </ul>
     </li>
    </ol>
    <h2>
     <a id="SpringMVC_59">
     </a>
     SpringMVC返回值
    </h2>
    <h3>
     <a id="_String__61">
     </a>
     返回
     <code>
      String
     </code>
     类型
    </h3>
    <ul>
     <li>
      <strong>
       作为视图名称
      </strong>
      ：当返回值为
      <code>
       String
      </code>
      类型时，Spring MVC 通常会将其视为视图名称，结合视图解析器（如
      <code>
       InternalResourceViewResolver
      </code>
      ）来定位实际的视图资源。
     </li>
     <li>
      <strong>
       重定向和转发
      </strong>
      ：可以在返回的
      <code>
       String
      </code>
      中使用特殊前缀来实现重定向或转发。
     </li>
    </ul>
    <h4>
     <a id="_66">
     </a>
     重定向和转发
    </h4>
    <pre><code>@GetMapping("/forward2")
public String forward2() {
    System.out.println("-------forward2-------");
    return "forward:/test/responseEntityTest";
}

@GetMapping("/redirect2")
public String redirect2() {
    System.out.println("-------redirect2-------");
    return "redirect:/test/responseEntityTest";
}
</code></pre>
    <h3>
     <a id="_ModelAndView__82">
     </a>
     返回
     <code>
      ModelAndView
     </code>
     类型
    </h3>
    <p>
     <code>
      ModelAndView
     </code>
     可以同时包含视图名称和要传递给视图的数据，使用它能更灵活地设置视图和数据。
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ModelAndViewController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/modelAndViewTest"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">modelAndViewTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ModelAndView</span> modelAndView <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置视图名称</span>
        modelAndView<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">// 添加数据到模型</span>
        modelAndView<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span> <span class="token string">"这是通过 ModelAndView 传递的消息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_void__102">
     </a>
     返回
     <code>
      void
     </code>
     类型
    </h3>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoidReturnController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/voidTest"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voidTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     当控制器方法返回
     <code>
      void
     </code>
     时，Spring MVC 会根据请求的 URL 自动推断视图名称。若请求的 URL 为
     <code>
      /voidTest
     </code>
     ，Spring MVC 会尝试将视图名称解析为
     <code>
      voidTest
     </code>
     ，再结合视图解析器定位实际的视图资源。
    </p>
    <h3>
     <a id="_ResponseBody__117">
     </a>
     返回
     <code>
      @ResponseBody
     </code>
     修饰的对象
    </h3>
    <p>
     当控制器方法使用
     <code>
      @ResponseBody
     </code>
     注解时，返回的对象会被转换为特定格式的数据（通常是 JSON 或 XML）作为 HTTP 响应体返回给客户端。
    </p>
    <p>
     形式如下，@RestController = @Controller + @ResponseBody
    </p>
    <h3>
     <a id="_ResponseEntity__123">
     </a>
     返回
     <code>
      ResponseEntity
     </code>
     类型
    </h3>
    <p>
     <code>
      ResponseEntity
     </code>
     可用于更精细地控制 HTTP 响应，包括设置响应状态码、响应头和响应体。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ad2ca66063aa4bc4ac6295df40e4497e.png"/>
    </p>
    <pre><code>@RestController
@RequestMapping("/test")
public class TestController {
    @GetMapping("/responseEntityTest")
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; responseEntityTest() {
        Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
        data.put("message", "这是通过 ResponseEntity 返回的消息");
        // 创建 ResponseEntity 对象，设置响应状态码为 200 OK
        return new ResponseEntity&lt;&gt;(data, HttpStatus.OK);
    }
}
</code></pre>
    <h2>
     <a id="SpringMVC_144">
     </a>
     SpringMVC注解解析
    </h2>
    <h3>
     <a id="RequestMapping_146">
     </a>
     @RequestMapping
    </h3>
    <p>
     RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系
    </p>
    <p>
     RequestMapping注解可以作用在方法和类上
    </p>
    <ol>
     <li>
      作用在类上：第一级的访问目录
     </li>
     <li>
      作用在方法上：第二级的访问目录
     </li>
     <li>
      细节：路径可以不编写 / 表示应用的根目录开始
     </li>
    </ol>
    <p>
     RequestMapping的属性
    </p>
    <ol>
     <li>
      path 指定请求路径的url
     </li>
     <li>
      value value属性和path属性是一样的
     </li>
     <li>
      mthod 指定该方法的请求方式
     </li>
     <li>
      params 指定限制请求参数的条件
     </li>
    </ol>
    <p>
     <strong>
      示例：
     </strong>
    </p>
    <pre><code>@Controller
@RequestMapping(path = "/role")        // 一级请求路径
public class RoleController {

    /**
     * /role/save.do
     * method="当前方法允许请求方式能访问"
     * params="请求路径上传参数"
     * @return
     */
    @RequestMapping(path = "/save.do",method = {RequestMethod.GET},params = "username")
    public String save(){
        System.out.println("保存角色...");
        return "suc";
    }

    @RequestMapping(value = "/delete.do")
    public String delete(){
        System.out.println("删除角色...");
        return "suc";
    }

}

</code></pre>
    <h3>
     <a id="ResponseBody_192">
     </a>
     @ResponseBody
    </h3>
    <p>
     <code>
      @ResponseBody
     </code>
     是 Spring MVC 框架中的一个重要注解，主要用于将控制器方法返回的对象直接写入 HTTP 响应体中，而不是将其解析为视图名称来渲染视图。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        将对象转换为 JSON 或 XML
       </strong>
      </p>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span> <span class="token comment">// 相当于 @Controller + @ResponseBody</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/data"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       在上述代码中，getData 方法返回一个 Map 对象，由于使用了 @RestController（包含 @ResponseBody），Spring MVC 会将 Map 对象转换为 JSON 格式的字符串作为 HTTP 响应体返回给客户端
       <br/>
       {
       <!-- -->
       <br/>
       “name”: “John”,
       <br/>
       “age”: “30”
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       <strong>
        返回字符串
       </strong>
       ：如果返回的是字符串，
       <code>
        @ResponseBody
       </code>
       会直接将该字符串作为响应体返回，而不会去查找视图。
      </p>
     </li>
    </ul>
    <h3>
     <a id="RequestBody_221">
     </a>
     @RequestBody
    </h3>
    <p>
     <code>
      @RequestBody
     </code>
     注解用于指示 Spring MVC 框架将 HTTP 请求体中的内容直接绑定到方法的参数上。它会根据请求的
     <code>
      Content-Type
     </code>
     自动选择合适的消息转换器来将请求体中的数据反序列化为 Java 对象。常见的
     <code>
      Content-Type
     </code>
     包括
     <code>
      application/json
     </code>
     、
     <code>
      application/xml
     </code>
     等。
    </p>
    <p>
     总之，
     <code>
      @RequestBody
     </code>
     注解在 Spring MVC 中用于处理 HTTP 请求体中的数据，通过合适的消息转换器将数据反序列化为 Java 对象，方便开发者进行业务处理。
    </p>
    <ul>
     <li>
      <strong>
       处理 JSON 数据
      </strong>
      ：当客户端以 JSON 格式发送数据到服务器时，使用
      <code>
       @RequestBody
      </code>
      可以方便地将 JSON 数据转换为 Java 对象。
     </li>
     <li>
      <strong>
       处理 XML 数据
      </strong>
      ：类似地，当请求体为 XML 格式时，也可以使用
      <code>
       @RequestBody
      </code>
      将 XML 数据转换为 Java 对象。
     </li>
    </ul>
    <ol>
     <li>
      作用：用于获取请求体的内容（注意：get方法不可以）
     </li>
     <li>
      属性：required：是否必须有请求体，默认值是true
     </li>
    </ol>
    <pre><code class="prism language-json"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>
<span class="token comment">// 构造函数、toString方法重写,Getter和Setter方法</span>
<span class="token punctuation">}</span>
<span class="token comment">//可以使用 Postman 或其他工具发送一个 POST 请求到 `/users` 接口，请求体为 JSON 格式：</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"username"</span><span class="token operator">:</span> <span class="token string">"john_doe"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"password"</span><span class="token operator">:</span> <span class="token string">"123456"</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>测试<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
    @<span class="token function">PostMapping</span><span class="token punctuation">(</span><span class="token string">"/users"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token parameter">@RequestBody User user</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received user: "</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="PathVariable_252">
     </a>
     @PathVariable
    </h3>
    <p>
     <code>
      @PathVariable
     </code>
     ，这是 Spring MVC 中一个非常实用的注解，用于从 URL 的路径部分中提取变量值，并将其绑定到控制器方法的参数上。
    </p>
    <ol>
     <li>
      作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符
     </li>
     <li>
      属性：value：指定url中的占位符名称
     </li>
     <li>
      Restful风格的URL
      <ol>
       <li>
        请求路径一样，可以根据不同的请求方式去执行后台的不同方法
       </li>
       <li>
        restful风格的URL优点
        <ol>
         <li>
          结构清晰
         </li>
         <li>
          符合标准
         </li>
         <li>
          易于理解
         </li>
         <li>
          扩展方便
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code>@GetMapping("/articles/{year}/{month}/{articleId}")
public String getArticle(@PathVariable("year") int year,
                         @PathVariable("month") int month,
                         @PathVariable("articleId") String articleId) {
    System.out.println(year+""+month+""+articleId);
    return "suceess";
}
//请求url:http://localhost:8080/s1/rp/articles/2024/03/abc
</code></pre>
    <h3>
     <a id="RequestHeader_277">
     </a>
     @RequestHeader
    </h3>
    <p>
     在 Spring MVC 中，
     <code>
      @RequestHeader
     </code>
     注解用于将 HTTP 请求头中的值绑定到控制器方法的参数上。它允许你从请求头中提取特定的信息，如
     <code>
      User - Agent
     </code>
     、
     <code>
      Content - Type
     </code>
     、自定义请求头等，并将其作为方法参数传递，以便在方法内部进行处理。
    </p>
    <p>
     <strong>
      注解属性
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        name
       </code>
       或
       <code>
        value
       </code>
      </strong>
      ：指定要获取的请求头的名称。
     </li>
     <li>
      <strong>
       <code>
        required
       </code>
      </strong>
      ：表示该请求头是否为必需项，默认值为
      <code>
       true
      </code>
      。如果设置为
      <code>
       true
      </code>
      ，而请求中没有该请求头，会抛出
      <code>
       HttpMessageNotReadableException
      </code>
      异常；若设置为
      <code>
       false
      </code>
      ，当请求中不存在该请求头时，参数会被赋值为
      <code>
       null
      </code>
      。
     </li>
     <li>
      <strong>
       <code>
        defaultValue
       </code>
      </strong>
      ：当请求中不存在指定的请求头时，使用该默认值。
     </li>
    </ul>
    <pre><code>@GetMapping("/getUserAgent")
public String getUserAgent(@RequestHeader("User-Agent") String userAgent) {
    System.out.println(userAgent);
    return "suceess";
}

Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5a5ab0a049994011ac259f761dc00d65.png"/>
    </p>
    <h3>
     <a id="CookieValue_300">
     </a>
     @CookieValue
    </h3>
    <p>
     在 Spring MVC 里，`` 注解的主要作用是把 HTTP 请求中的 Cookie 值绑定到控制器方法的参数上。借助这个注解，你能够方便地从请求的 Cookie 里提取特定 Cookie 的值，进而在控制器方法里使用这些值开展业务逻辑处理。
    </p>
    <p>
     <strong>
      注解属性
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        name
       </code>
       或
       <code>
        value
       </code>
      </strong>
      ：此属性用于指定要获取的 Cookie 的名称。
     </li>
     <li>
      <strong>
       <code>
        required
       </code>
      </strong>
      ：它是一个布尔类型的属性，默认值为
      <code>
       true
      </code>
      。当设置为
      <code>
       true
      </code>
      时，意味着请求中必须包含指定名称的 Cookie，若不包含，就会抛出
      <code>
       HttpStatus 400 Bad Request
      </code>
      异常；当设置为
      <code>
       false
      </code>
      时，请求中可以不包含该 Cookie。
     </li>
     <li>
      <strong>
       <code>
        defaultValue
       </code>
      </strong>
      ：当
      <code>
       required
      </code>
      设置为
      <code>
       false
      </code>
      且请求中不存在指定名称的 Cookie 时，会使用该默认值来给方法参数赋值。
     </li>
    </ul>
    <pre><code>@GetMapping("/getSessionId")
public String getSessionId(@CookieValue(name = "sessionId",defaultValue = "hhhh") String sessionId) {
    System.out.println(sessionId);
    return "suceess";
}
</code></pre>
    <h2>
     <a id="_318">
     </a>
     请求参数绑定
    </h2>
    <h3>
     <a id="_URL__320">
     </a>
     基于 URL 查询参数的绑定
    </h3>
    <p>
     当 HTTP 请求的 URL 中包含查询参数时，Spring MVC 可以自动将这些参数绑定到控制器方法的同名参数上。
    </p>
    <p>
     可以通过设置
     <code>
      @RequestParam
     </code>
     的
     <code>
      required
     </code>
     属性为
     <code>
      false
     </code>
     来指定参数为可选的，并使用
     <code>
      defaultValue
     </code>
     属性设置默认值。
    </p>
    <pre><code>@GetMapping("/user")
public String getUser(@RequestParam String name, @RequestParam int age) {
    System.out.println(name+""+age);
    return "suceess";
}
//请求url:http://localhost:8080/s1/rp/user?name=luxiya&amp;age=19
</code></pre>
    <h3>
     <a id="_337">
     </a>
     基于表单参数的绑定
    </h3>
    <p>
     当客户端通过表单提交数据时，Spring MVC 可以将表单数据绑定到一个 Java 实体类上。
    </p>
    <pre><code>@RequestMapping("/save4.do")
public String save4(User user){
    System.out.println("user对象："+user);
    return "suceess";
}
------前端----------
&lt;form action="/s1/rp/save4.do" method="post"&gt;
    姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt;
    年龄：&lt;input type="text" name="age" /&gt;&lt;br/&gt;
    金额：&lt;input type="text" name="address.money" /&gt;&lt;br/&gt;
    集合：&lt;input type="text" name="list[0].money" /&gt;&lt;br/&gt;
    集合：&lt;input type="text" name="list[1].money" /&gt;&lt;br/&gt;
    &lt;input type="submit" value="提交" /&gt;
&lt;/form&gt;
</code></pre>
    <p>
     当客户端通过表单提交
     <code>
      name
     </code>
     和
     <code>
      age
     </code>
     字段时，Spring MVC 会自动将这些字段的值绑定到
     <code>
      User
     </code>
     对象的相应属性上。
    </p>
    <h3>
     <a id="RequestBody_360">
     </a>
     基于请求体的绑定@RequestBody(和表单绑定的区别)
    </h3>
    <p>
     使用
     <code>
      @RequestBody
     </code>
     注解可以将 HTTP 请求体中的数据绑定到控制器方法的参数上，常用于处理 JSON 或 XML 格式的数据。
    </p>
    <h4>
     <a id="_366">
     </a>
     区别
    </h4>
    <p>
     @RequestBody基于请求体的绑定
    </p>
    <ul>
     <li>
      适用于处理复杂的数据结构，特别是需要传递大量数据或嵌套数据的场景。JSON 和 XML 等格式可以很好地表示复杂的对象层次结构，因此使用
      <code>
       @RequestBody
      </code>
      可以方便地处理这些数据。
     </li>
     <li>
      常用于前后端分离的项目中，前端使用 JavaScript 发送 AJAX 请求，将数据以 JSON 格式封装在请求体中发送给后端。
     </li>
     <li>
      此方法使用了
      <code>
       @RequestBody
      </code>
      注解，这表明它期望从 HTTP 请求体中获取数据。通常，请求体的数据格式可以是 JSON、XML 等。
     </li>
     <li>
      将请求体中的数据反序列化为 JAVA 对象。
     </li>
     <li>
      由于依赖请求体中的数据，需要正确设置请求头的
      <code>
       Content - Type
      </code>
      。如果请求体是 JSON 格式，
      <code>
       Content - Type
      </code>
      应该设置为
      <code>
       application/json
      </code>
      ；如果是 XML 格式，
      <code>
       Content - Type
      </code>
      应该设置为
      <code>
       application/xml
      </code>
      。如果
      <code>
       Content - Type
      </code>
      设置不正确，Spring MVC 可能无法找到合适的消息转换器来处理请求体数据，从而抛出异常。
     </li>
    </ul>
    <p>
     无@RequestBody表单绑定
    </p>
    <ul>
     <li>
      适用于简单的表单提交场景，例如传统的 HTML 表单提交。用户在表单中填写数据，点击提交按钮后，表单数据会以表单编码的形式发送到服务器。
     </li>
     <li>
      对于一些简单的业务逻辑，使用表单数据或查询参数进行数据传递更加方便和直观。
     </li>
     <li>
      没有使用
      <code>
       @RequestBody
      </code>
      注解，Spring MVC 默认会从请求的表单数据或 URL 查询参数中获取数据。
     </li>
    </ul>
    <h3>
     <a id="Cookie_382">
     </a>
     基于路径变量/请求头/Cookie的绑定
    </h3>
    <p>
     就是上文@PathVariable,@RequestHeader,@CookieValue的使用。
    </p>
    <p>
     使用
     <code>
      @PathVariable
     </code>
     注解可以将 URL 路径中的变量绑定到控制器方法的参数上，常用于 RESTful API 设计。
    </p>
    <p>
     使用
     <code>
      @RequestHeader
     </code>
     注解可以将 HTTP 请求头中的值绑定到控制器方法的参数上。
    </p>
    <p>
     使用
     <code>
      @CookieValue
     </code>
     注解可以将 HTTP 请求中的 Cookie 值绑定到控制器方法的参数上。
    </p>
    <h2>
     <a id="SpringMVC_392">
     </a>
     SpringMVC异常处理
    </h2>
    <h3>
     <a id="_394">
     </a>
     异常处理思路
    </h3>
    <p>
     Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进行异常的处理。
    </p>
    <p>
     核心接口为
     <code>
      HandlerExceptionResolver
     </code>
     。其核心价值在于：
    </p>
    <ol>
     <li>
      <strong>
       统一管理
      </strong>
      ：避免分散的
      <code>
       try-catch
      </code>
      代码，集中处理控制器层异常。
     </li>
     <li>
      <strong>
       解耦业务逻辑
      </strong>
      ：将错误处理从业务代码中剥离，提升代码可读性。
     </li>
     <li>
      <strong>
       灵活响应
      </strong>
      ：支持动态返回JSON、HTML页面或自定义协议数据。
     </li>
    </ol>
    <h3>
     <a id="HandlerExceptionResolver_404">
     </a>
     HandlerExceptionResolver
    </h3>
    <p>
     <code>
      HandlerExceptionResolver
     </code>
     是 SpringMVC 提供的一个接口，用于自定义异常处理逻辑。可以实现该接口，并将其注册到 SpringMVC 中，以处理异常。
    </p>
    <p>
     <strong>
      执行流程：
     </strong>
    </p>
    <ol>
     <li>
      <code>
       DispatcherServlet
      </code>
      捕获到异常后，会依次调用已注册的
      <code>
       HandlerExceptionResolver
      </code>
      实现类的
      <code>
       resolveException
      </code>
      方法，尝试处理异常。
     </li>
     <li>
      如果某个
      <code>
       HandlerExceptionResolver
      </code>
      成功处理了异常，返回一个非
      <code>
       null
      </code>
      的
      <code>
       ModelAndView
      </code>
      对象，
      <code>
       DispatcherServlet
      </code>
      会使用该
      <code>
       ModelAndView
      </code>
      进行视图渲染；如果所有的
      <code>
       HandlerExceptionResolver
      </code>
      都无法处理异常，
      <code>
       DispatcherServlet
      </code>
      会将异常继续抛出。
     </li>
    </ol>
    <pre><code>-----------------自定义异常类--------------
public class SysException extends Exception{
    // 提示消息
    private String message;
    @Override
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    public SysException(String message) {
        this.message = message;
    }
}
-------------注册异常处理器-----------
@Component
public class SysExceptionResolver implements HandlerExceptionResolver {
    /**
     * 程序出现了异常，调用异常处理器中的方法
     * @param o
     * @param e
     * @return
     */
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object o, Exception e) {
        // 在控制台打印异常的信息
        e.printStackTrace();
        // 做强转
        SysException exception = null;
        // 判断
        if(e instanceof SysException){
            exception = (SysException)e;
        }else{
            exception = new SysException("系统正在维护，请联系管理员");
        }
        // 存入异常提示信息
        ModelAndView mv = new ModelAndView();
        mv.addObject("errorMsg",e.getMessage());
        // 设置跳转的页面
        mv.setViewName("error");
        return mv;
    }
}
--------------测试方法-----------
@Controller
@RequestMapping("/error")
public class ErrorController {
    @RequestMapping("/test")
    public String test() {
        int i = 1 / 0;
        return "success";
    }
}
---------error.jsp页面----------
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;错误提示页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;错误的友好提示页面&lt;/h3&gt;
${errorMsg}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <h3>
     <a id="SimpleMappingExceptionResolver_481">
     </a>
     SimpleMappingExceptionResolver
    </h3>
    <p>
     <code>
      SimpleMappingExceptionResolver
     </code>
     的核心原理是通过配置异常类与视图名称之间的映射关系，当控制器方法抛出异常时，它会根据异常类型查找对应的视图名称，并将请求转发到该视图页面进行错误信息的展示。
    </p>
    <p>
     在 Spring MVC 的 XML 配置文件中，可以通过以下方式配置
     <code>
      SimpleMappingExceptionResolver
     </code>
     ：
    </p>
    <pre><code>&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;
    &lt;!-- 定义异常类与视图名称的映射 --&gt;
    &lt;property name="exceptionMappings"&gt;
        &lt;props&gt;
            &lt;!-- 当抛出 java.lang.Exception 异常时，跳转到 error 视图 --&gt;
            &lt;prop key="java.lang.Exception"&gt;error&lt;/prop&gt; 
            &lt;!-- 当抛出 java.lang.RuntimeException 异常时，跳转到 runtimeError 视图 --&gt;
            &lt;prop key="java.lang.RuntimeException"&gt;runtimeError&lt;/prop&gt; 
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- 默认的错误视图名称，当没有匹配的异常映射时使用 --&gt;
    &lt;property name="defaultErrorView" value="defaultError"/&gt; 
    &lt;!-- 异常属性名，将异常对象存储在请求域中，可在视图中通过该属性名获取异常信息 --&gt;
    &lt;property name="exceptionAttribute" value="ex"/&gt; 
&lt;/bean&gt;
</code></pre>
    <h3>
     <a id="ExceptionHandler_505">
     </a>
     @ExceptionHandler
    </h3>
    <p>
     <code>
      @ExceptionHandler
     </code>
     注解用于处理控制器方法中抛出的特定异常。可以在控制器类中定义一个方法，并使用该注解来捕获和处理指定类型的异常。
    </p>
    <pre><code>@Controller
@RequestMapping("/error")
public class ErrorController {
    @RequestMapping("/test")
    public String test() {
        int i = 1 / 0;
        return "success";
    }
    @ExceptionHandler(Exception.class)
    public ModelAndView error(Exception e) {
        e.printStackTrace();
        System.out.println("error----ExceptionHandler");

        // 创建 ModelAndView 对象
        ModelAndView modelAndView = new ModelAndView();
        // 设置要跳转的视图名称
        modelAndView.setViewName("error");
        // 添加异常信息到模型中，键名为 errorMsg
        modelAndView.addObject("errorMsg", e.getMessage());
        return modelAndView;
    }
}
</code></pre>
    <h3>
     <a id="ControllerAdvice_534">
     </a>
     @ControllerAdvice
    </h3>
    <p>
     <code>
      @ControllerAdvice
     </code>
     注解用于定义全局异常处理器，它可以处理所有控制器中抛出的异常。结合
     <code>
      @ExceptionHandler
     </code>
     注解，可以实现统一的异常处理逻辑。
    </p>
    <pre><code>@ControllerAdvice
public class GlobalExceptionHandler {

    // 处理所有类型的异常
    @ExceptionHandler(Exception.class)
    public ModelAndView error(Exception e) {
        // 创建 ModelAndView 对象
        ModelAndView modelAndView = new ModelAndView();
        // 设置要跳转的视图名称
        modelAndView.setViewName("error");
        // 添加异常信息到模型中，键名为 errorMsg
        modelAndView.addObject("errorMsg", e.getMessage());
        return modelAndView;
    }
}
</code></pre>
    <h2>
     <a id="SpringMVC_558">
     </a>
     SpringMVC框架中的拦截器
    </h2>
    <h3>
     <a id="_560">
     </a>
     拦截器的概述
    </h3>
    <ol>
     <li>
      SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。
     </li>
     <li>
      可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。
     </li>
     <li>
      拦截器和过滤器的功能比较类似，有区别
      <ol>
       <li>
        过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。
       </li>
       <li>
        拦截器是SpringMVC框架独有的。
       </li>
       <li>
        过滤器配置了/*，可以拦截任何资源。
       </li>
       <li>
        拦截器只会对控制器中的方法进行拦截。
       </li>
      </ol>
     </li>
     <li>
      拦截器也是AOP思想的一种实现方式
     </li>
     <li>
      想要自定义拦截器，需要实现HandlerInterceptor接口。
     </li>
    </ol>
    <pre><code>/**
 * 测试拦截器
 * @return
 */
@RequestMapping("/test2")
public String test2() {
    System.out.println("controller 执行了");
    return "suceess";
}
------springMVC的xml文件配置
    &lt;mvc:interceptors&gt;
        &lt;!--配置拦截器--&gt;
        &lt;mvc:interceptor&gt;
            &lt;!--哪些资源需要拦截--&gt;
            &lt;mvc:mapping path="/error/**"/&gt;
            &lt;!--哪些资源不想拦截--&gt;
&lt;!--            &lt;mvc:exclude-mapping path=""/&gt;--&gt;
            &lt;!--拦截器器对象--&gt;
            &lt;bean class="com.luxiya.study_01.controller.MyInterceptor"/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
    <h3>
     <a id="_596">
     </a>
     配置多个拦截器
    </h3>
    <p>
     再定义一个拦截器MyInterceptor2。
    </p>
    <p>
     当配置了多个拦截器时，它们的执行顺序遵循以下规则：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        preHandle
       </code>
       方法
      </strong>
      ：按照拦截器注册的顺序依次执行。
     </li>
     <li>
      <strong>
       <code>
        postHandle
       </code>
       方法
      </strong>
      ：按照拦截器注册顺序的逆序执行。
     </li>
     <li>
      <strong>
       <code>
        afterCompletion
       </code>
       方法
      </strong>
      ：按照拦截器注册顺序的逆序执行。
     </li>
    </ul>
    <pre><code>    &lt;mvc:interceptors&gt;
        &lt;!--配置拦截器--&gt;
        &lt;mvc:interceptor&gt;
            &lt;!--哪些资源需要拦截--&gt;
            &lt;mvc:mapping path="/error/**"/&gt;
            &lt;!--哪些资源不想拦截--&gt;
&lt;!--            &lt;mvc:exclude-mapping path=""/&gt;--&gt;
            &lt;!--拦截器器对象--&gt;
            &lt;bean class="com.luxiya.study_01.controller.MyInterceptor"/&gt;
        &lt;/mvc:interceptor&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path="/error/**"/&gt;
            &lt;bean class="com.luxiya.study_01.controller.MyInterceptor2"/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
    <h3>
     <a id="_624">
     </a>
     拦截器与过滤器的区别
    </h3>
    <ul>
     <li>
      <strong>
       使用范围
      </strong>
      ：过滤器是 Servlet 规范中的一部分，适用于所有的 Web 应用；而拦截器是 SpringMVC 框架中的一部分，仅适用于 SpringMVC 应用。
     </li>
     <li>
      <strong>
       拦截范围
      </strong>
      ：过滤器可以拦截所有的请求，包括静态资源请求；而拦截器只能拦截 SpringMVC 处理的请求，即通过
      <code>
       DispatcherServlet
      </code>
      处理的请求。
     </li>
     <li>
      <strong>
       实现机制
      </strong>
      ：过滤器基于函数回调实现，而拦截器基于 Java 的反射机制实现。
     </li>
     <li>
      拦截器的功能更为强大，它可以访问 Spring 容器中的 Bean，而过滤器无法直接访问 Spring 容器。
     </li>
    </ul>
    <h2>
     <a id="_633">
     </a>
     配置文件
    </h2>
    <h3>
     <a id="_635">
     </a>
     概述
    </h3>
    <ul>
     <li>
      <strong>
       <code>
        &lt;mvc:annotation-driven/&gt;
       </code>
      </strong>
      ：开启 Spring MVC 的注解支持，使得可以使用
      <code>
       @Controller
      </code>
      、
      <code>
       @RequestMapping
      </code>
      等注解。
     </li>
     <li>
      <strong>
       <code>
        &lt;context:component-scan&gt;
       </code>
      </strong>
      ：指定 Spring 扫描组件的基础包，Spring 会自动扫描该包及其子包下带有
      <code>
       @Controller
      </code>
      、
      <code>
       @Service
      </code>
      等注解的类，并将其注册为 Spring Bean。
     </li>
     <li>
      <strong>
       <code>
        InternalResourceViewResolver
       </code>
      </strong>
      ：配置视图解析器，用于将控制器返回的视图名称解析为实际的视图资源。
      <code>
       prefix
      </code>
      和
      <code>
       suffix
      </code>
      分别指定视图文件的前缀和后缀。
     </li>
     <li>
      <strong>
       <code>
        &lt;mvc:resources&gt;
       </code>
      </strong>
      ：配置静态资源处理，指定静态资源的映射路径和实际存储位置。
     </li>
     <li>
      <strong>
       <code>
        &lt;mvc:interceptors&gt;
       </code>
      </strong>
      ：配置拦截器，
      <code>
       mvc:mapping
      </code>
      指定拦截的路径，
      <code>
       mvc:exclude-mapping
      </code>
      指定排除的路径，
      <code>
       bean
      </code>
      指定拦截器的实现类。
     </li>
    </ul>
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;!--扫描控制器--&gt;
    &lt;context:component-scan base-package="com.luxiya.study_01.controller"/&gt;
    &lt;!--开启注解扫描--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!--配置视图解析器--&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/pages/"/&gt;
        &lt;property name="suffix" value=".jsp"/&gt;
    &lt;/bean&gt;

    &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;
        &lt;property name="exceptionMappings"&gt;
            &lt;props&gt;
                &lt;prop key="java.lang.ArithmeticException"&gt;error&lt;/prop&gt;

            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;mvc:interceptors&gt;
        &lt;!--配置拦截器--&gt;
        &lt;mvc:interceptor&gt;
            &lt;!--哪些资源需要拦截--&gt;
            &lt;mvc:mapping path="/error/**"/&gt;
            &lt;!--哪些资源不想拦截--&gt;
&lt;!--            &lt;mvc:exclude-mapping path=""/&gt;--&gt;
            &lt;!--拦截器器对象--&gt;
            &lt;bean class="com.luxiya.study_01.controller.MyInterceptor"/&gt;
        &lt;/mvc:interceptor&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path="/error/**"/&gt;
            &lt;bean class="com.luxiya.study_01.controller.MyInterceptor2"/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/beans&gt;
</code></pre>
    <h3>
     <a id="_692">
     </a>
     静态资源处理
    </h3>
    <p>
     DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置
    </p>
    <p>
     标签配置不过滤
    </p>
    <ol>
     <li>
      location元素表示webapp目录下的包下的所有文件
     </li>
     <li>
      mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b
     </li>
    </ol>
    <pre><code>    &lt;!-- 设置静态资源不过滤 --&gt;
    &lt;mvc:resources location="/css/" mapping="/css/**"/&gt;  &lt;!-- 样式 --&gt;
    &lt;mvc:resources location="/images/" mapping="/images/**"/&gt;  &lt;!-- 图片 --&gt;
    &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;  &lt;!-- javascript --&gt;
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f38303233363437352f:61727469636c652f64657461696c732f313436313836353036" class_="artid" style="display:none">
 </p>
</div>


