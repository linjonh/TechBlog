---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303232303630372f:61727469636c652f64657461696c732f313433383135303431"
layout: post
title: "Linux探索学习第十六弹进程地址空间深入解析操作系统中的进程地址空间"
date: 2024-11-25 20:39:47 +0800
description: "【Linux探索学习】第十六弹：进程地址空间：进程地址空间是操作系统内存管理的核心概念，帮助我们理解"
keywords: "linux 查看地址空间"
categories: ['Linux']
tags: ['运维', '学习', 'Linux']
artid: "143815041"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=143815041
    alt: "Linux探索学习第十六弹进程地址空间深入解析操作系统中的进程地址空间"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=143815041
featuredImagePreview: https://bing.ee123.net/img/rand?artid=143815041
---

# 【Linux探索学习】第十六弹——进程地址空间：深入解析操作系统中的进程地址空间

**Linux学习笔记：**

[https://blog.csdn.net/2301\_80220607/category\_12805278.html?spm=1001.2014.3001.5482](https://blog.csdn.net/2301_80220607/category_12805278.html?spm=1001.2014.3001.5482 "https://blog.csdn.net/2301_80220607/category_12805278.html?spm=1001.2014.3001.5482")

**前言：**

> 进程地址空间是操作系统进程管理的重要概念之一，它定义了进程在执行时所能访问的内存布局。理解进程地址空间不仅有助于掌握操作系统的运行原理，也为程序优化、内存管理和调试等实践提供了理论支持。本文将从地址空间的基本概念入手，详细讲解其结构、特点，以及Linux系统中的具体实现，辅以表格和代码示例帮助加深理解。

---

**目录**

[一、什么是进程地址空间？](#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%9F)

[1.1 进程地址空间的特点](#1.1%20%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E7%89%B9%E7%82%B9)

[二、进程地址空间的结构](#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%93%E6%9E%84)

[2.1 地址空间布局图](#2.1%20%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%9B%BE)

[三、各段的详细说明](#%E4%B8%89%E3%80%81%E5%90%84%E6%AE%B5%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E)

[3.1 代码段](#3.1%20%E4%BB%A3%E7%A0%81%E6%AE%B5)

[3.2 数据段](#3.2%20%E6%95%B0%E6%8D%AE%E6%AE%B5)

[3.3 BSS段](#3.3%20BSS%E6%AE%B5)

[3.4 堆（Heap）](#3.4%20%E5%A0%86%EF%BC%88Heap%EF%BC%89)

[3.5 栈（Stack）](#3.5%20%E6%A0%88%EF%BC%88Stack%EF%BC%89)

[四、Linux进程地址空间实现](#%E5%9B%9B%E3%80%81Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AE%9E%E7%8E%B0)

[4.1 虚拟内存与地址映射](#4.1%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84)

[4.2 /proc/[pid]/maps查看地址空间](#4.2%20%2Fproc%2F%5Bpid%5D%2Fmaps%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)

[示例](#%E7%A4%BA%E4%BE%8B)

[4.3 C代码示例：进程地址空间](#4.3%20C%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)

[输出示例](#%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B)

[五、内核空间与用户空间](#%E4%BA%94%E3%80%81%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4)

[六、进程地址空间常见问题](#%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)

[6.1 栈溢出](#6.1%20%E6%A0%88%E6%BA%A2%E5%87%BA)

[6.2 内存泄漏](#6.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)

[6.3 地址冲突](#6.3%20%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81)

[七、总结](#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93)

---

### 一、什么是进程地址空间？

进程地址空间是操作系统为每个进程分配的一块独立的虚拟地址范围，用于存储程序代码、数据和栈等运行所需的内容。操作系统通过虚拟内存技术，使每个进程拥有一个独立的地址空间，与物理内存隔离。

#### 1.1 进程地址空间的特点

> 1. **虚拟化**
>    ：每个进程的地址空间是独立的虚拟地址，互不干扰。
> 2. **隔离性**
>    ：一个进程不能直接访问另一个进程的地址空间，提供了安全性。
> 3. **统一性**
>    ：操作系统通过页表将虚拟地址映射到物理地址，对用户透明。

---

### 二、进程地址空间的结构

操作系统将进程地址空间划分为多个区域，每个区域用于存储特定类型的数据。以下是典型的地址空间布局：

| 地址区域 | 描述 |
| --- | --- |
| **代码段** | 存储可执行代码的指令。只读，通常不可修改。 |
| **数据段** | 存储已初始化的全局变量和静态变量。 |
| **BSS段** | 存储未初始化的全局变量和静态变量。 |
| **堆（Heap）** | 动态分配的内存区域（如 `malloc` 分配的内存）。向高地址增长。 |
| **栈（Stack）** | 函数调用相关的局部变量、返回地址等。向低地址增长。 |
| **内核空间** | 操作系统内核相关的代码和数据。用户态无法直接访问。 |

#### 

#### 2.1 地址空间布局图

以32位操作系统为例，地址空间布局如下：

```cpp
+---------------------------+  0xFFFFFFFF
| 内核空间                  |  
+---------------------------+  0xC0000000
| 用户栈                    |
+---------------------------+
| 动态分配的堆（Heap）      |
+---------------------------+
| BSS段                    |
+---------------------------+
| 数据段                    |
+---------------------------+
| 代码段                    |
+---------------------------+  0x00000000

```

### 三、各段的详细说明

#### 3.1 代码段

> * **存储内容**
>   ：存放程序的可执行代码。
> * **访问权限**
>   ：只读，防止程序意外修改指令。
> * **特点**
>   ：多个进程可以共享同一段代码段（如共享库）。

#### 3.2 数据段

> * **存储内容**
>   ：存储已初始化的全局变量和静态变量。
> * **访问权限**
>   ：读写权限。
> * **特点**
>   ：程序运行时大小固定。

#### 3.3 BSS段

> * **存储内容**
>   ：存储未初始化的全局变量和静态变量。
> * **特点**
>   ：初始值默认为0，占用物理内存时才分配。

#### 3.4 堆（Heap）

> * **存储内容**
>   ：动态分配的内存（如
>   `malloc`
>   、
>   `new`
>   分配的内存）。
> * **特点**
>   ：向高地址增长；由程序员手动分配和释放。

#### 3.5 栈（Stack）

> * **存储内容**
>   ：局部变量、函数调用参数、返回地址等。
> * **特点**
>   ：向低地址增长；由操作系统自动管理，超出范围会触发栈溢出。

上面的几种是主要的几种，还有几个小的内存区，比如字符段常量区，字符常量区的内容不能修改，只有读权限

---

### 四、Linux进程地址空间实现

#### 4.1 虚拟内存与地址映射

Linux使用虚拟内存技术，将进程的虚拟地址空间映射到物理内存。内核通过页表实现虚拟地址到物理地址的映射。

> * **虚拟地址**
>   ：由程序访问的地址。
> * **物理地址**
>   ：内存硬件实际使用的地址。
> * **页表**
>   ：存储虚拟地址到物理地址的映射关系。

这里我们重点讲解一下，此前在我们讲解父子进程时我们曾遗留了一个问题，那就是为什么

```cpp
pid_t id = fork();
```

中id能有两个值，为什么同一个地址空间下能有两个值呢？其实这就已经能说明这个地址并不是物理地址了，这个地址其实是虚拟地址，它与物理地址通过页表是存在某种对应关系的，即页表，子进程是对父进程的拷贝，但是当他的数据发生改动与父进程不同的时候就会发生写时拷贝，不会对父进程造成影响

![](https://i-blog.csdnimg.cn/direct/71f3ba0e8707485cb967db215352a744.png)

我们还需要重点讲解一下上面页表的问题，页表是存放在CPU一个叫cr3的寄存器中的，它是属于进程上下文的一部分，所以进程切换时会将它带走，不用担心找不到，页表的地址是物理地址

![](https://i-blog.csdnimg.cn/direct/f3c98c096d05480a95ea5ee2ae9aa14d.png)

同时我们在用页表查找相对应的物理地址时，有些物理地址是有权限限制的，比如只可读不可写，页表就可以通过标识符来告诉我们，如果我们要强行写入的话页表就会发现这个问题并干掉进程，所以页表也能起到很好的管理进程的作用

此外页表除了这种标识符外还有一种告知进程代码数据是否写入内存中去的标识符，比如我们前面讲过进程在处于挂起状态时代码和数据是没有往内存中存的，那么当进程重启时我们需要知道我们的代码和数据是否在挂起前已经存入内存中去了，页表中就存在这种标识符来告诉进程数据是否已经在内存中了，如果不在就需要先在内存中开辟空间存入数据后进程才能继续运行

---

#### 4.2 `/proc/[pid]/maps` 查看地址空间

在Linux系统中，可以通过
`/proc/[pid]/maps`
文件查看进程的地址空间布局。

##### 示例

运行以下命令查看当前Shell进程的地址空间：

```cpp
cat /proc/$$/maps

```

输出示例：

```cpp
00400000-0040c000 r-xp 00000000 08:01 123456 /bin/bash
0060b000-0060c000 r--p 0000b000 08:01 123456 /bin/bash
0060c000-0060d000 rw-p 0000c000 08:01 123456 /bin/bash
7fff5c123000-7fff5c144000 rw-p 00000000 00:00 0  [stack]
7ffff7dd8000-7ffff7dfa000 r-xp 00000000 08:01 654321 /lib/libc.so.6
...

```

* 每一行表示地址空间的一段。
* 第一列是起始和结束地址，最后一列是内存映射的文件（如可执行文件、共享库）。

---

#### 4.3 C代码示例：进程地址空间

以下代码展示了不同段的地址空间位置。

```cpp
#include <stdio.h>
#include <stdlib.h>

int global_var = 10;  // 全局变量（数据段）
int uninit_var;       // 未初始化变量（BSS段）

void print_addresses() {
    int local_var = 20;  // 局部变量（栈）
    void *heap_var = malloc(10);  // 动态内存（堆）

    printf("代码段地址: %p\n", (void*)print_addresses);
    printf("全局变量地址: %p\n", (void*)&global_var);
    printf("未初始化全局变量地址: %p\n", (void*)&uninit_var);
    printf("局部变量地址: %p\n", (void*)&local_var);
    printf("堆变量地址: %p\n", heap_var);

    free(heap_var);
}

int main() {
    print_addresses();
    return 0;
}

```

##### 输出示例

```cpp
代码段地址: 0x401000
全局变量地址: 0x601020
未初始化全局变量地址: 0x601030
局部变量地址: 0x7ffd25d3f8bc
堆变量地址: 0x55d3ecf1b260

```

![](https://i-blog.csdnimg.cn/direct/db530186620743e09299be063d6d2f7e.png)

---

### 五、内核空间与用户空间

Linux将地址空间划分为用户空间和内核空间：

| 空间 | 描述 |
| --- | --- |
| 用户空间 | 用于运行用户程序（如Shell、文本编辑器等）。 |
| 内核空间 | 用于运行操作系统内核代码，存储内核数据结构，用户进程无法直接访问。 |

在32位系统中，通常用户空间占用地址的低3GB，内核空间占用地址的高1GB。

---

### 六、进程地址空间常见问题

#### 6.1 栈溢出

> **原因**
> ：递归调用过深或局部变量占用过多内存，导致栈空间耗尽。
>
> **解决**
> ：优化递归深度，增大栈大小（通过
> `ulimit -s`
> 命令）。

---

#### 6.2 内存泄漏

> **原因**
> ：堆内存分配后未释放。
>
> **解决**
> ：通过工具（如
> `valgrind`
> ）检测内存泄漏，确保分配的内存及时释放。

---

#### 6.3 地址冲突

> **原因**
> ：动态加载的库与程序内存分布冲突。
>
> **解决**
> ：使用
> `ld`
> 指定加载地址，避免冲突。

---

### 七、总结

> 进程地址空间是操作系统管理内存的核心概念，通过将地址空间划分为代码段、数据段、堆、栈等区域，提供了独立的运行环境。Linux通过虚拟内存技术实现了地址空间的隔离和映射。通过本文的理论分析与代码示例，相信你对进程地址空间的布局与实现有了更加深入的理解。
>
> 理解进程地址空间不仅是操作系统学习的基础，也对程序优化、内存调试等实际问题的解决具有重要意义。

**本章节笔记：**

![](https://i-blog.csdnimg.cn/direct/518e04a93feb48a699c9cabe5abbae68.png)

---

> **感谢各位大佬观看，创作不易，还请各位大佬点赞支持！！！**