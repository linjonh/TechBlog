---
layout: post
title: "java中实体类常见的设计模式"
date: 2025-03-06 22:19:54 +0800
description: "虽然使用了 Set 链式编程、构建者设计模式 能更方便快捷的实现一个类，但是也产生了与 Lombok 之间的冲突，导致不能直接使用类似@Data等注解生成一些方法，但这个问题总的来说，是可以忽略的。毕竟鱼和熊掌不可兼得，合适的场景使用合适的方法即可。"
keywords: "java中实体类常见的设计模式"
categories: ['设计模式']
tags: ['设计模式', 'Java']
artid: "146081739"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146081739
    alt: "java中实体类常见的设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146081739
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146081739
cover: https://bing.ee123.net/img/rand?artid=146081739
image: https://bing.ee123.net/img/rand?artid=146081739
img: https://bing.ee123.net/img/rand?artid=146081739
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java中实体类常见的设计模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     实体类常见的设计模式
    </h2>
    <h3>
     <a id="1_Set__2">
     </a>
     1. Set 链式编程
    </h3>
    <p>
     在实体类中实现链式调用通常是指让 setter 方法
     <strong>
      返回当前对象实例
     </strong>
     （
     <code>
      this
     </code>
     ），从而
     <strong>
      允许连续调用多个 setter 方法
     </strong>
     设置属性值。这种方式可以使代码更加简洁和直观。
    </p>
    <p>
     例如实体类为：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 返回当前实例以支持链式调用</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">"Person{name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"', age="</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token char">'}'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     使用：
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     这种方式非常适合那些属性不是很多，或者不强制要求所有属性都必须初始化的情况。
    </p>
    <blockquote>
     <p>
      可以使用
      <code>
       @Accessors(chain = true)
      </code>
      注解来自动启用链式调用（使用方式在后面）。
     </p>
    </blockquote>
    <h3>
     <a id="2__43">
     </a>
     2. 构建者设计模式
    </h3>
    <p>
     当一个类有很多属性，特别是有些是
     <em>
      可选
     </em>
     的时候，使用传统的构造函数或链式 setter 方法可能会导致代码冗长且不易维护。构建者设计模式通过分离对象的构造过程与表示来解决这个问题，使得创建复杂对象的过程更加清晰和灵活。
    </p>
    <p>
     例如实体类为：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

  <span class="token comment">// 私有构造函数，防止直接实例化</span>
  <span class="token keyword">private</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> builder<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> builder<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 返回当前 Builder 实例以支持链式调用</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 Builder 中的数据创建新的 Person 实例</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">"Person{name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"', age="</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token char">'}'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     使用：
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     构建者模式特别适用于
     <strong>
      需要构建的对象具有许多可选参数的情况
     </strong>
     。它不仅提高了代码的可读性，也避免了构造函数参数列表过长的问题。
    </p>
    <blockquote>
     <p>
      可以使用
      <code>
       @Builder
      </code>
      注解可以轻松实现构建者模式（使用方式在后面）。
     </p>
    </blockquote>
    <h3>
     <a id="3__102">
     </a>
     3. 其它
    </h3>
    <h4>
     <a id="31__Lombok__104">
     </a>
     3.1 两者与 Lombok 一同使用的问题
    </h4>
    <p>
     Lombok 是一个非常流行的 Java 库，它通过注解来减少样板代码，例如 getter、setter、构造函数等。然而，当你在同一个类中同时使用 Lombok 注解与手动实现的 Set 链式编程或构建者设计模式时，可能会遇到一些问题或冲突。
    </p>
    <ol>
     <li>
      <p>
       Set 链式编程与 Lombok
      </p>
      <p>
       如果你使用 Lombok 的
       <code>
        @Setter
       </code>
       注解，并尝试手动实现链式 setter 方法，可能会出现以下问题：
      </p>
      <ol>
       <li>
        方法重复
       </li>
       <li>
        不可预期的行为
       </li>
      </ol>
      <p>
       为了解决这个问题，你可以选择不使用 Lombok 的
       <code>
        @Setter
       </code>
       注解，而是完全手动编写所有需要的 setter 方法，或者利用 Lombok 的
       <code>
        @Accessors(chain = true)
       </code>
       注解来自动启用链式调用。例如：
      </p>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@Getter</span> <span class="token annotation punctuation">@Setter</span> <span class="token annotation punctuation">@Accessors</span><span class="token punctuation">(</span>chain <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       构建者设计模式与 Lombok
      </p>
      <p>
       Lombok 提供了对构建者模式的支持，通过
       <code>
        @Builder
       </code>
       注解可以轻松实现构建者模式，避免手动编写复杂的 Builder 类。但是，如果同时手动实现构建者模式和使用 Lombok 的
       <code>
        @Builder
       </code>
       注解，则可能会遇到类似的问题：
      </p>
      <ul>
       <li>
        代码冗余
       </li>
       <li>
        冲突
       </li>
      </ul>
      <p>
       为了避免这种情况，你应该选择一种方式来实现构建者模式。如果你希望利用 Lombok 简化代码，可以删除手动编写的 Builder 实现，转而使用 Lombok 的
       <code>
        @Builder
       </code>
       注解：
      </p>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@Getter</span>
<span class="token annotation punctuation">@Builder</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ol>
    <p>
     总之，在结合使用 Lombok 与自定义的 Set 链式编程或构建者设计模式时，关键是保持一致性并理解 Lombok 在背后所做的工作。通常情况下，推荐充分利用 Lombok 提供的相关注解来简化这些模式的实现，除非有特定的需求要求手动控制。这样做不仅可以减少出错的机会，还能让代码更加简洁易读。
    </p>
    <h4>
     <a id="32__Lombok__145">
     </a>
     3.2 又想方便编程、又想使用 Lombok 怎么做
    </h4>
    <ol>
     <li>
      <p>
       使用
       <code>
        @Accessors(chain = true)
       </code>
       和其他 Lombok 注解
      </p>
      <p>
       当你想为你的实体类启用链式 setter 方法同时又希望自动生成
       <code>
        toString
       </code>
       、
       <code>
        equals
       </code>
       和
       <code>
        hashCode
       </code>
       方法时，你可以这样做：
      </p>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@Getter</span> <span class="token annotation punctuation">@Setter</span> <span class="token annotation punctuation">@Accessors</span><span class="token punctuation">(</span>chain <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ToString</span>
<span class="token annotation punctuation">@EqualsAndHashCode</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       在这个例子中，
       <code>
        @Getter
       </code>
       和
       <code>
        @Setter
       </code>
       自动生成所有属性的 getter 和 setter 方法，
       <code>
        @Accessors(chain = true)
       </code>
       使得 setter 方法支持链式调用。
       <code>
        @ToString
       </code>
       自动生成
       <code>
        toString
       </code>
       方法，而
       <code>
        @EqualsAndHashCode
       </code>
       自动生成
       <code>
        equals
       </code>
       和
       <code>
        hashCode
       </code>
       方法。
      </p>
     </li>
     <li>
      <p>
       使用
       <code>
        @Builder
       </code>
       和其他 Lombok 注解
      </p>
      <p>
       如果你想使用构建者模式（通过
       <code>
        @Builder
       </code>
       注解），同时还需要
       <code>
        toString
       </code>
       、
       <code>
        equals
       </code>
       和
       <code>
        hashCode
       </code>
       方法，同样可以直接将这些注解添加到你的类上：
      </p>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@Getter</span> <span class="token comment">// 注意：通常与 @Builder 一起使用时不需要 @Setter，除非你确实需要setter方法</span>
<span class="token annotation punctuation">@Builder</span>
<span class="token annotation punctuation">@ToString</span>
<span class="token annotation punctuation">@EqualsAndHashCode</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       这里需要注意的是，通常当你使用
       <code>
        @Builder
       </code>
       时，你可能不会为所有字段提供 setter 方法（因为 Builder 模式本身提供了设置属性值的方法）。然而，如果你确实需要 setter 方法，你可以继续使用
       <code>
        @Setter
       </code>
       注解。
      </p>
     </li>
    </ol>
    <h4>
     <a id="33__182">
     </a>
     3.3 总结
    </h4>
    <p>
     虽然使用了 Set 链式编程、构建者设计模式 能更方便快捷的实现一个类，但是也产生了与 Lombok 之间的冲突，导致不能直接使用类似
     <code>
      @Data
     </code>
     等注解生成一些方法，但这个问题总的来说，是可以忽略的。
    </p>
    <p>
     毕竟鱼和熊掌不可兼得，合适的场景使用合适的方法即可。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333635363436312f:61727469636c652f64657461696c732f313436303831373339" class_="artid" style="display:none">
 </p>
</div>


