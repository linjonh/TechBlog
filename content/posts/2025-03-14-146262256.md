---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f6b616b615f62756b612f:61727469636c652f64657461696c732f313436323632323536"
layout: post
title: "Spring-Boot如何在业务项目中覆盖基础项目的默认实现"
date: 2025-03-14 17:19:19 +0800
description: "在 Spring Boot 项目中，我们通常会将一些通用的功能封装到基础项目（基础模块）中，而业务项目则依赖于这个基础项目。但是，实际开发过程中，业务项目可能需要自定义某些功能的实现，而不是直接使用基础项目提供的默认实现。"
keywords: "Spring Boot：如何在业务项目中覆盖基础项目的默认实现"
categories: ['Spring']
tags: ['后端', 'Spring', 'Python', 'Boot']
artid: "146262256"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146262256
    alt: "Spring-Boot如何在业务项目中覆盖基础项目的默认实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146262256
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146262256
cover: https://bing.ee123.net/img/rand?artid=146262256
image: https://bing.ee123.net/img/rand?artid=146262256
img: https://bing.ee123.net/img/rand?artid=146262256
---

# Spring Boot：如何在业务项目中覆盖基础项目的默认实现

## **Spring Boot：如何在业务项目中覆盖基础项目的默认实现**

在 Spring Boot 项目中，我们通常会将一些通用的功能封装到基础项目（基础模块）中，而业务项目则依赖于这个基础项目。但是，实际开发过程中，业务项目可能需要自定义某些功能的实现，而不是直接使用基础项目提供的默认实现。

本文将以
**`ExceptionNoticeService`**
为例，探讨如何在业务项目中重新实现基础项目提供的接口逻辑。

---

### **一. 场景分析**

假设我们在基础项目中定义了
`ExceptionNoticeService`
接口，并提供了一个默认实现：

```java
public interface ExceptionNoticeService {
    void notifyException(Exception e);
}

@Service
public class DefaultExceptionNoticeService implements ExceptionNoticeService {
    @Override
    public void notifyException(Exception e) {
        System.out.println("默认异常通知: " + e.getMessage());
    }
}

```

业务项目依赖于这个基础项目，但现在我们希望在业务项目中
**自定义异常通知逻辑**
，比如通过
**企业微信、钉钉或者邮件**
发送异常通知，而不是使用默认的
`System.out.println`
方式。

---

### **二. 在业务项目中重新实现 ExceptionNoticeService**

#### **方式 1：直接提供新的 Bean 实现**

Spring 允许我们在
**同一个接口有多个实现**
的情况下，覆盖默认实现。只需在业务项目中提供一个新的
`@Service`
实现：

```java
@Service
@Primary  // 让 Spring 优先使用这个 Bean
public class CustomExceptionNoticeService implements ExceptionNoticeService {
    @Override
    public void notifyException(Exception e) {
        // 这里可以调用企业微信、钉钉、邮件等通知渠道
        System.out.println("自定义异常通知: " + e.getMessage());
    }
}

```

**关键点：**

* **`@Primary`
  注解**
  ：当 Spring 发现多个
  `ExceptionNoticeService`
  实现时，会优先使用
  `@Primary`
  标注的 Bean。
* **新的
  `@Service`
  组件**
  会覆盖基础项目中的
  `DefaultExceptionNoticeService`
  ，确保 Spring 使用的是业务项目中的实现。

---

#### **方式 2：使用 Spring 的 Bean 覆盖机制**

如果不想使用
`@Primary`
，也可以通过
`@Bean`
方式在业务项目中覆盖默认实现：

##### **2.1 在业务项目的配置类中替换 Bean**

```java
@Configuration
public class ExceptionNoticeConfig {
    @Bean
    public ExceptionNoticeService exceptionNoticeService() {
        return new CustomExceptionNoticeService();
    }
}

```

##### **2.2 自定义实现**

```java
public class CustomExceptionNoticeService implements ExceptionNoticeService {
    @Override
    public void notifyException(Exception e) {
        System.out.println("自定义异常通知: " + e.getMessage());
    }
}

```

**原理解析：**

* 业务项目的
  `ExceptionNoticeConfig`
  通过
  `@Bean`
  方法定义了新的
  `ExceptionNoticeService`
  实现。
* Spring 会使用
  **新的
  `Bean`
  实例**
  ，替换默认的
  `DefaultExceptionNoticeService`
  。

---

#### **方式 3：移除基础项目的默认实现**

如果业务项目总是需要自定义实现，可以在基础项目中
**不提供
`@Service`
的默认实现**
，而是让业务项目必须提供自己的实现：

##### **修改基础项目**

```java
public interface ExceptionNoticeService {
    void notifyException(Exception e);
}

```

*去掉
`DefaultExceptionNoticeService`
，不再提供默认实现。*

##### **业务项目中必须提供实现**

```java
@Service
public class CustomExceptionNoticeService implements ExceptionNoticeService {
    @Override
    public void notifyException(Exception e) {
        System.out.println("自定义异常通知: " + e.getMessage());
    }
}

```

这样，业务项目
**必须**
自己实现
`ExceptionNoticeService`
，否则 Spring 在运行时会报错
**`No qualifying bean of type 'ExceptionNoticeService'`**
。

---

#### **方式 4：使用 @ConditionalOnMissingBean**

如果基础项目希望
**提供默认实现**
，但允许业务项目
**自定义覆盖**
，可以使用
`@ConditionalOnMissingBean`
：

##### **4.1 修改基础项目的默认实现**

```java
@Service
@ConditionalOnMissingBean(ExceptionNoticeService.class)  // 仅当容器中没有其他 ExceptionNoticeService 时才生效
public class DefaultExceptionNoticeService implements ExceptionNoticeService {
    @Override
    public void notifyException(Exception e) {
        System.out.println("默认异常通知: " + e.getMessage());
    }
}

```

##### **4.2 在业务项目中提供自定义实现**

```java
@Service
public class CustomExceptionNoticeService implements ExceptionNoticeService {
    @Override
    public void notifyException(Exception e) {
        System.out.println("自定义异常通知: " + e.getMessage());
    }
}

```

**原理解析：**

* **基础项目的
  `DefaultExceptionNoticeService`
  只有在没有其他
  `ExceptionNoticeService`
  实现时才会生效**
  。
* **业务项目定义了
  `CustomExceptionNoticeService`
  后，Spring 容器中已经存在了
  `ExceptionNoticeService`
  ，基础项目的默认实现就不会被加载**
  。
* 这样，我们既能提供
  **默认实现**
  ，又允许
  **业务项目自定义覆盖**
  ，更加灵活。

### **三. 总结**

在 Spring Boot 业务项目中
**覆盖基础项目的
`ExceptionNoticeService`
实现**
，可以使用以下方式：

| 方式 | 适用场景 | 关键技术点 |
| --- | --- | --- |
| **`@Primary`** | 业务项目提供新实现，覆盖默认实现 | `@Primary` 让 Spring 选择业务项目的 Bean |
| **`@Bean` 覆盖** | 业务项目通过 `@Configuration` 配置新实现 | 在 `@Configuration` 类中定义新的 `Bean` |
| **`@ConditionalOnMissingBean`** | 基础项目提供默认实现，业务项目可覆盖 | 仅当 **没有其他 Bean** 时，才加载默认实现 |
| **基础项目不提供默认实现** | 业务项目必须提供实现 | 仅定义接口，避免无用的默认实现 |

如果：

* **基础项目想提供默认实现**
  ，但业务项目可以覆盖 →
  **使用
  `@ConditionalOnMissingBean`**
  ✅
* **业务项目总是需要自定义实现**
  →
  **基础项目不提供默认实现**
  ✅
* **业务项目只想覆盖默认实现**
  →
  **使用
  `@Primary`
  或
  `@Bean`**
  ✅

---

### **4. 参考资料**

* [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
* [Spring @Primary 注解](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Primary.html)
* [Spring @ConditionalOnMissingBean](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/condition/ConditionalOnMissingBean.html)
* [Spring @Bean 注解](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e746ae11b679474aa374492ce785abc3.jpeg#pic_center)