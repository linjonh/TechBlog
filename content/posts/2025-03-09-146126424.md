---
layout: post
title: "Java常见的并发设计模式"
date: 2025-03-09 02:21:50 +0800
description: "【代码】Java常见的并发设计模式。"
keywords: "Java常见的并发设计模式"
categories: ['未分类']
tags: ['设计模式', '开发语言', 'Java']
artid: "146126424"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146126424
    alt: "Java常见的并发设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146126424
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146126424
cover: https://bing.ee123.net/img/rand?artid=146126424
image: https://bing.ee123.net/img/rand?artid=146126424
img: https://bing.ee123.net/img/rand?artid=146126424
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java常见的并发设计模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <strong>
      1. 经典生产者-消费者模式
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       核心思想
      </strong>
      ：生产者生产数据放入缓冲区，消费者从缓冲区取数据处理，二者通过阻塞队列（如
      <code>
       BlockingQueue
      </code>
      ）协调。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：消息队列、任务调度、数据处理管道。
     </li>
     <li>
      <strong>
       实现方式
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         BlockingQueue
        </code>
        （如
        <code>
         LinkedBlockingQueue
        </code>
        ）
       </li>
       <li>
        使用
        <code>
         wait/notify
        </code>
       </li>
       <li>
        使用
        <code>
         Lock
        </code>
        和
        <code>
         Condition
        </code>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     示例：
    </p>
    <pre><code class="hljs">class Producer implements Runnable {
    private BlockingQueue&lt;Integer&gt; queue;
    public Producer(BlockingQueue&lt;Integer&gt; queue) { this.queue = queue; }
    public void run() {
        try {
            while (true) {
                int item = new Random().nextInt(100);
                queue.put(item);  // 阻塞式放入
                System.out.println("生产：" + item);
                Thread.sleep(100);
            }
        } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    }
}

class Consumer implements Runnable {
    private BlockingQueue&lt;Integer&gt; queue;
    public Consumer(BlockingQueue&lt;Integer&gt; queue) { this.queue = queue; }
    public void run() {
        try {
            while (true) {
                int item = queue.take();  // 阻塞式获取
                System.out.println("消费：" + item);
                Thread.sleep(200);
            }
        } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    }
}

public class ProducerConsumerExample {
    public static void main(String[] args) {
        BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(10);
        new Thread(new Producer(queue)).start();
        new Thread(new Consumer(queue)).start();
    }
}
</code></pre>
    <h3>
     <strong>
      2. 观察者模式（Observer Pattern）
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       核心思想
      </strong>
      ：一个对象（Subject）发生变化时，通知多个观察者（Observer）。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：事件驱动系统（如 GUI 事件监听、消息通知）。
     </li>
     <li>
      <strong>
       实现方式
      </strong>
      ：
      <ul>
       <li>
        <code>
         java.util.Observer
        </code>
        （Java 9 之后被弃用）
       </li>
       <li>
        <code>
         java.beans.PropertyChangeListener
        </code>
       </li>
       <li>
        自定义回调函数模式
       </li>
      </ul>
     </li>
    </ul>
    <p>
     示例：
    </p>
    <pre><code class="hljs">interface Observer {
    void update(String message);
}

class ConcreteObserver implements Observer {
    private String name;
    public ConcreteObserver(String name) { this.name = name; }
    public void update(String message) {
        System.out.println(name + " 收到消息: " + message);
    }
}

class Subject {
    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();
    public void addObserver(Observer observer) { observers.add(observer); }
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

public class ObserverExample {
    public static void main(String[] args) {
        Subject subject = new Subject();
        Observer o1 = new ConcreteObserver("A");
        Observer o2 = new ConcreteObserver("B");
        subject.addObserver(o1);
        subject.addObserver(o2);
        subject.notifyObservers("新任务来了");
    }
}
</code></pre>
    <h3>
     <strong>
      3. 生产者-消费者-缓冲池模式（Producer-Consumer-Pool）
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       核心思想
      </strong>
      ：在生产者和消费者之间加入一个线程池（如
      <code>
       ThreadPoolExecutor
      </code>
      ），用于处理任务，而不是直接由消费者消费。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：高吞吐任务处理，如 Web 服务器、日志处理。
     </li>
     <li>
      <strong>
       实现方式
      </strong>
      ：
      <ul>
       <li>
        <code>
         ExecutorService
        </code>
        线程池
       </li>
       <li>
        <code>
         BlockingQueue
        </code>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     示例：
    </p>
    <pre><code class="hljs">public class ThreadPoolProducerConsumer {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(10);

        Runnable producer = () -&gt; {
            try {
                while (true) {
                    int item = new Random().nextInt(100);
                    queue.put(item);
                    System.out.println("生产：" + item);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        };

        Runnable consumer = () -&gt; {
            try {
                while (true) {
                    int item = queue.take();
                    System.out.println("消费：" + item);
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        };

        executor.execute(producer);
        executor.execute(consumer);
        executor.shutdown();
    }
}
</code></pre>
    <h3>
     <strong>
      4. 事件驱动架构（EDA - Event-Driven Architecture）
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       核心思想
      </strong>
      ：生产者触发事件，消费者以异步方式处理事件。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：微服务架构、消息队列（Kafka、RabbitMQ）。
     </li>
     <li>
      <strong>
       实现方式
      </strong>
      ：
      <ul>
       <li>
        <code>
         CompletableFuture
        </code>
       </li>
       <li>
        <code>
         EventBus
        </code>
       </li>
       <li>
        消息队列（如 Kafka）
       </li>
      </ul>
     </li>
    </ul>
    <p>
     示例（
     <code>
      CompletableFuture
     </code>
     ）：
    </p>
    <pre><code class="hljs">import java.util.concurrent.*;

public class EventDrivenExample {
    public static void main(String[] args) {
        CompletableFuture.runAsync(() -&gt; {
            try {
                System.out.println("生产事件");
                Thread.sleep(1000);
            } catch (InterruptedException e) { e.printStackTrace(); }
        }).thenRun(() -&gt; System.out.println("消费事件"));
    }
}
</code></pre>
    <h3>
     <strong>
      5. 责任链模式（Chain of Responsibility Pattern）
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       核心思想
      </strong>
      ：多个处理者形成链条，依次处理请求，直到找到合适的处理者。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：日志处理、权限控制、请求过滤。
     </li>
     <li>
      <strong>
       实现方式
      </strong>
      ：
      <ul>
       <li>
        设计链式调用模式
       </li>
       <li>
        <code>
         FilterChain
        </code>
        机制（如 Servlet 过滤器）
       </li>
      </ul>
     </li>
    </ul>
    <p>
     示例：
    </p>
    <pre><code class="hljs">abstract class Handler {
    protected Handler next;
    public void setNext(Handler next) { this.next = next; }
    public abstract void handleRequest(int request);
}

class ConcreteHandlerA extends Handler {
    public void handleRequest(int request) {
        if (request &lt; 10) {
            System.out.println("A 处理请求: " + request);
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

class ConcreteHandlerB extends Handler {
    public void handleRequest(int request) {
        System.out.println("B 处理请求: " + request);
    }
}

public class ChainExample {
    public static void main(String[] args) {
        Handler handlerA = new ConcreteHandlerA();
        Handler handlerB = new ConcreteHandlerB();
        handlerA.setNext(handlerB);

        handlerA.handleRequest(5);
        handlerA.handleRequest(15);
    }
}
</code></pre>
    <h3>
     <strong>
      总结
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        模式
       </th>
       <th>
        适用场景
       </th>
       <th>
        特点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         生产者-消费者模式
        </strong>
       </td>
       <td>
        任务队列
       </td>
       <td>
        多线程并发控制
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         观察者模式
        </strong>
       </td>
       <td>
        事件通知
       </td>
       <td>
        低耦合，异步
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         生产者-消费者-缓冲池
        </strong>
       </td>
       <td>
        高并发任务处理
       </td>
       <td>
        使用线程池优化资源
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         事件驱动架构（EDA）
        </strong>
       </td>
       <td>
        微服务，消息驱动
       </td>
       <td>
        异步，解耦
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         责任链模式
        </strong>
       </td>
       <td>
        过滤器，权限控制
       </td>
       <td>
        链式调用
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     如果你是做
     <strong>
      高并发系统、微服务、消息队列
     </strong>
     ，可以考虑
     <strong>
      事件驱动
     </strong>
     和
     <strong>
      生产者-消费者模式
     </strong>
     。如果是
     <strong>
      GUI 事件、回调机制
     </strong>
     ，
     <strong>
      观察者模式
     </strong>
     更适用。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33363130343834332f:61727469636c652f64657461696c732f313436313236343234" class_="artid" style="display:none">
 </p>
</div>


