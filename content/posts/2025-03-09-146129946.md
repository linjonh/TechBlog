---
layout: post
title: "Android-paging初识"
date: 2025-03-09 11:55:58 +0800
description: "接下来，我应该考虑用户可能的背景。比如，对于简单的分页需求，可能手动实现更快捷，但对于复杂场景，如数据库和网络结合、预加载等，Paging是更好的选择。但根据之前的回答，我已经详细介绍了Paging的优势和学习路径，用户可能仍然需要更简洁的指导，或者更明确的步骤来降低入门难度。这时候需要强调Paging库的长期收益，以及实际项目中的应用效果，比如大公司的使用情况，社区支持等。总结下来，用户需要的是明确的指导，帮助他们克服学习障碍，理解核心概念，并通过实际案例看到学习后的收益，从而减少犹豫，坚定学习的决心。"
keywords: "Android paging初识"
categories: ['未分类']
tags: ['Android']
artid: "146129946"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146129946
    alt: "Android-paging初识"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146129946
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146129946
cover: https://bing.ee123.net/img/rand?artid=146129946
image: https://bing.ee123.net/img/rand?artid=146129946
img: https://bing.ee123.net/img/rand?artid=146129946
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android paging初识
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     嗯，用户之前已经问过关于Android Paging库的问题，现在又提到了同样的困惑，可能说明他们在实际学习中遇到了困难，或者在项目应用过程中遇到了障碍。用户可能已经尝试过学习Paging库，但感觉复杂，导致犹豫是否继续投入时间。
    </p>
    <p>
     首先，我需要确认用户的核心痛点。用户觉得Paging库复杂，但担心不用的话会有性能问题。这说明用户可能对Paging库的优势和实际应用场景还不够清楚，或者在学习过程中遇到了难以理解的概念，比如PagingSource、PagingDataAdapter、RemoteMediator等。
    </p>
    <p>
     接下来，我应该考虑用户可能的背景。用户可能是一个Android开发者，有一定经验，但可能之前没有接触过分页加载的复杂需求，或者之前自己实现分页逻辑时遇到了性能问题，比如内存泄漏、重复加载等。现在他们希望找到一个高效的解决方案，但被Paging库的学习曲线吓到了。
    </p>
    <p>
     用户的需求不仅仅是是否要学Paging库，可能更深层次的是如何高效学习它，或者有没有替代方案。但根据之前的回答，我已经详细介绍了Paging的优势和学习路径，用户可能仍然需要更简洁的指导，或者更明确的步骤来降低入门难度。
    </p>
    <p>
     另外，用户提到“纠结中”，说明他们可能处于决策阶段，需要更多的动力或成功案例来说服他们投入时间学习。这时候需要强调Paging库的长期收益，以及实际项目中的应用效果，比如大公司的使用情况，社区支持等。
    </p>
    <p>
     可能用户在实际操作中遇到了问题，比如配置错误、API使用不当，或者对Flow/RxJava不熟悉，导致难以理解Paging的数据流。这时候需要提供更具体的解决方案，比如分步骤的教程、常见错误的解决方法，或者推荐更直观的学习资源。
    </p>
    <p>
     还需要考虑用户是否了解Paging 3的最新改进，因为相比Paging 2，Paging 3简化了很多API，并且更好地与协程集成。如果用户之前接触的是旧版本，可能会觉得更复杂，所以需要强调版本差异和现在的易用性。
    </p>
    <p>
     最后，用户可能需要一个权衡的结论，帮助他们决定在什么情况下必须使用Paging，什么情况下可以暂时不用。比如，对于简单的分页需求，可能手动实现更快捷，但对于复杂场景，如数据库和网络结合、预加载等，Paging是更好的选择。
    </p>
    <p>
     总结下来，用户需要的是明确的指导，帮助他们克服学习障碍，理解核心概念，并通过实际案例看到学习后的收益，从而减少犹豫，坚定学习的决心。
    </p>
    <p>
     对于 Android Paging 库的纠结，其实核心在于「
     <strong>
      短期学习成本
     </strong>
     」和「
     <strong>
      长期项目收益
     </strong>
     」的权衡。以下从实际场景出发，用更直白的逻辑帮你理清思路，并给出具体的学习路径和避坑指南：
    </p>
    <hr/>
    <h4>
     <a id="_Paging_25">
     </a>
     <strong>
      一、什么情况下必须用 Paging？
     </strong>
    </h4>
    <p>
     如果项目存在以下场景，
     <strong>
      不用 Paging 会更痛苦
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       超长列表
      </strong>
      ：数据量极大（如消息记录、商品列表），直接加载全部数据会导致内存爆炸。
     </li>
     <li>
      <strong>
       实时更新
      </strong>
      ：列表需要动态更新（如新消息插入顶部、数据库变动同步到列表）。
     </li>
     <li>
      <strong>
       混合数据源
      </strong>
      ：需要同时读取本地数据库（缓存）和网络数据（如先展示缓存，再加载网络最新数据）。
     </li>
     <li>
      <strong>
       流畅体验
      </strong>
      ：要求滚动时无卡顿，且需要智能预加载下一页数据。
     </li>
    </ol>
    <p>
     <strong>
      反之
     </strong>
     ，如果只是简单静态列表（比如仅展示 20 条固定数据），手动实现分页反而更简单。
    </p>
    <hr/>
    <h4>
     <a id="Paging__36">
     </a>
     <strong>
      二、Paging 的核心价值：用复杂性换性能
     </strong>
    </h4>
    <p>
     Paging 的难点本质是把原本散落在各处的分页逻辑（网络请求、缓存、数据合并、UI 状态）
     <strong>
      标准化
     </strong>
     。它的复杂度不是「坑」，而是「
     <strong>
      用统一模式解决所有分页问题
     </strong>
     」。
    </p>
    <h5>
     <a id="_39">
     </a>
     <strong>
      举个例子：
     </strong>
    </h5>
    <p>
     假设你要实现一个聊天记录页面：
     <br/>
     •
     <strong>
      无 Paging
     </strong>
     ：需要手动处理分页请求、数据库缓存、页面跳转后数据恢复、下拉刷新和上拉加载的冲突、加载中/错误状态的 UI 逻辑。
     <br/>
     •
     <strong>
      用 Paging
     </strong>
     ：只需定义数据来源（
     <code>
      PagingSource
     </code>
     或
     <code>
      RemoteMediator
     </code>
     ），其他逻辑由库自动处理。
    </p>
    <p>
     <strong>
      结论
     </strong>
     ：Paging 的复杂度是「
     <strong>
      集中式复杂度
     </strong>
     」，而自己实现分页是「
     <strong>
      分散式复杂度
     </strong>
     」。前者初期学习难，但后期维护简单；后者初期看似简单，但随着需求迭代会逐渐失控。
    </p>
    <hr/>
    <h4>
     <a id="3__48">
     </a>
     <strong>
      三、极简学习路径：3 天快速上手
     </strong>
    </h4>
    <h5>
     <a id="Day_1_49">
     </a>
     <strong>
      Day 1：搞定基础分页（纯网络请求）
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        依赖配置
       </strong>
       ：
      </p>
      <pre><code class="prism language-gradle">implementation "androidx.paging:paging-runtime:3.2.1"     // 核心库
implementation "androidx.paging:paging-compose:3.2.1"    // 如果用 Compose
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        核心代码模板
       </strong>
       （网络分页）：
      </p>
      <pre><code class="prism language-kotlin"><span class="token comment">// 1. 定义 PagingSource（数据源）</span>
<span class="token keyword">class</span> <span class="token function">MyPagingSource</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> api<span class="token operator">:</span> ApiService<span class="token punctuation">)</span> <span class="token operator">:</span> PagingSource<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> Data<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">load</span><span class="token punctuation">(</span>params<span class="token operator">:</span> LoadParams<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> LoadResult<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> Data<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> page <span class="token operator">=</span> params<span class="token punctuation">.</span>key <span class="token operator">?:</span> <span class="token number">1</span>  <span class="token comment">// 从第一页开始</span>
        <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">val</span> response <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span>
            LoadResult<span class="token punctuation">.</span><span class="token function">Page</span><span class="token punctuation">(</span>
                <span class="token keyword">data</span> <span class="token operator">=</span> response<span class="token punctuation">.</span>data<span class="token punctuation">,</span>
                prevKey <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">null</span> <span class="token keyword">else</span> page <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
                nextKey <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page <span class="token operator">&gt;=</span> response<span class="token punctuation">.</span>totalPages<span class="token punctuation">)</span> <span class="token keyword">null</span> <span class="token keyword">else</span> page <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            LoadResult<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2. ViewModel 中触发分页</span>
<span class="token keyword">class</span> MyViewModel <span class="token operator">:</span> <span class="token function">ViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> pagingData <span class="token operator">=</span> <span class="token function">Pager</span><span class="token punctuation">(</span><span class="token function">PagingConfig</span><span class="token punctuation">(</span>pageSize <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">MyPagingSource</span><span class="token punctuation">(</span>api <span class="token operator">=</span> RetrofitClient<span class="token punctuation">.</span>api<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span>flow<span class="token punctuation">.</span><span class="token function">cachedIn</span><span class="token punctuation">(</span>viewModelScope<span class="token punctuation">)</span>  <span class="token comment">// 避免重复创建</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3. Activity/Fragment 中监听数据</span>
lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
    viewModel<span class="token punctuation">.</span>pagingData<span class="token punctuation">.</span><span class="token function">collectLatest</span> <span class="token punctuation">{<!-- --></span> pagingData <span class="token operator">-&gt;</span>
        adapter<span class="token punctuation">.</span><span class="token function">submitData</span><span class="token punctuation">(</span>pagingData<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 4. Adapter 继承 PagingDataAdapter</span>
<span class="token keyword">class</span> MyAdapter <span class="token operator">:</span> PagingDataAdapter<span class="token operator">&lt;</span>Data<span class="token punctuation">,</span> MyViewHolder<span class="token operator">&gt;</span><span class="token punctuation">(</span>DataDiffCallback<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ... 实现 ViewHolder</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ol>
    <h5>
     <a id="Day_2_95">
     </a>
     <strong>
      Day 2：处理加载状态和错误
     </strong>
    </h5>
    <p>
     Paging 内置了加载状态监听，
     <strong>
      10 行代码实现全局 Loading/Error UI
     </strong>
     ：
    </p>
    <pre><code class="prism language-kotlin"><span class="token comment">// 在 Activity/Fragment 中监听状态</span>
lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
    adapter<span class="token punctuation">.</span>loadStateFlow<span class="token punctuation">.</span><span class="token function">collectLatest</span> <span class="token punctuation">{<!-- --></span> loadStates <span class="token operator">-&gt;</span>
        <span class="token comment">// 下拉刷新状态</span>
        <span class="token keyword">when</span> <span class="token punctuation">(</span>loadStates<span class="token punctuation">.</span>refresh<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">is</span> LoadState<span class="token punctuation">.</span>Loading <span class="token operator">-&gt;</span> <span class="token function">showLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">is</span> LoadState<span class="token punctuation">.</span>Error <span class="token operator">-&gt;</span> <span class="token function">showError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">is</span> LoadState<span class="token punctuation">.</span>NotLoading <span class="token operator">-&gt;</span> <span class="token function">hideLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 上拉加载更多状态</span>
        binding<span class="token punctuation">.</span>btnRetry<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span> adapter<span class="token punctuation">.</span><span class="token function">retry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="Day_3_113">
     </a>
     <strong>
      Day 3：进阶玩法（数据库+网络混合分页）
     </strong>
    </h5>
    <p>
     用
     <code>
      RemoteMediator
     </code>
     实现先读缓存、再请求网络：
    </p>
    <pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">MyRemoteMediator</span><span class="token punctuation">(</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> localDb<span class="token operator">:</span> AppDatabase<span class="token punctuation">,</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> remoteApi<span class="token operator">:</span> ApiService
<span class="token punctuation">)</span> <span class="token operator">:</span> RemoteMediator<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> Data<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">override</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">load</span><span class="token punctuation">(</span>loadType<span class="token operator">:</span> LoadType<span class="token punctuation">,</span> state<span class="token operator">:</span> PagingState<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> Data<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> MediatorResult <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 1. 根据加载类型计算下一页的 Key</span>
            <span class="token keyword">val</span> pageKey <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">(</span>loadType<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                LoadType<span class="token punctuation">.</span>REFRESH <span class="token operator">-&gt;</span> <span class="token number">1</span>
                LoadType<span class="token punctuation">.</span>PREPEND <span class="token operator">-&gt;</span> <span class="token keyword">return</span> MediatorResult<span class="token punctuation">.</span><span class="token function">Success</span><span class="token punctuation">(</span>endOfPaginationReached <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
                LoadType<span class="token punctuation">.</span>APPEND <span class="token operator">-&gt;</span> localDb<span class="token punctuation">.</span><span class="token function">getNextPageKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 2. 请求网络数据</span>
            <span class="token keyword">val</span> response <span class="token operator">=</span> remoteApi<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span>pageKey<span class="token punctuation">)</span>

            <span class="token comment">// 3. 写入数据库</span>
            localDb<span class="token punctuation">.</span><span class="token function">withTransaction</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>loadType <span class="token operator">==</span> LoadType<span class="token punctuation">.</span>REFRESH<span class="token punctuation">)</span> localDb<span class="token punctuation">.</span><span class="token function">clearData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                localDb<span class="token punctuation">.</span><span class="token function">insertData</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
                localDb<span class="token punctuation">.</span><span class="token function">saveNextPageKey</span><span class="token punctuation">(</span>pageKey <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            MediatorResult<span class="token punctuation">.</span><span class="token function">Success</span><span class="token punctuation">(</span>endOfPaginationReached <span class="token operator">=</span> response<span class="token punctuation">.</span>isLastPage<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            MediatorResult<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <hr/>
    <h4>
     <a id="_150">
     </a>
     <strong>
      四、避坑指南：常见问题秒解
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        列表跳转后数据丢失
       </strong>
       <br/>
       <strong>
        解决
       </strong>
       ：在
       <code>
        Pager
       </code>
       后调用
       <code>
        .cachedIn(viewModelScope)
       </code>
       ，让数据流在 ViewModel 生命周期内缓存。
      </p>
     </li>
     <li>
      <p>
       <strong>
        重复请求相同分页
       </strong>
       <br/>
       <strong>
        解决
       </strong>
       ：在
       <code>
        PagingSource
       </code>
       中正确实现
       <code>
        getRefreshKey()
       </code>
       ，确保分页 Key 正确恢复。
      </p>
     </li>
     <li>
      <p>
       <strong>
        下拉刷新无效
       </strong>
       <br/>
       <strong>
        解决
       </strong>
       ：调用
       <code>
        adapter.refresh()
       </code>
       而非重新创建 Pager。
      </p>
     </li>
     <li>
      <p>
       <strong>
        性能优化
       </strong>
       ：调整
       <code>
        PagingConfig
       </code>
       参数：
      </p>
      <pre><code class="prism language-kotlin"><span class="token function">PagingConfig</span><span class="token punctuation">(</span>
    pageSize <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>             <span class="token comment">// 每页数量</span>
    prefetchDistance <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>     <span class="token comment">// 提前加载下一页的阈值</span>
    initialLoadSize <span class="token operator">=</span> <span class="token number">40</span>       <span class="token comment">// 首次加载数量</span>
<span class="token punctuation">)</span>
</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_171">
     </a>
     <strong>
      五、替代方案对比
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         场景
        </strong>
       </th>
       <th>
        <strong>
         推荐方案
        </strong>
       </th>
       <th>
        <strong>
         原因
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        简单静态列表（数据量小）
       </td>
       <td>
        手动实现分页
       </td>
       <td>
        避免引入 Paging 的复杂度
       </td>
      </tr>
      <tr>
       <td>
        需要极致定制化分页逻辑
       </td>
       <td>
        自研分页框架 + RxJava/协程
       </td>
       <td>
        Paging 的灵活性不足时
       </td>
      </tr>
      <tr>
       <td>
        大型项目长期维护
       </td>
       <td>
        Paging 3
       </td>
       <td>
        官方维护、社区支持、功能全面
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="Paging__180">
     </a>
     <strong>
      六、结论：Paging 是「高投入高回报」的选择
     </strong>
    </h4>
    <p>
     •
     <strong>
      短期
     </strong>
     ：花 3 天掌握核心 API，能解决 80% 的分页需求。
     <br/>
     •
     <strong>
      长期
     </strong>
     ：随着项目复杂度的增加，Paging 的预加载、状态管理、数据源混合等特性会节省大量开发时间。
    </p>
    <p>
     <strong>
      最后建议
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       边写边学
      </strong>
      ：直接从项目里抽一个简单列表用 Paging 改造（比如消息列表）。
     </li>
     <li>
      <strong>
       善用官方工具
      </strong>
      ：Android Studio 的
      <code>
       PagingDataAdapter
      </code>
      模板代码可以自动生成基础结构。
     </li>
     <li>
      <strong>
       不求完美
      </strong>
      ：初期不用纠结
      <code>
       RemoteMediator
      </code>
      等高阶用法，先解决主流程问题。
     </li>
    </ol>
    <p>
     Paging 的初期学习曲线陡峭，但一旦跨过门槛，你会发现它像
     <strong>
      RecyclerView
     </strong>
     一样，成为 Android 开发的「基础设施」之一。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32363239363139372f:61727469636c652f64657461696c732f313436313239393436" class_="artid" style="display:none">
 </p>
</div>


