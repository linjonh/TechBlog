---
layout: post
title: "51和stm32的点灯区别"
date: 2025-08-23T11:15:59+0800
description: "51单片机与STM32点灯对比：51单片机点灯仅需简单GPIO控制，代码简洁（约10行），无需时钟配置；而STM32需完整配置流程（时钟使能、模式/类型/速度设置等），代码更复杂（约30行）。51适合简单控制场景，STM32适合复杂应用，提供更灵活的GPIO配置选项（输入/输出/复用模式、推挽/开漏、速度调节等）。两者差异体现了不同架构的设计理念：51追求简单易用，STM32强调功能丰富性。"
keywords: "51和stm32的点灯区别"
categories: ['未分类']
tags: ['单片机', 'Stm', '51单片机']
artid: "150637917"
arturl: "https://blog.csdn.net/amyliyanice/article/details/150637917"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150637917
    alt: "51和stm32的点灯区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150637917
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150637917
cover: https://bing.ee123.net/img/rand?artid=150637917
image: https://bing.ee123.net/img/rand?artid=150637917
img: https://bing.ee123.net/img/rand?artid=150637917
---



# 51和stm32的点灯区别



**点一个灯，51是“一句话的事”，而STM32是“一个流程的事”**。

### 51点灯

控制GPIO口高低电平即可

```

#include <REGX52.H> // 包含STC89C52的头文件，定义了P1等寄存器

sbit LED = P1^0; // 使用sbit关键字定义P1口的第0位为LED

// 简单的延时函数，用于产生闪烁间隔
void Delay_ms(unsigned int ms) {
    unsigned int i, j;
    for(i=ms; i>0; i--)
        for(j=114; j>0; j--);
}

void main() { // 主函数
    while(1) { // 无限循环
        LED = 0; // P1.0输出低电平，点亮LED（假设共阳接法）
        Delay_ms(500); // 延时500毫秒
        LED = 1; // P1.0输出高电平，熄灭LED
        Delay_ms(500); // 延时500毫秒
    }
}
```

### stm32点灯

使能时钟

配置模式

配置类型

配置速度

设置初始状态

控制电平

```

// 寄存器地址定义
#define RCC_APB2ENR (*(volatile unsigned int*)0x40021018) // 时钟使能寄存器地址
#define GPIOA_CRL (*(volatile unsigned int*)0x40010800)   // GPIOA配置寄存器低地址
#define GPIOA_ODR (*(volatile unsigned int*)0x4001080C)   // GPIOA输出数据寄存器地址

int main(void) {
    // 1. 使能GPIOA的时钟 (必做第一步!)
    RCC_APB2ENR |= (1 << 2); // 将第2位置1，开启GPIOA端口的时钟

    // 2. 配置GPIOA第5引脚的模式
    // 先清空PA5对应的配置位（CNF5[1:0]和MODE5[1:0]），位于CRL寄存器的[23:20]
    GPIOA_CRL &= ~(0xF << 20);
    // 设置PA5为通用推挽输出模式，最大速度50MHz
    // 推挽输出(GPIO)：CNF5[1:0]=00, 输出模式，50MHz：MODE5[1:0]=11
    // 所以写入二进制的0011，即0x3，左移20位
    GPIOA_CRL |= (0x3 << 20); // (0b0011 << 20)

    while(1) {
        // 3. 控制输出：点亮LED（假设低电平点亮）
        GPIOA_ODR &= ~(1 << 5); // 将第5位清0
        // 使用简陋的延时
        for(volatile int i=0; i<500000; i++);
        
        // 4. 控制输出：熄灭LED
        GPIOA_ODR |= (1 << 5);  // 将第5位置1
        for(volatile int i=0; i<500000; i++);
    }
}
```

### 51点灯和stm32点灯对比

| 特性 | 51单片机 (如AT89C51) | STM32单片机 (如STM32F103) |
| --- | --- | --- |
| **编程范式** | 通常**直接操作寄存器**16，相对简单 | 支持**直接操作寄存器**19、使用**标准外设库**（STD库）19、或**HAL/LL库**，复杂度更高，灵活性更强 |
| **时钟配置** | 通常**无需额外使能**GPIO端口时钟6 | **必须首先使能**对应GPIO端口的时钟（通过RCC寄存器）189，否则IO口无法正常工作 |
| **GPIO模式配置** | 配置相对简单，主要是**准双向口**（类似弱上拉）、开漏、强推挽输出等少数几种模式 | 配置复杂，需通过**模式寄存器 (MODER)** 设置输入/输出/复用/模拟，**输出类型寄存器 (OTYPER)** 选择推挽/开漏，**速度寄存器 (OSPEEDR)** 选择输出速度18 |
| **上下拉电阻配置** | 配置选项较少 | 有专门的**上拉/下拉寄存器 (PUPDR)** 进行配置1 |
| **控制输出方式** | 直接对**端口寄存器**（如P1）赋值或位操作（如`sbit`）167 | 可通过**输出数据寄存器 (ODR)**、**位设置/复位寄存器 (BSRR)**、**复位寄存器 (BRR)** 等多种方式控制输出89 |
| **代码示例特点** | 代码简短，几行即可完成点灯16 | 即使最简单的点灯，也需要较多配置代码（寄存器版）19，库函数版可读性更好19 |
| **中断应用** | 支持外部中断，配置相对简单 | 中断系统**高度复杂且灵活**，支持多优先级、大量中断源，需配置NVIC、EXTI等35 |
| **适用场景** | 简单控制、教学入门、成本敏感、对功耗要求不高的应用 | 复杂应用、多任务、实时性要求高、低功耗、需要丰富外设（如PWM、ADC、多种通信接口）的场景 |

* **51单片机**：**大部分情况下操作I/O口并不需要像STM32那样显式地“使能”一个GPIO模块的时钟**（部分增强型51外设如ADC、串口等可能需要配置相关寄存器来“使能”其工作）6。51的I/O口功能相对固定，复用选项少，其端口寄存器本身已经映射到了固定的地址（如P2口地址0xA0）69，操作这些地址就相当于直接控制I/O口。
* **STM32的配置维度**：你提到的“使能、模式、类型、速度、初始状态”**非常准确地概括了STM32 GPIO配置的核心步骤**18：

  + **使能时钟 (Enable)**：通过RCC (Reset and Clock Control) 模块的**AHBxENR**或**APBxENR**寄存器开启对应GPIO端口的时钟189。这是STM32操作任何外设的**第一步**，不打开时钟，后续所有配置都无效。
  + **设置模式 (Mode)**：通过**GPIOx_MODER**寄存器设置引脚为**输入**、**输出**、**复用功能**（连接其他外设如串口、SPI）还是**模拟功能**（用于ADC/DAC）18。
  + **设置输出类型 (Type)**：通过**GPIOx_OTYPER**寄存器选择输出是**推挽**（强输出高低电平）还是**开漏**（常用于电平转换、I2C等）1。
  + **设置输出速度 (Speed)**：通过**GPIOx_OSPEEDR**寄存器配置引脚的**翻转速度**（如2MHz, 50MHz），速度越高功耗也越大，需根据实际需求（如防止信号振铃）选择1。
  + **设置上/下拉 (Pull-up/Pull-down)**：通过**GPIOx_PUPDR**寄存器配置是否使用内部的上拉或下拉电阻，以避免引脚悬空时的电平不确定1。
  + **初始状态**：通过**ODR**或**BSRR**寄存器设置输出高低电平8。
* **中断系统的差异**：STM32的中断系统（NVIC, Nested Vectored Interrupt Controller）远比51强大和复杂35。它支持**中断优先级分组**、**大量外部中断线**（EXTI）并可灵活映射到多个GPIO引脚、**硬件自动处理现场保护和恢复**等，这使得STM32的中断响应更快速，实时性更强。

💡 **如何选择单片机**

* **选择51单片机**，如果你的项目是**简单的控制**（如继电器开关、LED显示、按键扫描）、**教学入门**、**对成本极其敏感**，或者**产品批量大且功能固定**，51是不错的选择。
* **选择STM32单片机**，如果你的项目需要**复杂的处理**、**丰富的通信接口**（如多个UART, SPI, I2C, USB, CAN）、**实时性要求高**（如电机控制）、需要**低功耗特性**（STM32有丰富的低功耗模式），或者**未来可能需要功能升级**，STM32更能满足需求。

🚀 **进阶学习建议**

* **从51过渡到STM32**：理解了51的寄存器操作，有助于你理解STM32寄存器编程的本质6。但也要适应STM32更复杂的时钟树和外设配置思路。
* **善用库函数和工具**：STM32的标准外设库（StdPeriph Library）或HAL库（Hardware Abstraction Layer）能**简化配置过程**，提高开发效率19。STM32CubeMX工具可以**图形化配置引脚、时钟、外设**，并生成初始化代码，是新手福音。
* **关注实际应用**：点灯是第一步，后续可以尝试PWM调



