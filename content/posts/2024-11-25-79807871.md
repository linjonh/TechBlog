---
layout: post
title: "ssh连接linux服务器中断后,如何让命令继续在服务器运行"
date: 2024-11-25 15:44:19 +0800
description: "ssh连接linux服务器中断后，如何让命令继续在服务器运行_ssh断开后 命令还会继续执行吗"
keywords: "ssh断开后 命令还会继续执行吗"
categories: ['Ubuntu', 'Linux']
tags: ['服务器', 'Ssh', 'Linux']
artid: "79807871"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=79807871
    alt: "ssh连接linux服务器中断后,如何让命令继续在服务器运行"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=79807871
featuredImagePreview: https://bing.ee123.net/img/rand?artid=79807871
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ssh连接linux服务器中断后，如何让命令继续在服务器运行
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="sshlinux_1">
     </a>
     ssh连接linux服务器中断后，如何让命令继续在服务器运行
    </h2>
    <p>
     这个问题也许是我们这些小白比较头疼的问题，尤其对于那些做机器学习需要花很久的时间才能训练出一个结果。然而就在这时，因为各种不可抗力我们使用ssh连接服务器时，ssh的窗口突然断开了连接，那么在服务器上跑的程序就也跟着断掉了，之前所有跑的数据也将丢失，这样将会浪费我们大量的时间。
    </p>
    <p>
     今天刚好有人跟我提到了这个问题，然后就简单上网查找资料，简单的学习一下，做个笔记方便自己以后查阅。
    </p>
    <p>
     参考链接：
    </p>
    <p>
     <a href="http://blog.csdn.net/gukesdo/article/details/6901902">
      http://blog.csdn.net/gukesdo/article/details/6901902
     </a>
    </p>
    <h2>
     <a id="ssh_12">
     </a>
     为什么ssh一旦断开我们的进程也将会被杀掉？
    </h2>
    <p>
     元凶：SIGHUP 信号
    </p>
    <p>
     让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。
    </p>
    <p>
     在Linux/Unix中，有这样几个概念：
    </p>
    <p>
     进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。
    </p>
    <p>
     会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。
    </p>
    <p>
     会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。
    </p>
    <p>
     根据POSIX.1定义：
    </p>
    <p>
     挂断信号（SIGHUP）默认的动作是终止程序。
    </p>
    <p>
     当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。
    </p>
    <p>
     如果会话期首进程终止，则该信号发送到该会话期前台进程组。
    </p>
    <p>
     一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。
    </p>
    <p>
     因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。
    </p>
    <p>
     <strong>
      这里我认为我们的进程被杀掉也就是因为ssh与服务器之间的通信断掉了，这个通信断掉之后linux程序就默认将该连接下的所有进程都杀掉
     </strong>
    </p>
    <h2>
     <a id="_41">
     </a>
     解决方案
    </h2>
    <p>
     针对上面的问题，上面的参考链接中也有讲解，在此进行一个简单的整理。
    </p>
    <p>
     这里主要有三个方案，一个是使用nohup指令，一个是使用screen指令，最后一个是screen的升级版byobu。看完这三个指令之后其实**我更倾向于使用byobu指令，因为byobu指令更加的强大,是screen的升级版本，并且界面也比较友好。
     <br/>
     **
    </p>
    <h3>
     <a id="nohup_48">
     </a>
     nohup命令
    </h3>
    <p>
     nohup命令参考
    </p>
    <p>
     nohup 命令
    </p>
    <p>
     用途：不挂断地运行命令。
    </p>
    <p>
     语法：nohup Command [ Arg … ] [　&amp; ]
    </p>
    <p>
     描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断(SIGHUP)信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; ( 表示”and”的符号)到命令的尾部。
    </p>
    <p>
     无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。
    </p>
    <h4>
     <a id="nohup_63">
     </a>
     nohup的简单使用
    </h4>
    <p>
     在执行命令时在命令前面加上nohup，然后回车开始运行。
    </p>
    <p>
     <strong>
      这时你会发现该有的输出其实并没有输出出来，这个时候不要方，这是因为nohup命令将你的所有输出都输出到了当前文件夹下的nohup.out文件中，自己可以使用vim指令进行一个查看。
     </strong>
    </p>
    <p>
     nohup命令及其输出文件
     <br/>
     nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。
     <br/>
     该命令的一般形式为：nohup command &amp;
     <br/>
     使用nohup命令提交作业
     <br/>
     如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：
     <br/>
     nohup command &gt; myout.file 2&gt;&amp;1 &amp;
    </p>
    <p>
     <strong>
      使用 jobs 查看任务。
     </strong>
    </p>
    <p>
     <strong>
      使用 fg %n　关闭。
     </strong>
    </p>
    <h3>
     <a id="screen_82">
     </a>
     screen命令
    </h3>
    <p>
     简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在screen中创建一个新的窗口有这样几种方式：
    </p>
    <p>
     1．直接在命令行键入screen命令
    </p>
    <p>
     $ screen
     <br/>
     Screen将创建一个执行shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。
    </p>
    <p>
     2．Screen命令后跟你要执行的程序。
    </p>
    <p>
     $ screen 【后面跟你执行程序的命令】
    </p>
    <p>
     Screen创建一个执行vi test.c的单窗口会话，退出vi将退出该窗口/会话。
    </p>
    <p>
     3．以上两种方式都创建新的screen会话。我们还可以在一个已有screen会话中创建新的窗口。在当前screen窗口中键入C-a c ，即Ctrl键+a键，之后再按下c键，screen 在该会话内生成一个新的窗口并切换到该窗口。
    </p>
    <p>
     screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。
    </p>
    <h4>
     <a id="screen_102">
     </a>
     screen的简单使用
    </h4>
    <p>
     在所要执行的指令前添加screen.然后程序的运行等一切正常。（nohup的输出是定向到了nohup.out文件中，然而screen指令的输出是直接输出到了屏幕上的）
    </p>
    <p>
     这个时候如果ssh终端断开了连接。我们只需要再次连接服务器然后输入指令
    </p>
    <pre><code class="prism language-bash"><span class="token function">screen</span> -ls
</code></pre>
    <p>
     然后会得到类似下面的结果：
    </p>
    <pre><code class="prism language-bash">There is a <span class="token function">screen</span> on:
	27267.pts-19.TITAN-X	<span class="token punctuation">(</span>09/08/2017 03:49:10 PM<span class="token punctuation">)</span>	<span class="token punctuation">(</span>Detached<span class="token punctuation">)</span>
1 Socket <span class="token keyword">in</span> /var/run/screen/S-huanghailiang.
</code></pre>
    <p>
     这里就会显示ssh断开之前的程序，
     <em>
      <strong>
       其实断开后程序依然在后台在运行
      </strong>
     </em>
     ，只是我们这个时候需要将它放到前台来运行。这个时候我们们已经通过screen -ls查询到了线程号是27267了，所以我们只需要执行下面的指令即可恢复到前台了。
    </p>
    <pre><code class="prism language-bash"><span class="token function">screen</span> -r 27267
</code></pre>
    <p>
     如果想杀掉终端可以执行
    </p>
    <pre><code class="prism language-bash"><span class="token function">kill</span> 27267
</code></pre>
    <p>
     其他更多的指令可以通过screen --help来进行学习。
    </p>
    <p>
     当然screen还有更多的快捷键值得我们学习。我们可以通过C-a ? 即先按ctrl+a以后再按？即可查看。
    </p>
    <p>
     <strong>
      通过观察我们可以发现它其实恢复了我们ssh断开前的那个界面。（所有的输出也都会在此显示出来）
     </strong>
    </p>
    <h3>
     <a id="byobu_138">
     </a>
     byobu命令
    </h3>
    <p>
     byobu感觉就是screen的一个升级版本，界面比较友好，操作也比较方便。
     <br/>
     一般Ubuntu系统开始的时候默认没有安装，我们需要手动安装byobu:
    </p>
    <pre><code>sudo apt install byobu
</code></pre>
    <h4>
     <a id="byobu_146">
     </a>
     byobu的基本简单操作
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        按键
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        F2
       </td>
       <td>
        新建窗口
       </td>
      </tr>
      <tr>
       <td>
        F3
       </td>
       <td>
        移动到前一个窗口
       </td>
      </tr>
      <tr>
       <td>
        F4
       </td>
       <td>
        移动到后一个窗口
       </td>
      </tr>
      <tr>
       <td>
        F6
       </td>
       <td>
        退出byobu窗口
       </td>
      </tr>
      <tr>
       <td>
        F9
       </td>
       <td>
        打开byobu菜单，查看帮助信息的配置信息
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     关闭当前窗口其实Ctrl+D就可以完成
    </p>
    <p>
     剩余操作我们可以F9查看byobu的帮助即可。
    </p>
    <p>
     如果我们想要一登陆就显示byobu界面的话，可以使用指令
    </p>
    <pre><code>byobu-enable
</code></pre>
    <p>
     如果想取消一登陆就显示byobu界面可以是用指令
    </p>
    <pre><code>byobu-disable
</code></pre>
    <h2>
     <a id="_172">
     </a>
     注（个人理解）：
    </h2>
    <p>
     <strong>
      nohup
     </strong>
     虽然可以把所有的输出都写入到nohup.out中间来，但是在面对需要人机交互的时候它就不能正常使用了。另外在我做测试的时候，一旦ssh断开，虽然程序还在后台运行，但是好像并不会再把输出写入到nohup.out文件中，这一点很不好。
    </p>
    <p>
     <strong>
      screen
     </strong>
     相比之下就强大了很多，不仅可以满足人机交互，而且还可以将所有的输出都再次展示出来，方便我们查看。我对screen的理解是，其实它是一个虚拟的终端，我们运行的时候screen指令就为我们创建了一个虚拟的终端，所以我们再次连接后我们打开的还是这个虚拟的终端，所以我们可以更好的进行操作，而且screen支持开很多个终端。
    </p>
    <p>
     <strong>
      byobu
     </strong>
     相比之下继承了screen的所有优点，并且拥有了更加方便快捷的操作界面，同时在界面下方还能很好的显示目前计算机的硬件使用情况，十分方便。
    </p>
    <p>
     它们三者的共性我认为都已经不受SIGHUP信号的影响了，所以即使断掉了ssh程序依旧会运行。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f64617272656e383137:2f61727469636c652f64657461696c732f3739383037383731" class_="artid" style="display:none">
 </p>
</div>


