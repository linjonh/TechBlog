---
layout: post
title: "谈谈常用的分布式-ID-设计方案"
date: 2025-03-05 21:11:48 +0800
description: "分布式 ID 设计方案需要满足全局唯一性、高性能、高可用、趋势递增等要求，以下是一些常用的分布式 ID 设计方案：INCRINCRBYINCRINCRBYINCR。"
keywords: "谈谈常用的分布式 ID 设计方案？"
categories: ['未分类']
tags: ['分布式']
artid: "146053177"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053177
    alt: "谈谈常用的分布式-ID-设计方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053177
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053177
cover: https://bing.ee123.net/img/rand?artid=146053177
image: https://bing.ee123.net/img/rand?artid=146053177
img: https://bing.ee123.net/img/rand?artid=146053177
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     谈谈常用的分布式 ID 设计方案？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     分布式 ID 设计方案需要满足全局唯一性、高性能、高可用、趋势递增等要求，以下是一些常用的分布式 ID 设计方案：
    </p>
    <h4>
     UUID
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：UUID（Universally Unique Identifier）是一种由数字和字母组成的 128 位标识符，通常表示为 32 个十六进制数字，中间用连字符分隔成 5 段。它基于时间戳、MAC 地址等信息生成，具有全球唯一性。
     </li>
     <li>
      <strong>
       优点
      </strong>
      <ul>
       <li>
        <strong>
         唯一性强
        </strong>
        ：几乎不可能出现重复的 UUID，在全球范围内具有唯一性。
       </li>
       <li>
        <strong>
         生成简单
        </strong>
        ：不需要依赖数据库等外部系统，本地即可生成，性能较高。
       </li>
       <li>
        <strong>
         无中心节点
        </strong>
        ：不存在单点故障问题，系统的稳定性和可靠性较高。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       缺点
      </strong>
      <ul>
       <li>
        <strong>
         无顺序性
        </strong>
        ：生成的 UUID 是无序的，不利于按照时间等顺序进行排序和索引。
       </li>
       <li>
        <strong>
         存储空间大
        </strong>
        ：32 位的字符串存储，占用空间相对较大，在存储和查询时会消耗更多的资源。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：适用于对 ID 的顺序性没有要求，且需要快速生成大量唯一 ID 的场景，如分布式系统中的临时文件标识、对象标识等。
     </li>
    </ul>
    <h4>
     数据库自增长 ID
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：在数据库表中设置一个自增长字段，通常为整数类型，每当插入一条新记录时，数据库会自动为该字段分配一个唯一的递增数值。
     </li>
     <li>
      <strong>
       优点
      </strong>
      <ul>
       <li>
        <strong>
         简单易用
        </strong>
        ：数据库本身提供了自增长功能，使用起来非常方便，不需要额外的复杂逻辑。
       </li>
       <li>
        <strong>
         顺序性好
        </strong>
        ：ID 是按照插入顺序依次递增的，具有良好的顺序性，便于进行排序和分页等操作。
       </li>
       <li>
        <strong>
         数值类型
        </strong>
        ：通常为整数类型，在存储和查询时效率较高，占用空间相对较小。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       缺点
      </strong>
      <ul>
       <li>
        <strong>
         单点瓶颈
        </strong>
        ：如果数据库出现故障，可能会影响 ID 的生成，存在单点故障问题。
       </li>
       <li>
        <strong>
         分布式扩展困难
        </strong>
        ：在分布式系统中，多个节点同时向数据库插入数据时，可能会出现 ID 冲突或性能问题，扩展能力有限。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：适用于单体应用或小型分布式系统，对 ID 的生成性能要求不高，且数据量相对较小的场景。
     </li>
    </ul>
    <h4>
     雪花算法（Snowflake）
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：雪花算法是 Twitter 开源的分布式 ID 生成算法，它生成的 ID 是一个 64 位的长整型数字。其将 64 位的 ID 划分为不同的部分，分别表示时间戳、数据中心 ID、工作节点 ID 和序列号等信息。
     </li>
     <li>
      <strong>
       优点
      </strong>
      <ul>
       <li>
        <strong>
         高性能
        </strong>
        ：可以在单机上每秒生成数百万个 ID，性能非常高。
       </li>
       <li>
        <strong>
         趋势递增
        </strong>
        ：生成的 ID 是趋势递增的，在分布式系统中可以保证一定的顺序性，有利于数据的排序和索引。
       </li>
       <li>
        <strong>
         可定制性
        </strong>
        ：可以根据实际需求调整数据中心 ID 和工作节点 ID 的位数，以适应不同的分布式环境。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       缺点
      </strong>
      <ul>
       <li>
        <strong>
         依赖时钟
        </strong>
        ：如果服务器的时钟发生回拨，可能会导致生成重复的 ID，需要进行额外的处理。
       </li>
       <li>
        <strong>
         ID 空间有限
        </strong>
        ：由于 ID 的位数是固定的，随着时间的推移，可能会出现 ID 空间不足的问题。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：适用于对 ID 生成性能要求高、需要趋势递增 ID 的分布式系统，如订单系统、日志系统等。
     </li>
    </ul>
    <h4>
     Redis 生成 ID
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：利用 Redis 的原子指令
      <code>
       INCR
      </code>
      或
      <code>
       INCRBY
      </code>
      来实现 ID 的生成。可以为每个业务模块创建一个独立的计数器，每次调用
      <code>
       INCR
      </code>
      或
      <code>
       INCRBY
      </code>
      命令时，Redis 会原子性地将计数器的值增加指定的步长，从而生成唯一的 ID。
     </li>
     <li>
      <strong>
       优点
      </strong>
      <ul>
       <li>
        <strong>
         高性能
        </strong>
        ：Redis 是内存数据库，执行
        <code>
         INCR
        </code>
        等指令的速度非常快，可以满足高并发场景下的 ID 生成需求。
       </li>
       <li>
        <strong>
         可扩展性
        </strong>
        ：可以通过增加 Redis 节点来扩展 ID 生成的能力，支持大规模的分布式系统。
       </li>
       <li>
        <strong>
         灵活性
        </strong>
        ：可以根据需要自定义 ID 的生成规则，如设置起始值、步长等。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       缺点
      </strong>
      <ul>
       <li>
        <strong>
         依赖 Redis
        </strong>
        ：如果 Redis 出现故障，可能会影响 ID 的生成，需要考虑 Redis 的高可用性和数据持久化问题。
       </li>
       <li>
        <strong>
         没有时间顺序
        </strong>
        ：生成的 ID 没有直接的时间顺序信息，需要额外的处理来保证 ID 的有序性。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：适用于对 ID 生成性能要求高、需要灵活定制 ID 生成规则的分布式系统，如电商平台的商品 ID 生成、用户 ID 生成等。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f37383337383436362f:61727469636c652f64657461696c732f313436303533313737" class_="artid" style="display:none">
 </p>
</div>


