---
layout: post
title: "go-sync.Once-源码分析"
date: 2025-03-12 09:53:57 +0800
description: "sync.Once是 Go 语言标准库中的一个同步原语，用于确保某个操作或函数在并发环境下只执行一次。"
keywords: "go sync.Once 源码分析"
categories: ['Go']
tags: ['开发语言', 'Golang']
artid: "146196597"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146196597
    alt: "go-sync.Once-源码分析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146196597
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146196597
cover: https://bing.ee123.net/img/rand?artid=146196597
image: https://bing.ee123.net/img/rand?artid=146196597
img: https://bing.ee123.net/img/rand?artid=146196597
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     go sync.Once 源码分析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <code>
      sync.Once
     </code>
     是 Go 语言标准库中的一个同步原语，用于确保某个操作或函数在并发环境下只执行一次。它通常用于以下场景：
    </p>
    <ol>
     <li>
      <strong>
       单例模式
      </strong>
      ：确保全局只有一个实例对象，避免重复创建资源
     </li>
     <li>
      <strong>
       延迟初始化
      </strong>
      ：在程序运行过程中，当真正需要某个资源时才进行初始化
     </li>
     <li>
      <strong>
       执行性一次的操作
      </strong>
      ：例如加载配置文件、初始化日志系统等
     </li>
    </ol>
    <h3>
     <a id="_4">
     </a>
     使用方法
    </h3>
    <p>
     <code>
      sync.Once
     </code>
     提供了一个方法
     <code>
      Do
     </code>
     ，接受一个函数作为参数。无论
     <code>
      Do
     </code>
     被调用多少次，传入的函数只会执行一次。例如：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once
<span class="token keyword">var</span> config <span class="token operator">*</span>Config

<span class="token keyword">func</span> <span class="token function">ReadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Config <span class="token punctuation">{<!-- --></span>
    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        config <span class="token operator">=</span> <span class="token operator">&amp;</span>Config<span class="token punctuation">{<!-- --></span>Server<span class="token punctuation">:</span> <span class="token string">"example.com"</span><span class="token punctuation">,</span> Port<span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> config
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在这个例子中，
     <code>
      config
     </code>
     的初始化只会在第一次调用
     <code>
      ReadConfig
     </code>
     时执行，后续调用直接返回已初始化的
     <code>
      config
     </code>
     。
    </p>
    <p>
     特点
    </p>
    <ul>
     <li>
      <code>
       线程安全
      </code>
      ：即使在多个协程同时调用
      <code>
       Do
      </code>
      方法，也能保证函数只执行一次。
     </li>
     <li>
      <code>
       不可重用
      </code>
      ：一旦
      <code>
       sync.Once
      </code>
      执行完成，它将标记为“已完成”，后续调用不会重新执行。
     </li>
     <li>
      <code>
       异常处理
      </code>
      ：如果
      <code>
       Do
      </code>
      中的函数发生 panic，
      <code>
       sync.Once
      </code>
      会将其视为“已完成”，后续调用不会重新执行。
     </li>
    </ul>
    <h3>
     <a id="_24">
     </a>
     源码分析
    </h3>
    <p>
     sync.Once 的实现基于
     <strong>
      双重锁检查机制
     </strong>
     实现的。它通过
     <code>
      atomic.LoadUint32
     </code>
     和
     <code>
      atomic.StoreUint32
     </code>
     来检查和标记操作是否已完成。这种设计既保证了性能，又确保了线程安全。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> sync

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"sync/atomic"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Once <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	done <span class="token builtin">uint32</span>
	m    Mutex
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Outlined slow-path to allow inlining of the fast-path.</span>
		o<span class="token punctuation">.</span><span class="token function">doSlow</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">doSlow</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> o<span class="token punctuation">.</span>done <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> atomic<span class="token punctuation">.</span><span class="token function">StoreUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// f() 触发 panic 也会标记为 “已完成”，后续调用不会重新执行</span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <h4>
     <a id="_56">
     </a>
     双重锁检查机制
    </h4>
    <p>
     双重锁检查机制（Double-Checked Locking，DCL）是一种用于多线程环境中实现延迟初始化单例模式的设计模式，其核心思想是通过两次检查来减少同步锁的开销，同时保证线程安全。
    </p>
    <p>
     <strong>
      工作原理
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       第一次检查
      </strong>
      ：在进入同步代码块之前，先检查实例是否已经被初始化。如果实例已经存在，则直接返回实例，避免进入同步块。
     </li>
     <li>
      <strong>
       加锁
      </strong>
      ：如果实例尚未初始化，线程将尝试获取锁，以确保只有一个线程可以进入初始化代码块。
     </li>
     <li>
      <strong>
       第二次检查
      </strong>
      ：在获取锁后，再次检查实例是否已经被初始化。这是为了确保在当前线程等待锁的过程中，其他线程没有初始化实例。
     </li>
    </ol>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f576b73796378792f:61727469636c652f64657461696c732f313436313936353937" class_="artid" style="display:none">
 </p>
</div>


