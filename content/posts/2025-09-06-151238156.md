---
layout: post
title: "算法双指针一移动零"
date: 2025-09-06T03:33:06+0800
description: "本文结合力扣习题-移动零，介绍了双指针 在维护条件边界方向上 实现数组条件分块的原理"
keywords: "【算法】双指针(一)移动零"
categories: ['未分类']
tags: ['算法', '学习']
artid: "151238156"
arturl: "https://blog.csdn.net/2401_86112610/article/details/151238156"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151238156
    alt: "算法双指针一移动零"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151238156
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151238156
cover: https://bing.ee123.net/img/rand?artid=151238156
image: https://bing.ee123.net/img/rand?artid=151238156
img: https://bing.ee123.net/img/rand?artid=151238156
---



# 【算法】双指针(一)移动零



![](https://i-blog.csdnimg.cn/direct/4bb4f0158cf44e08a820eb72ddc23777.gif)








---

## 一、题目介绍

[**283. 移动零 - 力扣（LeetCode）**](https://leetcode.cn/problems/move-zeroes/description/ "283. 移动零 - 力扣（LeetCode）")

![](https://i-blog.csdnimg.cn/direct/0cce954a493242b588491c44b4afc9bd.png)

---

> ## 二、双指针原理
>
> **扩容遍历指针**、**当前维护指针** **从小维护到大**
>
> ### 当前维护指针-维护方向
>
> #### (1)条件边界
>
> **根据条件** **判搬新值 维护一个条件边界**

---

## 三、提交代码

```
public void moveZeroes(int[] nums) {
    int cur = 0;
    int dest = -1;
    while(cur < nums.length) {
        if(nums[cur] != 0) {
            int tmp;
            tmp = nums[++dest];//除最开始时外，就是0的
            nums[dest] = nums[cur];
            nums[cur] = tmp;
        }
        cur++;
    }
}
```

![](https://i-blog.csdnimg.cn/direct/75e58d41ca614777b160e9bc5b221931.png)



