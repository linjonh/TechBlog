---
layout: post
title: "Linux从互斥原理到C-RAII封装实践"
date: 2025-03-14 15:46:18 +0800
description: "紧接上回的线程C++封装，这回笔者着重介绍一下互斥的原理和其必要性，并手把手使用C++封装一个RAII模型。还有一点，笔者之后的封装都会使用之前博客中封装好的容器，需要的可以去仓库或者前面的博客中自取。RAII的核心思想是将资源的获取和初始化放在对象的构造函数中进行，而资源的释放放在对象的析构函数中进行。当对象被创建时，其构造函数会自动执行，从而完成资源的获取；当对象的生命周期结束时，其析构函数会被自动调用，从而完成资源的释放。"
keywords: "【Linux】从互斥原理到C++ RAII封装实践"
categories: ['未分类']
tags: ['Linux', 'C']
artid: "146257773"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257773
    alt: "Linux从互斥原理到C-RAII封装实践"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257773
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257773
cover: https://bing.ee123.net/img/rand?artid=146257773
image: https://bing.ee123.net/img/rand?artid=146257773
img: https://bing.ee123.net/img/rand?artid=146257773
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Linux】从互斥原理到C++ RAII封装实践
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      📢博客主页：
      <a href="https://blog.csdn.net/2301_77954967?spm=1011.2444.3001.5343">
       https://blog.csdn.net/2301_779549673
      </a>
      <br/>
      📢欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！
      <br/>
      📢本文由
      <em>
       <strong>
        JohnKi
       </strong>
      </em>
      原创，首发于 CSDN🙉
      <br/>
      📢未来很长，值得我们全力奔赴更美好的生活✨
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/direct/9393ea55f0d5414da8e09bd55eb82f4f.gif#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/direct/b55982b2fa5b47dda351a719b325c9e1.gif#pic_center"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_20">
     </a>
     📢前言
    </h2>
    <p>
     紧接上回的
     <code>
      线程C++封装
     </code>
     ，这回笔者着重介绍一下互斥的原理和其必要性，并手把手使用C++封装一个RAII模型。
    </p>
    <p>
     还有一点，笔者之后的封装都会使用之前博客中封装好的容器，需要的可以去仓库或者前面的博客中自取。
    </p>
    <p>
     <code>
      RAII
     </code>
     的核心思想是将资源的获取和初始化放在对象的构造函数中进行，而资源的释放放在对象的析构函数中进行。当对象被创建时，其构造函数会自动执行，从而完成资源的获取；当对象的生命周期结束时，其析构函数会被自动调用，从而完成资源的释放。这样，资源的生命周期就与对象的生命周期绑定在一起，利用 C++ 等语言的对象自动销毁机制来确保资源的正确释放。
    </p>
    <hr/>
    <h2>
     <a id="_31">
     </a>
     🏳️‍🌈一、从场景看互斥：为什么需要锁？
    </h2>
    <p>
     <strong>
      假设你的银行账户余额是1000元，同时有两个线程执行转账操作：
     </strong>
    </p>
    <ul>
     <li>
      ​线程A：存入200元 → balance += 200
     </li>
     <li>
      ​线程B：取出300元 → balance -= 300
      <br/>
      <strong>
       无锁情况下可能的执行顺序：
      </strong>
     </li>
    </ul>
    <pre><code class="prism language-cpp">线程A读取<span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> → 线程B读取<span class="token function">balance</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> → 
线程A写入<span class="token number">1200</span> → 线程B写入<span class="token number">700</span>  
最终结果：<span class="token number">700</span>元（正确应为<span class="token number">900</span>元）
</code></pre>
    <h2>
     <a id="_44">
     </a>
     🏳️‍🌈二、互斥锁核心概念图解
    </h2>
    <h3>
     <a id="21__45">
     </a>
     2.1 临界区与非临界区
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/11f6297af1ca40baba191298248094b7.png"/>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 非临界区（可并发执行）</span>
    <span class="token function">prepare_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    
    <span class="token comment">// 临界区（需互斥访问）</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_shared_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 非临界区（可并发执行）</span>
    <span class="token function">post_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     关键特征：
    </p>
    <p>
     🔵 ​非临界区：允许多线程并行（如图中绿色区域）
     <br/>
     🔴 ​临界区：同一时刻仅一个线程执行（红色区域）
    </p>
    <h3>
     <a id="2_2__67">
     </a>
     2. 2 进程线程间的互斥相关背景概念
    </h3>
    <ul>
     <li>
      <strong>
       临界资源
      </strong>
      :多线程执行流共享的资源就叫做临界资源
     </li>
     <li>
      <strong>
       临界区
      </strong>
      :每个线程内部，访问临界资源的代码，就叫做临界区
     </li>
     <li>
      <strong>
       互斥
      </strong>
      :任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用
     </li>
     <li>
      <strong>
       原子性
      </strong>
      :(后面讨论如何实现):不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成
     </li>
    </ul>
    <h2>
     <a id="Linux_72">
     </a>
     🏳️‍🌈三、Linux互斥锁原理剖析
    </h2>
    <p>
     <strong>
      核心操作流程：
     </strong>
    </p>
    <pre><code class="prism language-cpp">sequenceDiagram
    participant 线程A
    participant 互斥锁
    participant 内核
    
    线程A<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>互斥锁<span class="token operator">:</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    alt 锁空闲
        互斥锁<span class="token operator">--</span><span class="token operator">&gt;&gt;</span>线程A<span class="token operator">:</span> 立即获得锁
    <span class="token keyword">else</span> 锁被占
        线程A<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>内核<span class="token operator">:</span> 进入休眠队列
        内核<span class="token operator">--</span><span class="token operator">&gt;&gt;</span>线程A<span class="token operator">:</span> 唤醒并获取锁
    end
    线程A<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>临界区<span class="token operator">:</span> 执行操作
    线程A<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>互斥锁<span class="token operator">:</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <h3>
     <a id="32__93">
     </a>
     3.2 初始化互斥量
    </h3>
    <p>
     <strong>
      方法一：静态分布
     </strong>
    </p>
    <pre><code class="prism language-cpp">pthread_mutex_t mutex <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER
</code></pre>
    <p>
     <strong>
      方法二：动态分布
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      mutex
     </strong>
     ：要初始化的互斥量
     <br/>
     <strong>
      attr
     </strong>
     ：NULL
    </p>
    <h3>
     <a id="33__108">
     </a>
     3.3 销毁互斥量
    </h3>
    <p>
     <strong>
      销毁互斥量需要注意：
     </strong>
    </p>
    <ul>
     <li>
      使用 PTHREAD_MUTEXINITIALIZER 初始化的互斥量不需要销毁
     </li>
     <li>
      不要销毁一个已经加锁的互斥量
     </li>
     <li>
      已经销毁的互斥量，要确保后面不会有线程再尝试加锁
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span>；
</code></pre>
    <p>
     <strong>
      互斥量加锁和解锁
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
返回值<span class="token operator">:</span>成功返回<span class="token number">0</span><span class="token punctuation">,</span>失败返回错误号
</code></pre>
    <p>
     <strong>
      调⽤ pthread_mutex_lock 时，可能会遇到以下情况:
     </strong>
    </p>
    <ul>
     <li>
      互斥量处于未锁状态，该函数会将互斥量锁定，同时返回成功
     </li>
     <li>
      发起函数调用时，其他线程已经锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互斥量，那么pthread lock调用会陷入阻塞(执行流被挂起)，等待互斥量解锁。
     </li>
    </ul>
    <h3>
     <a id="33_pthread_mutex__132">
     </a>
     3.3 pthread_mutex 底层实现
    </h3>
    <pre><code class="prism language-cpp"><span class="token comment">// 锁结构（简化为x86实现）</span>
<span class="token keyword">struct</span> <span class="token class-name">pthread_mutex</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> __lock<span class="token punctuation">;</span>          <span class="token comment">// 锁状态标识</span>
    <span class="token keyword">int</span> __count<span class="token punctuation">;</span>         <span class="token comment">// 递归锁计数器</span>
    <span class="token keyword">int</span> __owner<span class="token punctuation">;</span>         <span class="token comment">// 持有者线程ID</span>
    <span class="token keyword">int</span> __kind<span class="token punctuation">;</span>          <span class="token comment">// 锁类型标识</span>
    <span class="token comment">// ... 其他字段</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <h2>
     <a id="C_RAII_144">
     </a>
     🏳️‍🌈四、C++ RAII封装实战
    </h2>
    <h3>
     <a id="41_Mutex_145">
     </a>
     4.1 基础互斥类（Mutex）
    </h3>
    <pre><code class="prism language-cpp"><span class="token comment">// 互斥锁封装类（不可拷贝构造/赋值）</span>
    <span class="token keyword">class</span> <span class="token class-name">Mutex</span>
    <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 禁止拷贝（保护系统锁资源）</span>
        <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token keyword">const</span> Mutex<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> Mutex<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Mutex<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

        <span class="token comment">// 构造函数：初始化POSIX互斥锁</span>
        <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 初始化互斥锁属性为默认值</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> <span class="token comment">// 实际开发建议处理错误码</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 析构函数：销毁锁资源</span>
        <span class="token operator">~</span><span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 确保锁已处于未锁定状态</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> <span class="token comment">// 生产环境应检查返回值</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 加锁操作（阻塞直至获取锁）</span>
        <span class="token keyword">void</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 可能返回EDEADLK（死锁检测）等错误码</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> <span class="token comment">// 简化处理，实际建议抛异常或记录日志</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 解锁操作（必须由锁持有者调用）</span>
        <span class="token keyword">void</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 未持有锁时解锁将返回EPERM</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        pthread_mutex_t _lock<span class="token punctuation">;</span> <span class="token comment">// 底层锁对象</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="42_LockGuard_192">
     </a>
     4.2 守卫锁（LockGuard）
    </h3>
    <p>
     守卫锁不是新的锁类型，而是对已有锁的自动化生命周期管理工具。这种设计模式完美契合图示中"Lock-unlock"边界需要严格匹配的核心诉求
    </p>
    <p>
     <strong>
      守卫锁工作流程
     </strong>
    </p>
    <pre><code class="prism language-cpp">sequenceDiagram
    participant 线程
    participant 守卫锁
    participant 互斥锁
    
    线程<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>守卫锁<span class="token operator">:</span> 创建LockGuard对象
    守卫锁<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>互斥锁<span class="token operator">:</span> 调用<span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    互斥锁<span class="token operator">--</span><span class="token operator">&gt;&gt;</span>守卫锁<span class="token operator">:</span> 获得锁
    线程<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>临界区<span class="token operator">:</span> 执行操作
    线程<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>守卫锁<span class="token operator">:</span> 对象离开作用域
    守卫锁<span class="token operator">-&gt;</span><span class="token operator">&gt;</span>互斥锁<span class="token operator">:</span> 调用<span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    互斥锁<span class="token operator">--</span><span class="token operator">&gt;&gt;</span>其他线程<span class="token operator">:</span> 释放锁资源
</code></pre>
    <p>
     <strong>
      实现
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// RAII锁守卫（自动管理锁生命周期）</span>
    <span class="token keyword">class</span> <span class="token class-name">LockGuard</span>
    <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 构造时加锁（必须传入已初始化的Mutex引用）</span>
        <span class="token function">LockGuard</span><span class="token punctuation">(</span>Mutex <span class="token operator">&amp;</span>mtx<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_mtx</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            _mtx<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入临界区</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 析构时自动解锁（异常安全保证）</span>
        <span class="token operator">~</span><span class="token function">LockGuard</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            _mtx<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 离开作用域自动释放</span>
        <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        Mutex <span class="token operator">&amp;</span>_mtx<span class="token punctuation">;</span> <span class="token comment">// 引用方式持有，避免拷贝导致未定义行为</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <h2>
     <a id="_234">
     </a>
     🏳️‍🌈五、完整代码
    </h2>
    <h3>
     <a id="51_Mutexhpp_235">
     </a>
     5.1 Mutex.hpp
    </h3>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span> <span class="token comment">// POSIX线程库头文件</span></span>

<span class="token keyword">namespace</span> LockModule
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 互斥锁封装类（不可拷贝构造/赋值）</span>
    <span class="token keyword">class</span> <span class="token class-name">Mutex</span>
    <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 禁止拷贝（保护系统锁资源）</span>
        <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token keyword">const</span> Mutex<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> Mutex<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Mutex<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

        <span class="token comment">// 构造函数：初始化POSIX互斥锁</span>
        <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 初始化互斥锁属性为默认值</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> <span class="token comment">// 实际开发建议处理错误码</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 析构函数：销毁锁资源</span>
        <span class="token operator">~</span><span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 确保锁已处于未锁定状态</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> <span class="token comment">// 生产环境应检查返回值</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 加锁操作（阻塞直至获取锁）</span>
        <span class="token keyword">void</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 可能返回EDEADLK（死锁检测）等错误码</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> <span class="token comment">// 简化处理，实际建议抛异常或记录日志</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 解锁操作（必须由锁持有者调用）</span>
        <span class="token keyword">void</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 未持有锁时解锁将返回EPERM</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        pthread_mutex_t _lock<span class="token punctuation">;</span> <span class="token comment">// 底层锁对象</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// RAII锁守卫（自动管理锁生命周期）</span>
    <span class="token keyword">class</span> <span class="token class-name">LockGuard</span>
    <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 构造时加锁（必须传入已初始化的Mutex引用）</span>
        <span class="token function">LockGuard</span><span class="token punctuation">(</span>Mutex <span class="token operator">&amp;</span>mtx<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_mtx</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            _mtx<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入临界区</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 析构时自动解锁（异常安全保证）</span>
        <span class="token operator">~</span><span class="token function">LockGuard</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            _mtx<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 离开作用域自动释放</span>
        <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        Mutex <span class="token operator">&amp;</span>_mtx<span class="token punctuation">;</span> <span class="token comment">// 引用方式持有，避免拷贝导致未定义行为</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="52_Mutexcc_310">
     </a>
     5.2 Mutex.cc
    </h3>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sched.h&gt;</span></span>

<span class="token keyword">int</span> ticket <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pthread_mutex_t mutex<span class="token punctuation">;</span>
pthread_cond_t cond <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> <span class="token operator">*</span>id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ticket <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s sells ticket:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ticket<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s wait on cond!\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//醒来的时候，会重新申请锁！！</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s 被叫醒了\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pthread_t t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">,</span> t4<span class="token punctuation">;</span>

    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> route<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> route<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> route<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t4<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> route<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread 4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ticket <span class="token operator">+=</span> cnt<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"主线程放票喽, ticket: %d\n"</span><span class="token punctuation">,</span> ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t3<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t4<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="53_Makefile_378">
     </a>
     5.3 Makefile
    </h3>
    <pre><code class="prism language-cpp">bin<span class="token operator">=</span>testMutex
cc<span class="token operator">=</span>g<span class="token operator">++</span>
src<span class="token operator">=</span>$<span class="token punctuation">(</span>wildcard <span class="token operator">*</span><span class="token punctuation">.</span>cc<span class="token punctuation">)</span>
obj<span class="token operator">=</span>$<span class="token punctuation">(</span>src<span class="token operator">:</span><span class="token punctuation">.</span>cc<span class="token operator">=</span><span class="token punctuation">.</span>o<span class="token punctuation">)</span>

$<span class="token punctuation">(</span>bin<span class="token punctuation">)</span><span class="token operator">:</span>$<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
	$<span class="token punctuation">(</span>cc<span class="token punctuation">)</span> <span class="token operator">-</span>o $@ $<span class="token operator">^</span> <span class="token operator">-</span>lpthread
<span class="token operator">%</span><span class="token punctuation">.</span>o<span class="token operator">:</span><span class="token operator">%</span><span class="token punctuation">.</span>cc
	$<span class="token punctuation">(</span>cc<span class="token punctuation">)</span> <span class="token operator">-</span>c $<span class="token operator">&lt;</span> <span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">17</span>

<span class="token punctuation">.</span>PHONY<span class="token operator">:</span>clean
clean<span class="token operator">:</span>
	rm <span class="token operator">-</span>f $<span class="token punctuation">(</span>bin<span class="token punctuation">)</span> $<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>

<span class="token punctuation">.</span>PHONY<span class="token operator">:</span>test
test<span class="token operator">:</span>
	echo $<span class="token punctuation">(</span>src<span class="token punctuation">)</span>
	echo $<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre>
    <hr/>
    <h2>
     <a id="_405">
     </a>
     👥总结
    </h2>
    <p>
     本篇博文对
     <strong>
      从互斥原理到C++ RAII封装实践
     </strong>
     做了一个较为详细的介绍，不知道对你有没有帮助呢
    </p>
    <p>
     觉得博主写得还不错的三连支持下吧！会继续努力的~
    </p>
    <p>
     <img alt="请添加图片描述" height="400" src="https://img-blog.csdnimg.cn/direct/ccd277ddb2e84277b6970d9cc24da8bd.jpeg#pic_center" width="600"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373935343936372f:61727469636c652f64657461696c732f313436323537373733" class_="artid" style="display:none">
 </p>
</div>


