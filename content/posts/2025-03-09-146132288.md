---
layout: post
title: "list的模拟实现"
date: 2025-03-09 16:44:17 +0800
description: "C++中stl中的list的模拟实现 思路及代码 附源码cv即可"
keywords: "list的模拟实现"
categories: ['未分类']
tags: ['链表', '迭代器', '数据结构', 'List', 'List', 'C']
artid: "146132288"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146132288
    alt: "list的模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146132288
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146132288
cover: https://bing.ee123.net/img/rand?artid=146132288
image: https://bing.ee123.net/img/rand?artid=146132288
img: https://bing.ee123.net/img/rand?artid=146132288
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     list的模拟实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <span style="color:#fe2c24">
      <strong>
       一：框架
      </strong>
     </span>
    </h3>
    <p>
     <u>
      <span style="color:#0d0016">
       <strong>
        ①：
       </strong>
      </span>
     </u>
     由stl的源码可知，list内部 其实就是带哨兵位循环双向链表
    </p>
    <p>
     <img alt="" height="234" src="https://i-blog.csdnimg.cn/direct/5c1620aa53b74c618d41480e0ebe1ae4.png" width="1068"/>
    </p>
    <p>
     <u>
      <span style="color:#0d0016">
       <strong>
        ②：
       </strong>
      </span>
     </u>
     用三个类实现，分别是：节点类，迭代器类，链表类
    </p>
    <p>
     本文实现的是三个类在同一个域中
    </p>
    <p>
     <img alt="" height="241" src="https://i-blog.csdnimg.cn/direct/e5fda509b39248d7acdeaf49a5009957.png" width="653"/>
    </p>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <span style="color:#fe2c24">
      Q：
     </span>
     为什么list的迭代器是一个类，而string和vector中的迭代器是指针？
    </p>
    <p>
     <span style="color:#fe2c24">
      A：
     </span>
     string和vector中的迭代器是指针是因为，在string和vector中，它们的物理地址都是连续的，因此可以直接使用指针来表示迭代器，此时的指针++ 和 *解引用等，均可以得到想要的结果；
    </p>
    <p>
     但在list中，其物理地址并不连续，单纯的指针++和*解引用等，达不到我们想要的结果，所以我们吧这个指针封装成一个类，在类中重载++和*解引用等操作符，让其达到我们想要的效果
    </p>
    <p>
    </p>
    <h3>
     <span style="color:#fe2c24">
      二：三个类的成员变量
     </span>
    </h3>
    <h4>
     <u>
      <span style="color:#0d0016">
       <strong>
        ①：节点类
       </strong>
      </span>
     </u>
    </h4>
    <pre><code class="language-cpp">    //节点类
	template&lt;class T&gt;
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;//指向下一个节点的指针
		ListNode&lt;T&gt;* _prev;//指向上一个节点的指针
		T _data;//该节点的数据

	};</code></pre>
    <p>
     <strong>
      解释：
     </strong>
     节点类的成员变量应该有
    </p>
    <p>
     节点的值_data
    </p>
    <p>
     一个_prev指针指向前一个节点
    </p>
    <p>
     一个_next指针指向后一个节点
    </p>
    <p>
    </p>
    <h4>
     <u>
      <span style="color:#0d0016">
       <strong>
        ②：迭代器类
       </strong>
      </span>
     </u>
    </h4>
    <pre><code class="language-cpp">//迭代器类
	template&lt;class T, class Ref, class Ptr&gt;
	struct __list_iterator
	{
		typedef ListNode&lt;T&gt; Node;//节点类的typedef

		Node* _node;//唯一的一个成员变量(对内置类型封装成自定义类型)
	};</code></pre>
    <p>
     <strong>
      解释：
     </strong>
     迭代器类既然是对一个结构体指针的封装，那么成员变量就只有一个结构体指针
    </p>
    <p>
    </p>
    <h4>
     <span style="color:#0d0016">
      <u>
       <strong>
        ③：链表类
       </strong>
      </u>
     </span>
    </h4>
    <pre><code class="language-cpp">//链表类
	template&lt;class T&gt;
	class list
	{
		typedef ListNode&lt;T&gt; Node;//节点类的typedef
	
	private:
		Node* _head;//list类的唯一一个成员变量 头结点
	};</code></pre>
    <p>
     <strong>
      解释：
     </strong>
     链表类中成员变量为一个头结点，因为双向循环带头链表，初始状态就是一个头结点
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       Q：
      </strong>
     </span>
     为什么前两个类是struct，最后一个是class？
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       A：
      </span>
     </strong>
    </p>
    <p>
     <em>
      <strong>
       1.
       <code>
        ListNode
       </code>
       和
       <code>
        __list_iterator
       </code>
       的设计考虑
      </strong>
     </em>
    </p>
    <p>
     <strong>
      <code>
       ListNode
      </code>
     </strong>
     ：这是一个简单的节点类，通常用于表示链表中的一个节点。它的成员变量（
     <code>
      _next
     </code>
     、
     <code>
      _prev
     </code>
     、
     <code>
      _data
     </code>
     ）通常需要被外部直接访问，尤其是在链表中节点的连接和删除操作中。因此，使用
     <code>
      struct
     </code>
     可以让这些成员变量默认是
     <code>
      public
     </code>
     的，方便外部直接访问和操作。
    </p>
    <p>
     <strong>
      <code>
       __list_iterator
      </code>
     </strong>
     ：这是一个迭代器类，通常用于遍历链表。它的成员变量（
     <code>
      _node
     </code>
     ）也需要被外部直接访问，尤其是在迭代器的操作中，需要对迭代器类的对象进行++ -- * 等操作。使用
     <code>
      struct
     </code>
     可以让这些成员变量默认是
     <code>
      public
     </code>
     的，方便外部直接访问和操作。
    </p>
    <p>
     <em>
      <strong>
       2.
       <code>
        list
       </code>
       的设计考虑
      </strong>
     </em>
    </p>
    <p>
     <strong>
      <code>
       list
      </code>
     </strong>
     ：这是一个链表类。它的成员变量（
     <code>
      _head
     </code>
     ）头结点不应该被外部直接访问，而是通过类的成员函数来操作各个节点的状态。因此，使用
     <code>
      class
     </code>
     可以让成员变量（
     <code>
      _head
     </code>
     ）默认是
     <code>
      private
     </code>
     的，确保封装性，防止外部直接修改链表的内部状态。
    </p>
    <p>
    </p>
    <h3>
     <span style="color:#fe2c24">
      三：三个类的成员函数、
     </span>
    </h3>
    <h4>
     <u>
      <span style="color:#0d0016">
       ①：节点类
      </span>
     </u>
    </h4>
    <pre><code class="language-cpp">//节点类
	template&lt;class T&gt;
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;//指向下一个节点的指针
		ListNode&lt;T&gt;* _prev;//指向上一个节点的指针
		T _data;//该节点的数据

		ListNode(const T&amp; x = T())//构造函数
			:_next(nullptr)//置空
			, _prev(nullptr)//置空
			, _data(x)//x赋值
		{}
	};</code></pre>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <strong>
      a：
     </strong>
     节点类只需要一个成员函数，那就是构造函数，因为该类的作用在于在list类需要插入节点的时候，会new一个节点类的对象，所以我们只需要对new出来的对象进行初始化就行
    </p>
    <p>
     <strong>
      b：
     </strong>
     _data接收的是传过来的值，插入可肯定要先有值，其余两个指针先置空，连接指向的操作在list链表类的push_back函数中
    </p>
    <p>
     <strong>
      c：
     </strong>
     成员函数被使用的场景：
    </p>
    <pre><code class="language-cpp">Node* newnode = new Node(x);//用x创建一个新节点
</code></pre>
    <h4>
     <span style="color:#0d0016">
      <u>
       ②：迭代器类
      </u>
     </span>
    </h4>
    <pre><code class="language-cpp">//迭代器类
	template&lt;class T, class Ref, class Ptr&gt;
	struct __list_iterator
	{
		typedef ListNode&lt;T&gt; Node;//节点类的typedef
		typedef __list_iterator&lt;T, Ref, Ptr&gt; self;//返回值的typedef

		Node* _node;//唯一的一个成员变量(对内置类型封装成自定义类型)

		__list_iterator(Node* x)//构造函数 接收一个节点指针 赋值给成员变量
			:_node(x)
		{}

		// ++it
		self&amp; operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}

		// it++
		self operator++(int)
		{
			self tmp(*this);
			_node = _node-&gt;_next;

			return tmp;//返回的是tmp 但是*this本身已经++
		}

		//--it
		self&amp; operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}

		//it--
		self operator--(int)
		{
			self tmp(*this);
			_node = _node-&gt;_prev;

			return tmp;
		}

		//*it
		Ref operator*()
		{
			return _node-&gt;_data;
		}

		//list类中的元素是一个自定义对象 
		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;//返回的是该自定义对象的地址
		}

		bool operator!=(const self&amp; s)
		{
			return _node != s._node;//地址对比
		}

		bool operator==(const self&amp; s)
		{
			return _node == s._node;//地址对比
		}
	};</code></pre>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <strong>
      a：
     </strong>
     构造函数：
    </p>
    <pre><code class="language-cpp">__list_iterator(Node* x)//构造函数 接收一个节点指针 赋值给成员变量
    :_node(x)
	{}</code></pre>
    <p>
     其实本质就是把Node*这种类型的指针赋值给了成员变量，间接的把一个Node*指针封装成了一个类，x就是无法满足迭代器要求的Node*指针
    </p>
    <p>
     <strong>
      b：
     </strong>
     三参数模版的意义先暂时不管
    </p>
    <p>
     <strong>
      c：
     </strong>
     其余函数就是重载操作符，让其++ -- *等之后，能的到我们想要的效果
    </p>
    <p>
     <strong>
      d：
     </strong>
     self 即我们调用函数之后都要返回一个当前的迭代器，过长所以typedef
    </p>
    <p>
     <strong>
      e：
      <u>
       重载-&gt;的意义：
      </u>
     </strong>
     如果list的元素是一个结构体，也就是一个类，此时我们又要取它的每一个成员变量，需要用到-&gt;
    </p>
    <p>
     比如是一个日期类，假设我们没有实现其流插入，我们自己访问
    </p>
    <pre><code class="language-cpp">	struct Date {
		int _year;
		int _month;
		int _day;
 
		Date(int year = 1, int month = 1, int day = 1) 
			: _year(year)
			, _month(month)
			, _day(day) 
		{}
	};
 
	void test_list3() {
		list&lt;Date&gt; L;
		L.push_back(Date(2022, 5, 1));
		L.push_back(Date(2022, 5, 2));
		L.push_back(Date(2022, 5, 3));
 
		list&lt;Date&gt;::iterator it = L.begin();
		while (it != L.end()) {
			// cout &lt;&lt; *it &lt;&lt; " ";  假设我们没有实现流插入，我们自己访问
			cout &lt;&lt; (*it)._year &lt;&lt; "/" &lt;&lt; (*it)._month &lt;&lt; "/" &lt;&lt; (*it)._day &lt;&lt; endl;
			it++;
		}
		cout &lt;&lt; endl;
	}</code></pre>
    <h4>
     <img alt="" height="112" src="https://i-blog.csdnimg.cn/direct/728a489795b045c3ad24b34b0f56eda1.png" width="508"/>
    </h4>
    <p>
     <em>
      我们发现，在我们没有实现日期类的流提取运算符的前提下，想去迭代链表 L，
     </em>
    </p>
    <p>
     <em>
      我们就需要 *(it)._xxx 去访问，而大多数主流习惯应该是用 -&gt; 去访问的：
     </em>
    </p>
    <p>
     <em>
      ​（诚然，用 *. 去访问完全没有问题）
     </em>
    </p>
    <p>
     <em>
      所以我们这里可以去实现一下箭头操作符 -&gt;
     </em>
    </p>
    <p>
     <img alt="" height="360" src="https://i-blog.csdnimg.cn/direct/7d08a6a97e7d47c58036455055ef3c21.png" width="850"/>
    </p>
    <p>
     <strong>
      总结：
     </strong>
     所有类型重载 operator-&gt; 时都会省略一个箭头。
    </p>
    <h4>
     <u>
      <span style="color:#0d0016">
       ③：链表类
      </span>
     </u>
    </h4>
    <pre><code class="language-cpp">//链表类
	template&lt;class T&gt;
	class list
	{
		typedef ListNode&lt;T&gt; Node;//节点类的typedef
	public:
		typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;//将迭代器类typedef为统一的名字
		typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;//将迭代器类typedef为统一的名字
		//二者的不同在于list这个类的对象是否为const 


		iterator begin()
		{
			return _head-&gt;_next;//单参构造函数的隐式转换
		}

		iterator end()
		{
			return _head;//单参构造函数的隐式转换
		}

		const_iterator begin() const
		{
			return _head-&gt;_next;//单参构造函数的隐式转换
		}

		const_iterator end() const
		{
			return _head;//单参构造函数的隐式转换
		}

		void empty_init()//初始化函数
		{
			_head = new Node;
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			//创建一个头结点，自己指向自己
		}

		list()//构造函数复用初始化函数
		{
			empty_init();
		}

		void clear()//清理函数 清理除了头结点以外的所有节点 
		{
			iterator it = begin();
			while (it != end())
			{
				it = erase(it);
			}
		}

		~list()//复用清理函数  最后再对头结点进行释放置空
		{
			clear();

			delete _head;
			_head = nullptr;
		}


		list(const list&lt;T&gt;&amp; lt)//拷贝构造函数 被拷贝的对象不应该被修改所以用const
		{
			empty_init();//先对*this进行初始化（给一个头结点）

			for (const auto&amp; e : lt)//从it（被拷贝的对象）中范围for边读取边push到*this中
			{
				push_back(e);
			}
		}

		void swap(list&lt;T&gt;&amp; tmp)//交换函数 交换头结点即可
		{
			std::swap(_head, tmp._head);
		}

		//赋值函数
		list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)//参数用传值 触发拷贝构造生成it
		{
			swap(lt);//再把it和*this交换 
			return *this;
		}

		//尾插
		void push_back(const T&amp; x)
		{
			insert(end(), x);
		}

		//头插
		void push_front(const T&amp; x)
		{
			insert(begin(), x);
		}

		//尾删
		void pop_back()
		{
			erase(--end());
		}

		//头删
		void pop_front()
		{
			erase(begin());
		}


		// vector insert会导致迭代器失效
		// list会不会？不会  因为无扩容
		iterator insert(iterator pos, const T&amp; x)
		{
			Node* cur = pos._node;//保存pos位置的节点
			Node* prev = cur-&gt;_prev;//保存pos位置的前一个节点
			Node* newnode = new Node(x);//用x创建一个新节点

			// prev newnode cur 缝合三者
			prev-&gt;_next = newnode;
			newnode-&gt;_prev = prev;
			newnode-&gt;_next = cur;
			cur-&gt;_prev = newnode;

			return newnode;//单参构造的隐式转换 这样也符合统一标准
		}

		//清理函数 只保留头结点
		iterator erase(iterator pos)
		{
			assert(pos != end());//end()为头结点 不能erase

			Node* cur = pos._node;
			Node* prev = cur-&gt;_prev;
			Node* next = cur-&gt;_next;
			prev-&gt;_next = next;
			next-&gt;_prev = prev;//缝合

			delete cur;//释放

			return next;//返回pos位置的下一个节点
		}

	private:
		Node* _head;//list类的唯一一个成员变量 头结点
	};

}</code></pre>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <strong>
      a：
     </strong>
     typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;
     <br/>
     typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;
    </p>
    <p>
     是否const的对象，调用的迭代器不同，所以我们这里对两种迭代器进行了正确的明确，因为我们迭代器的名字就是iterator 和 const_iterator
    </p>
    <p>
     <strong>
      b：
     </strong>
     begin函数和end函数 分别写两种，因为要被正常对象和const对象分别调用
    </p>
    <p>
     <strong>
      c：
     </strong>
     构造函数，链表的构造就是给一个头结点，然后该节点的_prev和_next都指向自己
    </p>
    <p>
     <strong>
      d：
     </strong>
     赋值函数是一种现代写法，如list1 = list2 ，此时参数用传值，触发拷贝构造生成list2的拷贝之后的lt，然后交换二者即可
    </p>
    <p>
    </p>
    <h3>
     <span style="color:#fe2c24">
      四：三个类的模版的串联
     </span>
    </h3>
    <p>
     用一个例子来讲解，当我们进行以下操作的时候，各个类之间的模版是怎么相互影响的？
    </p>
    <pre><code class="language-cpp">list&lt;int&gt; lt;
		lt.push_back(1);
		lt.push_back(2);
		lt.push_back(3);
		lt.push_back(4);

		list&lt;int&gt;::iterator it = lt.begin();
		while (it != lt.end())
		{
			//*it += 10;

			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}</code></pre>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <strong>
      <u>
       1.
       <code>
        list&lt;int&gt; lt
       </code>
       的实例化
      </u>
     </strong>
    </p>
    <p>
     当我们定义
     <code>
      list&lt;int&gt; lt
     </code>
     时：
    </p>
    <p>
     <code>
      list&lt;int&gt;
     </code>
     的模板参数
     <code>
      T
     </code>
     被替换为
     <code>
      int
     </code>
     。
    </p>
    <p>
     此时，
     <code>
      list&lt;int&gt;
     </code>
     内部的类型定义会被展开为：
    </p>
    <pre><code class="language-cpp">typedef ListNode&lt;int&gt; Node; // 节点类
typedef __list_iterator&lt;int, int&amp;, int*&gt; iterator; // 普通迭代器
typedef __list_iterator&lt;int, const int&amp;, const int*&gt; const_iterator; // const迭代器</code></pre>
    <p>
    </p>
    <p>
     <strong>
      <u>
       2.
       <code>
        lt.push_back(1)
       </code>
       的调用
      </u>
     </strong>
    </p>
    <p>
     <code>
      push_back
     </code>
     是
     <code>
      list
     </code>
     的成员函数，用于在链表尾部插入一个元素。当我们调用
     <code>
      lt.push_back(1)
     </code>
     时：
    </p>
    <p>
     <code>
      push_back
     </code>
     的参数类型是
     <code>
      T
     </code>
     ，即
     <code>
      int
     </code>
     。
    </p>
    <p>
     <code>
      push_back
     </code>
     内部会创建一个
     <code>
      ListNode&lt;int&gt;
     </code>
     节点，并将
     <code>
      1
     </code>
     存储到节点的
     <code>
      _data
     </code>
     成员中。
    </p>
    <p>
     新节点会被链接到链表的尾部。
    </p>
    <p>
    </p>
    <p>
     <u>
      3.
      <strong>
       <code>
        list&lt;int&gt;::iterator it = lt.begin()
       </code>
       的调用
      </strong>
     </u>
    </p>
    <p>
     <code>
      begin()
     </code>
     是
     <code>
      list
     </code>
     的成员函数，用于返回指向链表第一个元素的迭代器。当我们调用
     <code>
      lt.begin()
     </code>
     时：
    </p>
    <p>
     <code>
      begin()
     </code>
     的返回类型是
     <code>
      iterator
     </code>
     ，即
     <code>
      __list_iterator&lt;int, int&amp;, int*&gt;
     </code>
     。
    </p>
    <p>
     <code>
      iterator
     </code>
     是一个迭代器类，它的模板参数展开为：
    </p>
    <pre><code class="language-cpp">struct __list_iterator&lt;int, int&amp;, int*&gt; {
    typedef ListNode&lt;int&gt; Node; // 节点类的typedef
    Node* _node; // 指向 ListNode&lt;int&gt; 的指针
};</code></pre>
    <p>
    </p>
    <p>
     <code>
      begin()
     </code>
     返回的迭代器会指向链表的第一个节点（即
     <code>
      _head-&gt;_next
     </code>
     ）。
    </p>
    <p>
    </p>
    <p>
     <u>
      4.
      <strong>
       <code>
        *it
       </code>
       的解引用操作
      </strong>
     </u>
    </p>
    <p>
     <code>
      *it
     </code>
     是迭代器的解引用操作，用于获取当前节点的数据。当我们调用
     <code>
      *it
     </code>
     时：
    </p>
    <p>
     <code>
      *it
     </code>
     的实现会调用
     <code>
      __list_iterator&lt;int, int&amp;, int*&gt;
     </code>
     的
     <code>
      operator*
     </code>
     函数。
    </p>
    <p>
     <code>
      operator*
     </code>
     的实现通常是：
    </p>
    <pre><code class="language-cpp">Ref operator*() const {
    return _node-&gt;_data; // 返回当前节点的数据
}</code></pre>
    <p>
     在这里，
     <code>
      Ref
     </code>
     是
     <code>
      int&amp;
     </code>
     ，因此
     <code>
      *it
     </code>
     返回的是
     <code>
      int&amp;
     </code>
     ，即当前节点的
     <code>
      _data
     </code>
     的引用。
    </p>
    <p>
    </p>
    <p>
     <u>
      5.
      <strong>
       <code>
        ++it
       </code>
       的迭代操作
      </strong>
     </u>
    </p>
    <p>
     <code>
      ++it
     </code>
     是迭代器的自增操作，用于将迭代器移动到下一个节点。当我们调用
     <code>
      ++it
     </code>
     时：
    </p>
    <p>
     <code>
      ++it
     </code>
     的实现会调用
     <code>
      __list_iterator&lt;int, int&amp;, int*&gt;
     </code>
     的
     <code>
      operator++
     </code>
     函数。
    </p>
    <p>
     <code>
      operator++
     </code>
     的实现通常是：
    </p>
    <pre><code class="language-cpp">iterator&amp; operator++() {
    _node = _node-&gt;_next; // 移动到下一个节点
    return *this;
}</code></pre>
    <p>
    </p>
    <p>
     <u>
      <strong>
       6.
       <code>
        it != lt.end()
       </code>
       的比较操作
      </strong>
     </u>
    </p>
    <p>
     <code>
      it != lt.end()
     </code>
     是迭代器的比较操作，用于判断迭代器是否到达链表末尾。当我们调用
     <code>
      it != lt.end()
     </code>
     时：
    </p>
    <p>
     <code>
      end()
     </code>
     的返回类型是
     <code>
      iterator
     </code>
     ，即
     <code>
      __list_iterator&lt;int, int&amp;, int*&gt;
     </code>
     。
    </p>
    <p>
     <code>
      end()
     </code>
     返回的迭代器会指向链表的哨兵节点（即
     <code>
      _head
     </code>
     ）。
    </p>
    <p>
     <code>
      !=
     </code>
     的实现会调用
     <code>
      __list_iterator&lt;int, int&amp;, int*&gt;
     </code>
     的
     <code>
      operator!=
     </code>
     函数。
    </p>
    <p>
     <code>
      operator!=
     </code>
     的实现通常是：
    </p>
    <pre><code class="language-cpp">bool operator!=(const iterator&amp; other) const {
    return _node != other._node; // 比较两个迭代器是否指向同一个节点
}</code></pre>
    <p>
     <strong>
      <u>
       7.  模板参数的互相影响总结
      </u>
     </strong>
     <br/>
     在整个过程中，模板参数的互相影响如下：
    </p>
    <p>
     <strong>
      a：list&lt;int&gt;：
     </strong>
    </p>
    <p>
     模板参数 T 被替换为 int。
     <br/>
     内部类型 Node 被展开为 ListNode&lt;int&gt;。
    </p>
    <p>
     内部类型 iterator 被展开为 __list_iterator&lt;int, int&amp;, int*&gt;。
    </p>
    <p>
     <strong>
      b：ListNode&lt;int&gt;：
     </strong>
    </p>
    <p>
     存储 int 类型的数据。
    </p>
    <p>
     提供指向前后节点的指针（_next 和 _prev）。
    </p>
    <p>
     <strong>
      c：__list_iterator&lt;int, int&amp;, int*&gt;：
     </strong>
    </p>
    <p>
     模板参数 T 被替换为 int。
    </p>
    <p>
     模板参数 Ref 被替换为 int&amp;，表示解引用操作返回 int&amp;。
    </p>
    <p>
     模板参数 Ptr 被替换为 int*，表示指针操作返回 int*。
    </p>
    <p>
     <strong>
      d：push_back：
     </strong>
    </p>
    <p>
     参数类型是 int。
    </p>
    <p>
     内部创建 ListNode&lt;int&gt; 节点并链接到链表尾部。
    </p>
    <p>
     <strong>
      e：begin() 和 end()：
     </strong>
    </p>
    <p>
     返回类型是 iterator，即 __list_iterator&lt;int, int&amp;, int*&gt;。
    </p>
    <p>
     begin() 返回指向第一个节点的迭代器。
    </p>
    <p>
     end() 返回指向哨兵节点的迭代器。
    </p>
    <p>
     <strong>
      f：*it 和 ++it：
     </strong>
    </p>
    <p>
     *it 返回当前节点的 _data（int&amp;）。
    </p>
    <p>
     ++it 将迭代器移动到下一个节点。
    </p>
    <p>
    </p>
    <h3>
     <span style="color:#fe2c24">
      五：源码
     </span>
    </h3>
    <pre><code class="language-cpp">#include&lt;assert.h&gt;
namespace bit
{
	//节点类
	template&lt;class T&gt;
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;//指向下一个节点的指针
		ListNode&lt;T&gt;* _prev;//指向上一个节点的指针
		T _data;//该节点的数据

		ListNode(const T&amp; x = T())//构造函数
			:_next(nullptr)//置空
			, _prev(nullptr)//置空
			, _data(x)//x赋值
		{}
	};

	//迭代器类
	template&lt;class T, class Ref, class Ptr&gt;
	struct __list_iterator
	{
		typedef ListNode&lt;T&gt; Node;//节点类的typedef
		typedef __list_iterator&lt;T, Ref, Ptr&gt; self;//返回值的typedef

		Node* _node;//唯一的一个成员变量(对内置类型封装成自定义类型)

		__list_iterator(Node* x)//构造函数 接收一个节点指针 赋值给成员变量
			:_node(x)
		{}

		// ++it
		self&amp; operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}

		// it++
		self operator++(int)
		{
			self tmp(*this);
			_node = _node-&gt;_next;

			return tmp;//返回的是tmp 但是*this本身已经++
		}

		//--it
		self&amp; operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}

		//it--
		self operator--(int)
		{
			self tmp(*this);
			_node = _node-&gt;_prev;

			return tmp;
		}

		//*it
		Ref operator*()
		{
			return _node-&gt;_data;
		}

		//list类中的元素是一个自定义对象 
		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;//返回的是该自定义对象的地址
		}

		bool operator!=(const self&amp; s)
		{
			return _node != s._node;//地址对比
		}

		bool operator==(const self&amp; s)
		{
			return _node == s._node;//地址对比
		}
	};

	//链表类
	template&lt;class T&gt;
	class list
	{
		typedef ListNode&lt;T&gt; Node;//节点类的typedef
	public:
		typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;//将迭代器类typedef为统一的名字
		typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;//将迭代器类typedef为统一的名字
		//二者的不同在于list这个类的对象是否为const 


		iterator begin()
		{
			return _head-&gt;_next;//单参构造函数的隐式转换
		}

		iterator end()
		{
			return _head;//单参构造函数的隐式转换
		}

		const_iterator begin() const
		{
			return _head-&gt;_next;//单参构造函数的隐式转换
		}

		const_iterator end() const
		{
			return _head;//单参构造函数的隐式转换
		}

		void empty_init()//初始化一个链表
		{
			_head = new Node;
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			//创建一个头结点，自己指向自己
		}

		list()//构造函数复用初始化函数
		{
			empty_init();
		}

		void clear()
		{
			iterator it = begin();
			while (it != end())
			{
				it = erase(it);
			}
		}

		~list()
		{
			clear();

			delete _head;
			_head = nullptr;
		}


		list(const list&lt;T&gt;&amp; lt)//拷贝构造 被拷贝的对象不应该被修改
		{
			empty_init();//先对*this进行初始化

			for (const auto&amp; e : lt)//从it中范围for边读取边push到*this中
			{
				push_back(e);
			}
		}

		void swap(list&lt;T&gt;&amp; tmp)//交换函数 交换头结点即可
		{
			std::swap(_head, tmp._head);
		}

		//赋值函数
		list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)//参数用传值 触发拷贝构造生成it
		{
			swap(lt);//再把it和*this交换 
			return *this;
		}

		//尾插
		void push_back(const T&amp; x)
		{
			insert(end(), x);
		}

		//头插
		void push_front(const T&amp; x)
		{
			insert(begin(), x);
		}

		//尾删
		void pop_back()
		{
			erase(--end());
		}

		//头删
		void pop_front()
		{
			erase(begin());
		}

		// vector insert会导致迭代器失效
		// list会不会？不会  因为无扩容
		iterator insert(iterator pos, const T&amp; x)
		{
			Node* cur = pos._node;//保存pos位置的节点
			Node* prev = cur-&gt;_prev;//保存pos位置的前一个节点
			Node* newnode = new Node(x);//用x创建一个新节点

			// prev newnode cur 缝合三者
			prev-&gt;_next = newnode;
			newnode-&gt;_prev = prev;
			newnode-&gt;_next = cur;
			cur-&gt;_prev = newnode;

			return newnode;//单参构造的隐式转换 这样也符合统一标准
		}

		//清理函数 只保留头结点
		iterator erase(iterator pos)
		{
			assert(pos != end());//end()为头结点 不能erase

			Node* cur = pos._node;
			Node* prev = cur-&gt;_prev;
			Node* next = cur-&gt;_next;
			prev-&gt;_next = next;
			next-&gt;_prev = prev;//缝合

			delete cur;//释放

			return next;//返回pos位置的下一个节点
		}

	private:
		Node* _head;//list类的唯一一个成员变量 头结点
	};

}
</code></pre>
    <h4>
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f7368796c796c795f2f:61727469636c652f64657461696c732f313436313332323838" class_="artid" style="display:none">
 </p>
</div>


