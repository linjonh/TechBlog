---
layout: post
title: "每日八股Redis篇四持久化下"
date: 2025-03-09 00:28:55 +0800
description: "根据 csview 整理 Redis 持久化部分的八股文。"
keywords: "【每日八股】Redis篇（四）：持久化（下）"
categories: ['数据库']
tags: ['缓存', '数据库', 'Redis']
artid: "146125191"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146125191
    alt: "每日八股Redis篇四持久化下"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146125191
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146125191
cover: https://bing.ee123.net/img/rand?artid=146125191
image: https://bing.ee123.net/img/rand?artid=146125191
img: https://bing.ee123.net/img/rand?artid=146125191
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【每日八股】Redis篇（四）：持久化（下）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="Redis__1">
     </a>
     Redis 过期机制？
    </h2>
    <p>
     Redis 的过期机制通过
     <strong>
      惰性删除 + 定期删除
     </strong>
     组合策略实现，同时结合持久化、主从复制等机制处理数据一致性。
    </p>
    <h3>
     <a id="_3">
     </a>
     过期键删除策略
    </h3>
    <p>
     <strong>
      定时删除
     </strong>
    </p>
    <ul>
     <li>
      触发条件：在设置 key 的过期时间时，创建一个定时事件，当时间到达时，由事件处理器执行 key 的删除操作。
     </li>
     <li>
      优点：内存可以被尽快释放，因此定时删除对内存最友好。
     </li>
     <li>
      缺点：定时删除对 CPU 不友好，删除过期 key 会占用相当一部分 CPU 时间，CPU 紧张时如果将 CPU 用于删除和当前无关的过期键，会对服务器的响应时间和吞吐量产生影响。
     </li>
    </ul>
    <p>
     <strong>
      惰性删除
     </strong>
    </p>
    <ul>
     <li>
      触发条件：访问键时触发检查。
     </li>
     <li>
      行为：如果键过期，直接删除并返回空值。
     </li>
     <li>
      优点：CPU 友好，仅实际访问时消耗资源。
     </li>
     <li>
      缺点：可能导致内存泄露（过期但长期不被访问的键无法释放）。
     </li>
    </ul>
    <p>
     <strong>
      定期删除
     </strong>
    </p>
    <ul>
     <li>
      触发条件：Redis 定期扫描过期字典。
     </li>
     <li>
      行为：随机选取
      <code>
       N
      </code>
      个过期的键。删除其中已过期的键，若过期键比例超过
      <code>
       25%
      </code>
      ，则重复该过程。
     </li>
     <li>
      优点：平衡内存和 CPU 资源。
     </li>
    </ul>
    <p>
     <strong>
      Redis 采用惰性删除 + 定期删除两种策略配合使用
     </strong>
     ：平衡 CPU 的合理使用并避免内存浪费。具体来说，Redis 在访问或修改 key 之前，会调用 expireIfNeeded 函数检查 key 是否过期：
    </p>
    <ul>
     <li>
      如果 key 过期，删除 key，返回 null 给客户端；
     </li>
     <li>
      如果没有过期，不做任何处理，返回正常的 value。
     </li>
    </ul>
    <p>
     此外，Redis 在定期删除时，从过期字典中随机抽取
     <code>
      N
     </code>
     （比如
     <code>
      20
     </code>
     ）个key，检查这些 key 是否过期，并删除其中已经过期的 key。如果已经过期的 key 在这
     <code>
      N
     </code>
     个 key 中的数量大于 25%，则重复上述步骤直到比重小于 25%。
    </p>
    <h3>
     <a id="_25">
     </a>
     持久化与过期键
    </h3>
    <p>
     <strong>
      RDB 持久化
     </strong>
    </p>
    <ul>
     <li>
      生成 RDB：过期键不会被保存到 RDB 文件中。
     </li>
     <li>
      加载 RDB：主服务器会忽略过期键，从服务器保留过期键（依赖主从同步删除）。
     </li>
    </ul>
    <p>
     <strong>
      AOF 持久化
     </strong>
    </p>
    <ul>
     <li>
      写入 AOF：键过期后执行 DEL 命令时，AOF 文件追加
      <code>
       DEL
      </code>
      记录。
     </li>
     <li>
      AOF 重写：重写时检查键是否过期，过期键不写入新的 AOF。
     </li>
    </ul>
    <h3>
     <a id="_34">
     </a>
     主从复制与过期键
    </h3>
    <p>
     <strong>
      从服务器不主动删除过期键
     </strong>
     ：而是依赖主服务器同步
     <code>
      DEL
     </code>
     命令。
    </p>
    <p>
     <strong>
      主服务器删除逻辑
     </strong>
     ：主服务器删除过期键后，向从服务器发送
     <code>
      DEL
     </code>
     命令。从服务器读到过期键，返回空值（但不会主动删除）。
    </p>
    <h2>
     <a id="Redis__39">
     </a>
     Redis 的内存淘汰策略？
    </h2>
    <h3>
     <a id="_40">
     </a>
     不淘汰策略（默认策略）
    </h3>
    <p>
     当运行内存超过最大内存设置时，不进行数据淘汰，此时拒绝写入操作，但是可以进行查询和删除操作。
    </p>
    <h3>
     <a id="_42">
     </a>
     淘汰有过期时间的数据
    </h3>
    <p>
     在设置了过期时间的数据当中进行淘汰：
    </p>
    <ul>
     <li>
      volatile-random：随机淘汰设置了过期时间的任意键值；
     </li>
     <li>
      volatile-ttl：优先淘汰更早过期的键值；
     </li>
     <li>
      volatile-lru：淘汰所有设置了过期时间的键值中，最久未使用的键值；
     </li>
     <li>
      volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；
     </li>
    </ul>
    <h3>
     <a id="_48">
     </a>
     淘汰所有数据
    </h3>
    <ul>
     <li>
      allkeys-random：随机淘汰任意键值；
     </li>
     <li>
      allkeys-lru：淘汰整个键值中最久未使用的键值；
     </li>
     <li>
      allkeys-lfu：淘汰整个键值中最少使用的键值；
     </li>
    </ul>
    <h2>
     <a id="Redis__53">
     </a>
     Redis 持久化时对过期键会如何处理？
    </h2>
    <h3>
     <a id="RDB_54">
     </a>
     RDB
    </h3>
    <p>
     <strong>
      生成 RDB 文件时
     </strong>
     ：
    </p>
    <ul>
     <li>
      已过期的键不会写入 RDB 文件；
     </li>
     <li>
      仍在有效期内的键会保留过期时间信息；
     </li>
    </ul>
    <p>
     <strong>
      加载 RDB 文件时
     </strong>
     ：
    </p>
    <ul>
     <li>
      主节点：加载时会检查键的过期时间，
      <strong>
       自动过滤已过期的键
      </strong>
      ；
     </li>
     <li>
      从节点：会完整加载所有的键（包含已过期的），依赖主节点同步 DEL 命令来删除。
     </li>
    </ul>
    <h3>
     <a id="AOF_63">
     </a>
     AOF
    </h3>
    <p>
     <strong>
      AOF 写入时
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       当键过期被删除时，会追加一条 DEL 命令到 AOF 文件
      </strong>
      ；
     </li>
     <li>
      通过
      <code>
       redis.conf
      </code>
      的
      <code>
       appendfsync
      </code>
      配置控制同步策略；
     </li>
    </ul>
    <p>
     <strong>
      AOF 重写时
     </strong>
     ：
    </p>
    <ul>
     <li>
      重写过程会检查键的过期时间，已过期的键不会写入新的 AOF；
     </li>
    </ul>
    <h3>
     <a id="_71">
     </a>
     主从模式特殊处理
    </h3>
    <ul>
     <li>
      从节点不会主动删除过期键，依赖主节点的 DEL 命令同步；
     </li>
     <li>
      读取从节点时可能返回逻辑上已经过期的数据。
     </li>
    </ul>
    <p>
     <strong>
      关键注意事项
     </strong>
     ：
    </p>
    <ol>
     <li>
      内存中已过期但未被删除的键会被持久化保留；
     </li>
     <li>
      持久化文件中的过期时间使用绝对时间戳存储；
     </li>
     <li>
      混合持久化模式同时遵循上述 RDB 和 AOF 的处理规则。
     </li>
    </ol>
    <h2>
     <a id="Redis__80">
     </a>
     Redis 主从模式中，对过期键会如何处理？
    </h2>
    <p>
     从库不会进行过期扫描，
     <strong>
      即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值
     </strong>
     。从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f436f666665656d616b657238382f:61727469636c652f64657461696c732f313436313235313931" class_="artid" style="display:none">
 </p>
</div>


