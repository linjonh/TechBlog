---
layout: post
title: "java集合总结"
date: 2025-03-15 17:58:12 +0800
description: "java集合总结，ArrayList、LinkedList、Vector、HashSet、TreeSet、HashMap，TreeMap"
keywords: "java集合总结"
categories: ['Java']
tags: ['开发语言', 'Java']
artid: "146282930"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146282930
    alt: "java集合总结"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146282930
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146282930
cover: https://bing.ee123.net/img/rand?artid=146282930
image: https://bing.ee123.net/img/rand?artid=146282930
img: https://bing.ee123.net/img/rand?artid=146282930
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java集合总结
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="1_ArrayList_0">
     </a>
     1 ArrayList
    </h3>
    <h4>
     <a id="Java_ArrayList__2">
     </a>
     <strong>
      Java ArrayList 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       动态数组结构
      </strong>
      ：自动扩容（默认1.5倍），初始容量10，适合数据量不固定的场景。
     </li>
     <li>
      <strong>
       高效随机访问
      </strong>
      ：通过索引（
      <code>
       get/set
      </code>
      ）直接操作元素，时间复杂度
      <strong>
       O(1)
      </strong>
      。
     </li>
     <li>
      <strong>
       低效增删中间元素
      </strong>
      ：插入或删除元素需移动后续元素，时间复杂度
      <strong>
       O(n)
      </strong>
      。
     </li>
     <li>
      <strong>
       允许重复和null
      </strong>
      ：可存储重复值和
      <code>
       null
      </code>
      ，灵活但需注意业务逻辑。
     </li>
     <li>
      <strong>
       非线程安全
      </strong>
      ：多线程操作需手动同步（如加锁或用
      <code>
       Collections.synchronizedList
      </code>
      ）。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_12">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        动态数据缓存
       </strong>
      </p>
      <ul>
       <li>
        场景：缓存从数据库或API查询的结果集（如用户列表、商品信息）。
       </li>
       <li>
        优势：自动扩容，支持快速遍历和按索引查询。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        批量数据处理
       </strong>
      </p>
      <ul>
       <li>
        场景：读取文件、解析日志后存储数据，或批量上传前的临时存储。
       </li>
       <li>
        优势：顺序添加高效，适合流式处理（如过滤、转换后存入列表）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        UI层数据展示
       </strong>
      </p>
      <ul>
       <li>
        场景：前端页面渲染表格、下拉列表时，后端返回
        <code>
         ArrayList
        </code>
        格式的数据集合。
       </li>
       <li>
        优势：直接序列化为JSON，方便前端遍历。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        算法中的临时存储
       </strong>
      </p>
      <ul>
       <li>
        场景：实现广度优先搜索（BFS）时用
        <code>
         ArrayList
        </code>
        模拟队列（需配合索引控制）；动态规划中暂存中间结果。
       </li>
       <li>
        优势：快速随机访问，避免链表的结构开销。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数据转换与过滤
       </strong>
      </p>
      <ul>
       <li>
        场景：结合Stream API对集合进行过滤、映射、排序（如筛选出符合条件的订单）。
       </li>
       <li>
        优势：链式操作后直接生成新列表，代码简洁。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        配置项管理
       </strong>
      </p>
      <ul>
       <li>
        场景：存储系统配置参数（如白名单IP、允许的文件类型）。
       </li>
       <li>
        优势：初始化后较少修改，适合高频读取。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_40">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       避免频繁中间插入/删除
      </strong>
      ：大量增删时改用
      <code>
       LinkedList
      </code>
      。
     </li>
     <li>
      <strong>
       预分配容量
      </strong>
      ：已知数据量大时，初始化指定容量（如
      <code>
       new ArrayList&lt;&gt;(1000)
      </code>
      ）减少扩容开销。
     </li>
     <li>
      <strong>
       多线程同步
      </strong>
      ：并发环境用
      <code>
       CopyOnWriteArrayList
      </code>
      或手动加锁。
     </li>
     <li>
      <strong>
       慎用
       <code>
        contains
       </code>
       方法
      </strong>
      ：判断元素是否存在时，
      <code>
       ArrayList
      </code>
      的
      <code>
       contains
      </code>
      是
      <strong>
       O(n)
      </strong>
      ，高频查询改用
      <code>
       HashSet
      </code>
      。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_49">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 ArrayList 的场景
      </strong>
      ：数据量动态变化、高频查询、少量增删、需要快速原型开发。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：高频在头部/中间增删、严格的内存限制（数组结构有预留空间）、线程安全要求高。
     </li>
    </ul>
    <h3>
     <a id="2_LinkedList_54">
     </a>
     2 LinkedList
    </h3>
    <h4>
     <a id="Java_LinkedList__56">
     </a>
     <strong>
      Java LinkedList 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       双向链表结构
      </strong>
      ：每个节点包含前后节点的引用，内存空间非连续，增删节点只需修改指针，无需移动数据。
     </li>
     <li>
      <strong>
       高效增删头尾元素
      </strong>
      ：
      <code>
       addFirst()
      </code>
      、
      <code>
       addLast()
      </code>
      、
      <code>
       removeFirst()
      </code>
      、
      <code>
       removeLast()
      </code>
      等操作时间复杂度为
      <strong>
       O(1)
      </strong>
      。
     </li>
     <li>
      <strong>
       低效随机访问
      </strong>
      ：按索引访问元素需从头或尾遍历链表，时间复杂度
      <strong>
       O(n)
      </strong>
      。
     </li>
     <li>
      <strong>
       实现双端队列（Deque）
      </strong>
      ：天然支持队列、栈、双端队列的操作（如
      <code>
       offer()
      </code>
      、
      <code>
       poll()
      </code>
      、
      <code>
       push()
      </code>
      、
      <code>
       pop()
      </code>
      ）。
     </li>
     <li>
      <strong>
       内存占用较高
      </strong>
      ：每个节点需额外存储前后指针，适合元素数量较少或对增删性能要求高的场景。
     </li>
     <li>
      <strong>
       非线程安全
      </strong>
      ：多线程操作需手动同步。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_67">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        高频头尾增删操作
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          实现任务队列（如线程池任务调度）。
         </li>
         <li>
          消息中间件的临时消息缓存。
         </li>
         <li>
          操作历史记录（如撤销/重做功能，通过头插法记录操作步骤）。
         </li>
        </ul>
       </li>
       <li>
        优势：增删头尾元素的性能远高于
        <code>
         ArrayList
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        实现栈（Stack）或队列（Queue）
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          栈：方法调用栈模拟、表达式解析（如括号匹配）。
         </li>
         <li>
          队列：广度优先搜索（BFS）中的待处理节点队列。
         </li>
        </ul>
       </li>
       <li>
        优势：直接调用
        <code>
         push()
        </code>
        、
        <code>
         pop()
        </code>
        （栈）或
        <code>
         offer()
        </code>
        、
        <code>
         poll()
        </code>
        （队列），无需额外封装。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        需要双向遍历的场景
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          音乐播放器的“上一曲/下一曲”列表。
         </li>
         <li>
          分步表单中“上一步/下一步”导航。
         </li>
        </ul>
       </li>
       <li>
        优势：通过
        <code>
         ListIterator
        </code>
        支持双向遍历和修改。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        动态调整元素顺序
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          LRU缓存淘汰算法（快速将最近使用的元素移动到头部）。
         </li>
         <li>
          实时排行榜中频繁调整元素位置。
         </li>
        </ul>
       </li>
       <li>
        优势：插入/删除中间元素时仅需修改指针，无数据搬移开销。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        不确定数据量的流式处理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          逐行读取大文件并动态处理（如日志分析）。
         </li>
         <li>
          网络流数据的临时缓冲（如分片上传）。
         </li>
        </ul>
       </li>
       <li>
        优势：链表动态扩展无扩容成本，避免
        <code>
         ArrayList
        </code>
        的扩容数组拷贝。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        内存敏感但增删频繁的小数据集
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          高频增删的小型配置项集合（如动态路由规则）。
         </li>
         <li>
          临时存储中间计算结果（如递归算法的路径记录）。
         </li>
        </ul>
       </li>
       <li>
        优势：小数据量下链表的内存劣势不明显，且增删性能更优。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_108">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       避免按索引遍历
      </strong>
      ：优先用
      <code>
       Iterator
      </code>
      或
      <code>
       foreach
      </code>
      ，避免低效的
      <code>
       get(index)
      </code>
      。
     </li>
     <li>
      <strong>
       慎用中间插入/删除
      </strong>
      ：虽然链表增删节点快，但定位到中间位置仍需
      <strong>
       O(n)
      </strong>
      时间。
     </li>
     <li>
      <strong>
       多线程同步
      </strong>
      ：使用
      <code>
       Collections.synchronizedList()
      </code>
      或改用
      <code>
       ConcurrentLinkedQueue
      </code>
      。
     </li>
     <li>
      <strong>
       注意内存开销
      </strong>
      ：存储海量数据时，链表的指针内存可能成为瓶颈，优先考虑
      <code>
       ArrayList
      </code>
      。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_117">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 LinkedList 的场景
      </strong>
      ：高频头尾增删、需实现队列/栈、双向遍历、动态调整顺序、小规模数据流处理。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：高频随机访问、海量数据存储、内存严格受限、需要连续内存的场景（如缓存友好型算法）。
     </li>
    </ul>
    <p>
     <strong>
      对比 ArrayList
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       增删性能
      </strong>
      ：
      <code>
       LinkedList
      </code>
      在头尾增删占优，
      <code>
       ArrayList
      </code>
      在尾部增删占优。
     </li>
     <li>
      <strong>
       访问性能
      </strong>
      ：
      <code>
       ArrayList
      </code>
      的随机访问效率碾压
      <code>
       LinkedList
      </code>
      。
     </li>
     <li>
      <strong>
       内存占用
      </strong>
      ：
      <code>
       ArrayList
      </code>
      内存紧凑，
      <code>
       LinkedList
      </code>
      因指针占用额外空间。
     </li>
    </ul>
    <h3>
     <a id="3_Vector_128">
     </a>
     3 Vector
    </h3>
    <h4>
     <a id="Java_Vector__130">
     </a>
     <strong>
      Java Vector 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       线程安全
      </strong>
      ：所有方法均用
      <code>
       synchronized
      </code>
      修饰，支持多线程并发读写（但性能较低）。
     </li>
     <li>
      <strong>
       动态数组结构
      </strong>
      ：底层基于数组实现，自动扩容（默认容量翻倍，如 10 → 20 → 40）。
     </li>
     <li>
      <strong>
       遗留类
      </strong>
      ：早期 Java 集合的实现（JDK 1.0），现多被
      <code>
       ArrayList
      </code>
      或并发集合（如
      <code>
       CopyOnWriteArrayList
      </code>
      ）取代。
     </li>
     <li>
      <strong>
       枚举遍历
      </strong>
      ：提供
      <code>
       elements()
      </code>
      方法返回
      <code>
       Enumeration
      </code>
      对象（类似
      <code>
       Iterator
      </code>
      的前身）。
     </li>
     <li>
      <strong>
       同步开销大
      </strong>
      ：所有操作加锁，单线程环境下性能显著低于
      <code>
       ArrayList
      </code>
      。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_140">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        多线程环境下的共享数据存储
       </strong>
      </p>
      <ul>
       <li>
        场景：多个线程需要同时读写同一列表（如全局配置参数表）。
       </li>
       <li>
        注意：即使
        <code>
         Vector
        </code>
        线程安全，复合操作（如“检查再更新”）仍需额外同步。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        历史遗留系统维护
       </strong>
      </p>
      <ul>
       <li>
        场景：维护早期 Java 版本（如 JDK 1.2 之前）的代码库时，需兼容
        <code>
         Vector
        </code>
        的 API。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        需要同步的动态数组
       </strong>
      </p>
      <ul>
       <li>
        场景：简单的多线程任务队列（如生产者-消费者模型），但性能要求不高。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        替代 Stack 类
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <code>
         Stack
        </code>
        类继承自
        <code>
         Vector
        </code>
        ，但已不推荐使用；若需线程安全的栈，可用
        <code>
         Vector
        </code>
        的
        <code>
         addElement()
        </code>
        和
        <code>
         removeElement()
        </code>
        模拟栈操作。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        同步枚举遍历
       </strong>
      </p>
      <ul>
       <li>
        场景：通过
        <code>
         elements()
        </code>
        方法获取
        <code>
         Enumeration
        </code>
        遍历集合（需在遍历过程中同步）。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_160">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       避免在单线程中使用
      </strong>
      ：优先选择
      <code>
       ArrayList
      </code>
      （性能更高）。
     </li>
     <li>
      <strong>
       慎用复合操作
      </strong>
      ：即使单个方法线程安全，组合操作（如
      <code>
       if (!vec.isEmpty()) vec.remove(0)
      </code>
      ）仍需外部同步。
     </li>
     <li>
      <strong>
       替代方案
      </strong>
      ：
      <ul>
       <li>
        高并发读：用
        <code>
         CopyOnWriteArrayList
        </code>
        。
       </li>
       <li>
        高并发写：用
        <code>
         ConcurrentLinkedQueue
        </code>
        或
        <code>
         ConcurrentHashMap
        </code>
        。
       </li>
       <li>
        简单同步需求：用
        <code>
         Collections.synchronizedList(new ArrayList&lt;&gt;())
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       内存浪费风险
      </strong>
      ：容量翻倍扩容可能导致内存冗余，可初始化时指定容量（如
      <code>
       new Vector&lt;&gt;(100)
      </code>
      ）。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_172">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 Vector 的场景
      </strong>
      ：兼容旧代码、简单的多线程共享数据、需同步且对性能不敏感的场景。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：高并发写、单线程环境、内存敏感、需要高性能随机访问。
     </li>
    </ul>
    <p>
     <strong>
      对比 ArrayList/LinkedList
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       线程安全
      </strong>
      ：
      <code>
       Vector
      </code>
      自带同步，
      <code>
       ArrayList/LinkedList
      </code>
      需外部控制。
     </li>
     <li>
      <strong>
       性能
      </strong>
      ：
      <code>
       Vector
      </code>
      的同步机制导致性能远低于
      <code>
       ArrayList
      </code>
      。
     </li>
     <li>
      <strong>
       扩容策略
      </strong>
      ：
      <code>
       Vector
      </code>
      容量翻倍，
      <code>
       ArrayList
      </code>
      扩容 1.5 倍，内存利用更高效。
     </li>
    </ul>
    <p>
     <strong>
      现代替代方案
     </strong>
     ：
    </p>
    <ul>
     <li>
      需线程安全的动态数组：
      <code>
       Collections.synchronizedList()
      </code>
      +
      <code>
       ArrayList
      </code>
      。
     </li>
     <li>
      高并发场景：
      <code>
       CopyOnWriteArrayList
      </code>
      （读多写少）或
      <code>
       ConcurrentLinkedQueue
      </code>
      （写多读少）。
     </li>
    </ul>
    <h3>
     <a id="4_HashSet_190">
     </a>
     4 HashSet
    </h3>
    <hr/>
    <h4>
     <a id="Java_HashSet__194">
     </a>
     <strong>
      Java HashSet 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       基于哈希表实现
      </strong>
      ：底层依赖
      <code>
       HashMap
      </code>
      ，利用哈希值快速定位元素，查找/插入/删除的平均时间复杂度为
      <strong>
       O(1)
      </strong>
      。
     </li>
     <li>
      <strong>
       元素唯一性
      </strong>
      ：通过
      <code>
       equals()
      </code>
      和
      <code>
       hashCode()
      </code>
      方法保证元素不重复。
     </li>
     <li>
      <strong>
       无序性
      </strong>
      ：不保证元素的存储顺序（与插入顺序无关），迭代顺序可能随机变化。
     </li>
     <li>
      <strong>
       允许
       <code>
        null
       </code>
       值
      </strong>
      ：可存储一个
      <code>
       null
      </code>
      元素。
     </li>
     <li>
      <strong>
       非线程安全
      </strong>
      ：多线程操作需手动同步（如
      <code>
       Collections.synchronizedSet()
      </code>
      ）。
     </li>
     <li>
      <strong>
       性能依赖哈希函数
      </strong>
      ：哈希冲突过多时，性能退化为
      <strong>
       O(n)
      </strong>
      。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_205">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        快速去重
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          从数据库或文件中提取数据后，过滤重复记录（如用户ID、订单号）。
         </li>
         <li>
          统计日志中独立IP地址或唯一用户访问量。
         </li>
        </ul>
       </li>
       <li>
        优势：去重操作时间复杂度低，代码简洁。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        集合运算
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          判断两个数据集是否有交集（如用户权限校验）。
         </li>
         <li>
          合并多个来源的数据并去重（如多平台订单汇总）。
         </li>
        </ul>
       </li>
       <li>
        优势：直接调用
        <code>
         addAll()
        </code>
        （并集）、
        <code>
         retainAll()
        </code>
        （交集）、
        <code>
         removeAll()
        </code>
        （差集）等方法。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        快速存在性检查
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          缓存校验黑名单（如敏感词、禁止访问的IP）。
         </li>
         <li>
          用户注册时检查用户名是否已被占用。
         </li>
        </ul>
       </li>
       <li>
        优势：
        <code>
         contains()
        </code>
        方法性能远高于
        <code>
         List
        </code>
        的遍历查找。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        临时唯一性存储
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          遍历树或图时记录已访问的节点（避免重复处理）。
         </li>
         <li>
          分布式任务调度中标记已处理的任务ID。
         </li>
        </ul>
       </li>
       <li>
        优势：轻量且无需维护顺序。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        标签或属性管理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          商品的多标签分类（如“电子产品”“促销品”），确保标签唯一。
         </li>
         <li>
          用户兴趣标签的存储与快速匹配。
         </li>
        </ul>
       </li>
       <li>
        优势：天然支持唯一性，避免重复标签污染数据。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数据清洗与预处理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          清洗爬虫抓取的网页URL，避免重复爬取。
         </li>
         <li>
          预处理数据集中的异常值或重复条目。
         </li>
        </ul>
       </li>
       <li>
        优势：去重效率高，适合大规模数据处理。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_245">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       重写
       <code>
        hashCode()
       </code>
       和
       <code>
        equals()
       </code>
      </strong>
      ：存储自定义对象时，必须正确重写这两个方法，否则无法保证唯一性。
     </li>
     <li>
      <strong>
       避免存储可变对象
      </strong>
      ：若对象哈希值随内容变化，可能导致
      <code>
       HashSet
      </code>
      中元素“丢失”。
     </li>
     <li>
      <strong>
       初始化容量与负载因子
      </strong>
      ：数据量较大时，指定初始容量和负载因子（如
      <code>
       new HashSet&lt;&gt;(1000, 0.75f)
      </code>
      ），减少扩容次数。
     </li>
     <li>
      <strong>
       线程安全替代方案
      </strong>
      ：多线程环境用
      <code>
       ConcurrentHashMap.newKeySet()
      </code>
      或
      <code>
       CopyOnWriteArraySet
      </code>
      。
     </li>
     <li>
      <strong>
       慎用大规模数据
      </strong>
      ：哈希表内存占用较高，超大规模数据去重可改用布隆过滤器（Bloom Filter）。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_255">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 HashSet 的场景
      </strong>
      ：高频去重、快速存在性检查、无需顺序的集合运算、临时唯一性存储。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：需要元素有序（用
      <code>
       LinkedHashSet
      </code>
      或
      <code>
       TreeSet
      </code>
      ）、需要按范围查询（用
      <code>
       TreeSet
      </code>
      ）、内存极度敏感（用位图或数组）。
     </li>
    </ul>
    <p>
     <strong>
      对比其他 Set 实现
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        TreeSet
       </code>
      </strong>
      ：基于红黑树，元素按自然顺序或自定义规则排序，查找/插入/删除时间复杂度
      <strong>
       O(log n)
      </strong>
      。
     </li>
     <li>
      <strong>
       <code>
        LinkedHashSet
       </code>
      </strong>
      ：维护插入顺序的链表，适合需要按顺序迭代且去重的场景。
     </li>
    </ul>
    <p>
     <strong>
      性能关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      哈希函数的质量直接影响冲突概率，设计差的对象哈希方法会显著降低性能。
     </li>
     <li>
      负载因子默认 0.75，表示哈希表填充 75% 后触发扩容，可根据场景调整（值越小，冲突越少，内存占用越高）。
     </li>
    </ul>
    <h3>
     <a id="5_TreeSet_270">
     </a>
     5 TreeSet
    </h3>
    <h4>
     <a id="Java_TreeSet__272">
     </a>
     <strong>
      Java TreeSet 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       基于红黑树实现
      </strong>
      ：元素按自然顺序或自定义规则排序，插入时自动维护有序性。
     </li>
     <li>
      <strong>
       元素唯一且有序
      </strong>
      ：通过
      <code>
       compareTo()
      </code>
      或
      <code>
       Comparator
      </code>
      保证唯一性，迭代时按升序或自定义顺序输出。
     </li>
     <li>
      <strong>
       操作效率稳定
      </strong>
      ：查找、插入、删除操作的时间复杂度为
      <strong>
       O(log n)
      </strong>
      ，适合需要动态维护有序集合的场景。
     </li>
     <li>
      <strong>
       不允许
       <code>
        null
       </code>
       值
      </strong>
      （自然排序模式下）：若未指定自定义
      <code>
       Comparator
      </code>
      ，插入
      <code>
       null
      </code>
      会抛出
      <code>
       NullPointerException
      </code>
      。
     </li>
     <li>
      <strong>
       非线程安全
      </strong>
      ：多线程操作需手动同步（如
      <code>
       Collections.synchronizedSortedSet()
      </code>
      ）。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_282">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        动态排序数据集
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          实时排行榜（如游戏玩家积分榜、电商商品销量榜），插入数据时自动排序。
         </li>
         <li>
          股票价格实时更新后按价格排序展示。
         </li>
        </ul>
       </li>
       <li>
        优势：无需手动调用排序方法，维护成本低。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        范围查询与过滤
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          查询某区间内的数据（如筛选考试分数在 80~100 分的学生）。
         </li>
         <li>
          统计日志中某时间段内的请求记录（通过
          <code>
           subSet()
          </code>
          、
          <code>
           headSet()
          </code>
          、
          <code>
           tailSet()
          </code>
          方法）。
         </li>
        </ul>
       </li>
       <li>
        优势：基于红黑树结构，范围查询效率远高于遍历无序集合。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        去重且有序存储
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          从异构数据源合并数据后，按时间戳或优先级去重并排序。
         </li>
         <li>
          用户操作日志按时间顺序存储，避免重复记录。
         </li>
        </ul>
       </li>
       <li>
        优势：同时满足唯一性和有序性需求。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        任务调度与优先级管理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          定时任务队列按执行时间排序（如延迟任务调度）。
         </li>
         <li>
          线程池中任务按优先级（高/中/低）动态调整执行顺序。
         </li>
        </ul>
       </li>
       <li>
        优势：自动按规则调整顺序，确保高优先级任务优先处理。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        字典序或分类管理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          实现自动补全功能（如搜索框提示词按字母顺序排序）。
         </li>
         <li>
          文件系统中目录项按名称排序展示。
         </li>
        </ul>
       </li>
       <li>
        优势：天然支持字典序，简化业务逻辑。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        复杂规则去重
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          根据自定义业务规则（如“用户ID+日期”组合）去重。
         </li>
         <li>
          订单去重时需忽略大小写或特定字段差异。
         </li>
        </ul>
       </li>
       <li>
        优势：通过自定义
        <code>
         Comparator
        </code>
        灵活定义唯一性规则。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_322">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        正确实现比较逻辑
       </strong>
       ：
      </p>
      <ul>
       <li>
        存储自定义对象时，需实现
        <code>
         Comparable
        </code>
        接口或提供
        <code>
         Comparator
        </code>
        ，否则抛出
        <code>
         ClassCastException
        </code>
        。
       </li>
       <li>
        比较逻辑需与
        <code>
         equals()
        </code>
        一致，避免破坏唯一性规则（如两个对象
        <code>
         compareTo()
        </code>
        返回 0，但
        <code>
         equals()
        </code>
        为
        <code>
         false
        </code>
        ）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        慎用可变对象
       </strong>
       ：
      </p>
      <ul>
       <li>
        若对象的排序字段被修改，可能导致
        <code>
         TreeSet
        </code>
        内部顺序混乱，需先删除对象再重新插入。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        性能敏感场景慎用
       </strong>
       ：
      </p>
      <ul>
       <li>
        高频插入/删除时，红黑树的旋转操作可能成为性能瓶颈，可改用
        <code>
         HashSet
        </code>
        + 手动排序。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        替代方案
       </strong>
       ：
      </p>
      <ul>
       <li>
        需要线程安全：使用
        <code>
         ConcurrentSkipListSet
        </code>
        。
       </li>
       <li>
        仅需插入顺序：使用
        <code>
         LinkedHashSet
        </code>
        。
       </li>
       <li>
        内存敏感：权衡红黑树的结构开销与查询效率。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_341">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 TreeSet 的场景
      </strong>
      ：需动态维护有序集合、高频范围查询、自定义排序规则、去重且排序。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：仅需去重无需排序（用
      <code>
       HashSet
      </code>
      ）、高频随机访问（用
      <code>
       ArrayList
      </code>
      ）、内存极度受限。
     </li>
    </ul>
    <p>
     <strong>
      对比其他 Set 实现
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        HashSet
       </code>
      </strong>
      ：无序，去重效率
      <strong>
       O(1)
      </strong>
      ，适合纯去重场景。
     </li>
     <li>
      <strong>
       <code>
        LinkedHashSet
       </code>
      </strong>
      ：维护插入顺序，适合需要按插入顺序迭代的去重场景。
     </li>
     <li>
      <strong>
       <code>
        ConcurrentSkipListSet
       </code>
      </strong>
      ：线程安全且有序，适合高并发排序需求。
     </li>
    </ul>
    <p>
     <strong>
      性能关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      数据量较小时，
      <code>
       TreeSet
      </code>
      的有序性优势明显；数据量极大时需权衡红黑树的维护成本。
     </li>
     <li>
      自定义
      <code>
       Comparator
      </code>
      的复杂度直接影响操作效率，需避免复杂计算逻辑。
     </li>
    </ul>
    <h3>
     <a id="6_HashMap_357">
     </a>
     6 HashMap
    </h3>
    <h4>
     <a id="Java_HashMap__359">
     </a>
     <strong>
      Java HashMap 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       基于哈希表实现
      </strong>
      ：底层是“数组+链表/红黑树”（JDK8+），通过哈希值快速定位桶位置，理想情况下操作时间复杂度为
      <strong>
       O(1)
      </strong>
      。
     </li>
     <li>
      <strong>
       键值对存储
      </strong>
      ：唯一键（通过
      <code>
       equals()
      </code>
      和
      <code>
       hashCode()
      </code>
      去重），允许一个
      <code>
       null
      </code>
      键和多个
      <code>
       null
      </code>
      值。
     </li>
     <li>
      <strong>
       非线程安全
      </strong>
      ：多线程并发修改可能触发无限循环或数据丢失（JDK7）或脏读（JDK8+）。
     </li>
     <li>
      <strong>
       动态扩容
      </strong>
      ：默认容量 16，负载因子 0.75，容量超过阈值时扩容 2 倍并重新哈希。
     </li>
     <li>
      <strong>
       哈希冲突管理
      </strong>
      ：链表长度超过 8 时转红黑树（提升查询效率），长度小于 6 时退化为链表。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_369">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        缓存系统
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          临时存储高频访问数据（如用户会话信息、热点商品详情）。
         </li>
         <li>
          本地缓存数据库查询结果（键为查询条件，值为结果集）。
         </li>
        </ul>
       </li>
       <li>
        优势：快速通过键查找值，避免重复计算或数据库访问。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数据索引与映射
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          建立对象关联（如用户ID映射用户详情、订单号映射物流状态）。
         </li>
         <li>
          文件路径与文件内容的快速映射（如配置文件解析）。
         </li>
        </ul>
       </li>
       <li>
        优势：直接通过键定位数据，无需遍历。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分组与统计
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          统计词频（如文本中每个单词的出现次数）。
         </li>
         <li>
          按属性分组数据（如按部门分类员工、按城市归类订单）。
         </li>
        </ul>
       </li>
       <li>
        优势：键作为分类标识，值存储统计结果或子集合。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        配置参数管理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          存储系统动态配置（如开关参数、API地址映射）。
         </li>
         <li>
          国际化资源文件加载（键为文案ID，值为多语言文本）。
         </li>
        </ul>
       </li>
       <li>
        优势：灵活增删配置项，支持快速读取。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分布式分片
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          按哈希值分配任务到不同节点（如用户ID分片路由）。
         </li>
         <li>
          数据库分库分表时，用键计算数据所属分片。
         </li>
        </ul>
       </li>
       <li>
        优势：哈希算法均匀分布数据，减少热点问题。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        对象属性动态扩展
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          为实体附加临时元数据（如请求上下文的附加参数）。
         </li>
         <li>
          动态表单字段存储（键为字段名，值为用户输入）。
         </li>
        </ul>
       </li>
       <li>
        优势：无需预定义结构，灵活扩展键值对。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_409">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        线程安全替代方案
       </strong>
       ：
      </p>
      <ul>
       <li>
        多线程读写用
        <code>
         ConcurrentHashMap
        </code>
        。
       </li>
       <li>
        多线程读多写少用
        <code>
         Collections.synchronizedMap()
        </code>
        包装。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        优化哈希函数
       </strong>
       ：
      </p>
      <ul>
       <li>
        自定义对象作为键时，需正确重写
        <code>
         hashCode()
        </code>
        和
        <code>
         equals()
        </code>
        ，避免哈希冲突。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        合理初始化容量
       </strong>
       ：
      </p>
      <ul>
       <li>
        预估数据量时指定初始容量（如
        <code>
         new HashMap&lt;&gt;(1000)
        </code>
        ），减少扩容开销。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        避免遍历时修改
       </strong>
       ：
      </p>
      <ul>
       <li>
        使用
        <code>
         Iterator
        </code>
        遍历时删除元素，防止
        <code>
         ConcurrentModificationException
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        慎用可变对象作为键
       </strong>
       ：
      </p>
      <ul>
       <li>
        若键对象哈希值变化，会导致数据“丢失”（无法通过
        <code>
         get()
        </code>
        找到原有条目）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        处理哈希碰撞
       </strong>
       ：
      </p>
      <ul>
       <li>
        高频冲突时，考虑调整哈希算法或改用
        <code>
         LinkedHashMap
        </code>
        （维护插入顺序）。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_432">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 HashMap 的场景
      </strong>
      ：高频键值查询、去重映射、动态配置、缓存、分组统计、哈希分片。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：需要有序遍历（用
      <code>
       LinkedHashMap
      </code>
      或
      <code>
       TreeMap
      </code>
      ）、高并发写（用
      <code>
       ConcurrentHashMap
      </code>
      ）、范围查询（用
      <code>
       TreeMap
      </code>
      ）。
     </li>
    </ul>
    <p>
     <strong>
      对比其他 Map 实现
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        Hashtable
       </code>
      </strong>
      ：遗留类，全方法同步，性能低，不推荐使用。
     </li>
     <li>
      <strong>
       <code>
        TreeMap
       </code>
      </strong>
      ：基于红黑树，按键自然顺序或自定义顺序排序，操作效率
      <strong>
       O(log n)
      </strong>
      。
     </li>
     <li>
      <strong>
       <code>
        LinkedHashMap
       </code>
      </strong>
      ：维护插入顺序或访问顺序，适合缓存淘汰策略（如LRU）。
     </li>
    </ul>
    <p>
     <strong>
      性能关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      哈希函数的质量直接影响冲突率，设计差的哈希函数会导致性能退化为
      <strong>
       O(n)
      </strong>
      。
     </li>
     <li>
      负载因子默认 0.75，表示哈希表填充 75% 后扩容，可根据场景调整（值越小，冲突概率越低，但内存占用更高）。
     </li>
    </ul>
    <h3>
     <a id="7_TreeMap_448">
     </a>
     7 TreeMap
    </h3>
    <h4>
     <a id="Java_TreeMap__450">
     </a>
     <strong>
      Java TreeMap 的核心特点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       基于红黑树实现
      </strong>
      ：键值对按键的自然顺序（
      <code>
       Comparable
      </code>
      ）或自定义
      <code>
       Comparator
      </code>
      排序，保证有序性。
     </li>
     <li>
      <strong>
       键唯一且有序
      </strong>
      ：迭代时按键的升序或自定义顺序输出，支持范围查询（如子映射、头部/尾部映射）。
     </li>
     <li>
      <strong>
       操作效率稳定
      </strong>
      ：查找、插入、删除操作的时间复杂度为
      <strong>
       O(log n)
      </strong>
      ，适合需要动态维护有序键值对的场景。
     </li>
     <li>
      <strong>
       不允许
       <code>
        null
       </code>
       键
      </strong>
      （自然排序模式下）：若未指定自定义
      <code>
       Comparator
      </code>
      ，插入
      <code>
       null
      </code>
      键会抛出
      <code>
       NullPointerException
      </code>
      。
     </li>
     <li>
      <strong>
       非线程安全
      </strong>
      ：多线程操作需手动同步（如
      <code>
       Collections.synchronizedSortedMap()
      </code>
      ）。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_460">
     </a>
     <strong>
      开发中的典型使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        动态排序键值对
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          实时排行榜（如玩家积分按分数排序、商品按价格排序）。
         </li>
         <li>
          日志按时间戳排序存储（键为时间戳，值为日志内容）。
         </li>
        </ul>
       </li>
       <li>
        优势：自动维护键的有序性，无需手动排序。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        范围查询与区间操作
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          查询某时间段内的数据（如订单在 2023-01-01 至 2023-06-30 的记录）。
         </li>
         <li>
          筛选价格区间内的商品（如 100~500 元）。
         </li>
        </ul>
       </li>
       <li>
        优势：通过
        <code>
         subMap()
        </code>
        、
        <code>
         headMap()
        </code>
        、
        <code>
         tailMap()
        </code>
        快速获取子映射。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        字典序或分类管理
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          实现搜索提示词（如按字母顺序存储关键词）。
         </li>
         <li>
          多语言资源文件按键的字母顺序加载（如国际化文案）。
         </li>
        </ul>
       </li>
       <li>
        优势：天然支持字典序，简化排序逻辑。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        带权重的优先级调度
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          任务队列按优先级排序（如高、中、低优先级的后台任务）。
         </li>
         <li>
          定时任务按触发时间排序（键为执行时间，值为任务对象）。
         </li>
        </ul>
       </li>
       <li>
        优势：按键顺序处理任务，确保优先级规则。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        复杂键的排序与去重
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          按组合键排序（如“用户ID+操作时间”作为复合键）。
         </li>
         <li>
          去重并排序异构数据（如合并多个数据源的记录）。
         </li>
        </ul>
       </li>
       <li>
        优势：通过自定义
        <code>
         Comparator
        </code>
        灵活定义排序规则。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        统计与聚合分析
       </strong>
      </p>
      <ul>
       <li>
        场景：
        <ul>
         <li>
          统计区间数据分布（如按分数段统计学生人数）。
         </li>
         <li>
          实时聚合时间窗口内的指标（如每分钟请求量）。
         </li>
        </ul>
       </li>
       <li>
        优势：基于有序键快速定位区间并聚合结果。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_500">
     </a>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        正确实现比较逻辑
       </strong>
       ：
      </p>
      <ul>
       <li>
        自定义键对象需实现
        <code>
         Comparable
        </code>
        或提供
        <code>
         Comparator
        </code>
        ，否则抛出
        <code>
         ClassCastException
        </code>
        。
       </li>
       <li>
        比较逻辑需与
        <code>
         equals()
        </code>
        一致，避免键唯一性冲突。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        慎用可变键对象
       </strong>
       ：
      </p>
      <ul>
       <li>
        若键的排序字段被修改，会导致
        <code>
         TreeMap
        </code>
        内部顺序混乱，需先删除再重新插入。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        替代方案
       </strong>
       ：
      </p>
      <ul>
       <li>
        需要线程安全：使用
        <code>
         ConcurrentSkipListMap
        </code>
        。
       </li>
       <li>
        仅需插入顺序：使用
        <code>
         LinkedHashMap
        </code>
        。
       </li>
       <li>
        无需排序且高频查询：使用
        <code>
         HashMap
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        性能敏感场景优化
       </strong>
       ：
      </p>
      <ul>
       <li>
        高频插入/删除时，红黑树的平衡操作可能成为瓶颈，可改用
        <code>
         HashMap
        </code>
        + 定期排序。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_519">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       选 TreeMap 的场景
      </strong>
      ：需要键有序、高频范围查询、动态排序、复杂键规则、优先级调度。
     </li>
     <li>
      <strong>
       不选的场景
      </strong>
      ：仅需快速存取无序数据（用
      <code>
       HashMap
      </code>
      ）、内存极度受限、高并发写（用
      <code>
       ConcurrentSkipListMap
      </code>
      ）。
     </li>
    </ul>
    <p>
     <strong>
      对比其他 Map 实现
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       <code>
        HashMap
       </code>
      </strong>
      ：无序，操作效率
      <strong>
       O(1)
      </strong>
      ，适合纯键值存取。
     </li>
     <li>
      <strong>
       <code>
        LinkedHashMap
       </code>
      </strong>
      ：维护插入或访问顺序，适合缓存淘汰策略（如LRU）。
     </li>
     <li>
      <strong>
       <code>
        ConcurrentSkipListMap
       </code>
      </strong>
      ：线程安全且有序，适合高并发排序需求。
     </li>
    </ul>
    <p>
     <strong>
      性能关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      数据量较小时，
      <code>
       TreeMap
      </code>
      的有序性优势明显；数据量极大时需权衡红黑树的维护成本。
     </li>
     <li>
      自定义
      <code>
       Comparator
      </code>
      的逻辑复杂度直接影响操作效率，需避免复杂计算。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34333632343538342f:61727469636c652f64657461696c732f313436323832393330" class_="artid" style="display:none">
 </p>
</div>


