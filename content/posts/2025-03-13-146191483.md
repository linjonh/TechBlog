---
layout: post
title: "附JSPythonC题解Leetcode面试150题9三数之和"
date: 2025-03-13 22:21:49 +0800
description: "【联想到“两数之和Ⅱ”的那道题，因为有了一个“非严格递增”的顺序条件，我们得以简化遍历的过程；在这里也可以借鉴这个思路——创造一个顺序出来】1. 我们要返回的是“所有和为0且不重复的三元组”，这是一个数组类型，数组里的每一个元素都是三元组；这道题自己做的时候并没有先进行排序，导致重复的次数很多。下次遇到遍历很复杂的问题，要先进行处理！如果直接遍历，重复次数太多了，如何解决？答案中不可以包含重复的三元组。2. 要有三个用于遍历的指针；，判断是否存在三元组。"
keywords: "【附JS、Python、C++题解】Leetcode面试150题（9）——三数之和"
categories: ['Leetcode']
tags: ['Leetcode', 'Javascript', 'C']
artid: "146191483"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146191483
    alt: "附JSPythonC题解Leetcode面试150题9三数之和"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146191483
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146191483
cover: https://bing.ee123.net/img/rand?artid=146191483
image: https://bing.ee123.net/img/rand?artid=146191483
img: https://bing.ee123.net/img/rand?artid=146191483
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【附JS、Python、C++题解】Leetcode面试150题（9）——三数之和
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、题目
     <a href="https://leetcode.cn/problems/3sum/" rel="nofollow" title="​​​​​">
      ​​​​​
     </a>
    </h2>
    <p>
     <a href="https://leetcode.cn/problems/3sum/" rel="nofollow" title="15. 三数之和">
      15. 三数之和
     </a>
    </p>
    <p>
     <span style="color:#494949">
      给你一个整数数组
      <code>
       nums
      </code>
      ，判断是否存在三元组
      <code>
       [nums[i], nums[j], nums[k]]
      </code>
      满足：
      <br/>
      <code>
       i!=j
      </code>
      、
      <code>
       i!=k
      </code>
      且
      <code>
       j!= k
      </code>
      ，同时还满足：
      <code>
       nums[i] + nums[j] + nums[k] == 0
      </code>
      。请你返回所有和为
      <code>
       0
      </code>
      且不重复的三元组。
     </span>
    </p>
    <p>
     <strong>
      注意：
     </strong>
     答案中不可以包含重复的三元组。
    </p>
    <h2>
     二、思路
    </h2>
    <p>
     1. 我们要返回的是“所有和为0且不重复的三元组”，这是一个数组类型，数组里的每一个元素都是三元组；
    </p>
    <p>
     2. 要有三个用于遍历的指针；
    </p>
    <p>
     3. 判断条件就两个：
    </p>
    <ul>
     <li>
      <span style="color:#494949">
       <code>
        i!=j
       </code>
       、
       <code>
        i!=k
       </code>
       且
       <code>
        j!= k
       </code>
      </span>
     </li>
     <li>
      <span style="color:#494949">
       <code>
        nums[i] + nums[j] + nums[k] == 0、
       </code>
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#494949">
      <font face="monospace">
       4.
      </font>
     </span>
     如果直接遍历，重复次数太多了，如何解决？
    </p>
    <p>
     【联想到“两数之和Ⅱ”的那道题，因为有了一个“非严格递增”的顺序条件，我们得以简化遍历的过程；在这里也可以借鉴这个思路——创造一个顺序出来】
    </p>
    <p>
     该题题解见如下文章：
     <br/>
     <a href="https://blog.csdn.net/weixin_74769910/article/details/146140281?spm=1001.2014.3001.5501" title="【附JS、Python、C++题解】Leetcode面试150题（7）-CSDN博客">
      【附JS、Python、C++题解】Leetcode面试150题（7）-CSDN博客
     </a>
    </p>
    <h2>
     三、代码
    </h2>
    <p>
     ① JavaScript
    </p>
    <pre><code class="language-javascript">function threeNums(nums){
    nums.sort((a,b)-&gt;a-b);
    let res = [];
    let l = nums.length;
    for(let i = 0; i&lt;l-2; i++){
        if(i&gt;0 &amp;&amp; nums[i]===nums[i-1]){
            continue;
        }
        let j = i+1;
        let k = l-1;
        while(j&lt;k){
            const sum = nums[i] + nums[j] + nums[k];
            if(sum === 0){
                res.push([nums[i], nums[j], nums[k]]);
                while(j&lt;k &amp;&amp; nums[j] === nums[j+1]){
                    j++;
                }
                while(j&lt;k &amp;&amp; nums[k] === nums[k-1]){
                    k--;
                }
                j++;
                i--;
            }else if(sum&lt;0){
                j++;
            }
            else{
                K--;
            }
            
        }
    }
    return res;
}</code></pre>
    <p>
     ② Python
    </p>
    <pre><code class="language-python">def three_sum(nums):
    nums.sort()  # 先对数组进行排序
    res = []
    length = len(nums)

    for i in range(length - 2):
        if i &gt; 0 and nums[i] == nums[i - 1]:
            continue

        j, k = i + 1, length - 1

        while j &lt; k:
            total = nums[i] + nums[j] + nums[k]
            if total == 0:
                res.append([nums[i], nums[j], nums[k]])
                # 避免重复计算
                while j &lt; k and nums[j] == nums[j + 1]:
                    j += 1
                while j &lt; k and nums[k] == nums[k - 1]:
                    k -= 1
                j += 1
                k -= 1
            elif total &lt; 0:
                j += 1
            else:
                k -= 1

    return res
</code></pre>
    <p>
     ③ C++
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
    vector&lt;vector&lt;int&gt;&gt; res;
    int length = nums.size();

    // 先对数组进行排序
    sort(nums.begin(), nums.end());

    for (int i = 0; i &lt; length - 2; ++i) {
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
            continue;
        }

        int j = i + 1;
        int k = length - 1;

        while (j &lt; k) {
            int total = nums[i] + nums[j] + nums[k];
            if (total == 0) {
                res.push_back({nums[i], nums[j], nums[k]});
                // 避免重复计算
                while (j &lt; k &amp;&amp; nums[j] == nums[j + 1]) {
                    ++j;
                }
                while (j &lt; k &amp;&amp; nums[k] == nums[k - 1]) {
                    --k;
                }
                ++j;
                --k;
            } else if (total &lt; 0) {
                ++j;
            } else {
                --k;
            }
        }
    }

    return res;
}</code></pre>
    <h2>
     四、反思
    </h2>
    <p>
     这道题自己做的时候并没有先进行排序，导致重复的次数很多。下次遇到遍历很复杂的问题，要先进行处理！！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37343736393931302f:61727469636c652f64657461696c732f313436313931343833" class_="artid" style="display:none">
 </p>
</div>


