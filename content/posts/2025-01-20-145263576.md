---
arturl_encode: "68747470:733a2f2f626c6f672e6373646e2e6e65742f6c776377616d2f:61727469636c652f64657461696c732f313435323633353736"
layout: post
title: "Cè¯­è¨€ä¹‹æ–—åœ°ä¸»æ¸¸æˆ"
date: 2025-01-20 15:26:20 +08:00
description: "æœ¬æ–‡ä»‹ç»äº†ä¸€ä¸ªåŸºäºC++å®ç°çš„ç®€å•æ–—åœ°ä¸»æ¸¸æˆç¨‹åºã€‚è¯¥ç¨‹åºæ¨¡æ‹Ÿäº†æ–—åœ°ä¸»çš„åŸºæœ¬è§„åˆ™å’Œæµç¨‹ï¼ŒåŒ…æ‹¬å‘ç‰Œã€æŠ¢åœ°"
keywords: "Cè¯­è¨€ä¹‹æ–—åœ°ä¸»æ¸¸æˆ"
categories: ['C']
tags: ['æ¸¸æˆ', 'Microsoft', 'C', 'C']
artid: "145263576"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145263576
    alt: "Cè¯­è¨€ä¹‹æ–—åœ°ä¸»æ¸¸æˆ"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145263576
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145263576
---

# Cè¯­è¨€ä¹‹æ–—åœ°ä¸»æ¸¸æˆ

![](https://i-blog.csdnimg.cn/direct/8cede7ce5f1b41f195479959757c0e57.gif)

---

ğŸŒŸ
**å—¨ï¼Œæˆ‘æ˜¯
[LucianaiB](https://lucianaib.blog.csdn.net/ "LucianaiB")
ï¼**

**ğŸŒ æ€»æœ‰äººé—´ä¸€ä¸¤é£ï¼Œå¡«æˆ‘åä¸‡å…«åƒæ¢¦ã€‚**

**ğŸš€ è·¯æ¼«æ¼«å…¶ä¿®è¿œå…®ï¼Œå¾å°†ä¸Šä¸‹è€Œæ±‚ç´¢ã€‚**

---

â€‹

## Cè¯­è¨€ä¹‹æ–—åœ°ä¸»æ¸¸æˆ

## ç›®å½•

1. [ç¨‹åºæ¦‚è¿°](#%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0)
2. [ç¨‹åºè®¾è®¡](#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)
   1. [Cardç±»](#card%E7%B1%BB)
   2. [CardGroupç±»](#cardgroup%E7%B1%BB)
   3. [Playerç±»](#player%E7%B1%BB)
   4. [LastCardsç±»](#lastcards%E7%B1%BB)
   5. [Landlordsç±»](#landlords%E7%B1%BB)
3. [æ¸¸æˆæµç¨‹](#%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B)
4. [ç‰¹ç‚¹ä¸åŠŸèƒ½](#%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8A%9F%E8%83%BD)
   1. [ç‰Œå‹åˆ¤æ–­](#%E7%89%8C%E5%9E%8B%E5%88%A4%E6%96%AD)
   2. [AIæç¤º](#ai%E6%8F%90%E7%A4%BA)
   3. [äº¤äº’æ€§](#%E4%BA%A4%E4%BA%92%E6%80%A7)
   4. [éšæœºæ€§](#%E9%9A%8F%E6%9C%BA%E6%80%A7)
5. [æµ‹è¯•ä¸è¿è¡Œ](#%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%BF%90%E8%A1%8C)
6. [æ€»ä½“è¯„ä»·](#%E6%80%BB%E4%BD%93%E8%AF%84%E4%BB%B7)
7. [é™„å½•ä»£ç ](#%E9%99%84%E5%BD%95%E4%BB%A3%E7%A0%81)

æœ¬æ–‡ä»‹ç»äº†ä¸€ä¸ªåŸºäºC++å®ç°çš„ç®€å•æ–—åœ°ä¸»æ¸¸æˆç¨‹åºã€‚è¯¥ç¨‹åºæ¨¡æ‹Ÿäº†æ–—åœ°ä¸»çš„åŸºæœ¬è§„åˆ™å’Œæµç¨‹ï¼ŒåŒ…æ‹¬å‘ç‰Œã€æŠ¢åœ°ä¸»ã€å‡ºç‰Œä»¥åŠèƒœè´Ÿåˆ¤å®šç­‰åŠŸèƒ½ã€‚ç¨‹åºçš„æ ¸å¿ƒç”±å¤šä¸ªç±»ç»„æˆï¼ŒåŒ…æ‹¬
`Card`
ï¼ˆè¡¨ç¤ºå•å¼ ç‰Œï¼‰ã€
`CardGroup`
ï¼ˆè¡¨ç¤ºä¸€ç»„ç‰Œï¼‰ã€
`Player`
ï¼ˆè¡¨ç¤ºç©å®¶ï¼‰ã€
`LastCards`
ï¼ˆç”¨äºè®°å½•ä¸Šå®¶å‡ºçš„ç‰Œï¼‰å’Œ
`Landlords`
ï¼ˆç”¨äºç®¡ç†æ•´ä¸ªæ¸¸æˆæµç¨‹ï¼‰ã€‚

##### ç¨‹åºè®¾è®¡

ç¨‹åºé€šè¿‡
`Card`
ç±»å®šä¹‰äº†ç‰Œçš„åŸºæœ¬å±æ€§ï¼Œå¦‚ç‰Œé¢å€¼ã€èŠ±è‰²å’Œæ˜¾ç¤ºæ–¹æ³•ã€‚
`CardGroup`
ç±»ç”¨äºç®¡ç†ä¸€ç»„ç‰Œï¼Œå¹¶æä¾›ç‰Œå‹åˆ¤æ–­å’Œå¤§å°æ¯”è¾ƒçš„åŠŸèƒ½ã€‚
`Player`
ç±»åˆ™ç®¡ç†ç©å®¶æ‰‹ä¸­çš„ç‰Œï¼Œå¹¶æä¾›å‡ºç‰Œå’Œæç¤ºåŠŸèƒ½ã€‚
`LastCards`
ç±»ç”¨äºè®°å½•ä¸Šå®¶å‡ºçš„ç‰Œï¼Œå¹¶æä¾›æŸ¥æ‰¾å¯æ‰“å¾—è¿‡çš„ç‰Œçš„åŠŸèƒ½ã€‚
`Landlords`
ç±»ä½œä¸ºæ¸¸æˆçš„æ ¸å¿ƒï¼Œè´Ÿè´£åˆå§‹åŒ–æ¸¸æˆã€å‘ç‰Œã€æŠ¢åœ°ä¸»ã€è½®æµå‡ºç‰Œä»¥åŠåˆ¤æ–­æ¸¸æˆç»“æŸç­‰é€»è¾‘ã€‚

##### æ¸¸æˆæµç¨‹

æ¸¸æˆå¼€å§‹æ—¶ï¼Œç¨‹åºé€šè¿‡æ´—ç‰Œå’Œåˆ†ç‰Œå°†54å¼ ç‰Œéšæœºåˆ†é…ç»™ä¸‰ä¸ªç©å®¶ï¼Œå¹¶é€šè¿‡æŠ¢åœ°ä¸»ç¯èŠ‚ç¡®å®šåœ°ä¸»ç©å®¶ã€‚åœ°ä¸»ç©å®¶è·å¾—é¢å¤–çš„ä¸‰å¼ åº•ç‰Œåï¼Œæ¸¸æˆæ­£å¼å¼€å§‹ã€‚ç©å®¶æŒ‰é¡ºåºå‡ºç‰Œï¼Œæ¯æ¬¡å‡ºç‰Œéœ€è¦æ¯”ä¸Šå®¶çš„ç‰Œå¤§ï¼Œæˆ–è€…é€‰æ‹©ä¸å‡ºã€‚å½“æŸä¸ªç©å®¶æ‰‹ä¸­çš„ç‰Œå…¨éƒ¨å‡ºå®Œæ—¶ï¼Œæ¸¸æˆç»“æŸï¼Œç¨‹åºä¼šåˆ¤æ–­åœ°ä¸»æ˜¯å¦è·èƒœã€‚

##### ç‰¹ç‚¹ä¸åŠŸèƒ½

1. **ç‰Œå‹åˆ¤æ–­**
   ï¼šç¨‹åºèƒ½å¤Ÿå‡†ç¡®åˆ¤æ–­ç‰Œå‹ï¼Œå¦‚å•ç‰Œã€å¯¹å­ã€ä¸‰å¸¦ä¸€ã€ç‚¸å¼¹ç­‰ï¼Œå¹¶æ ¹æ®ç‰Œå‹å’Œç‰Œçš„å¤§å°è¿›è¡Œæ¯”è¾ƒã€‚
2. **AIæç¤º**
   ï¼šéåœ°ä¸»ç©å®¶åœ¨å‡ºç‰Œæ—¶ï¼Œç¨‹åºä¼šè‡ªåŠ¨æç¤ºå¯æ‰“å¾—è¿‡çš„ç‰Œï¼Œæé«˜äº†æ¸¸æˆçš„æµç•…æ€§ã€‚
3. **äº¤äº’æ€§**
   ï¼šç¨‹åºé€šè¿‡æ§åˆ¶å°è¾“å…¥è¾“å‡ºä¸ç”¨æˆ·äº¤äº’ï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©æ˜¯å¦æŠ¢åœ°ä¸»ã€å‡ºç‰Œä»¥åŠæ˜¯å¦ç»§ç»­æ¸¸æˆã€‚
4. **éšæœºæ€§**
   ï¼šé€šè¿‡éšæœºæ´—ç‰Œå’ŒæŠ¢åœ°ä¸»ç¯èŠ‚ï¼Œå¢åŠ äº†æ¸¸æˆçš„è¶£å‘³æ€§å’Œä¸ç¡®å®šæ€§ã€‚

##### æµ‹è¯•ä¸è¿è¡Œ

ç¨‹åºåœ¨æµ‹è¯•ä¸­è¡¨ç°å‡ºäº†è‰¯å¥½çš„ç¨³å®šæ€§å’Œæ­£ç¡®æ€§ã€‚ç©å®¶å¯ä»¥è‡ªç”±é€‰æ‹©å‡ºç‰Œç­–ç•¥ï¼Œç¨‹åºä¼šæ ¹æ®è§„åˆ™åˆ¤æ–­å‡ºç‰Œæ˜¯å¦åˆæ³•ï¼Œå¹¶åœ¨æ¸¸æˆç»“æŸåè¾“å‡ºèƒœè´Ÿç»“æœã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡ç®€å•çš„å‘½ä»¤è¡Œäº¤äº’ä½“éªŒå®Œæ•´çš„æ–—åœ°ä¸»æ¸¸æˆæµç¨‹ã€‚
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/092bd248d2a449cb9fdc724b420b56e7.png)

##### æ€»ä½“è¯„ä»·

æœ¬æ–‡ä»‹ç»äº†ä¸€ä¸ªåŸºäºC++å®ç°çš„æ–—åœ°ä¸»æ¸¸æˆç¨‹åºï¼Œæ¨¡æ‹Ÿäº†æ–—åœ°ä¸»çš„åŸºæœ¬è§„åˆ™å’Œæµç¨‹ï¼ŒåŒ…æ‹¬å‘ç‰Œã€æŠ¢åœ°ä¸»ã€å‡ºç‰Œå’Œèƒœè´Ÿåˆ¤å®šç­‰åŠŸèƒ½ã€‚ç¨‹åºçš„æ ¸å¿ƒç”±å¤šä¸ªç±»ç»„æˆï¼Œå¦‚Cardã€CardGroupã€Playerã€LastCardså’ŒLandlordsï¼Œé€šè¿‡é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ–¹å¼å®ç°äº†æ¸¸æˆçš„å®Œæ•´é€»è¾‘ã€‚

åœ¨ç¨‹åºè®¾è®¡ä¸­ï¼ŒCardç±»ç”¨äºå®šä¹‰å•å¼ ç‰Œçš„åŸºæœ¬å±æ€§ï¼Œå¦‚ç‰Œé¢å€¼ã€èŠ±è‰²å’Œæ˜¾ç¤ºæ–¹æ³•ã€‚CardGroupç±»ç®¡ç†ä¸€ç»„ç‰Œï¼Œå¹¶æä¾›ç‰Œå‹åˆ¤æ–­å’Œå¤§å°æ¯”è¾ƒçš„åŠŸèƒ½ã€‚Playerç±»ç®¡ç†ç©å®¶æ‰‹ä¸­çš„ç‰Œï¼Œå¹¶æä¾›å‡ºç‰Œå’Œæç¤ºåŠŸèƒ½ã€‚LastCardsç±»ç”¨äºè®°å½•ä¸Šå®¶å‡ºçš„ç‰Œï¼Œå¹¶æä¾›æŸ¥æ‰¾å¯æ‰“å¾—è¿‡çš„ç‰Œçš„åŠŸèƒ½ã€‚Landlordsç±»ä½œä¸ºæ¸¸æˆçš„æ ¸å¿ƒï¼Œè´Ÿè´£åˆå§‹åŒ–æ¸¸æˆã€å‘ç‰Œã€æŠ¢åœ°ä¸»ã€è½®æµå‡ºç‰Œä»¥åŠåˆ¤æ–­æ¸¸æˆç»“æŸç­‰é€»è¾‘ã€‚

æ¸¸æˆæµç¨‹ä»æ´—ç‰Œå’Œåˆ†ç‰Œå¼€å§‹ï¼Œé€šè¿‡æŠ¢åœ°ä¸»ç¯èŠ‚ç¡®å®šåœ°ä¸»ç©å®¶ã€‚åœ°ä¸»è·å¾—é¢å¤–ä¸‰å¼ åº•ç‰Œåï¼Œæ¸¸æˆæ­£å¼å¼€å§‹ã€‚ç©å®¶æŒ‰é¡ºåºå‡ºç‰Œï¼Œæ¯æ¬¡å‡ºç‰Œéœ€è¦æ¯”ä¸Šå®¶çš„ç‰Œå¤§ï¼Œæˆ–è€…é€‰æ‹©ä¸å‡ºã€‚å½“æŸä¸ªç©å®¶æ‰‹ä¸­çš„ç‰Œå…¨éƒ¨å‡ºå®Œæ—¶ï¼Œæ¸¸æˆç»“æŸï¼Œç¨‹åºä¼šåˆ¤æ–­åœ°ä¸»æ˜¯å¦è·èƒœã€‚
  
è¯¥ç¨‹åºå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

ç‰Œå‹åˆ¤æ–­ï¼šèƒ½å¤Ÿå‡†ç¡®åˆ¤æ–­ç‰Œå‹ï¼Œå¦‚å•ç‰Œã€å¯¹å­ã€ä¸‰å¸¦ä¸€ã€ç‚¸å¼¹ç­‰ï¼Œå¹¶æ ¹æ®ç‰Œå‹å’Œç‰Œçš„å¤§å°è¿›è¡Œæ¯”è¾ƒã€‚

AIæç¤ºï¼šéåœ°ä¸»ç©å®¶åœ¨å‡ºç‰Œæ—¶ï¼Œç¨‹åºä¼šè‡ªåŠ¨æç¤ºå¯æ‰“å¾—è¿‡çš„ç‰Œï¼Œæé«˜äº†æ¸¸æˆçš„æµç•…æ€§ã€‚

äº¤äº’æ€§ï¼šé€šè¿‡æ§åˆ¶å°è¾“å…¥è¾“å‡ºä¸ç”¨æˆ·äº¤äº’ï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©æ˜¯å¦æŠ¢åœ°ä¸»ã€å‡ºç‰Œä»¥åŠæ˜¯å¦ç»§ç»­æ¸¸æˆã€‚

éšæœºæ€§ï¼šé€šè¿‡éšæœºæ´—ç‰Œå’ŒæŠ¢åœ°ä¸»ç¯èŠ‚ï¼Œå¢åŠ äº†æ¸¸æˆçš„è¶£å‘³æ€§å’Œä¸ç¡®å®šæ€§ã€‚

åœ¨æµ‹è¯•ä¸­ï¼Œç¨‹åºè¡¨ç°å‡ºè‰¯å¥½çš„ç¨³å®šæ€§å’Œæ­£ç¡®æ€§ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡ç®€å•çš„å‘½ä»¤è¡Œäº¤äº’ä½“éªŒå®Œæ•´çš„æ–—åœ°ä¸»æ¸¸æˆæµç¨‹ã€‚è¯¥ç¨‹åºä¸ä»…å®ç°äº†æ–—åœ°ä¸»çš„åŸºæœ¬è§„åˆ™ï¼Œè¿˜é€šè¿‡ç±»çš„è®¾è®¡å’Œå°è£…å±•ç¤ºäº†é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ€æƒ³ã€‚ä»£ç ç»“æ„æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œæ‰©å±•ï¼Œé€‚åˆç”¨äºå­¦ä¹ å’Œç ”ç©¶C++ç¼–ç¨‹ä»¥åŠæ¸¸æˆå¼€å‘ã€‚

##### é™„å½•ä»£ç ï¼š

```c
#include <iostream>
#include<vector>
#include<assert.h>
#include<string>
#include<stdio.h>
#include<algorithm>
#include<time.h>

using namespace std;


#define PLAYERCOUNT 3
#define CARDSCOUNT 54
#define CURRENTPLAYER 0
#define VALUECOUNT 17
#define ERROR -1
using namespace std;
int scnt=0;
const char toFigure[]="34567890JQKA 2YZ";

enum COLOR{  //èŠ±è‰²æ˜¾ç¤ºASCII: 3~6
eHEART=3,//çº¢æ¡ƒ
eDIAMOND=4,//æ–¹ç‰‡
eCLUB=5,   //è‰èŠ±
eSPADE=6   //é»‘æ¡ƒ
};



class Card;
class CardsType;
class CardGroup;
class Player;
class Landlords;
class LastCards;
bool makeChoice(string tip);
bool cmp(Card* a,Card* b);
class Card{
public:
char figure;
COLOR color;
int value;
Card(char _figure,COLOR _color){
    figure=_figure;
    color=_color;
    value=calValue();
}
int calValue(){
    for(int i=0;toFigure[i];i++){
        if(toFigure[i]==figure){
            return i;
        }
    }
    return ERROR;
}


    void print() {
        assert(value != ERROR);

        switch (color) {
            case eHEART:
                cout << "â™¥"; // çº¢æ¡ƒ
                break;
            case eDIAMOND:
                cout << "â™¦"; // æ–¹ç‰‡
                break;
            case eCLUB:
                cout << "â™£"; // è‰èŠ±
                break;
            case eSPADE:
                cout << "â™ "; // é»‘æ¡ƒ
                break;
            default:
                cout << "?"; // æœªçŸ¥èŠ±è‰²
                break;
        }
        cout << figure << ' ';
    }
};
class CardsType{
public:
//ä¸ºäº†è§„èŒƒæŸ¥æ‰¾å¯¹åº”ç‰Œçš„æ–¹æ³•
//ç»Ÿä¸€ä¸º3ä¸ªå‚æ•°cnt1ã€isContinuousã€cnt2
int typeId;
string typeStr;
int cnt1,cnt2;
bool isContinuous;
CardsType(){
    typeId=ERROR;
}
bool operator ==(const CardsType& other)const{
    return this->typeId==other.typeId;
}
void init(char* _typeStr,int _typeId,int _cnt1,bool _isContinuous,int _cnt2){
    cnt1=_cnt1;
    isContinuous=_isContinuous;
    cnt2=_cnt2;
    typeStr=_typeStr;
    typeId=_typeId;
}
};
class CardGroup{
public:
vector<Card*> cards;
CardsType type;
void calType(){
    int i,n=cards.size();
    //init(typeStr,typeId,cnt1,isContinuous,cnt2)
    if(n==0){
        type.init("ä¸å‡º",14,0,0,0);
        return;
    }
    if(n==2&&cards[0]->value==15&&cards[1]->value==14){
        type.init("ç‹ç‚¸",0,0,0,0);
        return;
    }
    //ç»Ÿè®¡åŒç‚¹æ•°ç‰Œæœ‰å¤šå°‘å¼ 
    int cntFlag[VALUECOUNT]={0};
    for(i=0;i<n;i++){
        cntFlag[cards[i]->value]++;
    }
    //ç»Ÿè®¡ç‚¹æ•°æœ€å¤šå’Œæœ€å°‘çš„ç‰Œ
    int maxCnt=0,minCnt=4;
    for(i=0;i<VALUECOUNT;i++){
        if(maxCnt<cntFlag[i]){
           maxCnt=cntFlag[i];
        }
        if(cntFlag[i]&&minCnt>cntFlag[i]){
           minCnt=cntFlag[i];
        }
    }
    if(n==4&&maxCnt==4){
        type.init("ç‚¸å¼¹",1,4,0,0);
        return;
    }
    if(n==1){
        type.init("å•ç‰Œ",2,1,0,0);
        return;
    }
    if(n==2&&maxCnt==2){
        type.init("å¯¹å­",3,2,0,0);
        return;
    }
    if(n==3&&maxCnt==3){
        type.init("ä¸‰å¼  ",4,3,0,0);
        return;
    }
    if(n==4&&maxCnt==3){
        type.init("ä¸‰å¸¦ä¸€",5,3,0,1);
        return;
    }
    if(n==5&&maxCnt==3&&minCnt==2){
        type.init("ä¸‰å¸¦ä¸€å¯¹",6,3,0,2);
        return;
    }
    if(n==6&&maxCnt==4){
        type.init("å››å¸¦äºŒ",7,4,0,1);
        return;
    }
    if(n==8&&maxCnt==4&&minCnt==2){
        type.init("å››å¸¦äºŒ",8,4,0,2);
        return;
    }
    if(n>=5&&maxCnt==1&&cards[0]->value==cards[n-1]->value+n-1){
        type.init("é¡ºå­",9,1,1,0);
        return;
    }
    if(n>=6&&maxCnt==2&&minCnt==2&&cards[0]->value==cards[n-1]->value+n/2-1){
        type.init("è¿å¯¹",10,2,1,0);
        return;
    }
    int fjCnt;//ç»Ÿè®¡è¿ç»­ä¸”å¤§äº3ä¸‰å¼ çš„ç‰Œ
    for(i=0;i<VALUECOUNT &&cntFlag[i]<3;i++);
    for(fjCnt=0;i<VALUECOUNT &&cntFlag[i]>=3;i++,fjCnt++);
    if(fjCnt>1){
        if(n==fjCnt*3)
            type.init("é£æœº",11,3,1,0);
        else if(n==fjCnt*4)
            type.init("é£æœº",12,3,1,1);
        else if(n==fjCnt*5&&minCnt==2)
            type.init("é£æœº",13,3,1,2);
    }
}
void init(string inputStr, vector<Card*> &cardsHolded){
    this->cards.clear();
    //ä¸å‡º
    if(inputStr=="N"){
        this->calType();
        return;
    }
    int i,j;
    //è¾“å…¥åˆæ³•æ€§åˆ¤æ–­
    for(i=0;i<inputStr.size();i++){
        bool find=false;
        for(j=0;toFigure[j];j++){
            if(inputStr[i]==toFigure[j]){
                find=true;
                break;
            }
        }
        if(find==false){
            //è¾“å…¥å­—ç¬¦ä¸åœ¨toFigureä¸­
            return;
        }
    }
    //æŸ¥æ‰¾æ‰‹ä¸­æœ‰æ²¡æœ‰è¿™äº›ç‰Œ
    int visitFlag[20]={0};
    for(i=0;i<inputStr.size();i++){
        Card *find=NULL;
        for(j=0;j<cardsHolded.size();j++){
            if(!visitFlag[j]&&cardsHolded[j]->figure==inputStr[i]){
                visitFlag[j]=1;
                find=cardsHolded[j];
                break;
            }
        }
        if(find){
            this->cards.push_back(find);
        }else{
            cout<<inputStr[i];
            cout<<"æ²¡æœ‰æ‰¾åˆ°\t";
            this->cards.clear();
            return;
        }
    }//end for(i=0;i<inputStr.size();i++)
    this->arrange();
}
void init(vector<Card*> newCards){
    this->cards=newCards;
    this->arrange();
}
bool isCanBeat(CardGroup &cardGroup){
    if(cardGroup.type.typeStr=="ç‹ç‚¸"){
        return false;
    }else if(this->type.typeStr=="ç‹ç‚¸"){
        return true;
    }else if(cardGroup.type==this->type &&this->type.typeStr=="ç‚¸å¼¹"){
        return value()>cardGroup.value();
    }else if(cardGroup.type.typeStr=="ç‚¸å¼¹"){
        return false;
    }else if(this->type.typeStr=="ç‚¸å¼¹"){
        return true;
    }else if(cardGroup.type==this->type &&this->cards.size()==cardGroup.cards.size()){
        return this->value()>cardGroup.value();
    }else{
        return false;
    }
}
int value(){
    //è®¡ç®—ç‰Œç»„æƒå€¼
    int i;
    if(type.typeStr=="ä¸‰å¸¦ä¸€"||type.typeStr=="ä¸‰å¸¦ä¸€å¯¹"||type.typeStr=="é£æœº"){
        for(i=2;i<cards.size();i++){
            if(cards[i]->value==cards[i-2]->value){
                return cards[i]->value;
            }
        }
    }
    if(type.typeStr=="å››å¸¦äºŒ"){
        for(i=3;i<cards.size();i++){
            if(cards[i]->value==cards[i-3]->value){
                return cards[i]->value;
            }
        }
    }
    return cards[0]->value;
}
void arrange(){
    //æ•´ç†ï¼šæ’åºã€è®¡ç®—ç±»å‹
   // sort(this->cards.begin(),this->cards.end(),cmp);
    this->calType();
}
};
class LastCards{
static LastCards *lastCards;
public:
Player *player;
CardGroup cardGroup;
static LastCards* inst(){//å•ä¾‹æ¨¡å¼
    if(lastCards==NULL){
        lastCards=new LastCards();
    }
    return lastCards;
}
vector<Card*> findCanBeatFrom(vector<Card*> &cardsHolded){
    //æŸ¥æ‰¾èƒ½æ‰“å¾—è¿‡çš„ç‰Œ
    int i,j,k,n=cardsHolded.size(),m=cardGroup.cards.size();
    string typeStr=cardGroup.type.typeStr;
    vector<Card*> ret;
    if(typeStr=="ç‹ç‚¸"||n<m){
        //æ‰“ä¸è¿‡ï¼Œè¿”å›ç©ºæ•°ç»„
        return ret;
    }
    int value=cardGroup.value();
    //ç»Ÿè®¡å„ç‚¹ç‰Œå‡ºç°çš„æ¬¡æ•°
    int cntFlag[VALUECOUNT]={0};
    for(i=0;i<n;i++){
        cntFlag[cardsHolded[i]->value]++;
    }
    int continuousCount=1;
    if(cardGroup.type.isContinuous){
        continuousCount=m/(cardGroup.type.cnt1+cardGroup.type.cnt2);
    }
    bool findFirstFigure;
    //cout<<"continuousCount="<<continuousCount<<endl;
    for(i=value+1;i<VALUECOUNT;i++){
        findFirstFigure=true;
        for(j=0;j<continuousCount;j++){
            if(cntFlag[i-j]<cardGroup.type.cnt1){
                findFirstFigure=false;
                break;
            }
        }
        if(findFirstFigure){
            ret.clear();
            int firstFigure=i;
            //cout<<"æŸ¥æ‰¾"<<cardGroup.type.cnt1<<"ä¸ª"<<firstFigure+3<<endl;
            for(k=0,j=0;k<cardsHolded.size() &&j<continuousCount;k++){
                if(cardsHolded[k]->value==firstFigure-j){
                    for(int kk=0;j>=0&&kk<cardGroup.type.cnt1;kk++){
                        ret.push_back(cardsHolded[k+kk]);
                    }
                    j++;
                }
            }
            if(cardGroup.type.cnt2>0){
                int SecondFigures[5];
                int SecondCount=continuousCount;
                if(cardGroup.type.typeStr=="å››å¸¦äºŒ")
                    SecondCount=2;
                bool findSecondFigure=true;
                for(j=0,k=-1;j<SecondCount &&findSecondFigure;j++){
                    findSecondFigure=false;
                    for(k++;k<VALUECOUNT;k++){
                        SecondFigures[j]=k;
                        if(cntFlag[k]>=cardGroup.type.cnt2 &&cntFlag[k]<cardGroup.type.cnt1){
                            findSecondFigure=true;
                            break;
                        }
                    }
                }
                if(findSecondFigure){
                    //cout<<"æŸ¥æ‰¾SecondFigure "<<cardGroup.type.cnt2<<"ä¸ª"<<SecondFigures[0]+3<<endl;
                    //cout<<"SecondCount= "<<SecondCount<<endl;
                    //for(i=0;i<SecondCount;i++)cout<<"SecondFigures["<<i<<"]="<<SecondFigures[i]<<endl;
                    for(i=0;i<SecondCount;i++){
                        for(j=0;j<cardsHolded.size();){
                            if(cardsHolded[j]->value==SecondFigures[i]){
                                for(k=0;k<cardGroup.type.cnt2;k++){
                                    //cout<<"æ·»åŠ "<<cardsHolded[j]->value+3<<endl;
                                    ret.push_back(cardsHolded[j+k]);
                                }
                                do{
                                    j++;
                                }while(j<cardsHolded.size()&&cardsHolded[j]->value==SecondFigures[i]);
                            }else{
                                j++;
                            }
                        }
                    }
                    return ret;
                }//if(findSecondFigure)
            }//end if(cardGroup.type.cnt2>0)
            else{
                return ret;
            }
        }//end if(findFirstFigure)
    }//end for(i=value+1;i<VALUECOUNT;i++)
    ret.clear();
    //æ²¡ç‰Œæ‰“å¾—è¿‡æ—¶æŸ¥æ‰¾æœ‰æ²¡æœ‰ç‚¸å¼¹
    if(typeStr!="ç‚¸å¼¹"){
        for(i=cardsHolded.size()-1;i>=3;i--){
            if(cardsHolded[i]->value==cardsHolded[i-3]->value){
                for(j=0;j<4;j++){
                    ret.push_back(cardsHolded[i-j]);
                }
                break;
            }
        }
    }
    return ret;
}//end vector<Card*> findCanBeatFrom()
};
LastCards* LastCards::lastCards = NULL;
class Player{
public:
string name;
vector<Card*> cards;
void arrange(){
    sort(cards.begin(),cards.end(),cmp);
}
void print(){
    cout<<this->name<<":\t";
    for(int i=0;i<cards.size();i++){
        cards[i]->print();
    }
    cout<<"["<<cards.size()<<"]\n";
}
vector<Card*> tip(){
    //æç¤ºåŠŸèƒ½,ä½¿è‡ªå·±æœ€å°ä¸€å¼ è¿æœ€é•¿
    CardGroup ret;
    string temp;
    int j,k,m=cards.size();
    for(j=0;j<m;j++){
        temp="";
        for(k=j;k<m;k++){
            temp+=cards[k]->figure;
        }
        ret.init(temp,cards);
        if(ret.type.typeId!=ERROR){
            return ret.cards;
        }
    }
    ret.cards.clear();
    return ret.cards;
}
void chupai(CardGroup &cardGroup){
    //å‡ºç‰Œ
    cout<<this->name<<":\t";
    cout<<cardGroup.type.typeStr<<' ';
    for(int i=0;i<cardGroup.cards.size();i++){
        cardGroup.cards[i]->print();
        this->cards.erase(find(this->cards.begin(),this->cards.end(),cardGroup.cards[i]));
    }
    cout<<"\t["<<this->cards.size()<<"]\n";
    if(cardGroup.type.typeStr!="ä¸å‡º"){
        //è®°å½•åˆ° LastCards ä¸­
        LastCards::inst()->player=this;
        LastCards::inst()->cardGroup.init(cardGroup.cards);
    }
}
};
class Landlords{
Player *player[PLAYERCOUNT];
bool finished,youWin,landlordWin;
int landlordIndex;
Card *cards[CARDSCOUNT];
public:
Landlords(){
    int i=0,j=0,k=0;
    for(i=0;i<PLAYERCOUNT;i++){
        this->player[i]=new Player();
    }
    //54å¼ ç‰Œåˆå§‹åŒ–
    for(k=i=0;i<14;i++){
        if(toFigure[i]==' '){
            continue;
        }
        for(COLOR color=eHEART;color<=eSPADE;color=(COLOR)(color+1)){
            this->cards[k++]=new Card(toFigure[i],color);
        }
    }
    this->cards[k++]=new Card('Y',eSPADE);
    this->cards[k]=new Card('Z',eHEART);
}
~Landlords(){
    for(int i=0;i<PLAYERCOUNT;i++){
        delete this->player[i];
    }
    for(int i1=0;i1<CARDSCOUNT;i1++){
        delete this->cards[i1];
    }
}
void init(){
    player[CURRENTPLAYER]->name="Bice";
    player[1]->name="ç©å®¶2";
    player[2]->name="ç©å®¶3";
    finished=false;
    youWin=false;
    landlordWin=false;
    //æŠ¢åœ°ä¸»
    landlordIndex=ERROR;
    while(landlordIndex==ERROR){
        srand((int)time(0));
        shuffle();
        landlordIndex=chooseLandlord();
    }
    cout<<player[landlordIndex]->name<<"\tæˆä¸ºåœ°ä¸»\n\n";
    this->add3Cards();
    LastCards::inst()->player=player[landlordIndex];
}
void startGame(){
    string inputSrt;
    CardGroup inputCards;
    for(int iTurns=landlordIndex;!finished;iTurns++){
        if(iTurns>=PLAYERCOUNT){
            iTurns=0;
        }
        if(iTurns==CURRENTPLAYER){
            cout<<endl;
            player[iTurns]->print();
            cout<<"è¾“å…¥æç¤ºï¼šZ=å¤§ç‹ Y=å°ç‹ 0=10 N=ä¸è¦ è¾“å…¥å¯æ— åº ä¾‹å¦‚:JKQ0A9\nè¯·å‡ºç‰Œï¼š\t";
            do{
                cin>>inputSrt;
                inputCards.init(inputSrt,player[iTurns]->cards);
            }while(check(&inputCards)==false);
        }else{
            if(player[iTurns]==LastCards::inst()->player){
                //è‹¥æ˜¯ä¸Šæ¬¡å‡ºç‰Œçš„æ˜¯è‡ªå·±ï¼Œå¯ç”¨æç¤ºåŠŸèƒ½
                inputCards.init(player[iTurns]->tip());
            }else{
                //æŸ¥æ‰¾èƒ½æ‰“å¾—è¿‡ä¸Šå®¶çš„ç‰Œ
                inputCards.init(LastCards::inst()->findCanBeatFrom(player[iTurns]->cards));
            }
        }
        player[iTurns]->chupai(inputCards);//å‡ºç‰Œ
         if(player[iTurns]->cards.size()==0){
            //ç©å®¶æ‰‹ä¸­æ²¡ç‰Œäº†ï¼Œæ¸¸æˆç»“æŸ
            finished=true;
            landlordWin=iTurns==landlordIndex;
            if(landlordWin){
                youWin=landlordIndex==CURRENTPLAYER;
            }else{
                youWin=landlordIndex!=CURRENTPLAYER;
            }
        }
    }
    cout<<"\n_________________________ "<<(youWin?"You Win!":"You Lose!")<<" _________________________\n\n";
}
void add3Cards(){
    cout<<"åœ°ä¸»3å¼ ç‰Œ:\t";
    for(int i=PLAYERCOUNT*17;i<CARDSCOUNT;i++){
        this->cards[i]->print();
        player[landlordIndex]->cards.push_back(cards[i]);
    }
    cout<<endl;
    player[landlordIndex]->arrange();
}
int chooseLandlord(){
    cout<<"\n_________________________ æŠ¢åœ°ä¸» _________________________\n\n";
    int first=-1,last,cnt=0,i,j=rand()%PLAYERCOUNT;
    bool decision;
    for(i=0;i<PLAYERCOUNT;i++,j==2?j=0:j++){
        if(j==CURRENTPLAYER){
            decision=makeChoice("æ˜¯å¦æŠ¢åœ°ä¸»ï¼Ÿ(Y=æŠ¢/N=ä¸æŠ¢):");
        }else{
            decision=rand()%2;
        }
        if(decision){
            cnt++;
            last=j;
            if(first==-1){
                first=j;
            }
            cout<<this->player[j]->name<<"\tæŠ¢åœ°ä¸»\n";
        }else{
            cout<<this->player[j]->name<<"\tæ²¡æœ‰æŠ¢\n";
        }
    }
    if(cnt==0){
        cout<<"æ²¡äººæŠ¢ï¼Œé‡æ–°å‘ç‰Œ\n";
        return ERROR;
    }
    if(cnt==1){
        //ç¬¬ä¸€è½®åªæœ‰ä¸€äººæŠ¢åœ°ä¸»
        return first;
    }
    else{
        //æœ€åä¸€æ¬¡äº‰æŠ¢
        if(first==CURRENTPLAYER){
            decision=makeChoice("æ˜¯å¦æŠ¢åœ°ä¸»ï¼Ÿ(Y=æŠ¢/N=ä¸æŠ¢):");
        }else{
            decision=rand()%2;
        }
        if(decision){
            cout<<this->player[first]->name<<"\tæŠ¢åœ°ä¸»\n";
            return first;
        }else{
            cout<<this->player[first]->name<<"\tæ²¡æœ‰æŠ¢\n";
            return last;
        }
    }
}
void shuffle(){
    int i,j,k;
    //æ´—ç‰Œ
    for(i=0;i<CARDSCOUNT;i++){
        swap(this->cards[i],this->cards[rand()%CARDSCOUNT]);
    }
     //åˆ†ç‰Œ
    for(k=i=0;i<PLAYERCOUNT;i++){
        this->player[i]->cards.clear();
        for(j=0;j<17;j++){
            this->player[i]->cards.push_back(this->cards[k++]);
        }
        this->player[i]->arrange();//æ•´ç†
        this->player[i]->print();
    }
}
bool check(CardGroup *cardGroup){
    if(cardGroup->type.typeId==ERROR){
        cout<<"å‡ºç‰Œé”™è¯¯ï¼Œé‡æ–°è¾“å…¥\n";
        return false;
    }else if(cardGroup->type.typeStr=="ä¸å‡º"){
        return true;
    }else if(LastCards::inst()->player!=player[CURRENTPLAYER]&&!cardGroup->isCanBeat(LastCards::inst()->cardGroup)){
        cout<<"æ‰“ä¸è¿‡ï¼Œé‡æ–°è¾“å…¥\n";
        return false;
    }else{
        return true;
    }
}
};
int main(){
Landlords *landlords=new Landlords();
do{
    landlords->init();//å‘ç‰Œã€æŠ¢åœ°ä¸»
    landlords->startGame();//æ¸¸æˆå¼€å§‹
}while(makeChoice("\næ˜¯å¦ç»§ç»­æ¸¸æˆï¼Ÿï¼ˆY=ç»§ç»­/N=ç»“æŸï¼‰: "));
delete landlords;
return 0;
}
bool makeChoice(string tip){
cout<<tip;
string input;
cin>>input;
return input=="Y"||input=="y";
}
bool cmp(Card* a,Card* b){
if(a->value==b->value){
    return a->color>b->color;
}else{
    return a->value>b->value;
}
}




```

---

> å—¨ï¼Œæˆ‘æ˜¯[LucianaiB](https://lucianaib.blog.csdn.net/ â€œLucianaiBâ€)ã€‚å¦‚æœä½ è§‰å¾—æˆ‘çš„åˆ†äº«æœ‰ä»·å€¼ï¼Œä¸å¦¨é€šè¿‡ä»¥ä¸‹æ–¹å¼è¡¨è¾¾ä½ çš„æ”¯æŒï¼šğŸ‘ ç‚¹èµæ¥è¡¨è¾¾ä½ çš„å–œçˆ±ï¼ŒğŸ“ å…³æ³¨ä»¥è·å–æˆ‘çš„æœ€æ–°æ¶ˆæ¯ï¼ŒğŸ’¬ è¯„è®ºä¸æˆ‘äº¤æµä½ çš„è§è§£ã€‚æˆ‘ä¼šç»§ç»­åŠªåŠ›ï¼Œä¸ºä½ å¸¦æ¥æ›´å¤šç²¾å½©å’Œå®ç”¨çš„å†…å®¹ã€‚

ç‚¹å‡»è¿™é‡ŒğŸ‘‰[LucianaiB](https://lucianaib.blog.csdn.net/ â€œLucianaiBâ€) ï¼Œè·å–æœ€æ–°åŠ¨æ€ï¼Œâš¡ï¸ è®©ä¿¡æ¯ä¼ é€’æ›´åŠ è¿…é€Ÿã€‚