---
layout: post
title: "django下防御race-condition漏洞竞争型漏洞"
date: 2025-03-10 17:35:38 +0800
description: "概念悲观锁假设并发冲突一定会发生，因此在访问数据时直接加锁，确保其他事务无法修改数据，直到当前事务完成。悲观锁通常通过数据库的锁机制实现，如或。特点优点：保证数据的一致性，适合写操作多的场景。缺点：加锁会降低并发性能，可能导致死锁。使用场景高并发写操作。数据一致性要求高的场景。实例该例子需要实现一个转账操作，确保余额不会出现负数。在中，账户A的记录被锁定，其他事务无法修改，直到当前事务提交或回滚。-- 开启事务-- 使用悲观锁锁定账户A的记录-- 检查余额是否足够-- 扣除账户A的余额。"
keywords: "django下防御race condition漏洞(竞争型漏洞)"
categories: ['未分类']
tags: ['安全', 'Web']
artid: "146158257"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158257
    alt: "django下防御race-condition漏洞竞争型漏洞"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158257
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158257
cover: https://bing.ee123.net/img/rand?artid=146158257
image: https://bing.ee123.net/img/rand?artid=146158257
img: https://bing.ee123.net/img/rand?artid=146158257
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     django下防御race condition漏洞(竞争型漏洞)
    </h1>
   </div>
   <div class="article-resource-info-box">
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="%E7%AB%9E%E4%BA%89%E5%9E%8B%E6%BC%8F%E6%B4%9E" name="%E7%AB%9E%E4%BA%89%E5%9E%8B%E6%BC%8F%E6%B4%9E">
     竞争型漏洞
    </h3>
    <h4 id="%E6%A6%82%E5%BF%B5" name="%E6%A6%82%E5%BF%B5">
     概念
    </h4>
    <p>
     竞争型漏洞，也称为竞态条件漏洞（Race Condition Vulnerability），是由于程序在处理共享资源时，未能正确同步多个并发操作，导致执行结果依赖于这些操作的时序，从而可能被攻击者利用的安全漏洞。
    </p>
    <p>
     假设有一个银行应用，处理转账的时候，如果两个转账操作同时进行，而余额检查没有正确同步，可能导致余额错误地被处理。例如，用户A有100元，同时发起两笔转账，各转出100元，如果系统没有正确锁定资源，可能两笔转账都通过，导致用户A的余额变成负数，这就是竞争条件导致的漏洞。
    </p>
    <h3 id="%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%A4%BA%E4%BE%8B" name="%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%A4%BA%E4%BE%8B">
     <strong>
      常见类型及示例
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        TOCTOU（Time-of-Check to Time-of-Use）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          原理
         </strong>
         ：程序在检查资源状态后、使用资源前，攻击者篡改资源。
        </p>
       </li>
       <li>
        <p>
         <strong>
          示例
         </strong>
         ：检查文件权限后，攻击者替换为恶意文件，导致高权限执行。
        </p>
       </li>
       <li>
        <p>
         <strong>
          场景
         </strong>
         ：文件系统操作、权限验证。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        资源争用
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          原理
         </strong>
         ：并发操作修改同一资源（如余额、库存）时未同步。
        </p>
       </li>
       <li>
        <p>
         <strong>
          示例
         </strong>
         ：电商系统中，两用户同时购买最后一件商品，导致超卖。
        </p>
       </li>
       <li>
        <p>
         <strong>
          场景
         </strong>
         ：金融交易、库存管理。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        异步操作漏洞
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          原理
         </strong>
         ：回调或事件处理顺序不当引发状态混乱。
        </p>
       </li>
       <li>
        <p>
         <strong>
          示例
         </strong>
         ：JavaScript中多个异步回调修改同一变量，导致数据错误。
        </p>
       </li>
       <li>
        <p>
         <strong>
          场景
         </strong>
         ：前端应用、分布式任务处理。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     下面介绍一个关于竞争性的漏洞
    </p>
    <h3 id="%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" name="%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">
     环境搭建
    </h3>
    <p>
     可以在资源中下载文件解压
    </p>
    <p>
     将文件上传到linux下，我们修改文件按中的错误，
    </p>
    <p>
     将.env.defaul修改为.env
    </p>
    <p>
     修改文件中的DEBUG=True
    </p>
    <p>
     然后进行如下操作
    </p>
    <pre><code class="hljs">pip3 install -r requirements.txt 

python3 manage.py migrate

python3 manage.py collectstatic

python3 manage.py createsuperuser

python3 manage.py runserver  0.0.0.0:8080</code></pre>
    <p>
     完成之后可以访问网站
    </p>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0" name="%E2%80%8B%E7%BC%96%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0">
     <img alt="" height="902" src="https://i-blog.csdnimg.cn/direct/9c38b5230f054aff8657934e2d069e24.png" width="1920">
      漏洞复现
     </img>
    </h3>
    <h4 id="ucenter%2F1%2F" name="ucenter%2F1%2F">
     ucenter/1/
    </h4>
    <p>
     无锁无事务时的竞争攻击
    </p>
    <pre><code class="hljs">class WithdrawView1(BaseWithdrawView):
    success_url = reverse_lazy('ucenter:withdraw1')

    def form_valid(self, form):
        amount = form.cleaned_data['amount']
        self.request.user.money -= amount
        self.request.user.save()
        models.WithdrawLog.objects.create(user=self.request.user, amount=amount)

        return redirect(self.get_success_url())</code></pre>
    <p>
     <img alt="" height="518" src="https://i-blog.csdnimg.cn/direct/f23af5c56d674effaed6253bbe9f67b4.png" width="774"/>
    </p>
    <p>
     利用bp抓包，当出现两次以上的扣款成功，就说明漏洞利用成功
    </p>
    <p>
     竞争成功
    </p>
    <p>
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/aa0b626697604b98b199f6b78d4d72ea.png" width="1092"/>
    </p>
    <p>
     查看日志
    </p>
    <p>
     <img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/0ce56355343d4f2d9e6ce40d19e55c57.png" width="1383"/>
    </p>
    <h4 id="ucenter%2F2%2F" name="ucenter%2F2%2F">
     ucenter/2/
    </h4>
    <p>
     无锁有事务时的竞争攻击
    </p>
    <pre><code class="hljs">class WithdrawView2(BaseWithdrawView):
    success_url = reverse_lazy('ucenter:withdraw2')

    @transaction.atomic
    def form_valid(self, form):
        amount = form.cleaned_data['amount']
        self.request.user.money -= amount
        self.request.user.save()
        models.WithdrawLog.objects.create(user=self.request.user, amount=amount)

        return redirect(self.get_success_url())</code></pre>
    <p>
     继续竞争
    </p>
    <p>
     <img alt="" height="486" src="https://i-blog.csdnimg.cn/direct/abe2d07aa106485d8dd397a35568a0c3.png" width="1076">
      查看日志
     </img>
    </p>
    <p>
     <img alt="" height="375" src="https://i-blog.csdnimg.cn/direct/5c2eead1977a411883c0fe9970456d2b.png" width="1365"/>
    </p>
    <p>
     竞争成功。
    </p>
    <h4 id="ucenter%2F3%2F" name="ucenter%2F3%2F">
     ucenter/3/
    </h4>
    <p>
     悲观锁加事务防御Race Condition
    </p>
    <pre><code class="hljs">class WithdrawView3(BaseWithdrawView):
    success_url = reverse_lazy('ucenter:withdraw3')

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.user
        return kwargs

    @transaction.atomic
    def dispatch(self, request, *args, **kwargs):
        self.user = get_object_or_404(models.User.objects.select_for_update().all(), pk=self.request.user.pk)
        return super().dispatch(request, *args, **kwargs)

    def form_valid(self, form):
        amount = form.cleaned_data['amount']
        self.user.money -= amount
        self.user.save()
        models.WithdrawLog.objects.create(user=self.user, amount=amount)

        return redirect(self.get_success_url())
</code></pre>
    <p>
     <img alt="" height="554" src="https://i-blog.csdnimg.cn/direct/795259911a654b128b252ecddbbadbff.png" width="1115">
      发现只有一次提款成功
     </img>
    </p>
    <h4 id="ucenter%2F4%2F" name="ucenter%2F4%2F">
     ucenter/4/
    </h4>
    <p>
     乐观锁加事务防御Race Condition
    </p>
    <pre><code class="hljs">class WithdrawView4(BaseWithdrawView):
    success_url = reverse_lazy('ucenter:withdraw4')

    @transaction.atomic
    def form_valid(self, form):
        amount = form.cleaned_data['amount']
        rows = models.User.objects.filter(pk=self.request.user, money__gte=amount).update(money=F('money')-amount)
        if rows &gt; 0:
            models.WithdrawLog.objects.create(user=self.request.user, amount=amount)

        return redirect(self.get_success_url())
</code></pre>
    <p>
     <img alt="" height="620" src="https://i-blog.csdnimg.cn/direct/e73b13fe10884df3a12ba77c5a586dd7.png" width="1073"/>
    </p>
    <p>
     发现也只有一次成功
    </p>
    <h3 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93">
     总结
    </h3>
    <h4 id="%E6%82%B2%E8%A7%82%E9%94%81" name="%E6%82%B2%E8%A7%82%E9%94%81">
     悲观锁
    </h4>
    <p>
     <strong>
      概念
     </strong>
    </p>
    <ul>
     <li>
      <p>
       悲观锁假设并发冲突一定会发生，因此在访问数据时直接加锁，确保其他事务无法修改数据，直到当前事务完成。
      </p>
     </li>
     <li>
      <p>
       悲观锁通常通过数据库的锁机制实现，如
       <code>
        SELECT ... FOR UPDATE
       </code>
       或
       <code>
        SELECT ... LOCK IN SHARE MODE
       </code>
       。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      特点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        优点
       </strong>
       ：保证数据的一致性，适合写操作多的场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        缺点
       </strong>
       ：加锁会降低并发性能，可能导致死锁。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      使用场景
     </strong>
    </p>
    <ul>
     <li>
      <p>
       高并发写操作。
      </p>
     </li>
     <li>
      <p>
       数据一致性要求高的场景。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      实例
     </strong>
    </p>
    <p>
     该例子需要实现一个转账操作，确保余额不会出现负数。
    </p>
    <p>
     在
     <code>
      SELECT ... FOR UPDATE
     </code>
     中，账户A的记录被锁定，其他事务无法修改，直到当前事务提交或回滚。
    </p>
    <pre><code class="hljs">-- 开启事务
START TRANSACTION;

-- 使用悲观锁锁定账户A的记录
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;

-- 检查余额是否足够
IF (SELECT balance FROM accounts WHERE id = 1) &gt;= 100 THEN
    -- 扣除账户A的余额
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    -- 增加账户B的余额
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
END IF;

-- 提交事务
COMMIT;</code></pre>
    <h4 id="%E4%B9%90%E8%A7%82%E9%94%81" name="%E4%B9%90%E8%A7%82%E9%94%81">
     乐观锁
    </h4>
    <p>
     <strong>
      概念
     </strong>
    </p>
    <ul>
     <li>
      <p>
       乐观锁假设并发冲突很少发生，因此在访问数据时不加锁，而是在提交时检查数据是否被其他事务修改过。
      </p>
     </li>
     <li>
      <p>
       乐观锁通常通过版本号（Version）或时间戳（Timestamp）实现。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      特点
     </strong>
    </p>
    <ul>
     <li>
      <p>
       优点：提高并发性能，适合读操作多的场景。
      </p>
     </li>
     <li>
      <p>
       缺点：如果冲突频繁，会导致大量事务回滚。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      使用场景
     </strong>
    </p>
    <ul>
     <li>
      <p>
       高并发读操作。
      </p>
     </li>
     <li>
      <p>
       冲突较少的场景。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      实例
     </strong>
    </p>
    <p>
     在乐观锁中，通过
     <code>
      version
     </code>
     字段检查数据是否被修改。如果
     <code>
      version
     </code>
     不匹配，说明数据已被其他事务修改，当前事务需要回滚并重试。
    </p>
    <p>
     即，当用户A进行提款操作时，若存在两个以上的请求进程(查询的version为1)，当某一个进程率先请求成功，version会自增1，其他的进程就无法查询到该版本号,从而不会执行账户操作，事务回滚。
    </p>
    <pre><code class="hljs">-- 开启事务
START TRANSACTION;

-- 查询账户A的余额和版本号
SELECT balance, version FROM accounts WHERE id = 1;

-- 假设查询到的 balance = 500, version = 1
-- 检查余额是否足够
IF 500 &gt;= 100 THEN
    -- 扣除账户A的余额，并更新版本号
    UPDATE accounts SET balance = balance - 100, version = version + 1 WHERE id = 1 AND version = 1;

    -- 检查是否更新成功
    IF ROW_COUNT() = 0 THEN
        -- 版本号不匹配，说明数据已被其他事务修改，回滚事务
        ROLLBACK;
    ELSE
        -- 增加账户B的余额
        UPDATE accounts SET balance = balance + 100 WHERE id = 2;
        -- 提交事务
        COMMIT;
    END IF;
END IF;</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f736764687368736868732f:61727469636c652f64657461696c732f313436313538323537" class_="artid" style="display:none">
 </p>
</div>


