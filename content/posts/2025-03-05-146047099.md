---
layout: post
title: "C中的-互斥量-"
date: 2025-03-05 18:00:09 +0800
description: "为什么：线程的异步性，不是按照时间来的！！！多线程编程中，当多个线程可能同时访问和修改共享资源时，会导致数据不一致或程序错误。互斥量提供了一种加锁机制，线程在访问共享资源前必须先获取互斥量的锁，访问结束后释放锁，这样其他线程才能获取锁并访问共享资源。互斥量内部维护一个状态，表示它是否被锁定。当一个线程成功获取锁时，互斥量被锁定，其他线程试图获取锁时会被阻塞，直到锁被释放。"
keywords: "C++中的 互斥量 "
categories: ['未分类']
tags: ['面试', 'Jvm', 'Java']
artid: "146047099"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146047099
    alt: "C中的-互斥量-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146047099
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146047099
cover: https://bing.ee123.net/img/rand?artid=146047099
image: https://bing.ee123.net/img/rand?artid=146047099
img: https://bing.ee123.net/img/rand?artid=146047099
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++中的 互斥量
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.概念：
    </h2>
    <p>
     为什么：线程的异步性，不是按照时间来的！！！
    </p>
    <p>
     <a href="https://blog.csdn.net/m0_73359068/article/details/146025726?sharetype=blogdetail&amp;sharerId=146025726&amp;sharerefer=PC&amp;sharesource=m0_73359068&amp;spm=1011.2480.3001.8118" title="C++并发以及多线程的秘密-CSDN博客">
      C++并发以及多线程的秘密-CSDN博客
     </a>
    </p>
    <p>
     <strong>
      目的
     </strong>
    </p>
    <p>
     多线程编程中，当多个线程可能同时访问和修改共享资源时，会导致数据不一致或程序错误。互斥量提供了一种加锁机制，线程在访问共享资源前必须先获取互斥量的锁，访问结束后释放锁，这样其他线程才能获取锁并访问共享资源。
    </p>
    <p>
     <strong>
      原理：
     </strong>
    </p>
    <p>
     互斥量内部维护一个状态，表示它是否被锁定。当一个线程成功获取锁时，互斥量被锁定，其他线程试图获取锁时会被阻塞，直到锁被释放
    </p>
    <h2>
     2.基本用法
    </h2>
    <p>
     C++ 标准库在
     <code>
      &lt;mutex&gt;
     </code>
     头文件中提供了几种类型的互斥量，
     <code>
      std::mutex std::timed_mutex
     </code>
    </p>
    <p>
     <strong>
      <code>
       lock函数
      </code>
     </strong>
     <strong>
      <code>
       和unlock函数
      </code>
     </strong>
    </p>
    <pre><code class="language-cpp">#include&lt;mutex&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;
using namespace std;

int sharedResource = 0;
std::mutex mtx;
void increment() {
    for (int i = 0; i &lt; 10; ++i) {
        mtx.lock();
        ++sharedResource;
       cout&lt;&lt;++sharedResource&lt;&lt;endl
        mtx.unlock();
		
    }
}

void decrement() {
    for (int i = 0; i &lt; 10; ++i) {
        mtx.lock();
        --sharedResource;
        cout&lt;&lt;sharedResource&lt;&lt;endl;
		mtx.unlock();
		
    }
}
int main()
   {
	 std::thread thread1(increment);
    std::thread thread2(decrement);

    thread1.join();
    thread2.join();

    std::cout &lt;&lt; "Final value of sharedResource: " &lt;&lt; sharedResource &lt;&lt; std::endl;

    return 0;

 
}
</code></pre>
    <p>
     结果如下:
    </p>
    <pre><code class="language-cpp">1
2
3
4
5
6
7
8
9
10
9
8
7
6
5
4
3
2
1
0</code></pre>
    <p>
     结果展现清晰知道会有独占思想
    </p>
    <p>
     <strong>
      2.lock_guard函数
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std;

std::mutex mtx;
int n=0;

void func1() {
    lock_guard&lt;mutex&gt; lock(mtx);
     n++;
}
void func2() {
    lock_guard&lt;mutex&gt; lock(mtx);
    n--;
}

int main() {
    thread t1(func1);
    cout &lt;&lt; n &lt;&lt; endl;
    thread t2(func2);
    cout &lt;&lt; n &lt;&lt; endl;
    t1.join();
    t2.join();
}</code></pre>
    <p>
    </p>
    <h2>
     3.死锁以及解决办法
    </h2>
    <p>
     概念：
    </p>
    <p>
     死锁是指在多线程或多进程环境中，两个或多个执行单元（线程、进程等）因竞争系统资源或彼此通信而造成的一种阻塞现象，若无外力作用，这些执行单元都将无法推进。
    </p>
    <p>
     <strong>
      死锁产生的必要条件
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        互斥条件
       </strong>
       ：资源在同一时间只能被一个执行单元使用。例如，打印机在打印一份文档时，不能同时为另一份文档服务。
      </p>
     </li>
     <li>
      <p>
       <strong>
        占有并等待条件
       </strong>
       ：一个执行单元持有至少一个资源，并在等待获取其他执行单元持有的额外资源。比如，线程 A 持有资源 R1，同时等待资源 R2，而资源 R2 被线程 B 持有。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不可剥夺条件
       </strong>
       ：资源不能被强制从占有者手中夺走，只能由占有者主动释放。例如，一个线程获得了一个文件的独占访问权，其他线程不能强行剥夺这个权限。
      </p>
     </li>
     <li>
      <p>
       <strong>
        循环等待条件
       </strong>
       ：存在一个执行单元的循环链，链中的每个执行单元都在等待下一个执行单元持有的资源。例如，线程 A 等待线程 B 持有的资源，线程 B 等待线程 C 持有的资源，而线程 C 又等待线程 A 持有的资源。
      </p>
     </li>
    </ol>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex mutex1;
std::mutex mutex2;

void threadFunction1() {
    mutex1.lock();
    std::cout &lt;&lt; "Thread 1 has locked mutex1" &lt;&lt; std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
    mutex2.lock();
    std::cout &lt;&lt; "Thread 1 has locked mutex2" &lt;&lt; std::endl;
    mutex2.unlock();
    mutex1.unlock();
}

void threadFunction2() {
    mutex2.lock();
    std::cout &lt;&lt; "Thread 2 has locked mutex2" &lt;&lt; std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
    mutex1.lock();
    std::cout &lt;&lt; "Thread 2 has locked mutex1" &lt;&lt; std::endl;
    mutex1.unlock();
    mutex2.unlock();
}

int main() {
    std::thread thread1(threadFunction1);
    std::thread thread2(threadFunction2);

    thread1.join();
    thread2.join();

    return 0;
}
结果//Thread 1 has locked mutex1Thread 2 has locked mutex2</code></pre>
    <p>
     解析：
    </p>
    <p>
     在上述代码中，
     <code>
      threadFunction1
     </code>
     先锁定
     <code>
      mutex1
     </code>
     ，然后等待
     <code>
      mutex2
     </code>
     ，而
     <code>
      threadFunction2
     </code>
     先锁定
     <code>
      mutex2
     </code>
     ，然后等待
     <code>
      mutex1
     </code>
     。如果两个线程同时运行，就会满足死锁的四个条件，导致死锁发生。线程 1 持有
     <code>
      mutex1
     </code>
     并等待
     <code>
      mutex2
     </code>
     ，线程 2 持有
     <code>
      mutex2
     </code>
     并等待
     <code>
      mutex1
     </code>
     ，形成循环等待，且资源不能被剥夺，从而造成死锁。
    </p>
    <p>
     如何解决？
    </p>
    <p>
     <strong>
      利用另外一个lock_guard
     </strong>
    </p>
    <p>
     <code>
      std::lock_guard
     </code>
     是基于 RAII（资源获取即初始化）机制的互斥量管理类。它在构造时自动锁定互斥量，在析构时自动解锁，从而简化了代码并避免手动解锁失败的风险
    </p>
    <p>
     代表adopt_lock 以及手动锁了（就是用lock）
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std;

std::mutex mutex1;
std::mutex mutex2;
;

void threadFunction1() {

    lock(mutex1,mutex2);
    lock_guard&lt;mutex&gt;lock1(mutex1,adopt_lock);
    lock_guard&lt;mutex&gt;lock2(mutex2,adopt_lock);
    std::cout &lt;&lt; "Thread 1 has locked mutex1 and mutex2" &lt;&lt; std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout &lt;&lt; "Thread 1 is working with both mutexes" &lt;&lt; std::endl;
}



  
    void threadFunction2() {

        lock(mutex1,mutex2);
        lock_guard&lt;mutex&gt;lock1(mutex2,adopt_lock);
        lock_guard&lt;mutex&gt;lock2(mutex1,adopt_lock);
        std::cout &lt;&lt; "Thread 1 has locked mutex1 and mutex2" &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout &lt;&lt; "Thread 1 is working with both mutexes" &lt;&lt; std::endl;
    }



int main() {
    std::thread thread1(threadFunction1);
    std::thread thread2(threadFunction2);

    thread1.join();
    thread2.join();

    return 0;
}</code></pre>
    <pre><code class="language-cpp">Thread 1 has locked mutex1 and mutex2
Thread 1 is working with both mutexes
Thread 1 has locked mutex1 and mutex2
Thread 1 is working with both mutexes</code></pre>
    <h2>
     4.
     <code>
      unique_lock
     </code>
    </h2>
    <p>
     <code>
      std::lock_guard
     </code>
     是一个简单的 RAII（Resource Acquisition Is Initialization）类，用于在其生命周期内自动锁定和解锁互斥量。它的优点是简单易用，开销小。然而，
     <code>
      std::unique_lock
     </code>
     提供了更多的功能和灵活性，在很多场景下可以取代
     <code>
      std::lock_guard:
     </code>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        延迟锁定
       </strong>
       ：
       <code>
        std::unique_lock
       </code>
       可以在构造时不立即锁定互斥量，而
       <code>
        std::lock_guard
       </code>
       在构造时总是立即锁定互斥量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        锁定所有权的转移
       </strong>
       ：
       <code>
        std::unique_lock
       </code>
       允许通过移动语义转移锁定的所有权，这在函数间传递锁定状态时非常有用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        成员函数操作
       </strong>
       ：
       <code>
        std::unique_lock
       </code>
       提供了如
       <code>
        lock()
       </code>
       、
       <code>
        try_lock()
       </code>
       、
       <code>
        try_lock_for()
       </code>
       、
       <code>
        try_lock_until()
       </code>
       和
       <code>
        unlock()
       </code>
       等成员函数，允许对锁定状态进行更细粒度的控制，而
       <code>
        std::lock_guard
       </code>
       只在构造和析构时自动锁定和解锁，没有提供这些操作。
      </p>
     </li>
    </ul>
    <h3>
     4.1三种构造方法
    </h3>
    <p>
     1.
     <strong>
      <code>
       std::adopt_lock_t
      </code>
     </strong>
     ：与
     <code>
      std::lock_guard
     </code>
     类似，当使用
     <code>
      std::adopt_lock
     </code>
     作为第二个参数时，表明调用者已经手动锁定了互斥量，
     <code>
      std::unique_lock
     </code>
     在构造时不会再次锁定，而是在析构时负责解锁。例如：
    </p>
    <pre><code class="language-cpp">std::mutex mtx;
mtx.lock();
std::unique_lock&lt;std::mutex&gt; lock(mtx, std::adopt_lock);</code></pre>
    <p>
     2.
     <strong>
      <code>
       std::defer_lock_t
      </code>
     </strong>
     ：使用
     <code>
      std::defer_lock
     </code>
     作为第二个参数时，
     <code>
      std::unique_lock
     </code>
     构造时不会锁定互斥量，而是处于未锁定状态。之后可以通过调用
     <code>
      lock()
     </code>
     、
     <code>
      try_lock()
     </code>
     等成员函数来锁定互斥量。例如
    </p>
    <pre><code class="language-cpp">std::mutex mtx;
std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock);
if (lock.try_lock()) {
    // 成功锁定，执行临界区代码
    lock.unlock();
}</code></pre>
    <p>
     3.s
     <strong>
      <code>
       td::try_to_lock_t
      </code>
     </strong>
     ：使用
     <code>
      std::try_to_lock
     </code>
     作为第二个参数时，
     <code>
      std::unique_lock
     </code>
     构造时会尝试锁定互斥量，但不会阻塞等待。如果成功锁定，
     <code>
      unique_lock
     </code>
     对象拥有锁定；否则，处于未锁定状态。例如
    </p>
    <pre><code class="language-cpp">std::mutex mtx;
std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock);
if (lock.owns_lock()) {
    // 成功锁定，执行临界区代码
    lock.unlock();
}</code></pre>
    <h3>
     4.2成员函数
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         lock()
        </code>
       </strong>
       ：锁定关联的互斥量。如果互斥量已被锁定，调用线程将阻塞直到互斥量可用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         try_lock()
        </code>
       </strong>
       ：尝试锁定关联的互斥量，不会阻塞。如果成功锁定，返回
       <code>
        true
       </code>
       ；否则，返回
       <code>
        false
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         try_lock_for(duration)
        </code>
       </strong>
       ：尝试在指定的时间段内锁定关联的互斥量。如果在指定时间内成功锁定，返回（一般参数为chrono::seconds()）同理
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         try_lock_until(time_point) 只能time_mutex用
        </code>
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         unlock()
        </code>
       </strong>
       ：解锁关联的互斥量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         owns_lock()
        </code>
       </strong>
       ：返回
       <code>
        unique_lock
       </code>
       对象是否拥有互斥量的锁定。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         release()
        </code>
       </strong>
       ：释放
       <code>
        unique_lock
       </code>
       对象对互斥量的所有权，返回指向关联互斥量的指针，并且
       <code>
        unique_lock
       </code>
       对象变为不拥有任何互斥量
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;

// 使用 std::timed_mutex 来支持带超时的锁定操作
std::timed_mutex mtx;

// 线程函数
void worker(int id) {
    // 使用 unique_lock 管理互斥量
    std::unique_lock&lt;std::timed_mutex&gt; lock(mtx, std::defer_lock);

    // 尝试锁定互斥量，不会阻塞
    if (lock.try_lock()) {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " acquired the lock using try_lock()." &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        lock.unlock();
    } else {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " failed to acquire the lock using try_lock()." &lt;&lt; std::endl;
    }

    // 尝试在指定时间段内锁定互斥量
    if (lock.try_lock_for(std::chrono::seconds(2))) {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " acquired the lock using try_lock_for()." &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        lock.unlock();
    } else {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " failed to acquire the lock using try_lock_for()." &lt;&lt; std::endl;
    }

    // 尝试在指定时间点前锁定互斥量
    auto timeout = std::chrono::steady_clock::now() + std::chrono::seconds(2);
    if (lock.try_lock_until(timeout)) {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " acquired the lock using try_lock_until()." &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        lock.unlock();
    } else {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " failed to acquire the lock using try_lock_until()." &lt;&lt; std::endl;
    }

    // 正常锁定互斥量
    lock.lock();
    std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " acquired the lock using lock()." &lt;&lt; std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // 检查是否拥有互斥量的锁定
    if (lock.owns_lock()) {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " owns the lock." &lt;&lt; std::endl;
    }

    // 释放 unique_lock 对互斥量的所有权
    std::timed_mutex* released_mtx = lock.release();
    if (!lock.owns_lock()) {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " released the lock using release()." &lt;&lt; std::endl;
    }

    // 手动解锁互斥量
    released_mtx-&gt;unlock();
}

int main() {
    // 创建两个线程
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);

    // 等待线程完成
    t1.join();
    t2.join();

    return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333335393036382f:61727469636c652f64657461696c732f313436303437303939" class_="artid" style="display:none">
 </p>
</div>


