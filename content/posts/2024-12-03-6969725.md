---
layout: post
title: "利用命名管道实现进程之间的通信-........."
date: 2024-12-03 19:19:13 +0800
description: "/*   命名管道不仅可以实现 本地进程之间的通信还可以实现网络进程的通信   与油槽不同的是 管道"
keywords: "命名管道 通信 传递 std::list"
categories: ['Vc']
tags: ['操作系统相关', 'Socket', 'Path', 'Null', 'File', 'Access']
artid: "6969725"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=6969725
    alt: "利用命名管道实现进程之间的通信-........."
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=6969725
featuredImagePreview: https://bing.ee123.net/img/rand?artid=6969725
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     利用命名管道实现进程之间的通信 .........
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     /*
     <br/>
     命名管道不仅可以实现 本地进程之间的通信还可以实现网络进程的通信   与油槽不同的是 管道式基于面向连接的可靠的通信 只能一对一传输 数据
     <br/>
     我们可以通过
     <br/>
     CreateNamedPipe()创建一个管道 ,可以指定模式是双向 即客户端 和服务端都可以进行读写 管道    就跟基于 socket的TCP通信类似
     <br/>
     在服务端调用ConnectNamedPipe()来等待客户端连接管道 ，不像函数英文名字那样连接管道 而是等地啊客户端连接的到来
     <br/>
     <br/>
     在客户端我们需要调用  WaitNamedPipe()函数来连接管道
    </p>
    <p>
     在完成以上的工作之后 我们就可以利用  CreateFile()  ReadFile()   WriteFile()进行进程之间的通信了
     <br/>
     <br/>
     在 油槽 命名管道 磁盘文件的读写 的时候我们都用到了  CreateFile()  ReadFile() WriteFile()  一样的函数  来进行操作
     <br/>
     */
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     ///服务端
     <br/>
     #include &lt;iostream&gt;
     <br/>
     #include "windows.h"
     <br/>
     #include &lt;string&gt;
     <br/>
     using namespace std ;
     <br/>
     void main()
     <br/>
     {
     <!-- -->
     <br/>
     HANDLE  hNamedPipe=::CreateNamedPipe("\\\\.\\pipe\\path",  //管道名称    如果是不同主机需要吧.换成主机名字  或者直接换成＊就可以实现全网内部的通信
     <br/>
     PIPE_ACCESS_DUPLEX, //管道可以双向通信
     <br/>
     PIPE_TYPE_BYTE,//数据以字节流的方式写入管道
     <br/>
     PIPE_UNLIMITED_INSTANCES, //表示管道能够创建的最大实例数目 这里只和操作系统相关
     <br/>
     1024, //输出缓冲区大小
     <br/>
     1024,//输入缓冲区大小
     <br/>
     0,//超时间隔
     <br/>
     NULL//默认安全结构
     <br/>
     ) ;
     <br/>
     OVERLAPPED ov={0} ;  //定义一个OVERLAPPED结构体  并初始化为 0
     <br/>
     ::ConnectNamedPipe(hNamedPipe,&amp;ov);
     <br/>
     char buf[100]  ;
     <br/>
     DWORD len ;
     <br/>
     string s ;
     <br/>
     while(1)
     <br/>
     {
     <!-- -->
     <br/>
     ReadFile(hNamedPipe,(void*)buf,100,&amp;len,NULL) ;  //如果连接到来了 那么我们就从管道读取数据
     <br/>
     cout&lt;&lt;"客户端说:"&lt;&lt;buf&lt;&lt;endl ;
     <br/>
     cout&lt;&lt;"请输入发送给客户端的数据:"&lt;&lt;endl ;
     <br/>
     cin&gt;&gt;s;
     <br/>
     cout&lt;&lt;s&lt;&lt;endl ;
     <br/>
     WriteFile(hNamedPipe,(void*)s.c_str(),s.length()+1,&amp;len,NULL);
     <br/>
     }
    </p>
    <p>
     <br/>
     }
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     //客户端
    </p>
    <p>
     #include &lt;iostream&gt;
     <br/>
     #include "windows.h"
     <br/>
     using namespace std ;
     <br/>
     void main()
     <br/>
     {
     <!-- -->
    </p>
    <p>
     if(!::WaitNamedPipe("\\\\.\\pipe\\path",NMPWAIT_WAIT_FOREVER) )  //连接管道
     <br/>
     {
     <!-- -->
     <br/>
     cout&lt;&lt;"连接管道失败!"&lt;&lt;endl ;
     <br/>
     return  ;
     <br/>
     }
     <br/>
     <br/>
     HANDLE h1=::CreateFile("\\\\.\\pipe\\path",GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL) ;  //打开管道
     <br/>
     char buf[100]  ;
     <br/>
     DWORD len ;
     <br/>
     while(1)
     <br/>
     {
     <br/>
     cout&lt;&lt;"请输入要写入的数据:"&lt;&lt;endl ;
     <br/>
     cin&gt;&gt;buf ;
     <br/>
     WriteFile(h1,(LPVOID)buf,strlen(buf)+1,&amp;len,NULL) ;
     <br/>
     ReadFile(h1,(LPVOID)buf,100,&amp;len,NULL) ;
     <br/>
     cout&lt;&lt;"服务器说:"&lt;&lt;buf&lt;&lt;endl ;
     <br/>
     }
    </p>
    <p>
    </p>
    <p>
     }
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f797565373630333833:352f61727469636c652f64657461696c732f36393639373235" class_="artid" style="display:none">
 </p>
</div>


