---
layout: post
title: "java-finalize-方法引发的内存泄露"
date: 2025-01-07 14:15:57 +0800
description: "java finalize 方法引发的内存泄露Posted: Mon, 11 Mar 2013jav"
keywords: "the class \"java.lang.ref.finalizer\", loaded by \"<system class loader>\", occu"
categories: ['Java']
tags: ['无标签']
artid: "8665073"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=8665073
    alt: "java-finalize-方法引发的内存泄露"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=8665073
featuredImagePreview: https://bing.ee123.net/img/rand?artid=8665073
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java finalize 方法引发的内存泄露
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 class="title">
     <a href="/blog/java/java_finalize.html" rel="nofollow">
      java finalize 方法引发的内存泄露
     </a>
    </h2>
    Posted: Mon, 11 Mar 2013
    <ul class="tags clear">
     <li>
      <a class="small" href="/blog/tags/java.html" rel="nofollow">
       java
      </a>
     </li>
    </ul>
    <h3>
     内存dump
    </h3>
    <p>
     内存dump后，大量的内存(&gt;5G) 被 java.lang.ref.Finalizer hold 住(见图1)。 而这些内存是
     <span class="caps">
      BDB
     </span>
     占用，怀疑是
     <span class="caps">
      BDB
     </span>
     有内存泄露(见图2)。
    </p>
    <ul>
     <li>
      <img alt="Drawing" src="https://raw.github.com/cleef/cleef.github.com/master/media/images/java_finalizer.png" style="width:400px">
      </img>
     </li>
     <li>
      <img alt="Drawing" src="https://raw.github.com/cleef/cleef.github.com/master/media/images/java_finalizer2.png" style="width:400px">
      </img>
     </li>
    </ul>
    <h3>
     java finalizer 机制
    </h3>
    <p>
     为什么会是 java.lang.ref.Finalizer 的引用导致
     <span class="caps">
      BDB
     </span>
     无法释放内存？没有开启实时索引的机器上
     <span class="caps">
      BDB
     </span>
     不会有内存泄露?重新了解java finalize的机制：
    </p>
    <p>
     实现了finalize的对象，创建和回收的过程都更耗时。创建时，会新建一个额外的Finalizer 对象指向新创建的对象。 而回收时，至少需要经过两次
     <span class="caps">
      GC
     </span>
     .
    </p>
    <ul>
     <li>
      第一次
      <span class="caps">
       GC
      </span>
      , 检测到对象只有被Finalizer引用，将这个对象放入 java.lang.ref.Finalizer.ReferenceQueue 此时，因为Finalizer的引用，对象还无法被
      <span class="caps">
       GC
      </span>
      .
     </li>
     <li>
      java.lang.ref.Finalizer$FinalizerThread 会不停的清理Queue的对象，remove掉当前元素，并执行对象的finalize方法。
     </li>
     <li>
      清理后，对象没有任何引用，在下一次
      <span class="caps">
       GC
      </span>
      被回收。
     </li>
    </ul>
    <p>
     <a href="http://www.fasterj.com/articles/finalizer1.shtml" rel="nofollow">
      finalizer
     </a>
    </p>
    <h3>
     定位
    </h3>
    <p>
     最后我们发现 java.lang.ref.Finalizer$FinalizerThread wait在一个实时索引的线程上, 见下面代码.
    </p>
    <pre><code>//   java多线程同步的一种典型实现:
   //  循环检查条件(cachedreaderTimestamp &lt;= begintime), 每次wait一小段时间（200ms），最多wait指定的时间(timeout)
   //  另外一个线程会修改条件，让条件为true (cachedreaderTimestamp &gt; begintime)
   while (cachedreaderTimestamp &lt;= begintime)
   {
           synchronized (cachemonitor)
               {
                    cachemonitor.notifyAll();
                   long elapsed = System.currentTimeMillis() - begintime;
                   if (elapsed &gt; timeout) // elapsed 有可能等于 timeout
               {
                             log.debug("refreshCached reader timeout in " + elapsed + "ms");
                             throw new ZoieException("refreshCached reader timeout in " + elapsed + "ms");
               }
                   long timetowait = Math.min(timeout - elapsed, 200);
           try
           {
                 cachemonitor.wait(timetowait); //要么被其他线程唤醒，要么等待timetowait；如果timetowait为0时，只能被 其他线程唤醒，否则一直等待
           }    catch (InterruptedException e)
           {
                 log.warn("refreshCache", e);
           }
   }
   </code></pre>
    <h3>
     code review
    </h3>
    <p>
     检查mandy中的代码发现，有个shutdown 方法被调用两次一次显示调用，一次是finalize中调用第一次调用时，执行上面的代码即便timetowait为0，也没问题，会有线程唤醒调用者; 随后唤醒线程也退出.第二次finalize线程调用时，执行上面的代码timetowait为0时，调用线程(finalize线程)会一直block。因为唤醒线程在第一 次调用时已经退出.
    </p>
    <h3>
     fix
    </h3>
    <p>
     去掉finalize 方法即可
    </p>
    <h3>
     replay
    </h3>
    <p>
     执行下面的程序java -Xmx100m Finalize 程序永不停止
    </p>
    <pre><code>public class Finalize {
          byte[] a = new byte[10 * 1024 * 1024 ];
   
          protected void _finalize() {
                   synchronized(this) {
                           try {
                                   this.wait(0);
                           } catch(Exception e) {
                                   System.err.println(e);
                           }
                   }
          }
   
          public static void main(String[] args) throws Exception {
                   while(true) {
                           new Finalize();
                           Thread.sleep(200);
                   }
          }
   }
   </code></pre>
    <p>
     修改后，实现 finalize 方法java -Xmx100m Finalize
    </p>
    <p>
     很快报内存溢出错误Exception in thread “main” java.lang.OutOfMemoryError: Java heap space
    </p>
    <pre><code>protected void _finalize() {
                   synchronized(this) {
                           try {
                                   this.wait(0);
                           } catch(Exception e) {
                                   System.err.println(e);
                           }
                   }
          }
   
   ---&gt;
   
   protected void finalize() {
                   synchronized(this) {
                           try {
                                   this.wait(0);
                           } catch(Exception e) {
                                   System.err.println(e);
                           }
                   }
          }
   </code></pre>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f46697265436f6465:722f61727469636c652f64657461696c732f38363635303733" class_="artid" style="display:none">
 </p>
</div>


