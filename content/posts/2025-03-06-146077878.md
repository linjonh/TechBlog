---
layout: post
title: "vue3与react-react-hooks"
date: 2025-03-06 19:04:09 +0800
description: "2、setup是所有composition  API(组合式api)展示的舞台， 返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用，setUp(props, contex)接受两个参数，props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性（其实就是vue2.0的props功能），context：上下文对象（其中可以获取到1、attrs组件外部传递过来，但没有在props配置中声明的属性。如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；"
keywords: "vue3与react、 react hooks"
categories: ['面试题汇总与解析']
tags: ['课程设计', '大数据', '后端', 'Spring', 'Java', 'Boot']
artid: "146077878"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077878
    alt: "vue3与react-react-hooks"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077878
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077878
cover: https://bing.ee123.net/img/rand?artid=146077878
image: https://bing.ee123.net/img/rand?artid=146077878
img: https://bing.ee123.net/img/rand?artid=146077878
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     vue3与react、 react hooks
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <div>
     <div class="note-content">
      <blockquote>
       <p>
        <b>
         一、Vue3新特性：
        </b>
        setup、ref、reactive、computed、watch、watchEffect函数、生命周期钩子、自定义hooks函数、toRef和toRefs、shallowReactive 与 shallowRef、readonly 与 shallowReadonly、toRaw 与 markRaw、customRef、provide 与 inject、Fragment、Teleport、Suspense、data选项应始终被声明为一个函数
       </p>
      </blockquote>
      <blockquote>
       <p>
        2、setup是所有composition  API(组合式api)展示的舞台， 返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用，setUp(props, contex)接受两个参数，props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性（其实就是vue2.0的props功能），context：上下文对象（其中可以获取到1、attrs组件外部传递过来，但没有在props配置中声明的属性。2、slots：插槽内容3、emit：分发自定义事件的函数,并且以后在setup中不能写this.$emit,要写context.emit）
       </p>
      </blockquote>
      <blockquote>
       <p>
        3、ref一般用来定义一个
        <b>
         基本类型
        </b>
        的响应式数据， reactive定义一个响应式源对象，接收一个普通对象然后返回该普通对象的响应式代理器对象，响应式转换是“
        <b>
         深层的
        </b>
        ”：会影响对象内部所有嵌套的属性，内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的；watch默认是惰性的，watchEffect默认立即执行；watch可以获取到当前值和之前值，watchEffect只能获取当前值；watch可以传递多个函数作为参数，watchEffect只需要传递一个回调函数
       </p>
      </blockquote>
      <p>
       <b>
        4、
       </b>
      </p>
      <p>
       <b>
        （1）、vue2响应式原理：
       </b>
      </p>
      <blockquote>
       <p>
        核心:
       </p>
       <p>
        对象: 通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视/拦截)
       </p>
       <p>
        数组: 通过
        <b>
         重写数组
        </b>
        更新数组一系列更新元素的方法来实现元素修改的劫持
       </p>
      </blockquote>
      <p>
       <b>
        （2）、Vue3的响应式原理：
       </b>
      </p>
      <blockquote>
       <p>
        核心:
       </p>
       <p>
        通过Proxy(代理):拦截对data任意属性的任意(13种)操作, 包括属性值的读写, 属性的添加, 属性的删除等…
       </p>
       <p>
        通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作
       </p>
      </blockquote>
      <p>
       <b>
        5、生命周期：
       </b>
      </p>
      <p>
       为什么要在生命周期前加"on"？
      </p>
      <p>
       因为setup是围绕beforeCreate和created生命周期来运行的，所以不需要显式地定义它们，这些生命周期函数接受一个回调函数，当钩子被组件调用时将会被执行。
      </p>
      <blockquote>
       <p>
        beforeCreate -&gt; 使用 setup()
       </p>
       <p>
        created -&gt; 使用 setup()
       </p>
       <p>
        beforeMount -&gt; onBeforeMount
       </p>
       <p>
        mounted -&gt; onMounted
       </p>
       <p>
        beforeUpdate -&gt; onBeforeUpdate
       </p>
       <p>
        updated -&gt; onUpdated
       </p>
       <p>
        beforeDestroy -&gt; onBeforeUnmount
       </p>
       <p>
        destroyed -&gt; onUnmounted
       </p>
       <p>
        errorCaptured -&gt; onErrorCaptured
       </p>
       <p>
        1.vue3中已经没有destroyed 和beforeDestroy 了
       </p>
       <p>
        2.vue3也可以用vue2的生命周期,vue3生命周期比vue2快
       </p>
      </blockquote>
      <p>
       <b>
        6、自定义hook函数
       </b>
      </p>
      <p>
       <b>
        什么是hook？ ----本质是一个函数，把setup函数中使用的composition API进行了封装
        <br/>
       </b>
      </p>
      <p>
       类似于vue2中的mixin
      </p>
      <p>
       自定义hook的优势：复用代码,让setup中的逻辑更清晰易懂
      </p>
      <p>
       <b>
        （1）、基础封装hooks
       </b>
      </p>
      <blockquote>
       <p>
        <b>
         //定义的hooks
         <br/>
        </b>
       </p>
       <p>
        import {reactive,onMounted,onBeforeUnmount} from 'vue'
       </p>
       <p>
        export default function(){
        <!-- -->
       </p>
       <p>
        let point=reactive(
       </p>
       <p>
        {
        <!-- -->
       </p>
       <p>
        x:0,
       </p>
       <p>
        y:0
       </p>
       <p>
        }
       </p>
       <p>
        )
       </p>
       <p>
        function sponk(event){
        <!-- -->
       </p>
       <p>
        console.log(point);
       </p>
       <p>
        point.x=event.pageX;
       </p>
       <p>
        point.y=event.pageY;
       </p>
       <p>
        console.log(event);
       </p>
       <p>
        }
       </p>
       <p>
        onMounted(()=&gt;{
        <!-- -->
       </p>
       <p>
        console.log('onMounted');
       </p>
       <p>
        document.getElementById('HelloWorld').addEventListener('click',sponk)
       </p>
       <p>
        })
       </p>
       <p>
        onBeforeUnmount(()=&gt;{
        <!-- -->
       </p>
       <p>
        console.log('onBeforeUnmount');
       </p>
       <p>
        document.getElementById('HelloWorld').removeEventListener('click',sponk)
       </p>
       <p>
        })
       </p>
       <p>
        return point;
       </p>
       <p>
        }
       </p>
      </blockquote>
      <blockquote>
       <p>
        <b>
         //使用hooks的组件
         <br/>
        </b>
       </p>
       <p>
        &lt;template&gt;
       </p>
       <p>
        &lt;div class="hello" id="HelloWorld"&gt;
       </p>
       <p>
        x轴位置：{
        <!-- -->
        {valz.x}}&lt;br/&gt;
       </p>
       <p>
        y轴位置：{
        <!-- -->
        {valz.y}}&lt;br/&gt;
       </p>
       <p>
        &lt;/div&gt;
       </p>
       <p>
        &lt;/template&gt;
       </p>
       <p>
        &lt;script&gt;
       </p>
       <p>
        //引入定义的hooks
       </p>
       <p>
        import point from './../hook/commonFirst'
       </p>
       <p>
        export default {
        <!-- -->
       </p>
       <p>
        name: 'HelloWorld',
       </p>
       <p>
        props: {
        <!-- -->
       </p>
       <p>
        msg: String
       </p>
       <p>
        },
       </p>
       <p>
        setup(){
        <!-- -->
       </p>
       <p>
        console.log('---setup---');
       </p>
       <p>
        //触发执行此方法即可
       </p>
       <p>
        let valz=point()
       </p>
       <p>
        return{
        <!-- -->
       </p>
       <p>
        valz
       </p>
       <p>
        }
       </p>
       <p>
        },
       </p>
       <p>
        }
       </p>
       <p>
        &lt;/script&gt;
       </p>
      </blockquote>
      <p>
       <b>
        （2）、 封装发 axios 请求的 hook 函数
       </b>
      </p>
      <p>
       hooks/useRequest.ts
      </p>
      <blockquote>
       <p>
        import { ref } from 'vue'
       </p>
       <p>
        import axios from 'axios'
       </p>
       <p>
        /*
       </p>
       <p>
        使用axios发送异步ajax请求
       </p>
       <p>
        */
       </p>
       <p>
        export default function useUrlLoader&lt;T&gt;(url: string) {
        <!-- -->
       </p>
       <p>
        const result = ref&lt;T | null&gt;(null)
       </p>
       <p>
        const loading = ref(true)
       </p>
       <p>
        const errorMsg = ref(null)
       </p>
       <p>
        axios
       </p>
       <p>
        .get(url)
       </p>
       <p>
        .then(response =&gt; {
        <!-- -->
       </p>
       <p>
        loading.value = false
       </p>
       <p>
        result.value = response.data
       </p>
       <p>
        })
       </p>
       <p>
        .catch(e =&gt; {
        <!-- -->
       </p>
       <p>
        loading.value = false
       </p>
       <p>
        errorMsg.value = e.message || '未知错误'
       </p>
       <p>
        })
       </p>
       <p>
        return {
        <!-- -->
       </p>
       <p>
        loading,
       </p>
       <p>
        result,
       </p>
       <p>
        errorMsg
       </p>
       <p>
        }
       </p>
       <p>
        }
       </p>
      </blockquote>
      <blockquote>
       <p>
        &lt;template&gt;
       </p>
       <p>
        &lt;div class="about"&gt;
       </p>
       <p>
        &lt;h2 v-if="loading"&gt;LOADING...&lt;/h2&gt;
       </p>
       <p>
        &lt;h2 v-else-if="errorMsg"&gt;{
        <!-- -->
        { errorMsg }}&lt;/h2&gt;
       </p>
       <p>
        &lt;!-- &lt;ul v-else&gt;
       </p>
       <p>
        &lt;li&gt;id: {
        <!-- -->
        {result.id}}&lt;/li&gt;
       </p>
       <p>
        &lt;li&gt;name: {
        <!-- -->
        {result.name}}&lt;/li&gt;
       </p>
       <p>
        &lt;li&gt;distance: {
        <!-- -->
        {result.distance}}&lt;/li&gt;
       </p>
       <p>
        &lt;/ul&gt; --&gt;
       </p>
       <p>
        &lt;ul v-for="p in result" :key="p.id"&gt;
       </p>
       <p>
        &lt;li&gt;id: {
        <!-- -->
        { p.id }}&lt;/li&gt;
       </p>
       <p>
        &lt;li&gt;title: {
        <!-- -->
        { p.title }}&lt;/li&gt;
       </p>
       <p>
        &lt;li&gt;price: {
        <!-- -->
        { p.price }}&lt;/li&gt;
       </p>
       <p>
        &lt;/ul&gt;
       </p>
       <p>
        &lt;!-- &lt;img v-if="result" :src="result[0].url" alt=""&gt; --&gt;
       </p>
       <p>
        &lt;/div&gt;
       </p>
       <p>
        &lt;/template&gt;
       </p>
       <p>
        &lt;script lang="ts"&gt;
       </p>
       <p>
        import { watch } from 'vue'
       </p>
       <p>
        import useRequest from './hooks/useRequest'
       </p>
       <p>
        // 地址数据接口
       </p>
       <p>
        interface AddressResult {
        <!-- -->
       </p>
       <p>
        id: number
       </p>
       <p>
        name: string
       </p>
       <p>
        distance: string
       </p>
       <p>
        }
       </p>
       <p>
        // 产品数据接口
       </p>
       <p>
        interface ProductResult {
        <!-- -->
       </p>
       <p>
        id: string
       </p>
       <p>
        title: string
       </p>
       <p>
        price: number
       </p>
       <p>
        }
       </p>
       <p>
        export default {
        <!-- -->
       </p>
       <p>
        setup() {
        <!-- -->
       </p>
       <p>
        // const {loading, result, errorMsg} = useRequest&lt;AddressResult&gt;('/data/address.json')
       </p>
       <p>
        const { loading, result, errorMsg } = useRequest&lt;ProductResult[]&gt;('/data/products.json')
       </p>
       <p>
        watch(result, () =&gt; {
        <!-- -->
       </p>
       <p>
        if (result.value) {
        <!-- -->
       </p>
       <p>
        console.log(result.value.length) // 有提示
       </p>
       <p>
        }
       </p>
       <p>
        })
       </p>
       <p>
        return {
        <!-- -->
       </p>
       <p>
        loading,
       </p>
       <p>
        result,
       </p>
       <p>
        errorMsg
       </p>
       <p>
        }
       </p>
       <p>
        }
       </p>
       <p>
        }
       </p>
       <p>
        &lt;/script&gt;
       </p>
      </blockquote>
      <p>
       其他可以查看
       <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fweixin_47886687%2Farticle%2Fdetails%2F123163295" rel="nofollow noopener noreferrer" target="_blank">
        从0到1学vue3_山竹回家了的博客-CSDN博客_vue3
       </a>
      </p>
      <p>
       <br/>
      </p>
      <h2>
       <b>
        下面写一下vue3、react hooks原理及其区别
       </b>
      </h2>
      <p>
       <b>
        vue3 带来的六大新特性
        <br/>
       </b>
      </p>
      <blockquote>
       <p>
        Performance：性能比vue2.x块1.2～2倍
       </p>
       <p>
        Tree shaking support：支持按需编译，体积更小
       </p>
       <p>
        Composition API：组合API，类似React Hooks
       </p>
       <p>
        Custom Renderer API：暴露了自定义渲染API
       </p>
       <p>
        Fragment，Teleport（Protal），Suspense：新增三个组件
       </p>
       <p>
        Better TypeScript support：更好的支持TS
       </p>
      </blockquote>
      <p>
       <b>
        Performance
       </b>
      </p>
      <blockquote>
       <p>
        Vue3.0在性能方面比Vue2.x快了1.2～2倍。
       </p>
       <p>
        重写虚拟DOM的实现
       </p>
       <p>
        运行时编译
       </p>
       <p>
        静态提升与事件侦听器缓存
       </p>
       <p>
        SSR 速度提高
       </p>
      </blockquote>
      <p>
       <b>
        Three-shaking support
       </b>
      </p>
      <blockquote>
       <p>
        Vue3.x中的核心API都支持tree-shaking，这些API都是通过包引入的方式而不是直接在实例化时就注入，只会对使用到的功能或特性进行打包（按需打包），这意味着更多的功能和更小的体积。
       </p>
      </blockquote>
      <p>
       <b>
        Composition API
       </b>
      </p>
      <blockquote>
       <p>
        Vue2.x中，我们通常采用mixin来复用逻辑代码，使用起来虽然方便，但也存在一些问题：代码来源不清晰、方法属性可能出现冲突。因此，Vue3.x引入了Composition API（组合API），
        <i>
         <b>
          使用纯函数分割复用代码
         </b>
        </i>
        。和React Hooks的概念相似。
       </p>
      </blockquote>
      <p>
       更好的逻辑复用和代码组织
      </p>
      <p>
       更好的类型推导
      </p>
      <p>
       <b>
        Fragment、Teleport、Suspense
       </b>
      </p>
      <p>
       新增三个组件。
      </p>
      <p>
       Fragment
      </p>
      <blockquote>
       <p>
        在书写Vue2.x时，由于组件必须是一个根结点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React 中的Fragment组件是一样的）。
       </p>
      </blockquote>
      <p>
       Teleport
      </p>
      <blockquote>
       <p>
        Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
       </p>
       <p>
        一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。
       </p>
      </blockquote>
      <p>
       Suspense
      </p>
      <blockquote>
       <p>
        同样的，这和React中的Supense是一样的。
       </p>
       <p>
        Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。
       </p>
      </blockquote>
      <p>
       <b>
        Vue3.0 是如何变快的
        <br/>
       </b>
      </p>
      <p>
       <b>
        diff 算法优化
        <br/>
       </b>
      </p>
      <blockquote>
       <p>
        Vue2 中的虚拟dom 是进行全量对比
       </p>
       <p>
        Vue3 新增静态标记，这和react的fiber类似，都是打tag
       </p>
      </blockquote>
      <p>
       <b>
        hoistStatic 静态提升
       </b>
      </p>
      <blockquote>
       <p>
        Vue2 中无论元素是否参与更新，每次都会重新创建，然后在渲染
       </p>
       <p>
        Vue3 中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可
       </p>
      </blockquote>
      <p>
       <b>
        cacheHandlers 事件侦听器缓存
       </b>
      </p>
      <blockquote>
       <p>
        默认情况下默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化，但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可
       </p>
      </blockquote>
      <p>
       <b>
        ssr 渲染
       </b>
      </p>
      <blockquote>
       <p>
        当有大量静态的内容的时候，这些内容会被当作纯字符串推进一个buffer里面，即使存在动态的绑定，会通过模版插值嵌入进去，这样会比通过虚拟dom来渲染的快上很多很多
       </p>
       <p>
        当静态内容大到一定量级的时候，会用_createStaticVNode方法在客户端去生成一个static node。这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。
       </p>
      </blockquote>
      <h2>
       <b>
        vue3底层设计思想：
       </b>
      </h2>
      <blockquote>
       <p>
        <b>
         1.浏览器性能提升
        </b>
       </p>
       <p>
        首先，随着ES6的发展已及广泛使用，浏览器对这些新的特性逐渐增加，性能不断优化，这就给vue3优化提供了一个机会，通过重写来优化提升vue的性能。
       </p>
       <p>
        <b>
         2、底层实现方法
        </b>
       </p>
       <p>
        在框架设计上，vue2.0 是采用Object.defineProperty来实现双向绑定原理，这个属性本身就存在一些不足的地方，比如：
       </p>
       <p>
        1.Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组，push()，pop()，shift()，unshift()，splice()，sort()，reverse()；由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。
       </p>
       <p>
        2.Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择，新增的属性还行通过set方法来添加监听，有一定的局限性。
       </p>
       <p>
        vue3主要采用的Proxy特性，有以下优点：
       </p>
       <p>
        1.可以劫持整个对象，并返回一个新的对象
       </p>
       <p>
        2.有13种劫持操作，但同时Proxy作为ES6的新特性，有一定的兼容问题，最主要的是这个属性无法用polyfill来兼容，这个需要在vue3中需要解决的问题。
       </p>
      </blockquote>
      <h2>
       <b>
        React原理分析：
       </b>
      </h2>
      <blockquote>
       <p>
        <b>
         实现和更新原理
         <br/>
        </b>
       </p>
       <p>
        React将每个节点转化为fiber对象,最终形成一个fiber树结构，来依次渲染。通过两个fiber的对比来实现更新。这里要说到几个diff算法，分别是tree diff,component diff和element diff。同时更新过程可能会被打断，让优先级更高的任务优先执行(例如浏览器渲染)
       </p>
       <p>
        Tree diff
       </p>
       <p>
        新旧两个DOM树，逐层对比的过程；当整个DOM树逐层对比完毕，则所有需要被更新的元素必然能被找到；
       </p>
       <p>
        Component diff
       </p>
       <p>
        在进行Tree Diff的时候，每一层中，组件级别的对比。如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新；如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；
       </p>
       <p>
        Element diff
       </p>
       <p>
        在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，叫做element diff；
       </p>
      </blockquote>
      <p>
       <b>
        <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.cn%2Fpost%2F7005484531054542885" rel="nofollow noopener noreferrer" target="_blank">
         React 原理分析(一) —— React 设计思想 - 掘金 (juejin.cn)
        </a>
        <br/>
       </b>
      </p>
      <p>
       <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.cn%2Fpost%2F7035604734933205000" rel="nofollow noopener noreferrer" target="_blank">
        React 源码分析（二）—— Fiber 的 render 阶段 - 掘金 (juejin.cn)
       </a>
      </p>
      <p>
       <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.cn%2Fpost%2F7044824667164508196" rel="nofollow noopener noreferrer" target="_blank">
        React 原理分析（三）—— Fiber 的commit 阶段 - 掘金 (juejin.cn)
       </a>
      </p>
      <h2>
       <b>
        vue与react的区别：
       </b>
      </h2>
      <p>
       <b>
        1、Vue和React存在着很多的共同点：
       </b>
      </p>
      <blockquote>
       <p>
        数据驱动视图
       </p>
       <p>
        组件化
       </p>
       <p>
        都使用Virtual DOM
       </p>
      </blockquote>
      <p>
       <b>
        2、核心思想不同
       </b>
      </p>
      <blockquote>
       <p>
        vue的主要特点：灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确。
       </p>
       <p>
        Reactt推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助onChange和setState来实现。
       </p>
       <p>
        由于两者核心思想的不同，所以导致Vue和React在后续设计产生了许多的差异。
       </p>
      </blockquote>
      <p>
       <b>
        3、组件写法差异
       </b>
      </p>
      <blockquote>
       <p>
        Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue也支持JSX写法)
       </p>
       <p>
        React推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js
       </p>
       <p>
        这个差异一定程度上也是由于二者核心思想不同而导致的。
       </p>
      </blockquote>
      <p>
       <b>
        4.、响应式原理不同
       </b>
      </p>
      <blockquote>
       <p>
        Vue依赖收集，自动优化，数据可变。Vue递归监听data的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。
       </p>
       <p>
        React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制
       </p>
      </blockquote>
      <p>
       <br/>
      </p>
      <p>
       <br/>
      </p>
      <p>
       <br/>
      </p>
      <p>
       <b>
        vue3.2中的defineProps、defineEmits、defineExpose，方便使用
       </b>
      </p>
      <p>
       <a href="https://www.jianshu.com/p/04ce44cc7ed8" rel="nofollow noopener noreferrer" target="_blank">
        vue3.2中的defineProps、defineEmits、defineExpose - 简书 (jianshu.com)
       </a>
      </p>
     </div>
     <div class="note-meta-time">
      最后编辑于：2025-02-24 21:39:25
     </div>
     <div class="copyright">
      © 
   著作权归作者所有,转载或内容合作请联系作者
     </div>
    </div>
    <br/>
    <img src="https://img-blog.csdnimg.cn/direct/67c64049147741939b85489caefbb597.png" width="800px">
     <br/>
     <p style="font-weight: 700;">
      喜欢的朋友记得点赞、收藏、关注哦！！！
     </p>
    </img>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6361696875617975616e352f:61727469636c652f64657461696c732f313436303737383738" class_="artid" style="display:none">
 </p>
</div>


