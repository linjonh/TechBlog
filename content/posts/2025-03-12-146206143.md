---
layout: post
title: "并查集,find函数的压缩路径,Union函数的小树合并大树"
date: 2025-03-12 15:16:59 +0800
description: "/更新结点个数，每个根节点的数组值为连接的结点个数。printf(\"5的根节点是%d\\n\",find(S,5));printf(\"6的根节点是%d\\n\",find(S,6));printf(\"5的根节点是%d\\n\",find(S,5));printf(\"6的根节点是%d\\n\",find(S,6));//压缩路径，将k到根节点的所有结点都变为根节点的直接后继。//实现\"查\"的操作，查这个元素所属的根节点的下标。//用森林的双亲表示法的思想，表示并查集。//实现\"并\"的操作，小树并到大树里面。"
keywords: "并查集，find函数的压缩路径，Union函数的小树合并大树"
categories: ['未分类']
tags: ['算法', '数据结构']
artid: "146206143"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146206143
    alt: "并查集,find函数的压缩路径,Union函数的小树合并大树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146206143
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146206143
cover: https://bing.ee123.net/img/rand?artid=146206143
image: https://bing.ee123.net/img/rand?artid=146206143
img: https://bing.ee123.net/img/rand?artid=146206143
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     并查集，find函数的压缩路径，Union函数的小树合并大树
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     #include&lt;stdio.h&gt;
     <br/>
     #define maxSize 10
     <br/>
     //用森林的双亲表示法的思想，表示并查集
     <br/>
     int S[maxSize];
     <br/>
     //初始化，将每个元素的前驱下标设置为-1
     <br/>
     void initial(int s[]){
     <!-- -->
     <br/>
     for(int i=0;i&lt;maxSize;i++){
     <!-- -->
     <br/>
     s[i]=-1;
     <br/>
     }
     <br/>
     }
     <br/>
     //实现"查"的操作，查这个元素所属的根节点的下标
     <br/>
     int  find(int s[],int k){
     <!-- -->
     <br/>
     int root=k;
     <br/>
     while(s[root]&gt;=0) root=s[root];//找到根节点
     <br/>
     //压缩路径，将k到根节点的所有结点都变为根节点的直接后继
     <br/>
     while(k!=root){
     <!-- -->
     <br/>
     int t=s[k];//指向k的父节点
     <br/>
     s[k]=root;
     <br/>
     k=t;
     <br/>
     }
     <br/>
     return root;
     <br/>
     }
    </p>
    <p>
     //实现"并"的操作，小树并到大树里面
     <br/>
     void Union(int s[],int root1,int root2){
     <!-- -->
     <br/>
     if(root1==root2){
     <!-- -->
     <br/>
     return;
     <br/>
     }
     <br/>
     //确保root1和root2是根节点
     <br/>
     if(s[root1]&gt;=0){
     <!-- -->
     <br/>
     root1=find(s,root1);
     <br/>
     }
     <br/>
     if(s[root2]&gt;=0){
     <!-- -->
     <br/>
     root2=find(s,root2);
     <br/>
     }
     <br/>
     //小树合并到大树里面
     <br/>
     if(s[root1]&gt;s[root2]){
     <!-- -->
     <br/>
     s[root2]+=s[root1];//更新结点个数，每个根节点的数组值为连接的结点个数
     <br/>
     s[root1]=root2;//合并
     <br/>
     }else{
     <!-- -->
     <br/>
     s[root1]+=s[root2];
     <br/>
     s[root2]=root1;
     <br/>
     }
     <br/>
     <br/>
     }
     <br/>
     int main(){
     <!-- -->
     <br/>
     //自己的测试数据
     <br/>
     S[0]=-1;S[1]=0;S[2]=-1;S[3]=-1;S[4]=1;S[5]=1;S[6]=2;S[7]=3;S[8]=3;S[9]=3;S[10]=4;
     <br/>
     printf("5的根节点是%d\n",find(S,5));
     <br/>
     printf("6的根节点是%d\n",find(S,6));
     <br/>
     //合并
     <br/>
     Union(S,0,2);
     <br/>
     printf("5的根节点是%d\n",find(S,5));
     <br/>
     printf("6的根节点是%d\n",find(S,6));
     <br/>
     <br/>
     return 0;
     <br/>
     }
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343231393831352f:61727469636c652f64657461696c732f313436323036313433" class_="artid" style="display:none">
 </p>
</div>


