---
layout: post
title: "docker实践与应用举例"
date: 2025-03-13 13:14:37 +0800
description: "在当今快速迭代的软件开发和部署环境中，容器化技术成为了提升效率、保障一致性的关键手段。Docker作为容器化技术的佼佼者，以其轻量级、可移植性和高效性，彻底改变了应用程序的开发、交付和运行方式。Docker是一个基于Go语言开发的开源应用容器引擎，它遵循Apache 2.0协议。Docker容器技术允许开发者将应用及其依赖项打包到一个轻量级的、可移植的容器中，并在任何安装了Docker的环境中快速部署运行。"
keywords: "docker实践与应用举例"
categories: ['运维']
tags: ['运维', '容器', 'Docker']
artid: "146228337"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146228337
    alt: "docker实践与应用举例"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146228337
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146228337
cover: https://bing.ee123.net/img/rand?artid=146228337
image: https://bing.ee123.net/img/rand?artid=146228337
img: https://bing.ee123.net/img/rand?artid=146228337
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     docker实践与应用举例
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     一、介绍
    </h3>
    <p>
     在当今快速迭代的软件开发和部署环境中，容器化技术成为了提升效率、保障一致性的关键手段。Docker作为容器化技术的佼佼者，以其
     <em>
      轻量级、可移植性和高效性
     </em>
     ，彻底改变了应用程序的开发、交付和运行方式。
    </p>
    <h3>
     <a id="Docker_4">
     </a>
     二、Docker概述
    </h3>
    <p>
     Docker是一个
     <strong>
      基于Go语言开发的开源应用容器引擎
     </strong>
     ，它遵循Apache 2.0协议。Docker容器技术允许开发者将
     <em>
      <strong>
       应用及其依赖项打包到一个轻量级的、可移植的容器中
      </strong>
     </em>
     ，并在任何安装了Docker的环境中快速部署运行。Docker的主要组件包括Docker客户端（用户与Docker交互的主要接口）、Docker守护进程（负责管理和运行容器，处理容器的生命周期，管理镜像、网络、存储等）、Docker镜像（一个只读的文件系统快照，包含了应用程序运行所需的文件、库和依赖项）、Docker容器（基于Docker镜像创建的运行实例，提供了一个
     <strong>
      隔离的环境
     </strong>
     ，包括文件系统、进程空间和网络）以及Docker仓库（用于存储和分享Docker镜像，Docker Hub是一个公共的Docker仓库）。
    </p>
    <h3>
     <a id="Docker_8">
     </a>
     三、Docker实践与应用实例
    </h3>
    <h4>
     <a id="1_Python_10">
     </a>
     1. 创建并运行Python开发环境
    </h4>
    <p>
     <strong>
      背景
     </strong>
     ：在软件开发过程中，设置和配置开发环境是一项耗时且容易出错的任务。特别是对于复杂的项目，开发环境可能包含大量的依赖和配置。Docker可以通过提供一致的开发环境来解决这个问题。
    </p>
    <p>
     <strong>
      实现步骤
     </strong>
     ：
    </p>
    <p>
     （1）编写Dockerfile
    </p>
    <pre><code class="prism language-Dockerfile"># 使用Python官方镜像作为基础镜像
FROM python:3.9-slim

# 设置工作目录
WORKDIR /app

# 复制依赖文件并安装
COPY requirements.txt .
RUN pip install -r requirements.txt

# 复制应用程序代码
COPY . .

# 启动应用程序
CMD ["python", "app.py"]
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       FROM python:3.9-slim
      </code>
      ：使用Python 3.9的官方镜像作为基础镜像，并选择了slim版本以减小镜像体积。
     </li>
     <li>
      <code>
       WORKDIR /app
      </code>
      ：设置工作目录为
      <code>
       /app
      </code>
      。
     </li>
     <li>
      <code>
       COPY requirements.txt .
      </code>
      ：将本地的
      <code>
       requirements.txt
      </code>
      文件复制到容器的当前目录下。
     </li>
     <li>
      <code>
       RUN pip install -r requirements.txt
      </code>
      ：安装
      <code>
       requirements.txt
      </code>
      文件中列出的所有依赖项。
     </li>
     <li>
      <code>
       COPY . .
      </code>
      ：将本地的应用程序代码复制到容器的当前目录下。
     </li>
     <li>
      <code>
       CMD ["python", "app.py"]
      </code>
      ：设置容器启动时执行的命令为运行
      <code>
       app.py
      </code>
      。
     </li>
    </ul>
    <p>
     （2）构建Docker镜像
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> my-python-app <span class="token builtin class-name">.</span>
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       -t my-python-app
      </code>
      ：为构建的镜像指定名称为
      <code>
       my-python-app
      </code>
      。
     </li>
     <li>
      <code>
       .
      </code>
      ：表示Dockerfile在当前目录下。
     </li>
    </ul>
    <p>
     （3）运行Docker容器
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/app my-python-app
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       -it
      </code>
      ：以交互模式运行容器，并分配一个伪终端。
     </li>
     <li>
      <code>
       --rm
      </code>
      ：容器停止后自动删除容器。
     </li>
     <li>
      <code>
       -v $(pwd):/app
      </code>
      ：将当前目录挂载到容器的
      <code>
       /app
      </code>
      目录下，这样可以在容器内直接修改代码并实时反映到宿主机上。
     </li>
    </ul>
    <p>
     <strong>
      效果
     </strong>
     ：通过这种方式，开发人员可以在统一的Python环境中工作，无需担心不同系统之间的兼容性问题。即使切换开发机器或系统，也能保持一致的依赖和配置。
    </p>
    <h4>
     <a id="2_Docker_Compose_70">
     </a>
     2. 使用Docker Compose编排多容器应用
    </h4>
    <p>
     <strong>
      背景
     </strong>
     ：在实际项目中，应用通常依赖多个服务，如数据库、缓存等。Docker Compose是一个工具，用于定义和运行多容器Docker应用程序。通过一个YAML文件来配置应用的服务，可以使用一个命令创建并启动所有服务。
    </p>
    <p>
     <strong>
      实现步骤
     </strong>
     ：
    </p>
    <p>
     （1）编写
     <code>
      docker-compose.yml
     </code>
     文件
    </p>
    <pre><code class="prism language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3000:3000"</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db
  <span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">POSTGRES_USER</span><span class="token punctuation">:</span> example
      <span class="token key atrule">POSTGRES_PASSWORD</span><span class="token punctuation">:</span> example
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       version: '3'
      </code>
      ：指定Docker Compose文件的版本。
     </li>
     <li>
      <code>
       services
      </code>
      ：定义服务列表。
     </li>
     <li>
      <code>
       web
      </code>
      ：定义Web服务。
      <ul>
       <li>
        <code>
         build: .
        </code>
        ：使用当前目录下的Dockerfile构建镜像。
       </li>
       <li>
        <code>
         ports
        </code>
        ：将容器的3000端口映射到宿主机的3000端口。
       </li>
       <li>
        <code>
         depends_on
        </code>
        ：指定Web服务依赖于db服务。
       </li>
      </ul>
     </li>
     <li>
      <code>
       db
      </code>
      ：定义数据库服务。
      <ul>
       <li>
        <code>
         image: postgres
        </code>
        ：使用官方的PostgreSQL镜像。
       </li>
       <li>
        <code>
         environment
        </code>
        ：设置环境变量，用于配置数据库用户和密码。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     （2）构建并运行多容器应用
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       -d
      </code>
      ：以后台模式运行容器。
     </li>
    </ul>
    <p>
     <strong>
      效果
     </strong>
     ：通过这种方式，可以轻松地启动多个相互依赖的服务，并管理它们的生命周期。Docker Compose非常适合用于开发和测试环境，可以模拟真实环境下的服务交互。
    </p>
    <h4>
     <a id="3_CICDDocker_118">
     </a>
     3. 在CI/CD流程中使用Docker
    </h4>
    <p>
     <strong>
      背景
     </strong>
     ：在持续集成和持续交付（CI/CD）流程中，需要确保代码从开发到发布的流程自动化。Docker可以用来创建一致的构建环境和测试环境，确保代码在不同阶段使用相同的应用环境。
    </p>
    <p>
     <strong>
      实现步骤
     </strong>
     ：
    </p>
    <p>
     （1）编写Dockerfile
    </p>
    <pre><code class="prism language-Dockerfile"># 使用官方的Node.js镜像作为基础镜像
FROM node:14

# 设置工作目录
WORKDIR /usr/src/app

# 复制package.json和package-lock.json到容器中
COPY package*.json ./

# 安装应用依赖
RUN npm install

# 复制应用代码到容器中
COPY . .

# 暴露端口
EXPOSE 3000

# 定义启动命令
CMD ["node", "app.js"]
</code></pre>
    <p>
     （2）在CI/CD平台上编写脚本
    </p>
    <p>
     以Jenkins为例，可以在Jenkinsfile中定义流水线：
    </p>
    <pre><code class="prism language-groovy">pipeline <span class="token punctuation">{<!-- --></span>
    agent <span class="token punctuation">{<!-- --></span>
        docker <span class="token punctuation">{<!-- --></span>
            image <span class="token string">'node:14'</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    stages <span class="token punctuation">{<!-- --></span>
        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Install Dependencies'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            steps <span class="token punctuation">{<!-- --></span>
                sh <span class="token string">'npm install'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Run Tests'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            steps <span class="token punctuation">{<!-- --></span>
                sh <span class="token string">'npm test'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Build Docker Image'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            steps <span class="token punctuation">{<!-- --></span>
                script <span class="token punctuation">{<!-- --></span>
                    docker<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">"my-app:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">env<span class="token punctuation">.</span>BUILD_ID</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Push Docker Image'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            steps <span class="token punctuation">{<!-- --></span>
                script <span class="token punctuation">{<!-- --></span>
                    docker<span class="token punctuation">.</span><span class="token function">withRegistry</span><span class="token punctuation">(</span><span class="token string">'https://registry.hub.docker.com'</span><span class="token punctuation">,</span> <span class="token string">'docker-credentials-id'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        dockerImage<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">stage</span><span class="token punctuation">(</span><span class="token string">'Deploy'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            steps <span class="token punctuation">{<!-- --></span>
                sh <span class="token string">'kubectl set image deployment/my-app-deployment my-app=my-app:${env.BUILD_ID}'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       agent { docker { image 'node:14' } }
      </code>
      ：指定流水线运行在Node.js 14的Docker容器中。
     </li>
     <li>
      <code>
       stage('Install Dependencies')
      </code>
      ：安装应用依赖。
     </li>
     <li>
      <code>
       stage('Run Tests')
      </code>
      ：运行测试。
     </li>
     <li>
      <code>
       stage('Build Docker Image')
      </code>
      ：构建Docker镜像。
     </li>
     <li>
      <code>
       stage('Push Docker Image')
      </code>
      ：将Docker镜像推送到Docker Hub。
     </li>
     <li>
      <code>
       stage('Deploy')
      </code>
      ：使用kubectl命令更新Kubernetes部署，以使用新的镜像版本。
     </li>
    </ul>
    <p>
     <strong>
      效果
     </strong>
     ：通过这种方式，可以确保代码从开发到发布的流程自动化，减少人为错误，提高开发和运维的效率。
    </p>
    <h4>
     <a id="4_DockerNginx_207">
     </a>
     4. 使用Docker部署Nginx服务器
    </h4>
    <p>
     <strong>
      背景
     </strong>
     ：Nginx是一个高性能的HTTP和反向代理服务器，常用于静态文件服务、负载均衡等场景。Docker可以快速部署Nginx服务器，并方便地进行配置和管理。
    </p>
    <p>
     <strong>
      实现步骤
     </strong>
     ：
    </p>
    <p>
     （1）编写Dockerfile
    </p>
    <pre><code class="prism language-Dockerfile"># 使用官方的Nginx镜像作为基础镜像
FROM nginx:alpine

# 将静态文件复制到Nginx目录
COPY ./static-html-directory /usr/share/nginx/html

# 暴露端口
EXPOSE 80
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       FROM nginx:alpine
      </code>
      ：使用官方的Nginx镜像，并选择了alpine版本以减小镜像体积。
     </li>
     <li>
      <code>
       COPY ./static-html-directory /usr/share/nginx/html
      </code>
      ：将本地的静态文件目录复制到容器的Nginx默认目录。
     </li>
     <li>
      <code>
       EXPOSE 80
      </code>
      ：暴露80端口，用于HTTP服务。
     </li>
    </ul>
    <p>
     （2）构建Docker镜像
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> my-nginx <span class="token builtin class-name">.</span>
</code></pre>
    <p>
     （3）运行Docker容器
    </p>
    <pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 my-nginx
</code></pre>
    <p>
     解释：
    </p>
    <ul>
     <li>
      <code>
       -d
      </code>
      ：以后台模式运行容器。
     </li>
     <li>
      <code>
       -p 8080:80
      </code>
      ：将容器的80端口映射到宿主机的8080端口。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34313235363533352f:61727469636c652f64657461696c732f313436323238333337" class_="artid" style="display:none">
 </p>
</div>


