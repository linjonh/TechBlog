---
layout: post
title: "JVM-解释器和即时编译器有什么区别"
date: 2025-03-12 14:07:44 +0800
description: "JVM 解释器和即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中执行 Java 字节码的两种核心机制，它们在执行方式、性能特点和应用场景上存在显著差异。例如，在性能调优时，可以关注 JIT 编译器的优化效果，分析热点代码，并采取相应的措施来提升性能。HotSpot VM (最常用的 JVM 实现) 默认采用。"
keywords: "JVM 解释器和即时编译器有什么区别？"
categories: ['Jvm']
tags: ['Jvm']
artid: "146153664"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146153664
    alt: "JVM-解释器和即时编译器有什么区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146153664
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146153664
cover: https://bing.ee123.net/img/rand?artid=146153664
image: https://bing.ee123.net/img/rand?artid=146153664
img: https://bing.ee123.net/img/rand?artid=146153664
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM 解释器和即时编译器有什么区别？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     JVM 解释器和即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中执行 Java 字节码的两种核心机制，它们在执行方式、性能特点和应用场景上存在显著差异。
    </p>
    <p>
     <strong>
      简单来说：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       解释器 (Interpreter):
      </strong>
      就像一个
      <strong>
       逐行翻译官
      </strong>
      ，它读取 Java 字节码指令，然后逐条解释并执行。
      <strong>
       速度慢，启动快。
      </strong>
     </li>
     <li>
      <strong>
       即时编译器 (JIT Compiler):
      </strong>
      就像一个
      <strong>
       预先翻译重要段落的高级翻译官
      </strong>
      ，它将
      <strong>
       热点代码 (经常执行的代码)
      </strong>
      编译成本地机器码，直接由 CPU 执行。
      <strong>
       速度快，但启动有延迟。
      </strong>
     </li>
    </ul>
    <p>
     <strong>
      以下是详细的对比和区别：
     </strong>
    </p>
    <p>
     <strong>
      1. 执行方式:
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        解释器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         逐条解释执行:
        </strong>
        读取一条字节码指令，解释器将其翻译成机器码，然后立即执行。重复这个过程，一条指令一条指令地执行整个程序。
       </li>
       <li>
        <strong>
         不进行代码优化:
        </strong>
        解释器主要关注指令的直接翻译和执行，通常不进行复杂的代码优化。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        JIT 编译器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         编译后执行:
        </strong>
        监控程序运行，识别出
        <strong>
         热点代码 (Hotspot)
        </strong>
        ，例如被频繁调用的方法、循环体等。
       </li>
       <li>
        <strong>
         将热点代码编译成本地机器码:
        </strong>
        JIT 编译器会将这些热点代码编译成针对特定硬件平台的本地机器码，并缓存起来。
       </li>
       <li>
        <strong>
         优化代码:
        </strong>
        JIT 编译器在编译过程中会进行各种代码优化，例如内联、循环展开、逃逸分析等，以提高执行效率。
       </li>
       <li>
        <strong>
         后续直接执行本地机器码:
        </strong>
        当程序再次执行到这些热点代码时，JVM 会直接执行已经编译好的本地机器码，而不是再次解释执行字节码。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      2. 性能特点:
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        解释器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         启动速度快:
        </strong>
        因为不需要编译，可以直接开始解释执行，所以程序启动速度很快。
       </li>
       <li>
        <strong>
         执行速度慢:
        </strong>
        由于逐条解释，每次执行都需要翻译，性能较低，尤其对于循环和频繁调用的代码。
       </li>
       <li>
        <strong>
         峰值性能低:
        </strong>
        即使程序长时间运行，性能提升也有限，因为始终是解释执行。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        JIT 编译器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         启动速度相对较慢:
        </strong>
        需要一定的预热时间，因为 JIT 编译器需要在程序运行一段时间后才能识别热点代码并进行编译。
       </li>
       <li>
        <strong>
         执行速度快 (编译后):
        </strong>
        一旦热点代码被编译成机器码，执行速度会大幅提升，接近甚至超过 C/C++ 等编译型语言。
       </li>
       <li>
        <strong>
         峰值性能高:
        </strong>
        随着程序运行时间增加，JIT 编译器会不断优化热点代码，程序的峰值性能会持续提升。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      3. 内存占用:
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        解释器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         内存占用相对较低:
        </strong>
        不需要存储编译后的机器码，内存占用相对较小。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        JIT 编译器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         内存占用相对较高:
        </strong>
        需要存储编译后的机器码，以及 JIT 编译器本身运行所需的内存，内存占用相对较大。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      4. 应用场景:
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        解释器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         程序启动阶段:
        </strong>
        在程序启动初期，JIT 编译器尚未发挥作用，解释器负责快速启动程序。
       </li>
       <li>
        <strong>
         非热点代码:
        </strong>
        对于执行频率不高、非关键的代码，解释器执行效率也足够。
       </li>
       <li>
        <strong>
         对启动速度敏感的场景:
        </strong>
        例如一些命令行工具、脚本等，可能更注重快速启动。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        JIT 编译器:
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         长时间运行的应用程序:
        </strong>
        例如服务器端应用、大型桌面应用等，JIT 编译器可以充分发挥性能优势，提高程序运行效率。
       </li>
       <li>
        <strong>
         对性能要求高的场景:
        </strong>
        例如游戏、科学计算等，JIT 编译器可以显著提升性能。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      5. HotSpot VM 的混合模式:
     </strong>
    </p>
    <p>
     HotSpot VM (最常用的 JVM 实现) 默认采用
     <strong>
      混合模式 (Mixed Mode)
     </strong>
     ，即
     <strong>
      解释器和 JIT 编译器协同工作
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       程序启动初期:
      </strong>
      先使用解释器快速启动程序。
     </li>
     <li>
      <strong>
       程序运行一段时间后:
      </strong>
      JIT 编译器开始工作，识别并编译热点代码。
     </li>
     <li>
      <strong>
       对于热点代码:
      </strong>
      执行编译后的机器码，提高性能。
     </li>
     <li>
      <strong>
       对于非热点代码:
      </strong>
      仍然使用解释器执行。
     </li>
    </ul>
    <p>
     这种混合模式结合了解释器和 JIT 编译器的优点：
     <strong>
      既保证了快速启动，又能在程序长时间运行时提供高吞吐量和高性能。
     </strong>
    </p>
    <p>
     <strong>
      总结:
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        解释器 (Interpreter)
       </th>
       <th>
        即时编译器 (JIT Compiler)
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        执行方式
       </td>
       <td>
        逐条解释执行
       </td>
       <td>
        编译后执行
       </td>
      </tr>
      <tr>
       <td>
        启动速度
       </td>
       <td>
        快
       </td>
       <td>
        相对慢
       </td>
      </tr>
      <tr>
       <td>
        执行速度
       </td>
       <td>
        慢
       </td>
       <td>
        快 (编译后)
       </td>
      </tr>
      <tr>
       <td>
        峰值性能
       </td>
       <td>
        低
       </td>
       <td>
        高
       </td>
      </tr>
      <tr>
       <td>
        代码优化
       </td>
       <td>
        无/少
       </td>
       <td>
        有/多
       </td>
      </tr>
      <tr>
       <td>
        内存占用
       </td>
       <td>
        低
       </td>
       <td>
        高
       </td>
      </tr>
      <tr>
       <td>
        适用场景
       </td>
       <td>
        启动阶段、非热点代码
       </td>
       <td>
        长时间运行、热点代码
       </td>
      </tr>
     </tbody>
    </table>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6e6d736f66746b6c622f:61727469636c652f64657461696c732f313436313533363634" class_="artid" style="display:none">
 </p>
</div>


