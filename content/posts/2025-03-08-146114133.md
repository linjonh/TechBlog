---
layout: post
title: "系统架构设计师数据库基础篇数据库优化技术"
date: 2025-03-08 12:23:35 +0800
description: "Redis用作缓存组件时，其基于内存的读写特性，比基于磁盘读写的数据库性能要高很多，适合缓存高频热点的数据，来提高读性能。采取了相同的过期时间，例如在同一时刻设置了大量的key，但过期时间都是5分钟。缺点：如果这些过期的key没有被访问，那么就一直无法被删除，一直占用内存。通过角色分担的策略，分别提升读写性能，有效减少数据并发操作的延迟。主从复制，建立一个和主数据库完全一样的数据库环境，称为从数据库。查询key时，才对key进行检测，如果已经达到过期时间，则删除。访问的key在redis中不存在。"
keywords: "系统架构设计师—数据库基础篇—数据库优化技术"
categories: ['系统架构设计师']
tags: ['系统架构', '数据库', '优化技术']
artid: "146114133"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146114133
    alt: "系统架构设计师数据库基础篇数据库优化技术"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146114133
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146114133
cover: https://bing.ee123.net/img/rand?artid=146114133
image: https://bing.ee123.net/img/rand?artid=146114133
img: https://bing.ee123.net/img/rand?artid=146114133
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     系统架构设计师—数据库基础篇—数据库优化技术
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     集中式数据库
    </h2>
    <h3>
     <a id="_2">
     </a>
     反规范化设计
    </h3>
    <p>
     优点：
    </p>
    <ul>
     <li>
      避免进行表之间的连接操作，可以提高数据操作的性能。
     </li>
    </ul>
    <p>
     缺点：
    </p>
    <ul>
     <li>
      数据的重复存储，浪费磁盘空间。
     </li>
     <li>
      会产生数据不一致性问题。
     </li>
    </ul>
    <h4>
     <a id="_11">
     </a>
     分类
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
       <th>
        作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        增加冗余列
       </td>
       <td>
        指在多个表中具有相同的列。
       </td>
       <td>
        在查询时避免连接操作。
       </td>
      </tr>
      <tr>
       <td>
        增加派生列
       </td>
       <td>
        增加的列可用通过表中其他数据计算生成。
       </td>
       <td>
        在查询时减少计算量，从而加快查询速度。
       </td>
      </tr>
      <tr>
       <td>
        重新组表
       </td>
       <td>
        如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。
       </td>
       <td>
        在查询时减少连接，从而加快查询速度。
       </td>
      </tr>
      <tr>
       <td>
        水平分割表
       </td>
       <td>
        按记录进行分割，把数据放到多个独立的表中。
       </td>
       <td>
        主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上使用的场景。
       </td>
      </tr>
      <tr>
       <td>
        垂直分割表
       </td>
       <td>
        对表进行分割，将主键与部分列放到一个表中，主键与其他列放到另一个表中。
       </td>
       <td>
        在查询时减少I/O次数，以提高查询效率。
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_21">
     </a>
     保证数据的一致性方法
    </h4>
    <ol>
     <li>
      触发器
     </li>
     <li>
      事务机制保证（适用于单体数据库中）
     </li>
     <li>
      应用保证（适用于异构数据库之间）
     </li>
     <li>
      批处理脚本（）
     </li>
    </ol>
    <h2>
     <a id="_27">
     </a>
     分布式数据库
    </h2>
    <h3>
     <a id="_28">
     </a>
     主从复制
    </h3>
    <p>
     主从复制，建立一个和主数据库完全一样的数据库环境，称为从数据库。
    </p>
    <ul>
     <li>
      做数据的热备：作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
     </li>
     <li>
      架构的扩展：业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个及其的I/O性能。
     </li>
     <li>
      读写分离：使数据库能支持更大的并发。
     </li>
    </ul>
    <h4>
     <a id="_34">
     </a>
     基本过程
    </h4>
    <p>
     主从数据库之间通过 binary log（二进制日志，一般称 binlog）进行数据的同步。
     <br/>
     <img alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=en-resource%3A%2F%2Fdatabase%2F1942%3A1&amp;pos_id=img-C1QOSTcD-1741407807339"/>
    </p>
    <h5>
     <a id="binlog_37">
     </a>
     binlog的同步模式
    </h5>
    <table>
     <thead>
      <tr>
       <th>
       </th>
       <th>
        基于SQL语句的复制
       </th>
       <th>
        基于行的复制
       </th>
       <th>
        混合复制
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        基本流程
       </td>
       <td>
        每一条写语句都会记录在binlog中，进而同步到从库的relaylog中，被从库的SQL线程取出来，回放执行。
       </td>
       <td>
        不记录SQL语句，只记录了哪个记录更新前和更新后的数据。
       </td>
       <td>
        对于有绑定本地特性、评估可能造成主从不一致的SQL语句，则自动选用ROW；其他的选则STATEMENT。
       </td>
      </tr>
      <tr>
       <td>
        优点
       </td>
       <td>
        binlog的日志量比较少。
       </td>
       <td>
        可以保证主从之间数据绝对相同。
       </td>
       <td>
        binlog的日志量尽可能少，主从之间数据尽可能相同。
       </td>
      </tr>
      <tr>
       <td>
        缺点
       </td>
       <td>
        同步的SQL语句如果含有绑定本地变量的函数、关键字时，可能造成主从不一致的情况。如：时区。
       </td>
       <td>
        单条SQL批量更新数据的情况，会产生大量日志。
       </td>
       <td>
        受限于评估算法，如未快速支持某种新特性，可能产生主从数据不一致的问题。
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     <a id="MySQL_44">
     </a>
     MySQL的同步模式
    </h5>
    <table>
     <thead>
      <tr>
       <th>
       </th>
       <th>
       </th>
       <th>
        一致性
       </th>
       <th>
        可用性
       </th>
       <th>
        典型框架/系统
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        全同步复制技术
       </td>
       <td>
        主库等待所有从库都同步完毕，才返回客户端。
       </td>
       <td>
        强
       </td>
       <td>
        弱
       </td>
       <td>
        MySQL
       </td>
      </tr>
      <tr>
       <td>
        半同步复制技术
       </td>
       <td>
        主课等待至少一个从库同步完毕，则返回客户端
       </td>
       <td>
        较强
       </td>
       <td>
        较弱
       </td>
       <td>
        MySQL、Zookeeper、Redis、Oracle
       </td>
      </tr>
      <tr>
       <td>
        异步复制技术
       </td>
       <td>
        主库不等待从库同步，执行完客户端提交的事务后就返回客户端。
       </td>
       <td>
        弱
       </td>
       <td>
        强
       </td>
       <td>
        MySQL、Redis、Oracle
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_52">
     </a>
     读写分离
    </h3>
    <p>
     读写分离，设置不同的主/从数据库分别负责不同的操作。
    </p>
    <ul>
     <li>
      主数据库负责数据的写操作。
     </li>
     <li>
      从数据库负责数据的读操作。
     </li>
    </ul>
    <p>
     通过角色分担的策略，分别提升读写性能，有效减少数据并发操作的延迟。
    </p>
    <h3>
     <a id="_59">
     </a>
     分表
    </h3>
    <p>
     分表，也叫分片，解决并发能力、I/O性能提升。
     <br/>
     将一张大表分成若干小表，业务同时访问多个表。
     <br/>
     分表是重
     <strong>
      在单个实例
     </strong>
     内部，一张表拆分称多个表。
    </p>
    <ul>
     <li>
      垂直切分
     </li>
     <li>
      水平切分
     </li>
    </ul>
    <h3>
     <a id="_67">
     </a>
     分库
    </h3>
    <p>
     分库，将原本存放在一个实例上众多分类的数据(表)，分开存放到
     <strong>
      不同的实例
     </strong>
     上。有利于差异化管理。
    </p>
    <h2>
     <a id="Redis_72">
     </a>
     分布式缓存技术-Redis
    </h2>
    <p>
     Redis用作缓存组件时，其基于内存的读写特性，比基于磁盘读写的数据库性能要高很多，适合缓存高频热点的数据，来提高读性能。这样可以降低厎数据库服务器的查询请求，提高系统性能。
    </p>
    <h3>
     <a id="_75">
     </a>
     数据类型
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
       <th>
        适用场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        string
       </td>
       <td>
        基本类型。
       </td>
       <td>
        可用于缓存层或计数器，如视频播放量、文章浏览量等。
       </td>
      </tr>
      <tr>
       <td>
        hash
       </td>
       <td>
        代替string类型，节省空间。
       </td>
       <td>
        描述用户信息较为方便
       </td>
      </tr>
      <tr>
       <td>
        set
       </td>
       <td>
        无序集合，每个值不能重复。
       </td>
       <td>
        可用于去重、抽奖、初始化用户池等。
       </td>
      </tr>
      <tr>
       <td>
        zset
       </td>
       <td>
        有序集合，每个元素有一个分数。
       </td>
       <td>
        如首页推荐10个最热门的帖子。
       </td>
      </tr>
      <tr>
       <td>
        list
       </td>
       <td>
        双向链表结构，可以模拟栈、队列等形式。
       </td>
       <td>
        可用于回复评论、点赞。
       </td>
      </tr>
      <tr>
       <td>
        pub/sub
       </td>
       <td>
        发布/订阅
       </td>
       <td>
        可以用作消息队列,生产者将消息投送给某个key为主题的队列,消费者监听并得到消息的推送.
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_86">
     </a>
     读写数据的基本步骤
    </h3>
    <h4>
     <a id="_87">
     </a>
     读数据
    </h4>
    <ol>
     <li>
      根据key读缓存。
     </li>
     <li>
      读取成功则直接返回。
     </li>
     <li>
      若key不在缓存中时，根据key读数据库。
     </li>
     <li>
      读取成功后写缓存。
     </li>
     <li>
      成功返回。
     </li>
    </ol>
    <h4>
     <a id="_94">
     </a>
     写数据
    </h4>
    <ol>
     <li>
      根据key写数据库。
     </li>
     <li>
      成功后更新缓存key值。
     </li>
     <li>
      成功返回。
     </li>
    </ol>
    <h3>
     <a id="_99">
     </a>
     过期策略
    </h3>
    <h4>
     <a id="_100">
     </a>
     惰性删除
    </h4>
    <p>
     查询key时，才对key进行检测，如果已经达到过期时间，则删除。
     <br/>
     缺点：如果这些过期的key没有被访问，那么就一直无法被删除，一直占用内存。
    </p>
    <h4>
     <a id="_103">
     </a>
     定期删除
    </h4>
    <p>
     redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所有redis会每次随机取一些key去做检查和删除。
    </p>
    <h4>
     <a id="_106">
     </a>
     内存淘汰机制
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        淘汰机制
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        volatile-lru
       </td>
       <td>
        从已设置过期时间的key中，移出最近最少使用的key进行淘汰。
       </td>
      </tr>
      <tr>
       <td>
        volatile-lfu
       </td>
       <td>
        从已设置过期时间的key中，移出最不经常使用的进行淘汰。
       </td>
      </tr>
      <tr>
       <td>
        volatile-random
       </td>
       <td>
        从已设置过期时间的key中随机选择key淘汰。
       </td>
      </tr>
      <tr>
       <td>
        volatile-ttl
       </td>
       <td>
        从已设置过期时间的key中，移出将要过期的key。
       </td>
      </tr>
      <tr>
       <td>
        allkeys-lru
       </td>
       <td>
        从所有key中选择最近最少使用的进行淘汰。
       </td>
      </tr>
      <tr>
       <td>
        allkeys-lfu
       </td>
       <td>
        从所有key中选择最不经常使用的进行淘汰。
       </td>
      </tr>
      <tr>
       <td>
        allkeys-random
       </td>
       <td>
        从所有key中随机选择key进行淘汰。
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_118">
     </a>
     持久化
    </h3>
    <table>
     <thead>
      <tr>
       <th>
       </th>
       <th>
        RDB内存快照(RedisDataBase)
       </th>
       <th>
        AOF日志(Append Only File)
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        说明
       </td>
       <td>
        把当前内存中的数据集快照写入磁盘(数据库中所有键值对数据)。恢复时，是将快照文件直接读取到内存里。
       </td>
       <td>
        通过持续不断地保存Redis服务器所执行的更新命令来记录数据库状态，类似mysql的binlog。恢复数据时，需要从头开始回放更新命令。
       </td>
      </tr>
      <tr>
       <td>
        磁盘刷新频率
       </td>
       <td>
        低
       </td>
       <td>
        高
       </td>
      </tr>
      <tr>
       <td>
        文件大小
       </td>
       <td>
        小
       </td>
       <td>
        大
       </td>
      </tr>
      <tr>
       <td>
        数据恢复效率
       </td>
       <td>
        高
       </td>
       <td>
        低
       </td>
      </tr>
      <tr>
       <td>
        数据安全
       </td>
       <td>
        低
       </td>
       <td>
        高
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_128">
     </a>
     缓存异常问题
    </h3>
    <h4>
     <a id="_129">
     </a>
     缓存穿透
    </h4>
    <p>
     访问的key在redis中不存在。
    </p>
    <p>
     原因：
    </p>
    <ol>
     <li>
      恶意攻击，造成大量访问Redis中不存在的key。
     </li>
     <li>
      大量请求访问数据库里有但redis没有的key。
     </li>
    </ol>
    <p>
     解决方案：
    </p>
    <ul>
     <li>
      针对来源是比较少的请求来源ip，主动限制访问次数，或者拉入黑名单。
     </li>
     <li>
      应用程序检查key的合法性，提前拒绝不合法的请求。
     </li>
     <li>
      使用布隆过滤器。
     </li>
     <li>
      预热redis，运行一个批处理脚本，将可能会大量访问的数据预先加载到redis，业务再开张。
     </li>
     <li>
      在最前端进行流量控制，逐步释放进来的请求。给出一段时间，让redis逐步加载热数据。
     </li>
     <li>
      如果数据库里也没有的key，也要在redis中设置key，使其值为null或空。
     </li>
    </ul>
    <h4>
     <a id="_147">
     </a>
     缓存雪崩
    </h4>
    <p>
     Redis的key是已存在的，但同时失效了。
    </p>
    <h5>
     <a id="redis_149">
     </a>
     redis故障
    </h5>
    <p>
     如宕机、网络抖动
    </p>
    <p>
     解决方案：
    </p>
    <ul>
     <li>
      使用主从复制提高可用性，使用cluster集群方案降低故障时的影响范围。
     </li>
     <li>
      如果出现故障，则可以采取服务降级、熔断、限流等措施。
     </li>
    </ul>
    <h5>
     <a id="key_157">
     </a>
     大量key同时过期
    </h5>
    <p>
     采取了相同的过期时间，例如在同一时刻设置了大量的key，但过期时间都是5分钟。
    </p>
    <p>
     解决方案：
    </p>
    <ul>
     <li>
      过期时间加上一个随机值，使得众多key均匀过期。
     </li>
    </ul>
    <h4>
     <a id="_163">
     </a>
     缓存击穿
    </h4>
    <p>
     少量热点key缓存时间失效。
    </p>
    <p>
     原因：
    </p>
    <ul>
     <li>
      热点的key设置了太短的过期时间。
     </li>
    </ul>
    <p>
     如：秒杀业务下的“库存数量”。
    </p>
    <p>
     解决方案：
    </p>
    <ul>
     <li>
      设置较长的过期时间。非常重要的key则设置永久有效。但需要解决好与数据库中的key的一致性问题。
     </li>
     <li>
      使用分布式锁：如果热点key失效了，要控制好访问后端数据库的流量。只允许一个请求去访问数据库，取出罪行的key，存放到redis，其他请求必须等待。但分布式锁也要防止出现异常的情况。
     </li>
    </ul>
    <h3>
     <a id="_176">
     </a>
     集群
    </h3>
    <ul>
     <li>
      主从复制集群
     </li>
     <li>
      哨兵集群
     </li>
     <li>
      Cluster集群
     </li>
    </ul>
    <h3>
     <a id="_181">
     </a>
     切片
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        客户端分片
       </td>
       <td>
        将分片工作放在业务程序端。不依赖于第三方分布式中间件，实现方法和代码可掌控，对开发人员要求高。
       </td>
      </tr>
      <tr>
       <td>
        代理分片
       </td>
       <td>
        将分片工作交给专门的代理程序来做，运维方便。代表：Twemproy，Codis。
       </td>
      </tr>
      <tr>
       <td>
        服务器端分片
       </td>
       <td>
        Redis Cluster将所有key映射到16384个Slot中，集群中每个Redis实例负责一部分，业务程序通过集成的Redis Cluster客户端进行操作。
       </td>
      </tr>
     </tbody>
    </table>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f31383934313731332f:61727469636c652f64657461696c732f313436313134313333" class_="artid" style="display:none">
 </p>
</div>


