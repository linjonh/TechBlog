---
layout: post
title: "C工程实战入门笔记13-多态"
date: 2025-09-08T16:35:08+0800
description: "本文演示了C++中多态性的实现过程。首先通过Widget基类和Rect、Circle派生类展示成员函数重写，但发现非多态调用问题。然后通过添加virtual关键字和override修饰符实现真正多态。最后通过Scene类展示多态在实际工程中的应用，实现了统一管理多种图形对象、统一接口调用和易于扩展的代码结构。这种设计体现了面向对象的核心原则，是构建大型可维护C++应用的基础。"
keywords: "C++工程实战入门笔记13-多态"
categories: ['C']
tags: ['笔记', '开发语言', 'C']
artid: "151325270"
arturl: "https://blog.csdn.net/xiaofeixia002X/article/details/151325270"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151325270
    alt: "C工程实战入门笔记13-多态"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151325270
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151325270
cover: https://bing.ee123.net/img/rand?artid=151325270
image: https://bing.ee123.net/img/rand?artid=151325270
img: https://bing.ee123.net/img/rand?artid=151325270
---



# C++工程实战入门笔记13-多态

![](https://i-operation.csdnimg.cn/images/cf31225e169b4512917b2e77694eb0a2.png)C++多态性实战解析



## 成员函数重写（非多态）

```cpp
#include<iostream>
using namespace std;
#include<string>

class Widget
{
public:
	void Move(int x, int y) { x_ = x; y_ = y; }
	void Draw() { cout << "Widget Draw:" << x_ << ":"<< y_ << endl; }
	int x() { return x_; }
	int y() { return y_; }
private:
	int x_{ 0 };
	int y_{ 0 };
};

//画矩形，继承Draw
class Rect :public Widget
{
public:
	void Draw() { cout << "Rect Draw:" << x() << ":" << y() << endl; }
};

//画圆，继承Draw
class Circle :public Widget
{
public:
	void Draw() { cout << "Circle Draw:" << x() << ":" << y() << endl; }
};

int main()
{
	Widget w;// 创建基类对象
	w.Draw(); // 调用基类的Draw

	Rect re;// 创建派生类对象
	re.Move(100,100);// 调用继承自基类的方法
	re.Draw();// 调用派生类自己的Draw

	Circle ci;// 创建另一个派生类对象
	ci.Draw();// 调用派生类自己的Draw
	
	system("pause");

}


```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d2238ff5b7dc443b842f511c8ee56893.png)

## 多态

加入两个函数

```cpp
void DrawWidget(Widget* w)
{
	w->Draw();
}

void DrawWidget(Widget& w)
{
	w.Draw();
}

```

main函数中加入

```cpp
	cout << "------------------------" << endl;
	DrawWidget(re);
	DrawWidget(&ci);
	DrawWidget(w);

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3b1e056383d34d3b918c19abb991ebcf.png)

```cpp
void Draw() { cout << "Widget Draw:" << x_ << ":"<< y_ << endl; }

```

改成

```cpp
virtual void Draw() { cout << "Widget Draw:" << x_ << ":"<< y_ << endl; }

```

添加override

```cpp
//画矩形，继承Draw
class Rect :public Widget
{
public:
	void Draw() override { cout << "Rect Draw:" << x() << ":" << y() << endl; }
};

//画圆，继承Draw
class Circle :public Widget
{
public:
	void Draw() override { cout << "Circle Draw:" << x() << ":" << y() << endl; }
};

```

再次运行代码  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/12bb64aae8074a3a85a70d4a17f2d787.png)

## 多态性的优势

实际工程中应用举例

```cpp
class Scene
{
public:
    void Add(Widget* w)
    {
        wids_.push_back(w);
    }
    void DrawAll()
    {
        for (auto w : wids_)
            w->Draw();
    }
    ~Scene()//防止内存泄露
	{
		for (auto w : wids_)
			delete w;
		wids_.clear();
	}
private:
    vector<Widget*>wids_;
};

```

* Scene类包含一组Widget对象，可以统一管理它们；
* 使用vector<Widget*>存储指向各种图形对象的指针；
* 通过遍历集合，对所有对象执行相同操作（如绘制）；
* 可以轻松添加新的图形类型，无需修改Scene类，具有可扩展性

main函数中加入

```cpp
int main()
{
    Scene sec;
    sec.Add(new Widget());
    sec.Add(new Circle());
    sec.Add(new Rect());
    sec.DrawAll();
}

```

这段代码展示了C++多态性的强大功能，特别是通过Scene类实现了：

> 多态容器管理多种类型的图形对象  
> 统一接口处理不同类型的对象  
> 易于扩展和维护的代码结构

Scene类的设计体现了面向对象设计的重要原则：

> 开闭原则（对扩展开放，对修改关闭）  
> 依赖倒置原则（依赖抽象而非具体实现）  
> 单一职责原则（每个类负责一个明确的功能）  
> 这种设计模式是构建大型、可维护C++应用程序的基础。



