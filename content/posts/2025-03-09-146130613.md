---
layout: post
title: "Scala-中trait的线性化规则Linearization-Rule和-super-的调用行为"
date: 2025-03-09 12:54:11 +0800
description: "最右优先原则：决定了特质的优先级，最右边的特质会优先生效。线性化规则：决定了super的调用顺序，super会根据线性化顺序动态绑定到下一个特质或类。在示例3中中，线性化顺序是，因此输出的顺序是。在示例2中，为什么输出是，而不是默认行为：在C的greet方法中，如果没有调用，则只会执行C的逻辑，输出。组合行为：如果希望将父特质的行为与当前特质的行为组合起来，需要在重写方法时显式调用。线性化顺序super的调用是根据线性化顺序动态绑定的，线性化顺序决定了方法调用的优先级。"
keywords: "Scala 中trait的线性化规则（Linearization Rule）和 super 的调用行为"
categories: ['未分类']
tags: ['开发语言', '大数据', 'Scala']
artid: "146130613"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146130613
    alt: "Scala-中trait的线性化规则Linearization-Rule和-super-的调用行为"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146130613
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146130613
cover: https://bing.ee123.net/img/rand?artid=146130613
image: https://bing.ee123.net/img/rand?artid=146130613
img: https://bing.ee123.net/img/rand?artid=146130613
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Scala 中trait的线性化规则（Linearization Rule）和 super 的调用行为
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Scala 中，
     <strong>
      特质（Trait）
      <strong>
       是一种强大的工具，用于实现代码的复用和组合。当一个类混入（
       <code>
        with
       </code>
       ）多个特质时，可能会出现方法冲突的情况。为了解决这种冲突，Scala 引入了
      </strong>
      最右优先原则（Rightmost First Rule）
     </strong>
     ，也称为
     <strong>
      线性化规则（Linearization Rule）
     </strong>
     。
    </p>
    <h4>
     最右优先原则
    </h4>
    <p>
     最右优先原则的核心思想是：
     <strong>
      在混入多个特质时，最右边的特质会优先生效
     </strong>
     。也就是说，如果一个方法在多个特质中都有定义，那么最右边的特质中的方法会覆盖左边特质中的方法。
    </p>
    <h5>
     示例1
    </h5>
    <pre><code class="language-Scala">trait A {
  def greet(): String = "Hello from A"
}

trait B {
  def greet(): String = "Hello from B"
}

class C extends A with B {
  override def greet(): String = super.greet()
}

val obj = new C
println(obj.greet())  // 输出: Hello from B</code></pre>
    <p>
     在上面的例子中：
    </p>
    <ul>
     <li>
      <p>
       类
       <code>
        C
       </code>
       混入了特质
       <code>
        A
       </code>
       和
       <code>
        B
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       根据最右优先原则，
       <code>
        B
       </code>
       中的
       <code>
        greet
       </code>
       方法会覆盖
       <code>
        A
       </code>
       中的
       <code>
        greet
       </code>
       方法。
      </p>
     </li>
     <li>
      <p>
       因此，调用
       <code>
        obj.greet()
       </code>
       时，输出的是
       <code>
        B
       </code>
       中的实现。
      </p>
     </li>
    </ul>
    <h4>
     线性化规则
    </h4>
    <p>
     最右优先原则是 Scala 线性化规则的一部分。Scala 会为每个类生成一个
     <strong>
      线性化顺序（Linearization Order）
     </strong>
     ，这个顺序决定了方法调用的优先级。
    </p>
    <h5>
     线性化顺序的生成规则
    </h5>
    <ol>
     <li>
      <p>
       类的线性化顺序从最具体的类开始，逐步向更通用的类扩展。
      </p>
     </li>
     <li>
      <p>
       混入的特质按照从右到左的顺序排列。
      </p>
     </li>
     <li>
      <p>
       每个特质只会在线性化顺序中出现一次。
      </p>
     </li>
    </ol>
    <h5>
     示例2
    </h5>
    <pre><code class="language-Scala">trait A {
  def greet(): String = "Hello from A"
}

trait B extends A {
  override def greet(): String = "Hello from B"
}

trait C extends A {
  override def greet(): String = "Hello from C"
}

class D extends B with C {
  override def greet(): String = super.greet()
}

val obj = new D
println(obj.greet())  // 输出: Hello from C</code></pre>
    <p>
     在这个例子中：
    </p>
    <ul>
     <li>
      <p>
       类
       <code>
        D
       </code>
       的线性化顺序是：
       <code>
        D -&gt; C -&gt; B -&gt; A
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       根据最右优先原则，
       <code>
        C
       </code>
       中的
       <code>
        greet
       </code>
       方法会覆盖
       <code>
        B
       </code>
       中的
       <code>
        greet
       </code>
       方法。
      </p>
     </li>
     <li>
      <p>
       因此，调用
       <code>
        obj.greet()
       </code>
       时，输出的是
       <code>
        C
       </code>
       中的实现。
      </p>
     </li>
    </ul>
    <h4>
     <code>
      super
     </code>
     的调用
    </h4>
    <p>
     在特质中，
     <code>
      super
     </code>
     的调用是动态绑定的，它会根据线性化顺序调用下一个特质或类中的方法。
    </p>
    <h5>
     示例3
    </h5>
    <pre><code class="language-Scala">trait A {
  def greet(): String = "Hello from A"
}

trait B extends A {
  override def greet(): String = s"${super.greet()} and Hello from B"
}

trait C extends A {
  override def greet(): String = s"${super.greet()} and Hello from C"
}

class D extends B with C {
  override def greet(): String = super.greet()
}

val obj = new D
println(obj.greet())  // 输出: Hello from A and Hello from B and Hello from C</code></pre>
    <p>
    </p>
    <p>
     如果你还是有疑问，接下来，是更加具体的分析：
     <br/>
    </p>
    <p>
     <code>
      在示例3中，输出的是Hello from A and Hello from B and Hello from C
     </code>
     ，而不是
     <code>
      Hello from A and Hello from C and Hello from B
     </code>
     。这看起来似乎与最右优先原则相矛盾，但实际上这是由 Scala 的线性化规则（Linearization Rule）决定的。
    </p>
    <h4>
     线性化规则详解
    </h4>
    <p>
     Scala 的线性化规则决定了方法调用的顺序。具体来说，当一个类混入多个特质时，Scala 会生成一个
     <strong>
      线性化顺序
     </strong>
     ，这个顺序决定了
     <code>
      super
     </code>
     调用的行为。
    </p>
    <h5>
     线性化顺序的生成规则
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        从最具体的类开始
       </strong>
       ，逐步向更通用的类扩展。
      </p>
     </li>
     <li>
      <p>
       <strong>
        混入的特质按照从右到左的顺序排列
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        每个特质只会在线性化顺序中出现一次
       </strong>
       。
      </p>
     </li>
    </ol>
    <p>
     在示例3中：
    </p>
    <pre><code class="language-Scala">class D extends B with C</code></pre>
    <ul>
     <li>
      <p>
       <code>
        D
       </code>
       的线性化顺序是：
       <code>
        D -&gt; C -&gt; B -&gt; A
       </code>
       。
      </p>
     </li>
    </ul>
    <h5>
     线性化顺序的解释
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         D
        </code>
       </strong>
       ：最具体的类。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         C
        </code>
       </strong>
       ：因为
       <code>
        C
       </code>
       是最右边的特质，所以它排在
       <code>
        B
       </code>
       前面。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         B
        </code>
       </strong>
       ：
       <code>
        B
       </code>
       是左边的特质，排在
       <code>
        C
       </code>
       后面。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         A
        </code>
       </strong>
       ：
       <code>
        A
       </code>
       是
       <code>
        B
       </code>
       和
       <code>
        C
       </code>
       的共同父特质，排在最后。
      </p>
     </li>
    </ol>
    <p>
     因此，
     <code>
      D
     </code>
     的线性化顺序是：
     <code>
      D -&gt; C -&gt; B -&gt; A
     </code>
     。
    </p>
    <h4>
     <code>
      super
     </code>
     的调用行为
    </h4>
    <p>
     在 Scala 中，
     <code>
      super
     </code>
     的调用是动态绑定的，它会根据线性化顺序调用下一个特质或类中的方法。
    </p>
    <h5>
     例子分析
    </h5>
    <pre><code class="language-Scala">trait A {
  def greet(): String = "Hello from A"
}

trait B extends A {
  override def greet(): String = s"${super.greet()} and Hello from B"
}

trait C extends A {
  override def greet(): String = s"${super.greet()} and Hello from C"
}

class D extends B with C {
  override def greet(): String = super.greet()
}

val obj = new D
println(obj.greet())  // 输出: Hello from A and Hello from B and Hello from C</code></pre>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         D
        </code>
        中的
        <code>
         greet
        </code>
        方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调用
         <code>
          super.greet()
         </code>
         ，根据线性化顺序，
         <code>
          super
         </code>
         指向
         <code>
          C
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         C
        </code>
        中的
        <code>
         greet
        </code>
        方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调用
         <code>
          super.greet()
         </code>
         ，根据线性化顺序，
         <code>
          super
         </code>
         指向
         <code>
          B
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         B
        </code>
        中的
        <code>
         greet
        </code>
        方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调用
         <code>
          super.greet()
         </code>
         ，根据线性化顺序，
         <code>
          super
         </code>
         指向
         <code>
          A
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         A
        </code>
        中的
        <code>
         greet
        </code>
        方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         返回
         <code>
          "Hello from A"
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        方法调用的堆栈
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          A
         </code>
         返回
         <code>
          "Hello from A"
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <code>
          B
         </code>
         在其基础上追加
         <code>
          " and Hello from B"
         </code>
         ，得到
         <code>
          "Hello from A and Hello from B"
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <code>
          C
         </code>
         在其基础上追加
         <code>
          " and Hello from C"
         </code>
         ，得到
         <code>
          "Hello from A and Hello from B and Hello from C"
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     为什么不是
     <code>
      Hello from A and Hello from C and Hello from B
     </code>
     ？
    </h4>
    <ul>
     <li>
      <p>
       因为
       <code>
        super
       </code>
       的调用是根据线性化顺序动态绑定的，而不是简单地按照最右优先原则直接覆盖。
      </p>
     </li>
     <li>
      <p>
       线性化顺序是
       <code>
        D -&gt; C -&gt; B -&gt; A
       </code>
       ，所以
       <code>
        C
       </code>
       的
       <code>
        super
       </code>
       指向
       <code>
        B
       </code>
       ，
       <code>
        B
       </code>
       的
       <code>
        super
       </code>
       指向
       <code>
        A
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       因此，
       <code>
        C
       </code>
       的
       <code>
        greet
       </code>
       方法会先调用
       <code>
        B
       </code>
       的
       <code>
        greet
       </code>
       方法，而
       <code>
        B
       </code>
       的
       <code>
        greet
       </code>
       方法会调用
       <code>
        A
       </code>
       的
       <code>
        greet
       </code>
       方法。
      </p>
     </li>
    </ul>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        最右优先原则
       </strong>
       ：决定了特质的优先级，最右边的特质会优先生效。
      </p>
     </li>
     <li>
      <p>
       <strong>
        线性化规则
       </strong>
       ：决定了
       <code>
        super
       </code>
       的调用顺序，
       <code>
        super
       </code>
       会根据线性化顺序动态绑定到下一个特质或类。
      </p>
     </li>
     <li>
      <p>
       在示例3中，线性化顺序是
       <code>
        D -&gt; C -&gt; B -&gt; A
       </code>
       ，因此输出的顺序是
       <code>
        Hello from A and Hello from B and Hello from C
       </code>
       。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <p>
     在示例2中，为什么输出是
     <code>
      Hello from C
     </code>
     ，而不是
     <code>
      Hello from A and Hello from C？
     </code>
    </p>
    <hr/>
    <h4>
     代码分析
    </h4>
    <pre><code class="language-Scala">trait A {
  def greet(): String = "Hello from A"
}

trait B extends A {
  override def greet(): String = "Hello from B"
}

trait C extends A {
  override def greet(): String = "Hello from C"
}

class D extends B with C {
  override def greet(): String = super.greet()
}

val obj = new D
println(obj.greet())  // 输出: Hello from C</code></pre>
    <ol>
     <li>
      <p>
       <strong>
        特质的继承关系
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          B
         </code>
         和
         <code>
          C
         </code>
         都继承自
         <code>
          A
         </code>
         ，并且都重写了
         <code>
          greet
         </code>
         方法。
        </p>
       </li>
       <li>
        <p>
         <code>
          D
         </code>
         混入了
         <code>
          B
         </code>
         和
         <code>
          C
         </code>
         ，并且重写了
         <code>
          greet
         </code>
         方法，调用了
         <code>
          super.greet()
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        线性化顺序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当
         <code>
          D
         </code>
         混入
         <code>
          B
         </code>
         和
         <code>
          C
         </code>
         时，Scala 会生成一个线性化顺序。线性化顺序的规则是：
        </p>
        <ul>
         <li>
          <p>
           从最具体的类开始，逐步向更通用的类扩展。
          </p>
         </li>
         <li>
          <p>
           混入的特质按照从右到左的顺序排列。
          </p>
         </li>
         <li>
          <p>
           每个特质只会在线性化顺序中出现一次。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         对于
         <code>
          class D extends B with C
         </code>
         ，线性化顺序是：
         <code>
          D -&gt; C -&gt; B -&gt; A
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         super
        </code>
        的调用行为
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在
         <code>
          D
         </code>
         的
         <code>
          greet
         </code>
         方法中，
         <code>
          super.greet()
         </code>
         会根据线性化顺序调用下一个特质或类中的
         <code>
          greet
         </code>
         方法。
        </p>
       </li>
       <li>
        <p>
         线性化顺序是
         <code>
          D -&gt; C -&gt; B -&gt; A
         </code>
         ，因此
         <code>
          super.greet()
         </code>
         会调用
         <code>
          C
         </code>
         中的
         <code>
          greet
         </code>
         方法。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         C
        </code>
        中的
        <code>
         greet
        </code>
        方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          C
         </code>
         中的
         <code>
          greet
         </code>
         方法直接返回
         <code>
          "Hello from C"
         </code>
         ，
         <strong>
          没有调用
          <code>
           super.greet()
          </code>
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         因此，
         <code>
          C
         </code>
         的
         <code>
          greet
         </code>
         方法不会继续调用
         <code>
          B
         </code>
         或
         <code>
          A
         </code>
         的
         <code>
          greet
         </code>
         方法。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     为什么输出是
     <code>
      Hello from C
     </code>
     ？
    </h4>
    <ul>
     <li>
      <p>
       在
       <code>
        D
       </code>
       的
       <code>
        greet
       </code>
       方法中，
       <code>
        super.greet()
       </code>
       调用的是
       <code>
        C
       </code>
       的
       <code>
        greet
       </code>
       方法。
      </p>
     </li>
     <li>
      <p>
       <code>
        C
       </code>
       的
       <code>
        greet
       </code>
       方法直接返回
       <code>
        "Hello from C"
       </code>
       ，没有继续调用
       <code>
        super.greet()
       </code>
       （即没有调用
       <code>
        B
       </code>
       或
       <code>
        A
       </code>
       的
       <code>
        greet
       </code>
       方法）。
      </p>
     </li>
     <li>
      <p>
       因此，最终的输出是
       <code>
        "Hello from C"
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     为什么不是
     <code>
      Hello from A and Hello from C
     </code>
     ？
    </h4>
    <ul>
     <li>
      <p>
       如果希望输出
       <code>
        Hello from A and Hello from C
       </code>
       ，
       <strong>
        需要在
        <code>
         C
        </code>
        的
        <code>
         greet
        </code>
        方法中显式调用
        <code>
         super.greet()
        </code>
       </strong>
       ，将
       <code>
        A
       </code>
       的行为与
       <code>
        C
       </code>
       的行为组合起来。
      </p>
     </li>
     <li>
      <p>
       例如：
      </p>
     </li>
    </ul>
    <pre><code class="language-Scala">trait C extends A {
  override def greet(): String = s"${super.greet()} and Hello from C"
}</code></pre>
    <p>
     修改后，
     <code>
      C
     </code>
     的
     <code>
      greet
     </code>
     方法会先调用
     <code>
      A
     </code>
     的
     <code>
      greet
     </code>
     方法，然后追加
     <code>
      " and Hello from C"
     </code>
     。此时，输出会是
     <code>
      Hello from A and Hello from C
     </code>
     。
    </p>
    <hr/>
    <h4>
     修改后的代码
    </h4>
    <pre><code class="language-Scala">trait A {
  def greet(): String = "Hello from A"
}

trait B extends A {
  override def greet(): String = "Hello from B"
}

trait C extends A {
  override def greet(): String = s"${super.greet()} and Hello from C"
}

class D extends B with C {
  override def greet(): String = super.greet()
}

val obj = new D
println(obj.greet())  // 输出: Hello from A and Hello from C</code></pre>
    <hr/>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：在
       <code>
        C
       </code>
       的
       <code>
        greet
       </code>
       方法中，如果没有调用
       <code>
        super.greet()
       </code>
       ，则只会执行
       <code>
        C
       </code>
       的逻辑，输出
       <code>
        Hello from C
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        组合行为
       </strong>
       ：如果希望将父特质的行为与当前特质的行为组合起来，需要在重写方法时显式调用
       <code>
        super.greet()
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        线性化顺序
       </strong>
       ：
       <code>
        super
       </code>
       的调用是根据线性化顺序动态绑定的，线性化顺序决定了方法调用的优先级。
      </p>
     </li>
    </ul>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36333332323132322f:61727469636c652f64657461696c732f313436313330363133" class_="artid" style="display:none">
 </p>
</div>


