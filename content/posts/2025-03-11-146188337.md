---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f4368656e374368616e2f:61727469636c652f64657461696c732f313436313838333337"
layout: post
title: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—29-å‰ç«¯é”™è¯¯å¤„ç†å®è·µ"
date: 2025-03-11 20:26:38 +0800
description: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ä¹‹æ—…ç¬¬äºŒåä¹ç«™"
keywords: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ29ï¼‰--å‰ç«¯é”™è¯¯å¤„ç†å®è·µ"
categories: ['å‰ç«¯å·¥ç¨‹åŒ–ä¸æ¡†æ¶']
tags: ['çŠ¶æ€æ¨¡å¼', 'å‰ç«¯']
artid: "146188337"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146188337
    alt: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—29-å‰ç«¯é”™è¯¯å¤„ç†å®è·µ"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146188337
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146188337
cover: https://bing.ee123.net/img/rand?artid=146188337
image: https://bing.ee123.net/img/rand?artid=146188337
img: https://bing.ee123.net/img/rand?artid=146188337
---

# å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ29ï¼‰--å‰ç«¯é”™è¯¯å¤„ç†å®è·µ

## å‰ç«¯é”™è¯¯å¤„ç†å®è·µ ğŸ”§

### å¼•è¨€

å‰ç«¯é”™è¯¯å¤„ç†æ˜¯ä¿è¯åº”ç”¨ç¨³å®šæ€§å’Œç”¨æˆ·ä½“éªŒçš„å…³é”®ç¯èŠ‚ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å‰ç«¯é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µï¼ŒåŒ…æ‹¬é”™è¯¯æ•è·ã€ç›‘æ§ã€ä¸ŠæŠ¥å’Œæ¢å¤ç­‰æ–¹é¢ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºæ›´åŠ å¥å£®çš„å‰ç«¯åº”ç”¨ã€‚

### é”™è¯¯å¤„ç†æ¦‚è¿°

å‰ç«¯é”™è¯¯å¤„ç†ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹æ–¹é¢ï¼š

* **é”™è¯¯æ•è·**
  ï¼šè¿è¡Œæ—¶é”™è¯¯ã€Promiseé”™è¯¯ã€ç½‘ç»œé”™è¯¯ç­‰
* **é”™è¯¯ç›‘æ§**
  ï¼šé”™è¯¯æ”¶é›†ã€åˆ†æå’Œç»Ÿè®¡
* **é”™è¯¯ä¸ŠæŠ¥**
  ï¼šé”™è¯¯ä¿¡æ¯å‘é€åˆ°æœåŠ¡å™¨
* **é”™è¯¯æ¢å¤**
  ï¼šä¼˜é›…é™çº§å’Œå®¹é”™å¤„ç†
* **è°ƒè¯•æ”¯æŒ**
  ï¼šé”™è¯¯å®šä½å’Œè°ƒè¯•è¾…åŠ©

### é”™è¯¯å¤„ç†å®ç°

#### é”™è¯¯ç›‘æ§ç®¡ç†å™¨

```typescript
// é”™è¯¯ç›‘æ§ç®¡ç†å™¨
class ErrorMonitor {
    private static instance: ErrorMonitor;
    private isInitialized: boolean;
    private config: ErrorMonitorConfig;
    private errorQueue: ErrorInfo[];
    private timer: number | null;
    
    private constructor() {
        this.isInitialized = false;
        this.config = {
            appId: '',
            appVersion: '',
            maxQueueSize: 100,
            flushInterval: 5000,
            reportUrl: '',
            ignoreErrors: []
        };
        this.errorQueue = [];
        this.timer = null;
    }
    
    // è·å–å•ä¾‹å®ä¾‹
    static getInstance(): ErrorMonitor {
        if (!ErrorMonitor.instance) {
            ErrorMonitor.instance = new ErrorMonitor();
        }
        return ErrorMonitor.instance;
    }
    
    // åˆå§‹åŒ–ç›‘æ§å™¨
    initialize(config: Partial<ErrorMonitorConfig>): void {
        if (this.isInitialized) {
            return;
        }
        
        this.config = { ...this.config, ...config };
        
        // æ³¨å†Œå…¨å±€é”™è¯¯å¤„ç†å™¨
        this.registerErrorHandlers();
        
        // å¯åŠ¨å®šæ—¶ä¸ŠæŠ¥
        this.startAutoReport();
        
        this.isInitialized = true;
    }
    
    // æ‰‹åŠ¨ä¸ŠæŠ¥é”™è¯¯
    report(error: Error | string, extra?: Record<string, any>): void {
        const errorInfo = this.createErrorInfo(error, extra);
        this.addToQueue(errorInfo);
    }
    
    // ç«‹å³ä¸ŠæŠ¥æ‰€æœ‰é”™è¯¯
    flush(): Promise<void> {
        if (this.errorQueue.length === 0) {
            return Promise.resolve();
        }
        
        const errors = [...this.errorQueue];
        this.errorQueue = [];
        
        return this.sendToServer(errors);
    }
    
    // æ³¨å†Œé”™è¯¯å¤„ç†å™¨
    private registerErrorHandlers(): void {
        // å¤„ç†æœªæ•è·çš„é”™è¯¯
        window.addEventListener('error', (event) => {
            if (this.shouldIgnoreError(event.error)) {
                return;
            }
            
            const errorInfo = this.createErrorInfo(event.error, {
                type: 'uncaught',
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
            
            this.addToQueue(errorInfo);
        });
        
        // å¤„ç†æœªå¤„ç†çš„Promiseæ‹’ç»
        window.addEventListener('unhandledrejection', (event) => {
            if (this.shouldIgnoreError(event.reason)) {
                return;
            }
            
            const errorInfo = this.createErrorInfo(event.reason, {
                type: 'unhandledrejection'
            });
            
            this.addToQueue(errorInfo);
        });
        
        // å¤„ç†èµ„æºåŠ è½½é”™è¯¯
        window.addEventListener('error', (event) => {
            if (event.target && (event.target as HTMLElement).nodeName) {
                const target = event.target as HTMLElement;
                const errorInfo = this.createErrorInfo(new Error('Resource load failed'), {
                    type: 'resource',
                    tagName: target.nodeName.toLowerCase(),
                    src: (target as HTMLImageElement | HTMLScriptElement).src || 
                         (target as HTMLLinkElement).href
                });
                
                this.addToQueue(errorInfo);
            }
        }, true);
    }
    
    // åˆ›å»ºé”™è¯¯ä¿¡æ¯
    private createErrorInfo(
        error: Error | string,
        extra?: Record<string, any>
    ): ErrorInfo {
        const errorObj = error instanceof Error ? error : new Error(error);
        const timestamp = Date.now();
        
        return {
            appId: this.config.appId,
            appVersion: this.config.appVersion,
            timestamp,
            url: window.location.href,
            userAgent: navigator.userAgent,
            message: errorObj.message,
            stack: errorObj.stack,
            ...extra
        };
    }
    
    // æ·»åŠ åˆ°é”™è¯¯é˜Ÿåˆ—
    private addToQueue(errorInfo: ErrorInfo): void {
        this.errorQueue.push(errorInfo);
        
        // é˜Ÿåˆ—è¶…å‡ºé™åˆ¶æ—¶ç«‹å³ä¸ŠæŠ¥
        if (this.errorQueue.length >= this.config.maxQueueSize) {
            this.flush();
        }
    }
    
    // å¯åŠ¨è‡ªåŠ¨ä¸ŠæŠ¥
    private startAutoReport(): void {
        if (this.timer !== null) {
            return;
        }
        
        this.timer = window.setInterval(() => {
            this.flush();
        }, this.config.flushInterval);
    }
    
    // åœæ­¢è‡ªåŠ¨ä¸ŠæŠ¥
    private stopAutoReport(): void {
        if (this.timer === null) {
            return;
        }
        
        window.clearInterval(this.timer);
        this.timer = null;
    }
    
    // å‘é€é”™è¯¯åˆ°æœåŠ¡å™¨
    private async sendToServer(errors: ErrorInfo[]): Promise<void> {
        try {
            const response = await fetch(this.config.reportUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(errors)
            });
            
            if (!response.ok) {
                throw new Error('Failed to report errors');
            }
        } catch (error) {
            console.error('Error reporting failed:', error);
            // é‡æ–°åŠ å…¥é˜Ÿåˆ—
            this.errorQueue.push(...errors);
        }
    }
    
    // åˆ¤æ–­æ˜¯å¦å¿½ç•¥é”™è¯¯
    private shouldIgnoreError(error: any): boolean {
        return this.config.ignoreErrors.some(pattern => {
            if (pattern instanceof RegExp) {
                return pattern.test(error.message || error);
            }
            return pattern === error.message || pattern === error;
        });
    }
}

// é”™è¯¯ç›‘æ§é…ç½®æ¥å£
interface ErrorMonitorConfig {
    appId: string;
    appVersion: string;
    maxQueueSize: number;
    flushInterval: number;
    reportUrl: string;
    ignoreErrors: (string | RegExp)[];
}

// é”™è¯¯ä¿¡æ¯æ¥å£
interface ErrorInfo {
    appId: string;
    appVersion: string;
    timestamp: number;
    url: string;
    userAgent: string;
    message: string;
    stack?: string;
    [key: string]: any;
}

// ä½¿ç”¨ç¤ºä¾‹
const errorMonitor = ErrorMonitor.getInstance();

// åˆå§‹åŒ–é”™è¯¯ç›‘æ§
errorMonitor.initialize({
    appId: 'my-app',
    appVersion: '1.0.0',
    reportUrl: '/api/errors',
    ignoreErrors: [
        /Script error/,
        'Network error'
    ]
});

// æ‰‹åŠ¨ä¸ŠæŠ¥é”™è¯¯
try {
    throw new Error('Something went wrong');
} catch (error) {
    errorMonitor.report(error, {
        type: 'business',
        module: 'payment'
    });
}

```

#### é”™è¯¯è¾¹ç•Œç»„ä»¶

```typescript
// é”™è¯¯è¾¹ç•ŒåŸºç±»
abstract class ErrorBoundary extends HTMLElement {
    private root: ShadowRoot;
    private hasError: boolean;
    private error: Error | null;
    
    constructor() {
        super();
        
        this.root = this.attachShadow({ mode: 'open' });
        this.hasError = false;
        this.error = null;
        
        this.initialize();
    }
    
    // åˆå§‹åŒ–ç»„ä»¶
    private initialize(): void {
        // ç›‘å¬å­å…ƒç´ é”™è¯¯
        this.addEventListener('error', this.handleError.bind(this));
        
        // æ¸²æŸ“åˆå§‹å†…å®¹
        this.render();
    }
    
    // å¤„ç†é”™è¯¯
    private handleError(event: ErrorEvent): void {
        event.preventDefault();
        
        this.hasError = true;
        this.error = event.error;
        
        // ä¸ŠæŠ¥é”™è¯¯
        ErrorMonitor.getInstance().report(event.error, {
            type: 'component',
            tagName: this.tagName.toLowerCase()
        });
        
        // é‡æ–°æ¸²æŸ“
        this.render();
    }
    
    // é‡ç½®é”™è¯¯çŠ¶æ€
    protected reset(): void {
        this.hasError = false;
        this.error = null;
        this.render();
    }
    
    // æ¸²æŸ“ç»„ä»¶
    private render(): void {
        this.root.innerHTML = this.hasError
            ? this.renderError(this.error!)
            : this.renderContent();
    }
    
    // æ¸²æŸ“æ­£å¸¸å†…å®¹ï¼ˆå­ç±»å®ç°ï¼‰
    protected abstract renderContent(): string;
    
    // æ¸²æŸ“é”™è¯¯å†…å®¹ï¼ˆå­ç±»å®ç°ï¼‰
    protected abstract renderError(error: Error): string;
}

// é”™è¯¯è¾¹ç•Œç¤ºä¾‹
class UserProfileErrorBoundary extends ErrorBoundary {
    private userId: string;
    
    constructor() {
        super();
        this.userId = '';
    }
    
    // è§‚å¯Ÿçš„å±æ€§
    static get observedAttributes() {
        return ['user-id'];
    }
    
    // å±æ€§å˜åŒ–å¤„ç†
    attributeChangedCallback(
        name: string,
        oldValue: string,
        newValue: string
    ) {
        if (name === 'user-id') {
            this.userId = newValue;
            this.reset();
        }
    }
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯
    protected renderContent(): string {
        return `
            <div class="user-profile">
                <h2>User Profile</h2>
                <div class="loading">Loading user ${this.userId}...</div>
            </div>
            
            <style>
                .user-profile {
                    padding: 16px;
                    border: 1px solid #eee;
                    border-radius: 4px;
                }
                
                .loading {
                    color: #666;
                    font-style: italic;
                }
            </style>
        `;
    }
    
    // æ¸²æŸ“é”™è¯¯ä¿¡æ¯
    protected renderError(error: Error): string {
        return `
            <div class="error">
                <h3>Something went wrong</h3>
                <p>${error.message}</p>
                <button onclick="this.getRootNode().host.reset()">
                    Retry
                </button>
            </div>
            
            <style>
                .error {
                    padding: 16px;
                    border: 1px solid #f66;
                    border-radius: 4px;
                    background: #fee;
                    color: #c00;
                }
                
                button {
                    margin-top: 8px;
                    padding: 4px 12px;
                    border: 1px solid #c00;
                    border-radius: 4px;
                    background: #fff;
                    color: #c00;
                    cursor: pointer;
                }
                
                button:hover {
                    background: #c00;
                    color: #fff;
                }
            </style>
        `;
    }
}

// æ³¨å†Œç»„ä»¶
customElements.define('error-boundary', UserProfileErrorBoundary);

// ä½¿ç”¨ç¤ºä¾‹
const template = `
    <error-boundary user-id="123">
        <user-profile></user-profile>
    </error-boundary>
`;

```

#### ç½‘ç»œé”™è¯¯å¤„ç†

```typescript
// ç½‘ç»œè¯·æ±‚å®¢æˆ·ç«¯
class HttpClient {
    private baseUrl: string;
    private timeout: number;
    private retryCount: number;
    private retryDelay: number;
    
    constructor(config: HttpClientConfig) {
        this.baseUrl = config.baseUrl || '';
        this.timeout = config.timeout || 10000;
        this.retryCount = config.retryCount || 3;
        this.retryDelay = config.retryDelay || 1000;
    }
    
    // å‘é€è¯·æ±‚
    async request<T>(config: RequestConfig): Promise<T> {
        let lastError: Error | null = null;
        
        // é‡è¯•æœºåˆ¶
        for (let i = 0; i <= this.retryCount; i++) {
            try {
                return await this.sendRequest<T>(config);
            } catch (error) {
                lastError = error as Error;
                
                // åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
                if (!this.shouldRetry(error) || i === this.retryCount) {
                    break;
                }
                
                // ç­‰å¾…å»¶è¿Ÿæ—¶é—´
                await this.delay(this.retryDelay * Math.pow(2, i));
            }
        }
        
        // å¤„ç†é”™è¯¯
        this.handleError(lastError!);
        throw lastError;
    }
    
    // å‘é€å•æ¬¡è¯·æ±‚
    private async sendRequest<T>(config: RequestConfig): Promise<T> {
        const url = this.baseUrl + config.url;
        const controller = new AbortController();
        
        // è®¾ç½®è¶…æ—¶
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, this.timeout);
        
        try {
            const response = await fetch(url, {
                method: config.method || 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    ...config.headers
                },
                body: config.data ? JSON.stringify(config.data) : undefined,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            // å¤„ç†å“åº”
            if (!response.ok) {
                throw new HttpError(
                    response.statusText,
                    response.status,
                    await response.json()
                );
            }
            
            return await response.json();
            
        } catch (error) {
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    throw new HttpError('Request timeout', 408);
                }
                throw new HttpError(error.message, 0);
            }
            throw error;
        }
    }
    
    // åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
    private shouldRetry(error: any): boolean {
        if (!(error instanceof HttpError)) {
            return false;
        }
        
        // æ ¹æ®çŠ¶æ€ç åˆ¤æ–­
        const retryableStatus = [408, 500, 502, 503, 504];
        return retryableStatus.includes(error.status);
    }
    
    // å¤„ç†é”™è¯¯
    private handleError(error: Error): void {
        // ä¸ŠæŠ¥é”™è¯¯
        ErrorMonitor.getInstance().report(error, {
            type: 'http',
            url: error instanceof HttpError ? error.url : undefined,
            status: error instanceof HttpError ? error.status : undefined
        });
    }
    
    // å»¶è¿Ÿå‡½æ•°
    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// HTTPé”™è¯¯ç±»
class HttpError extends Error {
    constructor(
        message: string,
        public status: number,
        public data?: any
    ) {
        super(message);
        this.name = 'HttpError';
    }
}

// é…ç½®æ¥å£
interface HttpClientConfig {
    baseUrl?: string;
    timeout?: number;
    retryCount?: number;
    retryDelay?: number;
}

interface RequestConfig {
    url: string;
    method?: string;
    headers?: Record<string, string>;
    data?: any;
}

// ä½¿ç”¨ç¤ºä¾‹
const http = new HttpClient({
    baseUrl: 'https://api.example.com',
    timeout: 5000,
    retryCount: 3
});

// å‘é€è¯·æ±‚
async function fetchUserProfile(userId: string) {
    try {
        const user = await http.request({
            url: `/users/${userId}`,
            method: 'GET'
        });
        
        return user;
        
    } catch (error) {
        if (error instanceof HttpError) {
            switch (error.status) {
                case 404:
                    throw new Error('User not found');
                case 401:
                    throw new Error('Unauthorized');
                default:
                    throw new Error('Failed to fetch user profile');
            }
        }
        throw error;
    }
}

```

### æœ€ä½³å®è·µä¸å»ºè®®

1. **é”™è¯¯åˆ†ç±»**

   * è¿è¡Œæ—¶é”™è¯¯
   * ç½‘ç»œé”™è¯¯
   * ä¸šåŠ¡é”™è¯¯
   * èµ„æºé”™è¯¯
2. **é”™è¯¯å¤„ç†ç­–ç•¥**

   * å…¨å±€ç»Ÿä¸€å¤„ç†
   * ä¼˜é›…é™çº§
   * é”™è¯¯æ¢å¤
   * ç”¨æˆ·åé¦ˆ
3. **é”™è¯¯ä¸ŠæŠ¥**

   * é”™è¯¯å»é‡
   * é‡‡æ ·ä¸ŠæŠ¥
   * æ‰¹é‡ä¸ŠæŠ¥
   * é”™è¯¯åˆ†æ
4. **è°ƒè¯•æ”¯æŒ**

   * æºç æ˜ å°„
   * é”™è¯¯å®šä½
   * ç¯å¢ƒä¿¡æ¯
   * ç”¨æˆ·è¡Œä¸º

### æ€»ç»“

å‰ç«¯é”™è¯¯å¤„ç†éœ€è¦è€ƒè™‘ä»¥ä¸‹æ–¹é¢ï¼š

1. é”™è¯¯æ•è·ä¸åˆ†ç±»
2. é”™è¯¯ç›‘æ§ä¸ä¸ŠæŠ¥
3. é”™è¯¯æ¢å¤ä¸é™çº§
4. è°ƒè¯•æ”¯æŒä¸åˆ†æ
5. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

é€šè¿‡åˆç†çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œå¯ä»¥æé«˜åº”ç”¨çš„ç¨³å®šæ€§å’Œå¯ç”¨æ€§ã€‚

### å­¦ä¹ èµ„æº

1. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ
2. é”™è¯¯ç›‘æ§å¹³å°
3. è°ƒè¯•å·¥å…·æŒ‡å—
4. æ€§èƒ½ä¼˜åŒ–å»ºè®®
5. ç”¨æˆ·ä½“éªŒè®¾è®¡

---

å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è—ï¼Œä¹ŸæœŸå¾…åœ¨è¯„è®ºåŒºçœ‹åˆ°ä½ çš„æƒ³æ³•å’Œå»ºè®®ï¼ğŸ‘‡

***ç»ˆèº«å­¦ä¹ ï¼Œå…±åŒæˆé•¿ã€‚***

å’±ä»¬ä¸‹ä¸€æœŸè§

ğŸ’»