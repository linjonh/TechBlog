---
layout: post
title: "30Vuex-为啥可以进行缓存处理"
date: 2025-03-13 17:02:37 +0800
description: "【代码】30、Vuex 为啥可以进行缓存处理。"
keywords: "30、Vuex 为啥可以进行缓存处理"
categories: ['前端面试题']
tags: ['前端']
artid: "146236473"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146236473
    alt: "30Vuex-为啥可以进行缓存处理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146236473
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146236473
cover: https://bing.ee123.net/img/rand?artid=146236473
image: https://bing.ee123.net/img/rand?artid=146236473
img: https://bing.ee123.net/img/rand?artid=146236473
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     30、Vuex 为啥可以进行缓存处理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <ol>
     <li>
      <p>
       <strong>
        Vuex 状态管理基础与缓存的关联
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Vuex 的核心概念
         </strong>
         ：
        </p>
        <ul>
         <li>
          Vuex 主要由五个部分组成：
          <code>
           state
          </code>
          、
          <code>
           mutations
          </code>
          、
          <code>
           actions
          </code>
          、
          <code>
           getters
          </code>
          和
          <code>
           modules
          </code>
          。其中，
          <code>
           state
          </code>
          是存储数据的地方，类似于一个全局的数据仓库。在这个菜谱 APP 的例子中，缓存的数据就存储在
          <code>
           state
          </code>
          中。
         </li>
         <li>
          例如，我们可以在
          <code>
           state
          </code>
          中定义一个对象来存储菜谱品类和菜谱的数据，像这样：
          <p>
           javascript
          </p>
          <pre><code>const state = {
  recipeCache: {}
};
</code></pre>
          <br/>
          这里的
          <code>
           recipeCache
          </code>
          就是用来缓存菜谱相关数据的对象，以品类下标作为键，对应的菜谱数据作为值。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          组件与 Vuex 数据的交互
         </strong>
         ：
        </p>
        <ul>
         <li>
          组件可以通过
          <code>
           mapState
          </code>
          、
          <code>
           mapGetters
          </code>
          等辅助函数来获取
          <code>
           state
          </code>
          中的数据。这样，不同的组件（如左边的菜谱品类展示组件和右边的菜谱展示组件）都能够访问和使用存储在
          <code>
           state
          </code>
          中的缓存数据。
         </li>
         <li>
          比如，在一个组件中，我们可以这样获取缓存的菜谱数据：
          <p>
           javascript
          </p>
          <pre><code>import { mapState } from 'vuex';
export default {
  computed: {
   ...mapState(['recipeCache'])
  }
};
</code></pre>
          <br/>
          这使得组件能够方便地获取
          <code>
           recipeCache
          </code>
          中的数据，并根据这些数据进行渲染。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        缓存处理的具体实现与优势
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          减少接口调用次数
         </strong>
         ：
        </p>
        <ul>
         <li>
          最初，每次切换菜谱品类时，都会调用接口获取数据。有了 Vuex 缓存后，在获取数据之前，可以先检查
          <code>
           state
          </code>
          中的
          <code>
           recipeCache
          </code>
          对象是否已经存在对应的品类数据。
         </li>
         <li>
          例如，有一个方法用于获取菜谱数据，改造后的代码可能如下：
          <p>
           javascript
          </p>
          <pre><code>async getRecipeData(categoryIndex) {
  if (this.$store.state.recipeCache[categoryIndex]) {
    return this.$store.state.recipeCache[categoryIndex];
  }
  // 如果缓存中没有数据，则调用接口获取
  const data = await api.getRecipeData(categoryIndex);
  this.$store.commit('setRecipeData', { categoryIndex, data });
  return data;
}
</code></pre>
          <br/>
          这里通过判断
          <code>
           recipeCache
          </code>
          中是否存在数据来决定是否调用接口，从而避免了不必要的接口调用，减少了性能消耗。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          数据共享与一致性
         </strong>
         ：
        </p>
        <ul>
         <li>
          由于 Vuex 的
          <code>
           state
          </code>
          是全局共享的，多个组件可以访问相同的缓存数据。这确保了整个应用中菜谱数据的一致性。
         </li>
         <li>
          比如，左边的菜谱品类组件和右边的菜谱展示组件都可以访问
          <code>
           recipeCache
          </code>
          中的数据。当左边组件切换品类时，右边组件可以直接使用更新后的缓存数据进行渲染，而不需要重新获取数据，保证了数据在不同组件之间的同步和共享。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        引用类型问题及深复制解决方案
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          引用类型在响应式系统中的挑战
         </strong>
         ：
        </p>
        <ul>
         <li>
          在 JavaScript 中，对象和数组是引用数据类型。在 Vue 的响应式系统中，如果只是修改了引用数据类型内部的属性，而没有改变数据的引用地址，Vue 可能无法检测到数据的变化。
         </li>
         <li>
          例如，在
          <code>
           recipeCache
          </code>
          中存储的菜谱数据是一个对象。如果直接修改这个对象的某个属性，像这样：
          <p>
           javascript
          </p>
          <pre><code>this.$store.state.recipeCache[categoryIndex].recipeName = '新菜谱名称';
</code></pre>
          <br/>
          Vue 可能不会触发组件的更新，因为数据的引用地址没有改变。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          深复制的原理与应用
         </strong>
         ：
        </p>
        <ul>
         <li>
          深复制是创建一个全新的对象，它的所有属性和子属性都是原始对象的副本。在
          <code>
           mutation
          </code>
          中进行深复制，可以确保每次更新数据时，数据的引用地址发生变化，从而触发 Vue 的响应式更新。
         </li>
         <li>
          假设我们有一个
          <code>
           mutation
          </code>
          用于更新
          <code>
           recipeCache
          </code>
          中的数据，可能会这样做：
          <p>
           javascript
          </p>
          <pre><code>mutations: {
  setRecipeData(state, { categoryIndex, data }) {
    // 使用深复制库（如lodash的cloneDeep）
    const newData = _.cloneDeep(data);
    state.recipeCache[categoryIndex] = newData;
  }
}
</code></pre>
          <br/>
          通过这种方式，每次更新数据时，都会将全新的数据副本赋值给
          <code>
           recipeCache
          </code>
          ，使得 Vue 能够正确地检测到数据的变化并更新组件。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        缓存清除与生命周期钩子的配合
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          缓存清除的原因
         </strong>
         ：
        </p>
        <ul>
         <li>
          虽然缓存数据可以提高性能，但如果后台数据发生变化，而缓存没有更新，页面将显示旧的数据。因此，需要在适当的时候清除缓存，以便下次访问页面时能够重新获取最新的数据。
         </li>
         <li>
          例如，当用户退出菜谱页面或者在一定条件下（如后台数据更新通知），应该清除
          <code>
           recipeCache
          </code>
          中的数据。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          生命周期钩子的选择
         </strong>
         ：
        </p>
        <ul>
         <li>
          <strong>
           destroyed 生命周期钩子
          </strong>
          ：在组件正常销毁时，
          <code>
           destroyed
          </code>
          钩子会被触发。如果组件没有被
          <code>
           Keep - alive
          </code>
          包裹，这个钩子可以用来清除缓存。例如：
          <p>
           javascript
          </p>
          <pre><code>destroyed() {
  this.$store.commit('clearRecipeCache');
}
</code></pre>
         </li>
         <li>
          <strong>
           deactivated 生命周期钩子
          </strong>
          ：当组件被
          <code>
           Keep - alive
          </code>
          包裹时，组件在切换时不会被销毁，而是会触发
          <code>
           deactivated
          </code>
          钩子。在这种情况下，应该在
          <code>
           deactivated
          </code>
          钩子中清除缓存，以确保数据的及时更新。例如：
          <p>
           javascript
          </p>
          <pre><code>deactivated() {
  this.$store.commit('clearRecipeCache');
}
</code></pre>
          <p>
          </p>
          这里的
          <code>
           clearRecipeCache
          </code>
          是一个
          <code>
           mutation
          </code>
          ，用于清除
          <code>
           recipeCache
          </code>
          中的数据，比如将
          <code>
           recipeCache
          </code>
          对象重置为空对象等操作。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353630303136352f:61727469636c652f64657461696c732f313436323336343733" class_="artid" style="display:none">
 </p>
</div>


