---
layout: post
title: "深入解析Java并发编程与单例模式"
date: 2025-08-28T17:07:34+0800
description: "【JavaEE】调度(四)、锁(二)、线程方法(二)、单例模式：主要探讨并发编程中的调度机制、锁机制及线程方法，并分析单例模式的实现。在调度方面，阐述了随机调度环境下的锁竞争问题；锁机制部分详细介绍了重入锁、连续锁等特性及其优化措施；线程方法章节重点解析wait-notify机制及其在join方法中的应用；最后对比了饿汉式和懒汉式单例模式的实现方式，强调线程安全的重要性。全文围绕并发编程的核心问题展开，为多线程开发提供了实用指导。"
keywords: "深入解析Java并发编程与单例模式"
categories: ['未分类']
tags: ['开发语言', '学习', '单例模式', 'Java', 'Ee']
artid: "150876986"
arturl: "https://blog.csdn.net/2401_86112610/article/details/150876986"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150876986
    alt: "深入解析Java并发编程与单例模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150876986
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150876986
cover: https://bing.ee123.net/img/rand?artid=150876986
image: https://bing.ee123.net/img/rand?artid=150876986
img: https://bing.ee123.net/img/rand?artid=150876986
---



# 深入解析Java并发编程与单例模式



---

## 一、[调度](https://blog.csdn.net/2401_86112610/article/details/149071428?sharetype=blogdetail&sharerId=149071428&sharerefer=PC&sharesource=2401_86112610&spm=1011.2480.3001.8118 "调度")(四)

### 1.随机调度大环境

**随机调度大环境** 里面有 **锁竞争阻塞**，里面又有 **代码块的竞锁能力**

---

## 二、[锁](https://blog.csdn.net/2401_86112610/article/details/150408102?sharetype=blogdetail&sharerId=150408102&sharerefer=PC&sharesource=2401_86112610&spm=1011.2480.3001.8118 "锁")(二)

### 1.位置

锁只在**竞争中 跳跃存在**着

---

### 2.无锁阻塞

**竞争无锁处 被锁阻塞**着

---

### 3.重入锁

线程**重入锁**时 **处运行态**、**其它代码块被锁阻塞 无竞争** 能**高效地获取锁**

---

### 4.连续锁

线程**连续竞同锁** 会因上把锁出时 还**处运行态** 较**其他同锁竞争线程的 阻塞刚唤醒态** **容易连续调度 去竞争到同锁**

#### 4.1措施

可在上把锁 用**wait后移 消除连续调度竞争** 而避免造成 线程饿死

---

## 三、[线程方法](https://blog.csdn.net/2401_86112610/article/details/149494586?sharetype=blogdetail&sharerId=149494586&sharerefer=PC&sharesource=2401_86112610&spm=1011.2480.3001.8118 "线程方法")(二)

### 1.wait

锁的wait方法 对**身竞争代码块** **停位地 封印其竞锁能力**，便也失去了锁，处于**无法参与竞争的 永阻塞状态**

* wait(时间)设置**最长等待时间**后**自动唤醒**

---

### 2.notify

锁的notify方法 对**异竞争代码块 续位地 恢复其竞锁能力**，在**瞬时间内** 处回**可参与竞争的 现阻塞状态**

* notify **随机唤醒一个**此锁wait线程，notifyAll **唤醒所有**此锁wait线程

---

### 3.wait-notify指位后移

锁的wait方法 将**身线程wait后部分 阻塞往后放到 异线程锁noity方法的后面**，应用案例：

#### 3.1可能时再检查

**循环连续的wait阻塞 等着只为每次可能情况时 再notify对接 来唤醒检查一下**，**提高了检查的情况针对性**

##### 3.1.1join(二)

join使**当前线程 执行卡在该方法 直到该线程实例的系统线程死亡 才执行完退出来**，将**当前线程后部分** **阻塞往后放到** **目标系统线程死亡的后面**

###### 3.1.1.1可能时再检查死亡

**系统线程**销毁**死亡**后，对应的**线程实例** 会**自动调用notifyAll**，所以就可以针对**线程实例notify时 才对线程进行死亡检查**：

```
public final synchronized void join(long millis) throws InterruptedException {
    while (this.isAlive()) {
        wait(millis);
    }
}
```

---

## 四、单例模式

### 1.实现

#### 1.1private构造器

**private向外 封闭构造器 无法外部创建实例**

---

#### 1.2一次一个

**内部只创建一次一个**

---

#### 1.3静态存储

**放静态中 外部才可 对类的仅静态取出**

---

### 2.样式

#### 2.1饿汉模式

**必创建地 类加载时就创建实例****:**

```
class SingletonHungry {
    private static SingletonHungry instance = new SingletonHungry();//static静态存储,只有类加载时的创建一次一个
    private SingletonHungry() {}//private封闭构造器
    public static SingletonHungry getInstance() {//封装好获取
        return instance;
    }
}
```

---

#### 2.2懒汉模式

**需要时 才调用接口去创建实例**:

```
class SingletonLazy {
    private static SingletonLazy instance = null;//static静态存储
    private SingletonLazy() {}//private封闭构造器
    public static SingletonLazy getInstance() {
        if (instance == null) { //优化时 线程不加锁能过(只读)情况 就拎开 少加点锁 分开处理掉
            synchronized (SingletonLazy.class) {//写的这块范围内 线程安全问题保障:
                if (instance == null) {//->连续读取instance的null时，两次没有前后影响到 都读为null 都去创建实例
                    instance = new SingletonLazy();
                }
                return instance;
            }
        }
        return instance;
    }
}
```

![](https://i-blog.csdnimg.cn/direct/57e22fdbebf84b1daa7fccea58c82e83.png)



