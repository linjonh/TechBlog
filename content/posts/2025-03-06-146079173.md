---
layout: post
title: "PTA-7-6-列出连通集"
date: 2025-03-06 20:26:32 +0800
description: "给定一个有 n 个顶点和 m 条边的无向图，请用深度优先遍历（DFS）和广度优先遍历（BFS）分别列出其所有的连通集。假设顶点从 0 到 n−1 编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。"
keywords: "pta 7-6 列出连通集"
categories: ['每周练手']
tags: ['算法', '数据结构', '图论']
artid: "146079173"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146079173
    alt: "PTA-7-6-列出连通集"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146079173
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146079173
cover: https://bing.ee123.net/img/rand?artid=146079173
image: https://bing.ee123.net/img/rand?artid=146079173
img: https://bing.ee123.net/img/rand?artid=146079173
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     PTA 7-6 列出连通集
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     题目详情：
    </h2>
    <p>
     给定一个有 n 个顶点和 m 条边的无向图，请用深度优先遍历（DFS）和广度优先遍历（BFS）分别列出其所有的连通集。假设顶点从 0 到 n−1 编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。
    </p>
    <h3 id="输入格式">
     输入格式:
    </h3>
    <p>
     输入第 1 行给出 2 个整数 n (0&lt;n≤10) 和 m，分别是图的顶点数和边数。随后 m 行，每行给出一条边的两个端点。每行中的数字之间用 1 空格分隔。
    </p>
    <h3 id="输出格式">
     输出格式:
    </h3>
    <p>
     按照"{ v1​ v2​ ... vk​ }"的格式，每行输出一个连通集。先输出 DFS 的结果，再输出 BFS 的结果。
    </p>
    <h3 id="输入样例">
     输入样例:
    </h3>
    <pre><code>8 6
0 7
0 1
2 0
4 1
2 4
3 5
</code></pre>
    <h3 id="输出样例">
     输出样例:
    </h3>
    <pre><code>{ 0 1 4 2 7 }
{ 3 5 }
{ 6 }
{ 0 1 2 7 4 }
{ 3 5 }
{ 6 }</code></pre>
    <h2>
     题目解析
    </h2>
    <h3>
     逐步分析
    </h3>
    <p>
     首先，图的表示方式。顶点数n不超过10，可以用邻接表或者邻接矩阵。因为需要按编号递增的顺序访问邻接点，所以邻接表里的每个顶点的邻接点应该按升序排列。或者，在每次访问邻接点的时候，按从小到大的顺序遍历。例如，对于邻接矩阵来说，每个顶点x的所有邻接点，可以按顶点编号从小到大遍历，即从0到n-1依次检查是否有边相连。
    </p>
    <p>
     或者，邻接表的话，每个顶点的邻接点列表需要排序。例如，每次添加边的时候，把邻接点插入到正确的位置，保持列表的升序。或者，在生成邻接表之后，对每个顶点的邻接点列表进行排序。这一步很重要，因为DFS和BFS的遍历顺序必须按照邻接点的编号递增的顺序进行访问。所以，图的存储结构可能需要邻接表或者邻接矩阵，同时要保证遍历邻接点的顺序是递增的。
    </p>
    <p>
     例如，邻接矩阵的话，对于每个顶点，遍历时检查所有顶点，按照编号顺序依次访问是否有边相连。这可能比较方便，特别是当顶点数目较小的时候（n&lt;=10）。这样，在处理每个顶点的时候，只需要从0到n-1遍历，检查是否相连，并且是否未被访问过。这样就能保证按照编号递增的顺序访问邻接点。
    </p>
    <p>
     那邻接矩阵可能更适合这个题目，因为处理顺序容易控制。比如，假设用邻接矩阵存储，那么每个顶点x的邻接点就是所有y满足matrix[x][y]为true，并且y按照从小到大排列。所以在遍历的时候，只需要从0到n-1循环，判断是否是邻接点，并且是否已访问过。
    </p>
    <p>
     所以，邻接矩阵可能更简单。
    </p>
    <p>
     整个流程应该是这样的：对于DFS和BFS各需要处理一次：初始化访问数组，所有顶点未被访问。然后，按照顶点编号从小到大（从0到n-1）的顺序，逐个检查顶点是否被访问。如果未被访问，则从该顶点开始进行DFS或BFS，并将访问到的顶点记录下来，形成一个连通集。这样就能保证每个连通分量都是从其中最小的顶点开始遍历，并且在遍历过程中，邻接点按照编号递增的顺序被访问。
    </p>
    <p>
     大致步骤如下：
    </p>
    <p>
     1. 读取输入n和m。
    </p>
    <p>
     2. 构建邻接矩阵。初始化n×n的二维数组，初始为false。然后读取m条边，将对应的两个顶点之间的边设为true。
    </p>
    <p>
     3. 进行DFS遍历：
    </p>
    <p>
     a. 初始化一个访问数组visited，所有元素初始为false。
    </p>
    <p>
     b. 按照顶点编号从小到大遍历每个顶点i：
    </p>
    <p>
     i. 如果未被访问，则开始DFS遍历，并将结果记录为一个连通集。
    </p>
    <p>
     ii. 在DFS过程中，将访问的顶点按顺序保存，并在结束后输出。
    </p>
    <p>
     4. 进行BFS遍历，同样的逻辑，但使用队列。
    </p>
    <h3>
     推荐代码
    </h3>
    <p>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

void DFS(int v, vector&lt;bool&gt;&amp; visited, const vector&lt;vector&lt;bool&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; component) {
    visited[v] = true;
    component.push_back(v);
    for (int i = 0; i &lt; adj.size(); ++i) {
        if (adj[v][i] &amp;&amp; !visited[i]) {
            DFS(i, visited, adj, component);
        }
    }
}

void BFS(int v, vector&lt;bool&gt;&amp; visited, const vector&lt;vector&lt;bool&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; component) {
    queue&lt;int&gt; q;
    q.push(v);
    visited[v] = true;
    component.push_back(v);
    while (!q.empty()) {
        int current = q.front();
        q.pop();
        for (int i = 0; i &lt; adj.size(); ++i) {
            if (adj[current][i] &amp;&amp; !visited[i]) {
                visited[i] = true;
                component.push_back(i);
                q.push(i);
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;bool&gt;&gt; adj(n, vector&lt;bool&gt;(n, false));
    for (int i = 0; i &lt; m; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u][v] = true;
        adj[v][u] = true;
    }

    // DFS
    vector&lt;bool&gt; visited(n, false);
    for (int i = 0; i &lt; n; ++i) {
        if (!visited[i]) {
            vector&lt;int&gt; component;
            DFS(i, visited, adj, component);
            cout &lt;&lt; "{ ";
            for (int v : component) {
                cout &lt;&lt; v &lt;&lt; " ";
            }
            cout &lt;&lt; "}" &lt;&lt; endl;
        }
    }

    // BFS
    visited.assign(n, false);
    for (int i = 0; i &lt; n; ++i) {
        if (!visited[i]) {
            vector&lt;int&gt; component;
            BFS(i, visited, adj, component);
            cout &lt;&lt; "{ ";
            for (int v : component) {
                cout &lt;&lt; v &lt;&lt; " ";
            }
            cout &lt;&lt; "}" &lt;&lt; endl;
        }
    }

    return 0;
}</code></pre>
    <h2>
     自我实现代码
    </h2>
    <p>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
 
using namespace std;
 
 
int n,m;
int g[15][15];
int vis[15];
vector&lt;int&gt;res;
queue&lt;int&gt;q;
 
void dfs(int x)
{
	res.push_back(x);
	vis[x]=1;
	for(int i=1;i&lt;=n;++i)
	{
		if(g[x][i]==1&amp;&amp;!vis[i])
		{
			vis[i]=1;
			dfs(i);
		}
	}
}
 
void bfs(int x)
{
	res.push_back(x);
	q.push(x);
	vis[x]=1;
	while(!q.empty())
	{
		int xx=q.front();
		q.pop();
		for(int i=1;i&lt;=n;++i)
		{
			if(g[xx][i]==1&amp;&amp;!vis[i])
			{
				res.push_back(i);
				vis[i]=1;
				q.push(i);
			}
		}
	}
	
}
 
 
int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	int a,b;
	for(int i=1;i&lt;=m;++i)
	{
		cin&gt;&gt;a&gt;&gt;b;
		g[a+1][b+1]=1;
		g[b+1][a+1]=1;	
	}
	for(int i=1;i&lt;=n;++i)
	{
		if(!vis[i])
		{
			res.clear();
			dfs(i);
			cout&lt;&lt;"{";
			for(int i=0;i&lt;res.size();++i)
			{
				cout&lt;&lt;" "&lt;&lt;res[i]-1;
			}
			cout&lt;&lt;" }"&lt;&lt;endl;
		}
	}
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=n;++i)
	{
		if(!vis[i])
		{
			while(!q.empty())q.pop();
			res.clear();
			bfs(i);
			cout&lt;&lt;"{";
			for(int i=0;i&lt;res.size();++i)
			{
				cout&lt;&lt;" "&lt;&lt;res[i]-1;
			}
			cout&lt;&lt;" }"&lt;&lt;endl;
			
		}
	}
	
	
	return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333936313433342f:61727469636c652f64657461696c732f313436303739313733" class_="artid" style="display:none">
 </p>
</div>


