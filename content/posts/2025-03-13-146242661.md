---
layout: post
title: "基于C语言的简单HTTP-Web服务器实现-"
date: 2025-03-13 22:13:08 +0800
description: "本案例使用C语言实现了一个简单的HTTP服务器，能够处理客户端的GET请求，并返回静态文件（如HTML、图片等）。Socket编程：基于TCP协议的Socket通信。HTTP协议：HTTP请求和响应的基本格式。多线程：使用多线程处理客户端请求。文件操作：读取本地文件并发送给客户端。MIME类型：根据文件扩展名设置正确的。通过这个案例，我们实现了一个简单的HTTP服务器，支持静态文件的请求和响应。核心知识点包括Socket编程、HTTP协议、多线程和文件操作。"
keywords: "基于C语言的简单HTTP Web服务器实现 "
categories: ['未分类']
tags: ['网络协议', '服务器', 'Http', 'C']
artid: "146242661"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146242661
    alt: "基于C语言的简单HTTP-Web服务器实现-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146242661
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146242661
cover: https://bing.ee123.net/img/rand?artid=146242661
image: https://bing.ee123.net/img/rand?artid=146242661
img: https://bing.ee123.net/img/rand?artid=146242661
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     基于C语言的简单HTTP Web服务器实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     1. 概述
    </h3>
    <p>
     本案例使用C语言实现了一个简单的HTTP服务器，能够处理客户端的GET请求，并返回静态文件（如HTML、图片等）。在此案例中案例，我们主要使用的知识点有：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        Socket编程
       </strong>
       ：基于TCP协议的Socket通信。
      </p>
     </li>
     <li>
      <p>
       <strong>
        HTTP协议
       </strong>
       ：HTTP请求和响应的基本格式。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多线程
       </strong>
       ：使用多线程处理客户端请求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        文件操作
       </strong>
       ：读取本地文件并发送给客户端。
      </p>
     </li>
     <li>
      <p>
       <strong>
        MIME类型
       </strong>
       ：根据文件扩展名设置正确的
       <code>
        Content-Type
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     2. 主要知识点
    </h3>
    <h4>
     2.1 Socket编程
    </h4>
    <p>
     Socket是网络通信的基础，本案例使用Windows下的Socket API（
     <code>
      winsock2.h
     </code>
     ）实现TCP通信。主要函数包括：
    </p>
    <ul>
     <li>
      <p>
       <code>
        WSAStartup
       </code>
       ：初始化Winsock库。
      </p>
     </li>
     <li>
      <p>
       <code>
        socket
       </code>
       ：创建套接字。
      </p>
     </li>
     <li>
      <p>
       <code>
        bind
       </code>
       ：绑定套接字到本地地址和端口。
      </p>
     </li>
     <li>
      <p>
       <code>
        listen
       </code>
       ：监听客户端连接。
      </p>
     </li>
     <li>
      <p>
       <code>
        accept
       </code>
       ：接受客户端连接。
      </p>
     </li>
     <li>
      <p>
       <code>
        send
       </code>
       /
       <code>
        recv
       </code>
       ：发送和接收数据。
      </p>
     </li>
     <li>
      <p>
       <code>
        closesocket
       </code>
       ：关闭套接字。
      </p>
     </li>
    </ul>
    <h4>
     2.2 HTTP协议
    </h4>
    <p>
     HTTP是一种无状态的请求-响应协议。本案例实现了HTTP/1.0的基本功能：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        请求格式
       </strong>
       ：
      </p>
     </li>
     <li>
      <pre><code class="hljs">GET /path HTTP/1.0
Host: 127.0.0.1:8080</code></pre>
      <p>
       <strong>
        响应格式
       </strong>
       ：
      </p>
     </li>
     <li>
      <pre><code class="hljs">HTTP/1.0 200 OK
Content-Type: text/html

&lt;html&gt;...&lt;/html&gt;</code></pre>
      <h4>
       2.3 多线程
      </h4>
      <p>
       为了支持多个客户端同时连接，本案例使用Windows的
       <code>
        CreateThread
       </code>
       函数创建新线程处理每个客户端请求。
      </p>
     </li>
    </ul>
    <h4>
     2.4 文件操作
    </h4>
    <p>
     服务器需要读取本地文件并发送给客户端。本案例使用
     <code>
      fopen
     </code>
     、
     <code>
      fread
     </code>
     等函数操作文件。
    </p>
    <h4>
     2.5 MIME类型
    </h4>
    <p>
     根据文件扩展名设置正确的
     <code>
      Content-Type
     </code>
     ，例如：
    </p>
    <ul>
     <li>
      <p>
       <code>
        .html
       </code>
       -&gt;
       <code>
        text/html
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .jpg
       </code>
       -&gt;
       <code>
        image/jpeg
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .png
       </code>
       -&gt;
       <code>
        image/png
       </code>
      </p>
     </li>
    </ul>
    <h3>
     3. 实现思路
    </h3>
    <h4>
     3.1 服务器启动流程
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        初始化Winsock库
       </strong>
       ：调用
       <code>
        WSAStartup
       </code>
       初始化网络通信。
      </p>
     </li>
     <li>
      <p>
       <strong>
        创建套接字
       </strong>
       ：调用
       <code>
        socket
       </code>
       创建TCP套接字。
      </p>
     </li>
     <li>
      <p>
       <strong>
        绑定地址和端口
       </strong>
       ：调用
       <code>
        bind
       </code>
       绑定套接字到本地地址和端口。
      </p>
     </li>
     <li>
      <p>
       <strong>
        监听连接
       </strong>
       ：调用
       <code>
        listen
       </code>
       开始监听客户端连接。
      </p>
     </li>
     <li>
      <p>
       <strong>
        接受连接
       </strong>
       ：调用
       <code>
        accept
       </code>
       接受客户端连接，并为每个连接创建新线程。
      </p>
     </li>
    </ol>
    <h4>
     3.2 处理客户端请求
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        读取请求行
       </strong>
       ：从客户端读取HTTP请求的第一行，解析请求方法和URL。
      </p>
     </li>
     <li>
      <p>
       <strong>
        解析URL
       </strong>
       ：根据URL确定请求的文件路径。
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查文件是否存在
       </strong>
       ：使用
       <code>
        stat
       </code>
       函数检查文件是否存在。
      </p>
     </li>
     <li>
      <p>
       <strong>
        发送响应头
       </strong>
       ：根据文件类型设置
       <code>
        Content-Type
       </code>
       ，并发送HTTP响应头。
      </p>
     </li>
     <li>
      <p>
       <strong>
        发送文件内容
       </strong>
       ：读取文件内容并发送给客户端。
      </p>
     </li>
    </ol>
    <h4>
     3.3 多线程处理
    </h4>
    <p>
     每个客户端连接由一个独立的线程处理，避免阻塞主线程。
    </p>
    <h3>
     4. 代码细节分析
    </h3>
    <h4>
     4.1 初始化网络和创建套接字
    </h4>
    <pre><code class="hljs">int startup(unsigned short* port) {
    WSADATA wsaData;
    int ret = WSAStartup(MAKEWORD(1, 1), &amp;wsaData);
    if (ret) {
        printf("初始化网络通信失败\n");
        return -1;
    }

    int server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (server_sock == INVALID_SOCKET) {
        error_die("socket()失败");
    }

    // 设置端口复用
    int opt = 1;
    setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, (char*)&amp;opt, sizeof(opt));

    // 绑定地址和端口
    struct sockaddr_in server_addr;
    memset(&amp;server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(*port);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    ret = bind(server_sock, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
    if (ret == SOCKET_ERROR) {
        error_die("bind()失败");
    }

    // 动态分配端口
    if (*port == 0) {
        int len = sizeof(server_addr);
        getsockname(server_sock, (struct sockaddr*)&amp;server_addr, &amp;len);
        *port = ntohs(server_addr.sin_port);
    }

    // 监听连接
    ret = listen(server_sock, 5);
    if (ret == SOCKET_ERROR) {
        error_die("listen()失败");
    }

    return server_sock;
}</code></pre>
    <h4>
     4.2 读取HTTP请求
    </h4>
    <pre><code class="hljs">int get_line(int sock, char* buf, int size) {
    int i = 0;
    char c = 0;
    while (i &lt; size - 1 &amp;&amp; c != '\n') {
        int n = recv(sock, &amp;c, 1, 0);
        if (n &lt;= 0) break;
        if (c == '\r') {
            n = recv(sock, &amp;c, 1, MSG_PEEK);
            if (n &gt; 0 &amp;&amp; c == '\n') recv(sock, &amp;c, 1, 0);
            c = '\n';
        }
        buf[i++] = c;
    }
    buf[i] = '\0';
    return i;
}</code></pre>
    <h4>
     4.3 处理客户端请求
    </h4>
    <pre><code class="hljs">DWORD WINAPI accept_request(LPVOID arg) {
    int client = (SOCKET)arg;
    char buf[1024], method[255], url[255], path[255];
    int numchars = get_line(client, buf, sizeof(buf));

    // 解析请求方法和URL
    sscanf(buf, "%s %s", method, url);

    // 检查请求方法
    if (_stricmp(method, "GET") &amp;&amp; _stricmp(method, "POST")) {
        unimplemented(client);
        return 0;
    }

    // 构造文件路径
    sprintf(path, "htdocs%s", url);
    if (path[strlen(path) - 1] == '/') strcat(path, "index.html");

    // 检查文件是否存在
    struct stat st;
    if (stat(path, &amp;st) == -1) {
        while ((numchars &gt; 0) &amp;&amp; strcmp("\n", buf))
            numchars = get_line(client, buf, sizeof(buf));
        not_found(client);
    } else {
        if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, "/index.html");
        server_file(client, path);
    }

    closesocket(client);
    return 0;
}</code></pre>
    <h4>
     4.4 发送文件内容
    </h4>
    <pre><code class="hljs">void cat(int client_sock, FILE* resource) {
    char buf[4096];
    int count = 0;
    while (1) {
        int ret = fread(buf, sizeof(char), sizeof(buf), resource);
        if (ret &lt;= 0) break;
        send(client_sock, buf, ret, 0);
        count += ret;
    }
    printf("总共发送了%d字节\n", count);
}</code></pre>
    <h3>
     5. 总结
    </h3>
    <p>
     通过这个案例，我们实现了一个简单的HTTP服务器，支持静态文件的请求和响应。核心知识点包括Socket编程、HTTP协议、多线程和文件操作。这个案例是学习网络编程的入门项目，后续可以扩展支持更多功能，如POST请求、动态内容生成等。
    </p>
    <p>
     静态资源的访问位置记得改成自己的，这是我存放的静态资源位置。
    </p>
    <p>
     <img alt="" height="1282" src="https://i-blog.csdnimg.cn/direct/61b69a16967e452c901db18f1b3355d9.png" width="1992"/>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="1088" src="https://i-blog.csdnimg.cn/direct/bc4edbdf2b2142f1b01236963d2547de.png" width="1661"/>
    </p>
    <p>
     如果edge浏览器访问不了可以多刷新几次，或者使用谷歌等其他浏览器。
    </p>
    <p>
     <img alt="" height="1659" src="https://i-blog.csdnimg.cn/direct/4dab76cd38624cb8af23f91c1cf4712d.png" width="2804"/>
    </p>
    <p>
     如果通过路径访问的资源不存在，则返回404信息
    </p>
    <p>
     <img alt="" height="1417" src="https://i-blog.csdnimg.cn/direct/5ee57d26228e4c969d4532dd276a94cc.png" width="2880"/>
    </p>
    <p>
     案例完整代码如下：
    </p>
    <pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS

#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#pragma comment(lib, "ws2_32.lib")

#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/stat.h&gt; //访问文件的属性

#define PRINTF(str) printf("[%s - %d] "#str" = %s\r\n",__func__,__LINE__,str);

#define ISspace(x) isspace((int)(x))

void error_die(const char* msg) {
    // 打印错误信息
    printf("%s\n", msg);
    // 退出程序
    exit(1);
}

// 初始化网络并创建服务端的套接字
int startup(unsigned short* port) {
    // 1. 网络通信初始化
    WSADATA wsaData;
    int ret = WSAStartup(MAKEWORD(1, 1), &amp;wsaData);
    if (ret) {
        printf("初始化网络通信失败\n");
        return -1;
    }

    // 2. 创建服务端的套接字
    int server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (server_sock == INVALID_SOCKET) {
        error_die("socket()失败");
    }

    // 设置端口号可复用
    int opt = 1;
    ret = setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, (char*)&amp;opt, sizeof(opt));
    if (ret == -1) {
        error_die("setsockopt()失败");
    }

    // 配置服务端套接字地址
    struct sockaddr_in server_addr;
    memset(&amp;server_addr, 0, sizeof(struct sockaddr_in)); // 清空结构体
    server_addr.sin_family = AF_INET; // 地址族，这里是IPv4
    server_addr.sin_port = htons(*port); // 端口号
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // IP地址，这里是任意IP

    // 绑定套接字与服务端地址
    ret = bind(server_sock, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr));
    if (ret == SOCKET_ERROR) {
        error_die("bind()失败");
    }

    // 动态分配一个端口号
    if (*port == 0) {
        int len = sizeof(struct sockaddr);
        getsockname(server_sock, (struct sockaddr*)&amp;server_addr, &amp;len);
        *port = ntohs(server_addr.sin_port);
    }

    // 创建监听队列
    ret = listen(server_sock, 5);
    if (ret == SOCKET_ERROR) {
        error_die("listen()失败");
    }

    return server_sock; // 返回server_sock而不是0
}

//返回从套接字读取一行信息，并把数据存入buf中
int get_line(int sock, char* buf, int size) {
    int i = 0;
    int n;
    char c = 0;

    while (i &lt; size - 1 &amp;&amp; c != '\n') {
        n = recv(sock, &amp;c, 1, 0);
        if (n &lt;= 0) {
            // 连接关闭或出错，结束循环
            break;
        }

        if (c == '\r') {
            // 查看下一个字符是否是'\n'
            char next_char;
            n = recv(sock, &amp;next_char, 1, MSG_PEEK);
            if (n &gt; 0 &amp;&amp; next_char == '\n') {
                // 读取并消耗'\n'
                recv(sock, &amp;next_char, 1, 0);
            }
            c = '\n'; // 统一转换为换行符
        }

        buf[i++] = c;

        if (c == '\n') {
            break; // 换行符结束行读取
        }
    }

    buf[i] = '\0'; // 添加字符串终止符
    return i; // 返回读取的字符数（不含终止符）
}

void unimplemented(int client_sock) {
    // 发送501响应
    char buf[1024];

    strcpy(buf, "HTTP/1.0 501 Method Not Implemented\r\n");
    send(client_sock, buf, strlen(buf), 0);

    strcpy(buf, "Server: RockHTTP/0.1 libcurl/7.22.0\r\n");
    send(client_sock, buf, strlen(buf), 0);

    strcpy(buf, "Content-Type: text/html\r\n");
    send(client_sock, buf, strlen(buf), 0);

    strcpy(buf, "\r\n");
    send(client_sock, buf, strlen(buf), 0);

    // 发送501页面
    char unimplemented_html[] = "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;501 Method Not Implemented&lt;/H1&gt;&lt;/BODY&gt;&lt;/HTML&gt;";
    send(client_sock, unimplemented_html, strlen(unimplemented_html), 0);
}

void not_found(int client_sock) {
    // 发送404响应
    char buf[1024];

    strcpy(buf, "HTTP/1.0 404 Not Found\r\n");
    send(client_sock, buf, strlen(buf), 0);

    strcpy(buf, "Server: RockHTTP/0.1 libcurl/7.22.0\r\n");
    send(client_sock, buf, strlen(buf), 0);

    sprintf(buf, "Content-Type: text/html\r\n");
    send(client_sock, buf, strlen(buf), 0);

    strcpy(buf, "\r\n");
    send(client_sock, buf, strlen(buf), 0);

    // 发送404页面
    char not_found_html[] = "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;404 Not Found&lt;/H1&gt;&lt;/BODY&gt;&lt;/HTML&gt;";
    send(client_sock, not_found_html, strlen(not_found_html), 0);
}

const char* get_content_type(const char* path) {
    const char* last_dot = strrchr(path, '.');
    if (last_dot) {
        if (strcmp(last_dot, ".html") == 0 || strcmp(last_dot, ".htm") == 0) {
            return "text/html";
        }
        else if (strcmp(last_dot, ".jpg") == 0 || strcmp(last_dot, ".jpeg") == 0) {
            return "image/jpeg";
        }
        else if (strcmp(last_dot, ".png") == 0) {
            return "image/png";
        }
        else if (strcmp(last_dot, ".gif") == 0) {
            return "image/gif";
        }
        else if (strcmp(last_dot, ".css") == 0) {
            return "text/css";
        }
        else if (strcmp(last_dot, ".js") == 0) {
            return "application/javascript";
        }
    }
    return "text/plain";
}

void headers(int client_sock, const char* path) {
    // 发送HTTP头部                         
    char buf[1024];

    strcpy(buf, "HTTP/1.0 200 OK\r\n");
    send(client_sock, buf, strlen(buf), 0);

    sprintf(buf, "Content-Type: %s\r\n", get_content_type(path));
    send(client_sock, buf, strlen(buf), 0);

    strcpy(buf, "\r\n");
    send(client_sock, buf, strlen(buf), 0);
}

void cat(int client_sock, FILE* resource) {
    char buf[4096];
    int count = 0;

    while (1) {
        int ret = fread(buf, sizeof(char), sizeof(buf), resource);
        if (ret &lt;= 0) {
            break;
        }
        send(client_sock, buf, ret, 0);
        count += ret;
    }

    printf("总共发送了%d字节\n", count);
}

void server_file(int client_sock, const char* fileName) {
    char numchars = 1;
    char buf[1024];

    // 将请求包剩余数据读完，直到遇到换行符
    while (numchars &gt; 0 &amp;&amp; strcmp(buf, "\n")) {
        numchars = get_line(client_sock, buf, sizeof(buf));
        PRINTF(buf);
    }

    // 发送文件内容
    FILE* resource = fopen(fileName, "rb"); // 以二进制模式打开文件
    if (resource == NULL) {
        printf("文件打开失败\n");
        not_found(client_sock);
    }
    else {
        // 返回数据给浏览器
        headers(client_sock, fileName);

        // 发送请求的资源
        cat(client_sock, resource);

        printf("资源发送完毕\n");
    }

    fclose(resource);
}

// 处理客户端的连接请求 
DWORD WINAPI accept_request(LPVOID arg) {
    char buf[1024];
    int numchars;
    char method[255];
    char url[255];
    char path[255];
    size_t i, j;

    struct stat st;
    int cgi = 0;

    int client = (SOCKET)arg;

    // 读取一行信息
    numchars = get_line(client, buf, sizeof(buf));
    printf("read %d bytes of data from client\n", numchars);
    PRINTF(buf);

    char* query_string = NULL;

    i = 0; j = 0;
    while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(method) - 1)) {
        method[i] = buf[j];
        i++;
        j++;
    }
    method[i] = 0;  // 解析后， method的值："GET"或者"POST"
    PRINTF(method);

    // 判断是否为GET或POST请求
    if (_stricmp(method, "GET") &amp;&amp; _stricmp(method, "POST")) {
        unimplemented(client);
        return 0;
    }

    // 判断是否为CGI请求
    if (_stricmp(method, "POST") == 0)
        cgi = 1;

    // 解析URL，获得资源路径
    i = 0;
    while (ISspace(buf[j]) &amp;&amp; (j &lt; sizeof(buf))) // 跳过buff中的空格
        j++;
    while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; sizeof(buf))) // 获得资源url 比如 / 或者 /images/head.png
    {
        url[i] = buf[j];
        i++; j++;
    }
    url[i] = '\0';
    PRINTF(url);

    sprintf(path, "htdocs%s", url);
    if (path[strlen(path) - 1] == '/')
        strcat(path, "index.html"); // 如果路径以"/"结尾，则认为是目录，拼接上默认的HTML文件名
    PRINTF(path);

    struct stat status;

    // 检查访问的资源是否存在
    if (stat(path, &amp;st) == -1) {  // stat获取指定文件的属性信息
        // 如果不能访问它的属性信息，那么这个文件就不存在
        // 此时，就需要把这个请求报文，读完！虽然已经没有用了，但是也要把这个报文读完
        while ((numchars &gt; 0) &amp;&amp; strcmp("\n", buf))  /* read &amp; discard headers */
            numchars = get_line(client, buf, sizeof(buf));
        not_found(client);
    }
    else {
        // 如果浏览器的地址输入：http://127.0.0.1:8000/movies 
        // 如果movies是目录，就默认访问这个目录下的index.html
        if ((st.st_mode &amp; S_IFMT) == S_IFDIR)
            strcat(path, "/index.html");

        server_file(client, path);
    }

    closesocket(client);
    return 0;
}

int main() {
    // httpd默认的端口是80，这里指定了8000端口，也可以使用其它端口
    unsigned short port = 8080;

    // 初始化网络，并使用指定端口来创建服务端的套接字
    int server_sock = startup(&amp;port);
    printf("httpd running on port %d\n", port);

    while (1) {
        // 等待客户端的连接
        struct sockaddr_in client_addr;
        int client_len = sizeof(struct sockaddr);

        // 阻塞式等待客户端的连接
        int client_sock = accept(server_sock, (struct sockaddr*)&amp;client_addr, &amp;client_len);
        if (client_sock == -1) {
            error_die("accept"); // 打印错误信息并结束
        }

        // 创建一个线程来处理客户端请求
        DWORD threadId = 0;

        HANDLE handleFirst = CreateThread(NULL, 0, accept_request, (void*)client_sock, 0, &amp;threadId);
        if (handleFirst == NULL) {
            error_die("CreateThread()失败");
        }
    }

    return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7a62743839383234313839352f:61727469636c652f64657461696c732f313436323432363631" class_="artid" style="display:none">
 </p>
</div>


