---
layout: post
title: "数据结构单调栈"
date: 2025-03-03 22:23:37 +0800
description: "超级简单的单调栈，都是模板题，加例题《发射塔》"
keywords: "数据结构——单调栈"
categories: ['未分类']
tags: ['算法', '数据结构', '开发语言', 'C']
artid: "145999883"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145999883
    alt: "数据结构单调栈"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145999883
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145999883
cover: https://bing.ee123.net/img/rand?artid=145999883
image: https://bing.ee123.net/img/rand?artid=145999883
img: https://bing.ee123.net/img/rand?artid=145999883
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——单调栈
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一.单调栈简介
    </h3>
    <h4>
     1.1单调栈定义与特性
    </h4>
    <blockquote>
     <ul>
      <li>
       <strong>
        本质
       </strong>
       ：单调栈是一种特殊的栈结构，其内部元素始终保持
       <strong>
        单调递增
       </strong>
       或
       <strong>
        单调递减
       </strong>
       的顺序。
      </li>
      <li>
       <strong>
        核心规则
       </strong>
       ：当新元素入栈时，会通过
       <strong>
        弹出破坏单调性的栈顶元素
       </strong>
       来维持有序性。
      </li>
      <li>
       <strong>
        单调方向
       </strong>
       ：
       <ul>
        <li>
         <strong>
          单调递增栈
         </strong>
         ：从栈底到栈顶，元素逐渐变大（例如 [1,3,5,7][1,3,5,7]）。
        </li>
        <li>
         <strong>
          单调递减栈
         </strong>
         ：从栈底到栈顶，元素逐渐变小（例如 [9,6,2,1][9,6,2,1]）。
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h4>
     1.2
     <strong>
      应用场景
     </strong>
    </h4>
    <p>
     单调栈擅长解决
     <strong>
      “边界查找”问题，即快速找到数组中某个元素
     </strong>
     左侧或右侧
     <strong>
      第一个比它大（或小）
     </strong>
     的元素
    </p>
    <h4>
     <strong>
      1.3时间复杂度
     </strong>
    </h4>
    <blockquote>
     <p>
      通过一次遍历
      <strong>
       O(n)即可解决问题
      </strong>
      ，而暴力解法通常需要
      <strong>
       O(n²)
      </strong>
      。
     </p>
    </blockquote>
    <h4>
     1.4.
     <strong>
      原理
     </strong>
    </h4>
    <p>
     <strong>
      例如：使用 10 3 7 4 12 构造一个单调递增栈。
     </strong>
    </p>
    <p>
     <img alt="" height="138" src="https://i-blog.csdnimg.cn/direct/b9c4fb535e5242c7815204dc36a69814.png" width="298"/>
    </p>
    <p>
     <img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/e376b84683aa4310a45444460b5900ee.png" width="295"/>
    </p>
    <p>
     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/73f401555a72401fa30db7a050825973.png" width="292"/>
    </p>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/42581dc7243347218cfa69a0dc4155f4.png" width="291"/>
    </p>
    <h3>
     <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/fbf7bf62bc624b3480b79d8ea491d2d5.png" width="295">
      <br/>
      <br/>
      二.例题《发射站》
     </img>
    </h3>
    <h4>
     2.1题目描述
    </h4>
    <p>
     <img alt="" height="972" src="https://i-blog.csdnimg.cn/direct/c1616969841d4cfc828c2ad29c5f81d7.png" width="902"/>
    </p>
    <h4>
     2.2思路
    </h4>
    <p>
     只要求出
     <strong>
      每个发射站 i 接收到的能量总和 tot[i]
     </strong>
     ，就能求出
     <strong>
      最大值
     </strong>
     了。
     <br/>
     <strong>
      每个单调栈向左右两个方向发射的能量，
      <span style="color:#fe2c24">
       只会分别最多被一个发射站
      </span>
      接收
     </strong>
     <br/>
     因此可以考虑求出
     <strong>
      每个发射站发射的能量被谁接收
     </strong>
     ，这样就能统计
     <strong>
      tot 数组
     </strong>
     了。
     <br/>
     这个
     <strong>
      过程分两步
     </strong>
     进行：
    </p>
    <p>
     求出
     <strong>
      每个发射站向左发射的能量被谁接收
     </strong>
     <br/>
     求出
     <strong>
      每个发射站向右发射的能量被谁接收
     </strong>
    </p>
    <p>
     <strong>
      每个发射站向左发射的能量被谁接收
     </strong>
     ：
     <br/>
     也就是
     <span style="color:#fe2c24">
      <strong>
       左边第一个大于当前值的位置
      </strong>
     </span>
    </p>
    <p>
     <strong>
      维护一个从栈底到栈顶单调递减的单调栈
     </strong>
     ，从前往后
     <strong>
      枚举每个放射站并将其高度插入到
      <br/>
      单调栈中
     </strong>
     。
    </p>
    <p>
     可以发现，在将
     <strong>
      栈顶所有比 i 的高度小的发射站出栈之后（参考单调栈的插入操作），
      <br/>
      新的栈顶就是
      <span style="color:#fe2c24">
       接收 i 向左发射的能量的发射站。
      </span>
     </strong>
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       在维护单调栈的过程中，有些发射站在维护单调性的过程中被出栈了
       <br/>
       这些被出栈的发射站是否会接收到 i 后面的发射站发来的能量？
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       不会
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       ，因为 h[i]已经比这些发射站要高了，
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       所以 i 之后的发射站发来的能量就算这些发射站高度符合，也会被 i 挡住，因为 i 也一定符合高度要求
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       。
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       如何求出每个发射站向右发射的能量被谁接收？
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       倒序枚举发射站 n~1，同样维护一个栈底到栈顶单调递减的栈
      </strong>
     </span>
    </p>
    <h4>
     2.3AC代码
    </h4>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,a[1000005],v[1000005],ans[1000005],maxx;
stack&lt;int&gt; st,tmp;
int main(){
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i]&gt;&gt;v[i];
    }
    for(int i=1;i&lt;=n;i++){
        while(!st.empty()&amp;&amp;a[st.top()]&lt;=a[i]){
            st.pop();
        }
        if(!st.empty()&amp;&amp;a[st.top()]&gt;a[i]){
            ans[st.top()]+=v[i];
        }
        st.push(i);
    }
    st=tmp;
    for(int i=n;i&gt;=1;i--){
        while(!st.empty()&amp;&amp;a[st.top()]&lt;=a[i]){
            st.pop();
        }
        if(!st.empty()&amp;&amp;a[st.top()]&gt;a[i]){
            ans[st.top()]+=v[i];
        }
        st.push(i);
    }
    for(int i=1;i&lt;=n;i++){
        if(maxx&lt;ans[i]){
            maxx=ans[i];
        }
    }
    cout&lt;&lt;maxx;
    return 0;
}</code></pre>
    <h4>
     2.4AC代码(2)
    </h4>
    <p>
     如果我们
     <strong>
      一次单调栈操作
     </strong>
     ，
     <strong>
      直接
      <span style="color:#fe2c24">
       维护两个信息
      </span>
     </strong>
     呢？
    </p>
    <p>
     得到：
    </p>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,a[1000005],v[1000005],ans[1000005],maxx;
stack&lt;int&gt; st;
int main(){
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i]&gt;&gt;v[i];
    }
    for(int i=1;i&lt;=n;i++){
        while(!st.empty()&amp;&amp;a[st.top()]&lt;=a[i]){
            ans[i]+=v[st.top()];
            st.pop();
        }
        if(!st.empty()){
            ans[st.top()]+=v[i];
        }
        st.push(i);
    }
    for(int i=1;i&lt;=n;i++){
        if(maxx&lt;ans[i]){
            maxx=ans[i];
        }
    }
    cout&lt;&lt;maxx;
    return 0;
}</code></pre>
    <h2>
     加纳！！！！！！！！！
    </h2>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37373537323335332f:61727469636c652f64657461696c732f313435393939383833" class_="artid" style="display:none">
 </p>
</div>


