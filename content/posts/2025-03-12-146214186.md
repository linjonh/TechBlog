---
layout: post
title: "反射机制的理解"
date: 2025-03-12 20:29:37 +0800
description: "反射（Reflection）是 Java 在运行时动态获取类信息并操作类的能力，包括：动态加载类创建对象调用方法访问私有成员。"
keywords: "反射机制的理解"
categories: ['好记性不如烂笔头']
tags: ['Java']
artid: "146214186"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146214186
    alt: "反射机制的理解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146214186
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146214186
cover: https://bing.ee123.net/img/rand?artid=146214186
image: https://bing.ee123.net/img/rand?artid=146214186
img: https://bing.ee123.net/img/rand?artid=146214186
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     反射机制的理解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h6>
     <strong>
      一、
      <code>
       getName
      </code>
      方法解析
     </strong>
    </h6>
    <h6>
     代码功能
    </h6>
    <pre>public static String getName(String key) throws IOException {
    Properties properties = new Properties();
    FileInputStream in = new FileInputStream("D:\\路径...\\application.properties");
    properties.load(in); // 加载配置文件内容
    in.close(); // 关闭流
    return properties.getProperty(key); // 根据 key 返回对应的值
}</pre>
    <h6>
     <strong>
      作用
     </strong>
     ：
    </h6>
    <p>
     从
     <code>
      application.properties
     </code>
     配置文件中读取指定
     <code>
      key
     </code>
     的值（如
     <code>
      className
     </code>
     或
     <code>
      methodName
     </code>
     ）。
    </p>
    <h6>
     配置文件示例
    </h6>
    <p>
     假设
     <code>
      application.properties
     </code>
     内容如下：
    </p>
    <pre># 定义要反射的类名和方法名
className=com.example.TestInvoke
methodName=printMessage</pre>
    <h6>
     执行过程
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        加载文件
       </strong>
       ：通过
       <code>
        FileInputStream
       </code>
       读取指定路径的配置文件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        解析配置
       </strong>
       ：
       <code>
        Properties.load()
       </code>
       方法将文件内容解析为键值对。
      </p>
     </li>
     <li>
      <p>
       <strong>
        获取值
       </strong>
       ：
       <code>
        properties.getProperty("className")
       </code>
       返回
       <code>
        "com.example.TestInvoke"
       </code>
       。
      </p>
     </li>
    </ol>
    <h6>
     代码问题
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        硬编码路径
       </strong>
       ：
       <code>
        D:\\路径...
       </code>
       是绝对路径，实际项目应使用相对路径或类路径加载。
      </p>
     </li>
     <li>
      <p>
       <strong>
        资源未安全关闭
       </strong>
       ：若
       <code>
        load()
       </code>
       抛出异常，
       <code>
        in.close()
       </code>
       可能不会执行，建议用
       <code>
        try-with-resources
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        异常处理简单
       </strong>
       ：直接抛出
       <code>
        IOException
       </code>
       ，未处理文件不存在等具体问题。
      </p>
     </li>
    </ol>
    <h6>
     改进版本
    </h6>
    <pre>public static String getName(String key) {
    // 使用类路径加载（文件需放在 resources 目录下）
    try (InputStream in = YourClass.class.getClassLoader().getResourceAsStream("application.properties")) {
        Properties properties = new Properties();
        properties.load(in);
        return properties.getProperty(key);
    } catch (IOException e) {
        throw new RuntimeException("加载配置文件失败", e);
    }
}</pre>
    <hr/>
    <h6>
     <strong>
      二、反射机制详解
     </strong>
    </h6>
    <h6>
     什么是反射？
    </h6>
    <p>
     反射（Reflection）是 Java 在
     <strong>
      运行时
     </strong>
     动态获取类信息并操作类的能力，包括：
    </p>
    <ul>
     <li>
      <p>
       动态加载类
      </p>
     </li>
     <li>
      <p>
       创建对象
      </p>
     </li>
     <li>
      <p>
       调用方法
      </p>
     </li>
     <li>
      <p>
       访问私有成员
      </p>
     </li>
    </ul>
    <h6>
     为什么需要反射？
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        解耦
       </strong>
       ：代码不直接依赖具体类（如通过配置文件指定类名）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        灵活性
       </strong>
       ：框架中自动装配对象（如 Spring 的
       <code>
        @Autowired
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        通用工具
       </strong>
       ：如 JSON 序列化、单元测试调用私有方法。
      </p>
     </li>
    </ol>
    <hr/>
    <h6>
     <strong>
      三、结合代码理解反射流程
     </strong>
    </h6>
    <h6>
     完整流程
    </h6>
    <pre>1. 读取配置文件 → 2. 获取类名和方法名 → 3. 反射加载类 → 4. 创建对象 → 5. 调用方法</pre>
    <h6>
     分步解析
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        读取配置
       </strong>
       通过
       <code>
        getName("className")
       </code>
       获取
       <code>
        "com.example.TestInvoke"
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        加载类
       </strong>
      </p>
      <pre>Class&lt;?&gt; c = Class.forName("com.example.TestInvoke");</pre>
      <ul>
       <li>
        <p>
         JVM 动态加载该类到内存（如果尚未加载）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        创建实例
       </strong>
      </p>
      <pre>TestInvoke obj = (TestInvoke) c.newInstance();</pre>
      <ul>
       <li>
        <p>
         相当于执行
         <code>
          new TestInvoke()
         </code>
         （要求类有无参构造方法）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        获取并调用方法
       </strong>
      </p>
      <pre>Method method = c.getDeclaredMethod("printMessage");
method.invoke(obj);</pre>
      <ul>
       <li>
        <p>
         即使
         <code>
          printMessage
         </code>
         是私有方法，
         <code>
          setAccessible(true)
         </code>
         后仍可调用。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h6>
     <strong>
      四、反射核心 API
     </strong>
    </h6>
    <table>
     <thead>
      <tr>
       <th>
        操作
       </th>
       <th>
        API 示例
       </th>
       <th>
        作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        加载类
       </td>
       <td>
        <code>
         Class.forName("全限定类名")
        </code>
       </td>
       <td>
        获取类的 Class 对象
       </td>
      </tr>
      <tr>
       <td>
        创建实例
       </td>
       <td>
        <code>
         clazz.newInstance()
        </code>
        或
        <code>
         clazz.getConstructor().newInstance()
        </code>
       </td>
       <td>
        实例化对象
       </td>
      </tr>
      <tr>
       <td>
        获取方法
       </td>
       <td>
        <code>
         clazz.getMethod("方法名", 参数类型...)
        </code>
       </td>
       <td>
        获取公开方法
       </td>
      </tr>
      <tr>
       <td>
        获取私有方法
       </td>
       <td>
        <code>
         clazz.getDeclaredMethod("方法名")
        </code>
        +
        <code>
         setAccessible(true)
        </code>
       </td>
       <td>
        访问私有方法
       </td>
      </tr>
      <tr>
       <td>
        调用方法
       </td>
       <td>
        <code>
         method.invoke(实例对象, 参数...)
        </code>
       </td>
       <td>
        执行方法
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h6>
     <strong>
      五、示例：从配置到反射的完整过程
     </strong>
    </h6>
    <h6>
     1. 配置文件
     <code>
      application.properties
     </code>
    </h6>
    <pre>className=com.example.UserService
methodName=login</pre>
    <h6>
     2. 目标类
     <code>
      UserService
     </code>
    </h6>
    <pre>package com.example;
​
public class UserService {
    private void login() {
        System.out.println("用户登录成功！");
    }
}</pre>
    <h6>
     3. 反射调用代码
    </h6>
    <pre>public static void main(String[] args) {
    try {
        // 从配置读取类名和方法名
        String className = getName("className"); // "com.example.UserService"
        String methodName = getName("methodName"); // "login"
​
        // 反射操作
        Class&lt;?&gt; clazz = Class.forName(className);
        Method method = clazz.getDeclaredMethod(methodName);
        method.setAccessible(true);
        Object instance = clazz.getDeclaredConstructor().newInstance();
        method.invoke(instance); // 输出："用户登录成功！"
    } catch (Exception e) {
        e.printStackTrace();
    }
}</pre>
    <hr/>
    <h6>
     <strong>
      六、反射的注意事项
     </strong>
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        性能开销
       </strong>
       ：反射比直接调用慢，频繁调用需谨慎。
      </p>
     </li>
     <li>
      <p>
       <strong>
        安全限制
       </strong>
       ：模块化系统中（Java 9+）可能禁止访问私有成员。
      </p>
     </li>
     <li>
      <p>
       <strong>
        破坏封装
       </strong>
       ：反射可以绕过访问修饰符，滥用会导致代码难以维护。
      </p>
     </li>
     <li>
      <p>
       <strong>
        类型安全
       </strong>
       ：编译时无法检测类型错误，需自行保证类型正确性。
      </p>
     </li>
    </ol>
    <hr/>
    <h6>
     <strong>
      七、常见应用场景
     </strong>
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        框架开发
       </strong>
       ：如 Spring 的依赖注入、MyBatis 的 Mapper 动态代理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        动态加载插件
       </strong>
       ：通过配置文件指定实现类。
      </p>
     </li>
     <li>
      <p>
       <strong>
        单元测试
       </strong>
       ：测试私有方法（不推荐，但有时必要）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        通用工具
       </strong>
       ：如通过反射实现对象拷贝、序列化工具。
      </p>
     </li>
    </ol>
    <hr/>
    <h6>
     <strong>
      总结
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       通过
       <strong>
        配置文件
       </strong>
       解耦了类名和方法名的硬编码，利用
       <strong>
        反射
       </strong>
       实现了动态调用。
      </p>
     </li>
     <li>
      <p>
       反射是 Java 强大的特性，但需谨慎使用。理解其原理后，可以更深入掌握框架设计思想（如 Spring 的核心机制）。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343035303433382f:61727469636c652f64657461696c732f313436323134313836" class_="artid" style="display:none">
 </p>
</div>


