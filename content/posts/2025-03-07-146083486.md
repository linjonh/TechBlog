---
layout: post
title: "SpringBoot实战三十五微服务集成OAuth2.0UAA"
date: 2025-03-07 00:27:01 +0800
description: "SpringBoot实战（三十五）微服务集成OAuth2.0（UAA）"
keywords: "springboot 集成 oauth2.0"
categories: ['Springboot']
tags: ['微服务', '后端', 'Spring', 'Boot']
artid: "146083486"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146083486
    alt: "SpringBoot实战三十五微服务集成OAuth2.0UAA"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146083486
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146083486
cover: https://bing.ee123.net/img/rand?artid=146083486
image: https://bing.ee123.net/img/rand?artid=146083486
img: https://bing.ee123.net/img/rand?artid=146083486
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringBoot实战（三十五）微服务集成OAuth2.0（UAA）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <img src="https://i-blog.csdnimg.cn/direct/65a48c0c3e9a4e319327d1660b5498a6.jpeg" width="60%">
     <h3>
      <a id="_6">
      </a>
      一、知识回顾
     </h3>
     <p>
      在进行微服务集成前，我们先来回顾一下 OAuth2.0 的基础知识。
     </p>
     <h4>
      <a id="11__OAuth2__10">
      </a>
      1.1 什么是 OAuth2 协议？
     </h4>
     <p>
      <code>
       OAuth2（Open Authorization 2.0）
      </code>
      协议是
      <a href="https://datatracker.ietf.org/doc/html/rfc6749" rel="nofollow">
       RFC 6749 文件
      </a>
      ，是一种
      <strong>
       用于授权的开放标准协议
      </strong>
      ，用于通过第三方应用程序访问用户在某个服务提供商上存储的资源，而无需共享用户的凭证（例如用户名和密码）。
     </p>
     <blockquote>
      <p>
       OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。…资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。
      </p>
     </blockquote>
     <p>
      OAuth2.0 的运行流程如下图所示：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f30e8850e0d6437f9c8eaf614a3f1e2a.jpeg"/>
     </p>
     <p>
      （A）用户打开客户端以后，客户端要求用户给予授权。
      <br/>
      （B）用户同意给予客户端授权。
      <br/>
      （C）客户端使用上一步获得的授权，向认证服务器申请令牌。
      <br/>
      （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
      <br/>
      （E）客户端使用令牌，向资源服务器申请获取资源。
      <br/>
      （F）资源服务器确认令牌无误，同意向客户端开放资源。
     </p>
     <blockquote>
      <p>
       简而言之：你要获取我（资源服务器）的资源的话，得先找他（授权服务器）授权。
      </p>
     </blockquote>
     <h4>
      <a id="12_OAuth2_4_30">
      </a>
      1.2 OAuth2 的4个角色
     </h4>
     <p>
      OAuth2.0 认证过程中，涉及到的四个角色如下 ：
     </p>
     <ul>
      <li>
       <code>
        客户端（Client）
       </code>
       ：代表资源所有者与授权服务器进行交互的应用程序。可以是Web应用程序、移动应用程序或第三方服务。
      </li>
      <li>
       <code>
        资源所有者（Resource Owner）
       </code>
       ：即用户或系统的代表，拥有受保护资源的所有权。
      </li>
      <li>
       <code>
        授权服务器（Authorization Server）
       </code>
       ：负责验证资源所有者的身份并颁发访问令牌（Access Token）给客户端。它通常是一个独立的服务器，可以与资源服务器分离或合并。
      </li>
      <li>
       <code>
        资源服务器（Resource Server）
       </code>
       ：存储受保护的资源，并根据令牌的有效性进行访问控制。资源服务器可以是一个或多个服务，可以授权服务器分离或合并。
      </li>
     </ul>
     <h4>
      <a id="13_OAuth2_3_39">
      </a>
      1.3 OAuth2 的3种令牌
     </h4>
     <ul>
      <li>
       <strong>
        授权许可（Authorization Grant）
       </strong>
       ：资源所有者授权客户端访问受保护资源的凭证，如：授权码、隐式授权、密码授权、客户端凭证等。
      </li>
      <li>
       <strong>
        令牌（Access Token）
       </strong>
       ：用于标识授权许可的凭证，包括访问令牌、刷新令牌和身份令牌等。
      </li>
      <li>
       <strong>
        令牌端点（Token Endpoint）
       </strong>
       ：客户端与授权服务器交互以获取或刷新令牌的API端点。
      </li>
     </ul>
     <h4>
      <a id="14_OAuth2_5_45">
      </a>
      1.4 OAuth2 的5种认证方式
     </h4>
     <p>
      OAuth2.0 提供了五种认证方式：
     </p>
     <table>
      <thead>
       <tr>
        <th align="left">
         授权类型
        </th>
        <th align="left">
         <code>
          grant_type
         </code>
         值
        </th>
        <th align="left">
         适用场景
        </th>
        <th align="left">
         安全性
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td align="left">
         <strong>
          授权码模式
         </strong>
        </td>
        <td align="left">
         <code>
          authorization_code
         </code>
        </td>
        <td align="left">
         有后端的 Web 应用
        </td>
        <td align="left">
         高
        </td>
       </tr>
       <tr>
        <td align="left">
         <strong>
          简化模式
         </strong>
        </td>
        <td align="left">
         <code>
          implicit
         </code>
        </td>
        <td align="left">
         纯前端应用（如 SPA）
        </td>
        <td align="left">
         中
        </td>
       </tr>
       <tr>
        <td align="left">
         <strong>
          密码模式
         </strong>
        </td>
        <td align="left">
         <code>
          password
         </code>
        </td>
        <td align="left">
         高度信任的客户端（如第一方应用）
        </td>
        <td align="left">
         低
        </td>
       </tr>
       <tr>
        <td align="left">
         <strong>
          客户端凭证模式
         </strong>
        </td>
        <td align="left">
         <code>
          client_credentials
         </code>
        </td>
        <td align="left">
         客户端访问自己的资源（M2M）
        </td>
        <td align="left">
         中
        </td>
       </tr>
       <tr>
        <td align="left">
         <strong>
          刷新令牌模式
         </strong>
        </td>
        <td align="left">
         <code>
          refresh_token
         </code>
        </td>
        <td align="left">
         获取新的访问令牌
        </td>
        <td align="left">
         高
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      这里我们举例的是
      <code>
       授权码模式
      </code>
      ，篇幅有限，没有集成数据库。如果需要支持其他模式，需要对
      <code>
       AuthorizationConfig.java
      </code>
      中的内容进行改造。
     </p>
     <h4>
      <a id="15_OAuth2__59">
      </a>
      1.5 OAuth2 内置接口地址
     </h4>
     <p>
      OAuth2.0 内置了6个接口地址，如下所示：
     </p>
     <ul>
      <li>
       <strong>
        /oauth/authorize
       </strong>
       ：授权端点（核心）
      </li>
      <li>
       <strong>
        /oauth/token
       </strong>
       ：获取令牌端点（核心）
      </li>
      <li>
       /oauth/confirm_access：用户确认授权提交端点
      </li>
      <li>
       /oauth/error：授权服务错误信息端点
      </li>
      <li>
       /oauth/check_token：用于资源服务访问的令牌解析端点
      </li>
      <li>
       /oauth/token_key：提供公有密匙的端点，如果你使用JWT令牌的话
      </li>
     </ul>
     <hr/>
     <h3>
      <a id="UAA_72">
      </a>
      二、UAA介绍
     </h3>
     <ul>
      <li>
       <strong>
        官方文档：
       </strong>
       <a href="https://docs.spring.io/spring-cloud-dataflow-samples/docs/current/reference/html/_security.html" rel="nofollow">
        https://docs.spring.io/spring-cloud-dataflow-samples/docs/current/reference/html/_security.html
       </a>
      </li>
     </ul>
     <h4>
      <a id="21__76">
      </a>
      2.1 概述
     </h4>
     <p>
      <code>
       UAA(User Account and Authentication)
      </code>
      是 Cloud Foundry 提供的一个用户账户和认证服务，
      <strong>
       主要用于管理用户的身份验证和授权
      </strong>
      。UAA 支持多种认证机制，包括 Oauth2.0、OpenID Connect 等，能够为应用程序提供安全的用户管理和访问控制功能。UAA 的
      <strong>
       核心功能是为用户提供统一的身份验证服务
      </strong>
      ，并确保只有经过授权的用户才能访问特定的资源。
     </p>
     <h4>
      <a id="22_UAA_80">
      </a>
      2.2 UAA的主要功能
     </h4>
     <p>
      UAA 的主要功能如下：
     </p>
     <ol>
      <li>
       <strong>
        用户管理
       </strong>
       ：UAA 允许管理员创建、管理和删除用户账户。用户可以通过用户名和密码进行登录，也可以通过其他身份提供者（如 LDAP、SAML 等）进行身份验证。
      </li>
      <li>
       <strong>
        OAuth2.0支持
       </strong>
       ：UAA 实现了 OAuth2 协议，允许应用程序通过 OAuth2 进行授权和认证。OAuth2 是一种广泛使用的授权框架，允许用户授权第三方应用访问其资源，而无需共享其凭据。
      </li>
      <li>
       <strong>
        OpenID Connect支持
       </strong>
       ：UAA 还支持 OpenID Connect，这是一种基于 OAuth2 的身份验证协议，允许应用程序验证用户的身份并获取用户的基本信息。
      </li>
      <li>
       <strong>
        多租户支持
       </strong>
       ：UAA 支持多租户架构，允许不同的组织或团队在同一 UAA 实例中管理各自的用户和权限。
      </li>
      <li>
       <strong>
        LDAP 集成
       </strong>
       ：UAA 可以与 LDAP（轻量级目录访问协议）集成，允许企业使用现有的 LDAP 目录服务进行用户认证。通过 LDAP 集成，UAA 可以从 LDAP 服务器中获取用户信息，并将其映射到 UAA 中的用户角色和权限。
      </li>
     </ol>
     <h4>
      <a id="23_UAA__90">
      </a>
      2.3 UAA 的应用场景
     </h4>
     <p>
      UAA 广泛应用于需要用户认证和授权的场景，特别是在微服务架构中。通过 UAA，开发者可以轻松地为多个微服务提供统一的身份验证和授权机制，而不需要每个服务都实现自己的认证逻辑。
     </p>
     <p>
      在
      <code>
       Spring Cloud Data Flow
      </code>
      中，UAA 被用于保护数据流和任务的管理接口。通过 UAA，管理员可以控制哪些用户可以创建、部署和管理数据流和任务。UAA 还可以与 LDAP 集成，使得企业可以使用现有的 LDAP 目录服务来管理用户权限。
     </p>
     <hr/>
     <h3>
      <a id="_98">
      </a>
      三、微服务集成
     </h3>
     <blockquote>
      <p>
       <strong>
        代码地址：
       </strong>
       <a href="https://gitee.com/acgkaka/SpringBootExamples/tree/master/springboot-mybatis-plus-oauth2.0" rel="nofollow">
        https://gitee.com/acgkaka/SpringBootExamples/tree/master/springboot-mybatis-plus-oauth2.0
       </a>
      </p>
     </blockquote>
     <h4>
      <a id="31__102">
      </a>
      3.1 集成示例介绍
     </h4>
     <p>
      在示例项目中，包含两个核心服务：
     </p>
     <ol>
      <li>
       <strong>
        demo-eureka：
       </strong>
       注册中心；
      </li>
      <li>
       <strong>
        demo-gateway：
       </strong>
       网关中心；
      </li>
      <li>
       <strong>
        auth-server：
       </strong>
       鉴权服务 – 相当于 “授权服务器”；
      </li>
      <li>
       **user-center： **用户服务 – 相当于 “资源服务器”。
      </li>
     </ol>
     <p>
      包含五个基础启动包：
     </p>
     <ol>
      <li>
       <strong>
        common-spring-boot-starter：
       </strong>
       基础公共包；
      </li>
      <li>
       <strong>
        jdbc-spring-boot-starter：
       </strong>
       JDBC数据库连接工具包；
      </li>
      <li>
       <strong>
        redis-spring-boot-starter：
       </strong>
       Redis缓存连接工具包；
      </li>
      <li>
       <strong>
        uaa-client-spring-boot-starter：
       </strong>
       <font color="red">
        “资源服务器” 工具包
       </font>
       ；
      </li>
      <li>
       <strong>
        uaa-server-spring-boot-starter：
       </strong>
       <font color="red">
        “授权服务器” 工具包
       </font>
       。
      </li>
     </ol>
     <p>
      整体项目目录结构如下：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/80965cb238964442a90a0aa2bd375467.png"/>
     </p>
     <p>
      “资源服务器” 工具包
      <code>
       uaa-client-spring-boot-starter
      </code>
      目录结构如下：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/51494b6e651045a08a6814fc0827c0c1.png"/>
     </p>
     <blockquote>
      <p>
       <strong>
        注意：
       </strong>
       为了实现分布式鉴权，这里我们将token存到了redis缓存中。
      </p>
     </blockquote>
     <p>
      “授权服务器” 工具包
      <code>
       uaa-server-spring-boot-starter
      </code>
      目录结构如下：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/39e522979a0a44e79cb3c3963531cd3a.png"/>
     </p>
     <h4>
      <a id="32__136">
      </a>
      3.2 集成测试
     </h4>
     <p>
      1）启动本地redis和数据库，确保
      <code>
       mydb.sql
      </code>
      中的数据已被初始化。
     </p>
     <p>
      2）启动所有服务，如下所示：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/96af452c7d3c4458847be69ab40e48de.png"/>
     </p>
     <p>
      3）在 user-center 服务中，有测试接口：
      <code>
       /user/list
      </code>
      ，如下所示：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/242313895ad44fe088ac8932f97c6b2c.png"/>
     </p>
     <p>
      我们直接使用 Postman 请求这个接口，如下所示：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f568b6a4080c47ebba139698b0beb632.png"/>
     </p>
     <p>
      可以看到，HTTP返回状态码为
      <code>
       401
      </code>
      ，返回内容中提示
      <code>
       unauthorized
      </code>
      ，没有权限，说明拦截成功。
     </p>
     <p>
      4）在 auth-server 服务中，OAuth 2.0 默认的获取授权接口为：
      <code>
       /oauth/token
      </code>
      ，如下所示：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0a7750368daf48ecb77e74f05cf8fc08.png"/>
     </p>
     <p>
      我们输入相应的入参进行请求 token，这里我们以密码模式为例。如下所示：
     </p>
     <ul>
      <li>
       <strong>
        请求地址：
       </strong>
       http://localhost:8081/oauth/token?grant_type=password&amp;username=ACGkaka&amp;password=123456&amp;client_id=app&amp;client_secret=app
      </li>
     </ul>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1a7db5a15f6f4f59ac5724120607688d.png"/>
     </p>
     <p>
      这里我们成功获取到了 token。
     </p>
     <p>
      5）将 token 作为鉴权请求头，再次请求 user-center 中的接口，如下所示：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/dfea069d503d4f5ea46c85eca9fc86f4.png"/>
     </p>
     <p>
      可以看到，原本被拦截的接口已经可以正常访问了，HTTP状态码也正常返回200了。
     </p>
     <blockquote>
      <p>
       <strong>
        代码地址：
       </strong>
       <a href="https://gitee.com/acgkaka/SpringBootExamples/tree/master/springboot-mybatis-plus-oauth2.0" rel="nofollow">
        https://gitee.com/acgkaka/SpringBootExamples/tree/master/springboot-mybatis-plus-oauth2.0
       </a>
      </p>
     </blockquote>
     <p>
      整理完毕，完结撒花~🌻
     </p>
    </img>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33333230343730392f:61727469636c652f64657461696c732f313436303833343836" class_="artid" style="display:none">
 </p>
</div>


