---
arturl_encode: "68747470:733a2f2f626c6f672e6373646e2e6e65742f736b646b6a7879:2f61727469636c652f64657461696c732f3339353031303539"
layout: post
title: "嵌入式-中断服务子程序注意事情"
date: 2024-06-30 14:36:35 +08:00
description: "中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是"
keywords: "在嵌入式系统中,中断需要注意什么"
categories: ['嵌入式']
tags: ['无标签']
artid: "39501059"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=39501059
    alt: "嵌入式-中断服务子程序注意事情"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=39501059
featuredImagePreview: https://bing.ee123.net/img/rand?artid=39501059
---

# 嵌入式 中断服务子程序注意事情

中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。

具代表事实是，产生了一个新的关键字 __interrupt。

**下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。**



__interrupt double compute_area (double radius)
  
{
  
double area = PI * radius * radius;
  
printf("\nArea = %f", area);
  
return area;
  
}

这个函数有太多的错误了，以至让人不知从何说起了：
  

**1)  ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。**

**2)  ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。**

**3)  在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。**

**此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。**

**4) 与第三点一脉相承，printf经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。**



不能在中断服务程序中执行类似操作的原因是运算时间太长,不能在中段中作复杂的工作,你可以在中断服务程序中置一个标志位.然后在主程序中查询此位,判断是否执行计算子程序.当然这样做会在中断产生与实际的中断响应之间产生一定的延迟,如果你的系统对时间不太敏感还好,如果非常敏感可以考虑采用rtos。否则。。。多加几句对中断标志位的判断语句。。。。

在主程序中监测是否被置位来决定子程序是否执行.可能存在以下问题,就是,中断返回后要执行几个耗时比较长的子程序才能执行判断标志位的语句,这样,可能会有太长的时间间隔.如果你在几个耗时比较长的子程序之间加上一句判断语句,就会减小中断产生与中断响应之
  
间的时间延迟.

中断活动的全过程大致为：

1、中断请求：中断事件一旦发生或者中断条件一旦构成，中断源提交“申请报告”，与请求CPU暂时放下目前的工作而转为中断源作为专项服务

2、中断屏蔽：虽然中断源提交了“申请报告”，但是，是否得到CPU的响应，还要取决于“申请报告”是否能够通过2道或者3道“关卡”（中断屏蔽）送达CPU（相应的中断屏蔽位等于1，为关卡放行；反之相应的中断屏蔽位等于0，为关卡禁止通行）；

3、中断响应：如果一路放行，则CPU响应中断后，将被打断的工作断点记录下来（把断点地址保护到堆栈），挂起“不再受理其他申请报告牌”（清除全局中断标志位GIE=0），跳转到中断服务子程序

4、保护现场：在处理新任务时可能破坏原有的工作现场，所以需要对工作现场和工作环境进行适当保护；

5、调查中断源：检查“申请报告”是由哪个中断源提交的，以便作出有针对性的服务；

6、中断处理：开始对查明的中断源进行有针对性的中断服务；

7、清除标志：在处理完毕相应的任务之后，需要进行撤消登记（清除中断标志），以避免造成重复响应；

8、恢复现场：恢复前面曾经被保护起来的工作现场，以便继续执行被中断的工作；

9、中断返回：将被打断的工作断点找回来（从堆栈中恢复断点地址），并摘下“不再受理其他申请报告牌”（GIE＝1），继续执行原先被打断的工作。