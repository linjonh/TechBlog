---
layout: post
title: "python调用java之Jpype实现java接口"
date: 2024-02-21 15:01:08 +0800
description: "python实现java接口概述java程序java接口java测试函数在pytho"
keywords: "Python,Java接口,JImplements"
categories: ['Python']
tags: ['Python', 'Java']
artid: "119487904"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=119487904
    alt: "python调用java之Jpype实现java接口"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=119487904
featuredImagePreview: https://bing.ee123.net/img/rand?artid=119487904
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     python调用java之Jpype实现java接口
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      python实现java接口
     </h4>
     <ul>
      <li>
       <a href="#_1" rel="nofollow">
        概述
       </a>
      </li>
      <li>
       <a href="#java_7" rel="nofollow">
        java程序
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#java_8" rel="nofollow">
          java接口
         </a>
        </li>
        <li>
         <a href="#java_18" rel="nofollow">
          java测试函数
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#pythonjava_27" rel="nofollow">
        在python中实现java接口的两种方式
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#JImplements_28" rel="nofollow">
          第一种：JImplements
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#JImplements_30" rel="nofollow">
            JImplements的使用示例
           </a>
          </li>
          <li>
           <a href="#JImplements_59" rel="nofollow">
            JImplements不友好的地方
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#JProxy_91" rel="nofollow">
          第二种：JProxy
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_116" rel="nofollow">
        总结
       </a>
      </li>
      <li>
       <a href="#_118" rel="nofollow">
        示例源码
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     概述
    </h2>
    <p>
     本文介绍在python中实现java接口。
     <br/>
     JPype 可以通过使用装饰器或手动创建 JProxy 来实现 Java 接口。Java 只支持代理接口，因此我们不能扩展现有的 Java 类。
     <br/>
     笔者在测试领域，通常使用python调用java程序，达到在通过python测试java程序的目的。因此不能很理解在python中实现java接口的意义。如果有人知道，请留言告知。
     <br/>
     了解的一个意义是：在python中实现java接口，然后作为回调函数传递给java api。
     <br/>
     下面介绍下在java中，一个函数的参数是一个回调函数的例子。
    </p>
    <h2>
     <a id="java_7">
     </a>
     java程序
    </h2>
    <h3>
     <a id="java_8">
     </a>
     java接口
    </h3>
    <pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">params</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> testInterface <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <h3>
     <a id="java_18">
     </a>
     java测试函数
    </h3>
    <p>
     该函数的第二个参数是一个实现了testInterface接口的对象，但这个接口java提供方没有实现，而是留给调用方实现。
    </p>
    <pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test_recall</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> testInterface a_interface_obj<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> a_interface_obj<span class="token punctuation">.</span><span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <p>
     如果使用python调用test_recall函数，那么就需要在python中实现testInterface接口。
    </p>
    <h2>
     <a id="pythonjava_27">
     </a>
     在python中实现java接口的两种方式
    </h2>
    <h3>
     <a id="JImplements_28">
     </a>
     第一种：JImplements
    </h3>
    <p>
     JImplements是Jpype提供的一个装饰器对象，通过使用它来实现java接口的实现。但这个方法有个不友好的地方，下面遇到会介绍。
    </p>
    <h4>
     <a id="JImplements_30">
     </a>
     JImplements的使用示例
    </h4>
    <p>
     通过JImplements实现上文中的testInterface接口
    </p>
    <pre><code class="prism language-python"><span class="token comment"># coding: utf-8</span>
<span class="token keyword">from</span> jpype <span class="token keyword">import</span> JImplements<span class="token punctuation">,</span> JOverride


<span class="token decorator annotation punctuation">@JImplements</span><span class="token punctuation">(</span><span class="token string">"params.testInterface"</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">java_interface</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@JOverride</span>
    <span class="token keyword">def</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">99</span>
</code></pre>
    <p>
     调用java程序中的test_recall函数
    </p>
    <pre><code class="prism language-python">    res <span class="token operator">=</span> myJpypeTest<span class="token punctuation">.</span>test_recall<span class="token punctuation">(</span>to_int<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> java_interface<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre>
    <pre><code class="prism language-python"><span class="token string">"D:\Program Files\Python39\python.exe"</span> D<span class="token punctuation">:</span><span class="token operator">/</span>myProjects<span class="token operator">/</span>python<span class="token operator">/</span>test_JPype<span class="token operator">/</span>main<span class="token punctuation">.</span>py
<span class="token number">100</span>

Process finished <span class="token keyword">with</span> exit code <span class="token number">0</span>

</code></pre>
    <p>
     我们通过使用JImplements装饰器在python中实现了testInterface接口，然后把其作为回调函数传给test_recall，完成test_recall调用。
    </p>
    <h4>
     <a id="JImplements_59">
     </a>
     JImplements不友好的地方
    </h4>
    <p>
     这个不友好的地方来源与python的一个知识点：
    </p>
    <ul>
     <li>
      <strong>
       python在导入模块时就会执行装饰器
      </strong>
     </li>
    </ul>
    <p>
     按照笔者的编程风格，实现java接口，作为独立功能是单独放在一个python模块文件中，而调用java程序的代码放在另一个模块中。
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/58dedd378415f380c02b7b66a61bdbf5.png">
      <br/>
      其中java_interface.py是实现java接口的模块。
      <br/>
      main.py是实现调用java程序的模块。
      <br/>
      在main.py的顶部，会有
      <code>
       from java_interface import java_interface
      </code>
      来导入实现java接口的类。
      <br/>
      因为JImplements是一个装饰器，所以在加载java_interface模块时就会执行，此时业务代码没有执行，jar包没有加载，jvm没有启动，所以JImplements执行会报JVM没有启动的错误。
     </img>
    </p>
    <pre><code class="prism language-python"><span class="token string">"D:\Program Files\Python39\python.exe"</span> D<span class="token punctuation">:</span><span class="token operator">/</span>myProjects<span class="token operator">/</span>python<span class="token operator">/</span>test_JPype<span class="token operator">/</span>main<span class="token punctuation">.</span>py
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"D:\myProjects\python\test_JPype\main.py"</span><span class="token punctuation">,</span> line <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
    <span class="token keyword">from</span> java_interface <span class="token keyword">import</span> java_interface
  File <span class="token string">"D:\myProjects\python\test_JPype\java_interface.py"</span><span class="token punctuation">,</span> line <span class="token number">6</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
    <span class="token keyword">class</span> <span class="token class-name">java_interface</span><span class="token punctuation">:</span>
  File <span class="token string">"D:\Program Files\Python39\lib\site-packages\jpype\_jproxy.py"</span><span class="token punctuation">,</span> line <span class="token number">136</span><span class="token punctuation">,</span> <span class="token keyword">in</span> JProxyCreator
    <span class="token keyword">return</span> _createJProxy<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>interfaces<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
  File <span class="token string">"D:\Program Files\Python39\lib\site-packages\jpype\_jproxy.py"</span><span class="token punctuation">,</span> line <span class="token number">80</span><span class="token punctuation">,</span> <span class="token keyword">in</span> _createJProxy
    actualIntf <span class="token operator">=</span> _prepareInterfaces<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> intf<span class="token punctuation">)</span>
  File <span class="token string">"D:\Program Files\Python39\lib\site-packages\jpype\_jproxy.py"</span><span class="token punctuation">,</span> line <span class="token number">51</span><span class="token punctuation">,</span> <span class="token keyword">in</span> _prepareInterfaces
    actualIntf <span class="token operator">=</span> _convertInterfaces<span class="token punctuation">(</span>intf<span class="token punctuation">)</span>
  File <span class="token string">"D:\Program Files\Python39\lib\site-packages\jpype\_jproxy.py"</span><span class="token punctuation">,</span> line <span class="token number">156</span><span class="token punctuation">,</span> <span class="token keyword">in</span> _convertInterfaces
    actualIntf<span class="token punctuation">.</span>add<span class="token punctuation">(</span>_jpype<span class="token punctuation">.</span>JClass<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
  File <span class="token string">"D:\Program Files\Python39\lib\site-packages\jpype\_jclass.py"</span><span class="token punctuation">,</span> line <span class="token number">99</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __new__
    <span class="token keyword">return</span> _jpype<span class="token punctuation">.</span>_getClass<span class="token punctuation">(</span>jc<span class="token punctuation">)</span>
jpype<span class="token punctuation">.</span>_core<span class="token punctuation">.</span>JVMNotRunning<span class="token punctuation">:</span> Java Virtual Machine <span class="token keyword">is</span> <span class="token keyword">not</span> running
</code></pre>
    <p>
     从异常Traceback中可以看到，在
     <code>
      from java_interface import java_interface
     </code>
     这一步就报错了。
     <br/>
     如果想顺利运行，除非在
     <code>
      from java_interface import java_interface
     </code>
     之前，就加载jar包启动jvm，但这对于代码风格来说不友好。
    </p>
    <h3>
     <a id="JProxy_91">
     </a>
     第二种：JProxy
    </h3>
    <p>
     首先编写一个python类，这个类包含了testInterface接口声明的方法。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">java_interface_1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">99</span>
</code></pre>
    <p>
     然后，调用java程序，通过JProxy实现接口对象的实现。
    </p>
    <pre><code class="prism language-python">   <span class="token comment"># 测试python实现java接口作为回调函数</span>
    res <span class="token operator">=</span> myJpypeTest<span class="token punctuation">.</span>test_recall<span class="token punctuation">(</span>to_int<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> JProxy<span class="token punctuation">(</span><span class="token string">"params.testInterface"</span><span class="token punctuation">,</span> inst<span class="token operator">=</span>java_interface_1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre>
    <pre><code class="prism language-python"><span class="token string">"D:\Program Files\Python39\python.exe"</span> D<span class="token punctuation">:</span><span class="token operator">/</span>myProjects<span class="token operator">/</span>python<span class="token operator">/</span>test_JPype<span class="token operator">/</span>main<span class="token punctuation">.</span>py
<span class="token number">100</span>

Process finished <span class="token keyword">with</span> exit code <span class="token number">0</span>

</code></pre>
    <p>
     遗憾的是，官方文档提到，JProxy是一个老式的API，新代码应该使用@JImplements注释，因为它将支持改进的类型安全和错误处理。
    </p>
    <h2>
     <a id="_116">
     </a>
     总结
    </h2>
    <p>
     本文介绍了两种方式，都可以在python中实现java接口。虽然两种方式都不完美，但满足实际需求是可以的。
    </p>
    <h2>
     <a id="_118">
     </a>
     示例源码
    </h2>
    <p>
     <a href="https://github.com/linchao001/testJpype">
      https://github.com/linchao001/testJpype
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6c635f62757a686964616f2f:61727469636c652f64657461696c732f313139343837393034" class_="artid" style="display:none">
 </p>
</div>


