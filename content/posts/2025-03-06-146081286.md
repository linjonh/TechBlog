---
layout: post
title: "linux内存页块划分及位图存储机制"
date: 2025-03-06 22:23:35 +0800
description: "核心作用与背景是 Linux 内存管理中的一个关键数据结构，主要用于跟踪和管理 ​内存块（pageblock）​的特性。通过，内核可以高效地记录每个内存块的属性，例如迁移类型、分配状态等，从而优化内存分配与回收策略。"
keywords: "linux内存页块划分及位图存储机制"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "146081286"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146081286
    alt: "linux内存页块划分及位图存储机制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146081286
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146081286
cover: https://bing.ee123.net/img/rand?artid=146081286
image: https://bing.ee123.net/img/rand?artid=146081286
img: https://bing.ee123.net/img/rand?artid=146081286
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     linux内存页块划分及位图存储机制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <a href="https://elixir.bootlin.com/linux/v5.4.285/source/mm/page_alloc.c#L551" rel="nofollow" title="            page_alloc.c - mm/page_alloc.c -  Linux source code v5.4.285 - Bootlin Elixir Cross Referencer        ">
      page_alloc.c - mm/page_alloc.c - Linux source code v5.4.285 - Bootlin Elixir Cross Referencer
     </a>
    </p>
    <p>
    </p>
    <h2>
     <strong>
      一. 什么是页块（Pageblock）？
     </strong>
    </h2>
    <ul>
     <li>
      <p>
       <strong>
        定义
       </strong>
       ：页块是物理内存中的一个连续区域，由
       <code>
        2^pageblock_order
       </code>
       个物理页（Page）组成。
      </p>
     </li>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：页块是内存碎片管理的最小单位，用于跟踪内存区域的
       <strong>
        迁移类型（Migratetype）
       </strong>
       （如可移动、不可移动等），优化内存分配和碎片整理。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      1.1.
      <code>
       pageblock_order
      </code>
      的默认值
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        常规配置
       </strong>
       ：
      </p>
      <pre><code class="language-cpp">#ifdef CONFIG_HUGETLB_PAGE_SIZE_VARIABLE
  #define pageblock_order HUGETLB_PAGE_ORDER
#else
  #define pageblock_order (MAX_ORDER - 1)
#endif</code></pre>
      <ul>
       <li>
        <p>
         <strong>
          默认情况
         </strong>
         ：若未启用巨型页（HugeTLB）的动态大小配置，
         <code>
          pageblock_order
         </code>
         通常设置为
         <code>
          MAX_ORDER - 1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           MAX_ORDER
          </code>
         </strong>
         ：伙伴系统的最大分配阶数，通常为
         <code>
          11
         </code>
         （对应
         <code>
          2^10 = 1024
         </code>
         页，即
         <code>
          4MB
         </code>
         ，假设页大小为
         <code>
          4KB
         </code>
         ）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         默认页块大小为
         <code>
          2^(MAX_ORDER-1)
         </code>
         页（例如
         <code>
          MAX_ORDER=11
         </code>
         时，页块为
         <code>
          2^10 = 1024
         </code>
         页 =
         <code>
          4MB
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         每个页块在全局位图
         <code>
          pageblock_flags
         </code>
         中占用若干位（如3位用于迁移类型）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      1.2. 为什么选择
      <code>
       MAX_ORDER - 1
      </code>
      ？
     </strong>
    </h4>
    <h5>
     <strong>
      设计目标
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        对齐伙伴系统
       </strong>
       ：确保页块大小与伙伴系统的最大连续内存块（
       <code>
        MAX_ORDER
       </code>
       ）对齐，避免跨页块分配。
      </p>
     </li>
     <li>
      <p>
       <strong>
        减少碎片
       </strong>
       ：较大的页块能更高效地隔离不可移动内存（如内核对象），减少长期内存碎片。
      </p>
     </li>
     <li>
      <p>
       <strong>
        迁移类型管理
       </strong>
       ：每个页块独立维护迁移类型，方便内存碎片整理时批量移动页面。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      权衡
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        内存粒度
       </strong>
       ：页块越大，管理更粗粒度，可能浪费内存；页块越小，管理更细粒度，但元数据开销增加。
      </p>
     </li>
     <li>
      <p>
       <strong>
        性能
       </strong>
       ：较大的页块减少位图操作次数，提高效率。
      </p>
     </li>
    </ul>
    <h4>
    </h4>
    <h4>
    </h4>
    <h2>
     二、什么是页块位图？
    </h2>
    <h5>
     1. ​
     <strong>
      核心作用与背景
     </strong>
    </h5>
    <p>
     <code>
      pageblock_flags
     </code>
     是 Linux 内存管理中的一个关键数据结构，主要用于跟踪和管理 ​
     <strong>
      内存块（pageblock）​
     </strong>
     的特性。通过
     <code>
      pageblock_flags
     </code>
     ，内核可以高效地记录每个内存块的属性，例如迁移类型、分配状态等，从而优化内存分配与回收策略。
    </p>
    <h5>
     2. ​
     <strong>
      数据结构与存储方式
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       存储位置
      </strong>
      ：
      <code>
       pageblock_flags
      </code>
      以位图（bitmap）形式存储在
      <code>
       struct zone
      </code>
      结构体中（字段
      <code>
       unsigned long *pageblock_flags
      </code>
      ），每个
      <span style="color:#fe2c24">
       内存块对应位图中的若干比特位
      </span>
      。
      <pre><code class="language-cpp">// https://elixir.bootlin.com/linux/v5.4.285/source/include/linux/mmzone.h#L448

struct zone {
#ifndef CONFIG_SPARSEMEM
	/*
	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.
	 * In SPARSEMEM, this map is stored in struct mem_section
	 */
	unsigned long		*pageblock_flags;  // 指向位图的指针
#endif /* CONFIG_SPARSEMEM */
}</code></pre>
      <p>
       单个
       <code>
        pageblock_flags
       </code>
       元素可表示的页块和页的数量为：
      </p>
      <p>
       ​
       <strong>
        32位系统
       </strong>
       ：32/4=8 个页块=8*1024页。
      </p>
      <p>
       ​
       <strong>
        64位系统
       </strong>
       ：64/4=16 个页块=16*1024页。
      </p>
     </li>
     <li>
      <strong>
       位图管理
      </strong>
      ：每个内存块的标志位由
      <code>
       NR_PAGEBLOCK_BITS
      </code>
      定义，用于存储以下信息：
      <ul>
       <li>
        ​
        <strong>
         迁移类型
        </strong>
        ​（如
        <code>
         MIGRATE_UNMOVABLE
        </code>
        、
        <code>
         MIGRATE_MOVABLE
        </code>
        等）。
       </li>
       <li>
        内存块的其他状态（如是否跳过内存碎片整理等）
        <pre><code class="language-cpp">#define PB_migratetype_bits 3
/* Bit indices that affect a whole block of pages */
enum pageblock_bits {
	PB_migrate,
	PB_migrate_end = PB_migrate + PB_migratetype_bits - 1,
			/* 3 bits required for migrate types */
	PB_migrate_skip,/* 1位标记是否跳过压缩（PB_migrate_skip），避免重复处理低效内存块 */

	/*
	 * Assume the bits will always align on a word. If this assumption
	 * changes then get/set pageblock needs updating.
	 */
	NR_PAGEBLOCK_BITS
};</code></pre>
        <p>
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     3. ​
     <strong>
      初始化
     </strong>
    </h5>
    <p>
     <br/>
     <a href="https://elixir.bootlin.com/linux/v5.4.285/C/ident/free_area_init_core" rel="nofollow" title="free_area_init_core">
      free_area_init_core
     </a>
     -&gt;
     <a href="https://elixir.bootlin.com/linux/v5.4.285/C/ident/setup_usemap" rel="nofollow" title="setup_usemap">
      setup_usemap
     </a>
    </p>
    <pre><code class="language-cpp">static void __ref setup_usemap(struct pglist_data *pgdat,
				struct zone *zone,
				unsigned long zone_start_pfn,
				unsigned long zonesize)
{
	unsigned long usemapsize = usemap_size(zone_start_pfn, zonesize);
	zone-&gt;pageblock_flags = NULL;
	if (usemapsize) {
		zone-&gt;pageblock_flags =
			memblock_alloc_node(usemapsize, SMP_CACHE_BYTES,
					    pgdat-&gt;node_id);
		if (!zone-&gt;pageblock_flags)
			panic("Failed to allocate %ld bytes for zone %s pageblock flags on node %d\n",
			      usemapsize, zone-&gt;name, pgdat-&gt;node_id);
	}
}</code></pre>
    <p>
     <code>
      setup_usemap
     </code>
     的作用是为内存管理区（Zone）分配并初始化
     <code>
      pageblock_flags
     </code>
     位图，该位图用于跟踪每个内存块（Pageblock）的迁移类型（Migratetype）和其他状态。
    </p>
    <hr/>
    <p>
     ​
     <strong>
      参数说明
     </strong>
    </p>
    <ul>
     <li>
      <code>
       struct pglist_data *pgdat
      </code>
      : 指向 NUMA 节点的
      <code>
       pglist_data
      </code>
      结构，描述节点的内存布局。
     </li>
     <li>
      <code>
       struct zone *zone
      </code>
      : 目标内存管理区（如
      <code>
       ZONE_NORMAL
      </code>
      、
      <code>
       ZONE_DMA
      </code>
      ）。
     </li>
     <li>
      <code>
       unsigned long zone_start_pfn
      </code>
      : 该 Zone 的起始物理页帧号（Page Frame Number）。
     </li>
     <li>
      <code>
       unsigned long zonesize
      </code>
      : 该 Zone 的总页数。
     </li>
    </ul>
    <hr/>
    <p>
     ​
     <strong>
      代码逻辑分解
     </strong>
    </p>
    <p>
     ​
     <strong>
      1. 计算
      <code>
       pageblock_flags
      </code>
      位图大小
     </strong>
    </p>
    <pre><code class="language-cpp">#define PB_migratetype_bits 3
/* Bit indices that affect a whole block of pages */
enum pageblock_bits {
	PB_migrate,
	PB_migrate_end = PB_migrate + PB_migratetype_bits - 1,
			/* 3 bits required for migrate types */
	PB_migrate_skip,/* 1位标记是否跳过压缩（PB_migrate_skip），避免重复处理低效内存块 */

	/*
	 * Assume the bits will always align on a word. If this assumption
	 * changes then get/set pageblock needs updating.
	 */
	NR_PAGEBLOCK_BITS
};

#define pageblock_nr_pages	(1UL &lt;&lt; pageblock_order)


static unsigned long __init usemap_size(unsigned long zone_start_pfn, unsigned long zonesize)
{
    unsigned long usemapsize;
    zonesize += zone_start_pfn &amp; (pageblock_nr_pages-1);       // 步骤1：对齐修正
    usemapsize = roundup(zonesize, pageblock_nr_pages);        // 步骤2：向上对齐到pageblock整数倍
    usemapsize = usemapsize &gt;&gt; pageblock_order;                // 步骤3：计算pageblock数量
    usemapsize *= NR_PAGEBLOCK_BITS;                           // 步骤4：总位数 = 块数 × 4位
    usemapsize = roundup(usemapsize, 8 * sizeof(unsigned long));// 步骤5：位对齐到unsigned long
    return usemapsize / 8;                                     // 步骤6：转换为字节
}

</code></pre>
    <ul>
     <li>
      ​**
      <code>
       usemap_size()
      </code>
      **: 计算位图所需内存大小（单位：字节）。
      <ul>
       <li>
        ​
        <strong>
         参数
        </strong>
        ：根据 Zone 的起始页帧（
        <code>
         zone_start_pfn
        </code>
        ）和总页数（
        <code>
         zonesize
        </code>
        ）。
       </li>
       <li>
        ​
        <strong>
         内部逻辑
        </strong>
        :
        <br/>
        举例：某一个zone的start pfn = 0X1234；end pfn =  0X3600；zonesize = 0X23CC
        <table>
         <thead>
          <tr>
           <th style="width:124px">
            操作
           </th>
           <th style="width:196px">
            目的
           </th>
           <th style="width:308px">
            结果
           </th>
          </tr>
          <tr>
           <td style="width:124px">
            <strong>
             计算对齐修正值
            </strong>
           </td>
           <td style="width:196px">
            处理Zone起始地址未按pageblock对齐的情况（如Zone起始于一个pageblock中间），修正总页数以包含不完整的起始pageblock
           </td>
           <td style="width:308px">
            <code>
             修正值：zone_start_pfn &amp; (pageblock_nr_pages-1)=0x234
            </code>
            <br/>
            zonesize += zone_start_pfn &amp; (pageblock_nr_pages-1)=0x23CC+0x234=0x2600
           </td>
          </tr>
          <tr>
           <td style="width:124px">
            <strong>
             向上取整对齐
            </strong>
           </td>
           <td style="width:196px">
            确保总页数是pageblock大小的整数倍（例如：1024页的倍数），避免部分pageblock无法被位图覆盖
           </td>
           <td style="width:308px">
            usemapsize  = roundup(zonesize, pageblock_nr_pages) = roundup(0x2600, 1024)  = 0x2800页
           </td>
          </tr>
          <tr>
           <td style="width:124px">
            ​
            <strong>
             计算pageblock数量
            </strong>
           </td>
           <td style="width:196px">
            右移
            <code>
             pageblock_order
            </code>
            位（等价于除以
            <code>
             pageblock_nr_pages
            </code>
            ），得到Zone内完整的pageblock数量
           </td>
           <td style="width:308px">
            usemapsize = usemapsize &gt;&gt; pageblock_order; =   0x2800 &gt;&gt; 10 = 10
           </td>
          </tr>
          <tr>
           <td style="width:124px">
            <strong>
             计算总位数
            </strong>
           </td>
           <td style="width:196px">
            每个pageblock需要
            <code>
             NR_PAGEBLOCK_BITS
            </code>
            （4位）来存储状态，总位数 = pageblock数量 × 4
           </td>
           <td style="width:308px">
            40
           </td>
          </tr>
          <tr>
           <td style="width:124px">
            ​
            <strong>
             最终位图大小（字节）​
            </strong>
           </td>
           <td style="width:196px">
            ​总位数 / 8（1字节=8位）
           </td>
           <td style="width:308px">
            40 / 8 = 5。（32bit系统上，需要两个
            <code>
             pageblock_flags
            </code>
            元素）
           </td>
          </tr>
         </thead>
        </table>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="" height="313" src="https://i-blog.csdnimg.cn/direct/804569c4eb8946548a02e5f949b8e11d.png" width="1370"/>
    </p>
    <hr/>
    <p>
     ​
     <strong>
      2. 分配
      <code>
       pageblock_flags
      </code>
      内存
     </strong>
    </p>
    <pre><code class="language-cpp">if (usemapsize) {
    zone-&gt;pageblock_flags = memblock_alloc_node(usemapsize, SMP_CACHE_BYTES, pgdat-&gt;node_id);
    // ...
}</code></pre>
    <ul>
     <li>
      ​
      <strong>
       条件判断
      </strong>
      ：仅在
      <code>
       usemapsize &gt; 0
      </code>
      时分配内存（Zone 包含至少一个完整内存块）。
     </li>
     <li>
      ​
      <strong>
       分配函数
      </strong>
      :
      <code>
       memblock_alloc_node
      </code>
      <ul>
       <li>
        ​
        <strong>
         用途
        </strong>
        : 在内核启动早期（伙伴系统未初始化时），从
        <code>
         memblock
        </code>
        分配器分配内存。
       </li>
       <li>
        ​
        <strong>
         参数
        </strong>
        :
        <ul>
         <li>
          <code>
           usemapsize
          </code>
          : 分配的字节数。
         </li>
         <li>
          <code>
           SMP_CACHE_BYTES
          </code>
          : 对齐到缓存行（通常 64 字节），避免伪共享（False Sharing）。
         </li>
         <li>
          <code>
           pgdat-&gt;node_id
          </code>
          : 在指定 NUMA 节点上分配内存，确保 NUMA 亲和性。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      ​
      <strong>
       结果
      </strong>
      :
      <code>
       zone-&gt;pageblock_flags
      </code>
      指向分配的位图内存。
     </li>
    </ul>
    <hr/>
    <h2>
     <strong>
      三. 实际应用场景
     </strong>
    </h2>
    <h5>
     <strong>
      3.1、内存碎片整理（Memory Compaction）
     </strong>
     ：
    </h5>
    <p>
     碎片整理器根据页块的迁移类型，将可移动页面（如用户态数据）迁移到其他页块，腾出连续内存。页块大小决定了迁移操作的最小单位。
    </p>
    <p>
     <strong>
      3.1.1、设置迁移类型
     </strong>
     ：
     <code>
      set_pageblock_migratetype(struct page *page, int migratetype)
     </code>
     ，用于在页释放时将其所属内存块的迁移类型标记为正确值
    </p>
    <blockquote>
     <pre><code class="language-cpp">#define PB_migratetype_bits 3
/* Bit indices that affect a whole block of pages */
enum pageblock_bits {
	PB_migrate,
	PB_migrate_end = PB_migrate + PB_migratetype_bits - 1,
			/* 3 bits required for migrate types */
	PB_migrate_skip,/* If set the block is skipped by compaction */

	/*
	 * Assume the bits will always align on a word. If this assumption
	 * changes then get/set pageblock needs updating.
	 */
	NR_PAGEBLOCK_BITS
};

#define set_pageblock_flags_group(page, flags, start_bitidx, end_bitidx) \
	set_pfnblock_flags_mask(page, flags, page_to_pfn(page),		\
			end_bitidx,					\
			(1 &lt;&lt; (end_bitidx - start_bitidx + 1)) - 1)

void set_pageblock_migratetype(struct page *page, int migratetype)
{
	if (unlikely(page_group_by_mobility_disabled &amp;&amp;
		     migratetype &lt; MIGRATE_PCPTYPES))
		migratetype = MIGRATE_UNMOVABLE;

	set_pageblock_flags_group(page, (unsigned long)migratetype,
					PB_migrate, PB_migrate_end);
}

/**
 * set_pfnblock_flags_mask - Set the requested group of flags for a pageblock_nr_pages block of pages
 * @page: The page within the block of interest
 * @flags: The flags to set
 * @pfn: The target page frame number
 * @end_bitidx: The last bit of interest
 * @mask: mask of bits that the caller is interested in
 */
void set_pfnblock_flags_mask(struct page *page, unsigned long flags,
					unsigned long pfn,
					unsigned long end_bitidx,
					unsigned long mask)
{
	unsigned long *bitmap;
	unsigned long bitidx, word_bitidx;
	unsigned long old_word, word;

	BUILD_BUG_ON(NR_PAGEBLOCK_BITS != 4);
	BUILD_BUG_ON(MIGRATE_TYPES &gt; (1 &lt;&lt; PB_migratetype_bits));
    // 获取目标页块对应的位图指针及位偏移
	bitmap = get_pageblock_bitmap(page, pfn); //page_zone(page)-&gt;pageblock_flags
	bitidx = pfn_to_bitidx(page, pfn);
    // 计算位图中的具体位置（原子操作）
	word_bitidx = bitidx / BITS_PER_LONG;
	bitidx &amp;= (BITS_PER_LONG-1);

	VM_BUG_ON_PAGE(!zone_spans_pfn(page_zone(page), pfn), page);
    // 位操作：对齐掩码和标志值
	bitidx += end_bitidx;
	mask &lt;&lt;= (BITS_PER_LONG - bitidx - 1);
	flags &lt;&lt;= (BITS_PER_LONG - bitidx - 1);
    // 原子更新位图
	word = READ_ONCE(bitmap[word_bitidx]);
	for (;;) {
		old_word = cmpxchg(&amp;bitmap[word_bitidx], word, (word &amp; ~mask) | flags);
		if (word == old_word)
			break;
		word = old_word;
	}
}

static inline int pfn_to_bitidx(struct page *page, unsigned long pfn)
{
    // 步骤1：计算对齐后的Zone起始PFN，并调整pfn为相对于该起始的偏移
    pfn = pfn - round_down(page_zone(page)-&gt;zone_start_pfn, pageblock_nr_pages);
    // 步骤2：将偏移转换为内存块索引，再乘以每块占用的位数，得到位索引
    return (pfn &gt;&gt; pageblock_order) * NR_PAGEBLOCK_BITS;
}</code></pre>
    </blockquote>
    <p>
     <strong>
      迁移特性开关检查
     </strong>
     ：
     <br/>
     <code>
      page_group_by_mobility_disabled
     </code>
     全局标志（由系统内存状态决定）若为真，表示禁用按迁移类型分组。此时强制将基础迁移类型（如
     <code>
      MIGRATE_MOVABLE
     </code>
     ）设为
     <code>
      MIGRATE_UNMOVABLE
     </code>
     ，避免碎片整理操作。
    </p>
    <p>
     <strong>
      生成掩码：
     </strong>
    </p>
    <p>
     (1 &lt;&lt; (end_bitidx - start_bitidx + 1)) - 1
    </p>
    <p>
     计算
     <code>
      start_bitidx
     </code>
     到
     <code>
      end_bitidx
     </code>
     的位宽（如3位），生成掩码
     <code>
      0b111
     </code>
    </p>
    <p>
     <strong>
      <code>
       pfn_to_bitidx:
      </code>
     </strong>
     将物理页帧号（PFN）转换为对应内存块（Pageblock）在位图（
     <code>
      pageblock_flags
     </code>
     ）中的
     <span style="color:#fe2c24">
      起始位索引
     </span>
    </p>
    <blockquote>
     <h5>
      示例:
     </h5>
     <ul>
      <li>
       ​
       <strong>
        参数
       </strong>
       ：
       <ul>
        <li>
         <code>
          zone_start_pfn = 0x1234
         </code>
         （未对齐到内存块大小）。
        </li>
        <li>
         <code>
          pageblock_nr_pages = 1024
         </code>
         。
        </li>
        <li>
         <code>
          pfn = 0x1500
         </code>
         （目标页 PFN）。
        </li>
       </ul>
      </li>
      <li>
       ​
       <strong>
        计算过程
       </strong>
       ：
       <ol>
        <li>
         ​
         <strong>
          对齐 Zone 起始 PFN
         </strong>
         ：
         <br/>
         <code>
          round_down(0x1234, 1024) = 0x1000
         </code>
         。
        </li>
        <li>
         ​
         <strong>
          PFN 偏移
         </strong>
         ：
         <br/>
         <code>
          0x1500 - 0x1000 = 0x500
         </code>
         。
        </li>
        <li>
         ​
         <strong>
          内存块索引
         </strong>
         ：
         <br/>
         <code>
          0x500 &gt;&gt; 10 = 1
         </code>
         （第 1 个内存块）。
        </li>
        <li>
         ​
         <strong>
          位索引
         </strong>
         ：
         <br/>
         <code>
          1 * 4 = 4
         </code>
         。
        </li>
       </ol>
      </li>
      <li>
       ​
       <strong>
        结果
       </strong>
       ：
       <br/>
       该页位于第 1 个内存块，其状态位在位图的第 4 位。
      </li>
     </ul>
    </blockquote>
    <p>
    </p>
    <p>
     3.1.2、​
     <strong>
      获取迁移类型
     </strong>
     ：
     <code>
      get_pageblock_migratetype(struct page *page)
     </code>
     ，从页的元数据中提取所属内存块的迁移类型
    </p>
    <p>
     3.1.3、​
     <strong>
      初始化与校验
     </strong>
     ：在系统启动时，内核会检查每个迁移类型的内存块是否达到最小数量（
     <code>
      pageblock_nr_pages
     </code>
     ），以决定是否启用迁移优化特性
    </p>
    <h5>
     <strong>
      3.2、连续内存分配器（CMA）
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <p>
       CMA 预留的连续内存以页块为单位管理，
       <code>
        pageblock_order
       </code>
       影响 CMA 区域的最小粒度。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      3.3、巨型页（HugeTLB）
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <p>
       若启用动态巨型页大小（
       <code>
        CONFIG_HUGETLB_PAGE_SIZE_VARIABLE
       </code>
       ），
       <code>
        pageblock_order
       </code>
       可能与巨型页大小对齐。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      3.4、内存热插拔
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <p>
       动态调整内存区域时，通过
       <code>
        pageblock_flags
       </code>
       快速定位可迁移或可回收的内存块
      </p>
     </li>
    </ul>
    <h4>
    </h4>
    <h4>
    </h4>
    <p>
     <a href="https://elixir.bootlin.com/linux/v5.4.285/source/mm/page_alloc.c#L551" rel="nofollow" title="            page_alloc.c - mm/page_alloc.c -  Linux source code v5.4.285 - Bootlin Elixir Cross Referencer        ">
      page_alloc.c - mm/page_alloc.c - Linux source code v5.4.285 - Bootlin Elixir Cross Referencer
     </a>
    </p>
    <p>
     <a href="https://elixir.bootlin.com/linux/v5.4.285/source/mm/page_alloc.c#L506" rel="nofollow" title="            page_alloc.c - mm/page_alloc.c -  Linux source code v5.4.285 - Bootlin Elixir Cross Referencer        ">
      page_alloc.c - mm/page_alloc.c - Linux source code v5.4.285 - Bootlin Elixir Cross Referencer
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7777776c796a3132333332312f:61727469636c652f64657461696c732f313436303831323836" class_="artid" style="display:none">
 </p>
</div>


