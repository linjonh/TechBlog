---
layout: post
title: "mybatismybatis-plus"
date: 2025-03-15 15:13:39 +0800
description: "MyBatis 是一个流行的 Java 持久层框架，专注于简化数据库操作。它通过 XML 或注解配置，支持自定义 SQL、存储过程和高级映射，极大地减少了繁琐的 JDBC 代码。MyBatis 的灵活性使其适用于需要精细控制 SQL 性能的场景，同时也能实现 SQL 与 Java 代码的分离，提升代码的可维护性。"
keywords: "mybatis&mybatis-plus"
categories: ['未分类']
tags: ['Tomcat', 'Mybatis', 'Java']
artid: "146279038"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146279038
    alt: "mybatismybatis-plus"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146279038
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146279038
cover: https://bing.ee123.net/img/rand?artid=146279038
image: https://bing.ee123.net/img/rand?artid=146279038
img: https://bing.ee123.net/img/rand?artid=146279038
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     mybatis&amp;mybatis-plus
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     MyBatis
    </h2>
    <h3>
     持久层框架
    </h3>
    <p>
     MyBatis 是一个流行的 Java 持久层框架，专注于简化数据库操作。它通过 XML 或注解配置，支持自定义 SQL、存储过程和高级映射，极大地减少了繁琐的 JDBC 代码。MyBatis 的灵活性使其适用于需要精细控制 SQL 性能的场景，同时也能实现 SQL 与 Java 代码的分离，提升代码的可维护性
    </p>
    <h3>
     CRUD步骤
    </h3>
    <p>
     1.添加mybatis依赖
    </p>
    <pre><code class="language-XML"> &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.4&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
    <p>
     2.创建java实体类
    </p>
    <pre><code class="language-java">@Data
public class Emp {
    private Integer id;
    private String empName;
    private Integer age;
    private Double empSalary;
}</code></pre>
    <p>
    </p>
    <p>
     3.写Service接口,但此时是Mapper(加@Mapper注解)
    </p>
    <pre><code class="language-java">@Mapper//告诉Spring,这是MyBatis操作数据库的Mapper接口
public interface EmpMapper {
   Emp getEmpById(Integer id);
   void addEmp(Emp emp);
   void deleteEmpById(Integer id);
   void updateEmp(Emp emp);
   List&lt;Emp&gt; getAllEmp();
}</code></pre>
    <p>
     4.为接口写xml文档,编写sql语句
    </p>
    <p>
     5.调用接口方法即可
    </p>
    <h3>
     数据处理
    </h3>
    <h4>
     #{}和${}
    </h4>
    <h5>
     <strong>
      1.
      <code>
       #{}
      </code>
      （PreparedStatement 方式，占位符）
     </strong>
    </h5>
    <h6>
     <strong>
      特点
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       采用
       <strong>
        预编译
       </strong>
       方式，使用
       <strong>
        JDBC
        <code>
         PreparedStatement
        </code>
       </strong>
       进行 SQL 传参。
      </p>
     </li>
     <li>
      <p>
       <strong>
        防止 SQL 注入
       </strong>
       ，因为参数是作为
       <strong>
        占位符
       </strong>
       传递，而不是直接拼接 SQL 语句。
      </p>
     </li>
     <li>
      <p>
       性能较优，SQL 解析和执行效率较高。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      2.
      <code>
       ${}
      </code>
      （字符串替换方式）
     </strong>
    </h5>
    <h6>
     <strong>
      特点
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       直接进行
       <strong>
        字符串拼接
       </strong>
       ，参数会被
       <strong>
        原样替换
       </strong>
       到 SQL 语句中。
      </p>
     </li>
     <li>
      <p>
       <strong>
        容易引发 SQL 注入
       </strong>
       ，因为参数值直接拼接到 SQL 语句里。
      </p>
     </li>
     <li>
      <p>
       主要用于
       <strong>
        动态 SQL（表名、列名）
       </strong>
       需要动态拼接的场景。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">&lt;select id="getUserByColumn" resultType="User"&gt;
    SELECT * FROM user WHERE ${column} = #{value}
&lt;/select&gt;
    编译的语句
SELECT * FROM user WHERE username = ?</code></pre>
    <pre></pre>
    <p>
     多个参数时
    </p>
    <p>
     @param注解可指定参数
    </p>
    <p>
     `
    </p>
    <p>
     编写sql语句时,若类的属性名和数据库的字段名不同,会导致数据无法赋值
    </p>
    <p>
     解决方式
    </p>
    <p>
     1.让属性名和字段名一样(不推荐)
    </p>
    <p>
     2.编写sql语句时,给字段名起别名成属性名
    </p>
    <p>
     3.在配置文件中声明驼峰命名转换
     <code>
      mybatis.configuration.map-underscore-to-camel-case=true
     </code>
    </p>
    <p>
     4.在Mapperxml文件里写resultMap改名
    </p>
    <pre><code class="language-XML">&lt;resultMap id="EmpRM" type="org.example.mybatis01helloworld.bean.Emp"&gt;
       &lt;id column="id" property="id" /&gt;
       &lt;result column="emp_name" property="empName" /&gt;
       &lt;result column="age" property="age" /&gt;
       &lt;result column="emp_salary" property="empSalary" /&gt;
   &lt;/resultMap&gt;</code></pre>
    <p>
     最佳实践:
    </p>
    <p>
     1.开启驼峰命名规则
    </p>
    <p>
     2.1 搞不定的用自定义映射(resultMap)
    </p>
    <h3>
     关联查询
    </h3>
    <p>
     一对一的映射用association标签
    </p>
    <pre><code class="language-XML">&lt;resultMap id="userResultMap" type="User"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="name" column="name"/&gt;
    &lt;association property="address" javaType="Address"&gt;
        &lt;id property="id" column="address_id"/&gt;
        &lt;result property="city" column="city"/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
&lt;select id="getUserWithAddress" resultMap="userResultMap"&gt;
    SELECT u.id, u.name, a.id as address_id, a.city
    FROM users u
    LEFT JOIN addresses a ON u.address_id = a.id
    WHERE u.id = #{id}
&lt;/select&gt;</code></pre>
    <p>
     一对多映射使用collection标签
    </p>
    <pre><code class="language-XML">&lt;resultMap id="departmentResultMap" type="Department"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="name" column="name"/&gt;
    &lt;collection property="employees" ofType="Employee"&gt;
        &lt;id property="id" column="employee_id"/&gt;
        &lt;result property="name" column="employee_name"/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;select id="getDepartmentWithEmployees" resultMap="departmentResultMap"&gt;
    SELECT d.id, d.name, e.id as employee_id, e.name as employee_name
    FROM departments d
    LEFT JOIN employees e ON d.id = e.department_id
    WHERE d.id = #{id}
&lt;/select&gt;</code></pre>
    <h5>
     原生分布查询
    </h5>
    <p>
     编写多个sql语句,调用多次方法
    </p>
    <h5>
     自动分布查询
    </h5>
    <pre><code class="language-XML">&lt;resultMap id="DepartmentResultMap" type="Department"&gt;
    &lt;id property="id" column="id"/&gt;
    &lt;result property="name" column="name"/&gt;
    &lt;!-- 一对多分步查询 --&gt;
    &lt;collection property="employees" column="id"#传入的参数 select="getEmployeesByDeptId"#自动执行的sql语句 fetchType="lazy"/&gt;
&lt;/resultMap&gt;
​
&lt;select id="getDepartmentById" resultMap="DepartmentResultMap"&gt;
    SELECT * FROM department WHERE id = #{id}
&lt;/select&gt;
​
&lt;select id="getEmployeesByDeptId" resultType="Employee"&gt;
    SELECT * FROM employee WHERE department_id = #{id}
&lt;/select&gt;</code></pre>
    <pre><span style="background-color:#fe2c24">要点: select属性写sql语句 column传入参数</span>
</pre>
    <h3>
     动态sql
    </h3>
    <p>
     &lt;if test="   "&gt;判断是否执行
    </p>
    <pre><code class="language-XML">&lt;select id="getUsers" resultType="User"&gt;
    SELECT * FROM user
    WHERE 1=1#防止逻辑错误
    &lt;if test="name != null"&gt;
        AND name = #{name}
    &lt;/if&gt;
    &lt;if test="age != null"&gt;
        AND age = #{age}
    &lt;/if&gt;
&lt;/select&gt;</code></pre>
    <pre></pre>
    <p>
     where标签 解决where后面无条件或多and
    </p>
    <p>
     set 标签 解决不传值时多逗号的情况
    </p>
    <p>
     trim标签 可以代替where 和set 标签
    </p>
    <ul>
     <li>
      <p>
       <strong>
        prefix
       </strong>
       ：指定需要添加的前缀，例如
       <code>
        WHERE
       </code>
       或
       <code>
        SET
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        prefixOverrides
       </strong>
       ：指定需要移除的前缀，比如
       <code>
        AND
       </code>
       、
       <code>
        OR
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        suffix
       </strong>
       ：指定需要添加的后缀。
      </p>
     </li>
     <li>
      <p>
       <strong>
        suffixOverrides
       </strong>
       ：指定需要移除的后缀。
      </p>
     </li>
    </ul>
    <p>
     choose/when/ortherwise 相当于switch(break)一旦找到配匹配的when就不会继续检查后面的when了
    </p>
    <pre><code class="language-XML">&lt;select id="getUser" resultType="User"&gt;
    SELECT * FROM user
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test="id != null"&gt;
                id = #{id}
            &lt;/when&gt;
            &lt;when test="name != null"&gt;
                name = #{name}
            &lt;/when&gt;
            &lt;otherwise&gt;
                1=1
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre>
    <p>
     foreach标签 collection 集合名
    </p>
    <p>
     item 集合中的变量
    </p>
    <p>
     separator 设置分隔符
    </p>
    <p>
     open 指定开始的前缀
    </p>
    <p>
     close 结束后缀
    </p>
    <pre><code class="language-XML">&lt;select id="getUsersByIds" resultType="User"&gt;
    SELECT * FROM user WHERE id IN
    &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt;
        #{id}
    &lt;/foreach&gt;
&lt;/select&gt;</code></pre>
    <h4>
     抽取可复用的sql片段
    </h4>
    <p>
     &lt;sql id = "column_name"&gt;
    </p>
    <p>
     xxxx
    </p>
    <p>
     &lt;/sql&gt;
    </p>
    <h4>
     缓存机制
    </h4>
    <h5>
     两级缓存机制:
    </h5>
    <p>
     一级缓存机制
    </p>
    <p>
     <strong>
      同一个
      <code>
       SqlSession
      </code>
      内
     </strong>
     共享缓存,第一次查询数据库并缓存结果,第二次查询相同的sql时不访问数据库,直接从缓存取
    </p>
    <p>
     二级缓存机制:
    </p>
    <p>
     手动开启,在同一个mapper内,跨sqlsession共享
    </p>
    <p>
     查找顺序:二一库
    </p>
    <p>
     1.事务级别 默认开启
    </p>
    <p>
     &lt;!---同一个事务期间,前面查询的数据,后面如果要执行相同查询,会从一级缓存中获取数据--&gt;
    </p>
    <p>
     有时候缓存会失效:缓存不命中
    </p>
    <ol>
     <li>
      <p>
       查询的东西不一样
      </p>
     </li>
     <li>
      <p>
       两次查询之间,进行了增删改(Mybatis会认为数据库发生了改变,所以要再发送一次查询)
      </p>
     </li>
    </ol>
    <p>
     2.所有事务共享 :需要手动配置开启
    </p>
    <p>
    </p>
    <p>
     分页插件
    </p>
    <p>
     1.手写limit语句
    </p>
    <pre>SELECT * FROM table_name LIMIT offset, pageSize;</pre>
    <p>
     <strong>
      <code>
       offset
      </code>
     </strong>
     ：跳过的记录数（
     <code>
      (pageNum - 1) * pageSize
     </code>
     ）
    </p>
    <p>
     <strong>
      <code>
       pageSize
      </code>
     </strong>
     ：每页显示的记录数
    </p>
    <p>
     2.使用PageHelper插件
    </p>
    <p>
     导入依赖
    </p>
    <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.3.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
    <p>
     service层
    </p>
    <pre>import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
​
</pre>
    <pre><code class="language-java">public PageInfo&lt;User&gt; getUsersByPage(int pageNum, int pageSize) {
    PageHelper.startPage(pageNum, pageSize);  // 开启分页
    List&lt;User&gt; users = userMapper.getAllUsers();  // 查询所有
    return new PageInfo&lt;&gt;(users);  // 封装分页信息
}</code></pre>
    <p>
     controller层实现
    </p>
    <hr/>
    <h2>
     MybatisPlus
    </h2>
    <p>
     适合单表查询,多表查询还是自己编写更好
    </p>
    <p>
     快速入门
    </p>
    <p>
     导入依赖
    </p>
    <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.5.10.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
    <p>
     在接口继承BaseMaper&lt;T&gt;
    </p>
    <p>
     注入依赖.就可调用各种单表查询的方法
    </p>
    <p>
    </p>
    <p>
     MybatisPlus通过扫描实体类,基于反射获取实体类信息作为数据库表信息
    </p>
    <ul>
     <li>
      <p>
       类名驼峰转下划线作为表名
      </p>
     </li>
     <li>
      <p>
       名为id的字段作为主键
      </p>
     </li>
     <li>
      <p>
       变量名驼峰转下划线作为表的字段名
      </p>
     </li>
    </ul>
    <p>
     常用注解
    </p>
    <p>
     @TableName: 用来指定表名
    </p>
    <p>
     @TableId: 用来指定表中的主键字段
    </p>
    <p>
     @TableField: 用来指定表中的普通字段信息
    </p>
    <p>
     成员变量名和数据库字段名不一致
    </p>
    <p>
     成员变量名以is开头,且是布尔值
    </p>
    <p>
     成员变量名和数据库关键字冲突
    </p>
    <p>
     成员变量不是数据库字段
     <code>
      @TableField(exist = false)
     </code>
    </p>
    <p>
     常见配置
    </p>
    <p>
     <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/b25d33ddd13a4ac9869d96fb5da7c5fb.png" width="1500"/>
    </p>
    <p>
     核心功能
    </p>
    <p>
     条件构造器Wrapper
    </p>
    <p>
     基于QueryWrapper的查询
    </p>
    <pre><code class="language-java">1.查询出名字中带o的,存款大于等于1000元的人的id,username,info,balance字段
     @Test
    public void testQueryWrapper(){
        //构建查询对象
        QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;User&gt;().select("id", "username", "info", "balance")
                .like("username", "o")
                .gt("balance", 1000);
        //查询
        List&lt;User&gt; users = userMapper.selectList(userQueryWrapper);
        log.info("users = " + users);
        users.forEach(System.out::println);
    }
2.更新用户名为jack的用户工资 为2k
    @Test
    public void testUpdateByQueryWrapper(){
        User user = new User();
        user.setBalance(20000);
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq("username", "jack");
        userMapper.update(user,wrapper);
    }</code></pre>
    <p>
     基于UpdateWrapper的查询
    </p>
    <pre><code class="language-java">1.把id为 1,2,4的用户工资减200
    @Test
    public void testReduceUserBalance(){
        List&lt;Long&gt; ids = List.of(1L, 2L,  4L);
        UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;().setSql("balance =  balance-200")
                                                            .in("id",ids);
        userMapper.update(null,wrapper);
    }</code></pre>
    <p>
     使用lambdaQueryWrapper和LambdaUpdateWrapper
    </p>
    <pre><code class="language-java"> @Test
    public void testQueryWrapper(){
        //构建查询对象
        LambdaQueryWrapper&lt;User&gt; userQueryWrapper = new LambdaQueryWrapper&lt;User&gt;().select(User::getId,User::getUsername,User::getInfo,User::getBalance)
                .like(User::getUsername, "o")
                .gt(User::getBalance, 1000);
        //查询
        List&lt;User&gt; users = userMapper.selectList(userQueryWrapper);
        
        users.forEach(System.out::println);
    }</code></pre>
    <p>
     自定义SQL
    </p>
    <p>
     1.通过注解方式编写自定义sql
    </p>
    <pre><code class="language-java">public interface UserMapper extends BaseMapper&lt;User&gt; {
​
    @Select("SELECT * FROM user WHERE age &gt; #{age}")
    List&lt;User&gt; selectByAge(int age);
}</code></pre>
    <p>
     <strong>
      <code>
       @Select
      </code>
     </strong>
     注解可以用于执行
     <strong>
      查询操作
     </strong>
     。
    </p>
    <p>
     你也可以使用
     <code>
      @Insert
     </code>
     、
     <code>
      @Update
     </code>
     、
     <code>
      @Delete
     </code>
     注解来编写相应的操作 SQL。
    </p>
    <p>
     利用mp构建复杂的where条件,然后剩下的sql语句自己写
    </p>
    <h5>
     IService接口
    </h5>
    <pre><code class="language-java">创建一个继承自IService的接口

public interface IUserService extends IService&lt;User&gt; {
    void deductBalanceById(Long id, Integer money);//可自定义方法
}
创建接口的实现类,还要继承ServiceImpl&lt;UserMapper,User&gt;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;
​
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {
    // 通过继承 ServiceImpl，就不需要显式实现 CRUD 方法
    @Override
    public User getUserByEmail(String email) {
        return baseMapper.selectOne(new QueryWrapper&lt;User&gt;().eq("email", email));
    }
}</code></pre>
    <p>
     实际开发中,使用IService接口更常见
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38363537373136322f:61727469636c652f64657461696c732f313436323739303338" class_="artid" style="display:none">
 </p>
</div>


