---
layout: post
title: "SQL-递归CTE"
date: 2025-03-11 13:25:13 +0800
description: "WITH 临时笔记本 AS (SELECT ... FROM ... -- 先写点笔记SELECT * FROM 临时笔记本;-- 再用笔记做分析特点：📌 临时性：仅在当前查询有效（像一次性草稿纸）🧩 可复用：可在一个查询中多次引用🪄 自描述：增强SQL可读性（比子查询更清晰）清晰结构：WITH CTE名称 AS (...) 像写大纲递归力量：UNION ALL + 终止条件 实现循环严格模式生存法则：GROUP BY 要完整！"
keywords: "✨SQL-递归CTE"
categories: ['未分类']
tags: ['数据库', 'Sql']
artid: "146176461"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146176461
    alt: "SQL-递归CTE"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146176461
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146176461
cover: https://bing.ee123.net/img/rand?artid=146176461
image: https://bing.ee123.net/img/rand?artid=146176461
img: https://bing.ee123.net/img/rand?artid=146176461
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ✨SQL-递归CTE
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     📖 SQL魔法课堂：CTE「时间折叠术」全解
    </p>
    <h3>
     <a id="_CTE_1">
     </a>
     🎩 第一章：什么是CTE？
    </h3>
    <p>
     CTE（Common Table Expression） 就像 SQL 里的「临时笔记本」📒：
    </p>
    <pre><code>WITH 临时笔记本 AS (  
    SELECT ... FROM ...  -- 先写点笔记
)
SELECT * FROM 临时笔记本;  -- 再用笔记做分析
</code></pre>
    <p>
     特点：
     <br/>
     📌 临时性：仅在当前查询有效（像一次性草稿纸）
     <br/>
     🧩 可复用：可在一个查询中多次引用
     <br/>
     🪄 自描述：增强SQL可读性（比子查询更清晰）
    </p>
    <h3>
     <a id="_CTE_15">
     </a>
     🌟 第二章：递归CTE——时间魔法师
    </h3>
    <p>
     当CTE学会「自我复制」，它就成了处理树形结构、日期序列的利器！
    </p>
    <p>
     🔮 经典结构：
    </p>
    <pre><code>WITH RECURSIVE 时间魔法师 AS (
    -- 🪄 初始咒语（锚点）
    SELECT 开始时间, 结束时间 FROM 时间表 WHERE...
    
    UNION ALL  -- 连接符
    
    -- 🔄 递归咒语（时间+1天）
    SELECT 开始时间, 结束时间 + 1天 
    FROM 时间魔法师 
    WHERE 结束时间 &lt; 目标时间
)
</code></pre>
    <p>
     举个栗子🌰：
     <br/>
     把「2025-03-10 到 2025-03-12」的假期拆分成三天：
    </p>
    <pre><code>WITH RECURSIVE 拆分假期 AS (
    SELECT '2025-03-10' AS 假期日, '2025-03-12' AS 结束日
    UNION ALL
    SELECT 假期日 + 1 DAY, 结束日 
    FROM 拆分假期 
    WHERE 假期日 &lt; 结束日
)
SELECT * FROM 拆分假期;
</code></pre>
    <p>
     输出结果：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        假期日
       </th>
       <th>
        结束日
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        2025-03-10
       </td>
       <td>
        2025-03-12
       </td>
      </tr>
      <tr>
       <td>
        2025-03-11
       </td>
       <td>
        2025-03-12
       </td>
      </tr>
      <tr>
       <td>
        2025-03-12
       </td>
       <td>
        2025-03-12
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_CTE_52">
     </a>
     🛠️ 第三章：CTE实战——假期拆分器
    </h3>
    <p>
     需求：把员工请假记录按天展开，并关联企业ID
    </p>
    <pre><code>WITH RECURSIVE 假期拆分器 AS (
    -- 🎯 锚点：获取原始请假单
    SELECT 
        vacation_id,
        emp_id,
        ent_id,
        DATE(start_time) AS 开始日,
        DATE(end_time) AS 结束日
    FROM vacation 
    WHERE emp_id = 1001
    
    UNION ALL
    
    -- ⏳ 递归：每天+1直到结束日
    SELECT 
        vacation_id,
        emp_id,
        ent_id,
        开始日 + INTERVAL 1 DAY,
        结束日
    FROM 假期拆分器
    WHERE 开始日 &lt; 结束日
)
SELECT 
    ent_id,
    开始日 AS work_date,
    'holiday' AS type,
    vacation_id
FROM 假期拆分器
ORDER BY 开始日 DESC;
</code></pre>
    <p>
     效果：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        ent_id
       </th>
       <th>
        work_date
       </th>
       <th>
        type
       </th>
       <th>
        vacation_id
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1001
       </td>
       <td>
        2025-03-12
       </td>
       <td>
        holiday
       </td>
       <td>
        202
       </td>
      </tr>
      <tr>
       <td>
        1001
       </td>
       <td>
        2025-03-11
       </td>
       <td>
        holiday
       </td>
       <td>
        202
       </td>
      </tr>
      <tr>
       <td>
        1001
       </td>
       <td>
        2025-03-10
       </td>
       <td>
        holiday
       </td>
       <td>
        202
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="__94">
     </a>
     ⚠️ 第四章：避坑指南
    </h3>
    <p>
     严格模式咬人🐞：
    </p>
    <p>
     错误：1055 - Expression not in GROUP BY
     <br/>
     解法：GROUP BY 必须包含所有非聚合字段
    </p>
    <pre><code>GROUP BY vacation_day, vacation_id, ent_id
</code></pre>
    <p>
     递归深度限制：
    </p>
    <p>
     默认最大递归100次，超长链需设置：
    </p>
    <pre><code>SET @@cte_max_recursion_depth = 365;  -- 允许拆一年假期
</code></pre>
    <p>
     性能优化：
    </p>
    <pre><code>📌 索引：vacation(emp_id, start_time, end_time)
🚫 避免大表递归：超过1万行的递归可能变慢
</code></pre>
    <h3>
     <a id="_CTE_113">
     </a>
     💡 第五章：什么时候用CTE？
    </h3>
    <table>
     <thead>
      <tr>
       <th align="center">
        场景
       </th>
       <th align="right">
        优点
       </th>
       <th align="right">
        举个栗
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        多层嵌套查询
       </td>
       <td align="right">
        代码更易读 🧐
       </td>
       <td align="right">
        报表统计中的多步骤计算
       </td>
      </tr>
      <tr>
       <td align="center">
        递归结构处理
       </td>
       <td align="right">
        轻松拆解树形数据
       </td>
       <td align="right">
        🌲 组织架构、日期序列
       </td>
      </tr>
      <tr>
       <td align="center">
        临时结果复用
       </td>
       <td align="right">
        避免重复计算
       </td>
       <td align="right">
        ⚡ 多个JOIN用同一子查询
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_CTE_120">
     </a>
     ✨ 总结：CTE的魔法三要素
    </h3>
    <pre><code>清晰结构：WITH CTE名称 AS (...) 像写大纲
递归力量：UNION ALL + 终止条件 实现循环
严格模式生存法则：GROUP BY 要完整！
</code></pre>
    <h3>
     <a id="_DEMO_126">
     </a>
     ✨ DEMO：查询假期分页
    </h3>
    <pre><code>WITH RECURSIVE vacation_days AS (
    SELECT 
        vacation_id,
        emp_id,
        ent_id,  -- 明确包含需要输出的字段
        DATE(start_time) AS vacation_day,
        DATE(end_time) AS end_day
    FROM vacation 
    WHERE 
        emp_id = #{emp_id}
        AND audit_status = 2
        AND del_flag = 0
    UNION ALL
    SELECT 
        vacation_id,
        emp_id,
        ent_id,  -- 递归时保留必要字段
        vacation_day + INTERVAL 1 DAY,
        end_day
    FROM vacation_days
    WHERE vacation_day &lt; end_day
)
SELECT 
    vd.ent_id,
    DATE_FORMAT(vd.vacation_day, '%Y-%m-%d') AS work_date,
    'holiday' AS type,
    vd.vacation_id
FROM vacation_days vd
-- 修正分组条件（添加ent_id保证GROUP BY完整性）
GROUP BY vd.vacation_day, vd.vacation_id, vd.ent_id  
ORDER BY vd.vacation_day DESC
LIMIT #{pageSize} OFFSET #{offset};
</code></pre>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33383839353930352f:61727469636c652f64657461696c732f313436313736343631" class_="artid" style="display:none">
 </p>
</div>


