---
layout: post
title: "系统架构设计师操作系统-进程管理-进程死锁-死锁-四大条件-死锁资源数计算-"
date: 2025-03-07 23:45:00 +0800
description: "一、进程 死锁1、死锁 概念2、死锁 案例 ( 重点 )3、死锁 四大条件4、解除死锁 - 破坏 死锁 四大条件5、解除死锁 - 有序分配6、解除死锁 - 银行家算法二、软考考点1、死锁资源数计算 案例2、死锁资源数计算公式 13、死锁资源数计算公式 24、鸽巢原理"
keywords: "【系统架构设计师】操作系统 - 进程管理 ⑤ ( 进程死锁 | 死锁 四大条件 | 死锁资源数计算 )"
categories: ['系统架构设计师']
tags: ['进程管理', '进程死锁', '软考', '系统架构设计师', '死锁资源', '死锁', '操作系统']
artid: "145816176"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145816176
    alt: "系统架构设计师操作系统-进程管理-进程死锁-死锁-四大条件-死锁资源数计算-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145816176
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145816176
cover: https://bing.ee123.net/img/rand?artid=145816176
image: https://bing.ee123.net/img/rand?artid=145816176
img: https://bing.ee123.net/img/rand?artid=145816176
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【系统架构设计师】操作系统 - 进程管理 ⑤ ( 进程死锁 | 死锁 四大条件 | 死锁资源数计算 )
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night-eighties" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <br/>
    <br/>
    <br/>
    <br/>
    <h2>
     <a id="__8">
     </a>
     一、进程 死锁
    </h2>
    <hr/>
    <br/>
    <br/>
    <h3>
     <a id="1__16">
     </a>
     1、死锁 概念
    </h3>
    <br/>
    <p>
     <strong>
      死锁 概念 :
     </strong>
     <font color="blue">
      两个或两个以上的进程
     </font>
     , 在执行过程中 , 因
     <font color="red">
      争夺资源
     </font>
     而造成的一种
     <font color="purple">
      互相等待的现象
     </font>
     , 如果没有外力作用 ,
     <font color="orange">
      所有进程都无法继续执行
     </font>
     , 进程 等待 不可能发生的条件 , 就会产生 " 死锁 " ;
    </p>
    <p>
     <strong>
      死锁 进程 :
     </strong>
     多个进程产生 " 死锁 " , 就会造成
     <font color="green">
      " 系统死锁 "
     </font>
     , 这些
     <font color="magenta">
      永远在互相等待的进程称为 " 死锁进程 " ;
     </font>
    </p>
    <br/>
    <h3>
     <a id="2_____28">
     </a>
     2、死锁 案例 ( 重点 )
    </h3>
    <br/>
    <p>
     <strong>
      进程死锁 案例 :
     </strong>
     进程 1 和 进程 2 都在运行 ;
    </p>
    <ul>
     <li>
      <font color="blue">
       进程 1 需要 资源 A 和 资源 B
      </font>
      , 已经持有 资源 A , 等待 资源 B ;
     </li>
     <li>
      <font color="red">
       进程 2 需要 资源 B 和 资源 A
      </font>
      , 已经持有 资源 B , 等待 资源 A ;
     </li>
     <li>
      两个进程
      <font color="purple">
       都不释放 已有资源 ;
      </font>
     </li>
     <li>
      系统
      <font color="orange">
       不剥夺 每个进程的 已有资源 ;
      </font>
     </li>
     <li>
      这里 产生了
      <font color="green">
       环路等待 ;
      </font>
     </li>
    </ul>
    <p>
     这样就产生了死锁 , 如下图所示 :
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/22f5a6e00a254ebcb02d888c21d2d9a1.png"/>
    </p>
    <br/>
    <h3>
     <a id="3__48">
     </a>
     3、死锁 四大条件
    </h3>
    <br/>
    <p>
     <strong>
      " 死锁 " 形成 需要满足以下 四大条件 :
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       互斥条件 ( Mutual Exclusion ) :
      </strong>
      <font color="blue">
       资源具有排他性
      </font>
      , 即
      <font color="red">
       一个资源每次只能被一个进程独占使用
      </font>
      , 造成 死锁 的资源 是 " 互斥 " 的 , 同一时间只能有一个进程访问该资源 ;
     </li>
     <li>
      <strong>
       占有且等待 ( Hold and Wait ) :
      </strong>
      进程
      <font color="purple">
       已持有至少一个资源
      </font>
      , 同时又在
      <font color="orange">
       请求其他资源 , 且请求的资源被其他进程占有
      </font>
      , 进程 会 " 保持 " 当前 已经拥有的资源 , 并且保持等待状态 ;
     </li>
     <li>
      <strong>
       不可剥夺 ( No Preemption ) :
      </strong>
      进程
      <font color="green">
       已获得的资源在未使用完毕前 , 不能被强制剥夺
      </font>
      ,
      <font color="magenta">
       只能由进程主动释放
      </font>
      , 进程 " 不剥夺 " 其它进程 占有的 本应用急需的 资源 ;
     </li>
     <li>
      <strong>
       循环等待 ( Circular Wait ) :
      </strong>
      <font color="cyan">
       存在一个 进程等待链 ,
       <font color="brown">
        每个进程都在等待 下一个进程 持有的资源 ,
        <font color="black">
         形成环路 , 多个进程 等待的 资源 形成环路 ;
        </font>
       </font>
      </font>
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a0abb57bf73e427ab842e0908f80b8a4.png"/>
    </p>
    <br/>
    <h3>
     <a id="4_____64">
     </a>
     4、解除死锁 - 破坏 死锁 四大条件
    </h3>
    <br/>
    <p>
     上述
     <font color="blue">
      四大条件 只要打破任意一个 ,
      <font color="red">
       就可以解除 " 死锁 " 状态 ,
       <font color="black">
        破坏死锁条件的方式 :
       </font>
      </font>
     </font>
    </p>
    <ul>
     <li>
      <strong>
       互斥条件 ( Mutual Exclusion ) :
      </strong>
      <font color="purple">
       允许资源共享
      </font>
      , 多个进程可共享同一资源 ;
     </li>
     <li>
      <strong>
       占有且等待 ( Hold and Wait ) :
      </strong>
      进程执行前需要
      <font color="orange">
       一次性申请所有资源
      </font>
      , 避免进程 占有资源却不执行 和 无限期等待申请不到的资源 ;
      <ul>
       <li>
        银行家算法 就是 破坏该条件 的解决方案 ;
       </li>
      </ul>
     </li>
     <li>
      <strong>
       不可剥夺 ( No Preemption ) :
      </strong>
      <font color="green">
       允许强制回收资源
      </font>
      , 该操作可能导致进程执行失败 ;
     </li>
     <li>
      <strong>
       循环等待 ( Circular Wait ) :
      </strong>
      <font color="magenta">
       有序分配算法
      </font>
      就是 破坏该条件 的解决方案 ;
     </li>
    </ul>
    <br/>
    <h3>
     <a id="5___82">
     </a>
     5、解除死锁 - 有序分配
    </h3>
    <br/>
    <p>
     有序分配法是一种通过破坏 " 循环等待 ( Circular Wait ) " 条件来避免死锁的方法 , 该算法的核心思想是要求 所有进程必须按照 相同的顺序 申请资源 ;
    </p>
    <ul>
     <li>
      <strong>
       资源排序 :
      </strong>
      对所有可申请的 资源 进行排序 , 每个进程在申请资源时必须严格按照这个顺序进行 ;
     </li>
     <li>
      <strong>
       进程申请 :
      </strong>
      当进程需要申请多个资源时 , 它必须 首先申请 序号最小的资源 , 然后申请 序号更大的资源 ;
     </li>
     <li>
      <strong>
       避免环路 :
      </strong>
      由于所有进程都按照相同的顺序申请资源 , 因此不会出现一个进程持有另一个进程所需的资源 , 同时又在等待第三个进程释放它所持有的资源的情况 , 从而避免了环路等待条件 ;
     </li>
    </ul>
    <p>
     有序分配法通过 循环等待 ( Circular Wait ) 条件来避免死锁 , 实现简单但 资源利用率低、灵活性差 ;
    </p>
    <br/>
    <h3>
     <a id="6___96">
     </a>
     6、解除死锁 - 银行家算法
    </h3>
    <br/>
    <p>
     银行家算法 是一种更为复杂但更为有效的避免死锁的方法 , 它以银行借贷系统的 分配策略 为基础 , 通过模拟资源分配的情况来确保系统始终处于安全状态 ;
    </p>
    <p>
     系统模拟资源分配过程 , 试图找到一个安全进程序列 , 按照这个序列分配资源后 , 每个进程都能顺利完成 ;
    </p>
    <p>
     如果能找到这样的安全序列 , 则系统处于安全状态 ; 否则 , 系统处于不安全状态 ;
    </p>
    <br/>
    <p>
     银行家算法 虽然实现复杂 , 但能够 动态地分配资源 , 并提高资源的利用率 ;
    </p>
    <br/>
    <br/>
    <br/>
    <br/>
    <h2>
     <a id="_117">
     </a>
     二、软考考点
    </h2>
    <hr/>
    <br/>
    <br/>
    <h3>
     <a id="1__124">
     </a>
     1、死锁资源数计算 案例
    </h3>
    <br/>
    <p>
     操作系统 中 有 3 个进程 , 每个进程都需要 5 个系统资源 , 系统资源数为 n , 分析系统中资源数量 与 死锁 的关联 ;
    </p>
    <ul>
     <li>
      <strong>
       n &lt; 5 的情况 :
      </strong>
      系统肯定死锁 ; 假如 系统只有 4 个资源 , 则任何一个进程无都法执行 , 整个系统死锁 ;
     </li>
     <li>
      <strong>
       n = 5 的情况 :
      </strong>
      大概率造成死锁 ;
      <ul>
       <li>
        最好情况 : 每次将所有资源分配给一个进程 , 3 个进程是有可能执行完毕的 ;
       </li>
       <li>
        最坏情况 : 假如 三个进程 分别持有若干资源不释放 , 则有可能造成死锁 ;
       </li>
      </ul>
     </li>
     <li>
      <strong>
       5 &lt; n &lt;= 12 的情况 :
      </strong>
      可能死锁 ;
      <ul>
       <li>
        n = 12 的最坏情况 : 三个进程平均分配资源 , 每个进程分配到 4 个资源 , 也会造成死锁 ;
       </li>
      </ul>
     </li>
     <li>
      <strong>
       n &gt;= 13 的情况 :
      </strong>
      不可能死锁 ;
      <ul>
       <li>
        只要在 n = 12 的情况下 , 再多增加一个资源 , 就会有一个进程可以执行完毕 , 释放出全部资源 , 死锁解除 ;
       </li>
      </ul>
     </li>
    </ul>
    <br/>
    <h3>
     <a id="2_1_143">
     </a>
     2、死锁资源数计算公式 1
    </h3>
    <br/>
    <p>
     <font color="blue">
      进程个数 m 个 ,
      <font color="red">
       每个进程需要资源数 w 个资源 ,
       <font color="purple">
        则资源数 n &gt;= m (w - 1) + 1 可以保证系统无法死锁 ;
       </font>
      </font>
     </font>
    </p>
    <br/>
    <h3>
     <a id="3_2_153">
     </a>
     3、死锁资源数计算公式 2
    </h3>
    <br/>
    <p>
     <font color="blue">
      进程个数 m 个 ,
      <font color="red">
       每个进程需要资源数 wi 个资源 ( i = 1, 2, … , m ) ,
      </font>
     </font>
    </p>
    <ul>
     <li>
      <p>
       第 1 个进程需要 w1 个资源 ;
      </p>
     </li>
     <li>
      <p>
       第 2 个进程需要 w2 个资源 ;
      </p>
      <p>
       …
      </p>
     </li>
     <li>
      <p>
       第 m 个进程需要 wm 个资源 ;
      </p>
     </li>
    </ul>
    <p>
     则资源数
     <font color="purple">
      <span class="katex--display">
       <span class="katex-display">
        <span class="katex">
         <span class="katex-mathml">
          n 
          
         
           ≥ 
          
          
          
            ∑ 
           
           
           
             i 
            
           
             = 
            
           
             1 
            
           
          
            m 
           
          
         
           ( 
          
          
          
            w 
           
          
            i 
           
          
         
           − 
          
         
           1 
          
         
           ) 
          
         
           + 
          
         
           1 
          
         
        
          n \geq \sum_{i = 1}^{m}(w_i - 1) + 1
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.7719em; vertical-align: -0.136em;">
           </span>
           <span class="mord mathnormal">
            n
           </span>
           <span class="mspace" style="margin-right: 0.2778em;">
           </span>
           <span class="mrel">
            ≥
           </span>
           <span class="mspace" style="margin-right: 0.2778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 2.9291em; vertical-align: -1.2777em;">
           </span>
           <span class="mop op-limits">
            <span class="vlist-t vlist-t2">
             <span class="vlist-r">
              <span class="vlist" style="height: 1.6514em;">
               <span class="" style="top: -1.8723em; margin-left: 0em;">
                <span class="pstrut" style="height: 3.05em;">
                </span>
                <span class="sizing reset-size6 size3 mtight">
                 <span class="mord mtight">
                  <span class="mord mathnormal mtight">
                   i
                  </span>
                  <span class="mrel mtight">
                   =
                  </span>
                  <span class="mord mtight">
                   1
                  </span>
                 </span>
                </span>
               </span>
               <span class="" style="top: -3.05em;">
                <span class="pstrut" style="height: 3.05em;">
                </span>
                <span class="">
                 <span class="mop op-symbol large-op">
                  ∑
                 </span>
                </span>
               </span>
               <span class="" style="top: -4.3em; margin-left: 0em;">
                <span class="pstrut" style="height: 3.05em;">
                </span>
                <span class="sizing reset-size6 size3 mtight">
                 <span class="mord mtight">
                  <span class="mord mathnormal mtight">
                   m
                  </span>
                 </span>
                </span>
               </span>
              </span>
              <span class="vlist-s">
               ​
              </span>
             </span>
             <span class="vlist-r">
              <span class="vlist" style="height: 1.2777em;">
               <span class="">
               </span>
              </span>
             </span>
            </span>
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord">
            <span class="mord mathnormal" style="margin-right: 0.0269em;">
             w
            </span>
            <span class="msupsub">
             <span class="vlist-t vlist-t2">
              <span class="vlist-r">
               <span class="vlist" style="height: 0.3117em;">
                <span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;">
                 <span class="pstrut" style="height: 2.7em;">
                 </span>
                 <span class="sizing reset-size6 size3 mtight">
                  <span class="mord mathnormal mtight">
                   i
                  </span>
                 </span>
                </span>
               </span>
               <span class="vlist-s">
                ​
               </span>
              </span>
              <span class="vlist-r">
               <span class="vlist" style="height: 0.15em;">
                <span class="">
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
           <span class="mspace" style="margin-right: 0.2222em;">
           </span>
           <span class="mbin">
            −
           </span>
           <span class="mspace" style="margin-right: 0.2222em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord">
            1
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mspace" style="margin-right: 0.2222em;">
           </span>
           <span class="mbin">
            +
           </span>
           <span class="mspace" style="margin-right: 0.2222em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 0.6444em;">
           </span>
           <span class="mord">
            1
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
      <font color="orange">
       可以保证系统无法死锁 ;
      </font>
     </font>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fded6befa9eb4b74a8eb23e41fde514d.png"/>
    </p>
    <br/>
    <h3>
     <a id="4_174">
     </a>
     4、鸽巢原理
    </h3>
    <br/>
    <p>
     <font color="blue">
      死锁资源数计算 的 底层原理 是 鸽巢原理 ;
     </font>
    </p>
    <br/>
    <p>
     <strong>
      鸽巢原理 :
     </strong>
    </p>
    <p>
     <font color="red">
      将 n + 1 个物体 放到 n 个盒子 中
     </font>
     , 则
    </p>
    <p>
     <font color="purple">
      一定存在一个盒子 中
      <font color="magenta">
       至少 含有 2 个 或 2 个以上的物体 ;
      </font>
     </font>
    </p>
    <p>
     <strong>
      <font color="blue">
       这个存在的一个盒子 就是
       <font color="red">
        为 " 进程 " 分配了 满足执行的所有资源 ;
       </font>
      </font>
     </strong>
    </p>
    <br/>
    <p>
     鸽巢原理 实际上是
     <font color="orange">
      多对少 的配置 ,
      <font color="green">
       至少存在一个多对一的情况 ;
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      参考 :
     </strong>
    </p>
    <ul>
     <li>
      <a href="https://blog.csdn.net/shulianghan/article/details/109103795">
       【组合数学】鸽巢原理 ( 鸽巢原理简单形式 | 鸽巢原理简单形式示例 1、2、3 )
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/shulianghan/article/details/109105928">
       【组合数学】鸽巢原理 ( 鸽巢原理简单形式示例 4、5 )
      </a>
     </li>
    </ul>
    <p>
     博客 ;
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f68616e313230323031322f:61727469636c652f64657461696c732f313435383136313736" class_="artid" style="display:none">
 </p>
</div>


