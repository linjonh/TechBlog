---
layout: post
title: "Java-面试-八股文计算机网络篇"
date: 2025-03-10 19:56:08 +0800
description: "HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于客户端（浏览器）和服务器之间通信的协议，主要用于传输网页数据，如HTML、CSS、JavaScript以及API请求等。它是无状态的，即每个请求都是独立的，服务器不会记录之前的请求信息。HTTP 和 HTTPS 的区别：1. 安全性：HTTP：数据是明文传输的，容易被中间人攻击、窃听和篡改。HTTPS：使用SSL/TLS（安全套接层/传输层安全协议）加密数据，提高数据的机密性和完整性，防止信息被窃取或篡改。"
keywords: "【Java 面试 八股文】计算机网络篇"
categories: ['基础知识', 'Java']
tags: ['面试', '计算机网络', 'Java']
artid: "146072332"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146072332
    alt: "Java-面试-八股文计算机网络篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146072332
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146072332
cover: https://bing.ee123.net/img/rand?artid=146072332
image: https://bing.ee123.net/img/rand?artid=146072332
img: https://bing.ee123.net/img/rand?artid=146072332
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Java 面试 八股文】计算机网络篇
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="1_HTTP_HTTP__HTTPS__1">
     </a>
     1. 什么是HTTP? HTTP 和 HTTPS 的区别?
    </h3>
    <p>
     HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于客户端（浏览器）和服务器之间通信的协议，主要用于传输网页数据，如HTML、CSS、JavaScript以及API请求等。它是无状态的，即每个请求都是独立的，服务器不会记录之前的请求信息。
    </p>
    <p>
     <strong>
      HTTP 和 HTTPS 的区别：
     </strong>
    </p>
    <p>
     <strong>
      1. 安全性：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       HTTP
      </strong>
      ：数据是明文传输的，容易被中间人攻击、窃听和篡改。
     </li>
     <li>
      <strong>
       HTTPS
      </strong>
      ：使用
      <strong>
       SSL/TLS（安全套接层/传输层安全协议）
      </strong>
      加密数据，提高数据的机密性和完整性，防止信息被窃取或篡改。
     </li>
    </ul>
    <p>
     <strong>
      2. 端口号：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       HTTP
      </strong>
      默认使用
      <strong>
       80
      </strong>
      端口。
     </li>
     <li>
      <strong>
       HTTPS
      </strong>
      默认使用
      <strong>
       443
      </strong>
      端口。
     </li>
    </ul>
    <p>
     <strong>
      3. 证书：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       HTTP
      </strong>
      不需要任何证书。
     </li>
     <li>
      <strong>
       HTTPS
      </strong>
      需要由
      <strong>
       CA（证书颁发机构）
      </strong>
      签发的 SSL/TLS 证书 进行身份认证，确保通信方的真实性。
     </li>
    </ul>
    <p>
     <strong>
      4. 性能：
     </strong>
    </p>
    <ul>
     <li>
      由于 HTTPS 需要进行加密和解密，理论上比 HTTP 稍慢，但现代硬件优化（如 TLS 1.3）使 HTTPS 的性能影响可以忽略不计。
     </li>
    </ul>
    <p>
     <strong>
      总结：
     </strong>
     <br/>
     HTTPS 相比 HTTP 更安全，能够有效防止数据泄露，尤其适用于涉及用户隐私和敏感信息的场景，如登录页面、支付页面等。因此，现在大部分网站都推荐使用 HTTPS。
    </p>
    <hr/>
    <h3>
     <a id="2_HTTPSHTTP_HTTPS_25">
     </a>
     2. 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？
    </h3>
    <p>
     HTTPS 比 HTTP 更安全，主要是因为它在 HTTP 的基础上加入了
     <strong>
      SSL/TLS（安全套接层/传输层安全协议）
     </strong>
     ，通过
     <strong>
      加密、身份验证和数据完整性保护
     </strong>
     来防止数据被窃取、篡改或伪造。
    </p>
    <p>
     <strong>
      HTTPS 主要通过以下三方面来提升安全性：
     </strong>
    </p>
    <p>
     <strong>
      1. 数据加密（防窃听）
     </strong>
    </p>
    <ul>
     <li>
      HTTPS 采用
      <strong>
       对称加密
      </strong>
      和
      <strong>
       非对称加密
      </strong>
      结合的方式，确保数据在传输过程中是加密的，即使黑客截获数据包，也无法解密。
     </li>
     <li>
      <strong>
       非对称加密（RSA、ECDSA）
      </strong>
      ：用于安全地交换对称密钥。
     </li>
     <li>
      <strong>
       对称加密（AES、ChaCha20）
      </strong>
      ：用于数据的高速加密传输。
     </li>
    </ul>
    <p>
     <strong>
      2. 认证机制（防中间人攻击）
     </strong>
    </p>
    <ul>
     <li>
      HTTPS 采用
      <strong>
       SSL/TLS 证书
      </strong>
      来验证服务器的身份，防止用户访问伪造网站。
     </li>
     <li>
      <strong>
       CA（证书颁发机构）
      </strong>
      颁发的
      <strong>
       数字证书
      </strong>
      可以保证网站的真实性，避免钓鱼攻击和中间人攻击。
     </li>
    </ul>
    <p>
     <strong>
      3. 数据完整性（防篡改）
     </strong>
    </p>
    <ul>
     <li>
      HTTPS 使用
      <strong>
       消息摘要算法（如 SHA-256）
      </strong>
      计算数据的哈希值，并通过
      <strong>
       HMAC（哈希消息认证码）
      </strong>
      进行完整性校验，确保数据在传输过程中不会被篡改。
     </li>
     <li>
      若数据被篡改，接收方计算出的哈希值与发送方的不匹配，通信将被中断。
     </li>
    </ul>
    <p>
     <strong>
      总结
     </strong>
     <br/>
     HTTPS 通过
     <strong>
      加密
     </strong>
     确保数据不被窃听，通过
     <strong>
      身份认证
     </strong>
     防止钓鱼网站，通过
     <strong>
      完整性校验
     </strong>
     防止数据被篡改，因此比 HTTP 更安全。现在，大部分网站、银行系统、电商平台等都采用 HTTPS 来保障数据安全。
    </p>
    <hr/>
    <h3>
     <a id="3_UDP__TCP___48">
     </a>
     3. 如何理解UDP 和 TCP? 区别? 应用场景?
    </h3>
    <h4>
     <a id="31_TCP__UDP__49">
     </a>
     3.1 TCP 和 UDP 的特点
    </h4>
    <p>
     UDP（User Datagram Protocol，用户数据报协议）和 TCP（Transmission Control Protocol，传输控制协议）是两种常见的
     <strong>
      传输层协议
     </strong>
     ，它们在数据传输方式、可靠性、连接管理等方面存在明显区别。
    </p>
    <p>
     <strong>
      UDP（User Datagram Protocol）
     </strong>
     ，用户数据包协议，是一个简单的
     <strong>
      面向数据报的通信协议
     </strong>
     ，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层。
    </p>
    <p>
     特点如下：
    </p>
    <ul>
     <li>
      UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
     </li>
     <li>
      传输途中出现丢包，UDP 也不负责重发
     </li>
     <li>
      当包的到达顺序出现乱序时，UDP没有纠正的功能。
     </li>
     <li>
      并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为
     </li>
    </ul>
    <p>
     <strong>
      TCP（Transmission Control Protocol）
     </strong>
     ，传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送
    </p>
    <p>
     特点如下：
    </p>
    <ul>
     <li>
      TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。
     </li>
     <li>
      此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。
     </li>
     <li>
      根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        TCP（面向连接）
       </th>
       <th>
        UDP（无连接）
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        连接方式
       </td>
       <td>
        需要
        <strong>
         三次握手
        </strong>
        建立连接，通信前后需要维护连接
       </td>
       <td>
        无需连接，直接发送数据
       </td>
      </tr>
      <tr>
       <td>
        可靠性
       </td>
       <td>
        <strong>
         可靠传输
        </strong>
        ：有确认机制（ACK）、重传机制、流量控制和拥塞控制
       </td>
       <td>
        <strong>
         不可靠传输
        </strong>
        ：无确认机制，可能丢包
       </td>
      </tr>
      <tr>
       <td>
        数据顺序
       </td>
       <td>
        <strong>
         有序传输
        </strong>
        ，接收方能按顺序组装数据
       </td>
       <td>
        <strong>
         无序传输
        </strong>
        ，可能乱序到达
       </td>
      </tr>
      <tr>
       <td>
        传输效率
       </td>
       <td>
        <strong>
         较低
        </strong>
        （因需保证可靠性）
       </td>
       <td>
        <strong>
         较高
        </strong>
        （因无连接管理，减少开销）
       </td>
      </tr>
      <tr>
       <td>
        数据单位
       </td>
       <td>
        以
        <strong>
         字节流
        </strong>
        传输，无固定边界
       </td>
       <td>
        以
        <strong>
         数据报（Datagram）
        </strong>
        传输，具有边界
       </td>
      </tr>
      <tr>
       <td>
        应用场景
       </td>
       <td>
        适用于
        <strong>
         数据可靠性高
        </strong>
        的场景，
       </td>
       <td>
        如文件传输、Web请求
        <strong>
         适用于实时性高
        </strong>
        、
        <strong>
         丢包可接受
        </strong>
        的场景，如视频通话、直播、DNS查询
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="32__82">
     </a>
     3.2 适用场景
    </h4>
    <p>
     <strong>
      适用于 TCP 的场景（强调可靠性）
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       HTTP/HTTPS（网页浏览）
      </strong>
      ：网页加载需要完整的数据，不允许丢失
     </li>
     <li>
      <strong>
       FTP（文件传输）
      </strong>
      ：传输文件时必须保证数据完整性
     </li>
     <li>
      <strong>
       SMTP/POP3/IMAP（电子邮件）
      </strong>
      ：邮件内容不能丢失或错乱
     </li>
     <li>
      <strong>
       数据库连接（MySQL、PostgreSQL）
      </strong>
      ：数据交互需要高可靠性
     </li>
    </ul>
    <p>
     <strong>
      适用于 UDP 的场景（强调实时性）
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       视频直播、在线会议（如 Zoom、直播推流）
      </strong>
      ：即使丢失部分数据，也要保证流畅
     </li>
     <li>
      <strong>
       在线游戏
      </strong>
      ：丢包影响不大，低延迟比数据完整性更重要
     </li>
     <li>
      <strong>
       DNS（域名解析）
      </strong>
      ：查询请求很短，丢失可重试，无需建立连接
     </li>
     <li>
      <strong>
       VoIP（网络语音通话）
      </strong>
      ：轻微丢包不会影响通话体验，减少延迟更重要
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="4_TCPIP_97">
     </a>
     4. 如何理解TCP/IP协议?
    </h3>
    <p>
     TCP/IP（Transmission Control Protocol/Internet Protocol）是一组用于
     <strong>
      互联网通信
     </strong>
     的协议，它定义了计算机如何通过网络进行数据传输。TCP/IP 是
     <strong>
      分层协议
     </strong>
     ，确保数据能够从一台计算机可靠地传输到另一台计算机。
    </p>
    <p>
     <strong>
      TCP/IP 的分层模型
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        TCP/IP 层
       </th>
       <th>
        对应 OSI 层
       </th>
       <th>
        主要协议
       </th>
       <th>
        作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        应用层
       </td>
       <td>
        应用层、表示层、会话层
       </td>
       <td>
        HTTP、HTTPS、FTP、SMTP、DNS
       </td>
       <td>
        提供具体应用服务（如网页浏览、邮件等）
       </td>
      </tr>
      <tr>
       <td>
        传输层
       </td>
       <td>
        传输层
       </td>
       <td>
        TCP、UDP
       </td>
       <td>
        负责端到端通信，提供可靠或非可靠传输
       </td>
      </tr>
      <tr>
       <td>
        网络层
       </td>
       <td>
        网络层
       </td>
       <td>
        IP、ICMP、ARP
       </td>
       <td>
        负责寻址与路由，将数据包从源传输到目标
       </td>
      </tr>
      <tr>
       <td>
        链路层
       </td>
       <td>
        数据链路层、物理层
       </td>
       <td>
        以太网、Wi-Fi、PPP
       </td>
       <td>
        负责物理设备间的通信
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     TCP/IP 是互联网通信的核心协议，提供数据传输的基础。
     <br/>
     TCP 负责可靠传输，IP 负责寻址和路由。
     <br/>
     TCP 适用于可靠传输场景，UDP 适用于高实时性场景。
    </p>
    <hr/>
    <h3>
     <a id="5_DNS_DNS__114">
     </a>
     5. DNS协议 是什么？说说DNS 完整的查询过程?
    </h3>
    <h4>
     <a id="51__DNS__115">
     </a>
     5.1 什么是 DNS 协议？
    </h4>
    <p>
     DNS（Domain Name System，域名系统）是一种
     <strong>
      将域名转换为 IP 地址
     </strong>
     的协议。由于人们更容易记住
     <code>
      www.google.com
     </code>
     这样的域名，而计算机网络使用 IP 地址（如
     <code>
      142.250.190.14
     </code>
     ）来标识服务器，因此 DNS 充当了
     <strong>
      域名解析服务
     </strong>
     ，帮助用户找到目标服务器的 IP 地址。
    </p>
    <p>
     DNS 是
     <strong>
      应用层协议
     </strong>
     ，通常使用
     <strong>
      UDP 53
     </strong>
     端口 进行查询，但某些情况下（如大数据包或安全需求）会使用 TCP 53 端口。
    </p>
    <h4>
     <a id="52_DNS__121">
     </a>
     5.2 DNS 解析的完整查询过程
    </h4>
    <p>
     当用户在浏览器中输入
     <code>
      www.example.com
     </code>
     并回车后，DNS 解析过程如下：
    </p>
    <p>
     📌
     <strong>
      查询步骤：
     </strong>
    </p>
    <p>
     <strong>
      1. 浏览器缓存
     </strong>
     （本地缓存）：
    </p>
    <ul>
     <li>
      浏览器会先检查本地缓存（如之前访问过
      <code>
       www.example.com
      </code>
      ）。
     </li>
     <li>
      如果有对应的 IP 地址，则直接使用，
      <strong>
       无需 DNS 查询
      </strong>
      。
     </li>
    </ul>
    <p>
     <strong>
      2. 操作系统缓存
     </strong>
     （本机 DNS 缓存）：
    </p>
    <ul>
     <li>
      如果浏览器没有找到，会向操作系统（
      <code>
       ipconfig /displaydns
      </code>
      ）查询本机缓存。
     </li>
     <li>
      如果缓存中有，则直接返回。
     </li>
    </ul>
    <p>
     <strong>
      3. 本地 DNS 服务器
     </strong>
     （ISP 提供的解析服务器）
    </p>
    <ul>
     <li>
      如果本机缓存中没有，操作系统会向
      <strong>
       本地 DNS
      </strong>
      服务器（通常由 ISP 提供，如电信、联通、移动）查询。
      <br/>
      本地 DNS 服务器如果有缓存，就直接返回
      <strong>
       IP 地址（递归查询）
      </strong>
      。
     </li>
    </ul>
    <p>
     <strong>
      4. 根 DNS 服务器
     </strong>
     （Root Servers）：
    </p>
    <ul>
     <li>
      若本地 DNS 服务器没有缓存，它会向
      <strong>
       根 DNS 服务器
      </strong>
      发起请求（全球 13 个根服务器，如
      <code>
       .
      </code>
      ）。
     </li>
     <li>
      根服务器不会直接返回 IP，而是告诉本地 DNS 去找
      <strong>
       顶级域（TLD）DNS 服务器
      </strong>
      （如
      <code>
       .com
      </code>
      ）。
     </li>
    </ul>
    <p>
     <strong>
      5. 顶级域（TLD）DNS 服务器
     </strong>
     （如
     <code>
      .com
     </code>
     服务器）：
    </p>
    <ul>
     <li>
      TLD 服务器负责管理
      <code>
       .com
      </code>
      、
      <code>
       .cn
      </code>
      、
      <code>
       .net
      </code>
      等顶级域。
     </li>
     <li>
      它会告诉本地 DNS，去找
      <strong>
       权威 DNS 服务器
      </strong>
      （如
      <code>
       example.com
      </code>
      的 DNS 服务器）。
     </li>
    </ul>
    <p>
     <strong>
      6. 权威 DNS 服务器
     </strong>
     （Authoritative DNS）：
    </p>
    <ul>
     <li>
      该服务器存储了
      <code>
       example.com
      </code>
      的真实 IP 地址，并返回给本地 DNS 服务器。
     </li>
    </ul>
    <p>
     <strong>
      7. 本地 DNS 服务器缓存并返回：
     </strong>
    </p>
    <ul>
     <li>
      本地 DNS 服务器缓存该结果，减少下次查询时间。
     </li>
     <li>
      然后返回给客户端（用户设备）。
     </li>
    </ul>
    <p>
     <strong>
      8.浏览器与服务器建立连接
     </strong>
     ：
    </p>
    <ul>
     <li>
      解析完 IP 地址后，浏览器使用
      <strong>
       TCP/IP
      </strong>
      与目标服务器建立
      <strong>
       HTTP/HTTPS
      </strong>
      连接。
     </li>
    </ul>
    <h4>
     <a id="53_DNS__156">
     </a>
     5.3 DNS 查询的类型
    </h4>
    <ul>
     <li>
      <strong>
       递归查询（Recursive Query）
      </strong>
      ：
      <br/>
      本地 DNS 服务器
      <strong>
       负责查到底
      </strong>
      ，直到找到 IP 地址（用户 → 本地 DNS → 找 IP）。
     </li>
     <li>
      <strong>
       迭代查询（Iterative Query）
      </strong>
      ：
      <br/>
      本地 DNS 服务器
      <strong>
       逐步向上查询
      </strong>
      ，直到找到 IP 地址（本地 DNS → 根 DNS → TLD DNS → 权威 DNS）。
     </li>
    </ul>
    <h4>
     <a id="54_DNS__163">
     </a>
     5.4 DNS 解析优化
    </h4>
    <ul>
     <li>
      <strong>
       本地缓存
      </strong>
      （浏览器、系统、DNS 服务器缓存）加速解析。
     </li>
     <li>
      <strong>
       CDN（内容分发网络）
      </strong>
      通过就近服务器提供解析，提高访问速度。
     </li>
     <li>
      <strong>
       负载均衡
      </strong>
      通过多个 IP 地址优化解析，减少服务器压力。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="6__HTTP101120__169">
     </a>
     6. 说说 HTTP1.0/1.1/2.0 的区别?
    </h3>
    <p>
     HTTP（HyperText Transfer Protocol）是
     <strong>
      超文本传输协议
     </strong>
     ，主要用于
     <strong>
      客户端（浏览器）和服务器之间的数据通信
     </strong>
     。随着 Web 需求的增长，HTTP 先后经历了
     <strong>
      HTTP/1.0 → HTTP/1.1 → HTTP/2.0
     </strong>
     的演进，提升了性能、并发能力和安全性。
    </p>
    <h4>
     <a id="61_HTTP_10_172">
     </a>
     6.1 HTTP 1.0
    </h4>
    <p>
     <strong>
      特点：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       无连接（非持久连接）
      </strong>
      ：每次请求都要建立 TCP 连接，完成后立刻关闭，导致
      <strong>
       资源浪费
      </strong>
      。
     </li>
     <li>
      <strong>
       串行请求
      </strong>
      ：浏览器请求资源时，每个请求必须等上一个完成才能继续，
      <strong>
       低效
      </strong>
      。
     </li>
     <li>
      无 Host 头：不支持虚拟主机，多个网站共用同一 IP 时，服务器无法识别请求属于哪个网站。
     </li>
     <li>
      不支持压缩：数据传输量大，加载慢。
     </li>
    </ul>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      每个请求都会创建新连接，
      <strong>
       增加服务器开销
      </strong>
      。
     </li>
     <li>
      <strong>
       队头阻塞（Head-of-line Blocking）
      </strong>
      ：必须等待前一个请求完成，才能发送下一个。
     </li>
    </ul>
    <h4>
     <a id="62_HTTP_11_183">
     </a>
     6.2 HTTP 1.1
    </h4>
    <p>
     <strong>
      相较 HTTP/1.0 的改进：
     </strong>
    </p>
    <p>
     ✅
     <strong>
      支持持久连接（Keep-Alive）
     </strong>
     ：
    </p>
    <ul>
     <li>
      默认
      <strong>
       复用 TCP 连接
      </strong>
      ，多个请求可复用一个 TCP 连接，减少
      <strong>
       频繁建立/断开连接的开销
      </strong>
      。
     </li>
     <li>
      通过
      <code>
       Connection: keep-alive
      </code>
      头部控制。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      支持管道化（Pipelining）
     </strong>
     ：
    </p>
    <ul>
     <li>
      允许多个请求同时发送，不必等待前一个请求结束（但仍会受到队头阻塞影响）。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      支持 Host 头
     </strong>
     ：
    </p>
    <ul>
     <li>
      允许在同一 IP 地址上托管多个网站（虚拟主机）。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      支持分块传输（Chunked Transfer Encoding）
     </strong>
     ：
    </p>
    <ul>
     <li>
      服务器可以
      <strong>
       逐块
      </strong>
      发送数据，不必等全部内容生成后再返回，提升性能。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      增加缓存控制（Cache-Control）
     </strong>
     ：
    </p>
    <ul>
     <li>
      增加 Cache-Control 头，支持
      <strong>
       缓存管理
      </strong>
      ，减少重复请求。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      断点续传（Range 请求）
     </strong>
     ：
    </p>
    <ul>
     <li>
      允许客户端请求某个资源的一部分（如视频流），提升下载体验。
     </li>
    </ul>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       仍然存在队头阻塞（HOL Blocking）
      </strong>
      ，同一 TCP 连接仍需等待上一个请求完成。
     </li>
     <li>
      <strong>
       不支持多路复用
      </strong>
      ，并发请求仍需多个 TCP 连接。
     </li>
    </ul>
    <h4>
     <a id="63_HTTP_20_211">
     </a>
     6.3 HTTP 2.0
    </h4>
    <p>
     <strong>
      HTTP/2 主要优化了性能，解决了 HTTP/1.1 并发低的问题。
     </strong>
    </p>
    <p>
     ✅
     <strong>
      二进制帧传输（Binary Framing）
     </strong>
     ：
    </p>
    <ul>
     <li>
      HTTP/1.x 使用 纯文本，HTTP/2 使用 二进制（更高效）。
     </li>
     <li>
      结构化数据传输，减少解析成本。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      多路复用（Multiplexing）——最大改进点
     </strong>
     ：
    </p>
    <ul>
     <li>
      允许
      <strong>
       多个请求同时在一个 TCP 连接上传输
      </strong>
      ，而不会互相阻塞，
      <strong>
       消除队头阻塞
      </strong>
      。
     </li>
     <li>
      之前 HTTP/1.1 一个 TCP 连接一次只能传输一个请求，
      <strong>
       HTTP/2 一个连接可并行处理多个请求
      </strong>
      。
     </li>
    </ul>
    <p>
     ✅ Header 压缩（HPACK）：
    </p>
    <ul>
     <li>
      HTTP/1.x 的请求头较大，每次请求都要携带，浪费带宽。
     </li>
     <li>
      HTTP/2 采用
      <strong>
       HPACK 压缩算法
      </strong>
      ，减少
      <strong>
       重复头部
      </strong>
      ，提升传输效率。
     </li>
    </ul>
    <p>
     ✅ 服务器推送（Server Push）：
    </p>
    <ul>
     <li>
      服务器可主动推送资源（如 CSS、JS），减少客户端请求，提高加载速度。
     </li>
    </ul>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      仍然基于 TCP，虽然解决了 HTTP/1.1 的队头阻塞问题，但 TCP 层仍可能有 队头阻塞。
     </li>
     <li>
      服务器需额外支持 HTTP/2，如 Nginx 需开启 HTTP/2 配置。
     </li>
     <li>
      浏览器和服务器都需支持 HTTP/2（现代浏览器基本支持）。
     </li>
    </ul>
    <h4>
     <a id="64_HTTP_30_QUIC_235">
     </a>
     6.4 HTTP 3.0（基于 QUIC）
    </h4>
    <p>
     <strong>
      HTTP/2 仍然基于 TCP，而 TCP 本身有队头阻塞问题。HTTP/3 采用 QUIC（基于 UDP），解决了 TCP 的缺陷。
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       使用 QUIC 协议（基于 UDP），减少握手延迟
      </strong>
     </li>
     <li>
      连接迁移能力更强（适用于移动网络）
     </li>
     <li>
      完全消除 TCP 层队头阻塞
     </li>
     <li>
      更安全（默认 TLS 1.3）
     </li>
    </ul>
    <h4>
     <a id="_244">
     </a>
     总结
    </h4>
    <p>
     <strong>
      版本对比总结
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        HTTP/1.0
       </th>
       <th>
        HTTP/1.1
       </th>
       <th>
        HTTP/2.0
       </th>
       <th>
        HTTP/3.0
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        连接复用
       </td>
       <td>
        ❌ 每次请求建立新 TCP 连接
       </td>
       <td>
        ✅ Keep-Alive
       </td>
       <td>
        ✅ 多路复用
       </td>
       <td>
        ✅ QUIC 连接复用
       </td>
      </tr>
      <tr>
       <td>
        管道化
       </td>
       <td>
        ❌
       </td>
       <td>
        ✅ 支持
       </td>
       <td>
        ✅ 完全支持
       </td>
       <td>
        ✅
       </td>
      </tr>
      <tr>
       <td>
        队头阻塞
       </td>
       <td>
        ✅ 串行请求
       </td>
       <td>
        ✅ 仍存在
       </td>
       <td>
        ❌ 解决（应用层）
       </td>
       <td>
        ❌（TCP 层也解决）
       </td>
      </tr>
      <tr>
       <td>
        数据传输格式
       </td>
       <td>
        文本
       </td>
       <td>
        文本
       </td>
       <td>
        二进制
       </td>
       <td>
        二进制
       </td>
      </tr>
      <tr>
       <td>
        Header 压缩
       </td>
       <td>
        ❌
       </td>
       <td>
        ❌
       </td>
       <td>
        ✅ HPACK
       </td>
       <td>
        ✅ QPACK
       </td>
      </tr>
      <tr>
       <td>
        服务器推送
       </td>
       <td>
        ❌
       </td>
       <td>
        ❌
       </td>
       <td>
        ✅ 支持
       </td>
       <td>
        ✅
       </td>
      </tr>
      <tr>
       <td>
        使用协议
       </td>
       <td>
        TCP
       </td>
       <td>
        TCP
       </td>
       <td>
        TCP
       </td>
       <td>
        QUIC（基于 UDP）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      候选人回答：
     </strong>
    </p>
    <blockquote>
     <p>
      HTTP1.0、HTTP1.1 和 HTTP2.0 主要在
      <strong>
       连接管理
      </strong>
      、
      <strong>
       并发性能
      </strong>
      和
      <strong>
       数据传输方式
      </strong>
      上有所不同。HTTP1.0 每次请求都要建立新的 TCP 连接，
      <strong>
       开销大
      </strong>
      ，
      <strong>
       性能低下
      </strong>
      。HTTP1.1 通过
      <code>
       Keep-Alive
      </code>
      复用 TCP 连接，
      <strong>
       支持管道化请求
      </strong>
      ，但仍然存在队头阻塞。HTTP2.0
      <strong>
       采用二进制帧传输
      </strong>
      ，并
      <strong>
       引入多路复用机制
      </strong>
      ，使得多个请求可以共享同一个 TCP 连接并行传输，从而提高了并发能力。同时，HTTP2.0 还
      <strong>
       支持头部压缩
      </strong>
      （HPACK）和
      <strong>
       服务器推送
      </strong>
      ，进一步减少了数据传输的冗余和延迟。总体来说，HTTP2.0 相较于 HTTP1.1 提升了网络效率，减少了延迟。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="7_HTTP__263">
     </a>
     7. 说说HTTP 常见的状态码有哪些，适用场景？
    </h3>
    <p>
     HTTP 状态码用于表示服务器对客户端请求的响应情况，常见的状态码包括以下几类：
    </p>
    <ul>
     <li>
      <strong>
       1xx（信息响应）
      </strong>
      ：表示请求已接收，需进一步操作。
      <ul>
       <li>
        100 Continue：表示服务器已接收到请求的部分数据，客户端可继续发送剩余部分。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       2xx（成功响应）
      </strong>
      ：表示请求成功。
      <ul>
       <li>
        200 OK：请求成功，服务器返回正常数据（常见于 GET 请求）。
       </li>
       <li>
        201 Created：请求成功，并且资源已被创建（常见于 POST 请求）。
       </li>
       <li>
        204 No Content：请求成功，但无返回内容（常见于 DELETE 请求）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       3xx（重定向）
      </strong>
      ：客户端需执行额外操作才能完成请求。
      <ul>
       <li>
        301 Moved Permanently：资源已永久移动，客户端应使用新的 URL 访问。
       </li>
       <li>
        302 Found（临时重定向）：资源临时移动，客户端仍可使用原 URL。
       </li>
       <li>
        304 Not Modified：资源未修改，客户端可使用本地缓存版本。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       4xx（客户端错误）
      </strong>
      ：请求错误，需客户端修正。
      <ul>
       <li>
        400 Bad Request：请求格式错误，服务器无法解析。
       </li>
       <li>
        401 Unauthorized：请求未认证，需提供身份凭证（如 JWT、OAuth）。
       </li>
       <li>
        403 Forbidden：服务器拒绝请求（权限不足）。
       </li>
       <li>
        404 Not Found：资源不存在（URL 错误或资源被删除）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       5xx（服务器错误）
      </strong>
      ：服务器处理请求时发生错误。
      <ul>
       <li>
        500 Internal Server Error：服务器内部错误，无法完成请求。
       </li>
       <li>
        502 Bad Gateway：服务器作为网关或代理，收到无效响应。
       </li>
       <li>
        503 Service Unavailable：服务器暂时无法处理请求（可能是过载或维护中）。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="8__GET__POST__288">
     </a>
     8. 说一下 GET 和 POST 的区别？
    </h3>
    <p>
     <code>
      GET
     </code>
     和
     <code>
      POST
     </code>
     ，两者是 HTTP 协议中发送请求的方法。
     <br/>
     <code>
      GET
     </code>
     方法
     <strong>
      从服务器获取指定的资源
     </strong>
     <br/>
     <code>
      POST
     </code>
     方法
     <strong>
      根据请求负荷（报文body）对指定的资源做出处理
     </strong>
    </p>
    <p>
     <strong>
      主要区别：
     </strong>
    </p>
    <p>
     <strong>
      1. 请求参数传递方式：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       GET
      </strong>
      ：参数通过
      <strong>
       URL
      </strong>
      传递，拼接在 URL 后面，参数可见，格式为
      <code>
       ?key=value&amp;key2=value2
      </code>
      。
     </li>
     <li>
      <strong>
       POST
      </strong>
      ：参数放在
      <strong>
       请求体（body）
      </strong>
      中，数据不可见，适合传输敏感信息或大数据量。
     </li>
    </ul>
    <p>
     <strong>
      2. 安全性：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       GET
      </strong>
      ：由于参数暴露在 URL 中，容易被篡改、缓存，不适合传输敏感数据（如密码）。
     </li>
     <li>
      <strong>
       POST
      </strong>
      ：数据放在请求体中，相对安全，但仍需要 HTTPS 加密来增强安全性。
     </li>
    </ul>
    <p>
     <strong>
      3. 请求长度限制：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       GET
      </strong>
      ：由于 URL 长度限制（不同浏览器和服务器有所不同，一般为 2048 字符），不适合大数据提交。
     </li>
     <li>
      <strong>
       POST
      </strong>
      ：理论上无大小限制（但服务器可以自行设定最大请求体大小）。
     </li>
    </ul>
    <p>
     <strong>
      4. 幂等性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       GET
      </strong>
      ：幂等，即多次请求相同资源不会改变服务器状态，适用于查询操作。
     </li>
     <li>
      <strong>
       POST
      </strong>
      ：非幂等，每次请求可能导致数据变化（如新增用户、提交订单）。
     </li>
    </ul>
    <p>
     <strong>
      5. 浏览器缓存：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       GET
      </strong>
      ：浏览器可缓存 GET 请求的结果，提高性能。
     </li>
     <li>
      <strong>
       POST
      </strong>
      ：默认不会被缓存，需要手动设置。
     </li>
    </ul>
    <p>
     总结来说，
     <strong>
      GET 适用于查询数据，速度快但不适合传输敏感信息或大数据
     </strong>
     ，而
     <strong>
      POST 适用于提交数据，安全性更高，适合修改服务器资源
     </strong>
     。
    </p>
    <hr/>
    <h3>
     <a id="9__HTTP___318">
     </a>
     9. 说说 HTTP 常见的请求头有哪些? 作用？
    </h3>
    <p>
     HTTP 请求头（Headers）用于在客户端和服务器之间传递额外的信息，常见的请求头包括以下几类：
    </p>
    <p>
     <strong>
      1. 通用请求头（General Headers）
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Host
      </strong>
      ：指定服务器的域名和端口，如
      <code>
       Host: example.com:8080
      </code>
      ，用于虚拟主机识别。
     </li>
     <li>
      <strong>
       Connection
      </strong>
      ：控制连接状态，如
      <code>
       Connection: keep-alive
      </code>
      （保持连接）或
      <code>
       Connection: close
      </code>
      （请求完成后关闭连接）。
     </li>
     <li>
      <strong>
       User-Agent
      </strong>
      ：标识客户端信息，如浏览器或爬虫。
     </li>
     <li>
      <strong>
       Accept
      </strong>
      ：客户端可接受的数据类型，如
      <code>
       Accept: text/html, application/json
      </code>
      ，用于服务器返回合适的内容。
     </li>
     <li>
      <strong>
       Accept-Encoding
      </strong>
      ：指定支持的编码方式，如
      <code>
       gzip, deflate, br
      </code>
      ，服务器可返回压缩内容以减少流量。
     </li>
     <li>
      <strong>
       Accept-Language
      </strong>
      ：指定客户端可接受的语言，如
      <code>
       Accept-Language: zh-CN, en-US
      </code>
      。
     </li>
    </ul>
    <p>
     <strong>
      2. 资源请求相关头
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Referer
      </strong>
      ：表明请求的来源页面，如
      <code>
       Referer: https://example.com/page1
      </code>
      ，用于防止 CSRF 攻击。
     </li>
     <li>
      <strong>
       Origin
      </strong>
      ：类似 Referer，但只包含协议和域名，如
      <code>
       Origin: https://example.com
      </code>
      ，用于 CORS 认证。
     </li>
    </ul>
    <p>
     <strong>
      3. 认证与安全相关头
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Authorization
      </strong>
      ：用于身份验证，如
      <code>
       Authorization: Bearer &lt;token&gt;
      </code>
      （OAuth 令牌认证）。
     </li>
     <li>
      <strong>
       Cookie
      </strong>
      ：用于在请求中携带会话信息，如
      <code>
       Cookie: sessionId=abc123
      </code>
      ，服务器可基于 Cookie 识别用户状态。
     </li>
    </ul>
    <p>
     <strong>
      4. 内容传输相关头
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Content-Type
      </strong>
      ：声明请求体的数据格式，如：
      <ul>
       <li>
        <code>
         Content-Type: application/json
        </code>
        （JSON 格式）
       </li>
       <li>
        <code>
         Content-Type: application/x-www-form-urlencoded
        </code>
        （表单提交）
       </li>
       <li>
        <code>
         Content-Type: multipart/form-data
        </code>
        （文件上传）
       </li>
      </ul>
     </li>
     <li>
      <strong>
       Content-Length
      </strong>
      ：表示请求体的字节大小，如
      <code>
       Content-Length: 348
      </code>
      ，用于服务器解析请求数据。
     </li>
    </ul>
    <p>
     <strong>
      5. 缓存控制相关头
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Cache-Control
      </strong>
      ：控制缓存策略，如：
      <ul>
       <li>
        <code>
         Cache-Control: no-cache
        </code>
        （不使用缓存）
       </li>
       <li>
        <code>
         Cache-Control: max-age=3600
        </code>
        （缓存 1 小时）
       </li>
      </ul>
     </li>
     <li>
      <strong>
       If-Modified-Since
      </strong>
      ：携带资源的上次修改时间，配合
      <code>
       304 Not Modified
      </code>
      ，避免重复下载数据。
     </li>
     <li>
      <strong>
       If-None-Match
      </strong>
      ：携带资源的 ETag（唯一标识符），服务器可比较是否更新，减少不必要的传输。
     </li>
    </ul>
    <p>
     这些请求头在 HTTP 请求中起到了
     <strong>
      控制缓存、身份验证、数据格式
     </strong>
     等关键作用。例如，
     <code>
      Authorization
     </code>
     头用于携带 JWT 令牌，
     <code>
      Accept
     </code>
     头用于指定响应格式，而
     <code>
      Content-Type
     </code>
     头则决定了 POST 请求传输的数据格式。
    </p>
    <hr/>
    <h3>
     <a id="10__URL__354">
     </a>
     10. 说说地址栏输入 URL 敲下回车后发生了什么?
    </h3>
    <p>
     当我们在浏览器地址栏输入 URL 并按下回车后，浏览器会经历一系列步骤来加载网页，主要过程如下：
    </p>
    <p>
     <strong>
      1. URL 解析
     </strong>
     <br/>
     浏览器首先解析用户输入的 URL，如果省略了
     <code>
      http://
     </code>
     或
     <code>
      https://
     </code>
     ，会默认添加协议（通常是 HTTPS）。
    </p>
    <p>
     <strong>
      2. DNS 解析（域名解析）
     </strong>
     <br/>
     浏览器需要将域名（如
     <code>
      example.com
     </code>
     ）解析为 IP 地址，解析过程包括：
    </p>
    <ul>
     <li>
      浏览器缓存（检查是否已解析过该域名）
     </li>
     <li>
      本地 DNS 缓存（操作系统维护的解析记录）
     </li>
     <li>
      本地 DNS 服务器（ISP 提供的解析服务器）
     </li>
     <li>
      递归查询根 DNS 服务器 → 顶级域名（TLD）服务器 → 权威 DNS 服务器，获取最终 IP
     </li>
    </ul>
    <p>
     <strong>
      3. 建立 TCP 连接
     </strong>
     <br/>
     浏览器使用解析出的 IP 地址，与服务器建立
     <strong>
      TCP 三次握手
     </strong>
     连接（如果是 HTTPS，则额外进行 TLS/SSL 握手）。
    </p>
    <ul>
     <li>
      第一次握手：客户端发送 SYN（请求建立连接）
     </li>
     <li>
      第二次握手：服务器返回 SYN-ACK（同意建立连接）
     </li>
     <li>
      第三次握手：客户端发送 ACK，连接建立
     </li>
    </ul>
    <p>
     <strong>
      4. 发送 HTTP 请求
     </strong>
     <br/>
     浏览器向服务器发送 HTTP 请求，常见内容包括：
    </p>
    <ul>
     <li>
      请求方法（如
      <code>
       GET /index.html HTTP/1.1
      </code>
      ）
     </li>
     <li>
      请求头（如
      <code>
       User-Agent
      </code>
      、
      <code>
       Accept
      </code>
      、
      <code>
       Cookie
      </code>
      ）
     </li>
     <li>
      请求体（仅 POST/PUT 等请求携带数据）
     </li>
    </ul>
    <p>
     <strong>
      5. 服务器处理请求
     </strong>
     <br/>
     服务器收到请求后，处理请求并返回 HTTP 响应，流程包括：
    </p>
    <ul>
     <li>
      检查路由（确定请求的资源，如静态文件或 API）
     </li>
     <li>
      查询数据库（如果请求涉及动态数据）
     </li>
     <li>
      执行业务逻辑
     </li>
     <li>
      生成 HTML、JSON 等数据
     </li>
    </ul>
    <p>
     <strong>
      6. 服务器返回 HTTP 响应
     </strong>
     <br/>
     服务器返回 HTTP 响应，包括：
    </p>
    <ul>
     <li>
      状态码（如
      <code>
       200 OK
      </code>
      、
      <code>
       404 Not Found
      </code>
      ）
     </li>
     <li>
      响应头（如
      <code>
       Content-Type: text/html
      </code>
      、
      <code>
       Set-Cookie
      </code>
      ）
     </li>
     <li>
      响应体（HTML 页面或 JSON 数据）
     </li>
    </ul>
    <p>
     <strong>
      7. 浏览器解析与渲染页面
     </strong>
    </p>
    <ul>
     <li>
      解析 HTML，构建 DOM 树
     </li>
     <li>
      解析 CSS，构建 CSSOM 树
     </li>
     <li>
      执行 JavaScript（如动态渲染、Ajax 请求）
     </li>
     <li>
      合成渲染树并绘制页面
     </li>
    </ul>
    <h3>
     <a id="11_TCP_398">
     </a>
     11. 说说TCP为什么需要三次握手和四次挥手？
    </h3>
    <h4>
     <a id="TCP__399">
     </a>
     三次握手（TCP 建立连接）
    </h4>
    <p>
     三次握手用于确保客户端和服务器之间的连接是可靠的，并且双方都准备好发送和接收数据。
    </p>
    <p>
     <strong>
      1. 第一次握手（客户端 → 服务器）
     </strong>
     ：
    </p>
    <ul>
     <li>
      客户端向服务器发送 SYN（同步）标志位为 1 的数据包，表示请求建立连接。
     </li>
     <li>
      这个数据包中还包含客户端的初始序列号（Sequence Number），用来同步数据流的编号。
     </li>
    </ul>
    <p>
     <strong>
      2. 第二次握手（服务器 → 客户端）：
     </strong>
    </p>
    <ul>
     <li>
      服务器接收到客户端的 SYN 包后，返回一个 SYN-ACK（同步-确认）包，表示同意建立连接并同步服务器的初始序列号。
     </li>
     <li>
      该包中的确认号为客户端发送的序列号 + 1，表示已接收到客户端的请求。
     </li>
    </ul>
    <p>
     <strong>
      3. 第三次握手（客户端 → 服务器）
     </strong>
     ：
    </p>
    <ul>
     <li>
      客户端收到服务器的 SYN-ACK 包后，发送一个 ACK（确认）包，表示连接建立完成，确认号为服务器的序列号 + 1。
     </li>
     <li>
      一旦服务器收到该确认包，连接建立完成，数据传输可以开始。
     </li>
    </ul>
    <p>
     <strong>
      为什么需要三次握手？
     </strong>
    </p>
    <ul>
     <li>
      第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的
     </li>
     <li>
      第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过
      <strong>
       此时服务器并不能确认客户端的接收能力是否正常
      </strong>
     </li>
     <li>
      第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常
     </li>
     <li>
      通过三次握手，就能
      <strong>
       确定双方的接收和发送能力是正常的
      </strong>
      。
     </li>
    </ul>
    <p>
     <strong>
      为什么不是两次握手?
     </strong>
    </p>
    <ul>
     <li>
      如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到
     </li>
     <li>
      并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源
     </li>
    </ul>
    <h4>
     <a id="TCP__424">
     </a>
     四次挥手（TCP 断开连接）
    </h4>
    <p>
     四次挥手用于可靠地断开连接，确保双方都完全关闭连接，防止数据丢失。
    </p>
    <p>
     <strong>
      1. 第一次挥手（客户端 → 服务器）
     </strong>
     ：
    </p>
    <ul>
     <li>
      客户端发送 FIN（终止）包，表示客户端没有数据发送完毕，要求关闭连接。
     </li>
     <li>
      这个包的序列号是客户端的最后一个数据包的序列号，客户端告知服务器它的数据已经发送完。
     </li>
    </ul>
    <p>
     <strong>
      2. 第二次挥手（服务器 → 客户端）
     </strong>
     ：
    </p>
    <ul>
     <li>
      服务器收到 FIN 包后，返回 ACK 包，确认客户端的连接关闭请求。
     </li>
     <li>
      服务器表示已经收到了客户端的关闭连接请求，但可能还有数据要发送，所以并不立即关闭连接。
     </li>
    </ul>
    <p>
     <strong>
      3. 第三次挥手（服务器 → 客户端）
     </strong>
     ：
    </p>
    <ul>
     <li>
      服务器准备好关闭连接后，发送 FIN 包，表示服务器的数据也已发送完毕，要求关闭连接。
     </li>
    </ul>
    <p>
     <strong>
      4. 第四次挥手（客户端 → 服务器）
     </strong>
     ：
    </p>
    <ul>
     <li>
      客户端收到服务器的 FIN 包后，发送 ACK 包确认，表示客户端也准备好关闭连接。
     </li>
     <li>
      至此，连接双方都已关闭连接，TCP 连接完全断开。
     </li>
    </ul>
    <p>
     <strong>
      四次挥手的原因
     </strong>
    </p>
    <ul>
     <li>
      服务端在收到客户端断开连接 Fin 报文后，并不会立即关闭连接，而是先发送一个 ACK 包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送 FIN 报文断开连接，因此需要四次挥手。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="12_WebSocket_446">
     </a>
     12. 说说对WebSocket的理解？应用场景？
    </h3>
    <p>
     WebSocket 是一种用于在客户端和服务器之间建立
     <strong>
      全双工通信
     </strong>
     的协议。与传统的 HTTP 协议不同，WebSocket 允许客户端和服务器之间的
     <strong>
      持续连接
     </strong>
     ，可以在双方之间实时双向传输数据。
    </p>
    <p>
     <strong>
      WebSocket 的特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       全双工通信
      </strong>
      ：WebSocket 在客户端和服务器之间建立了一个持久的连接，双方可以在同一连接上相互发送数据，而不需要每次都建立新的连接。
     </li>
     <li>
      <strong>
       实时性
      </strong>
      ：一旦建立连接，服务器可以随时向客户端推送数据，客户端也可以随时向服务器发送数据，避免了传统 HTTP 请求-响应模式的延迟。
     </li>
     <li>
      <strong>
       较低的开销
      </strong>
      ：由于 WebSocket 使用的是单一的连接，避免了 HTTP 每次请求都需要建立连接的高开销。协议的握手阶段仅发生一次，数据传输更高效。
     </li>
     <li>
      <strong>
       支持二进制数据
      </strong>
      ：WebSocket 不仅支持文本数据的传输，还支持二进制数据（如图片、音频等）的传输，这使得它能够应用于更多的场景。
     </li>
    </ul>
    <p>
     <strong>
      WebSocket 与 HTTP 的区别
     </strong>
     ：
    </p>
    <ul>
     <li>
      HTTP 是无状态的，每次请求都需要建立新的连接，而 WebSocket 通过一次握手建立连接后，保持长时间连接，可以多次交换数据。
     </li>
     <li>
      HTTP 是请求-响应模型，每次客户端发起请求，服务器返回响应，而 WebSocket 是双向的，客户端和服务器可以随时互相发送消息。
     </li>
     <li>
      HTTP 不支持实时通信，而 WebSocket 支持实时双向通信，适合需要低延迟和实时更新的应用。
     </li>
    </ul>
    <p>
     <strong>
      WebSocket 的应用场景：
     </strong>
    </p>
    <ul>
     <li>
      弹幕
     </li>
     <li>
      媒体聊天
     </li>
     <li>
      协同编辑
     </li>
     <li>
      基于位置的应用
     </li>
     <li>
      体育实况更新
     </li>
     <li>
      股票基金报价实时更新
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="13_JWT__469">
     </a>
     13. JWT 是什么？如何使用的？
    </h3>
    <p>
     JWT（JSON Web Token）是一种用于身份认证和信息安全传输的开放标准（RFC 7519）。它是一种基于 JSON 格式的令牌，用于在客户端与服务器之间安全地传递信息。
    </p>
    <h4>
     <a id="JWT__473">
     </a>
     JWT 的结构
    </h4>
    <p>
     JWT 由三个部分组成，并用
     <code>
      .
     </code>
     连接：
    </p>
    <ul>
     <li>
      <strong>
       Header（头部）
      </strong>
      ：包含令牌的元信息，如加密算法（如 HS256、RS256）。
     </li>
     <li>
      <strong>
       Payload（负载）
      </strong>
      ：存储用户信息（如 userId、username），以及额外的声明（claims），如
      <code>
       exp
      </code>
      （过期时间）。
     </li>
     <li>
      <strong>
       Signature（签名）
      </strong>
      ：使用 Header 中指定的算法，对 Header 和 Payload 进行签名，确保 JWT 的完整性。
     </li>
    </ul>
    <h4>
     <a id="JWT___480">
     </a>
     JWT 的使用
    </h4>
    <p>
     <strong>
      1. 登录时生成 JWT
     </strong>
    </p>
    <ul>
     <li>
      用户登录后，服务器验证用户名和密码。
     </li>
     <li>
      服务器生成 JWT 并返回给客户端。
     </li>
     <li>
      客户端存储 JWT（通常存放在
      <code>
       localStorage
      </code>
      或
      <code>
       HTTP Only Cookie
      </code>
      ）。
     </li>
    </ul>
    <p>
     <strong>
      2. 客户端携带 JWT 访问资源
     </strong>
    </p>
    <ul>
     <li>
      客户端在请求时将 JWT 放入
      <code>
       Authorization
      </code>
      头部：
      <code>
       Authorization: Bearer &lt;JWT_TOKEN&gt;
      </code>
     </li>
     <li>
      服务器接收请求，验证 JWT 的有效性（是否篡改、是否过期）。
     </li>
    </ul>
    <p>
     <strong>
      3. 服务器验证 JWT 并返回响应
     </strong>
    </p>
    <ul>
     <li>
      服务器解码 JWT，验证签名和过期时间。
     </li>
     <li>
      若 JWT 有效，则返回数据；否则返回
      <code>
       401 Unauthorized
      </code>
      。
     </li>
    </ul>
    <h4>
     <a id="JWT__496">
     </a>
     JWT 的优缺点
    </h4>
    <p>
     ✅ 优点：
    </p>
    <ul>
     <li>
      无状态认证：不需要在服务器存储会话信息，适用于分布式系统。
     </li>
     <li>
      安全性：使用签名（HMAC、RSA）防止篡改。
     </li>
     <li>
      可扩展性：可以自定义 payload 内容，如角色权限等。
     </li>
    </ul>
    <p>
     ❌ 缺点：
    </p>
    <ul>
     <li>
      无法撤销：JWT 一旦签发，无法主动让其失效（除非使用黑名单机制）。
     </li>
     <li>
      体积较大：相比传统的 Session ID，JWT 包含较多信息，占用带宽。
     </li>
    </ul>
    <p>
     总结来说，JWT 是一种
     <strong>
      轻量级的身份认证机制
     </strong>
     ，适用于
     <strong>
      分布式架构
     </strong>
     。它通过
     <strong>
      签名
     </strong>
     确保数据完整性，在 Web 和移动应用的身份认证中被广泛应用。
    </p>
    <hr/>
    <h3>
     <a id="14_JWT__510">
     </a>
     14. JWT 令牌和传统方式有什么区别？
    </h3>
    <p>
     JWT 与传统 Token 的对比
    </p>
    <table>
     <thead>
      <tr>
       <th>
        对比项
       </th>
       <th>
        JWT（JSON Web Token）
       </th>
       <th>
        传统 Token（Session Token）
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        存储方式
       </td>
       <td>
        客户端存储（LocalStorage、Cookie）
       </td>
       <td>
        服务器存储（数据库、Redis）
       </td>
      </tr>
      <tr>
       <td>
        身份验证
       </td>
       <td>
        服务器通过 JWT 签名验证
       </td>
       <td>
        服务器通过 查数据库/Redis 验证
       </td>
      </tr>
      <tr>
       <td>
        服务器开销
       </td>
       <td>
        无状态，不需要维护 Session
       </td>
       <td>
        有状态，需要维护会话信息
       </td>
      </tr>
      <tr>
       <td>
        扩展性
       </td>
       <td>
        适用于分布式系统，可跨服务验证
       </td>
       <td>
        适用于单体应用，难以扩展
       </td>
      </tr>
      <tr>
       <td>
        安全性
       </td>
       <td>
        使用签名防篡改，但无法撤销
       </td>
       <td>
        可随时撤销 Token
       </td>
      </tr>
      <tr>
       <td>
        请求体积
       </td>
       <td>
        较大，包含用户信息和签名
       </td>
       <td>
        较小，仅包含 Token ID
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      传统 Token 机制（Session Token）
     </strong>
    </p>
    <ul>
     <li>
      用户登录后，服务器生成一个 Token（Session ID） 并存入数据库或 Redis。
     </li>
     <li>
      服务器返回该 Token，客户端存储并在每次请求时携带它（通常放在 Cookie 或 Authorization 头）。
     </li>
     <li>
      服务器收到请求后，从数据库/Redis 中查找该 Token，验证其有效性。
     </li>
    </ul>
    <p>
     <strong>
      优点
     </strong>
     ：
     <br/>
     ✅ Token 可随时在服务器端失效，适用于安全要求高的场景（如银行、支付）。
     <br/>
     ✅ 请求体积小，适合频繁交互的应用。
    </p>
    <p>
     <strong>
      缺点
     </strong>
     ：
     <br/>
     ❌ 服务器需要存储大量 Session，影响性能和扩展性。
     <br/>
     ❌ 在分布式环境下，需要共享 Session，增加复杂度。
    </p>
    <p>
     <strong>
      JWT 机制
     </strong>
    </p>
    <ul>
     <li>
      用户登录后，服务器生成一个 JWT，其中包含用户身份信息（如
      <code>
       userId
      </code>
      、
      <code>
       role
      </code>
      ）。
     </li>
     <li>
      服务器用私钥对 JWT 签名，并返回给客户端。
     </li>
     <li>
      客户端在请求时携带 JWT（
      <code>
       Authorization: Bearer &lt;JWT&gt;
      </code>
      ）。
     </li>
     <li>
      服务器不需要查询数据库，只需验证 JWT 签名，即可确认用户身份。
     </li>
    </ul>
    <p>
     <strong>
      优点
     </strong>
     ：
     <br/>
     ✅
     <strong>
      无状态
     </strong>
     ，服务器不需要存储 Token，适用于
     <strong>
      分布式系统
     </strong>
     。
     <br/>
     ✅
     <strong>
      跨域支持
     </strong>
     ，适用于 Web 前后端分离的架构。
     <br/>
     ✅ 携带用户信息，减少查询数据库的次数，提高性能。
    </p>
    <p>
     <strong>
      缺点
     </strong>
     ：
     <br/>
     ❌ 无法主动失效，Token 只能等到 exp 过期，除非维护黑名单机制。
     <br/>
     ❌ Token 体积较大，可能影响传输效率。
    </p>
    <p>
     JWT 适用于分布式系统，提供无状态认证，但缺点是无法主动失效；传统 Token 更适用于需要更强安全控制的系统，如支付、银行。
    </p>
    <hr/>
    <h3>
     <a id="15_tokensessioncookie_554">
     </a>
     15. token，session，cookie的区别?
    </h3>
    <ul>
     <li>
      <strong>
       session
      </strong>
      存储于
      <strong>
       服务器
      </strong>
      ，可以理解为一个状态列表，拥有一个唯一识别符号sessionld，通常存放于 cookie 中。服务器收到cookie后解析出sessionld，再去session列表中查找，才能找到相应session，依赖 cookie。
     </li>
     <li>
      <strong>
       cookie
      </strong>
      类似一个令牌，装有sessionld，存储在
      <strong>
       客户端
      </strong>
      ，浏览器通常会自动添加。
     </li>
     <li>
      <strong>
       token
      </strong>
      也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户，需要开发者手动添加。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="16_cookiesession_560">
     </a>
     16. cookie和session支持跨域吗
    </h3>
    <p>
     在默认情况下，Cookie 和 Session 都不支持跨域，但可以通过一些手段实现跨域共享。
    </p>
    <p>
     <strong>
      Cookie 是否支持跨域？
     </strong>
    </p>
    <p>
     ❌ 默认情况下，Cookie 不能跨域。
    </p>
    <ul>
     <li>
      同源策略（Same-Origin Policy） 限制 Cookie 只能在相同 domain 下使用。
     </li>
     <li>
      domain 不同的情况下，浏览器不会携带 Cookie。
     </li>
    </ul>
    <p>
     ✅ 解决方案：
    </p>
    <ul>
     <li>
      设置 domain 属性：可以
      <strong>
       跨子域
      </strong>
      共享 Cookie
     </li>
     <li>
      使用 CORS（跨域资源共享）
     </li>
    </ul>
    <p>
     <strong>
      Session 是否支持跨域？
     </strong>
     <br/>
     Session 本身存储在服务器端，但由于 Session 依赖 Cookie 进行会话识别，因此默认情况下也不支持跨域。
    </p>
    <p>
     ✅ 解决方案：
    </p>
    <ul>
     <li>
      使用 Redis 共享 Session
      <ul>
       <li>
        服务器将 Session 存储在 Redis，所有子域访问同一个 Redis，确保 Session 共享。
       </li>
      </ul>
     </li>
     <li>
      Token 方式代替 Session
      <ul>
       <li>
        前端不依赖 Cookie，而是通过
        <strong>
         JWT
        </strong>
        或 Redis Token 来进行跨域身份验证。
       </li>
      </ul>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f4c756f5f4c412f:61727469636c652f64657461696c732f313436303732333332" class_="artid" style="display:none">
 </p>
</div>


