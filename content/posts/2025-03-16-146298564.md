---
layout: post
title: "前端缓存接口数据"
date: 2025-03-16 18:00:46 +0800
description: "在前端缓存接口数据时，可以结合 浏览器缓存策略、前端存储（localStorage、sessionStorage、IndexedDB）、内存缓存（变量存储）、Service Worker 等方式，选择适合的方案。在 Vue / React / Angular 项目中，可以用 全局变量、Vuex / Pinia / Redux / Zustand 缓存数据，避免重复请求 API。如果接口数据不会频繁变化，可以使用 HTTP 缓存策略（强缓存 + 协商缓存），减少不必要的请求。"
keywords: "前端缓存接口数据"
categories: ['笔记']
tags: ['前端']
artid: "146298564"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146298564
    alt: "前端缓存接口数据"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146298564
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146298564
cover: https://bing.ee123.net/img/rand?artid=146298564
image: https://bing.ee123.net/img/rand?artid=146298564
img: https://bing.ee123.net/img/rand?artid=146298564
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端缓存接口数据
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在前端缓存接口数据时，可以结合 浏览器缓存策略、前端存储（localStorage、sessionStorage、IndexedDB）、内存缓存（变量存储）、Service Worker 等方式，选择适合的方案。
    </p>
    <hr/>
    <ol>
     <li>
      使用浏览器 HTTP 缓存（推荐，依赖后端支持）
     </li>
    </ol>
    <p>
     如果接口数据不会频繁变化，可以使用 HTTP 缓存策略（强缓存 + 协商缓存），减少不必要的请求。
    </p>
    <p>
     后端设置 Cache-Control
    </p>
    <p>
     在接口响应头中，服务器可以设置缓存策略：
    </p>
    <p>
     Cache-Control: max-age=600, public
     <br/>
     ETag: “abc123”
     <br/>
     Last-Modified: Wed, 20 Mar 2025 10:00:00 GMT
    </p>
    <p>
     max-age=600：缓存 10 分钟，期间不会请求服务器。
    </p>
    <p>
     ETag 和 Last-Modified：客户端在缓存过期后，会通过 If-None-Match 或 If-Modified-Since 进行 协商缓存。
    </p>
    <p>
     前端请求接口
    </p>
    <p>
     fetch(’/api/data’)
     <br/>
     .then(response =&gt; response.json())
     <br/>
     .then(data =&gt; console.log(data));
    </p>
    <p>
     适用场景：
    </p>
    <p>
     数据变化不频繁的 API（如新闻、天气、配置信息）。
    </p>
    <p>
     依赖服务器缓存策略的前端应用。
    </p>
    <hr/>
    <ol start="2">
     <li>
      前端存储（localStorage / sessionStorage / IndexedDB）
     </li>
    </ol>
    <p>
     如果数据需要在 浏览器端长时间存储，可以使用 localStorage 或 IndexedDB。
    </p>
    <p>
     localStorage 方案
    </p>
    <p>
     // 缓存 API 数据
     <br/>
     async function fetchData() {
     <!-- -->
     <br/>
     const cacheKey = ‘api_data’;
     <br/>
     const cacheTimeKey = ‘api_data_timestamp’;
     <br/>
     const cacheTimeLimit = 10 * 60 * 1000; // 10 分钟
    </p>
    <p>
     const cachedData = localStorage.getItem(cacheKey);
     <br/>
     const cacheTimestamp = localStorage.getItem(cacheTimeKey);
    </p>
    <p>
     // 如果缓存存在且未过期，直接使用
     <br/>
     if (cachedData &amp;&amp; cacheTimestamp &amp;&amp; Date.now() - cacheTimestamp &lt; cacheTimeLimit) {
     <!-- -->
     <br/>
     return JSON.parse(cachedData);
     <br/>
     }
    </p>
    <p>
     // 否则，重新请求数据
     <br/>
     const response = await fetch(’/api/data’);
     <br/>
     const data = await response.json();
    </p>
    <p>
     // 存储新数据
     <br/>
     localStorage.setItem(cacheKey, JSON.stringify(data));
     <br/>
     localStorage.setItem(cacheTimeKey, Date.now());
    </p>
    <p>
     return data;
     <br/>
     }
    </p>
    <p>
     fetchData().then(data =&gt; console.log(data));
    </p>
    <p>
     适用场景：
    </p>
    <p>
     缓存数据一段时间，减少 API 调用。
    </p>
    <p>
     适用于用户配置、城市信息、字典数据等相对静态的数据。
    </p>
    <p>
     IndexedDB 方案（适用于大数据量存储）
    </p>
    <p>
     async function saveDataToIndexedDB(data) {
     <!-- -->
     <br/>
     const db = await idb.openDB(‘myDatabase’, 1, {
     <!-- -->
     <br/>
     upgrade(db) {
     <!-- -->
     <br/>
     db.createObjectStore(‘apiData’);
     <br/>
     },
     <br/>
     });
     <br/>
     await db.put(‘apiData’, data, ‘cachedData’);
     <br/>
     }
    </p>
    <p>
     async function getDataFromIndexedDB() {
     <!-- -->
     <br/>
     const db = await idb.openDB(‘myDatabase’, 1);
     <br/>
     return db.get(‘apiData’, ‘cachedData’);
     <br/>
     }
    </p>
    <p>
     适用场景：
    </p>
    <p>
     大数据存储（如离线数据同步），比 localStorage 性能更好。
    </p>
    <p>
     PWA 或离线模式。
    </p>
    <hr/>
    <ol start="3">
     <li>
      内存缓存（适用于单页面应用）
     </li>
    </ol>
    <p>
     在 Vue / React / Angular 项目中，可以用 全局变量、Vuex / Pinia / Redux / Zustand 缓存数据，避免重复请求 API。
    </p>
    <p>
     const cache = new Map();
    </p>
    <p>
     async function fetchWithMemoryCache(url) {
     <!-- -->
     <br/>
     if (cache.has(url)) {
     <!-- -->
     <br/>
     return cache.get(url);
     <br/>
     }
    </p>
    <p>
     const response = await fetch(url);
     <br/>
     const data = await response.json();
     <br/>
     cache.set(url, data);
     <br/>
     return data;
     <br/>
     }
    </p>
    <p>
     适用场景：
    </p>
    <p>
     应用生命周期内需要频繁访问的 API（如用户信息、系统设置）。
    </p>
    <p>
     适用于单页应用（SPA），页面刷新后缓存会丢失。
    </p>
    <hr/>
    <ol start="4">
     <li>
      Service Worker（离线缓存 + 适用于 PWA）
     </li>
    </ol>
    <p>
     Service Worker 可以拦截网络请求，实现 离线缓存 和 智能更新。
    </p>
    <p>
     self.addEventListener(‘fetch’, event =&gt; {
     <!-- -->
     <br/>
     event.respondWith(
     <br/>
     caches.match(event.request).then(cachedResponse =&gt; {
     <!-- -->
     <br/>
     if (cachedResponse) {
     <!-- -->
     <br/>
     return cachedResponse;
     <br/>
     }
     <br/>
     return fetch(event.request).then(response =&gt; {
     <!-- -->
     <br/>
     return caches.open(‘api-cache’).then(cache =&gt; {
     <!-- -->
     <br/>
     cache.put(event.request, response.clone());
     <br/>
     return response;
     <br/>
     });
     <br/>
     });
     <br/>
     })
     <br/>
     );
     <br/>
     });
    </p>
    <p>
     适用场景：
    </p>
    <p>
     PWA（渐进式 Web 应用），实现离线模式。
    </p>
    <p>
     缓存 API 请求，提高性能。
    </p>
    <hr/>
    <ol start="5">
     <li>
      结合多种缓存策略
     </li>
    </ol>
    <p>
     可以结合 不同缓存方式 来优化 API 调用，例如：
    </p>
    <ol>
     <li>
      <p>
       短时间内用内存缓存（提升性能）。
      </p>
     </li>
     <li>
      <p>
       较长时间用 localStorage 或 IndexedDB（防止丢失）。
      </p>
     </li>
     <li>
      <p>
       服务器控制 Cache-Control 进行 HTTP 缓存（减少请求）。
      </p>
     </li>
     <li>
      <p>
       PWA 使用 Service Worker（实现离线模式）。
      </p>
     </li>
    </ol>
    <p>
     示例：组合缓存策略
    </p>
    <p>
     async function fetchDataWithCaching(url) {
     <!-- -->
     <br/>
     // 1. 先从内存缓存获取
     <br/>
     if (cache.has(url)) {
     <!-- -->
     <br/>
     return cache.get(url);
     <br/>
     }
    </p>
    <p>
     // 2. 再从 localStorage 获取
     <br/>
     const cachedData = localStorage.getItem(url);
     <br/>
     if (cachedData) {
     <!-- -->
     <br/>
     return JSON.parse(cachedData);
     <br/>
     }
    </p>
    <p>
     // 3. 最后请求 API
     <br/>
     const response = await fetch(url, { cache: ‘force-cache’ });
     <br/>
     const data = await response.json();
    </p>
    <p>
     // 4. 更新缓存
     <br/>
     cache.set(url, data);
     <br/>
     localStorage.setItem(url, JSON.stringify(data));
    </p>
    <p>
     return data;
     <br/>
     }
    </p>
    <p>
     适用场景：
    </p>
    <p>
     优化性能，减少 API 调用。
    </p>
    <p>
     适用于数据变化不频繁的场景。
    </p>
    <hr/>
    <p>
     总结
    </p>
    <p>
     最佳实践：
    </p>
    <p>
     短时间缓存（几分钟）：内存（变量、Vuex、Redux）。
    </p>
    <p>
     页面刷新后仍需要缓存：localStorage / IndexedDB。
    </p>
    <p>
     减少 API 请求：HTTP 缓存 (Cache-Control, ETag)。
    </p>
    <p>
     PWA 离线支持：Service Worker。
    </p>
    <p>
     选择合适的缓存方式可以大幅提升前端性能，减少 API 负担，让页面加载更快！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353832353931372f:61727469636c652f64657461696c732f313436323938353634" class_="artid" style="display:none">
 </p>
</div>


