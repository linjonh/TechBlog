---
layout: post
title: "ITester接口测试框架"
date: 2024-12-03 09:49:33 +0800
description: "ITester接口测试框架 (一) ：接口基础知识本系列教材将主要为大家讲解接口测试框架的设计，本框"
keywords: "itester"
categories: ['Java']
tags: ['无标签']
artid: "70263042"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=70263042
    alt: "ITester接口测试框架"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=70263042
featuredImagePreview: https://bing.ee123.net/img/rand?artid=70263042
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ITester接口测试框架
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <span class="link_title">
      <a href="http://blog.csdn.net/tobetheender/article/details/53116046" rel="noopener noreferrer" target="_blank">
       ITester接口测试框架 (一) ：接口基础知识
      </a>
     </span>
    </h2>
    <p>
     <br/>
    </p>
    <p>
    </p>
    <div class="markdown_views">
     <p>
      本系列教材将主要为大家讲解接口
      <a class="replace_word" href="http://lib.csdn.net/base/softwaretest" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="软件测试知识库">
       测试
      </a>
      框架的设计，本框架属于轻量型的，目前的需求基本都能满足，后续还要不断的完善，最后开源出去。暂且命名为ITester（取名字是一件很蛋疼的事情，要与接口相关，又要不能和其他框架重名）
     </p>
     <p>
      同样先规划下系列blog目录：
      <br/>
      ITester接口测试框架(一)：接口基础知识
      <br/>
      ITester接口测试框架(二)：框架简介和流程图
      <br/>
      ITester接口测试框架(三)：框架实现细节
     </p>
     <p>
      接下来开始第一部分，接口测试基础知识的讲解
     </p>
     <h2 id="什么是接口测试">
      <a name="t0" target="_blank">
      </a>
      什么是接口测试
     </h2>
     <blockquote>
      <p>
       接口是指系统模块与模块或系统与系统间进行交互,一般我们用的多的是HTTP协议的接口、WebService协议的接口,还有RPC (Remote Procedure Call Protocol)——远程过程调用协议的接口。
      </p>
     </blockquote>
     <p>
      接口测试是为了测试接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换，传递和控制管理过程，还包括处理的次数。
      <br/>
      不管是哪种接口,其本质就是发送一个request,然后服务器响应 后返回一个response,然后我们对response进行分析,这即是接口测试。
     </p>
     <h2 id="为什么要做接口测试">
      <a name="t1" target="_blank">
      </a>
      为什么要做接口测试
     </h2>
     <ul>
      <li>
       首先，随着系统复杂程度的上升，传统的测试方法测试成本急剧增加，测试效率大幅下降（数据模型推算，底层的一个bug能够引发上层的 8 个左右bug，而且底层的bug很容易引起全网的宕机。相反接口测试能够提供系统复杂度上升情况下的低成本高效率的解决方案。
      </li>
      <li>
       其次接口测试不同于传统开发的单元测试，接口测试是站在用户的角度对系统接口进行全面高效持续的检测。
      </li>
      <li>
       最后接口测试是自动化并且持续集成的，这也是为什么接口测试能够低成本高收益的根源。
      </li>
     </ul>
     <p>
      接口测试的核心战略在于：以保证系统的正确和稳定为核心，以持续集成为手段，提高测试效率，提升用户体验，降低产品研发成本。
     </p>
     <p>
      接口测试要为代码的编写保驾护航，增强开发人员和测试人员的自信，让隐含的 BUG提前暴露出来，要让开发人员在第一时间修复 BUG，要让功能测试人员和性能测试人员在测试的时候更加顺手，最大限度得减少底层 BUG 的出现数量，要让产品研发的流程更加
      <a class="replace_word" href="http://lib.csdn.net/base/agile" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="敏捷知识库">
       敏捷
      </a>
      ，要缩短产品的研发周期，最后在产品上线以后，要让用户用得更加顺畅，要让用户感觉产品服务零缺陷。
     </p>
     <p>
      另外在这个过程中，我们需要几类资源作为支撑，下面做简单描述。
      <br/>
      1. 首先最重要的一点是要强调团队的重要性，特别是团队中需要有合理的人力资源配置，在这个团队中，需要全才，也需要专才，需要技术专家，也需要业务专家，既需要高效的执行者，也需要有效的管理者，任何人在这个团队中都可以发挥重要作用。
      <br/>
      2. 其次我们需要强大的测试技术以及测试框架去支撑我们的日常工作，包括基于
      <a class="replace_word" href="http://lib.csdn.net/base/javase" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="Java SE知识库">
       Java
      </a>
      以及基于 C++的测试框架，甚至以后会扩展到其他各个语种的框架，计算机软件的
      <a class="replace_word" href="http://lib.csdn.net/base/architecture" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="大型网站架构知识库">
       架构
      </a>
      发展到今天，特别是分布式软件的发展，导致软件体系结构日益复杂化，各个系统之间的依赖逐渐加强，JAVA、C++以及多种技术的综合使用，使传统的单元测试已经无法满足于针对接口编程的架构方式，我们需要以一种更加干净的层面也就是从业务的层面对接口进行隔离测试，同时为了模拟真实场景，也需要在真实的环境中对系统内根据业务流程对各个接口进行串联测试，
      <br/>
      3. 最后以持续集成系统保证被测代码的稳定性。再次要充分重视文档的重要性，包括需求文档，开发技术方案，测试技术方案，接口定义 JAVADOC，测试用例文档等等，完善这些文档可以大大减少软件工程周期中各个团队配合障碍，也可以降低后期软件维护成本。因此贯彻和落实接口测试的战略可以最大程度地提高软件质量的稳定性。
     </p>
     <h2 id="接口的种类">
      <a name="t2" target="_blank">
      </a>
      接口的种类
     </h2>
     <ul>
      <li>
       系统与系统之间的调用，比如支付宝会提供接口给DJI商城调用，或者说，支付宝会提供接口给天猫调用
      </li>
      <li>
       上层服务对下层服务的调用，比如Service层会调用DAO层的接口，而应用层又会调用Service层提供的接口
      </li>
      <li>
       服务之间的调用，比如注册用户时，会先调用用户查询的服务，查看该用户是否已经注册。
      </li>
     </ul>
     <p>
      而我们所要做的接口测试，先要了解是基于哪一种类型的接口测试，不同类型的接口测试方法可能是不一致的，总体来说，不管是哪种类型，我们只要把被测接口当做是服务方，而把我们的测试手段当做是客户方，我们的目的就是，通过我们的测试手段，去验证服务端满足了他声明提供的功能。
     </p>
     <h2 id="get和post区别">
      <a name="t3" target="_blank">
      </a>
      GET和POST区别
     </h2>
     <p>
      参考我之前的blog：
      <a href="http://blog.csdn.net/tobetheender/article/details/52277989" rel="noopener noreferrer" target="_blank">
       HTTP 学习笔记
      </a>
     </p>
     <h3 id="get方式提交">
      <a name="t4" target="_blank">
      </a>
      GET方式提交
     </h3>
     <p>
      a）地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。
     </p>
     <pre class="prettyprint" name="code"><code class="hljs http has-numbering"><span class="hljs-request">GET <span class="hljs-string">/day09/testMethod.html?name=eric&amp;password=123456</span> HTTP/1.1</span>
<span class="hljs-attribute">Host</span>: <span class="hljs-string">localhost:8080</span>
<span class="hljs-attribute">User-Agent</span>: <span class="hljs-string">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0</span>
<span class="hljs-attribute">Accept</span>: <span class="hljs-string">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="hljs-attribute">Accept-Language</span>: <span class="hljs-string">zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3</span>
<span class="hljs-attribute">Accept-Encoding</span>: <span class="hljs-string">gzip, deflate</span>
<span class="hljs-attribute">Referer</span>: <span class="hljs-string">http://localhost:8080/day09/testMethod.html</span>
<span class="hljs-attribute">Connection</span>: <span class="hljs-string">keep-alive</span></code>
  
  <ul class="pre-numbering" style=""><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul>
  
  <ul class="pre-numbering" style=""><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul></pre>
     <p>
      b）GET提交参数数据有限制，不超过1KB。
      <br/>
      c）GET方式不适合提交敏感密码。
      <br/>
      d）注意： 浏览器直接访问的请求，默认提交方式是GET方式
     </p>
     <h3 id="post方式提交">
      <a name="t5" target="_blank">
      </a>
      POST方式提交
     </h3>
     <p>
      a）参数不会跟着URI后面。参数而是跟在请求的实体内容中。没有？开头，多个参数之间以&amp;分割。
     </p>
     <pre class="prettyprint" name="code"><code class="hljs http has-numbering"><span class="hljs-request">POST <span class="hljs-string">/day09/testMethod.html</span> HTTP/1.1</span>
<span class="hljs-attribute">Host</span>: <span class="hljs-string">localhost:8080</span>
<span class="hljs-attribute">User-Agent</span>: <span class="hljs-string">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0</span>
<span class="hljs-attribute">Accept</span>: <span class="hljs-string">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="hljs-attribute">Accept-Language</span>: <span class="hljs-string">zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3</span>
<span class="hljs-attribute">Accept-Encoding</span>: <span class="hljs-string">gzip, deflate</span>
<span class="hljs-attribute">Referer</span>: <span class="hljs-string">http://localhost:8080/day09/testMethod.html</span>
<span class="hljs-attribute">Connection</span>: <span class="hljs-string">keep-alive</span>

<span class="fix"><span class="hljs-attribute">name</span>=<span class="hljs-string">eric&amp;password=123456</span></span></code>
  
  <ul class="pre-numbering" style=""><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li></ul>
  
  <ul class="pre-numbering" style=""><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li></ul></pre>
     <p>
      b）POST提交的参数数据没有限制。
      <br/>
      c）POST方式提交敏感数据。
     </p>
     <h2 id="接口测试的方法">
      <a name="t6" target="_blank">
      </a>
      接口测试的方法
     </h2>
     <p>
      至于接口测试具体的测试方法，http协议的接口测试，一般会用jmeter去测试，jmeter的好处是不用写测试代码，直接使用jmeter提供的http请求去测试，也可以使用postman，也可以使用HttpClient去测试，好处是可以方便集成和自动化。java接口的测试，则需要编写测试代码去测试，有点类似于单元测试。
      <br/>
      但是以上的方法都只是通过发送Request，返回Respouse，简单的验证返回值是否正确，它的缺点很多：
      <br/>
      <br/>
      - 它不能将请求参数完全的覆盖，只是简单的覆盖几个参数
      <br/>
      - 手动的一条一条伪造自测数据
      <br/>
      - 对于复杂类型的请求参数，例如javaBean对象，无法发送
      <br/>
      - 不能自动化的判断返回值是否正确
      <br/>
      - 需要手工一条一条去执行接口，效率太低
     </p>
     <p>
      基于以上缺点，github上有很多同学做了各种不同的接口框架，比如百度的iTest，阿里taobao etao测试团队开发的TOAST，网易的Dagger，但是上述框架都是基于自己公司的业务基础设计开发的，只供参考，我自己设计了一套接口测试框架 ，暂且命名为ITester，详细介绍请看下一篇博文。
     </p>
    </div>
    <h2>
     <span class="link_title">
      <a href="http://blog.csdn.net/tobetheender/article/details/53243144" rel="noopener noreferrer" target="_blank">
       ITester接口测试框架 (二) : 框架简介和流程图
      </a>
     </span>
    </h2>
    <h2 id="itester框架简介">
     ITester框架简介
    </h2>
    <p>
    </p>
    <p>
     上一篇的blog主要讲解了接口
     <a class="replace_word" href="http://lib.csdn.net/base/softwaretest" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="软件测试知识库">
      测试
     </a>
     的基础知识，这一章将详细介绍接口测试框架图和流程图。
    </p>
    <p>
     ITester是处理API接口测试的轻量级自动化测试框架，
     <a class="replace_word" href="http://lib.csdn.net/base/javase" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="Java SE知识库">
      Java
     </a>
     语言实现。主要是面向service接口，诸如：HTTP，SOAP，JSON-RPC的轻量级自动化测试框架。将数据准备、参数的输入、请求执行、结果解析、数据验证、数据清理各个环节都做了封装，以数据文本文件为接口，降低自动化测试过程中case书写的难度。底层主要使用的是HttpClient+TestNG
    </p>
    <p>
     <strong>
      工具特点：
     </strong>
    </p>
    <ol>
     <li>
      采取数据驱动方式，支持Excel 和Xml以及数据库的方式录入接口请求数据；
     </li>
     <li>
      支持失败用例重跑；
     </li>
     <li>
      支持用例多线程执行，缩短执行时间(用例间需线程安全)；
     </li>
     <li>
      接入Jenkins持续集成平台，随时随地自动化构建，执行测试；
     </li>
     <li>
      支持定制化测试报告，邮件通知测试结果。
     </li>
    </ol>
    <hr/>
    <h2 id="itester框架图">
     <a name="t1" target="_blank">
     </a>
     ITester框架图
    </h2>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161125124053984" title=""/>
    </p>
    <p>
     如图所示，我将框架分为五大部分：
    </p>
    <ul>
     <li>
      Client：也就是数据准备、参数的输入、请求执行、结果解析、数据验证、数据清理各个环节
     </li>
     <li>
      TestCase：测试脚本用例模块
     </li>
     <li>
      CI：也就是持续集成模块
     </li>
     <li>
      Report：测试报告和邮件通知
     </li>
     <li>
      调度：触发整个测试框架运行起来
     </li>
    </ul>
    <hr/>
    <h2 id="iterster组件">
     <a name="t2" target="_blank">
     </a>
     ITerster组件
    </h2>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161120173349065" title=""/>
    </p>
    <p>
     <strong>
      核心组件
     </strong>
    </p>
    <ol>
     <li>
      通过Maven进行项目和依赖管理
     </li>
     <li>
      通过HttpClient和服务端进行通信
     </li>
     <li>
      通过TestNG进行测试脚本的管理
     </li>
     <li>
      通过Log4j生成运行日志
     </li>
     <li>
      通过Jackson实现各类型数据：javaBean，xml，json之间的相互转换
     </li>
     <li>
      通过C3P0数据库连接池实现与数据库的连接通信
     </li>
     <li>
      通过AssertJ提供丰富的断言
     </li>
     <li>
      通过ReportNG输出丰富多彩的测试报告
     </li>
     <li>
      最后将源码托管于Git通过Jenkins实现持续集成
     </li>
    </ol>
    <p>
     <strong>
      调度执行
     </strong>
    </p>
    <ol>
     <li>
      通过Maven进行项目的构建，测试
     </li>
     <li>
      通过Shell脚本调度执行
     </li>
     <li>
      通过Jenkins平台实现持续集成
     </li>
    </ol>
    <hr/>
    <h2 id="接口调用流程">
     <a name="t3" target="_blank">
     </a>
     接口调用流程
    </h2>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161120183830546" title=""/>
    </p>
    <hr/>
    <h2 id="用例执行流程">
     <a name="t4" target="_blank">
     </a>
     用例执行流程
    </h2>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161120183539654" title=""/>
    </p>
    <p>
     下一篇blog将主要介绍ITester接口框架的实现细节，后续相关的文档和源码会开源到github上！
    </p>
    <h2>
     <span class="link_title">
      <a href="http://blog.csdn.net/tobetheender/article/details/53333059" rel="noopener noreferrer" target="_blank">
       ITester接口测试框架 (三) : 框架实现细节
      </a>
     </span>
    </h2>
    <h2 id="项目结构">
     项目结构
    </h2>
    <p>
     结构图
    </p>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161124193935168" title=""/>
    </p>
    <hr/>
    <h2 id="框架实现">
     <a name="t1" target="_blank">
     </a>
     框架实现
    </h2>
    <h3 id="1数据准备-和-参数输入">
     <a name="t2" target="_blank">
     </a>
     1.数据准备 和 参数输入
    </h3>
    <p>
     数据准备有三种方式：
    </p>
    <ul>
     <li>
      一：通过访问数据库，获取我们需要的接口测试参数，比如测试登录接口，我们要提前获得 用户名和密码，然后才能连同我们的url发送给服务端。
     </li>
    </ul>
    <p>
     要想访问
     <a class="replace_word" href="http://lib.csdn.net/base/mysql" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="MySQL知识库">
      数据库
     </a>
     ，必须要先与数据库建立连接，我这里采用的是JDBC 和C3P0，可以参考我之前的blog
     <br/>
     <a href="http://blog.csdn.net/tobetheender/article/details/52772157" rel="noopener noreferrer" target="_blank">
      Java通过JDBC 进行MySQL数据库操作
     </a>
     <br/>
     <a href="http://blog.csdn.net/tobetheender/article/details/52841983" rel="noopener noreferrer" target="_blank">
      Java数据库连接池 学习笔记
     </a>
    </p>
    <ul>
     <li>
      二：直接将所需要的数据写入到xml或者excel中，然后写一个工具类直接去读取就行。
     </li>
    </ul>
    <p>
     <strong>
      例如 ：要准备
      <a class="replace_word" href="http://lib.csdn.net/base/softwaretest" rel="nofollow noopener noreferrer" style="color:#df3434; font-weight:bold" target="_blank" title="软件测试知识库">
       测试
      </a>
      接口输入参数为：email和password
     </strong>
    </p>
    <p>
     （1）编写paramsData.xml，将上述参数放在xml中进行管理
    </p>
    <pre class="prettyprint" name="code"><code class="hljs xml has-numbering"><span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">map</span>&gt;</span>   
    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">beanName</span>=<span class="hljs-value">"signIn"</span>&gt;</span>     
        <span class="hljs-tag">&lt;<span class="hljs-title">locator</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"email"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"charlie.chen@dji.com"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">locator</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">locator</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"password"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"123456"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">locator</span>&gt;</span>      
    <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">map</span>&gt;</span></code></pre>
    <p>
     （2）封装一个XmlUtil工具类负责读取xml ,使用第三方的jar包dom4j，XmlUtil中readXMLDocument方法返回值为Map
    </p>
    <pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering">public static <span class="hljs-keyword">Map</span>&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; readXMLDocument(<span class="hljs-keyword">String</span> xmlPath, <span class="hljs-keyword">String</span> beanName) throws IOException <span class="hljs-list">{

}</span></code></pre>
    <p>
     上述readXMLDocument方法中，参数xmlName为xml文件的名字； 参数beanName为xml文件中节点的名称。
    </p>
    <ul>
     <li>
      三：通过xml管理测试数据，也可以用Excel进行管理
     </li>
    </ul>
    <p>
     和xml管理数据类似：封装一个ExcelUtil工具类负责读取excel ,使用第三方的jar包poi，ExcelUtil中readExcel方法返回值为List
    </p>
    <pre class="prettyprint" name="code"><code class="hljs java has-numbering"><span class="hljs-comment">// 读取Excel中数据</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;ParamBean&gt; <span class="hljs-title">readExcel</span>(String excelPath) <span class="hljs-keyword">throws</span> Exception {

}</code></pre>
    <h3 id="2请求执行">
     <a name="t3" target="_blank">
     </a>
     2.请求执行
    </h3>
    <p>
     （1）封装一个CookieUtil工具类，通过CookieStore储存cookie
     <br/>
     CookieUtil类中setCookieStore方法返回值为CookieStore
    </p>
    <pre class="prettyprint" name="code"><code class="hljs java has-numbering">**
 * 将服务端返回的SessionID存储在CookieStore中
 * <span class="hljs-annotation">@author</span> Charlie.chen
 * <span class="hljs-annotation">@date</span> <span class="hljs-number">2016</span>-<span class="hljs-number">10</span>-<span class="hljs-number">31</span>
 *
 */
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieUtil</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CookieStore cookieStore = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LogUtil log = <span class="hljs-keyword">new</span> LogUtil(CookieUtil.class);


    <span class="hljs-comment">/*
     * 通过CookieStore储存cookie
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CookieStore <span class="hljs-title">setCookieStore</span>(HttpResponse httpResponse) {

        log.info(<span class="hljs-string">"setCookieStore"</span>);
        cookieStore = <span class="hljs-keyword">new</span> BasicCookieStore();
        <span class="hljs-comment">// JSESSIONID</span>
        String setCookie = httpResponse.getFirstHeader(<span class="hljs-string">"Set-Cookie"</span>).getValue();
        String JSESSIONID = setCookie.substring(<span class="hljs-string">"JSESSIONID="</span>.length(),
        setCookie.indexOf(<span class="hljs-string">";"</span>));
        log.debug(<span class="hljs-string">"JSESSIONID:"</span> + JSESSIONID);

        <span class="hljs-comment">// 新建一个Cookie</span>
        BasicClientCookie cookie = <span class="hljs-keyword">new</span> BasicClientCookie(<span class="hljs-string">"JSESSIONID"</span>, JSESSIONID);
        cookie.setVersion(<span class="hljs-number">0</span>);
        cookie.setDomain(<span class="hljs-string">"127.0.0.1"</span>);
        cookie.setPath(<span class="hljs-string">"/CwlProClient"</span>);

        cookieStore.addCookie(cookie);
        <span class="hljs-keyword">return</span> cookieStore;
    }
}</code></pre>
    <p>
     上述setCookieStore方法中，httpResponse参数为服务端响应值，类型为HttpResponse
    </p>
    <p>
     （2）用httpClient简单封装一个httpClientUtil工具类有get.post,put,delete方法
    </p>
    <pre class="prettyprint" name="code"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CloseableHttpResponse <span class="hljs-title">doGet</span>(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient, CookieStore cookieStore) {
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CloseableHttpResponse <span class="hljs-title">doPost</span>(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient,CookieStore cookieStore) {
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CloseableHttpResponse <span class="hljs-title">doPut</span>(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient, CookieStore cookieStore) {
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CloseableHttpResponse <span class="hljs-title">doDelete</span>(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient, CookieStore cookieStore) {
}

<span class="hljs-javadoc">/**
* 封装一个获取请求实体的方法
*<span class="hljs-javadoctag"> @param</span> params
*<span class="hljs-javadoctag"> @param</span> ucode
*<span class="hljs-javadoctag"> @return</span>
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UrlEncodedFormEntity <span class="hljs-title">getFormEntity</span>(Map&lt;String, String&gt; paramsMap, Charset... ucode) {
}
</code>
</pre>
    <h3 id="3结果解析-和-验证">
     <a name="t4" target="_blank">
     </a>
     3.结果解析 和 验证
    </h3>
    <p>
     （1）将从服务端返回的HttpResponse结果解析为ResponseBean对象
    </p>
    <pre class="prettyprint" name="code"><code class="hljs cs has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ReponseUtil {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LogUtil log = <span class="hljs-keyword">new</span> LogUtil(ReponseUtil.class);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ResponseBean responseBean=<span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResponseBean <span class="hljs-title">setResponseBean</span>(CloseableHttpResponse httpResponse) {

        <span class="hljs-comment">// 使用响应对象获取响应实体</span>
        HttpEntity entity = httpResponse.getEntity();
        <span class="hljs-keyword">if</span> (entity != <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 将响应实体转为字符串</span>
                String responseString = EntityUtils.toString(entity, <span class="hljs-string">"utf-8"</span>);
                String rs = responseString.replace(<span class="hljs-string">"\r\n"</span>, <span class="hljs-string">""</span>);

                responseBean = <span class="hljs-keyword">new</span> ResponseBean();
                responseBean.setStatus(httpResponse.getStatusLine().getReasonPhrase());
                responseBean.setStatusCode(Integer.toString(httpResponse.getStatusLine().getStatusCode()));
                responseBean.setBody(rs);

                log.info(<span class="hljs-string">"\n"</span> + <span class="hljs-string">"***************************返回开始**********************************"</span> + <span class="hljs-string">"\n"</span>
                        + httpResponse.getStatusLine().getReasonPhrase() + <span class="hljs-string">"\n"</span>
                        + Integer.toString(httpResponse.getStatusLine().getStatusCode()) + <span class="hljs-string">"\n"</span> + <span class="hljs-string">"Context"</span> + rs + <span class="hljs-string">"\n"</span>
                        + <span class="hljs-string">"***************************返回结束**********************************"</span>);

                HeaderIterator iterator = httpResponse.headerIterator();
                <span class="hljs-keyword">while</span> (iterator.hasNext()) {
                    log.debug(<span class="hljs-string">"\t"</span> + iterator.next());
                }
            } <span class="hljs-keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        <span class="hljs-keyword">return</span> responseBean;
    }
}</code>
</pre>
    <p>
     （2）结果验证
     <br/>
     主要验证 HttpResponse的状态status，状态码statusCode和 响应实体body，通过第三方断言jar包AsertJ
    </p>
    <pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering">// <span class="hljs-keyword">add</span> Assert
Assert<span class="hljs-preprocessor">.assertEquals</span>(<span class="hljs-string">"OK"</span>, responseBean<span class="hljs-preprocessor">.getStatus</span>())<span class="hljs-comment">;</span>
Assert<span class="hljs-preprocessor">.assertEquals</span>(<span class="hljs-string">"200"</span>, responseBean<span class="hljs-preprocessor">.getStatusCode</span>())<span class="hljs-comment">;</span>
Assert<span class="hljs-preprocessor">.assertEquals</span>(<span class="hljs-string">"dsgfdfgdfsdfdgfdg"</span>, responseBean<span class="hljs-preprocessor">.getBody</span>())<span class="hljs-comment">;</span>
</code></pre>
    <h3 id="4测试用例">
     <a name="t5" target="_blank">
     </a>
     4.测试用例
    </h3>
    <p>
     测试用例管理使用了testNG管理 ，使用了TestNG参数化测试，通过xml文件来执行case
    </p>
    <p>
     （1）测试case脚本
    </p>
    <pre class="prettyprint" name="code"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewTest</span> {<!-- --></span>

    <span class="hljs-keyword">static</span> CookieStore cookieStore=<span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">static</span> CloseableHttpClient httpclient=<span class="hljs-keyword">null</span>;

    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>() {

        <span class="hljs-keyword">try</span> {
            String url = PropertiesUtil.getValue(<span class="hljs-string">"url"</span>,<span class="hljs-string">"config.properties"</span>);

            String xmlPath=NewTest.class.getClassLoader().getResource(<span class="hljs-string">"paramData.xml"</span>).getPath();

            Map&lt;String, String&gt; paramsMap = XmlUtil.readXMLDocument(xmlPath, <span class="hljs-string">"signIn"</span>);

            httpclient = HttpClients.custom().setDefaultCookieStore(cookieStore).build();
            CloseableHttpResponse httpResponse = HttpClientUtil.doPost(url, paramsMap, httpclient, cookieStore);

            ResponseBean responseBean = ReponseUtil.setResponseBean(httpResponse);

            <span class="hljs-comment">// add Assert</span>
            Assert.assertEquals(<span class="hljs-string">"OK"</span>, responseBean.getStatus());
            Assert.assertEquals(<span class="hljs-string">"200"</span>, responseBean.getStatusCode());
            Assert.assertEquals(<span class="hljs-string">"dsgfdfgdfsdfdgfdg"</span>, responseBean.getBody());

        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="hljs-annotation">@BeforeClass</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeClass</span>() {
    }

    <span class="hljs-annotation">@AfterClass</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterClass</span>() {
    }

    <span class="hljs-annotation">@BeforeTest</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTest</span>() {
    }

    <span class="hljs-annotation">@AfterTest</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTest</span>() {
    }

    <span class="hljs-annotation">@BeforeSuite</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeSuite</span>() {
        <span class="hljs-comment">/*
        * 登录进入系统获取JSESSIONID放入到CookieStore中
        * */</span>
    }

    <span class="hljs-annotation">@AfterSuite</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeClient</span>() {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 关闭流并释放资源</span>
            httpclient.close();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
}

</code></pre>
    <p>
     （2）testng.xml文件的编写
    </p>
    <pre class="prettyprint" name="code"><code class="hljs xml has-numbering"><span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-doctype">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd"&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">suite</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"Suite"</span> <span class="hljs-attribute">parallel</span>=<span class="hljs-value">"false"</span> <span class="hljs-attribute">preserve-order</span>=<span class="hljs-value">"true"</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">test</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"Test"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">classes</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">class</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"com.dji.itester.cases.NewTest"</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-title">methods</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">include</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"test"</span> /&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-title">methods</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">classes</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">test</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-title">suite</span>&gt;</span> 
</code>
</pre>
    <p>
     右键-&gt;run as -&gt;TestNG Suite,这个场景的的测试用例就可以运行了
    </p>
    <h3 id="5失败用例重跑">
     <a name="t6" target="_blank">
     </a>
     5.失败用例重跑
    </h3>
    <p>
     关于失败用例重跑，在我前面的blog
     <a href="http://blog.csdn.net/tobetheender/article/details/52684633" rel="noopener noreferrer" target="_blank">
      TestNG实现用例运行失败自动截图和重跑
     </a>
     写的很清楚了，这里就不详说了，大概步骤如下：
    </p>
    <p>
     （1）新建TestNGRetry类继承IRetryAnalyzer，实现用例失败自动重跑逻辑
     <br/>
     （2）添加用例重跑监听器RetryListener，用例失败自动重跑功能
     <br/>
     （3）在testng.xml文件中配置自己编写的监听器
    </p>
    <pre class="prettyprint" name="code"><code class="hljs xml has-numbering">    <span class="hljs-tag">&lt;<span class="hljs-title">listeners</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">listener</span> <span class="hljs-attribute">class-name</span>=<span class="hljs-value">"com.dji.itester.runfail.TestNGListener"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">listener</span> <span class="hljs-attribute">class-name</span>=<span class="hljs-value">"com.dji.itester.runfail.RetryListener"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">listeners</span>&gt;</span></code></pre>
    <h3 id="6源码管理-和-jenkins配置">
     <a name="t7" target="_blank">
     </a>
     6.源码管理 和 Jenkins配置
    </h3>
    <p>
     （1）源码管理
     <br/>
     将代码上传到github上进行托管，关于github的使用参考我前面的blog
     <a href="http://blog.csdn.net/tobetheender/article/details/52295021" rel="noopener noreferrer" target="_blank">
      Git 学习笔记
     </a>
     ）
    </p>
    <p>
     （2）Jenkins配置
     <br/>
     运行jenkins，首先创建一个job为ITester-DJI
     <br/>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161125110536407" title=""/>
    </p>
    <p>
     将代码上传到github上进行托管，然后在jenkins上配置clone 到你本地或者远程的jenkins来：
     <br/>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161125110714144" title=""/>
    </p>
    <p>
     构建触发器
     <br/>
     Poll SCM： 定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。Build periodically：周期进行项目构建（它不care源码是否发生变化）
     <br/>
     我的配置如下： 每天凌晨2：00进行一次构建
    </p>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161125110849560" title=""/>
    </p>
    <p>
     构建
     <br/>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161125110959936" title=""/>
    </p>
    <p>
     构建后操作,发送邮件
    </p>
    <h3 id="7测试报告和邮件">
     <a name="t8" target="_blank">
     </a>
     7.测试报告和邮件
    </h3>
    <p>
     这里用到第三方的jar包ReportNG，对测试报告进行定制化。添加插件，关联testNg.xml,添加ReportNg的监听器，修改最后的TestNG的报告。
    </p>
    <pre class="prettyprint" name="code"><code class="hljs xml has-numbering">    <span class="hljs-tag">&lt;<span class="hljs-title">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">plugins</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 添加插件，关联testNg.xml,添加ReportNg的监听器，修改最后的TestNG的报告 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>2.18.1<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">configuration</span>&gt;</span>

                    <span class="hljs-tag">&lt;<span class="hljs-title">forkMode</span>&gt;</span>once<span class="hljs-tag">&lt;/<span class="hljs-title">forkMode</span>&gt;</span>  
                    <span class="hljs-tag">&lt;<span class="hljs-title">argLine</span>&gt;</span>-Dfile.encoding=UTF-8<span class="hljs-tag">&lt;/<span class="hljs-title">argLine</span>&gt;</span> 

                    <span class="hljs-tag">&lt;<span class="hljs-title">suiteXmlFiles</span>&gt;</span>
                        <span class="hljs-comment">&lt;!--&lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;  --&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">suiteXmlFile</span>&gt;</span>src/test/java/com/dji/itester/testSuites/${xmlFileName}<span class="hljs-tag">&lt;/<span class="hljs-title">suiteXmlFile</span>&gt;</span> 
                    <span class="hljs-tag">&lt;/<span class="hljs-title">suiteXmlFiles</span>&gt;</span>

                    <span class="hljs-tag">&lt;<span class="hljs-title">properties</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">property</span>&gt;</span>
                            <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>usedefaultlisteners<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>
                            <span class="hljs-tag">&lt;<span class="hljs-title">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-title">value</span>&gt;</span>
                        <span class="hljs-tag">&lt;/<span class="hljs-title">property</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">property</span>&gt;</span>
                            <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>listener<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>
                            <span class="hljs-tag">&lt;<span class="hljs-title">value</span>&gt;</span>org.uncommons.reportng.HTMLReporter,
                                org.uncommons.reportng.JUnitXMLReporter<span class="hljs-tag">&lt;/<span class="hljs-title">value</span>&gt;</span>
                        <span class="hljs-tag">&lt;/<span class="hljs-title">property</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-title">properties</span>&gt;</span>

                    <span class="hljs-tag">&lt;<span class="hljs-title">workingDirectory</span>&gt;</span>target/<span class="hljs-tag">&lt;/<span class="hljs-title">workingDirectory</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">plugin</span>&gt;</span>


            <span class="hljs-tag">&lt;<span class="hljs-title">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">configuration</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">source</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-title">source</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">target</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-title">target</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">encoding</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-title">encoding</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">plugin</span>&gt;</span>


        <span class="hljs-tag">&lt;/<span class="hljs-title">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">build</span>&gt;</span>
</code></pre>
    <p>
     测试报告：
    </p>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20161125132520107" title=""/>
    </p>
    <hr/>
    <div class="bdsharebuttonbox tracking-ad bdshare-button-style0-16" style="float:right">
    </div>
    <div id="digg">
     <dl class="digg digg_enable" id="btnDigg">
      转自：http://blog.csdn.net/ToBeTheEnder/article/category/6372155
      <br/>
     </dl>
    </div>
    <br/>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f647261676f6e70656e6732303038:2f61727469636c652f64657461696c732f3730323633303432" class_="artid" style="display:none">
 </p>
</div>


