---
layout: post
title: "npm-run-start-的整个过程"
date: 2025-08-27T11:20:48+0800
description: "的核心魔法在于修改 PATH，优先使用项目本地的可执行文件。目录是连接已安装包和可执行命令的桥梁。生命周期钩子提供了扩展脚本能力的机制。npm start 是 npm run start 的快捷方式，它们的功能完全一样。npm 为一些常用脚本（如 start, test, stop, restart）提供了这种快捷方式。整个过程确保了项目的自包含性和环境一致性：只要你拥有项目的 package.json 和 node_modules，在任何地方运行 npm run start 都会以相同的方式工作。"
keywords: "npm run start 的整个过程"
categories: ['未分类']
tags: ['前端', 'Npm', 'Node']
artid: "150920513"
arturl: "https://blog.csdn.net/qq_34574204/article/details/150920513"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150920513
    alt: "npm-run-start-的整个过程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150920513
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150920513
cover: https://bing.ee123.net/img/rand?artid=150920513
image: https://bing.ee123.net/img/rand?artid=150920513
img: https://bing.ee123.net/img/rand?artid=150920513
---



# npm run start 的整个过程

### 一、整体执行流程概览

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f6667700bb62418388767bc791ad1722.png)

### 二、详细执行阶段分解

**1. 阶段一：解析命令与脚本 (Command & Script Resolution)**

* 命令输入：你在终端中输入 npm run start 并按下回车。
* `npm CLI 接管`：`操作系统 shell`（如 bash、zsh、PowerShell）`识别出 npm 命令`，并将其交给`全局安装的 Node.js 的 npm CLI（`命令行接口）程序处理。
* `参数解析`：npm CLI 解析后面的参数 `run 和 start`。`run 是 npm 的一个子命令，专门用于执行脚本。start 是你要运行的脚本的名称`。
* `寻找 package.json`：npm 会在`当前目录及其所有父目录中向上查找最近的 package.json 文件`。
* `定位脚本`：找到 package.json 后，`npm 会读取其中的 scripts 对象，查找 start 这个属性`。

  + 如果找到：获取其对应的值（`例如 "react-scripts start"）`。
  + 如果未找到：`npm 有一个默认行为。它会去检查项目根目录是否存在 server.js 文件`。如果存在，它会默认`执行 node server.js`。这是一个历史遗留的备用方案。

**2. 阶段二：准备执行环境 (Execution Environment Preparation)**  
这是最关键但也最隐蔽的一步。npm 不会简单地把你写在 scripts 里的字符串直接扔给系统的 shell 去执行。它会为一个高度定制化的环境：

* **创建子进程**：npm 会`启动一个新的子进程`（child process）来专门运行这个脚本。这意味着脚本的执行环境与你的当前终端环境是隔离的。
* 修改 PATH 环境变量：这是最重要的一步。npm 会临时地修改这个子进程的 PATH 环境变量。

  + 它会将项目本地 node_modules/.bin 目录的路径添加到 PATH 的最前面。
  + 例如：原来的 PATH 可能是 `/usr/local/bin:/usr/bin:/bin`。修改后会变成 `/your/project/path/node_modules/.bin:/usr/local/bin:/usr/bin:/bin`。
* 为何要修改 `PATH`？

  + 项目本地安装的包（比如 react-scripts, webpack, vite）的可执行文件（binaries）都存放在 `node_modules/.bin` 目录下。
  + 通过将其`添加到 PATH 前端`，npm 确保了当你执行 `react-scripts start` 时，shell 找到的是你项目本地安装的版本，而不是可能存在于系统全局的另一个版本。这保证了项目依赖的隔离性和版本一致性。

**3. 阶段三：执行生命周期钩子 (Lifecycle Hooks Execution)**  
npm 脚本支持“生命周期钩子”。在执行 start 脚本之前，`npm 会先检查是否存在名为 prestart 的脚本。`

* 如果 `scripts 里有 "prestart"`: “…”：`npm 会首先执行 npm run prestart`。这个过程`是递归的`，所以 `prestart 也可以有自己的 preprestart`。
* 通常 `prestart` 用于在`执行主启动任务前做一些准备工作`，比如检查环境变量、清理旧的构建产物等。

**4. 阶段四：执行核心 start 脚本 (Core Script Execution)**  
现在，终于要执行 scripts 对象里 start 对应的命令了。

* **Shell 执行**：准备就绪后，npm 会使用系统 shell（在 Unix 系统通常是 /bin/sh，在 Windows 上是 cmd.exe）来`执行你定义的命令字符串`（例如 react-scripts start）。
* **命令解析**：

  + Shell 会按照空格将命令拆分成多个部分：`['react-scripts', 'start']`。
  + 因为它的第一个词是 react-scripts，`shell 会去刚刚被 npm 修改过的 PATH 环境变量里查找名为 react-scripts 的可执行文件`。
  + 它首先在 `/your/project/path/node_modules/.bin` 目录下找到了这个文件。
* `执行 Node.js 模块`：

  + node_modules/.bin/react-scripts 实际上是一个`软链接`（symlink）或者一个包装 `shell 脚本`（Windows 上是 .cmd 批处理文件）。它指向的是实际安装的 react-scripts 包中的主 JavaScript 文件（通常在 node_modules/react-scripts/bin/react-scripts.js）。
  + 这个包装脚本的核心作用就是使用 Node.js 解释器来运行对应的 .js 文件。其内容本质上是：node “/path/to/node_modules/react-scripts/bin/react-scripts.js” start。
* **参数传递**：start 这个参数会被传递给 react-scripts.js 这个脚本。该`脚本内部通过 process.argv 获取到这个参数`，然后根据它来执行对应的逻辑（即启动开发服务器）。

**5. 阶段五：执行 poststart 钩子**  
当 start 脚本启动的进程退出后，npm `会检查是否存在名为 poststart 的脚本`。

* 如果 `scripts 里有 "poststart": "..."：npm 会接着执行 npm run poststart`。
* 注意：对于 npm run start，这个钩子通常很少使用，因为 `start 命令启动的开发服务器通常是一个长期运行的进程`（会一直阻塞终端，直到你按下 Ctrl+C 终止它）。只有在`服务器进程终止后，poststart 才会运行`。

### 总结与关键点

* `npm run <script>` 的核心魔法在于`修改 PATH`，优先使用项目本地的可执行文件。
* `node_modules/.bin` 目录是连接`已安装包和可执行命令的桥梁`。
* 生命周期钩子`（pre<script> & post<script>）`提供了扩展脚本能力的机制。
* npm start 是 npm run start 的快捷方式，它们的功能完全一样。`npm 为一些常用脚本（如 start, test, stop, restart）提供了这种快捷方式`。
* 整个过程确保了`项目的自包含性和环境一致性`：只要你拥有项目的 p`ackage.json 和 node_modules`，在任何地方运行 npm run start 都会以相同的方式工作。



