---
layout: post
title: "分布式聊聊分布式id实现方案和生产经验"
date: 2025-03-09 21:48:05 +0800
description: "【分布式】聊聊分布式id实现方案和生产经验"
keywords: "【分布式】聊聊分布式id实现方案和生产经验"
categories: ['分布式存储']
tags: ['架构', '分布式']
artid: "146123257"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123257
    alt: "分布式聊聊分布式id实现方案和生产经验"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123257
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123257
cover: https://bing.ee123.net/img/rand?artid=146123257
image: https://bing.ee123.net/img/rand?artid=146123257
img: https://bing.ee123.net/img/rand?artid=146123257
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【分布式】聊聊分布式id实现方案和生产经验
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night-eighties" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/22ceb9cdfdee41a1bb2efc5eb37e5d97.png">
      <br/>
      对于分布式Id来说，在面试过程中也是高频面试题，所以主要针对分布式id实现方案进行详细分析下。
     </img>
    </p>
    <h2>
     <a id="_2">
     </a>
     应用场景
    </h2>
    <p>
     对于无论是单机还是分布式系统来说，对于很多场景需要全局唯一ID，
    </p>
    <ul>
     <li>
      数据库id唯一性
     </li>
     <li>
      日志traceId 可以方便找到日志链，一般使用uuid 更多一点
     </li>
     <li>
      幂等场景下，mq、api接口层面 保证幂等下
     </li>
     <li>
      业务系统订单id
     </li>
    </ul>
    <h3>
     <a id="UUID_10">
     </a>
     UUID
    </h3>
    <p>
     最简单的就是使用UUID，UUID的规则是一组32位16进制数字构成，形式就是8-4-4-4-8，主要就是利用当前时间和时钟序列 和 全局唯一的IEEE机器识别。
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name">UUID</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

307e16d0<span class="token operator">-</span>26d4<span class="token operator">-</span>4fff<span class="token operator">-</span>ab06<span class="token operator">-</span>a9397b8369fb
</code></pre>
    <p>
     优点：实现简单，全局唯一，缺点是不具有连续性，并且占用空间比较大，对于mysql主键来说不具备友好。
    </p>
    <h3>
     <a id="ID_20">
     </a>
     数据库自增ID
    </h3>
    <p>
     就目前公司内部，其实还是使用的数据库自增id进行处理，对于数据库来说的话，就是多个实例操作表自增id，对于业务来说使用自定义时间戳来实现。
    </p>
    <p>
     还有一种方式就是创建一个单独的表，通过数据库本身的自增id来保证。
    </p>
    <pre><code class="prism language-csharp">CREATE TABLE `test_order_id`  <span class="token punctuation">(</span>
  `id` bigint NOT <span class="token class-name">NULL</span> AUTO_INCREMENT<span class="token punctuation">,</span>
  `title` <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token class-name">NOT</span> NULL<span class="token punctuation">,</span>
  <span class="token return-type class-name">PRIMARY</span> KEY <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>
    UNIQUE KEY `title` <span class="token punctuation">(</span>`title`<span class="token punctuation">)</span>
<span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> <span class="token class-name">InnoDB</span> AUTO_INCREMENT<span class="token operator">=</span><span class="token number">1</span> <span class="token class-name">DEFAULT</span> CHARSET <span class="token operator">=</span>utf8<span class="token punctuation">;</span>

BEGIN<span class="token punctuation">;</span>

REPLACE <span class="token return-type class-name">INTO</span> test_order_id <span class="token punctuation">(</span>title<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token char">'p'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token return-type class-name">SELECT</span> <span class="token function">LAST_INSERT_ID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

COMMIT<span class="token punctuation">;</span>
</code></pre>
    <p>
     这种方式的优点就是 实现比较简单，但是缺点就是不具备高可用性，如果mysql是单节点部署的话，那么整体就不可用。
    </p>
    <h4>
     <a id="_41">
     </a>
     高可用数据库实例
    </h4>
    <p>
     部署多个数据库实例，通过设置不同的自增，比如mysql实例1，自增是2，从1开始，mysql实例2 从2开始，那么就是 实例1 ： 1、3、5、7，实例2: 2、4、6、8。
    </p>
    <p>
     对于并发量不高的场景来说，可以解决，但是对于高并发场景来说，数据库实例就是成为瓶颈。如果1秒1000个订单，那么就需要频繁访问1000次数据库，显然这个网络以及IO就成为短板。
    </p>
    <h4>
     <a id="_46">
     </a>
     号段模型
    </h4>
    <p>
     号段模式，其实就是通过在一个表中唯一一条记录，然后通过业务区分，每次获取一个区间的号，这样比如获取1-1000的号段，那么就只需要交互一次数据库，并且通过添加version来避免出现并发修改数据的问题。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/42d381d7d5a74ff6a857f82bd27115b4.png"/>
    </p>
    <h3>
     <a id="Redis_50">
     </a>
     Redis
    </h3>
    <p>
     除了借助于mysql，还可以通过redis的自增 incr命令来实现自增ID，并且可以部署一主多从的架构，来保证高可用性。
    </p>
    <pre><code class="prism language-csharp">    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">long</span></span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.生成时间戳</span>
        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 格林威治时间差</span>
        <span class="token class-name"><span class="token keyword">long</span></span> nowSecond <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span>ZoneOffset<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 我们需要获取的 时间戳 信息</span>
        <span class="token class-name"><span class="token keyword">long</span></span> timestamp <span class="token operator">=</span> nowSecond <span class="token operator">-</span> BEGIN_TIMESTAMP<span class="token punctuation">;</span>
        <span class="token comment">// 2.生成序号 --》 从Redis中获取</span>
        <span class="token comment">// 当前当前的日期</span>
        <span class="token class-name">String</span> date <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy:MM:dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取对应的自增的序号</span>
        <span class="token class-name">Long</span> increment <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token string">"id:"</span> <span class="token operator">+</span> item <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> timestamp <span class="token operator">&lt;&lt;</span> <span class="token number">32</span> <span class="token operator">|</span> increment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <p>
     具体原理其实就是 当前时间戳-制定时间 &lt;&lt; 32 | 自增的id 这样输出的就是连续的id了
    </p>
    <h3>
     <a id="_70">
     </a>
     雪花算法
    </h3>
    <p>
     雪花算法整体结构就是 64位 0-41位位毫秒值，5位是数据中心id，5位机器id，最后12位是毫秒级别内的自增id
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/437d0418e6e1459b98326d76f1b5fea8.png"/>
    </p>
    <p>
     分析源码 可以大概了解其核心流程
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4ffc895bfe7a4b9c80439b9124195211.png"/>
    </p>
    <h4>
     <a id="_76">
     </a>
     雪花算法时钟回拨
    </h4>
    <p>
     在实际的生产环境中，分布式环境下，其实时钟是很难保证统一的，所以就可能实现时间不一样的情况，导致时钟回拨问题，我们来分析两类问题
    </p>
    <p>
     情况1:UTC时间是8点01，实例机器是8点整
     <br/>
     情况2:UTC时间是8点01 实例机器是8点03
    </p>
    <p>
     对于情况1来说，其实就调整一下时间就好，1分钟内的id生成不用就可以。但是对于第二种情况，相当于需要从3分回退到01分，那么其中的2分钟的时间已经生成了对应的id，如果在次生成，就会出现id重复的问题？
    </p>
    <p>
     如何解决呢
     <br/>
     其实比较简单，大方向就是如果时间短，那么就等得阻塞对应的时间就可以，如果超过1S以上，服务直接下线，通过其他实例获取id就可以。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/05ec319382e44bc6bc1dab1313a1e0fb.png"/>
    </p>
    <h3>
     <a id="_88">
     </a>
     其他
    </h3>
    <p>
     业界有主流的其他方案，具体可以详细看
     <br/>
     百度、美团对应的解决方案，这里自己查看对应文档就可以。
    </p>
    <h3>
     <a id="_91">
     </a>
     总结
    </h3>
    <p>
     从上面的分析可以知道 目前业界主流的方案，我们来抽丝剥茧下，对于设计一个分布式id来说，需要哪些核心点
     <br/>
     1.需要顺序 这样可以简单清晰
     <br/>
     2.依赖的服务需要高可用、高性能
     <br/>
     3.全局唯一
     <br/>
     4.有具体的业务含义，比如针对订单号：11xxx 开始，还款订单21xxx，借款订单31xxx。就比较清晰。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6a69613937303432362f:61727469636c652f64657461696c732f313436313233323537" class_="artid" style="display:none">
 </p>
</div>


