---
layout: post
title: "关于嵌入式学习嵌入式硬件2"
date: 2025-09-03T20:44:47+0800
description: "原理：P11高电平，NPN基极高电平，发射极接地，NPN导通，集电极电电压接近0，BZ1一端VCC高电平，一端低电平，导通，蜂鸣器响；晶振12GHZ------&gt;12分频供给使用 ----&gt;机器周期频率1GHZ----&gt;1000000HZ-----&gt;执行一次指令需要1us-----&gt;定时器定时0.0025s需要执行------&gt;2500次------&gt;65535计数器溢出-----&gt;因此初始值为63035。5.中断优先级：CPU再去处理中断任务时候，会去比较多个中断的优先级，优先去处理优先级高的中断。"
keywords: "关于嵌入式学习——嵌入式硬件2"
categories: ['未分类']
tags: ['驱动开发', '嵌入式硬件', '学习', 'Linux']
artid: "151140684"
arturl: "https://blog.csdn.net/m0_57137282/article/details/151140684"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151140684
    alt: "关于嵌入式学习嵌入式硬件2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151140684
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151140684
cover: https://bing.ee123.net/img/rand?artid=151140684
image: https://bing.ee123.net/img/rand?artid=151140684
img: https://bing.ee123.net/img/rand?artid=151140684
---



# 关于嵌入式学习——嵌入式硬件2

**一基本概念：**

**GPlO**:Genral Purpose Input/Output，GPIO是51单片机和外界交互最基本的方式  
工作模式:  
       **输出模式:**单片机给定引脚一个电平(高电平(5V)低电平(0V)),控制引脚实现高低电平  
        **输入模式**:检测引脚电平变化  
类比GPIO为 水龙头:  
        输出模式:控制水龙头(水流)  
        输入模式:观察水龙头是否有水流**(按键)**

**二 按键:**  
        按键K1，两个引脚被接到GND和P14引脚，当K1按被技下时，P14引|脚会和GND短路到一起，P14引脚即会呈现低电平

        判断按键是否被按下:只需要检测对应的引即是否为低电平  
P14 引脚是否为低电平？P1 初始化全为1，   (P1 & 0001 0000) == 0 说明P14 引脚是为低电平，按键1被按下。

```

#include <reg51.h>

//初始化是P1高四位和P35置1
void Key_Init(void)
{
	P1 |= (0xF0 << 0);
	P3 |= (1 << 5);

	return ;
}

//检测是否有按键按下
int Key_Press(void)
{
	//初始化P1全为1 若有按键按下，则说明按位与不为0 
	int ret = 0;
	//把1放在第 4bit 位置  通过这种方式定位到具体按键
	if ((P1 & (1 << 4)) == 0)//注意加括号 关系运算符优先级高于位运算符
	{	
	 	ret = 1;
	}
	else if ((P1 & (1 << 5)) == 0)
	{
		ret = 2;
	
	}
	else if ((P1 & (1 << 6)) == 0)
	{
		ret = 3;
	
	}
	else if ((P1 & (1 << 7)) == 0)
	{
		ret = 4;
	
	}
	else if ((P3 & (1 << 5)) == 0)
	{
		ret = 5;
	
	}

	return ret;
}
```

**三、中断：**  
1.中断概念：CPU在执行一个任务时，被外界更为紧急的事件打断，转而去执行更为紧急的任务，执行完后再回到刚才的地方继续向下执行，这一过程叫做中断

2.中断源：打断CPU执行当前任务的事件/源头叫做中断源（51单片机只有5个中断源）

3中断源分类：外部中断0，外部中断1，定时器0，定时器1，串口

4外部中断：单片机上的引脚电平变化所引起的中断（INT0（P3-2）、INT1（P3-3）)

5.中断优先级：CPU再去处理中断任务时候，会去比较多个中断的优先级，优先去处理优先级高的中断  
6.中断嵌套：处理一个中断时，再套另外的中断：51单片机只允许嵌套2层  
**7.中断处理流程：**

* (1)   中断源发出中断请求
* (2）检查CPU是否响应中断及该中断源是否被屏蔽
* (3）比较中断优先级
* (4)   保护现场
* (5）执行中断服务函数 (回调函数）
* (6）恢复现场

**四、中断相关寄存器配置：**

![](https://i-blog.csdnimg.cn/direct/e988e54c03fa4b179c13b22eaf287b7f.png)

**1 IE寄存器（中断允许寄存器）**

![](https://i-blog.csdnimg.cn/direct/c02a8c7f43444dd78a581cf211f94373.png)

![](https://i-blog.csdnimg.cn/direct/43815fda4402446c905b01085bb65dbb.png)

![](https://i-blog.csdnimg.cn/direct/a39e79bbb36149728b5346c836574492.png)

![](https://i-blog.csdnimg.cn/direct/b38d533b5d9542cda6e0b4b78ce25095.png)

（1）将TCON寄存器的bit1，IE0置1，代表向CPU发起中断请求，CPU响应完中断请求后，硬件清“0"  
（2）将TCON寄存器的bit0，IT0置1，代表外部中断0下降沿触发中断

**五、定时器**

1. **定时器：**能够产生一个精准的定时，不同外设对时序的要求高（高电平和低电平时间是精准的）
2. 51单片机内部有两个定时器，分别为**timer0、timer1**，所使用**自增型**定时器（计数器16位：0-65535）
3. Clock，时钟，CPU运行节拍，频率（Intel2.1GHZ）
   1. 频率单位：HZ
   2. 时间单位：S
   3. 频率和时间关系：1/2.1GHZ ns（hz-s  khz -ms Mhz-us Ghz-ns）

51单片机：

* 晶振，晶体振荡器（12MHZ  or 11.059MHZ）
* 51单片机达不到12MHZ，将12MHZ进行12分频，12MHZ/12 = 1MHZ（机器实际使用）
* 51单片机完成一条指令运算:1/1MHZ=1uS
* ex:通过定时器0实现1ms定时:
  + 1ms = 1000us，定时器溢出是计数器16位占满总共是65535次运算， 一条指令运算需要1us，花费时间1000us刚好溢出，即进行1000次运算，定时器初值:64535。

**六、定时器相关寄存器配置：**

        8位自动重装载定时器：分为TLO和THO两部分，1byte，实际参与计数的只有TLO，当TLO中的值加到255溢出后，再将THO中的值重新装入到TLO中  
**TCON寄存器：**  
（1）bit4置1，TMOD寄存器中的Gate位清0，代表允许定时器开始计数

![](https://i-blog.csdnimg.cn/direct/23cb6b19a0814bc68a643a525ca0c84a.png)  
**TMOD寄存器：**  
  (1）定时器0>低四位清0  
（2）将TMOD寄存器中的M0，bit0置1，代表定时器0工作在16位定时器/计数器模式

工作模式寄存器

![](https://i-blog.csdnimg.cn/direct/f65f662c74dd4e1a8d86655696bd2bfc.png)

![](https://i-blog.csdnimg.cn/direct/65897168150e4f95a6631b5d5b8028d1.png)

**IE寄存器：**

            （1）将IE寄存器中的bit7置1，代表CPU能够响应所有中断  
              
            （2）将IE寄存器中的bit1置1，代表允许定时器0产生中断

```

#include <reg51.h>
#include "led.h"

unsigned int g_i = 0;

//定时器中断服务函数
void Timer0_Handler(void) interrupt 1
{
	TH0 = 64535 >> 8;
	TL0 = 64535;	//溢出之后，下一次进入这个函数 定时器得重新赋初始值
	g_i++;
	if(g_i >= 1000)//1000ms执行一次中断处理函数 执行1000次才执行led反转 即1s
	  {
	  	 LED_NOR();
		 g_i = 0;
	  }

	return;
}

//定时器0初始化函数
void Timer0_Init(void)
{
	//配置定时器0工作模式寄存器
	TMOD &= ~(0x0F << 0);//TMOD寄存器低四位清零
	TMOD |= (1 << 0);//TMOD bit0 M0置1 工作在16位定时器模式
	//补充一点：TMOD bit2 C/T 置0是定时器 置1为计数器 这里初始化低四位清零正好赋值0

	//配置16位定时器的高八位和低八位  
	TH0 = 64535 >> 8;//64535是16位数据，右移八位正好把高八位赋值给TH0；
	TL0 = 64535;// 64535是16位数据,多位数据赋值给少位数据，优先赋值低位
	 //定时1000ms：执行一次指令需要1ms 起点64535 执行1000次 65535计数溢出 触发中断函数

	//配置定时器0中断控制寄存器	
	TCON |= (1 << 4);//配合TMOD bit3 GATE置0,TCON bit4 TR0置1 表示允许定时器T0开始计数

	//配置定时器0中断允许寄存器
	IE |= (1 << 7)|(1 << 1);	//运行CPU响应中断（总开关）以及定时器0产生中断（子开关）
	
	
}
```

流程：

        1. 先配置TMOD模式选择寄存器，将低四位清0，再将bit0置1代表工作在16位定时器

        2. 向TH0和TL0中装入定时器的初值(1ms -> 64535)  
      
        3.  将TCON寄存器中的bit6置1，代表允许定时器开始计数

        4.  将IE寄存器中的bit7和bit1置1，开启中断总开关和定时器0的子开关

        5. 编写定时器0的中断服务函数

**七、蜂鸣器、PWM：**

**PWM：**

* **脉冲宽度调制**，能够让引脚产生一个方波，周期性的让引脚的电平发生翻转
* **PWM周期**：一个方波所经历的周期（从上升沿到上升沿所经历的时间/从下降沿到下降沿所经历的时间）
* **PWM占空比**：在一个周期内高电平所占的比例

**蜂鸣器：**

* 震荡源  -> 声音（波）-> 音调不同 -> 波的频率发生变化 -> 高音 高频  低音 低频
* 音量不同 -> 波的振幅 -> 能量
* **有源蜂鸣器**：存在震荡源，通电后蜂鸣器会发出持续频率的声音
* **无源蜂鸣器：**不存在震荡源，通电后蜂鸣器不会发出声音，需要给蜂鸣器一个震荡

![](https://i-blog.csdnimg.cn/direct/4a301e23687f4ae6915183385a193c86.png)

        原理：P11高电平，NPN基极高电平，发射极接地，NPN导通，集电极电电压接近0，BZ1一端VCC高电平，一端低电平，导通，蜂鸣器响；同理P11低电平，NPN基极低电平，发射极接地，NPN不导通，集电极高阻态电压很高，BZ1一端VCC高电平，一端高电平，没有电压差不导通，蜂鸣器不响。（无源蜂鸣器：需要给蜂鸣器一个震荡，PWM方波）

> 如何计算：
>
> 200hz （周期的倒数，周期代表从高电平到下一高电平的时间）
>
> 50%的占空比（高电平占一周期的比例）
>
> 蜂鸣器200hz--->周期为0.005s---->高电平周期---->0.0025s------>定时器定时0.0025s
>
> 晶振12GHZ------>12分频供给使用 ---->机器周期频率1GHZ---->1000000HZ----->执行一次指令需要1us----->定时器定时0.0025s需要执行------>2500次------>65535计数器溢出----->因此初始值为63035

```

#include <reg51.h>
#include "led.h"

unsigned int g_i = 0;

//定时器中断服务函数
void Timer0_Handler(void) interrupt 1
{
	TH0 = g_i >> 8;
	TL0 = g_i;	//溢出之后，下一次进入这个函数 定时器得重新赋初始值
	g_i++;
	P2 ^= (1 << 1);//P21引脚置1置0 来回翻转
	return;
}

//定时器0初始化函数
void Timer0_Init(void)
{
	//配置定时器0工作模式寄存器
	TMOD &= ~(0x0F << 0);//TMOD寄存器低四位清零
	TMOD |= (1 << 0);//TMOD bit0 M0置1 工作在16位定时器模式
	//补充一点：TMOD bit2 C/T 置0是定时器 置1为计数器 这里初始化低四位清零正好赋值0

	//配置16位定时器的高八位和低八位  
	TH0 = g_i >> 8;//64535是16位数据，右移八位正好把高八位赋值给TH0；
	TL0 = g_i;// 64535是16位数据,多位数据赋值给少位数据，优先赋值低位
	 //定时1000ms：执行一次指令需要1ms 起点64535 执行1000次 65535计数溢出 触发中断函数

	//配置定时器0中断控制寄存器	
	TCON |= (1 << 4);//配合TMOD bit3 GATE置0,TCON bit4 TR0置1 表示允许定时器T0开始计数

	//配置定时器0中断允许寄存器
	IE |= (1 << 7)|(1 << 1);	//运行CPU响应中断（总开关）以及定时器0产生中断（子开关）
	
	
}
```

> 补充：中断处理函数：
>
> ![](https://i-blog.csdnimg.cn/direct/5d4b31c6975d49f8b984878d9740cf87.png)

重点：

1GPIO输入模式、输出模式

2. 按键工作原理（GPIO输入）

3. 中断概念

4. 中断源概念、中断源个数、哪几个中断源

5. 外部中断、定时器中断概念

6. 中断处理流程

7. 51单片机中定时器的个数？类型

8. 16位定时器和8位自动重装载定时器的区别

9. PWM的概念、PWM周期、PWM占空比

10、有源蜂鸣器和无源蜂鸣器的区别

11、51单片机蜂鸣器实现原理



