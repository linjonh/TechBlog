---
layout: post
title: "从事件冒泡到处理前端事件系统的隐形逻辑"
date: 2025-03-09 20:18:13 +0800
description: "我将从事件从出现到被处理的各个过程来介绍事件机制：这张图片给我们展示了react事件的各个阶段，我们可以看到有DOM，合成事件层，还有事件处理函数。我觉得我们如果想要了解事件机制首先要知道的就是事件从注册到执行结束的全过程： React 事件的完整生命周期：React的事件绑定与原生的事件绑定不同，React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不"
keywords: "​​《从事件冒泡到处理：前端事件系统的“隐形逻辑”》"
categories: ['面试精选']
tags: ['前端', 'React', 'Javascript']
artid: "146137463"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146137463
    alt: "从事件冒泡到处理前端事件系统的隐形逻辑"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146137463
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146137463
cover: https://bing.ee123.net/img/rand?artid=146137463
image: https://bing.ee123.net/img/rand?artid=146137463
img: https://bing.ee123.net/img/rand?artid=146137463
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ​​《从事件冒泡到处理：前端事件系统的“隐形逻辑”》
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      <strong>
       “那天在document见到你的第一眼，我就下定决心要陪你到天荒地老”
      </strong>
     </p>
     <p style="text-align:right">
      <strong>
       ---React
      </strong>
     </p>
    </blockquote>
    <p>
     我将从事件从
     <strong>
      出现到被处理
     </strong>
     的各个过程来介绍事件机制：
    </p>
    <p>
     <img alt="" height="395" src="https://i-blog.csdnimg.cn/direct/656bba8df37d42ef844b023e1951928b.webp" width="878"/>
    </p>
    <p>
     这张图片给我们展示了react事件的各个阶段，我们可以看到有
     <strong>
      DOM，合成事件层，还有事件处理函数。
     </strong>
    </p>
    <hr/>
    <p>
     我觉得我们如果想要了解事件机制首先要知道的就是事件从注册到执行结束的全过程：
    </p>
    <h2>
     事件注册与触发流程
    </h2>
    <p>
     React 事件的完整生命周期：
    </p>
    <ol>
     <li>
      ​
      <strong>
       初始化阶段
      </strong>
      ：
      <br/>
      React 在根容器上注册所有支持的事件监听（如
      <code>
       onClick
      </code>
      对应
      <code>
       click
      </code>
      事件）。
     </li>
     <li>
      ​
      <strong>
       触发原生事件
      </strong>
      ：
      <br/>
      用户操作触发原生 DOM 事件（如点击按钮）。
     </li>
     <li>
      ​
      <strong>
       冒泡到根容器
      </strong>
      ：
      <br/>
      事件冒泡到根容器，React 根据
      <code>
       event.target
      </code>
      找到实际触发事件的组件。
     </li>
     <li>
      ​
      <strong>
       构造合成事件
      </strong>
      ：
      <br/>
      创建
      <code>
       SyntheticEvent
      </code>
      对象，并触发组件树中对应的事件回调。
     </li>
     <li>
      ​
      <strong>
       回调执行
      </strong>
      ：
      <br/>
      执行组件中定义的
      <code>
       onClick
      </code>
      等处理函数。
     </li>
     <li>
      ​
      <strong>
       事件池回收
      </strong>
      ：
      <br/>
      事件处理完成后，合成事件对象被释放回事件池。
     </li>
    </ol>
    <blockquote>
     <p>
      （在React17以后，移除事件池，合成事件对象不再复用，可直接异步访问事件属性）
     </p>
    </blockquote>
    <h2>
     事件绑定
    </h2>
    <p>
     React的事件绑定与原生的事件绑定不同，React并不是将
     <strong>
      click事件
     </strong>
     绑定到了div的
     <strong>
      真实DOM
     </strong>
     上，而是在d
     <strong>
      ocument处监听
     </strong>
     了所有的事件，当事件发生并且冒泡到
     <strong>
      document处
     </strong>
     的时候，React将事件内容封装并交由
     <strong>
      真正的处理函数运行
     </strong>
     。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。
    </p>
    <p>
     并且冒泡到document上的事件也不是原生的浏览器事件；而是react自己合成的合成事件。
    </p>
    <p>
     所以，如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。
    </p>
    <h2>
     合成事件
    </h2>
    <p>
     React 将所有原生事件封装为
     <code>
      SyntheticEvent
     </code>
     对象，提供
     <strong>
      跨浏览器一致性
     </strong>
     ：
    </p>
    <ul>
     <li>
      ​
      <strong>
       统一接口
      </strong>
      ：无论浏览器差异（如 IE 与 Chrome），事件对象的行为一致。
     </li>
     <li>
      ​
      <strong>
       事件池（Event Pooling）​
      </strong>
      ：
      <br/>
      事件对象会被重用，事件回调执行后，事件属性会被清空。若需异步访问事件属性，需调用
      <code>
       e.persist()
      </code>
      保留事件。
     </li>
    </ul>
    <pre><code class="language-javascript">handleClick(e) {
  e.persist(); // 保留事件对象
  setTimeout(() =&gt; console.log(e.target), 100);
}</code></pre>
    <h2>
    </h2>
    <ol>
    </ol>
    <h2>
     React事件和普通Html事件的区别
    </h2>
    <p>
     区别：
    </p>
    <ul>
     <li>
      对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；
     </li>
     <li>
      对于事件函数处理语法，原生事件为字符串，react 事件为函数；
     </li>
     <li>
      react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用
      <code>
       preventDefault()
      </code>
      来阻止默认行为。
     </li>
    </ul>
    <p>
     合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：
    </p>
    <ul>
     <li>
      兼容所有浏览器，更好的跨平台；
     </li>
     <li>
      将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
     </li>
     <li>
      方便 react 统一管理和事务机制。
     </li>
    </ul>
    <p>
     事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。
    </p>
    <h2>
     事件代理
    </h2>
    <p>
     事件代理（Event Delegation）是一种通过
     <strong>
      利用事件冒泡机制
     </strong>
     ，将子元素的事件处理委托给父元素统一管理的技术。它在 ​
     <strong>
      JavaScript 原生开发
     </strong>
     和 ​
     <strong>
      React 等框架
     </strong>
     中广泛应用，主要用于
     <strong>
      优化性能
     </strong>
     和
     <strong>
      简化动态元素的事件绑定
     </strong>
     。
    </p>
    <blockquote>
     <p>
      在React底层，主要对合成事件做了两件事：
     </p>
     <ul>
      <li>
       <strong>
        事件委派：
       </strong>
       React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。
      </li>
      <li>
       <strong>
        自动绑定：
       </strong>
       React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。
      </li>
     </ul>
    </blockquote>
    <h4>
     <strong>
      一、原生 JavaScript 中的事件代理
     </strong>
    </h4>
    <h5>
     ​
     <strong>
      1. 核心原理
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       事件冒泡
      </strong>
      ：子元素触发的事件会逐级向上传递到父元素。
     </li>
     <li>
      ​
      <strong>
       统一监听
      </strong>
      ：在父元素上绑定事件监听器，通过
      <code>
       event.target
      </code>
      判断实际触发事件的子元素。
     </li>
    </ul>
    <h5>
     ​
     <strong>
      2. 代码示例
     </strong>
    </h5>
    <pre><code class="language-html">&lt;ul id="parent"&gt;
  &lt;li data-id="1"&gt;Item 1&lt;/li&gt;
  &lt;li data-id="2"&gt;Item 2&lt;/li&gt;
  &lt;li data-id="3"&gt;Item 3&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
  document.getElementById('parent').addEventListener('click', function(e) {
    if (e.target.tagName === 'LI') { // 判断触发元素
      const id = e.target.dataset.id;
      console.log('Clicked item:', id);
    }
  });
&lt;/script&gt;</code></pre>
    <h5>
     ​
     <strong>
      3. 优势
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       性能优化
      </strong>
      ：减少事件监听器数量（尤其适用于列表、表格等大量子元素场景）。
     </li>
     <li>
      ​
      <strong>
       动态元素支持
      </strong>
      ：新增子元素无需重新绑定事件（如 AJAX 加载的数据）。
     </li>
    </ul>
    <h5>
     ​
     <strong>
      4. 缺点
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       事件类型限制
      </strong>
      ：仅适用于冒泡阶段的事件（如
      <code>
       click
      </code>
      ，不适用于
      <code>
       focus
      </code>
      等无冒泡的事件）。
     </li>
     <li>
      ​
      <strong>
       逻辑复杂度
      </strong>
      ：需要手动判断
      <code>
       event.target
      </code>
      ，层级较深时可能需递归查找。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      二、React 中的事件代理
     </strong>
    </h4>
    <p>
     React 通过
     <strong>
      合成事件（SyntheticEvent）​
     </strong>
     自动实现了事件代理，开发者无需手动处理。
    </p>
    <h5>
     ​
     <strong>
      1. 实现原理
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       统一绑定到根节点
      </strong>
      ：所有事件监听器默认绑定在根容器（如
      <code>
       #root
      </code>
      ）。
     </li>
     <li>
      ​
      <strong>
       自动委托
      </strong>
      ：React 内部通过事件插件机制，根据事件类型动态管理监听。
     </li>
    </ul>
    <h5>
     ​
     <strong>
      2. 代码表现
     </strong>
    </h5>
    <pre><code class="language-javascript">function List() {
  const handleClick = (e) =&gt; {
    // 直接通过 e.target 获取触发元素（React 已封装跨浏览器兼容）
    console.log('Clicked element:', e.target);
  };

  return (
    &lt;ul onClick={handleClick}&gt;
      &lt;li&gt;Item 1&lt;/li&gt;
      &lt;li&gt;Item 2&lt;/li&gt;
      &lt;li&gt;Item 3&lt;/li&gt;
    &lt;/ul&gt;
  );
}</code></pre>
    <h5>
     ​
     <strong>
      3. 优势
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       自动管理
      </strong>
      ：无需手动判断
      <code>
       event.target
      </code>
      ，组件销毁时自动解绑事件。
     </li>
     <li>
      ​
      <strong>
       性能优化
      </strong>
      ：避免为每个子元素单独绑定监听器，减少内存占用。
     </li>
     <li>
      ​
      <strong>
       跨浏览器一致性
      </strong>
      ：合成事件屏蔽了浏览器差异（如
      <code>
       event.preventDefault()
      </code>
      的行为）。
     </li>
    </ul>
    <h5>
     ​
     <strong>
      4. 注意事项
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       阻止冒泡
      </strong>
      ：需显式调用
      <code>
       e.stopPropagation()
      </code>
      ，否则事件会冒泡到 React 根节点。
     </li>
     <li>
      ​
      <strong>
       原生事件冲突
      </strong>
      ：React 事件与原生
      <code>
       addEventListener
      </code>
      混用时，执行顺序可能不符合预期（见下文示例）。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      三、事件代理的常见问题与解决方案
     </strong>
    </h4>
    <h5>
     ​
     <strong>
      1. 事件目标判断错误
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       问题
      </strong>
      ：当子元素内部有嵌套元素时（如
      <code>
       &lt;li&gt;&lt;span&gt;Text&lt;/span&gt;&lt;/li&gt;
      </code>
      ），
      <code>
       e.target
      </code>
      可能指向
      <code>
       span
      </code>
      而非
      <code>
       li
      </code>
      。
     </li>
     <li>
      ​
      <strong>
       解决
      </strong>
      ：递归查找匹配的父元素：
      <pre><code class="language-javascript">function findClosestParent(el, selector) {
  while (el &amp;&amp; el !== document) {
    if (el.matches(selector)) return el;
    el = el.parentNode;
  }
  return null;
}

// React 示例
const handleClick = (e) =&gt; {
  const li = findClosestParent(e.target, 'li');
  if (li) console.log('Clicked li:', li.dataset.id);
};</code></pre>
     </li>
    </ul>
    <blockquote>
     <p>
      主包在和同学重温博客的时候发现这一块很难懂，我做一下解释：
     </p>
     <p>
      首先：冒泡这个行为是发生在父子级元素之间。
     </p>
     <p>
      其次：事件代理的含义是 在父元素上绑定事件监听器，通过
      <code>
       event.target
      </code>
      判断实际触发事件的子元素。所以我们绑定的监听器在父元素上。
     </p>
     <p>
      最后：看这个结构span不是li的子元素和它只是嵌套关系，所以不会向上冒泡，就得我们递归的去查找父元素。
     </p>
    </blockquote>
    <h5>
     ​
     <strong>
      2. React 与原生事件混用
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       执行顺序
      </strong>
      ：原生事件监听器先于 React 合成事件执行。
     </li>
     <li>
      ​
      <strong>
       示例
      </strong>
      ：
      <pre><code class="language-javascript">useEffect(() =&gt; {
  document.addEventListener('click', () =&gt; {
    console.log('原生事件');
  });
}, []);

const handleClick = (e) =&gt; {
  e.stopPropagation(); // 无法阻止原生事件触发
  console.log('React 事件');
};</code></pre>
      ​
      <strong>
       输出顺序
      </strong>
      ：
      <code>
       原生事件
      </code>
      →
      <code>
       React 事件
      </code>
      <br/>
      ​
      <strong>
       解决
      </strong>
      ：在原生事件中调用
      <code>
       e.stopImmediatePropagation()
      </code>
      。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      四、适用场景
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        ​
        <strong>
         场景
        </strong>
       </th>
       <th>
        ​
        <strong>
         原生 JS
        </strong>
       </th>
       <th>
        ​
        <strong>
         React
        </strong>
       </th>
       <th>
        ​
        <strong>
         说明
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        动态列表/表格
       </td>
       <td>
        ✔️
       </td>
       <td>
        ✔️
       </td>
       <td>
        新增元素无需重新绑定事件
       </td>
      </tr>
      <tr>
       <td>
        高频事件（如
        <code>
         mousemove
        </code>
        ）
       </td>
       <td>
        ✔️
       </td>
       <td>
        ✔️
       </td>
       <td>
        减少监听器数量以优化性能
       </td>
      </tr>
      <tr>
       <td>
        全局事件（如
        <code>
         scroll
        </code>
        ）
       </td>
       <td>
        ✔️
       </td>
       <td>
        ❌
       </td>
       <td>
        React 建议使用
        <code>
         useEffect
        </code>
        绑定
       </td>
      </tr>
      <tr>
       <td>
        自定义组件通信
       </td>
       <td>
        ❌
       </td>
       <td>
        ✔️
       </td>
       <td>
        通过父组件统一管理子组件事件
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     end....
    </h4>
    <p class="img-center">
     <img alt="" height="834" src="https://i-blog.csdnimg.cn/direct/5f4abf38efe94bd7800da6072fcf8e9c.jpeg" width="469"/>
    </p>
    <p style="text-align:center">
     <strong>
      “我们这一路走来一直一帆风顺，可惜功亏一篑”
     </strong>
    </p>
    <p style="text-align:right">
     ——《花束般的恋爱》
    </p>
    <hr/>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393839363437302f:61727469636c652f64657461696c732f313436313337343633" class_="artid" style="display:none">
 </p>
</div>


