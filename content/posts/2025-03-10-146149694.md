---
layout: post
title: "涨薪技术Kubernetesk8s之Service服务类型"
date: 2025-03-10 11:53:40 +0800
description: "在上面的信息中可以看到三个POD节点对应的IP地址，其中endpoints是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。使用云提供商的负载均衡器向外部暴露服务。上面的测试是先修改了每台nginx首页的内容，具体如何修改，步骤如下：​​​​​​​。例如需要暴露服务的端口给外界访问的话可以通过命令：​​​​​​​。编辑一个nodeport的yaml文件，内容如下：​​​​​​​。"
keywords: "涨薪技术|Kubernetes(k8s)之Service服务类型"
categories: ['未分类']
tags: ['贪心算法', '容器', 'Tomcat', 'Nginx', 'Mysql', 'Kubernetes', 'Docker']
artid: "146149694"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146149694
    alt: "涨薪技术Kubernetesk8s之Service服务类型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146149694
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146149694
cover: https://bing.ee123.net/img/rand?artid=146149694
image: https://bing.ee123.net/img/rand?artid=146149694
img: https://bing.ee123.net/img/rand?artid=146149694
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     涨薪技术|Kubernetes(k8s)之Service服务类型
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     上次我们对Service服务有了详细的了解，今天给大家分享Service服务究竟有哪些类型以及各个类型又是怎么样的存在？
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="459" src="https://i-blog.csdnimg.cn/img_convert/ff28d220edd62665f2ce9bbfbe6e6faf.jpeg" width="1080"/>
    </p>
    <p>
     对一些应用(如 Frontend)的某些部分，可能希望通过外部(Kubernetes 集群外部)IP地址暴露Service服务。
    </p>
    <p>
     Kubernetes Service Types允许指定一个需要的类型的Service，默认是ClusterIP类型。
    </p>
    <p>
     服务类型有：
    </p>
    <p>
     1. ClusterIP
    </p>
    <p>
     2. nodePort
    </p>
    <p>
     3. LoadBalancer
    </p>
    <p>
     4. ExternalName
    </p>
    <p>
    </p>
    <h3>
     <strong>
      01ClusterIP
     </strong>
    </h3>
    <p>
     ClusterIP(内网ip),暴露集群IP和端口号，解决IP随Pod变化的问题.
    </p>
    <p>
     编辑一个service-clusterip.yaml文件，内容如下：
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Service</code><code>metadata:</code><code>name: service-clusterip</code><code>namespace: test</code><code>spec:</code><code>selector:</code><code>app: nginx</code><code>clusterIP: 10.96.0.11 #表示sevice的IP地址，可以设置，也可以不设置，不设置会默认分配一个</code><code>IP地址</code><code>type: ClusterIP</code><code>ports:</code><code>- protocol: TCP</code><code>port: 80 #表示设置service的端口</code><code>targetPort: 80 #表示设置pod的端口</code></pre>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="533" src="https://i-blog.csdnimg.cn/img_convert/67beb5c6e9621f951371ac8655abfb09.png" width="685"/>
    </p>
    <p>
     再使用以下命令进行创建
    </p>
    <pre><code>[root@master ~]# kubectl apply -f service-clusterip.yaml</code></pre>
    <p>
     创建成功后，可以使用以下命令查看service的详情
    </p>
    <pre><code>[root@master ~]# kubectl describe svc service-clusterip -n test</code><code>Name: service-clusterip</code><code>Namespace: test</code><code>Labels: &lt;none&gt;</code><code>Annotations: &lt;none&gt;</code><code>Selector: app=nginx</code><code>Type: ClusterIP</code><code>IP: 10.96.0.11</code><code>Port: &lt;unset&gt; 80/TCP</code><code>TargetPort: 80/TCP</code><code>Endpoints: 10.244.104.29:80,10.244.104.51:80,10.244.104.7:80</code><code>Session Affinity: None</code><code>Events: &lt;none&gt;</code></pre>
    <p>
     在上面的信息中可以看到三个POD节点对应的IP地址，其中endpoints是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。
    </p>
    <p>
     再使用以下命令查看KUBE-SERVICES target:​​​​​​​
    </p>
    <pre><code>[root@master ~]# iptables -nvL -t nat | grep KUBE-SVC</code><code>0 0 KUBE-SVC-QVNRCSZEL5TGFQEZ tcp -- * * 0.0.0.0/0</code><code>0.0.0.0/0 /* test/service-nodeport */ tcp dpt:30002</code><code>0 0 KUBE-SVC-LOLE4ISW44XBNF3G tcp -- * * 0.0.0.0/0</code><code>0.0.0.0/0 /* default/web */ tcp dpt:32259</code><code>0 0 KUBE-SVC-CEZPIJSAUFW5MYPQ tcp -- * * 0.0.0.0/0</code><code>0.0.0.0/0 /* kubernetes-dashboard/kubernetes-dashboard */ tcp</code><code>dpt:32349</code><code>0 0 KUBE-SVC-JD5MR3NA4I4DYORP tcp -- * * 0.0.0.0/0</code><code>10.96.0.10 /* kube-system/kube-dns:metrics cluster IP */ tcp</code><code>dpt:9153</code><code>0 0 KUBE-SVC-Z6GDYMWE5TV2NNJN tcp -- * * 0.0.0.0/0</code><code>10.96.59.159 /* kubernetes-dashboard/dashboard-metrics-scraper</code><code>cluster IP */ tcp dpt:8000</code><code>0 0 KUBE-SVC-NPX46M4PTMTKRN6Y tcp -- * * 0.0.0.0/0</code><code>10.96.0.1 /* default/kubernetes:https cluster IP */ tcp dpt:443</code><code>0 0 KUBE-SVC-QVNRCSZEL5TGFQEZ tcp -- * * 0.0.0.0/0</code><code>10.96.217.148 /* test/service-nodeport cluster IP */ tcp dpt:80</code><code>0 0 KUBE-SVC-LOLE4ISW44XBNF3G tcp -- * * 0.0.0.0/0</code><code>10.96.210.17 /* default/web cluster IP */ tcp dpt:80</code><code>0 0 KUBE-SVC-H6S3G453RTJY5LVE tcp -- * * 0.0.0.0/0</code><code>10.96.0.11 /* test/service-clusterip cluster IP */ tcp dpt:80</code></pre>
    <p>
     接下来可以使用以下命令来测试负载的算法：​​​​​​​
    </p>
    <pre><code>[root@master ~]# while true;do curl 10.96.0.11:80;sleep 5;done;</code><code>10.244.104.7</code><code>10.244.104.29</code><code>10.244.104.51</code><code>10.244.104.51</code><code>10.244.104.51</code></pre>
    <p>
     上面的测试是先修改了每台nginx首页的内容，具体如何修改，步骤如下：​​​​​​​
    </p>
    <pre><code>#1.先查看pod节点名</code><code>[root@master ~]# kubectl get pods -n test</code><code>NAME READY STATUS RESTARTS AGE</code><code>web-test-7f4fc68488-4swtz 1/1 Running 10 66d</code><code>web-test-7f4fc68488-b4t6r 1/1 Running 10 66d</code><code>web-test-7f4fc68488-jcwhx 1/1 Running 10 66d</code><code>#2.进入pod节点容器</code><code>[root@master ~]# kubectl exec -it web-test-7f4fc68488-4swtz -n test -- /bin/sh</code><code>#3.执行echo命令，修改首页内容</code><code># echo '10.244.104.7' &gt; /usr/share/nginx/html/index.html</code></pre>
    <p>
    </p>
    <h3>
     <strong>
      02nodePort
     </strong>
    </h3>
    <p>
     上面介绍了ClusterIP的通信方式，但有一个问题是ClusterIP只允许内部通信，这个通信是不能通过外界来访问的，如果需要将这个端口暴露到外面，则可以使用nodeport方式。
    </p>
    <p>
     生产环境比较好的方案就是借助云服务商使用LoadBalancer的方式，但由于是测试环境就使用了比较简单的NodePort来暴露服务，在实践过程中，也加深了对K8s概念的理解。
    </p>
    <p>
     NodePort是外部流量访问K8s的一种方式，即nodeIP:nodePort，是提供给外部流量访问K8s集群资源的一种方式。
    </p>
    <p>
     例如需要暴露服务的端口给外界访问的话可以通过命令：​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl expose deployment web-test --type=NodePort -n test</code><code>service/web-test exposed</code></pre>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="374" src="https://i-blog.csdnimg.cn/img_convert/d9bdad650eba3e3912e2da7e155219e8.png" width="751"/>
    </p>
    <p>
     编辑一个nodeport的yaml文件，内容如下：​​​​​​​
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Service</code><code>metadata:</code><code>name: service-nodeport</code><code>namespace: test</code><code>spec:</code><code>selector:</code><code>app: nginx</code><code>type: NodePort</code><code>ports:</code><code>- protocol: TCP</code><code>port: 80 #服务器访问端口</code><code>nodePort: 30002 #指定绑定的node的端口（默认的取值范围是：30000-32767）,如果不指定，</code><code>会默认分配</code><code>targetPort: 80 #容器端口</code></pre>
    <p>
     容器的端口，也是最终底层的服务所提供的端口，所以说targetPod也就是Pod的端口。从port或者是nodePort进入的流量，经过路由转发之后，最终都会都通过targetPort进入到Pod中。
    </p>
    <p>
     再创建service资源
    </p>
    <pre><code>[root@master ~]# kubectl apply -f service-nodeport.yaml</code></pre>
    <p>
     再使用以下命令查看service的详细信息​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get svc -n test -o wide</code><code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</code><code>SELECTOR</code><code>service-clusterip ClusterIP 10.96.0.11 &lt;none&gt; 80/TCP 23h</code><code>app=nginx</code><code>service-nodeport NodePort 10.96.217.148 &lt;none&gt; 80:30002/TCP 67d</code><code>app=nginx</code><code>web-test NodePort 10.96.50.184 &lt;none&gt; 80:30648/TCP 52m</code><code>app=nginx</code></pre>
    <p>
     这可样就可以通过http://192.168.158.100:30002/来访问站点
    </p>
    <h3>
    </h3>
    <h3>
     <strong>
      03LoadBalancer
     </strong>
    </h3>
    <p>
     使用云提供商的负载均衡器向外部暴露服务。外部负载均衡器可以将流量路由到自动创建的NodePort 服务和 ClusterIP 服务上。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="541" src="https://i-blog.csdnimg.cn/img_convert/9c4e9efa7eec99f3490c52d3ffddc592.png" width="781"/>
    </p>
    <p>
     loadbalancer-my-service.yaml 配置文件的内容如下，设置 type 的值为 LoadBalancer，将为Service 提供负载均衡器。负载均衡器是异步创建的，关于被提供的负载均衡器的信息将会通过 Service的 status.loadBalancer 字段发布出去。通过 kubectl 命令创建，kubectl apply -f loadbalancer-myservice.yaml。​​​​​​​
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Service</code><code>metadata:</code><code>name: loadbalancer-my-service</code><code>spec:</code><code>selector:</code><code>app: MyApp</code><code>ports:</code><code>- protocol: TCP</code><code>port: 80</code><code>targetPort: 9376</code><code>type: LoadBalancer</code><code>status:</code><code>loadBalancer:</code><code>ingress:</code><code>- ip: 192.0.2.127</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36303838393235342f:61727469636c652f64657461696c732f313436313439363934" class_="artid" style="display:none">
 </p>
</div>


