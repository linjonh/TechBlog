---
layout: post
title: "D路径搜索算法原理解析及Python实现"
date: 2025-01-21 08:04:35 +0800
description: "D*路径搜索算法原理解析及Python实现1.D*算法简述2.操"
keywords: "d*寻路"
categories: ['路径规划']
tags: ['路径规划', '算法实现', '搜索算法', 'Python', 'D']
artid: "85055569"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=85055569
    alt: "D路径搜索算法原理解析及Python实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=85055569
featuredImagePreview: https://bing.ee123.net/img/rand?artid=85055569
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     D*路径搜索算法原理解析及Python实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      D*路径搜索算法原理解析及Python实现
     </h4>
     <ul>
      <li>
       <a href="#1D_1" rel="nofollow">
        1.D*算法简述
       </a>
      </li>
      <li>
       <a href="#2_12" rel="nofollow">
        2.操作
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#21_20" rel="nofollow">
          2.1扩张
         </a>
        </li>
        <li>
         <a href="#22_35" rel="nofollow">
          2.2障碍处理
         </a>
        </li>
        <li>
         <a href="#23__53" rel="nofollow">
          2.3 发生死锁
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#3_76" rel="nofollow">
        3.伪代码
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#31_85" rel="nofollow">
          3.1扩张
         </a>
        </li>
        <li>
         <a href="#32Raise_114" rel="nofollow">
          3.2Raise检查
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#4_130" rel="nofollow">
        4.变体
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#Focussed_D_131" rel="nofollow">
          Focussed D*
         </a>
        </li>
        <li>
         <a href="#D_Lite_133" rel="nofollow">
          D* Lite
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#5_135" rel="nofollow">
        5.最小成本与当前成本之比
       </a>
      </li>
      <li>
       <a href="#6_137" rel="nofollow">
        6.经典论文算法介绍
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#61_141" rel="nofollow">
          6.1符号表示
         </a>
        </li>
        <li>
         <a href="#62_151" rel="nofollow">
          6.2算法描述
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#7D_177" rel="nofollow">
        7.D*算法的另一种理解
       </a>
      </li>
      <li>
       <a href="#8DPython_210" rel="nofollow">
        8.D*算法实现（Python）
       </a>
      </li>
      <li>
       <a href="#9_429" rel="nofollow">
        9.算法总结
       </a>
      </li>
      <li>
       <a href="#_437" rel="nofollow">
        参考资料
       </a>
      </li>
      <li>
       <a href="#font_colorredfont_444" rel="nofollow">
        <font color="red">
         搜索算法其他文章
        </font>
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="1D_1">
     </a>
     1.D*算法简述
    </h2>
    <p>
     D*是以下三种相关增量搜索算法之一:
    </p>
    <ul>
     <li>
      最初的D* (Anthony Stentz的)是一种知情的增量搜索算法。
     </li>
     <li>
      Focussed D
      <em>
       是Anthony Stentz设计的一种增量启发式搜索算法，它结合了A
      </em>
      [3]和原始D
      <em>
       的思想。Focussed D
      </em>
      源于对原始D*的进一步开发。
     </li>
     <li>
      D* Lite[4]是Sven Koenig和Maxim Likhachev基于LPA_star的增量启发式搜索算法，是结合A*思想和动态SWSF-FP的增量启发式搜索算法。
     </li>
    </ul>
    <p>
     这三种搜索算法都解决了相同的基于假设的路径规划问题，包括利用空闲空间假设进行规划，其中机器人必须在未知地形中导航到给定的目标坐标[7]。它对地形的未知部分(例如:它不包含障碍物)进行假设，并在这些假设下找到从当前坐标到目标坐标的最短路径。然后机器人沿着这条路走。当它观察到新的地图信息(如以前未知的障碍)时，它将这些信息添加到地图中，并在必要时重新规划从当前坐标到给定目标坐标的新的最短路径。它重复这个过程，直到达到目标坐标或确定无法达到目标坐标。当穿越未知地形时，可能会经常发现新的障碍物，所以这种重新规划需要快速。增量式(启发式)搜索算法利用以往问题的经验加快对当前问题的搜索，从而加快对相似搜索问题序列的搜索。假设目标坐标不变，三种搜索算法都比重复的A*搜索更有效。
    </p>
    <p>
     D_star及其变体已广泛应用于移动机器人和自主车辆导航。当前的系统通常基于D* Lite，而不是最初的D
     <em>
      或Focussed D
     </em>
     。事实上，甚至Stentz的实验室在一些实现中也使用D* Lite而不是D*。这些导航系统包括在“机遇号”和“勇气号”火星漫游者上测试的原型系统，以及在美国国防部高级研究计划局城市挑战赛中获胜的导航系统。
     <br/>
     最初的D
     <em>
      是Anthony Stentz在1994年提出的。名称D
     </em>
     来自术语“Dynamic A*”，因为该算法的行为类似于A*，只是在算法运行时圆弧成本可能发生变化。
    </p>
    <h2>
     <a id="2_12">
     </a>
     2.操作
    </h2>
    <p>
     D_star的基本操作概述如下。
     <br/>
     与Dijkstra算法和A*类似，D *维护要评估的节点列表，称为“OPEN list”。节点被标记为具有以下几种状态之一:
    </p>
    <ul>
     <li>
      NEW：意味着它从未被列入OPEN list
     </li>
     <li>
      OPEN：意味着它当前在OPEN list中
     </li>
     <li>
      CLOSED：意味着它不在OPEN list中
     </li>
     <li>
      RAISE：意味着它的成本比上次OPEN list时要高
     </li>
     <li>
      LOWER：意味着它的成本比上次OPEN list时要低
     </li>
    </ul>
    <h3>
     <a id="21_20">
     </a>
     2.1扩张
    </h3>
    <p>
     该算法通过迭代地从OPEN list中选择一个节点并对其求值来工作。然后，它将节点的变化传播到所有相邻节点，并将它们放到OPEN list中。这种传播过程称为“扩张”。与从始至终遵循路径的canonical A_star不同，D*从目标节点开始向后搜索。每个扩张节点都有一个反向指针，它指向指向目标的下一个节点，每个节点都知道目标的确切成本。当开始节点是下一个要展开的节点时，算法就完成了，只需遵循反向指针就可以找到目标的路径。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/838f50e2f90d7076192d0f595181ec18.png">
     </img>
    </div>
    <div align="center">
     <font size="3">
      扩张过程。结束节点(黄色)位于点的顶部行中间，开始节点位于底部行中间。红色表示障碍;黑色/蓝色表示扩张节点(亮度表示成本)。绿色表示正在展开的节点。
     </font>
    </div>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/d0f9d173d80c177b14706be16ac5a067.png">
     </img>
    </div>
    <div align="center">
     <font size="3">
      完成扩张。路径以青色表示。
     </font>
    </div>
    <h3>
     <a id="22_35">
     </a>
     2.2障碍处理
    </h3>
    <p>
     当在指定的路径上检测到障碍物时，所有受影响的点将再次被放到OPEN列表中，这次标记为RAISE。然而，在一个RAISED的节点增加成本之前，算法会检查它的邻居，并检查它是否可以降低节点的成本。如果没有，则提升状态传播到所有节点的后代，即具有反向指针的节点。然后评估这些节点，并且传递RAISE状态，形成波。 当RAISED节点可以减少时，它的反向指针（backpointer）会更新，并将LOWER状态传递给它的邻居。这些RAISE和LOWER的状态波是D*的核心。到这个时候，一系列其他的点就不会被波浪“碰触”了。因此，该算法只适用于受成本变化影响的点。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/dc8b0f9d0f3bceea38d519157f7dd231.png">
     </img>
    </div>
    <div align="center">
     <font size="3">
      添加了一个障碍(红色)和标记为RAISE(黄色)的节点。
     </font>
    </div>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/e23e597556fa51d279aba0096dc1085a.png">
     </img>
    </div>
    <div align="center">
     <font size="3">
      正在扩张中。 黄色表示标记为RAISE的节点，绿色表示标记为LOWER的节点。
     </font>
    </div>
    <h3>
     <a id="23__53">
     </a>
     2.3 发生死锁
    </h3>
    <p>
     这一次，不能如此优雅地绕过死锁。没有一个点可以通过邻居找到一条新的路线到达目的地。因此，他们继续传播他们的成本增加。只有在通道外才能找到点，这些点可以通过可行的路线到达目的地。这就是两个较低的波是如何发展的，它们扩张成具有新路线信息的不可到达的标记点。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/398047793889217dcd3b3af807317b2c.png">
     </img>
    </div>
    <div align="center">
     <font size="3">
      通道被其他障碍物阻挡(红色)
     </font>
    </div>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/371daac8eb3d47ab167da9736d3f247b.png">
     </img>
    </div>
    <div align="center">
     <font size="3">
      正在膨胀(黄色波浪上升，绿色波浪下降)
     </font>
    </div>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/340c66f86ec4dfa7c2b5e3f0640b8009.png">
     </img>
    </div>
    <div align="center">
     <font size="2">
      新路径找到(青色)
     </font>
    </div>
    <h2>
     <a id="3_76">
     </a>
     3.伪代码
    </h2>
    <pre><code>while(!openList.isEmpty()) {
  point = openList.getFirst();
  expand(point);
}

</code></pre>
    <h3>
     <a id="31_85">
     </a>
     3.1扩张
    </h3>
    <pre><code>  void expand(currentPoint) {
   boolean isRaise = isRaise(currentPoint);
   double cost;
   foreach(neighbor in currentPoint.getNeighbors()) {
    if(isRaise) {
     if(neighbor.nextPoint == currentPoint) {
      neighbor.setNextPointAndUpdateCost(currentPoint);
      openList.add(neighbor);
     } else {
      cost = neighbor.calculateCostVia(currentPoint);
      if(cost &lt; neighbor.getCost()) {
       currentPoint.setMinimumCostToCurrentCost();
       openList.add(currentPoint);
      }
     }
    } else {
      cost = neighbor.calculateCostVia(currentPoint);
      if(cost &lt; neighbor.getCost()) {
       neighbor.setNextPointAndUpdateCost(currentPoint);
       openList.add(neighbor);
      }
    }
   }
  }

</code></pre>
    <h3>
     <a id="32Raise_114">
     </a>
     3.2Raise检查
    </h3>
    <pre><code>boolean isRaise(point) {
 double cost;
 if(point.getCurrentCost() &gt; point.getMinimumCost()) {
  foreach(neighbor in point.getNeighbors()) {
   cost = point.calculateCostVia(neighbor);
   if(cost &lt; point.getCurrentCost()) {
    point.setNextPointAndUpdateCost(neighbor);
   }
  }
 }
 return point.getCurrentCost() &gt; point.getMinimumCost();
}
</code></pre>
    <h2>
     <a id="4_130">
     </a>
     4.变体
    </h2>
    <h3>
     <a id="Focussed_D_131">
     </a>
     Focussed D*
    </h3>
    <p>
     顾名思义，Focussed D
     <em>
      是D
     </em>
     的一个扩展，它使用启发式的方法来聚焦（focus）RAISE、LOWER对机器人的传播。这样，只更新重要的状态，就像A*只计算某些节点的成本一样。
    </p>
    <h3>
     <a id="D_Lite_133">
     </a>
     D* Lite
    </h3>
    <p>
     D* Lite不是基于原始的D
     <em>
      或聚焦的D
     </em>
     ，而是实现了相同的行为。它更容易理解，而且可以用更少的代码行实现，因此名为“D* Lite”。在性能方面，它和Focussed D
     <em>
      一样好，甚至更好。D
     </em>
     Lite基于Lifelong Planning A*，这是Koenig和Likhachev在几年前提出的。
    </p>
    <h2>
     <a id="5_135">
     </a>
     5.最小成本与当前成本之比
    </h2>
    <p>
     对于D*，区分当前成本和最低成本是很重要的。前者只在收集时重要，而后者非常重要，因为它对OpenList进行了排序。返回最小成本的函数总是当前点的最低成本，因为它是OpenList的第一个条目。
    </p>
    <h2>
     <a id="6_137">
     </a>
     6.经典论文算法介绍
    </h2>
    <p>
     “D_star算法”的名称源自 Dynamic A Star,最初由Anthony Stentz于“Optimal and Efficient Path Planning for Partially-Known Environments”中介绍。它是一种启发式的路径搜索算法，适合面对周围环境未知或者周围环境存在动态变化的场景。
    </p>
    <p>
     同A_star算法类似，D-star通过一个维护一个优先队列（OpenList）来对场景中的路径节点进行搜索，所不同的是，D*不是由起始点开始搜索，而是以目标点为起始，通过将目标点置于Openlist中来开始搜索，直到机器人当前位置节点由队列中出队为止（当然如果中间某节点状态有动态改变，需要重新寻路，所以才是一个动态寻路算法）。
    </p>
    <h3>
     <a id="61_141">
     </a>
     6.1符号表示
    </h3>
    <p>
     主要介绍一下论文中用到的一些符号及其含义。
     <br/>
     论文中将地图中的路径点用State表示，每一个State包含如下信息：
    </p>
    <ul>
     <li>
      <strong>
       Backpointer
      </strong>
      : 指向前一个state的指针，指向的state为当前状态的父辈，当前state称为指针指向state的后代，目标state无Backpointer。（路径搜索完毕后，通过机器人所在的state，通过backpointer即可一步步地移动到目标Goal state，GoalState以后用 G表示），b（X）=Y表示X的父辈为Y。
     </li>
     <li>
      <strong>
       Tag
      </strong>
      ：表示当前state的状态，有
      <strong>
       New、Open、Closed
      </strong>
      三种状态，New表示该State从未被置于Openlist中，Open表示该State正位于OpenList中，Closed表示已不再位于Openlist中。
     </li>
     <li>
      <strong>
       H（X）
      </strong>
      ：代价函数估计，表示当前State到G的开销估计。
     </li>
     <li>
      <strong>
       K（X）
      </strong>
      ：Key Function，
      <strong>
       该值是优先队列Openlist中的排序依据，K值最小的State位于队列头
      </strong>
      ，对于处于OpenList上的State X，K（X）表示从X被置于Openlist后，X到G的最小代价H（X），可以简单理解为K（X）将位于Openlist的State X划分为两种不同的状态，一种状态为
      <strong>
       Raise
      </strong>
      （如果K（X）&lt;H（X）），用来传递路径开销的增加（例如某两点之间开销的增加，会导致与之相关的节点到目标的路径开销随之增加）；另一种状态为
      <strong>
       Lower
      </strong>
      （如果K（X）=H（X）），用来传递路径开销的减少（例如某两点之间开销的减少，或者某一新的节点被加入到Openlist中，可能导致与之相关的节点到目标的路径开销随之减少）。
     </li>
     <li>
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         k 
          
          
          
            m 
           
          
            i 
           
          
            n 
           
          
         
        
       
         k_{min}
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 0.84444em; vertical-align: -0.15em;">
          </span>
          <span class="mord">
           <span class="mord mathdefault" style="margin-right: 0.03148em;">
            k
           </span>
           <span class="msupsub">
            <span class="vlist-t vlist-t2">
             <span class="vlist-r">
              <span class="vlist" style="height: 0.311664em;">
               <span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;">
                <span class="pstrut" style="height: 2.7em;">
                </span>
                <span class="sizing reset-size6 size3 mtight">
                 <span class="mord mtight">
                  <span class="mord mathdefault mtight">
                   m
                  </span>
                  <span class="mord mathdefault mtight">
                   i
                  </span>
                  <span class="mord mathdefault mtight">
                   n
                  </span>
                 </span>
                </span>
               </span>
              </span>
              <span class="vlist-s">
               ​
              </span>
             </span>
             <span class="vlist-r">
              <span class="vlist" style="height: 0.15em;">
               <span class="">
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
      ：表示所有位于Openlist上的state的最小K值。
     </li>
     <li>
      <strong>
       C（X,Y）
      </strong>
      ：表示X与Y之间的路径开销。
     </li>
     <li>
      <strong>
       Openlist
      </strong>
      是依据K值由小到大进行排序的优先队列。
     </li>
    </ul>
    <h3>
     <a id="62_151">
     </a>
     6.2算法描述
    </h3>
    <p>
     搜索的关键是state的传递过程，即由G向机器人所在位置进行搜索的过程，这种传递过程是通过不断地从当前OpenList中取出K值最小的State来实现的，每当一个State由Openlist中移出时，它会将开销传递给它的邻域state，这些邻域state会被置于Openlist中，持续进行该循环，直到机器人所在State的状态为 Closed ，或者Openlist为空（表示不存在到G的路径）。
    </p>
    <p>
     算法最主要的是两个函数，Process-State 和 Modify-Cost，前者用于计算到目标G的最优路径，后者用于改变两个state之间的开销C（X,Y）并将受影响的state置于Openlist中。
    </p>
    <p>
     算法的主要流程，在初始时，所有state的t（Tag）被设置为New，H（G）被设置为0，G被放置于OpenList，然后Process-State函数被不断执行，直到机器人所处state X由openlist中出队，然后可以通过机器人的当前state按backpointer指向目标G。
     <font color="red">
      <strong>
       当移动过程中发现新探测到的障碍时，Modify-Cost函数立刻被调用，来更正C（X,Y）中的路径开销并将受影响的state重新置于openlist中。
      </strong>
     </font>
    </p>
    <p>
     令Y表示robot发现障碍时所在的state，通过不断调用Process-State直到kmin≥H（Y），这时表示路径开销的更改已经传播到了Y，此时，新的路径构建完成。
     <br/>
     <strong>
      论文中的伪代码如下
     </strong>
     ：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/df96e3b9e7c9e3cb6cafa975a502dfbc.png">
     </img>
    </div>
    简要解释为：
    <ul>
     <li>
      <p>
       L1-L3表示拥有最低K值的X由openlist中移出，如果X为Lower，那么它的路径代价为最优的。
      </p>
     </li>
     <li>
      <p>
       在L8-L13，X为Lower状态，X的所有邻接state都被检测是否其路径代价可以更低，状态为New的邻接state被赋予初始路径开销值，并且开销的变动被传播给每一个backpointer指向X的邻接state Y（不管这个新的开销比原开销大或者小），也就是说只要你指向了X，那么X的路径开销变动时，你的路径代价必须随之改变。这里可能存在由于X路径开销变动过大，Y可以通过非X的其他state到达目标且路径开销更小的情况，这点在L8-13中并没有处理，而是放在后续针对Y的process-state函数中，在对Y进行处理时，会将其backpointer指向周围路径开销最小的state。如果X的邻接State状态为New时，应将其邻接state的backpointer指向X。所有路径开销有所变动的state都被置于Openlist中进行处理，从而将变动传播给邻接的state。
      </p>
     </li>
     <li>
      <p>
       在L4-L7中X为Raise，它的路径开销H可能不是最优的，通过其邻居state中已经处于最优开销（即h（Y）≤kold）的节点来优化X的路径开销，如果存在更短的路径，则将X的backpointer指向其neighbor。
      </p>
     </li>
     <li>
      <p>
       在L15-L18中，开销变动传播到状态为New的邻居state。如果X可以使一个backpointer并不指向X的邻居state的路径开销最小，即Y通过X到目标G的距离更短，但是此时Y的backpointer并不指向X，针对这种情况，可以将X重新置于Openlist中进而优化Y。
      </p>
     </li>
     <li>
      <p>
       在L23-25中，如果X可以通过一个状态为closed的并不是最理想的邻居stateY来减小路径开销，那么将Y重新置于Openlist中。
      </p>
      <div align="center">
      </div>
     </li>
    </ul>
    <img src="https://i-blog.csdnimg.cn/blog_migrate/4ffb77e3de78a3fada4d305a9ccc6017.png"/>
    <p>
     在modify-cost中，更新C（X,Y）并将X重新置于Openlist中，当X通过process-state进行传播时，会对Y进行开销计算，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         Y 
        
       
         ) 
        
       
         = 
        
       
         h 
        
       
         ( 
        
       
         X 
        
       
         ) 
        
       
         + 
        
       
         c 
        
       
         ( 
        
       
         X 
        
       
         , 
        
       
         Y 
        
       
         ) 
        
       
      
        h(Y)=h(X)+c(X,Y)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault" style="margin-right: 0.22222em;">
          Y
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault" style="margin-right: 0.07847em;">
          X
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          c
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault" style="margin-right: 0.07847em;">
          X
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.22222em;">
          Y
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     。
    </p>
    <h2>
     <a id="7D_177">
     </a>
     7.D*算法的另一种理解
    </h2>
    <p>
     以下来自于参考资料[2]:
    </p>
    <ol>
     <li>
      先用Dijstra算法从目标节点G向起始节点搜索。储存路网中目标点到各个节点的最短路和该位置到目标点的实际值h,k（k为所有变化h之中最小的值,当前为k=h。原OPEN和CLOSE中节点信息保存。
     </li>
     <li>
      机器人沿最短路开始移动，在移动的下一节点没有变化时，无需计算，利用上一步Dijstra计算出的最短路信息从出发点向后追述即可，当在Y点探测到下一节点X状态发生改变，如堵塞。机器人首先调整自己在当前位置Y到目标点G的实际值h(Y)，h(Y)=X到Y的新权值c(X,Y)+X的原实际值h(X).X为下一节点(到目标点方向Y-&gt;X-&gt;G），Y是当前点。k值取h值变化前后的最小。机器人沿最短路开始移动，在移动的下一节点没有变化时，无需计算，利用上一步Dijstra计算出的最短路信息从出发点向后追述即可，当在Y点探测到下一节点X状态发生改变，如堵塞。机器人首先调整自己在当前位置Y到目标点G的实际值h(Y)，h(Y)=X到Y的新权值c(X,Y)+X的原实际值h(X).X为下一节点(到目标点方向Y-&gt;X-&gt;G），Y是当前点。k值取h值变化前后的最小。
     </li>
     <li>
      用A_star或其它算法计算，这里假设用A_star算法,遍历Y的子节点，点放入CLOSE,调整Y的子节点a的h值，h(a)=h(Y)+Y到子节点a的权重C(Y,a),比较a点是否存在于OPEN和CLOSE中，方法如下：用A
      <em>
       或其它算法计算，这里假设用A
      </em>
      算法,遍历Y的子节点，点放入CLOSE,调整Y的子节点a的h值，h(a)=h(Y)+Y到子节点a的权重C(Y,a),比较a点是否存在于OPEN和CLOSE中，方法如下：
     </li>
    </ol>
    <pre><code class="prism language-c++">while()
{
从OPEN表中取k值最小的节点Y;
遍历Y的子节点a,计算a的h值 h(a)=h(Y)+Y到子节点a的权重C(Y,a)
{
    if(a in OPEN)     比较两个a的h值 
    if( a的h值小于OPEN表a的h值 )
    {
更新OPEN表中a的h值;k值取最小的h值
          有未受影响的最短路经存在
          break; 
    }
    if(a in CLOSE) 比较两个a的h值 //注意是同一个节点的两个不同路径的估价值
    if( a的h值小于CLOSE表的h值 )
    {
更新CLOSE表中a的h值; k值取最小的h值;将a节点放入OPEN表
       有未受影响的最短路经存在
       break;
    }
    if(a not in both)
        将a插入OPEN表中;　//还没有排序
}
放Y到CLOSE表；
OPEN表比较k值大小进行排序；
}

</code></pre>
    <h2>
     <a id="8DPython_210">
     </a>
     8.D*算法实现（Python）
    </h2>
    <pre><code class="prism language-python"><span class="token comment">#!/usr/bin/env python</span>
<span class="token comment"># -*- coding: utf-8 -*-</span>
<span class="token comment"># @Time    : 2018/12/13 0013 22:30</span>
<span class="token comment"># @Author  : 心一</span>
<span class="token comment"># @Site    : </span>
<span class="token comment"># @File    : D_star.py</span>
<span class="token comment"># @Software: PyCharm</span>

<span class="token keyword">import</span> math
<span class="token keyword">from</span> sys <span class="token keyword">import</span> maxsize <span class="token comment"># 导入最大数，2^63-1</span>


<span class="token keyword">class</span> <span class="token class-name">State</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x
        self<span class="token punctuation">.</span>y <span class="token operator">=</span> y
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">"."</span>
        self<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token string">"new"</span>
        self<span class="token punctuation">.</span>h <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># k即为f</span>

    <span class="token keyword">def</span> <span class="token function">cost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">"#"</span> <span class="token operator">or</span> state<span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> maxsize  <span class="token comment"># 存在障碍物时，距离无穷大</span>
        <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>x <span class="token operator">-</span> state<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                         math<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>y <span class="token operator">-</span> state<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">set_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> state <span class="token operator">not</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"S"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"#"</span><span class="token punctuation">,</span> <span class="token string">"E"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span><span class="token string">"+"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        self<span class="token punctuation">.</span>state <span class="token operator">=</span> state


<span class="token keyword">class</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''
    创建地图
    '''</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>row <span class="token operator">=</span> row
        self<span class="token punctuation">.</span>col <span class="token operator">=</span> col
        self<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>init_map<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">init_map</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 初始化map</span>
        map_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>
                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>State<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>
            map_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
        <span class="token keyword">return</span> map_list

    <span class="token keyword">def</span> <span class="token function">print_map</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tmp <span class="token operator">=</span> <span class="token string">""</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>
                tmp <span class="token operator">+=</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>state <span class="token operator">+</span> <span class="token string">" "</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_neighbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 获取8邻域</span>
        state_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                <span class="token keyword">if</span> state<span class="token punctuation">.</span>x <span class="token operator">+</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> state<span class="token punctuation">.</span>x <span class="token operator">+</span> i <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>row<span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                <span class="token keyword">if</span> state<span class="token punctuation">.</span>y <span class="token operator">+</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> state<span class="token punctuation">.</span>y <span class="token operator">+</span> j <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>col<span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                state_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span>state<span class="token punctuation">.</span>x <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">[</span>state<span class="token punctuation">.</span>y <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> state_list

    <span class="token keyword">def</span> <span class="token function">set_obstacle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 设置障碍物的位置</span>
        <span class="token keyword">for</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span> point_list<span class="token punctuation">:</span>
            <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> x <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>row <span class="token operator">or</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> y <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>col<span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>set_state<span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span>


<span class="token keyword">class</span> <span class="token class-name">Dstar</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> maps<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token operator">=</span> maps
        self<span class="token punctuation">.</span>open_list <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 创建空集合</span>

    <span class="token keyword">def</span> <span class="token function">process_state</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''
        D*算法的主要过程
        :return:
        '''</span>
        x <span class="token operator">=</span> self<span class="token punctuation">.</span>min_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 获取open list列表中最小k的节点</span>
        <span class="token keyword">if</span> x <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        k_old <span class="token operator">=</span> self<span class="token punctuation">.</span>get_kmin<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#获取open list列表中最小k节点的k值</span>
        self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 从openlist中移除</span>
        <span class="token comment"># 判断openlist中</span>
        <span class="token keyword">if</span> k_old <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>h<span class="token punctuation">:</span>
            <span class="token keyword">for</span> y <span class="token keyword">in</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">.</span>get_neighbers<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> y<span class="token punctuation">.</span>h <span class="token operator">&lt;=</span> k_old <span class="token operator">and</span> x<span class="token punctuation">.</span>h <span class="token operator">&gt;</span> y<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                    x<span class="token punctuation">.</span>h <span class="token operator">=</span> y<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> k_old <span class="token operator">==</span> x<span class="token punctuation">.</span>h<span class="token punctuation">:</span>
            <span class="token keyword">for</span> y <span class="token keyword">in</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">.</span>get_neighbers<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> y<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"new"</span> <span class="token operator">or</span> y<span class="token punctuation">.</span>parent <span class="token operator">==</span> x <span class="token operator">and</span> y<span class="token punctuation">.</span>h <span class="token operator">!=</span> x<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span> \
                        <span class="token operator">or</span> y<span class="token punctuation">.</span>parent <span class="token operator">!=</span> x <span class="token operator">and</span> y<span class="token punctuation">.</span>h <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    y<span class="token punctuation">.</span>parent <span class="token operator">=</span> x
                    self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> y <span class="token keyword">in</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">.</span>get_neighbers<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> y<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"new"</span> <span class="token operator">or</span> y<span class="token punctuation">.</span>parent <span class="token operator">==</span> x <span class="token operator">and</span> y<span class="token punctuation">.</span>h <span class="token operator">!=</span> x<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    y<span class="token punctuation">.</span>parent <span class="token operator">=</span> x
                    self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> y<span class="token punctuation">.</span>parent <span class="token operator">!=</span> x <span class="token operator">and</span> y<span class="token punctuation">.</span>h <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">.</span>h<span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">if</span> y<span class="token punctuation">.</span>parent <span class="token operator">!=</span> x <span class="token operator">and</span> x<span class="token punctuation">.</span>h <span class="token operator">&gt;</span> y<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>y<span class="token punctuation">)</span> \
                                <span class="token operator">and</span> y<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"close"</span> <span class="token operator">and</span> y<span class="token punctuation">.</span>h <span class="token operator">&gt;</span> k_old<span class="token punctuation">:</span>
                            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>y<span class="token punctuation">,</span> y<span class="token punctuation">.</span>h<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>get_kmin<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">min_state</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        min_state <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>open_list<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>k<span class="token punctuation">)</span>  <span class="token comment"># 获取openlist中k值最小对应的节点</span>
        <span class="token keyword">return</span> min_state

    <span class="token keyword">def</span> <span class="token function">get_kmin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 获取openlist表中k(f)值最小的k</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        k_min <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">.</span>k <span class="token keyword">for</span> x <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> k_min

    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">,</span> h_new<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> state<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"new"</span><span class="token punctuation">:</span>
            state<span class="token punctuation">.</span>k <span class="token operator">=</span> h_new
        <span class="token keyword">elif</span> state<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"open"</span><span class="token punctuation">:</span>
            state<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>k<span class="token punctuation">,</span> h_new<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> state<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"close"</span><span class="token punctuation">:</span>
            state<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>h<span class="token punctuation">,</span> h_new<span class="token punctuation">)</span>
        state<span class="token punctuation">.</span>h <span class="token operator">=</span> h_new
        state<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token string">"open"</span>
        self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>add<span class="token punctuation">(</span>state<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> state<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"open"</span><span class="token punctuation">:</span>
            state<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token string">"close"</span>
        self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>state<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">modify_cost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> x<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"close"</span><span class="token punctuation">:</span>  <span class="token comment"># 是以一个openlist，通过parent递推整条路径上的cost</span>
            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>h <span class="token operator">+</span> x<span class="token punctuation">.</span>cost<span class="token punctuation">(</span>x<span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>add<span class="token punctuation">(</span>end<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>process_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> start<span class="token punctuation">.</span>t <span class="token operator">==</span> <span class="token string">"close"</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        start<span class="token punctuation">.</span>set_state<span class="token punctuation">(</span><span class="token string">"S"</span><span class="token punctuation">)</span>
        s <span class="token operator">=</span> start
        <span class="token keyword">while</span> s <span class="token operator">!=</span> end<span class="token punctuation">:</span>
            s <span class="token operator">=</span> s<span class="token punctuation">.</span>parent
            s<span class="token punctuation">.</span>set_state<span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span>
        s<span class="token punctuation">.</span>set_state<span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'障碍物未发生变化时，搜索的路径如下：'</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">.</span>print_map<span class="token punctuation">(</span><span class="token punctuation">)</span>
        tmp <span class="token operator">=</span> start <span class="token comment"># 起始点不变</span>
        self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">.</span>set_obstacle<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 障碍物发生变化</span>
        <span class="token triple-quoted-string string">'''
        从起始点开始，往目标点行进，当遇到障碍物时，重新修改代价，再寻找路径
        '''</span>
        <span class="token keyword">while</span> tmp <span class="token operator">!=</span> end<span class="token punctuation">:</span>
            tmp<span class="token punctuation">.</span>set_state<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>
            <span class="token comment"># self.map.print_map()</span>
            <span class="token comment"># print("")</span>
            <span class="token keyword">if</span> tmp<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>modify<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
                <span class="token keyword">continue</span>
            tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>parent
        tmp<span class="token punctuation">.</span>set_state<span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'障碍物发生变化时，搜索的路径如下(*为更新的路径)：'</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">.</span>print_map<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">modify</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">'''
        当障碍物发生变化时，从目标点往起始点回推，更新由于障碍物发生变化而引起的路径代价的变化
        :param state:
        :return:
        '''</span>
        self<span class="token punctuation">.</span>modify_cost<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            k_min <span class="token operator">=</span> self<span class="token punctuation">.</span>process_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> k_min <span class="token operator">&gt;=</span> state<span class="token punctuation">.</span>h<span class="token punctuation">:</span>
                <span class="token keyword">break</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    m <span class="token operator">=</span> Map<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
    m<span class="token punctuation">.</span>set_obstacle<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    start <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
    end <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span>
    dstar <span class="token operator">=</span> Dstar<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
    dstar<span class="token punctuation">.</span>run<span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span>
    <span class="token comment"># m.print_map()</span>

</code></pre>
    <p>
     运行效果如下：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/00a2ffa7577edd6da3b3ceae16d4fdb1.png"/>
    </div>
    <h2>
     <a id="9_429">
     </a>
     9.算法总结
    </h2>
    <p>
     相比A-star算法，D-star的主要特点就是由目标位置开始向起始位置进行路径搜索，当物体由起始位置向目标位置运行过程中，发现路径中
     <font color="red">
      <strong>
       存在新的障碍
      </strong>
     </font>
     时，对于目标位置到新障碍之间的范围内的路径节点，
     <font color="red">
      <strong>
       新的障碍是不会影响到其到目标的路径的
      </strong>
     </font>
     。新障碍只会影响的是物体所在位置到障碍之间范围的节点的路径。在这时通过
     <font color="red">
      <strong>
       将新的障碍周围的节点加入到Openlist中进行处理然后向物体所在位置进行传播
      </strong>
     </font>
     ，能最小程度的减少计算开销。
    </p>
    <p>
     D*路径搜索的过程和Dijkstra算法比较像，A-star算法中f(n)=g(n)+h(n)，h(n)在D-star中并没有体现，路径的搜索并没有A-star所具有的方向感，即朝着目标搜索的感觉，这种搜索更多的是一种由目标位置向四周发散搜索，直到把起始位置纳入搜索范围为止，更像是Dijkstra算法。
    </p>
    <p>
     同时，由示例的算法效果来看，D_star算法能够在障碍物发生变化时，仍能找到一条路径，但不一定是一条最短的路径。
    </p>
    <h2>
     <a id="_437">
     </a>
     参考资料
    </h2>
    <p>
     [1]
     <a href="https://www.wikiwand.com/en/D*" rel="nofollow">
      Wiki百科：D*
     </a>
     <br/>
     [2]
     <a href="https://blog.csdn.net/kongbu0622/article/details/1871520">
      最短路经算法简介(Dijkstra算法，A
      <em>
       算法，D
      </em>
      算法)（转载）
     </a>
     <br/>
     [3]
     <a href="https://blog.csdn.net/a380331382/article/details/82841071">
      D star路径搜索算法
     </a>
     <br/>
     [4]
     <a href="http://web.mit.edu/16.412j/www/html/papers/original_dstar_icra94.pdf" rel="nofollow">
      Optimal and Efficient Path Planning for Partially-Known Environments.pdf
     </a>
    </p>
    <h2>
     <a id="font_colorredfont_444">
     </a>
     <font color="red">
      搜索算法其他文章
     </font>
    </h2>
    <p>
     <a href="https://blog.csdn.net/lqzdreamer/article/details/85158542">
      Field Ｄstar路径规划算法
     </a>
     <br/>
     <a href="https://blog.csdn.net/lqzdreamer/article/details/85108310">
      Dstar Lite路径规划算法
     </a>
     <br/>
     <a href="https://blog.csdn.net/lqzdreamer/article/details/85175372">
      终身规划Astar算法（LPA*）：Lifelong Planning A*
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6c717a647265616d6572:2f61727469636c652f64657461696c732f3835303535353639" class_="artid" style="display:none">
 </p>
</div>


