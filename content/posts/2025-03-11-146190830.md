---
layout: post
title: "Django-ORM-prefetch_related"
date: 2025-03-11 22:42:04 +0800
description: "Author和Book。一个作者可以写多本书，一本书也可以有多个作者（多对多关系）。是 Django ORM 提供的一个强大的查询优化工具，特别适用于处理多对多和一对多关系中的 N+1 查询问题。通过预先加载关联对象，能够显著减少数据库查询次数，提高应用的性能。在使用时，需要根据具体的业务场景选择合适的预取策略，并注意内存消耗等问题，以达到最佳的优化效果。希望通过以上的解释和示例，你对有了更深入的理解！"
keywords: "Django-ORM-prefetch_related"
categories: ['Python', 'Django']
tags: ['数据库', 'Python', 'Django']
artid: "146190830"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146190830
    alt: "Django-ORM-prefetch_related"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146190830
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146190830
cover: https://bing.ee123.net/img/rand?artid=146190830
image: https://bing.ee123.net/img/rand?artid=146190830
img: https://bing.ee123.net/img/rand?artid=146190830
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Django-ORM-prefetch_related
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-kimbie-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <p>
     通过
     <code>
      Author
     </code>
     和
     <code>
      Books
     </code>
     两个模型来理解 Django 的
     <code>
      prefetch_related
     </code>
     方法。
     <br/>
     探讨如何使用
     <code>
      prefetch_related
     </code>
     来优化查询，避免 N+1 查询问题，
     <br/>
     并展示其在处理多对多关系和复杂查询中的强大功能。
    </p>
    <h2>
     <a id="_6">
     </a>
     模型定义
    </h2>
    <p>
     首先，假设我们有两个模型：
     <code>
      Author
     </code>
     和
     <code>
      Book
     </code>
     。一个作者可以写多本书，一本书也可以有多个作者（多对多关系）。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models

<span class="token keyword">class</span> <span class="token class-name">Author</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>name

<span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    title <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    authors <span class="token operator">=</span> models<span class="token punctuation">.</span>ManyToManyField<span class="token punctuation">(</span>Author<span class="token punctuation">,</span> related_name<span class="token operator">=</span><span class="token string">'books'</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>title
</code></pre>
    <h3>
     <a id="N1__27">
     </a>
     N+1 查询问题示例
    </h3>
    <p>
     假设我们想要获取所有作者以及他们所写的书籍。
     <br/>
     如果不使用
     <code>
      prefetch_related
     </code>
     ，可能会遇到 N+1 查询问题。
    </p>
    <pre><code class="prism language-python"><span class="token comment"># 获取所有作者</span>
authors <span class="token operator">=</span> Author<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> author <span class="token keyword">in</span> authors<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Author: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>author<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 每个作者都会触发一次数据库查询</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  Book: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>book<span class="token punctuation">.</span>title<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      问题分析：
     </strong>
     <br/>
     • 第一次查询获取所有作者。
     <br/>
     • 对于每个作者，执行一次查询来获取其书籍。
     <br/>
     • 如果有 10 个作者，总共会执行 1 + 10 = 11 次查询。
    </p>
    <h2>
     <a id="_prefetch_related__47">
     </a>
     使用 prefetch_related 优化查询
    </h2>
    <p>
     <code>
      prefetch_related
     </code>
     可以显著减少查询次数。
     <br/>
     它会在后台执行额外的查询，并将结果缓存起来，
     <br/>
     以便在访问关联对象时不需要额外的数据库查询。
    </p>
    <pre><code class="prism language-python"><span class="token comment"># 使用 prefetch_related 预取每个作者的书籍</span>
authors <span class="token operator">=</span> Author<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>prefetch_related<span class="token punctuation">(</span><span class="token string">'books'</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> author <span class="token keyword">in</span> authors<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Author: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>author<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 现在只执行两次查询</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  Book: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>book<span class="token punctuation">.</span>title<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      优化效果：
     </strong>
     <br/>
     • 第一次查询获取所有作者。
     <br/>
     • 第二次查询获取所有相关的书籍。
     <br/>
     • Django 在 Python 层面将这些书籍分配给相应的作者。
     <br/>
     • 总共只执行了 2 次查询，无论有多少个作者。
    </p>
    <h2>
     <a id="_69">
     </a>
     处理更复杂的查询
    </h2>
    <p>
     有时候，我们可能需要预取多个关联字段，或者对预取的数据进行过滤。
     <br/>
     这时，可以使用
     <code>
      Prefetch
     </code>
     对象来实现更细粒度的控制。
    </p>
    <h3>
     <a id="_74">
     </a>
     示例：预取特定条件的书籍
    </h3>
    <p>
     假设我们只想预取每位作者最近出版的 5 本书：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db<span class="token punctuation">.</span>models <span class="token keyword">import</span> Prefetch

<span class="token comment"># 定义一个 Prefetch 对象，过滤并限制预取的书籍数量</span>
recent_books <span class="token operator">=</span> Prefetch<span class="token punctuation">(</span>
    <span class="token string">'books'</span><span class="token punctuation">,</span>
    queryset<span class="token operator">=</span>Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'-id'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment"># 假设 id 越大，出版时间越近</span>
    to_attr<span class="token operator">=</span><span class="token string">'recent_books'</span>                     <span class="token comment"># 将预取的书籍存储在 author.recent_books 中</span>
<span class="token punctuation">)</span>

authors <span class="token operator">=</span> Author<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>prefetch_related<span class="token punctuation">(</span>recent_books<span class="token punctuation">)</span>

<span class="token keyword">for</span> author <span class="token keyword">in</span> authors<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Author: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>author<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> author<span class="token punctuation">.</span>recent_books<span class="token punctuation">:</span>  <span class="token comment"># 访问预取的书籍</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  Recent Book: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>book<span class="token punctuation">.</span>title<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      解释：
     </strong>
     <br/>
     • 使用
     <code>
      Prefetch
     </code>
     对象，我们可以自定义预取的查询集。
     <br/>
     •
     <code>
      to_attr
     </code>
     参数指定了预取的数据存储在模型实例的哪个属性中。
     <br/>
     • 这样可以避免加载所有关联对象，只加载我们需要的部分。
    </p>
    <h3>
     <a id="_101">
     </a>
     示例：预取多个关联字段
    </h3>
    <p>
     如果
     <code>
      Author
     </code>
     模型还有其他关联字段，比如
     <code>
      editor
     </code>
     ，我们可以同时预取多个关联：
    </p>
    <pre><code class="prism language-python">authors <span class="token operator">=</span> Author<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>prefetch_related<span class="token punctuation">(</span>
    <span class="token string">'books'</span><span class="token punctuation">,</span>
    <span class="token string">'editor'</span>  <span class="token comment"># 假设有一个 ForeignKey 字段 'editor'</span>
<span class="token punctuation">)</span>

<span class="token keyword">for</span> author <span class="token keyword">in</span> authors<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Author: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>author<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  Book: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>book<span class="token punctuation">.</span>title<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> author<span class="token punctuation">.</span>editor<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  Editor: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>author<span class="token punctuation">.</span>editor<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre>
    <h2>
     <a id="_119">
     </a>
     性能比较
    </h2>
    <p>
     为了更直观地理解
     <code>
      prefetch_related
     </code>
     的性能优势，我们来看一个简单的性能对比：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> time

<span class="token comment"># 不使用 prefetch_related</span>
start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
authors <span class="token operator">=</span> Author<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> author <span class="token keyword">in</span> authors<span class="token punctuation">:</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>  <span class="token comment"># 模拟操作</span>
end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"无 prefetch_related 查询次数: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>end_time <span class="token operator">-</span> start_time<span class="token punctuation">}</span></span><span class="token string"> 秒"</span></span><span class="token punctuation">)</span>

<span class="token comment"># 使用 prefetch_related</span>
start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
authors <span class="token operator">=</span> Author<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>prefetch_related<span class="token punctuation">(</span><span class="token string">'books'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> author <span class="token keyword">in</span> authors<span class="token punctuation">:</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>  <span class="token comment"># 模拟操作</span>
end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"使用 prefetch_related 查询次数: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>end_time <span class="token operator">-</span> start_time<span class="token punctuation">}</span></span><span class="token string"> 秒"</span></span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      预期结果：
     </strong>
     <br/>
     • 不使用
     <code>
      prefetch_related
     </code>
     的情况下，查询时间会随着作者数量的增加而线性增长。
     <br/>
     • 使用
     <code>
      prefetch_related
     </code>
     后，查询时间基本保持不变，因为关联数据的查询次数大大减少。
    </p>
    <h2>
     <a id="_149">
     </a>
     注意事项
    </h2>
    <ol>
     <li>
      <p>
       <strong>
        适用场景
       </strong>
       ：
       <code>
        prefetch_related
       </code>
       主要用于处理“多对多”和“一对多”关系。对于“一对一”或“外键”关系，通常使用
       <code>
        select_related
       </code>
       更为高效。
      </p>
     </li>
     <li>
      <p>
       <strong>
        内存消耗
       </strong>
       ：由于
       <code>
        prefetch_related
       </code>
       会将所有预取的数据加载到内存中，如果关联数据量非常大，可能会导致内存占用过高。因此，在处理大数据集时需要谨慎使用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自定义查询
       </strong>
       ：通过
       <code>
        Prefetch
       </code>
       对象，可以自定义预取的查询集，如过滤、排序或限制数量，从而进一步优化性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        链式调用
       </strong>
       ：
       <code>
        prefetch_related
       </code>
       可以与其他查询优化方法（如
       <code>
        filter
       </code>
       、
       <code>
        exclude
       </code>
       等）结合使用，以满足复杂的查询需求。
      </p>
     </li>
    </ol>
    <h2>
     <a id="_159">
     </a>
     总结
    </h2>
    <p>
     <code>
      prefetch_related
     </code>
     是 Django ORM 提供的一个强大的查询优化工具，特别适用于处理多对多和一对多关系中的 N+1 查询问题。通过预先加载关联对象，
     <code>
      prefetch_related
     </code>
     能够显著减少数据库查询次数，提高应用的性能。在使用时，需要根据具体的业务场景选择合适的预取策略，并注意内存消耗等问题，以达到最佳的优化效果。
    </p>
    <p>
     希望通过以上的解释和示例，你对
     <code>
      django-prefetch_related
     </code>
     有了更深入的理解！
    </p>
    <p>
    </p>
    <div class="toc">
     <h4>
      Django-ORM-prefetch_related
     </h4>
     <ul>
      <li>
       <a href="#_6" rel="nofollow">
        模型定义
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#N1__27" rel="nofollow">
          N+1 查询问题示例
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_prefetch_related__47" rel="nofollow">
        使用 prefetch_related 优化查询
       </a>
      </li>
      <li>
       <a href="#_69" rel="nofollow">
        处理更复杂的查询
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_74" rel="nofollow">
          示例：预取特定条件的书籍
         </a>
        </li>
        <li>
         <a href="#_101" rel="nofollow">
          示例：预取多个关联字段
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_119" rel="nofollow">
        性能比较
       </a>
      </li>
      <li>
       <a href="#_149" rel="nofollow">
        注意事项
       </a>
      </li>
      <li>
       <a href="#_159" rel="nofollow">
        总结
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32323033383332372f:61727469636c652f64657461696c732f313436313930383330" class_="artid" style="display:none">
 </p>
</div>


