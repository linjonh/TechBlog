---
arturl_encode: "68747470733a2f2f626c6f672e63:73646e2e6e65742f636861726c69653131343531343139312f:61727469636c652f64657461696c732f313436323833363735"
layout: post
title: "IMX6ULL学习整理篇Linux驱动开发的基础2-老框架的一次实战LED驱动"
date: 2025-03-15 18:54:15 +0800
description: "​\t在上一篇博客中，我们实现了从0开始搭建的字符设备驱动框架，但是这个框架还是空中楼阁，没有应用，很难说明我们框架的正确性。这里，我们就准备好驱动正点原子开发板上的一个LED小灯外设。他被接在了GPIO01_IO03上。"
keywords: "IMX6ULL学习整理篇——Linux驱动开发的基础2 老框架的一次实战：LED驱动"
categories: ['从0开始的学习Armv7A', 'Imx']
tags: ['驱动开发', '教程', '学习', '字符设备', '内核', 'Linux']
artid: "146283675"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146283675
    alt: "IMX6ULL学习整理篇Linux驱动开发的基础2-老框架的一次实战LED驱动"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146283675
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146283675
cover: https://bing.ee123.net/img/rand?artid=146283675
image: https://bing.ee123.net/img/rand?artid=146283675
img: https://bing.ee123.net/img/rand?artid=146283675
---

# IMX6ULL学习整理篇——Linux驱动开发的基础2 老框架的一次实战：LED驱动
## IMX6ULL学习整理篇——Linux驱动开发的基础2 老框架的一次实战：LED驱动
​ 在上一篇博客中，我们实现了从0开始搭建的字符设备驱动框架，但是这个框架还是空中楼阁，没有应用，很难说明我们框架的正确性。这里，我们就准备好驱动正点原子开发板上的一个LED小灯外设。他被接在了GPIO01\\_IO03上。
### 开始之前，复习一下架构体系对外设的地址处理
​ 毫无疑问，任何一个搞过单片机的朋友都知道：在 ARM 架构中，外设的地址处理主要通过内存映射（Memory-Mapped I/O）方式进行。这意味着，外设的寄存器被映射到处理器的内存地址空间，CPU 可以像访问内存一样访问这些外设寄存器。这个技术连x86开始就在使用了！每个外设的寄存器都被分配了特定的物理地址，处理器通过读写这些地址来控制外设的操作。这种方式简化了处理器与外设之间的通信，因为不需要专门的 I/O 指令，统一了内存和外设的访问方式。
​ 当然，对于我们复杂的ARM芯片上的主板一般还有MMU内存管理单元。我们的地址访问都被认为是一个虚拟地址时，这个时候MMU 会根据页表将其转换为相应的物理地址。这不仅实现了内存的虚拟化，还允许操作系统为不同的应用程序提供独立的地址空间，提高了系统的安全性和稳定性。
​ 关于虚拟内存和物理内存，复习微机原理可以帮助你理解这些知识，笔者这里是驱动笔记整理，不是计算机体系架构笔记整理，所以请你自行翻阅相关的知识！
​ 这也就意味着，我们没法子直接拿物理地址访问我们的GPIO寄存器了，那咋办呢？答案是：Linux考虑到了这类情况，提供了一组API，让我们添加IO设备的外设地址映射，告诉我们我们操作的虚拟地址是哪个！
### ioremap和iounmap函数
​ 在 Linux 内核中，
`ioremap`
和
`iounmap`
函数用于在内核虚拟地址空间中映射和解除映射物理 I/O 内存区域，以便内核能够安全地访问硬件设备的寄存器或内存。
`ioremap`
函数用于将指定的物理地址范围映射到内核的虚拟地址空间，使内核能够通过虚拟地址访问对应的物理 I/O 内存区域。
```c
void \_\_iomem \*ioremap(resource\_size\_t phys\_addr, unsigned long size);
```
​ 其中：
`phys\_addr`
是要映射的物理起始地址。
`size`
：要映射的内存区域大小。成功时，返回指向映射后虚拟地址空间的指针；失败时，返回
`NULL`
。调用
`ioremap`
后，内核可以通过返回的虚拟地址指针访问对应的物理 I/O 内存区域。
​
`iounmap`
函数用于解除先前通过
`ioremap`
建立的映射关系，释放对应的虚拟地址空间。
```c
void iounmap(void \_\_iomem \*addr);
```
​ 这里的
`addr`
：要解除映射的虚拟地址，即先前
`ioremap`
的返回值。调用
`iounmap`
后，内核将不再能够通过该虚拟地址访问对应的物理 I/O 内存区域。
​ 当然笔者提醒：
\* 在访问硬件设备的寄存器或内存时，必须先使用
`ioremap`
将物理地址映射到内核虚拟地址空间，然后通过返回的虚拟地址进行读写操作。
\* 在不再需要访问该 I/O 内存区域时，应调用
`iounmap`
解除映射，以释放资源。
\* 直接访问物理地址可能导致不可预期的行为，因此应始终通过
`ioremap`
和
`iounmap`
函数进行 I/O 内存的映射和解除映射。
### read蔟函数和write蔟函数——操作我们的IO设备
​ 拿到地址了，咋写呢？别自己手搓，我们的Linux还是给我们提供了API：在 Linux 内核中，
`readb`
、
`readw`
、
`readl`
以及
`writeb`
、
`writew`
、
`writel`
等函数用于在内存映射的 I/O 空间中读取和写入数据。
\*\*读取操作函数：
`readb`
、
`readw`
、
`readl`
函数用于从内存映射的 I/O 空间读取 8 位、16 位和 32 位的数据。\*\*
`readb`
：从指定的内存映射 I/O 地址读取 8 位（1 字节）数据。
```c
unsigned char readb(const volatile void \_\_iomem \*addr);
```
`readw`
：从指定的内存映射 I/O 地址读取 16 位（2 字节）数据。
```c
unsigned short readw(const volatile void \_\_iomem \*addr);
```
`readl`
：从指定的内存映射 I/O 地址读取 32 位（4 字节）数据。
```c
unsigned int readl(const volatile void \_\_iomem \*addr);
```
\*\*写入操作函数：\*\*
`writeb`
、
`writew`
、
`writel`
函数用于向内存映射的 I/O 空间写入 8 位、16 位和 32 位的数据。
`writeb`
：向指定的内存映射 I/O 地址写入 8 位（1 字节）数据。
```c
void writeb(u8 value, volatile void \_\_iomem \*addr);
```
`writew`
：向指定的内存映射 I/O 地址写入 16 位（2 字节）数据。
```c
void writew(u16 value, volatile void \_\_iomem \*addr);
```
`writel`
：向指定的内存映射 I/O 地址写入 32 位（4 字节）数据。
```c
void writel(u32 value, volatile void \_\_iomem \*addr);
```
\* `addr`
：指向内存映射 I/O 空间中目标地址的指针。
\* `value`
：要写入的数据。
### 编程，启动！
​ 具体是啥地址，这个事情三个字：翻手册。没了，还不懂看如何裸机驱动LED，这就跟LKM驱动开发半毛钱关系没有了
```c
#include 
#include 
#include 
#include 
#include 
#include 
MODULE\_LICENSE("GPL");
MODULE\_AUTHOR("charliechen");
#define LED\_MAJOR\_DEV\_N (114)
#define LED\_DEV\_NAME ("charlies\_led")
/\*
LED Physical Address
See the manual
\*/
#define CCM\_CCGR1\_BASE (0x020C406C)
#define GPIO1\_IOLED\_BASE (0x020E0068)
#define GPIO1\_IOPAD\_BASE (0x020E02F4)
#define GPIO1\_IODR\_BASE (0x0209C000)
#define GPIO1\_GDIR\_BASE (0x0209C004)
/\* mappings of the io phe\*/
static void\* \_\_iomem LED\_CCGR1;
static void\* \_\_iomem LEDBASE;
static void\* \_\_iomem LEDPAD\_BASE;
static void\* \_\_iomem LEDDR\_BASE;
static void\* \_\_iomem LEDGDIR\_BASE;
/\* operations cached \*/
static char operations\_cached[20];
static void \_\_led\_turn\_on(void)
{
u32 val = 0;
val = readl(LEDDR\_BASE);
val &= ~(1 << 3);
writel(val, LEDDR\_BASE);
}
static void \_\_led\_turn\_off(void)
{
u32 val = 0;
val = readl(LEDDR\_BASE);
val |= (1 << 3);
writel(val, LEDDR\_BASE);
}
static u8 \_\_fetch\_led\_status(void)
{
u32 val = 0;
val = readl(LEDDR\_BASE);
return !(val & (1 << 3));
}
static void \_\_enable\_led\_mappings(void)
{
int val = 0;
pr\_info("Ready to mappings the registers...\n");
LED\_CCGR1 = ioremap(CCM\_CCGR1\_BASE, 4);
LEDBASE = ioremap(GPIO1\_IOLED\_BASE, 4);
LEDPAD\_BASE = ioremap(GPIO1\_IOPAD\_BASE, 4);
LEDDR\_BASE = ioremap(GPIO1\_IODR\_BASE, 4);
LEDGDIR\_BASE = ioremap(GPIO1\_GDIR\_BASE, 4);
pr\_info("mappings the registers done!\n");
pr\_info("LED\_CCGR1 ioremap to: %p\n", LED\_CCGR1);
pr\_info("LEDBASE ioremap to: %p\n", LEDBASE);
pr\_info("LEDPAD\_BASE ioremap to: %p\n", LEDPAD\_BASE);
pr\_info("LEDDR\_BASE ioremap to: %p\n", LEDDR\_BASE);
pr\_info("LEDGDIR\_BASE ioremap to: %p\n", LEDGDIR\_BASE);
pr\_info("initialize the led registers\n");
val = readl(LED\_CCGR1);
// clear the bits
val &= ~(3 << 26);
val |= (3 << 26);
writel(val, LED\_CCGR1);
writel(0x5, LEDBASE);
writel(0x10B0, LEDPAD\_BASE);
val = readl(LEDGDIR\_BASE);
val |= 1 << 3;
writel(val, LEDGDIR\_BASE);
pr\_info("operations of led is accessable!\n");
}
static void \_\_disable\_led\_mappings(void)
{
\_\_led\_turn\_off();
pr\_info("set the led turning off...\n");
pr\_info("set the led turning off done!\n");
pr\_info("Ready to unmappings the registers...\n");
iounmap(LED\_CCGR1);
iounmap(LEDBASE);
iounmap(LEDPAD\_BASE);
iounmap(LEDDR\_BASE);
iounmap(LEDGDIR\_BASE);
pr\_info("unmappings the registers done\n");
}
static int led\_open(struct inode\* inode, struct file\* filp)
{
pr\_info("\nled device is opened!\n");
return 0;
}
static int led\_close(struct inode\* inode, struct file\* filp)
{
pr\_info("\nled device is released!\n");
return 0;
}
static ssize\_t led\_read(struct file\* filp, char\* buffer,
size\_t count, loff\_t\* ppos)
{
const char\* status = "opened";
int ret = 0;
pr\_info("\nled device is reading!\n");
if(!\_\_fetch\_led\_status()){
status = "closed";
}
ret = copy\_to\_user(buffer, status, strlen(status));
if(ret < 0)
{
pr\_warn("Copy to the user failed\n");
return -EFAULT;
}
return 0;
}
static ssize\_t led\_write(struct file\* filp,const char\* buffer,
size\_t count, loff\_t\* ppos)
{
int check = 0;
pr\_info("\nled device is ready writing!\n");
check = copy\_from\_user(operations\_cached, buffer, count);
if(check < 0){
pr\_warn("Can not copy from user!\n");
return -EFAULT;
}
if(!strcmp(operations\_cached, "open")){
\_\_led\_turn\_on();
}else if(!strcmp(operations\_cached, "close")){
\_\_led\_turn\_off();
}else{
pr\_warn("Can not find the indications operations!\n"
"check the business: %s", operations\_cached);
}
return 0;
}
static struct file\_operations led\_ops = {
.owner = THIS\_MODULE,
.read = led\_read,
.write = led\_write,
.open = led\_open,
.release = led\_close
};
static int \_\_init led\_init(void)
{
int result = 0;
pr\_info("LED Device is setting up\n");
result = register\_chrdev(LED\_MAJOR\_DEV\_N, LED\_DEV\_NAME, &led\_ops);
if(result < 0){
pr\_warn("can not register the device!\n");
return -EIO;
}
\_\_enable\_led\_mappings();
return 0;
}
static void \_\_exit led\_exit(void)
{
unregister\_chrdev(LED\_MAJOR\_DEV\_N, LED\_DEV\_NAME);
\_\_disable\_led\_mappings();
pr\_info("LED Device is unhooked!\n");
}
module\_init(led\_init);
module\_exit(led\_exit);
```
### 书写测试程序
```c
#include 
#include 
#include 
#include 
#include 
#define ISSUE\_BUFFER\_N (40)
static void display\_help(const char\* app\_name)
{
fprintf(stderr,
"do: %s  \n"
"op: read : read the data from char dev\n"
"op: write: write the data to char dev:\n"
" open: turn on the led\n"
" close: turn off the led\n", app\_name);
}
int main(int argc, char\* argv[])
{
int check = 0;
if(argc < 3){
display\_help(argv[0]);
return -1;
}
char\* filename = argv[1];
check = open(filename, O\_RDWR);
if(check < 0){
fprintf(stderr, "Hey, Error in open filename: %s!\n", filename);
return -1;
}
int result = 0;
if(!strcmp(argv[2], "read")){
// process reading issue
printf("user process the read issue\n");
char buffer[ISSUE\_BUFFER\_N];
result = read(check, buffer, ISSUE\_BUFFER\_N);
if(result < 0){
fprintf(stderr, "Hey, Error in read! filename: %s!\n", filename);
goto close\_issue;
}
printf("user receive from driver: %s\n", buffer);
// done!
}else if(!strcmp(argv[2], "write")){
// process the write
printf("args: %d\n", argc);
if(argc != 4){
display\_help(argv[0]);
goto close\_issue;
}
printf("user process the write issue: %s\n", argv[3]);
result = write(check, argv[3], strlen(argv[3]));
if(result < 0){
fprintf(stderr, "Hey, Error in write! filename: %s!\n", filename);
goto close\_issue;
}
}else{
fprintf(stderr, "Unknown options!\n");
display\_help(argv[0]);
goto close\_issue;
}
close\_issue:
result = close(check);
if(result < 0){
fprintf(stderr, "Hey, Error in close device! filename: %s!\n", filename);
return -1;
}
return 0;
}
```
​ 无比怀念CLI框架的一天.jpg
​ 下面我们测试一下：
### 测试
```
/module\_test # ls
chrdev\_application led.ko
/module\_test # mknod /dev/ccled c 114 0
/module\_test # insmod led.ko
LED Device is setting up
Ready to mappings the registers...
mappings the registers done!
LED\_CCGR1 ioremap to: f42c406c
LEDBASE ioremap to: f42e0068
LEDPAD\_BASE ioremap to: f42e02f4
LEDDR\_BASE ioremap to: a092e000
LEDGDIR\_BASE ioremap to: a0936004
initialize the led registers
operations of led is accessable!
/module\_test # ./chrdev\_application /dev/ccled read
led device is opened!
user process the read issue
led device is reading!
user receive from driver: closed
led device is released!
v
/module\_test # ./chrdev\_application /dev/ccled write open
led device is opened!
args: 4
led device is ready writing!
user process the write issue: o
led device is released!
pen
/module\_test # ./chrdev\_application /dev/ccled write close
led device is opened!
args: 4
user process the write issue:
led device is ready writing!
close
led device is released!
/module\_test # rmmod led.ko
set the led turning off...
set the led turning off done!
Ready to unmappings the registers...
unmappings the registers done
LED Device is unhooked!
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/456d7e3e3fd34b7eb6d5511ae0ac26eb.jpeg#pic\_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/00f72f0e85424a35b7c85c0e1d47fea7.jpeg#pic\_center)