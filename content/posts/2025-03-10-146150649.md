---
layout: post
title: "RabbitMQ-的工作模式"
date: 2025-03-10 12:29:17 +0800
description: "在这里，我们并不重点关注。"
keywords: "rabbitmq 设置channel模式"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['Java']
artid: "146150649"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146150649
    alt: "RabbitMQ-的工作模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146150649
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146150649
cover: https://bing.ee123.net/img/rand?artid=146150649
image: https://bing.ee123.net/img/rand?artid=146150649
img: https://bing.ee123.net/img/rand?artid=146150649
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ 的工作模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      目录
     </strong>
    </p>
    <p>
     <a href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" rel="nofollow">
      工作模式
     </a>
    </p>
    <p>
     <a href="#Simple%EF%BC%88%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">
      Simple（简单模式）
     </a>
    </p>
    <p>
     <a href="#Work%20Queue%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%89" rel="nofollow">
      Work Queue（工作队列）
     </a>
    </p>
    <p>
     <a href="#Publish%2FSubscribe%EF%BC%88%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%EF%BC%89" rel="nofollow">
      Publish/Subscribe（发布/订阅）
     </a>
    </p>
    <p>
     <a href="#Exchange%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89%C2%A0" rel="nofollow">
      Exchange（交换机）?
     </a>
    </p>
    <p>
     <a href="#Routing%EF%BC%88%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">
      Routing（路由模式）
     </a>
    </p>
    <p>
     <a href="#Topics%EF%BC%88%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">
      Topics（通配符模式）
     </a>
    </p>
    <p>
     <a href="#RPC%EF%BC%88RPC%E9%80%9A%E4%BF%A1%EF%BC%89" rel="nofollow">
      RPC（RPC通信）
     </a>
    </p>
    <p>
     <a href="#Publisher%20Confirms%EF%BC%88%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%EF%BC%89" rel="nofollow">
      Publisher Confirms（发布确认）
     </a>
    </p>
    <p>
     <a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">
      代码实现
     </a>
    </p>
    <p>
     <a href="#Simple%EF%BC%88%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">
      Simple（简单模式）
     </a>
    </p>
    <p>
     <a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      生产者代码
     </a>
    </p>
    <p>
     <a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      消费者代码
     </a>
    </p>
    <p>
     <a href="#Work%20Queues%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%89" rel="nofollow">
      Work Queues（工作队列）
     </a>
    </p>
    <p>
     <a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      生产者代码
     </a>
    </p>
    <p>
     <a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      消费者代码
     </a>
    </p>
    <p>
     <a href="#Publish%2FSubscribe%EF%BC%88%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%EF%BC%89" rel="nofollow">
      Publish/Subscribe（发布/订阅）
     </a>
    </p>
    <p>
     <a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      生产者代码
     </a>
    </p>
    <p>
     <a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      消费者代码
     </a>
    </p>
    <p>
     <a href="#Routing%EF%BC%88%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">
      Routing（路由模式）
     </a>
    </p>
    <p>
     <a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      生产者代码
     </a>
    </p>
    <p>
     <a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      消费者代码
     </a>
    </p>
    <p>
     <a href="#Topics%EF%BC%88%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">
      Topics（通配符模式）
     </a>
    </p>
    <p>
     <a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      生产者代码
     </a>
    </p>
    <p>
     <a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81" rel="nofollow">
      消费者代码
     </a>
    </p>
    <p>
     <a href="#RPC%EF%BC%88RPC%E9%80%9A%E4%BF%A1%EF%BC%89" rel="nofollow">
      RPC（RPC通信）
     </a>
    </p>
    <p>
     <a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81" rel="nofollow">
      客户端代码
     </a>
    </p>
    <p>
     <a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81" rel="nofollow">
      服务端代码
     </a>
    </p>
    <p>
     <a href="#Publisher%20Confirms%EF%BC%88%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%EF%BC%89" rel="nofollow">
      Publisher Confirms（发布确认）
     </a>
    </p>
    <p>
     <a href="#strategy-1-publishing-messages-individually" rel="nofollow">
      Publishing Messages Individually（单独确认）
     </a>
    </p>
    <p>
     <a href="#strategy-2-publishing-messages-in-batches" rel="nofollow">
      Publishing Messages in Batches（批量确认）
     </a>
    </p>
    <p>
     <a href="#strategy-3-handling-publisher-confirms-asynchronously" rel="nofollow">
      Handling Publisher Confirms Asynchronously（异步确认）
     </a>
    </p>
    <hr/>
    <p>
     <strong>
      RabbitMQ
     </strong>
     共提供了
     <strong>
      7
     </strong>
     种工作模式进行消息传递：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9bfc5b71d44340dfaabe1fca4f8b40f0.png"/>
    </p>
    <p>
     在本篇文章中，我们就来学习
     <strong>
      RabbitMQ 的工作模式
     </strong>
     ，我们首先来了解这 7 种工作模式分别是怎样的
    </p>
    <h3>
     <a id="_78">
     </a>
     工作模式
    </h3>
    <h4>
     <a id="Simple_81">
     </a>
     Simple（简单模式）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/be79dbcdfcbe4479b6438847843e3fb1.png"/>
    </p>
    <p>
     <strong>
      P
     </strong>
     表示
     <strong>
      生产者
     </strong>
     ，是消息的发送方
    </p>
    <p>
     <strong>
      C
     </strong>
     表示
     <strong>
      消费者
     </strong>
     ，是消息的接收者
    </p>
    <p>
     <strong>
      Queue
     </strong>
     ：表示
     <strong>
      消息队列
     </strong>
     ，用于
     <strong>
      缓存消息
     </strong>
     ，生产者生产的消息发送到队列中，消费者从队列中取出消息
    </p>
    <p>
     简单模式下，只有
     <strong>
      一个生产者和一个消费者
     </strong>
     ，生产者生产的消息存储到队列中后，都由这个消费者消费
    </p>
    <p>
     <strong>
      特点：一个生产者 P，一个消费者 C，消息只能被消费一次
     </strong>
     ，也称为 **点对点（Point-to-Point）**模式
    </p>
    <p>
     <strong>
      适用场景
     </strong>
     ：消息只能被单个消费者处理
    </p>
    <p>
     在 RabbitMQ 入门中的入门代码的工作模式就是简单模式
    </p>
    <h4>
     <a id="Work_Queue_99">
     </a>
     Work Queue（工作队列）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/1c53b198d050494d95d310a7fcf508c7.png"/>
    </p>
    <p>
     此时有
     <strong>
      一个生产者和多个消费者
     </strong>
    </p>
    <p>
     当生产者向队列中发送多条消息后，Work Queue 会将消息
     <strong>
      分配给不同的消费者
     </strong>
     ，每个消费者接收到的消息不同，由
     <strong>
      多个消费者共同消费生产者生产的消息
     </strong>
    </p>
    <p>
     例如：
    </p>
    <p>
     由 A （生产者）发送不同消息，消息存储到 RabbitMQ 中，接着，由 B（消费者1） 和 C（消费者2） 共同消息A 发送的消息，此时，RabbitMQ 选择将第一条消息分配给 B，B 消费第一条消息，RabbitMQ 将第二条消息分配给 C，C 消费第二条消息…
    </p>
    <p>
     B 和 C 接收到的消息是不同的，这两个消费者共同消费 A 发送的所有消息
    </p>
    <p>
     <strong>
      特点
     </strong>
     ：消息不会重复，分配给不同的消费者
    </p>
    <p>
     <strong>
      适用场景
     </strong>
     ：集群环境中实现异步处理
    </p>
    <h4>
     <a id="PublishSubscribe_117">
     </a>
     Publish/Subscribe（发布/订阅）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/cd8c6cb69f7542589a67f973ec870645.png"/>
    </p>
    <p>
     其中，X 表示的是
     <strong>
      交换机
     </strong>
     ，在 发布/订阅 模式中，多了
     <strong>
      Exchange
     </strong>
     角色，因此，我们先来学习交换机相关知识
    </p>
    <h5>
     <a id="Exchange_123">
     </a>
     Exchange（交换机）
    </h5>
    <p>
     <strong>
      Exchange（交换机）
      <strong>
       的作用是
      </strong>
      接收生产者发送的消息
     </strong>
     ，并将消息按照一定的规则
     <strong>
      路由到一个或多个队列中
     </strong>
    </p>
    <p>
     <strong>
      生产者的消息都会先发送到交换机
     </strong>
     ，然后再由交换机将消息路由到队列中
    </p>
    <p>
     在前面
     <strong>
      简单模式
     </strong>
     和
     <strong>
      工作队列模式
     </strong>
     下，图中都没有出现交换机，但实际上，
     <strong>
      生产者生产的消息都是先发送到交换机
     </strong>
     ，然后再路由到队列中的。在前两种模式下，直接使用 RabbitMQ 提供的内置交换机就可以实现，因此，并没有突出交换机的存在，但实际上
     <strong>
      生产者生产的消息不会直接投递到队列中
     </strong>
    </p>
    <p>
     在 RabbitMQ 中，交换机有
     <strong>
      4
     </strong>
     种类型：
     <strong>
      Fanout
     </strong>
     、
     <strong>
      Direct
     </strong>
     、
     <strong>
      Topic
     </strong>
     和
     <strong>
      Headers
     </strong>
     ，不同的类型有着不同的路由策略
    </p>
    <p>
     而
     <strong>
      AMQP
     </strong>
     协议中还有两种类型，
     <strong>
      System
     </strong>
     和
     <strong>
      自定义
     </strong>
     ，在这里，我们并不重点关注
    </p>
    <blockquote>
     <p>
      <strong>
       Fanout
      </strong>
      ：广播，将消息交给所有绑定到交换机的队列（
      <strong>
       Publish / Subscribe 模式
      </strong>
      ）
     </p>
     <p>
      <strong>
       Direct
      </strong>
      ：定向，将消息交给符合指定
      <strong>
       routing key
      </strong>
      的队列（
      <strong>
       Routing 模式
      </strong>
      ）
     </p>
     <p>
      <strong>
       Topic
      </strong>
      ：通配符，将消息交给符合
      <strong>
       routing patterm
      </strong>
      （路由模式）的队列（
      <strong>
       Topics 模式
      </strong>
      ）
     </p>
     <p>
      <strong>
       Headers
      </strong>
      ：Headers 类型的交换机通过
      <strong>
       消息头部的属性
      </strong>
      来路由消息，而
      <strong>
       不依赖路由键的匹配规则来路由消息
      </strong>
      。根据发送的消息内容中的 headers 属性进行匹配，headers 类型的交换机性能会较差，因此也不太实用，基本上也不会进行使用
     </p>
    </blockquote>
    <p>
     <strong>
      Exchange（交换机）
      <strong>
       只负责转发消息，并
      </strong>
      不具备存储消息的能力
     </strong>
     ，因此，若是没有任何队列与 Exchange 绑定，或是没有符合路由规则的队列，消息就会丢失
    </p>
    <p>
     接下来，我们来看
     <strong>
      RoutingKey
     </strong>
     和
     <strong>
      BindingKey
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       RoutingKey
      </strong>
      ：路由键，当生产者将消息发送给交换机时，会指定一个字符串，用于
      <strong>
       告诉交换机如何处理这个消息
      </strong>
     </p>
     <p>
      <strong>
       BindingKey
      </strong>
      ：绑定，RabbitMQ 中通过 Binding（绑定）
      <strong>
       将交换机与队列关联起来
      </strong>
      ，在绑定时会指定一个 Binding Key，这样 RabbitMQ 就知道
      <strong>
       如何正确地将消息路由到队列
      </strong>
      了
     </p>
    </blockquote>
    <p>
     即，
     <strong>
      绑定时，需要的路由键是 BindingKey；发送消息时，需要的路由键是 RoutingKey
     </strong>
    </p>
    <p>
     例如：
    </p>
    <p>
     使用
     <strong>
      BindingKey1
     </strong>
     将交换机与 队列1 进行绑定，使用
     <strong>
      BindingKey2
     </strong>
     将交换机与 队列2 进行绑定
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2cc90f16b4bb4ebea5ed33c86180048e.png"/>
    </p>
    <p>
     若在发送消息时，若设置
     <strong>
      Routing Key
     </strong>
     设置为
     <strong>
      BindingKey1
     </strong>
     ，交换机就会将消息路由到 队列1
    </p>
    <p>
     即，
     <strong>
      当消息的 RoutingKey 与队列绑定的 BindingKey 相匹配时，消息才会被路由到这个队列中
     </strong>
    </p>
    <p>
     其实，
     <strong>
      BindingKey 也属于路由键的一种
     </strong>
     ，即，
     <strong>
      在绑定时使用的路由键
     </strong>
     ，有时，也会使用 RoutingKey 表示 BindingKey，即使用 RoutingKey 表示 BindingKey 和 RoutingKey，因此，我们需要根据其使用场景进行区分
    </p>
    <p>
     在了解了相关概念之后，我们继续看
     <strong>
      Publish/ Subscribe
     </strong>
     模式
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f1e27634884e481998771c3d3f6d5f64.png"/>
    </p>
    <p>
     上述有一个生产者 P，多个消费者 C1、C2，X 表示交换机，交换机
     <strong>
      将消息复制多份
     </strong>
     ，
     <strong>
      每个消费者接收到相同的消息
     </strong>
    </p>
    <p>
     也就是说，生产者发送一条消息，经过交换机转发到不同的队列，不同的消费者从不同的队列中取出消息进行消费
    </p>
    <p>
     <strong>
      特点
     </strong>
     ：不同的消费者接收到的消息是相同的
    </p>
    <p>
     <strong>
      适用场景
     </strong>
     ：消息需要被多个消费者同时接收，如：实时通信或广播消息
    </p>
    <p>
     Publish/Subscribe（发布/订阅）模式 与Work Queue（工作队列）模式 最大的区别就是：
     <strong>
      发布/订阅
     </strong>
     模式下，
     <strong>
      不同消费者接收到的消息是相同的
     </strong>
     ；而
     <strong>
      工作队列
     </strong>
     模式下，
     <strong>
      不同消费者接收到的消息是不同的
     </strong>
    </p>
    <h4>
     <a id="Routing_179">
     </a>
     Routing（路由模式）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/434d6bde3bdc441b92987638e3d903de.png"/>
    </p>
    <p>
     路由模式可以看做是 发布订阅模式 的变种，其在发布订阅模式的基础上，增加了
     <strong>
      路由 key
     </strong>
    </p>
    <p>
     <strong>
      发布订阅模式会无条件的将所有消息发送给所有消费者
     </strong>
     ，而路由模式下，交换机会
     <strong>
      根据 RoutingKey 的规则
     </strong>
     ，将数据筛选后发送给对应的消费者队列
    </p>
    <p>
     也就是说，
     <strong>
      只有满足条件的队列才会收到消息
     </strong>
    </p>
    <p>
     如上图所示，Q1 通过 a 与交换机进行绑定，Q2 通过 a、b 和 c 与交换机进行绑定
    </p>
    <p>
     当 P （生产者）在发送消息时，若设置
     <strong>
      Routing Key
     </strong>
     设置为 a，则此时 Q1 和 Q2 的
     <strong>
      BindingKey
     </strong>
     都与其相匹配，消息就会被路由到 Q1 和 Q2 中
    </p>
    <p>
     而当 P 发送消息时，设置
     <strong>
      Routing Key
     </strong>
     设置为 b，此时，只有 Q2 的
     <strong>
      BindingKey
     </strong>
     与其相匹配，消息也就只会被路由到 Q2 中
    </p>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要根据特定规则分发消息
    </p>
    <h4>
     <a id="Topics_197">
     </a>
     Topics（通配符模式）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/67f1c2d2dfe746a398a6949c94b21681.png"/>
    </p>
    <p>
     <strong>
      通配符模式
     </strong>
     ，则是 路由模式 的变种，在
     <strong>
      RoutingKey
     </strong>
     的基础上，增加了
     <strong>
      通配符
     </strong>
     的功能，使得匹配更加灵活
    </p>
    <p>
     Topics 和 Routing 的基本原理相同，即：生产者将消息发送给交换机，交换机根据
     <strong>
      RoutingKey
     </strong>
     将消息转发给与
     <strong>
      RoutingKey
     </strong>
     匹配的队列
    </p>
    <p>
     而不同的是，
     <strong>
      Routing
     </strong>
     模式下，
     <strong>
      需要RoutingKey 和 BingingKey 完全匹配
     </strong>
     ；而
     <strong>
      Topics
     </strong>
     模式下，则是
     <strong>
      通配符匹配
     </strong>
    </p>
    <p>
     在 BindingKey 中，存在两种特殊的字符串，用于
     <strong>
      模糊匹配
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       *
      </strong>
      ：表示能够匹配任意一个单词
     </p>
     <p>
      <strong>
       #
      </strong>
      ：表示能够匹配任意多个单词（可以为 0 个）
     </p>
    </blockquote>
    <p>
     Q1 通过 *.a.* 与交换机进行绑定，Q2 通过 *.*.b 和 c.# 与交换机进行绑定
    </p>
    <p>
     当 P （生产者）在发送消息时，若设置 Routing Key 设置为 work.a.b，则此时 Q1 和 Q2 的BindingKey 都能够与其相匹配，消息就会被路由到 Q1 和 Q2 中
    </p>
    <p>
     而当 P 发送消息时，设置Routing Key 设置为 a.a.a，此时，只有 Q1的 BindingKey 与其相匹配，消息也就只会被路由到 Q1中
    </p>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要灵活匹配和过滤消息的场景
    </p>
    <h4>
     <a id="RPCRPC_221">
     </a>
     RPC（RPC通信）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/35c4d70441344ac29048e32e8bf02331.png"/>
    </p>
    <p>
     在
     <strong>
      RPC
     </strong>
     通信过程中，
     <strong>
      没有生产者和消费者
     </strong>
     ，而是
     <strong>
      通过两个队列实现了一个可回调的过程
     </strong>
    </p>
    <p>
     例如：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a9a520026e6f49099ec99bca661e2ed2.png"/>
    </p>
    <p>
     客户端（Client）发送请求消息到指定队列（rpc_queue），并在消息属性中设置
     <strong>
      reply_to
     </strong>
     字段，这个字段指定了一个
     <strong>
      回调队列
     </strong>
     （amq.gen-Xa2…），这个回调队列
     <strong>
      用于接收服务端的响应消息
     </strong>
    </p>
    <p>
     服务器（Server）从队列 rpc_queue 中取出请求消息，处理请求后，将响应消息发送到 reply_to 指定的回调队列（amq.gen-Xa2…）
    </p>
    <p>
     客户端（Client）在回调队列上等待响应消息，一旦接收到响应，
     <strong>
      客户端就会检查消息的 correlation_id 属性，确保其是所期望的响应
     </strong>
    </p>
    <p>
     简而言之，客户端将请求消息发送到 队列Q1 中，服务器从 Q1 中取出请求消息进行处理，然后将响应消息发送到 队列Q2 中，客户端从 Q2 中读取响应消息
    </p>
    <p>
     从而实现了
     <strong>
      客户端向服务器发送请求，服务器返回对应的响应
     </strong>
     的功能
    </p>
    <h4>
     <a id="Publisher_Confirms_241">
     </a>
     Publisher Confirms（发布确认）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/48b89d448a5e41558cb849333f87ebff.jpeg"/>
    </p>
    <p>
     <strong>
      Publisher Confirms
     </strong>
     模式是 RabbitMQ 提供的一种
     <strong>
      确保消息可靠发送到 RabbitMQ 服务器
     </strong>
     的机制，在这种模式下，生产者可以
     <strong>
      等待 RabbitMQ 服务器的确认，以确保消息已经被服务器接收并处理
     </strong>
    </p>
    <p>
     其过程为：
    </p>
    <p>
     （1）生产者将
     <strong>
      Channel
     </strong>
     设置为
     <strong>
      confirm
     </strong>
     模式（通过调用
     <strong>
      channel.confirmSelect()
     </strong>
     完成），发布的每一条消息都会获得一个
     <strong>
      唯一的 ID
     </strong>
     ，生产者可以将这些
     <strong>
      序列号与消息关联
     </strong>
     起来，以便追踪消息的状态
    </p>
    <p>
     （2）当消息被 RabbitMQ 服务器接收并处理后，服务器会
     <strong>
      异步
     </strong>
     地向生产者发送一个
     <strong>
      确认（ACK）
     </strong>
     ，其中包含消息的唯一 ID，表示消息已经送达
    </p>
    <p>
     通过
     <strong>
      Publisher Confirms
     </strong>
     模式，生产者可以确保消息被 RabbitMQ 服务器成功接收，从而避免消息丢失
    </p>
    <p>
     **适用场景：**对数据安全性要求较高，如金融交易，订单处理等
    </p>
    <p>
     在基本了解了 RabbitMQ 的 7 种工作模式后，我们就来通过代码简单实现一下这 7 种工作模式
    </p>
    <h3>
     <a id="_259">
     </a>
     代码实现
    </h3>
    <h4>
     <a id="Simple_262">
     </a>
     Simple（简单模式）
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7d3eb523d81a47e3904b827e5f6773f2.png"/>
    </p>
    <p>
     在
     <strong>
      简单模式
     </strong>
     下，只有
     <strong>
      一个生产者和一个消费者
     </strong>
     ，生产者生产的消息存储到队列后，都由这个消费者消费
    </p>
    <p>
     在
     <a href="https://blog.csdn.net/2301_76161469/article/details/143893863spm=1001.2014.3001.5501" title="RabbitMQ入门-CSDN博客">
      RabbitMQ入门-CSDN博客
     </a>
     中的入门代码的工作模式就是简单模式，因此，在这里就不再进行过多解释了
    </p>
    <p>
     <strong>
      首先引入依赖：
     </strong>
    </p>
    <pre><code>        &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.20.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
    <h5>
     <a id="_279">
     </a>
     <strong>
      生产者代码
     </strong>
    </h5>
    <pre><code>public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost("49.232.238.62"); // ip 的默认值为 localhost
        factory.setPort(5672); // 默认值为 5672
        factory.setVirtualHost("test01"); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername("admin"); // 用户名，默认为 guest
        factory.setPassword("123456"); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare("simple.test", true, false, false, null);
        // 6. 通过 channel 发送消息到队列中
        String message = "test...";
        channel.basicPublish("", "simple.test", null, message.getBytes());
        System.out.println("消息：" + message + " 发送成功");
        // 7. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <h5>
     <a id="_308">
     </a>
     <strong>
      消费者代码
     </strong>
    </h5>
    <pre><code>public class Consumer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost("49.232.238.62"); // ip 的默认值为 localhost
        factory.setPort(5672); // 默认值为 5672
        factory.setVirtualHost("test01"); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername("admin"); // 用户名，默认为 guest
        factory.setPassword("123456"); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare("simple.test", true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume("simple.test", true, consumer);
        // 7. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <h4>
     <a id="Work_Queues_342">
     </a>
     Work Queues（工作队列）
    </h4>
    <h5>
     <a id="_344">
     </a>
     生产者代码
    </h5>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e69375293d13416497504f50a372a631.png"/>
    </p>
    <p>
     工作队列模式下，由
     <strong>
      一个生产者生产消息，多个消费者共同接收消息
     </strong>
     ，消费者之间是竞争关系，每个消息只能被一个消费者接收
    </p>
    <p>
     由于我们每次连接时都要使用 IP、端口号、虚拟主机名等，因此，我们可以将它们提取出来，放到
     <strong>
      Constants
     </strong>
     类中：
    </p>
    <pre><code>public class Constants {
    public static final String HOST = "49.232.238.62";
    public static final int PORT = 5672;
    public static final String VIRTUAL_HOST = "test01";
    public static final String USER_NAME = "admin";
    public static final String USER_PASSWORD = "123456";
}
</code></pre>
    <p>
     声明 工作队列 模式下使用的队列：
    </p>
    <pre><code>    // 工作模式
    public static final String WORK_QUEUE = "work.queue";
</code></pre>
    <p>
     接下来，我们就来实现生产者的代码：
    </p>
    <p>
     工作队列模式与简单模式的区别在于工作模式下有多个消费者，因此生产者的消费代码与简单模式下差别不大，但在发送消息时，我们一次发送 20 条消息：
    </p>
    <pre><code>public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.WORK_QUEUE, true, false, false, null);
        // 6. 通过 channel 发送消息到队列中
        for (int i = 0; i &lt; 20; i++) {
            String message = "work test... " + i;
            channel.basicPublish("", Constants.WORK_QUEUE, null, message.getBytes());
        }
        System.out.println("消息发送成功!");
        // 7. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     运行代码，可以看到
     <strong>
      work.queue
     </strong>
     队列被创建，且存储了 20 条消息
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/60098464f8fe45f89c89fc5f2de2dfd8.png"/>
    </p>
    <p>
     接下来，我们继续编写消费者代码
    </p>
    <h5>
     <a id="_404">
     </a>
     消费者代码
    </h5>
    <p>
     消费者的代码也与简单模式下的代码差别不大，但在最后，我们并不进行资源的释放：
    </p>
    <p>
     <strong>
      Consumer1：
     </strong>
    </p>
    <pre><code>public class Consumer1 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.WORK_QUEUE, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.WORK_QUEUE, true, consumer);
    }
}
</code></pre>
    <p>
     <strong>
      Consumer2：
     </strong>
    </p>
    <pre><code>public class Consumer2 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.WORK_QUEUE, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.WORK_QUEUE, true, consumer);
    }
}
</code></pre>
    <p>
     启动 Consumer1 和 Consumer2：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/1f4bd222c7e547e6adea69e21abad817.png"/>
    </p>
    <p>
     由于我们之前先启动了生产者，此时再启动消费者，由于消息较少，因此，先启动的 Consumer1 会瞬间将 20 条消息消费掉
    </p>
    <p>
     因此，再次启动 Producer，观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/0cc863768a5a4b9f8b0472052333df99.png"/>
    </p>
    <p>
     可以看到两个消费者分别消费了 10 条消息
    </p>
    <h4>
     <a id="PublishSubscribe_482">
     </a>
     Publish/Subscribe（发布/订阅）
    </h4>
    <h5>
     <a id="_484">
     </a>
     生产者代码
    </h5>
    <p>
     在
     <strong>
      发布/订阅
     </strong>
     模式中，多了
     <strong>
      Exchange
     </strong>
     角色
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f1bc295a32264dd7a4ccc9532c589c48.png"/>
    </p>
    <p>
     <strong>
      Exchange
     </strong>
     常见有三种类型，分别代表不同的路由规则：
    </p>
    <blockquote>
     <p>
      <strong>
       Fanout
      </strong>
      ：广播，将消息交给所有绑定到交换机的队列（Publish/Subscribe 模式）
     </p>
     <p>
      <strong>
       Direct
      </strong>
      ：定向，将消息交给符合指定 RoutingKey 的队列（Routing 模式）
     </p>
     <p>
      <strong>
       Topics
      </strong>
      ：通配符，将消息交给符合 Routing Pattern（路由模式）的队列（Topics 模式）
     </p>
    </blockquote>
    <p>
     此时，在
     <strong>
      发布/订阅
     </strong>
     模式下，我们就需要
     <strong>
      声明交换机
     </strong>
     ，并
     <strong>
      绑定队列和交换机
     </strong>
    </p>
    <p>
     我们首先来看
     <strong>
      声明交换机
     </strong>
     ：
    </p>
    <p>
     使用
     <strong>
      channel.exchangeDeclare
     </strong>
     方法来创建交换机，我们来看
     <strong>
      exchangeDeclare
     </strong>
     方法：
    </p>
    <blockquote>
     <p>
      Exchange.DeclareOk exchangeDeclare(String exchange,
      <br/>
      BuiltinExchangeType type,
      <br/>
      boolean durable,
      <br/>
      boolean autoDelete,
      <br/>
      boolean internal,
      <br/>
      Map&lt;String, Object&gt; arguments) throws IOException;
     </p>
    </blockquote>
    <p>
     <strong>
      参数：
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       exchange
      </strong>
      ：交换机名称
     </p>
     <p>
      <strong>
       type
      </strong>
      ：交换机类型
     </p>
     <p>
      <strong>
       durable
      </strong>
      ：是否持久化，当为 true 时，会将交换机存盘，在服务器重启时不会丢失相关信息
     </p>
     <p>
      <strong>
       autoDelete
      </strong>
      ：是否自动删除，自动删除的前提是至少有一个队列或交换机与这个交换机绑定，之后与这个交换机绑定的队列或交换机都会与此解绑
     </p>
     <p>
      <strong>
       internal
      </strong>
      ：是否为内部使用，若设置为 true，则表示内部使用，客户端无法直接发送消息到这个交换机中，只能通过交换机路由到交换机这种方式
     </p>
     <p>
      <strong>
       arguments
      </strong>
      ：相关参数
     </p>
    </blockquote>
    <p>
     其中，
     <strong>
      type
     </strong>
     表示
     <strong>
      交换机类型
     </strong>
     ，其类型为
     <strong>
      BuiltinExchangeType
     </strong>
     ，也可以为
     <strong>
      String
     </strong>
     ：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/62fe3a74ed4146f7a9a1bf0b89ddbdf6.png"/>
    </p>
    <p>
     我们来看
     <strong>
      BuiltinExchangeType
     </strong>
     ，它是一个
     <strong>
      枚举类型
     </strong>
     ：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9b721ee5a0e34f6d86a6962808cbd80b.png"/>
    </p>
    <p>
     <strong>
      DIRECT(“direct”)
     </strong>
     ：定向，直连，将消息交给符合指定 RoutingKey 的队列（Routing 模式）
    </p>
    <p>
     <strong>
      FANOUT(“fanout”)
     </strong>
     ：扇形，广播，将消息交给所有绑定到交换机的队列（Publish/Subscribe 模式）
    </p>
    <p>
     <strong>
      TOPIC(“topic”)
     </strong>
     ：通配符，将消息交给符合 Routing Pattern（路由模式）的队列（Topics 模式）
    </p>
    <p>
     **HEADERS(“headers”)：**参数模式（较少使用）
    </p>
    <p>
     <strong>
      返回值：
     </strong>
    </p>
    <blockquote>
     <p>
      Exchange.DeclareOk：声明确认方法，用于指示已成功声明交换
     </p>
    </blockquote>
    <p>
     在
     <strong>
      Constants
     </strong>
     类中定义 发布/订阅 模式下使用的交换机和两个队列：
    </p>
    <pre><code>    // 广播模式
    public static final String PUBLISH_CHANGE = "fanout";
    public static final String PUBLISH_QUEUE_1 = "publish.queue.1";
    public static final String PUBLISH_QUEUE_2 = "publish.queue.2";
</code></pre>
    <p>
     建立连接，并声明交换机和两个队列：
    </p>
    <pre><code>public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明交换机
        channel.exchangeDeclare(Constants.PUBLISH_CHANGE, BuiltinExchangeType.FANOUT, true, false, false, null);
        // 6. 声明队列
        channel.queueDeclare(Constants.PUBLISH_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.PUBLISH_QUEUE_2, true, false, false, null);
    }
}
</code></pre>
    <p>
     交换机的类型为
     <strong>
      BuiltinExchangeType.FANOUT
     </strong>
     广播模式
    </p>
    <p>
     接着，我们使用
     <strong>
      channel.queueBind
     </strong>
     方法将队列和交换机进行绑定：
    </p>
    <blockquote>
     <p>
      Queue.BindOk queueBind(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments) throws IOException;
     </p>
    </blockquote>
    <p>
     <strong>
      queue
     </strong>
     ：要绑定的队列名称
    </p>
    <p>
     <strong>
      exchange
     </strong>
     ：要绑定的交换机名称
    </p>
    <p>
     <strong>
      routingKey
     </strong>
     ：路由 key，路由规则
    </p>
    <p>
     <strong>
      arguments
     </strong>
     ：相关参数
    </p>
    <p>
     在这里的
     <strong>
      routingKey
     </strong>
     ，其实就是
     <strong>
      BindingKey
     </strong>
     ，
     <strong>
      将交换机与队列关联起来
     </strong>
     ，从而让 RabbitMQ 知道如何正确地将消息路由到队列
    </p>
    <p>
     在发布/订阅模式下，交换机类型为
     <strong>
      fanout
     </strong>
     ，
     <strong>
      routingKey
     </strong>
     设置为
     <strong>
      “”
     </strong>
     ，表示
     <strong>
      每个消费者都可以收到全部信息
     </strong>
    </p>
    <pre><code>        // 7. 绑定交换机和队列
        channel.queueBind(Constants.PUBLISH_QUEUE_1, Constants.PUBLISH_CHANGE, "", null);
        channel.queueBind(Constants.PUBLISH_QUEUE_2, Constants.PUBLISH_CHANGE, "", null);
</code></pre>
    <p>
     接下来，就可以发送消息了：
    </p>
    <pre><code>        // 8. 发送消息
        for (int i = 0; i &lt; 20; i++) {
            String message = "work test... " + i;
            channel.basicPublish(Constants.PUBLISH_CHANGE, "", null, message.getBytes());
        }
        System.out.println("消息发送成功!");
        // 9. 释放资源
        channel.close();
        connection.close();
</code></pre>
    <p>
     完整代码：
    </p>
    <pre><code>public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明交换机
        channel.exchangeDeclare(Constants.PUBLISH_CHANGE, BuiltinExchangeType.FANOUT, true, false, false, null);
        // 6. 声明队列
        channel.queueDeclare(Constants.PUBLISH_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.PUBLISH_QUEUE_2, true, false, false, null);
        // 7. 绑定交换机和队列
        channel.queueBind(Constants.PUBLISH_QUEUE_1, Constants.PUBLISH_CHANGE, "", null);
        channel.queueBind(Constants.PUBLISH_QUEUE_2, Constants.PUBLISH_CHANGE, "", null);
        // 8. 发送消息
        for (int i = 0; i &lt; 20; i++) {
            String message = "work test... " + i;
            channel.basicPublish(Constants.PUBLISH_CHANGE, "", null, message.getBytes());
        }
        System.out.println("消息发送成功!");
        // 9. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     运行代码，并观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e7a93cd0599d4f4fb1181ff761f605fa.png"/>
    </p>
    <p>
     可以看到，publish.queue.1 和 publish.queue.2 中都已经存储了 20 条消息
    </p>
    <p>
     查看 fanout 的绑定关系：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/447c81c3c8664eea9b0172ff9517da0f.png"/>
    </p>
    <p>
     成功绑定publish.queue.1 和 publish.queue.2：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/dc621518eade4f3b9937293adef478d8.png"/>
    </p>
    <p>
     接下来，我们继续编写消费者代码
    </p>
    <h5>
     <a id="_664">
     </a>
     消费者代码
    </h5>
    <p>
     交换机和队列的绑定关系已经在生产者中实现了，因此，消费者代码中可以不必再写
    </p>
    <p>
     其实现与 工作队列模式 下是基本相同的，只需要修改读取的队列即可
    </p>
    <p>
     <strong>
      Consumer1：
     </strong>
    </p>
    <pre><code>public class Consumer1 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.PUBLISH_QUEUE_1, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.PUBLISH_QUEUE_1, true, consumer);
    }
}
</code></pre>
    <p>
     <strong>
      Consumer2：
     </strong>
    </p>
    <pre><code>public class Consumer2 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.PUBLISH_QUEUE_2, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.PUBLISH_QUEUE_2, true, consumer);
    }
}
</code></pre>
    <p>
     运行 Consumer1 和 Consumer2：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/bb6eebd8a37647f599e7ba5e4a911af7.png"/>
    </p>
    <p>
     Consumer1 和 Consumer2 都接收到了这 20 条消息
    </p>
    <h4>
     <a id="Routing_738">
     </a>
     Routing（路由模式）
    </h4>
    <h5>
     <a id="_740">
     </a>
     生产者代码
    </h5>
    <p>
     <strong>
      Routing
     </strong>
     模式下，队列与交换机之间的绑定，不再是任意的绑定了，而是需要指定一个
     <strong>
      BindingKey
     </strong>
    </p>
    <p>
     生产者在向 交换机 发送消息时，也需要指定消息的
     <strong>
      RoutingKey
     </strong>
    </p>
    <p>
     交换机不会将消息发送给每一个绑定的 key，而是会根据消息的 RoutingKey 进行判断，只有
     <strong>
      队列绑定时的 BindingKey 和发送消息的 RoutingKey 完全一致时
     </strong>
     ，才会接收消息
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9e5efc1f7b454b56a8fa7a7aed91346f.png"/>
    </p>
    <p>
     先在
     <strong>
      Constants
     </strong>
     类中定义 路由模式下使用的交换机和队列：
    </p>
    <pre><code>    // 路由模式
    public static final String ROUTING_CHANGE = "routing";
    public static final String ROUTINT_QUEUE_1 = "routing.queue.1";
    public static final String ROUTINT_QUEUE_2 = "routing.queue.2";
</code></pre>
    <p>
     路由模式下，生产者的代码与 发布/订阅模式 下的区别在于：
     <strong>
      交换机的类型不同
     </strong>
     以及
     <strong>
      绑定队列的 BindKey 不同
     </strong>
    </p>
    <p>
     <strong>
      （1）交换机类型不同
     </strong>
    </p>
    <p>
     在声明交换机时，交换机的类型为
     <strong>
      BuiltinExchangeType.DIRECT
     </strong>
    </p>
    <pre><code>        // 5. 声明交换机
        channel.exchangeDeclare(Constants.ROUTING_CHANGE, BuiltinExchangeType.DIRECT, true, false, false, null);
</code></pre>
    <p>
     <strong>
      （2）声明队列
     </strong>
    </p>
    <pre><code>        // 6. 声明队列
        channel.queueDeclare(Constants.ROUTINT_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.ROUTINT_QUEUE_2, true, false, false, null);
</code></pre>
    <p>
     <strong>
      （3）交换机与队列的绑定方式不同
     </strong>
    </p>
    <pre><code>        // 7. 绑定交换机和队列
        channel.queueBind(Constants.ROUTINT_QUEUE_1, Constants.ROUTING_CHANGE, "a", null);
        channel.queueBind(Constants.ROUTINT_QUEUE_2, Constants.ROUTING_CHANGE, "a", null);
        channel.queueBind(Constants.ROUTINT_QUEUE_2, Constants.ROUTING_CHANGE, "b", null);
        channel.queueBind(Constants.ROUTINT_QUEUE_2, Constants.ROUTING_CHANGE, "c", null);
</code></pre>
    <p>
     此时，我们就可以发送消息了
    </p>
    <p>
     在发送消息时，需要指定
     <strong>
      RoutingKey
     </strong>
     ：
    </p>
    <pre><code>        // 8. 发送消息
        String messageA = "test a...";
        channel.basicPublish(Constants.ROUTING_CHANGE, "a", null, messageA.getBytes());
        String messageB = "test b...";
        channel.basicPublish(Constants.ROUTING_CHANGE, "b", null, messageB.getBytes());
        String messageC = "test c... ";
        channel.basicPublish(Constants.ROUTING_CHANGE, "c", null, messageB.getBytes());
        System.out.println("消息发送成功!");
</code></pre>
    <p>
     完整代码：
    </p>
    <pre><code>public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明交换机
        channel.exchangeDeclare(Constants.ROUTING_CHANGE, BuiltinExchangeType.DIRECT, true, false, false, null);
        // 6. 声明队列
        channel.queueDeclare(Constants.ROUTINT_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.ROUTINT_QUEUE_2, true, false, false, null);
        // 7. 绑定交换机和队列
        channel.queueBind(Constants.ROUTINT_QUEUE_1, Constants.ROUTING_CHANGE, "a", null);
        channel.queueBind(Constants.ROUTINT_QUEUE_2, Constants.ROUTING_CHANGE, "a", null);
        channel.queueBind(Constants.ROUTINT_QUEUE_2, Constants.ROUTING_CHANGE, "b", null);
        channel.queueBind(Constants.ROUTINT_QUEUE_2, Constants.ROUTING_CHANGE, "c", null);
        // 8. 发送消息
        String messageA = "test a...";
        channel.basicPublish(Constants.ROUTING_CHANGE, "a", null, messageA.getBytes());
        String messageB = "test b...";
        channel.basicPublish(Constants.ROUTING_CHANGE, "b", null, messageB.getBytes());
        String messageC = "test c... ";
        channel.basicPublish(Constants.ROUTING_CHANGE, "c", null, messageB.getBytes());
        System.out.println("消息发送成功!");
        // 9. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     运行代码，并观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f08668161bd04bc0903651550764f004.png"/>
    </p>
    <p>
     routing.queue.1 中有 1 条消息，routing.queue.2 中有两条消息
    </p>
    <p>
     查看 routing 交换机与 队列的绑定关系：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/cef0c1f4c59c4109b7ec7639314ced0e.png"/>
    </p>
    <p>
     接下来，我们继续编写消费者的代码
    </p>
    <h5>
     <a id="_846">
     </a>
     消费者代码
    </h5>
    <p>
     消费者代码与 发布/订阅 模式下基本相同，只需要修改队列名称即可：
    </p>
    <p>
     <strong>
      Consumer1：
     </strong>
    </p>
    <pre><code>public class Consumer1 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.ROUTINT_QUEUE_1, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("Consumer1 成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.ROUTINT_QUEUE_1, true, consumer);
    }
}
</code></pre>
    <p>
     <strong>
      Consumer2：
     </strong>
    </p>
    <pre><code>public class Consumer2 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.ROUTINT_QUEUE_2, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("Consumer2 成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.ROUTINT_QUEUE_2, true, consumer);
    }
}
</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2ff9824149b4443fbccd984f116af611.png"/>
    </p>
    <h4>
     <a id="Topics_917">
     </a>
     Topics（通配符模式）
    </h4>
    <h5>
     <a id="_919">
     </a>
     生产者代码
    </h5>
    <p>
     相比于 routing 模式，topics 类型的交换机在匹配规则上进行了扩展，BindingKey 支持
     <strong>
      通配符匹配
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ac79af7ef2994406947804f40316f446.png"/>
    </p>
    <p>
     其中，RoutingKey 是一系列由
     <strong>
      .
     </strong>
     分割的单词，如 user.name、work.abc等
    </p>
    <p>
     BindingKey 也和 RoutingKey 一样，由 . 分割的字符串
    </p>
    <p>
     在 BindingKey 中可以存在两种特殊的字符串，用于模糊匹配：
    </p>
    <blockquote>
     <p>
      <strong>
       *
      </strong>
      ：表示能够匹配任意一个单词
     </p>
     <p>
      <strong>
       #
      </strong>
      ：表示能够匹配任意多个单词（可以为 0 个）
     </p>
    </blockquote>
    <p>
     例如：
    </p>
    <blockquote>
     <p>
      交换机 与 队列1（Q1）的 BindingKey 为 *.a.*
     </p>
     <p>
      交换机 与 队列2（Q2）的 BindingKey 为 *.*.b
     </p>
     <p>
      交换机 与 队列2（Q2）的 BindingKey 为 c.#
     </p>
    </blockquote>
    <p>
     则：
    </p>
    <blockquote>
     <p>
      若生产者的 RoutingKey 为 work.a.b，则消息会被路由到 Q1 和 Q2
     </p>
     <p>
      若生产者的 RoutingKey 为 a.a.a，则消息会被路由到 Q1
     </p>
     <p>
      若生产者的 RoutingKey 为 c.work.a，则消息会被路由到 Q2
     </p>
     <p>
      若生产者的 RoutingKey 为 b.c.g，则消息会被丢弃，或是返回给生产者（需要设置 mandatory 参数）
     </p>
    </blockquote>
    <p>
     接下来，我们就来实现 通配符模式下 的生产者：
    </p>
    <p>
     先在 Constants 类中定义通配符模式下使用的交换机和队列：
    </p>
    <pre><code>    // 通配符模式
    public static final String TOPICS_CHANGE = "topics";
    public static final String TOPICS_QUEUE_1 = "topics.queue.1";
    public static final String TOPICS_QUEUE_2 = "topics.queue.2";
</code></pre>
    <p>
     与 路由模式相比，发布订阅模式与其区别为：
     <strong>
      交换机类型不同
     </strong>
     以及
     <strong>
      绑定队列的 RoutingKey 不同
     </strong>
    </p>
    <p>
     <strong>
      （1）交换机类型不同
     </strong>
    </p>
    <p>
     交换机的类型为
     <strong>
      BuiltinExchangeType.TOPIC
     </strong>
    </p>
    <pre><code>        // 5. 声明交换机
        channel.exchangeDeclare(Constants.TOPICS_CHANGE, BuiltinExchangeType.TOPIC, true, false, false, null);
</code></pre>
    <p>
     <strong>
      （2）声明队列
     </strong>
    </p>
    <pre><code>        // 6. 声明队列
        channel.queueDeclare(Constants.TOPICS_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.TOPICS_QUEUE_2, true, false, false, null);
</code></pre>
    <p>
     <strong>
      （3）交换机与队列的绑定方式不同
     </strong>
    </p>
    <pre><code>        // 7. 绑定交换机和队列
        channel.queueBind(Constants.TOPICS_QUEUE_1, Constants.TOPICS_CHANGE, "*.a.*", null);
        channel.queueBind(Constants.TOPICS_QUEUE_2, Constants.TOPICS_CHANGE, "*.*.b", null);
        channel.queueBind(Constants.TOPICS_QUEUE_2, Constants.TOPICS_CHANGE, "c.#", null);
</code></pre>
    <p>
     此时，我们就可以发送消息了
    </p>
    <p>
     在发送消息时，需要指定
     <strong>
      RoutingKey
     </strong>
     ：
    </p>
    <pre><code>        // 8. 发送消息
        String message1 = "test work.a.b";
        channel.basicPublish(Constants.TOPICS_CHANGE, "work.a.b", null, message1.getBytes());
        String message2 = "test a.a.a";
        channel.basicPublish(Constants.TOPICS_CHANGE, "a.a.a", null, message2.getBytes());
        String message3 = "test c.work.a";
        channel.basicPublish(Constants.TOPICS_CHANGE, "c.work.a", null, message3.getBytes());
        System.out.println("消息发送成功!");
</code></pre>
    <p>
     <strong>
      完整代码：
     </strong>
    </p>
    <pre><code>public class Producer {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明交换机
        channel.exchangeDeclare(Constants.TOPICS_CHANGE, BuiltinExchangeType.TOPIC, true, false, false, null);
        // 6. 声明队列
        channel.queueDeclare(Constants.TOPICS_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.TOPICS_QUEUE_2, true, false, false, null);
        // 7. 绑定交换机和队列
        channel.queueBind(Constants.TOPICS_QUEUE_1, Constants.TOPICS_CHANGE, "*.a.*", null);
        channel.queueBind(Constants.TOPICS_QUEUE_2, Constants.TOPICS_CHANGE, "*.*.b", null);
        channel.queueBind(Constants.TOPICS_QUEUE_2, Constants.TOPICS_CHANGE, "c.#", null);
        // 8. 发送消息
        String message1 = "test work.a.b";
        channel.basicPublish(Constants.TOPICS_CHANGE, "work.a.b", null, message1.getBytes());
        String message2 = "test a.a.a";
        channel.basicPublish(Constants.TOPICS_CHANGE, "a.a.a", null, message2.getBytes());
        String message3 = "test c.work.a";
        channel.basicPublish(Constants.TOPICS_CHANGE, "c.work.a", null, message3.getBytes());
        System.out.println("消息发送成功!");
        // 9. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     运行并观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7621c45959d2494288535330f1059d61.png"/>
    </p>
    <p>
     topics.queue.1 和 topics.queue.2 中都已经存储了两条消息
    </p>
    <p>
     我们来看topics.queue.1 中的消息：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/8a49a8fe2590412fbac1b7bc17a18be4.png"/>
    </p>
    <p>
     我们继续实现消费者代码
    </p>
    <h5>
     <a id="_1051">
     </a>
     消费者代码
    </h5>
    <p>
     Topics 模式的消费者代码与 Routing 模式下相同，只需要修改消费的队列名称即可：
    </p>
    <p>
     <strong>
      Consumer1：
     </strong>
    </p>
    <pre><code>public class Consumer1 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.TOPICS_QUEUE_1, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("Consumer1 成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.TOPICS_QUEUE_1, true, consumer);
    }
}
</code></pre>
    <p>
     <strong>
      Consumer2：
     </strong>
    </p>
    <pre><code>public class Consumer2 {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 5. 声明队列
        channel.queueDeclare(Constants.TOPICS_QUEUE_2, true, false, false, null);
        // 6. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            // 回调方法，当接收到消息后，自动执行该方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("Consumer1 成功接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.TOPICS_QUEUE_2, true, consumer);
    }
}
</code></pre>
    <p>
     运行 Consumer1 和 Consumer2，并观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/006b2119290d47d4954a6330f62c472e.png"/>
    </p>
    <h4>
     <a id="RPCRPC_1121">
     </a>
     RPC（RPC通信）
    </h4>
    <p>
     <strong>
      RPC（Remote Procedure Call）
     </strong>
     ，远程过程调用，是一种通过网络从远程计算机上请求服务，不需要了解底层网络的技术，类似于 Http 远程调用
    </p>
    <p>
     RabbitMQ 实现 RPC 通信，是通过
     <strong>
      两个队列
     </strong>
     实现一个
     <strong>
      可回调
     </strong>
     的过程：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3c0259c21e5d470681d3c9c1b294e38b.png"/>
    </p>
    <p>
     其过程为：
    </p>
    <p>
     客户端（Client）发送请求消息到指定队列（rpc_queue），并在消息属性中设置
     <strong>
      reply_to
     </strong>
     字段，这个字段指定了一个
     <strong>
      回调队列
     </strong>
     （amq.gen-Xa2…），这个回调队列
     <strong>
      用于接收服务端的响应消息
     </strong>
    </p>
    <p>
     服务器（Server）从队列 rpc_queue 中取出请求消息，处理请求后，将响应消息发送到 reply_to 指定的回调队列（amq.gen-Xa2…）
    </p>
    <p>
     客户端（Client）在回调队列上等待响应消息，一旦接收到响应，客户端就会检查消息的
     <strong>
      correlation_id
     </strong>
     属性，确保其是否是所期望的响应
    </p>
    <p>
     接下来，我们就来实现 RPC 的客户端：
    </p>
    <h5>
     <a id="_1139">
     </a>
     客户端代码
    </h5>
    <p>
     客户端主要实现的功能有：
    </p>
    <blockquote>
     <p>
      1. 发送请求消息到队列中
     </p>
     <p>
      2. 从回调队列中读取响应消息
     </p>
    </blockquote>
    <p>
     我们先来看发送请求消息到队列的过程：
    </p>
    <blockquote>
     <p>
      （1）声明两个队列：消息发送到的队列（Queue） 和 回调队列（replayQueue），并声明本次请求的唯一标志
      <strong>
       corrId
      </strong>
     </p>
     <p>
      （2）将 replayQueue 和 corrId 配置到 Queue 中
     </p>
    </blockquote>
    <p>
     接下来，需要从回调队列中读取响应消息，若我们直接从回调队列中读取响应消息，此时，可能服务端还没有处理完请求，也就未将响应消息发送到回调队列中，就读取不到响应
    </p>
    <p>
     因此，我们可以使用
     <strong>
      阻塞队列
     </strong>
     来监听回调队列中的消息
    </p>
    <blockquote>
     <p>
      1. 使用阻塞队列阻塞当前进程，监听回调队列中的消息，回调队列中有消息时，将响应消息放到阻塞队列中
     </p>
     <p>
      2. 阻塞队列中有消息后，主线程被唤醒，处理返回内容
     </p>
    </blockquote>
    <p>
     先在
     <strong>
      Constants
     </strong>
     类中声明 RPC 模式下使用的两个队列：
    </p>
    <pre><code>    // RPC 模式
    public static final String RPC_QUEUE_1 = "rpc.queue1";
    public static final String RPC_QUEUE_2 = "rpc.queue2";
</code></pre>
    <p>
     在这里，我们就不再声明交换机了，直接使用默认的交换机
    </p>
    <p>
     声明 消息发送的队列 和 回调队列：
    </p>
    <pre><code>        // 声明队列
        channel.queueDeclare(Constants.RPC_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.RPC_QUEUE_2, true, false, false, null);
</code></pre>
    <p>
     使用
     <strong>
      UUID
     </strong>
     生成本次请求的唯一标志，并配置消息属性：
    </p>
    <pre><code>        // 本次请求的唯一标识
        String corrId = UUID.randomUUID().toString();
</code></pre>
    <p>
     消息相关配置的类型为
     <strong>
      BasicProperties
     </strong>
     ，位于
     <strong>
      com.rabbitmq.client.AMQP
     </strong>
     下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a1752949d9f946e3b167c044e5fff6ca.png"/>
    </p>
    <p>
     <strong>
      AMQP.BasicProperties
     </strong>
     提供了一个
     <strong>
      构造器
     </strong>
     ，可以通过
     <strong>
      builder()
     </strong>
     来设置一些属性：
    </p>
    <p>
     使用
     <strong>
      correlationId
     </strong>
     方法设置唯一标识，
     <strong>
      replyTo
     </strong>
     方法设置回调队列：
    </p>
    <pre><code>        // 本次请求的唯一标识
        String corrId = UUID.randomUUID().toString();
        // 消息属性
        AMQP.BasicProperties basicProperties = new AMQP.BasicProperties()
                .builder()
                .correlationId(corrId) // 唯一ID
                .replyTo(Constants.RPC_QUEUE_2) // 回调队列
                .build();
</code></pre>
    <p>
     最后调用
     <strong>
      build
     </strong>
     方法创建实例
    </p>
    <p>
     使用内置交换机发送消息：
    </p>
    <pre><code>        // 7. 发送消息
        String message = "test rpc...";
        channel.basicPublish("", Constants.RPC_QUEUE_1, basicProperties, message.getBytes());
</code></pre>
    <p>
     接着，使用阻塞队列存储回调结果：
    </p>
    <pre><code>        // 阻塞队列，存放回调结果，一次获取一条消息
        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
</code></pre>
    <p>
     从回调队列中接收响应消息：
    </p>
    <pre><code>        // 8. 接收服务器的响应
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到回调消息: " + new String(body));
                // 判断标识是否正确
                if(corrId.equals(properties.getCorrelationId())) {
                    queue.offer(new String(body, "UTF-8"));
                }
            }
        };
        channel.basicConsume(Constants.RPC_QUEUE_2, true, consumer);
</code></pre>
    <p>
     最后，从阻塞队列中获取响应消息：
    </p>
    <pre><code>        // 9. 获取响应消息
        String result = queue.take();
        System.out.println("result: " + result);
</code></pre>
    <p>
     完整代码：
    </p>
    <pre><code>public class Client {
    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException, IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 使用默认的交换机
        // 5. 声明队列
        channel.queueDeclare(Constants.RPC_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.RPC_QUEUE_2, true, false, false, null);
        // 6. 设置消息属性
        // 本次请求的唯一标识
        String corrId = UUID.randomUUID().toString();
        // 消息属性
        AMQP.BasicProperties basicProperties = new AMQP.BasicProperties()
                .builder()
                .correlationId(corrId) // 唯一ID
                .replyTo(Constants.RPC_QUEUE_2) // 回调队列
                .build();
        // 7. 发送消息
        String message = "test rpc...";
        channel.basicPublish("", Constants.RPC_QUEUE_1, basicProperties, message.getBytes());
        // 阻塞队列，存放回调结果，一次获取一条消息
        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
        // 8. 接收服务器的响应
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到回调消息: " + new String(body));
                // 判断标识是否正确
                if(corrId.equals(properties.getCorrelationId())) {
                    queue.offer(new String(body, "UTF-8"));
                }
            }
        };
        channel.basicConsume(Constants.RPC_QUEUE_2, true, consumer);
        // 9. 获取响应消息
        String result = queue.take();
        System.out.println("result: " + result);
    }
}
</code></pre>
    <p>
     我们继续编写服务端代码
    </p>
    <h5>
     <a id="_1286">
     </a>
     服务端代码
    </h5>
    <p>
     服务端要实现的功能为：
    </p>
    <blockquote>
     <p>
      1. 从队列中接收请求消息
     </p>
     <p>
      2. 根据消息内容处理请求消息，并将响应消息返回到回调队列中
     </p>
    </blockquote>
    <p>
     我们先来实现接收消息：
    </p>
    <p>
     建立连接、声明队列等过程都与 客户端代码相同
    </p>
    <p>
     但需要注意的是，我们需要
     <strong>
      设置服务端同时最多只能获取一条消息
     </strong>
     ：
    </p>
    <pre><code>        // 6. 设置同时最多只能获取一条消息
        channel.basicQos(1);
</code></pre>
    <p>
     若不设置
     <strong>
      basicQos
     </strong>
     ，RabbitMQ 会使用默认的 Qos 设置，其 prefetchCount 默认值为 0，当prefetchCount 为 0 时，RabbitMQ 会根据内部实现和当前网络状况等因素，可能同时发送多条消息给消费者。这也就意味着，在默认情况下，消费者可能会同时接收到多条消息，但具体数量不是严格保证的，可能会有波动
    </p>
    <p>
     而在 RPC 模式下，通常希望是
     <strong>
      一对一的消息处理
     </strong>
     ，即，一个请求对应一个响应。服务端在处理完一个消息并确认后，才会接收到下一条消息
    </p>
    <p>
     接收消息后，就可以对请求消息进行处理并返回响应结果了：
    </p>
    <pre><code>        // 7. 接收消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 将消息发到队列2中
                AMQP.BasicProperties replayProperties = new AMQP.BasicProperties().
                        builder().
                        correlationId(properties.getCorrelationId()).
                        build();
                // 返回
                String message = new String(body);
                System.out.println("接收到消息: " + message);
                // 响应消息
                String response = "request: " + message + " 接收成功";
                channel.basicPublish("", properties.getReplyTo(), replayProperties, response.getBytes());
                // 对消息进行应答
                channel.basicAck(envelope.getDeliveryTag(), false);
            }
        };
        channel.basicConsume(Constants.RPC_QUEUE_1, false, consumer);
</code></pre>
    <p>
     需要注意的是，在这里我们需要
     <strong>
      手动对消息进行应答
     </strong>
     ，而不是自动确认：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/386f5d27cdd54a7caa7d055655d1382f.png"/>
    </p>
    <p>
     在 RabbitMQ 中，
     <strong>
      basicConsume
     </strong>
     方法的
     <strong>
      autoAck
     </strong>
     参数用于指定消费者是否会自动向消息队列确认消息
    </p>
    <p>
     当设置为
     <strong>
      true
     </strong>
     时，消息队列会在将消息发送给消费者后，认为消息已经被成功消费，立即删除该条消息，这也就意味着，若消费者处理消息失败，消息就会丢失
    </p>
    <p>
     当设置为
     <strong>
      false
     </strong>
     时，消息队列在将消息发送给消费者后，需要消费者显示地调用 basicAck 方式来确认消息，手动确认提供了更高的可靠性，保证消息不会被意外丢失，适用于消息处理重要且需要确保每个消息被正确处理的场景
    </p>
    <p>
     <strong>
      完整代码：
     </strong>
    </p>
    <pre><code>public class Service {
    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        // 4. 创建 Channel
        Channel channel = connection.createChannel();
        // 使用默认的交换机
        // 5. 声明队列
        channel.queueDeclare(Constants.RPC_QUEUE_1, true, false, false, null);
        channel.queueDeclare(Constants.RPC_QUEUE_2, true, false, false, null);
        // 6. 设置同时最多只能获取一条消息
        channel.basicQos(1);
        // 7. 接收消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                // 将消息发到队列2中
                AMQP.BasicProperties replayProperties = new AMQP.BasicProperties().
                        builder().
                        correlationId(properties.getCorrelationId()).
                        build();
                // 返回
                String message = new String(body);
                System.out.println("接收到消息: " + message);
                // 响应消息
                String response = "request: " + message + " 接收成功";
                channel.basicPublish("", properties.getReplyTo(), replayProperties, response.getBytes());
                // 对消息进行应答
                channel.basicAck(envelope.getDeliveryTag(), false);
            }
        };
        channel.basicConsume(Constants.RPC_QUEUE_1, false, consumer);
    }
}
</code></pre>
    <p>
     运行代码，观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/dda405fa2f194c8290be80e7dc32b940.png"/>
    </p>
    <h4>
     <a id="Publisher_Confirms_1390">
     </a>
     Publisher Confirms（发布确认）
    </h4>
    <p>
     消息中间件，都会面临
     <strong>
      消息丢失
     </strong>
     的问题
    </p>
    <p>
     消息丢失大概分为三种情况：
    </p>
    <blockquote>
     <p>
      1.
      <strong>
       生产者的问题
      </strong>
      ：由于应用程序故障、网络抖动等各种原因，生产者没有成功向 broker 发送消息
     </p>
     <p>
      2.
      <strong>
       消息中间件的问题
      </strong>
      ：生产者成功将消息发送给了 broker，但 broker 未能将消息保存好，导致消息丢失
     </p>
     <p>
      3.
      <strong>
       消费者的问题
      </strong>
      ：broker 将消息发送给了消费者，消费者在消费消息时，未处理好，导致 broker 将消费失败的消息从队列中删除了
     </p>
    </blockquote>
    <p>
     Rabbit 针对上述问题给出了相应的解决方案：
    </p>
    <blockquote>
     <p>
      针对问题1，可以采用**发布确认（Publisher Confirms）**机制实现
     </p>
     <p>
      针对问题2，可以通过
      <strong>
       持久化
      </strong>
      机制
     </p>
     <p>
      针对问题3，可以采用
      <strong>
       消息应答
      </strong>
      机制
     </p>
    </blockquote>
    <p>
     接下来，我们就来进一步学习
     <strong>
      发布确认机制
     </strong>
    </p>
    <p>
     发布确认的过程：
    </p>
    <p>
     （1）生产者将
     <strong>
      Channel
     </strong>
     设置为
     <strong>
      confirm
     </strong>
     模式（通过调用 channel.confirmSelect() 完成），发布的每一条消息都会获得一个唯一的 ID，生产者可以将这些序列号与消息关联起来，以便追踪消息的状态
    </p>
    <p>
     （2）当消息被 RabbitMQ 服务器接收并处理后，服务器会向生产者发送一个
     <strong>
      确认（ACK）
     </strong>
     ，其中包含消息的唯一 ID，表示消息已经送达
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/407c6a8e165c4151acdd60931ee4cefa.jpeg"/>
    </p>
    <p>
     其中，
     <strong>
      deliveryTag
     </strong>
     包含了确认消息的序号，此外，broker 也可以设置
     <strong>
      channel.basicAck
     </strong>
     方法中的
     <strong>
      multiple
     </strong>
     参数，表示
     <strong>
      这个序号之前的所有消息都已经被处理
     </strong>
    </p>
    <p>
     发送确认机制最大的好处在于它是
     <strong>
      异步
     </strong>
     的，生产者可以
     <strong>
      同时发布消息和等待信道返回确认消息
     </strong>
    </p>
    <p>
     当消息最终得到确认之后，生产者可以通过
     <strong>
      回调方法
     </strong>
     来处理该确认消息
    </p>
    <p>
     若 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 **nack（Basic.Nack）**命令，生产者同样可以在回调方法中处理该 nack 命令
    </p>
    <p>
     使用发布确认机制，需要将信道设置为 **confirm（确认）**模式：
    </p>
    <pre><code>            // 开启信道
            Channel channel = connection.createChannel();
            // 开启信道确认模式
            channel.confirmSelect();
</code></pre>
    <p>
     发布模式有
     <strong>
      3 种确认策略
     </strong>
     ，我们分别来进行学习
    </p>
    <p>
     由于使用每种策略时都需要建立连接，因此，我们将建立连接抽取出来：
    </p>
    <pre><code>    public static Connection createConnection() throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        return connection;
    }
</code></pre>
    <h5>
     <a id="Publishing_Messages_Individually_1454">
     </a>
     Publishing Messages Individually（单独确认）
    </h5>
    <p>
     单独确认模式下，每发送一条消息，RabbitMQ 会在消息被成功持久化到队列或者被消费者成功接收后，发回一个确认（acknowledgment）。
     <strong>
      生产者可以收到关于每条消息的确认信息
     </strong>
    </p>
    <p>
     也就是说，
     <strong>
      生产者发送消息后会等待每条消息的确认信号
     </strong>
     。如果消息发送成功，RabbitMQ 会返回一个确认信号；如果消息失败，RabbitMQ 会返回一个负确认信号（nack）
    </p>
    <p>
     我们先在
     <strong>
      Constans
     </strong>
     类中声明会使用的队列：
    </p>
    <pre><code>    // 发布确认模式
    public static final String PUBLISH_CONFIRMS_QUEUE_1 = "publish.confims.queue1";
    public static final String PUBLISH_CONFIRMS_QUEUE_2 = "publish.confims.queue2";
    public static final String PUBLISH_CONFIRMS_QUEUE_3 = "publish.confims.queue3";
</code></pre>
    <p>
     我们仍使用默认的交换机进行路由
    </p>
    <p>
     每次都发送 200 条消息：
    </p>
    <pre><code>public class Producer {
    public static int MESSAGE_COUNT = 200;
}
</code></pre>
    <p>
     每当发送一条消息，就使用
     <strong>
      channel.waitForConfirms()
     </strong>
     方法等待确认消息
    </p>
    <blockquote>
     <p>
      void waitForConfirmsOrDie(long timeout) throws IOException, InterruptedException, TimeoutException;
     </p>
    </blockquote>
    <p>
     等待确认消息，当消息被确认，方法就会返回，若消息超时，就会抛出
     <strong>
      TimeoutException
     </strong>
     异常，若消息丢失，就会抛出
     <strong>
      IOException
     </strong>
    </p>
    <p>
     此外，我们记录
     <strong>
      单独确认策略
     </strong>
     发送消息的耗时：
    </p>
    <pre><code>public class Producer {
    public static int MESSAGE_COUNT = 200;
    public static int WAIT_TIME = 5000;

    public static void publishMessageIndividually() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 开启信道确认模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_1, true, false, false, null);
            // 记录开始时间
            long startTime = System.currentTimeMillis();
            // 发送消息
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_1, null, message.getBytes());
                // 等待确认
                channel.waitForConfirms(WAIT_TIME);
            }
            // 记录结束时间
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages individually in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
    <p>
     完整代码：
    </p>
    <pre><code>public class Producer {
    public static int MESSAGE_COUNT = 200;
    public static int WAIT_TIME = 5000;

    // 建立连接
    public static Connection createConnection() throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        return connection;
    }

    // 单独确认模式
    public static void publishMessageIndividually() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 开启信道确认模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_1, true, false, false, null);
            // 记录开始时间
            long startTime = System.currentTimeMillis();
            // 发送消息
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_1, null, message.getBytes());
                // 等待确认
                channel.waitForConfirmsOrDie(WAIT_TIME);
            }
            // 记录结束时间
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages individually in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        // 单独确认模式
        publishMessageIndividually();
    }
}
</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f2e5d08c15994cfe824ad8bf2d9d39bd.png"/>
    </p>
    <p>
     可以看到，发送 200 条消息的耗时较长
    </p>
    <p>
     且，单独确认策略是每发送一条消息后，就调用
     <strong>
      channel.waitForConfirmsOrDie
     </strong>
     方法，等待服务端的确认，也就是一种
     <strong>
      串行同步等待
     </strong>
     的方式，尤其是对于持久化的消息而言，需要等待消息确认存储在磁盘之后才会返回
    </p>
    <p>
     但发布确认机制支持
     <strong>
      异步确认
     </strong>
     ，即，可以
     <strong>
      一边发送消息，一边等待消息确认
     </strong>
    </p>
    <p>
     我们接着看另外两种策略
    </p>
    <h5>
     <a id="Publishing_Messages_in_Batches_1590">
     </a>
     Publishing Messages in Batches（批量确认）
    </h5>
    <p>
     批量确认会在
     <strong>
      每发送一批消息后
     </strong>
     ，调用
     <strong>
      waitForConfirms
     </strong>
     方法，等待服务器的确认返回
    </p>
    <p>
     我们每发送 50 条消息，就调用
     <strong>
      waitForConfirms
     </strong>
     方法进行确认：
    </p>
    <pre><code>    public static int BATCH_SIZE = 50;
    // 批量确认模式
    public static void publishMessageInBatches() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 设置为 confirm 模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_2, true, false, false, null);
            // 发送消息
            int messageCount = 0;
            long startTime = System.currentTimeMillis();
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_2, null, message.getBytes());
                messageCount++;
                // 批量确认
                if(messageCount == BATCH_SIZE) {
                    channel.waitForConfirms(WAIT_TIME);
                    messageCount = 0;
                }
            }
            // 消息发送完，若还有未确认消息，则进行最后的确认
            if (messageCount &gt; 0) {
                channel.waitForConfirms(WAIT_TIME);
            }
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages in batch in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }
</code></pre>
    <p>
     需要注意的是，若我们发送的消息为 210 条，此时最后的十条消息未被确认，因此，我们
     <strong>
      在消息发送完成后，进行最后的确认
     </strong>
    </p>
    <p>
     调用
     <strong>
      publishMessageInBatches
     </strong>
     方法，并观察结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b692caaca6254a47a510abf8ab9c922d.png"/>
    </p>
    <p>
     我们可以看到，相比于单独确认策略，批量确认极大的提高了 confirm 的效率，但当出现了 Basic.Nack 或超时时，我们
     <strong>
      无法确定是哪一条消息出现了问题
     </strong>
     ，客户端需要将这一批消息都进行重发，这也就重复发送了很多消息，
     <strong>
      当消息经常丢失时，批量确认的性能会不升反降
     </strong>
    </p>
    <p>
     最后，我们来看
     <strong>
      异步确认
     </strong>
    </p>
    <h5>
     <a id="Handling_Publisher_Confirms_Asynchronously_1645">
     </a>
     Handling Publisher Confirms Asynchronously（异步确认）
    </h5>
    <p>
     异步确认提供了一个
     <strong>
      回调方法
     </strong>
     ，服务端确认了一条或多条消息后，客户端会调用这个方法进行处理
    </p>
    <p>
     <strong>
      Channel
     </strong>
     接口提供了
     <strong>
      addConfirmListener
     </strong>
     方法，可以添加
     <strong>
      ConfirmListener 回调接口
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/fe6b1e6a20db4f9abe541977ccd96a90.png"/>
    </p>
    <p>
     在
     <strong>
      ConfirmListener
     </strong>
     接口中包含两个重要方法：
    </p>
    <p>
     <strong>
      handleAck
     </strong>
     和
     <strong>
      handleNack
     </strong>
     ，分别对应处理 RabbitMQ 发送给生产者的 ack 和 nack
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/514f8d03df074051adcc6a27bc5a8b09.png"/>
    </p>
    <p>
     <strong>
      deliveryTag
     </strong>
     表示发送消息的序号
    </p>
    <p>
     <strong>
      multiple
     </strong>
     表示是否批量确认，开启批量确认后，若 RabbitMQ 返回的消息序号为 20，则表明
     <strong>
      前
     </strong>
     20 条消息都已经接收成功；当不开启批量确认时，若 RabbitMQ 返回的消息序号为 20 ，则表明
     <strong>
      第
     </strong>
     20 条消息被成功接收
    </p>
    <p>
     在使用异步确认策略时，我们需要为每个 Channel
     <strong>
      维护一个已发送消息的序号集合
     </strong>
     ，当收到 RabbitMQ 的 confirm 回调时，从集合中删除掉对应消息
    </p>
    <p>
     当
     <strong>
      Channel
     </strong>
     开启
     <strong>
      confirm
     </strong>
     模式后，
     <strong>
      channel
     </strong>
     上发送消息都会附带一个从 1 开始递增的
     <strong>
      deliveryTag
     </strong>
     序号。我们可以使用
     <strong>
      SortedSet
     </strong>
     的有序性来维护这个已发送消息的集合
    </p>
    <p>
     <strong>
      实现步骤：
     </strong>
    </p>
    <p>
     1. 使用有序集合存储未确认的消息序号
    </p>
    <pre><code>            // 使用有序集合来存储未确认的消息
            SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;&gt;());
</code></pre>
    <p>
     2. 当收到 ack 时，从集合中删除消息序号，若为批量确认，则删除小于等于当前消息序号的所有序号
    </p>
    <pre><code>            // 进行确认
            channel.addConfirmListener(new ConfirmListener() {
                @Override
                public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                    // 若为批量确认，则删除确认序号前所有元素
                    if (multiple) {
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        confirmSet.remove(deliveryTag);
                    }
                }
            });
</code></pre>
    <p>
     3. 当接收到 nack 时，需要根据具体情况进行消息重发等操作
    </p>
    <p>
     在这里，我们就不对其进行处理了，直接将消息清除：
    </p>
    <pre><code>                @Override
                public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                    // 处理失败，消息重发...
                    // 若为批量确认，则删除确认序号前所有元素
                    if (multiple) {
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        confirmSet.remove(deliveryTag);
                    }
                }
</code></pre>
    <p>
     接着，我们发送消息，每当发送一条消息，就将其序号存储到有序集合中：
    </p>
    <pre><code>            // 发送消息
            long startTime = System.currentTimeMillis();
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                // 获取序号
                long nextPublishSeqNo = channel.getNextPublishSeqNo();
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_3, null, message.getBytes());
                // 存储序号
                confirmSet.add(nextPublishSeqNo);
            }
</code></pre>
    <p>
     当有序集合为空时，消息确认完，因此，我们使用 while 循环等待消息确认完毕：
    </p>
    <pre><code>            // 消息确认完毕
            while (!confirmSet.isEmpty()) {
                Thread.sleep(10);
            }
</code></pre>
    <p>
     若循环体中什么也不写，while 循环执行的速度会非常快，因此，每当判断一次，我们让其等待 10 ms
    </p>
    <p>
     完整代码：
    </p>
    <pre><code>    // 异步确认模式
    public static void handlePublishConfirmAsynchronously() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 设置 confirm 模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_3, false, false, true, null);
            // 使用有序集合来存储未确认的消息
            SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;&gt;());
            // 进行确认
            channel.addConfirmListener(new ConfirmListener() {
                @Override
                public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                    // 若为批量确认，则删除确认序号前所有元素
                    if (multiple) {
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        confirmSet.remove(deliveryTag);
                    }
                }

                @Override
                public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                    // 处理失败，消息重发...
                    // 若为批量确认，则删除确认序号前所有元素
                    if (multiple) {
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        confirmSet.remove(deliveryTag);
                    }
                }
            });
            // 记录开始时间
            long startTime = System.currentTimeMillis();
            // 发送消息
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                // 获取序号
                long nextPublishSeqNo = channel.getNextPublishSeqNo();
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_3, null, message.getBytes());
                // 存储序号
                confirmSet.add(nextPublishSeqNo);
            }
            // 消息确认完毕
            while (!confirmSet.isEmpty()) {
                Thread.sleep(10);
            }
            // 记录结束时间
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages and handled confirms asynchronously in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }
</code></pre>
    <p>
     运行结果：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/46adb9c6b2a9452aa1453ecb851e4910.png"/>
    </p>
    <p>
     可以看到，三种策略中，异步确认的表现更好
    </p>
    <p>
     完整代码：
    </p>
    <pre><code>public class Producer {
    public static int MESSAGE_COUNT = 200;
    public static int WAIT_TIME = 5000;
    public static int BATCH_SIZE = 50;

    // 建立连接
    public static Connection createConnection() throws IOException, TimeoutException {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 2. 设置参数
        factory.setHost(Constants.HOST); // ip 的默认值为 localhost
        factory.setPort(Constants.PORT); // 默认值为 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟主机，默认值为 /
        // 账号
        factory.setUsername(Constants.USER_NAME); // 用户名，默认为 guest
        factory.setPassword(Constants.USER_PASSWORD); // 密码，默认为 guest
        // 3. 创建连接 Connection
        Connection connection = factory.newConnection(); // 需要处理异常，在此处直接抛出，并不进行处理
        return connection;
    }

    // 单独确认模式
    public static void publishMessageIndividually() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 开启信道确认模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_1, true, false, false, null);
            // 记录开始时间
            long startTime = System.currentTimeMillis();
            // 发送消息
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_1, null, message.getBytes());
                // 等待确认
                channel.waitForConfirmsOrDie(WAIT_TIME);
            }
            // 记录结束时间
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages individually in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }

    // 批量确认模式
    public static void publishMessageInBatches() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 设置为 confirm 模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_2, true, false, false, null);
            // 发送消息
            int messageCount = 0;
            long startTime = System.currentTimeMillis();
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_2, null, message.getBytes());
                messageCount++;
                // 批量确认
                if(messageCount == BATCH_SIZE) {
                    channel.waitForConfirms(WAIT_TIME);
                    messageCount = 0;
                }
            }
            // 消息发送完，若还有未确认消息，则进行最后的确认
            if (messageCount &gt; 0) {
                channel.waitForConfirms(WAIT_TIME);
            }
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages in batch in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }

    // 异步确认模式
    public static void handlePublishConfirmAsynchronously() {
        try (Connection connection = createConnection()){
            // 开启信道
            Channel channel = connection.createChannel();
            // 设置 confirm 模式
            channel.confirmSelect();
            // 声明队列
            channel.queueDeclare(Constants.PUBLISH_CONFIRMS_QUEUE_3, false, false, true, null);
            // 使用有序集合来存储未确认的消息
            SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;&gt;());
            // 进行确认
            channel.addConfirmListener(new ConfirmListener() {
                @Override
                public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                    // 若为批量确认，则删除确认序号前所有元素
                    if (multiple) {
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        confirmSet.remove(deliveryTag);
                    }
                }

                @Override
                public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                    // 处理失败，消息重发...
                    // 若为批量确认，则删除确认序号前所有元素
                    if (multiple) {
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        confirmSet.remove(deliveryTag);
                    }
                }
            });
            // 记录开始时间
            long startTime = System.currentTimeMillis();
            // 发送消息
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "message " + i;
                // 获取序号
                long nextPublishSeqNo = channel.getNextPublishSeqNo();
                channel.basicPublish("", Constants.PUBLISH_CONFIRMS_QUEUE_3, null, message.getBytes());
                // 存储序号
                confirmSet.add(nextPublishSeqNo);
            }
            // 消息确认完毕
            while (!confirmSet.isEmpty()) {
                Thread.sleep(10);
            }
            // 记录结束时间
            long endTime = System.currentTimeMillis();
            System.out.printf("publish %d messages and handled confirms asynchronously in %d ms
", MESSAGE_COUNT, endTime - startTime);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        // 单独确认模式
        publishMessageIndividually();
        // 批量确认模式
         publishMessageInBatches();
        // 异步确认
         handlePublishConfirmAsynchronously();
    }
}
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f77656231383238353939373038392f:61727469636c652f64657461696c732f313436313530363439" class_="artid" style="display:none">
 </p>
</div>


