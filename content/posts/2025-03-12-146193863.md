---
layout: post
title: "每日八股Golang篇五垃圾回收"
date: 2025-03-12 02:38:40 +0800
description: "根据 csview 整理 golang 垃圾回收部分的八股。"
keywords: "golang 垃圾回收详解"
categories: ['Golang']
tags: ['服务器', '后端', 'Golang']
artid: "146193863"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146193863
    alt: "每日八股Golang篇五垃圾回收"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146193863
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146193863
cover: https://bing.ee123.net/img/rand?artid=146193863
image: https://bing.ee123.net/img/rand?artid=146193863
img: https://bing.ee123.net/img/rand?artid=146193863
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【每日八股】Golang篇（五）：垃圾回收
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="golang__1">
     </a>
     golang 的垃圾回收？
    </h2>
    <p>
     golang GC 算法使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动和整理）、并发（与用户代码并发执行）的三色标记清扫算法。
    </p>
    <p>
     三色标记清扫算法将对象分为三类，分别是：
    </p>
    <ul>
     <li>
      <strong>
       白色对象（可能死亡）
      </strong>
      ：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，回收结束后，白色对象均不可达；
     </li>
     <li>
      <strong>
       灰色对象（波面）
      </strong>
      ：已经被回收器访问到的对象，但回收期需要对其中的一个或多个指针进行扫描，因为指针指向的可能是白色对象；
     </li>
     <li>
      <strong>
       黑色对象（确定存活）
      </strong>
      ：已被回收器访问到的对象，其中所有字段均已被扫描，黑色对象中任意一个指针都不可能直接指向白色对象。
     </li>
    </ul>
    <p>
     对象颜色标记的过程如下：
    </p>
    <ul>
     <li>
      第一步：初始化所有对象为白色的；
     </li>
     <li>
      第二步：从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；
     </li>
     <li>
      第三步：从待处理队列取出灰色对象，将其引用的对象标记为灰色，并放入待处理队列中，当前对象标记为黑色；
     </li>
     <li>
      重复第三步，直到待处理队列为空，此时白色对象积为不可达的“垃圾”对象，回收白色对象。
     </li>
    </ul>
    <h2>
     <a id="_15">
     </a>
     写屏障？
    </h2>
    <p>
     由于颜色标记与垃圾回收和程序执行是并发的，在标记的过程中，难免会出现以下极端情况：清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而由于黑色对象不会被再次扫描，那么这个白色对象就会在扫描结束后被当作真正的白色对象回收掉。
    </p>
    <p>
     为了避免上述极端情况的产生，golang 采用写屏障，作用就是为了避免勿清扫。具体来说，写屏障在内存的写操作前，维护一个约束，从而确保清扫开始前，黑色对象不能够引用白色对象。GC 一旦开始执行，无论是创建对象还是改变对象的引用，一律将新创建的或新引用的对象标记为灰色的，进入待处理队列，这样可以保证它们至少不会在本次 GC 被误删除。
    </p>
    <h2>
     <a id="_20">
     </a>
     垃圾回收的触发条件？
    </h2>
    <ul>
     <li>
      系统触发：运行时自行根据内置的条件，检查、发现，并执行 GC，确保整个程序的可用性；
     </li>
     <li>
      系统监控：当超过 2 min 没有 GC 时，强制调用 GC；
     </li>
     <li>
      步调（Pacing）算法：其核心思想是控制内存增长的比例，当内存达到一定比例时触发 GC；
     </li>
     <li>
      触发：业务代码中手动调用
      <code>
       runtime.GC
      </code>
      触发 GC。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f436f666665656d616b657238382f:61727469636c652f64657461696c732f313436313933383633" class_="artid" style="display:none">
 </p>
</div>


