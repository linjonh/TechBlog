---
layout: post
title: "图论part4827.-最大人工岛127.-单词接龙463.-岛屿的周长"
date: 2025-03-15 00:10:39 +0800
description: "示例 1：输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]输出：5解释：一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。示例 1:输入: grid = [[1, 0], [0, 1]]输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。463. 岛屿的周长 - 力扣（LeetCode）"
keywords: "图论part4｜827. 最大人工岛、127. 单词接龙、463. 岛屿的周长"
categories: ['未分类']
tags: ['图论']
artid: "146264978"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146264978
    alt: "图论part4827.-最大人工岛127.-单词接龙463.-岛屿的周长"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146264978
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146264978
cover: https://bing.ee123.net/img/rand?artid=146264978
image: https://bing.ee123.net/img/rand?artid=146264978
img: https://bing.ee123.net/img/rand?artid=146264978
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     图论part4｜827. 最大人工岛、127. 单词接龙、463. 岛屿的周长
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     827. 最大人工岛
    </h2>
    <ul>
     <li>
      🔗：
      <a class="has-card" href="https://leetcode.cn/problems/making-a-large-island/description/" rel="nofollow" title="827. 最大人工岛 - 力扣（LeetCode）">
       <span class="link-card-box" contenteditable="false">
        <span class="link-title">
         827. 最大人工岛 - 力扣（LeetCode）
        </span>
        <span class="link-desc">
         827. 最大人工岛 - 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。返回执行此操作后，grid 中最大的岛屿面积是多少？岛屿 由一组上、下、左、右四个方向相连的 1 形成。 示例 1:输入: grid = [[1, 0], [0, 1]]输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。示例 2:输入: grid = [[1, 1], [1, 0]]输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。示例 3:输入: grid = [[1, 1], [1, 1]]输出: 4解释: 没有0可以让我们变成1，面积依然为 4。 提示： * n == grid.length * n == grid[i].length * 1 &lt;= n &lt;= 500 * grid[i][j] 为 0 或 1
        </span>
        <span class="link-link">
         <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
          https://leetcode.cn/problems/making-a-large-island/description/
         </img>
        </span>
       </span>
      </a>
     </li>
     <li>
      思路：
     </li>
     <li>
      代码：
     </li>
    </ul>
    <pre><code class="language-java">class Solution {
    /**
        思路：
            1. 先把已经存在的岛找出来，并且计算他们的面积（dfs）
            2. 遍历为0的点，计算加上附近的岛的面积之后的最大面积
            3. 去重：避免把一个相邻的岛的面积计算两遍
     */
    private final int[][] dirs = {<!-- -->{-1,0},{1,0},{0,1},{0,-1}};

    public int largestIsland(int[][] grid) {
        int n = grid.length;
        // 计算每一个存在的岛的面积
        List&lt;Integer&gt; area = new ArrayList&lt;&gt;();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;n; j++){
                if(grid[i][j] == 1)//找到小岛
                    area.add(dfs(grid, i, j, area.size()+2));
            }
        }
        // 
        int maxSquare = 0;
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;n; j++){
                //遍历为0的点，计算加上附近的岛的面积之后的最大面积
                if(grid[i][j] == 0){
                    int square = 1;
                    s.clear();
                    for(int[] dir: dirs){
                        int newi = dir[0] + i;
                        int newj = dir[1] + j;
                        if(newi&gt;=0 &amp;&amp; newj&gt;=0 &amp;&amp; newi&lt;grid.length &amp;&amp; newj &lt; grid.length &amp;&amp; grid[newi][newj]!=0 &amp;&amp; s.add(grid[newi][newj])){
                            square += area.get(grid[newi][newj]-2);
                        }
                    }
                    maxSquare = Math.max(square, maxSquare);
                }
            }
        }
        // 考虑小岛不需要添加任何1的情况
        return maxSquare == 0 ? n*n : maxSquare;
    }

    private int dfs(int[][] grid, int row, int col, int island){
        // 标记小岛的编号
        grid[row][col] = island;

        int square = 1;
        for(int[] dir: dirs){
            int newr = row + dir[0];
            int newc = col + dir[1];
            if(newc&gt;=0 &amp;&amp; newr&gt;=0 &amp;&amp; newc&lt;grid.length &amp;&amp; newr &lt; grid.length &amp;&amp; grid[newr][newc]==1){
                // 计算岛屿的大小
                square += dfs(grid, newr, newc, island);
            }
        }
        return square;
    }
}</code></pre>
    <h2 style="text-align:start">
     <span style="color:#000000">
      127.  单词
      <span style="background-color:#ffffff">
       <strong>
        <span style="color:#2c3e50">
         接龙
        </span>
       </strong>
      </span>
     </span>
    </h2>
    <ul>
     <li>
      🔗：
      <a class="has-card" href="https://leetcode.cn/problems/word-ladder/description/" rel="nofollow" title="127. 单词接龙 - 力扣（LeetCode）">
       <span class="link-card-box" contenteditable="false">
        <span class="link-title">
         127. 单词接龙 - 力扣（LeetCode）
        </span>
        <span class="link-desc">
         127. 单词接龙 - 字典 wordList 中从单词 beginWord 到 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk： * 每一对相邻的单词只差一个字母。 *  对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。 * sk == endWord给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。 示例 1：输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]输出：5解释：一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。示例 2：输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]输出：0解释：endWord "cog" 不在字典中，所以无法进行转换。 提示： * 1 &lt;= beginWord.length &lt;= 10 * endWord.length == beginWord.length * 1 &lt;= wordList.length &lt;= 5000 * wordList[i].length == beginWord.length * beginWord、endWord 和 wordList[i] 由小写英文字母组成 * beginWord != endWord * wordList 中的所有字符串 互不相同
        </span>
        <span class="link-link">
         <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
          https://leetcode.cn/problems/word-ladder/description/
         </img>
        </span>
       </span>
      </a>
     </li>
     <li>
      思路1：广度优先遍历
      <ul>
       <li>
        用图论的思想去看待这道题，返回begin--&gt;end的最短路径
       </li>
      </ul>
     </li>
     <li>
      代码1（广度优先遍历）
     </li>
    </ul>
    <pre><code class="language-java">class Solution {
    /**
        beginword: --&gt;   --&gt;       --&gt;    --&gt; endword
            hit      hot      dot      dog       cog
        用图论的思想去看待这道题，begin--》end的最短路径
     */

    // to judge whether there is an edge
    private boolean isEdge(String cur, String next){
        if(cur.length()!=next.length()) return false;
        int diff = 0;
        for(int i=0; i&lt;cur.length(); i++){
            if(diff &gt; 1) return false;
            if(cur.charAt(i) != next.charAt(i)){
                diff++;
            }
        }
        return diff == 1;
    }

    // 
    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {
        Set&lt;String&gt; visited = new HashSet&lt;&gt;();
        if(!wordList.contains(endWord)) return 0;

        Queue&lt;String&gt; neighbours = new LinkedList&lt;&gt;();
        neighbours.add(beginWord);
        visited.add(beginWord);
        int length = 1;
        
        while(!neighbours.isEmpty()){
            int size = neighbours.size();
            for(int i=0; i&lt;size; i++){
                String currentword = neighbours.poll();
                if(isEdge(currentword,endWord)) return length+1;
                for(String word: new HashSet&lt;&gt;(wordList)){
                    if(visited.contains(word)) continue;
                    if(isEdge(currentword,word)){
                        neighbours.add(word);
                        visited.add(word);
                    }
                }
            }
            // 现在的数值和endword间有边

            
            length++;
        }
        return 0;
    }
}</code></pre>
    <ul>
     <li style="text-align:start">
      思路2: 优化方式--用双向bfs缩短遍历的流程
      <ul>
       <li style="text-align:start">
        1. 除了visited（所有访问过的节点）之外，采用startvisited和endvisited存储前后向遍历的节点（非全部节点，而是要处理的新一层的节点）
       </li>
       <li style="text-align:start">
        交替处理startvisited和endvisited中需要处理的数据，每次处理节点数小的那个list
       </li>
       <li style="text-align:start">
        如果startvisited的下一层（nextvisited）中，包含endvisited中的元素，则表示找到了最短的路径
       </li>
       <li style="text-align:start">
        图示：（来源weiwei）
        <img alt="" height="332" src="https://i-blog.csdnimg.cn/direct/52d5739253d447b7b69288d9fa403f53.png" width="914"/>
       </li>
      </ul>
     </li>
     <li style="text-align:start">
      代码2:
      <ul>
       <li style="text-align:start">
        <pre><code class="language-java">public class Solution {

    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {
        // 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里
        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList);
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return 0;
        }

        // 第 2 步：已经访问过的 word 添加到 visited 哈希表里
        Set&lt;String&gt; visited = new HashSet&lt;&gt;();
        // 分别用左边和右边扩散的哈希表代替单向 BFS 里的队列，它们在双向 BFS 的过程中交替使用
        Set&lt;String&gt; beginVisited = new HashSet&lt;&gt;();
        beginVisited.add(beginWord);
        Set&lt;String&gt; endVisited = new HashSet&lt;&gt;();
        endVisited.add(endWord);

        // 第 3 步：执行双向 BFS，左右交替扩散的步数之和为所求
        int step = 1;
        while (!beginVisited.isEmpty() &amp;&amp; !endVisited.isEmpty()) {
            // 优先选择小的哈希表进行扩散，考虑到的情况更少
            if (beginVisited.size() &gt; endVisited.size()) {
                Set&lt;String&gt; temp = beginVisited;
                beginVisited = endVisited;
                endVisited = temp;
            }

            // 逻辑到这里，保证 beginVisited 是相对较小的集合，nextLevelVisited 在扩散完成以后，会成为新的 beginVisited
            Set&lt;String&gt; nextLevelVisited = new HashSet&lt;&gt;();
            for (String word : beginVisited) {
                if (changeWordEveryOneLetter(word, endVisited, visited, wordSet, nextLevelVisited)) {
                    return step + 1;
                }
            }

            // 原来的 beginVisited 废弃，从 nextLevelVisited 开始新的双向 BFS
            beginVisited = nextLevelVisited;
            step++;
        }
        return 0;
    }


    /**
     * 尝试对 word 修改每一个字符，看看是不是能落在 endVisited 中，扩展得到的新的 word 添加到 nextLevelVisited 里
     *
     * @param word
     * @param endVisited
     * @param visited
     * @param wordSet
     * @param nextLevelVisited
     * @return
     */
    private boolean changeWordEveryOneLetter(String word, Set&lt;String&gt; endVisited,
                                             Set&lt;String&gt; visited,
                                             Set&lt;String&gt; wordSet,
                                             Set&lt;String&gt; nextLevelVisited) {
        char[] charArray = word.toCharArray();
        for (int i = 0; i &lt; word.length(); i++) {
            char originChar = charArray[i];
            for (char c = 'a'; c &lt;= 'z'; c++) {
                if (originChar == c) {
                    continue;
                }
                charArray[i] = c;
                String nextWord = String.valueOf(charArray);
                if (wordSet.contains(nextWord)) {
                    if (endVisited.contains(nextWord)) {
                        return true;
                    }
                    if (!visited.contains(nextWord)) {
                        nextLevelVisited.add(nextWord);
                        visited.add(nextWord);
                    }
                }
            }
            // 恢复，下次再用
            charArray[i] = originChar;
        }
        return false;
    }
}</code></pre>
        <p>
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h2 style="text-align:start">
     <span style="background-color:#ffffff">
      <strong>
       <span style="color:#000000">
        <span style="caret-color:#000000">
         105. 有向图的完全可达性
        </span>
       </span>
       <span style="color:#2c3e50">
       </span>
      </strong>
     </span>
    </h2>
    <ul>
     <li>
      🔗：
      <a class="has-card" href="https://kamacoder.com/problempage.php?pid=1177" rel="nofollow" title="105. 有向图的完全可达性">
       <span class="link-card-box" contenteditable="false">
        <span class="link-title">
         105. 有向图的完全可达性
        </span>
        <span class="link-link">
         <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
          https://kamacoder.com/problempage.php?pid=1177
         </img>
        </span>
       </span>
      </a>
     </li>
     <li>
      思路：不难做，主要练习一下acm模式，用的是广度优先的搜索方式，用深度是一样的
     </li>
     <li>
      代码：
      <pre><code class="language-java">import java.util.*;

class Main{
    private static Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();

    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int num_node = scanner.nextInt();
        int num_edge = scanner.nextInt();
        // if there is only 1 node
        //if(num_node==1) return 1;
        List&lt;int[]&gt; edges  = new ArrayList&lt;&gt;();

        for(int i=0 ;i&lt;num_edge; i++){
            int[] edge = new int[2];
            edge[0] = scanner.nextInt();
            edge[1] = scanner.nextInt();
            edges.add(edge);
        }


        int currentNode = 1;
        Queue&lt;Integer&gt; que = new LinkedList&lt;&gt;();
        que.add(currentNode);
        visited.add(currentNode);
        
        while(!que.isEmpty()){
            int size = que.size();
            for(int j=0; j&lt;size; j++){
                currentNode = que.poll();
                
                for(int[] edge1: edges){
                    //
                    // System.out.println(edge1[0]+" "+edge1[1]);
                    if(edge1[0] == currentNode){
                        // 如果加不进去代表重复visited了
                        if(visited.add(edge1[1])){
                            que.add(edge1[1]);
                            
                        }
                    }
                }
            }
        }

        if(visited.size()==num_node)
            System.out.println(1);
        else
            System.out.println(-1);

    }

}</code></pre>
      <p>
      </p>
     </li>
    </ul>
    <h2 style="text-align:start">
     <span style="color:#000000">
      <span style="caret-color:#000000">
       463. 岛屿的周长
      </span>
     </span>
    </h2>
    <ul>
     <li>
      🔗：
      <a class="has-card" href="https://leetcode.cn/problems/island-perimeter/description/" rel="nofollow" title="463. 岛屿的周长 - 力扣（LeetCode）">
       <span class="link-card-box" contenteditable="false">
        <span class="link-title">
         463. 岛屿的周长 - 力扣（LeetCode）
        </span>
        <span class="link-desc">
         463. 岛屿的周长 - 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 1：[https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png]输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边示例 2：输入：grid = [[1]]输出：4示例 3：输入：grid = [[1,0]]输出：4 提示： * row == grid.length * col == grid[i].length * 1 &lt;= row, col &lt;= 100 * grid[i][j] 为 0 或 1
        </span>
        <span class="link-link">
         <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
          https://leetcode.cn/problems/island-perimeter/description/
         </img>
        </span>
       </span>
      </a>
     </li>
     <li>
      思路：深度优先搜索
      <ul>
       <li>
        <p>
         dfs遍历的方式可扩展至统计多个岛屿各自的周长。
        </p>
       </li>
      </ul>
     </li>
     <li>
      代码：
      <pre><code class="language-java">class Solution {
    int[][] dirs = {<!-- -->{-1,0},{1,0},{0,1},{0,-1}};

    public int islandPerimeter(int[][] grid) {
        int circle = 0;
        int m = grid.length;
        int n = grid[0].length;
        for(int i=0; i&lt;m; i++){
            for(int j=0; j&lt;n; j++){
                if(grid[i][j]==1){
                    circle = dfs(grid, i, j);
                    return circle;
                }
            }
        }
        return circle;    
    }

    private int dfs(int[][] grid, int row, int column){
        if(grid[row][column]==2) return 0;
        int circle = 0;
        grid[row][column] = 2;
        for(int[] dir: dirs){
            int x = row + dir[0];
            int y = column + dir[1];
            if(x&lt;0 || y&lt;0 || x &gt;= grid.length || y &gt;= grid[0].length || grid[x][y] == 0){
                circle += 1;
            }
            else if(grid[x][y] == 1){
                circle += dfs(grid, x, y);
            }
        }
        return circle;
    }
}</code></pre>
      <p>
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36323537323536372f:61727469636c652f64657461696c732f313436323634393738" class_="artid" style="display:none">
 </p>
</div>


