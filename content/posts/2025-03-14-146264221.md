---
layout: post
title: "iOS底层原理系列04-并发编程"
date: 2025-03-14 18:15:26 +0800
description: "iOS提供了多种并发编程和线程安全的机制，从底层的pthread到高级的GCD和NSOperation。性能需求：对于性能要求极高的场景，考虑os_unfair_lock或dispatch_semaphore；对于一般场景，NSLock和串行队列足够。编程范式：如果偏好面向对象的API，选择NSOperation和NSLock系列；如果偏好函数式编程，选择GCD。任务特性：如果需要复杂的任务依赖和取消机制，选择NSOperation；如果是简单的并发任务，GCD更简洁。同步需求。"
keywords: "iOS底层原理系列04-并发编程"
categories: ['Ios']
tags: ['Macos', 'Ios', 'Cocoa']
artid: "146264221"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146264221
    alt: "iOS底层原理系列04-并发编程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146264221
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146264221
cover: https://bing.ee123.net/img/rand?artid=146264221
image: https://bing.ee123.net/img/rand?artid=146264221
img: https://bing.ee123.net/img/rand?artid=146264221
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     iOS底层原理系列04-并发编程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night-eighties" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在移动应用开发中，流畅的用户体验至关重要，而并发编程是实现这一目标的关键技术。本文将深入探讨iOS平台上的并发编程和多线程架构，帮助你构建高性能、响应迅速的应用程序。
    </p>
    <h2>
     <a id="1_iOS_2">
     </a>
     1. iOS线程调度机制
    </h2>
    <h3>
     <a id="11_iOS_4">
     </a>
     1.1 线程本质和iOS线程调度机制
    </h3>
    <p>
     线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一个进程可以拥有多个线程，每个线程共享进程的资源，但拥有自己的执行路径。
    </p>
    <p>
     在iOS系统中，线程调度由系统内核负责，通过优先级队列和时间片轮转算法确定线程的执行顺序和执行时长。苹果对标准的线程模型进行了优化，引入了更高级的抽象，如GCD和Operation，使开发者能够专注于任务本身，而非线程管理的细节。
    </p>
    <h3>
     <a id="12__10">
     </a>
     1.2 并发计算模型中的同步/异步与串行/并行
    </h3>
    <p>
     并发编程中的两组基本概念：同步/异步和串行/并行。这两组概念看似简单，但常被混淆，它们实际上描述了两个不同的维度。
    </p>
    <h4>
     <a id="_14">
     </a>
     同步/异步的本质
    </h4>
    <p>
     <strong>
      同步(Synchronous)与异步(Asynchronous)
      <strong>
       描述的是
      </strong>
      调用方式
     </strong>
     ，关注的是
     <strong>
      线程的等待方式
     </strong>
     。
    </p>
    <ul>
     <li>
      <strong>
       同步调用
      </strong>
      ：调用者会一直等待被调用的任务完成后，才继续执行后续代码。调用者线程在任务执行期间处于阻塞状态。
     </li>
     <li>
      <strong>
       异步调用
      </strong>
      ：调用者不会等待被调用的任务完成，会立即继续执行后续代码。任务的完成通常通过回调、通知或其他机制通知调用者。
     </li>
    </ul>
    <h4>
     <a id="_21">
     </a>
     串行/并行的本质
    </h4>
    <p>
     **串行(Serial)与并行(Concurrent)**描述的是任务的执行方式，关注的是多个任务之间的关系。
    </p>
    <ul>
     <li>
      <strong>
       串行执行
      </strong>
      ：多个任务按顺序依次执行，任何时刻只有一个任务在执行。
     </li>
     <li>
      <strong>
       并行执行
      </strong>
      ：多个任务可以同时执行，任务之间相互独立，各自在不同的线程上执行。
     </li>
    </ul>
    <h4>
     <a id="_28">
     </a>
     同步/异步与串行/并行排列组合的调度机制和执行效果
    </h4>
    <p>
     这两组概念可以组合出四种不同的调度情况，下面我们详细分析每种组合的调度机制和执行效果。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1098ebbbdef54337aa00dd64c492043d.png#pic_center"/>
    </p>
    <p>
     <strong>
      1. 同步 + 串行
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       调度机制
      </strong>
      ：任务在当前线程上按顺序执行
     </li>
     <li>
      <strong>
       执行效果
      </strong>
      ：调用者线程被阻塞，直到所有任务完成
     </li>
    </ul>
    <p>
     <strong>
      2. 同步 + 并行
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       调度机制
      </strong>
      ：任务被分配到多个线程并发执行
     </li>
     <li>
      <strong>
       执行效果
      </strong>
      ：调用者线程仍然被阻塞，直到所有任务完成
     </li>
     <li>
      <strong>
       注意
      </strong>
      ：这种组合在实际中较少使用，因为即使任务并行执行，调用者仍需等待所有任务完成，无法充分利用并行的优势
     </li>
    </ul>
    <p>
     <strong>
      3. 异步 + 串行
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       调度机制
      </strong>
      ：任务在另一个线程上按顺序执行
     </li>
     <li>
      <strong>
       执行效果
      </strong>
      ：调用者线程立即返回继续执行后续代码，不会被阻塞
     </li>
    </ul>
    <p>
     <strong>
      4. 异步 + 并行
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       调度机制
      </strong>
      ：任务被分配到多个线程并发执行
     </li>
     <li>
      <strong>
       执行效果
      </strong>
      ：调用者线程立即返回继续执行后续代码，不会被阻塞，同时多个任务可以同时执行，充分利用多核处理器性能
     </li>
    </ul>
    <p>
     这四种组合方式构成了iOS多线程编程的基础模型，也是理解GCD和NSOperation等高级API的关键。
    </p>
    <h2>
     <a id="2_iOS_58">
     </a>
     2. iOS线程方案
    </h2>
    <p>
     iOS提供了多种多线程编程方案，从底层的pthread到高级的GCD和NSOperation，为开发者提供了灵活的选择。
    </p>
    <h3>
     <a id="21_pthread_61">
     </a>
     2.1 pthread
    </h3>
    <p>
     <code>
      pthread
     </code>
     (POSIX thread)是一套跨平台的线程API标准，iOS也支持这一标准。它比NSThread更底层，提供了更多的控制选项。
    </p>
    <pre><code class="prism language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>pthread<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token comment">// 创建线程</span>
pthread_t thread<span class="token punctuation">;</span>
<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> ThreadFunction<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 线程函数</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ThreadFunction</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 执行任务</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"任务在pthread中执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 等待线程结束</span>
<span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      跨平台兼容性好
     </li>
     <li>
      控制粒度更细
     </li>
     <li>
      可以设置线程的各种属性
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      API复杂，使用不便
     </li>
     <li>
      需要手动管理线程的各个方面
     </li>
     <li>
      缺乏Objective-C与iOS集成的便利特性
     </li>
    </ul>
    <h3>
     <a id="22_NSThread_94">
     </a>
     2.2 NSThread
    </h3>
    <p>
     <code>
      NSThread
     </code>
     是Objective-C中最基本的线程类，它是对pthread的面向对象封装，提供了创建和管理线程的基本功能。
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 创建并启动线程</span>
NSThread <span class="token operator">*</span>thread <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSThread alloc<span class="token punctuation">]</span> initWithTarget<span class="token punctuation">:</span><span class="token keyword">self</span> 
                                           selector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">:</span><span class="token punctuation">)</span> 
                                             object<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">@"MyCustomThread"</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>thread start<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 或者使用类方法创建并自动启动线程</span>
<span class="token punctuation">[</span>NSThread detachNewThreadSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">:</span><span class="token punctuation">)</span> 
                         toTarget<span class="token punctuation">:</span><span class="token keyword">self</span> 
                       withObject<span class="token punctuation">:</span>nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      简单直观，面向对象的API
     </li>
     <li>
      可以直接控制线程的生命周期
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      需要手动管理线程生命周期
     </li>
     <li>
      缺乏高级特性，如线程池、任务依赖等
     </li>
     <li>
      线程创建和销毁的开销较大
     </li>
    </ul>
    <h3>
     <a id="23_GCD_125">
     </a>
     2.3 GCD
    </h3>
    <p>
     GCD是一个强大的并发编程框架，通过任务和队列的概念简化了多线程编程。GCD的核心思想是让开发者关注"做什么"而不是"怎么做"。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f4954aad806741159ded158cb9df9e8e.png#pic_center"/>
    </p>
    <h4>
     <a id="231_GCD_130">
     </a>
     2.3.1 GCD的核心概念：
    </h4>
    <p>
     <strong>
      队列(Queue)
     </strong>
     ：负责存储和管理任务。
    </p>
    <ul>
     <li>
      <strong>
       串行队列(Serial Queue)
      </strong>
      ：按顺序执行任务。
     </li>
     <li>
      <strong>
       并行队列(Concurrent Queue)
      </strong>
      ：可以同时执行多个任务。
     </li>
     <li>
      <strong>
       主队列(Main Queue)
      </strong>
      ：在主线程上执行任务，通常用于UI更新。
     </li>
    </ul>
    <p>
     <strong>
      任务(Task)
     </strong>
     ：以Block(代码块)形式提交到队列。
    </p>
    <p>
     <strong>
      调度方式
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       同步调度(sync)
      </strong>
      ：等待任务完成后返回。
     </li>
     <li>
      <strong>
       异步调度(async)
      </strong>
      ：提交任务后立即返回。
     </li>
    </ul>
    <p>
     下面是GCD的常见用法示例：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 获取全局并行队列</span>
dispatch_queue_t globalQueue <span class="token operator">=</span> <span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span>DISPATCH_QUEUE_PRIORITY_DEFAULT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 异步执行任务</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span>globalQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 耗时操作</span>
    NSData <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">self</span> fetchDataFromServer<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 在主队列更新UI</span>
    <span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">[</span><span class="token keyword">self</span> updateUIWithData<span class="token punctuation">:</span>data<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建自定义串行队列</span>
dispatch_queue_t serialQueue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">"com.example.serialQueue"</span><span class="token punctuation">,</span> DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 同步执行任务</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span>serialQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 这会阻塞当前线程直到该任务完成</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> processData<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="232_GCD_172">
     </a>
     2.3.2 GCD其他高级功能
    </h4>
    <p>
     如分组(group)、信号量(semaphore)、一次性执行(once)等：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 使用组管理多个任务</span>
dispatch_group_t group <span class="token operator">=</span> <span class="token function">dispatch_group_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span>DISPATCH_QUEUE_PRIORITY_DEFAULT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加任务到组</span>
<span class="token function">dispatch_group_async</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 任务1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dispatch_group_async</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 任务2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等待所有任务完成</span>
<span class="token function">dispatch_group_notify</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> <span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"所有任务已完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      简洁高效的API
     </li>
     <li>
      自动管理线程池
     </li>
     <li>
      针对多核处理器优化
     </li>
     <li>
      低系统开销
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      相比NSOperation，不支持取消任务
     </li>
     <li>
      不支持任务优先级(旧版本)
     </li>
     <li>
      调试难度相对较高
     </li>
    </ul>
    <h3>
     <a id="24_NSOperationNSOperationQueue_208">
     </a>
     2.4 NSOperation/NSOperationQueue
    </h3>
    <p>
     <code>
      NSOperation
     </code>
     和
     <code>
      NSOperationQueue
     </code>
     是基于GCD构建的更高级的抽象，提供了面向对象的API和更强大的任务管理能力。
    </p>
    <p>
     NSOperation是一个抽象类，开发者通常使用其子类：
    </p>
    <ol>
     <li>
      <strong>
       NSBlockOperation
      </strong>
      ：用于执行一个或多个Block的操作。
     </li>
     <li>
      <strong>
       NSInvocationOperation
      </strong>
      ：用于调用特定对象的选择器。
     </li>
     <li>
      <strong>
       自定义NSOperation子类
      </strong>
      ：实现复杂任务逻辑。
     </li>
    </ol>
    <p>
     NSOperationQueue用于管理和执行NSOperation对象：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 创建队列</span>
NSOperationQueue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSOperationQueue alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span>maxConcurrentOperationCount <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 设置最大并发数</span>

<span class="token comment">// 创建操作</span>
NSBlockOperation <span class="token operator">*</span>operation1 <span class="token operator">=</span> <span class="token punctuation">[</span>NSBlockOperation blockOperationWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    NSData <span class="token operator">*</span>imageData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">self</span> downloadImageData<span class="token punctuation">]</span><span class="token punctuation">;</span>
    UIImage <span class="token operator">*</span>image <span class="token operator">=</span> <span class="token punctuation">[</span>UIImage imageWithData<span class="token punctuation">:</span>imageData<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 在主队列更新UI</span>
    <span class="token punctuation">[</span><span class="token punctuation">[</span>NSOperationQueue mainQueue<span class="token punctuation">]</span> addOperationWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>imageView<span class="token punctuation">.</span>image <span class="token operator">=</span> image<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 添加完成回调</span>
operation1<span class="token punctuation">.</span>completionBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"图片下载完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 添加操作到队列</span>
<span class="token punctuation">[</span>queue addOperation<span class="token punctuation">:</span>operation1<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     NSOperation/NSOperationQueue最强大的特性是可以设置操作之间的依赖关系，构建复杂的工作流：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 创建多个操作</span>
NSBlockOperation <span class="token operator">*</span>downloadOp <span class="token operator">=</span> <span class="token punctuation">[</span>NSBlockOperation blockOperationWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 下载图片</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

NSBlockOperation <span class="token operator">*</span>filterOp <span class="token operator">=</span> <span class="token punctuation">[</span>NSBlockOperation blockOperationWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 过滤图片</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

NSBlockOperation <span class="token operator">*</span>saveOp <span class="token operator">=</span> <span class="token punctuation">[</span>NSBlockOperation blockOperationWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 保存图片</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 设置依赖关系</span>
<span class="token punctuation">[</span>filterOp addDependency<span class="token punctuation">:</span>downloadOp<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 先下载，再过滤</span>
<span class="token punctuation">[</span>saveOp addDependency<span class="token punctuation">:</span>filterOp<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 先过滤，再保存</span>

<span class="token comment">// 添加到队列</span>
NSOperationQueue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSOperationQueue alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>queue addOperations<span class="token punctuation">:</span><span class="token operator">@</span><span class="token punctuation">[</span>downloadOp<span class="token punctuation">,</span> filterOp<span class="token punctuation">,</span> saveOp<span class="token punctuation">]</span> waitUntilFinished<span class="token punctuation">:</span>NO<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     NSOperation还支持任务的取消、暂停和恢复：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 取消单个操作</span>
<span class="token punctuation">[</span>operation cancel<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 取消队列中所有操作</span>
<span class="token punctuation">[</span>queue cancelAllOperations<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 暂停队列</span>
queue<span class="token punctuation">.</span>suspended <span class="token operator">=</span> YES<span class="token punctuation">;</span>

<span class="token comment">// 恢复队列</span>
queue<span class="token punctuation">.</span>suspended <span class="token operator">=</span> NO<span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      面向对象的API
     </li>
     <li>
      支持操作的取消、暂停和恢复
     </li>
     <li>
      支持操作优先级
     </li>
     <li>
      支持操作间依赖关系
     </li>
     <li>
      内置了完成块(completionBlock)
     </li>
     <li>
      KVO兼容，可以观察操作状态
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      相比GCD，开销略大
     </li>
     <li>
      API相对复杂
     </li>
     <li>
      初始化和配置需要更多代码
     </li>
    </ul>
    <h2>
     <a id="3_iOS_301">
     </a>
     3. iOS中的线程安全方案
    </h2>
    <p>
     多线程编程中，一个关键问题是如何确保共享资源的访问安全。iOS提供了多种锁机制和同步方案，下面按性能从高到低介绍。
    </p>
    <h3>
     <a id="31_os_unfair_lock_305">
     </a>
     3.1 os_unfair_lock
    </h3>
    <p>
     这是iOS 10引入的锁机制，用于替代已废弃的OSSpinLock。它是一种低级互斥锁，性能极高。
    </p>
    <pre><code class="prism language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>os<span class="token operator">/</span>lock<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token comment">// 创建锁</span>
os_unfair_lock lock <span class="token operator">=</span> OS_UNFAIR_LOCK_INIT<span class="token punctuation">;</span>

<span class="token comment">// 加锁</span>
<span class="token function">os_unfair_lock_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区代码</span>
<span class="token function">os_unfair_lock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 尝试加锁（非阻塞）</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">os_unfair_lock_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 加锁成功，执行临界区代码</span>
    <span class="token function">os_unfair_lock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 加锁失败</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要高性能且临界区操作简短的场景。
    </p>
    <h3>
     <a id="32_OSSpinLock__331">
     </a>
     3.2 OSSpinLock (已废弃)
    </h3>
    <p>
     自旋锁在等待锁释放时会持续尝试获取锁，不会进入休眠状态。虽然性能很高，但在iOS平台上存在优先级反转问题，已被苹果废弃。
    </p>
    <pre><code class="prism language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>libkern<span class="token operator">/</span>OSAtomic<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token comment">// 创建锁</span>
OSSpinLock lock <span class="token operator">=</span> OS_SPINLOCK_INIT<span class="token punctuation">;</span>

<span class="token comment">// 加锁</span>
<span class="token function">OSSpinLockLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区代码</span>
<span class="token function">OSSpinLockUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      注意
     </strong>
     ：由于存在优先级反转问题，不推荐使用，应改用os_unfair_lock。
    </p>
    <h3>
     <a id="33_dispatch_semaphore_t_349">
     </a>
     3.3 dispatch_semaphore_t
    </h3>
    <p>
     信号量是一种计数器，可以用来控制访问共享资源的线程数量。
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 创建信号量，初始值为1（表示互斥锁）</span>
dispatch_semaphore_t semaphore <span class="token operator">=</span> <span class="token function">dispatch_semaphore_create</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等待（减1，如果结果小于0则等待）</span>
<span class="token function">dispatch_semaphore_wait</span><span class="token punctuation">(</span>semaphore<span class="token punctuation">,</span> DISPATCH_TIME_FOREVER<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区代码</span>
<span class="token comment">// 释放（加1，如果之前小于0则唤醒等待线程）</span>
<span class="token function">dispatch_semaphore_signal</span><span class="token punctuation">(</span>semaphore<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要控制并发访问数量的场景，不仅限于互斥访问。
    </p>
    <h3>
     <a id="34_pthread_mutex_366">
     </a>
     3.4 pthread_mutex
    </h3>
    <p>
     POSIX线程库提供的互斥锁，是一种通用的同步机制。
    </p>
    <pre><code class="prism language-objc">pthread_mutex_t mutex<span class="token punctuation">;</span>
<span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 加锁</span>
<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区代码</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 释放锁</span>
<span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要可靠互斥且对性能要求不极端高的通用场景。
    </p>
    <h3>
     <a id="35_dispatch_queueDISPATCH_QUEUE_SERIAL_385">
     </a>
     3.5 dispatch_queue(DISPATCH_QUEUE_SERIAL)
    </h3>
    <p>
     串行队列可以用作同步机制，确保任务按顺序执行。
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 创建串行队列</span>
dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">"com.example.safeQueue"</span><span class="token punctuation">,</span> DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 同步执行（类似于加锁）</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 临界区代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 异步执行（非阻塞）</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 临界区代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：适合需要异步执行且保证顺序的场景，更偏向任务编排而非简单锁定。
    </p>
    <h3>
     <a id="36_NSLock_406">
     </a>
     3.6 NSLock
    </h3>
    <p>
     Foundation框架提供的Objective-C互斥锁类。
    </p>
    <pre><code class="prism language-objc">NSLock <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSLock alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 加锁</span>
<span class="token punctuation">[</span>lock lock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区代码</span>
<span class="token punctuation">[</span>lock unlock<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 尝试加锁（非阻塞）</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>lock tryLock<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 加锁成功</span>
    <span class="token punctuation">[</span>lock unlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 带超时的加锁</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>lock lockBeforeDate<span class="token punctuation">:</span><span class="token punctuation">[</span>NSDate dateWithTimeIntervalSinceNow<span class="token punctuation">:</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在1秒内获取到锁</span>
    <span class="token punctuation">[</span>lock unlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要面向对象API和超时功能的一般场景。
    </p>
    <h3>
     <a id="37_NSCondition_433">
     </a>
     3.7 NSCondition
    </h3>
    <p>
     条件变量和互斥锁的结合，用于线程间的等待和通知机制。
    </p>
    <pre><code class="prism language-objc">NSCondition <span class="token operator">*</span>condition <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSCondition alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 生产者线程</span>
<span class="token punctuation">[</span>condition lock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 修改共享数据</span>
<span class="token punctuation">[</span>condition signal<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 或 [condition broadcast]</span>
<span class="token punctuation">[</span>condition unlock<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 消费者线程</span>
<span class="token punctuation">[</span>condition lock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token comment">/* 条件不满足 */</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">[</span>condition wait<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 等待通知</span>
<span class="token punctuation">}</span>
<span class="token comment">// 临界区代码</span>
<span class="token punctuation">[</span>condition unlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：生产者-消费者模式等需要线程间通信的场景。
    </p>
    <h3>
     <a id="38_NSRecursiveLock_457">
     </a>
     3.8 NSRecursiveLock
    </h3>
    <p>
     递归锁允许同一线程多次获取锁，而不会导致死锁。
    </p>
    <pre><code class="prism language-objc">NSRecursiveLock <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSRecursiveLock alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 第一次加锁</span>
<span class="token punctuation">[</span>lock lock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 可以再次获取同一把锁而不会死锁</span>
<span class="token punctuation">[</span>lock lock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区代码</span>
<span class="token punctuation">[</span>lock unlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>lock unlock<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 需要平衡调用unlock</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：需要在递归调用或嵌套调用中使用锁的场景。
    </p>
    <h3>
     <a id="39_synchronized_475">
     </a>
     3.9 @synchronized
    </h3>
    <p>
     Objective-C提供的语言级同步原语，使用简单但性能相对较低。
    </p>
    <pre><code class="prism language-objc"><span class="token operator">@</span><span class="token function">synchronized</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 临界区代码</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：对性能要求不高的简单同步场景，或原型开发。
    </p>
    <h3>
     <a id="310__atomic__487">
     </a>
     3.10 原子属性 (atomic) 实现原理
    </h3>
    <p>
     Objective-C中的属性可以声明为atomic，保证读写操作的原子性：
    </p>
    <pre><code class="prism language-objc"><span class="token keyword">@property</span> <span class="token punctuation">(</span>atomic<span class="token punctuation">,</span> strong<span class="token punctuation">)</span> NSString <span class="token operator">*</span>name<span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      实现原理
     </strong>
     ：编译器会为atomic属性生成访问器方法，使用自旋锁/互斥锁确保读写操作的原子性。
    </p>
    <p>
     <strong>
      限制
     </strong>
     ：atomic只保证单个属性的读写原子性，不保证相关操作的原子性。例如，对数组的原子性读写不保证数组内容的访问也是原子的。
    </p>
    <h3>
     <a id="311__499">
     </a>
     3.11 读写安全方案
    </h3>
    <p>
     除了互斥锁外，还有专门针对读多写少场景优化的读写锁：
    </p>
    <h5>
     <a id="pthread_rwlock_503">
     </a>
     pthread_rwlock
    </h5>
    <p>
     读写锁允许多个线程同时读取共享资源，但写操作需要独占访问。
    </p>
    <pre><code class="prism language-objc">pthread_rwlock_t rwlock<span class="token punctuation">;</span>
<span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 读锁（共享）</span>
<span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 读取操作</span>
<span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 写锁（独占）</span>
<span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 写入操作</span>
<span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 销毁锁</span>
<span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h5>
     <a id="dispatch_barrier_async_525">
     </a>
     dispatch_barrier_async：异步栅栏调用
    </h5>
    <p>
     GCD提供的栅栏函数可以用于实现高效的读写分离：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 创建并发队列</span>
dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">"com.example.rwQueue"</span><span class="token punctuation">,</span> DISPATCH_QUEUE_CONCURRENT<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 读操作（多个可并发执行）</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 读取操作</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 写操作（栅栏函数，保证独占访问）</span>
<span class="token function">dispatch_barrier_async</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 写入操作</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     栅栏函数的工作原理是：
    </p>
    <ol>
     <li>
      等待队列中已有的任务完成
     </li>
     <li>
      独占式执行栅栏任务
     </li>
     <li>
      栅栏任务完成后，后续的普通任务才能执行
     </li>
    </ol>
    <p>
     这种方式非常适合读多写少的场景，能够提供极高的并发性能。
    </p>
    <h2>
     <a id="4__552">
     </a>
     4. 常见陷阱
    </h2>
    <h3>
     <a id="41__554">
     </a>
     4.1 死锁情况及预防
    </h3>
    <p>
     死锁发生在两个或多个线程互相等待对方释放锁的情况。最常见的死锁场景：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 主线程</span>
<span class="token function">dispatch_sync</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 这会导致死锁，因为主线程尝试同步等待主队列的任务，</span>
    <span class="token comment">// 而主队列的任务必须等待主线程完成当前执行</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      预防措施
     </strong>
     ：
    </p>
    <ol>
     <li>
      避免在持有锁时获取另一个锁
     </li>
     <li>
      如需多个锁，按固定顺序获取
     </li>
     <li>
      使用带超时的锁获取方式
     </li>
     <li>
      避免在主线程上同步派发到主队列
     </li>
     <li>
      使用GCD的dispatch_group或信号量来协调多个异步操作
     </li>
    </ol>
    <h3>
     <a id="42__574">
     </a>
     4.2 优先级反转
    </h3>
    <p>
     当低优先级线程持有锁，高优先级线程等待该锁，而中优先级线程占用CPU时，高优先级线程会被无限期阻塞。
    </p>
    <p>
     <strong>
      解决方案
     </strong>
     ：
    </p>
    <ol>
     <li>
      使用优先级继承的锁机制
     </li>
     <li>
      避免在临界区执行耗时操作
     </li>
     <li>
      使用合适的队列优先级
     </li>
    </ol>
    <h3>
     <a id="43_UI_584">
     </a>
     4.3 主线程阻塞引起的UI卡顿
    </h3>
    <p>
     在主线程上执行耗时操作会导致UI无法响应，造成卡顿感：
    </p>
    <pre><code class="prism language-objc"><span class="token comment">// 错误示例: 主线程同步等待耗时操作</span>
NSData <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>NSData dataWithContentsOfURL<span class="token punctuation">:</span><span class="token punctuation">[</span>NSURL URLWithString<span class="token punctuation">:</span><span class="token string">@"https://example.com/large-file.zip"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      正确做法
     </strong>
     ：
    </p>
    <ol>
     <li>
      将耗时操作移至后台线程
     </li>
     <li>
      使用异步API而非同步API
     </li>
     <li>
      合理分解大任务为小任务
     </li>
     <li>
      使用Instruments等工具监测和优化主线程性能
     </li>
    </ol>
    <pre><code class="prism language-objc"><span class="token comment">// 正确示例: 异步执行耗时操作，完成后回到主线程更新UI</span>
<span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span>QOS_CLASS_UTILITY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
    NSData <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>NSData dataWithContentsOfURL<span class="token punctuation">:</span><span class="token punctuation">[</span>NSURL URLWithString<span class="token punctuation">:</span><span class="token string">@"https://example.com/large-file.zip"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token function">dispatch_async</span><span class="token punctuation">(</span><span class="token function">dispatch_get_main_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 更新UI</span>
        <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>imageView setImage<span class="token punctuation">:</span><span class="token punctuation">[</span>UIImage imageWithData<span class="token punctuation">:</span>data<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h2>
     <a id="_612">
     </a>
     总结
    </h2>
    <p>
     iOS提供了多种并发编程和线程安全的机制，从底层的pthread到高级的GCD和NSOperation。选择合适的机制需要考虑以下因素：
    </p>
    <ol>
     <li>
      <strong>
       性能需求
      </strong>
      ：对于性能要求极高的场景，考虑os_unfair_lock或dispatch_semaphore；对于一般场景，NSLock和串行队列足够。
     </li>
     <li>
      <strong>
       编程范式
      </strong>
      ：如果偏好面向对象的API，选择NSOperation和NSLock系列；如果偏好函数式编程，选择GCD。
     </li>
     <li>
      <strong>
       任务特性
      </strong>
      ：如果需要复杂的任务依赖和取消机制，选择NSOperation；如果是简单的并发任务，GCD更简洁。
     </li>
     <li>
      <strong>
       同步需求
      </strong>
      ：读多写少场景推荐读写锁或栅栏函数；需要线程通信的场景适合条件变量。
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6a7364303931352f:61727469636c652f64657461696c732f313436323634323231" class_="artid" style="display:none">
 </p>
</div>


