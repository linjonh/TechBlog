---
layout: post
title: "Tengine高性能Web-服务器与反向代理"
date: 2025-03-16 10:04:45 +0800
description: "user a a;"
keywords: "Tengine：高性能Web 服务器与反向代理"
categories: ['未分类']
tags: ['运维', '服务器', '前端']
artid: "146290981"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146290981
    alt: "Tengine高性能Web-服务器与反向代理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146290981
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146290981
cover: https://bing.ee123.net/img/rand?artid=146290981
image: https://bing.ee123.net/img/rand?artid=146290981
img: https://bing.ee123.net/img/rand?artid=146290981
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Tengine：高性能Web 服务器与反向代理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="Nginx%E5%92%8CTengine" name="Nginx%E5%92%8CTengine">
     Nginx和Tengine
    </h2>
    <h3 id="Nginx" name="Nginx">
     Nginx
    </h3>
    <p>
     Nginx ("engine x") 是一个高性能的
     <strong>
      HTTP
     </strong>
     和
     <strong>
      反向代理
     </strong>
     服务器，也是一个 IMAP/POP3/SMTP 代理服务器。
    </p>
    <p>
     •第一个公开版本0.1.0发布于2004年10月4日。
    </p>
    <p>
     其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名
    </p>
    <p>
     官方测试nginx能够支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定
    </p>
    <p>
     2011年6月1日，nginx 1.0.4发布。
    </p>
    <p>
     Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，
    </p>
    <p>
     其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：新浪、网易、腾讯等。
    </p>
    <p>
     功能：
    </p>
    <ul>
     <li>
      <p>
       web服务器
      </p>
     </li>
     <li>
      <p>
       web reverse proxy
      </p>
     </li>
     <li>
      <p>
       smtp reverse proxy
      </p>
     </li>
    </ul>
    <h3 id="Nginx%E5%92%8Capache%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" name="Nginx%E5%92%8Capache%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">
     Nginx和apache的优缺点
    </h3>
    <h4 id="nginx%E7%9B%B8%E5%AF%B9%E4%BA%8Eapache%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A" name="nginx%E7%9B%B8%E5%AF%B9%E4%BA%8Eapache%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A">
     nginx相对于apache的优点：
    </h4>
    <ul>
     <li>
      <p>
       高性能：Nginx 是一个轻量级、高性能的 Web 服务器，在处理静态内容和高并发请求时表现优秀，能够更有效地利用服务器资源，降低服务器负载。
      </p>
     </li>
     <li>
      <p>
       高并发处理能力：Nginx 使用事件驱动架构，能够更有效地处理大量并发连接，适合高流量的网站和应用。
      </p>
     </li>
     <li>
      <p>
       微服务支持：Nginx 提供了丰富的功能和模块，可以用于反向代理、负载均衡、缓存等，支持微服务架构的部署。
      </p>
     </li>
     <li>
      <p>
       低内存消耗：相比于 Apache，Nginx 的内存消耗更低，可以在较少的资源下运行更多的并发连接。
      </p>
     </li>
     <li>
      <p>
       配置灵活性：Nginx 的配置文件结构简单清晰，支持模块化的配置和灵活的重定向规则，方便管理员进行定制化配置。
      </p>
     </li>
     <li>
      <p>
       社区活跃，各种高性能模块出品迅速
      </p>
     </li>
    </ul>
    <h4 id="apache%20%E7%9B%B8%E5%AF%B9%E4%BA%8Enginx%20%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A" name="apache%20%E7%9B%B8%E5%AF%B9%E4%BA%8Enginx%20%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A">
     apache 相对于nginx 的优点：
    </h4>
    <ul>
     <li>
      <p>
       rewrite ，比nginx 的rewrite 强大
      </p>
     </li>
     <li>
      <p>
       模块超多，基本想到的都可以找到
      </p>
     </li>
     <li>
      <p>
       少bug ，nginx 的bug 相对较多
      </p>
     </li>
    </ul>
    <p>
     Nginx 配置简洁, Apache 复杂
    </p>
    <p>
     最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；
    </p>
    <p>
     nginx是异步的，多个连接（万级别）可以对应一个进程
    </p>
    <h2 id="Nginx%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98" name="Nginx%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">
     Nginx解决的问题
    </h2>
    <ul>
     <li>
      <p>
       <strong>
        高并发处理
       </strong>
       ：Nginx采用了事件驱动模型，能够有效地处理大量并发请求，不会因为高流量而崩溃。
      </p>
     </li>
     <li>
      <p>
       <strong>
        反向代理
       </strong>
       ：Nginx可以作为反向代理服务器，将请求转发给后端的应用服务器，实现负载均衡和提高性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        静态资源服务
       </strong>
       ：Nginx对静态文件的处理效率非常高，可以快速地提供静态文件的访问服务，减轻后端应用服务器的负担。
      </p>
     </li>
     <li>
      <p>
       <strong>
        安全性
       </strong>
       ：Nginx具有丰富的安全功能，包括访问控制、防止DDoS攻击、SSL/TLS 加密等，可以帮助保护网站免受恶意攻击。
      </p>
     </li>
     <li>
      <p>
       <strong>
        高可靠性
       </strong>
       ：Nginx具有高可靠性和稳定性，能够持续运行长时间而不会出现问题，适用于大型生产环境。
      </p>
     </li>
    </ul>
    <h2 id="%E5%AE%89%E8%A3%85" name="%E5%AE%89%E8%A3%85">
     安装
    </h2>
    <h3 id="%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" name="%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">
     准备工作
    </h3>
    <h4 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" name="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">
     操作系统
    </h4>
    <p>
     最好使用linux操作系统，课上使用VirtualBox或VMware虚拟机搭建centos6.x做实验。
    </p>
    <p>
     系统依赖组件
     <code>
      gcc openssl-devel pcre-devel zlib-devel
     </code>
    </p>
    <p>
     安装：
     <code>
      yum install gcc openssl-devel pcre-devel zlib-devel
     </code>
    </p>
    <h4 id="Tengine%E4%B8%8B%E8%BD%BD%E5%92%8C%E6%96%87%E6%A1%A3" name="Tengine%E4%B8%8B%E8%BD%BD%E5%92%8C%E6%96%87%E6%A1%A3">
     Tengine下载和文档
    </h4>
    <p>
     <a href="http://tengine.taobao.org/" rel="nofollow" title="The Tengine Web Server">
      The Tengine Web Server
     </a>
    </p>
    <h4 id="Nginx%E5%AE%98%E7%BD%91%E5%92%8C%E6%96%87%E6%A1%A3" name="Nginx%E5%AE%98%E7%BD%91%E5%92%8C%E6%96%87%E6%A1%A3">
     Nginx官网和文档
    </h4>
    <p>
     <a href="http://nginx.org/" rel="nofollow" title="http://nginx.org">
      http://nginx.org
     </a>
    </p>
    <p>
     上传Nginx压缩包到服务器，一般安装在/usr/local目录下
    </p>
    <h4 id="%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85" name="%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85">
     编译安装
    </h4>
    <pre><code class="hljs">./ configure --prefix=/安装路径

make &amp;&amp; make install</code></pre>
    <h2 id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" name="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">
     启动服务
    </h2>
    <h3 id="%E8%84%9A%E6%9C%AC%E8%87%AA%E5%90%AF%E5%8A%A8" name="%E8%84%9A%E6%9C%AC%E8%87%AA%E5%90%AF%E5%8A%A8">
     脚本自启动
    </h3>
    <p>
     拷贝附件提供的Nginx启动脚本文件内容到
     <code>
      /etc/init.d/nginx
     </code>
     这个文件中
    </p>
    <p>
     目录下如果没有这个文件的话需要手动创建
    </p>
    <h4 id="%E4%BF%AE%E6%94%B9%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90" name="%E4%BF%AE%E6%94%B9%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90">
     修改可执行权限
    </h4>
    <p>
     chmod 777 nginx
    </p>
    <h4 id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" name="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">
     启动服务
    </h4>
    <p>
     service Nginx start 启动服务
    </p>
    <p>
     service Nginx stop 停止
    </p>
    <p>
     service Nginx status 状态
    </p>
    <p>
     service Nginx reload 动态重载配置文件
    </p>
    <h4 id="%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%9A" name="%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%9A">
     脚本内容：
    </h4>
    <pre><code class="hljs">#!/bin/sh
#
# nginx - this script starts and stops the nginx daemon
#
# chkconfig:   - 85 15 
# description:  Nginx is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /etc/nginx/nginx.conf
# config:      /etc/sysconfig/nginx
# pidfile:     /var/run/nginx.pid
 
# Source function library.
. /etc/rc.d/init.d/functions
 
# Source networking configuration.
. /etc/sysconfig/network
 
# Check that networking is up.
[ "$NETWORKING" = "no" ] &amp;&amp; exit 0
 
nginx="/usr/local/tengine/sbin/nginx"
prog=$(basename $nginx)
 
NGINX_CONF_FILE="/usr/local/tengine/conf/nginx.conf"
 
[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx
 
lockfile=/var/lock/subsys/nginx
 
make_dirs() {
   # make required directories
   user=`nginx -V 2&gt;&amp;1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`
   options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'`
   for opt in $options; do
       if [ `echo $opt | grep '.*-temp-path'` ]; then
           value=`echo $opt | cut -d "=" -f 2`
           if [ ! -d "$value" ]; then
               # echo "creating" $value
               mkdir -p $value &amp;&amp; chown -R $user $value
           fi
       fi
   done
}
 
start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    make_dirs
    echo -n $"Starting $prog: "
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;&amp; touch $lockfile
    return $retval
}
 
stop() {
    echo -n $"Stopping $prog: "
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile
    return $retval
}
 
restart() {
    configtest || return $?
    stop
    sleep 1
    start
}
 
reload() {
    configtest || return $?
    echo -n $"Reloading $prog: "
    killproc $nginx -HUP
    RETVAL=$?
    echo
}
 
force_reload() {
    restart
}
 
configtest() {
  $nginx -t -c $NGINX_CONF_FILE
}
 
rh_status() {
    status $prog
}
 
rh_status_q() {
    rh_status &gt;/dev/null 2&gt;&amp;1
}
 
case "$1" in
    start)
        rh_status_q &amp;&amp; exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
            ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"
        exit 2
esac
</code></pre>
    <h2 id="Nginx%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90" name="Nginx%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90">
     Nginx配置解析
    </h2>
    <h3 id="%E5%AE%9A%E4%B9%89Nginx%E8%BF%90%E8%A1%8C%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84" name="%E5%AE%9A%E4%B9%89Nginx%E8%BF%90%E8%A1%8C%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84">
     定义Nginx运行的用户和用户组
    </h3>
    <pre><code class="hljs">user a a;`</code></pre>
    <h3 id="%E8%BF%9B%E7%A8%8B%E6%95%B0" name="%E8%BF%9B%E7%A8%8B%E6%95%B0">
     进程数
    </h3>
    <p>
     建议设置为等于CPU总核心数。
    </p>
    <p>
     <code>
      worker_processes 12;
     </code>
    </p>
    <h3 id="%E5%85%A8%E5%B1%80%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97" name="%E5%85%A8%E5%B1%80%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97">
     全局错误日志
    </h3>
    <p>
     全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]
    </p>
    <p>
     <code>
      error_log /var/log/nginx/error.log info;
     </code>
    </p>
    <h3 id="%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6" name="%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6">
     进程文件
    </h3>
    <p>
     <code>
      pid /var/run/nginx.pid;
     </code>
    </p>
    <h3 id="%E6%89%93%E5%BC%80%E7%9A%84%E6%9C%80%E5%A4%9A%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" name="%E6%89%93%E5%BC%80%E7%9A%84%E6%9C%80%E5%A4%9A%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">
     打开的最多文件描述符
    </h3>
    <p>
     一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
    </p>
    <p>
     <code>
      worker_rlimit_nofile 65535;
     </code>
    </p>
    <h3 id="event" name="event">
     event
    </h3>
    <h4 id="%E5%8D%95%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0" name="%E5%8D%95%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0">
     单个进程最大连接数
    </h4>
    <p>
     并发总数是 worker_processes 和 worker_connections 的乘积
    </p>
    <p>
     即 max_clients = worker_processes * worker_connections
    </p>
    <p>
     在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 为什么上面反向代理要除以4，应该说是一个经验值根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000worker_connections 值的设置跟物理内存大小有关
    </p>
    <p>
     因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数
    </p>
    <pre><code class="hljs">工作模式与连接数上限
events
{
参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。
use epoll;
单个进程最大连接数（最大连接数=连接数*进程数）
worker_connections 65535;
}
</code></pre>
    <p>
     <strong>
      可以打开的文件句柄数是多少
     </strong>
    </p>
    <p>
     <code>
      –$ cat /proc/sys/fs/file-max
     </code>
    </p>
    <p>
     输出：
     <code>
      97320
     </code>
    </p>
    <p>
     并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内
    </p>
    <p>
     所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置,使得并发总数小于操作系统可以打开的最大文件数目
    </p>
    <p>
     – # 其实质也就是根据主机的物理CPU和内存进行配置
    </p>
    <p>
     当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。
    </p>
    <p>
     <strong>
      查看系统限制
     </strong>
     <code>
      ulimit -a
     </code>
    </p>
    <h4 id="%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6" name="%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6" style="background-color:transparent">
     打开文件句柄数量限制
    </h4>
    <p>
     是Linux操作系统对一个进程打开的文件句柄数量的限制(也包含打开的SOCKET数量，可影响MySQL的并发连接数目)
    </p>
    <p>
     系统总限制：
     <code>
      /proc/sys/fs/file-max
     </code>
     当前使用句柄数：
     <code>
      /proc/sys/fs/file-nr
     </code>
    </p>
    <p>
     修改句柄数：
     <code>
      ulimit -SHn 65535
     </code>
    </p>
    <h3 id="http" name="http">
     http
    </h3>
    <p>
    </p>
    <p>
     include mime.types; #文件扩展名与文件类型映射表
    </p>
    <p>
     default_type application/octet-stream; #默认文件类型
    </p>
    <p>
     charset utf-8; #默认编码
    </p>
    <p>
     client_header_buffer_size 32k; #上传文件大小限制
    </p>
    <h4 id="sendfile" name="sendfile">
     sendfile
    </h4>
    <p>
     sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    </p>
    <p>
     sendfile()还能够用来在两个文件夹之间移动数据
    </p>
    <p>
     <code>
      tcp_nopush
     </code>
     在linux/Unix系统中优化tcp数据传输，仅在sendfile开启时有效
    </p>
    <p>
     <code>
      autoindex on;
     </code>
     #开启目录列表访问，合适下载服务器，默认关闭。
    </p>
    <p>
     <code>
      keepalive_timeout 120;
     </code>
     #长连接超时时间，单位是秒
    </p>
    <h4 id="gzip" name="gzip">
     gzip
    </h4>
    <p>
     <code>
      gzip on;
     </code>
     开启gzip压缩输出
    </p>
    <p>
     <code>
      gzip_min_length 1k;
     </code>
     设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于2k的字节数，小于2k可能会越压越大。
    </p>
    <p>
     <code>
      gzip_buffers 4 16k;
     </code>
     设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。
    </p>
    <p>
     <code>
      gzip_http_version 1.0;
     </code>
     压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
    </p>
    <p>
     <code>
      gzip_comp_level 2;
     </code>
     压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间
    </p>
    <p>
     <code>
      gzip_types text/plain application/x-javascript text/css application/xml;
     </code>
     #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
    </p>
    <p>
     默认值: gzip_types text/html (默认不对js/css文件进行压缩)
    </p>
    <p>
     压缩类型，匹配MIME类型进行压缩
    </p>
    <p>
     设置哪压缩种文本文件可参考 conf/mime.types
    </p>
    <p>
     <code>
      gzip_disable "MSIE [1-6]\.";
     </code>
     E6及以下禁止压缩
    </p>
    <p>
     <code>
      gzip_vary on;
     </code>
     给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本
    </p>
    <h3 id="server" name="server">
     server
    </h3>
    <p>
     <code>
      listen 80;
     </code>
     监听端口
     <code>
      server_name www.mashibing.com mashibing.com;
     </code>
     域名可以有多个，用空格隔开
    </p>
    <p>
     <code>
      charset koi8-r;
     </code>
     编码集
    </p>
    <pre><code class="hljs">日志相关
access_log  "pipe:rollback logs/host.access_log interval=1d baknum=7 maxsize=2G"  main;</code></pre>
    <p>
     <code>
      index index.html index.htm index.jsp;
     </code>
     默认页
     <code>
      root /data/a/ha97;
     </code>
     主目录
    </p>
    <h4 id="%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" name="%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA">
     虚拟主机
    </h4>
    <p>
     虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供www服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响的
    </p>
    <p>
    </p>
    <p>
     通过nginx可以实现虚拟主机的配置，nginx支持三种类型的虚拟主机配置
    </p>
    <ul>
     <li>
      <p>
       基于ip的虚拟主机， （一块主机绑定多个ip地址）
      </p>
     </li>
     <li>
      <p>
       基于域名的虚拟主机（servername）
      </p>
     </li>
     <li>
      <p>
       基于端口的虚拟主机（listen如果不写ip端口模式）
      </p>
     </li>
    </ul>
    <pre><code class="hljs">http{
	server{
		#表示一个虚拟主机
	}
}</code></pre>
    <h6 id="location" name="location">
     location
    </h6>
    <p>
     映射/虚拟目录
    </p>
    <pre><code class="hljs">location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}</code></pre>
    <p>
     location [ = | ~ | ~* | ^~ ] uri { ... }
    </p>
    <p>
     <code>
      location URI {}
     </code>
     对当前路径及子路径下的所有对象都生效；
    </p>
    <p>
     <code>
      location = URI {}
     </code>
     注意URL最好为具体路径。 精确匹配指定的路径，不包括子路径，因此，只对当前资源生效；
    </p>
    <p>
     <code>
      location ~ URI {} location ~* URI {}
     </code>
     模式匹配URI，此处的URI可使用正则表达式，~区分字符大小写，~*不区分字符大小写；
    </p>
    <p>
     <code>
      location ^~ URI {}
     </code>
     禁用正则表达式
    </p>
    <p>
     <strong>
      优先级
     </strong>
     ：= &gt; ^~ &gt; ~|~* &gt; /|/dir/
    </p>
    <h6 id="location%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99" name="location%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99">
     location配置规则
    </h6>
    <p>
     location 的执行逻辑跟 location 的编辑顺序无关。 矫正：这句话不全对，“普通 location ”的匹配规则是“最大前缀”，因此“普通 location ”的确与 location 编辑顺序无关；
    </p>
    <p>
     但是“正则 location ”的匹配规则是“顺序匹配，且只要匹配到第一个就停止后面的匹配”；
    </p>
    <p>
     “普通location ”与“正则 location ”之间的匹配顺序是？先匹配普通 location ，再“考虑”匹配正则 location 。
    </p>
    <p>
     注意这里的“考虑”是“可能”的意思，也就是说匹配完“普通 location ”后，有的时候需要继续匹配“正则 location ”，有的时候则不需要继续匹配“正则 location ”。两种情况下，不需要继续匹配正则 location ：
    </p>
    <ul>
     <li>
      <p>
       （ 1 ）当普通 location 前面指定了“ ^~ ”，特别告诉 Nginx 本条普通 location 一旦匹配上，则不需要继续正则匹配；
      </p>
     </li>
     <li>
      <p>
       （ 2 ）当普通location 恰好严格匹配上，不是最大前缀匹配，则不再继续匹配正则
      </p>
     </li>
    </ul>
    <h3 id="IP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6" name="IP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">
     IP访问控制
    </h3>
    <pre><code class="hljs">location  {
	   deny  IP /IP段
	   deny  192.168.1.101;
	   allow 192.168.1.0/24;192.168.0.0/16;192.0.0.0/8
	}
</code></pre>
    <h3 id="%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E8%AE%BF%E9%97%AE" name="%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E8%AE%BF%E9%97%AE" style="background-color:transparent">
     用户认证访问
    </h3>
    <p>
     模块ngx_http_auth_basic_module 允许使用“HTTP基本认证”协议验证用户名和密码来限制对资源的访问。
    </p>
    <pre><code class="hljs">        location ~ (.*)\.avi$ {
                 auth_basic  "closed site";
                 auth_basic_user_file conf/users;
        }
</code></pre>
    <h3 id="httpd-tools" name="httpd-tools">
     <strong>
      httpd-tools
     </strong>
    </h3>
    <pre><code class="hljs">yum install httpd

htpasswd -c -d /usr/local/users zhangyang</code></pre>
    <h3 id="nginx%E8%AE%BF%E9%97%AE%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7" name="nginx%E8%AE%BF%E9%97%AE%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7">
     nginx访问状态监控
    </h3>
    <pre><code class="hljs">location /basic_status {
    stub_status on;
}</code></pre>
    <h3 id="%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" name="%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">
     反向代理
    </h3>
    <p>
     通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中由代理服务器向Internet上的web服务器发起请求，最终达到客户机上网的目的。
    </p>
    <p>
     反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="267" src="https://i-blog.csdnimg.cn/direct/9e32c671498d49868726727651cecebf.png" width="427"/>
    </p>
    <h4 id="%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BB%93%E6%9E%84" name="%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BB%93%E6%9E%84">
     经典的反向代理结构
    </h4>
    <p>
     <img alt="" height="300" src="https://i-blog.csdnimg.cn/direct/027aa0fc42334d999ef683616ce3b112.png" width="462"/>
    </p>
    <blockquote>
     <p>
      Proxy_pass http://192.168.43.110/
     </p>
    </blockquote>
    <p>
     301重定向问题
    </p>
    <h4 id="upstream" name="upstream" style="background-color:transparent">
     upstream
    </h4>
    <p>
     反向代理配合upstream使用
    </p>
    <pre><code class="hljs">  upstream httpds {
    server 192.168.50.152:80;
    server 192.168.50.153:80;
}</code></pre>
    <h5 id="weight(%E6%9D%83%E9%87%8D)" name="weight(%E6%9D%83%E9%87%8D)">
     <strong>
      weight(权重)
     </strong>
    </h5>
    <p>
     指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
    </p>
    <pre><code class="hljs">upstream httpds {
    server 127.0.0.1:8050       weight=10 down;
    server 127.0.0.1:8060       weight=1;
     server 127.0.0.1:8060      weight=1 backup;
}</code></pre>
    <ul>
     <li>
      <p>
       down：表示当前的server暂时不参与负载
      </p>
     </li>
     <li>
      <p>
       weight：默认为1.weight越大，负载的权重就越大。
      </p>
     </li>
     <li>
      <p>
       backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。
      </p>
     </li>
    </ul>
    <h5 id="max_conns" name="max_conns">
     <strong>
      max_conns
     </strong>
    </h5>
    <p>
     可以根据服务的好坏来设置最大连接数，防止挂掉，比如1000，我们可以设置800
    </p>
    <pre><code class="hljs">upstream httpds {
    server 127.0.0.1:8050    weight=5  max_conns=800;
    server 127.0.0.1:8060    weight=1;
}</code></pre>
    <h5 id="max_fails%E3%80%81%20fail_timeout" name="max_fails%E3%80%81%20fail_timeout">
     <strong>
      max_fails、 fail_timeout
     </strong>
    </h5>
    <p>
     max_fails:失败多少次 认为主机已挂掉则，踢出，公司资源少的话一般设置2~3次，多的话设置1次
    </p>
    <p>
     max_fails=3 fail_timeout=30s代表在30秒内请求某一应用失败3次，认为该应用宕机，后等待30秒，这期间内不会再把新请求发送到宕机应用，而是直接发到正常的那一台，时间到后再有请求进来继续尝试连接宕机应用且仅尝试1次，如果还是失败，则继续等待30秒...以此循环，直到恢复。
    </p>
    <pre><code class="hljs">upstream httpds {
    server 127.0.0.1:8050    weight=1  max_fails=1  fail_timeout=20;
    server 127.0.0.1:8060    weight=1;
}</code></pre>
    <h5 id="%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95" name="%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">
     负载均衡算法
    </h5>
    <p>
     <strong>
      轮询+weight
     </strong>
     <strong>
      ip_hash
     </strong>
     <strong>
      url_hash
     </strong>
     <strong>
      least_conn
     </strong>
     <strong>
      least_time
     </strong>
    </p>
    <h4 id="%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%9D%97" name="%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%9D%97">
     健康检查模块
    </h4>
    <p>
     配置一个status的location
    </p>
    <pre><code class="hljs">location /status {
            check_status;
 
        }
</code></pre>
    <p>
     在upstream配置如下
    </p>
    <pre><code class="hljs">check interval=3000 rise=2 fall=5 timeout=1000 type=http;
check_http_send "HEAD / HTTP/1.0\r\n\r\n";
check_http_expect_alive http_2xx http_3xx;
</code></pre>
    <h3 id="session%E5%85%B1%E4%BA%AB" name="session%E5%85%B1%E4%BA%AB">
     session共享
    </h3>
    <h4 id="Memcached" name="Memcached">
     Memcached
    </h4>
    <h5 id="%E5%AE%89%E8%A3%85" name="%E5%AE%89%E8%A3%85">
     安装
    </h5>
    <ul>
     <li>
      <p>
       安装libevent
      </p>
     </li>
     <li>
      <p>
       安装memcached
      </p>
     </li>
    </ul>
    <p>
     可以用yum方式安装
     <code>
      yum –y install memcached
     </code>
    </p>
    <h5 id="%E5%90%AF%E5%8A%A8memcached" name="%E5%90%AF%E5%8A%A8memcached">
     启动memcached
    </h5>
    <pre><code class="hljs">memcached -d -m 128 -u root -l 192.168.43.151 -p 11210 -c 256 -P /tmp/memcached.pid
memcached-tool 192.168.2.11:11211
参数解释：
	-d:后台启动服务
	-m:缓存大小
	-p：端口
	-l:IP
	-P:服务器启动后的系统进程ID，存储的文件
	-u:服务器启动是以哪个用户名作为管理用户</code></pre>
    <h5 id="Nginx%E9%85%8D%E7%BD%AE" name="Nginx%E9%85%8D%E7%BD%AE">
     Nginx配置
    </h5>
    <pre><code class="hljs">upstream tomcat{
        server 192.168.1.52:8080;
        server 192.168.1.53:8080;
      }

        location /tomcat {
        proxy_pass http://tomcat/;
      </code></pre>
    <h4 id="Tomcat%E9%85%8D%E7%BD%AE" name="Tomcat%E9%85%8D%E7%BD%AE">
     Tomcat配置
    </h4>
    <p>
     到tomcat的lib下，jar包见附件
    </p>
    <p>
     每个tomcat里面的context.xml中加入
    </p>
    <p>
    </p>
    <pre><code class="hljs">&lt;Manager className="de.javakaffee.web.msm.MemcachedBackupSessionManager" 
	memcachedNodes="n1:192.168.50.151:11211" 
    sticky="false" 
    lockingMode="auto"
    sessionBackupAsync="false"
	requestUriIgnorePattern=".*\.(ico|png|gif|jpg|css|js)$"
    sessionBackupTimeout="1000" transcoderFactoryClass="de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory" 
/&gt;</code></pre>
    <h4 id="http_proxy%20%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98" name="http_proxy%20%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98">
     http_proxy 本地磁盘缓存
    </h4>
    <pre><code class="hljs">proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;
server {
     set $upstream http://ip:port
          location / {
                   proxy_cache my_cache;
                   proxy_pass $upstream;
                }
}


	/path/to/cache  #本地路径，用来设置Nginx缓存资源的存放地址
	levels          #默认所有缓存文件都放在同一个/path/to/cache下，但是会影响缓存的性能，因此通常会在/path/to/cache下面建立子目录用来分别存放不同的文件。假设levels=1:2，Nginx为将要缓存的资源生成的key为f4cd0fbc769e94925ec5540b6a4136d0，那么key的最后一位0，以及倒数第2-3位6d作为两级的子目录，也就是该资源最终会被缓存到/path/to/cache/0/6d目录中
	key_zone        #在共享内存中设置一块存储区域来存放缓存的key和metadata（类似使用次数），这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key
	max_size        #最大cache空间，如果不指定，会使用掉所有disk space，当达到配额后，会删除最少使用的cache文件
	inactive        #未被访问文件在缓存中保留时间，本配置中如果60分钟未被访问则不论状态是否为expired，缓存控制程序会删掉文件。inactive默认是10分钟。需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件
	use_temp_path   #如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，official建议为off，避免文件在不同文件系统中不必要的拷贝
	proxy_cache     #启用proxy cache，并指定key_zone。另外，如果proxy_cache off表示关闭掉缓存。</code></pre>
    <h2 id="%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8" name="%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8">
     开机启动
    </h2>
    <pre><code class="hljs">chkconfig --list
chkconfig --add nginx
chkconfig nginx on</code></pre>
    <h2 id="%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95" name="%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95">
     虚拟目录
    </h2>
    <pre><code class="hljs">   location /d{
        alias  /var/data/d1;
        index  index.html index.htm a.html;
    }</code></pre>
    <h2 id="%E8%87%AA%E5%8A%A8%E7%B4%A2%E5%BC%95" name="%E8%87%AA%E5%8A%A8%E7%B4%A2%E5%BC%95">
     自动索引
    </h2>
    <pre><code class="hljs"> location /art {
        alias  /var/data/d1/;
          autoindex on;
   
    }</code></pre>
    <h2 id="%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB" name="%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB">
     动静分离
    </h2>
    <pre><code class="hljs">   location / {
		proxy_pass http://192.168.0.11:803;
    
        }

     
     
     location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|html|htm|css|js)$ {
            root  /var/data/d1/;
	       
        }</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33333337333630392f:61727469636c652f64657461696c732f313436323930393831" class_="artid" style="display:none">
 </p>
</div>


