---
layout: post
title: "测试工具使用"
date: 2024-03-27 08:35:50 +0800
description: "Charles操作步骤:一、修改request请求参数 值\t在接口处鼠标右击 选择breakpoin"
keywords: "火狐浏览器 修改请求返回结果"
categories: ['未分类']
tags: ['无标签']
artid: "113971439"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=113971439
  alt: "测试工具使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=113971439
featuredImagePreview: https://bing.ee123.net/img/rand?artid=113971439
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     测试工具使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     Charles操作步骤:
    </h4>
    <p>
     一、修改request请求参数 值
    </p>
    <ol>
     <li>
      <p>
       在接口处鼠标右击 选择breakpoints(断言)
      </p>
     </li>
     <li>
      <p>
       点击proxy(代理)选择Breakpoint settings(设置断点)
      </p>
     </li>
     <li>
      <p>
       点击钻到的接口 修改query(参数)为* request勾选 输完值 点击ok保存变量
      </p>
     </li>
     <li>
      <p>
       重新请求接口 edit request(编辑要求) 在 channelID(通道) 点击具体值 修改 添加或删除
      </p>
     </li>
     <li>
      <p>
       关掉 break point(断点) 点击 abort(终止)
      </p>
     </li>
    </ol>
    <p>
     二、修改request请求参数值
    </p>
    <ol>
     <li>
      <p>
       选中接口对应的request值 点击rewrite按钮 (小铅笔)
      </p>
     </li>
     <li>
      <p>
       选中需要修改的参数 点击对应值 对其修改即可
      </p>
     </li>
     <li>
      <p>
       执行后刷新 看返回结果的展示情况 (execute)
      </p>
     </li>
     <li>
      <p>
       点击execute(执行)之后 看新的response
      </p>
     </li>
    </ol>
    <p>
     三、修改返回值 response
    </p>
    <ol>
     <li>
      <p>
       选中接口右击 复制url路径 选择break points(断点)
      </p>
     </li>
     <li>
      <p>
       点击proxy(代理)选择break points settings (设置断点)
      </p>
     </li>
     <li>
      <p>
       点击接口修改query(参数)为* request勾选 点击ok保存
      </p>
     </li>
     <li>
      <p>
       重新请求接口 点击edit request 返回值所有的字符都可以修改
      </p>
     </li>
     <li>
      <p>
       刷新页面 请求接口 点击abort(终止)
      </p>
     </li>
    </ol>
    <p>
     四、修改返回值 request
    </p>
    <ol>
     <li>
      <p>
       复制response内容 保存为TXT文件 存放到本地 编码的格式为'utf-8' 否则可能会出现乱码
      </p>
     </li>
     <li>
      <p>
       接口返回值右击 选择 save response 后 选择response
      </p>
     </li>
     <li>
      <p>
       选中需要修改的response值的接口后右击 选择maplocal功能 query(参数)修改为 *
      </p>
      <p>
       (map to 下 local path 填TXT文件的绝对路径)
      </p>
     </li>
     <li>
      <p>
       修改TXT文件中 需要修改的字段值
      </p>
     </li>
     <li>
      <p>
       重新请求此接口
      </p>
     </li>
     <li>
      <p>
       完毕后 点击 tools(工具) 点击 map local 取消勾选的 enable map local
      </p>
     </li>
    </ol>
    <p>
     五、弱网测试
    </p>
    <ol>
     <li>
      <p>
       点击proxy(代理) 选择 throttle settings(节流阀调整) 勾选 enable throttling(使用节流阀) 修改 宽带: 上限值 下限值 带宽的利用率:上限值 下限值 数据传输往返延迟时间值 最大传输字节量 可靠性 网速不稳定性的占比等 点击ok保存
      </p>
     </li>
     <li>
      <p>
       打开throt setting 版本3.0是红旗 4.0的是乌龟
      </p>
     </li>
    </ol>
    <p>
     六、模拟 404/403 返回值
    </p>
    <ol>
     <li>
      <p>
       点击tools(工具)选择blacklist(黑名单)
      </p>
     </li>
     <li>
      <p>
       允许启动黑名单功能 选择接口返回值的形式 添加接口地址并保存
      </p>
     </li>
     <li>
      <p>
       选中需要返回404/403的接口 点击ok再次请求
      </p>
     </li>
    </ol>
    <p>
     七、屏蔽web网页的抓包信息
    </p>
    <ol>
     <li>
      <p>
       点击proxy(代理) 选中或取消 Windows proxy macOS proxy
      </p>
     </li>
    </ol>
    <p>
     八、抓包结果列表 只展示关注的接口
    </p>
    <ol>
     <li>
      <p>
       点击view 选择focused hosts
      </p>
     </li>
     <li>
      <p>
       点击 add 添加 协议 域名 端口号
      </p>
     </li>
     <li>
      <p>
       将 关注的接口 勾选 点击 ok 保存
      </p>
     </li>
     <li>
      <p>
       重新抓包
      </p>
     </li>
    </ol>
    <p>
     九、https抓包
    </p>
    <ol>
     <li>
      <p>
       点击help(帮助) 选择SSL Proxying 点击 install Chales root
      </p>
     </li>
     <li>
      <p>
       移动端下载证书
      </p>
     </li>
     <li>
      <p>
       点击 proxy 选择 ssl proxying setting 添加主机 为* (所有) 端口号 点击 ok 保存
      </p>
     </li>
     <li>
      <p>
       勾选添加的接口 勾选 Enable ssl proxying 点击 ok
      </p>
     </li>
    </ol>
    <p>
     十、接口压力测试
    </p>
    <ol>
     <li>
      <p>
       选择需要进行测试的接口 右键 选中repeat advance(重复之前)
      </p>
     </li>
     <li>
      <p>
       填写 迭代次数 每次迭代的并发量 每次迭代中多个请求之间的间隔时间
      </p>
      <p>
       和每次迭代之间的间隔时间
      </p>
      <p>
       3.勾选 use ranges (使用间隔时间区间) 点击ok
      </p>
     </li>
    </ol>
    <p>
    </p>
    <h3>
     jmeter相关操作
    </h3>
    <p>
     一、对数据库的操作
    </p>
    <ol>
     <li>
      <p>
       下载jmeter连接数据库的jar包 在测试计划添加数据库连接jar包
      </p>
     </li>
     <li>
      <p>
       右键添加 --&gt; 线程 --&gt; 线程组
      </p>
     </li>
     <li>
      <p>
       右键新建线程组 --&gt; 添加 --&gt; 配置元件 --&gt; JDBC connection configuration (连接配置)
      </p>
     </li>
     <li>
      <p>
       在variable name(变量名)输入要连接的数据库
      </p>
     </li>
     <li>
      <p>
       在databese URL 输入adb.mysql://端口号/库名?allowMulti Queries = true(允许执行多条sql语句)&amp;character Encoding = utf-8(解决乱码)数据库用户名/密码
      </p>
     </li>
     <li>
      <p>
       添加JDBC request 线程组右键 --&gt; 添加 --&gt; sampler --&gt; JDBC request
      </p>
     </li>
     <li>
      <p>
       在variable name(变量名) 输入与JDBC connection configuration (连接配置)同样的数据库名
      </p>
     </li>
     <li>
      <p>
       在SQL query(SQL查询)中 输入要查询的SQL语句
      </p>
     </li>
     <li>
      <p>
       添加查看结果树
      </p>
     </li>
     <li>
      <p>
       点击运行按钮
      </p>
     </li>
    </ol>
    <p>
     二、固定定时器
    </p>
    <ol>
     <li>
      <p>
       线程组 --&gt; 添加 --&gt; 定时器 --&gt; 固定定时器 --&gt; 设置线程 --&gt; 延迟(毫秒)
      </p>
     </li>
    </ol>
    <p>
     三、循环控制器
    </p>
    <ol>
     <li>
      <p>
       右键线程组 --&gt; 添加 --&gt; 逻辑控制器 --&gt; 循环控制器 --&gt; 设置循环次数
      </p>
     </li>
    </ol>
    <p>
     四、获取 Token 值
    </p>
    <ol>
     <li>
      <p>
       右键线程组 --&gt; 添加 --&gt; 取样器 --&gt; HTTP请求 --&gt; 输入 --&gt; 协议 --&gt; 服务器名称或IP端口 --&gt; 请求方式 --&gt; 路径 --&gt; 编码 --&gt; 根据需求文档传参
      </p>
     </li>
     <li>
      <p>
       右键HTTP请求 --&gt; 添加 --&gt; 后置处理器 --&gt; 正则表达式提取器 --&gt; 输入 引用名称
      </p>
      <p>
       --&gt; 正则表达式 Token(.*?) --&gt; 模板 $1$ --&gt; 匹配数字
      </p>
     </li>
     <li>
      <p>
       右键HTTP请求 --&gt; 添加 --&gt; 配置元件 --&gt; HTTP信息管理器 填入相关参数
      </p>
     </li>
     <li>
      <p>
       添加查看结果树 点击运行 查看结果
      </p>
     </li>
    </ol>
    <p>
     五、参数化关联 用户自定义变量
    </p>
    <ol>
     <li>
      <p>
       右键 --&gt; 添加 --&gt; 线程 --&gt; 线程组
      </p>
     </li>
     <li>
      <p>
       右键线程组 --&gt; 添加 --&gt; 取样器 --&gt; HTTP请求
      </p>
     </li>
     <li>
      <p>
       右键线程组 --&gt; 添加 --&gt; 配置元件 --&gt; 用户定义变量 --&gt; 添加 --&gt; 写入名称与值
      </p>
     </li>
     <li>
      <p>
       点击HTTP请求 --&gt; 引用用户定义的变量(格式为${变量名})
      </p>
     </li>
     <li>
      <p>
       右键线程组 --&gt; 添加 --&gt; 监听器 --&gt; 查看结果树
      </p>
     </li>
     <li>
      <p>
       运行 查看结果
      </p>
     </li>
    </ol>
    <p>
     六、参数化关联 CSV文件参数化
    </p>
    <ol>
     <li>
      <p>
       创建CSV文件 写入相关数据 多条数据用,(逗号)隔开
      </p>
     </li>
     <li>
      <p>
       右键线程组 --&gt; 添加 --&gt; 配置元件 --&gt; CSV set confing --&gt; 填入filename:保存信息文件的相对或绝对路径 编码 变量名 CSV文件中各列名字 用逗号隔开
      </p>
     </li>
     <li>
      <p>
       找到需要传参的HTTP请求 将具体值 改为变量引用 ${变量名}
      </p>
     </li>
     <li>
      <p>
       添加查看结果树
      </p>
     </li>
     <li>
      <p>
       运行 查看结果
      </p>
     </li>
    </ol>
    <p>
     七、性能测试
    </p>
    <ol>
     <li>
      <p>
       右键 添加 线程 线程组 设置线程数 用时 循环次数
      </p>
     </li>
     <li>
      <p>
       右键线程组 添加 取样器 HTTP请求 设置协议 服务器名称或IP端口号
      </p>
      <p>
       请求方式 路径 内容编码
      </p>
     </li>
     <li>
      <p>
       右键线程组 添加 监听器 查看结果树 聚合报告 图形结果 表格查看结果......
      </p>
     </li>
     <li>
      <p>
       运行 查看结果
      </p>
     </li>
    </ol>
    <p>
     八、断言
    </p>
    <ol>
     <li>
      <p>
       右键 添加 线程 线程组
      </p>
     </li>
     <li>
      <p>
       右键线程组 添加 取样器 HTTP请求
      </p>
     </li>
     <li>
      <p>
       右键HTTP请求 添加 断言 响应断言 设置测试字段 模式匹配规则.....点击添加 输入匹配内容......
      </p>
     </li>
     <li>
      <p>
       右键线程组 添加 监听器 断言结果 查看结果树
      </p>
     </li>
     <li>
      <p>
       运行 查看结果
      </p>
     </li>
    </ol>
    <p>
     九、脚本录制
    </p>
    <ol>
     <li>
      <p>
       创建一个Thread Group (邮件点击： Test Plan -&gt; Add -&gt; Thread Group)
      </p>
     </li>
     <li>
      <p>
       创建http 代理服务器 （邮件点击"工作台"（WorkBench） Add-&gt; Non-Test Elements -&gt; HTTP(S) Test Script Recorder）
      </p>
     </li>
     <li>
      <p>
       设置浏览器的代理服务器
      </p>
     </li>
     <li>
      <p>
       设置好后 在浏览器中访问网站
      </p>
     </li>
     <li>
      <p>
       Jmeter就能录制下来了
      </p>
     </li>
    </ol>
    <p>
     jmeter性能测试报告
    </p>
    <ol>
     <li>
      <p>
       性能测试背景
      </p>
     </li>
     <li>
      <p>
       性能测试目标
      </p>
     </li>
     <li>
      <p>
       性能测试范围
      </p>
     </li>
     <li>
      <p>
       性能名词术语约定
      </p>
     </li>
     <li>
      <p>
       被测环境系统架构
      </p>
     </li>
     <li>
      <p>
       被测环境软硬件配置： 主机 数量 用途 配置 系统
      </p>
     </li>
     <li>
      <p>
       负载机 软硬件配置
      </p>
     </li>
     <li>
      <p>
       测试数据
      </p>
     </li>
     <li>
      <p>
       硬件性能指标
      </p>
     </li>
     <li>
      <p>
       测试进度 开始时间 结束时间 测试类别 测试目的 测试结果 测试报告 测试分析 等....
      </p>
     </li>
    </ol>
    <p>
    </p>
    <h3>
     测试流程
    </h3>
    <ol>
     <li>
      <p>
       立项（确定项目要干啥）— 甲方和乙方领导以及需求人员讨论
      </p>
     </li>
     <li>
      <p>
       需求人员写需求文档（word/原型图）
      </p>
     </li>
     <li>
      <p>
       需求评审 —（本公司小组人员，项目经理，开发人员，测试人员，需求人员）
      </p>
     </li>
     <li>
      <p>
       开发测试同时进行： 开发-----详细设计 —（数据库设计） 测试-----写测试用例
      </p>
     </li>
     <li>
      <p>
       用例评审 — （本公司小组人员，项目经理，开发人员，测试人员，需求人员） （有问题进行修改，有缺陷进行添加等等）
      </p>
     </li>
     <li>
      <p>
       开发编码
      </p>
     </li>
     <li>
      <p>
       部署环境 — （window环境，linux环境）
      </p>
     </li>
     <li>
      <p>
       单元测试(方法)
      </p>
     </li>
     <li>
      <p>
       集成测试 — （postman，jmeter）
      </p>
     </li>
     <li>
      <p>
       功能测试(黑盒测试)
      </p>
     </li>
     <li>
      <p>
       bug(管理) — 禅道（缺陷报告）
      </p>
     </li>
     <li>
      <p>
       测试报告 — 测试用例总条数（包括解决bug数，遗留bug数）
      </p>
     </li>
     <li>
      <p>
       文档(测试用例测试报告，详细设计，需求文档，war)
      </p>
     </li>
     <li>
      <p>
       后期线上发现问题（不是特别大的问题）— 运维人员根据客户提供问题，提出bug(邮件发送)
      </p>
     </li>
     <li>
      <p>
       回退版本
      </p>
     </li>
    </ol>
    <p>
    </p>
    <h3>
     测试用例
    </h3>
    <p>
     <strong>
      测试用例特征:
     </strong>
    </p>
    <p>
     正确性 完整性 准确 清晰 简洁 可维护性 适应性 可重复性 可追溯性 可移植性
    </p>
    <p>
     <strong>
      测试用例特性
     </strong>
     :
    </p>
    <p>
     代表性: 能够代表并覆盖各种合理的和不合理 合法 不合法 边界和越界的 以及极限的输入数据 操作等......
    </p>
    <p>
     针对性:对程序中可能存在的错误有针对性的测试
    </p>
    <p>
     可判断性:测试执行结果的正确性是可判定的 每一个测试用例都应有相应的期待结果
    </p>
    <p>
     可重现性:对同样的测试用例 系统的执行结构应当是相同的
    </p>
    <p>
    </p>
    <p>
     测试评审的标准
    </p>
    <ol>
     <li>
      <p>
       测试用例的正确性 (测试用例不含有争议)
      </p>
     </li>
     <li>
      <p>
       测试用例是否冗余
      </p>
     </li>
     <li>
      <p>
       测试用例的覆盖率
      </p>
     </li>
     <li>
      <p>
       测试用例是否满足需求文档
      </p>
      <p>
       评审的内容有以下几个方面
      </p>
      <ol>
       <li>
        <p>
         用例设计的结构安排是否清晰、合理，是否利于高效对需求进行覆盖。 、
        </p>
       </li>
       <li>
        <p>
         优先极安排是否合理。
        </p>
       </li>
       <li>
        <p>
         是否覆盖测试需求上的所有功能点。
        </p>
       </li>
       <li>
        <p>
         用例是否具有很好可执行性。例如用例的前提条件、执行步骤、输入数据和期待结果是否清晰、正确_期待结果是否有明显的验证方法。
        </p>
       </li>
       <li>
        <p>
         是否已经删除了冗余的用例。
        </p>
       </li>
       <li>
        <p>
         是否包含充分的负面测试用例。充分的定义，如果在这里使用2&amp;8法则，那就是4倍于正面用例的数量，毕竟一个健壮的软件，其中80%的代码都是在"保护"20%的功能实现。
        </p>
       </li>
       <li>
        <p>
         是否从用户层面来设计用户使用场景和使用流程的测试用例。
        </p>
       </li>
       <li>
        <p>
         是否简洁，复用性强。例如，可将重复度高的步骤或过程抽取出来定义为一些可复用标准步骤
        </p>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     组成部分
    </p>
    <p>
     测试编号 测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等
    </p>
    <p>
    </p>
    <h3>
     性能测试指标:
    </h3>
    <p>
     系统指标: 响应时间 258 吞吐量 TPS 并发数 点击率
    </p>
    <p>
     资源使用率: CPU使用率 75% 内存使用率 80% 磁盘吞吐率 80% 网络吞吐率 80%
    </p>
    <p>
    </p>
    <h3>
     测试报告
    </h3>
    <p>
     组成部分
    </p>
    <p>
     · 首页
    </p>
    <p>
     · 引言（目的、背景、缩略语、参考文献）
    </p>
    <p>
     · 测试概要(测试方法、范围、测试环境、工具)
    </p>
    <p>
     · 测试结果与缺陷分析（功能、性能）
    </p>
    <p>
     · 测试结论与建议（项目概况、测试时间 测试情况、结论性能汇总）
    </p>
    <p>
     · 附录（缺陷统计）
    </p>
    <p>
     性能测试报告
    </p>
    <p>
     <strong>
      1、 项目描述
     </strong>
     描述项目的背景，以及压测的目的。
     <strong>
      2、 性能指标和业务模型
     </strong>
     列举本次性能测试所有接口的目标TPS。如果测试多个接口，需要写明各个接口的业务比例。
     <strong>
      3、 测试人员
     </strong>
     列举本次测试项目都有哪些人组成，各自担任什么职责。
     <strong>
      4、 测试环境配置
     </strong>
     列出压测时的网络环境拓扑图，以及本次测试涉及到的所有服务器的软硬件资源配置，包括压力机、应用服务器、数据库服务器等。 如果与生产环境有差异，一定要做出说明本次测试是基于什么配置测试出来的。
     <strong>
      5、 测试数据规模
     </strong>
     本次测试都准备了多少数据，比如用户数据、商品数据等，以及数据根据什么规则产生。
     <strong>
      6、 测试结果分析
     </strong>
     详细记录每个测试场景的最终结果，如tps、平均响应时间、top响应时间、错误率等。另外还需要写出该场景对应的性能监控数据，如CPU、内存、磁盘和网络的监控数据。
     <strong>
      7、 调优说明
     </strong>
     在压测过程中，如果项目进行了性能调优，要写明问题的原因和优化的内容，以及优化前后的性能对比。
     <strong>
      8、 结论
     </strong>
     根据测试的实际结果和预期结果进行判断，本次性能测试是否通过。
     <strong>
      9、 建议
     </strong>
     在压测过程中，根据测试实际结果提出的一些建议，如部署建议，中间件配置等。
    </p>
    <p>
     <strong>
      缺陷报告的书写
     </strong>
    </p>
    <p>
     1、尽量保证缺陷可以重现
    </p>
    <p>
     2、简洁、准确、完整
    </p>
    <p>
     3、一个缺陷报告只写一个缺陷
    </p>
    <p>
     <strong>
      缺陷书写规范
     </strong>
    </p>
    <p>
     1、标题简洁、提供缺陷的本质信息即可
    </p>
    <p>
     2、复现的步骤要详细，应包含如何使别人能够很容易的复现该缺陷的完整步骤。用数字编
    </p>
    <p>
     码。
    </p>
    <p>
     3、实际结果要描述清楚，及错误的结果。
    </p>
    <p>
     4、列出预期结果
    </p>
    <p>
     5、测试数据
    </p>
    <p>
     6、提供附件
    </p>
    <p>
     7、提供严重属性和公司需要填写的属性
    </p>
    <h3>
     压力测试
    </h3>
    <h4>
     adb命令
    </h4>
    <p>
     查看当前连接设备
    </p>
    <p>
     adb devices
    </p>
    <p>
     adb开启
    </p>
    <p>
     adb start-server
    </p>
    <p>
     adb关闭
    </p>
    <p>
     adb kill-server
    </p>
    <p>
     查询当前应用程序的包名和启动项
    </p>
    <p>
     adb shell dumpsys window | findstr mCurrentFocus adb shell dumpsys window w |findstr \/ |findstr name=
    </p>
    <p>
     adb shell dumpsys activity | findstr “mResume” adb activity adb shell dumpsys window w
    </p>
    <p>
     查询包名
    </p>
    <p>
     系统应用 adb shell pm list packages -s
    </p>
    <p>
     adb shell pm list packages
    </p>
    <p>
     第三方应用 adb shell pm list packages -3
    </p>
    <p>
     查看顶部Activity
    </p>
    <p>
     windows环境下 adb shell dumpsys activity | findstr "mFocusedActivity"
    </p>
    <p>
     Linux、Mac环境下 adb shell dumpsys activity | grep "mFocusedActivity"
    </p>
    <p>
     查看日志
    </p>
    <p>
     adb logcat
    </p>
    <p>
     adb logcat *:E &gt;C:\log\e.txt
    </p>
    <p>
     Android 的日志分为如下几个级别： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出）
    </p>
    <p>
     安装apk文件
    </p>
    <p>
     adb install xxx.apk
    </p>
    <p>
     覆盖安装
    </p>
    <p>
     adb install -r xxx.apk
    </p>
    <p>
     比分直接RUN出来的包是test-onlu的无法安装，推荐使用
     <strong>
      -t
     </strong>
    </p>
    <p>
     adb install -r -t xxx.apk
    </p>
    <p>
     卸载App
    </p>
    <p>
     adb uninstall com.zhy.app
    </p>
    <p>
     如果想要保留数据
    </p>
    <p>
     adb uninstall -k com.zhy.app
    </p>
    <p>
     往手机SDCard传递文件
    </p>
    <p>
     adb push 文件名 手机端SDCard路径
    </p>
    <p>
     从手机端下载文件
    </p>
    <p>
     adb pull /sdcard/xxx.txt
    </p>
    <p>
     将移动端文件传输到电脑
    </p>
    <p>
     adb pull 移动端路径 电脑路径
    </p>
    <p>
     将移电脑文件传输到移动端
    </p>
    <p>
     adb push 电脑路径 移动端路径
    </p>
    <p>
     截屏
    </p>
    <p>
     adb shell screencap -p 路径
    </p>
    <p>
     启动Activity
    </p>
    <p>
     adb shell am start 包名/完整Activity路径
    </p>
    <p>
     如果需要携带参数(携带一个Intent,Key 为name):
    </p>
    <p>
     adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity -e name zhy
    </p>
    <p>
     发送广播
    </p>
    <p>
     adb shell am broadcast -a "broadcastactionfilter"
    </p>
    <p>
     如果需要携带参数（携带一个Intent,key为name）:
    </p>
    <p>
     adb shell am broadcast -a "broadcastactionfilter" -e name zhy
    </p>
    <p>
     查看adb命令帮助信息
    </p>
    <p>
     adb help
    </p>
    <p>
     查看当前版本号
    </p>
    <p>
     adb shell getprop ro.build.version.release
    </p>
    <p>
     查看进程
    </p>
    <p>
     adb shell dumpsys cpuinfo
    </p>
    <p>
     adb shell dumpsys meminfo
    </p>
    <p>
    </p>
    <p>
    </p>
    <h3>
     Monkey测试
    </h3>
    <p>
     <strong>
      adb shell monkey -p com.xy.android.junit
     </strong>
    </p>
    <p>
     <strong>
      -s 500 （指定测试的种子值（编号））
     </strong>
    </p>
    <p>
     <strong>
      --throttle 300（每个事件结束后的间隔时间）
     </strong>
    </p>
    <p>
     <strong>
      --ignore-crashes（忽略程序崩溃）
     </strong>
    </p>
    <p>
     <strong>
      --ignore-timeouts （ 忽略超时）
     </strong>
    </p>
    <p>
     <strong>
      --monitor-native-crashes（监视本地程序崩溃）
     </strong>
    </p>
    <p>
     <strong>
      -v -v （日志详细信息级别）
     </strong>
    </p>
    <p>
     <strong>
      10000 （进行的压测次数）
     </strong>
    </p>
    <p>
     <strong>
      &gt;E:\monkey_log\java_monkey_log.txt（打印log日志到本地）
     </strong>
    </p>
    <p>
     monkey作用的包：com.ckt.android.junit 产生时间序列的种子值：500 忽略程序崩溃 、 忽略超时 、 监视本地程序崩溃 、 详细信息级别为2 ， 产生 10000个事件 。
    </p>
    <p>
     <strong>
      monkey命令的启动
     </strong>
     :
    </p>
    <p>
     adb shell monkey 包名
    </p>
    <p>
     <strong>
      指定测试的种子值（编号）
     </strong>
    </p>
    <p>
     -s 500
    </p>
    <p>
     <strong>
      主要用于回归和 重现出现的 Bug。 这里稍微难以理解一点， 每次 monkey 命令的指令都是完全随机的，导致如果测试过程中 发现问题，就无法复现。这也就导致开发修复问题之后，我们也无法确定之前的问题是否被修复。 为了保证 能重现问题，在运行 monkey 指令的时候加一个 种子值，只要后续的指令带上该种子值，那么两次运行的随 机命令完全一致。
     </strong>
    </p>
    <p>
     <strong>
      对app进行多次访问的测试
     </strong>
     :
    </p>
    <p>
     adb monkey -p 包名 100 访问的测试
    </p>
    <p>
     <strong>
      显示日志的详细程度:
     </strong>
    </p>
    <ol>
     <li>
      <p>
       -v 启动提示及测试完成 最终结果
      </p>
     </li>
     <li>
      <p>
       -v -v 标为详细的日志发 送到activity (页面的)的事件信息
      </p>
     </li>
     <li>
      <p>
       -v -v -v 最为详细的日志 测试中选中或者是没有选中的activity(信息)测试信
      </p>
     </li>
    </ol>
    <p>
     <strong>
      打印日志的命令
     </strong>
     :
    </p>
    <p>
     adb shell monkey 200 &gt;d: / monkeylog. txt
    </p>
    <p>
     --throttle 用于用户对app的操作上的时间延迟 单位是毫秒|
    </p>
    <p>
     没有时间延迟 monkey会以最快的方式进行操作 发送请求
    </p>
    <p>
     <strong>
      忽略崩溃
     </strong>
    </p>
    <p>
     --ignore-crashes
    </p>
    <p>
     <strong>
      在adb命令中有此命令参数 monkey会继续执行直到事件计数完毕
     </strong>
    </p>
    <p>
     <strong>
      (ANR) app发生超时限制的时候 忽略超时
     </strong>
    </p>
    <p>
     --ignore-timeouts
    </p>
    <p>
     <strong>
      --pct-touch 调整触摸事件的占比
     </strong>
    </p>
    <p>
     adb shell monkey -p com.wan.android -pct-touch -v 10
    </p>
    <p>
     <strong>
      在adb命令中有此命令参数 monkey会继续执行直到事件计数完毕
     </strong>
    </p>
    <p>
     0 触摸事件的占比 -–pct-touch
    </p>
    <p>
     1 手势事件占比 -–pct-motion
    </p>
    <p>
     2 两指操作占比 -–pct-pinchzoom
    </p>
    <p>
     3 动作事件(有一定轨迹) --pct-trackball
    </p>
    <p>
     4 屏幕旋转的占比 --pct-rotation
    </p>
    <p>
     5 导航事件 上下左右 --pct-nav
    </p>
    <p>
     6 导航事件 home 回退 隐藏菜单 --pct-majornav
    </p>
    <p>
     7 按键事件 关机键 音量加 减 --pct-syskeys
    </p>
    <p>
     8 启动activity事件 即参数–pct-appswitch
    </p>
    <p>
     9 键盘翻转事件 即参数–pct-flip
    </p>
    <p>
     10 其他事件 即参数–pct-anyevent
    </p>
    <p>
     那么对于 monkey 跑完之后，我们要如何去确认有没有出现 bug 呢？ 最直观简单的方式就是通过搜索以下关键字：
    </p>
    <ul>
     <li>
      <ol>
       <li>
        <p>
         程序无响应的情况：搜索关键字“ANR in”
        </p>
       </li>
      </ol>
     </li>
     <li>
      <ol>
       <li>
        <p>
         崩溃的情况1：搜索关键字“CRASH”
        </p>
       </li>
      </ol>
     </li>
     <li>
      <ol>
       <li>
        <p>
         崩溃的情况2：搜索关键字“Exception”
        </p>
       </li>
      </ol>
     </li>
     <li>
      <ol>
       <li>
        <p>
         内存溢出的情况：搜索关键字“OOM”
        </p>
       </li>
      </ol>
     </li>
     <li>
      <ol>
       <li>
        <p>
         测试成功的情况：搜索关键字“Monkey finished”
        </p>
       </li>
      </ol>
     </li>
     <li>
      <ol>
       <li>
        <p>
         如果出现空指针 NullPointerException ，就一定是 bug
        </p>
       </li>
      </ol>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     app端测试
    </h3>
    <p>
     功能测试：
    </p>
    <p>
     1.业务逻辑正确性测试：依据：产品文档-&gt;测试用例编写
    </p>
    <p>
     兼容性测试：
    </p>
    <p>
     1.系统版本：Android:官方版本,定制版本;IOS：官方提供版本
    </p>
    <p>
     2.分辨率：720 * 1280 1080* 1920
    </p>
    <p>
     3.网络情况:2g 3g 4g 5g Wi-Fi
    </p>
    <p>
     异常测试
    </p>
    <p>
     1.热启动应用:应用在后台长时间待机;应用在后台待机过程中，手机重启
    </p>
    <p>
     2.网络切换和中断恢复:网络切换;中断恢复：
    </p>
    <p>
     3.电话信息中断恢复
    </p>
    <p>
     升级，安装，卸载测试
    </p>
    <p>
     1.升级测试：临近版本升级(1.0-&gt;1.1);跨版本(1.0-&gt;....-&gt;2.2)
    </p>
    <p>
     2.安装测试：首次安装;覆盖安装(同版本，不同版本覆盖);卸载后安装
    </p>
    <p>
     3.卸载测试：首次卸载;卸载安装后在卸载
    </p>
    <p>
     健壮性测试
    </p>
    <p>
     1.手机资源消耗：cpu，内存
    </p>
    <p>
     2.流量消耗：图片，数据，视频
    </p>
    <p>
     3.电量测试
    </p>
    <p>
     4.崩溃恢复
    </p>
    <h3>
     Web端测试
    </h3>
    <p>
     功能测试
    </p>
    <p>
     <strong>
      链接测试
     </strong>
    </p>
    <p>
     链接是Web应用系统的一个主要特征，它是在页面之间切换和指导用户去一些不知道地址的页面的主要手段。链接测试可分为三个方面。首先，测试所有链接是否按指示的那样确实链接到了该链接的页面；其次，测试所链接的页面是否存在；最后，保证Web应用系统上没有孤立的页面，所谓孤立页面是指没有链接指向该页面，只有知道正确的URL地址才能访问。 链接测试可以自动进行，现在已经有许多工具可以采用。链接测试必须在集成测试阶段完成，也就是说，在整个Web应用系统的所有页面开发完成之后进行链接测试。
    </p>
    <ol>
     <li>
      <p>
       采取措施：采用自动检测网站链接的软件来进行。
      </p>
     </li>
     <li>
      <p>
       推荐软件：
      </p>
     </li>
     <li>
      <p>
       Xenu Link Sleuth免费绿色免安装软件
      </p>
     </li>
     <li>
      <p>
       HTML Link Validator共享（30天试用）
      </p>
     </li>
    </ol>
    <p>
     <strong>
      表单测试
     </strong>
    </p>
    <p>
     当用户通过表单提交信息的时候，都希望表单能正常工作。
    </p>
    <p>
     如果使用表单来进行在线注册，要确保提交按钮能正常工作，当注册完成后应返回注册成功的消息。如果使用表单收集配送信息，应确保程序能够正确处理这些数据，最后能让顾客能让客户收到包裹。要测试这些程序，需要验证服务器能正确保存这些数据，而且后台运行的程序能正确解释和使用这些信息。
    </p>
    <p>
     当用户使用表单进行用户注册、登陆、信息提交等操作时，我们必须测试提交操作的完整性，以校验提交给服务器的信息的正确性。例如：用户填写的出生日期与职业是否恰当，填写的所属省份与所在城市是否匹配等。如果使用了默认值，还要检验默认值的正确性。如果表单只能接受指定的某些值，则也要进行测试。例如：只能接受某些字符，测试时可以跳过这些字符，看系统是否会报错。
    </p>
    <p>
     <strong>
      数据校验
     </strong>
    </p>
    <p>
     如果系根据业务规则需要对用户输入进行校验，需要保证这些校验功能正常工作。例如，省份的字段可以用一个有效列表进行校验。在这种情况下，需要验证列表完整而且程序正确调用了该列表(例如在列表中添加一个测试值，确定系统能够接受这个测试值)。
    </p>
    <p>
     在测试表单时，该项测试和表单测试可能会有一些重复。
    </p>
    <p>
     1.2和1.3的采取措施：第一个完整的版本采用手动检查，同时形成
     <strong>
      <em>
       *
      </em>
      *WinRunner****
     </strong>
     （
     <strong>
      <em>
       *
      </em>
      *QTP****
     </strong>
     ）脚本；回归测试以及升级版本主要靠WinRunner（QTP）自动回放测试
    </p>
    <p>
     <strong>
      cookies测试
     </strong>
    </p>
    <p>
     Cookies通常用来存储用户信息和用户在某应用系统的操作，当一个用户使用Cookies访问了某一个应用系统时，Web服务器将发送关于用户的信息，把该信息以Cookies的形式存储在客户端计算机上，这可用来创建动态和自定义页面或者存储登陆等信息。 　　如果Web应用系统使用了Cookies，就必须检查Cookies是否能正常
     <strong>
      <em>
       *
      </em>
      *工作****
     </strong>
     。测试的内容可包括Cookies是否起作用，是否按预定的时间进行保存，刷新对Cookies有什么影响等。如果在cookies中保存了注册信息，请确认该cookie能够正常工作而且已对这些信息已经加密。如果使用cookie来统计次数，需要验证次数累计正确。
    </p>
    <p>
     采取措施：
    </p>
    <p>
     1采用
     <strong>
      黑盒测试
     </strong>
     ：采用上面提到的方法进行测试
    </p>
    <p>
     2采用查看cookies的软件进行（初步的想法）
    </p>
    <p>
     可以选择采用的软件
    </p>
    <p>
     IECookiesView v1.50
    </p>
    <p>
     Cookies Manager v1.1
    </p>
    <p>
     <strong>
      数据库测试
     </strong>
    </p>
    <p>
     在Web应用
     <strong>
      技术
     </strong>
     中，数据库起着重要的作用，数据库为Web应用系统的管理、运行、查询和实现用户对数据存储的请求等提供空间。在Web应用中，最常用的数据库类型是关系型数据库，可以使用
     <strong>
      SQL
     </strong>
     对信息进行处理。
    </p>
    <p>
     在使用了数据库的Web应用系统中，一般情况下，可能发生两种错误，分别是数据一致性错误和输出错误。数据一致性错误主要是由于用户提交的表单信息不正确而造成的，而输出错误主要是由于网络速度或程序设计问题等引起的，针对这两种情况，可分别进行测试。
    </p>
    <p>
     采取措施：暂时没有更好的测试方法
    </p>
    <p>
     考虑结合到1.2和1.3的测试中
    </p>
    <p>
     <strong>
      应用程序特定的功能需求
     </strong>
    </p>
    <p>
     最重要的是，测试人员需要对应用程序特定的功能需求进行验证。尝试用户可能进行的所有操作：下订单、更改订单、取消订单、核对订单状态、在货物发送之前更改送货信息、在线支付等等。这是用户之所以使用网站的原因，一定要确认网站能像广告宣传的那样神奇。
    </p>
    <p>
     采取措施：深刻理解需求说明文档
    </p>
    <p>
     <strong>
      设计语言测试
     </strong>
    </p>
    <p>
     Web设计语言版本的差异可以引起客户端或服务器端严重的问题，例如使用哪种版本的HTML等。当在分布式环境中开发时，开发人员都不在一起，这个问题就显得尤为重要。除了HTML的版本问题外，不同的脚本语言，例如Java、Javascrīpt、ActiveX、VBscrīpt或Perl等也要进行验证。
    </p>
    <p>
     暂时没有方法测试，可以多参考一点讨论组内的更新信息
    </p>
    <p>
     1．
     <strong>
      页面链接检查
     </strong>
     ：每一个链接是否都有对应的页面，并且页面之间切换正确。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        相关性检查
       </strong>
       ：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确。
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查按钮的功能是否正确
       </strong>
       ：如update, cancel, delete, save等功能是否正确。
      </p>
     </li>
     <li>
      <p>
       <strong>
        字符串长度检查:
       </strong>
       输入超出需求所说明的字符串长度的内容, 看系统是否检查字符串长度,会不会出错.
      </p>
     </li>
     <li>
      <p>
       <strong>
        字符类型检查
       </strong>
       : 在应该输入指定类型的内容的地方输入其他类型的内容(如在应该输入整型的地方输入其他字符类型),看系统是否检查字符类型,会否报错.
      </p>
     </li>
     <li>
      <p>
       <strong>
        标点符号检查
       </strong>
       : 输入内容包括各种标点符号,特别是空格,各种引号,回车键.看系统处理是否正确.
      </p>
     </li>
     <li>
      <p>
       <strong>
        中文字符处理:
       </strong>
       在可以输入中文的系统输入中文,看会否出现乱码或出错.
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查带出信息的完整性
       </strong>
       : 在查看信息和update信息时,查看所填写的信息是不是全部带出.,带出信息和添加的是否一致
      </p>
     </li>
     <li>
      <p>
       <strong>
        信息重复
       </strong>
       : 在一些需要命名,且名字应该唯一的信息输入重复的名字或ID,看系统有没有处理,会否报错,重名包括是否区分大小写,以及在输入内容的前后输入空格,系统是否作出正确处理.
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查删除功能
       </strong>
       :在一些可以一次删除多个信息的地方,不选择任何信息,按”delete”,看系统如何处理,会否出错;然后选择一个和多个信息,进行删除,看是否正确处理.
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查添加和修改是否一致
       </strong>
       : 检查添加和修改信息的要求是否一致,例如添加要求必填的项,修改也应该必填;添加规定为整型的项,修改也必须为整型.
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查修改重名
       </strong>
       :修改时把不能重名的项改为已存在的内容,看会否处理,报错.同时,也要注意,会不会报和自己重名的错.
      </p>
     </li>
     <li>
      <p>
       <strong>
        重复提交表单
       </strong>
       ：一条已经成功提交的纪录，back后再提交，看看系统是否做了处理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        检查多次使用back键的情况
       </strong>
       : 在有back的地方,back,回到原来页面,再back,重复多次,看会否出错.
      </p>
     </li>
     <li>
      <p>
       <strong>
        search检查
       </strong>
       : 在有search功能的地方输入系统存在和不存在的内容,看search结果是否正确.如果可以输入多个search条件,可以同时添加合理和不合理的条件,看系统处理是否正确.
      </p>
     </li>
     <li>
      <p>
       <strong>
        输入信息位置
       </strong>
       : 注意在光标停留的地方输入信息时,光标和所输入的信息会否跳到别的地方.
      </p>
     </li>
     <li>
      <p>
       <strong>
        上传下载文件检查
       </strong>
       ：上传下载文件的功能是否实现，上传文件是否能打开。对上传文件的格式有何规定，系统是否有解释信息，并检查系统是否能够做到。
      </p>
     </li>
     <li>
      <p>
       <strong>
        必填项检查
       </strong>
       ：应该填写的项没有填写时系统是否都做了处理，对必填项是否有提示信息，如在必填项前加*
      </p>
     </li>
     <li>
      <p>
       <strong>
        快捷键检查
       </strong>
       ：是否支持常用快捷键，如Ctrl+C Ctrl+V Backspace等，对一些不允许输入信息的字段，如选人，选日期对快捷方式是否也做了限制。
      </p>
     </li>
     <li>
      <p>
       <strong>
        回车键检查
       </strong>
       : 在输入结束后直接按回车键,看系统处理如何,会否报错.
      </p>
     </li>
    </ol>
    <p>
     性能测试
    </p>
    <ol>
     <li>
      <p>
       连接速度测试：测试页面链接的速度，系统需要重新登录的时间
      </p>
     </li>
     <li>
      <p>
       负载测试：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？
      </p>
     </li>
     <li>
      <p>
       压力测试：压力测试是测试系统的限制和故障恢复能力，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。
      </p>
     </li>
    </ol>
    <p>
     压力测试的区域包括表单、登陆和其他信息传输页面等。
    </p>
    <p>
     用户界面测试
    </p>
    <ol>
     <li>
      <p>
       导航测试：
      </p>
     </li>
    </ol>
    <p>
     导航是否直观？Web系统的主要部分是否可通过主页存取？Web系统是否需要站点地图、搜索引擎或其他的导航帮助？51Testing软件测试网)cvpd+V W8A
    </p>
    <p>
     页面结构、导航、菜单、连接的风格是否一致
    </p>
    <ol>
     <li>
      <p>
       图形测试：
      </p>
      <p>
       1）要确保图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间。Web应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面。
      </p>
      <p>
       2）验证所有页面字体的风格是否一致。
      </p>
      <p>
       3）背景颜色应该与字体颜色和前景颜色相搭配。
      </p>
      <p>
       4）图片的大小和质量也是一个很重要的因素，一般采用JPG或GIF压缩，
      </p>
      <p>
       5）最后，需要验证的是文字回绕是否正确。如果说明文字指向右边的图片，应该确保该图片出现在右边。不要因为使用图片而使窗口和段落排列古怪或者出现孤行。
      </p>
     </li>
     <li>
      <p>
       内容测试：检验Web应用系统提供信息的正确性、准确性和相关性。
      </p>
     </li>
     <li>
      <p>
       表格测试：用户是否需要向右滚动页面才能看见产品的价格？把价格放在左边，而把产品细节放在右边是否更有效? 每一栏的宽度是否足够宽，表格里的文字是否都有折行？是否有因为某一格的内容太多，而将整行的内容拉长?
      </p>
     </li>
     <li>
      <p>
       整体界面测试：界面测试主要从窗体及窗体中的控件两方面来考虑。
      </p>
     </li>
    </ol>
    <p>
     兼容性测试
    </p>
    <ol>
     <li>
      <p>
       平台测试：在各种操作系统下对Web系统进行兼容性测试。
      </p>
     </li>
     <li>
      <p>
       浏览器测试：创建一个兼容性矩阵。在这个矩阵中，测试不同厂商、不同版本的浏览器对某些构件和设置的适应性。
      </p>
     </li>
     <li>
      <p>
       分辨率测试：页面版式在不同的分辨率模式下是否显示正常? 字体是否太小以至于无法浏览? 或者是太大? 文本和图片是否对齐?
      </p>
     </li>
     <li>
      <p>
       连接速率：
      </p>
     </li>
     <li>
      <p>
       打印机测试：需要验证网页打印是否正常。有时在屏幕上显示的图片和文本的对齐方式可能与打印出来的东西不一样。测试人员至少需要验证订单确认页面打印是正常的。51Testing软件测试网8S2W*F:H4e4P7T
      </p>
     </li>
     <li>
      <p>
       组合测试：根据实际情况，采取等价划分的方法，列出兼容性矩阵
      </p>
     </li>
    </ol>
    <p>
     安全性测试
    </p>
    <ol>
     <li>
      <p>
       目录设置：Web 安全的第一步就是正确设置目录。每个目录下应该有 index.html 或 main.html 页面，这样就不会显示该目录下的所有内容。
      </p>
     </li>
     <li>
      <p>
       SSL:如果开发部门使用了SSL，测试人员需要确定是否有相应的替代页面(适用于3.0 以下版本的浏览器，这些浏览器不支持SSL。当用户进入或离开安全站点的时候，请确认有相应的提示信息。是否有连接时间限制？超过限制时间后出现什么情况？
      </p>
     </li>
     <li>
      <p>
       登录：用户登录是否有次数限制? 是否限制从某些 IP 地址登录? 如果允许登录失败的次数为3，你在第三次登录的时候输入正确的用户名和口令，能通过验证吗? 口令选择有规则限制吗? 是否可以不登陆而直接浏览某个页面？ HuK ]D2?1G-L }8n*N352621Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内（例如15分钟）没有点击任何页面，是否需要重新登陆才能正常使用。
      </p>
     </li>
     <li>
      <p>
       日志文件：日志是否记所有的事务处理? 是否记录失败的注册企图? 是否记录被盗信用卡的使用? 是否在每次事务完成的时候都进行保存? 记录IP 地址吗? 记录用户名吗?
      </p>
     </li>
     <li>
      <p>
       脚本语言：测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。
      </p>
     </li>
    </ol>
    <p>
     接口测试
    </p>
    <ol>
     <li>
      <p>
       服务器接口：浏览器与服务器的接口。测试人员提交事务，然后查看服务器记录，并验证在浏览器上看到的正好是服务器上发生的。测试人员还可以查询数据库，确认事务数据已正确保存。
      </p>
     </li>
     <li>
      <p>
       外部接口： 测试的时候，要使用 web 接口发送一些事务数据，分别对有效信用卡、无效信用卡和被盗信用卡进行验证。
      </p>
      <p>
       通常，测试人员需要确认软件能够处理外部服务器返回的所有可能的消息。
      </p>
     </li>
     <li>
      <p>
       错误处理：尝试在处理过程中中断事务，看看会发生什么情况？订单是否完成？尝试中断用户到服务器的网络连接。尝试中断 web 服务器到信用卡验证服务器的连接。在这些情况下，系统能否正确处理这些错误？是否已对信用卡进行收费？
      </p>
     </li>
    </ol>
    <h3>
     app和web测试的区别
    </h3>
    <p>
     <strong>
      单纯从功能测试的层面上来讲的话，APP 测试、web 测试 在流程和功能测试上是没有区别的
     </strong>
    </p>
    <p>
     <strong>
      根据两者载体不一样，则区别如下：
     </strong>
    </p>
    <p>
     <strong>
      1、系统结构方面：
     </strong>
    </p>
    <p>
     web项目，b/s架构，基于浏览器的；web测试只要更新了服务器端，客户端就会同步会更新
    </p>
    <p>
     app项目，c/s结构的，必须要有客户端；app 修改了服务端，则客户端用户所有核心版本都需要进行回归测试一遍
    </p>
    <p>
     <strong>
      2、性能方面：
     </strong>
    </p>
    <p>
     web项目 需监测 响应时间、CPU、Memory
    </p>
    <p>
     app项目 除了监测 响应时间、CPU、Memory外，还需监测流量、电量等
    </p>
    <p>
     <strong>
      3、兼容方面：
     </strong>
    </p>
    <p>
     web项目：
    </p>
    <p>
     1. 浏览器（火狐、谷歌、IE等）
    </p>
    <p>
     2. 操作系统（Windows7、Windows10、Linux等）
    </p>
    <p>
     app项目：
    </p>
    <p>
     1. 设备系统: iOS（ipad、iphone）、Android（三星、华为、联想等） 、Windows（Win7、Win8）、OSX（Mac）
    </p>
    <p>
     2. 手机设备可根据 手机型号、分辨率不同
    </p>
    <p>
     <strong>
      4、相对于 Wed 项目，APP有专项测试：
     </strong>
    </p>
    <p>
     1. 干扰测试：中断，来电，短信，关机，重启等
    </p>
    <p>
     2. 弱网络测试（模拟2g、3g、4g，wifi网络状态以及丢包情况）；网络切换测试（网络断开后重连、3g切换到4g/wifi 等）
    </p>
    <p>
     3. 安装、更新、卸载
    </p>
    <p>
     安装：需考虑安装时的中断、弱网、安装后删除安装文件等情况
    </p>
    <p>
     卸载：需考虑 卸载后是否删除app相关的文件
    </p>
    <p>
     更新：分强制更新、非强制更新、增量包更新、断点续传、弱网状态下更新
    </p>
    <p>
     <strong>
      5、测试工具方面：
     </strong>
    </p>
    <p>
     自动化工具：APP 一般使用 Appium; Web 一般使用 Selenium
    </p>
    <p>
     性能测试工具：APP 一般使用 JMeter; Web 一般使用 LR、JMeter
    </p>
    <p>
     <strong>
      6. 界面操作：
     </strong>
    </p>
    <p>
     关于手机端测试，需注意手势，横竖屏切换，多点触控，前后台切换
    </p>
    <p>
     <strong>
      7. 安全测试：
     </strong>
    </p>
    <p>
     安装包是否可反编译代码、安装包是否签名、权限设置，例如访问通讯录等
    </p>
    <p>
     <strong>
      8. 边界测试：
     </strong>
    </p>
    <p>
     可用存储空间少、没有SD卡/双SD卡、飞行模式、系统时间有误、第三方依赖（QQ、微信登录）等
    </p>
    <p>
     <strong>
      9. 权限测试：
     </strong>
    </p>
    <p>
     设置某个App是否可以获取该权限，例如是否可访问通讯录、相册、照相机等
    </p>
    <p>
     单纯从功能测试的层面上来讲的话，APP 测试、web 测试 在流程和功能测试上是没有区别的。 系统架构方面： web项目，一般都是b/s架构，基于浏览器的 app项目，则是c/s的，必须要有客户端，用户需要安装客户端。 web测试只要更新了服务器端，客户端就会同步会更新。App项目则需要客户端和服务器都更新。
    </p>
    <p>
     性能方面: web页面主要会关注响应时间 而app则还需要关心流量、电量、CPU、GPU、Memory这些。 它们服务端的性能没区别，都是一台服务器。
    </p>
    <p>
     兼容方面： web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 app测试则要看分辨率，屏幕尺寸，还要看设备系统。 web测试是基于浏览器的所以不必考虑安装卸载。 而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 此外APP还有一些专项测试：如网络、适配性。。。
    </p>
    <p>
     <strong>
      APP测试特点
     </strong>
    </p>
    <p>
     （除了按需求说明书外的 功能测试 之外还需要进行如下测试）
    </p>
    <p>
     1： 适配性测试（也叫兼容性测试，不同的安卓版本，不同厂商，不同手机品牌）
    </p>
    <p>
     2： 不同网络测试 （2G网络/3G网络/4G网络/WIFI网络）
    </p>
    <p>
     3; 在线升级测试
    </p>
    <p>
     4： 中断测试（电话、短中消息打扰）
    </p>
    <p>
     5： 耗电量测试
    </p>
    <p>
     6： 弱网测试（信号差，信号屏蔽实验室）
    </p>
    <p>
     7： 安装卸载 （C/S）
    </p>
    <p>
     8: 流量测试
    </p>
    <h3>
     git(版本控制工具)
    </h3>
    <p>
     Git是一个开源的分布式版本控制系统，可以有效的，高速的处理从很小到非常大的项目版本管理
    </p>
    <p>
     操作步骤：
    </p>
    <p>
     1.新建一个仓库(网页点击＋)
    </p>
    <p>
     2.把远程仓库clone到我们的本地仓库
    </p>
    <p>
     git clone &lt;你仓库的地址&gt; --&gt;cd 仓库名--&gt;git status 查看状态
    </p>
    <p>
     3.把项目拖拽到你的文件夹(查看一下 git status 是否多了什么东西) 并输入命令 git add . 进行提交 git status 查看状态
    </p>
    <p>
     4.我们进行提交 git commit -m '这是一次提交' git status 查看状态
    </p>
    <p>
     5.先拉取 git pull -Already up to date.-你的当前日期是没问题的
    </p>
    <p>
     6.最后一步 git push 一下 上传成功
    </p>
    <h3>
     mysql
    </h3>
    <p>
     增删改查
    </p>
    <p>
     增 : insert into 表名(字段名,...) value (值,.....)
    </p>
    <p>
     删: delete from 表名 where 条件 (删除记录)
    </p>
    <p>
     delete from 表名 (删除所有记录)
    </p>
    <p>
     drop 表名 (删除表)
    </p>
    <p>
     改: update 表名 set 字段=值 where 条件 (有条件则修改符合条件的 无则是全部)
    </p>
    <p>
     查: select * from 表名 (显示所有字段)
    </p>
    <p>
     select * from 表名 where 条件
    </p>
    <p>
     关系运算符:= != &gt; &lt; &lt;= &gt;=
    </p>
    <p>
     select * from 表名 where 字段名 (not)in (元素,...) (不在 或 在)
    </p>
    <p>
     select * from 表名 where 字段名 (not)between 值1 and 值2(不在...里 或 在...里)
    </p>
    <p>
     select * from from 表名 where 字段名 is(not) null (是否为空)
    </p>
    <p>
     select distinct 字段名 from 表名 (去重)
    </p>
    <p>
     select * from 表名 where 字段名 (not)like '匹配字符串' (关键字查询)
    </p>
    <p>
     select * from 表名 where like 'a%' (模糊查询)
    </p>
    <p>
     select * from 表名 where 条件1 and 条件2 ...... (多条件精准查询)
    </p>
    <p>
     select * from 表名 where 条件1 or 条件2 (或查询)
    </p>
    <h4>
     高级查询
    </h4>
    <p>
     聚合函数
    </p>
    <p>
     <em>
      count()记录总条数
     </em>
    </p>
    <p>
     select count(*) from 表名
    </p>
    <p>
     <em>
      sum()所有值的总和
     </em>
    </p>
    <p>
     select sum(字段名) from 表名
    </p>
    <p>
     <em>
      AVG()平均值
     </em>
    </p>
    <p>
     select AVG(字段名) from 表名
    </p>
    <p>
     <em>
      max()最大值
     </em>
    </p>
    <p>
     select max(字段名) from 表名
    </p>
    <p>
     <em>
      min()最小值
     </em>
    </p>
    <p>
     select min(字段名) from 表名
    </p>
    <p>
     排序
    </p>
    <p>
     select 字段,... from 表名 order by 字段 asc (升序)
    </p>
    <p>
     select 字段,... from 表名 order by 字段 desc (降序)
    </p>
    <p>
     分组
    </p>
    <p>
     select 字段,.. from 表名 group by 字段,...
    </p>
    <p>
     select sum(字段名) from 表名 group by 字段名 having sum(字段名) &lt; 10 (查询某字段总和小于10的)
    </p>
    <p>
     分页
    </p>
    <p>
     select * from 表名 limit 0,2 (每页显示2个,第一个页面)
    </p>
    <p>
    </p>
    <h4>
     连接查询
    </h4>
    <p>
     inner join ... on 等值连接
    </p>
    <p>
     left join ... on 左连接
    </p>
    <p>
     right join ... on 右连接
    </p>
    <p>
     select 表A.字段1,表B.字段1 from 表A [inner | left | right] join 表B on 表A.字段2 = 表B.字段2
    </p>
    <h4>
     子查询
    </h4>
    <p>
     select * from 表A where 字段1 &gt; (select AVG(字段) from 表B)
    </p>
    <h4>
     约束
    </h4>
    <p>
     int unsigned 无符号整形
    </p>
    <p>
     auto_increment 表示自动增长
    </p>
    <p>
     not null 表示不能为空
    </p>
    <p>
     primary key 表示主键
    </p>
    <p>
     default 默认值
    </p>
    <h4>
     外键
    </h4>
    <p>
     建表时: foreign key(a_id) references 表B(id)
    </p>
    <p>
     取消外键约束: show create table 表名 (获取名称之后 根据名称删除)
    </p>
    <p>
     添加外键约束: alter table 要连接表名 add foreign key (a_id) references 被连接的表名(id)
    </p>
    <h4>
     多表联查
    </h4>
    <p>
     内连接 inner join ​ 外连接 left join ,right join ​ 全连接 full join (不适用mysql,使用oracle) = left join+ union+right join
    </p>
    <p>
     取别名 as 或者是不写
    </p>
    <p>
     --------sql语句 select s.字段,c.字段，，， from student(表1) as s inner join（left join ,right join） class(表2) c on s.字段 = c.字段
    </p>
    <p>
     内连接
    </p>
    <p>
     select s.sname,s.sex,c.classroom from class c INNER JOIN student s on s.sid = c.sid SELECT sc.school,c.classroom from school as sc INNER JOIN class as c on sc.cid = c.cid
    </p>
    <p>
     外连接
    </p>
    <p>
     select s.sname,s.sex,c.classroom from class c left JOIN student s on s.sid = c.sid (左边为主表，右边有则填充，没有用null) select s.sname,s.sex,c.classroom from class c RIGHT JOIN student s on s.sid = c.sid (右边为主表，左边有则填充，没有用null)
    </p>
    <p>
     全连接（不适用mysql）
    </p>
    <p>
     select s.sname,s.sex,c.classroom from class c full JOIN student s on s.sid = c.sid
    </p>
    <p>
     全连接
    </p>
    <p>
     select s.sname,s.sex,c.classroom from class c left JOIN student s on s.sid = c.sid UNION select s.sname,s.sex,c.classroom from class c RIGHT JOIN student s on s.sid = c.sid
    </p>
    <h4>
     多表联查
    </h4>
    <p>
     三表联查
    </p>
    <p>
     select c.classroom,st.sname,st.sex ,sc.school from class as c INNER join student as st on c.sid = st.sid INNER JOIN school as sc on c.cid = sc.cid
    </p>
    <p>
     子查询(一个表的查询的结果作为另一个表的条件)
    </p>
    <p>
     SELECT cid from school where school ='北京' SELECT classroom from class where cid=(SELECT cid from school where school ='北京')
    </p>
    <h3>
     bug 的生命周期
    </h3>
    <p>
     一个Bug由测试人员发现并提交,我们将状态标注为新建;开发人员接收了该
    </p>
    <p>
     Bug,将Bug的状态修改为已分配(Assigned),表示已经认可;开发人员解决了该
    </p>
    <p>
     Bug后,就将Bug的状态修改为解决,并发给测试人员回归测试;测试人员对Bug
    </p>
    <p>
     进行回归测试，如果确实已经解决,就将Bug的状态修改为关闭,否则的话则发给
    </p>
    <p>
     开发人员重新修改。还要说明的是,Bug是可以“死而复生”的,以前版本已经关闭
    </p>
    <p>
     的Bug,如果新版本中重新出现,我们就需要将其状态修改为重新打开。
    </p>
    <p>
     高 中 低
    </p>
    <p>
     bug的种类划分
    </p>
    <ol>
     <li>
      <p>
       功能错误：功能上的错误性bug
      </p>
     </li>
     <li>
      <p>
       代码错误：一般很少出现，通常在自测时出现（对白盒测试、自测的比较适合）
      </p>
     </li>
     <li>
      <p>
       内容相关：业务逻辑方面以及业务描述等相关问题
      </p>
     </li>
     <li>
      <p>
       表单相关：表单逻辑、样式、内容问题
      </p>
     </li>
     <li>
      <p>
       用户界面：UI表现，包括对话框样式和文字描述问题
      </p>
     </li>
     <li>
      <p>
       需求变动：原有的需求基础上的更改
      </p>
     </li>
     <li>
      <p>
       新增需求：会议上提出的新需求，非正式会议提出的不属于该项
      </p>
     </li>
     <li>
      <p>
       设计文档：数据库设计文档、概要/详细设计文档
      </p>
     </li>
     <li>
      <p>
       建议：功能已满足但待改善，属于改良性建议
      </p>
     </li>
     <li>
      <p>
       配置相关：如web服务器或者数据库服务器配置等问题
      </p>
     </li>
     <li>
      <p>
       安装部署：项目部署时出现的错误，可能不是程序本身的问题而是工具本身和人为因素引起
      </p>
     </li>
     <li>
      <p>
       安全相关：加密和水印等安全信息
      </p>
     </li>
     <li>
      <p>
       性能压力：负载、压力测试
      </p>
     </li>
     <li>
      <p>
       标准规范：根据国际标准或者公司内部制定的某标准
      </p>
     </li>
     <li>
      <p>
       测试脚本：如用工具LR编写并执行脚本进行测试
      </p>
     </li>
    </ol>
    <p>
     如果在测试过程中出现的BUG 而开发人员不认为是BUG的时候 你怎么办???
    </p>
    <p>
     1.首先我会从自身去经过多次的测试发现BUG出现的次数和频率 记录复现BUG的方式 然后发送给开发人员
    </p>
    <p>
     2.再根据需求文档来确认是否为BUG
    </p>
    <p>
     3.如果开发不认为是BUG的 将复现BUG的记录和需求文档找产品经理和项目经理来确定是否BUG
    </p>
    <p>
     4.如果项目经理和产品经理都不认为是BUG 我会将BUG记录在测试文档中 方便在下次评审会上将问题再次抛出
    </p>
    <p>
     如何定位bug
    </p>
    <p>
     （1）查看报错日志
    </p>
    <p>
     查看报错日志，通过日志分析，需要有一定的经验，并且有一定的代码基础，才能更好地定位问题。
    </p>
    <p>
     （2）查看数据库的数据
    </p>
    <p>
     了解所测功能的数据表结构，测试过程中，查看数据库的数据，确认数据的正确性。
    </p>
    <p>
     （3）查看缓存（如Memcache、apc、redis等缓存）是否正确
    </p>
    <p>
     如何判断bug是前端 还是后端
    </p>
    <p>
     前台的bug通常是功能、界面和兼容性等有关；后台的bug与逻辑、性能和与数据相关的错误、排序安全性有关。
    </p>
    <p>
     也可以直接用charles抓包进行查看，可以从请求跟响应这一过bai程判断，如果前du端已经把数据发送给了后端zhi，后端没有返回数据dao则是后端问题，如果前端在用户输入数据之后发送请求，前端没有带数据在请求中就是前端的问题，或者说后台已经传回来了数据，但是到前端没有显示出来。这个也是前端问题。具体的话可以在浏览器中debug调试看看
    </p>
    <p>
     Bug不能复现怎么办?
    </p>
    <ol>
     <li>
      <p>
       首先考虑环境问题，看是否能够还原原来的环境
      </p>
     </li>
     <li>
      <p>
       遇到问题就要提，不能放过任何一个Bug，在提交的Bug描述中加上一句话，那就是复现概率，尝试20次，出现一次或尝试10次，交给开发，开发会根据Bug的复现概率，调整改Bug的优先级。
      </p>
     </li>
     <li>
      <p>
       尽量回想发生问题时的复现步骤，不要漏掉任何一个细节，按照步骤的组合尝试复现
      </p>
     </li>
     <li>
      <p>
       与开发人员配合，让开发人员对相应的代码检查，看是否通过代码层面检查出问题 也许是代码变更，引起的Bug
      </p>
     </li>
     <li>
      <p>
       保留发生bug时的log，附加到提交的Bug中，希望可以通过log中找到一些蛛丝马迹。
      </p>
     </li>
    </ol>
    <p>
     上线之后复现的bug如何解决
    </p>
    <p>
     1、测试人员复现问题后，提交问题单进行跟踪；
    </p>
    <p>
     2、评估该问题的严重程度，以及修复问题时和影响范围，回归测试需要测试哪些功能；
    </p>
    <p>
     3、问题修复后，先在测试环境上回归，通过后再在生产环境上打补丁，然后再进行回归测试；
    </p>
    <p>
     4、总结经验，分析问题发生的原因，避免下次出现同样问题
    </p>
    <h3>
     adb命令
    </h3>
    <p>
     查看当前连接设备：
    </p>
    <p>
     adb devices
    </p>
    <p>
     启动
    </p>
    <p>
     adb start server
    </p>
    <p>
     关闭
    </p>
    <p>
     adb kill-server
    </p>
    <p>
     安装apk文件
    </p>
    <p>
     adb install -r (apk的绝对路径)
    </p>
    <p>
     卸载App
    </p>
    <p>
     adb uninstall 包名 adb uninstall -k 包名 (保存配置及缓存文件)
    </p>
    <p>
     查看日志
    </p>
    <p>
     adb logcat
    </p>
    <p>
     列出所有的包名
    </p>
    <p>
     adb shell pm list package
    </p>
    <p>
     列出第三方的包名
    </p>
    <p>
     adb shell pm list package - 3
    </p>
    <p>
     列出系统应用的包名
    </p>
    <p>
     adb shell pm list package - s
    </p>
    <p>
     查看手机内存的命令
    </p>
    <p>
     adb shell dumpsys meminfo 包名
    </p>
    <p>
     将移动端文件传输到电脑
    </p>
    <p>
     adb pull 移动端路径 电脑路径
    </p>
    <p>
     将移电脑文件传输到移动端
    </p>
    <p>
     adb push 电脑路径 移动端路径
    </p>
    <p>
     查看手机内存情况
    </p>
    <p>
     adb shell dumpsys cpuinfo
    </p>
    <p>
     查看内存情况
    </p>
    <p>
     adb shell getprop | findstr dalvik 本机内存的使用情况
    </p>
    <p>
     查看应用内存使用情况
    </p>
    <p>
     adb shell dumpsys meminfo +包名：应用的内存使用情况
    </p>
    <p>
     清除应用缓存
    </p>
    <p>
     adb shell pm clear
    </p>
    <p>
     看日志的输出时间
    </p>
    <p>
     adb logcat -v time
    </p>
    <p>
     查看log日志并打印
    </p>
    <p>
     adb logcat *E:C:\log\log.txt
    </p>
    <p>
     日志级别
    </p>
    <p>
     V Verbose 最低
    </p>
    <p>
     D Debug bug
    </p>
    <p>
     I Info 信息
    </p>
    <p>
     W Warn 警告
    </p>
    <p>
     E Error 错误
    </p>
    <p>
     F Fatal 致命
    </p>
    <p>
     S Silent (supress all output)
    </p>
    <p>
     性能测试
    </p>
    <p>
     adb shell dumpsys cpuinfo 查看cpu信息
    </p>
    <p>
     adb shell dumpsys meminfo 内存信息
    </p>
    <h3>
     monkey
    </h3>
    <p>
     monkey命令的启动
    </p>
    <p>
     adb shell monkey + 命令参数
    </p>
    <p>
     对app进行多次访问的测试
    </p>
    <p>
     adb shell monkey -p (包名 具体的页面) 100 访问的测试
    </p>
    <p>
     显示日志的详细程度
    </p>
    <p>
     -v 启动提示及测试完成 最终结果
    </p>
    <p>
     -v -v 标为详细的日志发 送到activity (页面的)的事件信息
    </p>
    <p>
     -v -v -v 最为详细的日志 测试中选中或者是没有选中的activity(信息)测试信
    </p>
    <p>
     打印日志的命令
    </p>
    <p>
     adb shell monkey 200 &gt;d: / monkeylog. txt
    </p>
    <p>
     adb shell monkey -p com.wan.android -pct-touch -v 10
    </p>
    <p>
     用于用户对app的操作上的时间延迟 单位是毫秒
    </p>
    <p>
     --throttle
    </p>
    <p>
     没有时间延迟 monkey会以最快的方式进行操作 发送请求
    </p>
    <p>
     忽略崩溃
    </p>
    <p>
     --ignore-crashes 如果app发生崩溃或是异常时 monkey会跳过崩溃继续执行
    </p>
    <p>
     在adb命令中有此命令参数 monkey会继续执行直到事件计数完毕
    </p>
    <p>
     忽略超时
    </p>
    <p>
     --ignore-timeouts (ANR) app发生超时限制的时候
    </p>
    <p>
     在adb命令中有此命令参数 monkey会继续执行直到事件计数完毕
    </p>
    <p>
    </p>
    <p>
     0 触摸事件的占比
    </p>
    <p>
     1 手势事件占比
    </p>
    <p>
     2 两指操作占比
    </p>
    <p>
     3 动作事件(有一定轨迹)
    </p>
    <p>
     4 屏幕旋转的占比
    </p>
    <p>
     5 导航事件 上下左右
    </p>
    <p>
     6 导航事件 home 回退 隐藏菜单
    </p>
    <p>
     7 按键事件 关机键 音量加 减
    </p>
    <p>
     8 启动activity事件
    </p>
    <p>
     9 键盘抬起事件
    </p>
    <p>
     10 其他事件
    </p>
    <h3>
     Linux
    </h3>
    <h4>
     目录切换
    </h4>
    <p>
     cd usr/ 切换到该目录下usr目录
    </p>
    <p>
     cd ../ 切换到上一层目录
    </p>
    <p>
     cd / 切换到系统根目录
    </p>
    <p>
     cd ~ 切换到用户主目录
    </p>
    <h4>
     目录的操作命令（增删改查）
    </h4>
    <p>
     增加目录操作（增）
    </p>
    <p>
     mkdir 目录名称
    </p>
    <p>
     查看目录（查）
    </p>
    <p>
     ls 查看当前目录下的文件夹
    </p>
    <p>
     ls -a 查看当前目录下的隐藏文件夹
    </p>
    <p>
     ls -l / ll 查看当前目录下的所有文件
    </p>
    <p>
     寻找目录（查）
    </p>
    <p>
     find / -name ‘test*
    </p>
    <p>
     修改目录名称
    </p>
    <p>
     mv 目录名称 新目录名称
    </p>
    <p>
     <strong>
      mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作
     </strong>
    </p>
    <p>
     移动目录位置 剪切
    </p>
    <p>
     mv 目录名称 目录的新位置
    </p>
    <p>
     <strong>
      mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作
     </strong>
    </p>
    <p>
     拷贝目录
    </p>
    <p>
     cp -r 目录名称 目录拷贝的目标位置 -----r代表递归拷贝
    </p>
    <p>
     <strong>
      cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归
     </strong>
    </p>
    <p>
     删除目录
    </p>
    <p>
     rm -r 目录名 删除时回询问是否删除
    </p>
    <p>
     rm -rf 目录名 没有询问直接删除
    </p>
    <p>
     <strong>
      rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包
     </strong>
    </p>
    <p>
     创建文件
    </p>
    <p>
     touch 文件名
    </p>
    <p>
     查看文件
    </p>
    <p>
     cat / more / less / tail 文件
    </p>
    <p>
     <strong>
      cat查看/etc/sudo.conf文件，只能显示最后一屏内容
     </strong>
    </p>
    <p>
     <strong>
      more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看
     </strong>
    </p>
    <p>
     <strong>
      less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看
     </strong>
    </p>
    <p>
     <strong>
      tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束
     </strong>
    </p>
    <p>
     <strong>
      tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控文件的变化
     </strong>
    </p>
    <p>
     修改文件内容
    </p>
    <p>
     <strong>
      三种模式:命令模式，编辑模式，底行模式
     </strong>
    </p>
    <p>
     vim 文件
    </p>
    <p>
     但此时并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式，可以 编辑文件
    </p>
    <p>
     编辑完成后，按下Esc，退回命令模式
    </p>
    <p>
     此时文件虽然已经编辑完成，但是没有保存，需输入冒号：进入底行模式，在底行模 式下输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。
    </p>
    <p>
     看CPU信息
    </p>
    <p>
     /proc/meminfo
    </p>
    <p>
     查看占用CPU实用率最高的进程
    </p>
    <p>
     ps -aux |sort -k3nr |head -k
    </p>
    <p>
     查看一个文件前10行的内容
    </p>
    <p>
     head -n 10 /etc/profile
    </p>
    <p>
     查看一个文件末尾50行的信息
    </p>
    <p>
     tail -n 50 /etc/profile
    </p>
    <p>
     如何过滤文件内容中包括 “ ERROR ” 的行
    </p>
    <p>
     grep “ ERROR ” file_name
    </p>
    <p>
     cat file_name |grep “ ERROR ”
    </p>
    <p>
     查看端口号
    </p>
    <p>
     netstat -anp / an |grep 端口号
    </p>
    <p>
     查看进程号
    </p>
    <p>
     ps -ef |grep 进程号
    </p>
    <p>
     创建一个多级目录
    </p>
    <p>
     mkdir -p ./a/b
    </p>
    <p>
     查看tomcat的进程
    </p>
    <p>
     ps -ef |grep tomcat
    </p>
    <p>
     杀死进程
    </p>
    <p>
     kill -9 tomcat
    </p>
    <p>
     查看系统安全空间的命令
    </p>
    <p>
     df -ath
    </p>
    <p>
     查看当前机器的listen的所有端口
    </p>
    <p>
     netstat -tlnp
    </p>
    <p>
     把一个文件夹打包压缩成 .tzr.gz 的命令
    </p>
    <p>
     tar zcvf xxx.tzr.gz
    </p>
    <p>
     解压拆包命令
    </p>
    <p>
     tar zxvf xxx.tzr.gz
    </p>
    <p>
     z：调用gzip压缩命令进行压缩
    </p>
    <p>
     c：打包文件
    </p>
    <p>
     x：代表解压
    </p>
    <p>
     v：显示运行过程
    </p>
    <p>
     f：指定文件名
    </p>
    <p>
     显示当前所在位置
    </p>
    <p>
     pwd
    </p>
    <p>
     搜索命令
    </p>
    <p>
     grep 要搜索的字符串 要搜索的文件
    </p>
    <p>
     查看当前系统的网卡信息
    </p>
    <p>
     ifconfig
    </p>
    <p>
     查看与某台机器的连接情况
    </p>
    <p>
     ping
    </p>
    <p>
     修改文件/目录的权限的命令
    </p>
    <p>
     chmod 764 aaa.txt
    </p>
    <p>
     文件的类型：
    </p>
    <p>
     d：代表目录
    </p>
    <p>
     -：代表文件
    </p>
    <p>
     l：代表链接（可以认为是window中的快捷方式）
    </p>
    <p>
     后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的 用户的权限，其他用户的权限
    </p>
    <p>
     r：代表权限是可读，r也可以用数字4表示
    </p>
    <p>
     w：代表权限是可写，w也可以用数字2表示
    </p>
    <p>
     x：代表权限是可执行，x也可以用数字1表示
    </p>
    <p>
     Xshell 工具如果想要实现从服务器上传或者下载文件的话可以在服务器上安装什么包
    </p>
    <p>
     lrzsz
    </p>
    <p>
     以 / etc / password 的前五行内容为例，提取用户名
    </p>
    <p>
     cat / etc /password |head -n 5 |cut -d : -f l
    </p>
    <p>
     Linux的权限命令
    </p>
    <p>
     chmod 764 aaa.txt
    </p>
    <p>
     <strong>
      r：代表权限是可读，r也可以用数字4表示
     </strong>
    </p>
    <p>
     <strong>
      w：代表权限是可写，w也可以用数字2表示
     </strong>
    </p>
    <p>
     <strong>
      x：代表权限是可执行，x也可以用数字1表示
     </strong>
    </p>
    <p>
     netstat命令参数
    </p>
    <p>
     <strong>
      -t : 指明显示TCP端口
     </strong>
    </p>
    <p>
     <strong>
      -u : 指明显示UDP端口
     </strong>
    </p>
    <p>
     <strong>
      -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)
     </strong>
    </p>
    <p>
     <strong>
      -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。
     </strong>
    </p>
    <p>
     <strong>
      -n : 不进行DNS轮询，显示IP(可以加速操作)
     </strong>
    </p>
    <h3>
     python
    </h3>
    <p>
     面向对象
    </p>
    <p>
     面向对象编程是在面向过程编程的基础上发展来的，它比面向过程编程具有更强的灵活性和扩展性。 是一种封装代码的方法
    </p>
    <p>
     面向过程：
    </p>
    <p>
     核心是过程二字，过程指的是解决问题的步骤，好比如设计一条流水线，是一种机械式的思维方式。
    </p>
    <p>
     封装
    </p>
    <p>
     隐藏对象的属性和实现细节，仅对外提供公共访问方式。
    </p>
    <p>
     好处：
    </p>
    <ol>
     <li>
      <p>
       将变化隔离；
      </p>
     </li>
     <li>
      <p>
       便于使用；
      </p>
     </li>
     <li>
      <p>
       提高复用性；
      </p>
     </li>
     <li>
      <p>
       提高安全性；
      </p>
     </li>
    </ol>
    <p>
     封装原则：
    </p>
    <ol>
     <li>
      <p>
       将不需要对外提供的内容都隐藏起来，
      </p>
     </li>
     <li>
      <p>
       把属性都隐藏，提供公共方法对其访问。
      </p>
     </li>
    </ol>
    <h4>
     什么是继承？
    </h4>
    <p>
     继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类。
    </p>
    <p>
     子类会“遗传”父类的属性，从而解决代码重用的问题。
    </p>
    <p>
     多态
    </p>
    <p>
     多态指的是一类事物有多种形态
    </p>
    <p>
     请求头Request Headers
    </p>
    <ol>
     <li>
      <p>
       Accept : 指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。
      </p>
     </li>
     <li>
      <p>
       Accept-Encoding : 指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。
      </p>
     </li>
     <li>
      <p>
       Accept-Language : 指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。
      </p>
     </li>
     <li>
      <p>
       Connection ： 表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。
      </p>
     </li>
     <li>
      <p>
       Connec-Length : 请求头的长度。
      </p>
     </li>
     <li>
      <p>
       Connect-Type : 显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。
      </p>
     </li>
     <li>
      <p>
       有关Content-Type属性值可以如下两种编码类型：
      </p>
     </li>
     <li>
      <p>
       “application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。
      </p>
     </li>
     <li>
      <p>
       “multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。
      </p>
     </li>
     <li>
      <p>
       当提交为单单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。
      </p>
     </li>
     <li>
      <p>
       在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。
      </p>
     </li>
     <li>
      <p>
       cookie : 浏览器端cookie。
      </p>
     </li>
     <li>
      <p>
       Hose : 客户端地址
      </p>
     </li>
     <li>
      <p>
       Origin : 目标地址
      </p>
     </li>
     <li>
      <p>
       Referer : 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面
      </p>
     </li>
     <li>
      <p>
       User-Agent : 客户端信息
      </p>
     </li>
     <li>
      <p>
       x－Requested-With : 是否为同步请求 ，如果为XMLHttpRequest，则为 Ajax 异步请求。如果为null则为传统同步请求
      </p>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f545f6861745f6769726c2f:61727469636c652f64657461696c732f313133393731343339" class_="artid" style="display:none">
 </p>
</div>
