---
layout: post
title: "UNIXmacOSè·¯ç”±è¡¨æŸ¥è¯¢åŸç†ä¸å®ç°"
date: 2025-09-06T01:11:34+0800
description: "æœ¬æ–‡ä»‹ç»äº†UNIX/macOSç³»ç»Ÿä¸­è·¯ç”±è¡¨æŸ¥è¯¢çš„æ ¸å¿ƒåŸç†ä¸å®ç°æ–¹æ³•ã€‚é€šè¿‡sysctlç³»ç»Ÿè°ƒç”¨è®¿é—®å†…æ ¸è·¯ç”±è¡¨ï¼Œé‡‡ç”¨äºŒæ¬¡è°ƒç”¨æ¨¡å¼å…ˆè·å–ç¼“å†²åŒºå¤§å°å†è·å–å®é™…æ•°æ®ã€‚è·¯ç”±è¡¨æ•°æ®ç”±rt_msghdrå¤´å’Œå¯å˜é•¿åº¦çš„sockaddrç»“æ„é“¾ç»„æˆï¼Œé€šè¿‡æ ‡å¿—ä½è¿‡æ»¤ã€åœ°å€ç»“æ„è§£æå’Œå…³é”®ä¿¡æ¯æå–ç­‰æ­¥éª¤å¤„ç†è·¯ç”±æ¡ç›®ã€‚ä»£ç å®ç°é‡‡ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†å†…å­˜ï¼Œé€šè¿‡å›è°ƒå‡½æ•°å¤„ç†æ¯æ¡è·¯ç”±ä¿¡æ¯ï¼Œæ”¯æŒç›®æ ‡åœ°å€ã€ç½‘å…³å’Œå­ç½‘æ©ç çš„æå–ã€‚è¯¥æœºåˆ¶ä¸ºç½‘ç»œç¼–ç¨‹æä¾›äº†é«˜æ•ˆçš„è·¯ç”±è¡¨æŸ¥è¯¢æ¥å£ã€‚"
keywords: "UNIX/macOSè·¯ç”±è¡¨æŸ¥è¯¢åŸç†ä¸å®ç°"
categories: ['Markdown', 'Ip', 'C']
tags: ['ç¼–ç¨‹è¯­è¨€', 'æœåŠ¡å™¨', 'å¼€å‘è¯­è¨€', 'Unix', 'Macos', 'C']
artid: "151235617"
arturl: "https://blog.csdn.net/liulilittle/article/details/151235617"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151235617
    alt: "UNIXmacOSè·¯ç”±è¡¨æŸ¥è¯¢åŸç†ä¸å®ç°"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151235617
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151235617
cover: https://bing.ee123.net/img/rand?artid=151235617
image: https://bing.ee123.net/img/rand?artid=151235617
img: https://bing.ee123.net/img/rand?artid=151235617
---



# UNIX/macOSè·¯ç”±è¡¨æŸ¥è¯¢åŸç†ä¸å®ç°



#### ğŸŒ UNIX/macOSè·¯ç”±è¡¨æŸ¥è¯¢åŸç†ä¸å®ç°

---

##### ğŸ“Œ **åŠŸèƒ½å…¨æ™¯å›¾**

ç”¨æˆ·è°ƒç”¨å‡½æ•°

å‚æ•°æ ¡éªŒ

ç¬¬ä¸€æ¬¡sysctlè°ƒç”¨

è·å–ç¼“å†²åŒºå¤§å°

å†…å­˜åˆ†é…

ç¬¬äºŒæ¬¡sysctlè°ƒç”¨

è·å–è·¯ç”±æ•°æ®

éå†è·¯ç”±æ¡ç›®

æ¶ˆæ¯å¤´è§£æ

æ ‡å¿—ä½è¿‡æ»¤

åœ°å€ç»“æ„è§£æ

å…³é”®ä¿¡æ¯æå–

å›è°ƒå¤„ç†

ç»“æœè¿”å›

---

#### ğŸ§  **æ ¸å¿ƒåŸç†**

##### ğŸ”§ **1. sysctlç³»ç»Ÿè°ƒç”¨æœºåˆ¶**

ç”¨æˆ·ç©ºé—´

sysctlç³»ç»Ÿè°ƒç”¨

å†…æ ¸è·¯ç”±è¡¨

è·¯ç”±è¡¨ç»“æ„

rt_msghdrå¤´

sockaddrç»“æ„é“¾

**è·¯ç”±è¡¨åœ¨å†…æ ¸ä¸­çš„ç»„ç»‡æ–¹å¼**ï¼š

```plaintext
+-------------------+-------------------+-------------------+
| rt_msghdr å¤´      | sockaddr ç»“æ„1    | sockaddr ç»“æ„2    |
| (å›ºå®šé•¿åº¦)         | (å¯å˜é•¿åº¦)         | (å¯å˜é•¿åº¦)         |
+-------------------+-------------------+-------------------+
| ä¸‹ä¸€æ¡è·¯ç”±æ¶ˆæ¯      | ...              | ...              |
+-------------------+-------------------+-------------------+

```

---

##### ğŸ“Š **2. è·¯ç”±æ¶ˆæ¯ç»“æ„è§£å‰–**

åŒ…å«

ç»§æ‰¿

rt_msghdr

u_short rtm_msglen

u_char rtm_version

u_char rtm_type

u_short rtm_index

int rtm_flags

int rtm_addrs

pid_t rtm_pid

int rtm_seq

int rtm_errno

int rtm_use

u_long rtm_inits

struct rt_metrics rtm_rmx

sockaddr

u_char sa_len

u_char sa_family

char sa_data[14]

sockaddr_in

u_char sin_len

u_char sin_family

u_short sin_port

struct in_addr sin_addr

char sin_zero[8]

---

#### ğŸ” **ä»£ç è§£æ**

```cpp
// ğŸŒŸ å‡½æ•°å®šä¹‰ï¼šè·å–æ‰€æœ‰IPv4ç½‘å…³è·¯ç”±ä¿¡æ¯
// ğŸ“Œ å‚æ•°ï¼špredicate - å›è°ƒå‡½æ•°ï¼Œç”¨äºå¤„ç†æ¯æ¡è·¯ç”±ä¿¡æ¯
// ğŸ“Œ è¿”å›å€¼ï¼š0æˆåŠŸï¼Œ-1å¤±è´¥
static int FetchAllRouteNtreeStuff(
    const ppp::function<bool(int, uint32_t, uint32_t, uint32_t)>& predicate) noexcept 
{
    // ğŸ”’ å‚æ•°å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å›è°ƒå‡½æ•°æœ‰æ•ˆ
    if (NULL == predicate) {
        return -1; // é”™è¯¯ç ï¼šæ— æ•ˆå‚æ•°
    }

    // ğŸ§© MIB(Management Information Base)æŸ¥è¯¢å‚æ•°é…ç½®
    // å±‚çº§ç»“æ„ï¼šç½‘ç»œå­ç³»ç»Ÿ â†’ è·¯ç”±è¡¨ â†’ æ‰€æœ‰åè®® â†’ IPv4 â†’ è·¯ç”±æ ‡å¿— â†’ ç½‘å…³è·¯ç”±
    int mib[] = { 
        CTL_NET,        // ç½‘ç»œå­ç³»ç»Ÿ
        PF_ROUTE,       // è·¯ç”±è¡¨
        0,              // æ‰€æœ‰åè®®
        AF_INET,        // IPv4åœ°å€æ—
        NET_RT_FLAGS,   // æŒ‰æ ‡å¿—è¿”å›è·¯ç”±
        RTF_GATEWAY     // ç½‘å…³è·¯ç”±æ ‡å¿—
    };
    size_t needed = 0; // å­˜å‚¨æ‰€éœ€ç¼“å†²åŒºå¤§å°

    // ğŸ“ ç¬¬ä¸€æ¬¡sysctlè°ƒç”¨ï¼šè·å–æ‰€éœ€ç¼“å†²åŒºå¤§å°
    // âš ï¸ å…³é”®ç‚¹ï¼šé€šè¿‡NULLç¼“å†²åŒºè·å–å®é™…æ•°æ®å¤§å°
    if (sysctl(mib, arraysizeof(mib), NULL, &needed, NULL, 0) < 0) {
        return -1; // ç³»ç»Ÿè°ƒç”¨å¤±è´¥
    }

    // ğŸ’¾ æ™ºèƒ½å†…å­˜ç®¡ç†ï¼šä½¿ç”¨shared_ptrè‡ªåŠ¨é‡Šæ”¾å†…å­˜
    std::shared_ptr<Byte> buffer_managed = ppp::make_shared_alloc<Byte>(needed);
    if (NULL == buffer_managed) {
        return -1; // å†…å­˜åˆ†é…å¤±è´¥
    }

    char* buffer = (char*)buffer_managed.get(); // è·å–åŸå§‹ç¼“å†²åŒºæŒ‡é’ˆ

    // ğŸ“¦ ç¬¬äºŒæ¬¡sysctlè°ƒç”¨ï¼šè·å–å®é™…è·¯ç”±æ•°æ®
    if (sysctl(mib, arraysizeof(mib), buffer, &needed, NULL, 0) < 0) {
        return -1; // æ•°æ®è·å–å¤±è´¥
    }

    struct rt_msghdr* rtm = NULL; // è·¯ç”±æ¶ˆæ¯å¤´æŒ‡é’ˆ
    char* buffer_end = buffer + needed; // ç¼“å†²åŒºç»“æŸä½ç½®

    // ğŸ”„ è·¯ç”±æ¡ç›®éå†ç®—æ³•
    for (char* i = buffer; i < buffer_end; i += rtm->rtm_msglen) 
    {
        rtm = (struct rt_msghdr*)(i); // å½“å‰è·¯ç”±æ¶ˆæ¯å¤´

        // ğŸš¦ æ¶ˆæ¯ç±»å‹è¿‡æ»¤ï¼šåªå¤„ç†RTM_GETç±»å‹
        if (rtm->rtm_type != RTM_GET) continue; 

        // ğŸš© è·¯ç”±æ ‡å¿—ä¸‰é‡è¿‡æ»¤æœºåˆ¶
        if (!(rtm->rtm_flags & RTF_UP)) continue;   // è¿‡æ»¤éæ´»è·ƒè·¯ç”±
        if (!(rtm->rtm_flags & RTF_GATEWAY)) continue; // ç¡®ä¿æ˜¯ç½‘å…³è·¯ç”±

        // ğŸ§© åœ°å€ç»“æ„è§£æç³»ç»Ÿ
        struct sockaddr* sa_tab[RTAX_MAX] = {0}; // åœ°å€ç»“æ„æŒ‡é’ˆè¡¨
        struct sockaddr* sa = (struct sockaddr*)(rtm + 1); // é¦–ä¸ªåœ°å€ç»“æ„ä½ç½®

        // ğŸ”¢ åœ°å€ç»“æ„éå†ç®—æ³•
        for (int j = 0; j < RTAX_MAX; j++) {
            if (rtm->rtm_addrs & (1 << j)) {
                sa_tab[j] = sa; // è®°å½•åœ°å€ç»“æ„ä½ç½®
                // ğŸ“ åœ°å€ç»“æ„å¯¹é½è®¡ç®—ï¼šsa_len + å¡«å……å­—èŠ‚
                sa = (struct sockaddr*)((char*)sa + ROUNDUP(sa->sa_len));
            }
        }

        // ğŸ¯ è·¯ç”±ä¸‰è¦ç´ æå–ç³»ç»Ÿ
        uint32_t ip = IPEndPoint::AnyAddress; 
        uint32_t gw = IPEndPoint::AnyAddress;
        uint32_t mask = IPEndPoint::AnyAddress;

        // 1. ç›®æ ‡åœ°å€æå–å™¨
        if (rtm->rtm_addrs & (1 << RTAX_DST)) {
            struct sockaddr_in* sa = (struct sockaddr_in*)(sa_tab[RTAX_DST]);
            if (sa->sin_family == AF_INET) {
                ip = sa->sin_addr.s_addr; // ç½‘ç»œå­—èŠ‚åºIP
            }
        }

        // 2. ç½‘å…³åœ°å€æå–å™¨
        if (rtm->rtm_addrs & (1 << RTAX_GATEWAY)) {
            struct sockaddr_in* sa = (struct sockaddr_in*)(sa_tab[RTAX_GATEWAY]);
            if (sa->sin_family == AF_INET) {
                gw = sa->sin_addr.s_addr;
            }
        }

        // 3. å­ç½‘æ©ç æå–å™¨
        if (rtm->rtm_addrs & (1 << RTAX_NETMASK)) {
            struct sockaddr_in* sa = (struct sockaddr_in*)(sa_tab[RTAX_NETMASK]);
            mask = sa->sin_addr.s_addr; 
        }

        // ğŸ“ å›è°ƒæ‰§è¡Œç³»ç»Ÿï¼šè¿”å›trueç»ˆæ­¢éå†
        if (predicate(rtm->rtm_index, ip, gw, mask)) {
            break;
        }
    }

    return 0; // æˆåŠŸè¿”å›
}

```

---

#### ğŸ§© **å†…æ ¸è·¯ç”±è¡¨**

##### ğŸ“Š **è·¯ç”±è¡¨æ•°æ®ç»“æ„æ‹“æ‰‘**

è·¯ç”±è¡¨

è·¯ç”±æ¡ç›®1

è·¯ç”±æ¡ç›®2

è·¯ç”±æ¡ç›®3

rt_msghdr

ç›®æ ‡åœ°å€

ç½‘å…³åœ°å€

å­ç½‘æ©ç 

rt_msghdr

ç›®æ ‡åœ°å€

ç½‘å…³åœ°å€

rt_msghdr

ç›®æ ‡åœ°å€

ç½‘å…³åœ°å€

å­ç½‘æ©ç 

##### ğŸ” **è·¯ç”±æ ‡å¿—ä½çŸ©é˜µ**

| æ ‡å¿—ä½ | åå…­è¿›åˆ¶å€¼ | åŠŸèƒ½æè¿° |
| --- | --- | --- |
| `RTF_UP` | 0x1 | è·¯ç”±å¤„äºæ´»è·ƒçŠ¶æ€ |
| `RTF_GATEWAY` | 0x2 | è·¯ç”±æŒ‡å‘ç½‘å…³ |
| `RTF_HOST` | 0x4 | ä¸»æœºè·¯ç”±ï¼ˆéç½‘ç»œè·¯ç”±ï¼‰ |
| `RTF_REJECT` | 0x8 | æ‹’ç»åŒ¹é…çš„è·¯ç”± |
| `RTF_DYNAMIC` | 0x10 | åŠ¨æ€åˆ›å»ºçš„è·¯ç”± |
| `RTF_MODIFIED` | 0x20 | è·¯ç”±è¢«åŠ¨æ€ä¿®æ”¹ |
| `RTF_STATIC` | 0x800 | é™æ€è·¯ç”± |

---

#### ğŸ› ï¸ **å†…å­˜ç®¡ç†**

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/c37625e0b88c4985a395a05256963b1e.png)

**å†…å­˜å¯¹é½è®¡ç®—åŸç†**ï¼š

```c
#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

```

* ç¡®ä¿æ¯ä¸ªsockaddrç»“æ„æŒ‰longç±»å‹å¯¹é½
* é¿å…ä¸åŒæ¶æ„ä¸‹çš„å†…å­˜è®¿é—®é”™è¯¯

---

#### âš¡ **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**

##### ğŸ“Š **è·¯ç”±æ¡ç›®è¿‡æ»¤æ•ˆç‡å¯¹æ¯”**

| è¿‡æ»¤é˜¶æ®µ | è¿‡æ»¤æ¯”ä¾‹ | æ€§èƒ½å½±å“ |
| --- | --- | --- |
| æ¶ˆæ¯ç±»å‹è¿‡æ»¤ | 50% | é«˜ |
| æ ‡å¿—ä½åˆçº§è¿‡æ»¤ | 30% | ä¸­ |
| åœ°å€æ—æ·±åº¦è¿‡æ»¤ | 10% | ä½ |

##### ğŸ”§ **å››å±‚ä¼˜åŒ–æœºåˆ¶**ï¼š

1. **é¢„è¿‡æ»¤æœºåˆ¶**ï¼šé€šè¿‡MIBå‚æ•°`RTF_GATEWAY`å‡å°‘æ•°æ®é‡
2. **å¿«é€Ÿä¸¢å¼ƒç­–ç•¥**ï¼šä¸‰å±‚æ ‡å¿—ä½è¿‡æ»¤ï¼ˆç±»å‹ã€UPçŠ¶æ€ã€ç½‘å…³æ ‡å¿—ï¼‰
3. **æƒ°æ€§è§£æ**ï¼šä»…è§£æéœ€è¦çš„åœ°å€ç»“æ„ï¼ˆDST/GATEWAY/NETMASKï¼‰
4. **çŸ­è·¯è¯„ä¼°**ï¼šå›è°ƒè¿”å›trueæ—¶ç«‹å³ç»ˆæ­¢éå†

---

#### ğŸŒ° **çœŸå®è·¯ç”±è§£æç¤ºä¾‹**

**è·¯ç”±æ¡ç›®äºŒè¿›åˆ¶å¸ƒå±€**ï¼š

```
+------------------------+-------------------+-------------------+-------------------+
| rt_msghdr (112å­—èŠ‚)    | sockaddr_in (16B) | sockaddr_in (16B) | sockaddr_in (16B) |
+------------------------+-------------------+-------------------+-------------------+
| rtm_type: RTM_GET      | sin_family: AF_INET | sin_family: AF_INET | sin_family: AF_INET |
| rtm_flags: 0x3 (UP+GW) | sin_addr: 10.0.0.0 | sin_addr: 10.0.0.1 | sin_addr: 255.0.0.0 |
| rtm_addrs: 0x7         | (ç›®æ ‡ç½‘ç»œ)         | (ç½‘å…³åœ°å€)         | (å­ç½‘æ©ç )         |
+------------------------+-------------------+-------------------+-------------------+

```

**è§£æè¿‡ç¨‹**ï¼š

1. éªŒè¯rtm_type == RTM_GET
2. æ£€æŸ¥flagsåŒ…å«RTF_UP|RTF_GATEWAY
3. è§£æåœ°å€ç»“æ„ï¼š
   * RTAX_DST: 10.0.0.0
   * RTAX_GATEWAY: 10.0.0.1
   * RTAX_NETMASK: 255.0.0.0
4. å›è°ƒå‚æ•°ï¼š(æ¥å£ç´¢å¼•, 0x0A000000, 0x0A000001, 0xFF000000)

---

#### âš ï¸ **è¾¹ç•Œæ¡ä»¶ä¸å¼‚å¸¸å¤„ç†**

##### ğŸ“œ **é”™è¯¯å¤„ç†çŸ©é˜µ**

| é”™è¯¯ç±»å‹ | æ£€æµ‹æ–¹å¼ | å¤„ç†æ–¹æ¡ˆ |
| --- | --- | --- |
| æ— æ•ˆå›è°ƒæŒ‡é’ˆ | NULLæ£€æŸ¥ | ç«‹å³è¿”å›-1 |
| ç¬¬ä¸€æ¬¡sysctlå¤±è´¥ | è¿”å›å€¼<0 | è¿”å›-1 |
| å†…å­˜åˆ†é…å¤±è´¥ | buffer_managed == NULL | è¿”å›-1 |
| ç¬¬äºŒæ¬¡sysctlå¤±è´¥ | è¿”å›å€¼<0 | è¿”å›-1 |
| åœ°å€ç»“æ„è¶Šç•Œ | i += rtm_msglen èŒƒå›´æ£€æŸ¥ | å¾ªç¯ç»ˆæ­¢ |
| éæ³•åœ°å€æ— | sin_family != AF_INET | è·³è¿‡å½“å‰æ¡ç›® |

##### ğŸ›¡ï¸ **å®‰å…¨é˜²æŠ¤æœºåˆ¶**ï¼š

1. **ç¼“å†²åŒºè¾¹ç•Œä¿æŠ¤**ï¼š`i < buffer_end`
2. **æ¶ˆæ¯é•¿åº¦éªŒè¯**ï¼š`rtm_msglen > sizeof(rt_msghdr)`
3. **åœ°å€é•¿åº¦æ ¡éªŒ**ï¼š`sa_len`æœ‰æ•ˆæ€§æ£€æŸ¥
4. **æ™ºèƒ½æŒ‡é’ˆæ‰˜ç®¡**ï¼šè‡ªåŠ¨å†…å­˜é‡Šæ”¾

---

#### ğŸ’ **å®Œæ•´ä»£ç å®ç°ï¼ˆå·¥ä¸šçº§ï¼‰**

```cpp
/**
 * ğŸŒ è·å–ç³»ç»ŸIPv4ç½‘å…³è·¯ç”±è¡¨
 * ğŸš€ é«˜æ€§èƒ½å®ç°ï¼šåŒç¼“å†²ç­–ç•¥+æ™ºèƒ½å†…å­˜ç®¡ç†+å››çº§è¿‡æ»¤
 * âš ï¸ æ³¨æ„ï¼šè¿”å›çš„IPåœ°å€ä¸ºç½‘ç»œå­—èŠ‚åº
 * 
 * @param predicate è·¯ç”±å¤„ç†å›è°ƒå‡½æ•°
 * @return 0æˆåŠŸï¼Œ-1å¤±è´¥
 */
static int FetchAllRouteNtreeStuff(
    const ppp::function<bool(int, uint32_t, uint32_t, uint32_t)>& predicate) noexcept 
{
    // ğŸ”’ å‚æ•°å®‰å…¨æ£€æŸ¥
    if (NULL == predicate) {
        return -1; // é”™è¯¯ç ï¼šEINVAL
    }

    // ğŸ§© MIBé…ç½®ï¼šIPv4ç½‘å…³è·¯ç”±
    int mib[] = { CTL_NET, PF_ROUTE, 0, AF_INET, NET_RT_FLAGS, RTF_GATEWAY };
    size_t needed = 0;

    // ğŸ“ ç¬¬ä¸€é˜¶æ®µï¼šè·å–ç¼“å†²åŒºå¤§å°
    if (sysctl(mib, arraysizeof(mib), NULL, &needed, NULL, 0) < 0) {
        return -1; // ç³»ç»Ÿé”™è¯¯
    }

    // ğŸ’¾ æ™ºèƒ½å†…å­˜åˆ†é…ï¼ˆå¼‚å¸¸å®‰å…¨ï¼‰
    std::shared_ptr<Byte> buffer_managed = ppp::make_shared_alloc<Byte>(needed);
    if (!buffer_managed) {
        return -1; // å†…å­˜ä¸è¶³
    }

    char* buffer = reinterpret_cast<char*>(buffer_managed.get());
    
    // ğŸ“¦ ç¬¬äºŒé˜¶æ®µï¼šè·å–è·¯ç”±æ•°æ®
    if (sysctl(mib, arraysizeof(mib), buffer, &needed, NULL, 0) < 0) {
        return -1; // ç³»ç»Ÿé”™è¯¯
    }

    // ğŸ§­ è·¯ç”±éå†ç³»ç»Ÿ
    char* current = buffer;
    char* const buffer_end = buffer + needed;
    
    while (current < buffer_end) {
        struct rt_msghdr* rtm = reinterpret_cast<struct rt_msghdr*>(current);
        
        // âš ï¸ è¾¹ç•Œä¿æŠ¤ï¼šæ— æ•ˆæ¶ˆæ¯é•¿åº¦
        if (rtm->rtm_msglen < sizeof(struct rt_msghdr)) break;
        
        // ğŸš¦ æ¶ˆæ¯ç±»å‹è¿‡æ»¤
        if (rtm->rtm_type != RTM_GET) {
            current += rtm->rtm_msglen;
            continue;
        }

        // ğŸš© æ ‡å¿—ä½ä¸‰é‡è¿‡æ»¤
        const bool is_valid_route = (rtm->rtm_flags & RTF_UP) && 
                                  (rtm->rtm_flags & RTF_GATEWAY);
        if (!is_valid_route) {
            current += rtm->rtm_msglen;
            continue;
        }

        // ğŸ§© åœ°å€è§£æç³»ç»Ÿ
        struct sockaddr* sa_tab[RTAX_MAX] = {0};
        struct sockaddr* sa = reinterpret_cast<struct sockaddr*>(rtm + 1);
        const char* const msg_end = current + rtm->rtm_msglen;

        for (int j = 0; j < RTAX_MAX; j++) {
            if (!(rtm->rtm_addrs & (1 << j))) {
                sa_tab[j] = nullptr;
                continue;
            }
            
            // âš ï¸ åœ°å€ç»“æ„è¾¹ç•Œæ£€æŸ¥
            if (reinterpret_cast<char*>(sa) >= msg_end) break;
            
            sa_tab[j] = sa;
            sa = reinterpret_cast<struct sockaddr*>(
                reinterpret_cast<char*>(sa) + ROUNDUP(sa->sa_len));
        }

        // ğŸ¯ è·¯ç”±ä¸‰è¦ç´ æå–
        uint32_t ip = 0, gw = 0, mask = 0;
        bool valid_entry = true;

        // ç›®æ ‡åœ°å€æå–
        if (sa_tab[RTAX_DST] && sa_tab[RTAX_DST]->sa_family == AF_INET) {
            ip = reinterpret_cast<sockaddr_in*>(sa_tab[RTAX_DST])->sin_addr.s_addr;
        } else {
            valid_entry = false;
        }

        // ç½‘å…³åœ°å€æå–
        if (sa_tab[RTAX_GATEWAY] && sa_tab[RTAX_GATEWAY]->sa_family == AF_INET) {
            gw = reinterpret_cast<sockaddr_in*>(sa_tab[RTAX_GATEWAY])->sin_addr.s_addr;
        } else {
            valid_entry = false;
        }

        // å­ç½‘æ©ç æå–ï¼ˆå¯é€‰ï¼‰
        if (sa_tab[RTAX_NETMASK] && sa_tab[RTAX_NETMASK]->sa_family == AF_INET) {
            mask = reinterpret_cast<sockaddr_in*>(sa_tab[RTAX_NETMASK])->sin_addr.s_addr;
        }

        // ğŸ“ å›è°ƒæ‰§è¡Œï¼ˆä»…æœ‰æ•ˆè·¯ç”±ï¼‰
        if (valid_entry && predicate(rtm->rtm_index, ip, gw, mask)) {
            break; // å›è°ƒè¦æ±‚ç»ˆæ­¢éå†
        }

        current += rtm->rtm_msglen;
    }

    return 0; // æˆåŠŸè¿”å›
}

```

---

#### ğŸ“š **æ€»ç»“**

ç”¨æˆ·è°ƒç”¨

å®‰å…¨æ ¡éªŒ

åŒé˜¶æ®µsysctl

æ™ºèƒ½å†…å­˜ç®¡ç†

è·¯ç”±éå†å¼•æ“

å››çº§è¿‡æ»¤ç³»ç»Ÿ

åœ°å€è§£æå™¨

ä¸‰è¦ç´ æå–

å›è°ƒæ‰§è¡Œ

ç»“æœè¿”å›

**æ ¸å¿ƒç‚¹**ï¼š

1. **åŒç¼“å†²ç­–ç•¥**ï¼šç²¾ç¡®å†…å­˜åˆ†é…é¿å…æµªè´¹
2. **å››çº§è¿‡æ»¤ç³»ç»Ÿ**ï¼šé€å±‚å‡å°‘æ— æ•ˆå¤„ç†
3. **è¾¹ç•Œå®‰å…¨é˜²æŠ¤**ï¼šå…¨é¢é˜²è¶Šç•Œå¤„ç†
4. **æ™ºèƒ½å†…å­˜ç®¡ç†**ï¼šå¼‚å¸¸å®‰å…¨ä¿è¯
5. **ç»“æ„åŒ–è§£æå¼•æ“**ï¼šæ¨¡å—åŒ–å¤„ç†æµç¨‹

---

#### ğŸŒŸ **åº”ç”¨åœºæ™¯**

1. ç½‘ç»œè¯Šæ–­å·¥å…·å®ç°
2. è·¯ç”±ç›‘æ§ç³»ç»Ÿ
3. VPNåº”ç”¨çš„è·¯ç”±ç®¡ç†
4. ç½‘ç»œæ‹“æ‰‘å‘ç°
5. é˜²ç«å¢™ç­–ç•¥å¼•æ“
6. è´Ÿè½½å‡è¡¡ç³»ç»Ÿ



