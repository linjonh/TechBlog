---
layout: post
title: "C修炼之路初识C"
date: 2025-03-08 15:57:28 +0800
description: "C++修炼之路：初识C++"
keywords: "C++修炼之路：初识C++"
categories: ['C']
tags: ['算法', 'C']
artid: "146079888"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146079888
    alt: "C修炼之路初识C"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146079888
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146079888
cover: https://bing.ee123.net/img/rand?artid=146079888
image: https://bing.ee123.net/img/rand?artid=146079888
img: https://bing.ee123.net/img/rand?artid=146079888
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++修炼之路：初识C++
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      <strong>
       Hello大家好！很高兴我们又见面啦！给生活添点passion，开始今天的编程之路！
      </strong>
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/91bfeb2bb1414a2ebf09cbc4f9706779.gif"/>
     </p>
     <p>
      <strong>
       我的博客：
      </strong>
      <a href="https://blog.csdn.net/2401_87995839?spm=1011.2266.3001.5343" title="&lt;但凡.">
       &lt;但凡.
      </a>
     </p>
     <p>
      <strong>
       我的专栏：
      </strong>
      <a href="https://blog.csdn.net/2401_87995839/category_12829275.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12829275&amp;sharerefer=PC&amp;sharesource=2401_87995839&amp;sharefrom=from_link" title="《编程之路》">
       《编程之路》
      </a>
      、
      <a href="https://blog.csdn.net/2401_87995839/category_12848831.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12848831&amp;sharerefer=PC&amp;sharesource=2401_87995839&amp;sharefrom=from_link" title="《数据结构与算法之美》">
       《数据结构与算法之美》
      </a>
      、
      <a href="https://blog.csdn.net/2401_87995839/category_12845996.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12845996&amp;sharerefer=PC&amp;sharesource=2401_87995839&amp;sharefrom=from_link" title="《题海拾贝》">
       《题海拾贝》
      </a>
     </p>
     <p>
      <strong>
       欢迎点赞，关注！
      </strong>
     </p>
    </blockquote>
    <h2>
     引言
    </h2>
    <p>
     ‌
     <strong>
      C++
     </strong>
     ‌，通常被称为“C加加”，是一种由
     <a href="https://www.baidu.com/s?tn=15007414_24_dg&amp;wd=Bjarne%20Stroustrup&amp;usm=3&amp;ie=utf-8&amp;rsv_pq=94dd757200020d90&amp;oq=c%E5%8A%A0%E5%8A%A0%E6%98%AF%E4%BB%80%E4%B9%88&amp;rsv_t=e283GIY6WnFwc0a3CNepQ%2BYXDKJKcAzXOFzUHi8%2Fz%2BYvL3yz4%2B2wt3NdcUjYBpTgG6CnobE&amp;rsv_dl=re_dqa_generate&amp;sa=re_dqa_generate" rel="nofollow" title="Bjarne Stroustrup">
      Bjarne Stroustrup
     </a>
     在1983年开发的通用编程语言。它是由C语言扩展升级而来，支持面向对象程序设计、过程化程序设计等多种编程范式。‌
    </p>
    <p>
     C++的应用领域服务器端、游戏（引擎）、机器学习引擎、音视频处理、嵌入式软件、电信设备、金融 应用、基础库、操作系统、编译器、基础架构、基础工具、硬件交互等很多方面都有。
    </p>
    <p>
     本篇文章作为c++基础教学的第一篇，将带大家认识和简单使用c++。
    </p>
    <h2>
     <br/>
     1、C++的第一个程序
    </h2>
    <p>
     <strong>
      万物始于hello world
     </strong>
     .现在我们来用
     <strong>
      c++
     </strong>
     写一个hello world：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
	cout &lt;&lt; "hello world" &lt;&lt; endl;

	return 0;
}
</code></pre>
    <p>
     我们来分析一下这个程序：首先和C语言一样，上来先包括一个头文件。这里我们包过的头文件是
     <strong>
      iostream
     </strong>
     库，意思是输入输出流。
     <strong>
      里面包含着c++最常用的输入和输出
     </strong>
     。
    </p>
    <p>
     接下来一行叫展开
     <strong>
      命名空间
     </strong>
     。只有展开的这个明明空间我们的iostream库里的函数才能随便使用。当然了至于什么是命名空间以及为什么要展开我们下文再谈。
    </p>
    <p>
     下面一行和我们的c语言一样，都是int main。这里的int main和C语言中的一样就不过多赘述了。
    </p>
    <p>
     接下来一行是输出hello world这个字符串。cout是iostream库中提供的输出函数。用法就是
     <strong>
      cout&lt;&lt;输出内容
     </strong>
     。后面的
     <strong>
      endl是换行（endline）
     </strong>
     ，但和C语言里面的\n不用，
     <strong>
      endl是一个函数
     </strong>
     。
    </p>
    <h2>
     2、命名空间
    </h2>
    <h3>
     2.1命名空间的定义及使用
    </h3>
    <p>
     <strong>
      命名空间namespace存在的意义是为了解决命名冲突。
     </strong>
     在C语言中实现这个代码
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int rand = 10;
int main()
{
 // 编译报错：error C2365: “rand”: 重定义；以前的定义是“函数” 
 printf("%d\n", rand);
 return 0;
}
</code></pre>
    <p>
     会报错。
     <strong>
      报错的原因就是我们自己定的变量rand和C语言自带的库函数冲突了。
     </strong>
     这时候编译器就无法识别了。这其实是C语言的不足之处。而c++中的命名空间就完美的解决了这个问题。
    </p>
    <p>
     想想一下这个场景。小张和小王同时进行一个项目，但是他俩写的函数名有时候会相同，不如小张的加法函数叫test，小王的乘法函数叫test，那这时候都不用和系统自带的函数冲突了，两个人写的函数就已经冲突了。这个时候namespace的用处就来了。我们把小张和小王的代码写成下面这样：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
namespace mrZhang
{
	int test(int x, int y)
	{
		return x + y;
	}
}
namespace mrWang
{
	int test(int x, int y)
	{
		return x * y;
	}
}
int main()
{
	int a = mrZhang::test(1, 5);
	int b = mrWang::test(1, 5);
	cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
	return 0;
}
</code></pre>
    <p>
     输出一下，分别是6和5，小张和小王的代码可以毫不冲突的正常使用了。
    </p>
    <p>
     <strong>
      其实命名空间本质上是定义出一个域
     </strong>
     ，我们小张和小王各有一个域，那他们从自己的域里面调用自己的函数不就毫不冲突了吗？
    </p>
    <p>
     在调用的时候，我们只要用 空间名：：函数名 这样的格式来调用。
    </p>
    <p>
     <strong>
      命名空间还可以进行嵌套，
     </strong>
     比如这样：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
namespace mrZhang
{
	int test(int x, int y)
	{
		return x + y;
	}
	namespace mrWang
	{
		int test(int x, int y)
		{
			return x * y;
		}
	}

}
int main()
{
	int a = mrZhang::test(1, 5);
	int b = mrZhang::mrWang::test(1, 5);
	cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b;
	return 0;
}
</code></pre>
    <p>
     输出结果仍然是6和5。
    </p>
    <p>
     <strong>
      命名空间中不止可以定义函数，也可以定义变量和自定义类型。
     </strong>
     这样的话你自己定义的变量也可以和别的同名变量毫不冲突了。
    </p>
    <p>
     <strong>
      另外在多文件中可以定义同名的命名空间。这样的话他们就会合成一个命名空间。
     </strong>
    </p>
    <h3>
     2.2命名空间的展开
    </h3>
    <p>
     现在看我们第一个helloworld程序，第二行的using namespace std；就是
     <strong>
      展开命名空间
     </strong>
     。正常我们使用输入输出函数是这样的：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
int main()
{
	std::cout &lt;&lt; "hello world" &lt;&lt; std::endl;

	return 0;
}
</code></pre>
    <p>
     当我们程序比较简单，
     <strong>
      不会出现冲突的命名的时候就可以把命名空间展开。
     </strong>
    </p>
    <p>
     比如平时的简单练习程序，或者算法题，我们就可以直接Using namespace std;把命名空间展开直接使用c++自带的函数。
    </p>
    <p>
     我们也可以只展开一个命名空间中的某个变量或函数，这样的话访问这个变量或函数就更简便了：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
namespace mrZhang
{
	int test(int x, int y)
	{
		return x + y;
	}
}
using mrZhang::test;
int main()
{
	int a = test(1, 5);

	cout &lt;&lt; a;
	return 0;
}
</code></pre>
    <h2>
     3、缺省参数
    </h2>
    <p>
     <strong>
      缺省参数是声明或定义函数时为函数的参数指定⼀个缺省值。
     </strong>
     在调用该函数时，如果没有指定实参 则采用该形参的缺省值，否则使用指定的实参，缺省参数分为全缺省和半缺省参数。
    </p>
    <p>
     <strong>
      缺省参数又叫默认参数。
     </strong>
    </p>
    <p>
     比如我们定义一个这样的函数：
    </p>
    <pre><code class="language-cpp">int test(int x=2, int y=6)
{
	return x + y;
}</code></pre>
    <p>
     我们调用这个函数但是不传入实参，返回结果就是8.
    </p>
    <p>
     如果再调用时我们传入实参1和2，那么返回值就是1+2=3。
    </p>
    <p>
     需要注意三点：
    </p>
    <p>
     <strong>
      1、缺省参数必须从右往左给。比如上面的程序，我们只给x缺省参数但不给y缺省参数这样其实是不合法的。
     </strong>
    </p>
    <p>
     <strong>
      2、函数实参一定是从左往右给函数的。
     </strong>
    </p>
    <p>
     <strong>
      3、函数声明和定义分离时，不能在声明和定义中同时给缺省值。
     </strong>
    </p>
    <p>
     比如这样，其实是不合法的：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int test(int x = 1, int y = 2);
int main()
{
	int a = test();
	cout &lt;&lt; a;
	return 0;
}
int test(int x = 1, int y = 2)
{
	return x + y;
}</code></pre>
    <p>
     我们只能在声明中给，不能在定义中给。
    </p>
    <h2>
     4、函数重载
    </h2>
    <p>
     <strong>
      在c++中允许出现同名函数，但是同名函数的返回值或者形参类型或形参个数必须有一个不同。在调用函数时，c++可以根据传入实参的类型自动选择正确的函数。
     </strong>
     比如这样：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int test(int x , int y )
{
	return x + y;
}
double test(double x, double y)
{
	return x + y;
}
int main()
{
	double x = 1.5, y = 2.8;
	int a = test(1,2);
	double b = test(x, y);
	cout &lt;&lt; a &lt;&lt;" "&lt;&lt; b ;
	return 0;
}
</code></pre>
    <h2>
     5、引用
    </h2>
    <h3>
     5.1引用的介绍
    </h3>
    <p>
     引用其实就是给我们已有的一个变量去别名。并不会开辟新的空间。它的使用格式是这样的：
     <strong>
      类型&amp;引用别名=引用对象;
     </strong>
    </p>
    <p>
     就像每个人都有大名和乳名一样，我叫这两个名字其实指的人都是一个。比如这样：
    </p>
    <pre><code class="language-cpp">int i = 5;
int&amp; j = i;</code></pre>
    <p>
     此时我们改变j就相当于改变了i。那这个东西有什么意义呢？回想我们在C语言阶段学习指针的时候，交换两个数的函数得用指针变量做形参。有了引用这个东西，我们就可以这样写交换函数
    </p>
    <pre><code class="language-cpp">void Swap(int&amp; a, int&amp; b)
{
	int tmp = a;
	a = b;
	b = tmp;
}</code></pre>
    <p>
     怎么样，是不是方便了很多呢?
    </p>
    <p>
     <strong>
      其实引用的底层也是指针。所以说通过引用我们能够改变原值。
     </strong>
    </p>
    <h3>
     5.2引用的特性
    </h3>
    <p>
     <strong>
      1、引用必须在定义时初始化。比如int&amp; a=0;这句代码其实是不合法的。
     </strong>
    </p>
    <p>
     <strong>
      2、一个变量可以有多个引用。
     </strong>
    </p>
    <p>
     <strong>
      3、引用一旦引用一个实体，再不能引用其他实体。
     </strong>
    </p>
    <p>
     比如下面这串代码：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
	int a = 10;
	int&amp; b = a;
	int c = 20;
	b = c;
	cout &lt;&lt; &amp;a &lt;&lt;" "&lt;&lt; &amp;b &lt;&lt;" "&lt;&lt; &amp;c &lt;&lt; endl;
	cout &lt;&lt; a &lt;&lt;" "&lt;&lt; b &lt;&lt;" "&lt;&lt; c &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     我们进行了b=c的操作，只是把c的值赋值给了b，但并没有改变b的引用实例，正因此a和b地址是相同的。
    </p>
    <h3>
     5.3引用的使用
    </h3>
    <p>
     <strong>
      引用在实践中主要是于引用传参和引用做返回值中减少拷贝提高效率和改变引用对象时同时改变被 引用对象。
     </strong>
    </p>
    <p>
     引用传参我们已经介绍过了，现在我们介绍一下引用做返回值。
    </p>
    <pre><code class="language-cpp">int STTop(ST&amp; rs)
{
 assert(rs.top &gt; 0);
 return rs.a[rs.top];
}
int main()
{
 ST st1;
 STInit(st1);
 STPush(st1, 1);
 STPush(st1, 2);
 STTop(st1)+=10;
 return 0;
}
</code></pre>
    <p>
     我们截取了一部分之前栈的操作，发现对于STTop(st1)+=10;这个操作是无法达到目的的。
    </p>
    <p>
     我们想的是让栈顶的数据加上10，但是实际上栈顶的数据并没有改变。
    </p>
    <p>
     这是因为咱们返回的是一个值，相当于我们把原来的数拷贝出了他的值然后返回了，就算把这份拷贝的值加上10也无法改变原来的栈顶数据。而且实际上值的拷贝具有常性，根本就无法改变，导致这个程序报错。所以从哪个角度来说栈顶数据都无法被更改。
    </p>
    <p>
     <img src="https://i-blog.csdnimg.cn/direct/8cc0d06b54af451b9b984c96fc2ac2b4.png"/>
    </p>
    <p>
     但是我们如果是引用返回的话，就可以成功改变栈顶的值，因为我们是直接对栈顶这个区域进行的操作。
    </p>
    <h3>
     5.4、const引用
    </h3>
    <p>
     <strong>
      const对象必须用const引用，普通对象也可以用const引用，但普通引用引用不了const对象。
     </strong>
     <img src="https://i-blog.csdnimg.cn/direct/a96f162e75e644e884aa6c6e26104ed5.png"/>
    </p>
    <p>
     这涉及到权限的问题。普通对象是一个变量，可以被改变的，所以他的权限更低。而const对象不能被改变所以他的权限更高。普通引用引用const对象权限就放大了，所以编译器会报错。反过来const引用可以引用普通对象，因为权限是可以缩小的。
    </p>
    <h2>
     6、inline内联
    </h2>
    <p>
     由于C语言中宏函数设计的不足，c++中inline的诞生就是为了代替宏函数。
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
inline int add(int x,int y)
{
	return x + y;
}
int main()
{
	cout &lt;&lt; add(1, 5) &lt;&lt; endl;

	return 0;
}</code></pre>
    <p>
     <strong>
      对于短小的函数，inline操作会使函数在编译时展开，可以提高效率。但是如果这个函数过长就不适合使用内联了，过长的函数内联反而会降低时间，
     </strong>
     甚至，有的编译器防止用户内联过长的函数，就算内联了，也不会起内联的作用。
    </p>
    <p>
     <strong>
      注意，内联函数的定义和声明必须在同一个文件。
     </strong>
    </p>
    <p>
     <strong>
      好了，今天的内容就分享到这，我们下期再见！
     </strong>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38373939353833392f:61727469636c652f64657461696c732f313436303739383838" class_="artid" style="display:none">
 </p>
</div>


