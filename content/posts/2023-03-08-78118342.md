---
layout: post
title: "JAVA-8函数式编程六怎样复用Stream对象"
date: 2023-03-08 17:17:32 +0800
description: "在JAVA 8的Stream方法中，分为两大类，一类是惰性求值，另一类是立刻求值，只要Stream调"
keywords: "stream里 return jaba"
categories: ['Java']
tags: ['复用Stream', '函数式编程', 'Stream', 'Reduce', 'Java']
artid: "78118342"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=78118342
    alt: "JAVA-8函数式编程六怎样复用Stream对象"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=78118342
featuredImagePreview: https://bing.ee123.net/img/rand?artid=78118342
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JAVA 8函数式编程（六）：怎样复用Stream对象
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在JAVA 8的Stream方法中，分为两大类，一类是惰性求值，另一类是立刻求值，只要Stream调用了立刻求值，Stream就会自动关闭，如果再次调用，将会提示如下错误：
    </p>
    <pre class="prettyprint"><code class="hljs avrasm"><span class="hljs-label">java.lang.IllegalStateException:</span> stream has already been operated upon <span class="hljs-keyword">or</span> closed
    at java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.stream</span><span class="hljs-preprocessor">.AbstractPipeline</span><span class="hljs-preprocessor">.evaluate</span>(AbstractPipeline<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">229</span>)
    at java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.stream</span><span class="hljs-preprocessor">.ReferencePipeline</span><span class="hljs-preprocessor">.reduce</span>(ReferencePipeline<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">479</span>)
    at <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.mirana</span><span class="hljs-preprocessor">.stream</span><span class="hljs-preprocessor">.FlatMapReduceTest</span><span class="hljs-preprocessor">.testFlatMap</span>(FlatMapReduceTest<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">49</span>)
    at sun<span class="hljs-preprocessor">.reflect</span><span class="hljs-preprocessor">.NativeMethodAccessorImpl</span><span class="hljs-preprocessor">.invoke</span>0(Native Method)
    at sun<span class="hljs-preprocessor">.reflect</span><span class="hljs-preprocessor">.NativeMethodAccessorImpl</span><span class="hljs-preprocessor">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">62</span>)
    at sun<span class="hljs-preprocessor">.reflect</span><span class="hljs-preprocessor">.DelegatingMethodAccessorImpl</span><span class="hljs-preprocessor">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">43</span>)
    at java<span class="hljs-preprocessor">.lang</span><span class="hljs-preprocessor">.reflect</span><span class="hljs-preprocessor">.Method</span><span class="hljs-preprocessor">.invoke</span>(Method<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">498</span>)</code></pre>
    <p>
     这样的情况，就给我们摆出了一个难题，如果我们既要进行元素个数统计，又要对元素进行求和，两个立刻求值的函数，必然只能执行一个，怎么办呢？
    </p>
    <p>
     查遍了Stream的官方接口，发现并没有解决此问题的方法，但是我们可以采用封装的方式解决此问题，即通过调用函数来获取新的Stream对象，从而分离Stream实例，如下：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">private</span>  List&lt;String&gt; joins = Lists.newArrayList(<span class="hljs-string">"1, 2, 3"</span>, <span class="hljs-string">"2, 3, 4"</span>, <span class="hljs-string">"3, 4, 5"</span>);
<span class="hljs-comment">//  通过函数每次返回新的Stream对象</span>
<span class="hljs-keyword">public</span> Stream&lt;Integer&gt; <span class="hljs-title">getStream</span>() {
    <span class="hljs-comment">//  将字符转换为数字Stream</span>
    <span class="hljs-keyword">return</span> joins.stream().flatMap(str -&gt; {
        String[] nums = str.split(<span class="hljs-string">","</span>);
        <span class="hljs-comment">//  将字符转换为数字</span>
        <span class="hljs-keyword">return</span> Arrays.asList(nums).stream().map(num -&gt; {
            <span class="hljs-keyword">return</span> Integer.parseInt(num.trim());
        });
    });
}</code></pre>
    <p>
     从上面的例子可以看出：
     <br/>
     1. Stream并没有依赖于可迭代对象的并发锁，只要调用stream()方法就会新的Stream实例，如上例中的joins对象可多次创建Stream实例，实例之间并没有相互影响；
     <br/>
     2. flatMap方法与map方法的区别在于函数接口的返回值（注意，是函数接口，而不是方法自身，即Function.apply方法），flatMap必须返回Stream，而Map没有此限制；
    </p>
    <p>
     如果要在函数内定义内调用，上述的方法还可以采用lambda的样式，如下：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-annotation">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReStream</span>() {
    <span class="hljs-comment">//  直接在函数内定义函数</span>
    Supplier&lt;Stream&lt;Integer&gt;&gt; supplier = () -&gt;              joins.stream().flatMap(str -&gt; {
        String[] nums = str.split(<span class="hljs-string">","</span>);
        <span class="hljs-keyword">return</span> Arrays.asList(nums).stream().map(num -&gt; {
            <span class="hljs-keyword">return</span> Integer.parseInt(num.trim());
        });
     });
    <span class="hljs-comment">//  计数</span>
    assertThat(supplier.get().count(), IsEqual.equalTo(<span class="hljs-number">9</span>L));
    <span class="hljs-comment">//  求和</span>
    <span class="hljs-keyword">int</span> sum = supplier.get().reduce((a, b) -&gt; a + b).get();
    assertThat(sum, IsEqual.equalTo(<span class="hljs-number">27</span>));
}</code></pre>
    <h3 id="结论">
     结论
    </h3>
    <p>
     JAVA 8的Stream类并没有直接提供复用的方法，只能采用封装的方式进行复用，所以也只是代码的复用，性能并没有提升。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f796969666161:2f61727469636c652f64657461696c732f3738313138333432" class_="artid" style="display:none">
 </p>
</div>


