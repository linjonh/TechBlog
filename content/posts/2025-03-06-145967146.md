---
layout: post
title: "万字深度剖析JS数据结构上"
date: 2025-03-06 19:44:52 +0800
description: "当在链表的特定位置插入新节点时，需要找到该位置的前一个节点和当前节点。将新节点的next指向当前节点。将前一个节点的next更新为新节点。具体代码else{const previous=this.getNodeAt(index-1)//获取前一个节点const current =previous.next//让前一个节点指向新节点引用的位置node.next=current//把新建的节点放进去完整插入代码const current=this.head//保护head。"
keywords: "万字深度剖析——JS数据结构（上）"
categories: ['未分类']
tags: ['数据结构']
artid: "145967146"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145967146
    alt: "万字深度剖析JS数据结构上"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145967146
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145967146
cover: https://bing.ee123.net/img/rand?artid=145967146
image: https://bing.ee123.net/img/rand?artid=145967146
img: https://bing.ee123.net/img/rand?artid=145967146
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     万字深度剖析——JS数据结构（上）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     数组本质是对象，键就是索引，值就是元素。
    </p>
    <p>
     push  /unshift       在数组最后/最前添加
    </p>
    <p>
     pop  /shift       把数组最后/最前的元素删除,返回的是被删除的元素
    </p>
    <p>
    </p>
    <p>
     splice(0,2，5)从第0给位置开始删除2个元素，并添加一个元素
    </p>
    <p>
     数组自带的排序方法
    </p>
    <p>
     let arr=[2,5,4,3,1]
    </p>
    <p>
     arr.sort((y,x)=&gt;x-y)x-y&gt;0交换顺序，不&gt;0就不会交换顺序
    </p>
    <p>
     最后结果时[2,3,4,5,6]顺序
    </p>
    <p>
     arr.sort(x,y)
    </p>
    <p>
     迭代方法 every some filter map foreach reduce
    </p>
    <pre><code>    arr.every((item)=&gt;item&gt;12)//如果每一项都满足条件，结果才是true

     arr.some((item)=&gt;item&gt;12)//只要有其中一项满足条件，结果就是true</code></pre>
    <p>
     <strong>
      map映射
     </strong>
     ，简单来说，就像是一个“翻译器”或者“转换器”。它的主要工作就是将一种东西（比如数字、文字、对象等）按照一定的规则转换成另一种东西。
    </p>
    <p>
     举个例子，假设你有一个列表，里面装着一些数字：[1, 2, 3, 4, 5]。现在你想把每个数字都变成它的两倍。那么，你可以使用map映射来实现这个目标。map映射会遍历这个列表，把每个数字都拿去乘以2，然后返回一个新的列表：[2, 4, 6, 8, 10]。
    </p>
    <p>
     再比如，你有一个装着名字的列表：[“张三”, “李四”, “王五”]。你想把每个名字都变成“你好，XXX”的格式。使用map映射，你可以很容易地得到一个新的列表：[“你好，张三”, “你好，李四”, “你好，王五”]。
    </p>
    <p>
     所以，map映射就是一个非常方便的工具，可以帮助我们快速地对一组数据进行统一的转换或处理。
    </p>
    <p>
     forEach
    </p>
    <pre><code>     arr.forEach((item,index)=&gt;
    console.log(item,index)
    )//返回数组里每个元素和索引值
</code></pre>
    <p>
     reduce
    </p>
    <p>
     第一个元素是上一次执行的返回值
    </p>
    <pre><code>    let res=arr.reduce((item1,item2)=item1+item2)//将每一个元素累加
</code></pre>
    <p>
     迭代器对象
    </p>
    <p>
     每一个数组都有一个迭代器
    </p>
    <pre><code>    let ite=arr[Symbol.iterator]()
</code></pre>
    <p>
     如上拿到迭代器接口
    </p>
    <p>
     只要符合迭代器对象就能使用for of、循环遍历对象
    </p>
    <pre><code>    for(let i of arr){
      console.log(i); 
    }
</code></pre>
    <pre><code>  console.log(arr.entries())
</code></pre>
    <p>
     结果是迭代器对象
    </p>
    <p>
     就能拿到键值对
    </p>
    <pre><code>  for(let i of arr.entries()){
    console.log(i);
  }
</code></pre>
    <p>
     拿到键
    </p>
    <pre><code>  for(let i of arr.keys()){
    console.log(i);
  }
</code></pre>
    <p>
     拿到元素的值
    </p>
    <pre><code> for(let i of arr.values()){
    console.log(i);
  }
</code></pre>
    <p>
     Arry.from将一个类似于数组的对象转化为真的数组结构
    </p>
    <pre><code>  function test(){
    console.log(Array.from(arguments));
    
  }
test(1,2,3)  
</code></pre>
    <p>
     虽然test函数没有形参，但是用arguments可以找到，但是arguments是一个对象用from可以转化成对象
    </p>
    <p>
     搜索 indexof  lastIndexof find findIndex findLast findLastIndex includes
    </p>
    <p>
     indexof
    </p>
    <p>
     如果包含就返回正确的索引值，如果不包含就返回-1
    </p>
    <pre><code>let arr=[12,22,23]
arr.indexOf(15)
//结果是-1</code></pre>
    <p>
     includes
    </p>
    <p>
     包含就返回true，不包含返回false
    </p>
    <pre><code>arr.includes(15)
</code></pre>
    <p>
     find能返回最先满足条件的元素
    </p>
    <p>
     findLast从后面开始查找
    </p>
    <p>
     findIndex返回索引值
    </p>
    <p>
     findLastIndex找出数组里最后一个大于10的元素
    </p>
    <pre><code>let res2=arr.findLastIndex(item=&gt;item&gt;10)
</code></pre>
    <p>
     栈结构的封装
    </p>
    <p>
     定义一个类，初始化一个元素。
    </p>
    <pre><code>  class stack{
    constructor(){
         this.item=[]
      }
  }
  let stack =new stack()
</code></pre>
    <p>
     现在可以直接跳过constructor
    </p>
    <pre><code>  class stack{
    items=[]
  }
</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        pop() 方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <code>
         pop()
        </code>
        方法应该是从栈中移除并返回最后一个元素，而不是添加元素。因此，
        <code>
         pop()
        </code>
        方法不需要参数，并且应该调用
        <code>
         this.items.pop()
        </code>
        来移除数组中的最后一个元素。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        peek() 方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <code>
         peek()
        </code>
        方法用于查看栈顶元素，但不移除它。因此，
        <code>
         peek()
        </code>
        方法也不需要参数，并且应该返回
        <code>
         this.items[this.items.length - 1]
        </code>
        ，而不是调用
        <code>
         this.items.peek()
        </code>
        。因为
        <code>
         this.items
        </code>
        是一个数组，而数组没有
        <code>
         peek()
        </code>
        方法。
       </li>
       <li>
        <strong>
         <code>
          push(data)
         </code>
         方法
        </strong>
       </li>
       <li>
        接受一个参数
        <code>
         data
        </code>
        ，并将其添加到栈顶。
       </li>
       <li>
        返回undefined
       </li>
       <li>
        <h2>
         栈
        </h2>
       </li>
       <li>
        <pre><code>    class stack {
        items = []
        pop(){
       this.items.push()
        }
        push(){
          this.items.push(data)
        }
        peek(data){
          return this.items[this.items.length-1]
        }
          isEmpty(){
            // return this.items.length===0
            return this.items.at(-1)
          }
          size(){
            return this.items.length
          }
          clear(){
            return this.items=[]
          }
      Tostring(){
      return this.items.join(',')
      }
      }
  let stack =new stack()
</code></pre>
        <p>
         由于我们可以随便用比如this.item.splice(0,2,9)的方式破坏栈，可以加下划线
        </p>
        <pre><code>        _items = []
</code></pre>
        <p>
         表示栈的私有性，来保护栈里的元素
        </p>
       </li>
       <li>
        <p>
         直至发布es13后才支持自带的属性用在前面加井号的方式
        </p>
       </li>
       <li>
        <pre><code>        #items = []
</code></pre>
        <p>
         每次访问stack.#items.push()用stack里面的方法才能改变栈的元素。直接stack.item会报错.
        </p>
       </li>
       <li>
        <h3>
         用栈方法应用——解决十进制转换
        </h3>
       </li>
       <li>
        <p>
         每一次把一个十进制的整数除以2的余数用push方法把余数push到栈里越往后的余数月堆到栈顶，再用pop方法把每次余数取出来，也就是从最后的余数取出
        </p>
        <pre><code>  let stack =new stack()
  function Dec(Decnumber){
    let remStack=new stack()
    let number=Decnumber
    let string=""
    while(number&gt;0){
      remStack.push(number)
      number=Math.floor(number%2)
    }
    while(!(remStack.isEmpty())){
      string+=remStack.pop()
    }
    return string
  }
  Dec(50)
</code></pre>
        <p>
         限制进制数如：8
        </p>
       </li>
       <li>
        <p>
         进制数如果是16，但是没有定义用ABCDEF表示10-16就需数组或者字符串定义
        </p>
       </li>
       <li>
        <pre><code>  function ECD(edcnumber){
    let string=''
    let rank=new stack()
    let number=edcnumber
    while(number&gt;0){
      rank.push(number%2)
     number=Math.floor(number / 2) 
    }
    while(!(rank.isEmpty())){
      string+=rank.pop()
    }
    return string
  }
EDC(500,16)//让500按照16进制转换
</code></pre>
        <h2>
         队列
        </h2>
       </li>
       <li>
        <p>
         先进先出：像日常做核酸，排在列队头的人做完出去，队尾可以随时加人
        </p>
       </li>
       <li>
        <p>
         队列和栈差不多，不同的在于
        </p>
       </li>
       <li>
        <p>
         dequeue：返回队头被删除的元素，方法里面用shift来删除第一个元素
        </p>
       </li>
       <li>
        <p>
         enqueue：表示队尾添加
        </p>
       </li>
       <li>
        <p>
         front：返回队头
        </p>
        <pre><code>class stack{
 #item=[]
dequeue(){
return this.#item.shift()
 }
 enqueue(data){
  this.#item.push(data)
 }
 front(){
  return this.#item.push.at(0)
 }
 isEmpty(){
  return this.#item.length===0
 }
 size(){
  return this.#item.length
 }
 clear(){
this.#item=[]
 }
 Tostring(){
  return this.#item.join(" ")
 }

}
</code></pre>
        <p>
         但是：用shift的缺点是删除第一个元素就使后面的元素都往后移动一个。若数据太多对渲染效果有害，而delet方法使删除的元素位置上是empty。
        </p>
       </li>
       <li>
        <pre><code>class Queue{
  #items={}
  #lowCout=0//记队头的索引值
  #count=0//为每次改变往后移记录索引值
  dequeue() {
    if(this.isEmpty()){
      return undefined
    }//防止出现size负数

    let res=this.#items[this.#lowCout]
    delete this.#items[this.#lowCout]
    this.#lowCout++
    return res
  }
  enqueue(data) {
    this.#items[this.#count]=data
   this. #count++
  }
  front() {
    return this.#items[this.#lowCout]
  }
  isEmpty() {
    return this.size()===0
  }
  size() {
    return this.#count-this.#lowCout
  }
  clear() {
    this.#items={}
        this.#lowCout = 0
    this.#count = 0

  }
  Tostring() {
  }

}
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         最应该采用对象obj的方式，来模拟数组
        </p>
        <pre><code>obj={0:1,1:2,3:3}
</code></pre>
        <p>
         那么数据结构就会改变，所以之前的队列就不能用了。
        </p>
       </li>
       <li>
        <h3>
         队列应用-——击鼓传花
        </h3>
       </li>
       <li>
        <p>
         首先由几个玩家，规定一轮击鼓数为7.转为编程思想就是由队头被删并加在队尾，队列轮回后到谁时第七个结束谁出局。首先定义几个玩家，和击鼓传花数
        </p>
       </li>
       <li>
        <pre><code>game(['kerwin','xiaoming','tiechui','gangaer','guludunzi'],7)
</code></pre>
        <p>
         封装game函数
        </p>
       </li>
       <li>
        <p>
         1，new一个队列
        </p>
       </li>
       <li>
        <pre><code>let queue=new Queue()
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         2，邀请玩家入场！
        </p>
       </li>
       <li>
        <pre><code>for(let i=0;i&lt;list.length;i++){
  queue.enqueue(list[i])
}
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         3，开始游戏！
        </p>
       </li>
       <li>
        <pre><code>while(queue.size&gt;1){
  for(let i=0;i&lt;num;i++){
   queue.enqueue( queue.dequeue())
  }
</code></pre>
        <p>
         4，获胜者出列颁奖！
        </p>
       </li>
       <li>
        <pre><code>return queue.dequeue()
</code></pre>
        <p>
         完整代码
        </p>
       </li>
       <li>
        <pre><code>function game(list,num){
let queue=new Queue()
for(let i=0;i&lt;list.length;i++){
  queue.enqueue(list[i])
}
while(queue.size&gt;1){
  for(let i=0;i&lt;num;i++){
   queue.enqueue( queue.dequeue())
  }
  console.log(queue.dequeue(),"淘汰了");
}
return queue.dequeue()
}
game(['kerwin','xiaoming','tiechui','gangaer','guludunzi'],7)
</code></pre>
        <h2>
         双端队列
        </h2>
       </li>
       <li>
        <p>
         可以从队头出，也可以从队头进，可以从队尾出，也可以从队尾进。例如，日常排队从队头插队，也可以看队太长了从队尾直接离开
        </p>
       </li>
       <li>
        <p>
         把方法改为从头加addFront
        </p>
       </li>
       <li>
        <p>
         分为三个情况：
        </p>
       </li>
       <li>
        <p>
         lowcount（开头索引值）=0;把数组中后面的元素向后移动一位，把第一个位置空出来。然后在第一个位置上添加数据data。
        </p>
       </li>
       <li>
        <pre><code>        else{
          //lowcount从0开始
          for(let i=this.#count;i&gt;0;i--){
            this.#items[i]=this.#items[i-1]
          }
          this.#items[0]=data //0的位置被移出来，就可以添加数据
          this.#count++
        }
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         lowcount（开头索引值)&gt;0;把lowcount减一，留出0的位置。添加data
        </p>
       </li>
       <li>
        <pre><code>        if(this.#lowCout&gt;0){
          this.#lowCout--
          this.#items[this.#lowCout]=data
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         数组为空就可以直接添加复用addback方法。
        </p>
       </li>
       <li>
        <pre><code>      //如果为空
      if(this.isEmpty()){
        this.addBack(data)
      }
</code></pre>
        <p>
         还有新颖的是在队尾删除
        </p>
       </li>
       <li>
        <p>
         因为count是从0开始计数，最后一个元素队尾元素的索引是
         <code>
          #count - 1
         </code>
         ，因为数组索引从0开始。因此，
         <code>
          #count
         </code>
         本身并不直接指向队尾元素，而是指向队尾元素之后的下一个位置（即队列的长度）。
        </p>
        <pre><code>  removeBack(){
    if(this.isEmpty()){
      return
    }
    this.#count--
    let res=this.#items[this.#count]
    delete this.#items[this.#count]
    return res
  }
</code></pre>
        <p>
         其他和单队列差不多
        </p>
       </li>
       <li>
        <pre><code>class Queue{
  #items
  #count=0
  #lowcount
  removeFont(){
    let res=this.#items[this.#lowcount]
    delete this.#items[this.#lowcount]
    return res
  }
  addBack(){
    this.#items.this.#count=[data]
    this.count++
  }
  addFront(){
    if(this.isEmpty()){
      this.#items.addBack()
    }else{
      if(this.#lowcount&gt;0){
        this.#lowcount--
        this.#items[this.#lowcount]=[data]
      }
      else {
        for(let i=0;i&lt;this.#count;i++)
        this.#items[i+1]=this.#items[i]
      for(let i=this.#count;i&gt;0;i--)
      this.#items[i]=this.#items[i-1]
      }
    }
  }
  removeBack(){
    if(this.isEmpty()){
      return
    }
    this.#count--
    let res=this.#items[this.#count]
    delete this.#items[this.#count]
    return res
  }
  isEmpty(){
    return this.size()===0
  }
  size(){
    return this.#count-this.#lowcount
  }
  peekFront(){
    return this.#items[this.#lowcount]
  }
  peekBack(){
    if(this.isEmpty()){
      return 
    }
    return this.#items[this.#count-1]
  }
  toString(){
    let str=""
    for(let i=0;i&lt;this.#count;i++){
      str=`${this.#items[i]}`
    }
    return str
  }
}
let dequeue=new Queue()
function test(str){
const lowstr=str.toLocalLowerCase().split("").join
let queue=new Queue()
for(let i=0;i&lt;lowstr.length;i++){
  queue.addBack(lowstr[i])
}
console.log(dequeue);

}
</code></pre>
        <h3>
         应用:回文检查如dad
        </h3>
       </li>
       <li>
        <p>
         ：split方法会自动缩进空格
        </p>
       </li>
       <li>
        <pre><code>function test(str){
const lowstr=str.toLocalLowerCase().split("").join
let queue=new Queue()
for(let i=0;i&lt;lowstr.length;i++){
  queue.addBack(lowstr[i])
}
while(dequeue.size()&gt;1){
  if(dequeue.removeBack!==dequeue.removeFont){
isEqual=false

break;
  }
}
}
test('DA     D')
</code></pre>
        <h2>
         链表
        </h2>
       </li>
       <li>
        <p>
         模拟栈和队列，也有自己独特的魅力
        </p>
       </li>
       <li>
        <p>
         在构造函数中设置
         <code>
          next
         </code>
         为
         <code>
          null
         </code>
         可以确保每个新创建的节点都默认没有指向下一个节点，合链表节点的初始状态。
         <code>
          this.element = element;
         </code>
         这行代码的作用是将传递给构造函数的
         <code>
          element
         </code>
         参数的值赋给新创建的节点实例的
         <code>
          element
         </code>
         属性。
        </p>
       </li>
       <li>
        <pre><code>  class Node {
  constructor(element) {
    this.element = element; // 节点存储的数据
    this.next = null; // 指向下一个节点的链接
  }
}</code></pre>
       </li>
       <li>
        <p>
         在linkedList中再定义记录节点位置和头节点
        </p>
       </li>
       <li>
        <p>
         1，在constructor构造函数器中用定义并初始化两个变量，cout用来记录链表中的节点，应为要从链头到链尾一点点找，还要初始化一个链头head
        </p>
       </li>
       <li>
        <p>
         2，push从后面插入
        </p>
       </li>
       <li>
        <pre><code>      push(){
       const node = new Node(element)
        if(head==null){
        this.head=Node  
      }
      else{
        let current=this.head
        while(current.next!==null){
          current =current.next
        }
        current.next=node
      }
      this.count++
   }
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         3，删除分为两种：删除特定位置，删除特点元素数据
        </p>
       </li>
       <li>
        <h4>
         删除特定位置
        </h4>
       </li>
       <li>
        <pre><code>   //指定位置删除
   removeAt(index){
      if(index&gt;=0&amp;&amp;index&lt;this.count){
  let current=this.head
        if(index===0){
          this.head=this.head
        }
        else{
          let previous
          for(let i=0;i&lt;index;i++){
            previous=current
            current=current.next
          }
          previous.next=current.next
        }
        this.current--
        return current.element

      }
   }
</code></pre>
        <p>
        </p>
       </li>
       <li>
        <p>
         <strong>
          参数检查
         </strong>
         ：
        </p>
       </li>
       <li>
        为了保护head不被破坏复制给current找节点头
        <ul>
         <li>
          首先检查传入的索引
          <code>
           index
          </code>
          是否有效，即是否在链表的范围内（0 到
          <code>
           this.count - 1
          </code>
          ）。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          删除头节点
         </strong>
         ：
        </p>
        <ul>
         <li>
          如果
          <code>
           index
          </code>
          为 0，表示要删除的是头节点。在这种情况下，只需要将头节点指向下一个节点即可。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          删除非头节点
         </strong>
         ：
        </p>
        <ul>
         <li>
          如果
          <code>
           index
          </code>
          大于 0，则需要遍历链表找到要删除的节点及其前一个节点。
         </li>
         <li>
          使用两个指针
          <code>
           previous
          </code>
          和
          <code>
           current
          </code>
          ，其中
          <code>
           current
          </code>
          初始指向头节点。
         </li>
         <li>
          遍历链表，直到
          <code>
           current
          </code>
          指向要删除的节点。
         </li>
         <li>
          然后，将
          <code>
           previous
          </code>
          的
          <code>
           next
          </code>
          指针指向
          <code>
           current
          </code>
          的
          <code>
           next
          </code>
          ，从而跳过
          <code>
           current
          </code>
          节点，实现删除。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          更新计数
         </strong>
         ：
        </p>
        <ul>
         <li>
          删除节点后，应该减少链表的节点计数
          <code>
           this.count
          </code>
          。但在您提供的代码中，这一步被遗漏了。
         </li>
         <li>
          你可能有这样的疑惑
         </li>
         <li>
          <h4>
           为什么
           <code>
            current
           </code>
           是正确的节点
          </h4>
         </li>
         <li>
          初始化时，
          <code>
           current
          </code>
          指向头节点，这是已知的。
         </li>
         <li>
          循环确保了
          <code>
           current
          </code>
          指针从头节点开始，逐个节点移动，直到到达指定的索引位置。
         </li>
         <li>
          循环结束后，
          <code>
           current
          </code>
          指针所指向的节点就是我们要删除的节点，因为我们已经根据
          <code>
           index
          </code>
          的值移动了
          <code>
           current
          </code>
          指针相应的次数。
         </li>
         <li>
          <p>
           因此，不需要将
           <code>
            current
           </code>
           复制为
           <code>
            index
           </code>
           ，因为
           <code>
            current
           </code>
           的位置是通过遍历链表来确定的，而不是通过直接设置索引值。循环的结构和
           <code>
            current
           </code>
           指针的移动确保了在循环结束时，
           <code>
            current
           </code>
           指向的是正确的节点。
          </p>
         </li>
         <li>
          <p>
           实验效果，
           <img alt="" height="298" src="https://i-blog.csdnimg.cn/direct/8c5d26359aca4f3ba1f3b1d8908cdf32.png" width="598">
            为简化方法，封装一个函数来接节点
           </img>
          </p>
         </li>
         <li>
          <pre><code>   getNodeAt(index){
    if(index&gt;=0&amp;&amp;index.this.count){
      let node=this.head
      for(let i=0;i&lt;index;i++){
        node=node.next
      }
      return node
    }
   }
</code></pre>
          <p>
           在removeAt函数中precious调用函数接收节点
          </p>
         </li>
         <li>
          <pre><code>   removeAt(index){
      if(index&gt;=0&amp;&amp;index&lt;this.count){
                  let current = this.head

        if(index===0){
          this.head=this.head
        }
        else{
          let previous=this.getNodeAt(index-1)
          previous.next=current
          previous.next=current.next
        }
        this.current--
        return current.element
      }
   }
</code></pre>
          <p>
           上面是根据节点位置删除，如果你想删除一个数据就需要下面的方法
          </p>
         </li>
         <li>
          <p>
           规定两个方法，第一个用于比对节点中你想找到的数值，并返回索引值
          </p>
         </li>
         <li>
          <pre><code>indexOf(element){
  let current =this.head
  for(let i=0;i&lt;this.count;i++){
    if(方法判断(element,current.element)){
      return i
    }
    current=current.next
  }
return -1
}
</code></pre>
          <p>
           在这个
           <code>
            indexOf
           </code>
           函数中，如果
           <code>
            方法判断(element, current.element)
           </code>
           返回
           <code>
            true
           </code>
           ，那么
           <code>
            return i;
           </code>
           会被执行，函数会返回索引
           <code>
            i
           </code>
           ，并且不会再执行
           <code>
            current = current.next;
           </code>
           或者任何后续的循环迭代。整个函数调用会结束，控制权会返回到调用
           <code>
            indexOf
           </code>
           函数的地方。
          </p>
         </li>
         <li>
          <p>
           第二个用于接收索引值，调上一个删除方法
          </p>
         </li>
         <li>
          <p>
           例如这样一个方法
          </p>
         </li>
         <li>
          <pre><code>   equalFn(a,b){
    return a===b
   }
</code></pre>
          <p>
           但是如果是一个对象，就不能这样简单对比，因为引用数据类型在栈中存放地址，每个对象地址不一样指向堆内存中实际对象的地址。
          </p>
         </li>
         <li>
          <p>
           可以直接暴力的转换成字符串
          </p>
         </li>
         <li>
          <pre><code>   equalFn(a,b){
    return JSON.stringify(a)===JSON.stringify(b)
   }
</code></pre>
          <p>
           但是如果把两个对象交换位置，就不能判断了
          </p>
         </li>
         <li>
          <p>
           可以直接用第三方库imumutable
          </p>
         </li>
         <li>
          <h2>
           双向链表
          </h2>
         </li>
         <li>
          <p>
           每个节点即能指向前一个（prev），有能指向后一个（next）
          </p>
         </li>
         <li>
          <h3>
           插入值
          </h3>
         </li>
         <li>
          <h4>
           如果想在头部插入
          </h4>
         </li>
         <li>
          <pre><code>insert(element,index){
    if(index&gt;=0&amp;&amp;index&lt;=this.count){
    const node=new Node(element)
    if(index===0){
      const current =this.head
      node.next=current
      this.head=node
}
}
</code></pre>
          <p>
          </p>
         </li>
         <li>
          <p>
           <code>
            if(index === 0){ // 如果插入位置是链表头部
           </code>
          </p>
          <p>
           这行代码检查是否要在链表的头部插入新节点。
           <code>
            index
           </code>
           是插入位置的索引，如果它是0，意味着新节点应该成为新的头节点。
          </p>
         </li>
         <li>
          <p>
           <code>
            node.next = this.head; // 新节点的下一个节点设置为当前头节点
           </code>
          </p>
          <p>
           这行代码将新节点（
           <code>
            node
           </code>
           ）的
           <code>
            next
           </code>
           属性设置为当前的头节点（
           <code>
            this.head
           </code>
           ）。这样，新节点就指向了原来的头节点，保持了链表的连续性。
          </p>
          <ul>
           <li>
            <code>
             node
            </code>
            ：新创建的节点，即将插入链表。
           </li>
           <li>
            <code>
             this.head
            </code>
            ：当前链表的头节点。
           </li>
           <li>
            <code>
             node.next = this.head
            </code>
            ：将新节点的
            <code>
             next
            </code>
            指针指向当前的头节点。
           </li>
           <li>
            <h4>
             如果想插入的位置不是头部
            </h4>
           </li>
           <li>
            <h5>
             思想：
            </h5>
           </li>
           <li>
            <h4>
             示例
            </h4>
            <p>
             假设链表当前状态如下：
            </p>
            <p>
             复制
            </p>
            <pre><code>Head -&gt; A -&gt; B -&gt; C
</code></pre>
            <p>
             其中，A 是头节点，B 是第二个节点，C 是第三个节点。现在，我们想要在B和C之间插入一个新节点X：
            </p>
           </li>
           <li>
            <code>
             previous = this.getNodeAt(1);
            </code>
            // 获取B的引用
           </li>
           <li>
            <code>
             current = previous.next;
            </code>
            // 获取C的引用
           </li>
           <li>
            <code>
             node.next = current;
            </code>
            // 设置X的next指向C
           </li>
           <li>
            <code>
             previous.next = node;
            </code>
            // 设置B的next指向X
           </li>
           <li>
            <p>
             插入后的链表状态：
            </p>
            <p>
             复制
            </p>
            <pre><code>Head -&gt; A -&gt; B -&gt; X -&gt; C
</code></pre>
            <h4>
             总结
            </h4>
           </li>
           <li>
            当在链表的特定位置插入新节点时，需要找到该位置的前一个节点和当前节点。
           </li>
           <li>
            将新节点的
            <code>
             next
            </code>
            指向当前节点。
           </li>
           <li>
            将前一个节点的
            <code>
             next
            </code>
            更新为新节点。
           </li>
           <li>
            具体代码
           </li>
           <li>
            <pre><code>    else{
      const previous=this.getNodeAt(index-1)//获取前一个节点
      const current =previous.next//让前一个节点指向新节点引用的位置
      node.next=current//把新建的节点放进去
      previous.next=node
    }
</code></pre>
            <p>
             完整插入代码
            </p>
           </li>
           <li>
            <pre><code>insert(element,index){
  if(index&gt;=0&amp;&amp;index&lt;=this.count){
    const node=new Node(element)
    if(index===0){
      const current=this.head//保护head
      node.next=current//当前头节点作为新节点的下一个
      this.head=node//把新节点作为头节点
      
    }else{
      const previous=getNodeAt(index-1)
      const current=previous.next
      node.next=current
      previous.next=node
    }
    this.count++
    return true
  }
  return false
}
</code></pre>
            <p>
             剩下几个简单的方法
            </p>
           </li>
           <li>
            <pre><code>isEmpty(){
  return this.size===0
}
size(){
  return this.count
}
gethead(){
  return this.head
}
</code></pre>
            <p>
             双端链表
            </p>
           </li>
           <li>
            <p>
             还可以继承单链表的属性
            </p>
           </li>
           <li>
            <pre><code>class DoubleNode extends Node {
  constructor(element) {
    super(element); // 调用父类Node的构造函数
    this.prev = null; // 初始化DoubleNode特有的pre属性
  }
}</code></pre>
            <p>
            </p>
           </li>
           <li>
            <p>
             <code>
              super(element)
             </code>
             调用
             <code>
              Node
             </code>
             类的构造函数，并将
             <code>
              element
             </code>
             参数传递给父类构造函数。这样，
             <code>
              DoubleNode
             </code>
             实例就继承了
             <code>
              Node
             </code>
             类的
             <code>
              element
             </code>
             属性
            </p>
           </li>
           <li>
            <p>
             之前封装的单向链表中很多方法需要重新封装
            </p>
           </li>
           <li>
            <h4>
             push
            </h4>
           </li>
           <li>
            <pre><code>    push(){
      const node=new DoublyNode()
      //prev next
if(this.head===null){
  this.head=node
  this.tail=node
}else{
  this.tail.next=node
  node.prev=node
  this.tail=node
}
</code></pre>
            <p>
             如果头部为空，就直接加
            </p>
           </li>
           <li>
            <p>
             头部不为空
            </p>
           </li>
           <li>
            <p>
             让链表尾部next与新节点连接，新节点prev指向尾部，再让尾部彻底等于新节点
            </p>
           </li>
           <li>
            <h4>
             insert
            </h4>
           </li>
           <li>
            不说了，思想全在图里
           </li>
           <li>
            <p>
             <img alt="" height="444" src="https://i-blog.csdnimg.cn/direct/33a970e5cbda42439c5f6eb2360a91f6.png" width="1528"/>
            </p>
            <pre><code>    insert(element,index){
      const node=DoublyLinked(element)
      let current=this.head
      if(index&gt;=0&amp;&amp;index&lt;=this.count){
        if(index===0){
          if(this.head===null)
          this.head=node
          this.tail=node
        }
        else{
          node.next=this.head
          this.head.prev=node
          this.head=node
        }          
      }
      else if(index===this.count){
        current=this.tail
        current.next=node
        node.prev=current
        this.tail=node
      }
      else{
        const previous=getNodeAt(index-1)
        current=previous.next
        node.next=current
        current.prev=node
        previous.next=node
        node.prev=previous
      }
          this.count++

          return true
    }
    
</code></pre>
            <h4>
             removeAt删除
            </h4>
           </li>
           <li>
            <p>
             注意：index要小于this.count，因为count从0开始，最后的count值没有节点（和insert不同）
            </p>
           </li>
           <li>
            <p>
             按照索引值删除和insert思想差不多，需要注意的是如果让head的next指向下一个会出问题，因为曾经的尾部被head占了，所以之前让head直接赋值为head的next—— this.head=current.next
            </p>
           </li>
           <li>
            <pre><code>    removeAt(index){
      if(index&gt;=0&amp;&amp;index&lt;this.count){
        let current=this.head
        if(index===0){
          this.head=current.next
          if(this.count===1){
            this.tail===null
          }else{
            this.head.prev=undefined
          }        
        }
        if(index===this.size()-1){
          let current =this.tail
          current.prev=this.tail
          this.tail.next=undefined
        }
        else{
          let previous=this.getNodeAt(index-1)
           current=previous.next
          previous.next=current.next
          current.next.prev=previous
        }
        this.count--
        return current.element

      }

    }
</code></pre>
            <p>
             remove
            </p>
           </li>
           <li>
            <p>
             按照数值删除和单链表方法一样
            </p>
           </li>
           <li>
            <h2>
             循环链表
            </h2>
           </li>
           <li>
            <p>
             就是让最后节点的next指向head，循环起来
            </p>
           </li>
           <li>
            <h3>
             insert插入
            </h3>
           </li>
           <li>
            <pre><code>insert(element,index){
  let node=new DoublyLinked(element)
  let current=this.head
  if(index&gt;=0&amp;&amp;index&lt;=count){
    if(index===0){
      if(head===0){
        this.head=node
        node.next=this.head
      }
      else{
        node.next=current
        current = this.getNodeAt(this.size() - 1)//不能保证后面的节点指向head，下面解决,获得尾部元素
        this.head=node//
        current.next=this.head//让尾部元素next指向head，保证循环
      }
    }else{
      const previous=this.getNodeAt(index-1)
       current=previous.next
      previous.next=node
      node.next=current
    }
    this.count++
return true
  }
  return false
}
</code></pre>
            <h3>
             removedAt——按索引删除
            </h3>
           </li>
           <li>
            <pre><code>removeAt(index){
if(index&gt;=0&amp;&amp;index&lt;count){
  let current=this.head
  if(index===0){
    if(this.size()===1){
      let last=this.getNodeAt(this.size()-1)
     this. head=this.head.next
      last.next=head
    }
  }
  else{
  let previous=this.getNodeAt(index-1)
  current=previous.next
  previous.next=current.next//不用怕删除后没有循环，因为被删的current的next就指向head
  }
  this.count--
  return current.element
}
}
</code></pre>
            <h2>
             集合set
            </h2>
           </li>
           <li>
            <p>
             无序且唯一的项组成
            </p>
           </li>
           <li>
            <p>
             因为对象的属性不能重复适合作为集合，下面我们用对象模拟
            </p>
           </li>
           <li>
            <p>
             属性和属性名都是一个内容，存100就是100:100所以想要操作某个元素直接this.items[element]就可以
            </p>
           </li>
           <li>
            <p>
             建一个class封装增删查改
            </p>
           </li>
           <li>
            <pre><code>    class kerwin{
      // constructor(){
      //   this.items={}
      // }
      items={}
      add(element){
        if(!this.has(element)){
          this.items[element]=element
          return true
        }
        return false

      }
      delete(element){
if(this.has(element)){
  delete this.items[element]
  return true
}
      }
      has(element){
return element in this.items
      }
      clear(){
return this.items={}
      }
      size(){
return Object.keys(this.items).length
      }
      values(){
return Object.values(this.items)
      }
    }
</code></pre>
            <p>
             其中size方法用
             <code>
              Object.keys()
             </code>
             方法会返回一个包含对象所有自有属性（不包括原型链上的属性）的键（key）的数组。
            </p>
           </li>
           <li>
            <p>
             应用：检查数组中是否有重复元素
            </p>
           </li>
           <li>
            <pre><code>    var arr=[1,2,3,3,3,4]
    arr.forEach(items=&gt;{
      myList.add(items)
    })
</code></pre>
            <h2>
             Es6中的set属性
            </h2>
           </li>
           <li>
            <p>
             迭代器
            </p>
           </li>
           <li>
            <p>
             符合迭代器的元素可以用多个next遍历，也可以用for...of遍历，也可以用展开运算符变为普通数组
            </p>
           </li>
           <li>
            <p>
             与上面我们自己封装的set不同在于，Es6的size是一个属性，我们是方法
            </p>
           </li>
           <li>
            <h4>
             应用
            </h4>
           </li>
           <li>
            <p>
             交集，并集，差集——从后端接收数据时候使用
            </p>
           </li>
           <li>
            <pre><code>    var mySetA=new Set([1,2,3])
    var mySetB=new Set([2,3,4])
    // 并集
    var mySetAnd=new Set([...mySetA],[...mySetB])
  // 交集——只有数组才有filter方法
  var mySetJiao=new Set([...mySetA].filter(item=&gt;mySetB.has(item)))
  //差集
  var mySetJiao=new Set([...mySetA].filter(item=&gt;!mySetB.has(item)))
</code></pre>
            <h2>
             字典
            </h2>
           </li>
           <li>
            <p>
             和集合很相似，但集合是【值，值】，字典【键，值】，键可以是对象，也可以是任意数据类型
            </p>
           </li>
           <li>
            <pre><code>    class Dictionary{
      table={}
      //将键转化为字符串
      tostrFn(item){
        if(item===null){
          return 'NULL'
        }
        else if(item===undefined){
          return 'UNDEFINDED'
        }
        else if(item==='string'||item instanceof String){
          return item
        }
        return JSON.stringify(item)
      }
}</code></pre>
            <h4>
             <code>
              tostrFn
             </code>
            </h4>
           </li>
           <li>
            <p>
             ：使用
             <code>
              tostrFn
             </code>
             方法将
             <code>
              key
             </code>
             转换为一个字符串。这是因为在 JavaScript 对象中，键总是被转换为字符串。
             <code>
              tostrFn
             </code>
             方法的执行步骤如下：
            </p>
            <ul>
             <li>
              如果
              <code>
               item
              </code>
              （在这里是
              <code>
               key
              </code>
              ）是
              <code>
               null
              </code>
              ，返回字符串
              <code>
               'NULL'
              </code>
              。
             </li>
             <li>
              如果
              <code>
               item
              </code>
              是
              <code>
               undefined
              </code>
              ，返回字符串
              <code>
               'UNDEFINED'
              </code>
              。
             </li>
             <li>
              如果
              <code>
               item
              </code>
              是字符串或
              <code>
               String
              </code>
              对象的实例，直接返回该字符串。
             </li>
             <li>
              否则，使用
              <code>
               JSON.stringify
              </code>
              将
              <code>
               item
              </code>
              转换为字符串。
             </li>
            </ul>
           </li>
           <li>
            <p>
             <strong>
              检查键存在性
             </strong>
             ：使用转换后的键字符串在
             <code>
              this.table
             </code>
             中查找。
             <code>
              this.table
             </code>
             是一个对象，用于存储字典的键值对。
            </p>
           </li>
           <li>
            <p>
             <strong>
              返回结果
             </strong>
             ：如果找到对应的键（即
             <code>
              this.table
             </code>
             中存在该键），则
             <code>
              this.table[this.tostrFn(key)]
             </code>
             不会是
             <code>
              null
             </code>
             ，
             <code>
              haskey
             </code>
             方法返回
             <code>
              true
             </code>
             。如果没有找到，或者对应的值是
             <code>
              null
             </code>
             ，则返回
             <code>
              false
             </code>
             。
            </p>
           </li>
           <li>
            <code>
             注意：如果haskey
            </code>
            方法中检查的是
            <code>
             !== null
            </code>
            ，这意味着如果键存在但对应的值是
            <code>
             undefined
            </code>
            或其他非
            <code>
             null
            </code>
            值，它也会返回
            <code>
             true
            </code>
            。所以改为！=null就可以了
           </li>
           <li>
            <h4>
             set
            </h4>
           </li>
           <li>
            检查是否有键
           </li>
           <li>
            第一种方法
            <pre><code>      //检查是否含有键
      haskey(key) {
        return this.table[this.tostrFn(key)] != null
      }
      set(key,value){
        if(key!==null&amp;&amp;value!==null){
          const tablekey=this.tostrFn(key)
          this.table[tablekey]=value
          return true
        }
        return false
      }
    }
</code></pre>
            <p>
             这种方法将键存放的被转化后的字符串键名，所以另起一个方法二将value中存键+值，保证获取到最原始的键
            </p>
           </li>
           <li>
            <p>
             方法二
            </p>
           </li>
           <li>
            <pre><code>      set(key,value){
        if(key!==null&amp;&amp;value!==null){
          const tablekey=this.tostrFn(key)
          this.table[tablekey]=new ValuePair(key,value)
          return true
        }
        return false
      }
    }
    var mysseet=Dictionary()
    class ValuePair{
      constructor(key,value){
        this.key=key
        this.value=value
      }
    }
</code></pre>
            <p>
             valuepair类创建一个实例对象保存一份原始的key，value
            </p>
           </li>
           <li>
            <h4>
             其他方法
            </h4>
           </li>
           <li>
            <pre><code>      get(key){
        const ValuePair=this.table[this.tostrFn(key)]
        return ValuePair ==null?undefined:ValuePair.value
      }
      remove(key){
        if(this.haskey(key)){
          delete this.table.tostrFn(key)
          return true
        }
        return false
      }
      keys(){
        return this.keyValues().map(item=&gt;item.key)
      }
     values(){
        return this.keyValues().map(item=&gt;item.value)
      }
      keyValues(){
        return Object.values(this.table)//Object.values() 只返回自有属性的值，不返回继承属性的值。
      }
      size(){
        return Object.keys(this.table).length
      }
      isEmpty(){
        return this.size===0
      }
      clear(){
        return this.table=null
      }
      forEach(cb){
        const ValuePair=this.keyValues()
        for(let i=0;i&lt;ValuePair.length;i++){
          cb(ValuePair[i].key,ValuePair[i].value)
        }
      }
      
</code></pre>
            <h2>
             散列表
            </h2>
           </li>
           <li>
            <p>
             有上字典可以看到，由于set每次查找键都需要转化为JSON字符串很麻烦，并且遍历上万条大数据很消耗性能，所以散列表可以把键通过散列函数转换为一个数组作为索引，再从散列表中查找
            </p>
           </li>
           <li>
            <h4>
             set方法(就相当于push）
            </h4>
           </li>
           <li>
            <pre><code>      set (key,value){
        if(key!=null&amp;&amp;value!=null){
          const position=111
          this.table[position]=ValuePair(key,value)
          return true
        }
        return false
      }
</code></pre>
            <p>
             需要有一个方法能给table设置类似position=111这个索引数字
            </p>
           </li>
           <li>
            <p>
             hash表就派上用场了，将table中的键转化为字符串，
            </p>
           </li>
          </ul>
          <ol>
           <li>
            <p>
             如果直接是数字就更好，不用转换，
            </p>
           </li>
           <li>
            <p>
             一旦是字符串就用charCodeAt方法转化为ASCALl码
            </p>
           </li>
           <li>
            <p>
             ，防止hash值过大用取余
            </p>
           </li>
           <li>
            <pre><code>      hashCode(key){
        const tablekey=this.tostrFn(key)
        for(let i=0;i&lt;tablekey.length;i++){
          hash+=tablekey.charCodeAt(i)

        }
        return hash%37
      }
      //put
      set (key,value){
        if(key!=null&amp;&amp;value!=null){
          const position= hashCode(key)
          this.table[position]=ValuePair(key,value)
          return true
        }
        return false
      }
</code></pre>
            <p>
            </p>
           </li>
          </ol>
          <ul>
           <li>
            <h4>
             其他方法——get remove
            </h4>
           </li>
           <li>
            <pre><code>      get(key){
const ValuePair=this.table[this.hashCode(key)]
return ValuePair==null?undefined:ValuePair
      }
      remove(key){
        const deletePair=this.table[hash]
        const hash=this.hashCode(key)
        if(deletePair!==null){
          delete this.table[hash]
          return true
        }
              return false
      }
</code></pre>
            <p>
            </p>
           </li>
           <li>
            <p>
             ES6中的map
            </p>
           </li>
           <li>
            <pre><code>const obj = {q: 235};
map.set(obj, 'aaaaa');
</code></pre>
            <p>
             在这段代码中，
             <code>
              obj
             </code>
             是一个常量，引用了一个对象。当你调用
             <code>
              map.set(obj, 'aaaaa')
             </code>
             时，你是将
             <code>
              obj
             </code>
             这个引用作为键设置到了
             <code>
              Map
             </code>
             中。
            </p>
            <p>
             如果你尝试直接使用字面量对象作为键，如下所示：
            </p>
            <pre><code>map.set({q: 123}, 'bbbbb');
</code></pre>
            <p>
             这里的问题在于，每次你使用
             <code>
              {q: 123}
             </code>
             这样的对象字面量时，你实际上是在创建一个全新的对象。在JavaScript中，对象是通过引用来比较的，而不是通过值。因此，即使两个对象字面量看起来相同（例如
             <code>
              {q: 123}
             </code>
             和另一个
             <code>
              {q: 123}
             </code>
             ），它们却是不同的引用，因此被视为不同的键。总结来说，不能直接把
             <code>
              {q: 123}
             </code>
             传入
             <code>
              map
             </code>
             作为键，是因为每次这样写都会创建一个全新的对象，而
             <code>
              Map
             </code>
             是通过引用来识别键的。
            </p>
           </li>
           <li>
            <h2>
             wakemap——对象只能是键
            </h2>
           </li>
           <li>
            <p>
             有垃圾回收机制，和map不同，一旦object被null，objet就不会占内存，也就不会被遍历
            </p>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303039323832332f:61727469636c652f64657461696c732f313435393637313436" class_="artid" style="display:none">
 </p>
</div>


