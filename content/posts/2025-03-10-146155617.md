---
layout: post
title: "你使用过哪些-Java-并发工具类"
date: 2025-03-10 15:21:56 +0800
description: "类别           | 工具类                                | 解决的核心问题              |, 线程池                       | 限制并发资源使用                |通过理解这些工具类的设计意图和底层机制，你可以在面试中展现出对高并发场景的深刻掌控力！| 高并发下数据安全访问            || 锁机制          || 线程协作        || 资源控制        |"
keywords: "你使用过哪些 Java 并发工具类？"
categories: ['未分类']
tags: ['开发语言', 'Python', 'Java']
artid: "146155617"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146155617
    alt: "你使用过哪些-Java-并发工具类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146155617
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146155617
cover: https://bing.ee123.net/img/rand?artid=146155617
image: https://bing.ee123.net/img/rand?artid=146155617
img: https://bing.ee123.net/img/rand?artid=146155617
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     你使用过哪些 Java 并发工具类？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <hr/>
    <p>
     你的回答（口语化，面试场景）
     <br/>
     面试官：你使用过哪些 Java 并发工具类？
     <br/>
     你：
     <br/>
     好的，我结合项目经验来说说常用的并发工具类：
    </p>
    <ol>
     <li>
      CountDownLatch
     </li>
    </ol>
    <ul>
     <li>
      作用：等所有线程就绪后再触发任务，或主线程等待子线程完成。
     </li>
     <li>
      场景：压测时模拟高并发（比如100个请求同时发起）。
     </li>
     <li>
      代码示例：
      <pre><code class="prism language-java"><span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">// 三个子线程执行任务  </span>
executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 主线程阻塞等待  </span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有任务完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre>
     </li>
    </ul>
    <ol start="2">
     <li>
      CyclicBarrier
     </li>
    </ol>
    <ul>
     <li>
      作用：让一组线程互相等待，达到屏障点后统一执行后续逻辑。
     </li>
     <li>
      场景：多线程分阶段处理数据（比如先各自加载数据，再统一合并）。
     </li>
     <li>
      代码示例：
      <pre><code class="prism language-java"><span class="token class-name">CyclicBarrier</span> barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"全部就绪！"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待其他线程  </span>
    <span class="token function">mergeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre>
     </li>
    </ul>
    <ol start="3">
     <li>
      Semaphore
     </li>
    </ol>
    <ul>
     <li>
      作用：控制并发线程数（比如限流）。
     </li>
     <li>
      场景：数据库连接池限制、接口限流（防止瞬时流量打满系统）。
     </li>
     <li>
      代码示例：
      <pre><code class="prism language-java"><span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 允许5个线程同时执行  </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>semaphore<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 超时等待  </span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span> <span class="token function">accessDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span> semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre>
     </li>
    </ul>
    <ol start="4">
     <li>
      ReentrantLock 和 StampedLock
     </li>
    </ol>
    <ul>
     <li>
      ReentrantLock：
      <ul>
       <li>
        可替代
        <code>
         synchronized
        </code>
        ，支持公平锁、可中断锁。
       </li>
       <li>
        场景：需要尝试获取锁（
        <code>
         tryLock()
        </code>
        ）或避免死锁（比如支付超时回滚）。
       </li>
      </ul>
     </li>
     <li>
      StampedLock：
      <ul>
       <li>
        读多写少场景优化，通过“乐观读”减少锁竞争。
       </li>
       <li>
        场景：高频读、低频写的缓存（比如商品库存缓存）。
       </li>
      </ul>
     </li>
    </ul>
    <ol start="5">
     <li>
      原子类（AtomicInteger 等）
     </li>
    </ol>
    <ul>
     <li>
      作用：无锁线程安全操作（基于 CAS）。
     </li>
     <li>
      场景：计数器（比如统计接口调用次数）、状态标志。
      <pre><code class="prism language-java"><span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
counter<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线程安全自增  </span>
</code></pre>
     </li>
    </ul>
    <ol start="6">
     <li>
      Future 和 CompletableFuture
     </li>
    </ol>
    <ul>
     <li>
      Future：异步获取任务结果（需配合线程池）。
     </li>
     <li>
      CompletableFuture：
      <ul>
       <li>
        支持链式调用、组合多个异步任务（如
        <code>
         thenApply()
        </code>
        、
        <code>
         allOf()
        </code>
        ）。
       </li>
       <li>
        场景：微服务并行调用（比如同时查询订单和用户信息）。
       </li>
      </ul>
     </li>
    </ul>
    <ol start="7">
     <li>
      线程池工具类（Executors）
     </li>
    </ol>
    <ul>
     <li>
      常用线程池：
      <ul>
       <li>
        <code>
         newFixedThreadPool
        </code>
        ：固定线程数，适用于稳定负载。
       </li>
       <li>
        <code>
         newCachedThreadPool
        </code>
        ：弹性线程数，适合短时异步任务。
       </li>
       <li>
        <code>
         newScheduledThreadPool
        </code>
        ：定时任务调度（替代 Timer）。
       </li>
      </ul>
     </li>
     <li>
      注意：阿里规约建议手动创建
      <code>
       ThreadPoolExecutor
      </code>
      ，避免资源耗尽风险。
     </li>
    </ul>
    <ol start="8">
     <li>
      并发集合（ConcurrentHashMap、CopyOnWriteArrayList）
     </li>
    </ol>
    <ul>
     <li>
      ConcurrentHashMap：
      <ul>
       <li>
        分段锁（JDK7）或 CAS + synchronized（JDK8），高并发下替代 HashMap。
       </li>
       <li>
        场景：全局缓存（比如电商首页类目数据）。
       </li>
      </ul>
     </li>
     <li>
      CopyOnWriteArrayList：
      <ul>
       <li>
        写时复制，读多写少场景（比如监听器列表）。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <p>
     预测面试官可能的追问及回答
     <br/>
     追问1：
     <code>
      CountDownLatch
     </code>
     和
     <code>
      CyclicBarrier
     </code>
     有什么区别？
     <br/>
     回答：
    </p>
    <ul>
     <li>
      触发机制：
      <ul>
       <li>
        <code>
         CountDownLatch
        </code>
        通过
        <code>
         countDown()
        </code>
        减计数，
        <code>
         await()
        </code>
        阻塞直到计数归零，一次性使用。
       </li>
       <li>
        <code>
         CyclicBarrier
        </code>
        通过
        <code>
         await()
        </code>
        等待线程数达标后触发回调，可重复使用（
        <code>
         reset()
        </code>
        ）。
       </li>
      </ul>
     </li>
     <li>
      场景：
      <ul>
       <li>
        <code>
         CountDownLatch
        </code>
        主等子，
        <code>
         CyclicBarrier
        </code>
        子等子。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     追问2：
     <code>
      ReentrantLock
     </code>
     和
     <code>
      synchronized
     </code>
     怎么选？
     <br/>
     回答：
    </p>
    <ul>
     <li>
      优先
      <code>
       synchronized
      </code>
      ：代码简洁，JVM自动管理锁。
     </li>
     <li>
      需要高级功能时用
      <code>
       ReentrantLock
      </code>
      ：比如尝试获取锁（
      <code>
       tryLock
      </code>
      ）、公平锁、可中断锁。
     </li>
    </ul>
    <hr/>
    <p>
     知识框架与底层原理补充
    </p>
    <ol>
     <li>
      <p>
       并发工具分类
       <br/>
       | 类别 | 工具类 | 解决的核心问题 |
       <br/>
       |--------------------|------------------------------------------|-------------------------------|
       <br/>
       | 线程协作 |
       <code>
        CountDownLatch
       </code>
       ,
       <code>
        CyclicBarrier
       </code>
       | 多线程步调协调 |
       <br/>
       | 资源控制 |
       <code>
        Semaphore
       </code>
       , 线程池 | 限制并发资源使用 |
       <br/>
       | 锁机制 |
       <code>
        ReentrantLock
       </code>
       ,
       <code>
        StampedLock
       </code>
       | 显式控制同步与互斥 |
       <br/>
       | 线程安全容器 |
       <code>
        ConcurrentHashMap
       </code>
       ,
       <code>
        CopyOnWriteArrayList
       </code>
       | 高并发下数据安全访问 |
       <br/>
       | 异步任务 |
       <code>
        Future
       </code>
       ,
       <code>
        CompletableFuture
       </code>
       | 非阻塞任务编排与结果获取 |
      </p>
     </li>
     <li>
      <p>
       底层原理
      </p>
     </li>
    </ol>
    <ul>
     <li>
      AQS（AbstractQueuedSynchronizer）：
      <ul>
       <li>
        <code>
         ReentrantLock
        </code>
        、
        <code>
         Semaphore
        </code>
        、
        <code>
         CountDownLatch
        </code>
        均基于 AQS 实现，通过
        <code>
         state
        </code>
        变量和 CLH 队列管理线程阻塞与唤醒。
       </li>
      </ul>
     </li>
     <li>
      CAS（Compare-And-Swap）：
      <ul>
       <li>
        原子类（如
        <code>
         AtomicInteger
        </code>
        ）和
        <code>
         ConcurrentHashMap
        </code>
        的线程安全操作依赖 CAS，避免锁竞争。
       </li>
      </ul>
     </li>
     <li>
      写时复制（Copy-On-Write）：
      <ul>
       <li>
        <code>
         CopyOnWriteArrayList
        </code>
        在写入时复制整个数组，保证读操作无锁，适合读多写极少场景。
       </li>
      </ul>
     </li>
    </ul>
    <ol start="3">
     <li>
      最佳实践
     </li>
    </ol>
    <ul>
     <li>
      避免死锁：
      <ul>
       <li>
        锁顺序一致、超时释放（
        <code>
         tryLock
        </code>
        ）、使用并发集合替代手动同步。
       </li>
      </ul>
     </li>
     <li>
      性能优化：
      <ul>
       <li>
        读多写少用
        <code>
         StampedLock
        </code>
        ，写多用
        <code>
         ReentrantLock
        </code>
        。
       </li>
       <li>
        短任务用
        <code>
         CompletableFuture
        </code>
        而非阻塞线程池。
       </li>
      </ul>
     </li>
     <li>
      线程池参数：
      <ul>
       <li>
        根据任务类型（CPU 密集型 vs IO 密集型）设置核心线程数（CPU 数 +1 或 2*CPU 数）。
       </li>
      </ul>
     </li>
    </ul>
    <ol start="4">
     <li>
      高频面试题扩展
     </li>
    </ol>
    <ul>
     <li>
      <code>
       ConcurrentHashMap
      </code>
      在 JDK7 和 JDK8 的区别？
      <ul>
       <li>
        JDK7：分段锁（Segment），锁粒度粗。
       </li>
       <li>
        JDK8：CAS + synchronized 锁单个 Node，粒度更细。
       </li>
      </ul>
     </li>
     <li>
      <code>
       CompletableFuture
      </code>
      的默认线程池问题？
      <ul>
       <li>
        默认使用
        <code>
         ForkJoinPool.commonPool()
        </code>
        ，建议自定义线程池避免业务阻塞公共池。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <p>
     通过理解这些工具类的设计意图和底层机制，你可以在面试中展现出对高并发场景的深刻掌控力！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38313134313134352f:61727469636c652f64657461696c732f313436313535363137" class_="artid" style="display:none">
 </p>
</div>


