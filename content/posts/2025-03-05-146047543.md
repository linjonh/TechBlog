---
layout: post
title: "flask学习1-基础"
date: 2025-03-05 21:30:00 +0800
description: "本文总结了Flask的安装、使用、路由、请求处理、模板渲染、扩展开发等内容，涵盖环境安装、应用创建、路由、模板渲染、请求处理、扩展开发及部署等方面，为开发者提供了一个全面的Flask应用开发指南。"
keywords: "flask学习1-基础"
categories: ['Flask']
tags: ['学习', 'Python', 'Flask']
artid: "146047543"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146047543
    alt: "flask学习1-基础"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146047543
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146047543
cover: https://bing.ee123.net/img/rand?artid=146047543
image: https://bing.ee123.net/img/rand?artid=146047543
img: https://bing.ee123.net/img/rand?artid=146047543
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     flask学习1-基础
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <br/>
    在线的省的自己装环境，选择python创建项目:
    <a href="https://www.marscode.cn/ide/kdkn1repe8dkeq" rel="nofollow">
     Python: main.py - MarsCode
    </a>
    <p>
    </p>
    <p>
     有2网站学flask：
     <a href="https://www.w3cschool.cn/flask/flask_application.html" rel="nofollow">
      Flask 应用_w3cschool
     </a>
    </p>
    <p>
     <a href="https://flask.palletsprojects.com/zh-cn/stable/quickstart/" rel="nofollow">
      官网:快速入门 — Flask 文档 （3.1.x）
     </a>
    </p>
    <h3>
     <a id="1_7">
     </a>
     1.环境安装
    </h3>
    <pre><code># 创建虚拟环境
$ mkdir testflask
$ cd testflask
$ python3 -m venv .venv
# 激活虚拟环境
$ . .venv/bin/activate
# 安装 Flask
pip install Flask
</code></pre>
    <h3>
     <a id="2_20">
     </a>
     2.使用
    </h3>
    <h4>
     <a id="21__22">
     </a>
     2.1 创建一个应用
    </h4>
    <p>
     在testflask下创建hello.py
    </p>
    <pre><code>from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello_world():
    return "&lt;p&gt;Hello, World!&lt;/p&gt;"
</code></pre>
    <p>
     启动项目 --debug 调试模式，不要在生产用
    </p>
    <pre><code>flask --app hello run --host=0.0.0.0
</code></pre>
    <p>
     访问：https://5dmoq7jq-pou9c8l4-cnsn6oy3hfgo.vcc3.mcprev.cn
    </p>
    <p>
     或者本地访问：curl http://localhost:5000
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/794afe4649d74089a86ed8ce6983d227.png"/>
    </p>
    <p>
     当然创建项目有可以选择flask的，我选择的是python，用做练习flask的安装使用。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/215360c79d5e4d579bc1d603b8ff8452.png"/>
    </p>
    <h4>
     <a id="22__54">
     </a>
     2.2 路由
    </h4>
    <pre><code># 路由也可以用add_url_rule绑定，访问/ak绑定到了hello_worldd函数，其他的都是可选值
def hello_worldd():
   return "&lt;p&gt;sssfsHello, World!&lt;/p&gt;"

app.add_url_rule('/ak', 'hello', hello_worldd)
</code></pre>
    <p>
     支持转换：
    </p>
    <pre><code>@app.route('/post/&lt;int:post_id&gt;')
@app.route('/path/&lt;path:subpath&gt;')
</code></pre>
    <p>
     转换器类型：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <code>
         string
        </code>
       </th>
       <th>
        （默认）接受任何不带斜杠的文本
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         int
        </code>
       </td>
       <td>
        接受正整数
       </td>
      </tr>
      <tr>
       <td>
        <code>
         float
        </code>
       </td>
       <td>
        接受正浮点值
       </td>
      </tr>
      <tr>
       <td>
        <code>
         path
        </code>
       </td>
       <td>
        like 但也接受斜杠
        <code>
         string
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         uuid
        </code>
       </td>
       <td>
        接受 UUID 字符串
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="23_HTTP__80">
     </a>
     2.3 HTTP 方法
    </h4>
    <p>
     @app.route(‘/login’, methods=[‘GET’, ‘POST’])
    </p>
    <pre><code># url_for使用
def hello_user(name):
   if name =='admin':
      return redirect(url_for('hello_admin'))
   else:
      return redirect(url_for('hello_guest', guest = name))
# 静态文件
url_for('static', filename='style.css')
#  Jinja2 模板引擎
from flask import render_template

@app.route('/hello/')
@app.route('/hello/&lt;name&gt;')
def hello(name=None):
    return render_template('hello.html', person=name)
    
/templates
    /hello.html
    
&lt;!doctype html&gt;
&lt;title&gt;Hello from Flask&lt;/title&gt;
{% if person %}
  &lt;h1&gt;Hello {<!-- -->{ person }}!&lt;/h1&gt;
{% else %}
  &lt;h1&gt;Hello, World!&lt;/h1&gt;
{% endif %}
# ---

</code></pre>
    <pre><code># 当 Flask 接收到一个请求时，它会创建一个请求上下文（Request Context），并将其绑定到当前线程。
# 在请求处理期间，request 和 session 等对象会被绑定到这个上下文。
# 由于每个线程都有自己的上下文，因此即使在多线程环境中，request 和 session 也能正确地返回当前请求的数据。
with app.test_request_context():
    print(url_for('index'))
    print(url_for('login'))
    print(url_for('login', next='/'))
    print(url_for('profile', username='John Doe'))
# 上下文结束后，request 对象不再可用
try:
    request.path
except RuntimeError:
    print("Request context is no longer available.")
</code></pre>
    <h4>
     <a id="24__131">
     </a>
     2.4 请求对象
    </h4>
    <p>
     要访问表单数据
    </p>
    <pre><code>@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == 'POST':
        if valid_login(request.form['username'],
                       request.form['password']):
            return log_the_user_in(request.form['username'])
        else:
            error = 'Invalid username/password'
    # the code below is executed if the request method
    # was GET or the credentials were invalid
    return render_template('login.html', error=error)
</code></pre>
    <p>
     要访问在 URL （） 中提交的参数，您可以使用以下属性：?key=value
    </p>
    <pre><code>searchword = request.args.get('key', '')
</code></pre>
    <h4>
     <a id="25__156">
     </a>
     2.5 文件上传
    </h4>
    <pre><code>from flask import request

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['the_file']
        f.save('/var/www/uploads/uploaded_file.txt')
    ...
</code></pre>
    <h4>
     <a id="26_Cookie_169">
     </a>
     2.6 Cookie
    </h4>
    <pre><code># 取
from flask import request
request.cookies.get('username')
# 存
from flask import make_response
resp = make_response(render_template(...))
resp.set_cookie('username', 'the username')
</code></pre>
    <h4>
     <a id="27__181">
     </a>
     2.7 重定向和错误
    </h4>
    <pre><code>from flask import abort, redirect, url_for

@app.route('/')
def index():
    return redirect(url_for('login'))

@app.route('/login')
def login():
    abort(401)
    this_is_never_executed()
</code></pre>
    <pre><code>from flask import render_template
# 全局拦截定义错误页面 404
@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html'), 404
</code></pre>
    <h4>
     <a id="28_json_204">
     </a>
     2.8 返回json
    </h4>
    <p>
     如果您从视图返回dict or list ，它将转换为 JSON 响应。 dict 或 list 中的所有数据都必须是 JSON 可序列化。
    </p>
    <pre><code>@app.route("/me")
def get_current_user():
    user = {
        "username": "example_user",
        "theme": "dark",
        "image": "default.jpg"
    }
    return user

@app.route("/users")
def get_all_users():
    # 假设这里有一些逻辑来获取所有用户
    users = [
        {"id": 1, "username": "user1"},
        {"id": 2, "username": "user2"},
        {"id": 3, "username": "user3"},
    ]
    # users = get_all_users()
    # return [user.to_json() for user in users]
    return users
</code></pre>
    <h4>
     <a id="29__231">
     </a>
     2.9 会话
    </h4>
    <pre><code class="prism language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> session

<span class="token comment"># Set the secret key to some random bytes. Keep this really secret!</span>
app<span class="token punctuation">.</span>secret_key <span class="token operator">=</span> <span class="token string">b'_5#y2L"F4Q8z\n\xec]/'</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token string">'username'</span> <span class="token keyword">in</span> session<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f'Logged in as </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>session<span class="token punctuation">[</span><span class="token string">"username"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">'</span></span>
    <span class="token keyword">return</span> <span class="token string">'You are not logged in'</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token punctuation">:</span>
        session<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> redirect<span class="token punctuation">(</span>url_for<span class="token punctuation">(</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token triple-quoted-string string">'''
        &lt;form method="post"&gt;
            &lt;p&gt;&lt;input type=text name=username&gt;
            &lt;p&gt;&lt;input type=submit value=Login&gt;
        &lt;/form&gt;
    '''</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/logout'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># remove the username from the session if it's there</span>
    session<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> redirect<span class="token punctuation">(</span>url_for<span class="token punctuation">(</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     访问：http://localhost:5000/login
    </p>
    <p>
     生成密钥
    </p>
    <pre><code>python -c 'import secrets; print(secrets.token_hex())'
</code></pre>
    <p>
     关于基于 cookie 的会话的说明：Flask 将采用您放入 session 对象并将它们序列化为 cookie。如果您发现一些 值不会在请求之间保留，Cookie 确实已启用，并且您 没有收到明确的错误消息，请检查页面中 cookie 的大小 响应与 Web 浏览器支持的大小进行比较。
    </p>
    <h4>
     <a id="210__274">
     </a>
     2.10 日志
    </h4>
    <pre><code>app.logger.debug('A value for debugging')
app.logger.warning('A warning occurred (%d apples)', 42)
app.logger.error('An error occurred')
</code></pre>
    <h4>
     <a id="211_WSGI_httpsflaskpalletsprojectscomzhcnstablequickstarthookinginwsgimiddleware_282">
     </a>
     2.11 WSGI 中间件中的挂钩
     <a href="https://flask.palletsprojects.com/zh-cn/stable/quickstart/#hooking-in-wsgi-middleware" rel="nofollow">
      ¶
     </a>
    </h4>
    <p>
     要将 WSGI 中间件添加到您的 Flask 应用程序，请包装应用程序的 attribute。例如，要应用 Werkzeug 的中间件来运行 Nginx 后面：wsgi_app
    </p>
    <pre><code class="prism language-nginx">server {
    listen 443 ssl;
    server_name example.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;

    location / {
        proxy_pass http://127.0.0.1:5000;  # 将请求转发到 Flask 应用
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
</code></pre>
    <pre><code class="prism language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
<span class="token keyword">from</span> werkzeug<span class="token punctuation">.</span>middleware<span class="token punctuation">.</span>proxy_fix <span class="token keyword">import</span> ProxyFix

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"Hello, World!"</span>

<span class="token comment"># 包装 wsgi_app，修复请求头</span>
app<span class="token punctuation">.</span>wsgi_app <span class="token operator">=</span> ProxyFix<span class="token punctuation">(</span>app<span class="token punctuation">.</span>wsgi_app<span class="token punctuation">,</span> x_for<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> x_proto<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> x_host<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> x_port<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> x_prefix<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <ul>
     <li>
      <strong>
       <code>
        x_for=1
       </code>
      </strong>
      ：修复
      <code>
       X-Forwarded-For
      </code>
      头，获取客户端的真实 IP 地址。
     </li>
     <li>
      <strong>
       <code>
        x_proto=1
       </code>
      </strong>
      ：修复
      <code>
       X-Forwarded-Proto
      </code>
      头，确保 Flask 应用知道请求是通过 HTTPS 发起的
     </li>
    </ul>
    <h4>
     <a id="212__Flask__324">
     </a>
     2.12 使用 Flask 扩展
    </h4>
    <h5>
     <a id="_326">
     </a>
     查找扩展
    </h5>
    <p>
     Flask 扩展通常命名为 “Flask-Foo” 或 “Foo-Flask”。您可以 在 PyPI 中搜索标记为
     <a href="https://pypi.org/search/?c=Framework+%3A%3A+Flask" rel="nofollow">
      Framework ：： Flask
     </a>
     的包。
    </p>
    <h5>
     <a id="_330">
     </a>
     使用扩展
    </h5>
    <p>
     请查阅每个扩展的文档，了解安装、配置、 和使用说明。通常，扩展会拉取自己的 配置 from
     <a href="https://flask.palletsprojects.com/zh-cn/stable/api/#flask.Flask.config" rel="nofollow">
      ``
     </a>
     和 are 在初始化期间传递应用程序实例。例如 一个名为 “Flask-Foo” 的扩展可以像这样使用：
    </p>
    <pre><code>from flask_foo import Foo

foo = Foo()

app = Flask(__name__)
app.config.update(
    FOO_BAR='baz',
    FOO_SPAM='eggs',
)

foo.init_app(app)
</code></pre>
    <h5>
     <a id="_348">
     </a>
     构建扩展
    </h5>
    <p>
     虽然
     <a href="https://pypi.org/search/?c=Framework+%3A%3A+Flask" rel="nofollow">
      PyPI
     </a>
     包含许多 Flask 扩展，但您可能找不到 适合您需求的扩展。如果是这种情况，您可以创建 您自己的，并将其发布供其他人使用。阅读
     <a href="https://flask.palletsprojects.com/zh-cn/stable/extensiondev/" rel="nofollow">
      Flask 扩展开发
     </a>
     以开发您自己的 Flask 扩展。
    </p>
    <h4>
     <a id="213__Web__352">
     </a>
     2.13 部署到 Web 服务器
    </h4>
    <p>
     WSGI服务器有内置的HTTP服务器。但是，专用的HTTP服务器可能更安全、更高效或功能更强大。将HTTP服务器放在WSGI服务器的前面称为“反向代理”。
    </p>
    <ul>
     <li>
      <a href="https://flask.palletsprojects.com/zh-cn/stable/deploying/proxy_fix/" rel="nofollow">
       Tell Flask it is Behind a Proxy
      </a>
     </li>
     <li>
      <a href="https://flask.palletsprojects.com/zh-cn/stable/deploying/nginx/" rel="nofollow">
       nginx
      </a>
     </li>
     <li>
      <a href="https://flask.palletsprojects.com/zh-cn/stable/deploying/apache-httpd/" rel="nofollow">
       Apache httpd
      </a>
     </li>
    </ul>
    <h4>
     <a id="214_flaskwsgiwsginginx_360">
     </a>
     2.14 flask、wsgi服务器、wsgi中间件、nginx的关系
    </h4>
    <h5>
     <a id="Flask_362">
     </a>
     <strong>
      Flask
     </strong>
    </h5>
    <ul>
     <li>
      Flask 是一个轻量级的 WSGI Web 框架，用于开发 Web 应用。
     </li>
     <li>
      Flask 应用本质上是一个 WSGI 应用，可以通过任何符合 WSGI 标准的服务器运行。
     </li>
    </ul>
    <h5>
     <a id="WSGI__Gunicorn__uWSGI_367">
     </a>
     <strong>
      WSGI 服务器（如 Gunicorn 或 uWSGI）
     </strong>
    </h5>
    <ul>
     <li>
      WSGI 服务器是运行 Flask 应用的后端服务，负责处理 Python 应用的请求和响应。
     </li>
     <li>
      常用的 WSGI 服务器包括 Gunicorn 和 uWSGI：
      <ul>
       <li>
        <strong>
         Gunicorn
        </strong>
        ：轻量级、易于配置，适合快速部署。
       </li>
       <li>
        <strong>
         uWSGI
        </strong>
        ：功能丰富，支持多进程、多线程和异步模式，适合高性能需求。
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <a id="Nginx_374">
     </a>
     <strong>
      Nginx
     </strong>
    </h5>
    <ul>
     <li>
      Nginx 是一个高性能的 Web 服务器和反向代理服务器。
     </li>
     <li>
      在部署 Flask 应用时，Nginx 通常作为反向代理服务器，将客户端的 HTTP 请求转发到后端的 WSGI 服务器（如 Gunicorn 或 uWSGI），并处理静态文件、SSL/TLS 终止等
     </li>
    </ul>
    <p>
     <strong>
      WSGI 中间件
     </strong>
    </p>
    <ul>
     <li>
      WSGI 中间件是位于 WSGI 服务器和 Flask 应用之间的可调用对象，用于在不修改应用代码的情况下添加功能
     </li>
    </ul>
    <h5>
     <a id="_383">
     </a>
     <strong>
      部署流程
     </strong>
    </h5>
    <h6>
     <a id="_1_Flask__385">
     </a>
     <strong>
      步骤 1：运行 Flask 应用
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       使用 WSGI 服务器（如 Gunicorn 或 uWSGI）启动 Flask 应用。
      </p>
     </li>
     <li>
      <p>
       示例：使用 Gunicorn 启动 Flask 应用：
      </p>
      <p>
       bash复制
      </p>
      <pre><code class="prism language-bash">gunicorn <span class="token parameter variable">-w</span> <span class="token number">4</span> <span class="token parameter variable">-b</span> <span class="token number">0.0</span>.0.0:8000 app:app
</code></pre>
      <p>
       其中
       <code>
        -w 4
       </code>
       表示启动 4 个工作进程，
       <code>
        -b 0.0.0.0:8000
       </code>
       表示绑定到 8000 端口。
      </p>
     </li>
    </ul>
    <h6>
     <a id="_2_Nginx__399">
     </a>
     <strong>
      步骤 2：配置 Nginx 作为反向代理
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       Nginx 配置文件示例：
      </p>
      <p>
       nginx复制
      </p>
      <pre><code class="prism language-nginx">server {
    listen 80;
    server_name yourdomain.com;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /static {
        alias /path/to/your/static/files;
    }
}
</code></pre>
      <ul>
       <li>
        <code>
         proxy_pass
        </code>
        将请求转发到后端的 WSGI 服务器。
       </li>
       <li>
        <code>
         location /static
        </code>
        用于处理静态文件。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="_3_427">
     </a>
     <strong>
      步骤 3：启动和管理服务
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       启动 Nginx 并确保其配置生效：
      </p>
      <p>
       bash复制
      </p>
      <pre><code class="prism language-bash"><span class="token function">sudo</span> systemctl restart nginx
</code></pre>
     </li>
     <li>
      <p>
       确保 WSGI 服务器（如 Gunicorn 或 uWSGI）在后台持续运行。
      </p>
     </li>
    </ul>
    <h6>
     <a id="WSGI__439">
     </a>
     <strong>
      WSGI 中间件的作用
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       WSGI 中间件是位于 WSGI 服务器和 Flask 应用之间的可调用对象，用于在不修改应用代码的情况下添加功能。
      </p>
     </li>
     <li>
      <p>
       例如，可以使用
       <code>
        ProxyFix
       </code>
       中间件修复在 Nginx 反向代理环境下可能出现的请求头问题：
      </p>
      <pre><code class="prism language-python"><span class="token keyword">from</span> werkzeug<span class="token punctuation">.</span>middleware<span class="token punctuation">.</span>proxy_fix <span class="token keyword">import</span> ProxyFix
app<span class="token punctuation">.</span>wsgi_app <span class="token operator">=</span> ProxyFix<span class="token punctuation">(</span>app<span class="token punctuation">.</span>wsgi_app<span class="token punctuation">)</span>
</code></pre>
      <p>
       这样可以确保 Flask 应用能够正确处理通过 Nginx 转发的请求。
      </p>
     </li>
    </ul>
    <h6>
     <a id="_452">
     </a>
     <strong>
      总结
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       Flask
      </strong>
      是 WSGI 应用，负责处理业务逻辑。
     </li>
     <li>
      <strong>
       WSGI 服务器
      </strong>
      （如 Gunicorn 或 uWSGI）运行 Flask 应用，处理 Python 请求。
     </li>
     <li>
      <strong>
       Nginx
      </strong>
      作为反向代理，处理静态文件、SSL/TLS 终止，并将动态请求转发到 WSGI 服务器。
     </li>
     <li>
      <strong>
       WSGI 中间件
      </strong>
      用于在 WSGI 服务器和 Flask 应用之间添加额外功能，如请求头修复。
     </li>
    </ul>
    <p>
     通过这种架构，可以实现高性能、高可用的 Flask 应用部署。
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373935343639332f:61727469636c652f64657461696c732f313436303437353433" class_="artid" style="display:none">
 </p>
</div>


