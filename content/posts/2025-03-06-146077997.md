---
layout: post
title: "react中的useContext-为什么使用一"
date: 2025-03-06 19:15:55 +0800
description: "让子组件把新的数据“反向”传回父组件，让父组件更新数据。React 提供了 useContext。，子组件无法直接修改父组件的数据。在 React 中，，但这还不算太糟糕。，就会变得非常痛苦。"
keywords: "usecontext 子组件可以改变父组件"
categories: ['React']
tags: ['前端框架', '前端', 'React']
artid: "146077997"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077997
    alt: "react中的useContext-为什么使用一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077997
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077997
cover: https://bing.ee123.net/img/rand?artid=146077997
image: https://bing.ee123.net/img/rand?artid=146077997
img: https://bing.ee123.net/img/rand?artid=146077997
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     react中的useContext--为什么使用（一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="React__0">
     </a>
     <strong>
      React 的数据传递流程
     </strong>
    </h4>
    <p>
     在 React 中，
     <strong>
      数据传递
     </strong>
     通常是
     <strong>
      自上而下
     </strong>
     的，也就是
     <strong>
      父组件把数据通过
      <code>
       props
      </code>
      传递给子组件
     </strong>
     ，子组件无法直接修改父组件的数据。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/90a7b35cb40e4bb4a0d1e787df5eaadf.jpeg#pic_center"/>
    </p>
    <h5>
     <a id="_4">
     </a>
     <strong>
      例子：父组件向子组件传递数据
     </strong>
    </h5>
    <pre><code class="prism language-jsx">const Parent = () =&gt; {
  const user = { name: "John", age: 24 };
  
  return &lt;Child user={user} /&gt;;
};

const Child = ({ user }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;姓名: {user.name}&lt;/h2&gt;
      &lt;h2&gt;年龄: {user.age}&lt;/h2&gt;
    &lt;/div&gt;
  );
};
</code></pre>
    <p>
     <strong>
      问题不大，看起来很简单，对吧？
     </strong>
    </p>
    <hr/>
    <h4>
     <a id="_25">
     </a>
     <strong>
      子组件传递数据的“噩梦”
     </strong>
    </h4>
    <p>
     但如果
     <strong>
      子组件需要修改父组件的数据
     </strong>
     ，就必须通过
     <strong>
      回调函数
     </strong>
     ，让子组件把新的数据“反向”传回父组件，让父组件更新数据。
    </p>
    <h5>
     <a id="_28">
     </a>
     <strong>
      例子：子组件修改父组件数据
     </strong>
    </h5>
    <pre><code class="prism language-jsx">const Parent = () =&gt; {
  const [user, setUser] = useState({ name: "John", age: 24 });

  // 让子组件调用这个方法来修改 user
  const updateUser = (newName) =&gt; {
    setUser({ ...user, name: newName });
  };

  return &lt;Child user={user} updateUser={updateUser} /&gt;;
};

const Child = ({ user, updateUser }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;姓名: {user.name}&lt;/h2&gt;
      &lt;button onClick={() =&gt; updateUser("Alice")}&gt;改名为 Alice&lt;/button&gt;
    &lt;/div&gt;
  );
};
</code></pre>
    <p>
     这样，点击按钮后，
     <code>
      John
     </code>
     就会变成
     <code>
      Alice
     </code>
     ，但这还不算太糟糕。
    </p>
    <p>
     <strong>
      真正的问题是：如果有很多层嵌套怎么办？
     </strong>
    </p>
    <hr/>
    <h4>
     <a id="_56">
     </a>
     <strong>
      多层嵌套时的“数据传递地狱”
     </strong>
    </h4>
    <p>
     如果
     <code>
      Child
     </code>
     不是直接在
     <code>
      Parent
     </code>
     里面，而是嵌套了
     <strong>
      好几层
     </strong>
     ，每一层都要手动传
     <code>
      props
     </code>
     ，就会变得非常痛苦。
    </p>
    <h5>
     <a id="_59">
     </a>
     <strong>
      数据传递“地狱”示例
     </strong>
    </h5>
    <pre><code class="prism language-jsx">const Parent = () =&gt; {
  const [user, setUser] = useState({ name: "John", age: 24 });

  const updateUser = (newName) =&gt; {
    setUser({ ...user, name: newName });
  };

  return &lt;Level1 user={user} updateUser={updateUser} /&gt;;
};

// 一层又一层地传递 props...
const Level1 = ({ user, updateUser }) =&gt; &lt;Level2 user={user} updateUser={updateUser} /&gt;;
const Level2 = ({ user, updateUser }) =&gt; &lt;Level3 user={user} updateUser={updateUser} /&gt;;
const Level3 = ({ user, updateUser }) =&gt; &lt;Level4 user={user} updateUser={updateUser} /&gt;;
const Level4 = ({ user, updateUser }) =&gt; (
  &lt;div&gt;
    &lt;h2&gt;姓名: {user.name}&lt;/h2&gt;
    &lt;button onClick={() =&gt; updateUser("Alice")}&gt;改名为 Alice&lt;/button&gt;
  &lt;/div&gt;
);
</code></pre>
    <p>
     <strong>
      问题：
     </strong>
    </p>
    <ul>
     <li>
      你要在
      <strong>
       每一层组件
      </strong>
      都写
      <code>
       props
      </code>
      传递，代码变得冗长且难以维护。
     </li>
     <li>
      组件越多，数据传递越混乱，很容易出错。
     </li>
     <li>
      这个问题被称为
      <strong>
       “Props Drilling”（属性挖掘）
      </strong>
      ，就像挖矿一样，数据要一层一层往下挖。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_useContext__89">
     </a>
     <strong>
      如何解决？——
      <code>
       useContext
      </code>
      来救场！
     </strong>
    </h4>
    <p>
     React 提供了
     <strong>
      <code>
       useContext
      </code>
     </strong>
     ，它就像一个
     <strong>
      全局数据仓库
     </strong>
     ，可以让任何组件
     <strong>
      直接访问
     </strong>
     数据，而不需要层层
     <code>
      props
     </code>
     传递。
    </p>
    <h5>
     <a id="_1_Context_92">
     </a>
     <strong>
      步骤 1：创建 Context
     </strong>
    </h5>
    <pre><code class="prism language-jsx">import { createContext, useState } from "react";

// 1. 创建 Context
const UserContext = createContext();

// 2. 创建 Provider 组件
const UserProvider = ({ children }) =&gt; {
  const [user, setUser] = useState({ name: "John", age: 24 });

  const updateUser = (newName) =&gt; {
    setUser({ ...user, name: newName });
  };

  return (
    &lt;UserContext.Provider value={<!-- -->{ user, updateUser }}&gt;
      {children}  {/* 这里的 children 让所有子组件都能访问这个 Context */}
    &lt;/UserContext.Provider&gt;
  );
};

export { UserContext, UserProvider };
</code></pre>
    <hr/>
    <h5>
     <a id="_2_useContext__119">
     </a>
     <strong>
      步骤 2：子组件直接用
      <code>
       useContext
      </code>
      读取数据
     </strong>
    </h5>
    <pre><code class="prism language-jsx">import { useContext } from "react";
import { UserContext } from "./UserContext";

const UserProfile = () =&gt; {
  const { user, updateUser } = useContext(UserContext);

  return (
    &lt;div&gt;
      &lt;h2&gt;姓名: {user.name}&lt;/h2&gt;
      &lt;button onClick={() =&gt; updateUser("Alice")}&gt;改名为 Alice&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default UserProfile;
</code></pre>
    <hr/>
    <h5>
     <a id="_3_Appjs__Provider_140">
     </a>
     <strong>
      步骤 3：在
      <code>
       App.js
      </code>
      里包裹 Provider
     </strong>
    </h5>
    <pre><code class="prism language-jsx">import React from "react";
import { UserProvider } from "./UserContext";
import UserProfile from "./UserProfile";

const App = () =&gt; {
  return (
    &lt;UserProvider&gt;
      &lt;UserProfile /&gt;
    &lt;/UserProvider&gt;
  );
};

export default App;
</code></pre>
    <hr/>
    <h4>
     <a id="_useContext__159">
     </a>
     <strong>
      为什么
      <code>
       useContext
      </code>
      很强大？
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       避免了“数据传递地狱”
      </strong>
      ：不需要层层
      <code>
       props
      </code>
      传递，所有组件都能直接访问数据。
     </li>
     <li>
      <strong>
       代码更清晰
      </strong>
      ：不管组件嵌套多少层，都能方便地读取和更新数据。
     </li>
     <li>
      <strong>
       性能更好
      </strong>
      ：不会因为
      <code>
       props
      </code>
      变化导致所有中间组件都重新渲染。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_166">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        传统数据传递方式（
        <code>
         props
        </code>
        ）
       </strong>
      </p>
      <ul>
       <li>
        适合小型项目，数据传递简单时使用。
       </li>
       <li>
        但是当层级变深时，
        <code>
         props drilling
        </code>
        让代码变得难以维护。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         useContext
        </code>
        方式
       </strong>
      </p>
      <ul>
       <li>
        适合共享状态的场景，比如用户信息、主题设置、语言切换等。
       </li>
       <li>
        让所有组件都能
        <strong>
         直接访问数据
        </strong>
        ，避免
        <code>
         props
        </code>
        层层传递。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        最佳实践
       </strong>
      </p>
      <ul>
       <li>
        如果数据只在
        <strong>
         父子组件之间传递
        </strong>
        ，用
        <code>
         props
        </code>
        即可。
       </li>
       <li>
        如果数据需要被多个组件共享，使用
        <code>
         useContext
        </code>
        来简化代码。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     🚀
     <strong>
      现在，你可以摆脱“数据传递地狱”，用
      <code>
       useContext
      </code>
      让 React 代码更清爽！
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031323434363936332f:61727469636c652f64657461696c732f313436303737393937" class_="artid" style="display:none">
 </p>
</div>


