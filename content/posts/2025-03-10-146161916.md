---
layout: post
title: "十四Golang-接口"
date: 2025-03-10 20:36:11 +0800
description: "接口是一种抽象的数据类型，它定义了一组方法或行为的规范，但不提供具体实现"
keywords: "【十四】Golang 接口"
categories: ['Golang']
tags: ['开发语言', '后端', 'Golang']
artid: "146161916"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146161916
    alt: "十四Golang-接口"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146161916
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146161916
cover: https://bing.ee123.net/img/rand?artid=146161916
image: https://bing.ee123.net/img/rand?artid=146161916
img: https://bing.ee123.net/img/rand?artid=146161916
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【十四】Golang 接口
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      💢欢迎来到张胤尘的开源技术站
      <br/>
      💥开源如江河，汇聚众志成。代码似星辰，照亮行征程。开源精神长，传承永不忘。携手共前行，未来更辉煌💥
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_5">
     </a>
     接口
    </h2>
    <p>
     <strong>
      接口是一种抽象的数据类型，它定义了一组方法或行为的规范，但不提供具体实现
     </strong>
     。在
     <code>
      golang
     </code>
     中接口的核心作用是：
     <strong>
      解耦合
     </strong>
     和
     <strong>
      多态
     </strong>
     。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        解耦合
       </strong>
       ：减少模块之间的直接依赖关系，使得模块之间的修改不会相互影响。另外，通过接口调用者只需要知道接口的规范，而不需要关心具体的实现细节。实现者可以随时替换，只要满足接口规范即可。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多态
       </strong>
       ：多态是指同一个接口可以被不同的实现类使用，调用者在运行时可以根据具体实现调用相应的方法。接口允许不同的实现类提供不同的行为，但调用者可以通过统一的接口进行操作。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_13">
     </a>
     接口定义
    </h3>
    <p>
     在
     <code>
      golang
     </code>
     中，接口通过
     <code>
      type
     </code>
     关键字和
     <code>
      interface
     </code>
     关键字定义。语法如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> InterfaceName <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Method1</span><span class="token punctuation">(</span>paramType1<span class="token punctuation">)</span> returnType1
    <span class="token function">Method2</span><span class="token punctuation">(</span>paramType2<span class="token punctuation">)</span> returnType2
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     例如：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span>
    <span class="token function">Perimeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在上面代码中，
     <code>
      Shape
     </code>
     是一个接口，它定义了两个方法：
     <code>
      Area()
     </code>
     和
     <code>
      Perimeter()
     </code>
     。
     <strong>
      只要是任何实现了这两个方法的类型都自动实现了
      <code>
       Shape
      </code>
      接口
     </strong>
     。
    </p>
    <p>
     下面有一个
     <code>
      Circle
     </code>
     类，实现了
     <code>
      Area()
     </code>
     和
     <code>
      Perimeter()
     </code>
     两个方法，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    Radius <span class="token builtin">float64</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Circle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>Radius <span class="token operator">*</span> c<span class="token punctuation">.</span>Radius
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Circle<span class="token punctuation">)</span> <span class="token function">Perimeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>Radius
<span class="token punctuation">}</span>
</code></pre>
    <p>
     从代码中可知
     <code>
      Circle
     </code>
     类型实现了
     <code>
      Shape
     </code>
     接口中的
     <code>
      Area()
     </code>
     和
     <code>
      Perimeter()
     </code>
     方法，它自动满足了
     <code>
      Shape
     </code>
     接口的要求。
    </p>
    <h3>
     <a id="_54">
     </a>
     接口初始化
    </h3>
    <p>
     接口的初始化并不是直接初始化接口本身，而是通过初始化实现了接口的类型来间接完成的。
     <strong>
      如果接口初始化时并没有指定具体的实现类，则接口默认是零值
      <code>
       nil
      </code>
      ，表示它没有指向任何具体的类型或值
     </strong>
     。如果接口变量为
     <code>
      nil
     </code>
     ，调用其方法会导致运行时错误。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span>
	<span class="token function">Perimeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> s Shape <span class="token operator">=</span> <span class="token boolean">nil</span>
	s<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// invalid memory address or nil pointer dereference</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     则需要为其指定正确的实现类来完成初始化行为，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"math"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span>
	<span class="token function">Perimeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Radius <span class="token builtin">float64</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Circle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>Radius <span class="token operator">*</span> c<span class="token punctuation">.</span>Radius
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Circle<span class="token punctuation">)</span> <span class="token function">Perimeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>Radius
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> shape Shape
	shape <span class="token operator">=</span> Circle<span class="token punctuation">{<!-- --></span>Radius<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token comment">// 初始化</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>shape<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 12.566370614359172</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     上述代码中，
     <code>
      shape
     </code>
     是一个
     <code>
      Shape
     </code>
     接口变量。通过将
     <code>
      Circle
     </code>
     类型的实例赋值给它，接口变量就初始化完成了，接下来通过
     <code>
      shape
     </code>
     调用了
     <code>
      Area
     </code>
     方法来打印出一个半径为 2 的
     <code>
      Circle
     </code>
     的面积。
    </p>
    <h3>
     <a id="_108">
     </a>
     接口嵌套
    </h3>
    <p>
     接口的嵌套主要体现在接口之间的继承关系，即一个接口可以嵌套另一个接口。这种嵌套关系可以让接口继承其他接口的方法集合，从而实现更灵活的接口设计。
    </p>
    <p>
     定义一个接口
     <code>
      Reader
     </code>
     ，在接口中定义了一个
     <code>
      Read
     </code>
     方法，用于从某个数据源读取数据到一个字节切片
     <code>
      p
     </code>
     中。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     定义一个接口
     <code>
      Writer
     </code>
     ，在接口中定义了一个
     <code>
      Write
     </code>
     方法，用于将字节切片
     <code>
      p
     </code>
     中的数据写入某个目标。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     定义一个接口
     <code>
      ReadWriter
     </code>
     ，通过嵌套
     <code>
      Reader
     </code>
     和
     <code>
      Writer
     </code>
     ，它继承了这两个接口的所有方法。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
    Reader
    Writer
<span class="token punctuation">}</span>
</code></pre>
    <p>
     由于
     <code>
      ReadWriter
     </code>
     继承了
     <code>
      Reader
     </code>
     和
     <code>
      Writer
     </code>
     两个接口，所以实现
     <code>
      ReadWriter
     </code>
     接口也同样需要实现这两个接口中的方法，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> MyReadWriter <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MyReadWriter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"MyReadWriter Read~~ %c\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MyReadWriter<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"MyReadWriter Write~~ %c\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     最后通过
     <code>
      main
     </code>
     函数进行测试，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> rw ReadWriter
	rw <span class="token operator">=</span> <span class="token operator">&amp;</span>MyReadWriter<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	rw<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello world~ ycz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// MyReadWriter Read~~ [h e l l o   w o r l d ~   y c z]</span>
	rw<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello world~ ycz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// MyReadWriter Write~~ [h e l l o   w o r l d ~   y c z]</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     通过接口嵌套，可以将接口的功能进行模块化设计，从而实现功能的组合和扩展，也可以避免在每个接口中重复定义相同的方法。
    </p>
    <h3>
     <a id="_167">
     </a>
     空接口
    </h3>
    <p>
     空接口是一种特殊的接口类型，它不包含任何方法。由于它没有任何方法约束，因此可以存储任何类型的值。定义如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">var</span> v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre>
    <p>
     上述代码中的
     <code>
      v
     </code>
     是一个空接口变量，它可以存储任何类型的值。
    </p>
    <p>
     在实际开发过程中，会经常使用到空接口，例如：
     <strong>
      存储任意类型的数据
     </strong>
     、
     <strong>
      作为函数参数
     </strong>
     、
     <strong>
      类型断言和类型切换
     </strong>
     。
    </p>
    <h4>
     <a id="_179">
     </a>
     存储任意类型的数据
    </h4>
    <p>
     空接口可以存储任何类型的值，包括基本类型（如
     <code>
      int
     </code>
     、
     <code>
      string
     </code>
     ）、自定义类型（如结构体、切片、映射等）。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	v <span class="token operator">=</span> <span class="token number">42</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment">// 42</span>

	v <span class="token operator">=</span> <span class="token string">"zyc"</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment">// zyc</span>

	v <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment">// [1 2 3]</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_202">
     </a>
     作为函数参数
    </h4>
    <p>
     空接口常用于函数参数，使函数能够接受任何类型的值。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">PrintValue</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">PrintValue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>             <span class="token comment">// 10</span>
	<span class="token function">PrintValue</span><span class="token punctuation">(</span><span class="token string">"zzzzzzz"</span><span class="token punctuation">)</span>      <span class="token comment">// zzzzzzz</span>
	<span class="token function">PrintValue</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [1 2 3]</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_222">
     </a>
     类型断言和类型切换
    </h4>
    <p>
     由于空接口存储的值类型不明确，通常需要通过
     <strong>
      类型断言
     </strong>
     或
     <strong>
      类型切换
     </strong>
     来获取其实际类型。
    </p>
    <h5>
     <a id="_226">
     </a>
     类型断言
    </h5>
    <p>
     用于从接口变量中提取具体的类型值。基本语法格式如下所示：
    </p>
    <pre><code class="prism language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> interfaceVariable<span class="token punctuation">.</span><span class="token punctuation">(</span>Type<span class="token punctuation">)</span>value <span class="token operator">:=</span> iface<span class="token punctuation">.</span><span class="token punctuation">(</span>Type<span class="token punctuation">)</span>
</code></pre>
    <p>
     在使用过程中，如果断言失败，
     <code>
      ok
     </code>
     会返回
     <code>
      false
     </code>
     ，而
     <code>
      value
     </code>
     会是目标类型的零值。
     <strong>
      但是需要注意的是，如果直接使用类型断言而不检查
      <code>
       ok
      </code>
      值可能导致运行时
      <code>
       panic
      </code>
     </strong>
     。例如，如果接口变量的实际类型与断言类型不匹配，程序会崩溃。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token string">"Hello, World!"</span>

	<span class="token keyword">if</span> str<span class="token punctuation">,</span> ok <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"v is string:"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token comment">// v is string: Hello, World!</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"v is not string"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_252">
     </a>
     类型切换
    </h5>
    <p>
     结合
     <code>
      switch...case
     </code>
     语句，处理接口变量可能包含多种类型的情况，基本语法格式如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">switch</span> v <span class="token operator">:=</span> interfaceVariable<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">case</span> Type1<span class="token punctuation">:</span>
    <span class="token comment">// 处理 Type1</span>
<span class="token keyword">case</span> Type2<span class="token punctuation">:</span>
    <span class="token comment">// 处理 Type2</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token comment">// 默认处理</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     类型切换适用于接口变量可能包含多种类型的情况，可以在多个类型之间进行分支处理。另外，与类型断言相比，类型切换可以优雅地处理未知类型，通过
     <code>
      default
     </code>
     分支提供默认逻辑。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token number">10</span>

	<span class="token keyword">switch</span> v <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"v is int:"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token comment">// v is int: 10</span>
	<span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"v is string:"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"unknown type"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_288">
     </a>
     源码解析
    </h3>
    <p>
     接口从功能上来说分为两类：
     <strong>
      空接口
     </strong>
     和
     <strong>
      非空接口
     </strong>
     。它们再底层实现上大致是类似的（还是有区别），但是它们的用途和约束有所不同：
    </p>
    <ul>
     <li>
      <strong>
       空接口
      </strong>
      ：没有方法集合，因此可以存储任何类型的值。
     </li>
     <li>
      <strong>
       非空接口
      </strong>
      ：有一个方法集合，只有实现了这些方法的类型才能被存储。
     </li>
    </ul>
    <p>
     下面分别从这两类对接口的源码进行深度解析。
    </p>
    <h4>
     <a id="_297">
     </a>
     空接口
    </h4>
    <p>
     空接口底层实现基于一个结构体，通常被称为
     <strong>
      接口类型描述符
     </strong>
     。定义如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> eface <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	_type <span class="token operator">*</span>_type
	data  unsafe<span class="token punctuation">.</span>Pointer
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       _type
      </code>
      ：指向一个类型描述符，它包含了值的类型信息，例如类型名称、大小、方法集合等。
     </li>
     <li>
      <code>
       data
      </code>
      ：是一个指针，指向实际存储的值。由于
      <code>
       data
      </code>
      是一个通用指针，它可以指向任何类型的值。
     </li>
    </ul>
    <h5>
     <a id="_313">
     </a>
     类型描述符
    </h5>
    <blockquote>
     <p>
      源码位置：src/runtime/type.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> _type <span class="token operator">=</span> abi<span class="token punctuation">.</span>Type
</code></pre>
    <blockquote>
     <p>
      源码位置：src/internal/abi/type.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Type <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Size_       <span class="token builtin">uintptr</span>
	PtrBytes    <span class="token builtin">uintptr</span> <span class="token comment">// number of (prefix) bytes in the type that can contain pointers</span>
	Hash        <span class="token builtin">uint32</span>  <span class="token comment">// hash of type; avoids computation in hash tables</span>
	TFlag       TFlag   <span class="token comment">// extra type information flags</span>
	Align_      <span class="token builtin">uint8</span>   <span class="token comment">// alignment of variable with this type</span>
	FieldAlign_ <span class="token builtin">uint8</span>   <span class="token comment">// alignment of struct field with this type</span>
	Kind_       Kind    <span class="token comment">// enumeration for C</span>
	<span class="token comment">// function for comparing objects of this type</span>
	<span class="token comment">// (ptr to object A, ptr to object B) -&gt; ==?</span>
	Equal <span class="token keyword">func</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span>
	<span class="token comment">// GCData stores the GC type data for the garbage collector.</span>
	<span class="token comment">// If the KindGCProg bit is set in kind, GCData is a GC program.</span>
	<span class="token comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span>
	GCData    <span class="token operator">*</span><span class="token builtin">byte</span>
	Str       NameOff <span class="token comment">// string form</span>
	PtrToThis TypeOff <span class="token comment">// type for pointer to this type, may be zero</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Size_
      </code>
      ：类型的大小（以字节为单位）。例如，
      <code>
       int32
      </code>
      的大小为 4 字节，
      <code>
       int64
      </code>
      的大小为 8 字节。
     </li>
     <li>
      <code>
       PtrBytes
      </code>
      ：类型中可能包含指针的前缀部分的字节数。这个字段主要用于垃圾回收器，帮助
      <code>
       gc
      </code>
      确定哪些部分可能包含指针。
     </li>
     <li>
      <code>
       Hash
      </code>
      ：类型的哈希值，用于在哈希表中快速比较和查找类型。
     </li>
     <li>
      <code>
       TFlag
      </code>
      ：类型标志，存储额外的类型信息标志。
     </li>
     <li>
      <code>
       Align_
      </code>
      ：类型的对齐要求。例如，
      <code>
       int64
      </code>
      在内存中需要 8 字节对齐。
     </li>
     <li>
      <code>
       FieldAlign_
      </code>
      ：作为结构体字段时的对齐要求。
     </li>
     <li>
      <code>
       Kind_
      </code>
      ：类型的种类（
      <code>
       Kind
      </code>
      ），是一个枚举值，例如
      <code>
       reflect.Int
      </code>
      、
      <code>
       reflect.String
      </code>
      、
      <code>
       reflect.Struct
      </code>
      等。
     </li>
     <li>
      <code>
       Equal
      </code>
      ：一个函数指针，用于比较两个该类型的值是否相等。例如，对于结构体类型，
      <code>
       Equal
      </code>
      函数会比较结构体的每个字段是否相等。
     </li>
     <li>
      <code>
       GCData
      </code>
      ：垃圾回收相关的数据。如果
      <code>
       Kind
      </code>
      中设置了
      <code>
       KindGCProg
      </code>
      标志，则
      <code>
       GCData
      </code>
      是一个垃圾回收程序；否则是一个指针掩码（
      <code>
       ptrmask
      </code>
      ）。
     </li>
     <li>
      <code>
       Str
      </code>
      ：类型的字符串表示（
      <code>
       NameOff
      </code>
      是一个偏移量，指向类型名称的字符串）。
     </li>
     <li>
      <code>
       PtrToThis
      </code>
      ：指向该类型的指针类型的偏移量。例如，如果
      <code>
       Type
      </code>
      表示
      <code>
       int
      </code>
      ，则
      <code>
       PtrToThis
      </code>
      表示
      <code>
       *int
      </code>
      。
     </li>
    </ul>
    <h5>
     <a id="_356">
     </a>
     输出接口值
    </h5>
    <p>
     给出一段打印空接口值的代码，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token number">10</span>
	<span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment">// (0x46d400,0x4967e8)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将上面的代码编译成汇编代码，如下所示：
    </p>
    <pre><code class="prism language-assembly">0x000e 00014        CALL    runtime.printlock(SB)
# ...
0x0021 00033        CALL    runtime.printeface(SB)
0x0026 00038        CALL    runtime.printunlock(SB)
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     <code>
      printeface
     </code>
     函数是运行时打印接口值所执行的函数，如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/print.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">printeface</span><span class="token punctuation">(</span>e eface<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>_type<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">")"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     经过
     <code>
      print
     </code>
     函数执行后，将类型描述符的地址和底层实际存储的值的地址格式化打印出来。
    </p>
    <h4>
     <a id="_392">
     </a>
     非空接口
    </h4>
    <p>
     非空接口底层实现也是基于一个结构体，通常被称为
     <strong>
      接口类型描述符
     </strong>
     。定义如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> iface <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	tab  <span class="token operator">*</span>itab
	data unsafe<span class="token punctuation">.</span>Pointer
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <p>
       <code>
        tab
       </code>
       ：是一个指向
       <code>
        ITab
       </code>
       的指针，
       <code>
        ITab
       </code>
       是一个重要的结构体，用于存储接口类型和具体实现类型之间的映射关系。
      </p>
     </li>
     <li>
      <p>
       <code>
        data
       </code>
       ：是一个指针，指向实际存储的值。由于
       <code>
        data
       </code>
       是一个通用指针，它可以指向任何类型的值。
      </p>
     </li>
    </ul>
    <h5>
     <a id="ITab_409">
     </a>
     <code>
      ITab
     </code>
    </h5>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> itab <span class="token operator">=</span> abi<span class="token punctuation">.</span>ITab
</code></pre>
    <p>
     <code>
      ITab
     </code>
     是一个运行时结构体，用于表示接口类型和具体实现类型之间的映射关系。它的定义如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/internal/abi/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> ITab <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Inter <span class="token operator">*</span>InterfaceType
	Type  <span class="token operator">*</span>Type
	Hash  <span class="token builtin">uint32</span>     <span class="token comment">// copy of Type.Hash. Used for type switches.</span>
	Fun   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span> <span class="token comment">// variable sized. fun[0]==0 means Type does not implement Inter.</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Inter
      </code>
      （
      <code>
       *InterfaceType
      </code>
      ）：接口类型的类型描述符。这表示接口的类型信息，例如接口中定义的方法集合。
     </li>
     <li>
      <code>
       Type
      </code>
      （
      <code>
       *Type
      </code>
      ）：具体实现类型的类型描述符。这表示接口背后的实际类型。
     </li>
     <li>
      <code>
       Hash
      </code>
      （
      <code>
       uint32
      </code>
      ）：用于类型切换的哈希值。它是
      <code>
       Type.Hash
      </code>
      的副本，用于快速比较类型。
     </li>
     <li>
      <code>
       Fun
      </code>
      （
      <code>
       [1]uintptr
      </code>
      ）：一个可变大小的数组，存储接口方法到具体实现方法的映射（函数指针）。
      <code>
       Fun
      </code>
      数组的大小取决于接口中定义的方法数量。
     </li>
    </ul>
    <h5>
     <a id="itabTableType_435">
     </a>
     <code>
      itabTableType
     </code>
    </h5>
    <p>
     <code>
      itabTableType
     </code>
     是
     <code>
      golang
     </code>
     运行时用来存储和管理所有
     <code>
      itab
     </code>
     的数据结构。它是一个全局的哈希表，用于缓存已经生成的
     <code>
      itab
     </code>
     ，以避免重复创建。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">const</span> itabInitSize <span class="token operator">=</span> <span class="token number">512</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
	itabLock      mutex                               <span class="token comment">// lock for accessing itab table</span>
	itabTable     <span class="token operator">=</span> <span class="token operator">&amp;</span>itabTableInit                    <span class="token comment">// pointer to current table</span>
	itabTableInit <span class="token operator">=</span> itabTableType<span class="token punctuation">{<!-- --></span>size<span class="token punctuation">:</span> itabInitSize<span class="token punctuation">}</span> <span class="token comment">// starter table</span>
<span class="token punctuation">)</span>

<span class="token comment">// Note: change the formula in the mallocgc call in itabAdd if you change these fields.</span>
<span class="token keyword">type</span> itabTableType <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	size    <span class="token builtin">uintptr</span>             <span class="token comment">// length of entries array. Always a power of 2.</span>
	count   <span class="token builtin">uintptr</span>             <span class="token comment">// current number of filled entries.</span>
	entries <span class="token punctuation">[</span>itabInitSize<span class="token punctuation">]</span><span class="token operator">*</span>itab <span class="token comment">// really [size] large</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       size
      </code>
      ：哈希表的大小（即
      <code>
       entries
      </code>
      数组的长度）。它始终是 2 的幂次方。
     </li>
     <li>
      <code>
       count
      </code>
      ：当前哈希表中已填充的条目数量（即已存储的
      <code>
       itab
      </code>
      数量）。
     </li>
     <li>
      <code>
       entries
      </code>
      ：哈希表的条目指针数组，存储指向
      <code>
       itab
      </code>
      的指针。数组的初始长度是512。
     </li>
    </ul>
    <h6>
     <a id="_itab__462">
     </a>
     初始化
     <code>
      itab
     </code>
     表
    </h6>
    <p>
     在
     <code>
      golang
     </code>
     程序启动时，运行时会执行一系列初始化操作，包括初始化全局锁、内存分配器等。在这些初始化操作中，
     <code>
      itabsinit
     </code>
     函数会被调用，用于初始化全局的
     <code>
      itab
     </code>
     表。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">itabsinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 初始化全局锁 itabLock</span>
	<span class="token function">lockInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">,</span> lockRankItab<span class="token punctuation">)</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
    <span class="token comment">// 获取所有加载的模块</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> md <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">activeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> md<span class="token punctuation">.</span>itablinks <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 将每个模块的 itab 添加到全局表中</span>
			<span class="token function">itabAdd</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      itabsinit
     </code>
     函数会遍历所有加载的模块，将每个模块的
     <code>
      itab
     </code>
     添加到全局表中。
    </p>
    <h6>
     <a id="_itab_486">
     </a>
     添加
     <code>
      itab
     </code>
    </h6>
    <p>
     <code>
      itabAdd
     </code>
     函数的主要作用是将一个新的
     <code>
      itab
     </code>
     添加到全局的
     <code>
      itab
     </code>
     表中。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// itabAdd adds the given itab to the itab hash table.</span>
<span class="token comment">// itabLock must be held.</span>
<span class="token keyword">func</span> <span class="token function">itabAdd</span><span class="token punctuation">(</span>m <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// Bugs can lead to calling this while mallocing is set,</span>
	<span class="token comment">// typically because this is called while panicking.</span>
	<span class="token comment">// Crash reliably, rather than only when we need to grow</span>
	<span class="token comment">// the hash table.</span>
    <span class="token comment">// 检查当前 Goroutine 是否处于内存分配中</span>
    <span class="token comment">// 如果在内存分配中调用 itabAdd，会触发死锁，因此直接抛出错误</span>
	<span class="token keyword">if</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>mallocing <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"malloc deadlock"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	t <span class="token operator">:=</span> itabTable
    <span class="token comment">// 检查哈希表的负载因子是否超过 75%</span>
	<span class="token keyword">if</span> t<span class="token punctuation">.</span>count <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token operator">*</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>size<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 75% load factor</span>
        <span class="token comment">// 哈希表扩容的逻辑</span>
		<span class="token comment">// Grow hash table.</span>
		<span class="token comment">// t2 = new(itabTableType) + some additional entries</span>
		<span class="token comment">// We lie and tell malloc we want pointer-free memory because</span>
		<span class="token comment">// all the pointed-to values are not in the heap.</span>
        <span class="token comment">// 分配新的哈希表，大小为原来的两倍</span>
		t2 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itabTableType<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>t<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		t2<span class="token punctuation">.</span>size <span class="token operator">=</span> t<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span>
		
        <span class="token comment">// 在复制时，其他线程可能会寻找 itab 而找不到它。没关系，然后它们将尝试获取 tab 锁，并因此等待，直到复制完成</span>
		<span class="token comment">// Copy over entries.</span>
		<span class="token comment">// Note: while copying, other threads may look for an itab and</span>
		<span class="token comment">// fail to find it. That's ok, they will then try to get the itab lock</span>
		<span class="token comment">// and as a consequence wait until this copying is complete.</span>
        <span class="token comment">// 遍历当前哈希表中的所有 itab，并将它们添加到新的哈希表中</span>
        <span class="token comment">// 传入 add 函数指针，其实调用的还是 add 函数进行添加</span>
		<span class="token function">iterate_itabs</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>add<span class="token punctuation">)</span>
		<span class="token keyword">if</span> t2<span class="token punctuation">.</span>count <span class="token operator">!=</span> t<span class="token punctuation">.</span>count <span class="token punctuation">{<!-- --></span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"mismatched count during itab table copy"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Publish new hash table. Use an atomic write: see comment in getitab.</span>
        <span class="token comment">// 原子地更新全局 itabTable 指针，确保线程安全</span>
		<span class="token function">atomicstorep</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabTable<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">// Adopt the new table as our own.</span>
		t <span class="token operator">=</span> itabTable
		<span class="token comment">// Note: the old table can be GC'ed here.</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 如果没有超过 75%，则调用 itabTableType.add 方法，将新的 itab 添加到哈希表中</span>
	t<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     另外，在扩容完成后，新的
     <code>
      itab
     </code>
     表需要被发布。为了确保线程安全，
     <code>
      golang
     </code>
     使用原子操作
     <code>
      atomicstorep
     </code>
     来更新全局
     <code>
      itabTable
     </code>
     指针，这样可以确保在多线程环境下，
     <code>
      itabTable
     </code>
     的更新是线程安全的。
    </p>
    <p>
     接下来就是将
     <code>
      itab
     </code>
     添加到哈希表中的代码
     <code>
      itabTableType.add
     </code>
     。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// add adds the given itab to itab table t.</span>
<span class="token comment">// itabLock must be held.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>itabTableType<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>m <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// See comment in find about the probe sequence.</span>
	<span class="token comment">// Insert new itab in the first empty spot in the probe sequence.</span>
    <span class="token comment">// 使用掩码 mask 确保哈希值在哈希表的范围内</span>
	mask <span class="token operator">:=</span> t<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment">// 使用 itabHashFunc 计算 itab 的哈希值</span>
	h <span class="token operator">:=</span> <span class="token function">itabHashFunc</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Inter<span class="token punctuation">,</span> m<span class="token punctuation">.</span>Type<span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用线性探测法解决哈希冲突</span>
		p <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>entries<span class="token punctuation">)</span><span class="token punctuation">,</span> h<span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
		m2 <span class="token operator">:=</span> <span class="token operator">*</span>p
        <span class="token comment">// 如果出现相同的 itab 则直接返回，避免重复添加</span>
		<span class="token keyword">if</span> m2 <span class="token operator">==</span> m <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// A given itab may be used in more than one module</span>
			<span class="token comment">// and thanks to the way global symbol resolution works, the</span>
			<span class="token comment">// pointed-to itab may already have been inserted into the</span>
			<span class="token comment">// global 'hash'.</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果找到空位，将新的 itab 添加到该位置</span>
		<span class="token keyword">if</span> m2 <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Use atomic write here so if a reader sees m, it also</span>
			<span class="token comment">// sees the correctly initialized fields of m.</span>
			<span class="token comment">// NoWB is ok because m is not in heap memory.</span>
			<span class="token comment">// *p = m</span>
            <span class="token comment">// 使用 atomic.StorepNoWB 确保写入操作是原子的</span>
			atomic<span class="token punctuation">.</span><span class="token function">StorepNoWB</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 更改全局哈希表的计数值</span>
			t<span class="token punctuation">.</span>count<span class="token operator">++</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">// 更新哈希值</span>
        <span class="token comment">// 直接查找下一个，线性探测法</span>
		h <span class="token operator">+=</span> i
		h <span class="token operator">&amp;=</span> mask
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h6>
     <a id="_itab_591">
     </a>
     查找
     <code>
      itab
     </code>
    </h6>
    <p>
     <code>
      getitab
     </code>
     函数的作用是查找或生成一个
     <code>
      itab
     </code>
     。如果找到现成的
     <code>
      itab
     </code>
     ，则直接返回；如果没有找到，则动态生成一个新的
     <code>
      itab
     </code>
     并添加到全局表中。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// getitab should be an internal detail,</span>
<span class="token comment">// but widely used packages access it using linkname.</span>
<span class="token comment">// Notable members of the hall of shame include:</span>
<span class="token comment">//   - github.com/bytedance/sonic</span>
<span class="token comment">//</span>
<span class="token comment">// Do not remove or change the type signature.</span>
<span class="token comment">// See go.dev/issue/67401.</span>
<span class="token comment">//</span>
<span class="token comment">//go:linkname getitab</span>
<span class="token keyword">func</span> <span class="token function">getitab</span><span class="token punctuation">(</span>inter <span class="token operator">*</span>interfacetype<span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> canfail <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token operator">*</span>itab <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果接口没有方法，抛出内部错误</span>
    <span class="token comment">// 必须保证是非空接口</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>Methods<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"internal error - misuse of itab"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// easy case</span>
    <span class="token comment">// 如果具体类型没有方法表, 并且 canfail 为 true，则返回 nil</span>
	<span class="token keyword">if</span> typ<span class="token punctuation">.</span>TFlag<span class="token operator">&amp;</span>abi<span class="token punctuation">.</span>TFlagUncommon <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> canfail <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果 canfail 为 false，抛出类型断言错误</span>
		name <span class="token operator">:=</span> <span class="token function">toRType</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>Type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>Methods<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{<!-- --></span><span class="token boolean">nil</span><span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>Type<span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> m <span class="token operator">*</span>itab

	<span class="token comment">// First, look in the existing table to see if we can find the itab we need.</span>
	<span class="token comment">// This is by far the most common case, so do it without locks.</span>
	<span class="token comment">// Use atomic to ensure we see any previous writes done by the thread</span>
	<span class="token comment">// that updates the itabTable field (with atomic.Storep in itabAdd).</span>
    <span class="token comment">// 使用原子操作加载全局 itabTable</span>
	t <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itabTableType<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loadp</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabTable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用 t.find 查找现有的 itab</span>
	<span class="token keyword">if</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> typ<span class="token punctuation">)</span><span class="token punctuation">;</span> m <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果找到，跳转到 finish</span>
		<span class="token keyword">goto</span> finish
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果没有找到，先加锁，确保线程安全</span>
	<span class="token comment">// Not found.  Grab the lock and try again.</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
    <span class="token comment">// 再次查找</span>
	<span class="token keyword">if</span> m <span class="token operator">=</span> itabTable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> typ<span class="token punctuation">)</span><span class="token punctuation">;</span> m <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 找到了直接就解锁，跳转到 finish</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> finish
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果代码走到了这里，表示全局 itabTable 表中不存在目标 itab</span>
    <span class="token comment">// 下面就需要动态生成 itab，并加入到全局 itabTable 表中</span>
	<span class="token comment">// Entry doesn't exist yet. Make a new entry &amp; add it.</span>
    <span class="token comment">// 动态分配新的 itab</span>
	m <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">persistentalloc</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>itab<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>Methods<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 初始化 itab 的字段</span>
	m<span class="token punctuation">.</span>Inter <span class="token operator">=</span> inter
	m<span class="token punctuation">.</span>Type <span class="token operator">=</span> typ
	<span class="token comment">// The hash is used in type switches. However, compiler statically generates itab's</span>
	<span class="token comment">// for all interface/type pairs used in switches (which are added to itabTable</span>
	<span class="token comment">// in itabsinit). The dynamically-generated itab's never participate in type switches,</span>
	<span class="token comment">// and thus the hash is irrelevant.</span>
	<span class="token comment">// Note: m.Hash is _not_ the hash used for the runtime itabTable hash table.</span>
	m<span class="token punctuation">.</span>Hash <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 调用 itabInit 初始化方法表</span>
	<span class="token function">itabInit</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用 itabAdd 将新的 itab 添加到全局表中</span>
	<span class="token function">itabAdd</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
    <span class="token comment">// 解锁</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
    
    <span class="token comment">// 接下来就是查找完成的逻辑</span>
finish<span class="token punctuation">:</span>
    <span class="token comment">// 如果 m.Fun[0] 不为 0，返回 itab</span>
    <span class="token comment">// 这里需要解释一下，为什么这里需要加这么一个判断</span>
    <span class="token comment">// 因为 m.Fun[0] 是这个方法表的第一个元素，通常对应接口的第一个方法</span>
    <span class="token comment">// m.Fun[0] != 0 就表示接口的第一个方法已经被正确加载，也就是说 itab 已经初始化完毕了</span>
    <span class="token comment">// m.Fun[0] == 0 表示接口的第一个方法没有被加载，itab初始化失败</span>
	<span class="token keyword">if</span> m<span class="token punctuation">.</span>Fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> m
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 如果 canfail 为 true，返回 nil</span>
	<span class="token keyword">if</span> canfail <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// this can only happen if the conversion</span>
	<span class="token comment">// was already done once using the , ok form</span>
	<span class="token comment">// and we have a cached negative result.</span>
	<span class="token comment">// The cached result doesn't record which</span>
	<span class="token comment">// interface function was missing, so initialize</span>
	<span class="token comment">// the itab again to get the missing function name.</span>
    <span class="token comment">// 否则，抛出类型断言错误</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{<!-- --></span>concrete<span class="token punctuation">:</span> typ<span class="token punctuation">,</span> asserted<span class="token punctuation">:</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>Type<span class="token punctuation">,</span> missingMethod<span class="token punctuation">:</span> <span class="token function">itabInit</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      find
     </code>
     方法的作用就是在
     <code>
      itabTable
     </code>
     中查找给定的接口类型和具体类型的
     <code>
      itab
     </code>
     。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// find finds the given interface/type pair in t.</span>
<span class="token comment">// Returns nil if the given interface/type pair isn't present.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>itabTableType<span class="token punctuation">)</span> <span class="token function">find</span><span class="token punctuation">(</span>inter <span class="token operator">*</span>interfacetype<span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">)</span> <span class="token operator">*</span>itab <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// Implemented using quadratic probing.</span>
	<span class="token comment">// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k.</span>
	<span class="token comment">// We're guaranteed to hit all table entries using this probe sequence.</span>
	mask <span class="token operator">:=</span> t<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment">// 计算接口类型和具体类型的哈希值</span>
	h <span class="token operator">:=</span> <span class="token function">itabHashFunc</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> typ<span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 计算当前哈希位置的指针</span>
		p <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>entries<span class="token punctuation">)</span><span class="token punctuation">,</span> h<span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">// Use atomic read here so if we see m != nil, we also see</span>
		<span class="token comment">// the initializations of the fields of m.</span>
		<span class="token comment">// m := *p</span>
        <span class="token comment">// 使用原子操作加载 itab，确保线程安全</span>
		m <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loadp</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果当前位置为空，返回 nil，表示未找到匹配的 itab</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果当前 itab 的接口类型和具体类型与目标匹配，返回该 itab</span>
		<span class="token keyword">if</span> m<span class="token punctuation">.</span>Inter <span class="token operator">==</span> inter <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">.</span>Type <span class="token operator">==</span> typ <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> m
		<span class="token punctuation">}</span>
        
        <span class="token comment">// 当前位置不为空，并且与目标类型也不匹配，则直接查找下一个</span>
        <span class="token comment">// 线性探测法</span>
        
        <span class="token comment">// 更新哈希值</span>
		h <span class="token operator">+=</span> i
		h <span class="token operator">&amp;=</span> mask
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在上面的代码中，使用了原子操作
     <code>
      atomic.Loadp
     </code>
     来加载
     <code>
      itab
     </code>
     ，确保线程安全。这避免了在多线程环境下可能出现的读取未初始化或部分初始化的
     <code>
      itab
     </code>
     的问题。
    </p>
    <p>
     另外，在
     <code>
      getitab
     </code>
     函数中，当
     <code>
      itab
     </code>
     不存在时，会创建一个新的
     <code>
      itab
     </code>
     ，并进行初始化，那么其中还有一个非常重要的初始化动作：
     <code>
      itabInit
     </code>
     函数，这个函数是
     <code>
      golang
     </code>
     运行时中用于初始化
     <code>
      itab
     </code>
     的方法表的关键函数。它的作用是将接口类型的方法与具体类型的方法进行匹配，并填充
     <code>
      itab
     </code>
     的
     <code>
      Fun
     </code>
     字段。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">itabInit</span><span class="token punctuation">(</span>m <span class="token operator">*</span>itab<span class="token punctuation">,</span> firstTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 接口类型</span>
	inter <span class="token operator">:=</span> m<span class="token punctuation">.</span>Inter
    <span class="token comment">// 具体类型</span>
	typ <span class="token operator">:=</span> m<span class="token punctuation">.</span>Type
    <span class="token comment">// 具体类型的 UncommonType，包含方法表信息</span>
	x <span class="token operator">:=</span> typ<span class="token punctuation">.</span><span class="token function">Uncommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// both inter and typ have method sorted by name,</span>
	<span class="token comment">// and interface names are unique,</span>
	<span class="token comment">// so can iterate over both in lock step;</span>
	<span class="token comment">// the loop is O(ni+nt) not O(ni*nt).</span>
    <span class="token comment">// 接口方法的数量</span>
	ni <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>Methods<span class="token punctuation">)</span>
    <span class="token comment">// 具体类型方法的数量</span>
	nt <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>Mcount<span class="token punctuation">)</span>
    <span class="token comment">// 具体类型的方法表</span>
	xmhdr <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>abi<span class="token punctuation">.</span>Method<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>Moff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>nt<span class="token punctuation">:</span>nt<span class="token punctuation">]</span>
	j <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token comment">// itab 的方法表，用于存储接口方法的函数指针</span>
	methods <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>Fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>ni<span class="token punctuation">:</span>ni<span class="token punctuation">]</span>
    <span class="token comment">// 第一个方法的函数指针，用于初始化 m.Fun[0]</span>
	<span class="token keyword">var</span> fun0 unsafe<span class="token punctuation">.</span>Pointer
imethods<span class="token punctuation">:</span>
    <span class="token comment">// 遍历接口的所有方法</span>
	<span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> ni<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 当前接口方法的描述</span>
		i <span class="token operator">:=</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>Methods<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
        <span class="token comment">// 当前接口方法的类型</span>
		itype <span class="token operator">:=</span> <span class="token function">toRType</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>Type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">typeOff</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>Typ<span class="token punctuation">)</span>
        <span class="token comment">// 当前接口方法的名称</span>
		name <span class="token operator">:=</span> <span class="token function">toRType</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>Type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
        <span class="token comment">// 当前接口方法的名称字符串</span>
		iname <span class="token operator">:=</span> name<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 当前接口方法的包路径</span>
		ipkg <span class="token operator">:=</span> <span class="token function">pkgPath</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
		<span class="token keyword">if</span> ipkg <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{<!-- --></span>
			ipkg <span class="token operator">=</span> inter<span class="token punctuation">.</span>PkgPath<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 遍历具体类型的所有方法，尝试找到匹配的接口方法</span>
		<span class="token keyword">for</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nt<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 当前具体类型方法的描述</span>
			t <span class="token operator">:=</span> <span class="token operator">&amp;</span>xmhdr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token comment">// 当前具体类型的类型信息</span>
			rtyp <span class="token operator">:=</span> <span class="token function">toRType</span><span class="token punctuation">(</span>typ<span class="token punctuation">)</span>
            <span class="token comment">// 当前具体类型方法的名称</span>
			tname <span class="token operator">:=</span> rtyp<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
            
            <span class="token comment">// 下面开始真正的匹配动作</span>
            <span class="token comment">// 匹配条件：1. 方法类型匹配</span>
            <span class="token comment">// 2. 方法名匹配</span>
            <span class="token comment">// 3. 包路径匹配</span>
			<span class="token keyword">if</span> rtyp<span class="token punctuation">.</span><span class="token function">typeOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Mtyp<span class="token punctuation">)</span> <span class="token operator">==</span> itype <span class="token operator">&amp;&amp;</span> tname<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> iname <span class="token punctuation">{<!-- --></span>
				pkgPath <span class="token operator">:=</span> <span class="token function">pkgPath</span><span class="token punctuation">(</span>tname<span class="token punctuation">)</span>
				<span class="token keyword">if</span> pkgPath <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{<!-- --></span>
					pkgPath <span class="token operator">=</span> rtyp<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>PkgPath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span> tname<span class="token punctuation">.</span><span class="token function">IsExported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> pkgPath <span class="token operator">==</span> ipkg <span class="token punctuation">{<!-- --></span>
					ifn <span class="token operator">:=</span> rtyp<span class="token punctuation">.</span><span class="token function">textOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>Ifn<span class="token punctuation">)</span>
                    <span class="token comment">// 如果是第一个方法，存储函数指针到 fun0</span>
					<span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
						fun0 <span class="token operator">=</span> ifn <span class="token comment">// we'll set m.Fun[0] at the end</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> firstTime <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 如果是第一次初始化，存储函数指针到 methods[k]</span>
						methods<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> ifn
					<span class="token punctuation">}</span>
					<span class="token keyword">continue</span> imethods
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// didn't find method</span>
		<span class="token comment">// Leaves m.Fun[0] set to 0.</span>
        <span class="token comment">// 如果没有找到匹配的方法，返回缺失方法的名称</span>
        <span class="token comment">// m.Fun[0] 保持为 0，其实就是表示了接口的第一个方法未被加载</span>
		<span class="token keyword">return</span> iname
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 如果是第一次初始化，设置 m.Fun[0] 为第一个方法的函数指针</span>
	<span class="token keyword">if</span> firstTime <span class="token punctuation">{<!-- --></span>
		m<span class="token punctuation">.</span>Fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>fun0<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 返回空字符串，表示初始化成功</span>
	<span class="token keyword">return</span> <span class="token string">""</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_830">
     </a>
     常见操作原理
    </h4>
    <h5>
     <a id="_832">
     </a>
     多态性
    </h5>
    <p>
     当一个变量被声明为接口类型时，
     <code>
      golang
     </code>
     运行时会动态地管理接口的调用逻辑。主要分为两阶段：
     <strong>
      接口赋值
     </strong>
     和
     <strong>
      方法调用
     </strong>
     。
    </p>
    <blockquote>
     <p>
      这里的多态性主要讨论的是非空接口。
     </p>
    </blockquote>
    <h6>
     <a id="_838">
     </a>
     接口赋值
    </h6>
    <p>
     当一个具体类型被赋值给接口变量时，
     <code>
      golang
     </code>
     运行时会执行以下操作：
    </p>
    <ul>
     <li>
      首先，检查该类型是否实现了接口。
     </li>
     <li>
      如果实现了接口，运行时会创建一个
      <code>
       itab
      </code>
      ，并将接口类型和具体类型关联起来。
     </li>
     <li>
      接口变量会存储指向
      <code>
       itab
      </code>
      的指针和具体类型的值。
     </li>
    </ul>
    <h6>
     <a id="_846">
     </a>
     方法调用
    </h6>
    <p>
     当调用接口方法时，
     <code>
      golang
     </code>
     运行时会通过以下步骤找到具体的方法实现：
    </p>
    <ul>
     <li>
      通过接口变量的
      <code>
       itab
      </code>
      指针找到对应的
      <code>
       itab
      </code>
      。
     </li>
     <li>
      在
      <code>
       itab
      </code>
      的方法表
      <code>
       Fun
      </code>
      中查找方法的函数指针。
     </li>
     <li>
      调用函数指针指向的具体方法。
     </li>
    </ul>
    <h6>
     <a id="_854">
     </a>
     代码示例
    </h6>
    <p>
     以下是一个完整的示例，展示接口多态的实现：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> Animal <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Name <span class="token builtin">string</span>
	Age  <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Name <span class="token builtin">string</span>
	Age  <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span>Name
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>Name
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> p Animal <span class="token operator">=</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">{<!-- --></span>Name<span class="token punctuation">:</span> <span class="token string">"ycz"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ycz</span>

	p <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">{<!-- --></span>Name<span class="token punctuation">:</span> <span class="token string">"ccc"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ccc</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将上述代码编译成汇编代码如下所示：
    </p>
    <pre><code class="prism language-assembly"># ...

# 分配内存
0x001a 00026      LEAQ    type:main.Person(SB), AX
0x0021 00033      PCDATA  $1, $0
0x0021 00033      CALL    runtime.newobject(SB)
0x0026 00038      MOVQ    AX, main..autotmp_5+88(SP)

# 初始化 Person 对象
0x002b 00043      MOVQ    $3, 8(AX)
0x0033 00051      CMPL    runtime.writeBarrier(SB), $0
0x003a 00058      PCDATA  $0, $-2
0x003a 00058      JEQ     64
0x003c 00060      JMP     66
0x003e 00062      NOP
0x0040 00064      JMP     79
0x0042 00066      MOVQ    (AX), CX
0x0045 00069      CALL    runtime.gcWriteBarrier1(SB)
0x004a 00074      MOVQ    CX, (R11)
0x004d 00077      JMP     79
0x004f 00079      LEAQ    go:string."ycz"(SB), CX
0x0056 00086      MOVQ    CX, (AX)

# ... 

# 接口赋值
0x0075 00117      LEAQ    go:itab.*main.Person,main.Animal(SB), CX
# 更新 itab 指针
0x007c 00124      MOVQ    CX, main.p+24(SP)
# 更新 data 指针
0x0081 00129      MOVQ    AX, main.p+32(SP)
# 调用 main.(*Person).GetName 方法
0x0086 00134      CALL    main.(*Person).GetName(SB)
0x008b 00139      MOVQ    AX, main..autotmp_2+120(SP)
0x0090 00144      MOVQ    BX, main..autotmp_2+128(SP)
0x0098 00152      MOVUPS  X15, main..autotmp_3+104(SP)
0x009e 00158      LEAQ    main..autotmp_3+104(SP), CX
0x00a3 00163      MOVQ    CX, main..autotmp_7+56(SP)
0x00a8 00168      MOVQ    main..autotmp_2+120(SP), AX
0x00ad 00173      MOVQ    main..autotmp_2+128(SP), BX
0x00b5 00181      PCDATA  $1, $1
# 将方法返回的结果转换为字符串类型
0x00b5 00181      CALL    runtime.convTstring(SB)

# ...

# 输出结果
0x0120 00288      CALL    fmt.Println(SB)

# 创建另一个对象 Cat
0x0125 00293      LEAQ    type:main.Cat(SB), AX
# 分配内存并存储对象地址
0x012c 00300      CALL    runtime.newobject(SB)
0x0131 00305      MOVQ    AX, main..autotmp_9+40(SP)
0x0136 00310      MOVQ    $3, 8(AX)
0x013e 00318      CMPL    runtime.writeBarrier(SB), $0
0x0145 00325      PCDATA  $0, $-2
0x0145 00325      JEQ     329
0x0147 00327      JMP     331
0x0149 00329      JMP     344
0x014b 00331      MOVQ    (AX), CX
0x014e 00334      CALL    runtime.gcWriteBarrier1(SB)
0x0153 00339      MOVQ    CX, (R11)
0x0156 00342      JMP     344
0x0158 00344      LEAQ    go:string."ccc"(SB), CX
0x015f 00351      MOVQ    CX, (AX)
0x0162 00354      PCDATA  $0, $-1
0x0162 00354      MOVQ    main..autotmp_9+40(SP), CX
0x0167 00359      TESTB   AL, (CX)
0x0169 00361      MOVQ    $1, 16(CX)
0x0171 00369      MOVQ    main..autotmp_9+40(SP), AX
0x0176 00374      MOVQ    AX, main..autotmp_4+96(SP)
# 将 Cat 对象赋值给接口变量
0x017b 00379      LEAQ    go:itab.*main.Cat,main.Animal(SB), CX
# 更新 itab 指针
0x0182 00386      MOVQ    CX, main.p+24(SP)
# 更新 data 指针
0x0187 00391      MOVQ    AX, main.p+32(SP)
# 调用 main.(*Cat).GetName 方法
0x018c 00396      CALL    main.(*Cat).GetName(SB)

# ...

# 将方法返回的结果转换为字符串类型
0x01c0 00448      CALL    runtime.convTstring(SB)

# ...

# 输出结果
0x023a 00570      CALL    fmt.Println(SB)

# 函数结束，返回
0x023f 00575      ADDQ    $184, SP
0x0246 00582      POPQ    BP
0x0247 00583      RET

# ...
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     从以上汇编代码就可以看出，当接口变量的类型切换时会更新
     <code>
      itab
     </code>
     指针和
     <code>
      data
     </code>
     指针，后续调用方法时，直接根据
     <code>
      itab
     </code>
     指针找到对应方法表，再从方法表中根据函数的次序定位到具体的函数（得到函数指针），再根据函数指针执行具体的方法。这种机制使得接口变量可以在运行时动态地切换类型，同时保持高效的性能和灵活的多态性。
    </p>
    <h5>
     <a id="_999">
     </a>
     类型断言
    </h5>
    <p>
     下面给出一个使用接口进行类型断言的例子，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> v <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> i<span class="token punctuation">,</span> ok <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span>
		<span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 10</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将上面的代码编译成汇编代码，如下所示：
    </p>
    <pre><code class="prism language-assembly"># ...
# 调用 someFunction 函数并赋值给 v
# AX 寄存器存储接口的类型信息
# BX 寄存器存储接口的数据指针
0x0012 00018       CALL    main.someFunction(SB)
0x0017 00023       MOVQ    AX, main.v+40(SP)
0x001c 00028       MOVQ    BX, main.v+48(SP)

# 类型断言的运行时检查
# 将 int 类型的地址加载到寄存器 CX
0x0021 00033       LEAQ    type:int(SB), CX
# 比较 v 的类型信息与目标类型 int 的类型信息
0x0028 00040       CMPQ    AX, CX
# 如果类型匹配跳转到成功分支地址 47
0x002b 00043       JEQ     47
# 如果类型不匹配跳转到失败分支地址 57
0x002d 00045       JMP     57

# 类型断言成功分支
# 将 v 的数据指针（存储10）指向的实际值加载到寄存器 AX
0x002f 00047       MOVQ    (BX), AX
# 将 1 赋值给寄存器 CX，表示 ok 为 true
0x0032 00050       MOVL    $1, CX
# 跳转到后续的赋值逻辑
0x0037 00055       JMP     63

# 类型断言失败分支
# 将寄存器 AX 和 CX 清零
# AX 表示 i 的值，清零表示 i 为 0
# CX 表示 ok 的值，清零表示 ok 为 false
0x0039 00057       XORL    AX, AX
0x003b 00059       XORL    CX, CX
# 跳转到后续的赋值逻辑
0x003d 00061       JMP     63

# 将寄存器中的值赋值给栈上的临时变量，最终赋值给 i 和 ok
# ...
# i 的值
0x0060 00096       MOVQ    AX, main.i+16(SP)
# ...
# ok 的值
0x006a 00106       MOVB    AL, main.ok+13(SP)

# 测试 ok 的值
0x006e 00110       TESTB   AL, AL
# 如果 ok 为 true，跳转到打印逻辑
0x0070 00112       JNE     116
# 如果 ok 为 false，跳过打印逻辑，直接结束函数
0x0072 00114       JMP     140

# 打印逻辑
# 如果类型断言成功，则调用 runtime.printint 打印 i 的值
0x0074 00116       CALL    runtime.printlock(SB)
0x0079 00121       MOVQ    main.i+16(SP), AX
0x007e 00126       NOP
0x0080 00128       CALL    runtime.printint(SB)
0x0085 00133       CALL    runtime.printunlock(SB)

# 结束函数
# ...
0x008c 00140       JMP     142
0x008e 00142       ADDQ    $56, SP
0x0092 00146       POPQ    BP
0x0093 00147       RET
# ...
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     仔细观察生成的汇编代码之后，不难发现问题所在：汇编代码中并没有调用
     <code>
      getitab
     </code>
     函数从全局
     <code>
      itab
     </code>
     表中进行获取
     <code>
      itab
     </code>
     进行接口判断。
     <strong>
      但是，实际上
      <code>
       golang
      </code>
      编译器在处理类型断言时，对于一些简单的情况，编译器可能会直接内联相关逻辑，生成断言类型目标的代码，从而直接判断是否与断言目标类型是否匹配，而不是调用
      <code>
       getitab
      </code>
      函数。这样会减少运行时额外的开销
     </strong>
     。
    </p>
    <p>
     如果将以上简单类型断言代码改为采用接口断言，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> Animal <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
	<span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
	<span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">SetAge</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Name <span class="token builtin">string</span>
	Age  <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span>Name
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span>Age
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span>Name <span class="token operator">=</span> name
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetAge</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span>Age <span class="token operator">=</span> age
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> p Animal <span class="token operator">=</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">{<!-- --></span>Name<span class="token punctuation">:</span> <span class="token string">"ycz"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
	<span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将以上代码编译成汇编代码，如下所示：
    </p>
    <pre><code class="prism language-assembly"># ...

# 创建 Person 对象
0x001a 00026      LEAQ    type:main.Person(SB), AX
# ...
0x0021 00033      CALL    runtime.newobject(SB)
0x0026 00038      MOVQ    AX, main..autotmp_9+80(SP)
0x002b 00043      MOVQ    $3, 8(AX)

# ...

# 初始化 Person 对象的字段
0x004f 00079      LEAQ    go:string."ycz"(SB), DX
0x0056 00086      MOVQ    DX, (AX)
0x0059 00089      PCDATA  $0, $-1
0x0059 00089      MOVQ    main..autotmp_9+80(SP), DX
0x005e 00094      TESTB   AL, (DX)
0x0060 00096      MOVQ    $18, 16(DX)

# 将 Person 对象赋值给接口变量 p
0x0068 00104      MOVQ    main..autotmp_9+80(SP), DX
0x006d 00109      MOVQ    DX, main..autotmp_5+120(SP)
# 加载 Person 类型和 Animal 接口的 itab 地址到寄存器 R8
0x0072 00114      LEAQ    go:itab.*main.Person,main.Animal(SB), R8
0x0079 00121      MOVQ    R8, main.p+64(SP)
0x007e 00126      MOVQ    DX, main.p+72(SP)


# 类型断言逻辑
0x0083 00131      MOVUPS  X15, main..autotmp_6+104(SP)
0x0089 00137      MOVQ    main.p+64(SP), DX
0x008e 00142      MOVQ    main.p+72(SP), R8
# 检查类型信息是否为零
0x0093 00147      TESTQ   DX, DX
# 如果类型信息不为零，跳转到地址 154
0x0096 00150      JNE     154
# 如果类型信息为零，跳转到地址 192
0x0098 00152      JMP     192

# 调用 runtime.typeAssert 进行类型断言
0x009a 00154      MOVQ    R8, main..autotmp_14+144(SP)
0x00a2 00162      MOVQ    8(DX), BX
0x00a6 00166      LEAQ    main..typeAssert.0(SB), AX
0x00ad 00173      PCDATA  $1, $1
0x00ad 00173      CALL    runtime.typeAssert(SB)
0x00b2 00178      MOVQ    main..autotmp_14+144(SP), R8
0x00ba 00186      MOVQ    AX, DX
0x00bd 00189      JMP     194
0x00bf 00191      NOP

# 类型断言结果处理
# ... 

# 函数结束，返回
0x0209 00521      ADDQ    $208, SP
0x0210 00528      POPQ    BP
0x0211 00529      RET
# ...
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     汇编代码中最为关键的一步就是运行时调用了
     <code>
      typeAssert
     </code>
     进行类型断言，那么下面继续跟踪源码。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// typeAssert builds an itab for the concrete type t and the</span>
<span class="token comment">// interface type s.Inter. If the conversion is not possible it</span>
<span class="token comment">// panics if s.CanFail is false and returns nil if s.CanFail is true.</span>
<span class="token keyword">func</span> <span class="token function">typeAssert</span><span class="token punctuation">(</span>s <span class="token operator">*</span>abi<span class="token punctuation">.</span>TypeAssert<span class="token punctuation">,</span> t <span class="token operator">*</span>_type<span class="token punctuation">)</span> <span class="token operator">*</span>itab <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> tab <span class="token operator">*</span>itab
    <span class="token comment">// 如果具体类型 t 为 nil，并且 s.CanFail 为 false，则抛出类型断言错误</span>
	<span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token operator">!</span>s<span class="token punctuation">.</span>CanFail <span class="token punctuation">{<!-- --></span>
			<span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{<!-- --></span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Inter<span class="token punctuation">.</span>Type<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 具体类型 t 不为 nil，则调用 getitab 函数，尝试获取或生成一个 itab</span>
		tab <span class="token operator">=</span> <span class="token function">getitab</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>Inter<span class="token punctuation">,</span> t<span class="token punctuation">,</span> s<span class="token punctuation">.</span>CanFail<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 如果当前架构不支持接口切换缓存，则直接返回 itab</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>abi<span class="token punctuation">.</span><span class="token function">UseInterfaceSwitchCache</span><span class="token punctuation">(</span>GOARCH<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> tab
	<span class="token punctuation">}</span>

	<span class="token comment">// Maybe update the cache, so the next time the generated code</span>
	<span class="token comment">// doesn't need to call into the runtime.</span>
    <span class="token comment">// 使用 cheaprand 生成一个随机数，只有当随机数满足条件时，才尝试更新缓存</span>
    <span class="token comment">// 这是为了减少更新缓存的频率，避免频繁更新带来的性能开销</span>
	<span class="token keyword">if</span> <span class="token function">cheaprand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1023</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Only bother updating the cache ~1 in 1000 times.</span>
		<span class="token keyword">return</span> tab
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 下面是更新缓存的逻辑</span>
    
	<span class="token comment">// Load the current cache.</span>
	oldC <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>abi<span class="token punctuation">.</span>TypeAssertCache<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loadp</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token function">cheaprand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token function">uint32</span><span class="token punctuation">(</span>oldC<span class="token punctuation">.</span>Mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// As cache gets larger, choose to update it less often</span>
		<span class="token comment">// so we can amortize the cost of building a new cache.</span>
		<span class="token keyword">return</span> tab
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 当代码运行到这一步的时候，就需要构建一个新的接口切换缓存实例</span>

	<span class="token comment">// Make a new cache.</span>
    <span class="token comment">// 调用 buildTypeAssertCache 函数，根据当前缓存 oldC、具体类型 t 和 itab 构建一个新的缓存</span>
	newC <span class="token operator">:=</span> <span class="token function">buildTypeAssertCache</span><span class="token punctuation">(</span>oldC<span class="token punctuation">,</span> t<span class="token punctuation">,</span> tab<span class="token punctuation">)</span>

	<span class="token comment">// Update cache. Use compare-and-swap so if multiple threads</span>
	<span class="token comment">// are fighting to update the cache, at least one of their</span>
	<span class="token comment">// updates will stick.</span>
    <span class="token comment">// 使用原子操作更新缓存</span>
	<span class="token function">atomic_casPointer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>oldC<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newC<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> tab
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      TypeAssertCache
     </code>
     用于优化类型断言的性能。缓存具体类型和对应的
     <code>
      itab
     </code>
     ，以便快速判断一个接口变量是否可以断言为某个具体类型。下面介绍三个核心的缓存结构体：
     <code>
      TypeAssert
     </code>
     、
     <code>
      TypeAssertCache
     </code>
     、
     <code>
      TypeAssertCacheEntry
     </code>
     。
    </p>
    <h6>
     <a id="TypeAssert_1265">
     </a>
     <code>
      TypeAssert
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/internal/abi/switch.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> TypeAssert <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Cache   <span class="token operator">*</span>TypeAssertCache
	Inter   <span class="token operator">*</span>InterfaceType
	CanFail <span class="token builtin">bool</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Cache
      </code>
      ：指向
      <code>
       TypeAssertCache
      </code>
      ，这是一个缓存结构，用于存储类型断言的结果。缓存的目的是减少运行时的重复计算，提高类型断言的性能。
     </li>
     <li>
      <code>
       Inter
      </code>
      ：指向
      <code>
       InterfaceType
      </code>
      ，表示目标接口类型。这个字段用于记录类型断言的目标接口类型，以便在需要时进行类型检查。
     </li>
     <li>
      <code>
       CanFail
      </code>
      ：布尔值，表示类型断言是否允许失败。如果
      <code>
       CanFail
      </code>
      为
      <code>
       true
      </code>
      ，类型断言失败时会返回
      <code>
       nil
      </code>
      ；如果
      <code>
       CanFail
      </code>
      为
      <code>
       false
      </code>
      ，类型断言失败时会抛出错误。
     </li>
    </ul>
    <h6>
     <a id="TypeAssertCache_1281">
     </a>
     <code>
      TypeAssertCache
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/internal/abi/switch.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> TypeAssertCache <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Mask    <span class="token builtin">uintptr</span>
	Entries <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>TypeAssertCacheEntry
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Mask
      </code>
      ：用于计算缓存的大小和索引。缓存的大小始终是 2 的幂，
      <code>
       Mask
      </code>
      的值为
      <code>
       size - 1
      </code>
      ，用于快速计算索引。
     </li>
     <li>
      <code>
       Entries
      </code>
      ：缓存条目数组，初始大小为 1。每个条目是一个
      <code>
       TypeAssertCacheEntry
      </code>
      ，存储了具体类型和对应的
      <code>
       itab
      </code>
      。
     </li>
    </ul>
    <h6>
     <a id="TypeAssertCacheEntry_1295">
     </a>
     <code>
      TypeAssertCacheEntry
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/internal/abi/switch.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> TypeAssertCacheEntry <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// type of source value (a *runtime._type)</span>
	Typ <span class="token builtin">uintptr</span>
	<span class="token comment">// itab to use for result (a *runtime.itab)</span>
	<span class="token comment">// nil if CanFail is set and conversion would fail.</span>
	Itab <span class="token builtin">uintptr</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Typ
      </code>
      ：具体类型的指针。用于记录具体类型的信息，以便在类型断言时进行比较。
     </li>
     <li>
      <code>
       Itab
      </code>
      ：
      <code>
       itab
      </code>
      的指针。如果
      <code>
       CanFail
      </code>
      为
      <code>
       true
      </code>
      且类型转换失败，则为
      <code>
       nil
      </code>
      。用于记录具体类型和接口类型的映射关系，以便在类型断言时快速查找。
     </li>
    </ul>
    <h6>
     <a id="buildTypeAssertCache_1312">
     </a>
     <code>
      buildTypeAssertCache
     </code>
    </h6>
    <p>
     构建类型断言缓存，源码如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">buildTypeAssertCache</span><span class="token punctuation">(</span>oldC <span class="token operator">*</span>abi<span class="token punctuation">.</span>TypeAssertCache<span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> tab <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token operator">*</span>abi<span class="token punctuation">.</span>TypeAssertCache <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 将旧缓存的条目转换为一个切片，包含所有旧的缓存条目</span>
	oldEntries <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>oldC<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> oldC<span class="token punctuation">.</span>Mask<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token comment">// Count the number of entries we need.</span>
    <span class="token comment">// 计算旧缓存中非空条目的数量，加上一个额外的条目用于终止</span>
	n <span class="token operator">:=</span> <span class="token number">1</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> oldEntries <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> e<span class="token punctuation">.</span>Typ <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">++</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Figure out how big a table we need.</span>
	<span class="token comment">// We need at least one more slot than the number of entries</span>
	<span class="token comment">// so that we are guaranteed an empty slot (for termination).</span>
    <span class="token comment">// 新缓存的大小，通常是旧缓存大小的两倍，确保新缓存的负载因子不超过 50%</span>
	newN <span class="token operator">:=</span> n <span class="token operator">*</span> <span class="token number">2</span>                         <span class="token comment">// make it at most 50% full</span>
    <span class="token comment">// 计算 newN-1 的二进制表示中的位数，确保新缓存大小是 2 的幂</span>
	newN <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> sys<span class="token punctuation">.</span><span class="token function">Len64</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span>newN<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// round up to a power of 2</span>

	<span class="token comment">// Allocate the new table.</span>
    <span class="token comment">// 计算新缓存的总大小，包括 TypeAssertCache 结构体和所有条目的大小</span>
	newSize <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>abi<span class="token punctuation">.</span>TypeAssertCache<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newN<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>abi<span class="token punctuation">.</span>TypeAssertCacheEntry<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 分配内存</span>
	newC <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>abi<span class="token punctuation">.</span>TypeAssertCache<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span>newSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置新缓存的掩码，用于计算哈希值</span>
	newC<span class="token punctuation">.</span>Mask <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// 将新缓存的条目转换为一个切片</span>
	newEntries <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newC<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newN<span class="token punctuation">)</span>

	<span class="token comment">// Fill the new table.</span>
    <span class="token comment">// 将新的缓存条目添加到新缓存中</span>
	addEntry <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> tab <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		h <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Typ <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
				newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Typ <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>typ<span class="token punctuation">)</span><span class="token punctuation">)</span>
				newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Itab <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
			h <span class="token operator">=</span> <span class="token punctuation">(</span>h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 遍历旧缓存的条目，将非空条目复制到新缓存中</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> oldEntries <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> e<span class="token punctuation">.</span>Typ <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>_type<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Typ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Itab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 调用上面的 addEntry 函数，将新的缓存条目添加到新缓存中</span>
	<span class="token function">addEntry</span><span class="token punctuation">(</span>typ<span class="token punctuation">,</span> tab<span class="token punctuation">)</span>
	
    <span class="token comment">// 返回新的缓存示例</span>
	<span class="token keyword">return</span> newC
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_1377">
     </a>
     类型切换
    </h5>
    <p>
     基于类型切换小结中的代码，再给出一段接口类型切换的代码，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> Animal <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
	<span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
	<span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
	<span class="token function">SetAge</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Name <span class="token builtin">string</span>
	Age  <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span>Name
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span>Age
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span>Name <span class="token operator">=</span> name
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetAge</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span>Age <span class="token operator">=</span> age
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> p Animal <span class="token operator">=</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">{<!-- --></span>Name<span class="token punctuation">:</span> <span class="token string">"ycz"</span><span class="token punctuation">,</span> Age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
	<span class="token keyword">switch</span> p <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> Animal<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将以上代码编译成汇编代码，如下所示：
    </p>
    <pre><code class="prism language-assembly"># ...

# 创建 Person 对象
0x001a 00026      LEAQ    type:main.Person(SB), AX
# ...
0x0021 00033      CALL    runtime.newobject(SB)
0x0026 00038      MOVQ    AX, main..autotmp_5+136(SP)
0x002e 00046      MOVQ    $3, 8(AX)

# ...

# 初始化 Person 对象的字段
0x0051 00081      LEAQ    go:string."ycz"(SB), CX
0x0058 00088      MOVQ    CX, (AX)
0x005b 00091      PCDATA  $0, $-1
0x005b 00091      MOVQ    main..autotmp_5+136(SP), CX
0x0063 00099      TESTB   AL, (CX)
0x0065 00101      MOVQ    $18, 16(CX)
0x006d 00109      MOVQ    main..autotmp_5+136(SP), CX
0x0075 00117      MOVQ    CX, main..autotmp_3+160(SP)
# 加载 Person 类型和 Animal 接口的 itab 地址到寄存器 DX
0x007d 00125      LEAQ    go:itab.*main.Person,main.Animal(SB), DX
0x0084 00132      MOVQ    DX, main.p+96(SP)
0x0089 00137      MOVQ    CX, main.p+104(SP)

# ...

# 类型断言逻辑
# 加载 Person 类型和 Animal 接口的 itab 地址到寄存器 CX
0x009d 00157      MOVL    go:itab.*main.Person,main.Animal+16(SB), CX
0x00a3 00163      MOVL    CX, main..autotmp_9+44(SP)
0x00a7 00167      MOVQ    main..autotmp_6+120(SP), CX
0x00ac 00172      MOVQ    8(CX), BX
# 加载类型断言的错误信息地址到寄存器 AX
0x00b0 00176      LEAQ    main..interfaceSwitch.0(SB), AX
0x00b7 00183      PCDATA  $1, $1
# 调用运行时的 interfaceSwitch 函数，进行接口切换
0x00b7 00183      CALL    runtime.interfaceSwitch(SB)
0x00bc 00188      MOVQ    AX, main..autotmp_10+56(SP)
0x00c1 00193      MOVQ    BX, main..autotmp_8+112(SP)

# 类型断言结果处理
# ...

# 函数结束，返回
0x023e 00574      ADDQ    $232, SP
0x0245 00581      POPQ    BP
0x0246 00582      RET
# ...
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     汇编代码中最为关键的一步就是运行时调用了
     <code>
      interfaceSwitch
     </code>
     进行接口类型切换，那么下面继续跟踪源码。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// interfaceSwitch compares t against the list of cases in s.</span>
<span class="token comment">// If t matches case i, interfaceSwitch returns the case index i and</span>
<span class="token comment">// an itab for the pair &lt;t, s.Cases[i]&gt;.</span>
<span class="token comment">// If there is no match, return N,nil, where N is the number</span>
<span class="token comment">// of cases.</span>
<span class="token keyword">func</span> <span class="token function">interfaceSwitch</span><span class="token punctuation">(</span>s <span class="token operator">*</span>abi<span class="token punctuation">.</span>InterfaceSwitch<span class="token punctuation">,</span> t <span class="token operator">*</span>_type<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 将 s.Cases 转换为一个切片，包含所有分支的接口类型</span>
	cases <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Cases<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>NCases<span class="token punctuation">)</span>

	<span class="token comment">// Results if we don't find a match.</span>
    <span class="token comment">// 如果没有找到匹配项，返回的分支索引</span>
	case_ <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span>
	<span class="token keyword">var</span> tab <span class="token operator">*</span>itab

	<span class="token comment">// Look through each case in order.</span>
    <span class="token comment">// 遍历所有分支，调用 getitab 检查具体类型 t 是否匹配当前分支的接口类型 c</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> cases <span class="token punctuation">{<!-- --></span>
		tab <span class="token operator">=</span> <span class="token function">getitab</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果找到匹配项，更新 case_ 和 tab，并退出循环</span>
		<span class="token keyword">if</span> tab <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			case_ <span class="token operator">=</span> i
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果不支持接口切换缓存，则直接返回结果</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>abi<span class="token punctuation">.</span><span class="token function">UseInterfaceSwitchCache</span><span class="token punctuation">(</span>GOARCH<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> case_<span class="token punctuation">,</span> tab
	<span class="token punctuation">}</span>

	<span class="token comment">// Maybe update the cache, so the next time the generated code</span>
	<span class="token comment">// doesn't need to call into the runtime.</span>
    <span class="token comment">// 使用 cheaprand() 生成一个随机数，只有当随机数满足条件时，才尝试更新缓存</span>
    <span class="token comment">// 避免频繁更新带来的性能开销</span>
	<span class="token keyword">if</span> <span class="token function">cheaprand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1023</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Only bother updating the cache ~1 in 1000 times.</span>
		<span class="token comment">// This ensures we don't waste memory on switches, or</span>
		<span class="token comment">// switch arguments, that only happen a few times.</span>
		<span class="token keyword">return</span> case_<span class="token punctuation">,</span> tab
	<span class="token punctuation">}</span>
    <span class="token comment">// 使用原子操作加载当前的接口切换缓存 s.Cache</span>
	<span class="token comment">// Load the current cache.</span>
	oldC <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>abi<span class="token punctuation">.</span>InterfaceSwitchCache<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loadp</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token function">cheaprand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token function">uint32</span><span class="token punctuation">(</span>oldC<span class="token punctuation">.</span>Mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// As cache gets larger, choose to update it less often</span>
		<span class="token comment">// so we can amortize the cost of building a new cache</span>
		<span class="token comment">// (that cost is linear in oldc.Mask).</span>
		<span class="token keyword">return</span> case_<span class="token punctuation">,</span> tab
	<span class="token punctuation">}</span>

   	<span class="token comment">// 调用 buildInterfaceSwitchCache 函数，根据当前缓存 oldC、具体类型 t、匹配的分支索引 case_ 和 itab 构建一个新的缓存</span>
	<span class="token comment">// Make a new cache.</span>
	newC <span class="token operator">:=</span> <span class="token function">buildInterfaceSwitchCache</span><span class="token punctuation">(</span>oldC<span class="token punctuation">,</span> t<span class="token punctuation">,</span> case_<span class="token punctuation">,</span> tab<span class="token punctuation">)</span>

	<span class="token comment">// Update cache. Use compare-and-swap so if multiple threads</span>
	<span class="token comment">// are fighting to update the cache, at least one of their</span>
	<span class="token comment">// updates will stick.</span>
    <span class="token comment">// 使用原子操作更新缓存</span>
	<span class="token function">atomic_casPointer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>oldC<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newC<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> case_<span class="token punctuation">,</span> tab
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      interfaceSwitch
     </code>
     同样做了缓存优化，类似于
     <code>
      TypeAssert
     </code>
     也有三个重要的结构体：
     <code>
      InterfaceSwitch
     </code>
     、
     <code>
      InterfaceSwitchCache
     </code>
     、
     <code>
      InterfaceSwitchCacheEntry
     </code>
     。
    </p>
    <h6>
     <a id="InterfaceSwitch_1555">
     </a>
     <code>
      InterfaceSwitch
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/internal/abi/switch.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> InterfaceSwitch <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Cache  <span class="token operator">*</span>InterfaceSwitchCache
	NCases <span class="token builtin">int</span>

	<span class="token comment">// Array of NCases elements.</span>
	<span class="token comment">// Each case must be a non-empty interface type.</span>
	Cases <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>InterfaceType
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Cache
      </code>
      ：指向
      <code>
       InterfaceSwitchCache
      </code>
      ，用于缓存接口切换的结果。
     </li>
     <li>
      <code>
       NCases
      </code>
      ：分支的数量。
     </li>
     <li>
      <code>
       Cases
      </code>
      ：接口类型数组，存储所有可能的分支。
     </li>
    </ul>
    <h6>
     <a id="InterfaceSwitchCache_1574">
     </a>
     <code>
      InterfaceSwitchCache
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/internal/abi/switch.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> InterfaceSwitchCache <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Mask    <span class="token builtin">uintptr</span>                      <span class="token comment">// mask for index. Must be a power of 2 minus 1</span>
	Entries <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>InterfaceSwitchCacheEntry <span class="token comment">// Mask+1 entries total</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Mask
      </code>
      ：掩码，用于计算缓存索引。
     </li>
     <li>
      <code>
       Entries
      </code>
      ：缓存条目数组，存储具体类型和对应的分支索引。
     </li>
    </ul>
    <h6>
     <a id="InterfaceSwitchCacheEntry_1588">
     </a>
     <code>
      InterfaceSwitchCacheEntry
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/internal/abi/switch.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> InterfaceSwitchCacheEntry <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// type of source value (a *Type)</span>
	Typ <span class="token builtin">uintptr</span>
	<span class="token comment">// case # to dispatch to</span>
	Case <span class="token builtin">int</span>
	<span class="token comment">// itab to use for resulting case variable (a *runtime.itab)</span>
	Itab <span class="token builtin">uintptr</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       Typ
      </code>
      ：具体类型的指针。用于记录具体类型的信息，以便在接口切换时进行类型匹配。
     </li>
     <li>
      <code>
       Case
      </code>
      ：匹配的分支索引。表示在接口切换中，具体类型匹配的分支编号。
     </li>
     <li>
      <code>
       Itab
      </code>
      ：
      <code>
       itab
      </code>
      的指针。用于记录具体类型和接口类型的映射关系，以便在接口切换时快速查找和使用。
     </li>
    </ul>
    <h6>
     <a id="buildInterfaceSwitchCache_1607">
     </a>
     <code>
      buildInterfaceSwitchCache
     </code>
    </h6>
    <p>
     构建类型切换缓存，源码如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/iface.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// buildInterfaceSwitchCache constructs an interface switch cache</span>
<span class="token comment">// containing all the entries from oldC plus the new entry</span>
<span class="token comment">// (typ,case_,tab).</span>
<span class="token keyword">func</span> <span class="token function">buildInterfaceSwitchCache</span><span class="token punctuation">(</span>oldC <span class="token operator">*</span>abi<span class="token punctuation">.</span>InterfaceSwitchCache<span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> case_ <span class="token builtin">int</span><span class="token punctuation">,</span> tab <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token operator">*</span>abi<span class="token punctuation">.</span>InterfaceSwitchCache <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 将旧缓存的条目转换为一个切片，包含所有旧的缓存条目</span>
	oldEntries <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>oldC<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> oldC<span class="token punctuation">.</span>Mask<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token comment">// Count the number of entries we need.</span>
	n <span class="token operator">:=</span> <span class="token number">1</span>
    <span class="token comment">// 遍历旧缓存条目，统计非空条目数量</span>
    <span class="token comment">// 新缓存需要包含旧缓存的所有条目，再加上一个新条目</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> oldEntries <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> e<span class="token punctuation">.</span>Typ <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">++</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Figure out how big a table we need.</span>
	<span class="token comment">// We need at least one more slot than the number of entries</span>
	<span class="token comment">// so that we are guaranteed an empty slot (for termination).</span>
    <span class="token comment">// 新缓存的大小至少是条目数量的两倍，保证哈希表的负载率不超过 50%</span>
    <span class="token comment">// 确保哈希表大小是 2 的整数次幂</span>
	newN <span class="token operator">:=</span> n <span class="token operator">*</span> <span class="token number">2</span>                         <span class="token comment">// make it at most 50% full</span>
	newN <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> sys<span class="token punctuation">.</span><span class="token function">Len64</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span>newN<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// round up to a power of 2</span>

	<span class="token comment">// Allocate the new table.</span>
    <span class="token comment">// 计算新缓存的总大小，包括 InterfaceSwitchCache 结构体和条目数组</span>
	newSize <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>abi<span class="token punctuation">.</span>InterfaceSwitchCache<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newN<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>abi<span class="token punctuation">.</span>InterfaceSwitchCacheEntry<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 分配内存</span>
	newC <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>abi<span class="token punctuation">.</span>InterfaceSwitchCache<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span>newSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 初始化新缓存的掩码</span>
	newC<span class="token punctuation">.</span>Mask <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// 初始化条目数组</span>
	newEntries <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newC<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newN<span class="token punctuation">)</span>

	<span class="token comment">// Fill the new table.</span>
    <span class="token comment">// 将新的缓存条目添加到新缓存中</span>
	addEntry <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> case_ <span class="token builtin">int</span><span class="token punctuation">,</span> tab <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		h <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Typ <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
				newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Typ <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>typ<span class="token punctuation">)</span><span class="token punctuation">)</span>
				newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Case <span class="token operator">=</span> case_
				newEntries<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">.</span>Itab <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
			h <span class="token operator">=</span> <span class="token punctuation">(</span>h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 遍历旧缓存的所有条目，将非空条目复制到新缓存</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> oldEntries <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> e<span class="token punctuation">.</span>Typ <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>_type<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Typ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>Case<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Itab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 调用上面的 addEntry 函数，最后插入新条目</span>
	<span class="token function">addEntry</span><span class="token punctuation">(</span>typ<span class="token punctuation">,</span> case_<span class="token punctuation">,</span> tab<span class="token punctuation">)</span>
	
    <span class="token comment">// 返回构建好的新缓存</span>
	<span class="token keyword">return</span> newC
<span class="token punctuation">}</span>
</code></pre>
    <p>
     🌺🌺🌺撒花！
    </p>
    <p>
     如果本文对你有帮助，就点关注或者留个👍
     <br/>
     如果您有任何技术问题或者需要更多其他的内容，请随时向我提问。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3734a0d4d24847a6ad83ea7ad3b1a2c6.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34363238373931382f:61727469636c652f64657461696c732f313436313631393136" class_="artid" style="display:none">
 </p>
</div>


