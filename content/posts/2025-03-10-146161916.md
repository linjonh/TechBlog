---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34363238373931382f:61727469636c652f64657461696c732f313436313631393136"
layout: post
title: "åå››Golang-æ¥å£"
date: 2025-03-10 20:36:11 +0800
description: "æ¥å£æ˜¯ä¸€ç§æŠ½è±¡çš„æ•°æ®ç±»å‹ï¼Œå®ƒå®šä¹‰äº†ä¸€ç»„æ–¹æ³•æˆ–è¡Œä¸ºçš„è§„èŒƒï¼Œä½†ä¸æä¾›å…·ä½“å®ç°"
keywords: "ã€åå››ã€‘Golang æ¥å£"
categories: ['Golang']
tags: ['å¼€å‘è¯­è¨€', 'åç«¯', 'Golang']
artid: "146161916"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146161916
    alt: "åå››Golang-æ¥å£"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146161916
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146161916
cover: https://bing.ee123.net/img/rand?artid=146161916
image: https://bing.ee123.net/img/rand?artid=146161916
img: https://bing.ee123.net/img/rand?artid=146161916
---

# ã€åå››ã€‘Golang æ¥å£

> ğŸ’¢æ¬¢è¿æ¥åˆ°å¼ èƒ¤å°˜çš„å¼€æºæŠ€æœ¯ç«™
>   
> ğŸ’¥å¼€æºå¦‚æ±Ÿæ²³ï¼Œæ±‡èšä¼—å¿—æˆã€‚ä»£ç ä¼¼æ˜Ÿè¾°ï¼Œç…§äº®è¡Œå¾ç¨‹ã€‚å¼€æºç²¾ç¥é•¿ï¼Œä¼ æ‰¿æ°¸ä¸å¿˜ã€‚æºæ‰‹å…±å‰è¡Œï¼Œæœªæ¥æ›´è¾‰ç…ŒğŸ’¥

## æ¥å£

**æ¥å£æ˜¯ä¸€ç§æŠ½è±¡çš„æ•°æ®ç±»å‹ï¼Œå®ƒå®šä¹‰äº†ä¸€ç»„æ–¹æ³•æˆ–è¡Œä¸ºçš„è§„èŒƒï¼Œä½†ä¸æä¾›å…·ä½“å®ç°**
ã€‚åœ¨
`golang`
ä¸­æ¥å£çš„æ ¸å¿ƒä½œç”¨æ˜¯ï¼š
**è§£è€¦åˆ**
å’Œ
**å¤šæ€**
ã€‚

* **è§£è€¦åˆ**
  ï¼šå‡å°‘æ¨¡å—ä¹‹é—´çš„ç›´æ¥ä¾èµ–å…³ç³»ï¼Œä½¿å¾—æ¨¡å—ä¹‹é—´çš„ä¿®æ”¹ä¸ä¼šç›¸äº’å½±å“ã€‚å¦å¤–ï¼Œé€šè¿‡æ¥å£è°ƒç”¨è€…åªéœ€è¦çŸ¥é“æ¥å£çš„è§„èŒƒï¼Œè€Œä¸éœ€è¦å…³å¿ƒå…·ä½“çš„å®ç°ç»†èŠ‚ã€‚å®ç°è€…å¯ä»¥éšæ—¶æ›¿æ¢ï¼Œåªè¦æ»¡è¶³æ¥å£è§„èŒƒå³å¯ã€‚
* **å¤šæ€**
  ï¼šå¤šæ€æ˜¯æŒ‡åŒä¸€ä¸ªæ¥å£å¯ä»¥è¢«ä¸åŒçš„å®ç°ç±»ä½¿ç”¨ï¼Œè°ƒç”¨è€…åœ¨è¿è¡Œæ—¶å¯ä»¥æ ¹æ®å…·ä½“å®ç°è°ƒç”¨ç›¸åº”çš„æ–¹æ³•ã€‚æ¥å£å…è®¸ä¸åŒçš„å®ç°ç±»æä¾›ä¸åŒçš„è¡Œä¸ºï¼Œä½†è°ƒç”¨è€…å¯ä»¥é€šè¿‡ç»Ÿä¸€çš„æ¥å£è¿›è¡Œæ“ä½œã€‚

### æ¥å£å®šä¹‰

åœ¨
`golang`
ä¸­ï¼Œæ¥å£é€šè¿‡
`type`
å…³é”®å­—å’Œ
`interface`
å…³é”®å­—å®šä¹‰ã€‚è¯­æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type InterfaceName interface {
    Method1(paramType1) returnType1
    Method2(paramType2) returnType2
    ...
}

```

ä¾‹å¦‚ï¼š

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}

```

åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œ
`Shape`
æ˜¯ä¸€ä¸ªæ¥å£ï¼Œå®ƒå®šä¹‰äº†ä¸¤ä¸ªæ–¹æ³•ï¼š
`Area()`
å’Œ
`Perimeter()`
ã€‚
**åªè¦æ˜¯ä»»ä½•å®ç°äº†è¿™ä¸¤ä¸ªæ–¹æ³•çš„ç±»å‹éƒ½è‡ªåŠ¨å®ç°äº†
`Shape`
æ¥å£**
ã€‚

ä¸‹é¢æœ‰ä¸€ä¸ª
`Circle`
ç±»ï¼Œå®ç°äº†
`Area()`
å’Œ
`Perimeter()`
ä¸¤ä¸ªæ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

```

ä»ä»£ç ä¸­å¯çŸ¥
`Circle`
ç±»å‹å®ç°äº†
`Shape`
æ¥å£ä¸­çš„
`Area()`
å’Œ
`Perimeter()`
æ–¹æ³•ï¼Œå®ƒè‡ªåŠ¨æ»¡è¶³äº†
`Shape`
æ¥å£çš„è¦æ±‚ã€‚

### æ¥å£åˆå§‹åŒ–

æ¥å£çš„åˆå§‹åŒ–å¹¶ä¸æ˜¯ç›´æ¥åˆå§‹åŒ–æ¥å£æœ¬èº«ï¼Œè€Œæ˜¯é€šè¿‡åˆå§‹åŒ–å®ç°äº†æ¥å£çš„ç±»å‹æ¥é—´æ¥å®Œæˆçš„ã€‚
**å¦‚æœæ¥å£åˆå§‹åŒ–æ—¶å¹¶æ²¡æœ‰æŒ‡å®šå…·ä½“çš„å®ç°ç±»ï¼Œåˆ™æ¥å£é»˜è®¤æ˜¯é›¶å€¼
`nil`
ï¼Œè¡¨ç¤ºå®ƒæ²¡æœ‰æŒ‡å‘ä»»ä½•å…·ä½“çš„ç±»å‹æˆ–å€¼**
ã€‚å¦‚æœæ¥å£å˜é‡ä¸º
`nil`
ï¼Œè°ƒç”¨å…¶æ–¹æ³•ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

type Shape interface {
	Area() float64
	Perimeter() float64
}

func main() {
	var s Shape = nil
	s.Area() // invalid memory address or nil pointer dereference
}

```

åˆ™éœ€è¦ä¸ºå…¶æŒ‡å®šæ­£ç¡®çš„å®ç°ç±»æ¥å®Œæˆåˆå§‹åŒ–è¡Œä¸ºï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import (
	"fmt"
	"math"
)

type Shape interface {
	Area() float64
	Perimeter() float64
}

type Circle struct {
	Radius float64
}

func (c Circle) Area() float64 {
	return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
	return 2 * math.Pi * c.Radius
}

func main() {
	var shape Shape
	shape = Circle{Radius: 2} // åˆå§‹åŒ–
	fmt.Println(shape.Area()) // 12.566370614359172
}

```

ä¸Šè¿°ä»£ç ä¸­ï¼Œ
`shape`
æ˜¯ä¸€ä¸ª
`Shape`
æ¥å£å˜é‡ã€‚é€šè¿‡å°†
`Circle`
ç±»å‹çš„å®ä¾‹èµ‹å€¼ç»™å®ƒï¼Œæ¥å£å˜é‡å°±åˆå§‹åŒ–å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥é€šè¿‡
`shape`
è°ƒç”¨äº†
`Area`
æ–¹æ³•æ¥æ‰“å°å‡ºä¸€ä¸ªåŠå¾„ä¸º 2 çš„
`Circle`
çš„é¢ç§¯ã€‚

### æ¥å£åµŒå¥—

æ¥å£çš„åµŒå¥—ä¸»è¦ä½“ç°åœ¨æ¥å£ä¹‹é—´çš„ç»§æ‰¿å…³ç³»ï¼Œå³ä¸€ä¸ªæ¥å£å¯ä»¥åµŒå¥—å¦ä¸€ä¸ªæ¥å£ã€‚è¿™ç§åµŒå¥—å…³ç³»å¯ä»¥è®©æ¥å£ç»§æ‰¿å…¶ä»–æ¥å£çš„æ–¹æ³•é›†åˆï¼Œä»è€Œå®ç°æ›´çµæ´»çš„æ¥å£è®¾è®¡ã€‚

å®šä¹‰ä¸€ä¸ªæ¥å£
`Reader`
ï¼Œåœ¨æ¥å£ä¸­å®šä¹‰äº†ä¸€ä¸ª
`Read`
æ–¹æ³•ï¼Œç”¨äºä»æŸä¸ªæ•°æ®æºè¯»å–æ•°æ®åˆ°ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡
`p`
ä¸­ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

```

å®šä¹‰ä¸€ä¸ªæ¥å£
`Writer`
ï¼Œåœ¨æ¥å£ä¸­å®šä¹‰äº†ä¸€ä¸ª
`Write`
æ–¹æ³•ï¼Œç”¨äºå°†å­—èŠ‚åˆ‡ç‰‡
`p`
ä¸­çš„æ•°æ®å†™å…¥æŸä¸ªç›®æ ‡ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}

```

å®šä¹‰ä¸€ä¸ªæ¥å£
`ReadWriter`
ï¼Œé€šè¿‡åµŒå¥—
`Reader`
å’Œ
`Writer`
ï¼Œå®ƒç»§æ‰¿äº†è¿™ä¸¤ä¸ªæ¥å£çš„æ‰€æœ‰æ–¹æ³•ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type ReadWriter interface {
    Reader
    Writer
}

```

ç”±äº
`ReadWriter`
ç»§æ‰¿äº†
`Reader`
å’Œ
`Writer`
ä¸¤ä¸ªæ¥å£ï¼Œæ‰€ä»¥å®ç°
`ReadWriter`
æ¥å£ä¹ŸåŒæ ·éœ€è¦å®ç°è¿™ä¸¤ä¸ªæ¥å£ä¸­çš„æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
type MyReadWriter struct{}

func (m *MyReadWriter) Read(p []byte) (n int, err error) {
	fmt.Printf("MyReadWriter Read~~ %c\n", p)
	return 0, nil
}

func (m *MyReadWriter) Write(p []byte) (n int, err error) {
	fmt.Printf("MyReadWriter Write~~ %c\n", p)
	return 0, nil
}

```

æœ€åé€šè¿‡
`main`
å‡½æ•°è¿›è¡Œæµ‹è¯•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
func main() {
	var rw ReadWriter
	rw = &MyReadWriter{}

	rw.Read([]byte("hello world~ ycz"))  // MyReadWriter Read~~ [h e l l o   w o r l d ~   y c z]
	rw.Write([]byte("hello world~ ycz")) // MyReadWriter Write~~ [h e l l o   w o r l d ~   y c z]
}

```

é€šè¿‡æ¥å£åµŒå¥—ï¼Œå¯ä»¥å°†æ¥å£çš„åŠŸèƒ½è¿›è¡Œæ¨¡å—åŒ–è®¾è®¡ï¼Œä»è€Œå®ç°åŠŸèƒ½çš„ç»„åˆå’Œæ‰©å±•ï¼Œä¹Ÿå¯ä»¥é¿å…åœ¨æ¯ä¸ªæ¥å£ä¸­é‡å¤å®šä¹‰ç›¸åŒçš„æ–¹æ³•ã€‚

### ç©ºæ¥å£

ç©ºæ¥å£æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ¥å£ç±»å‹ï¼Œå®ƒä¸åŒ…å«ä»»ä½•æ–¹æ³•ã€‚ç”±äºå®ƒæ²¡æœ‰ä»»ä½•æ–¹æ³•çº¦æŸï¼Œå› æ­¤å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ã€‚å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
var v interface{}

```

ä¸Šè¿°ä»£ç ä¸­çš„
`v`
æ˜¯ä¸€ä¸ªç©ºæ¥å£å˜é‡ï¼Œå®ƒå¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ã€‚

åœ¨å®é™…å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä¼šç»å¸¸ä½¿ç”¨åˆ°ç©ºæ¥å£ï¼Œä¾‹å¦‚ï¼š
**å­˜å‚¨ä»»æ„ç±»å‹çš„æ•°æ®**
ã€
**ä½œä¸ºå‡½æ•°å‚æ•°**
ã€
**ç±»å‹æ–­è¨€å’Œç±»å‹åˆ‡æ¢**
ã€‚

#### å­˜å‚¨ä»»æ„ç±»å‹çš„æ•°æ®

ç©ºæ¥å£å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ï¼ŒåŒ…æ‹¬åŸºæœ¬ç±»å‹ï¼ˆå¦‚
`int`
ã€
`string`
ï¼‰ã€è‡ªå®šä¹‰ç±»å‹ï¼ˆå¦‚ç»“æ„ä½“ã€åˆ‡ç‰‡ã€æ˜ å°„ç­‰ï¼‰ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func main() {
	var v interface{}

	v = 42
	fmt.Println(v) // 42

	v = "zyc"
	fmt.Println(v) // zyc

	v = []int{1, 2, 3}
	fmt.Println(v) // [1 2 3]
}

```

#### ä½œä¸ºå‡½æ•°å‚æ•°

ç©ºæ¥å£å¸¸ç”¨äºå‡½æ•°å‚æ•°ï¼Œä½¿å‡½æ•°èƒ½å¤Ÿæ¥å—ä»»ä½•ç±»å‹çš„å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func PrintValue(v interface{}) {
	fmt.Println(v)
}

func main() {
	PrintValue(10)             // 10
	PrintValue("zzzzzzz")      // zzzzzzz
	PrintValue([]int{1, 2, 3}) // [1 2 3]
}

```

#### ç±»å‹æ–­è¨€å’Œç±»å‹åˆ‡æ¢

ç”±äºç©ºæ¥å£å­˜å‚¨çš„å€¼ç±»å‹ä¸æ˜ç¡®ï¼Œé€šå¸¸éœ€è¦é€šè¿‡
**ç±»å‹æ–­è¨€**
æˆ–
**ç±»å‹åˆ‡æ¢**
æ¥è·å–å…¶å®é™…ç±»å‹ã€‚

##### ç±»å‹æ–­è¨€

ç”¨äºä»æ¥å£å˜é‡ä¸­æå–å…·ä½“çš„ç±»å‹å€¼ã€‚åŸºæœ¬è¯­æ³•æ ¼å¼å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
value, ok := interfaceVariable.(Type)value := iface.(Type)

```

åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ–­è¨€å¤±è´¥ï¼Œ
`ok`
ä¼šè¿”å›
`false`
ï¼Œè€Œ
`value`
ä¼šæ˜¯ç›®æ ‡ç±»å‹çš„é›¶å€¼ã€‚
**ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœç›´æ¥ä½¿ç”¨ç±»å‹æ–­è¨€è€Œä¸æ£€æŸ¥
`ok`
å€¼å¯èƒ½å¯¼è‡´è¿è¡Œæ—¶
`panic`**
ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ¥å£å˜é‡çš„å®é™…ç±»å‹ä¸æ–­è¨€ç±»å‹ä¸åŒ¹é…ï¼Œç¨‹åºä¼šå´©æºƒã€‚

```go
package main

import "fmt"

func main() {
	var v interface{} = "Hello, World!"

	if str, ok := v.(string); ok {
		fmt.Println("v is string:", str) // v is string: Hello, World!
	} else {
		fmt.Println("v is not string")
	}
}

```

##### ç±»å‹åˆ‡æ¢

ç»“åˆ
`switch...case`
è¯­å¥ï¼Œå¤„ç†æ¥å£å˜é‡å¯èƒ½åŒ…å«å¤šç§ç±»å‹çš„æƒ…å†µï¼ŒåŸºæœ¬è¯­æ³•æ ¼å¼å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
switch v := interfaceVariable.(type) {
case Type1:
    // å¤„ç† Type1
case Type2:
    // å¤„ç† Type2
default:
    // é»˜è®¤å¤„ç†
}

```

ç±»å‹åˆ‡æ¢é€‚ç”¨äºæ¥å£å˜é‡å¯èƒ½åŒ…å«å¤šç§ç±»å‹çš„æƒ…å†µï¼Œå¯ä»¥åœ¨å¤šä¸ªç±»å‹ä¹‹é—´è¿›è¡Œåˆ†æ”¯å¤„ç†ã€‚å¦å¤–ï¼Œä¸ç±»å‹æ–­è¨€ç›¸æ¯”ï¼Œç±»å‹åˆ‡æ¢å¯ä»¥ä¼˜é›…åœ°å¤„ç†æœªçŸ¥ç±»å‹ï¼Œé€šè¿‡
`default`
åˆ†æ”¯æä¾›é»˜è®¤é€»è¾‘ã€‚

```go
package main

import "fmt"

func main() {
	var v interface{} = 10

	switch v := v.(type) {
	case int:
		fmt.Println("v is int:", v) // v is int: 10
	case string:
		fmt.Println("v is string:", v)
	default:
		fmt.Println("unknown type")
	}
}

```

### æºç è§£æ

æ¥å£ä»åŠŸèƒ½ä¸Šæ¥è¯´åˆ†ä¸ºä¸¤ç±»ï¼š
**ç©ºæ¥å£**
å’Œ
**éç©ºæ¥å£**
ã€‚å®ƒä»¬å†åº•å±‚å®ç°ä¸Šå¤§è‡´æ˜¯ç±»ä¼¼çš„ï¼ˆè¿˜æ˜¯æœ‰åŒºåˆ«ï¼‰ï¼Œä½†æ˜¯å®ƒä»¬çš„ç”¨é€”å’Œçº¦æŸæœ‰æ‰€ä¸åŒï¼š

* **ç©ºæ¥å£**
  ï¼šæ²¡æœ‰æ–¹æ³•é›†åˆï¼Œå› æ­¤å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ã€‚
* **éç©ºæ¥å£**
  ï¼šæœ‰ä¸€ä¸ªæ–¹æ³•é›†åˆï¼Œåªæœ‰å®ç°äº†è¿™äº›æ–¹æ³•çš„ç±»å‹æ‰èƒ½è¢«å­˜å‚¨ã€‚

ä¸‹é¢åˆ†åˆ«ä»è¿™ä¸¤ç±»å¯¹æ¥å£çš„æºç è¿›è¡Œæ·±åº¦è§£æã€‚

#### ç©ºæ¥å£

ç©ºæ¥å£åº•å±‚å®ç°åŸºäºä¸€ä¸ªç»“æ„ä½“ï¼Œé€šå¸¸è¢«ç§°ä¸º
**æ¥å£ç±»å‹æè¿°ç¬¦**
ã€‚å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/runtime2.go

```go
type eface struct {
	_type *_type
	data  unsafe.Pointer
}

```

* `_type`
  ï¼šæŒ‡å‘ä¸€ä¸ªç±»å‹æè¿°ç¬¦ï¼Œå®ƒåŒ…å«äº†å€¼çš„ç±»å‹ä¿¡æ¯ï¼Œä¾‹å¦‚ç±»å‹åç§°ã€å¤§å°ã€æ–¹æ³•é›†åˆç­‰ã€‚
* `data`
  ï¼šæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘å®é™…å­˜å‚¨çš„å€¼ã€‚ç”±äº
  `data`
  æ˜¯ä¸€ä¸ªé€šç”¨æŒ‡é’ˆï¼Œå®ƒå¯ä»¥æŒ‡å‘ä»»ä½•ç±»å‹çš„å€¼ã€‚

##### ç±»å‹æè¿°ç¬¦

> æºç ä½ç½®ï¼šsrc/runtime/type.go

```go
type _type = abi.Type

```

> æºç ä½ç½®ï¼šsrc/internal/abi/type.go

```go
type Type struct {
	Size_       uintptr
	PtrBytes    uintptr // number of (prefix) bytes in the type that can contain pointers
	Hash        uint32  // hash of type; avoids computation in hash tables
	TFlag       TFlag   // extra type information flags
	Align_      uint8   // alignment of variable with this type
	FieldAlign_ uint8   // alignment of struct field with this type
	Kind_       Kind    // enumeration for C
	// function for comparing objects of this type
	// (ptr to object A, ptr to object B) -> ==?
	Equal func(unsafe.Pointer, unsafe.Pointer) bool
	// GCData stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, GCData is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	GCData    *byte
	Str       NameOff // string form
	PtrToThis TypeOff // type for pointer to this type, may be zero
}

```

* `Size_`
  ï¼šç±»å‹çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚ä¾‹å¦‚ï¼Œ
  `int32`
  çš„å¤§å°ä¸º 4 å­—èŠ‚ï¼Œ
  `int64`
  çš„å¤§å°ä¸º 8 å­—èŠ‚ã€‚
* `PtrBytes`
  ï¼šç±»å‹ä¸­å¯èƒ½åŒ…å«æŒ‡é’ˆçš„å‰ç¼€éƒ¨åˆ†çš„å­—èŠ‚æ•°ã€‚è¿™ä¸ªå­—æ®µä¸»è¦ç”¨äºåƒåœ¾å›æ”¶å™¨ï¼Œå¸®åŠ©
  `gc`
  ç¡®å®šå“ªäº›éƒ¨åˆ†å¯èƒ½åŒ…å«æŒ‡é’ˆã€‚
* `Hash`
  ï¼šç±»å‹çš„å“ˆå¸Œå€¼ï¼Œç”¨äºåœ¨å“ˆå¸Œè¡¨ä¸­å¿«é€Ÿæ¯”è¾ƒå’ŒæŸ¥æ‰¾ç±»å‹ã€‚
* `TFlag`
  ï¼šç±»å‹æ ‡å¿—ï¼Œå­˜å‚¨é¢å¤–çš„ç±»å‹ä¿¡æ¯æ ‡å¿—ã€‚
* `Align_`
  ï¼šç±»å‹çš„å¯¹é½è¦æ±‚ã€‚ä¾‹å¦‚ï¼Œ
  `int64`
  åœ¨å†…å­˜ä¸­éœ€è¦ 8 å­—èŠ‚å¯¹é½ã€‚
* `FieldAlign_`
  ï¼šä½œä¸ºç»“æ„ä½“å­—æ®µæ—¶çš„å¯¹é½è¦æ±‚ã€‚
* `Kind_`
  ï¼šç±»å‹çš„ç§ç±»ï¼ˆ
  `Kind`
  ï¼‰ï¼Œæ˜¯ä¸€ä¸ªæšä¸¾å€¼ï¼Œä¾‹å¦‚
  `reflect.Int`
  ã€
  `reflect.String`
  ã€
  `reflect.Struct`
  ç­‰ã€‚
* `Equal`
  ï¼šä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œç”¨äºæ¯”è¾ƒä¸¤ä¸ªè¯¥ç±»å‹çš„å€¼æ˜¯å¦ç›¸ç­‰ã€‚ä¾‹å¦‚ï¼Œå¯¹äºç»“æ„ä½“ç±»å‹ï¼Œ
  `Equal`
  å‡½æ•°ä¼šæ¯”è¾ƒç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µæ˜¯å¦ç›¸ç­‰ã€‚
* `GCData`
  ï¼šåƒåœ¾å›æ”¶ç›¸å…³çš„æ•°æ®ã€‚å¦‚æœ
  `Kind`
  ä¸­è®¾ç½®äº†
  `KindGCProg`
  æ ‡å¿—ï¼Œåˆ™
  `GCData`
  æ˜¯ä¸€ä¸ªåƒåœ¾å›æ”¶ç¨‹åºï¼›å¦åˆ™æ˜¯ä¸€ä¸ªæŒ‡é’ˆæ©ç ï¼ˆ
  `ptrmask`
  ï¼‰ã€‚
* `Str`
  ï¼šç±»å‹çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼ˆ
  `NameOff`
  æ˜¯ä¸€ä¸ªåç§»é‡ï¼ŒæŒ‡å‘ç±»å‹åç§°çš„å­—ç¬¦ä¸²ï¼‰ã€‚
* `PtrToThis`
  ï¼šæŒ‡å‘è¯¥ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ
  `Type`
  è¡¨ç¤º
  `int`
  ï¼Œåˆ™
  `PtrToThis`
  è¡¨ç¤º
  `*int`
  ã€‚

##### è¾“å‡ºæ¥å£å€¼

ç»™å‡ºä¸€æ®µæ‰“å°ç©ºæ¥å£å€¼çš„ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

func main() {
	var v interface{} = 10
	print(v) // (0x46d400,0x4967e8)
}

```

å°†ä¸Šé¢çš„ä»£ç ç¼–è¯‘æˆæ±‡ç¼–ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
0x000e 00014        CALL    runtime.printlock(SB)
# ...
0x0021 00033        CALL    runtime.printeface(SB)
0x0026 00038        CALL    runtime.printunlock(SB)

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

`printeface`
å‡½æ•°æ˜¯è¿è¡Œæ—¶æ‰“å°æ¥å£å€¼æ‰€æ‰§è¡Œçš„å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/print.go

```go
func printeface(e eface) {
	print("(", e._type, ",", e.data, ")")
}

```

ç»è¿‡
`print`
å‡½æ•°æ‰§è¡Œåï¼Œå°†ç±»å‹æè¿°ç¬¦çš„åœ°å€å’Œåº•å±‚å®é™…å­˜å‚¨çš„å€¼çš„åœ°å€æ ¼å¼åŒ–æ‰“å°å‡ºæ¥ã€‚

#### éç©ºæ¥å£

éç©ºæ¥å£åº•å±‚å®ç°ä¹Ÿæ˜¯åŸºäºä¸€ä¸ªç»“æ„ä½“ï¼Œé€šå¸¸è¢«ç§°ä¸º
**æ¥å£ç±»å‹æè¿°ç¬¦**
ã€‚å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/runtime2.go

```go
type iface struct {
	tab  *itab
	data unsafe.Pointer
}

```

* `tab`
  ï¼šæ˜¯ä¸€ä¸ªæŒ‡å‘
  `ITab`
  çš„æŒ‡é’ˆï¼Œ
  `ITab`
  æ˜¯ä¸€ä¸ªé‡è¦çš„ç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨æ¥å£ç±»å‹å’Œå…·ä½“å®ç°ç±»å‹ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚
* `data`
  ï¼šæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘å®é™…å­˜å‚¨çš„å€¼ã€‚ç”±äº
  `data`
  æ˜¯ä¸€ä¸ªé€šç”¨æŒ‡é’ˆï¼Œå®ƒå¯ä»¥æŒ‡å‘ä»»ä½•ç±»å‹çš„å€¼ã€‚

##### `ITab`

> æºç ä½ç½®ï¼šsrc/runtime/runtime2.go

```go
type itab = abi.ITab

```

`ITab`
æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶ç»“æ„ä½“ï¼Œç”¨äºè¡¨ç¤ºæ¥å£ç±»å‹å’Œå…·ä½“å®ç°ç±»å‹ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚å®ƒçš„å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/internal/abi/iface.go

```go
type ITab struct {
	Inter *InterfaceType
	Type  *Type
	Hash  uint32     // copy of Type.Hash. Used for type switches.
	Fun   [1]uintptr // variable sized. fun[0]==0 means Type does not implement Inter.
}

```

* `Inter`
  ï¼ˆ
  `*InterfaceType`
  ï¼‰ï¼šæ¥å£ç±»å‹çš„ç±»å‹æè¿°ç¬¦ã€‚è¿™è¡¨ç¤ºæ¥å£çš„ç±»å‹ä¿¡æ¯ï¼Œä¾‹å¦‚æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•é›†åˆã€‚
* `Type`
  ï¼ˆ
  `*Type`
  ï¼‰ï¼šå…·ä½“å®ç°ç±»å‹çš„ç±»å‹æè¿°ç¬¦ã€‚è¿™è¡¨ç¤ºæ¥å£èƒŒåçš„å®é™…ç±»å‹ã€‚
* `Hash`
  ï¼ˆ
  `uint32`
  ï¼‰ï¼šç”¨äºç±»å‹åˆ‡æ¢çš„å“ˆå¸Œå€¼ã€‚å®ƒæ˜¯
  `Type.Hash`
  çš„å‰¯æœ¬ï¼Œç”¨äºå¿«é€Ÿæ¯”è¾ƒç±»å‹ã€‚
* `Fun`
  ï¼ˆ
  `[1]uintptr`
  ï¼‰ï¼šä¸€ä¸ªå¯å˜å¤§å°çš„æ•°ç»„ï¼Œå­˜å‚¨æ¥å£æ–¹æ³•åˆ°å…·ä½“å®ç°æ–¹æ³•çš„æ˜ å°„ï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ã€‚
  `Fun`
  æ•°ç»„çš„å¤§å°å–å†³äºæ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•æ•°é‡ã€‚

##### `itabTableType`

`itabTableType`
æ˜¯
`golang`
è¿è¡Œæ—¶ç”¨æ¥å­˜å‚¨å’Œç®¡ç†æ‰€æœ‰
`itab`
çš„æ•°æ®ç»“æ„ã€‚å®ƒæ˜¯ä¸€ä¸ªå…¨å±€çš„å“ˆå¸Œè¡¨ï¼Œç”¨äºç¼“å­˜å·²ç»ç”Ÿæˆçš„
`itab`
ï¼Œä»¥é¿å…é‡å¤åˆ›å»ºã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
const itabInitSize = 512

var (
	itabLock      mutex                               // lock for accessing itab table
	itabTable     = &itabTableInit                    // pointer to current table
	itabTableInit = itabTableType{size: itabInitSize} // starter table
)

// Note: change the formula in the mallocgc call in itabAdd if you change these fields.
type itabTableType struct {
	size    uintptr             // length of entries array. Always a power of 2.
	count   uintptr             // current number of filled entries.
	entries [itabInitSize]*itab // really [size] large
}

```

* `size`
  ï¼šå“ˆå¸Œè¡¨çš„å¤§å°ï¼ˆå³
  `entries`
  æ•°ç»„çš„é•¿åº¦ï¼‰ã€‚å®ƒå§‹ç»ˆæ˜¯ 2 çš„å¹‚æ¬¡æ–¹ã€‚
* `count`
  ï¼šå½“å‰å“ˆå¸Œè¡¨ä¸­å·²å¡«å……çš„æ¡ç›®æ•°é‡ï¼ˆå³å·²å­˜å‚¨çš„
  `itab`
  æ•°é‡ï¼‰ã€‚
* `entries`
  ï¼šå“ˆå¸Œè¡¨çš„æ¡ç›®æŒ‡é’ˆæ•°ç»„ï¼Œå­˜å‚¨æŒ‡å‘
  `itab`
  çš„æŒ‡é’ˆã€‚æ•°ç»„çš„åˆå§‹é•¿åº¦æ˜¯512ã€‚

###### åˆå§‹åŒ– `itab` è¡¨

åœ¨
`golang`
ç¨‹åºå¯åŠ¨æ—¶ï¼Œè¿è¡Œæ—¶ä¼šæ‰§è¡Œä¸€ç³»åˆ—åˆå§‹åŒ–æ“ä½œï¼ŒåŒ…æ‹¬åˆå§‹åŒ–å…¨å±€é”ã€å†…å­˜åˆ†é…å™¨ç­‰ã€‚åœ¨è¿™äº›åˆå§‹åŒ–æ“ä½œä¸­ï¼Œ
`itabsinit`
å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œç”¨äºåˆå§‹åŒ–å…¨å±€çš„
`itab`
è¡¨ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
func itabsinit() {
    // åˆå§‹åŒ–å…¨å±€é” itabLock
	lockInit(&itabLock, lockRankItab)
	lock(&itabLock)
    // è·å–æ‰€æœ‰åŠ è½½çš„æ¨¡å—
	for _, md := range activeModules() {
		for _, i := range md.itablinks {
            // å°†æ¯ä¸ªæ¨¡å—çš„ itab æ·»åŠ åˆ°å…¨å±€è¡¨ä¸­
			itabAdd(i)
		}
	}
	unlock(&itabLock)
}

```

`itabsinit`
å‡½æ•°ä¼šéå†æ‰€æœ‰åŠ è½½çš„æ¨¡å—ï¼Œå°†æ¯ä¸ªæ¨¡å—çš„
`itab`
æ·»åŠ åˆ°å…¨å±€è¡¨ä¸­ã€‚

###### æ·»åŠ  `itab`

`itabAdd`
å‡½æ•°çš„ä¸»è¦ä½œç”¨æ˜¯å°†ä¸€ä¸ªæ–°çš„
`itab`
æ·»åŠ åˆ°å…¨å±€çš„
`itab`
è¡¨ä¸­ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// itabAdd adds the given itab to the itab hash table.
// itabLock must be held.
func itabAdd(m *itab) {
	// Bugs can lead to calling this while mallocing is set,
	// typically because this is called while panicking.
	// Crash reliably, rather than only when we need to grow
	// the hash table.
    // æ£€æŸ¥å½“å‰ Goroutine æ˜¯å¦å¤„äºå†…å­˜åˆ†é…ä¸­
    // å¦‚æœåœ¨å†…å­˜åˆ†é…ä¸­è°ƒç”¨ itabAddï¼Œä¼šè§¦å‘æ­»é”ï¼Œå› æ­¤ç›´æ¥æŠ›å‡ºé”™è¯¯
	if getg().m.mallocing != 0 {
		throw("malloc deadlock")
	}

	t := itabTable
    // æ£€æŸ¥å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­æ˜¯å¦è¶…è¿‡ 75%
	if t.count >= 3*(t.size/4) { // 75% load factor
        // å“ˆå¸Œè¡¨æ‰©å®¹çš„é€»è¾‘
		// Grow hash table.
		// t2 = new(itabTableType) + some additional entries
		// We lie and tell malloc we want pointer-free memory because
		// all the pointed-to values are not in the heap.
        // åˆ†é…æ–°çš„å“ˆå¸Œè¡¨ï¼Œå¤§å°ä¸ºåŸæ¥çš„ä¸¤å€
		t2 := (*itabTableType)(mallocgc((2+2*t.size)*goarch.PtrSize, nil, true))
		t2.size = t.size * 2
		
        // åœ¨å¤åˆ¶æ—¶ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½ä¼šå¯»æ‰¾ itab è€Œæ‰¾ä¸åˆ°å®ƒã€‚æ²¡å…³ç³»ï¼Œç„¶åå®ƒä»¬å°†å°è¯•è·å– tab é”ï¼Œå¹¶å› æ­¤ç­‰å¾…ï¼Œç›´åˆ°å¤åˆ¶å®Œæˆ
		// Copy over entries.
		// Note: while copying, other threads may look for an itab and
		// fail to find it. That's ok, they will then try to get the itab lock
		// and as a consequence wait until this copying is complete.
        // éå†å½“å‰å“ˆå¸Œè¡¨ä¸­çš„æ‰€æœ‰ itabï¼Œå¹¶å°†å®ƒä»¬æ·»åŠ åˆ°æ–°çš„å“ˆå¸Œè¡¨ä¸­
        // ä¼ å…¥ add å‡½æ•°æŒ‡é’ˆï¼Œå…¶å®è°ƒç”¨çš„è¿˜æ˜¯ add å‡½æ•°è¿›è¡Œæ·»åŠ 
		iterate_itabs(t2.add)
		if t2.count != t.count {
			throw("mismatched count during itab table copy")
		}
		// Publish new hash table. Use an atomic write: see comment in getitab.
        // åŸå­åœ°æ›´æ–°å…¨å±€ itabTable æŒ‡é’ˆï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨
		atomicstorep(unsafe.Pointer(&itabTable), unsafe.Pointer(t2))
		// Adopt the new table as our own.
		t = itabTable
		// Note: the old table can be GC'ed here.
	}
    
    // å¦‚æœæ²¡æœ‰è¶…è¿‡ 75%ï¼Œåˆ™è°ƒç”¨ itabTableType.add æ–¹æ³•ï¼Œå°†æ–°çš„ itab æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­
	t.add(m)
}

```

å¦å¤–ï¼Œåœ¨æ‰©å®¹å®Œæˆåï¼Œæ–°çš„
`itab`
è¡¨éœ€è¦è¢«å‘å¸ƒã€‚ä¸ºäº†ç¡®ä¿çº¿ç¨‹å®‰å…¨ï¼Œ
`golang`
ä½¿ç”¨åŸå­æ“ä½œ
`atomicstorep`
æ¥æ›´æ–°å…¨å±€
`itabTable`
æŒ‡é’ˆï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œ
`itabTable`
çš„æ›´æ–°æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

æ¥ä¸‹æ¥å°±æ˜¯å°†
`itab`
æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­çš„ä»£ç 
`itabTableType.add`
ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// add adds the given itab to itab table t.
// itabLock must be held.
func (t *itabTableType) add(m *itab) {
	// See comment in find about the probe sequence.
	// Insert new itab in the first empty spot in the probe sequence.
    // ä½¿ç”¨æ©ç  mask ç¡®ä¿å“ˆå¸Œå€¼åœ¨å“ˆå¸Œè¡¨çš„èŒƒå›´å†…
	mask := t.size - 1
    // ä½¿ç”¨ itabHashFunc è®¡ç®— itab çš„å“ˆå¸Œå€¼
	h := itabHashFunc(m.Inter, m.Type) & mask
	for i := uintptr(1); ; i++ {
        // ä½¿ç”¨çº¿æ€§æ¢æµ‹æ³•è§£å†³å“ˆå¸Œå†²çª
		p := (**itab)(add(unsafe.Pointer(&t.entries), h*goarch.PtrSize))
		m2 := *p
        // å¦‚æœå‡ºç°ç›¸åŒçš„ itab åˆ™ç›´æ¥è¿”å›ï¼Œé¿å…é‡å¤æ·»åŠ 
		if m2 == m {
			// A given itab may be used in more than one module
			// and thanks to the way global symbol resolution works, the
			// pointed-to itab may already have been inserted into the
			// global 'hash'.
			return
		}
        // å¦‚æœæ‰¾åˆ°ç©ºä½ï¼Œå°†æ–°çš„ itab æ·»åŠ åˆ°è¯¥ä½ç½®
		if m2 == nil {
			// Use atomic write here so if a reader sees m, it also
			// sees the correctly initialized fields of m.
			// NoWB is ok because m is not in heap memory.
			// *p = m
            // ä½¿ç”¨ atomic.StorepNoWB ç¡®ä¿å†™å…¥æ“ä½œæ˜¯åŸå­çš„
			atomic.StorepNoWB(unsafe.Pointer(p), unsafe.Pointer(m))
            // æ›´æ”¹å…¨å±€å“ˆå¸Œè¡¨çš„è®¡æ•°å€¼
			t.count++
			return
		}
        
        // æ›´æ–°å“ˆå¸Œå€¼
        // ç›´æ¥æŸ¥æ‰¾ä¸‹ä¸€ä¸ªï¼Œçº¿æ€§æ¢æµ‹æ³•
		h += i
		h &= mask
	}
}

```

###### æŸ¥æ‰¾ `itab`

`getitab`
å‡½æ•°çš„ä½œç”¨æ˜¯æŸ¥æ‰¾æˆ–ç”Ÿæˆä¸€ä¸ª
`itab`
ã€‚å¦‚æœæ‰¾åˆ°ç°æˆçš„
`itab`
ï¼Œåˆ™ç›´æ¥è¿”å›ï¼›å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™åŠ¨æ€ç”Ÿæˆä¸€ä¸ªæ–°çš„
`itab`
å¹¶æ·»åŠ åˆ°å…¨å±€è¡¨ä¸­ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// getitab should be an internal detail,
// but widely used packages access it using linkname.
// Notable members of the hall of shame include:
//   - github.com/bytedance/sonic
//
// Do not remove or change the type signature.
// See go.dev/issue/67401.
//
//go:linkname getitab
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
    // å¦‚æœæ¥å£æ²¡æœ‰æ–¹æ³•ï¼ŒæŠ›å‡ºå†…éƒ¨é”™è¯¯
    // å¿…é¡»ä¿è¯æ˜¯éç©ºæ¥å£
	if len(inter.Methods) == 0 {
		throw("internal error - misuse of itab")
	}

	// easy case
    // å¦‚æœå…·ä½“ç±»å‹æ²¡æœ‰æ–¹æ³•è¡¨, å¹¶ä¸” canfail ä¸º trueï¼Œåˆ™è¿”å› nil
	if typ.TFlag&abi.TFlagUncommon == 0 {
		if canfail {
			return nil
		}
        // å¦‚æœ canfail ä¸º falseï¼ŒæŠ›å‡ºç±»å‹æ–­è¨€é”™è¯¯
		name := toRType(&inter.Type).nameOff(inter.Methods[0].Name)
		panic(&TypeAssertionError{nil, typ, &inter.Type, name.Name()})
	}

	var m *itab

	// First, look in the existing table to see if we can find the itab we need.
	// This is by far the most common case, so do it without locks.
	// Use atomic to ensure we see any previous writes done by the thread
	// that updates the itabTable field (with atomic.Storep in itabAdd).
    // ä½¿ç”¨åŸå­æ“ä½œåŠ è½½å…¨å±€ itabTable
	t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&itabTable)))
    // è°ƒç”¨ t.find æŸ¥æ‰¾ç°æœ‰çš„ itab
	if m = t.find(inter, typ); m != nil {
        // å¦‚æœæ‰¾åˆ°ï¼Œè·³è½¬åˆ° finish
		goto finish
	}
	
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå…ˆåŠ é”ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨
	// Not found.  Grab the lock and try again.
	lock(&itabLock)
    // å†æ¬¡æŸ¥æ‰¾
	if m = itabTable.find(inter, typ); m != nil {
        // æ‰¾åˆ°äº†ç›´æ¥å°±è§£é”ï¼Œè·³è½¬åˆ° finish
		unlock(&itabLock)
		goto finish
	}
	
    // å¦‚æœä»£ç èµ°åˆ°äº†è¿™é‡Œï¼Œè¡¨ç¤ºå…¨å±€ itabTable è¡¨ä¸­ä¸å­˜åœ¨ç›®æ ‡ itab
    // ä¸‹é¢å°±éœ€è¦åŠ¨æ€ç”Ÿæˆ itabï¼Œå¹¶åŠ å…¥åˆ°å…¨å±€ itabTable è¡¨ä¸­
	// Entry doesn't exist yet. Make a new entry & add it.
    // åŠ¨æ€åˆ†é…æ–°çš„ itab
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.Methods)-1)*goarch.PtrSize, 0, &memstats.other_sys))
    // åˆå§‹åŒ– itab çš„å­—æ®µ
	m.Inter = inter
	m.Type = typ
	// The hash is used in type switches. However, compiler statically generates itab's
	// for all interface/type pairs used in switches (which are added to itabTable
	// in itabsinit). The dynamically-generated itab's never participate in type switches,
	// and thus the hash is irrelevant.
	// Note: m.Hash is _not_ the hash used for the runtime itabTable hash table.
	m.Hash = 0
    // è°ƒç”¨ itabInit åˆå§‹åŒ–æ–¹æ³•è¡¨
	itabInit(m, true)
    // è°ƒç”¨ itabAdd å°†æ–°çš„ itab æ·»åŠ åˆ°å…¨å±€è¡¨ä¸­
	itabAdd(m)
    // è§£é”
	unlock(&itabLock)
    
    // æ¥ä¸‹æ¥å°±æ˜¯æŸ¥æ‰¾å®Œæˆçš„é€»è¾‘
finish:
    // å¦‚æœ m.Fun[0] ä¸ä¸º 0ï¼Œè¿”å› itab
    // è¿™é‡Œéœ€è¦è§£é‡Šä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œéœ€è¦åŠ è¿™ä¹ˆä¸€ä¸ªåˆ¤æ–­
    // å› ä¸º m.Fun[0] æ˜¯è¿™ä¸ªæ–¹æ³•è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œé€šå¸¸å¯¹åº”æ¥å£çš„ç¬¬ä¸€ä¸ªæ–¹æ³•
    // m.Fun[0] != 0 å°±è¡¨ç¤ºæ¥å£çš„ç¬¬ä¸€ä¸ªæ–¹æ³•å·²ç»è¢«æ­£ç¡®åŠ è½½ï¼Œä¹Ÿå°±æ˜¯è¯´ itab å·²ç»åˆå§‹åŒ–å®Œæ¯•äº†
    // m.Fun[0] == 0 è¡¨ç¤ºæ¥å£çš„ç¬¬ä¸€ä¸ªæ–¹æ³•æ²¡æœ‰è¢«åŠ è½½ï¼Œitabåˆå§‹åŒ–å¤±è´¥
	if m.Fun[0] != 0 {
		return m
	}
    
    // å¦‚æœ canfail ä¸º trueï¼Œè¿”å› nil
	if canfail {
		return nil
	}
	// this can only happen if the conversion
	// was already done once using the , ok form
	// and we have a cached negative result.
	// The cached result doesn't record which
	// interface function was missing, so initialize
	// the itab again to get the missing function name.
    // å¦åˆ™ï¼ŒæŠ›å‡ºç±»å‹æ–­è¨€é”™è¯¯
	panic(&TypeAssertionError{concrete: typ, asserted: &inter.Type, missingMethod: itabInit(m, false)})
}

```

`find`
æ–¹æ³•çš„ä½œç”¨å°±æ˜¯åœ¨
`itabTable`
ä¸­æŸ¥æ‰¾ç»™å®šçš„æ¥å£ç±»å‹å’Œå…·ä½“ç±»å‹çš„
`itab`
ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// find finds the given interface/type pair in t.
// Returns nil if the given interface/type pair isn't present.
func (t *itabTableType) find(inter *interfacetype, typ *_type) *itab {
	// Implemented using quadratic probing.
	// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k.
	// We're guaranteed to hit all table entries using this probe sequence.
	mask := t.size - 1
    // è®¡ç®—æ¥å£ç±»å‹å’Œå…·ä½“ç±»å‹çš„å“ˆå¸Œå€¼
	h := itabHashFunc(inter, typ) & mask
	for i := uintptr(1); ; i++ {
        // è®¡ç®—å½“å‰å“ˆå¸Œä½ç½®çš„æŒ‡é’ˆ
		p := (**itab)(add(unsafe.Pointer(&t.entries), h*goarch.PtrSize))
		// Use atomic read here so if we see m != nil, we also see
		// the initializations of the fields of m.
		// m := *p
        // ä½¿ç”¨åŸå­æ“ä½œåŠ è½½ itabï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨
		m := (*itab)(atomic.Loadp(unsafe.Pointer(p)))
		if m == nil {
            // å¦‚æœå½“å‰ä½ç½®ä¸ºç©ºï¼Œè¿”å› nilï¼Œè¡¨ç¤ºæœªæ‰¾åˆ°åŒ¹é…çš„ itab
			return nil
		}
        // å¦‚æœå½“å‰ itab çš„æ¥å£ç±»å‹å’Œå…·ä½“ç±»å‹ä¸ç›®æ ‡åŒ¹é…ï¼Œè¿”å›è¯¥ itab
		if m.Inter == inter && m.Type == typ {
			return m
		}
        
        // å½“å‰ä½ç½®ä¸ä¸ºç©ºï¼Œå¹¶ä¸”ä¸ç›®æ ‡ç±»å‹ä¹Ÿä¸åŒ¹é…ï¼Œåˆ™ç›´æ¥æŸ¥æ‰¾ä¸‹ä¸€ä¸ª
        // çº¿æ€§æ¢æµ‹æ³•
        
        // æ›´æ–°å“ˆå¸Œå€¼
		h += i
		h &= mask
	}
}

```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œä½¿ç”¨äº†åŸå­æ“ä½œ
`atomic.Loadp`
æ¥åŠ è½½
`itab`
ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ã€‚è¿™é¿å…äº†åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯èƒ½å‡ºç°çš„è¯»å–æœªåˆå§‹åŒ–æˆ–éƒ¨åˆ†åˆå§‹åŒ–çš„
`itab`
çš„é—®é¢˜ã€‚

å¦å¤–ï¼Œåœ¨
`getitab`
å‡½æ•°ä¸­ï¼Œå½“
`itab`
ä¸å­˜åœ¨æ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„
`itab`
ï¼Œå¹¶è¿›è¡Œåˆå§‹åŒ–ï¼Œé‚£ä¹ˆå…¶ä¸­è¿˜æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„åˆå§‹åŒ–åŠ¨ä½œï¼š
`itabInit`
å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯
`golang`
è¿è¡Œæ—¶ä¸­ç”¨äºåˆå§‹åŒ–
`itab`
çš„æ–¹æ³•è¡¨çš„å…³é”®å‡½æ•°ã€‚å®ƒçš„ä½œç”¨æ˜¯å°†æ¥å£ç±»å‹çš„æ–¹æ³•ä¸å…·ä½“ç±»å‹çš„æ–¹æ³•è¿›è¡ŒåŒ¹é…ï¼Œå¹¶å¡«å……
`itab`
çš„
`Fun`
å­—æ®µã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
func itabInit(m *itab, firstTime bool) string {
    // æ¥å£ç±»å‹
	inter := m.Inter
    // å…·ä½“ç±»å‹
	typ := m.Type
    // å…·ä½“ç±»å‹çš„ UncommonTypeï¼ŒåŒ…å«æ–¹æ³•è¡¨ä¿¡æ¯
	x := typ.Uncommon()

	// both inter and typ have method sorted by name,
	// and interface names are unique,
	// so can iterate over both in lock step;
	// the loop is O(ni+nt) not O(ni*nt).
    // æ¥å£æ–¹æ³•çš„æ•°é‡
	ni := len(inter.Methods)
    // å…·ä½“ç±»å‹æ–¹æ³•çš„æ•°é‡
	nt := int(x.Mcount)
    // å…·ä½“ç±»å‹çš„æ–¹æ³•è¡¨
	xmhdr := (*[1 << 16]abi.Method)(add(unsafe.Pointer(x), uintptr(x.Moff)))[:nt:nt]
	j := 0
    // itab çš„æ–¹æ³•è¡¨ï¼Œç”¨äºå­˜å‚¨æ¥å£æ–¹æ³•çš„å‡½æ•°æŒ‡é’ˆ
	methods := (*[1 << 16]unsafe.Pointer)(unsafe.Pointer(&m.Fun[0]))[:ni:ni]
    // ç¬¬ä¸€ä¸ªæ–¹æ³•çš„å‡½æ•°æŒ‡é’ˆï¼Œç”¨äºåˆå§‹åŒ– m.Fun[0]
	var fun0 unsafe.Pointer
imethods:
    // éå†æ¥å£çš„æ‰€æœ‰æ–¹æ³•
	for k := 0; k < ni; k++ {
        // å½“å‰æ¥å£æ–¹æ³•çš„æè¿°
		i := &inter.Methods[k]
        // å½“å‰æ¥å£æ–¹æ³•çš„ç±»å‹
		itype := toRType(&inter.Type).typeOff(i.Typ)
        // å½“å‰æ¥å£æ–¹æ³•çš„åç§°
		name := toRType(&inter.Type).nameOff(i.Name)
        // å½“å‰æ¥å£æ–¹æ³•çš„åç§°å­—ç¬¦ä¸²
		iname := name.Name()
        // å½“å‰æ¥å£æ–¹æ³•çš„åŒ…è·¯å¾„
		ipkg := pkgPath(name)
		if ipkg == "" {
			ipkg = inter.PkgPath.Name()
		}
        // éå†å…·ä½“ç±»å‹çš„æ‰€æœ‰æ–¹æ³•ï¼Œå°è¯•æ‰¾åˆ°åŒ¹é…çš„æ¥å£æ–¹æ³•
		for ; j < nt; j++ {
            // å½“å‰å…·ä½“ç±»å‹æ–¹æ³•çš„æè¿°
			t := &xmhdr[j]
            // å½“å‰å…·ä½“ç±»å‹çš„ç±»å‹ä¿¡æ¯
			rtyp := toRType(typ)
            // å½“å‰å…·ä½“ç±»å‹æ–¹æ³•çš„åç§°
			tname := rtyp.nameOff(t.Name)
            
            // ä¸‹é¢å¼€å§‹çœŸæ­£çš„åŒ¹é…åŠ¨ä½œ
            // åŒ¹é…æ¡ä»¶ï¼š1. æ–¹æ³•ç±»å‹åŒ¹é…
            // 2. æ–¹æ³•ååŒ¹é…
            // 3. åŒ…è·¯å¾„åŒ¹é…
			if rtyp.typeOff(t.Mtyp) == itype && tname.Name() == iname {
				pkgPath := pkgPath(tname)
				if pkgPath == "" {
					pkgPath = rtyp.nameOff(x.PkgPath).Name()
				}
				if tname.IsExported() || pkgPath == ipkg {
					ifn := rtyp.textOff(t.Ifn)
                    // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªæ–¹æ³•ï¼Œå­˜å‚¨å‡½æ•°æŒ‡é’ˆåˆ° fun0
					if k == 0 {
						fun0 = ifn // we'll set m.Fun[0] at the end
					} else if firstTime {
                        // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ï¼Œå­˜å‚¨å‡½æ•°æŒ‡é’ˆåˆ° methods[k]
						methods[k] = ifn
					}
					continue imethods
				}
			}
		}
		// didn't find method
		// Leaves m.Fun[0] set to 0.
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ–¹æ³•ï¼Œè¿”å›ç¼ºå¤±æ–¹æ³•çš„åç§°
        // m.Fun[0] ä¿æŒä¸º 0ï¼Œå…¶å®å°±æ˜¯è¡¨ç¤ºäº†æ¥å£çš„ç¬¬ä¸€ä¸ªæ–¹æ³•æœªè¢«åŠ è½½
		return iname
	}
    
    // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ï¼Œè®¾ç½® m.Fun[0] ä¸ºç¬¬ä¸€ä¸ªæ–¹æ³•çš„å‡½æ•°æŒ‡é’ˆ
	if firstTime {
		m.Fun[0] = uintptr(fun0)
	}
    // è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºåˆå§‹åŒ–æˆåŠŸ
	return ""
}

```

#### å¸¸è§æ“ä½œåŸç†

##### å¤šæ€æ€§

å½“ä¸€ä¸ªå˜é‡è¢«å£°æ˜ä¸ºæ¥å£ç±»å‹æ—¶ï¼Œ
`golang`
è¿è¡Œæ—¶ä¼šåŠ¨æ€åœ°ç®¡ç†æ¥å£çš„è°ƒç”¨é€»è¾‘ã€‚ä¸»è¦åˆ†ä¸ºä¸¤é˜¶æ®µï¼š
**æ¥å£èµ‹å€¼**
å’Œ
**æ–¹æ³•è°ƒç”¨**
ã€‚

> è¿™é‡Œçš„å¤šæ€æ€§ä¸»è¦è®¨è®ºçš„æ˜¯éç©ºæ¥å£ã€‚

###### æ¥å£èµ‹å€¼

å½“ä¸€ä¸ªå…·ä½“ç±»å‹è¢«èµ‹å€¼ç»™æ¥å£å˜é‡æ—¶ï¼Œ
`golang`
è¿è¡Œæ—¶ä¼šæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

* é¦–å…ˆï¼Œæ£€æŸ¥è¯¥ç±»å‹æ˜¯å¦å®ç°äº†æ¥å£ã€‚
* å¦‚æœå®ç°äº†æ¥å£ï¼Œè¿è¡Œæ—¶ä¼šåˆ›å»ºä¸€ä¸ª
  `itab`
  ï¼Œå¹¶å°†æ¥å£ç±»å‹å’Œå…·ä½“ç±»å‹å…³è”èµ·æ¥ã€‚
* æ¥å£å˜é‡ä¼šå­˜å‚¨æŒ‡å‘
  `itab`
  çš„æŒ‡é’ˆå’Œå…·ä½“ç±»å‹çš„å€¼ã€‚

###### æ–¹æ³•è°ƒç”¨

å½“è°ƒç”¨æ¥å£æ–¹æ³•æ—¶ï¼Œ
`golang`
è¿è¡Œæ—¶ä¼šé€šè¿‡ä»¥ä¸‹æ­¥éª¤æ‰¾åˆ°å…·ä½“çš„æ–¹æ³•å®ç°ï¼š

* é€šè¿‡æ¥å£å˜é‡çš„
  `itab`
  æŒ‡é’ˆæ‰¾åˆ°å¯¹åº”çš„
  `itab`
  ã€‚
* åœ¨
  `itab`
  çš„æ–¹æ³•è¡¨
  `Fun`
  ä¸­æŸ¥æ‰¾æ–¹æ³•çš„å‡½æ•°æŒ‡é’ˆã€‚
* è°ƒç”¨å‡½æ•°æŒ‡é’ˆæŒ‡å‘çš„å…·ä½“æ–¹æ³•ã€‚

###### ä»£ç ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ï¼Œå±•ç¤ºæ¥å£å¤šæ€çš„å®ç°ï¼š

```go
package main

import "fmt"

type Animal interface {
	GetName() string
}

type Person struct {
	Name string
	Age  int
}

type Cat struct {
	Name string
	Age  int
}

func (p *Person) GetName() string {
	return p.Name
}

func (c *Cat) GetName() string {
	return c.Name
}

func main() {
	var p Animal = &Person{Name: "ycz", Age: 18}
	fmt.Println(p.GetName()) // ycz

	p = &Cat{Name: "ccc", Age: 1}
	fmt.Println(p.GetName()) // ccc
}

```

å°†ä¸Šè¿°ä»£ç ç¼–è¯‘æˆæ±‡ç¼–ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
# ...

# åˆ†é…å†…å­˜
0x001a 00026      LEAQ    type:main.Person(SB), AX
0x0021 00033      PCDATA  $1, $0
0x0021 00033      CALL    runtime.newobject(SB)
0x0026 00038      MOVQ    AX, main..autotmp_5+88(SP)

# åˆå§‹åŒ– Person å¯¹è±¡
0x002b 00043      MOVQ    $3, 8(AX)
0x0033 00051      CMPL    runtime.writeBarrier(SB), $0
0x003a 00058      PCDATA  $0, $-2
0x003a 00058      JEQ     64
0x003c 00060      JMP     66
0x003e 00062      NOP
0x0040 00064      JMP     79
0x0042 00066      MOVQ    (AX), CX
0x0045 00069      CALL    runtime.gcWriteBarrier1(SB)
0x004a 00074      MOVQ    CX, (R11)
0x004d 00077      JMP     79
0x004f 00079      LEAQ    go:string."ycz"(SB), CX
0x0056 00086      MOVQ    CX, (AX)

# ... 

# æ¥å£èµ‹å€¼
0x0075 00117      LEAQ    go:itab.*main.Person,main.Animal(SB), CX
# æ›´æ–° itab æŒ‡é’ˆ
0x007c 00124      MOVQ    CX, main.p+24(SP)
# æ›´æ–° data æŒ‡é’ˆ
0x0081 00129      MOVQ    AX, main.p+32(SP)
# è°ƒç”¨ main.(*Person).GetName æ–¹æ³•
0x0086 00134      CALL    main.(*Person).GetName(SB)
0x008b 00139      MOVQ    AX, main..autotmp_2+120(SP)
0x0090 00144      MOVQ    BX, main..autotmp_2+128(SP)
0x0098 00152      MOVUPS  X15, main..autotmp_3+104(SP)
0x009e 00158      LEAQ    main..autotmp_3+104(SP), CX
0x00a3 00163      MOVQ    CX, main..autotmp_7+56(SP)
0x00a8 00168      MOVQ    main..autotmp_2+120(SP), AX
0x00ad 00173      MOVQ    main..autotmp_2+128(SP), BX
0x00b5 00181      PCDATA  $1, $1
# å°†æ–¹æ³•è¿”å›çš„ç»“æœè½¬æ¢ä¸ºå­—ç¬¦ä¸²ç±»å‹
0x00b5 00181      CALL    runtime.convTstring(SB)

# ...

# è¾“å‡ºç»“æœ
0x0120 00288      CALL    fmt.Println(SB)

# åˆ›å»ºå¦ä¸€ä¸ªå¯¹è±¡ Cat
0x0125 00293      LEAQ    type:main.Cat(SB), AX
# åˆ†é…å†…å­˜å¹¶å­˜å‚¨å¯¹è±¡åœ°å€
0x012c 00300      CALL    runtime.newobject(SB)
0x0131 00305      MOVQ    AX, main..autotmp_9+40(SP)
0x0136 00310      MOVQ    $3, 8(AX)
0x013e 00318      CMPL    runtime.writeBarrier(SB), $0
0x0145 00325      PCDATA  $0, $-2
0x0145 00325      JEQ     329
0x0147 00327      JMP     331
0x0149 00329      JMP     344
0x014b 00331      MOVQ    (AX), CX
0x014e 00334      CALL    runtime.gcWriteBarrier1(SB)
0x0153 00339      MOVQ    CX, (R11)
0x0156 00342      JMP     344
0x0158 00344      LEAQ    go:string."ccc"(SB), CX
0x015f 00351      MOVQ    CX, (AX)
0x0162 00354      PCDATA  $0, $-1
0x0162 00354      MOVQ    main..autotmp_9+40(SP), CX
0x0167 00359      TESTB   AL, (CX)
0x0169 00361      MOVQ    $1, 16(CX)
0x0171 00369      MOVQ    main..autotmp_9+40(SP), AX
0x0176 00374      MOVQ    AX, main..autotmp_4+96(SP)
# å°† Cat å¯¹è±¡èµ‹å€¼ç»™æ¥å£å˜é‡
0x017b 00379      LEAQ    go:itab.*main.Cat,main.Animal(SB), CX
# æ›´æ–° itab æŒ‡é’ˆ
0x0182 00386      MOVQ    CX, main.p+24(SP)
# æ›´æ–° data æŒ‡é’ˆ
0x0187 00391      MOVQ    AX, main.p+32(SP)
# è°ƒç”¨ main.(*Cat).GetName æ–¹æ³•
0x018c 00396      CALL    main.(*Cat).GetName(SB)

# ...

# å°†æ–¹æ³•è¿”å›çš„ç»“æœè½¬æ¢ä¸ºå­—ç¬¦ä¸²ç±»å‹
0x01c0 00448      CALL    runtime.convTstring(SB)

# ...

# è¾“å‡ºç»“æœ
0x023a 00570      CALL    fmt.Println(SB)

# å‡½æ•°ç»“æŸï¼Œè¿”å›
0x023f 00575      ADDQ    $184, SP
0x0246 00582      POPQ    BP
0x0247 00583      RET

# ...

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

ä»ä»¥ä¸Šæ±‡ç¼–ä»£ç å°±å¯ä»¥çœ‹å‡ºï¼Œå½“æ¥å£å˜é‡çš„ç±»å‹åˆ‡æ¢æ—¶ä¼šæ›´æ–°
`itab`
æŒ‡é’ˆå’Œ
`data`
æŒ‡é’ˆï¼Œåç»­è°ƒç”¨æ–¹æ³•æ—¶ï¼Œç›´æ¥æ ¹æ®
`itab`
æŒ‡é’ˆæ‰¾åˆ°å¯¹åº”æ–¹æ³•è¡¨ï¼Œå†ä»æ–¹æ³•è¡¨ä¸­æ ¹æ®å‡½æ•°çš„æ¬¡åºå®šä½åˆ°å…·ä½“çš„å‡½æ•°ï¼ˆå¾—åˆ°å‡½æ•°æŒ‡é’ˆï¼‰ï¼Œå†æ ¹æ®å‡½æ•°æŒ‡é’ˆæ‰§è¡Œå…·ä½“çš„æ–¹æ³•ã€‚è¿™ç§æœºåˆ¶ä½¿å¾—æ¥å£å˜é‡å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°åˆ‡æ¢ç±»å‹ï¼ŒåŒæ—¶ä¿æŒé«˜æ•ˆçš„æ€§èƒ½å’Œçµæ´»çš„å¤šæ€æ€§ã€‚

##### ç±»å‹æ–­è¨€

ä¸‹é¢ç»™å‡ºä¸€ä¸ªä½¿ç”¨æ¥å£è¿›è¡Œç±»å‹æ–­è¨€çš„ä¾‹å­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

func someFunction() interface{} {
	return 10
}

func main() {
	var v interface{} = someFunction()
	if i, ok := v.(int); ok {
		print(i) // 10
	}
}

```

å°†ä¸Šé¢çš„ä»£ç ç¼–è¯‘æˆæ±‡ç¼–ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
# ...
# è°ƒç”¨ someFunction å‡½æ•°å¹¶èµ‹å€¼ç»™ v
# AX å¯„å­˜å™¨å­˜å‚¨æ¥å£çš„ç±»å‹ä¿¡æ¯
# BX å¯„å­˜å™¨å­˜å‚¨æ¥å£çš„æ•°æ®æŒ‡é’ˆ
0x0012 00018       CALL    main.someFunction(SB)
0x0017 00023       MOVQ    AX, main.v+40(SP)
0x001c 00028       MOVQ    BX, main.v+48(SP)

# ç±»å‹æ–­è¨€çš„è¿è¡Œæ—¶æ£€æŸ¥
# å°† int ç±»å‹çš„åœ°å€åŠ è½½åˆ°å¯„å­˜å™¨ CX
0x0021 00033       LEAQ    type:int(SB), CX
# æ¯”è¾ƒ v çš„ç±»å‹ä¿¡æ¯ä¸ç›®æ ‡ç±»å‹ int çš„ç±»å‹ä¿¡æ¯
0x0028 00040       CMPQ    AX, CX
# å¦‚æœç±»å‹åŒ¹é…è·³è½¬åˆ°æˆåŠŸåˆ†æ”¯åœ°å€ 47
0x002b 00043       JEQ     47
# å¦‚æœç±»å‹ä¸åŒ¹é…è·³è½¬åˆ°å¤±è´¥åˆ†æ”¯åœ°å€ 57
0x002d 00045       JMP     57

# ç±»å‹æ–­è¨€æˆåŠŸåˆ†æ”¯
# å°† v çš„æ•°æ®æŒ‡é’ˆï¼ˆå­˜å‚¨10ï¼‰æŒ‡å‘çš„å®é™…å€¼åŠ è½½åˆ°å¯„å­˜å™¨ AX
0x002f 00047       MOVQ    (BX), AX
# å°† 1 èµ‹å€¼ç»™å¯„å­˜å™¨ CXï¼Œè¡¨ç¤º ok ä¸º true
0x0032 00050       MOVL    $1, CX
# è·³è½¬åˆ°åç»­çš„èµ‹å€¼é€»è¾‘
0x0037 00055       JMP     63

# ç±»å‹æ–­è¨€å¤±è´¥åˆ†æ”¯
# å°†å¯„å­˜å™¨ AX å’Œ CX æ¸…é›¶
# AX è¡¨ç¤º i çš„å€¼ï¼Œæ¸…é›¶è¡¨ç¤º i ä¸º 0
# CX è¡¨ç¤º ok çš„å€¼ï¼Œæ¸…é›¶è¡¨ç¤º ok ä¸º false
0x0039 00057       XORL    AX, AX
0x003b 00059       XORL    CX, CX
# è·³è½¬åˆ°åç»­çš„èµ‹å€¼é€»è¾‘
0x003d 00061       JMP     63

# å°†å¯„å­˜å™¨ä¸­çš„å€¼èµ‹å€¼ç»™æ ˆä¸Šçš„ä¸´æ—¶å˜é‡ï¼Œæœ€ç»ˆèµ‹å€¼ç»™ i å’Œ ok
# ...
# i çš„å€¼
0x0060 00096       MOVQ    AX, main.i+16(SP)
# ...
# ok çš„å€¼
0x006a 00106       MOVB    AL, main.ok+13(SP)

# æµ‹è¯• ok çš„å€¼
0x006e 00110       TESTB   AL, AL
# å¦‚æœ ok ä¸º trueï¼Œè·³è½¬åˆ°æ‰“å°é€»è¾‘
0x0070 00112       JNE     116
# å¦‚æœ ok ä¸º falseï¼Œè·³è¿‡æ‰“å°é€»è¾‘ï¼Œç›´æ¥ç»“æŸå‡½æ•°
0x0072 00114       JMP     140

# æ‰“å°é€»è¾‘
# å¦‚æœç±»å‹æ–­è¨€æˆåŠŸï¼Œåˆ™è°ƒç”¨ runtime.printint æ‰“å° i çš„å€¼
0x0074 00116       CALL    runtime.printlock(SB)
0x0079 00121       MOVQ    main.i+16(SP), AX
0x007e 00126       NOP
0x0080 00128       CALL    runtime.printint(SB)
0x0085 00133       CALL    runtime.printunlock(SB)

# ç»“æŸå‡½æ•°
# ...
0x008c 00140       JMP     142
0x008e 00142       ADDQ    $56, SP
0x0092 00146       POPQ    BP
0x0093 00147       RET
# ...

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

ä»”ç»†è§‚å¯Ÿç”Ÿæˆçš„æ±‡ç¼–ä»£ç ä¹‹åï¼Œä¸éš¾å‘ç°é—®é¢˜æ‰€åœ¨ï¼šæ±‡ç¼–ä»£ç ä¸­å¹¶æ²¡æœ‰è°ƒç”¨
`getitab`
å‡½æ•°ä»å…¨å±€
`itab`
è¡¨ä¸­è¿›è¡Œè·å–
`itab`
è¿›è¡Œæ¥å£åˆ¤æ–­ã€‚
**ä½†æ˜¯ï¼Œå®é™…ä¸Š
`golang`
ç¼–è¯‘å™¨åœ¨å¤„ç†ç±»å‹æ–­è¨€æ—¶ï¼Œå¯¹äºä¸€äº›ç®€å•çš„æƒ…å†µï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šç›´æ¥å†…è”ç›¸å…³é€»è¾‘ï¼Œç”Ÿæˆæ–­è¨€ç±»å‹ç›®æ ‡çš„ä»£ç ï¼Œä»è€Œç›´æ¥åˆ¤æ–­æ˜¯å¦ä¸æ–­è¨€ç›®æ ‡ç±»å‹æ˜¯å¦åŒ¹é…ï¼Œè€Œä¸æ˜¯è°ƒç”¨
`getitab`
å‡½æ•°ã€‚è¿™æ ·ä¼šå‡å°‘è¿è¡Œæ—¶é¢å¤–çš„å¼€é”€**
ã€‚

å¦‚æœå°†ä»¥ä¸Šç®€å•ç±»å‹æ–­è¨€ä»£ç æ”¹ä¸ºé‡‡ç”¨æ¥å£æ–­è¨€ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

type Animal interface {
	GetName() string
	GetAge() int
	SetName(name string) error
	SetAge(age int) error
}

type Person struct {
	Name string
	Age  int
}

func (p *Person) GetName() string {
	return p.Name
}

func (p *Person) GetAge() int {
	return p.Age
}

func (p *Person) SetName(name string) error {
	p.Name = name
	return nil
}

func (p *Person) SetAge(age int) error {
	p.Age = age
	return nil
}

func main() {
	var p Animal = &Person{Name: "ycz", Age: 18}
	if v, ok := p.(Animal); ok {
		fmt.Printf("%v\n", v)
	}
}

```

å°†ä»¥ä¸Šä»£ç ç¼–è¯‘æˆæ±‡ç¼–ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
# ...

# åˆ›å»º Person å¯¹è±¡
0x001a 00026      LEAQ    type:main.Person(SB), AX
# ...
0x0021 00033      CALL    runtime.newobject(SB)
0x0026 00038      MOVQ    AX, main..autotmp_9+80(SP)
0x002b 00043      MOVQ    $3, 8(AX)

# ...

# åˆå§‹åŒ– Person å¯¹è±¡çš„å­—æ®µ
0x004f 00079      LEAQ    go:string."ycz"(SB), DX
0x0056 00086      MOVQ    DX, (AX)
0x0059 00089      PCDATA  $0, $-1
0x0059 00089      MOVQ    main..autotmp_9+80(SP), DX
0x005e 00094      TESTB   AL, (DX)
0x0060 00096      MOVQ    $18, 16(DX)

# å°† Person å¯¹è±¡èµ‹å€¼ç»™æ¥å£å˜é‡ p
0x0068 00104      MOVQ    main..autotmp_9+80(SP), DX
0x006d 00109      MOVQ    DX, main..autotmp_5+120(SP)
# åŠ è½½ Person ç±»å‹å’Œ Animal æ¥å£çš„ itab åœ°å€åˆ°å¯„å­˜å™¨ R8
0x0072 00114      LEAQ    go:itab.*main.Person,main.Animal(SB), R8
0x0079 00121      MOVQ    R8, main.p+64(SP)
0x007e 00126      MOVQ    DX, main.p+72(SP)


# ç±»å‹æ–­è¨€é€»è¾‘
0x0083 00131      MOVUPS  X15, main..autotmp_6+104(SP)
0x0089 00137      MOVQ    main.p+64(SP), DX
0x008e 00142      MOVQ    main.p+72(SP), R8
# æ£€æŸ¥ç±»å‹ä¿¡æ¯æ˜¯å¦ä¸ºé›¶
0x0093 00147      TESTQ   DX, DX
# å¦‚æœç±»å‹ä¿¡æ¯ä¸ä¸ºé›¶ï¼Œè·³è½¬åˆ°åœ°å€ 154
0x0096 00150      JNE     154
# å¦‚æœç±»å‹ä¿¡æ¯ä¸ºé›¶ï¼Œè·³è½¬åˆ°åœ°å€ 192
0x0098 00152      JMP     192

# è°ƒç”¨ runtime.typeAssert è¿›è¡Œç±»å‹æ–­è¨€
0x009a 00154      MOVQ    R8, main..autotmp_14+144(SP)
0x00a2 00162      MOVQ    8(DX), BX
0x00a6 00166      LEAQ    main..typeAssert.0(SB), AX
0x00ad 00173      PCDATA  $1, $1
0x00ad 00173      CALL    runtime.typeAssert(SB)
0x00b2 00178      MOVQ    main..autotmp_14+144(SP), R8
0x00ba 00186      MOVQ    AX, DX
0x00bd 00189      JMP     194
0x00bf 00191      NOP

# ç±»å‹æ–­è¨€ç»“æœå¤„ç†
# ... 

# å‡½æ•°ç»“æŸï¼Œè¿”å›
0x0209 00521      ADDQ    $208, SP
0x0210 00528      POPQ    BP
0x0211 00529      RET
# ...

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

æ±‡ç¼–ä»£ç ä¸­æœ€ä¸ºå…³é”®çš„ä¸€æ­¥å°±æ˜¯è¿è¡Œæ—¶è°ƒç”¨äº†
`typeAssert`
è¿›è¡Œç±»å‹æ–­è¨€ï¼Œé‚£ä¹ˆä¸‹é¢ç»§ç»­è·Ÿè¸ªæºç ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// typeAssert builds an itab for the concrete type t and the
// interface type s.Inter. If the conversion is not possible it
// panics if s.CanFail is false and returns nil if s.CanFail is true.
func typeAssert(s *abi.TypeAssert, t *_type) *itab {
	var tab *itab
    // å¦‚æœå…·ä½“ç±»å‹ t ä¸º nilï¼Œå¹¶ä¸” s.CanFail ä¸º falseï¼Œåˆ™æŠ›å‡ºç±»å‹æ–­è¨€é”™è¯¯
	if t == nil {
		if !s.CanFail {
			panic(&TypeAssertionError{nil, nil, &s.Inter.Type, ""})
		}
	} else {
        // å…·ä½“ç±»å‹ t ä¸ä¸º nilï¼Œåˆ™è°ƒç”¨ getitab å‡½æ•°ï¼Œå°è¯•è·å–æˆ–ç”Ÿæˆä¸€ä¸ª itab
		tab = getitab(s.Inter, t, s.CanFail)
	}

    // å¦‚æœå½“å‰æ¶æ„ä¸æ”¯æŒæ¥å£åˆ‡æ¢ç¼“å­˜ï¼Œåˆ™ç›´æ¥è¿”å› itab
	if !abi.UseInterfaceSwitchCache(GOARCH) {
		return tab
	}

	// Maybe update the cache, so the next time the generated code
	// doesn't need to call into the runtime.
    // ä½¿ç”¨ cheaprand ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œåªæœ‰å½“éšæœºæ•°æ»¡è¶³æ¡ä»¶æ—¶ï¼Œæ‰å°è¯•æ›´æ–°ç¼“å­˜
    // è¿™æ˜¯ä¸ºäº†å‡å°‘æ›´æ–°ç¼“å­˜çš„é¢‘ç‡ï¼Œé¿å…é¢‘ç¹æ›´æ–°å¸¦æ¥çš„æ€§èƒ½å¼€é”€
	if cheaprand()&1023 != 0 {
		// Only bother updating the cache ~1 in 1000 times.
		return tab
	}
    
    // ä¸‹é¢æ˜¯æ›´æ–°ç¼“å­˜çš„é€»è¾‘
    
	// Load the current cache.
	oldC := (*abi.TypeAssertCache)(atomic.Loadp(unsafe.Pointer(&s.Cache)))

	if cheaprand()&uint32(oldC.Mask) != 0 {
		// As cache gets larger, choose to update it less often
		// so we can amortize the cost of building a new cache.
		return tab
	}
    
    // å½“ä»£ç è¿è¡Œåˆ°è¿™ä¸€æ­¥çš„æ—¶å€™ï¼Œå°±éœ€è¦æ„å»ºä¸€ä¸ªæ–°çš„æ¥å£åˆ‡æ¢ç¼“å­˜å®ä¾‹

	// Make a new cache.
    // è°ƒç”¨ buildTypeAssertCache å‡½æ•°ï¼Œæ ¹æ®å½“å‰ç¼“å­˜ oldCã€å…·ä½“ç±»å‹ t å’Œ itab æ„å»ºä¸€ä¸ªæ–°çš„ç¼“å­˜
	newC := buildTypeAssertCache(oldC, t, tab)

	// Update cache. Use compare-and-swap so if multiple threads
	// are fighting to update the cache, at least one of their
	// updates will stick.
    // ä½¿ç”¨åŸå­æ“ä½œæ›´æ–°ç¼“å­˜
	atomic_casPointer((*unsafe.Pointer)(unsafe.Pointer(&s.Cache)), unsafe.Pointer(oldC), unsafe.Pointer(newC))

	return tab
}

```

`TypeAssertCache`
ç”¨äºä¼˜åŒ–ç±»å‹æ–­è¨€çš„æ€§èƒ½ã€‚ç¼“å­˜å…·ä½“ç±»å‹å’Œå¯¹åº”çš„
`itab`
ï¼Œä»¥ä¾¿å¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªæ¥å£å˜é‡æ˜¯å¦å¯ä»¥æ–­è¨€ä¸ºæŸä¸ªå…·ä½“ç±»å‹ã€‚ä¸‹é¢ä»‹ç»ä¸‰ä¸ªæ ¸å¿ƒçš„ç¼“å­˜ç»“æ„ä½“ï¼š
`TypeAssert`
ã€
`TypeAssertCache`
ã€
`TypeAssertCacheEntry`
ã€‚

###### `TypeAssert`

> æºç ä½ç½®ï¼šsrc/internal/abi/switch.go

```go
type TypeAssert struct {
	Cache   *TypeAssertCache
	Inter   *InterfaceType
	CanFail bool
}

```

* `Cache`
  ï¼šæŒ‡å‘
  `TypeAssertCache`
  ï¼Œè¿™æ˜¯ä¸€ä¸ªç¼“å­˜ç»“æ„ï¼Œç”¨äºå­˜å‚¨ç±»å‹æ–­è¨€çš„ç»“æœã€‚ç¼“å­˜çš„ç›®çš„æ˜¯å‡å°‘è¿è¡Œæ—¶çš„é‡å¤è®¡ç®—ï¼Œæé«˜ç±»å‹æ–­è¨€çš„æ€§èƒ½ã€‚
* `Inter`
  ï¼šæŒ‡å‘
  `InterfaceType`
  ï¼Œè¡¨ç¤ºç›®æ ‡æ¥å£ç±»å‹ã€‚è¿™ä¸ªå­—æ®µç”¨äºè®°å½•ç±»å‹æ–­è¨€çš„ç›®æ ‡æ¥å£ç±»å‹ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚
* `CanFail`
  ï¼šå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºç±»å‹æ–­è¨€æ˜¯å¦å…è®¸å¤±è´¥ã€‚å¦‚æœ
  `CanFail`
  ä¸º
  `true`
  ï¼Œç±»å‹æ–­è¨€å¤±è´¥æ—¶ä¼šè¿”å›
  `nil`
  ï¼›å¦‚æœ
  `CanFail`
  ä¸º
  `false`
  ï¼Œç±»å‹æ–­è¨€å¤±è´¥æ—¶ä¼šæŠ›å‡ºé”™è¯¯ã€‚

###### `TypeAssertCache`

> æºç ä½ç½®ï¼šsrc/internal/abi/switch.go

```go
type TypeAssertCache struct {
	Mask    uintptr
	Entries [1]TypeAssertCacheEntry
}

```

* `Mask`
  ï¼šç”¨äºè®¡ç®—ç¼“å­˜çš„å¤§å°å’Œç´¢å¼•ã€‚ç¼“å­˜çš„å¤§å°å§‹ç»ˆæ˜¯ 2 çš„å¹‚ï¼Œ
  `Mask`
  çš„å€¼ä¸º
  `size - 1`
  ï¼Œç”¨äºå¿«é€Ÿè®¡ç®—ç´¢å¼•ã€‚
* `Entries`
  ï¼šç¼“å­˜æ¡ç›®æ•°ç»„ï¼Œåˆå§‹å¤§å°ä¸º 1ã€‚æ¯ä¸ªæ¡ç›®æ˜¯ä¸€ä¸ª
  `TypeAssertCacheEntry`
  ï¼Œå­˜å‚¨äº†å…·ä½“ç±»å‹å’Œå¯¹åº”çš„
  `itab`
  ã€‚

###### `TypeAssertCacheEntry`

> æºç ä½ç½®ï¼šsrc/internal/abi/switch.go

```go
type TypeAssertCacheEntry struct {
	// type of source value (a *runtime._type)
	Typ uintptr
	// itab to use for result (a *runtime.itab)
	// nil if CanFail is set and conversion would fail.
	Itab uintptr
}

```

* `Typ`
  ï¼šå…·ä½“ç±»å‹çš„æŒ‡é’ˆã€‚ç”¨äºè®°å½•å…·ä½“ç±»å‹çš„ä¿¡æ¯ï¼Œä»¥ä¾¿åœ¨ç±»å‹æ–­è¨€æ—¶è¿›è¡Œæ¯”è¾ƒã€‚
* `Itab`
  ï¼š
  `itab`
  çš„æŒ‡é’ˆã€‚å¦‚æœ
  `CanFail`
  ä¸º
  `true`
  ä¸”ç±»å‹è½¬æ¢å¤±è´¥ï¼Œåˆ™ä¸º
  `nil`
  ã€‚ç”¨äºè®°å½•å…·ä½“ç±»å‹å’Œæ¥å£ç±»å‹çš„æ˜ å°„å…³ç³»ï¼Œä»¥ä¾¿åœ¨ç±»å‹æ–­è¨€æ—¶å¿«é€ŸæŸ¥æ‰¾ã€‚

###### `buildTypeAssertCache`

æ„å»ºç±»å‹æ–­è¨€ç¼“å­˜ï¼Œæºç å¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
func buildTypeAssertCache(oldC *abi.TypeAssertCache, typ *_type, tab *itab) *abi.TypeAssertCache {
    // å°†æ—§ç¼“å­˜çš„æ¡ç›®è½¬æ¢ä¸ºä¸€ä¸ªåˆ‡ç‰‡ï¼ŒåŒ…å«æ‰€æœ‰æ—§çš„ç¼“å­˜æ¡ç›®
	oldEntries := unsafe.Slice(&oldC.Entries[0], oldC.Mask+1)

	// Count the number of entries we need.
    // è®¡ç®—æ—§ç¼“å­˜ä¸­éç©ºæ¡ç›®çš„æ•°é‡ï¼ŒåŠ ä¸Šä¸€ä¸ªé¢å¤–çš„æ¡ç›®ç”¨äºç»ˆæ­¢
	n := 1
	for _, e := range oldEntries {
		if e.Typ != 0 {
			n++
		}
	}

	// Figure out how big a table we need.
	// We need at least one more slot than the number of entries
	// so that we are guaranteed an empty slot (for termination).
    // æ–°ç¼“å­˜çš„å¤§å°ï¼Œé€šå¸¸æ˜¯æ—§ç¼“å­˜å¤§å°çš„ä¸¤å€ï¼Œç¡®ä¿æ–°ç¼“å­˜çš„è´Ÿè½½å› å­ä¸è¶…è¿‡ 50%
	newN := n * 2                         // make it at most 50% full
    // è®¡ç®— newN-1 çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„ä½æ•°ï¼Œç¡®ä¿æ–°ç¼“å­˜å¤§å°æ˜¯ 2 çš„å¹‚
	newN = 1 << sys.Len64(uint64(newN-1)) // round up to a power of 2

	// Allocate the new table.
    // è®¡ç®—æ–°ç¼“å­˜çš„æ€»å¤§å°ï¼ŒåŒ…æ‹¬ TypeAssertCache ç»“æ„ä½“å’Œæ‰€æœ‰æ¡ç›®çš„å¤§å°
	newSize := unsafe.Sizeof(abi.TypeAssertCache{}) + uintptr(newN-1)*unsafe.Sizeof(abi.TypeAssertCacheEntry{})
    // åˆ†é…å†…å­˜
	newC := (*abi.TypeAssertCache)(mallocgc(newSize, nil, true))
    // è®¾ç½®æ–°ç¼“å­˜çš„æ©ç ï¼Œç”¨äºè®¡ç®—å“ˆå¸Œå€¼
	newC.Mask = uintptr(newN - 1)
    // å°†æ–°ç¼“å­˜çš„æ¡ç›®è½¬æ¢ä¸ºä¸€ä¸ªåˆ‡ç‰‡
	newEntries := unsafe.Slice(&newC.Entries[0], newN)

	// Fill the new table.
    // å°†æ–°çš„ç¼“å­˜æ¡ç›®æ·»åŠ åˆ°æ–°ç¼“å­˜ä¸­
	addEntry := func(typ *_type, tab *itab) {
		h := int(typ.Hash) & (newN - 1)
		for {
			if newEntries[h].Typ == 0 {
				newEntries[h].Typ = uintptr(unsafe.Pointer(typ))
				newEntries[h].Itab = uintptr(unsafe.Pointer(tab))
				return
			}
			h = (h + 1) & (newN - 1)
		}
	}
    // éå†æ—§ç¼“å­˜çš„æ¡ç›®ï¼Œå°†éç©ºæ¡ç›®å¤åˆ¶åˆ°æ–°ç¼“å­˜ä¸­
	for _, e := range oldEntries {
		if e.Typ != 0 {
			addEntry((*_type)(unsafe.Pointer(e.Typ)), (*itab)(unsafe.Pointer(e.Itab)))
		}
	}
    // è°ƒç”¨ä¸Šé¢çš„ addEntry å‡½æ•°ï¼Œå°†æ–°çš„ç¼“å­˜æ¡ç›®æ·»åŠ åˆ°æ–°ç¼“å­˜ä¸­
	addEntry(typ, tab)
	
    // è¿”å›æ–°çš„ç¼“å­˜ç¤ºä¾‹
	return newC
}

```

##### ç±»å‹åˆ‡æ¢

åŸºäºç±»å‹åˆ‡æ¢å°ç»“ä¸­çš„ä»£ç ï¼Œå†ç»™å‡ºä¸€æ®µæ¥å£ç±»å‹åˆ‡æ¢çš„ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

type Animal interface {
	GetName() string
	GetAge() int
	SetName(name string) error
	SetAge(age int) error
}

type Person struct {
	Name string
	Age  int
}

func (p *Person) GetName() string {
	return p.Name
}

func (p *Person) GetAge() int {
	return p.Age
}

func (p *Person) SetName(name string) error {
	p.Name = name
	return nil
}

func (p *Person) SetAge(age int) error {
	p.Age = age
	return nil
}

func main() {
	var p Animal = &Person{Name: "ycz", Age: 18}
	switch p := p.(type) {
	case Animal:
		fmt.Printf("%v\n", p)
	default:
		fmt.Printf("default")
	}
}

```

å°†ä»¥ä¸Šä»£ç ç¼–è¯‘æˆæ±‡ç¼–ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
# ...

# åˆ›å»º Person å¯¹è±¡
0x001a 00026      LEAQ    type:main.Person(SB), AX
# ...
0x0021 00033      CALL    runtime.newobject(SB)
0x0026 00038      MOVQ    AX, main..autotmp_5+136(SP)
0x002e 00046      MOVQ    $3, 8(AX)

# ...

# åˆå§‹åŒ– Person å¯¹è±¡çš„å­—æ®µ
0x0051 00081      LEAQ    go:string."ycz"(SB), CX
0x0058 00088      MOVQ    CX, (AX)
0x005b 00091      PCDATA  $0, $-1
0x005b 00091      MOVQ    main..autotmp_5+136(SP), CX
0x0063 00099      TESTB   AL, (CX)
0x0065 00101      MOVQ    $18, 16(CX)
0x006d 00109      MOVQ    main..autotmp_5+136(SP), CX
0x0075 00117      MOVQ    CX, main..autotmp_3+160(SP)
# åŠ è½½ Person ç±»å‹å’Œ Animal æ¥å£çš„ itab åœ°å€åˆ°å¯„å­˜å™¨ DX
0x007d 00125      LEAQ    go:itab.*main.Person,main.Animal(SB), DX
0x0084 00132      MOVQ    DX, main.p+96(SP)
0x0089 00137      MOVQ    CX, main.p+104(SP)

# ...

# ç±»å‹æ–­è¨€é€»è¾‘
# åŠ è½½ Person ç±»å‹å’Œ Animal æ¥å£çš„ itab åœ°å€åˆ°å¯„å­˜å™¨ CX
0x009d 00157      MOVL    go:itab.*main.Person,main.Animal+16(SB), CX
0x00a3 00163      MOVL    CX, main..autotmp_9+44(SP)
0x00a7 00167      MOVQ    main..autotmp_6+120(SP), CX
0x00ac 00172      MOVQ    8(CX), BX
# åŠ è½½ç±»å‹æ–­è¨€çš„é”™è¯¯ä¿¡æ¯åœ°å€åˆ°å¯„å­˜å™¨ AX
0x00b0 00176      LEAQ    main..interfaceSwitch.0(SB), AX
0x00b7 00183      PCDATA  $1, $1
# è°ƒç”¨è¿è¡Œæ—¶çš„ interfaceSwitch å‡½æ•°ï¼Œè¿›è¡Œæ¥å£åˆ‡æ¢
0x00b7 00183      CALL    runtime.interfaceSwitch(SB)
0x00bc 00188      MOVQ    AX, main..autotmp_10+56(SP)
0x00c1 00193      MOVQ    BX, main..autotmp_8+112(SP)

# ç±»å‹æ–­è¨€ç»“æœå¤„ç†
# ...

# å‡½æ•°ç»“æŸï¼Œè¿”å›
0x023e 00574      ADDQ    $232, SP
0x0245 00581      POPQ    BP
0x0246 00582      RET
# ...

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

æ±‡ç¼–ä»£ç ä¸­æœ€ä¸ºå…³é”®çš„ä¸€æ­¥å°±æ˜¯è¿è¡Œæ—¶è°ƒç”¨äº†
`interfaceSwitch`
è¿›è¡Œæ¥å£ç±»å‹åˆ‡æ¢ï¼Œé‚£ä¹ˆä¸‹é¢ç»§ç»­è·Ÿè¸ªæºç ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// interfaceSwitch compares t against the list of cases in s.
// If t matches case i, interfaceSwitch returns the case index i and
// an itab for the pair <t, s.Cases[i]>.
// If there is no match, return N,nil, where N is the number
// of cases.
func interfaceSwitch(s *abi.InterfaceSwitch, t *_type) (int, *itab) {
    // å°† s.Cases è½¬æ¢ä¸ºä¸€ä¸ªåˆ‡ç‰‡ï¼ŒåŒ…å«æ‰€æœ‰åˆ†æ”¯çš„æ¥å£ç±»å‹
	cases := unsafe.Slice(&s.Cases[0], s.NCases)

	// Results if we don't find a match.
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¡¹ï¼Œè¿”å›çš„åˆ†æ”¯ç´¢å¼•
	case_ := len(cases)
	var tab *itab

	// Look through each case in order.
    // éå†æ‰€æœ‰åˆ†æ”¯ï¼Œè°ƒç”¨ getitab æ£€æŸ¥å…·ä½“ç±»å‹ t æ˜¯å¦åŒ¹é…å½“å‰åˆ†æ”¯çš„æ¥å£ç±»å‹ c
	for i, c := range cases {
		tab = getitab(c, t, true)
        // å¦‚æœæ‰¾åˆ°åŒ¹é…é¡¹ï¼Œæ›´æ–° case_ å’Œ tabï¼Œå¹¶é€€å‡ºå¾ªç¯
		if tab != nil {
			case_ = i
			break
		}
	}
	
    // å¦‚æœä¸æ”¯æŒæ¥å£åˆ‡æ¢ç¼“å­˜ï¼Œåˆ™ç›´æ¥è¿”å›ç»“æœ
	if !abi.UseInterfaceSwitchCache(GOARCH) {
		return case_, tab
	}

	// Maybe update the cache, so the next time the generated code
	// doesn't need to call into the runtime.
    // ä½¿ç”¨ cheaprand() ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œåªæœ‰å½“éšæœºæ•°æ»¡è¶³æ¡ä»¶æ—¶ï¼Œæ‰å°è¯•æ›´æ–°ç¼“å­˜
    // é¿å…é¢‘ç¹æ›´æ–°å¸¦æ¥çš„æ€§èƒ½å¼€é”€
	if cheaprand()&1023 != 0 {
		// Only bother updating the cache ~1 in 1000 times.
		// This ensures we don't waste memory on switches, or
		// switch arguments, that only happen a few times.
		return case_, tab
	}
    // ä½¿ç”¨åŸå­æ“ä½œåŠ è½½å½“å‰çš„æ¥å£åˆ‡æ¢ç¼“å­˜ s.Cache
	// Load the current cache.
	oldC := (*abi.InterfaceSwitchCache)(atomic.Loadp(unsafe.Pointer(&s.Cache)))

	if cheaprand()&uint32(oldC.Mask) != 0 {
		// As cache gets larger, choose to update it less often
		// so we can amortize the cost of building a new cache
		// (that cost is linear in oldc.Mask).
		return case_, tab
	}

   	// è°ƒç”¨ buildInterfaceSwitchCache å‡½æ•°ï¼Œæ ¹æ®å½“å‰ç¼“å­˜ oldCã€å…·ä½“ç±»å‹ tã€åŒ¹é…çš„åˆ†æ”¯ç´¢å¼• case_ å’Œ itab æ„å»ºä¸€ä¸ªæ–°çš„ç¼“å­˜
	// Make a new cache.
	newC := buildInterfaceSwitchCache(oldC, t, case_, tab)

	// Update cache. Use compare-and-swap so if multiple threads
	// are fighting to update the cache, at least one of their
	// updates will stick.
    // ä½¿ç”¨åŸå­æ“ä½œæ›´æ–°ç¼“å­˜
	atomic_casPointer((*unsafe.Pointer)(unsafe.Pointer(&s.Cache)), unsafe.Pointer(oldC), unsafe.Pointer(newC))

	return case_, tab
}

```

`interfaceSwitch`
åŒæ ·åšäº†ç¼“å­˜ä¼˜åŒ–ï¼Œç±»ä¼¼äº
`TypeAssert`
ä¹Ÿæœ‰ä¸‰ä¸ªé‡è¦çš„ç»“æ„ä½“ï¼š
`InterfaceSwitch`
ã€
`InterfaceSwitchCache`
ã€
`InterfaceSwitchCacheEntry`
ã€‚

###### `InterfaceSwitch`

> æºç ä½ç½®ï¼šsrc/internal/abi/switch.go

```go
type InterfaceSwitch struct {
	Cache  *InterfaceSwitchCache
	NCases int

	// Array of NCases elements.
	// Each case must be a non-empty interface type.
	Cases [1]*InterfaceType
}

```

* `Cache`
  ï¼šæŒ‡å‘
  `InterfaceSwitchCache`
  ï¼Œç”¨äºç¼“å­˜æ¥å£åˆ‡æ¢çš„ç»“æœã€‚
* `NCases`
  ï¼šåˆ†æ”¯çš„æ•°é‡ã€‚
* `Cases`
  ï¼šæ¥å£ç±»å‹æ•°ç»„ï¼Œå­˜å‚¨æ‰€æœ‰å¯èƒ½çš„åˆ†æ”¯ã€‚

###### `InterfaceSwitchCache`

> æºç ä½ç½®ï¼šsrc/internal/abi/switch.go

```go
type InterfaceSwitchCache struct {
	Mask    uintptr                      // mask for index. Must be a power of 2 minus 1
	Entries [1]InterfaceSwitchCacheEntry // Mask+1 entries total
}

```

* `Mask`
  ï¼šæ©ç ï¼Œç”¨äºè®¡ç®—ç¼“å­˜ç´¢å¼•ã€‚
* `Entries`
  ï¼šç¼“å­˜æ¡ç›®æ•°ç»„ï¼Œå­˜å‚¨å…·ä½“ç±»å‹å’Œå¯¹åº”çš„åˆ†æ”¯ç´¢å¼•ã€‚

###### `InterfaceSwitchCacheEntry`

> æºç ä½ç½®ï¼šsrc/internal/abi/switch.go

```go
type InterfaceSwitchCacheEntry struct {
	// type of source value (a *Type)
	Typ uintptr
	// case # to dispatch to
	Case int
	// itab to use for resulting case variable (a *runtime.itab)
	Itab uintptr
}

```

* `Typ`
  ï¼šå…·ä½“ç±»å‹çš„æŒ‡é’ˆã€‚ç”¨äºè®°å½•å…·ä½“ç±»å‹çš„ä¿¡æ¯ï¼Œä»¥ä¾¿åœ¨æ¥å£åˆ‡æ¢æ—¶è¿›è¡Œç±»å‹åŒ¹é…ã€‚
* `Case`
  ï¼šåŒ¹é…çš„åˆ†æ”¯ç´¢å¼•ã€‚è¡¨ç¤ºåœ¨æ¥å£åˆ‡æ¢ä¸­ï¼Œå…·ä½“ç±»å‹åŒ¹é…çš„åˆ†æ”¯ç¼–å·ã€‚
* `Itab`
  ï¼š
  `itab`
  çš„æŒ‡é’ˆã€‚ç”¨äºè®°å½•å…·ä½“ç±»å‹å’Œæ¥å£ç±»å‹çš„æ˜ å°„å…³ç³»ï¼Œä»¥ä¾¿åœ¨æ¥å£åˆ‡æ¢æ—¶å¿«é€ŸæŸ¥æ‰¾å’Œä½¿ç”¨ã€‚

###### `buildInterfaceSwitchCache`

æ„å»ºç±»å‹åˆ‡æ¢ç¼“å­˜ï¼Œæºç å¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/iface.go

```go
// buildInterfaceSwitchCache constructs an interface switch cache
// containing all the entries from oldC plus the new entry
// (typ,case_,tab).
func buildInterfaceSwitchCache(oldC *abi.InterfaceSwitchCache, typ *_type, case_ int, tab *itab) *abi.InterfaceSwitchCache {
    // å°†æ—§ç¼“å­˜çš„æ¡ç›®è½¬æ¢ä¸ºä¸€ä¸ªåˆ‡ç‰‡ï¼ŒåŒ…å«æ‰€æœ‰æ—§çš„ç¼“å­˜æ¡ç›®
	oldEntries := unsafe.Slice(&oldC.Entries[0], oldC.Mask+1)

	// Count the number of entries we need.
	n := 1
    // éå†æ—§ç¼“å­˜æ¡ç›®ï¼Œç»Ÿè®¡éç©ºæ¡ç›®æ•°é‡
    // æ–°ç¼“å­˜éœ€è¦åŒ…å«æ—§ç¼“å­˜çš„æ‰€æœ‰æ¡ç›®ï¼Œå†åŠ ä¸Šä¸€ä¸ªæ–°æ¡ç›®
	for _, e := range oldEntries {
		if e.Typ != 0 {
			n++
		}
	}

	// Figure out how big a table we need.
	// We need at least one more slot than the number of entries
	// so that we are guaranteed an empty slot (for termination).
    // æ–°ç¼“å­˜çš„å¤§å°è‡³å°‘æ˜¯æ¡ç›®æ•°é‡çš„ä¸¤å€ï¼Œä¿è¯å“ˆå¸Œè¡¨çš„è´Ÿè½½ç‡ä¸è¶…è¿‡ 50%
    // ç¡®ä¿å“ˆå¸Œè¡¨å¤§å°æ˜¯ 2 çš„æ•´æ•°æ¬¡å¹‚
	newN := n * 2                         // make it at most 50% full
	newN = 1 << sys.Len64(uint64(newN-1)) // round up to a power of 2

	// Allocate the new table.
    // è®¡ç®—æ–°ç¼“å­˜çš„æ€»å¤§å°ï¼ŒåŒ…æ‹¬ InterfaceSwitchCache ç»“æ„ä½“å’Œæ¡ç›®æ•°ç»„
	newSize := unsafe.Sizeof(abi.InterfaceSwitchCache{}) + uintptr(newN-1)*unsafe.Sizeof(abi.InterfaceSwitchCacheEntry{})
    // åˆ†é…å†…å­˜
	newC := (*abi.InterfaceSwitchCache)(mallocgc(newSize, nil, true))
    // åˆå§‹åŒ–æ–°ç¼“å­˜çš„æ©ç 
	newC.Mask = uintptr(newN - 1)
    // åˆå§‹åŒ–æ¡ç›®æ•°ç»„
	newEntries := unsafe.Slice(&newC.Entries[0], newN)

	// Fill the new table.
    // å°†æ–°çš„ç¼“å­˜æ¡ç›®æ·»åŠ åˆ°æ–°ç¼“å­˜ä¸­
	addEntry := func(typ *_type, case_ int, tab *itab) {
		h := int(typ.Hash) & (newN - 1)
		for {
			if newEntries[h].Typ == 0 {
				newEntries[h].Typ = uintptr(unsafe.Pointer(typ))
				newEntries[h].Case = case_
				newEntries[h].Itab = uintptr(unsafe.Pointer(tab))
				return
			}
			h = (h + 1) & (newN - 1)
		}
	}
    
    // éå†æ—§ç¼“å­˜çš„æ‰€æœ‰æ¡ç›®ï¼Œå°†éç©ºæ¡ç›®å¤åˆ¶åˆ°æ–°ç¼“å­˜
	for _, e := range oldEntries {
		if e.Typ != 0 {
			addEntry((*_type)(unsafe.Pointer(e.Typ)), e.Case, (*itab)(unsafe.Pointer(e.Itab)))
		}
	}
    // è°ƒç”¨ä¸Šé¢çš„ addEntry å‡½æ•°ï¼Œæœ€åæ’å…¥æ–°æ¡ç›®
	addEntry(typ, case_, tab)
	
    // è¿”å›æ„å»ºå¥½çš„æ–°ç¼“å­˜
	return newC
}

```

ğŸŒºğŸŒºğŸŒºæ’’èŠ±ï¼

å¦‚æœæœ¬æ–‡å¯¹ä½ æœ‰å¸®åŠ©ï¼Œå°±ç‚¹å…³æ³¨æˆ–è€…ç•™ä¸ªğŸ‘
  
å¦‚æœæ‚¨æœ‰ä»»ä½•æŠ€æœ¯é—®é¢˜æˆ–è€…éœ€è¦æ›´å¤šå…¶ä»–çš„å†…å®¹ï¼Œè¯·éšæ—¶å‘æˆ‘æé—®ã€‚
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/3734a0d4d24847a6ad83ea7ad3b1a2c6.png)