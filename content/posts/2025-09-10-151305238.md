---
layout: post
title: "51单片机4温度传感器DS18B20"
date: 2025-09-10T01:48:54+0800
description: "本文介绍了DS18B20数字温度传感器的工作原理及单片机控制方法。DS18B20通过单总线接口(DQ)与单片机通信，提供9位温度数据。核心操作流程包括：复位、跳过ROM(0xCC)、启动转换(0x44)、读取温度(0xBE)等命令。详细解析了复位、写时序和读时序的操作方法，并提供了相应的C语言实现代码。其中，复位需拉低480-960μs后检测应答；写0/1和读0/1都有特定的时序要求。最后给出了完整的温度采集函数get_temp()和主程序示例，通过串口输出实测温度值。"
keywords: "51单片机4（温度传感器DS18B20）"
categories: ['未分类']
tags: ['算法', '开发语言', '嵌入式硬件', '单片机', '51单片机']
artid: "151305238"
arturl: "https://blog.csdn.net/2401_89312016/article/details/151305238"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151305238
    alt: "51单片机4温度传感器DS18B20"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151305238
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151305238
cover: https://bing.ee123.net/img/rand?artid=151305238
image: https://bing.ee123.net/img/rand?artid=151305238
img: https://bing.ee123.net/img/rand?artid=151305238
---



# 51单片机4（温度传感器DS18B20）

![](https://i-operation.csdnimg.cn/images/cf31225e169b4512917b2e77694eb0a2.png)DS18B20温度传感器工作原理与操作流程

## **1.DS18B20工作原理**

        DS18B20数字温度计提供九位温度度数，指示器件的温度。

![](https://i-blog.csdnimg.cn/direct/051a2b7e4b13476983e47fa982e6a215.png)

                （单片机上的接口）                                                （DS18B20模块）

按照IO<--->DQ链接，即可实现单片机对其的控制。

![](https://i-blog.csdnimg.cn/direct/fb4ab086d7834c33ab3f83a72a60aa41.png)

### 1.1DS18B20命令集

![](https://i-blog.csdnimg.cn/direct/e5c61bb8de6f44a3abd6cebb6399ce3a.png)

### 1.2DS18B20操作流程

![](https://i-blog.csdnimg.cn/direct/d13028d4eb7548bcb25402313768bdb4.png)

(1)复位  
(2)51单片机发送0xCC，代表跳过ROM  
(3)51单片机发送0x44，代表ds18b20开启温度转换  
(4)延时等待(1s)  
(5)复位  
(6)51单片机发送0xCC，代表跳过ROM  
(7)51单片机发送0xBE，代表读取ds18b20发送过来的温度值  
(8)读取温度数据

**每次和ds18b20通信前必须先复位！**

#### 1.2.1复位时序

![](https://i-blog.csdnimg.cn/direct/3d2b550715d24e26a30e555f2ada3a9f.png)

        最开始是高电平，主机将其由高电平拉低为低电平，持续480-960微秒，意味着单片机向ds18b20发送了一个复位信号，询问其是否存在。主机再将电平拉高，等待15-60微秒。若引脚一直为高电平，则表示ds18b20不存在，若电平被ds18b20拉低，则表示其存在。

根据时序图，我们可以写出复位函数：

```

#include <reg51.h>
#include "delay.h"

#define DQ_HIGH ((P3 |= (1 << 7)))//P37置高电平
#define DQ_DOWN ((P3 &= ~(1 << 7)))
#define DQ_CHECK ((P3 & (1 << 7)) != 0)

// ds18b20 复位函数
int ds18b20_Reset(void)
{
   int t = 0;

   DQ_DOWN;
   Delay10us(70);
   DQ_HIGH;
   Delay10us(5);

   // 等待ds18b20发送存在脉冲：低电平到来
   while (DQ_CHECK && t < 30)
   {
   	   Delay10us(1);
	   t++;
   }
   if (t >= 30)
   {
   		return 0;
   }

   // 等待ds18b20将DQ引脚拉高: 高电平到来
   t = 0;
   while (!DQ_CHECK && t < 30)
   {
   	   Delay10us(1);
	   t++;
   }
   if (t >= 30)
   {
   		return 0;
   }

   	return 1;
}
```

#### 1.2.2写时序

![](https://i-blog.csdnimg.cn/direct/780af70e54164544a00b3d9c79534bf3.png)

                                                                (写0和写1)

写0：单片机将电平拉低，ds18b20采样到低电平，说明单片机向传感器写入1

写1：单片机先将电平拉低至少1us后再缓慢拉高，ds18b20检测到高电平，说明单片机向传感器写入0

由写时序编写代码：

```

// 向ds18b20发送一个字节数据
void write_ds18b20(unsigned char dat)	
{
	  int i = 0;

	  // 循环判断要发送的数据中的8bit是1还是0
	  for (i = 0; i < 8; i++)
	  {
	  		if (dat & 1)	//bit1	  
			{
			   DQ_DOWN;
			   _nop_();
			   _nop_();
			   DQ_HIGH;
			   Delay10us(5);
			}
			else	  		// bit0
			{
			  	DQ_DOWN;
				Delay10us(5);
				DQ_HIGH;
			}

			dat >>= 1;
	  }
}
```

#### 1.2.3读时序

![](https://i-blog.csdnimg.cn/direct/8a05b153490f49d0ab10747fa43e0012.png)

                                                                （读0和写0）

读0：单片机将高电平拉低，15us内单片机采样，若检测到低电平，则单片机读取到0

读1：单片机将高电平拉为低电平至少1us，再将电平拉高，15us内单片机采样，若检测到高电平则读取到1

由读时序编写代码：

```

// 从ds18b20读取一个字节数据
unsigned char read_ds18b20(void)
{
	int i = 0;
	unsigned char ret = 0;

	for (i = 0; i < 8; i++)
	{
		DQ_DOWN;		  
		_nop_();
		_nop_();
		DQ_HIGH;
		_nop_();
		_nop_();
		_nop_();

		if (DQ_CHECK)	    // ds18b20发送一个bit1
		{
			ret |= (1 << i);	
		}
	   Delay10us(5);
	}

	return ret;
}

```

1.2.4获取ds18b20采集到的温度：

```

// 获取ds18b20采集到的温度
float get_temp(void)
{
  	short ret = 0;
	unsigned char tl = 0;
	unsigned char th = 0;

	ds18b20_Reset();
	write_ds18b20(0xCC);
	write_ds18b20(0x44);
	Delay1ms(1000);
	ds18b20_Reset();
	write_ds18b20(0xCC);
	write_ds18b20(0xBE);

	tl = read_ds18b20();
	th = read_ds18b20();

	ret = th << 8;
	ret |= tl;

	return ret * 0.0625;//分辨率0.0625
}
```

我们在主函数中调用看看结果：

```

#include <reg51.h>
#include <stdio.h>
#include "ds18b20.h"
#include "delay.h"
#include "uart.h"

int main(void)
{
	float ret = 0;
	xdata char s[20];

	Uart_Init();

	while (1)
	{
	   ret = get_temp();
	   sprintf(s, "%f\n", ret);
	   Uart_SendStr(s);
	}

	return 0;
}
```

![](https://i-blog.csdnimg.cn/direct/e767cf3484eb4f9d8aa7ec9e354c072c.png)

可以接收到温度



