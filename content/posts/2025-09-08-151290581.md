---
layout: post
title: "PostgreSQL打印实时查询语句监控PostgreSQL监控未成功"
date: 2025-09-08T20:55:49+0800
description: "定期执行以下 SQL 语句（可通过脚本或。"
keywords: "postgresql 打印语句"
categories: ['未分类']
tags: ['数据库', 'Postgresql']
artid: "151290581"
arturl: "https://blog.csdn.net/Dontla/article/details/151290581"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151290581
    alt: "PostgreSQL打印实时查询语句监控PostgreSQL监控未成功"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151290581
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151290581
cover: https://bing.ee123.net/img/rand?artid=151290581
image: https://bing.ee123.net/img/rand?artid=151290581
img: https://bing.ee123.net/img/rand?artid=151290581
---



# PostgreSQL打印实时查询语句（监控PostgreSQL监控）（未成功）


[![](https://csdnimg.cn/release/blogv2/dist/pc/img/activeVector.png)
王者杯·14天创作挑战营·第5期
10w+人浏览
1.1k人参与

![](https://csdnimg.cn/release/blogv2/dist/pc/img/arrowright-line-White.png)](https://activity.csdn.net/writing?id=10949)

最后通过后端flask sqlalchemy开启`SQLALCHEMY_ECHO`每次数据库访问打印实现了：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e4bea671a3304e8fa5cde3b942dc57ee.png)

  
 可以实现实时打印每条查询的 SQL 语句，方法如下：

---

## **方法 1：通过 PostgreSQL 日志实时查看**

### **1. 修改 PostgreSQL 配置文件**

在 `docker-compose.yml` 中挂载的 `postgresql.conf` 文件中，添加以下日志配置：

```conf
# 开启日志记录所有 SQL 语句
log_statement = 'all'

# 设置日志输出格式（推荐包含时间、进程 ID 等）
log_line_prefix = '%t [%p]: [user=%u,db=%d] '

# 开启日志收集器
logging_collector = on
log_directory = '/var/log/postgresql'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'

```

### **2. 重启 PostgreSQL 容器**

```bash
docker compose down
docker compose up -d

```

### **3. 实时查看日志**

通过 `docker logs` 或直接访问挂载的日志目录实时查看：

```bash
# 方法 1：通过 docker logs 实时查看
docker compose logs -f postgres

# 方法 2：直接访问宿主机日志目录（假设日志挂载到 ./logs）
tail -f ./logs/postgresql-*.log

```

### **日志示例**

```
2025-09-07 16:24:38.123 UTC [1234]: [user=postgres,db=postgres] LOG:  statement: SELECT * FROM my_table;

```

---

## **方法 2：通过 `pg_stat_activity` 实时监控**

### **1. 查询实时执行的 SQL**

定期执行以下 SQL 语句（可通过脚本或 `watch` 命令）：

```sql
SELECT 
    pid, 
    usename, 
    query, 
    query_start, 
    now() - query_start AS duration
FROM 
    pg_stat_activity
WHERE 
    state = 'active' 
    AND query != '<IDLE>'
ORDER BY 
    query_start DESC;

```

### **2. 使用 `watch` 实时刷新**

```bash
watch -n 1 "psql -U postgres -d postgres -c 'SELECT * FROM pg_stat_activity;'"

```

---

## **方法 3：使用 `pg_stat_statements` 扩展**

### **1. 启用 `pg_stat_statements`**

在 `postgresql.conf` 中添加：

```conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all

```

重启容器后执行：

```sql
CREATE EXTENSION pg_stat_statements;

```

### **2. 查询实时 SQL 统计**

```sql
SELECT 
    query, 
    calls, 
    total_exec_time, 
    mean_exec_time
FROM 
    pg_stat_statements
ORDER BY 
    total_exec_time DESC
LIMIT 10;

```

---

## **注意事项**

1. **日志性能开销**：`log_statement = 'all'` 会记录所有 SQL，可能影响性能，建议仅用于调试。
2. **日志轮转**：通过 `log_rotation_age` 和 `log_rotation_size` 控制日志文件大小。
3. **权限问题**：确保挂载的日志目录（如 `./logs`）有写入权限。
4. **生产环境**：建议仅记录慢查询（`log_min_duration_statement`）而非所有语句。

---

## **总结**

* **实时打印每条查询**：使用 **方法 1（日志记录）**。
* **实时监控活跃查询**：使用 **方法 2（`pg_stat_activity`）**。
* **分析历史查询性能**：使用 **方法 3（`pg_stat_statements`）**。



