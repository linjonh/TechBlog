---
layout: post
title: "vue-识别word表格中的图片"
date: 2025-03-13 14:27:00 +0800
description: "但是识别不出 .emf .tif。tif是不显示 emf这是不识别。"
keywords: "vue 识别word表格中的图片"
categories: ['未分类']
tags: ['前端', 'Word', 'Vue']
artid: "146230099"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146230099
    alt: "vue-识别word表格中的图片"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146230099
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146230099
cover: https://bing.ee123.net/img/rand?artid=146230099
image: https://bing.ee123.net/img/rand?artid=146230099
img: https://bing.ee123.net/img/rand?artid=146230099
---

# vue 识别word表格中的图片

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/398c7bdf30464409b5eb53d3d850bcef.png)

> 但是识别不出 .emf .tif  
>  tif是不显示 emf这是不识别
    
    
    <template>
      <div class="container">
        <h2>提取 Word 表格中的图片</h2>
        <input type="file" @change="handleFileUpload" accept=".docx">
        
        <div v-if="tables.length">
          <h3>解析结果：</h3>
          <div v-for="(table, index) in tables" :key="index">
            <table border="1">
              <tbody>
                <tr v-for="(row, rowIndex) in table" :key="rowIndex">
                  <td v-for="(cell, cellIndex) in row" :key="cellIndex" v-html="cell"></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </template>
    
    <script>
    import JSZip from "jszip";
    
    export default {
      data() {
        return {
          tables: []
        };
      },
      methods: {
        async handleFileUpload(event) {
          const file = event.target.files[0];
          if (!file) return alert("请选择一个 Word 文件");
    
          const zip = await JSZip.loadAsync(file);
          console.log("ZIP 文件结构:", Object.keys(zip.files)); // 调试 ZIP 内的文件结构
    
          const documentXml = await this.readXmlFile(zip, "word/document.xml");
          const relsXml = await this.readXmlFile(zip, "word/_rels/document.xml.rels");
    
          if (!documentXml || !relsXml) {
            alert("无法解析 Word 文件");
            return;
          }
    
          const parser = new DOMParser();
          const docXml = parser.parseFromString(documentXml, "application/xml");
          const relsXmlDoc = parser.parseFromString(relsXml, "application/xml");
    
          const tables = docXml.getElementsByTagName("w:tbl");
          if (!tables.length) {
            alert("未找到 Word 表格");
            return;
          }
    
          let extractedTables = [];
          for (let i = 0; i < tables.length; i++) {
            let tableArray = [];
            const rows = tables[i].getElementsByTagName("w:tr");
    
            for (let row of rows) {
              let rowArray = [];
              const cells = row.getElementsByTagName("w:tc");
    
              for (let cell of cells) {
                let cellContent = this.extractText(cell);
    
                // 查找单元格内的图片
                const images = await this.extractImages(cell, relsXmlDoc, zip);
                if (images.length) {
                  cellContent += images.map(imgSrc => `<img src="${imgSrc}" style="max-width:100px;">`).join("<br>");
                }
    
                rowArray.push(cellContent);
              }
              tableArray.push(rowArray);
            }
            extractedTables.push(tableArray);
          }
          this.tables = extractedTables;
        },
    
        async readXmlFile(zip, filePath) {
          const file = zip.file(filePath);
          return file ? await file.async("string") : null;
        },
    
        extractText(cell) {
          const paragraphs = cell.getElementsByTagName("w:p");
          let text = "";
    
          for (let paragraph of paragraphs) {
            const runs = paragraph.getElementsByTagName("w:r");
            for (let run of runs) {
              const texts = run.getElementsByTagName("w:t");
              for (let textNode of texts) {
                text += textNode.textContent + " ";
              }
            }
          }
          return text.trim();
        },
    
        async extractImages(cell, relsXmlDoc, zip) {
          let imageSources = [];
          const drawings = cell.getElementsByTagName("w:drawing");
          const picts = cell.getElementsByTagName("w:pict"); // 兼容旧格式
    
          const imagesToProcess = [];
    
          // 处理 w:drawing 图片
          for (let drawing of drawings) {
            const blips = drawing.getElementsByTagName("a:blip");
            for (let blip of blips) {
              const embed = blip.getAttribute("r:embed");
              if (embed) imagesToProcess.push(embed);
            }
          }
    
          // 处理 w:pict 图片
          for (let pict of picts) {
            const imgs = pict.getElementsByTagName("v:imagedata");
            for (let img of imgs) {
              const embed = img.getAttribute("r:id");
              if (embed) imagesToProcess.push(embed);
            }
          }
    
          console.log("提取到的图片 ID:", imagesToProcess); // 调试
    
          const imagePromises = imagesToProcess.map(async (embed) => {
            const rel = relsXmlDoc.querySelector(`Relationship[Id="${embed}"]`);
            if (rel) {
              const target = rel.getAttribute("Target");
              let imagePath = `word/${target}`;
    
              console.log("图片路径:", imagePath); // 调试
    
              if (zip.file(imagePath)) {
                return await zip.file(imagePath).async("base64").then(base64 => `data:image/png;base64,${base64}`);
              }
            }
          });
    
          return Promise.all(imagePromises);
        }
      }
    };
    </script>
    
    <style scoped>
    .container {
      max-width: 600px;
      margin: auto;
      text-align: center;
    }
    table {
      width: 100%;
      margin-top: 10px;
      border-collapse: collapse;
    }
    td {
      padding: 5px;
      text-align: center;
    }
    </style>
    
    



