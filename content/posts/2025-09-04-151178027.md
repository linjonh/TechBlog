---
layout: post
title: "微信小程序-day4"
date: 2025-09-04T22:52:37+0800
description: "在小程序组件中，最重要的生命周期函数有3个，分别是createdattacheddetached。它们各自的特点如下：①组件实例刚被创建好的时候，created生命周期函数会被触发此时还不能调用setData通常在这个生命周期函数中，只应该用于给组件的this添加一些自定义的属性字段②在组件完全初始化完毕、进入页面节点树后attached生命周期函数会被触发此时，this.data已被初始化完毕这个生命周期很有用，"
keywords: "微信小程序-day4"
categories: ['未分类']
tags: ['微信小程序', '小程序']
artid: "151178027"
arturl: "https://blog.csdn.net/2301_81525305/article/details/151178027"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151178027
    alt: "微信小程序-day4"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151178027
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151178027
cover: https://bing.ee123.net/img/rand?artid=151178027
image: https://bing.ee123.net/img/rand?artid=151178027
img: https://bing.ee123.net/img/rand?artid=151178027
---



# 微信小程序-day4

## 小程序中的组件

### 局部注册

在页面的.json中使用**usingComponents**来注册使用组件

```
  "usingComponents": {
      "text1": "/components/text/text"
  }
```

### 全局注册

在app.json中使用**usingComponents**

## **组件和页面的区别**

从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：

1.组件的 .json 文件中需要声明 "component": true 属性

2.组件的 .js 文件中调用的是 Component() 函数

3.组件的事件处理函数需要定义到 methods 节点中

## 组件的样式

默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，小程序页面的样式也不会影响组件的样式

**组件样式隔离的注意点**

app.wxss 中的全局样式对组件无效

**但只有 class 选择器会有样式隔离效果（会无效），id 选择器、属性选择器、标签选择器不受样式隔离的影响**

建议：在组件和引用组件的页面中建议使用 class 选择器，**不要使用** id、属性、标签选择器！

![](https://i-blog.csdnimg.cn/direct/889c4b71339e4151bc71e9b7c61f9a8b.png)

**styleIsolation** **的可选值**

![](https://i-blog.csdnimg.cn/direct/8247a5a6af8e412e9f256a1216b0c90b.png)

## **methods**

在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中

![](https://i-blog.csdnimg.cn/direct/ab253a0d635c4df98d9f42d094344c78.png)

## **properties**

**类比props**

与vue不同，在小程序的组件中，properties 属性和 data 数据的用法相同，它们都是可读可写的

data 更倾向于存储组件的私有数据

properties 更倾向于存储外界传递到组件中的数据

this.data === this.properties 的结果是true，两者指向同一个对象

## 数据监听器

![](https://i-blog.csdnimg.cn/direct/d958feaf645445348660f88aa10d290c.png)

监听的基础用法

![](https://i-blog.csdnimg.cn/direct/cfe5dda37caf44189519e7ad9a068eca.png)

监听对象属性变化

![](https://i-blog.csdnimg.cn/direct/fe8b3efc76524d2db22ec8022b122ff6.png)

![](https://i-blog.csdnimg.cn/direct/9d261bfd4a374e0ba2eaf955c74094e0.png)

## **纯数据字段**

概念：纯数据字段指的是那些不用于界面渲染的 data 字段。

应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。

好处：纯数据字段有助于提升页面更新的性能。

![](https://i-blog.csdnimg.cn/direct/e0d82c85ee0041ba90fe5195e1a6458d.png)

## 自定义组件的生命周期

![](https://i-blog.csdnimg.cn/direct/348e785050d9453a97f38fe2bead7f4f.png)

在小程序组件中，最重要的生命周期函数有 3 个，分别是 created、**attached**、detached。它们各自的特点如下：

① 组件实例刚被创建好的时候，created 生命周期函数会被触发

此时还不能调用 setData

通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段

② 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发

此时， this.data 已被初始化完毕

这个生命周期很有用，**绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）（类似vue2中的created）**

③ 在组件离开页面节点树后， detached 生命周期函数会被触发

退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数

此时适合做一些清理性质的工作

### lifetimes节点

生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。

自小程序基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html "2.2.3") 起，组件的的生命周期也可以在 `lifetimes` 字段内进行声明（这是推荐的方式，其优先级最高）。

```
Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {
    // 在组件实例进入页面节点树时执行
  },
  detached: function() {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
})
```

### **组件所在页面的生命周期**

有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。

例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。

![](https://i-blog.csdnimg.cn/direct/5b041234750d47b0a11a3691c0409956.png)

### **pageLifetimes** **节点**

![](https://i-blog.csdnimg.cn/direct/12e9876d76c04510a6ad823328aa9dba.png)

## Slot插槽

和vue中类似

单个插槽基本一样

使用多个插槽时首先需要在js中启用

![](https://i-blog.csdnimg.cn/direct/75a56b46481c482d930131e35a212eee.png)

在.wxml中定义多个插槽，以name来区分（类似vue中的具名插槽）

![](https://i-blog.csdnimg.cn/direct/368806e83b6a45fab2f58027d158b216.png)

在使用时需要用slot="name"来确定使用的插槽

![](https://i-blog.csdnimg.cn/direct/6ec5d3f047dc4b6b9e5569b7c9984555.png)

## 组件通信

### 父传子

父组件传属性给子组件

![](https://i-blog.csdnimg.cn/direct/437127c28906439aaff96bd1bf53bb58.png)

子组件通过properties接收

![](https://i-blog.csdnimg.cn/direct/dc82964f995340d7b3404a0c71adb217.png)

### 子传父

事件绑定（就是监听事件$emit）

父组件监听事件

![](https://i-blog.csdnimg.cn/direct/5383f9a4838344539998a90de97013f8.png)

子组件使用**this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ })**来向父组件提交

![](https://i-blog.csdnimg.cn/direct/2084001d61dc49ff8c0cd71efb303039.png)

父组件通过e.detail来获取子组件传过来的值

![](https://i-blog.csdnimg.cn/direct/6f82d281ede44f45b7a667ea1e57310b.png)

### 获取组件实例

类似ref

可在父组件里调用 this.selectComponent("id或class选择器") ，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(".my-component")。

![](https://i-blog.csdnimg.cn/direct/7232ddd0c3ce4f819941ed7e6e5066ba.png)

### **behaviors**

behaviors 是小程序中，用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins”。

![](https://i-blog.csdnimg.cn/direct/a1cba56586fc47dc8d5ee2ba51d2ea7d.png)

每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中。

每个组件可以引用多个 behavior，behavior 也可以引用其它 behavior。

**创建** **behavior**

调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：

![](https://i-blog.csdnimg.cn/direct/cb58813603ba412396d49b995b103af0.png)

**导入并使用** **behavior**

在组件中，使用 require() 方法导入需要的 behavior，挂载后即可访问 behavior 中的数据或方法，示例代码如下：

![](https://i-blog.csdnimg.cn/direct/86dca0b3d95c4dc8ae1639970d8280d7.png)

**behavior** **中所有可用的节点**

![](https://i-blog.csdnimg.cn/direct/531079cfb9ad406e82518e9f4c4858ac.png)



