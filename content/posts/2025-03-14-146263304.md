---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343739353236362f:61727469636c652f64657461696c732f313436323633333034"
layout: post
title: "自动化APP测试APPium的元素等待"
date: 2025-03-14 18:01:26 +0800
description: "在使用Appium进行移动应用自动化测试时，有三种等待。隐式等待driver.implicitly_wait()显式等待（常用）time.sleep()"
keywords: "自动化APP测试APPium的元素等待"
categories: ['Appium']
tags: ['运维', '自动化', 'Appium']
artid: "146263304"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146263304
    alt: "自动化APP测试APPium的元素等待"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146263304
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146263304
cover: https://bing.ee123.net/img/rand?artid=146263304
image: https://bing.ee123.net/img/rand?artid=146263304
img: https://bing.ee123.net/img/rand?artid=146263304
---

# 自动化APP测试APPium的元素等待

#### 在使用Appium进行移动应用自动化测试时，有三种等待。

* #### 隐式等待driver.implicitly\_wait()
* #### 显式等待（常用）
* #### `time.sleep()`

### 隐式等待（Implicit Wait）

**应用场景**
：

* 当你希望对所有元素定位操作设置统一的超时时间，以应对网络波动或服务器响应速度不一致的情况。

**概念**
：

* 设置一个全局的等待时间，如果在指定时间内未找到元素，则抛出
  `NoSuchElementException`
  异常。
* 适用于整个会话期间，对于每个元素查找都会生效。

**步骤**
：

```
driver.implicitly_wait(10)  # 设置隐式等待时间为10秒
```

**作用**
：

* 减少了代码中重复的等待逻辑，简化了脚本编写。
* 对于不稳定网络环境下的元素查找尤其有用。

### 显式等待（Explicit Wait）

**应用场景**
：

* 当你需要针对特定元素或条件进行等待时，例如等待某个特定元素变得可点击或可见。

**概念**
：

* 使用
  `WebDriverWait`
  结合
  `expected_conditions`
  模块，可以灵活地定义等待条件。
* 允许更精细地控制何时继续执行下一步操作。

**常用
`expected_conditions`
方法**
：

* `title_is(title)`
  ：等待页面标题等于给定值。
* `presence_of_element_located(locator)`
  ：等待元素出现在DOM中。
* `element_to_be_clickable(locator)`
  ：等待元素出现在DOM中且可点击。
* 更多请参考Selenium文档中的
  [Expected Conditions](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html "Expected Conditions")
  。

**示例代码**
：

```
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

wait = WebDriverWait(driver, 25, 5)  # 最多等待25秒，每5秒检查一次
element = wait.until(EC.element_to_be_clickable((By.XPATH, "//android.widget.TextView[@text='Login']")))
element.click()
```

### `time.sleep()`

**概念**
：

* 是一个阻塞调用，会让当前线程暂停执行指定的秒数。
* 不推荐频繁使用，因为它会导致不必要的延迟，降低测试效率。

#### 智能等待机制 - 轮询检查

为了提高测试效率并减少不必要的等待时间，可以采用轮询检查的方法代替固定的
`time.sleep()`
。这种方法通过每次短暂等待后检查目标状态是否满足，直到达到最大等待时间或条件被满足为止。

**示例代码**
：

```
def wait_for_element(driver, by, value, timeout=30):
    end_time = time.time() + timeout
    while time.time() < end_time:
        try:
            element = driver.find_element(by, value)
            if element.is_displayed():
                return element
        except Exception:
            pass
        time.sleep(1)  # 每隔1秒检查一次
    raise TimeoutError("等待元素超时")
```

#### 总结

* **隐式等待**
  提供了一种简单的方式为所有元素查找设置统一的超时时间，适合应用于需要一致等待策略的场景。
* **显式等待**
  则允许更加精准地控制何时继续执行，基于特定条件进行等待，非常适合复杂或动态变化的应用界面。
* **避免直接使用
  `time.sleep()`**
  ，除非确实有必要，因为这会导致不可预知的延迟，影响测试性能。