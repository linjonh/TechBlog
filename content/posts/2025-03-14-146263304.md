---
layout: post
title: "自动化APP测试APPium的元素等待"
date: 2025-03-14 18:01:26 +0800
description: "在使用Appium进行移动应用自动化测试时，有三种等待。隐式等待driver.implicitly_wait()显式等待（常用）time.sleep()"
keywords: "自动化APP测试APPium的元素等待"
categories: ['Appium']
tags: ['运维', '自动化', 'Appium']
artid: "146263304"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146263304
    alt: "自动化APP测试APPium的元素等待"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146263304
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146263304
cover: https://bing.ee123.net/img/rand?artid=146263304
image: https://bing.ee123.net/img/rand?artid=146263304
img: https://bing.ee123.net/img/rand?artid=146263304
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     自动化APP测试APPium的元素等待
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     在使用Appium进行移动应用自动化测试时，有三种等待。
    </h4>
    <ul>
     <li>
      <h4>
       隐式等待driver.implicitly_wait()
      </h4>
     </li>
     <li>
      <h4>
       显式等待（常用）
      </h4>
     </li>
     <li>
      <h4>
       <code>
        time.sleep()
       </code>
      </h4>
     </li>
    </ul>
    <h3>
     隐式等待（Implicit Wait）
    </h3>
    <p>
     <strong>
      应用场景
     </strong>
     ：
    </p>
    <ul>
     <li>
      当你希望对所有元素定位操作设置统一的超时时间，以应对网络波动或服务器响应速度不一致的情况。
     </li>
    </ul>
    <p>
     <strong>
      概念
     </strong>
     ：
    </p>
    <ul>
     <li>
      设置一个全局的等待时间，如果在指定时间内未找到元素，则抛出
      <code>
       NoSuchElementException
      </code>
      异常。
     </li>
     <li>
      适用于整个会话期间，对于每个元素查找都会生效。
     </li>
    </ul>
    <p>
     <strong>
      步骤
     </strong>
     ：
    </p>
    <pre><code>driver.implicitly_wait(10)  # 设置隐式等待时间为10秒</code></pre>
    <p>
     <strong>
      作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      减少了代码中重复的等待逻辑，简化了脚本编写。
     </li>
     <li>
      对于不稳定网络环境下的元素查找尤其有用。
     </li>
    </ul>
    <h3>
     显式等待（Explicit Wait）
    </h3>
    <p>
     <strong>
      应用场景
     </strong>
     ：
    </p>
    <ul>
     <li>
      当你需要针对特定元素或条件进行等待时，例如等待某个特定元素变得可点击或可见。
     </li>
    </ul>
    <p>
     <strong>
      概念
     </strong>
     ：
    </p>
    <ul>
     <li>
      使用
      <code>
       WebDriverWait
      </code>
      结合
      <code>
       expected_conditions
      </code>
      模块，可以灵活地定义等待条件。
     </li>
     <li>
      允许更精细地控制何时继续执行下一步操作。
     </li>
    </ul>
    <p>
     <strong>
      常用
      <code>
       expected_conditions
      </code>
      方法
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       title_is(title)
      </code>
      ：等待页面标题等于给定值。
     </li>
     <li>
      <code>
       presence_of_element_located(locator)
      </code>
      ：等待元素出现在DOM中。
     </li>
     <li>
      <code>
       element_to_be_clickable(locator)
      </code>
      ：等待元素出现在DOM中且可点击。
     </li>
     <li>
      更多请参考Selenium文档中的
      <a href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html" rel="nofollow" title="Expected Conditions">
       Expected Conditions
      </a>
      。
     </li>
    </ul>
    <p>
     <strong>
      示例代码
     </strong>
     ：
    </p>
    <pre><code>from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

wait = WebDriverWait(driver, 25, 5)  # 最多等待25秒，每5秒检查一次
element = wait.until(EC.element_to_be_clickable((By.XPATH, "//android.widget.TextView[@text='Login']")))
element.click()</code></pre>
    <h3>
     <code>
      time.sleep()
     </code>
    </h3>
    <p>
     <strong>
      概念
     </strong>
     ：
    </p>
    <ul>
     <li>
      是一个阻塞调用，会让当前线程暂停执行指定的秒数。
     </li>
     <li>
      不推荐频繁使用，因为它会导致不必要的延迟，降低测试效率。
     </li>
    </ul>
    <h4>
     智能等待机制 - 轮询检查
    </h4>
    <p>
     为了提高测试效率并减少不必要的等待时间，可以采用轮询检查的方法代替固定的
     <code>
      time.sleep()
     </code>
     。这种方法通过每次短暂等待后检查目标状态是否满足，直到达到最大等待时间或条件被满足为止。
    </p>
    <p>
     <strong>
      示例代码
     </strong>
     ：
    </p>
    <pre><code>def wait_for_element(driver, by, value, timeout=30):
    end_time = time.time() + timeout
    while time.time() &lt; end_time:
        try:
            element = driver.find_element(by, value)
            if element.is_displayed():
                return element
        except Exception:
            pass
        time.sleep(1)  # 每隔1秒检查一次
    raise TimeoutError("等待元素超时")</code></pre>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <strong>
       隐式等待
      </strong>
      提供了一种简单的方式为所有元素查找设置统一的超时时间，适合应用于需要一致等待策略的场景。
     </li>
     <li>
      <strong>
       显式等待
      </strong>
      则允许更加精准地控制何时继续执行，基于特定条件进行等待，非常适合复杂或动态变化的应用界面。
     </li>
     <li>
      <strong>
       避免直接使用
       <code>
        time.sleep()
       </code>
      </strong>
      ，除非确实有必要，因为这会导致不可预知的延迟，影响测试性能。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343739353236362f:61727469636c652f64657461696c732f313436323633333034" class_="artid" style="display:none">
 </p>
</div>


