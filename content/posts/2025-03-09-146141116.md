---
layout: post
title: "stm32中分析UART中IDLE,RXNE,TC,TXE这些标志位的作用"
date: 2025-03-09 23:27:20 +0800
description: "下面将基于 STM32 标准库，结合之前提到的不同应用场景，给出使用TXETCIDLE和RXNE标志位的代码示例及分析。"
keywords: "stm32 串口发送 idle tc"
categories: ['未分类']
tags: ['嵌入式硬件', '单片机', 'Stm']
artid: "146141116"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146141116
    alt: "stm32中分析UART中IDLE,RXNE,TC,TXE这些标志位的作用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146141116
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146141116
cover: https://bing.ee123.net/img/rand?artid=146141116
image: https://bing.ee123.net/img/rand?artid=146141116
img: https://bing.ee123.net/img/rand?artid=146141116
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     stm32中分析UART中IDLE,RXNE,TC,TXE这些标志位的作用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     下面将基于 STM32 标准库，结合之前提到的不同应用场景，给出使用
     <code>
      TXE
     </code>
     、
     <code>
      TC
     </code>
     、
     <code>
      IDLE
     </code>
     和
     <code>
      RXNE
     </code>
     标志位的代码示例及分析。
    </p>
    <h4>
     1. 连续数据发送（使用
     <code>
      TXE
     </code>
     ）
    </h4>
    <h5>
     应用场景
    </h5>
    <p>
     向外部设备连续发送大量数据，如向显示屏发送显示数据、向传感器发送配置指令序列等。
    </p>
    <h5>
     代码示例
    </h5>
    <pre><code>#include "stm32f10x.h"

void USART1_Configuration(void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    // 使能 USART1 和 GPIOA 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 配置 PA9 为复用推挽输出（TX）
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    // 配置 USART1
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx;
    USART_Init(USART1, &amp;USART_InitStructure);

    // 使能 USART1
    USART_Cmd(USART1, ENABLE);
}

void USART1_SendString(const char* str) {
    while (*str) {
        // 等待发送数据寄存器为空
        while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
        // 写入新的数据
        USART_SendData(USART1, (uint8_t)*str++);
    }
}

int main(void) {
    USART1_Configuration();
    const char* message = "Hello, World!";
    USART1_SendString(message);

    while (1) {
        // 主循环
    }
}
</code></pre>
    <h5>
     代码分析
    </h5>
    <ul>
     <li>
      <code>
       USART1_Configuration
      </code>
      函数：
      <ul>
       <li>
        使能 USART1 和 GPIOA 的时钟。
       </li>
       <li>
        配置 PA9 为复用推挽输出，用于 USART1 的发送功能。
       </li>
       <li>
        初始化 USART1，设置波特率为 115200，数据位为 8 位，停止位为 1 位，无校验位，无硬件流控制，仅使能发送模式。
       </li>
       <li>
        使能 USART1。
       </li>
      </ul>
     </li>
     <li>
      <code>
       USART1_SendString
      </code>
      函数：
      <ul>
       <li>
        使用
        <code>
         USART_GetFlagStatus
        </code>
        函数检查
        <code>
         TXE
        </code>
        标志位，当该标志位为
        <code>
         SET
        </code>
        时，表示发送数据寄存器为空。
       </li>
       <li>
        使用
        <code>
         USART_SendData
        </code>
        函数将字符串中的字符依次发送出去。
       </li>
      </ul>
     </li>
     <li>
      <code>
       main
      </code>
      函数：
      <ul>
       <li>
        调用
        <code>
         USART1_Configuration
        </code>
        函数初始化 USART1。
       </li>
       <li>
        调用
        <code>
         USART1_SendString
        </code>
        函数发送字符串 "Hello, World!"。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     2. 数据发送完成确认（使用
     <code>
      TC
     </code>
     ）
    </h4>
    <h5>
     应用场景
    </h5>
    <p>
     在对数据完整性要求较高的场景中，确保整个数据帧完整无误地发送到目标设备。
    </p>
    <h5>
     代码示例
    </h5>
    <pre><code>#include "stm32f10x.h"

void USART1_Configuration(void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    // 使能 USART1 和 GPIOA 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 配置 PA9 为复用推挽输出（TX）
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    // 配置 USART1
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx;
    USART_Init(USART1, &amp;USART_InitStructure);

    // 使能 USART1
    USART_Cmd(USART1, ENABLE);
}

void USART1_SendDataAndWaitComplete(uint8_t data) {
    // 等待发送数据寄存器为空
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    // 写入数据
    USART_SendData(USART1, data);
    // 等待发送完成
    while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
}

int main(void) {
    USART1_Configuration();
    uint8_t command = 0xAA;
    USART1_SendDataAndWaitComplete(command);

    while (1) {
        // 主循环
    }
}
</code></pre>
    <h5>
     代码分析
    </h5>
    <ul>
     <li>
      <code>
       USART1_Configuration
      </code>
      函数：与连续数据发送场景中的配置函数相同。
     </li>
     <li>
      <code>
       USART1_SendDataAndWaitComplete
      </code>
      函数：
      <ul>
       <li>
        先使用
        <code>
         USART_GetFlagStatus
        </code>
        函数检查
        <code>
         TXE
        </code>
        标志位，当该标志位为
        <code>
         SET
        </code>
        时，将数据写入
        <code>
         DR
        </code>
        寄存器。
       </li>
       <li>
        然后使用
        <code>
         USART_GetFlagStatus
        </code>
        函数检查
        <code>
         TC
        </code>
        标志位，当该标志位为
        <code>
         SET
        </code>
        时，表示整个数据帧发送完成。
       </li>
      </ul>
     </li>
     <li>
      <code>
       main
      </code>
      函数：
      <ul>
       <li>
        调用
        <code>
         USART1_Configuration
        </code>
        函数初始化 USART1。
       </li>
       <li>
        调用
        <code>
         USART1_SendDataAndWaitComplete
        </code>
        函数发送一个字节的命令
        <code>
         0xAA
        </code>
        。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     3. 数据帧边界识别（使用
     <code>
      IDLE
     </code>
     ）
    </h4>
    <h5>
     应用场景
    </h5>
    <p>
     接收不定长的数据帧，如从传感器接收实时数据、从其他设备接收通信协议数据等。
    </p>
    <h5>
     代码示例
    </h5>
    <pre><code>#include "stm32f10x.h"
#include &lt;stdio.h&gt;

#define BUFFER_SIZE 256
uint8_t rx_buffer[BUFFER_SIZE];
uint8_t rx_index = 0;

void USART1_Configuration(void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    // 使能 USART1 和 GPIOA 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 配置 PA10 为浮空输入（RX）
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    // 配置 USART1
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx;
    USART_Init(USART1, &amp;USART_InitStructure);

    // 使能 USART1 的 IDLE 中断
    USART_ITConfig(USART1, USART_IT_IDLE, ENABLE);

    // 配置 NVIC
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&amp;NVIC_InitStructure);

    // 使能 USART1
    USART_Cmd(USART1, ENABLE);
}

void USART1_IRQHandler(void) {
    if (USART_GetITStatus(USART1, USART_IT_IDLE) != RESET) {
        // 清除 IDLE 标志位
        USART_ClearITPendingBit(USART1, USART_IT_IDLE);
        uint8_t temp = USART_ReceiveData(USART1); // 读取数据以清除 IDLE 标志

        // 处理一帧数据接收完成事件
        // 这里简单打印接收到的数据长度
        printf("Received %d bytes of data.\n", rx_index);

        // 清空缓冲区和索引
        rx_index = 0;
    } else if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        // 读取接收缓冲区的数据
        rx_buffer[rx_index++] = USART_ReceiveData(USART1);
        // 清除 RXNE 标志位
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

int main(void) {
    USART1_Configuration();

    while (1) {
        // 主循环
    }
}
</code></pre>
    <h5>
     代码分析
    </h5>
    <ul>
     <li>
      <code>
       USART1_Configuration
      </code>
      函数：
      <ul>
       <li>
        使能 USART1 和 GPIOA 的时钟。
       </li>
       <li>
        配置 PA10 为浮空输入，用于 USART1 的接收功能。
       </li>
       <li>
        初始化 USART1，设置波特率为 115200，数据位为 8 位，停止位为 1 位，无校验位，无硬件流控制，仅使能接收模式。
       </li>
       <li>
        使能 USART1 的
        <code>
         IDLE
        </code>
        中断，并配置 NVIC。
       </li>
       <li>
        使能 USART1。
       </li>
      </ul>
     </li>
     <li>
      <code>
       USART1_IRQHandler
      </code>
      函数：
      <ul>
       <li>
        当
        <code>
         IDLE
        </code>
        中断发生时，使用
        <code>
         USART_ClearITPendingBit
        </code>
        函数清除
        <code>
         IDLE
        </code>
        标志位，读取数据以彻底清除该标志。处理接收到的数据（这里简单打印数据长度），并清空缓冲区和索引。
       </li>
       <li>
        当
        <code>
         RXNE
        </code>
        中断发生时，将接收到的数据存入缓冲区，并清除
        <code>
         RXNE
        </code>
        标志位。
       </li>
      </ul>
     </li>
     <li>
      <code>
       main
      </code>
      函数：
      <ul>
       <li>
        调用
        <code>
         USART1_Configuration
        </code>
        函数初始化 USART1。
       </li>
       <li>
        进入主循环等待中断。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     4. 实时数据接收（使用
     <code>
      RXNE
     </code>
     ）
    </h4>
    <h5>
     应用场景
    </h5>
    <p>
     实时处理接收到的数据，如实时监测传感器数据、接收外部设备的控制指令等。
    </p>
    <h5>
     代码示例
    </h5>
    <pre><code>#include "stm32f10x.h"

void USART1_Configuration(void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    // 使能 USART1 和 GPIOA 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 配置 PA10 为浮空输入（RX）
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    // 配置 USART1
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx;
    USART_Init(USART1, &amp;USART_InitStructure);

    // 使能 USART1 的 RXNE 中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);

    // 配置 NVIC
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&amp;NVIC_InitStructure);

    // 使能 USART1
    USART_Cmd(USART1, ENABLE);
}

void USART1_IRQHandler(void) {
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        uint8_t data = USART_ReceiveData(USART1); // 读取接收缓冲区的数据
        // 简单处理接收到的数据，这里假设点亮一个 LED
        if (data == '1') {
            GPIO_SetBits(GPIOA, GPIO_Pin_0);  // 点亮 PA0
        } else if (data == '0') {
            GPIO_ResetBits(GPIOA, GPIO_Pin_0);  // 熄灭 PA0
        }
        // 清除 RXNE 标志位
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

int main(void) {
    // 使能 GPIOA 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    // 配置 PA0 为推挽输出
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    USART1_Configuration();

    while (1) {
        // 主循环
    }
}
</code></pre>
    <h5>
     代码分析
    </h5>
    <ul>
     <li>
      <code>
       USART1_Configuration
      </code>
      函数：
      <ul>
       <li>
        使能 USART1 和 GPIOA 的时钟。
       </li>
       <li>
        配置 PA10 为浮空输入，用于 USART1 的接收功能。
       </li>
       <li>
        初始化 USART1，设置波特率为 115200，数据位为 8 位，停止位为 1 位，无校验位，无硬件流控制，仅使能接收模式。
       </li>
       <li>
        使能 USART1 的
        <code>
         RXNE
        </code>
        中断，并配置 NVIC。
       </li>
       <li>
        使能 USART1。
       </li>
      </ul>
     </li>
     <li>
      <code>
       USART1_IRQHandler
      </code>
      函数：
      <ul>
       <li>
        当
        <code>
         RXNE
        </code>
        中断发生时，使用
        <code>
         USART_ReceiveData
        </code>
        函数读取接收缓冲区的数据。
       </li>
       <li>
        根据接收到的数据内容，控制 PA0 引脚的电平，实现点亮或熄灭 LED 的功能。
       </li>
       <li>
        使用
        <code>
         USART_ClearITPendingBit
        </code>
        函数清除
        <code>
         RXNE
        </code>
        标志位。
       </li>
      </ul>
     </li>
     <li>
      <code>
       main
      </code>
      函数：
      <ul>
       <li>
        使能 GPIOA 时钟，配置 PA0 为推挽输出。
       </li>
       <li>
        调用
        <code>
         USART1_Configuration
        </code>
        函数初始化 USART1。
       </li>
       <li>
        进入主循环等待中断。
       </li>
      </ul>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35383033383230362f:61727469636c652f64657461696c732f313436313431313136" class_="artid" style="display:none">
 </p>
</div>


