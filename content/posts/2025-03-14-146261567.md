---
layout: post
title: "LeetCode-hot-100滑动窗口最大值"
date: 2025-03-14 17:21:47 +0800
description: "给你一个整数数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。"
keywords: "LeetCode hot 100—滑动窗口最大值"
categories: ['Leetcode']
tags: ['算法', '数据结构', 'Leetcode', 'C']
artid: "146261567"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146261567
    alt: "LeetCode-hot-100滑动窗口最大值"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146261567
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146261567
cover: https://bing.ee123.net/img/rand?artid=146261567
image: https://bing.ee123.net/img/rand?artid=146261567
img: https://bing.ee123.net/img/rand?artid=146261567
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LeetCode hot 100—滑动窗口最大值
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     题目
    </h2>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，有一个大小为
     <code>
      k
     </code>
     <em>
     </em>
     的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的
     <code>
      k
     </code>
     个数字。滑动窗口每次只向右移动一位。
    </p>
    <p>
     返回
     <em>
      滑动窗口中的最大值
     </em>
     。
    </p>
    <h2>
     示例
    </h2>
    <blockquote>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <pre><strong>输入：</strong>nums = [1,3,-1,-3,5,3,6,7], k = 3
<strong>输出：</strong>[3,3,5,5,6,7]
<strong>解释：</strong>
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       <strong>3</strong>
 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>
 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>
 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>
 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>
 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>nums = [1], k = 1
<strong>输出：</strong>[1]</pre>
    </blockquote>
    <h2>
     分析
    </h2>
    <h3>
     双端队列法
    </h3>
    <p>
     双端队列是一种可以在两端进行插入和删除操作的线性数据结构。可以在 O(1) 的时间复杂度内完成队首和队尾元素的插入和删除操作，从而使得我们能够高效地维护滑动窗口内的最大值。
    </p>
    <h4>
     整体思路
    </h4>
    <p>
     对于每个元素
     <code>
      nums[i]
     </code>
     ：
    </p>
    <ul>
     <li>
      <strong>
       移除窗口外的元素
      </strong>
      ：如果队列的队首元素
      <code>
       window.front()
      </code>
      等于
      <code>
       i - k
      </code>
      ，说明该元素已经不在当前滑动窗口内，将其从队列中移除。
     </li>
     <li>
      <strong>
       保持队列递减
      </strong>
      ：从队列的队尾开始，移除所有小于当前元素
      <code>
       nums[i]
      </code>
      的元素。因为这些元素不可能是后续滑动窗口中的最大值，所以可以直接移除。
     </li>
     <li>
      <strong>
       将当前元素的索引加入队列
      </strong>
      ：将当前元素的索引
      <code>
       i
      </code>
      加入队列的队尾。
     </li>
     <li>
      <strong>
       记录最大值
      </strong>
      ：当
      <code>
       i
      </code>
      大于等于
      <code>
       k - 1
      </code>
      时，说明滑动窗口的大小已经达到
      <code>
       k
      </code>
      ，此时队列的队首元素对应的元素就是当前滑动窗口中的最大值，将其加入
      <code>
       result
      </code>
      中。
     </li>
    </ul>
    <p>
     时间复杂度：O(
     <img alt="n" class="mathcode" src="https://latex.csdn.net/eq?n">
      )
     </img>
    </p>
    <p>
     空间复杂度：O(
     <img alt="k" class="mathcode" src="https://latex.csdn.net/eq?k">
      )
     </img>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        std::vector&lt;int&gt; result;
        std::deque&lt;int&gt; window;
        for (int i = 0; i &lt; nums.size(); ++i) {
            // 移除窗口外的元素
            if (!window.empty() &amp;&amp; window.front() == i - k) {
                window.pop_front();
            }
            // 保持队列递减，移除小于当前元素的元素
            while (!window.empty() &amp;&amp; nums[window.back()] &lt; nums[i]) {
                window.pop_back();
            }
            // 将当前元素的索引加入队列
            window.push_back(i);
            // 当窗口大小达到 k 时，记录最大值
            if (i &gt;= k - 1) {
                result.push_back(nums[window.front()]);
            }
        }
        return result;
    }
};    </code></pre>
    <h2>
     知识充电
    </h2>
    <h3>
     deque 容器
    </h3>
    <h4>
     初始化
    </h4>
    <pre><code class="language-cpp">#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    // 默认构造函数，创建一个空的双端队列
    std::deque&lt;int&gt; d1;

    // 构造一个包含 n 个值为 value 的元素的双端队列
    std::deque&lt;int&gt; d2(5, 10);  // 包含 5 个值为 10 的元素

    // 从另一个双端队列复制元素
    std::deque&lt;int&gt; d3(d2);

    // 从迭代器范围 [first, last) 复制元素
    std::deque&lt;int&gt; d4(d2.begin(), d2.end());

    return 0;
}</code></pre>
    <h4>
     随机访问
    </h4>
    <pre><code class="language-cpp">#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; d = {1, 2, 3, 4, 5};

    // 通过下标访问元素
    std::cout &lt;&lt; d[2] &lt;&lt; std::endl;  // 输出 3

    // 通过 at() 方法访问元素，会进行边界检查，越界时抛出异常
    std::cout &lt;&lt; d.at(3) &lt;&lt; std::endl;  // 输出 4

    // 访问第一个元素
    std::cout &lt;&lt; d.front() &lt;&lt; std::endl;  // 输出 1

    // 访问最后一个元素
    std::cout &lt;&lt; d.back() &lt;&lt; std::endl;  // 输出 5

    return 0;
}</code></pre>
    <h4>
     插入和删除
    </h4>
    <pre><code class="language-cpp">#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; d = {1, 2, 3};

    // 在尾部插入元素
    d.push_back(4);  // d 变为 {1, 2, 3, 4}

    // 在头部插入元素
    d.push_front(0);  // d 变为 {0, 1, 2, 3, 4}

    // 删除尾部元素
    d.pop_back();  // d 变为 {0, 1, 2, 3}

    // 删除头部元素
    d.pop_front();  // d 变为 {1, 2, 3}

    return 0;
}</code></pre>
    <p>
     当需要在队列的两端频繁进行插入和删除操作时，
     <code>
      std::deque
     </code>
     是一个很好的选择，比如实现滑动窗口算法，就可以利用其在两端高效操作的特性来维护窗口内的元素。
    </p>
    <p>
     当需要随机访问元素，但又不想像
     <code>
      std::vector
     </code>
     那样在头部插入或删除元素时性能不佳的情况，也可以使用
     <code>
      std::deque
     </code>
     。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f726967696477696c6c2f:61727469636c652f64657461696c732f313436323631353637" class_="artid" style="display:none">
 </p>
</div>


