---
layout: post
title: "WM_CREATE"
date: 2025-03-11 10:16:13 +0800
description: "​必须处理如果控件是自行实现的（如继承自CWnd的类），则需在WM_CREATE中完成类成员初始化资源分配或消息映射绑定等操作。​步骤​注册窗口类使用注册自定义控件的窗口类，并指定窗口过程（如​在WM_CREATE中初始化在自定义窗口过程中处理WM_CREATE，执行初始化代码。// 自定义列表框窗口过程// 自定义初始化代码（例如分配内存）// 其他消息处理...// 调用默认处理// 注册窗口类// 创建自定义列表框。"
keywords: "WM_CREATE"
categories: ['从入门到精通', 'Visual', 'C', '2017']
tags: ['Wm']
artid: "146171285"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146171285
    alt: "WM_CREATE"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146171285
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146171285
cover: https://bing.ee123.net/img/rand?artid=146171285
image: https://bing.ee123.net/img/rand?artid=146171285
img: https://bing.ee123.net/img/rand?artid=146171285
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     WM_CREATE
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     说明：以下内容主要来自腾讯元宝。
    </p>
    <h3>
     WM_CREATE会在什么时候触发？
    </h3>
    <p>
     <code>
      WM_CREATE
     </code>
     消息是 Windows 消息机制中非常重要的一个消息，它在窗口或控件
     <strong>
      创建完成并即将显示之前
     </strong>
     被系统发送给窗口过程（
     <code>
      WindowProc
     </code>
     ）。以下是
     <code>
      WM_CREATE
     </code>
     的具体触发时机、使用场景及注意事项：
    </p>
    <hr/>
    <h4>
     ​
     <strong>
      1. WM_CREATE 消息的触发时机
     </strong>
    </h4>
    <h5>
     ​**(1) 窗口首次创建时**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       示例场景
      </strong>
      ：
      <br/>
      当调用
      <code>
       CreateWindowEx
      </code>
      或
      <code>
       CreateWindow
      </code>
      创建顶级窗口（如主对话框、应用程序窗口）或子窗口（如按钮、列表框等控件）时，系统在窗口对象分配完毕、窗口句柄（
      <code>
       HWND
      </code>
      ）生成后，立即发送
      <code>
       WM_CREATE
      </code>
      消息。
     </li>
     <li>
      ​
      <strong>
       关键点
      </strong>
      ：
      <ul>
       <li>
        ​
        <strong>
         发生在窗口的
         <code>
          CREATESTRUCT
         </code>
         结构体初始化之后
        </strong>
        ，但窗口尚未显示（
        <code>
         ShowWindow
        </code>
        未调用）。
       </li>
       <li>
        ​
        <strong>
         适用于所有类型的窗口
        </strong>
        ​（顶级窗口、对话框、控件）。
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     ​**(2) 窗口被销毁后重新创建**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       场景
      </strong>
      ：
      <br/>
      如果窗口被销毁（如调用
      <code>
       DestroyWindow
      </code>
      ），随后再次创建同名窗口（例如重启应用程序的主窗口），系统会重新触发
      <code>
       WM_CREATE
      </code>
      。
     </li>
    </ul>
    <h5>
     ​**(3) 动态创建控件时**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       场景
      </strong>
      ：
      <br/>
      在运行时动态创建控件（如列表框、按钮）时，例如通过
      <code>
       CreateWindowEx
      </code>
      在对话框或父窗口内创建控件，​
      <strong>
       每个新创建的控件
      </strong>
      都会独立接收
      <code>
       WM_CREATE
      </code>
      消息。
     </li>
     <li>
      ​
      <strong>
       示例代码
      </strong>
      ：
      <pre><code class="language-cpp">HWND hListBox = CreateWindowEx(
    0, L"ListBox", NULL,
    WS_CHILD | WS_VISIBLE | LBS_OWNERDRAWFIXED,
    10, 10, 200, 300,
    hWndParent, (HMENU)IDC_MYLIST,
    hInstance, NULL);
// 此时 hListBox 会自动收到 WM_CREATE 消息</code></pre>
     </li>
    </ul>
    <h5>
     ​**(4) 通过对话框模板创建控件**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       场景
      </strong>
      ：
      <br/>
      如果使用资源编辑器设计对话框（
      <code>
       .rc
      </code>
      文件），并在对话框中声明控件（如列表框），当对话框被创建（如
      <code>
       DialogBox
      </code>
      或
      <code>
       CreateDialog
      </code>
      调用）时，​
      <strong>
       对话框本身和其内部的所有控件
      </strong>
      都会依次触发
      <code>
       WM_CREATE
      </code>
      消息。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      2. WM_CREATE 消息的典型用途
     </strong>
    </h4>
    <p>
     <code>
      WM_CREATE
     </code>
     是
     <span style="color:#fe2c24">
      初始化窗口或控件
     </span>
     的黄金时机，常见用途包括：
    </p>
    <ul>
     <li>
      ​
      <strong>
       初始化控件属性
      </strong>
      ：设置窗口样式、控件数据或关联资源（如图标、位图）。
     </li>
     <li>
      ​
      <strong>
       注册子窗口类
      </strong>
      ：如果窗口包含自定义控件（如继承自
      <code>
       CWnd
      </code>
      的类），需在此处注册类。
     </li>
     <li>
      ​
      <strong>
       分配内存
      </strong>
      ：为窗口或控件私有数据分配内存（如结构体、缓冲区）。
     </li>
     <li>
      ​
      <strong>
       绑定事件处理
      </strong>
      ：为控件设置消息映射（如
      <code>
       ON_BN_CLICKED
      </code>
      ）。
     </li>
    </ul>
    <h5>
     ​
     <strong>
      示例代码（初始化列表框）​
     </strong>
     ：
    </h5>
    <pre><code class="language-cpp">// 在窗口过程的 WM_CREATE 处理中
case WM_CREATE:
{
    CREATESTRUCT* pCreateInfo = (CREATESTRUCT*)lParam;
    
    // 创建自定义列表框（假设 LBS_OWNERDRAWFIXED）
    HWND hListBox = CreateWindowEx(
        0, L"ListBox", NULL,
        WS_CHILD | WS_VISIBLE | LBS_OWNERDRAWFIXED,
        10, 10, 200, 300,
        pCreateInfo-&gt;hwndParent, (HMENU)IDC_MYLIST,
        hInstance, NULL);
    
    // 设置列表框项的高度（需响应 WM_MEASUREITEM）
    SendMessage(hListBox, LB_SETITEMHEIGHT, 0, 30);
    
    return TRUE; // 必须返回 TRUE，否则窗口创建失败
}
break;</code></pre>
    <hr/>
    <h4>
     ​
     <strong>
      3. 与 WM_INITDIALOG 的区别
     </strong>
    </h4>
    <ul>
     <li>
      ​**
      <code>
       WM_CREATE
      </code>
      <strong>
       ：
       <br/>
       适用于
      </strong>
      所有窗口和控件**​（包括顶级窗口、对话框、控件），是通用的初始化消息。
     </li>
     <li>
      ​**
      <code>
       WM_INITDIALOG
      </code>
      <strong>
       ：
       <br/>
       仅当窗口是
      </strong>
      对话框框体**​（
      <code>
       DLGBOX
      </code>
      类型）时触发，专门用于初始化对话框中的控件和数据。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      4. 注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       ​
       <strong>
        必须返回
        <code>
         TRUE
        </code>
       </strong>
       ：
       <br/>
       在
       <code>
        WM_CREATE
       </code>
       处理函数中，​
       <strong>
        必须返回
        <code>
         TRUE
        </code>
       </strong>
       ，否则系统会认为窗口创建失败并终止创建流程。
      </p>
     </li>
     <li>
      <p>
       ​
       <strong>
        避免过早操作
       </strong>
       ：
      </p>
      <ul>
       <li>
        窗口尚未显示，但句柄（
        <code>
         HWND
        </code>
        ）已有效，可以安全调用
        <code>
         SendMessage
        </code>
        、
        <code>
         SetWindowText
        </code>
        等函数。
       </li>
       <li>
        ​
        <strong>
         不能直接调用
         <code>
          ShowWindow
         </code>
         或
         <code>
          UpdateWindow
         </code>
        </strong>
        ，因为窗口尚未进入显示状态。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        动态创建控件的层级关系
       </strong>
       ：
      </p>
      <ul>
       <li>
        动态创建的控件（如列表框）会自动成为父窗口的子窗口，但其
        <code>
         WM_CREATE
        </code>
        消息
        <strong>
         在父窗口的
         <code>
          WM_CREATE
         </code>
         之后触发
        </strong>
        。
       </li>
       <li>
        ​
        <strong>
         消息队列顺序
        </strong>
        ：父窗口
        <code>
         WM_CREATE
        </code>
        → 子窗口
        <code>
         WM_CREATE
        </code>
        → 父窗口
        <code>
         WM_SIZE
        </code>
        （调整布局）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        对话框中的控件创建
       </strong>
       ：
      </p>
      <ul>
       <li>
        如果在对话框的
        <code>
         WM_INITDIALOG
        </code>
        中动态创建控件，需确保父窗口句柄（
        <code>
         hWndDlg
        </code>
        ）已正确传递。
       </li>
       <li>
        ​
        <strong>
         推荐做法
        </strong>
        ：尽量在资源编辑器中声明控件，并通过
        <code>
         WM_INITDIALOG
        </code>
        初始化数据，而非动态创建。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     ​
     <strong>
      5. 消息触发流程示例
     </strong>
    </h4>
    <h5>
     ​
     <strong>
      步骤 1：创建主窗口
     </strong>
    </h5>
    <pre><code class="language-cpp">// 主窗口 WM_CREATE 处理
case WM_CREATE:
{
    // 初始化代码（如创建控件、加载资源）
    CreateMyCustomControl(hWnd);
    return TRUE;
}
break;</code></pre>
    <h5>
     ​
     <strong>
      步骤 2：创建对话框
     </strong>
    </h5>
    <pre><code class="language-cpp">// 对话框 WM_CREATE 处理（与 WM_INITDIALOG 区分）
case WM_CREATE:
{
    // 初始化对话框控件（如设置文本、绑定数据）
    SetDlgItemText(hWndDlg, IDC_EDIT1, _T("默认文本"));
    return TRUE;
}
break;

case WM_INITDIALOG:
{
    // 另一处初始化逻辑（如加载图标、设置焦点）
    return TRUE;
}
break;</code></pre>
    <hr/>
    <h4>
     ​
     <strong>
      6. 常见误区
     </strong>
    </h4>
    <ul>
     <li>
      ​
      <strong>
       误用
       <code>
        WM_INIT
       </code>
      </strong>
      ：
      <br/>
      <code>
       WM_INIT
      </code>
      并非标准 Windows 消息，可能是对
      <code>
       WM_CREATE
      </code>
      或
      <code>
       WM_INITDIALOG
      </code>
      的笔误。
     </li>
     <li>
      ​
      <strong>
       忘记返回
       <code>
        TRUE
       </code>
      </strong>
      ：
      <br/>
      导致窗口创建失败，表现为窗口一闪即逝或无法响应。
     </li>
     <li>
      ​
      <strong>
       在
       <code>
        WM_CREATE
       </code>
       中调用
       <code>
        ShowWindow
       </code>
      </strong>
      ：
      <br/>
      虽然句柄有效，但此时窗口尚未布局完成，可能导致显示异常。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      ​**
      <code>
       WM_CREATE
      </code>
      是窗口生命周期的起点**，适用于所有窗口和控件。
     </li>
     <li>
      ​
      <strong>
       核心用途
      </strong>
      ：初始化资源、设置控件属性、绑定数据。
     </li>
     <li>
      ​
      <strong>
       返回值必须为
       <code>
        TRUE
       </code>
      </strong>
      ，否则窗口创建失败。
     </li>
     <li>
      区分
      <code>
       WM_CREATE
      </code>
      （通用初始化）和
      <code>
       WM_INITDIALOG
      </code>
      （对话框专用初始化）。
     </li>
    </ul>
    <p>
    </p>
    <h3>
     同一个窗口的WM_CREATE会被重复触发吗？
    </h3>
    <pre><code class="language-cpp">case WM_CREATE:
    hListBox = CreateWindow(_T("ListBox"), NULL,
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP | LBS_OWNERDRAWFIXED | LBS_HASSTRINGS,
        20, 20, 60, 120,
        hWnd, (HMENU)ID_MYLIST,
        hInst, NULL);
    SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)_T("中国"));
    SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)_T("美国"));
    SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)_T("英国"));
    break;</code></pre>
    <p>
     在您提供的代码中，​
     <strong>
      动态创建的列表框控件会触发自身的
      <code>
       WM_CREATE
      </code>
      消息
     </strong>
     ，但
     <strong>
      不会再次触发父窗口的
      <code>
       WM_CREATE
      </code>
      消息
     </strong>
     。以下是详细分析：
    </p>
    <ul>
     <li>
      ​
      <strong>
       父窗口的
       <code>
        WM_CREATE
       </code>
      </strong>
      ：
      <br/>
      当父窗口（如对话框或主窗口）被创建时，系统首先触发父窗口的
      <code>
       WM_CREATE
      </code>
      。
     </li>
     <li>
      ​
      <strong>
       动态创建列表框
      </strong>
      ：
      <br/>
      在父窗口的
      <code>
       WM_CREATE
      </code>
      处理中，调用
      <code>
       CreateWindow
      </code>
      创建列表框控件。此时：
      <ol>
       <li>
        系统为列表框分配
        <code>
         HWND
        </code>
        。
       </li>
       <li>
        ​
        <strong>
         系统立即向列表框发送
         <code>
          WM_CREATE
         </code>
         消息
        </strong>
        ​（
        <span style="color:#fe2c24">
         列表框的窗口过程会处理此消息
        </span>
        ）。
       </li>
       <li>
        列表框创建完成后，父窗口的
        <code>
         WM_CREATE
        </code>
        继续执行后续代码（添加字符串）。
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      2. 消息触发顺序
     </strong>
    </h4>
    <ul>
     <li>
      ​
      <strong>
       父窗口
       <code>
        WM_CREATE
       </code>
       → 列表框
       <code>
        WM_CREATE
       </code>
       → 父窗口
       <code>
        WM_CREATE
       </code>
       继续执行
      </strong>
      <br/>
      消息队列的顺序如下：
      <ol>
       <li>
        父窗口的
        <code>
         WM_CREATE
        </code>
        开始执行。
       </li>
       <li>
        列表框被创建，触发列表框的
        <code>
         WM_CREATE
        </code>
        消息（
        <strong>
         独立于父窗口
        </strong>
        ）。
       </li>
       <li>
        列表框的
        <code>
         WM_CREATE
        </code>
        处理完成后，返回到父窗口的
        <code>
         WM_CREATE
        </code>
        ，继续执行
        <code>
         LB_ADDSTRING
        </code>
        等代码。
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      3. 关键结论
     </strong>
    </h4>
    <h5>
     ​**(1) 列表框会触发自己的
     <code>
      WM_CREATE
     </code>
     **
    </h5>
    <ul>
     <li>
      ​
      <strong>
       原因
      </strong>
      ：
      <br/>
      每个
      <code>
       CreateWindow
      </code>
      调用都会为新窗口（或控件）生成一个
      <code>
       HWND
      </code>
      ，系统会立即发送
      <code>
       WM_CREATE
      </code>
      消息到该窗口的窗口过程。
     </li>
     <li>
      ​
      <strong>
       验证方法
      </strong>
      ：
      <br/>
      如果列表框的类注册时绑定了自定义窗口过程（如
      <code>
       MyListBoxWndProc
      </code>
      ），则在该过程中会收到
      <code>
       WM_CREATE
      </code>
      消息。
     </li>
    </ul>
    <h5>
     ​**(2) 父窗口的
     <code>
      WM_CREATE
     </code>
     不会重复触发**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       原因
      </strong>
      ：
      <br/>
      <span style="color:#fe2c24">
       <code>
        WM_CREATE
       </code>
       是针对单个窗口的创建事件。父窗口的
       <code>
        WM_CREATE
       </code>
       已经完成，后续动态创建的控件不会导致父窗口的
       <code>
        WM_CREATE
       </code>
       再次触发。
      </span>
     </li>
     <li>
      ​
      <strong>
       例外情况
      </strong>
      ：
      <br/>
      如果在父窗口的
      <code>
       WM_CREATE
      </code>
      中销毁并重新创建父窗口本身（如递归调用
      <code>
       CreateWindow
      </code>
      ），才会重新触发父窗口的
      <code>
       WM_CREATE
      </code>
      。但您的代码中没有这种情况。
     </li>
    </ul>
    <h4>
     <strong>
      4. 潜在问题与改进
     </strong>
    </h4>
    <h5>
     ​**(1) 必须返回
     <code>
      TRUE
     </code>
     **
    </h5>
    <ul>
     <li>
      ​
      <strong>
       父窗口的
       <code>
        WM_CREATE
       </code>
       必须返回
       <code>
        TRUE
       </code>
      </strong>
      ，否则窗口创建失败。
      <pre><code class="language-cpp">case WM_CREATE:
    // ... 创建列表框和初始化代码
    return TRUE; // 必须添加此行
    break;</code></pre>
     </li>
    </ul>
    <h5>
     ​**(2) 列表框的
     <code>
      WM_CREATE
     </code>
     处理**
    </h5>
    <ul>
     <li>
      如果列表框是自定义控件（如继承自
      <code>
       CListBox
      </code>
      ），需确保其窗口过程正确处理
      <code>
       WM_CREATE
      </code>
      ，例如初始化内部数据。
      <pre><code class="language-cpp">// 自定义列表框窗口过程示例
LRESULT CALLBACK MyListBoxWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_CREATE:
            // 初始化列表框（例如分配内存）
            return TRUE;
        // ... 其他消息处理
    }
    return DefListBoxProc(hWnd, uMsg, wParam, lParam);
}</code></pre>
     </li>
    </ul>
    <h5>
     ​**(3) 避免在
     <code>
      WM_CREATE
     </code>
     中过早显示窗口**
    </h5>
    <ul>
     <li>
      列表框已设置
      <code>
       WS_VISIBLE
      </code>
      样式，会自动显示。但由于父窗口的布局尚未完成（如
      <code>
       WM_SIZE
      </code>
      消息未处理），可能导致显示位置不准确。
      <br/>
      ​
      <strong>
       建议
      </strong>
      ：
      <ul>
       <li>
        在父窗口的
        <code>
         WM_SIZE
        </code>
        中调整子窗口位置/大小。
       </li>
       <li>
        或延迟控件创建（如在
        <code>
         WM_INITDIALOG
        </code>
        中创建对话框控件）。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      5. 完整消息流程图
     </strong>
    </h4>
    <pre><code class="language-cpp">[父窗口 WM_CREATE] 
  ↓ 
创建列表框控件 → 
  ↓ 
[列表框 WM_CREATE] 
  ↓ 
返回到父窗口 WM_CREATE → 
执行 LB_ADDSTRING → 
父窗口 WM_CREATE 结束 → 
父窗口继续处理其他消息（如 WM_SIZE）</code></pre>
    <hr/>
    <h4>
     ​
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      ​
      <strong>
       动态创建的列表框会触发自身的
       <code>
        WM_CREATE
       </code>
      </strong>
      ，但这是独立于父窗口的。
     </li>
     <li>
      ​
      <strong>
       父窗口的
       <code>
        WM_CREATE
       </code>
       仅触发一次
      </strong>
      ，在其处理期间创建的控件会依次触发各自的
      <code>
       WM_CREATE
      </code>
      。
     </li>
     <li>
      确保父窗口和子窗口的
      <code>
       WM_CREATE
      </code>
      处理函数均返回
      <code>
       TRUE
      </code>
      ，否则创建流程会失败。
     </li>
    </ul>
    <p>
    </p>
    <h3>
     动态创建的列表框会触发自身的 WM_CREATE，如何处理？
    </h3>
    <p>
     动态创建的列表框会触发自身的
     <code>
      WM_CREATE
     </code>
     消息，但
     <strong>
      是否需要处理取决于控件的类型和需求
     </strong>
     ：
    </p>
    <hr/>
    <h4>
     ​
     <strong>
      1. 是否需要处理子窗口的
      <code>
       WM_CREATE
      </code>
      ？
     </strong>
    </h4>
    <h5>
     ​**(1) 标准控件（如
     <code>
      ListBox
     </code>
     /
     <code>
      Button
     </code>
     ）​**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       通常不需要处理
      </strong>
      ：
      <br/>
      Windows 系统已为标准控件实现了默认的窗口过程（如
      <code>
       DefWindowProc
      </code>
      或控件类专用过程），
      <code>
       WM_CREATE
      </code>
      已被内部处理（例如初始化控件样式、关联资源）。
     </li>
     <li>
      ​
      <strong>
       例外情况
      </strong>
      ：
      <br/>
      如果需要在控件创建时执行
      <strong>
       自定义初始化逻辑
      </strong>
      ​（如分配内存、加载数据或绑定事件），则需要处理
      <code>
       WM_CREATE
      </code>
      。
     </li>
    </ul>
    <h5>
     ​**(2) 自定义控件**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       必须处理
      </strong>
      ：
      <br/>
      如果控件是自行实现的（如继承自
      <code>
       CWnd
      </code>
      的类），则需在
      <code>
       WM_CREATE
      </code>
      中完成
      <strong>
       类成员初始化
      </strong>
      、
      <strong>
       资源分配
      </strong>
      或
      <strong>
       消息映射绑定
      </strong>
      等操作。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      2. 如何处理子窗口的
      <code>
       WM_CREATE
      </code>
      ？
     </strong>
    </h4>
    <h5>
     ​**(1) 标准控件的处理方式**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       无需手动处理
      </strong>
      ：
      <br/>
      直接依赖系统默认逻辑即可。
     </li>
     <li>
      ​
      <strong>
       间接扩展
      </strong>
      ：
      <br/>
      若需修改标准控件的默认行为，可通过
      <strong>
       子类化（Subclassing）​
      </strong>
      覆盖其窗口过程。
     </li>
    </ul>
    <h5>
     ​**(2) 自定义控件的处理方式**
    </h5>
    <ul>
     <li>
      ​
      <strong>
       步骤
      </strong>
      ：
      <ol>
       <li>
        ​
        <strong>
         注册窗口类
        </strong>
        ：
        <br/>
        <span style="color:#fe2c24">
         使用
         <code>
          RegisterClassEx
         </code>
         注册自定义控件的窗口类，并指定窗口过程
        </span>
        （如
        <code>
         MyListBoxProc
        </code>
        ）。
       </li>
       <li>
        ​
        <strong>
         在
         <code>
          WM_CREATE
         </code>
         中初始化
        </strong>
        ：
        <br/>
        在自定义窗口过程中处理
        <code>
         WM_CREATE
        </code>
        ，执行初始化代码。
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      3. 代码示例
     </strong>
    </h4>
    <h5>
     ​**(1) 自定义控件类（C++/MFC）​**
    </h5>
    <pre><code class="language-cpp">// 自定义列表框窗口过程
LRESULT CALLBACK MyListBoxProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_CREATE: {
            // 自定义初始化代码（例如分配内存）
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)new CMyData());
            return TRUE;
        }
        // 其他消息处理...
    }
    return DefListBoxProc(hWnd, uMsg, wParam, lParam); // 调用默认处理
}

// 注册窗口类
WNDCLASSEX wc = {0};
wc.lpfnWndProc = MyListBoxProc;
wc.hInstance = hInst;
wc.lpszClassName = L"MyCustomListBox";
RegisterClassEx(&amp;wc);

// 创建自定义列表框
hListBox = CreateWindowEx(
    0, L"MyCustomListBox", NULL,
    WS_CHILD | WS_VISIBLE,
    20, 20, 60, 120,
    hWndParent, (HMENU)ID_MYLIST,
    hInst, NULL);</code></pre>
    <h5>
     ​**(2) 标准控件的
     <code>
      WM_CREATE
     </code>
     处理（可选）​**
    </h5>
    <p>
     即使不处理
     <code>
      WM_CREATE
     </code>
     ，也可以通过以下方式在创建后立即操作控件：
    </p>
    <pre><code class="language-cpp">// 在父窗口的 WM_CREATE 中创建列表框后
SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)_T("中国")); // 添加字符串</code></pre>
    <hr/>
    <h4>
     ​
     <strong>
      4. 总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        ​
        <strong>
         场景
        </strong>
       </th>
       <th>
        ​
        <strong>
         是否需要处理
         <code>
          WM_CREATE
         </code>
        </strong>
       </th>
       <th>
        ​
        <strong>
         处理位置
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        标准控件（如
        <code>
         ListBox
        </code>
        ）
       </td>
       <td>
        通常不需要
       </td>
       <td>
        系统默认窗口过程（无需手动处理）
       </td>
      </tr>
      <tr>
       <td>
        自定义控件
       </td>
       <td>
        必须处理
       </td>
       <td>
        自定义窗口过程（如
        <code>
         MyListBoxProc
        </code>
        ）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     ​
     <strong>
      关键点
     </strong>
    </h4>
    <ul>
     <li>
      ​
      <strong>
       标准控件
      </strong>
      ：
      <br/>
      依赖系统默认行为，若需扩展功能，建议通过
      <strong>
       消息反射
      </strong>
      ​（如 MFC 的
      <code>
       ON_CONTROL通知
      </code>
      ）或
      <strong>
       子类化
      </strong>
      实现。
     </li>
     <li>
      ​
      <strong>
       自定义控件
      </strong>
      ：
      <br/>
      必须在
      <code>
       WM_CREATE
      </code>
      中完成初始化，否则可能导致控件行为异常。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32303732353232312f:61727469636c652f64657461696c732f313436313731323835" class_="artid" style="display:none">
 </p>
</div>


