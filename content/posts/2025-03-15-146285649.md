---
layout: post
title: "pytest-框架学习总结"
date: 2025-03-15 21:55:42 +0800
description: "基于 Python 语言的自动化测试框架 最知名的 有如下 3 款unittest、pytest、robotframework前两款框架主要（或者说很大程度上）是 聚焦 在 白盒单元测试而 robotframework 主要聚焦在 系统测试。pytest可以利用第三方插件，生成表报。"
keywords: "pytest 框架学习总结"
categories: ['未分类']
tags: ['学习', 'Pytest']
artid: "146285649"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146285649
    alt: "pytest-框架学习总结"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146285649
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146285649
cover: https://bing.ee123.net/img/rand?artid=146285649
image: https://bing.ee123.net/img/rand?artid=146285649
img: https://bing.ee123.net/img/rand?artid=146285649
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     pytest 框架学习总结
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     视频：
     <a href="https://www.bilibili.com/video/BV1bV41167a4/?p=1" rel="nofollow" title="pytest01-快速上手_哔哩哔哩_bilibili">
      pytest01-快速上手_哔哩哔哩_bilibili
     </a>
    </p>
    <p>
     资料：
     <a href="https://www.byhy.net/auto/pyatframework/pytest-01/" rel="nofollow" title="pytest 框架 - 白月黑羽">
      pytest 框架 - 白月黑羽
     </a>
    </p>
    <p>
     基于 Python 语言的自动化测试框架 最知名的 有如下 3 款unittest、pytest、robotframework
    </p>
    <p>
     前两款框架主要（或者说很大程度上）是 聚焦 在 白盒单元测试而 robotframework 主要聚焦在 系统测试。
    </p>
    <p>
     pytest可以利用第三方插件，生成表报。
    </p>
    <h3 id="_1">
     安装：
    </h3>
    <p>
     安装直接执行命令：pip install pytest
    </p>
    <p>
     还需要产生测试报表，执行如下命令安装：pip install pytest-html
    </p>
    <h3 id="_2">
     快速上手：
    </h3>
    <p id="_3">
     <strong>
      测试用例代码规格：
     </strong>
     我们编写的测试用例代码文件， 必须以
     <code>
      test_
     </code>
     开头，或者以
     <code>
      _test
     </code>
     结尾
    </p>
    <p>
     要求：类名（Class 类名）必须以Test为前缀，其中的类方法（def 类方法）必须以test为前缀。
    </p>
    <p>
     pytest 中用例的检查点 直接用 Python 的 assert 断言。assert 后面的表达式结果 为 True ，就是 检查点 通过，结果为False ，就是检查点 不通过。和hytest中的check_point（）方法不一样。
    </p>
    <p>
     <strong>
      执行
     </strong>
     ：pytest  或者pytest+对应目录。直接执行
     <code>
      pytest
     </code>
     命令不会将当前目录设置为模块搜索路径
     <br/>
     所以更推荐 执行命令
     <code>
      python -m pytest 。
     </code>
    </p>
    <p>
     目前 项目根目录 中 只有一个cases 目录用例存放测试用例， 将来还会有其他目录，比如：lib目录存放库代码、cfg目录存放配置数据 等等。为了防止 pytest 到其他目录中找测试用例项，执行测试时，我们可以在命令行加上目标目录 cases ，就是这样：python -m pytest cases
    </p>
    <p id="_5">
     <strong>
      产生报告
     </strong>
     ：python -m pytest cases
     <span style="color:#fe2c24">
      --html=report.html --self-contained-html
     </span>
    </p>
    <p>
    </p>
    <h3 id="_6">
     初始化清除：
    </h3>
    <p>
     对自动化测试框架来说，初始化清除功能 至关重要。
    </p>
    <p id="_7">
     <strong>
      模块级别
     </strong>
     ：
     <code>
      模块级别
     </code>
     的初始化、清除 分别 在
     <span style="color:#fe2c24">
      整个模块
     </span>
     的测试用例 执行前后执行，并且
     <code>
      只会执行1次
     </code>
     。定义 setup_module 和 teardown_module 全局函数。和hytest中的名称不一样。
    </p>
    <pre><code>def setup_module():
    print('\n *** 初始化-模块 ***')

def teardown_module():
    print('\n ***   清除-模块 ***')</code></pre>
    <p id="_8">
     <strong>
      类级别
     </strong>
     ：
     <code>
      类级别
     </code>
     的初始化、清除 分别 在
     <span style="color:#fe2c24">
      整个类
     </span>
     的测试用例 执行前后执行，并且
     <code>
      只会执行1次。
     </code>
     定义 setup_class 和 teardown_class 类方法。主要是用来为该
     <code>
      类
     </code>
     中的所有测试用例做
     <code>
      公共的
     </code>
     初始化 和 清除。
    </p>
    <pre><code>def setup_module():
    print('\n *** 初始化-模块 ***')

def teardown_module():
    print('\n ***   清除-模块 ***')

class Test_错误密码:

    @classmethod
    def setup_class(cls):
        print('\n === 初始化-类 ===')

    @classmethod
    def teardown_class(cls):
        print('\n === 清除 - 类 ===')</code></pre>
    <p id="_9">
     <strong>
      方法级别
     </strong>
     ：方法级别 的初始化、清除 分别 在
     <span style="color:#fe2c24">
      类的 每个测试方法
     </span>
     执行前后执行，并且
     <code>
      <span style="color:#fe2c24">
       每个用例分别执行1次
      </span>
      。
     </code>
     定义 setup_method 和 teardown_method 实例方法
    </p>
    <pre><code>class Test_错误密码:

    @classmethod
    def setup_class(cls):
        print('\n === 初始化-类 ===')

    @classmethod
    def teardown_class(cls):
        print('\n === 清除 - 类 ===')

    def setup_method(self):
        print('\n --- 初始化-方法  ---')

    def teardown_method(self):
        print('\n --- 清除  -方法 ---')</code></pre>
    <p id="_10">
     <strong>
      目录级别
     </strong>
     ：目标级别的 初始化清除，就是针对整个目录执行的初始化、清除。需要在初始化的目录下面创建 一个名为
     <code>
      conftest.py
     </code>
     的文件，里面内容如下所示
    </p>
    <pre id="__code_13"><code>import pytest 

@pytest.fixture(scope='package',autouse=True)
def st_emptyEnv():
    print(f'\n#### 初始化-目录甲')
//这里清除环境的代码就是 yield 之后的代码。 这是一个生成器
    yield

    print(f'\n#### 清除-目录甲')</code></pre>
    <h3>
    </h3>
    <h3 id="_11">
     挑选用例执行:
    </h3>
    <p id="_12">
     <strong>
      指定一个模块
     </strong>
     :python -m pytest cases\登录\test_错误登录.py
     <br/>
     <strong>
      指定目录
     </strong>
     :python -m pytest cases
     <br/>
     <strong>
      指定模块里面的函数或者类
     </strong>
     :python -m pytest cases\登录\test_错误登录.py::Test_错误密码
    </p>
    <p id="_15">
     <strong>
      根据名字
     </strong>
     :使用 命令行
     <span style="color:#fe2c24">
      参数 -k
     </span>
     后面加名字来挑选要执行的测试项.
     <br/>
     例如：python -m pytest -k C001001 -s
    </p>
    <p>
     -k 后面的名字：可以是测试函数的名字，可以是类的名字，可以是模块文件名，可以是目录的名字；是大小写敏感的；不一定要完整，只要能有部分匹配上就行；可以用 not 表示选择名字中不包含。
    </p>
    <p id="_16">
     <strong>
      根据标签
     </strong>
     ：需要先给标签，然后再使用此方法-m。标签也支持中文.
    </p>
    <pre id="__code_23"><code>import pytest

class Test_错误密码2:

    @pytest.mark.webtest    //或者@pytest.mark.网页测试
    def test_C001021(self):
        print('\n用例C001021')
        assert 1 == 1
</code></pre>
    <p>
     然后，可以这样运行指定标签的用例：python -m pytest cases -m webtest -s
    </p>
    <p>
    </p>
    <h3 id="pytest_1">
     Pytest 助手：
    </h3>
    <p>
     大佬开发的助手。看看即可。
    </p>
    <h3 id="_17">
     实战案例：
    </h3>
    <p>
     这样执行命令
    </p>
    <pre id="__code_32"><code>python -m pytest cases -sv
</code></pre>
    <p>
     因为
     <code>
      -m
     </code>
     这种执行模块的方式运行python， 会自动把当前工作目录作为模块搜索路径，这样就能避免Python解释器 搜索不到 库文件的问题
     <code>
      ModuleNotFoundError: No module named 'xxxx'
     </code>
     。
    </p>
    <p>
     但是，实际上仍然会出现这种问题。如果以上方法没能解决。可以尝试使用：pip install pytest。
    </p>
    <p>
     这样就会在类方法旁边形成一个可以运行的按钮。直接点击运行按钮即可。
    </p>
    <p>
    </p>
    <h3 id="_18" style="background-color:transparent">
     数据驱动：
    </h3>
    <p>
     和hytest的用法一样。只是方法名不一样。简约很多了！！！
    </p>
    <pre><code class="hljs">class Test_错误登录:
    @pytest.mark.parametrize('username, password, expectedalert', [
        (None, '88888888', '请输入用户名'),
        ('byhy', None, '请输入密码'),
        ('byh', '88888888', '登录失败 : 用户名或者密码错误'),
        ('byhy', '8888888', '登录失败 : 用户名或者密码错误'),
        ('byhy', '888888888', '登录失败 : 用户名或者密码错误'),
    ]
                             )
    def test_UI_0001_0005(self, username, password, expectedalert):
        alertText = loginAndCheck(username, password)
        assert alertText == expectedalert</code></pre>
    <h3 id="_19">
     调试：
    </h3>
    <p>
     添加断点。
    </p>
    <h3 id="fixture" style="background-color:transparent">
     使用 fixture（清除）：
    </h3>
    <p id="_20">
     <strong>
      使用方法
     </strong>
     ：相比前面讲的初始化清除方法，fixture 最大的特点是：声明式使用。就是：测试方法需要那个初始化清除，就在参数里面声明它。先来看初始化：其实就是依赖注入。
    </p>
    <p>
     # 定义一个fixture函数 @pytest.fixture def createzhangSan(): 。。。  //会先执行此函数方法
    </p>
    <p>
     这就是 pytest 的
     <code>
      denpendcy injection
     </code>
     中文称之为 ：
     <span style="color:#fe2c24">
      <code>
       依赖注入
      </code>
     </span>
     。
    </p>
    <p id="_21">
     <strong>
      清除
     </strong>
     ：如果需要清除，最推荐的使用
     <code>
      yield
     </code>
     代替
     <code>
      return
     </code>
     ， yield后面的代码就是清除部分的代码。
    </p>
    <p id="fixture_1">
     <strong>
      fixture 参数
     </strong>
     ：需要根据参数来创建不同的用户，就需要使用 parametrize 装饰器，并指定参数
     <code>
      indirect=True
     </code>
    </p>
    <p>
     fixture学的东西较多，暂时跳过，后面用到时可以翻阅资料在写。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35353932383038362f:61727469636c652f64657461696c732f313436323835363439" class_="artid" style="display:none">
 </p>
</div>


