---
layout: post
title: "kafka-rocketmq-rabbitmq-都是怎么实现顺序消费的"
date: 2025-03-14 00:22:39 +0800
description: "特性KafkaRocketMQRabbitMQ顺序性保证分区内有序，分区间无序队列内有序，队列间无序默认不保证顺序全局顺序消费单分区主题或按 Key 分区单队列主题或按 Key 选择队列单队列单消费者或消息分组并行处理能力高（多分区）高（多队列）低（单队列单消费者）实现复杂度中等中等高（需要外部排序或分组）适用场景高吞吐量、分区顺序消费高吞吐量、队列顺序消费低吞吐量、简单顺序消费Kafka和RocketMQ通过分区或队列的机制，天然支持分区或队列内的顺序消费，适合高吞吐量的场景。"
keywords: "kafka rocketmq rabbitmq 都是怎么实现顺序消费的"
categories: ['未分类']
tags: ['Rocketmq', 'Rabbitmq', 'Kafka']
artid: "146245684"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146245684
    alt: "kafka-rocketmq-rabbitmq-都是怎么实现顺序消费的"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146245684
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146245684
cover: https://bing.ee123.net/img/rand?artid=146245684
image: https://bing.ee123.net/img/rand?artid=146245684
img: https://bing.ee123.net/img/rand?artid=146245684
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     kafka rocketmq rabbitmq 都是怎么实现顺序消费的
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      Kafka
     </strong>
     、
     <strong>
      RocketMQ
     </strong>
     和
     <strong>
      RabbitMQ
     </strong>
     都支持顺序消费，但它们的实现机制有所不同。以下是这三种消息队列实现顺序消费的方式：
    </p>
    <hr/>
    <h3>
     1.
     <strong>
      Kafka 的顺序消费
     </strong>
    </h3>
    <h4>
     实现机制
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        分区内有序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Kafka 保证单个分区（Partition）内的消息是有序的。
        </p>
       </li>
       <li>
        <p>
         消息按照写入分区的顺序存储，消费者按照相同的顺序消费。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分区间无序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         不同分区之间的消息顺序是不保证的。
        </p>
       </li>
       <li>
        <p>
         例如，消息 A 写入分区 0，消息 B 写入分区 1，消费者可能会先消费到消息 B，再消费到消息 A。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     实现全局顺序消费的方式
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        单分区主题
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         将主题设置为只有一个分区，这样所有消息都会写入同一个分区，自然保证了全局顺序。
        </p>
       </li>
       <li>
        <p>
         <strong>
          缺点
         </strong>
         ：牺牲了 Kafka 的并行处理能力，吞吐量会受到限制。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        按消息键（Key）分区
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在生产者端，为每条消息指定一个键（Key），Kafka 会根据 Key 的哈希值将消息分配到特定的分区。
        </p>
       </li>
       <li>
        <p>
         如果需要保证某类消息的顺序，可以将这类消息的 Key 设置为相同的值，这样它们会被分配到同一个分区。
        </p>
       </li>
       <li>
        <p>
         例如，订单系统中可以将订单 ID 作为 Key，确保同一个订单的消息都进入同一个分区。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        消费者端排序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在消费者端，可以通过缓存和排序机制来实现多个分区的总体有序消费。
        </p>
       </li>
       <li>
        <p>
         例如：
        </p>
        <ol>
         <li>
          <p>
           消费者从多个分区拉取消息。
          </p>
         </li>
         <li>
          <p>
           将消息按时间戳或序列号缓存到内存中。
          </p>
         </li>
         <li>
          <p>
           对缓存的消息进行排序，然后按顺序处理。
          </p>
         </li>
        </ol>
       </li>
       <li>
        <p>
         <strong>
          缺点
         </strong>
         ：实现复杂，可能会增加延迟和内存开销。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     2.
     <strong>
      RocketMQ 的顺序消费
     </strong>
    </h3>
    <h4>
     实现机制
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        队列内有序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         RocketMQ 保证单个队列（Queue）内的消息是有序的。
        </p>
       </li>
       <li>
        <p>
         消息按照写入队列的顺序存储，消费者按照相同的顺序消费。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        队列间无序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         不同队列之间的消息顺序是不保证的。
        </p>
       </li>
       <li>
        <p>
         例如，消息 A 写入队列 0，消息 B 写入队列 1，消费者可能会先消费到消息 B，再消费到消息 A。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     实现全局顺序消费的方式
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        单队列主题
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         将主题设置为只有一个队列，这样所有消息都会写入同一个队列，自然保证了全局顺序。
        </p>
       </li>
       <li>
        <p>
         <strong>
          缺点
         </strong>
         ：牺牲了 RocketMQ 的并行处理能力，吞吐量会受到限制。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        按消息键（Key）选择队列
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在生产者端，为每条消息指定一个键（Key），RocketMQ 会根据 Key 的哈希值将消息分配到特定的队列。
        </p>
       </li>
       <li>
        <p>
         如果需要保证某类消息的顺序，可以将这类消息的 Key 设置为相同的值，这样它们会被分配到同一个队列。
        </p>
       </li>
       <li>
        <p>
         例如，订单系统中可以将订单 ID 作为 Key，确保同一个订单的消息都进入同一个队列。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        顺序消息 API
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         RocketMQ 提供了顺序消息的 API，生产者可以指定消息的顺序 Key，消费者可以按顺序消费。
        </p>
       </li>
       <li>
        <p>
         例如：
        </p>
        <ul>
         <li>
          <p>
           生产者使用
           <code>
            MessageQueueSelector
           </code>
           选择队列。
          </p>
         </li>
         <li>
          <p>
           消费者使用
           <code>
            MessageListenerOrderly
           </code>
           按顺序消费消息。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     3.
     <strong>
      RabbitMQ 的顺序消费
     </strong>
    </h3>
    <h4>
     实现机制
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        默认不保证顺序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         RabbitMQ 默认不保证消息的顺序性，因为消息可能会被分发到不同的消费者实例，或者由于重试机制导致消息乱序。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     实现顺序消费的方式
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        单队列单消费者
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         将队列绑定到一个消费者实例，确保消息按顺序消费。
        </p>
       </li>
       <li>
        <p>
         <strong>
          缺点
         </strong>
         ：无法实现并行处理，吞吐量较低。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        消息分组
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在生产者端，将需要保证顺序的消息分组，并将同一组的消息发送到同一个队列。
        </p>
       </li>
       <li>
        <p>
         在消费者端，确保同一组的消息由同一个消费者实例处理。
        </p>
       </li>
       <li>
        <p>
         例如，订单系统中可以将同一个订单的消息发送到同一个队列。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        外部排序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在消费者端，可以通过缓存和排序机制来实现顺序消费。
        </p>
       </li>
       <li>
        <p>
         例如：
        </p>
        <ol>
         <li>
          <p>
           消费者从队列中拉取消息。
          </p>
         </li>
         <li>
          <p>
           将消息按时间戳或序列号缓存到内存中。
          </p>
         </li>
         <li>
          <p>
           对缓存的消息进行排序，然后按顺序处理。
          </p>
         </li>
        </ol>
       </li>
       <li>
        <p>
         <strong>
          缺点
         </strong>
         ：实现复杂，可能会增加延迟和内存开销。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     对比总结
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        Kafka
       </th>
       <th>
        RocketMQ
       </th>
       <th>
        RabbitMQ
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         顺序性保证
        </strong>
       </td>
       <td>
        分区内有序，分区间无序
       </td>
       <td>
        队列内有序，队列间无序
       </td>
       <td>
        默认不保证顺序
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         全局顺序消费
        </strong>
       </td>
       <td>
        单分区主题或按 Key 分区
       </td>
       <td>
        单队列主题或按 Key 选择队列
       </td>
       <td>
        单队列单消费者或消息分组
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         并行处理能力
        </strong>
       </td>
       <td>
        高（多分区）
       </td>
       <td>
        高（多队列）
       </td>
       <td>
        低（单队列单消费者）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         实现复杂度
        </strong>
       </td>
       <td>
        中等
       </td>
       <td>
        中等
       </td>
       <td>
        高（需要外部排序或分组）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        高吞吐量、分区顺序消费
       </td>
       <td>
        高吞吐量、队列顺序消费
       </td>
       <td>
        低吞吐量、简单顺序消费
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Kafka
       </strong>
       和
       <strong>
        RocketMQ
       </strong>
       通过分区或队列的机制，天然支持分区或队列内的顺序消费，适合高吞吐量的场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        RabbitMQ
       </strong>
       默认不保证顺序，需要通过单队列单消费者或消息分组的方式实现顺序消费，适合低吞吐量的场景。
      </p>
     </li>
     <li>
      <p>
       如果需要全局顺序消费，可以通过单分区/单队列、按 Key 分区/队列或外部排序的方式实现，但需要权衡吞吐量和实现复杂度。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f4331383239383138323537352f:61727469636c652f64657461696c732f313436323435363834" class_="artid" style="display:none">
 </p>
</div>


