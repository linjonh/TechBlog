---
layout: post
title: "slf4j和log4j的区别与使用"
date: 2025-03-04 18:11:54 +0800
description: "官网：https://www.slf4j.org/manual.html(1)简单日记门面(simple logging Facade for Java)SLF4J是为各种loging APIs提供一个简单统一的接口。(2)slf4j并不是一种具体的日志系统，而是一个用户日志系统的facade。(3)在部署时，选择不同的日志系统包，即可自动转换到不同的日志系统上。"
keywords: "springboot log4j 和 slf4j"
categories: ['Java']
tags: ['单元测试', 'Python', 'Log']
artid: "146023363"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146023363
    alt: "slf4j和log4j的区别与使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146023363
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146023363
cover: https://bing.ee123.net/img/rand?artid=146023363
image: https://bing.ee123.net/img/rand?artid=146023363
img: https://bing.ee123.net/img/rand?artid=146023363
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     slf4j和log4j的区别与使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     slf4j和log4j的区别与使用
    </p>
    <h5>
     <a id="_2">
     </a>
     文章目录
    </h5>
    <ul>
     <li>
      <ul>
       <li>
        <a href="#1_1" rel="nofollow">
         1.简介
        </a>
       </li>
       <li>
        <a href="#2_23" rel="nofollow">
         2.使用教程
        </a>
       </li>
       <li>
        <a href="#3_190" rel="nofollow">
         3.常见报错解决（持续更新）
        </a>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="1_8">
     </a>
     1.简介
    </h4>
    <p>
     官网：https://www.slf4j.org/manual.html
     <br/>
     (1)简单日记门面(simple logging Facade for Java)SLF4J是为各种loging APIs提供一个简单统一的接口。
    </p>
    <p>
     (2)slf4j并不是一种具体的日志系统，而是一个用户日志系统的facade。
    </p>
    <p>
     (3)在部署时，选择不同的日志系统包，即可自动转换到不同的日志系统上。
     <br/>
     如：选择JDK自带的日志系统，则只需要将slf4j-api-XXX.jar和slf4j-jdkXXX.jar放置到classpath中即可，若想换成log4j的日志系统，仅需要用slf4j-log4jXXx.jar替换slf4j-jdkXXX.jar即可
    </p>
    <p>
     (4)slf4j和log4j比较:
     <br/>
     ①log4j看成是一个完整的日志库；而slf4j是一个日志库的规范接口,可以根据不同的日志包使用不同的日志库。
     <br/>
     ②日志中需要传入参数时，log4j一般是使用字符串进行拼接的方式;
     <br/>
     slf4j使用占位符，比字符串拼接更加高效。如logger.error("sql为 {} ",sql)。
    </p>
    <p>
     (5)slf4j日志级别
     <br/>
     Slf4j日志级别,级别由低到高，设置的级别约低，打印的日志越多
     <br/>
     ①trace: 一般不会使用，在日志里边也不会打印出来，最低的一个日志级别。
     <br/>
     ②debug: 一般放于程序的某个关键点的地方，用于打印一个变量值或者一个方法返回的信息之类的信息
     <br/>
     ③info 一般处理业务逻辑的时候使用，就跟 system.err打印一样，用于说明此处是干什么的。
     <br/>
     ④warn：警告，不会影响程序的运行，但是值得注意。
     <br/>
     ⑤error： 用户程序报错，必须解决的时候使用此级别打印日志。
    </p>
    <h4>
     <a id="2_31">
     </a>
     2.使用教程
    </h4>
    <p>
     官网上最新稳定版是1.7.32，前阵子log4j出重大漏洞了，这里我们配合logback（log4j的改良版，性能更好）使用。
     <br/>
     (1)在pom.xml引入依赖
    </p>
    <pre><code>  &lt;!--slf4j依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.32&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- logback 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
    <p>
     (2)在springBoot项目中添加一段controller代码
    </p>
    <pre><code>package com.example.springb_web.controller;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class VisualController {

    private Logger logger = LoggerFactory.getLogger(VisualController.class);

    @RequestMapping(value="/test")
    @ResponseBody
    public String test(){
        String msg = "fucking good";
        logger.info("slf4j print info msg:{}",msg);
        logger.debug("slf4j print debug msg:{}",msg);
        return msg;
    }

}
</code></pre>
    <p>
     这里通过http://localhost:8080/test访问可以看到控制台输出如下，可以看到info的输出了，debug没有，因为springboot内部集成了slf4j，默认是info级别：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bf2a972f501f2a29ab14eb1091ed9ac8.png"/>
    </p>
    <p>
     (3)只在控制台打印，application.yml文件配置如下：
    </p>
    <pre><code># slf4j日志配置
logging:
  # 配置级别
  level:
    root: info
    #分包配置级别，即不同的目录下可以使用不同的级别
    com.example.springb_web.controller: debug
</code></pre>
    <p>
     改完之后发现输出如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a6bc6a44f6bc3a2aec15d6eedcacb3ef.png">
      <br/>
      (4)把日志输出到文件，application.yml配置：
     </img>
    </p>
    <pre><code># slf4j日志配置
logging:
  config: classpath:logback.xml
</code></pre>
    <p>
     在resource下新建logback.xml：
    </p>
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;

	&lt;!--info日志文件--&gt;
	&lt;appender name="INFO_FILE"
		class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
		&lt;!--日志文件相对路径和名称--&gt;
		&lt;file&gt;./apilogs/info/xxxx_-${HOSTNAME}.log&lt;/file&gt;
		&lt;append&gt;true&lt;/append&gt;
		&lt;!--根据日志文件的大小来滚动（即创建新的）日志文件--&gt;
		&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
			&lt;fileNamePattern&gt;./apilogs/info/archive/xxxx_-${HOSTNAME}-%d.%i.log&lt;/fileNamePattern&gt;
			&lt;!--只保留最近30天的日志--&gt;
			&lt;maxHistory&gt;30&lt;/maxHistory&gt;
			&lt;timeBasedFileNamingAndTriggeringPolicy
				class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;
				&lt;!--超过10MB便会滚动日志文件--&gt;
				&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
			&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
		&lt;/rollingPolicy&gt;
		&lt;!-- 配置日志的输出格式 --&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;%date %level [%thread] %logger{10} %msg%n&lt;/pattern&gt;
			&lt;charset&gt;UTF-8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;

	&lt;!--异步处理--&gt;
	&lt;appender name="ASYNC_INFO_FILE" class="ch.qos.logback.classic.AsyncAppender"&gt;
		&lt;queueSize&gt;512&lt;/queueSize&gt;
		&lt;appender-ref ref="INFO_FILE" /&gt;
	&lt;/appender&gt;

	&lt;!--debug日志文件--&gt;
	&lt;appender name="DEBUG_FILE"
		class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
		&lt;!--日志文件相对路径和名称--&gt;
		&lt;file&gt;./apilogs/debug/xxxx_-${HOSTNAME}.log&lt;/file&gt;
		&lt;append&gt;true&lt;/append&gt;
		&lt;!--根据日志文件的大小来滚动（即创建新的）日志文件--&gt;
		&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
			&lt;fileNamePattern&gt;./apilogs/debug/archive/xxxx_-${HOSTNAME}-%d.%i.log&lt;/fileNamePattern&gt;
			&lt;!--只保留最近30天的日志--&gt;
			&lt;maxHistory&gt;30&lt;/maxHistory&gt;
			&lt;timeBasedFileNamingAndTriggeringPolicy
				class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;
				&lt;!--超过10MB便会滚动日志文件--&gt;
				&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
			&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
		&lt;/rollingPolicy&gt;
		&lt;!-- 配置日志的输出格式 --&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;%date %level [%thread] %logger{10} %msg%n&lt;/pattern&gt;
			&lt;charset&gt;UTF-8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;

	&lt;!--异步处理--&gt;
	&lt;appender name="ASYNC_DEBUG_FILE" class="ch.qos.logback.classic.AsyncAppender"&gt;
		&lt;queueSize&gt;512&lt;/queueSize&gt;
		&lt;appender-ref ref="DEBUG_FILE" /&gt;
	&lt;/appender&gt;

	&lt;!--控制台输出--&gt;
	&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
		&lt;encoder&gt;
			&lt;!--输出格式--&gt;
			&lt;pattern&gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern&gt;
			&lt;charset&gt;UTF-8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;

	&lt;!--异步处理--&gt;
	&lt;appender name="ASYNC-STDOUT" class="ch.qos.logback.classic.AsyncAppender"&gt;
		&lt;queueSize&gt;512&lt;/queueSize&gt;
		&lt;appender-ref ref="STDOUT" /&gt;
	&lt;/appender&gt;

	&lt;!--在info级别下，将包名所在org.springframework的日志全部打印到控制台--&gt;
	&lt;!--additivity被设置为'false'，这意味着日志事件不会传递给父级记录器--&gt;
	&lt;logger name="org.springframework" level="info" additivity="false"&gt;
		&lt;appender-ref ref="ASYNC-STDOUT" /&gt;
	&lt;/logger&gt;

	&lt;!--在debug级别下，会打印记录sql的相关日志，将包名为org.apache.ibatis下的日志输出到debug日志文件--&gt;
	&lt;logger name="org.apache.ibatis" level="debug" additivity="false"&gt;
		&lt;appender-ref ref="ASYNC_DEBUG_FILE" /&gt;
	&lt;/logger&gt;

	&lt;!--所有业务相关的info日志，打印到控制台，并输出到info日志文件--&gt;
	&lt;root level="info"&gt;
		&lt;appender-ref ref="ASYNC-STDOUT" /&gt;
		&lt;appender-ref ref="ASYNC_INFO_FILE" /&gt;
	&lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
    <p>
     可以看到控制台和日志文件都成功输出了：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0e81c3e03d3187bb802b3c7dc1ae7cd5.png"/>
    </p>
    <h4>
     <a id="3_203">
     </a>
     3.常见报错解决（持续更新）
    </h4>
    <p>
     (1)yml配置报错如：
     <br/>
     “Failed to bind properties under ‘logging.level’”
     <br/>
     可能跟版本有关，参考yml配置上面的使用教程的第(3)步
    </p>
    <p>
     (2)启动时报错：
     <br/>
     “class path contains multiple slf4j bindings
     <br/>
     found binding in …”
     <br/>
     不要忽视这种警告，若有多个jar包类冲突，需要把加载jar包顺序调整，正确的那个，比如slf4j-log4j12jar包放在最上面。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343638323236342f:61727469636c652f64657461696c732f313436303233333633" class_="artid" style="display:none">
 </p>
</div>


