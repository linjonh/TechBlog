---
layout: post
title: "react中的useContext-弊端二"
date: 2025-03-06 19:19:13 +0800
description: "方面非常有用，但它并不是万能的。在某些情况下，它可能会带来。中存储的数据结构过于复杂，会导致代码变得难以管理。，因为它会导致整个组件重新渲染。只能在 React 组件树的。如果某个状态变化非常频繁（如。，代码更清晰，维护更容易。"
keywords: "react usecontent的缺点"
categories: ['React']
tags: ['前端', 'React', 'Javascript']
artid: "146078123"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146078123
    alt: "react中的useContext-弊端二"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146078123
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146078123
cover: https://bing.ee123.net/img/rand?artid=146078123
image: https://bing.ee123.net/img/rand?artid=146078123
img: https://bing.ee123.net/img/rand?artid=146078123
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     react中的useContext-弊端（二）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <code>
      useContext
     </code>
     在解决
     <strong>
      “props 传递地狱”
     </strong>
     方面非常有用，但它并不是万能的。在某些情况下，它可能会带来
     <strong>
      性能问题和维护上的挑战
     </strong>
     。以下是
     <code>
      useContext
     </code>
     的几个主要弊端：
    </p>
    <hr/>
    <h3>
     <a id="1__Context_4">
     </a>
     <strong>
      1. 组件更新可能影响整个 Context
     </strong>
    </h3>
    <p>
     <strong>
      问题
     </strong>
     ：当
     <code>
      Context
     </code>
     的值发生变化时，
     <strong>
      所有使用该 Context 的组件都会重新渲染
     </strong>
     ，即使它们只依赖
     <code>
      Context
     </code>
     的部分数据。
    </p>
    <ul>
     <li>
      这可能会导致
      <strong>
       不必要的渲染
      </strong>
      ，降低应用的性能。
     </li>
    </ul>
    <h4>
     <a id="_8">
     </a>
     <strong>
      示例：整个组件树都被重新渲染
     </strong>
    </h4>
    <pre><code class="prism language-jsx">const UserContext = createContext();

const UserProvider = ({ children }) =&gt; {
  const [user, setUser] = useState({ name: "John", age: 24 });

  return (
    &lt;UserContext.Provider value={<!-- -->{ user, setUser }}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
};

// 子组件 1：只显示用户姓名
const UserName = () =&gt; {
  const { user } = useContext(UserContext);
  console.log("UserName 组件更新");
  return &lt;h2&gt;姓名: {user.name}&lt;/h2&gt;;
};

// 子组件 2：修改用户年龄
const UserAgeUpdater = () =&gt; {
  const { setUser } = useContext(UserContext);
  console.log("UserAgeUpdater 组件更新");

  return &lt;button onClick={() =&gt; setUser(prev =&gt; ({ ...prev, age: prev.age + 1 }))}&gt;增加年龄&lt;/button&gt;;
};

// App 组件
const App = () =&gt; (
  &lt;UserProvider&gt;
    &lt;UserName /&gt;
    &lt;UserAgeUpdater /&gt;
  &lt;/UserProvider&gt;
);

export default App;
</code></pre>
    <h4>
     <a id="_47">
     </a>
     <strong>
      问题出现了！
     </strong>
    </h4>
    <ul>
     <li>
      当
      <code>
       UserAgeUpdater
      </code>
      更新
      <code>
       age
      </code>
      时，
      <code>
       UserName
      </code>
      组件
      <strong>
       也会重新渲染
      </strong>
      ，尽管它
      <strong>
       没有使用
       <code>
        age
       </code>
      </strong>
      ！
     </li>
     <li>
      这会导致性能下降，尤其是当
      <code>
       Context
      </code>
      中的数据量很大，或者组件层级很深时。
     </li>
    </ul>
    <h4>
     <a id="_51">
     </a>
     <strong>
      解决方案
     </strong>
    </h4>
    <p>
     <strong>
      拆分
      <code>
       Context
      </code>
     </strong>
     ，让不同数据独立管理，避免不必要的渲染：
    </p>
    <pre><code class="prism language-jsx">const UserNameContext = createContext();
const UserAgeContext = createContext();

const UserProvider = ({ children }) =&gt; {
  const [name, setName] = useState("John");
  const [age, setAge] = useState(24);

  return (
    &lt;UserNameContext.Provider value={<!-- -->{ name, setName }}&gt;
      &lt;UserAgeContext.Provider value={<!-- -->{ age, setAge }}&gt;
        {children}
      &lt;/UserAgeContext.Provider&gt;
    &lt;/UserNameContext.Provider&gt;
  );
};
</code></pre>
    <p>
     ✅ 这样，
     <code>
      UserName
     </code>
     组件只会在
     <code>
      name
     </code>
     变化时更新，
     <code>
      UserAgeUpdater
     </code>
     只会在
     <code>
      age
     </code>
     变化时更新！
    </p>
    <hr/>
    <h3>
     <a id="2__Context__74">
     </a>
     <strong>
      2. 复杂的
      <code>
       Context
      </code>
      可能难以维护
     </strong>
    </h3>
    <p>
     如果
     <code>
      Context
     </code>
     中存储的数据结构过于复杂，会导致代码变得难以管理。例如：
    </p>
    <pre><code class="prism language-jsx">const AppContext = createContext();

const AppProvider = ({ children }) =&gt; {
  const [state, setState] = useState({
    user: { name: "John", age: 24 },
    theme: "dark",
    language: "zh",
    notifications: [],
  });

  return (
    &lt;AppContext.Provider value={<!-- -->{ state, setState }}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
};
</code></pre>
    <p>
     <strong>
      问题
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       Context
      </code>
      变成了一个
      <strong>
       大杂烩
      </strong>
      ，所有状态都存放在一起。
     </li>
     <li>
      任何一个状态变化，都会触发整个
      <code>
       Context
      </code>
      相关的组件更新。
     </li>
    </ul>
    <h4>
     <a id="_98">
     </a>
     <strong>
      解决方案
     </strong>
    </h4>
    <p>
     <strong>
      拆分多个 Context
     </strong>
     ，比如：
    </p>
    <pre><code class="prism language-jsx">const UserContext = createContext();
const ThemeContext = createContext();
const LanguageContext = createContext();
</code></pre>
    <p>
     ✅ 这样，每个
     <code>
      Context
     </code>
     只管理
     <strong>
      特定的数据
     </strong>
     ，代码更清晰，维护更容易。
    </p>
    <hr/>
    <h3>
     <a id="3_useContext__109">
     </a>
     <strong>
      3.
      <code>
       useContext
      </code>
      适用于“静态数据”，但不适合高频率变化的状态
     </strong>
    </h3>
    <p>
     如果某个状态变化非常频繁（如
     <strong>
      鼠标移动位置、WebSocket 数据、倒计时
     </strong>
     ），使用
     <code>
      useContext
     </code>
     可能会导致
     <strong>
      性能问题
     </strong>
     ，因为它会导致整个组件重新渲染。
    </p>
    <h4>
     <a id="_112">
     </a>
     <strong>
      示例：高频率变化的数据
     </strong>
    </h4>
    <pre><code class="prism language-jsx">const MouseContext = createContext();

const MouseProvider = ({ children }) =&gt; {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() =&gt; {
    const handleMouseMove = (event) =&gt; {
      setPosition({ x: event.clientX, y: event.clientY });
    };
    window.addEventListener("mousemove", handleMouseMove);
    return () =&gt; window.removeEventListener("mousemove", handleMouseMove);
  }, []);

  return (
    &lt;MouseContext.Provider value={position}&gt;
      {children}
    &lt;/MouseContext.Provider&gt;
  );
};
</code></pre>
    <p>
     <strong>
      问题
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       position
      </code>
      变化
      <strong>
       非常频繁
      </strong>
      ，导致
      <strong>
       所有使用
       <code>
        MouseContext
       </code>
       的组件都重新渲染
      </strong>
      ，影响性能。
     </li>
    </ul>
    <h4>
     <a id="_137">
     </a>
     <strong>
      解决方案
     </strong>
    </h4>
    <ul>
     <li>
      ✅
      <strong>
       改用
       <code>
        useRef
       </code>
       或
       <code>
        useState
       </code>
       只更新需要的组件
      </strong>
      。
     </li>
     <li>
      ✅
      <strong>
       用
       <code>
        Redux
       </code>
       、
       <code>
        Recoil
       </code>
       这类状态管理工具，优化性能
      </strong>
      。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="4_useContext__143">
     </a>
     <strong>
      4.
      <code>
       useContext
      </code>
      不能跨应用使用
     </strong>
    </h3>
    <p>
     <code>
      useContext
     </code>
     只能在 React 组件树的
     <strong>
      同一个层级
     </strong>
     下使用，
     <strong>
      不能跨页面或跨应用共享
     </strong>
     数据。例如：
    </p>
    <ul>
     <li>
      <strong>
       如果你在
       <code>
        App1
       </code>
       里创建了
       <code>
        UserContext
       </code>
       ，它在
       <code>
        App2
       </code>
       中无法使用
      </strong>
      。
     </li>
     <li>
      <strong>
       如果你有多个 React 渲染根（多个
       <code>
        ReactDOM.createRoot()
       </code>
       ），它们的
       <code>
        Context
       </code>
       是独立的
      </strong>
      。
     </li>
    </ul>
    <p>
     <strong>
      解决方案
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       使用全局状态管理工具，如 Redux、Recoil、Zustand
      </strong>
      ，它们支持跨应用共享数据。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="5__ContextProvider_153">
     </a>
     <strong>
      5. 依赖
      <code>
       Context.Provider
      </code>
      ，无法独立使用
     </strong>
    </h3>
    <p>
     使用
     <code>
      useContext
     </code>
     必须在
     <code>
      Context.Provider
     </code>
     <strong>
      内部
     </strong>
     ，否则会报错：
    </p>
    <pre><code class="prism language-jsx">const MyComponent = () =&gt; {
  const { user } = useContext(UserContext); // ❌ 错误
  return &lt;p&gt;{user.name}&lt;/p&gt;;
};

// 必须在 `UserProvider` 包裹下使用
const App = () =&gt; (
  &lt;UserProvider&gt;
    &lt;MyComponent /&gt;
  &lt;/UserProvider&gt;
);
</code></pre>
    <p>
     <strong>
      问题
     </strong>
     ：
    </p>
    <ul>
     <li>
      如果你
      <strong>
       忘记在
       <code>
        Provider
       </code>
       里包裹组件
      </strong>
      ，
      <code>
       useContext
      </code>
      会报错。
     </li>
     <li>
      <strong>
       如果组件可能在多个地方复用
      </strong>
      （有些地方没有
      <code>
       Provider
      </code>
      ），代码就会出问题。
     </li>
    </ul>
    <p>
     ✅
     <strong>
      解决方案
     </strong>
     ：可以在
     <code>
      useContext
     </code>
     里加一个默认值，避免报错：
    </p>
    <pre><code class="prism language-jsx">const UserContext = createContext({ user: { name: "默认用户" } });
</code></pre>
    <hr/>
    <h3>
     <a id="_179">
     </a>
     <strong>
      总结
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <code>
         useContext
        </code>
        的优点
       </th>
       <th>
        <code>
         useContext
        </code>
        的缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         避免 props 传递地狱
        </strong>
       </td>
       <td>
        <strong>
         所有使用
         <code>
          Context
         </code>
         的组件都会重新渲染
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         代码更清晰
        </strong>
       </td>
       <td>
        <strong>
         不适合高频率变化的数据
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用于共享状态（用户、主题、语言等）
        </strong>
       </td>
       <td>
        <strong>
         复杂
         <code>
          Context
         </code>
         可能变得难以维护
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         比 Redux、Recoil 轻量
        </strong>
       </td>
       <td>
        <strong>
         无法跨应用共享数据
        </strong>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <a id="_189">
     </a>
     <strong>
      最佳实践
     </strong>
    </h3>
    <p>
     ✅
     <strong>
      用
      <code>
       useContext
      </code>
      管理“全局但变化不频繁的数据”
     </strong>
     （如
     <strong>
      主题、用户信息、语言
     </strong>
     ）。
     <br/>
     ✅
     <strong>
      避免将高频率变化的状态放入
      <code>
       useContext
      </code>
     </strong>
     ，改用
     <code>
      useState
     </code>
     或
     <code>
      useRef
     </code>
     。
     <br/>
     ✅
     <strong>
      如果
      <code>
       Context
      </code>
      太大，拆分多个 Context，避免不必要的渲染
     </strong>
     。
     <br/>
     ✅
     <strong>
      对于复杂状态管理（如 Redux、Recoil、Zustand），可以结合
      <code>
       useContext
      </code>
      使用
     </strong>
     。
    </p>
    <hr/>
    <p>
     💡
     <strong>
      总结一句话：
      <code>
       useContext
      </code>
      很好用，但如果用错地方，可能会拖累性能！
     </strong>
     🚀
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031323434363936332f:61727469636c652f64657461696c732f313436303738313233" class_="artid" style="display:none">
 </p>
</div>


