---
layout: post
title: "前端请求patch接口,只传入已修改字段值的字段"
date: 2023-11-29 16:56:08 +0800
description: "在实际开发中前端肯定会遇到一个更新需求，回显数据 => 修改数据 => 请求更新接口这个步骤。通常建"
keywords: "patch接口"
categories: ['Javascript']
tags: ['前端', 'Vue', 'React']
artid: "134691637"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=134691637
    alt: "前端请求patch接口,只传入已修改字段值的字段"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=134691637
featuredImagePreview: https://bing.ee123.net/img/rand?artid=134691637
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端请求patch接口，只传入已修改字段值的字段
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="-toc" style="margin-left:80px;">
    </p>
    <p id="%E5%89%8D%E7%AB%AF%E4%BB%85%E4%BC%A0%E9%80%92%E5%8F%91%E7%94%9F%E6%9B%B4%E6%94%B9%E7%9A%84%E5%AD%97%E6%AE%B5-toc" style="margin-left:80px;">
     <a href="#%E5%89%8D%E7%AB%AF%E4%BB%85%E4%BC%A0%E9%80%92%E5%8F%91%E7%94%9F%E6%9B%B4%E6%94%B9%E7%9A%84%E5%AD%97%E6%AE%B5" rel="nofollow">
      前端仅传递发生更改的字段
     </a>
    </p>
    <p id="%E4%B8%BA%E4%BB%80%E4%B9%88-toc" style="margin-left:120px;">
     <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88" rel="nofollow">
      为什么
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E4%B8%BE%E4%BE%8B-toc" style="margin-left:120px;">
     <a href="#%E6%95%B0%E6%8D%AE%E4%B8%BE%E4%BE%8B" rel="nofollow">
      数据举例
     </a>
    </p>
    <p id="%E9%80%92%E5%BD%92%E5%AF%B9%E6%AF%94%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;">
     <a href="#%E9%80%92%E5%BD%92%E5%AF%B9%E6%AF%94%E5%87%BD%E6%95%B0" rel="nofollow">
      递归对比函数
     </a>
    </p>
    <p id="%E4%BB%8E%E5%9B%9E%E6%98%BE%E6%95%B0%E6%8D%AE%E5%88%B0%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;">
     <a href="#%E4%BB%8E%E5%9B%9E%E6%98%BE%E6%95%B0%E6%8D%AE%E5%88%B0%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C" rel="nofollow">
      从回显数据到提交更新接口的模拟操作
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h4 id="%E5%89%8D%E7%AB%AF%E4%BB%85%E4%BC%A0%E9%80%92%E5%8F%91%E7%94%9F%E6%9B%B4%E6%94%B9%E7%9A%84%E5%AD%97%E6%AE%B5">
     <strong>
      前端仅传递发生更改的字段
     </strong>
    </h4>
    <p>
     在实际开发中前端肯定会遇到一个更新需求，
     <strong>
      <span style="color:#6eaad7;">
       回显数据 =&gt; 修改数据 =&gt; 请求更新接口
      </span>
     </strong>
     这个步骤。
    </p>
    <p>
     通常建议前端仅传递发生更改的字段，而不是将所有字段都传递给后端。
    </p>
    <h5 id="%E4%B8%BA%E4%BB%80%E4%B9%88">
     为什么
    </h5>
    <p>
     <span style="color:#956fe7;">
      <strong>
       减少数据传输量：
      </strong>
     </span>
     如果只传递更改了的字段，可以减小数据传输的大小，降低网络开销，特别是在网络条件不理想的情况下更为重要。
    </p>
    <p>
     <span style="color:#956fe7;">
      <strong>
       提高性能：
      </strong>
     </span>
     传递更改了的字段可以减少后端的处理工作。只处理需要更新的字段可以提高性能，减少数据库操作的负担。
    </p>
    <h5 id="%E6%95%B0%E6%8D%AE%E4%B8%BE%E4%BE%8B">
     数据举例
    </h5>
    <pre><code class="language-javascript">const form = {
  a: 1,
  b: 2,
  c: 3,
  d: [1, 2, 3, 4],
  e: [{f: 5, g: 6}],
  h: {
       i: 7,
       g: 8
  }
}

//修改字段
form.a = 2
form.h.i = 2
form.d[0] = 2


//接口提交params
{
    a: 2,
    d: [2, 2, 3, 4],
    h: {
        i: 2
    }
}</code></pre>
    <p>
     以下是递归对比原始对象和修改后的对象的函数，返回一个
     <span style="color:#fe2c24;">
      <strong>
       只修改过字段值的对象
      </strong>
     </span>
     。
    </p>
    <h5 id="%E9%80%92%E5%BD%92%E5%AF%B9%E6%AF%94%E5%87%BD%E6%95%B0">
     递归对比函数
    </h5>
    <pre><code class="language-javascript">function findObjectChanges(original, modified, path = []) {
  if(original instanceof Array &amp;&amp; modified instanceof Array) {
    if(JSON.stringify(original) !== JSON.stringify(modified)) {
      return modified
    } else {
      return {}
    }
  }
  const changes = {};
  for (const key in modified) {
    const currentPath = [...path, key];
    if (typeof modified[key] === 'object' &amp;&amp; modified[key] !== null) {
      // 递归比较嵌套对象
      const nestedChanges = findObjectChanges(original[key], modified[key], currentPath);
      if (Object.keys(nestedChanges).length &gt; 0) {
        changes[key] = nestedChanges;
      }
    } else {
      // 比较基本数据类型
      if (original[key] !== modified[key]) {
        changes[key] = modified[key];
      }
    }
  }
  return changes;
}</code></pre>
    <h5 id="%E4%BB%8E%E5%9B%9E%E6%98%BE%E6%95%B0%E6%8D%AE%E5%88%B0%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C">
     从回显数据到提交更新接口的模拟操作
    </h5>
    <pre><code class="language-javascript">let form = {}  // 定义的form，不管是react的useState定义或者vue的reactive ref定义

const formData = fetchDataApi(...)
//接口数据
{ 
  a: 1,
  b: 2,
  c: 3,
  d: [1, 2, 3, 4],
  e: [{f: 5, g: 6}],
  h: {
    i: 7,
    g: 8
  }
}

form = JSON.parse(JSON.stringify(formData)) //从接口获取到回显数据，生成新对象

form.a = 2   //模拟vue或者react的form双向绑定更改值的操作
form.h.i = 2
form.d[0] = 2

const formParams = findObjectChanges(formData, form)  //递归对比修改了哪些字段

if(JSON.stringify(formParams) === "{}") {  //判断是否修改了字段
  alert('您还未修改任何数据')
} else {
  fetchUpdateApi(formParams)  // 请求更新接口
  alert('数据已提交')
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f53757070657253412f:61727469636c652f64657461696c732f313334363931363337" class_="artid" style="display:none">
 </p>
</div>


