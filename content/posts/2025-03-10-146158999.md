---
layout: post
title: "Spring-Boot-整合-Keycloak"
date: 2025-03-10 17:13:03 +0800
description: "本文介绍了如何如何设置了 Keycloak 服务器，以及如何在 Spring Boot 中使用 Spring Security OAuth2.0 结合 Keycloak 实现认证和授权。"
keywords: "keycloak spring boot jwt用法"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['后端', 'Spring', 'Java', 'Boot']
artid: "146158999"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158999
    alt: "Spring-Boot-整合-Keycloak"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158999
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158999
cover: https://bing.ee123.net/img/rand?artid=146158999
image: https://bing.ee123.net/img/rand?artid=146158999
img: https://bing.ee123.net/img/rand?artid=146158999
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring Boot 整合 Keycloak
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="1_4">
     </a>
     1、概览
    </h4>
    <p>
     本文将带你了解如何设置 Keycloak 服务器，以及如何使用 Spring Security OAuth2.0 将
     <a href="https://springdoc.cn/spring-boot/" rel="nofollow" title="Spring Boot">
      Spring Boot
     </a>
     应用连接到 Keycloak 服务器。
    </p>
    <h4>
     <a id="2Keycloak__8">
     </a>
     2、Keycloak 是什么？
    </h4>
    <p>
     <a href="http://www.keycloak.org/" rel="nofollow" title="Keycloak">
      Keycloak
     </a>
     是针对现代应用和服务的开源身份和访问管理解决方案。
    </p>
    <p>
     Keycloak 提供了诸如单点登录（SSO）、身份代理和社交登录、用户联盟、客户端适配器、管理控制台和账户管理等功能。
    </p>
    <p>
     本文使用 Keycloak 的管理控制台，使用 Spring Security OAuth2.0 设置和连接 Spring Boot。
    </p>
    <h4>
     <a id="3_Keycloak__16">
     </a>
     3、设置 Keycloak 服务器
    </h4>
    <p>
     设置和配置 Keycloak 服务器。
    </p>
    <h5>
     <a id="31_Keycloak_20">
     </a>
     3.1、下载和安装 Keycloak
    </h5>
    <p>
     有多种发行版可供选择，本文使 Keycloak-22.0.3 独立服务器发行版。点击
     <a href="https://www.keycloak.org/archive/downloads-22.0.3.html" rel="nofollow" title="这里">
      这里
     </a>
     从官方下载。
    </p>
    <p>
     下载完后，解压缩并从终端启动 Keycloak：
    </p>
    <pre><code>unzip keycloak-22.0.3.zip 
cd keycloak-22.0.3
bin/kc.sh start-dev
</code></pre>
    <p>
     运行这些命令后，Keycloak 会启动服务。如果你看到一行类似于
     <code>
      Keycloak 22.0.3 [...] started
     </code>
     的内容，就表示服务器启动成功。
    </p>
    <p>
     打开浏览器，访问
     <code>
      http://localhost:8080
     </code>
     ，会被重定向到
     <code>
      http://localhost:8080/auth
     </code>
     以创建管理员进行登录：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a7d2376cf7af4f3f83501345a89dcfce.webp"/>
    </p>
    <p>
     创建一个名为
     <code>
      initial1
     </code>
     的初始管理员用户，密码为
     <code>
      zaq1!QAZ
     </code>
     。点击 “Create”后，可以看到 “User Created” 的提示信息。
    </p>
    <p>
     现在进入管理控制台。在登录页面，输入
     <code>
      initial
     </code>
     管理员用户凭证：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/284399dd89d84275b45bd41215da544b.webp"/>
    </p>
    <h5>
     <a id="32_Realm_43">
     </a>
     3.2、创建 Realm
    </h5>
    <p>
     登录成功后，进入控制台，默认为
     <code>
      Master
     </code>
     Realm。
    </p>
    <p>
     导航到左上角，找到 “Create realm” 按钮：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/8d8ab50d8d6349bda293a6c741b9be51.webp"/>
    </p>
    <p>
     点击它，添加一个名为
     <code>
      SpringBootKeycloak
     </code>
     的新 Realm：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/938dbf2c66a04e658ed9f97c8303026a.webp"/>
    </p>
    <p>
     单击 “Create” 按钮，创建一个新的 Realm。会被重定向到该 Realm。接下来的所有操作都将在这个新的
     <code>
      SpringBootKeycloak
     </code>
     Realm 中执行。
    </p>
    <h5>
     <a id="33_57">
     </a>
     3.3、创建客户端
    </h5>
    <p>
     现在进入 “Clients” 页面。如下图所示，Keycloak 已经内置了客户端：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7a9033a0064f4c4bba1aff242b454c6f.webp"/>
    </p>
    <p>
     我们需要在应用中添加一个新客户端，点击 “Create”，将新客户端命名为
     <code>
      login-app
     </code>
     ：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/4eb4d72831ec4a958cf0e22eeae8beb2.webp"/>
    </p>
    <p>
     在下一步的设置中，除了 “Valid Redirect URIs” 字段外，其他字段保留所有默认值。该字段包含将使用此客户端进行身份验证的应用 URL：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/c4f9db2b65124b3d85d998afe55c3a75.webp"/>
    </p>
    <p>
     稍后，我们会创建一个运行于 8081 端口的 Spring Boot 应用，该应用将使用该客户端。因此，在上面使用了
     <code>
      http://localhost:8081/
     </code>
     的重定向 URL。
    </p>
    <h5>
     <a id="34_73">
     </a>
     3.4、创建角色和用户
    </h5>
    <p>
     Keycloak 使用基于角色的访问；因此，每个用户都必须有一个角色。
    </p>
    <p>
     进入 “Realm Roles” 页面：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/932e60744ebb4e908ba460f3354d4569.webp"/>
    </p>
    <p>
     然后添加用户角色：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/86b85b623b72414781a8757c72ad3fcf.webp"/>
    </p>
    <p>
     现在有了一个可以分配给用户的角色，但由于还没有用户，让我们去 “Users” 页面添加一个：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e1e77ab96435427da9750b53cac6fd72.webp"/>
    </p>
    <p>
     添加一个名为
     <code>
      user1
     </code>
     的用户：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/298f17a2be354f1b9b33f395a060a971.webp"/>
    </p>
    <p>
     用户创建后，会显示一个包含其详细信息的页面：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/510af70711aa4a0dbc5d708905ac837c.webp"/>
    </p>
    <p>
     现在进入 “Credentials” 选项卡。把初始密码设置为
     <code>
      xsw2@WS
     </code>
     ：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/aed608de4f3c48c184cba88c20283dc6.webp"/>
    </p>
    <p>
     最后，进入 “Role Mappings” 选项卡。为
     <code>
      user1
     </code>
     分配用户角色：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/dc4058398cca40848f5030ea52bed76e.webp"/>
    </p>
    <h4>
     <a id="4_Keycloak_API__Access_Token_105">
     </a>
     4、使用 Keycloak API 生成 Access Token
    </h4>
    <p>
     Keycloak 提供了用于生成和刷新 Access Token 的 REST API，可用于创建自己的登录页面。
    </p>
    <p>
     首先，向如下 URL 发送 POST 请求，从 Keycloak 获取 Access Token：
    </p>
    <pre><code>http://localhost:8080/realms/SpringBootKeycloak/protocol/openid-connect/token
</code></pre>
    <p>
     请求体应包含
     <code>
      x-www-form-urlencoded
     </code>
     格式的参数：
    </p>
    <pre><code>client_id:&lt;your_client_id&gt;
username:&lt;your_username&gt;
password:&lt;your_password&gt;
grant_type:password
</code></pre>
    <p>
     这会得到一个
     <code>
      access_token
     </code>
     和一个
     <code>
      refresh_token
     </code>
     。
    </p>
    <p>
     每次请求受 Keycloak 保护的资源时，都应使用 Access Token，只需将其放在
     <code>
      Authorization
     </code>
     头中即可：
    </p>
    <pre><code>headers: {
    'Authorization': 'Bearer' + access_token
}
</code></pre>
    <p>
     Access Token 过期后，可以通过向上述相同的 URL 发送 POST 请求来刷新 Access Token，但请求中应包含 Refresh Token，而不是用户名和密码：
    </p>
    <pre><code>{
    'client_id': 'your_client_id',
    'refresh_token': refresh_token_from_previous_request,
    'grant_type': 'refresh_token'
}
</code></pre>
    <p>
     Keycloak 会响应新的
     <code>
      access_token
     </code>
     和
     <code>
      refresh_token
     </code>
     。
    </p>
    <h4>
     <a id="5_Spring_Boot__142">
     </a>
     5、创建和配置 Spring Boot 应用
    </h4>
    <p>
     创建一个 Spring Boot 应用，并将其配置为 OAuth 客户端，与 Keycloak 服务器进行交互。
    </p>
    <h5>
     <a id="51_146">
     </a>
     5.1、依赖
    </h5>
    <p>
     使用 Spring Security OAuth2.0 客户端连接到 Keycloak 服务器。
    </p>
    <p>
     首先，在
     <code>
      pom.xml
     </code>
     中声明
     <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-oauth2-client" rel="nofollow" title="spring-boot-starter-oauth2-client">
      spring-boot-starter-oauth2-client
     </a>
     和
     <code>
      spring-boot-starter-security
     </code>
     依赖：
    </p>
    <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
    <p>
     使用
     <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-oauth2-resource-server" rel="nofollow" title="spring-boot-starter-oauth2-resource-server">
      spring-boot-starter-oauth2-resource-server
     </a>
     将身份验证控制委托给 Keycloak 服务器。它允许我们使用 Keycloak 服务器验证 JWT Token：
    </p>
    <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
    <p>
     现在，Spring Boot 应用可以与 Keycloak 交互了。
    </p>
    <h5>
     <a id="52Keycloak__173">
     </a>
     5.2、Keycloak 配置
    </h5>
    <p>
     将 Keycloak 客户端视为 OAuth 客户端。因此，需要配置 Spring Boot 应用以使用 OAuth 客户端。
    </p>
    <p>
     <code>
      ClientRegistration
     </code>
     类保存客户端的所有基本信息。Spring 自动配置会查找模式为
     <code>
      spring.security.oauth2.client.registration.[registrationId]
     </code>
     的属性，并使用 OAuth 2.0 或 OpenID Connect（OIDC） 注册客户端。
    </p>
    <p>
     客户端注册配置：
    </p>
    <pre><code>spring.security.oauth2.client.registration.keycloak.client-id=login-app
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak.scope=openid
</code></pre>
    <p>
     在
     <code>
      client-id
     </code>
     中指定的值与我们在管理控制台中命名的客户端相匹配。
    </p>
    <p>
     Spring Boot 应用需要与 OAuth 2.0 或 OIDC Provider 交互，以处理不同授权方式的实际请求逻辑。因此，需要配置 OIDC Provider。它可以根据 Schema
     <code>
      spring.security.oauth2.client.provider.[provider name]
     </code>
     的属性值自动配置。
    </p>
    <p>
     OIDC Provider 配置：
    </p>
    <pre><code>spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8080/realms/SpringBootKeycloak
spring.security.oauth2.client.provider.keycloak.user-name-attribute=preferred_username
</code></pre>
    <p>
     在
     <code>
      issuer-uri
     </code>
     中指定路径（我们是在 8080 端口启动 Keycloak 的）。该属性标识了授权服务器的基本 URI，输入在 Keycloak 管理控制台中创建的 Realm 名称。此外，还可以将
     <code>
      user-name-attribute
     </code>
     定义为
     <code>
      preferred_username
     </code>
     ，以便在 Controller 的
     <code>
      Principal
     </code>
     中填充合适的用户。
    </p>
    <p>
     最后，添加针对 Keycloak 服务器验证 JWT Token 所需的配置：
    </p>
    <pre><code>spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8080/realms/SpringBootKeycloak
</code></pre>
    <h5>
     <a id="53_203">
     </a>
     5.3、配置类
    </h5>
    <p>
     创建
     <code>
      SecurityFilterChain
     </code>
     Bean 来配置
     <code>
      HttpSecurity
     </code>
     。使用
     <code>
      http.oauth2Login()
     </code>
     启用 OAuth2 登录。
    </p>
    <p>
     创建 Security 配置：
    </p>
    <pre><code>@Configuration 
@EnableWebSecurity 
class SecurityConfig { 
    private final KeycloakLogoutHandler keycloakLogoutHandler; 
    SecurityConfig(KeycloakLogoutHandler keycloakLogoutHandler) { 
        this.keycloakLogoutHandler = keycloakLogoutHandler; 
    } 
    @Bean 
    protected SessionAuthenticationStrategy sessionAuthenticationStrategy() { 
        return new RegisterSessionAuthenticationStrategy(new SessionRegistryImpl()); 
    } 
    @Order(1) 
    @Bean 
    public SecurityFilterChain clientFilterChain(HttpSecurity http) throws Exception { 
        http.authorizeRequests() 
            .requestMatchers(new AntPathRequestMatcher("/")) 
            .permitAll() 
            .anyRequest() 
            .authenticated(); 
        http.oauth2Login() 
            .and() 
            .logout() 
            .addLogoutHandler(keycloakLogoutHandler) 
            .logoutSuccessUrl("/"); 
        return http.build(); 
    } 
     
    @Order(2) 
    @Bean 
    public SecurityFilterChain resourceServerFilterChain(HttpSecurity http) throws Exception { 
        http.authorizeRequests() 
            .requestMatchers(new AntPathRequestMatcher("/customers*")) 
            .hasRole("USER") 
            .anyRequest() 
            .authenticated(); 
        http.oauth2ResourceServer((oauth2) -&gt; oauth2.jwt(Customizer.withDefaults()));
        return http.build(); 
    } 
    @Bean 
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception { 
        return http.getSharedObject(AuthenticationManagerBuilder.class) 
            .build(); 
    } 
}
</code></pre>
    <p>
     在上面的代码中，
     <code>
      oauth2Login()
     </code>
     方法将
     <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/client/web/OAuth2LoginAuthenticationFilter.html" rel="nofollow" title="OAuth2LoginAuthenticationFilter">
      OAuth2LoginAuthenticationFilter
     </a>
     添加到过滤器链中。该过滤器会拦截请求并应用 OAuth 2 身份验证所需的逻辑。
     <code>
      oauth2ResourceServer
     </code>
     方法将根据 Keycloak 服务器验证绑定的 JWT Token。
    </p>
    <p>
     在
     <code>
      configure()
     </code>
     方法中根据权限和角色配置访问权限。这些约束条件可确保对
     <code>
      /customers/*
     </code>
     的每个请求只有在请求者是具有
     <code>
      USER
     </code>
     角色的经过身份验证的用户时才会获得授权。
    </p>
    <p>
     最后，添加了
     <code>
      KeycloakLogoutHandler
     </code>
     类来处理 Keycloak 注销：
    </p>
    <pre><code>@Component
public class KeycloakLogoutHandler implements LogoutHandler {

    private static final Logger logger = LoggerFactory.getLogger(KeycloakLogoutHandler.class);
    private final RestTemplate restTemplate;

    public KeycloakLogoutHandler(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Override
    public void logout(HttpServletRequest request, HttpServletResponse response, 
      Authentication auth) {
        logoutFromKeycloak((OidcUser) auth.getPrincipal());
    }

    private void logoutFromKeycloak(OidcUser user) {
        String endSessionEndpoint = user.getIssuer() + "/protocol/openid-connect/logout";
        UriComponentsBuilder builder = UriComponentsBuilder
          .fromUriString(endSessionEndpoint)
          .queryParam("id_token_hint", user.getIdToken().getTokenValue());

        ResponseEntity&lt;String&gt; logoutResponse = restTemplate.getForEntity(
        builder.toUriString(), String.class);
        if (logoutResponse.getStatusCode().is2xxSuccessful()) {
            logger.info("Successfulley logged out from Keycloak");
        } else {
            logger.error("Could not propagate logout to Keycloak");
        }
    }

}
</code></pre>
    <p>
     <code>
      KeycloakLogoutHandler
     </code>
     类实现了
     <code>
      LogoutHandler
     </code>
     ，并向 Keycloak 发送注销请求。
    </p>
    <p>
     现在，通过身份验证后，就可以访问内部 customers 页面了。
    </p>
    <h5>
     <a id="54Thymeleaf_Web__299">
     </a>
     5.4、Thymeleaf Web 页面
    </h5>
    <p>
     使用 Thymeleaf 渲染页面。
    </p>
    <p>
     有三个页面：
    </p>
    <ul>
     <li>
      <code>
       external.html
      </code>
      - 面向外部的页面
     </li>
     <li>
      <code>
       customers.html
      </code>
      - 面向内部的页面，其访问权限仅限于具有
      <code>
       user
      </code>
      角色的认证用户
     </li>
     <li>
      <code>
       layout.html
      </code>
      - 一个简单的布局，由两个片段组成，分别用于面向外部的页面和面向内部的页面
     </li>
    </ul>
    <p>
     Thymeleaf 模板的代码可在
     <a href="https://github.com/eugenp/tutorials/tree/master/spring-boot-modules/spring-boot-keycloak/src/main/resources/templates" title="Github">
      Github
     </a>
     上获取。
    </p>
    <h5>
     <a id="55Controller_311">
     </a>
     5.5、Controller
    </h5>
    <p>
     Web Controller 会将内部和外部 URL 映射到相应的 Thymeleaf 模板：
    </p>
    <pre><code>@GetMapping(path = "/")
public String index() {
    return "external";
}
    
@GetMapping(path = "/customers")
public String customers(Principal principal, Model model) {
    addCustomers();
    model.addAttribute("customers", customerDAO.findAll());
    model.addAttribute("username", principal.getName());
    return "customers";
}
</code></pre>
    <p>
     <code>
      /customers
     </code>
     会从 Repository 中检索所有客户，并将结果作为属性添加到 Model 中。之后，在 Thymeleaf 中遍历结果。
    </p>
    <p>
     为了能够显示用户名，还注入了
     <code>
      Principal
     </code>
     。
    </p>
    <p>
     注意，这里只是将客户（customers）作为原始数据来显示，仅此而已。
    </p>
    <h4>
     <a id="6_335">
     </a>
     6、演示
    </h4>
    <p>
     现在，测试应用。通过集成开发环境（如 Spring Tool Suite - STS）运行 Spring Boot 应用，或者在终端运行如下命令：
    </p>
    <pre><code>mvn clean spring-boot:run
</code></pre>
    <p>
     访问
     <code>
      http://localhost:8081
     </code>
     ，如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/d4b3d96ae8be47a5b9701833cb863ee2.webp"/>
    </p>
    <p>
     现在，点击 “customers” 户进入内部页面，这是敏感信息的位置。
    </p>
    <p>
     然后会被重定向到通过 Keycloak 进行身份验证，以检查我们是否被授权查看此内容：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3b289532b02d4a1b93fff7727d8c1904.webp"/>
    </p>
    <p>
     用
     <code>
      user1
     </code>
     的凭证登录，Keycloak 会验证我们的授权，确认我们拥有用户角色，然后会被重定向到受限的 “customers” 页面：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/4dfbc00407734ecda9816d908e4d2c67.webp"/>
    </p>
    <p>
     现在，整个流程已经完毕了。你可以看到，Spring Boot 无缝地处理了调用 Keycloak 授权服务器的整个过程。我们无需调用 Keycloak API 自己生成 Access Token，甚至无需在请求受保护资源时明确发送
     <code>
      Authorization
     </code>
     头。
    </p>
    <h4>
     <a id="7_358">
     </a>
     7、总结
    </h4>
    <p>
     本文介绍了如何如何设置了 Keycloak 服务器，以及如何在 Spring Boot 中使用 Spring Security OAuth2.0 结合 Keycloak 实现认证和授权。
    </p>
    <hr/>
    <p>
     Ref：
     <code>
      https://www.baeldung.com/spring-boot-keycloak
     </code>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343832343735352f:61727469636c652f64657461696c732f313436313538393939" class_="artid" style="display:none">
 </p>
</div>


