---
layout: post
title: "破局-MySQL-死锁深入理解锁机制与高效解决方案"
date: 2025-03-16 11:02:41 +0800
description: "破局 MySQL 死锁"
keywords: "破局 MySQL 死锁：深入理解锁机制与高效解决方案"
categories: ['未分类']
tags: ['数据库', 'Sql', 'Mysql', 'Java']
artid: "146291500"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146291500
    alt: "破局-MySQL-死锁深入理解锁机制与高效解决方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146291500
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146291500
cover: https://bing.ee123.net/img/rand?artid=146291500
image: https://bing.ee123.net/img/rand?artid=146291500
img: https://bing.ee123.net/img/rand?artid=146291500
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     破局 MySQL 死锁：深入理解锁机制与高效解决方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <strong>
      死锁的原理
     </strong>
    </h2>
    <p>
     <strong>
      1. 什么是死锁？
     </strong>
    </p>
    <blockquote>
     <p>
      当
      <strong>
       多个事务
      </strong>
      在并发执行时，每个事务都
      <strong>
       持有其他事务需要的锁
      </strong>
      ，同时又在
      <strong>
       等待对方释放锁
      </strong>
      ，导致所有事务都无法继续执行的状态，称为
      <strong>
       死锁
      </strong>
      （Deadlock）。
     </p>
    </blockquote>
    <p>
     <strong>
      2. 死锁的四个必要条件
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        互斥条件
       </strong>
       ：资源（如某行数据）一次只能被一个事务独占。
      </p>
     </li>
     <li>
      <p>
       <strong>
        请求与保持条件
       </strong>
       ：事务在持有某些锁的同时，请求新的锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不剥夺条件
       </strong>
       ：事务已获得的锁不能被强制剥夺。
      </p>
     </li>
     <li>
      <p>
       <strong>
        循环等待条件
       </strong>
       ：事务之间形成
       <strong>
        环形等待链
       </strong>
       ，如事务A等待事务B，事务B又等待事务A。
      </p>
     </li>
    </ul>
    <h2>
     <strong>
      MySQL 中死锁的常见场景
     </strong>
    </h2>
    <h3>
     <strong>
      1. 场景1：交叉更新不同顺序
     </strong>
    </h3>
    <pre><code class="language-sql">-- 事务1：先更新表A，再更新表B
BEGIN;
UPDATE table_a SET col = 1 WHERE id = 1;
UPDATE table_b SET col = 2 WHERE id = 2;
COMMIT;

-- 事务2：先更新表B，再更新表A
BEGIN;
UPDATE table_b SET col = 3 WHERE id = 2;
UPDATE table_a SET col = 4 WHERE id = 1;
COMMIT;</code></pre>
    <ul>
     <li>
      <p>
       事务1持有
       <code>
        table_a.id=1
       </code>
       的锁，请求
       <code>
        table_b.id=2
       </code>
       的锁。
      </p>
     </li>
     <li>
      <p>
       事务2持有
       <code>
        table_b.id=2
       </code>
       的锁，请求
       <code>
        table_a.id=1
       </code>
       的锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        形成循环等待
       </strong>
       ，触发死锁。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      2. 场景2：索引缺失导致全表锁
     </strong>
    </h3>
    <blockquote>
     <p>
      当 SQL 语句的
      <strong>
       WHERE 条件字段无索引
      </strong>
      时，InnoDB 引擎无法通过索引快速定位目标行，必须通过
      <strong>
       全表扫描
      </strong>
      逐行检查数据。在此过程中，InnoDB 会对
      <strong>
       所有扫描到的行加锁
      </strong>
      （具体锁类型由隔离级别决定）。这种机制会导致以下问题：
     </p>
     <p>
      <strong>
       锁范围扩大
      </strong>
      ：即使实际需要修改的行很少，也可能因全表扫描锁定大量无关行。
     </p>
     <p>
      <strong>
       间隙锁扩散
      </strong>
      ：在可重复读（REPEATABLE READ）隔离级别下，InnoDB 会为全表扫描的行加上
      <strong>
       间隙锁
      </strong>
      ，锁定整个表的间隙。
     </p>
     <p>
      <strong>
       锁冲突概率激增
      </strong>
      ：多个事务并发执行全表扫描操作时，可能因锁竞争导致死锁。
     </p>
    </blockquote>
    <p>
     <strong>
      场景示例
     </strong>
    </p>
    <p>
     假设有一张
     <code>
      users
     </code>
     表，存储用户信息，其中
     <code>
      age
     </code>
     字段无索引：
    </p>
    <pre><code class="language-sql">CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,          -- 无索引
    status VARCHAR(20)
);</code></pre>
    <p>
     两个事务并发执行以下操作：
    </p>
    <pre><code class="language-sql">-- 事务1：更新年龄大于30的用户状态
BEGIN;
UPDATE users SET status = 'inactive' WHERE age &gt; 30;  -- age字段无索引

-- 事务2：更新年龄小于20的用户状态
BEGIN;
UPDATE users SET status = 'active' WHERE age &lt; 20;    -- age字段无索引</code></pre>
    <p>
     <strong>
      锁行为分析
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       事务1
      </strong>
      执行
      <code>
       UPDATE
      </code>
      时，由于
      <code>
       age
      </code>
      无索引，InnoDB 必须
      <strong>
       全表扫描
      </strong>
      ，对所有扫描到的行加锁：
     </p>
     <ul>
      <li>
       若隔离级别为
       <strong>
        可重复读（REPEATABLE READ）
       </strong>
       ，会加
       <strong>
        Next-Key 锁
       </strong>
       （记录锁 + 间隙锁），锁定全表所有行及其间隙。
      </li>
      <li>
       若隔离级别为
       <strong>
        读已提交（READ COMMITTED）
       </strong>
       ，仅加
       <strong>
        记录锁
       </strong>
       ，但全表扫描仍可能锁定大量行。
      </li>
     </ul>
     <p>
      <strong>
       事务2
      </strong>
      同样执行全表扫描，尝试锁定符合条件的行。若两事务锁定的行存在
      <strong>
       交叉或重叠
      </strong>
      ，可能导致相互等待，最终触发死锁。
     </p>
    </blockquote>
    <p>
     <strong>
      3. 场景3：间隙锁（Gap Lock）冲突
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       隔离级别为可重复读（REPEATABLE READ）
      </strong>
      时，InnoDB 会使用
      <strong>
       间隙锁
      </strong>
      （锁定一个范围）。
     </p>
     <p>
      例如：
      <code>
       SELECT * FROM users WHERE id &gt; 100 FOR UPDATE;
      </code>
      会锁定
      <code>
       id &gt; 100
      </code>
      的所有间隙。
     </p>
     <p>
      两个事务锁定不同的间隙范围时，可能因间隙交叉导致死锁。
     </p>
    </blockquote>
    <h2 style="background-color:transparent">
     分析死锁
    </h2>
    <h3 style="background-color:transparent">
     <strong>
      1. 查看死锁日志
     </strong>
    </h3>
    <p>
     执行以下命令获取死锁信息：
    </p>
    <pre><code class="language-sql">SHOW ENGINE INNODB STATUS;</code></pre>
    <p>
     在输出中查找
     <code>
      LATEST DETECTED DEADLOCK
     </code>
     部分，关键信息包括：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        涉及的事务
       </strong>
       ：事务ID、执行的SQL语句。
      </p>
     </li>
     <li>
      <p>
       <strong>
        持有的锁
       </strong>
       ：事务当前持有的锁类型（行锁、间隙锁等）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        等待的锁
       </strong>
       ：事务正在请求的锁。
      </p>
     </li>
    </ul>
    <h3 style="background-color:transparent">
     <strong>
      2. 示例日志分析
     </strong>
    </h3>
    <pre><code class="language-sql">LATEST DETECTED DEADLOCK
------------------------
2023-10-01 10:00:00 0x7f8e12345600
*** (1) TRANSACTION:
TRANSACTION 1001, ACTIVE 2 sec updating
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 1, OS thread handle 123456, query id 100 localhost root
UPDATE table_b SET col = 3 WHERE id = 2;

*** (1) HOLDS THE LOCK(S):
RECORD LOCKS space id 10 page no 3 n bits 72 index PRIMARY of table `test`.`table_b` 
trx id 1001 lock_mode X locks rec but not gap

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 10 page no 4 n bits 72 index PRIMARY of table `test`.`table_a` 
trx id 1001 lock_mode X locks rec but not gap waiting

*** (2) TRANSACTION:
TRANSACTION 1002, ACTIVE 1 sec updating
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 2, OS thread handle 123457, query id 101 localhost root
UPDATE table_a SET col = 4 WHERE id = 1;

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 10 page no 4 n bits 72 index PRIMARY of table `test`.`table_a` 
trx id 1002 lock_mode X locks rec but not gap

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 10 page no 3 n bits 72 index PRIMARY of table `test`.`table_b` 
trx id 1002 lock_mode X locks rec but not gap waiting</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        务1
       </strong>
       持有
       <code>
        table_b.id=2
       </code>
       的锁，等待
       <code>
        table_a.id=1
       </code>
       的锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        事务2
       </strong>
       持有
       <code>
        table_a.id=1
       </code>
       的锁，等待
       <code>
        table_b.id=2
       </code>
       的锁。
      </p>
     </li>
     <li>
      <p>
       <strong>
        结论
       </strong>
       ：典型的交叉更新死锁。
      </p>
     </li>
    </ul>
    <h2>
     解决死锁
    </h2>
    <h3 style="background-color:transparent">
     <strong>
      1. 统一资源访问顺序
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        核心思想
       </strong>
       ：所有事务按固定顺序访问资源（如先操作表A，再操作表B）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：修改事务2的更新顺序：
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">-- 事务2调整为先更新表A，再更新表B
BEGIN;
UPDATE table_a SET col = 4 WHERE id = 1;
UPDATE table_b SET col = 3 WHERE id = 2;
COMMIT;</code></pre>
    <h3 style="background-color:transparent">
     <strong>
      2.优化索引
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        避免全表扫描
       </strong>
       ：为
       <code>
        WHERE
       </code>
       条件字段添加索引。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">ALTER TABLE users ADD INDEX idx_age (age);</code></pre>
    <p>
     优化后，
     <code>
      UPDATE users SET name = 'Tom' WHERE age = 20;
     </code>
     只会锁定符合条件的行，而非全表。
    </p>
    <h3>
     <strong>
      3. 缩短事务时间
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        尽早提交事务
       </strong>
       ：减少锁的持有时间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        避免长事务
       </strong>
       ：不在事务中执行耗时操作（如文件IO、网络请求）。
      </p>
     </li>
    </ul>
    <h3 style="background-color:transparent">
     <strong>
      4. 调整隔离级别
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        降低隔离级别
       </strong>
       ：将隔离级别从
       <code>
        REPEATABLE READ
       </code>
       改为
       <code>
        READ COMMITTED
       </code>
       ，减少间隙锁的使用。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre>
    <h3>
     <strong>
      5.锁定读（FOR UPDATE）
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        提前获取锁
       </strong>
       ：在事务开始时锁定所有需要的资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">BEGIN;
SELECT * FROM table_a WHERE id = 1 FOR UPDATE; -- 提前锁定行
UPDATE table_a SET col = 1 WHERE id = 1;
COMMIT;</code></pre>
    <h3>
     6.
     <strong>
      使用锁超时
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       设置
       <code>
        innodb_lock_wait_timeout
       </code>
       （默认50秒），强制终止长时间等待锁的事务：
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">SET GLOBAL innodb_lock_wait_timeout = 30; -- 设置为30秒</code></pre>
    <h2>
     补充：Mysql锁
    </h2>
    <h3 style="background-color:transparent">
     <strong>
      一、锁的分类
     </strong>
    </h3>
    <h4>
     <strong>
      1. 按锁的粒度划分
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        全局锁
       </strong>
       ：锁定整个数据库实例，用于全库备份。
      </p>
     </li>
     <li>
      <p>
       <strong>
        表级锁
       </strong>
       ：锁定整张表，MyISAM 默认使用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        行级锁
       </strong>
       ：锁定表中的特定行，InnoDB 支持。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      2. 按锁的兼容性划分
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        共享锁（S锁）
       </strong>
       ：允许读，阻止写。
      </p>
      <pre><code class="language-sql">SELECT * FROM table WHERE id = 1 LOCK IN SHARE MODE;</code></pre>
     </li>
     <li>
      <p>
       <strong>
        排他锁（X锁）
       </strong>
       ：阻止读和写。
      </p>
      <pre><code class="language-sql">SELECT * FROM table WHERE id = 1 FOR UPDATE;</code></pre>
     </li>
    </ul>
    <h4>
     <strong>
      3. 按锁的实现方式划分
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        悲观锁
       </strong>
       ：默认认为并发冲突会发生，先加锁再操作。
      </p>
     </li>
     <li>
      <p>
       <strong>
        乐观锁
       </strong>
       ：假设冲突较少，通过版本号（如CAS）控制。
      </p>
     </li>
    </ul>
    <h3 style="background-color:transparent">
     <strong>
      二、InnoDB 的行级锁类型
     </strong>
    </h3>
    <h4>
     <strong>
      1. 记录锁（Record Locks）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：锁定索引中的一行记录。
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：精确匹配索引的查询。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">UPDATE users SET name = 'Tom' WHERE id = 1; -- 锁定 id=1 的行</code></pre>
    <h4>
     <strong>
      2.间隙锁（Gap Locks）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：锁定索引记录之间的间隙（范围，不包含记录本身）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：防止其他事务插入数据（解决幻读）。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">SELECT * FROM users WHERE age &gt; 20 FOR UPDATE; -- 锁定 age &gt; 20 的间隙</code></pre>
    <h4>
     <strong>
      3.临键锁（Next-Key Locks）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：记录锁 + 间隙锁，锁定一个左开右闭的区间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：可重复读（REPEATABLE READ）下的默认锁机制。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">SELECT * FROM users WHERE id BETWEEN 5 AND 10 FOR UPDATE; -- 锁定 (5,10]</code></pre>
    <h4>
     <strong>
      4.插入意向锁（Insert Intention Locks）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：标记一个间隙，表示事务准备在此插入数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：插入新数据前触发，与间隙锁互斥。
      </p>
     </li>
    </ul>
    <pre><code class="language-sql">INSERT INTO users (id, name) VALUES (6, 'Jerry'); -- 对 id=6 的间隙加插入意向锁</code></pre>
    <h3>
     <strong>
      三、锁的兼容性
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         锁类型
        </strong>
       </th>
       <th>
        记录锁（X）
       </th>
       <th>
        间隙锁（Gap）
       </th>
       <th>
        临键锁（Next-Key）
       </th>
       <th>
        插入意向锁
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         记录锁（X）
        </strong>
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         间隙锁（Gap）
        </strong>
       </td>
       <td>
        兼容
       </td>
       <td>
        兼容
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         临键锁（Next-Key）
        </strong>
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         插入意向锁
        </strong>
       </td>
       <td>
        兼容
       </td>
       <td>
        冲突
       </td>
       <td>
        冲突
       </td>
       <td>
        兼容
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <strong>
      四、不同隔离级别的锁行为
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         隔离级别
        </strong>
       </th>
       <th>
        脏读
       </th>
       <th>
        不可重复读
       </th>
       <th>
        幻读
       </th>
       <th>
        锁机制
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         READ UNCOMMITTED
        </strong>
       </td>
       <td>
        允许
       </td>
       <td>
        允许
       </td>
       <td>
        允许
       </td>
       <td>
        不加锁（仅快照读）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         READ COMMITTED
        </strong>
       </td>
       <td>
        禁止
       </td>
       <td>
        允许
       </td>
       <td>
        允许
       </td>
       <td>
        仅记录锁，无间隙锁
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         REPEATABLE READ
        </strong>
       </td>
       <td>
        禁止
       </td>
       <td>
        禁止
       </td>
       <td>
        禁止
       </td>
       <td>
        记录锁 + 间隙锁（Next-Key Locks）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         SERIALIZABLE
        </strong>
       </td>
       <td>
        禁止
       </td>
       <td>
        禁止
       </td>
       <td>
        禁止
       </td>
       <td>
        所有操作加锁，强制串行执行
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35393436353632342f:61727469636c652f64657461696c732f313436323931353030" class_="artid" style="display:none">
 </p>
</div>


