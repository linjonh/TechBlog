---
layout: post
title: "C基础从C语言快速入门"
date: 2025-03-16 02:35:19 +0800
description: "内联函数的定义（而非仅仅是声明）必须对每个使用它的文件都可见，通常意味着将内联函数定义在头文件中。"
keywords: "C++基础——从C语言快速入门"
categories: ['未分类']
tags: ['算法', '数据结构', 'C']
artid: "146238547"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146238547
    alt: "C基础从C语言快速入门"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146238547
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146238547
cover: https://bing.ee123.net/img/rand?artid=146238547
image: https://bing.ee123.net/img/rand?artid=146238547
img: https://bing.ee123.net/img/rand?artid=146238547
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++基础——从C语言快速入门
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" name="%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">
     <span style="color:#333333">
      <strong>
       输入输出
      </strong>
     </span>
    </h2>
    <p>
     <span style="color:#333333">
      C++
     </span>
     <span style="color:#333333">
      中的输入和输出（
     </span>
     <span style="color:#333333">
      I/O
     </span>
     <span style="color:#333333">
      ）主要是通过标准库中的输入输出流来实现的。最常用的是
     </span>
     <span style="color:#333333">
      iostream
     </span>
     <span style="color:#333333">
      库，它提供了用于输入和输出的基本流类，包括 cin
     </span>
     <span style="color:#333333">
      、
     </span>
     <span style="color:#333333">
      cout
     </span>
     <span style="color:#333333">
      、
     </span>
     <span style="color:#333333">
      cerr
     </span>
     <span style="color:#333333">
      和
     </span>
     <span style="color:#333333">
      clog
     </span>
     <span style="color:#333333">
      。
     </span>
    </p>
    <h3 id="%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%20(%20cout%20)" name="%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%20(%20cout%20)">
     <span style="color:#333333">
      <strong>
       标准输出流
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       (
      </strong>
     </span>
     <span style="color:#333333">
      cout
     </span>
     <span style="color:#333333">
      <strong>
       )
      </strong>
     </span>
    </h3>
    <ul>
     <li>
      <span style="color:#333333">
       cout
      </span>
      <span style="color:#333333">
       代表标准输出流，通常用于向屏幕输出数据。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       使用操作符
      </span>
      <span style="color:#333333">
       &lt;&lt;
      </span>
      <span style="color:#333333">
       （插入操作符）向
      </span>
      <span style="color:#333333">
       cout
      </span>
      <span style="color:#333333">
       发送数据。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       例如， std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;（ endl 相当于换行），会在屏幕上打印 "Hello, world!"
      </span>
      <span style="color:#333333">
       并换行。
      </span>
     </li>
    </ul>
    <h3 id="%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%20(%20cin%20)" name="%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%20(%20cin%20)">
     <span style="color:#333333">
      <strong>
       标准输入流
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       (
      </strong>
     </span>
     <span style="color:#333333">
      cin
     </span>
     <span style="color:#333333">
      <strong>
       )
      </strong>
     </span>
    </h3>
    <ul>
     <li>
      <span style="color:#333333">
       cin
      </span>
      <span style="color:#333333">
       代表标准输入流，用于从键盘接收数据。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       使用操作符
      </span>
      <span style="color:#333333">
       &gt;&gt;
      </span>
      <span style="color:#333333">
       （提取操作符）从
      </span>
      <span style="color:#333333">
       cin
      </span>
      <span style="color:#333333">
       提取数据。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       例如，
      </span>
      <span style="color:#333333">
       int x; std::cin &gt;&gt; x;
      </span>
      <span style="color:#333333">
       会从用户那里读取一个整数并存储在变量
      </span>
      <span style="color:#333333">
       x
      </span>
      <span style="color:#333333">
       中。
      </span>
     </li>
    </ul>
    <h3 id="%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E6%B5%81%20(%20cerr%20)%20%E5%92%8C%E6%A0%87%E5%87%86%E6%97%A5%E5%BF%97%E6%B5%81%20(%20clog%20)" name="%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E6%B5%81%20(%20cerr%20)%20%E5%92%8C%E6%A0%87%E5%87%86%E6%97%A5%E5%BF%97%E6%B5%81%20(%20clog%20)">
     <span style="color:#333333">
      <strong>
       标准错误流
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       (
      </strong>
     </span>
     <span style="color:#333333">
      cerr
     </span>
     <span style="color:#333333">
      <strong>
       )
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       和标准日志流
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       (
      </strong>
     </span>
     <span style="color:#333333">
      clog
     </span>
     <span style="color:#333333">
      <strong>
       )
      </strong>
     </span>
    </h3>
    <ul>
     <li>
      <span style="color:#333333">
       cerr
      </span>
      <span style="color:#333333">
       用于输出错误消息。与
      </span>
      <span style="color:#333333">
       cout
      </span>
      <span style="color:#333333">
       不同，
      </span>
      <span style="color:#333333">
       cerr
      </span>
      <span style="color:#333333">
       不是缓冲的，这意味着它会立即输出。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       clog
      </span>
      <span style="color:#333333">
       类似于
      </span>
      <span style="color:#333333">
       cerr
      </span>
      <span style="color:#333333">
       ，但它是缓冲的。它通常用于记录错误和日志信息。
      </span>
     </li>
    </ul>
    <h3 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
     <span style="color:#333333">
      编程示例
     </span>
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a;
    int b;

    // 输出
    cout &lt;&lt; "请输入数据" &lt;&lt; endl;

    // 输入
    cin &gt;&gt; a;
    cin &gt;&gt; b;

    cout &lt;&lt; a &lt;&lt; "+" &lt;&lt; b &lt;&lt; "=" &lt;&lt; a + b &lt;&lt; endl;

    // 标准错误流
    cerr &lt;&lt; "程序错误退出" &lt;&lt; endl;


    return 0;
}
</code></pre>
    <p>
     <img alt="" height="310" src="https://i-blog.csdnimg.cn/direct/a7f83fc948974224b7be379091bb7ce8.png" width="615"/>
    </p>
    <hr/>
    <h2 id="%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B" name="%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">
     <span style="color:#333333">
      <strong>
       基本变量类型
      </strong>
     </span>
    </h2>
    <p>
     <span style="color:#333333">
      C++ 基本数据类型整理成表格（与
     </span>
     <span style="color:#333333">
      C
     </span>
     <span style="color:#333333">
      语言类似。）。以下是一个表格，展示了不同的基本数据类型及其一般用途和大小范围：
     </span>
    </p>
    <p>
     <img alt="" height="810" src="https://i-blog.csdnimg.cn/direct/c6147a0beb4347cca9a750e36f180387.png" width="719"/>
    </p>
    <h3 id="%E5%AE%BD%E5%AD%97%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95" name="%E5%AE%BD%E5%AD%97%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95">
     <span style="color:#333333">
      <strong>
       宽字符的用法
      </strong>
     </span>
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;wchar.h&gt;

int main() {
    // 设置本地化以支持宽字符
    std::setlocale(LC_ALL, "");

    // 使用 wchar_t 类型定义一个宽字符串
    wchar_t wstr[] = L"你好，世界！";

    // 在 C++ 中打印宽字符串
    std::wcout &lt;&lt; wstr &lt;&lt; std::endl;

    return 0;
}</code></pre>
    <h3 id="climits" name="climits">
     <span style="color:#333333">
      climits
     </span>
    </h3>
    <p>
     <span style="color:#333333">
      在
     </span>
     <span style="color:#333333">
      C++
     </span>
     <span style="color:#333333">
      中，
     </span>
     <span style="color:#333333">
      &lt;climits&gt;
     </span>
     <span style="color:#333333">
      （或在
     </span>
     <span style="color:#333333">
      C
     </span>
     <span style="color:#333333">
      中是
     </span>
     <span style="color:#333333">
      &lt;limits.h&gt;
     </span>
     <span style="color:#333333">
      ）是一个标准头文件，提供了关于整型限制的信 息。
      <u>
       这个头文件中定义了各种整型数据类型的属性，如最大值、最小值等
      </u>
      。使用这些信息可以帮助你了解在特定编译器和平台上各种数据类型的大小和范围。
     </span>
    </p>
    <h4 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20%3Cclimits%3E" name="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20%3Cclimits%3E">
     <span style="color:#333333">
      <strong>
       如何使用
      </strong>
     </span>
     <span style="color:#333333">
      &lt;climits&gt;
     </span>
    </h4>
    <p>
     <span style="color:#333333">
      要使用
     </span>
     <span style="color:#333333">
      &lt;climits&gt;
     </span>
     <span style="color:#333333">
      中定义的常量，你首先需要包含这个头文件：
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;climits&gt;</code></pre>
    <p>
     <span style="color:#333333">
      然后，你可以使用它提供的各种常量，例如：
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#333333">
       INT_MAX
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       int
      </span>
      <span style="color:#333333">
       类型的最大值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       INT_MIN
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       int
      </span>
      <span style="color:#333333">
       类型的最小值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       UINT_MAX
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       unsigned int
      </span>
      <span style="color:#333333">
       类型的最大值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       LONG_MAX
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       long int
      </span>
      <span style="color:#333333">
       类型的最大值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       LONG_MIN
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       long int
      </span>
      <span style="color:#333333">
       类型的最小值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       LLONG_MAX
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       long long int
      </span>
      <span style="color:#333333">
       类型的最大值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       LLONG_MIN
      </span>
      <span style="color:#333333">
       ：
      </span>
      <span style="color:#333333">
       long long int
      </span>
      <span style="color:#333333">
       类型的最小值。
      </span>
     </li>
    </ul>
    <h4 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
     编程示例
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;climits&gt;

int main() {

    std::cout &lt;&lt; "The range of int is from " &lt;&lt; INT_MIN &lt;&lt; " to " &lt;&lt; INT_MAX &lt;&lt; std::endl;
    std::cout &lt;&lt; "The maximum value of unsigned int is " &lt;&lt; UINT_MAX &lt;&lt; std::endl;
    std::cout &lt;&lt; "The range of long long is from " &lt;&lt; LLONG_MIN &lt;&lt; " to " &lt;&lt; LLONG_MAX &lt;&lt; std::endl;

    return 0;
}</code></pre>
    <p>
     <span style="color:#333333">
      这个程序会输出
     </span>
     <span style="color:#333333">
      int
     </span>
     <span style="color:#333333">
      、
     </span>
     <span style="color:#333333">
      unsigned int
     </span>
     <span style="color:#333333">
      和
     </span>
     <span style="color:#333333">
      long long int
     </span>
     <span style="color:#333333">
      类型的最大值和最小值。
     </span>
    </p>
    <p>
     <strong>
      <span style="color:#333333">
       输出结果：
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="519" src="https://i-blog.csdnimg.cn/direct/8753cb17444d42a398b88bff3afed0ab.png" width="993"/>
    </p>
    <h4 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
     <span style="color:#333333">
      注意事项
     </span>
    </h4>
    <ul>
     <li>
      <span style="color:#333333">
       &lt;climits&gt;
      </span>
      <span style="color:#333333">
       提供的是编译时确定的常量，这意味着这些值在编译时就已经固定，根据编译器和平台 的不同而可能有所不同。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       使用这些限制值可以帮助你编写更可移植和安全的代码，特别是在处理可能超出数据类型范围的操作时。
      </span>
     </li>
    </ul>
    <hr/>
    <h2 id="%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6" name="%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">
     <span style="color:#333333">
      <strong>
       流程控制
      </strong>
     </span>
    </h2>
    <p>
     <span style="color:#333333">
      在
     </span>
     <span style="color:#333333">
      C++
     </span>
     <span style="color:#333333">
      中，流程控制语句用于根据不同条件控制程序的执行流程。它们是编程中的基本构建块，允许程序根据条件执行不同的代码段，重复执行某些操作，或者根据特定情况跳过某些代码段。下面是 C++
     </span>
     <span style="color:#333333">
      中最常见的流程控制语句：
     </span>
    </p>
    <h3 id="%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5" name="%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">
     <span style="color:#333333">
      <strong>
       条件语句
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#333333">
      1.
     </span>
     <span style="color:#333333">
      if
     </span>
     <span style="color:#333333">
      <strong>
       语句
      </strong>
     </span>
     <span style="color:#333333">
      ：基于条件的基本控制结构。如果条件为真，则执行代码块。
     </span>
    </p>
    <div>
     <pre><code class="language-cpp">if (condition) {
    // 条件为真时执行的代码
}</code></pre>
     <p>
      <span style="color:#333333">
       else
      </span>
      <span style="color:#333333">
       <strong>
        语句
       </strong>
      </span>
      <span style="color:#333333">
       ：与
      </span>
      <span style="color:#333333">
       if
      </span>
      <span style="color:#333333">
       语句配合使用，当
      </span>
      <span style="color:#333333">
       if
      </span>
      <span style="color:#333333">
       的条件为假时执行。
      </span>
     </p>
     <pre><code class="language-cpp">if (condition) {
    // 条件为真时执行的代码
} else {
    // 条件为假时执行的代码
}</code></pre>
     <p>
      <span style="color:#333333">
       else if
      </span>
      <span style="color:#333333">
       <strong>
        语句
       </strong>
      </span>
      <span style="color:#333333">
       ：用于测试多个条件。
      </span>
     </p>
     <pre><code class="language-cpp">if (condition1) {
    // 第一个条件为真时执行的代码
} else if (condition2) {
    // 第二个条件为真时执行的代码
} else {
    // 所有条件为假时执行的代码
}</code></pre>
     <p>
      <span style="color:#333333">
       switch
      </span>
      <span style="color:#333333">
       <strong>
        语句
       </strong>
      </span>
      <span style="color:#333333">
       ：基于变量的值选择执行不同代码块的方法。
      </span>
     </p>
     <pre><code class="language-cpp">switch (expression) {
    case value1:
        // expression 等于 value1 时执行的代码
        break;
    case value2:
    // expression 等于 value2 时执行的代码
        break;
    default:
        // 没有匹配的 case 时执行的代码
}</code></pre>
     <h3 id="%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5" name="%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">
      <span style="color:#333333">
       <strong>
        循环语句
       </strong>
      </span>
     </h3>
     <p>
      <span style="color:#333333">
       for
      </span>
      <span style="color:#333333">
       循环：当知道循环应该执行的次数时使用。
      </span>
     </p>
     <pre><code class="language-cpp">for (initialization; condition; increment) {
    // 循环体
}</code></pre>
     <p>
      <span style="color:#333333">
       while
      </span>
      <span style="color:#333333">
       <strong>
        循环
       </strong>
      </span>
      <span style="color:#333333">
       ：当条件为真时，重复执行代码块。
      </span>
     </p>
     <pre><code class="language-cpp">while (condition) {
    // 循环体
}</code></pre>
     <p>
      <span style="color:#333333">
       do-while
      </span>
      <span style="color:#333333">
       <strong>
        循环
       </strong>
      </span>
      <span style="color:#333333">
       ：至少执行一次循环体，然后再检查条件。
      </span>
     </p>
     <pre><code class="language-cpp">do {
    // 循环体
} while (condition);</code></pre>
     <h3 id="%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5" name="%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5">
      <span style="color:#333333">
       <strong>
        跳转语句
       </strong>
      </span>
     </h3>
     <p>
      <span style="color:#333333">
       1.
      </span>
      <span style="color:#333333">
       break
      </span>
      <span style="color:#333333">
       <strong>
        语句
       </strong>
      </span>
      <span style="color:#333333">
       ：用于立即跳出最近的
      </span>
      <span style="color:#333333">
       switch
      </span>
      <span style="color:#333333">
       或循环（
      </span>
      <span style="color:#333333">
       for
      </span>
      <span style="color:#333333">
       、
      </span>
      <span style="color:#333333">
       while
      </span>
      <span style="color:#333333">
       、
      </span>
      <span style="color:#333333">
       do-while
      </span>
      <span style="color:#333333">
       ）。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       2.
      </span>
      <span style="color:#333333">
       continue
      </span>
      <span style="color:#333333">
       <strong>
        语句
       </strong>
      </span>
      <span style="color:#333333">
       ：跳过循环的当前迭代，并继续下一次迭代。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       3.
      </span>
      <span style="color:#333333">
       goto
      </span>
      <span style="color:#333333">
       <strong>
        语句
       </strong>
      </span>
      <span style="color:#333333">
       ：直接跳转到程序中的另一个点。使用
      </span>
      <span style="color:#333333">
       goto
      </span>
      <span style="color:#333333">
       通常不推荐，因为它可以使代码难以阅读和维护。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       流程控制语句是编程中非常重要的部分，允许开发者编写可以根据不同情况改变行为的灵活且强大的程序。在使用这些语句时，应该确保逻辑清晰，以便代码易于理解和维护。
      </span>
     </p>
     <hr/>
     <h2 id="%E5%87%BD%E6%95%B0" name="%E5%87%BD%E6%95%B0">
      <span style="color:#333333">
       <strong>
        函数
       </strong>
      </span>
     </h2>
     <p>
      <span style="color:#333333">
       在
      </span>
      <span style="color:#333333">
       C++
      </span>
      <span style="color:#333333">
       中，函数是一段执行特定任务的代码块，它可以带有参数，并且可能返回一个值。函数的使用使得代码更加模块化和可重用，有助于降低代码的复杂性，并提高可维护性。
      </span>
     </p>
     <h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" name="%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">
      <span style="color:#333333">
       <strong>
        函数的基本结构
       </strong>
      </span>
     </h3>
     <p>
      <span style="color:#333333">
       C++
      </span>
      <span style="color:#333333">
       函数的基本结构包括返回类型、函数名、参数列表和函数体：
      </span>
     </p>
     <pre><code class="language-cpp">返回类型 函数名(参数列表) {
    // 函数体
    // 返回语句（如果有返回值的话）
}</code></pre>
     <h4 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
      编程示例
     </h4>
     <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int addFunc(int a, int b)
{
    return a + b;
}

int main()
{
    int a;
    int b;

    cout &lt;&lt; "请输入两个整数" &lt;&lt; endl;

    cin &gt;&gt; a &gt;&gt; b;

    cout &lt;&lt; "结果为：" &lt;&lt; addFunc(a,b) &lt;&lt; endl;

    return 0;
}
</code></pre>
     <p>
      <span style="color:#333333">
       在这个示例中，
      </span>
      <span style="color:#333333">
       addFunc
      </span>
      <span style="color:#333333">
       函数接收两个整数参数，并返回它们的和。
      </span>
     </p>
     <h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" name="%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">
      <span style="color:#333333">
       函数的组成部分
      </span>
     </h3>
     <p>
      <span style="color:#333333">
       1.
      </span>
      <span style="color:#333333">
       <strong>
        返回类型
       </strong>
      </span>
      <span style="color:#333333">
       ：指定函数返回的数据类型。如果函数不返回任何值，则使用
      </span>
      <span style="color:#333333">
       void
      </span>
      <span style="color:#333333">
       。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       2.
      </span>
      <span style="color:#333333">
       <strong>
        函数名
       </strong>
      </span>
      <span style="color:#333333">
       ：函数的标识符，用于调用函数。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       3.
      </span>
      <span style="color:#333333">
       <strong>
        参数列表
       </strong>
      </span>
      <span style="color:#333333">
       ：括号内的变量列表，用于从函数的调用者那里接收值。如果函数不接收任何参数，则此列表为空。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       4.
      </span>
      <span style="color:#333333">
       <strong>
        函数体
       </strong>
      </span>
      <span style="color:#333333">
       ：大括号
      </span>
      <span style="color:#333333">
       {}
      </span>
      <span style="color:#333333">
       内的一系列语句，定义了函数的执行操作。
      </span>
     </p>
     <hr/>
     <h2 id="%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" name="%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">
      <span style="color:#333333">
       <strong>
        内联函数
       </strong>
      </span>
     </h2>
     <p>
      <span style="color:#333333">
       内联函数（
      </span>
      <span style="color:#333333">
       Inline Function
      </span>
      <span style="color:#333333">
       ）是
      </span>
      <span style="color:#333333">
       C++
      </span>
      <span style="color:#333333">
       中一种特殊的函数，
       <u>
        其定义直接在每个调用点展开
       </u>
       。这意味着
       <u>
        编译器会尝试将函数调用替换为函数本身的代码
       </u>
       ，这样可以减少函数调用的开销，尤其是在小型函数中。
      </span>
     </p>
     <h3 id="%E7%89%B9%E7%82%B9" name="%E7%89%B9%E7%82%B9">
      <span style="color:#333333">
       <strong>
        特点
       </strong>
      </span>
     </h3>
     <p>
      <span style="color:#333333">
       1.
      </span>
      <span style="color:#333333">
       <strong>
        减少函数调用开销
       </strong>
      </span>
      <span style="color:#333333">
       ：内联函数通常用于优化小型、频繁调用的函数，因为它避免了函数调用的常规开销（如参数传递、栈操作等）。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       2.
      </span>
      <span style="color:#333333">
       <strong>
        编译器决策
       </strong>
       ：
      </span>
     </p>
     <ul>
      <li>
       由编译器决定是否真正内联（即使使用
       <code>
        inline
       </code>
       关键字，也只是建议，并非强制）。
      </li>
      <li>
       <span style="color:#333333">
        即使函数被声明为内联，
        <u>
         编译器也可能决定不进行内联，特别是对于复杂或递归函数
        </u>
        。
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#333333">
       3.
      </span>
      <span style="color:#333333">
       <strong>
        适用于小型函数
       </strong>
      </span>
      <span style="color:#333333">
       ：通常只有简单的、执行时间短的函数适合做内联。
      </span>
     </p>
     <p>
      <span style="color:#333333">
       4.
      </span>
      <span style="color:#333333">
       <strong>
        定义在每个使用点
       </strong>
      </span>
      <span style="color:#333333">
       ：内联函数的定义（而非仅仅是声明）必须对每个使用它的文件都可见，
       <u>
        通常意味着将内联函数定义在头文件中
       </u>
       。
      </span>
     </p>
     <h3 id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" name="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">
      <span style="color:#333333">
       <strong>
        使用方法
       </strong>
      </span>
     </h3>
     <p>
      <span style="color:#333333">
       通过在
       <u>
        函数声明前添加关键字
       </u>
      </span>
      <u>
       <span style="color:#333333">
        inline
       </span>
      </u>
      <span style="color:#333333">
       <u>
        来指示编译器该函数适合内联
       </u>
       ：
      </span>
     </p>
     <pre><code class="language-cpp">inline int max(int x, int y) {
    return x &gt; y ? x : y;
}</code></pre>
     <p>
      <span style="color:#333333">
       在这个示例中，函数
      </span>
      <span style="color:#333333">
       addFunc
      </span>
      <span style="color:#333333">
       被定义为内联函数。当它被调用时，编译器可能会将函数调用替换为函数体内的代码。
      </span>
     </p>
     <h3 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
      <span style="color:#333333">
       编程示例
      </span>
     </h3>
     <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

// 添加 inline 关键字，声明该函数为内联函数
inline int addFunc(int a, int b)
{
    return a + b;
}

int main()
{
    int a,b;

    cout &lt;&lt; "请输入两个整数：" &lt;&lt; endl;

    cin &gt;&gt; a &gt;&gt; b;

    cout &lt;&lt; "结果为：" &lt;&lt; addFunc(a, b) &lt;&lt; endl;

    return 0;
}
</code></pre>
     <h3 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
      <span style="color:#333333">
       <strong>
        注意事项
       </strong>
      </span>
     </h3>
     <ul>
      <li>
       <span style="color:#333333">
        <strong>
         过度使用的风险
        </strong>
       </span>
       <span style="color:#333333">
        ：不应滥用内联函数，因为这可能会增加最终程序的大小（代码膨胀）。对于大型函数或递归函数，内联可能导致性能下降。
       </span>
      </li>
      <li>
       <span style="color:#333333">
        <strong>
         编译器的决定
        </strong>
       </span>
       <span style="color:#333333">
        ：最终是否将函数内联是由编译器决定的，即使函数被标记为
       </span>
       <span style="color:#333333">
        inline
       </span>
       <span style="color:#333333">
        。
       </span>
      </li>
      <li>
       <span style="color:#333333">
        <strong>
         适用场景
        </strong>
       </span>
       <span style="color:#333333">
        ：最适合内联的是小型函数和在性能要求高的代码中频繁调用的函数。
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#333333">
       内联函数是一种用于优化程序性能的工具，但需要合理使用，以确保代码的可维护性和性能的平衡。
      </span>
     </p>
     <hr/>
     <h3 id="auto%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97" name="auto%C2%A0%E5%85%B3%E9%94%AE%E5%AD%97">
      <span style="color:#0d0016">
       <code>
        auto
       </code>
       关键字
      </span>
     </h3>
     <h4 id="1.%20%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC" name="1.%20%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">
      <span style="color:#0d0016">
       1. 自动类型推导
      </span>
     </h4>
     <h5 id="%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" name="%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
      <span style="color:#0d0016">
       代码示例
      </span>
     </h5>
     <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // 自动推导基本数据类型
    auto num = 10;  // 编译器推断 num 的类型为 int
    auto pi = 3.14; // 编译器推断 pi 的类型为 double

    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    // 自动推导迭代器类型
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
     <ul>
      <li>
       <span style="color:#0d0016">
        <code>
         auto num = 10;
        </code>
        ：由于初始化值
        <code>
         10
        </code>
        是一个整数，编译器自动推断
        <code>
         num
        </code>
        的类型为
        <code>
         int
        </code>
        。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        <code>
         auto pi = 3.14;
        </code>
        ：初始化值
        <code>
         3.14
        </code>
        是一个双精度浮点数，编译器推断
        <code>
         pi
        </code>
        的类型为
        <code>
         double
        </code>
        。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        <code>
         auto it = vec.begin();
        </code>
        ：
        <code>
         vec.begin()
        </code>
        返回的是
        <code>
         std::vector&lt;int&gt;::iterator
        </code>
        类型，使用
        <code>
         auto
        </code>
        可以避免手动书写这个复杂的类型，让代码更简洁。
       </span>
      </li>
     </ul>
     <h4 id="2.%20%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC" name="2.%20%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">
      <span style="color:#0d0016">
       2. 用于函数返回类型推导
      </span>
     </h4>
     <p>
      <span style="color:#0d0016">
       <code>
        auto
       </code>
       可以用于函数返回类型的推导，编译器会根据函数体中的返回语句自动推断返回类型。
      </span>
     </p>
     <h5 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
      <span style="color:#0d0016">
       编程示例
      </span>
     </h5>
     <pre><code class="language-cpp">#include &lt;iostream&gt;

// 函数返回类型推导
auto add(int a, int b) {
    return a + b;
}

int main() {
    auto result = add(3, 5);
    std::cout &lt;&lt; "3 + 5 = " &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}</code></pre>
     <ul>
      <li>
       <code>
        auto add(int a, int b)
       </code>
       ：函数
       <code>
        add
       </code>
       的返回类型使用
       <code>
        auto
       </code>
       进行推导，编译器根据
       <code>
        return a + b;
       </code>
       语句推断返回类型为
       <code>
        int
       </code>
       。
      </li>
     </ul>
     <h4 id="3.%20%E7%94%A8%E4%BA%8E%20lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC" name="3.%20%E7%94%A8%E4%BA%8E%20lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">
      <span style="color:#0d0016">
       3. 用于 lambda 表达式的返回类型推导
      </span>
     </h4>
     <p>
      <span style="color:#0d0016">
       在 lambda 表达式中，
       <code>
        auto
       </code>
       可以让编译器自动推断返回类型，通常情况下可以省略返回类型的显式指定。
      </span>
     </p>
     <h5 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
      <span style="color:#0d0016">
       编程示例
      </span>
     </h5>
     <pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    // lambda 表达式返回类型推导
    auto multiply = [](int a, int b) {
        return a * b;
    };
    auto product = multiply(4, 6);
    std::cout &lt;&lt; "4 * 6 = " &lt;&lt; product &lt;&lt; std::endl;
    return 0;
}</code></pre>
     <ul>
      <li>
       <code>
        auto multiply = [](int a, int b) { return a * b; };
       </code>
       ：lambda 表达式的返回类型由编译器根据
       <code>
        return a * b;
       </code>
       语句自动推断为
       <code>
        int
       </code>
       。
      </li>
     </ul>
     <h4 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
      <span style="color:#0d0016">
       注意事项
      </span>
     </h4>
     <ul>
      <li>
       <strong>
        必须初始化
       </strong>
       ：使用
       <code>
        auto
       </code>
       声明变量时，必须进行初始化，因为编译器需要根据初始化表达式来推断类型。
      </li>
      <li>
       <strong>
        类型可能会被截断
       </strong>
       ：在某些情况下，
       <code>
        auto
       </code>
       推导的类型可能不是你期望的类型，
       <u>
        例如在推导指针和引用时，需要特别注意。
       </u>
      </li>
      <li>
       <strong>
        模板和泛型编程
       </strong>
       ：
       <code>
        auto
       </code>
       在模板和泛型编程中也非常有用，可以让代码更加通用和灵活。
      </li>
     </ul>
     <hr/>
     <h2 id="Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" name="Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F">
      <span style="color:#333333">
       <strong>
        Lambda
       </strong>
      </span>
      <span style="color:#333333">
       <strong>
        表达式
       </strong>
      </span>
     </h2>
     <p>
      在C++中，匿名函数（也称为Lambda表达式）是一种可以在代码中内联定义的函数，而不需要显式地命名。
     </p>
     <h3 id="%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" name="%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">
      基本语法
     </h3>
     <pre><code class="language-cpp">[capture clause](parameters) -&gt; return_type {
    // 函数体
    // 可以使用捕获列表中的变量
    return expression; // 可选的返回语句
}</code></pre>
     <ul>
      <li>
       <span style="color:#0d0016">
        <strong>
         捕获列表（Capture clause）
        </strong>
        ：捕获列表，用于指定Lambda表达式可以访问的外部变量。捕获方式可以是值捕获、引用捕获或混合捕获。
       </span>
      </li>
     </ul>
    </div>
    <ul>
     <li>
      <span style="color:#0d0016">
       <strong>
        参数列表（Parameters）
       </strong>
       ：参数列表，与普通函数的参数列表类似。
      </span>
     </li>
     <li>
      <span style="color:#0d0016">
       <strong>
        返回类型（Return type）
       </strong>
       ：Lambda 表达式可以自动推断返回类型，也可以显式指定返回类型 -&gt; return_type 。如果函数体只有一条返回语句，可以省略返回类型。
      </span>
     </li>
     <li>
      <span style="color:#0d0016">
       <strong>
        函数体（Body）
       </strong>
       ：Lambda 表达式的函数体，包含需要执行的代码。
      </span>
     </li>
    </ul>
    <h3 id="%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8" name="%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8">
     <span style="color:#0d0016">
      捕获列表
     </span>
    </h3>
    <p>
     <span style="color:#0d0016">
      捕获列表用于指定Lambda表达式如何访问外部变量。常见的捕获方式有：
     </span>
    </p>
    <ol>
     <li>
      <p>
       <span style="color:#0d0016">
        <strong>
         值捕获
        </strong>
        ：
        <code>
         [=]
        </code>
        或
        <code>
         [var1, var2]
        </code>
       </span>
      </p>
      <ul>
       <li>
        <p>
         <span style="color:#0d0016">
          <code>
           [=]
          </code>
          ：捕获所有外部变量，按值传递。
         </span>
        </p>
       </li>
       <li>
        <p>
         <span style="color:#0d0016">
          <code>
           [var1, var2]
          </code>
          ：只捕获
          <code>
           var1
          </code>
          和
          <code>
           var2
          </code>
          ，按值传递。
         </span>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <span style="color:#0d0016">
        <strong>
         引用捕获
        </strong>
        ：
        <code>
         [&amp;]
        </code>
        或
        <code>
         [&amp;var1, &amp;var2]
        </code>
       </span>
      </p>
      <ul>
       <li>
        <p>
         <span style="color:#0d0016">
          <code>
           [&amp;]
          </code>
          ：捕获所有外部变量，按引用传递。
         </span>
        </p>
       </li>
       <li>
        <p>
         <span style="color:#0d0016">
          <code>
           [&amp;var1, &amp;var2]
          </code>
          ：只捕获
          <code>
           var1
          </code>
          和
          <code>
           var2
          </code>
          ，按引用传递。
         </span>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <span style="color:#0d0016">
        <strong>
         混合捕获
        </strong>
        ：
        <code>
         [=, &amp;var1]
        </code>
        或
        <code>
         [&amp;, var1]
        </code>
       </span>
      </p>
      <ul>
       <li>
        <p>
         <span style="color:#0d0016">
          <code>
           [=, &amp;var1]
          </code>
          ：按值捕获所有外部变量，但
          <code>
           var1
          </code>
          按引用捕获。
         </span>
        </p>
       </li>
       <li>
        <p>
         <span style="color:#0d0016">
          <code>
           [&amp;, var1]
          </code>
          ：按引用捕获所有外部变量，但
          <code>
           var1
          </code>
          按值捕获。
         </span>
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3 id="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B" name="%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B">
     编程示例
    </h3>
    <p>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      表达式最简单的案例是在需要一个小型函数或临时函数时直接使用它。以下是一个非常简单的例子，其中使用 Lambda
     </span>
     <span style="color:#333333">
      表达式来定义一个加法操作，并立即使用它来计算两个数的和。
     </span>
    </p>
    <h4 id="1.%20%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E6%B3%95" name="1.%20%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E6%B3%95">
     <span style="color:#333333">
      <strong>
       1. 示例：使用
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       Lambda
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       表达式进行加法
      </strong>
     </span>
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a = 5;
    int b = 6;
    int ret;

    auto add = [](int a,int b)-&gt;int{
        return a + b;
    };

    ret = add(a,b);

    cout &lt;&lt; ret &lt;&lt; endl;

    return 0;
}
</code></pre>
    <p>
     <span style="color:#333333">
      在这个例子中：
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#333333">
       我们定义了一个名为
      </span>
      <span style="color:#333333">
       add
      </span>
      <span style="color:#333333">
       的
      </span>
      <span style="color:#333333">
       Lambda
      </span>
      <span style="color:#333333">
       表达式，它接受两个整数参数，并返回它们的和。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       然后，我们使用这个 Lambda
      </span>
      <span style="color:#333333">
       表达式来计算两个数字（
      </span>
      <span style="color:#333333">
       10
      </span>
      <span style="color:#333333">
       和
      </span>
      <span style="color:#333333">
       20
      </span>
      <span style="color:#333333">
       ）的和，并将结果存储在变量
      </span>
      <span style="color:#333333">
       ret 中。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       最后，我们打印出这个和。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#333333">
      这个例子展示了
     </span>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      表达式的基本用法：作为一种简洁而快速的方式来定义小型函数。
     </span>
    </p>
    <p>
     <span style="color:#333333">
      我们可以写一个例子，其中使用一个函数来找出两个数中的较大数，这个函数将接受一个
     </span>
     <span style="color:#333333">
      lambda
     </span>
     <span style="color:#333333">
      函数作为回调来比较这两个数。Lambda
     </span>
     <span style="color:#333333">
      函数将直接在函数调用时定义，完全是匿名的。
     </span>
    </p>
    <h4 id="2.%C2%A0%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%20Lambda%20%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%9A%84%E8%BE%83%E5%A4%A7%E6%95%B0" name="2.%C2%A0%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%20Lambda%20%E5%87%BD%E6%95%B0%E6%9D%A5%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%9A%84%E8%BE%83%E5%A4%A7%E6%95%B0">
     2.
     <span style="color:#333333">
      <strong>
       示例：使用匿名
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       Lambda
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       函数来返回两个数中的较大数
      </strong>
     </span>
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

int getMax(int a, int b, bool(*compare )(int, int))
{
    if(compare (a,b))
    {
        return a;
    }
    else
    {
        return b;
    }
}

int main()
{
    int x = 10;
    int y = 20;

    int ret = getMax(x,y,[](int a,int b)-&gt;bool{
        return a &gt; b;
    });

    std:: cout &lt;&lt; ret &lt;&lt; std:: endl;

    return 0;
}
</code></pre>
    <div>
     <span style="color:#333333">
      在这个例子中：
     </span>
    </div>
    <ul>
     <li>
      <span style="color:#333333">
       getMax
      </span>
      <span style="color:#333333">
       函数接受两个整数
      </span>
      <span style="color:#333333">
       a
      </span>
      <span style="color:#333333">
       和
      </span>
      <span style="color:#333333">
       b
      </span>
      <span style="color:#333333">
       ，以及一个比较函数
      </span>
      <span style="color:#333333">
       compare
      </span>
      <span style="color:#333333">
       。这个比较函数是一个指向函数的指针（函数指针），它接受两个整数并返回一个布尔值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       在
      </span>
      <span style="color:#333333">
       main
      </span>
      <span style="color:#333333">
       函数中，我们调用
      </span>
      <span style="color:#333333">
       getMax
      </span>
      <span style="color:#333333">
       ，并直接在调用点定义了一个匿名的
      </span>
      <span style="color:#333333">
       lambda
      </span>
      <span style="color:#333333">
       函数。这个 lambda 函数接受两个整数并返回一个表示第一个整数是否大于第二个整数的布尔值。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       这个
      </span>
      <span style="color:#333333">
       lambda
      </span>
      <span style="color:#333333">
       函数在
      </span>
      <span style="color:#333333">
       getMax
      </span>
      <span style="color:#333333">
       中被用作比较两个数的逻辑。根据
      </span>
      <span style="color:#333333">
       lambda
      </span>
      <span style="color:#333333">
       函数的返回值，
      </span>
      <span style="color:#333333">
       getMax 返回较大的数。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#333333">
      这个例子展示了如何直接在函数调用中使用匿名
     </span>
     <span style="color:#333333">
      lambda
     </span>
     <span style="color:#333333">
      函数，使代码更加简洁和直接。这种方法在需要临时函数逻辑的场合非常有用，尤其是在比较、条件检查或小型回调中。
     </span>
    </p>
    <p>
     <span style="color:#333333">
      在
     </span>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      表达式中，参数捕获是指
     </span>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      表达式从其定义的上下文中捕获变量的能力。这使得 Lambda 可以使用并操作在其外部定义的变量。捕获可以按值（拷贝）或按引用进行。
     </span>
    </p>
    <p>
     <span style="color:#333333">
      让我们通过一个简单的示例来展示带参数捕获的
     </span>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      表达式。
     </span>
    </p>
    <h4 id="3.%C2%A0%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B8%A6%E5%8F%82%E6%95%B0%E6%8D%95%E8%8E%B7%E7%9A%84%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" name="3.%C2%A0%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B8%A6%E5%8F%82%E6%95%B0%E6%8D%95%E8%8E%B7%E7%9A%84%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F">
     3.
     <span style="color:#333333">
      <strong>
       示例：使用带参数捕获的
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       Lambda
      </strong>
     </span>
     <span style="color:#333333">
      <strong>
       表达式
      </strong>
     </span>
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a = 10;
    int b = 20;
    int c = 30;
    int ret;

    // 捕获外部变量a，b 这两个变量的值不可被更改，可以理解为拷贝一份到匿名函数的捕获列表
    auto add = [a, b]()-&gt;int{
            return a + b;
    };
    ret = add();

    cout &lt;&lt; ret &lt;&lt; endl;

    // 捕获外部所有变量（值捕获），同样这些变量的值不可被更改，可以理解为拷贝一份到匿名函数的捕获列表
    auto multiplication = [=]()-&gt;int{
        return a * b * c;
    };
    ret = multiplication();

    cout &lt;&lt; ret &lt;&lt; endl;

    // 捕获所有外部变量按引用捕获
    auto allVariables = [&amp;]()-&gt;int {
        a++; // 修改变量 a 的实际值，引用捕获可以修改
        return a + b + c;
    };
    ret = allVariables();

    cout &lt;&lt; ret &lt;&lt; endl;
    cout &lt;&lt; a &lt;&lt; endl;

    return 0;
}
</code></pre>
    <p>
     <span style="color:#333333">
      在这个例子中：
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#333333">
       第一个
      </span>
      <span style="color:#333333">
       Lambda
      </span>
      <span style="color:#333333">
       表达式
      </span>
      <span style="color:#333333">
       add
      </span>
      <span style="color:#333333">
       按值捕获了
      </span>
      <span style="color:#333333">
       a
      </span>
      <span style="color:#333333">
       和
      </span>
      <span style="color:#333333">
       b
      </span>
      <span style="color:#333333">
       （即它们的副本）。这意味着
      </span>
      <span style="color:#333333">
       sum
      </span>
      <span style="color:#333333">
       内的
      </span>
      <span style="color:#333333">
       x
      </span>
      <span style="color:#333333">
       和
      </span>
      <span style="color:#333333">
       y
      </span>
      <span style="color:#333333">
       是在
      </span>
      <span style="color:#333333">
       Lambda
      </span>
      <span style="color:#333333">
       定义时的值的拷贝。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       第二个
      </span>
      <span style="color:#333333">
       Lambda
      </span>
      <span style="color:#333333">
       表达式 multiplication 使用
      </span>
      <span style="color:#333333">
       [=]
      </span>
      <span style="color:#333333">
       捕获列表，这表示它按值捕获所有外部变量。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       第三个
      </span>
      <span style="color:#333333">
       Lambda
      </span>
      <span style="color:#333333">
       表达式 allVariables 使用
      </span>
      <span style="color:#333333">
       [&amp;]
      </span>
      <span style="color:#333333">
       捕获列表，这表示它按引用捕获所有外部变量。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#333333">
      因此，它可以修改
     </span>
     <span style="color:#333333">
      x
     </span>
     <span style="color:#333333">
      和
     </span>
     <span style="color:#333333">
      y
     </span>
     <span style="color:#333333">
      的原始值。 这个示例展示了如何使用不同类型的捕获列表（按值和按引用）来控制 Lambda
     </span>
     <span style="color:#333333">
      表达式对外部变量的访问和修改。按值捕获是安全的，但不允许修改原始变量，而按引用捕获允许修改原始变量，但需要注意引用的有效性和生命周期问题。
     </span>
    </p>
    <p>
     <span style="color:#333333">
      以下是一个表格，概述了
     </span>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      函数和内联函数在
     </span>
     <span style="color:#333333">
      C++
     </span>
     <span style="color:#333333">
      中的相似之处和区别：
     </span>
    </p>
    <p>
     <img alt="" height="758" src="https://i-blog.csdnimg.cn/direct/d0c76156eedd4aae991a601969fa2164.png" width="730"/>
    </p>
    <p>
     <span style="color:#333333">
      请注意，虽然
     </span>
     <span style="color:#333333">
      Lambda
     </span>
     <span style="color:#333333">
      函数和内联函数在某些方面有相似之处，如它们都可以被编译器优化以减少调用开销，但它们在设计和用途上有明显的不同。
      <u>
       Lambda
      </u>
     </span>
     <span style="color:#333333">
      <u>
       函数的核心优势在于它们的匿名性和对外部变量的捕获能力，而内联函数则主要关注于提高小型函数的性能
      </u>
      。
     </span>
    </p>
    <h2 id="%E6%95%B0%E7%BB%84" name="%E6%95%B0%E7%BB%84">
     数组
    </h2>
    <p>
     <span style="color:#333333">
      在 C++
     </span>
     <span style="color:#333333">
      中，数组是一种存储固定大小的相同类型元素的序列。数组的所有元素都存储在连续的内存位置上。这种数据结构非常适合于存储具有固定数量和相同数据类型的元素集合。
     </span>
    </p>
    <h3 id="%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84" name="%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84">
     <span style="color:#333333">
      <strong>
       声明数组
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#333333">
      声明数组的基本语法如下：
     </span>
    </p>
    <pre><code class="language-cpp">数据类型 数组名[数组大小];</code></pre>
    <p>
     <span style="color:#333333">
      例如，声明一个类型为
     </span>
     <span style="color:#333333">
      int
     </span>
     <span style="color:#333333">
      的数组，包含
     </span>
     <span style="color:#333333">
      10
     </span>
     <span style="color:#333333">
      个元素：
     </span>
    </p>
    <pre><code class="language-cpp">int myArray[10];</code></pre>
    <h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84" name="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84">
     <span style="color:#333333">
      <strong>
       初始化数组
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#333333">
      在声明数组时，您可以同时初始化数组：
     </span>
    </p>
    <pre><code class="language-cpp">int myArray[5] = {10, 20, 30, 40, 50};</code></pre>
    <p>
     <span style="color:#333333">
      如果您在初始化数组时没有指定所有元素的值，未初始化的元素将被自动设置为该数据类型的默认值（对于基本数据类型通常是 0
     </span>
     <span style="color:#333333">
      ）：
     </span>
    </p>
    <pre><code class="language-cpp">int myArray[5] = {10, 20}; // 其余元素将被初始化为 0</code></pre>
    <h3 id="%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0" name="%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">
     <span style="color:#333333">
      <strong>
       访问数组元素
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#333333">
      您可以通过指定索引来访问数组中的元素。数组索引是从
     </span>
     <span style="color:#333333">
      0
     </span>
     <span style="color:#333333">
      开始的，所以数组的第一个元素是
     </span>
     <span style="color:#333333">
      数组名[0] ，第二个元素是
     </span>
     <span style="color:#333333">
      数组名
     </span>
     <span style="color:#333333">
      [1]
     </span>
     <span style="color:#333333">
      ，依此类推：
     </span>
    </p>
    <pre><code class="language-cpp">int value = myArray[2]; // 访问第三个元素</code></pre>
    <h3 id="%E7%A4%BA%E4%BE%8B" name="%E7%A4%BA%E4%BE%8B">
     <span style="color:#333333">
      <strong>
       示例
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#333333">
      以下是使用数组的简单示例：
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int myArray[5] = {10, 20, 30, 40, 50};

    // 输出所有数组元素的值
    for(int i = 0; i &lt; 5; ++i) {
        cout &lt;&lt; "Element at index " &lt;&lt; i &lt;&lt; ": " &lt;&lt; myArray[i] &lt;&lt; endl;
    }

    return 0;
}</code></pre>
    <p>
     <span style="color:#333333">
      <strong>
       注意事项
      </strong>
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#333333">
       数组的大小必须在编译时已知，且不能更改。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       数组索引越界是常见的错误，可能会导致未定义的行为。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       对于更复杂的用例，您可能需要使用
      </span>
      <span style="color:#333333">
       C++
      </span>
      <span style="color:#333333">
       的标准模板库（
      </span>
      <span style="color:#333333">
       STL
      </span>
      <span style="color:#333333">
       ）中的容器，如
      </span>
      <span style="color:#333333">
       std::vector
      </span>
      <span style="color:#333333">
       ，它提供了可以动态改变大小的数组。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       数组的元素存储在连续的内存位置上，这使得访问数组元素非常快。
      </span>
     </li>
    </ul>
    <h2 id="%E7%BB%83%E4%B9%A0" name="%E7%BB%83%E4%B9%A0">
     练习
    </h2>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    int idata1 = 0;
    int idata2 = 0;
    char compute;

    // Lambad 表达式,值捕获
    auto add = [](int a, int b)-&gt;int{
        return a + b;
    };
    auto subtraction = [](int a, int b)-&gt;int{
        return a - b;
    };
    auto multiplication = [](int a, int b)-&gt;int{
        return a * b;
    };
    auto division = [](int a, int b)-&gt;double{
        return (double)a / b;
    };

    while(1)
    {
        cout &lt;&lt; "请输入需计算的两个整数：" &lt;&lt; endl;
        cin &gt;&gt; idata1;
        cin &gt;&gt; idata2;

        cout &lt;&lt; "请输入计算类型：+、-、*、/" &lt;&lt; endl;
        cin &gt;&gt; compute;

        switch( compute )
        {
            case '+':
                cout &lt;&lt; add(idata1, idata2) &lt;&lt; endl;
                break;
            case '-':
                cout &lt;&lt; subtraction(idata1, idata2) &lt;&lt; endl;
                break;
            case '*':
                cout &lt;&lt; multiplication(idata1, idata2) &lt;&lt; endl;
                break;
            case '/':
                cout &lt;&lt; division(idata1, idata2) &lt;&lt; endl;
                break;
        }
    }
    return 0;
}
</code></pre>
    <p>
     注意：例如，multiplication 如果使用引用捕获，那么 multiplication 这个 Lambda 表达式，需要写在 cin &gt;&gt; idata2 的后面。因为按上面代码的写的，引用捕获会引用 idata1，idata2 初始化赋值的数据，而不是引用 cin 之后的数据。
    </p>
    <h2 id="%E6%8C%87%E9%92%88" name="%E6%8C%87%E9%92%88">
     指针
    </h2>
    <p>
     <span style="color:#333333">
      C++
     </span>
     <span style="color:#333333">
      完全兼容
     </span>
     <span style="color:#333333">
      C
     </span>
     <span style="color:#333333">
      语言指针，多出一个
     </span>
     <span style="color:#333333">
      this
     </span>
     <span style="color:#333333">
      指针，在面向对象中再学。
     </span>
    </p>
    <div>
     <pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

void swap(int *pa, int *pb)
{
    int tmp;
    tmp = *pa;
    *pa = *pb;
    *pb = tmp;
}

int main() {
    int a = 10;
    int b = 20;
    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; "after chage:" &lt;&lt; endl;
    swap(&amp;a,&amp;b);
    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; b &lt;&lt; endl;
}</code></pre>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36313232363434322f:61727469636c652f64657461696c732f313436323338353437" class_="artid" style="display:none">
 </p>
</div>


