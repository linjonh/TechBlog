---
layout: post
title: "动态路径规划01背包问题讲解和通过滚动数组优化"
date: 2025-03-14 20:29:48 +0800
description: "我们在填表的时候发现只用到了相邻的两行其实这里可以用滚动数组来优化，只需要一个dp[N]即可当我们填表时只需要在原表操作，但是我们的填表顺序变为了从右往左因为在填dp[i][j]时我们用到了dp[i-1][j]和dp[i-1][j-v[i]]显然dp[i-1][j-v[i]]位置在dp[i-1][j]前面所以如果从左往右填表会导致在填后一个位置的时候前面的位置的值已经被更新。2.1 当我们不拿时那么我们的dp[i][j]显然和dp[i-1][j]是相等的。3.2 当j为0时说明容积为0那么最大价值也是0。"
keywords: "动态路径规划——01背包问题讲解和通过滚动数组优化"
categories: ['算法']
tags: ['算法']
artid: "146266126"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146266126
    alt: "动态路径规划01背包问题讲解和通过滚动数组优化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146266126
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146266126
cover: https://bing.ee123.net/img/rand?artid=146266126
image: https://bing.ee123.net/img/rand?artid=146266126
img: https://bing.ee123.net/img/rand?artid=146266126
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     动态路径规划——01背包问题讲解和通过滚动数组优化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" height="689" src="https://i-blog.csdnimg.cn/direct/9ffae3b3770841ffa4ddb7f49e34b516.png" width="829"/>
    </p>
    <p>
     如果没有动态路径规划基础的兄弟可以出去了，这个题目有两个问题
    </p>
    <p>
     第一问讲解：
    </p>
    <p>
     1.定义状态表示
    </p>
    <p>
     刚开始我做的时候根据我的经验定义了一个状态表示dp[i]表示从1到i个物品中选择的最大价值，但是这个状态表示有一个明显的问题，我怎么知道第i个物品可不可以放入背包？
    </p>
    <p>
     所以这个一维的状态表示显然是不够的，在上面的时候其实我们只需要知道第i个物品能不能放入背包其实状态表示就完全了，故我们用二维的dp[i][j]来进行状态表示，它表示从1到i个物品中选择容积小于等于j的最大价值
    </p>
    <p>
     2.状态转移方程的推导
    </p>
    <p>
     对于第i个物品我们只有两种选择，要么拿要么不拿
    </p>
    <p>
     2.1 当我们不拿时那么我们的dp[i][j]显然和dp[i-1][j]是相等的
    </p>
    <p>
     2.2 当我们拿时需要先判断空间够不够，如果空间足够那么
    </p>
    <p>
     dp[i][j] = max(dp[i-1][j-v[i]]+w[i],dp[i][j])
    </p>
    <p>
     3.初始化
    </p>
    <p>
     3.1 当i为0时说明没有物品那么容积小于等于j的最大价值其实就是0
    </p>
    <p>
     3.2 当j为0时说明容积为0那么最大价值也是0
    </p>
    <p>
     4.填表顺序
    </p>
    <p>
     观察状态转移方程，我们发现dp[i][j]j会用到前一行的数据（这里是我们后面优化的关键），所以我们的填表顺序是从上往下、从左往右。
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
 
using namespace std;
 
const int N = 1010;
 
int n,V,v[N],w[N];
int dp[N][N];
 
int main()
{
    int ret1 = 0;
    cin&gt;&gt;n&gt;&gt;V;
    for(int i = 1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];
    for(int i = 1;i&lt;=n;i++)
        for(int j = 1;j&lt;=V;j++)
        {
            dp[i][j] = dp[i-1][j];
            if(j&gt;=v[i]) dp[i][j] = max(dp[i][j],
                dp[i-1][j-v[i]]+w[i]);
            ret1 = max(ret1,dp[i][j]);
        }
    cout&lt;&lt;ret1&lt;&lt;endl;
    return 0;
}</code></pre>
    <p>
     第二问讲解
    </p>
    <p>
     1.定义状态表示
    </p>
    <p>
     与第一问很像，但是这是并不是容积小于等于j的最大价值而是容积等于j的最大价值
    </p>
    <p>
     2.状态转移方程
    </p>
    <p>
     和第一问差不多，但是我们需要设定一个值来表示从1到i选不到容积为j的情况这里用-1来表示
    </p>
    <p>
     那么对于第i个位置同样有两种情况
    </p>
    <p>
     2,1 当我们不拿第i个物品时价值为dp[i-1][j](这里已经将选不到容积为j的情况包括)
    </p>
    <p>
     2.2 当我们如果要拿第i个物品时，那么我们首先当然是先判断空间j够不够，然后还要判断
    </p>
    <p>
     dp[i-1][j-v[i]]这个位置是否有意义即是否为-1，如果有意义那么
    </p>
    <p>
     dp[i][j] = max(dp[i-1][j-v[i]]+w[i],dp[i][j])
    </p>
    <p>
     3.初始化
    </p>
    <p>
     这里当i == 0时如果要选择容积等于j的最大价值显然是没有意义的所以我们将dp[0][j](j&gt;=1&amp;&amp;j&lt;=V)初始化为-1
    </p>
    <p>
     当j == 0时只需要不选择物品即可所以初始化dp[i][0]（i &gt;= 1&amp;&amp;i&lt;=n）为0
    </p>
    <p>
     4.填表顺序同上
    </p>
    <pre><code class="language-cpp"> for(int i = 1;i&lt;=V;i++) dp[0][i] = -1;
    int ret2 = -1;
    for(int i = 1;i&lt;=n;i++)
        for(int j = 1;j&lt;=V;j++)
        {
            dp[i][j] = dp[i-1][j];
            if(j&gt;=v[i] &amp;&amp; (dp[i-1][j-v[i]] != -1))
                dp[i][j] = max(dp[i][j],dp[i-1][j-v[i]]+w[i]);
        }
    for(int i = 1;i&lt;=n;i++) ret2 = max(ret2,dp[i][V]);
    if(ret2 == -1) cout&lt;&lt;0&lt;&lt;endl;
    else cout&lt;&lt;ret2&lt;&lt;endl;</code></pre>
    <p>
    </p>
    <p>
     下面讲讲这个算法的优化
    </p>
    <p>
     我们在填表的时候发现只用到了相邻的两行其实这里可以用滚动数组来优化，只需要一个dp[N]即可当我们填表时只需要在原表操作，但是我们的填表顺序变为了从右往左因为在填dp[i][j]时我们用到了dp[i-1][j]和dp[i-1][j-v[i]]显然dp[i-1][j-v[i]]位置在dp[i-1][j]前面所以如果从左往右填表会导致在填后一个位置的时候前面的位置的值已经被更新
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

const int N = 1010;

int n,V,v[N],w[N];
int dp[N];

int main()
{
    int ret1 = 0;
    cin&gt;&gt;n&gt;&gt;V;
    for(int i = 1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];
    for(int i = 1;i&lt;=n;i++)
        for(int j = V;j&gt;=v[i];j--)
        {
            dp[j] = max(dp[j],dp[j-v[i]]+w[i]);
            ret1 = max(ret1,dp[j]);
        }
    cout&lt;&lt;ret1&lt;&lt;endl;
    //第二问的初始化
    for(int i = 1;i&lt;=V;i++) dp[i] = -1;
    int ret2 = -1;
    for(int i = 1;i&lt;=n;i++)
        for(int j = V;j&gt;=v[i];j--)
        {
            if((dp[j-v[i]] != -1))
                dp[j] = max(dp[j],dp[j-v[i]]+w[i]);
        }
    for(int i = 1;i&lt;=n;i++) ret2 = max(ret2,dp[V]);
    if(ret2 == -1) cout&lt;&lt;0&lt;&lt;endl;
    else cout&lt;&lt;ret2&lt;&lt;endl;
    return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393634343931392f:61727469636c652f64657461696c732f313436323636313236" class_="artid" style="display:none">
 </p>
</div>


