---
layout: post
title: "go语言圣经1.3"
date: 2025-03-11 21:17:45 +0800
description: "标准化输出 format格式化动词%d 十进制整数%x, %o, %b 十六进制，八进制，二进制整数。%f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00%t 布尔：true或false%c 字符（rune） (Unicode码点)%s 字符串%q 带双引号的字符串\"abc\"或带单引号的字符'c'%v 变量的自然形式（natural format）%T 变量的类型%% 字面上的百分号标志（无操作数）转义字符。"
keywords: "【go语言圣经1.3】"
categories: ['未分类']
tags: ['Golang']
artid: "146189389"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146189389
    alt: "go语言圣经1.3"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146189389
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146189389
cover: https://bing.ee123.net/img/rand?artid=146189389
image: https://bing.ee123.net/img/rand?artid=146189389
img: https://bing.ee123.net/img/rand?artid=146189389
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【go语言圣经1.3】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     概念
    </h3>
    <ol>
     <li>
      <code>
       map
      </code>
      数据类型
      <ul>
       <li>
        <strong>
         map
        </strong>
        存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用
        <code>
         ==
        </code>
        运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数
        <code>
         make
        </code>
        创建空
        <code>
         map
        </code>
        ，此外，它还有别的作用。4.3 节讨论
        <code>
         map
        </code>
        。
       </li>
       <li>
        从功能和实现上说，
        <code>
         Go
        </code>
        的
        <code>
         map
        </code>
        类似于
        <code>
         Java
        </code>
        语言中的
        <code>
         HashMap
        </code>
        ，Python 语言中的
        <code>
         dict
        </code>
        ，
        <code>
         Lua
        </code>
        语言中的
        <code>
         table
        </code>
        ，通常使用
        <code>
         hash
        </code>
        实现
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_6">
     </a>
     语言特性
    </h3>
    <ol>
     <li>
      <p>
       if 语句：条件部分不需要括号，但主体必须用大括号包围。
      </p>
     </li>
     <li>
      <p>
       Go 中只有 for 一种循环形式，可以写成传统 for 循环、while 循环形式或无限循环。
      </p>
     </li>
     <li>
      <p>
       通过 range 遍历 map 或切片时，返回的顺序是不确定的，这要求程序不能依赖遍历顺序。
      </p>
     </li>
     <li>
      <p>
       标准输入与文件输入都通过类似方式处理：使用
       <code>
        bufio.Scanner
       </code>
       或
       <code>
        ioutil.ReadFile
       </code>
       。不同之处在于：前者逐行读取适合大数据流，后者适合一次性加载整个文件
      </p>
     </li>
     <li>
      <p>
       map 是一种引用类型（这里的“引用”类似于指针，但语法上更加简单）
      </p>
      <ul>
       <li>
        当你使用
        <code>
         make(map[string]int)
        </code>
        创建一个 map 时，实际上 Go 分配了一块内存来存储这个 map 的数据，并返回了一个引用，这个引用指向那块内存。你可以把这个引用看作是一个“地址”，它告诉程序实际数据存储在哪里。
       </li>
       <li>
        当你将 map 作为参数传递给函数时，传递的是这个引用的一个副本（浅拷贝），而不是整个 map 数据结构的拷贝。副本只是另一个指向同一块内存的引用。
       </li>
       <li>
        因为传入函数的 map 引用（副本）和原始的 map 引用都指向同一块内存，所以在函数内部对 map 的修改（如增加、删除或更新键值对）会直接影响到这块内存。结果就是，无论是在函数内部还是外部，你看到的都是同一份数据。
       </li>
       <li>
        再次强调：对于 map，使用
        <strong>
         赋值语句
        </strong>
        或者
        <strong>
         传递参数
        </strong>
        时，实际上只是把
        <strong>
         这个 map 的引用
        </strong>
        复制了一份（浅拷贝）。新变量和原变量都指向同一块内存区域。
       </li>
      </ul>
      <pre><code class="prism language-go">original <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">}</span>
copyRef <span class="token operator">:=</span> original <span class="token comment">// 复制的是引用，而非数据内容的独立副本</span>

copyMap <span class="token operator">:=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span> <span class="token comment">// 相当于手动复制了 map 的每个键值对</span>

</code></pre>
     </li>
    </ol>
    <h3>
     <a id="_27">
     </a>
     要点（案例）
    </h3>
    <p>
     通过 dup 程序的三个版本，我们可以看到 Go 语言在文本处理上的多种方法和技巧：
    </p>
    <ul>
     <li>
      <strong>
       dup1
      </strong>
      采用流式读取和 map 统计的方式，适合处理标准输入；
     </li>
     <li>
      <strong>
       dup2
      </strong>
      在此基础上扩展到处理具名文件，并引入了错误处理；
     </li>
     <li>
      <strong>
       dup3
      </strong>
      则展示了如何一次性读取整个文件，再用字符串分割方法处理数据。
     </li>
    </ul>
    <p>
     在 dup 程序中，核心思想是扫描输入中的每一行，然后利用数据结构统计每一行出现的次数，最后只输出出现多次的行。
    </p>
    <p>
     这个思路在许多文本处理工具中都非常常见，比如 Unix 中的 uniq 命令（寻找相邻的重复行）
    </p>
    <pre><code class="prism language-go"><span class="token comment">// Dup1 prints the text of each line that appears more than</span>
<span class="token comment">// once in the standard input, preceded by its count.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"bufio"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token builtin">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	counts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
	input <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
	<span class="token keyword">for</span> input<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		counts<span class="token punctuation">[</span>input<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// NOTE: ignoring potential errors from input.Err()</span>
<span class="token keyword">for</span> line<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> counts<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> n <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <ul>
     <li>
      <code>
       bufio
      </code>
      ：提供高效的缓冲输入，主要用于按行读取文本。
     </li>
     <li>
      <code>
       os
      </code>
      ：提供与操作系统交互的能力，比如读取标准输入
     </li>
     <li>
      <strong>
       主要数据结构——map
      </strong>
      <ul>
       <li>
        使用
        <code>
         make(map[string]int)
        </code>
        创建了一个空的 map，该 map 的键为字符串（每一行的内容），值为整型（该行出现的次数）。
       </li>
       <li>
        当某一行首次出现时，由于 map 默认值为该类型的零值（对 int 来说为 0），直接进行自增操作
        <code>
         counts[input.Text()]++
        </code>
        即可。
       </li>
      </ul>
     </li>
     <li>
      bufio.Scanner
      <ul>
       <li>
        <code>
         Scanner
        </code>
        类型是
        <code>
         bufio
        </code>
        包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法
       </li>
       <li>
        <code>
         bufio.NewScanner(os.Stdin)
        </code>
        创建了一个扫描器，用于逐行读取标准输入。
       </li>
       <li>
        调用
        <code>
         input.Scan()
        </code>
        读取下一行, 并移除行末的换行符(当没有更多输入时返回 false)
       </li>
       <li>
        调用
        <code>
         input.Text()
        </code>
        可以获取当前扫描到的行（已经去掉了换行符）
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-go"><span class="token comment">// Dup2 prints the count and text of lines that appear more than once</span>
<span class="token comment">// in the input.  It reads from stdin or from a list of named files.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"bufio"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	counts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
	
	files <span class="token operator">:=</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">countLines</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">,</span> counts<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> arg <span class="token operator">:=</span> <span class="token keyword">range</span> files<span class="token punctuation">{<!-- --></span>
			f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
			<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"dup2:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token function">countLines</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> counts<span class="token punctuation">)</span>
			f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> line<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> counts <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> n <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">countLines</span><span class="token punctuation">(</span>f <span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> counts <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	input <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token keyword">for</span> input<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		counts<span class="token punctuation">[</span>input<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// NOTE: ignoring potential errors from input.Err()</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      扩展读取具名函数的能力
     </li>
     <li>
      将按行读取并计数的逻辑提取到独立的函数
      <code>
       countLines
      </code>
      中
      <ul>
       <li>
        由于 map 是引用类型，将其作为参数传递后，函数内部对 map 的修改会反映到外部。
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-go"><span class="token comment">// 使用一种不同的方法：一次性将整个文件内容读入内存，再进行分割处理</span>

<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io/ioutil"</span>
    <span class="token string">"os"</span>
    <span class="token string">"strings"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	counts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> filename <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
        data<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"dup3: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> line <span class="token operator">:=</span> <span class="token keyword">range</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            counts<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token operator">++</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> line<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> counts <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> n <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <ul>
     <li>
      <code>
       ioutil.ReadFile
      </code>
      函数用于一次性读取整个文件内容，返回的是
      <strong>
       字节切片。
      </strong>
     </li>
     <li>
      需要将
      <strong>
       字节切片
      </strong>
      转换为
      <strong>
       字符串
      </strong>
      后
      <code>
       string(data)
      </code>
      ，才能使用
      <code>
       strings.Split
      </code>
      按换行符分割成多个行。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      <ul>
       <li>
        当输入数据较小或对内存要求不高时，一次性读取所有内容简化了处理过程；
       </li>
       <li>
        对于大文件或内存敏感的应用，前两种基于流式处理的方式（dup1 和 dup2）更合适。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_166">
     </a>
     总结与补充
    </h3>
    <ol>
     <li>
      标准化输出 format
      <ul>
       <li>
        <p>
         格式化动词
        </p>
        <pre><code class="prism language-go"><span class="token operator">%</span>d          十进制整数
<span class="token operator">%</span>x<span class="token punctuation">,</span> <span class="token operator">%</span>o<span class="token punctuation">,</span> <span class="token operator">%</span>b  十六进制，八进制，二进制整数。
<span class="token operator">%</span>f<span class="token punctuation">,</span> <span class="token operator">%</span>g<span class="token punctuation">,</span> <span class="token operator">%</span>e  浮点数： <span class="token number">3.141593</span> <span class="token number">3.141592653589793</span> <span class="token number">3.141593e+00</span>
<span class="token operator">%</span>t          布尔：<span class="token boolean">true</span>或<span class="token boolean">false</span>
<span class="token operator">%</span>c          字符（<span class="token builtin">rune</span>） <span class="token punctuation">(</span>Unicode码点<span class="token punctuation">)</span>
<span class="token operator">%</span>s          字符串
<span class="token operator">%</span>q          带双引号的字符串<span class="token string">"abc"</span>或带单引号的字符<span class="token char">'c'</span>
<span class="token operator">%</span>v          变量的自然形式（natural format）
<span class="token operator">%</span>T          变量的类型
<span class="token operator">%</span><span class="token operator">%</span>          字面上的百分号标志（无操作数）

</code></pre>
       </li>
       <li>
        <p>
         转义字符
        </p>
       </li>
      </ul>
     </li>
     <li>
      strings包的常用函数
      <ul>
       <li>
        <strong>
         <code>
          strings.Split(s, sep string) []string
         </code>
        </strong>
        将字符串s按照分隔符sep分割成子串，并返回字符串切片
       </li>
       <li>
        <code>
         strings.Join(a []string, sep string) string
        </code>
        将字符串切片a中的各个元素以分隔符sep连接成一个单一的字符串
       </li>
      </ul>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f5079726f79737465722f:61727469636c652f64657461696c732f313436313839333839" class_="artid" style="display:none">
 </p>
</div>


