---
layout: post
title: "Python函数一"
date: 2025-03-10 22:58:35 +0800
description: "python 函数相关内容笔记"
keywords: "Python：函数（一）"
categories: ['Python']
tags: ['开发语言', 'Windows', 'Python']
artid: "146164851"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146164851
    alt: "Python函数一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146164851
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146164851
cover: https://bing.ee123.net/img/rand?artid=146164851
image: https://bing.ee123.net/img/rand?artid=146164851
img: https://bing.ee123.net/img/rand?artid=146164851
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python：函数（一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      python函数相关的知识点
     </p>
    </blockquote>
    <h4>
     1. 函数定义与调用
    </h4>
    <p>
     <strong>
      定义
     </strong>
     ：使用
     <code>
      def
     </code>
     关键字，后接函数名和参数列表。
    </p>
    <pre><code class="language-python">def greet(name):
    """打印问候语（文档字符串）"""
    print(f"Hello, {name}!")</code></pre>
    <p>
     <strong>
      调用
     </strong>
     ：
    </p>
    <pre><code class="language-python">greet("Alice")  # 输出：Hello, Alice!</code></pre>
    <hr/>
    <h4>
     2. 参数与返回值
    </h4>
    <ul>
     <li>
      ​
      <strong>
       位置参数
      </strong>
      ：按顺序传递参数。
     </li>
     <li>
      ​
      <strong>
       默认参数
      </strong>
      ：为参数提供默认值。
     </li>
    </ul>
    <pre><code class="language-python">def power(base, exponent=2):
    return base ​** exponent

print(power(3))      # 输出：9（使用默认exponent=2）
print(power(2, 4))   # 输出：16</code></pre>
    <ul>
     <li>
      ​
      <strong>
       返回值
      </strong>
      ：使用
      <code>
       return
      </code>
      返回结果，无返回值时默认返回
      <code>
       None
      </code>
      。
     </li>
    </ul>
    <pre><code class="language-python">def add(a, b):
    return a + b

result = add(3, 5)  # result = 8</code></pre>
    <blockquote>
     <p>
      1. ​
      <strong>
       参数传递的基本机制
      </strong>
     </p>
     <p>
      Python中所有参数的传递都是 ​
      <span style="color:#fe2c24">
       <strong>
        对象引用的传递
       </strong>
      </span>
      ：
     </p>
     <ul>
      <li>
       <p>
        ​
        <span style="color:#fe2c24">
         <strong>
          不可变对象
         </strong>
         ​
        </span>
        （如整数、字符串、元组）：函数内对形参的修改会创建新对象，不影响实参。
       </p>
      </li>
      <li>
       <p>
        <span style="color:#fe2c24">
         ​
         <strong>
          可变对象
         </strong>
        </span>
        ​（如列表、字典）：函数内对形参的修改会影响实参（因为它们指向同一对象）。解决：传副本
       </p>
      </li>
     </ul>
     <p>
      示例
     </p>
     <p>
     </p>
     <pre><code class="language-python">def modify(a, b,c):
    a = 2       # 修改不可变对象（创建新对象）
    b.append(3) # 修改可变对象
    c.append(4)

x = 1          # 不可变
y = [1, 2]     # 可变
c=[1,2,3]
modify(x, y,c.copy())

print(x)       # 输出：1（未改变）
print(y)       # 输出：[1, 2, 3]（已改变）
print(c)       # 输出：[1, 2, 3]（不改变）</code></pre>
     <hr/>
     <p>
      2. ​
      <strong>
       参数传递的方式
      </strong>
     </p>
     <p>
      Python支持多种参数传递方式，具体取决于函数定义和调用时的语法。
     </p>
     <p>
      (1) ​
      <strong>
       位置参数（Positional Arguments）​
      </strong>
     </p>
     <p>
      按参数定义顺序传递，最常见的方式。
     </p>
     <p>
     </p>
     <pre><code class="language-python">def add(a, b):
    return a + b

print(add(3, 5))  # 输出：8</code></pre>
     <p>
      (2) ​
      <strong>
       关键字参数（Keyword Arguments）​
      </strong>
     </p>
     <p>
      通过参数名指定值，顺序可以打乱。
     </p>
     <p>
     </p>
     <pre><code class="language-python">print(add(b=5, a=3))  # 输出：8</code></pre>
     <p>
      (3) ​
      <strong>
       默认参数（Default Arguments）​
      </strong>
     </p>
     <p>
      为参数提供默认值，调用时可省略。
     </p>
     <p>
     </p>
     <pre><code class="language-python">def greet(name, msg="Hello"):
    print(f"{msg}, {name}!")

greet("Alice")          # 输出：Hello, Alice!
greet("Bob", "Hi")      # 输出：Hi, Bob!</code></pre>
     <p>
      (4) ​
      <strong>
       可变参数（*args 和 ​
      </strong>
      kwargs）​**
     </p>
     <ul>
      <li>
       <p>
        <code>
         *args
        </code>
        ：接收任意数量的位置参数（元组形式）(写最后）。
       </p>
      </li>
      <li>
       <p>
        <code>
         **kwargs
        </code>
        ：接收任意数量的关键字参数（字典形式）（写最后）。
       </p>
      </li>
     </ul>
     <p>
     </p>
     <pre><code class="language-python">def print_all(*args, ​**kwargs):
    print("位置参数:", args)
    print("关键字参数:", kwargs)

print_all(1, 2, name="Alice", age=25)
# 输出：
# 位置参数: (1, 2)
# 关键字参数: {'name': 'Alice', 'age': 25}</code></pre>
     <hr/>
     <p>
      3. ​
      <strong>
       参数解包（Unpacking）​
      </strong>
     </p>
     <p>
      在调用函数时，可以使用
      <code>
       *
      </code>
      和
      <code>
       **
      </code>
      解包序列或字典作为参数。
     </p>
     <p>
      示例
     </p>
     <pre><code class="language-python">def func(a, b, c):
    print(a, b, c)

# 解包列表/元组（按位置传递）
args = [1, 2, 3]
func(*args)  # 输出：1 2 3

# 解包字典（按关键字传递）
kwargs = {"a": 1, "b": 2, "c": 3}
func(**kwargs)  # 输出：1 2 3</code></pre>
     <hr/>
     <p>
      4. ​
      <strong>
       注意事项
      </strong>
     </p>
     <p>
      (1) ​
      <strong>
       默认参数的陷阱
      </strong>
     </p>
     <p>
      默认参数的值在函数定义时计算一次，若默认值是可变对象，多次调用会共享该对象。
     </p>
     <p>
     </p>
     <pre><code class="language-python">def append_to(item, lst=[]):
    lst.append(item)
    return lst

# 第一次调用
print(append_to(1))  # 输出：[1]
# 第二次调用
print(append_to(2))  # 输出：[1, 2]（而不是预期的[2]）</code></pre>
     <p>
      ​
      <strong>
       原因分析
      </strong>
     </p>
     <ul>
      <li>
       Python 在函数定义时（即代码加载时）就创建了默认参数
       <code>
        lst=[]
       </code>
       ，并将其存储在函数对象的
       <code>
        __defaults__
       </code>
       属性中。
      </li>
      <li>
       ​
       <strong>
        所有未显式传递
        <code>
         lst
        </code>
        参数的调用，都会共享同一个列表对象
       </strong>
       。
      </li>
      <li>
       每次调用
       <code>
        append_to
       </code>
       时，修改的是同一个列表，而不是创建新列表。
      </li>
     </ul>
     <p>
      <strong>
       修正方法
      </strong>
      ：使用不可变对象（如
      <code>
       None
      </code>
      ）占位。
     </p>
     <pre><code class="language-python">def append_to(item, lst=None):
    if lst is None:
        lst = []  # 每次调用时创建新列表
    lst.append(item)
    return lst

# 第一次调用
print(append_to(1))  # 输出：[1]
# 第二次调用
print(append_to(2))  # 输出：[2]（符合预期）</code></pre>
     <p>
      ​
      <strong>
       关键点
      </strong>
     </p>
     <ul>
      <li>
       默认参数设为
       <code>
        None
       </code>
       （不可变对象）。
      </li>
      <li>
       在函数内部检查
       <code>
        lst is None
       </code>
       ，若为真则创建一个新的空列表。
      </li>
      <li>
       ​
       <strong>
        每次调用都会生成新的列表对象
       </strong>
       ，避免共享问题。
      </li>
     </ul>
     <p>
      默认参数是字典、集合等可变对象时，同样需要警惕：
     </p>
     <pre><code class="language-python"># 错误示例：默认值为空字典
def update_dict(key, value, d={}):
    d[key] = value
    return d

print(update_dict("a", 1))  # {'a': 1}
print(update_dict("b", 2))  # {'a': 1, 'b': 2}

# 正确写法
def update_dict(key, value, d=None):
    if d is None:
        d = {}
    d[key] = value
    return d</code></pre>
     <p>
      通过
      <code>
       __defaults__
      </code>
      属性查看函数的默认参数值：
     </p>
     <pre><code class="language-python">def func(a, lst=[]):
    pass

print(func.__defaults__)  # 输出：([],)

# 调用函数后，默认列表被修改
func(1)
print(func.__defaults__)  # 输出：([1],)</code></pre>
     <ul>
      <li>
       ​
       <strong>
        规则
       </strong>
       ：默认参数的值在函数定义时被计算一次，并存储在函数对象中。
      </li>
      <li>
       ​
       <strong>
        陷阱
       </strong>
       ：若默认值是可变对象（列表、字典等），所有未显式传递该参数的调用会共享同一个对象。
      </li>
      <li>
       ​
       <strong>
        解决
       </strong>
       ：用
       <code>
        None
       </code>
       作为默认值，在函数内部初始化可变对象。
      </li>
      <li>
       <pre><code class="language-python"># 错误写法 ❌
def func(arg=[]):
    pass

# 正确写法 ✅
def func(arg=None):
    if arg is None:
        arg = []</code></pre>
      </li>
     </ul>
     <p>
      (2) ​
      <strong>
       避免意外修改可变对象
      </strong>
     </p>
     <p>
      若函数需要处理可变对象但不希望影响原始数据，应创建副本。
     </p>
     <p>
     </p>
     <pre><code class="language-python">def process_list(lst):
    lst = lst.copy()  # 创建副本
    lst.append(100)
    return lst

original = [1, 2, 3]
modified = process_list(original)
print(original)  # [1, 2, 3]（未被修改）
print(modified)   # [1, 2, 3, 100]</code></pre>
     <hr/>
     <p>
      5. ​
      <strong>
       总结
      </strong>
     </p>
     <table>
      <thead>
       <tr>
        <th>
         <p>
          参数类型
         </p>
        </th>
        <th>
         <p>
          特点
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <p>
          位置参数
         </p>
        </td>
        <td>
         <p>
          按顺序传递，简单直接
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          关键字参数
         </p>
        </td>
        <td>
         <p>
          按参数名指定，提高可读性
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          默认参数
         </p>
        </td>
        <td>
         <p>
          提供默认值，简化调用
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          可变参数（
          <code>
           *args
          </code>
          ）
         </p>
        </td>
        <td>
         <p>
          接收任意数量的位置参数
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          可变参数（
          <code>
           **kwargs
          </code>
          ）
         </p>
        </td>
        <td>
         <p>
          接收任意数量的关键字参数
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          参数解包
         </p>
        </td>
        <td>
         <p>
          使用
          <code>
           *
          </code>
          和
          <code>
           **
          </code>
          将序列或字典解包为参数
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </blockquote>
    <blockquote>
     <p>
      返回值
     </p>
     <p>
      1. ​
      <strong>
       基本返回值
      </strong>
     </p>
     <p>
      使用
      <code>
       return
      </code>
      语句返回结果。如果没有
      <code>
       return
      </code>
      或
      <code>
       return
      </code>
      后无值，函数默认返回
      <code>
       None
      </code>
      。
     </p>
     <pre><code class="language-python">def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 输出：8

# 无返回值的函数
def greet(name):
    print(f"Hello, {name}!")

result = greet("Alice")  # 输出：Hello, Alice!
print(result)            # 输出：None</code></pre>
     <hr/>
     <p>
      2. ​
      <strong>
       返回多个值
      </strong>
     </p>
     <p>
      Python 允许通过 ​
      <strong>
       返回元组
      </strong>
      实现多值返回，调用时可以直接解包。
     </p>
     <pre><code class="language-python">def min_max(numbers):
    return min(numbers), max(numbers)

values = [4, 2, 9, 7]
min_val, max_val = min_max(values)#解包
print(f"最小值: {min_val}, 最大值: {max_val}")  # 输出：最小值: 2, 最大值: 9</code></pre>
     <p>
      本质
     </p>
     <p>
      函数返回的多个值实际上是一个元组，解包是隐式操作：
     </p>
     <pre><code class="language-python">result = min_max(values)
print(result)  # 输出：(2, 9)</code></pre>
     <hr/>
     <p>
      3. ​
      <strong>
       返回复杂对象
      </strong>
     </p>
     <p>
      函数可以返回列表、字典、类实例等任意对象。
     </p>
     <p>
      示例 1：返回字典
     </p>
     <pre><code class="language-python">def create_person(name, age):
    return {"name": name, "age": age}

person = create_person("Bob", 30)
print(person)  # 输出：{'name': 'Bob', 'age': 30}</code></pre>
     <p>
      示例 2：返回函数（闭包）
     </p>
     <p>
     </p>
     <pre><code class="language-python">def outer():
    def inner():
        print("内部函数被调用")
    return inner

func = outer()
func()  # 输出：内部函数被调用</code></pre>
     <p>
     </p>
     <p>
      4. ​
      <strong>
       返回生成器（
       <code>
        yield
       </code>
       ）​
      </strong>
     </p>
     <p>
      使用
      <code>
       yield
      </code>
      关键字定义生成器函数，返回一个生成器对象，支持迭代。
     </p>
     <p>
     </p>
     <pre><code class="language-python">def count_up_to(max):
    count = 1
    while count &lt;= max:
        yield count
        count += 1

generator = count_up_to(3)
for num in generator:
    print(num)  # 依次输出：1, 2, 3</code></pre>
     <hr/>
     <p>
      5. ​
      <strong>
       返回
       <code>
        None
       </code>
       的情况
      </strong>
     </p>
     <p>
      以下情况函数返回
      <code>
       None
      </code>
      ：
     </p>
     <ol>
      <li>
       <p>
        没有
        <code>
         return
        </code>
        语句。
       </p>
      </li>
      <li>
       <p>
        <code>
         return
        </code>
        语句没有指定返回值。
       </p>
      </li>
      <li>
       <p>
        <code>
         return
        </code>
        后仅写
        <code>
         None
        </code>
        。
       </p>
      </li>
     </ol>
     <pre><code class="language-python">def func1():
    pass

def func2():
    return

def func3():
    return None

print(func1())  # None
print(func2())  # None
print(func3())  # None</code></pre>
     <hr/>
     <p>
      6. ​
      <strong>
       提前返回与多条件返回
      </strong>
     </p>
     <p>
      函数中可以存在多个
      <code>
       return
      </code>
      语句，执行到第一个
      <code>
       return
      </code>
      时函数终止。
     </p>
     <p>
      示例：根据条件返回不同结果
     </p>
     <pre><code class="language-python">def check_number(num):
    if num &lt; 0:
        return "负数"
    elif num == 0:
        return "零"
    else:
        return "正数"

print(check_number(-5))  # 输出：负数
print(check_number(0))   # 输出：零
print(check_number(10))  # 输出：正数</code></pre>
     <hr/>
     <p>
      7. ​
      <strong>
       注意事项
      </strong>
     </p>
     <p>
      (1) ​
      <strong>
       返回值与可变对象
      </strong>
     </p>
     <p>
      <span style="color:#fe2c24">
       如果返回的是可变对象（如列表、字典），多次调用可能共享同一对象（需谨慎）。
      </span>
     </p>
     <pre><code class="language-python">def get_list():
    return []

list1 = get_list()
list2 = get_list()
list1.append(1)
print(list2)  # 输出：[]（安全，因为每次返回新列表）

# 但若函数内部缓存了可变对象：
def get_cached_list(lst=[]):
    return lst

list3 = get_cached_list()
list4 = get_cached_list()
list3.append(1)
print(list4)  # 输出：[1]（危险！共享同一列表）</code></pre>
     <p>
      (2) ​
      <strong>
       类型提示（Python 3+）​
      </strong>
     </p>
     <p>
      可以为返回值添加类型注解，提高代码可读性。
     </p>
     <pre><code class="language-python">def add(a: int, b: int) -&gt; int:
    return a + b</code></pre>
     <hr/>
     <p>
      8. ​
      <strong>
       总结
      </strong>
     </p>
     <table>
      <thead>
       <tr>
        <th>
         <p>
          返回类型
         </p>
        </th>
        <th>
         <p>
          示例
         </p>
        </th>
        <th>
         <p>
          说明
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <p>
          单个值
         </p>
        </td>
        <td>
         <p>
          <code>
           return 10
          </code>
         </p>
        </td>
        <td>
         <p>
          直接返回数据
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          多个值（元组解包）
         </p>
        </td>
        <td>
         <p>
          <code>
           return a, b
          </code>
         </p>
        </td>
        <td>
         <p>
          返回元组，调用时可解包
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          复杂对象
         </p>
        </td>
        <td>
         <p>
          <code>
           return {"data": [...]}
          </code>
         </p>
        </td>
        <td>
         <p>
          返回字典、列表、实例等
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          函数或闭包
         </p>
        </td>
        <td>
         <p>
          <code>
           return inner
          </code>
         </p>
        </td>
        <td>
         <p>
          返回内部函数，形成闭包
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          生成器
         </p>
        </td>
        <td>
         <p>
          <code>
           yield value
          </code>
         </p>
        </td>
        <td>
         <p>
          返回生成器，支持惰性计算
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          <code>
           None
          </code>
         </p>
        </td>
        <td>
         <p>
          <code>
           return
          </code>
          或
          <code>
           return None
          </code>
         </p>
        </td>
        <td>
         <p>
          默认返回值
         </p>
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      合理使用返回值可以让函数更灵活，例如：
     </p>
     <ul>
      <li>
       <p>
        通过返回生成器处理大数据集（节省内存）。
       </p>
      </li>
      <li>
       <p>
        返回函数实现装饰器或策略模式。
       </p>
      </li>
      <li>
       <p>
        返回元组简化多值传递。
       </p>
      </li>
     </ul>
    </blockquote>
    <h4>
     3. 作用域与
     <code>
      global
     </code>
    </h4>
    <ul>
     <li>
      函数内部默认不能修改全局变量，需使用
      <code>
       global
      </code>
      声明。
     </li>
    </ul>
    <pre><code class="language-python">x = 10

def modify_global():
    global x
    x = 20

modify_global()
print(x)  # 输出：20</code></pre>
    <hr/>
    <h4>
     5. 嵌套函数、闭包与装饰器
    </h4>
    <ul>
     <li>
      ​
      <strong>
       嵌套函数
      </strong>
      ：在函数内部定义另一个函数。
     </li>
     <li>
      ​
      <strong>
       闭包
      </strong>
      ：内部函数记住外部作用域的变量。
     </li>
    </ul>
    <pre><code class="language-python">def outer(msg):
    def inner():
        print(msg)  # 闭包保留外部变量msg
    return inner

closure = outer("Hello")
closure()  # 输出：Hello</code></pre>
    <p>
     装饰器用于增强函数功能，不修改原函数代码。
    </p>
    <pre><code class="language-python">def my_decorator(func):
    def wrapper():
        print("装饰器：函数执行前")
        func()
        print("装饰器：函数执行后")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# 输出：
# 装饰器：函数执行前
# Hello!
# 装饰器：函数执行后</code></pre>
    <blockquote>
     <p>
      在 Python 中，​
      <strong>
       闭包（Closure）​
      </strong>
      和 ​
      <strong>
       装饰器（Decorator）​
      </strong>
      是两个紧密关联且强大的概念，它们通过函数的高阶特性实现代码复用和动态扩展功能。
     </p>
     <hr/>
     <p>
      一、闭包（Closure）
     </p>
     <p>
      1. ​
      <strong>
       定义
      </strong>
     </p>
     <p>
      闭包是 ​
      <strong>
       一个函数与其外部作用域变量的绑定关系
      </strong>
      。即使外部函数已执行完毕，内部函数仍能访问和修改外部函数的变量。
     </p>
     <p>
      2. ​
      <strong>
       核心机制
      </strong>
     </p>
     <ul>
      <li>
       <p>
        ​
        <strong>
         捕获变量
        </strong>
        ：内部函数会“记住”外部函数的作用域（即闭包环境）。
       </p>
      </li>
      <li>
       <p>
        ​
        <strong>
         延迟绑定
        </strong>
        ：闭包中的变量引用在函数调用时才解析，可能导致意外行为（需注意循环变量问题）。
       </p>
      </li>
     </ul>
     <p>
      3. ​
      <strong>
       示例
      </strong>
     </p>
     <pre><code class="language-python">def outer(msg):
    def inner():
        print(msg)  # inner捕获了外部变量msg
    return inner

closure = outer("Hello")
closure()  # 输出：Hello（即使outer函数已执行完毕，msg仍被保留）</code></pre>
     <p>
      4. ​
      <strong>
       实际应用
      </strong>
     </p>
     <ul>
      <li>
       <p>
        ​
        <strong>
         工厂函数
        </strong>
        ：动态生成不同行为的函数。
       </p>
      </li>
     </ul>
     <pre><code class="language-python">def power_factory(exponent):
    def power(base):
        return base ​** exponent  # 捕获exponent
    return power

square = power_factory(2)
print(square(3))  # 9（3^2）</code></pre>
     <ul>
      <li>
       <p>
        ​
        <strong>
         延迟绑定问题与解决
        </strong>
        ：
       </p>
      </li>
     </ul>
     <pre><code class="language-python"># 错误示例：所有闭包共享循环变量i的最终值
def create_buttons():
    buttons = []
    for i in range(3):
        def button():
            print(f"Button {i} clicked")
        buttons.append(button)
    return buttons

# 解决：通过默认参数或嵌套函数绑定当前值
def create_buttons_fixed():
    buttons = []
    for i in range(3):
        def wrapper(x):  # 捕获当前x的值
            def button():
                print(f"Button {x} clicked")
            return button
        buttons.append(wrapper(i))
    return buttons</code></pre>
     <h5>
      1. ​
      <strong>
       状态保持计数器
      </strong>
     </h5>
     <pre><code class="language-python">def counter(start=0):
    count = start  # 闭包保存状态
    def increment():
        nonlocal count  # 声明为非局部变量
        count += 1
        return count
    return increment

c = counter(10)
print(c())  # 11
print(c())  # 12（闭包记住count的值）</code></pre>
     <h5>
      2. ​
      <strong>
       动态配置函数
      </strong>
     </h5>
     <pre><code class="language-python">def configure_printer(prefix):
    def printer(message):
        print(f"[{prefix}] {message}")  # 闭包捕获prefix
    return printer

error_log = configure_printer("ERROR")
info_log = configure_printer("INFO")

error_log("File not found!")  # [ERROR] File not found!
info_log("Process started.")  # [INFO] Process started.</code></pre>
     <h5>
      3. ​
      <strong>
       缓存机制
      </strong>
     </h5>
     <pre><code class="language-python">def cached(func):
    cache = {}  # 闭包保存缓存数据
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

@cached
def factorial(n):
    return 1 if n &lt;= 1 else n * factorial(n-1)

print(factorial(5))  # 120（后续调用直接返回缓存结果）</code></pre>
     <p>
     </p>
     <p>
     </p>
     <p>
      二、装饰器（Decorator）
     </p>
     <p>
      1. ​
      <strong>
       定义
      </strong>
     </p>
     <p>
      装饰器是 ​
      <strong>
       一个修改其他函数行为的函数
      </strong>
      ，通过接受目标函数作为参数，返回增强后的新函数，而无需修改原函数代码。
     </p>
     <p>
      2. ​
      <strong>
       核心机制
      </strong>
     </p>
     <ul>
      <li>
       <p>
        ​
        <strong>
         高阶函数
        </strong>
        ：装饰器本身是一个返回函数的函数。
       </p>
      </li>
      <li>
       <p>
        ​
        <strong>
         语法糖
        </strong>
        ：使用
        <code>
         @decorator
        </code>
        简化装饰器调用。
       </p>
      </li>
     </ul>
     <p>
      3. ​
      <strong>
       基本示例
      </strong>
     </p>
     <pre><code class="language-python">def logger(func):
    def wrapper(*args, ​**kwargs):
        print(f"调用函数: {func.__name__}")
        return func(*args, ​**kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

print(add(3, 5))  
# 输出：
# 调用函数: add
# 8</code></pre>
     <p>
      4. ​
      <strong>
       带参数的装饰器
      </strong>
     </p>
     <p>
      需三层嵌套函数：
     </p>
     <pre><code class="language-python">def repeat(n):
    def decorator(func):
        def wrapper(*args, ​**kwargs):
            result = None
            for _ in range(n):
                result = func(*args, ​**kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# 输出：
# Hello, Alice!
# Hello, Alice!
# Hello, Alice!</code></pre>
     <p>
      5. ​
      <strong>
       类装饰器
      </strong>
     </p>
     <p>
      通过实现
      <code>
       __call__
      </code>
      方法：
     </p>
     <pre><code class="language-python">class Timer:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, ​**kwargs):
        import time
        start = time.time()
        result = self.func(*args, ​**kwargs)
        end = time.time()
        print(f"{self.func.__name__} 执行时间: {end - start:.2f}s")
        return result

@Timer
def slow_func():
    time.sleep(1)

slow_func()  # 输出：slow_func 执行时间: 1.00s</code></pre>
     <p>
      6. ​
      <strong>
       实际应用
      </strong>
     </p>
     <ul>
      <li>
       <p>
        ​
        <strong>
         缓存（Memoization）​
        </strong>
        ：
       </p>
      </li>
     </ul>
     <pre><code class="language-python">def memoize(func):
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

@memoize
def fibonacci(n):
    return n if n &lt;= 1 else fibonacci(n-1) + fibonacci(n-2)</code></pre>
     <ul>
      <li>
       <p>
        ​
        <strong>
         权限验证
        </strong>
        ：
       </p>
      </li>
     </ul>
     <pre><code class="language-python">def login_required(func):
    def wrapper(user, *args, ​**kwargs):
        if user.is_authenticated:
            return func(user, *args, ​**kwargs)
        else:
            raise PermissionError("用户未登录")
    return wrapper</code></pre>
     <p>
      7. ​
      <strong>
       注意事项
      </strong>
     </p>
     <ul>
      <li>
       <p>
        ​
        <strong>
         多个装饰器的顺序
        </strong>
        ：装饰器从下往上应用，但执行顺序从上到下。
       </p>
       <pre><code class="language-python">@decorator1
@decorator2
def func(): pass
# 等效于 func = decorator1(decorator2(func))</code></pre>
      </li>
      <li>
       <p>
        ​
        <strong>
         保留原函数元信息
        </strong>
        ：使用
        <code>
         functools.wraps
        </code>
        保留原函数名和文档。
       </p>
       <pre><code class="language-python">from functools import wraps
def logger(func):
    @wraps(func)
    def wrapper(*args, ​**kwargs):
        print(f"调用函数: {func.__name__}")
        return func(*args, ​**kwargs)
    return wrapper</code></pre>
      </li>
     </ul>
     <hr/>
     <p>
      三、闭包与装饰器的关系
     </p>
     <ul>
      <li>
       <p>
        ​
        <strong>
         装饰器依赖闭包
        </strong>
        ：装饰器通常通过闭包保存目标函数和装饰器参数。
       </p>
      </li>
      <li>
       <p>
        ​
        <strong>
         闭包是装饰器的基础
        </strong>
        ：装饰器返回的增强函数本质上是一个闭包，捕获了原函数和装饰逻辑。
       </p>
      </li>
     </ul>
     <hr/>
     <p>
      四、总结
     </p>
     <table>
      <thead>
       <tr>
        <th>
         <p>
          概念
         </p>
        </th>
        <th>
         <p>
          特点
         </p>
        </th>
        <th>
         <p>
          应用场景
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <p>
          闭包
         </p>
        </td>
        <td>
         <p>
          内部函数捕获外部变量，保留状态
         </p>
        </td>
        <td>
         <p>
          工厂函数、延迟计算、回调
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          装饰器
         </p>
        </td>
        <td>
         <p>
          动态扩展函数功能，不修改原代码，支持多层装饰
         </p>
        </td>
        <td>
         <p>
          日志、缓存、权限、性能测试
         </p>
        </td>
       </tr>
      </tbody>
     </table>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h4>
     7. Lambda 函数
    </h4>
    <p>
     匿名函数，适用于简单操作。
    </p>
    <pre><code class="language-python">square = lambda x: x ​** 2
print(square(4))  # 输出：16

# 结合map使用
numbers = [1, 2, 3]
squared = list(map(lambda x: x**2, numbers))  # [1, 4, 9]</code></pre>
    <hr/>
    <h4>
     8. 生成器函数
    </h4>
    <p>
     使用
     <code>
      yield
     </code>
     逐个返回值，节省内存。
    </p>
    <pre><code class="language-python">def count_up_to(max):
    count = 1
    while count &lt;= max:
        yield count
        count += 1

for num in count_up_to(3):
    print(num)  # 输出：1 2 3</code></pre>
    <hr/>
    <h4>
     9. 递归函数
    </h4>
    <p>
     函数调用自身，需设置终止条件。
    </p>
    <pre><code class="language-python">def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))  # 输出：120</code></pre>
    <hr/>
    <h4>
     10. 参数传递的注意事项
    </h4>
    <ul>
     <li>
      ​
      <strong>
       可变对象
      </strong>
      ​（如列表）作为参数时，函数内修改会影响原始对象。
     </li>
    </ul>
    <pre><code class="language-python">def append_item(lst, item):
    lst.append(item)

my_list = [1, 2]
append_item(my_list, 3)
print(my_list)  # 输出：[1, 2, 3]</code></pre>
    <hr/>
    <h4>
     11. 函数注解
    </h4>
    <p>
     提供类型提示（Python 3+）。
    </p>
    <pre><code>def greet(name: str, age: int) -&gt; str:
    return f"{name} is {age} years old."</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323733373438362f:61727469636c652f64657461696c732f313436313634383531" class_="artid" style="display:none">
 </p>
</div>


