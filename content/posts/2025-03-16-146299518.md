---
layout: post
title: "平方矩阵问题"
date: 2025-03-16 20:40:08 +0800
description: "在这个程序中，每个位置 ( 𝑖 , 𝑗 )需要填充一个数，该数的计算方式是取该位置到四条边的最短距离。"
keywords: "平方矩阵问题"
categories: ['C']
tags: ['矩阵']
artid: "146299518"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146299518
    alt: "平方矩阵问题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146299518
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146299518
cover: https://bing.ee123.net/img/rand?artid=146299518
image: https://bing.ee123.net/img/rand?artid=146299518
img: https://bing.ee123.net/img/rand?artid=146299518
---

# 平方矩阵问题

### Ⅰ

[回字形二维数组](https://www.acwing.com/problem/content/755/)

    
    
    #include <iostream>
    #include <iomanip>
    using namespace std;
    int main(){
        int n;
        while(cin>>n,n){
            for(int i=0; i<n;i++){
                for(int j=0; j<n; j++){
                    int up=i, down=n-i+1, left=j, right=n-j+1;
                    cout<<min(min(up,down),min(left,right))<<' ';
                    
                }
                cout<<endl;
            }
            cout<<endl;
        }
        return 0;
    }
    

在这个程序中，每个位置 ( 𝑖 , 𝑗 )需要填充一个数，该数的计算方式是取该位置到四条边的最短距离。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/801aa0a526a94f2e8d1a346784d969ff.png#pic_center)

### Ⅱ

[二维数组](https://www.acwing.com/problem/content/756/)

    
    
    #include <iostream>
    using namespace std;
    int a[100][100];
    int main(){
        int n；
        while(cin>>n,n){
            for(int i=0; i<n; i++){
                //填充对角线
                a[i][j]==1;
                //填充上三角
                for(int j=i+1, k=2; j<n; j++, k++){
                    //行不变列变
                    a[i][j]=k;
                }
                //填充下三角
                for(int j=i+1, k=2; j<n; j++,k++){
                    //行变列不变
                    a[j][i]=k;
                }
            }
            
            //输出
            for(int i=0; i<n; i++){
                for(int j=0; j<n; j++){
                    cout<<a[i][j]<<endl;
                }
                cout<<endl;
            }
            cout<<endl;
        }
        return 0;
    }
    

上三角填充分析  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3ef541ed4618492da65be2016e4dddc5.png#pic_center)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8ddde93ded9343dfa1fc9d953c48ba7e.png#pic_center)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1463c09911f747539baac59c8877609d.png#pic_center)  
//下三角填充分析  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/756a4f4521af43dda6ffacc905ef7e6e.png#pic_center)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6bdbb68ea8ad4abdbd4db4b26cca6583.png#pic_center)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7f371965dd794f349fa8508e567db970.png#pic_center)

### Ⅲ

[2的 i + j 次方](https://www.acwing.com/problem/content/757/)

    
    
    #include <iostream>
    using namespace std;
    int main(){
        int n;
        while(cin>>n, n){
            for(int i=0; i<n; i++){
                for(int j=0; j<n; j++){
                    int v=1;
                    //2的n次方等于n个2相乘
                    for(int k=0; k<i+j; k++){
                        v*=2;
                    }
                    cout<<v<<' ';
                }
                cout<<endl;
            }
            cout<<endl;
        }
        return 0;
    }
    

### Ⅳ

[蛇形矩阵](https://www.acwing.com/problem/content/758/)

    
    
    #include <iostream>
    using namespace std;
    int res[100][100];
    int main(){
        int n,m;
        cin>>n>>m;
        //定义方向数组
        //控制行变动
        int dx[]={0,1,0,-1}
        //控制列变动
        int dy[]={1,0,-1,0};
        
        //x = 0, y = 0：起始位置在矩阵的左上角 (0,0)
        //d = 0：初始方向向右
        //k = 1：从 1 开始填充到 n*m，一共 n*m 次
        
        for(int x=0, y=0, d=0, k=1; k<=n*m; k++){
            
            res[x][y] = k;
            
            //计算当前方向的下一个坐标 (a, b)
            int a=x+dx[d] , b=y+dy[d];
            
            //判断是否 超出矩阵边界 (a < 0, a >= n, b < 0, b >= m)。
            //判断是否 已经填充过 (res[a][b] 非零)。
            if(a<0 || a>=n || b<0 || b>=m || res[a][b]){
                //(d + 1) % 4 保证 d 在 0~3 之间循环
                d=(d+1)%4;
                
                如果无法前进，则顺时针换方向 (d+1)，再计算新方向的 (a, b)
                a=x+dx[d],b=y+dy[d];
            }
            //更新 x, y 为新的位置。
            x=a, y=b;
        }
        
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                cout<<res[i][j]<<' ';
            }
            cout<<endl;
        }
        return 0;
    }
    

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4b526e1dc199449e9e561e76156845dc.png#pic_center)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/db0826c9c8d3469fb1e90e00286064ec.png#pic_center)



