---
layout: post
title: "Linux五种-IO-模型与非阻塞-IO"
date: 2025-03-16 13:00:53 +0800
description: "本文深入探讨分析了五种I/O模型（阻塞、非阻塞、信号驱动、多路复用、异步I/O）的特点与适用场景，并通过实例代码展示了如何实现非阻塞I/O操作。"
keywords: "【Linux】五种 IO 模型与非阻塞 IO"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux', 'Io', 'C']
artid: "146243172"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146243172
    alt: "Linux五种-IO-模型与非阻塞-IO"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146243172
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146243172
cover: https://bing.ee123.net/img/rand?artid=146243172
image: https://bing.ee123.net/img/rand?artid=146243172
img: https://bing.ee123.net/img/rand?artid=146243172
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Linux】五种 IO 模型与非阻塞 IO
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <img src="https://i-blog.csdnimg.cn/direct/d2fb21b1ee6743fca931495a42612e07.png#pic_center" width="10%">
     <p>
      🌈
      <strong>
       个人主页：
       <a href="https://blog.csdn.net/weixin_50776420?type=blog">
        Zfox_
       </a>
      </strong>
      <br/>
      🔥
      <strong>
       系列专栏：
       <a href="https://blog.csdn.net/weixin_50776420/category_12753277.html?spm=1001.2014.3001.5482">
        Linux
       </a>
      </strong>
     </p>
     <img src="https://i-blog.csdnimg.cn/direct/9f847edb50d9499e90b73ca82eff1413.gif" width="160%">
      <p>
      </p>
      <p>
      </p>
      <h2>
       <a id="font_colorDarkOrchid__IOfont_9">
       </a>
       <font color="DarkOrchid">
        一：🔥 重新理解 IO
       </font>
      </h2>
      <h3>
       <a id="__IO__12">
       </a>
       🦋 为什么说网络问题的本质是 I/O 问题？
      </h3>
      <h4>
       <a id="__14">
       </a>
       🎀 从数据流动看网络通信
      </h4>
      <ul>
       <li>
        <strong>
         <font color="#41acs">
          网络通信的核心
         </font>
        </strong>
        ：数据在客户端与服务器之间**
        <font color="#41acs">
         双向流动**。
        </font>
        <ul>
         <li>
          客户端发送请求 →
          <strong>
           <font color="#41acs">
            输出（Write）
           </font>
          </strong>
         </li>
         <li>
          服务器接收请求 →
          <strong>
           <font color="#41acs">
            输入（Read）
           </font>
          </strong>
         </li>
         <li>
          服务器返回响应 →
          <strong>
           <font color="#41acs">
            输出（Write）
           </font>
          </strong>
         </li>
         <li>
          客户端接收响应 →
          <strong>
           <font color="#41acs">
            输入（Read）
           </font>
          </strong>
         </li>
        </ul>
       </li>
       <li>
        <strong>
         <font color="#41acs">
          每个步骤均涉及 I/O 操作
         </font>
        </strong>
        ：数据通过网卡、内核缓冲区、用户程序传递，本质是
        <strong>
         <font color="#41acs">
          跨层数据搬运
         </font>
        </strong>
        。
       </li>
      </ul>
      <h4>
       <a id="__IO__23">
       </a>
       🎀 网络 I/O 的瓶颈
      </h4>
      <ul>
       <li>
        <strong>
         <font color="#41acs">
          延迟（Latency）
         </font>
        </strong>
        ：数据从一端到另一端的传输时间（如物理距离、路由跳数）。
       </li>
       <li>
        <strong>
         <font color="#41acs">
          带宽（Bandwidth）
         </font>
        </strong>
        ：单位时间内可传输的数据量上限。
       </li>
       <li>
        <strong>
         <font color="#41acs">
          并发（Concurrency）
         </font>
        </strong>
        ：同时处理的连接数影响资源分配效率。
       </li>
      </ul>
      <p>
       <strong>
        总结
       </strong>
       ：
       <br/>
       网络性能优化的核心是
       <strong>
        <code>
         减少 I/O 等待时间
        </code>
       </strong>
       和
       <strong>
        <code>
         提升 I/O 吞吐量
        </code>
       </strong>
       。
      </p>
      <hr/>
      <h3>
       <a id="__IO__34">
       </a>
       🦋 如何理解 I/O 的本质？
      </h3>
      <p>
       🔬
       <strong>
        <font color="#41acs">
         IO 就是 input，output，参照物是计算机本身，是计算机系统内部和外部设备进行交互的过程。
        </font>
       </strong>
      </p>
      <p>
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          IO = 等+拷贝（等是主要矛盾） 
         
        
       
      
        \colorbox{#FF7F00}{IO = 等+拷贝（等是主要矛盾）}
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1.3667em; vertical-align: -0.3833em;">
           </span>
           <span class="mord">
            <span class="vlist-t vlist-t2">
             <span class="vlist-r">
              <span class="vlist" style="height: 0.9833em;">
               <span class="" style="top: -2.9833em;">
                <span class="pstrut" style="height: 3.3667em;">
                </span>
                <span class="stretchy colorbox" style="height: 1.3667em; background-color: rgb(255, 127, 0);">
                </span>
               </span>
               <span class="" style="top: -3.3667em;">
                <span class="pstrut" style="height: 3.3667em;">
                </span>
                <span class="mord boxpad">
                 <span class="mord">
                  IO =
                 </span>
                 <span class="mord cjk_fallback">
                  等
                 </span>
                 <span class="mord">
                  +
                 </span>
                 <span class="mord cjk_fallback">
                  拷贝（等是主要矛盾）
                 </span>
                </span>
               </span>
              </span>
              <span class="vlist-s">
               ​
              </span>
             </span>
             <span class="vlist-r">
              <span class="vlist" style="height: 0.3833em;">
               <span class="">
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </p>
      <p>
       🐳 等待外部设备就绪，当外部设备准备好了以后，通过 CPU 的针脚发送中断信号告知操作系统。操作系统转入内核态，进行拷贝工作。
      </p>
      <ol>
       <li>
        <strong>
         <font color="viole">
          等待（Waiting）
         </font>
        </strong>
        ：
        <mark>
         等待数据就绪（如网络数据到达内核缓冲区、磁盘数据加载到内存）。
        </mark>
       </li>
       <li>
        <strong>
         <font color="viole">
          拷贝（Copying）
         </font>
        </strong>
        ：
        <mark>
         将数据从内核缓冲区复制到用户空间（或反向）。
        </mark>
       </li>
      </ol>
      <p>
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          高效IO 
         
        
       
      
        \colorbox{turquoise}{高效IO}
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1.2833em; vertical-align: -0.3em;">
           </span>
           <span class="mord">
            <span class="vlist-t vlist-t2">
             <span class="vlist-r">
              <span class="vlist" style="height: 0.9833em;">
               <span class="" style="top: -2.9833em;">
                <span class="pstrut" style="height: 3.2833em;">
                </span>
                <span class="stretchy colorbox" style="height: 1.2833em; background-color: turquoise;">
                </span>
               </span>
               <span class="" style="top: -3.2833em;">
                <span class="pstrut" style="height: 3.2833em;">
                </span>
                <span class="mord boxpad">
                 <span class="mord cjk_fallback">
                  高效
                 </span>
                 <span class="mord">
                  IO
                 </span>
                </span>
               </span>
              </span>
              <span class="vlist-s">
               ​
              </span>
             </span>
             <span class="vlist-r">
              <span class="vlist" style="height: 0.3em;">
               <span class="">
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
       <br/>
       <strong>
        <code>
         上面说的IO=等待+拷贝
        </code>
       </strong>
      </p>
      <p>
       在大多数情况下，时间都浪费在等待上面，因为和等待相比，拷贝要花的时间比等待的时间少的多。
      </p>
      <ul>
       <li>
        <strong>
         高效 IO 的核心
        </strong>
        ：
        <strong>
         减少等待时间的浪费
        </strong>
        ，而非单纯优化拷贝速度。
       </li>
      </ul>
      <hr/>
      <p>
       <strong>
        <font color="#FF4500">
         等待的分类
        </font>
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         主动等待
        </strong>
        ：进程阻塞直到数据就绪（如阻塞式
        <code>
         read()
        </code>
        ）。
       </li>
       <li>
        <strong>
         被动等待
        </strong>
        ：进程通过轮询或事件通知检查状态（如非阻塞 IO +
        <code>
         epoll
        </code>
        ）。
       </li>
      </ul>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <ul>
       <li>
        <strong>
         网络请求
        </strong>
        ：客户端等待服务器响应的 RTT（Round-Trip Time）属于被动等待。
       </li>
       <li>
        <strong>
         数据库查询
        </strong>
        ：从磁盘读取数据时，CPU 因 IO 阻塞而空闲属于主动等待。
       </li>
      </ul>
      <h3>
       <a id="__IO_68">
       </a>
       🦋 什么是高效的 I/O？
      </h3>
      <p>
       ⚡🧙 任何通信场景，IO 通信效率一定是有上限的，毕竟 花盆里长不出参天大树（受硬件限制）
      </p>
      <p>
       <strong>
        IO效率低
       </strong>
       的原因主要有以下几点：
      </p>
      <ol>
       <li>
        <strong>
         等待时间
        </strong>
        ：IO操作通常涉及与外部设备的交互，这些设备的速度远低于CPU和内存。例如，硬盘的读写速度比内存慢几个数量级，网络传输的速度也受带宽和延迟的限制。因此，程序在等待IO操作完成时会浪费大量时间。
       </li>
       <li>
        <strong>
         上下文切换
        </strong>
        ：在阻塞IO中，操作系统需要将等待IO的进程挂起，并切换到其他进程执行。这种上下文切换会消耗额外的CPU资源，降低整体效率，
       </li>
       <li>
        <strong>
         资源竞争
        </strong>
        ：在高并发环境下，多个进程或线程可能同时请求IO操作，导致资源竞争和排队，进一步增加等待时间。
       </li>
      </ol>
      <h4>
       <a id="__IO__78">
       </a>
       🎀 高效 I/O 的目标
      </h4>
      <ol>
       <li>
        <strong>
         最大化 CPU 利用率
        </strong>
        ：减少进程因等待 I/O 而阻塞的时间。
       </li>
       <li>
        <strong>
         最小化延迟
        </strong>
        ：快速响应每个 I/O 请求。
       </li>
       <li>
        <strong>
         最大化吞吐量
        </strong>
        ：单位时间内处理更多 I/O 操作。
       </li>
      </ol>
      <h4>
       <a id="__IO__85">
       </a>
       🎀 实现高效 I/O 的策略
      </h4>
      <p>
       <strong>
        策略 1：减少阻塞等待
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         非阻塞 I/O
        </strong>
        ：轮询检查数据是否就绪，避免进程挂起。
        <ul>
         <li>
          <strong>
           代价
          </strong>
          ：频繁轮询可能导致 CPU 空转。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         多路复用（如
         <code>
          epoll
         </code>
         ）
        </strong>
        ：单线程监控多个 I/O 事件，仅处理就绪的描述符。
        <ul>
         <li>
          <strong>
           优势
          </strong>
          ：适合高并发网络服务（如 Web 服务器）。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <strong>
        策略 2：批量处理 I/O
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         缓冲（Buffering）
        </strong>
        ：累积多个小数据包后一次性处理，减少系统调用次数。
        <ul>
         <li>
          <strong>
           示例
          </strong>
          ：TCP 协议的 Nagle 算法合并小数据包。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <strong>
        策略 3：异步化与并行化
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         异步 I/O（如
         <code>
          io_uring
         </code>
         ）
        </strong>
        ：内核全程处理 I/O，完成后通知进程。
       </li>
       <li>
        <strong>
         多线程/进程
        </strong>
        ：为每个连接分配独立执行单元（但需权衡上下文切换开销）
       </li>
      </ul>
      <p>
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          由于 IO 大部分时间花在了 等待上，因此高效的 IO 本质：单位时间内，等待的比重越低， IO 效率越高 
         
        
       
      
        \colorbox{cyan}{由于 IO 大部分时间花在了 等待上，因此高效的 IO 本质：单位时间内，等待的比重越低， IO 效率越高}
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1.2833em; vertical-align: -0.3em;">
           </span>
           <span class="mord">
            <span class="vlist-t vlist-t2">
             <span class="vlist-r">
              <span class="vlist" style="height: 0.9833em;">
               <span class="" style="top: -2.9833em;">
                <span class="pstrut" style="height: 3.2833em;">
                </span>
                <span class="stretchy colorbox" style="height: 1.2833em; background-color: cyan;">
                </span>
               </span>
               <span class="" style="top: -3.2833em;">
                <span class="pstrut" style="height: 3.2833em;">
                </span>
                <span class="mord boxpad">
                 <span class="mord cjk_fallback">
                  由于
                 </span>
                 <span class="mord">
                  IO
                 </span>
                 <span class="mord cjk_fallback">
                  大部分时间花在了
                 </span>
                 <span class="mord">
                 </span>
                 <span class="mord cjk_fallback">
                  等待上，因此高效的
                 </span>
                 <span class="mord">
                  IO
                 </span>
                 <span class="mord cjk_fallback">
                  本质：单位时间内，等待的比重越低，
                 </span>
                 <span class="mord">
                  IO
                 </span>
                 <span class="mord cjk_fallback">
                  效率越高
                 </span>
                </span>
               </span>
              </span>
              <span class="vlist-s">
               ​
              </span>
             </span>
             <span class="vlist-r">
              <span class="vlist" style="height: 0.3em;">
               <span class="">
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </p>
      <h2>
       <a id="font_colorDarkOrchid__IO_font_108">
       </a>
       <font color="DarkOrchid">
        二：🔥 五种 IO 模型
       </font>
      </h2>
      <p>
       在了解相关知识之前，我们先来看个例子，方便我们对其的理解
      </p>
      <h3>
       <a id="__110">
       </a>
       🦋 生动例子：餐厅点餐
      </h3>
      <p>
       <strong>
        角色定义
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         进程
        </strong>
        ：顾客（发起 I/O 请求的主体）。
       </li>
       <li>
        <strong>
         文件描述符
        </strong>
        ：订单号（标识一个 I/O 请求）。
       </li>
       <li>
        <strong>
         数据
        </strong>
        ：顾客点的餐（需要处理的内容）。
       </li>
      </ul>
      <hr/>
      <p>
       <font color="#ff0097" size="3">
        1.1 阻塞 I/O
       </font>
      </p>
      <ul>
       <li>
        <strong>
         场景
        </strong>
        ：
        <br/>
        顾客下单后，
        <strong>
         一直坐在餐桌前等待
        </strong>
        ，直到服务员端上菜才能做其他事（如玩手机）。
       </li>
       <li>
        <strong>
         关键点
        </strong>
        ：
        <ul>
         <li>
          顾客（进程）在等待期间完全被阻塞。
         </li>
         <li>
          订单号（文件描述符）对应唯一的请求。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <font color="#ff0097" size="3">
        1.2 非阻塞 I/O
       </font>
      </p>
      <ul>
       <li>
        <strong>
         场景
        </strong>
        ：
        <br/>
        顾客下单后，
        <strong>
         每隔 5 秒去厨房问一次
        </strong>
        “我的菜好了吗？”，期间可以喝水、聊天。
       </li>
       <li>
        <strong>
         关键点
        </strong>
        ：
        <ul>
         <li>
          顾客（进程）需要主动轮询状态。
         </li>
         <li>
          若厨房（内核）回答“没好”，顾客继续做其他事。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <font color="#ff0097" size="3">
        1.3 信号驱动 I/O
       </font>
      </p>
      <ul>
       <li>
        <strong>
         场景
        </strong>
        ：
        <br/>
        顾客下单后，
        <strong>
         留下手机号
        </strong>
        给服务员，继续聊天。厨房准备好菜时，服务员
        <strong>
         打电话通知顾客
        </strong>
        取餐。
       </li>
       <li>
        <strong>
         关键点
        </strong>
        ：
        <ul>
         <li>
          数据就绪时内核（服务员）通过信号（电话）通知进程（顾客）。
         </li>
         <li>
          顾客仍需自己从厨房端走菜（同步拷贝数据）。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <font color="#ff0097" size="3">
        1.4 多路转接 I/O
       </font>
      </p>
      <ul>
       <li>
        <strong>
         场景
        </strong>
        ：
        <br/>
        顾客同时点了咖啡和蛋糕，
        <strong>
         告诉大堂经理
        </strong>
        “两样都好了叫我”。经理一直监听多个订单，任一就绪时通知顾客。
       </li>
       <li>
        <strong>
         关键点
        </strong>
        ：
        <ul>
         <li>
          一个进程（顾客）通过多路复用接口（经理）监控多个文件描述符（订单）。
         </li>
         <li>
          仍需顾客自己取餐（同步拷贝数据）。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <font color="#ff0097" size="3">
        1.5 异步 I/O
       </font>
      </p>
      <ul>
       <li>
        <strong>
         场景
        </strong>
        ：
        <br/>
        顾客下单后，继续办公。厨房准备好菜后，
        <strong>
         服务员直接将菜端到顾客桌上
        </strong>
        ，并说“您的菜齐了”。
       </li>
       <li>
        <strong>
         关键点
        </strong>
        ：
        <ul>
         <li>
          数据准备和端菜（拷贝）全程由内核（服务员）完成。
         </li>
         <li>
          顾客（进程）无需参与任何等待或操作。
         </li>
        </ul>
       </li>
      </ul>
      <hr/>
      <h3>
       <a id="___159">
       </a>
       🦋 专业术语介绍
      </h3>
      <ol>
       <li>
        <p>
         <strong>
          <font color="FF7F00">
           阻塞 I/O (Blocking I/O)
          </font>
         </strong>
        </p>
        <ul>
         <li>
          进程发起 I/O 操作后，
          <strong>
           立即进入阻塞状态
          </strong>
          ，（在内核将数据准备好之前，系统调用一直等待）直到内核将数据准备好并拷贝到用户空间后，进程才恢复执行。
         </li>
         <li>
          所有的套接字默认是阻塞方式
         </li>
         <li>
          <strong>
           同步 I/O
          </strong>
          ：进程全程需要等待数据就绪和拷贝完成。
          <br/>
          <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a43c50d651e6448da15aa1da86f03178.png"/>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          <font color="FF7F00">
           非阻塞 I/O (Non-blocking I/O)
          </font>
         </strong>
        </p>
        <ul>
         <li>
          进程发起 I/O 操作后，
          <strong>
           内核立即返回一个状态值
          </strong>
          （未就绪），进程通过
          <strong>
           轮询（Polling）
          </strong>
          反复检查数据是否就绪，期间可以执行其他任务。
         </li>
         <li>
          如果内核还未将数据准备好, 系统调用仍然会直接返回, 并且返回
          <code>
           EWOULDBLOCK
          </code>
          错误码.
         </li>
         <li>
          <strong>
           轮询
          </strong>
          ：意指程序员循环的方式反复尝试读写文件描述符。这对 CPU 来说是较大的浪费, 一般只有特定场景下才使用.
         </li>
         <li>
          <strong>
           同步 I/O
          </strong>
          ：进程需要主动检查数据状态并完成拷贝。
          <br/>
          <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bdc6e5ae985344c8905cf70675be6ead.png"/>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          <font color="FF7F00">
           信号驱动 I/O (Signal-driven I/O)
          </font>
         </strong>
        </p>
        <ul>
         <li>
          进程发起 I/O 操作后，内核在数据就绪时
          <strong>
           发送信号（如
           <code>
            SIGIO
           </code>
           ）
          </strong>
          通知进程，进程随后执行数据拷贝。
         </li>
         <li>
          <strong>
           同步 I/O
          </strong>
          ：数据拷贝阶段仍需进程主动完成。
          <br/>
          <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d3ed82c58acc4b27b7be835f416b7aae.png"/>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          <font color="FF7F00">
           多路转接 I/O (Multiplexing I/O)
          </font>
         </strong>
        </p>
        <ul>
         <li>
          进程通过
          <code>
           select
          </code>
          、
          <code>
           poll
          </code>
          或
          <code>
           epoll
          </code>
          <strong>
           <font color="red">
            同时监控多个文件描述符
           </font>
          </strong>
          ，当任一描述符数据就绪时，内核通知进程进行处理。
         </li>
         <li>
          <strong>
           同步 I/O
          </strong>
          ：数据就绪后仍需进程主动拷贝数据。
         </li>
        </ul>
       </li>
      </ol>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8ac0b0c8437b468983c9f9eb0cdb4dd2.png"/>
      </p>
      <p>
       虽然从流程图上看起来和阻塞 IO 类似实际上最核心在于 IO 多路转接 能够同时等待多个文件描述符的就绪状态.
      </p>
      <ol start="5">
       <li>
        <strong>
         <font color="FF7F00">
          异步 I/O (Asynchronous I/O)
         </font>
        </strong>
        <ul>
         <li>
          进程发起 I/O 操作后，内核
          <strong>
           <font color="red">
            全程负责数据准备和拷贝
           </font>
          </strong>
          ，完成后通过回调（如信号或回调函数）通知进程。
         </li>
         <li>
          <strong>
           异步 I/O
          </strong>
          ：
          <mark>
           进程无需参与数据准备或拷贝
          </mark>
          。
         </li>
        </ul>
       </li>
      </ol>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6b24989c01354f479502faba63e7645c.png"/>
      </p>
      <hr/>
      <h3>
       <a id="___202">
       </a>
       🦋 总结表
      </h3>
      <ul>
       <li>
        <strong>
         同步 I/O
        </strong>
        ：
        <ul>
         <li>
          <strong>
           阻塞 I/O
          </strong>
          、
          <strong>
           非阻塞 I/O
          </strong>
          、
          <strong>
           信号驱动 I/O
          </strong>
          、
          <strong>
           多路转接 I/O
          </strong>
          。
         </li>
         <li>
          共同点：
          <strong>
           数据拷贝阶段需进程主动完成
          </strong>
          （即使通过信号或轮询触发）。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         异步 I/O
        </strong>
        ：
        <ul>
         <li>
          数据准备和拷贝全程由内核处理，进程无需参与。
         </li>
        </ul>
       </li>
      </ul>
      <table>
       <thead>
        <tr>
         <th align="left">
          I/O 模型
         </th>
         <th align="left">
          同步/异步
         </th>
         <th align="left">
          例子类比
         </th>
         <th align="left">
          进程角色
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td align="left">
          阻塞 I/O
         </td>
         <td align="left">
          同步
         </td>
         <td align="left">
          干等上菜
         </td>
         <td align="left">
          全程阻塞
         </td>
        </tr>
        <tr>
         <td align="left">
          非阻塞 I/O
         </td>
         <td align="left">
          同步
         </td>
         <td align="left">
          轮询询问厨房
         </td>
         <td align="left">
          主动轮询
         </td>
        </tr>
        <tr>
         <td align="left">
          信号驱动 I/O
         </td>
         <td align="left">
          同步
         </td>
         <td align="left">
          电话通知取餐
         </td>
         <td align="left">
          被动响应信号
         </td>
        </tr>
        <tr>
         <td align="left">
          多路转接 I/O
         </td>
         <td align="left">
          同步
         </td>
         <td align="left">
          经理监听多个订单
         </td>
         <td align="left">
          批量监听
         </td>
        </tr>
        <tr>
         <td align="left">
          异步 I/O
         </td>
         <td align="left">
          异步
         </td>
         <td align="left">
          服务员直接端菜到桌
         </td>
         <td align="left">
          完全无需参与
         </td>
        </tr>
       </tbody>
      </table>
      <h2>
       <a id="font_colorDarkOrchid_font_218">
       </a>
       <font color="DarkOrchid">
        三：🔥 思考
       </font>
      </h2>
      <h3>
       <a id="__vs__219">
       </a>
       🦋 阻塞 vs 非阻塞，非阻塞效率效率一定高吗?
      </h3>
      <p>
       <strong>
        答案：
       </strong>
       <br/>
       <strong>
        不一定
       </strong>
       ，非阻塞 I/O 的效率取决于具体场景。
      </p>
      <ul>
       <li>
        <strong>
         非阻塞 I/O 的优势
        </strong>
        ：
        <br/>
        进程在等待数据就绪期间可以执行其他任务（避免完全阻塞），适合需要同时处理多任务的场景。
        <br/>
        <strong>
         例子
        </strong>
        ：餐厅顾客边等餐边聊天（非阻塞）比干等的顾客（阻塞）更高效。
       </li>
       <li>
        <strong>
         非阻塞 I/O 的劣势
        </strong>
        ：
        <br/>
        如果频繁轮询（如每秒检查 1000 次），会导致
        <strong>
         CPU 资源浪费
        </strong>
        ，甚至比阻塞 I/O 效率更低。
        <br/>
        <strong>
         例子
        </strong>
        ：顾客每隔 1 秒就去厨房问一次，导致自己无法专心聊天，服务员也被频繁打扰。
       </li>
      </ul>
      <p>
       <strong>
        结论
       </strong>
       ：
      </p>
      <ul>
       <li>
        <strong>
         低并发场景
        </strong>
        ：阻塞 I/O 更简单高效（避免轮询开销）。
       </li>
       <li>
        <strong>
         高并发场景
        </strong>
        ：非阻塞 I/O + 多路复用（如
        <code>
         epoll
        </code>
        ）效率更高（避免大量线程阻塞）
       </li>
      </ul>
      <h3>
       <a id="___IO__234">
       </a>
       🦋 五种模型中，谁的 I/O 效率最高？
      </h3>
      <p>
       <strong>
        答案：
       </strong>
       <br/>
       <strong>
        异步 I/O（如 Linux 的
        <code>
         io_uring
        </code>
        ）理论效率最高
       </strong>
       ，但实际中
       <strong>
        多路复用 I/O（如
        <code>
         epoll
        </code>
        ）
       </strong>
       在同步模型中更常用。
      </p>
      <ul>
       <li>
        <strong>
         异步 I/O
        </strong>
        ：
        <ul>
         <li>
          <strong>
           优势
          </strong>
          ：内核全程处理数据准备和拷贝，进程完全无需等待（服务员直接端菜到桌）。
         </li>
         <li>
          <strong>
           限制
          </strong>
          ：依赖操作系统和硬件的支持（如 Linux 的异步 I/O 实现复杂）。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         多路复用 I/O（
         <code>
          epoll
         </code>
         ）
        </strong>
        ：
        <ul>
         <li>
          <strong>
           优势
          </strong>
          ：单线程监控大量文件描述符，避免进程/线程频繁切换（大堂经理统一管理订单）。
         </li>
         <li>
          <strong>
           场景
          </strong>
          ：高并发网络服务器（如 Nginx、Redis）的核心模型。
         </li>
        </ul>
       </li>
      </ul>
      <p>
       <strong>
        总结
       </strong>
       ：
      </p>
      <ul>
       <li>
        异步 I/O 理论最优，但实际中多路复用 I/O 因兼容性和成熟度更常用
       </li>
       <li>
        异步 I/O 的高效主要和其特点无关，还是得依靠程序员自己，而多路复用 I/O 可以用于处理大批网络数据，降低了等的比重
       </li>
      </ul>
      <p>
       <font color="red">
        因此总的来说，我们更认为 多路复用的 I/O 效率更高
       </font>
      </p>
      <h3>
       <a id="___vs__252">
       </a>
       🦋 同步通信 vs 异步通信
      </h3>
      <p>
       同步 和 异步 关注的是消息通信机制.
      </p>
      <ul>
       <li>
        所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回. 但是一旦调用返回，就得到返回值了;
        <ul>
         <li>
          换句话说，就是由调用者主动等待这个调用的结果;
         </li>
        </ul>
       </li>
       <li>
        异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果;
        <ul>
         <li>
          换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果; 而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用.
         </li>
        </ul>
       </li>
      </ul>
      <p>
       另外：之前我们在讲
       <strong>
        多进程多线程
       </strong>
       的时候，也提到同步和互斥。
       <br/>
       注意：这里的同步通信和进程之间的同步是完全不相干的概念.
      </p>
      <ul>
       <li>
        <strong>
         进程/线程同步
        </strong>
        也是进程/线程之间直接的制约关系
       </li>
       <li>
        是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调
        <br/>
        他们的工作次序而等待、传递信息所产生的制约关系。尤其是在访问临界资源的时候.
       </li>
      </ul>
      <p>
       因此以后在看到 “同步” 这个词，一定要先搞清楚大背景是什么。这个同步是同步通信异步通信的同步, 还是同步与互斥的同步
      </p>
      <h2>
       <a id="font_colorDarkOrchid__IOfont_267">
       </a>
       <font color="DarkOrchid">
        四：🔥 非阻塞 IO
       </font>
      </h2>
      <h3>
       <a id="_fcntl_268">
       </a>
       🦋 fcntl
      </h3>
      <p>
       一个文件描述符, 默认都是阻塞 IO.
      </p>
      <p>
       函数原型如下.
      </p>
      <pre><code class="prism language-cpp">NAME
       fcntl <span class="token operator">-</span> manipulate file descriptor

SYNOPSIS
       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

       <span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* arg */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
      <p>
       <mark>
        cmd 是命令，是要操作的类型。主要的操作类型有：
       </mark>
      </p>
      <ul>
       <li>
        <strong>
         获取，设置文件状态信息：cmd=F_GETFL，F_SETFL。
        </strong>
       </li>
       <li>
        <strong>
         复制现有的描述符，cmd=F_DUPFD。
        </strong>
       </li>
       <li>
        <span class="katex--inline">
         <span class="katex">
          <span class="katex-mathml">
           获取，设置文件描述符标识, ，cmd=F_GETFD，F_SETFD  
          
         
        
       
         \colorbox{pink}{ 获取，设置文件描述符标识, ，cmd=F\_GETFD，F\_SETFD }
          </span>
          <span class="katex-html">
           <span class="base">
            <span class="strut" style="height: 1.6044em; vertical-align: -0.61em;">
            </span>
            <span class="mord">
             <span class="vlist-t vlist-t2">
              <span class="vlist-r">
               <span class="vlist" style="height: 0.9944em;">
                <span class="" style="top: -2.9944em;">
                 <span class="pstrut" style="height: 3.6044em;">
                 </span>
                 <span class="stretchy colorbox" style="height: 1.6044em; background-color: pink;">
                 </span>
                </span>
                <span class="" style="top: -3.6044em;">
                 <span class="pstrut" style="height: 3.6044em;">
                 </span>
                 <span class="mord boxpad">
                  <span class="mord">
                  </span>
                  <span class="mord cjk_fallback">
                   获取，设置文件描述符标识
                  </span>
                  <span class="mord">
                   ,
                  </span>
                  <span class="mord cjk_fallback">
                   ，
                  </span>
                  <span class="mord">
                   cmd=F_GETFD
                  </span>
                  <span class="mord cjk_fallback">
                   ，
                  </span>
                  <span class="mord">
                   F_SETFD
                  </span>
                 </span>
                </span>
               </span>
               <span class="vlist-s">
                ​
               </span>
              </span>
              <span class="vlist-r">
               <span class="vlist" style="height: 0.61em;">
                <span class="">
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </li>
       <li>
        <strong>
         获取，设置异步IO所有权，cmd=F_GETOWN，F_SETOWN。
        </strong>
       </li>
       <li>
        <strong>
         获取、设置记录锁，cmd=F_GETLK，F_SETLK，F_SETLKW。
        </strong>
       </li>
      </ul>
      <p>
       <strong>
        🧊
        <font color="A020F0">
         我们此处只是用第三种功能,
         <code>
          获取/设置文件状态标记
         </code>
         , 就可以将一个文件描述符设置为非阻塞. 文件状态标志包括
         <code>
          O_APPEND
         </code>
         、
         <code>
          O_NONBLOCK
         </code>
         。
        </font>
       </strong>
      </p>
      <h3>
       <a id="__SetNonBlock_295">
       </a>
       🦋 实现函数 SetNonBlock
      </h3>
      <p>
       ⚙️ 基于
       <code>
        fcntl
       </code>
       , 我们实现一个
       <code>
        SetNoBlock
       </code>
       函数, 将文件描述符设置为非阻塞.
      </p>
      <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token comment">// 让文件描述符非阻塞</span>
<span class="token keyword">void</span> <span class="token function">SetNonBlock</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>f1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fcntl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> f1 <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//  O_NONBLOCK 让fd 以非阻塞的方式进行工作</span>
<span class="token punctuation">}</span>
</code></pre>
      <blockquote>
       <ul>
        <li>
         <strong>
          <font color="viole">
           使用 F_GETFL 将当前的文件描述符的属性取出来 (这是一个位图).
          </font>
         </strong>
        </li>
        <li>
         <strong>
          <font color="viole">
           然后再使用 F_SETFL 将文件描述符设置回去. 设置回去的同时, 加上一个 O_NONBLOCK 参数.
          </font>
         </strong>
        </li>
       </ul>
      </blockquote>
      <h3>
       <a id="__317">
       </a>
       🦋 非阻塞方式读取标准输入
      </h3>
      <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cerrno&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token comment">// 让文件描述符非阻塞</span>
<span class="token keyword">void</span> <span class="token function">SetNonBlock</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>f1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fcntl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> f1 <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//  O_NONBLOCK 让fd 以非阻塞的方式进行工作</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>string tips <span class="token operator">=</span> <span class="token string">"Please Enter# "</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">SetNonBlock</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tips<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tips<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 非阻塞，如果我们不做输入，数据不就绪，以出错形式返回！！</span>
        <span class="token comment">// read 不是有读取失败(-1)吗？失败vs底层数据没就绪 -&gt; 底层数据没就绪，不算失败</span>
        <span class="token comment">// 如果是 -1， 失败vs底层数据没就绪我们后续的做法是不同的！</span>
        <span class="token comment">// read -&gt; -1, 失败vs底层数据没就绪 -&gt; 需要区分的必要性的！</span>
        <span class="token comment">// errno 表示：更详细的出错原因, 最近一次调用，出错的时候的出错码</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"echo# "</span> <span class="token operator">&lt;&lt;</span> buffer <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"read file end"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// EAGAIN		11	/* Try again */</span>
            <span class="token comment">// EWOULDBLOCK	EAGAIN	/* Operation would block */</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 做其他事情呢？</span>

                std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"底层数据，没有就绪"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"被中断, 重新来"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{<!-- --></span>
                std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"read error: "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">", errno: "</span> <span class="token operator">&lt;&lt;</span> errno <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <h2>
       <a id="font_colorDarkOrchid__font_396">
       </a>
       <font color="DarkOrchid">
        五：🔥 共勉
       </font>
      </h2>
      <p>
       😋 以上就是我对
       <strong>
        <code>
         【Linux】五种 IO 模型与阻塞 IO
        </code>
       </strong>
       的理解, 觉得这篇博客对你有帮助的，可以点赞收藏关注支持一波~ 😉
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1c9d1ff0140a4e5685ff162c69851475.gif"/>
      </p>
     </img>
    </img>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35303737363432302f:61727469636c652f64657461696c732f313436323433313732" class_="artid" style="display:none">
 </p>
</div>


