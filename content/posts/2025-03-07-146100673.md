---
layout: post
title: "Java虚拟机之垃圾收集一"
date: 2025-03-07 17:37:05 +0800
description: "每个对象维护一个引用计数器，被引用时计数器 +1，引用失效时 -1。：频繁 Full GC 会导致应用停顿（Stop-The-World），需谨慎使用。垃圾收集（GC）的核心是识别无用对象。无法解决循环引用问题（如对象 A 引用 B，B 也引用 A）。本地方法栈中 JNI 引用的对象（Native 方法）。Java 虚拟机内部对象（如系统类加载器、异常对象）。（STW）：标记 GC Roots 直接关联对象。（STW）：标记 GC Roots 直接关联对象。：熬过多次 GC 的对象难以消亡（老年代）。"
keywords: "java 垃圾回收 参数"
categories: ['未分类']
tags: ['开发语言', 'Jvm', 'Java']
artid: "146100673"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146100673
    alt: "Java虚拟机之垃圾收集一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146100673
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146100673
cover: https://bing.ee123.net/img/rand?artid=146100673
image: https://bing.ee123.net/img/rand?artid=146100673
img: https://bing.ee123.net/img/rand?artid=146100673
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java虚拟机之垃圾收集（一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E2%80%9C%E7%94%9F%E6%AD%BB%E2%80%9D%EF%BC%9F" name="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E2%80%9C%E7%94%9F%E6%AD%BB%E2%80%9D%EF%BC%9F">
     <strong>
      一、如何判定对象“生死”？
     </strong>
    </h2>
    <p>
     垃圾收集（GC）的核心是识别无用对象。JVM 通过两种算法判断对象是否存活：
    </p>
    <h3 id="1.%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%EF%BC%88%E7%90%86%E8%AE%BA%E5%8F%82%E8%80%83%EF%BC%89" name="1.%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%EF%BC%88%E7%90%86%E8%AE%BA%E5%8F%82%E8%80%83%EF%BC%89">
     <strong>
      1. 引用计数算法（理论参考）
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        原理
       </strong>
       ：
       <br/>
       每个对象维护一个引用计数器，被引用时计数器 +1，引用失效时 -1。计数器为 0 时判定为可回收。
      </p>
     </li>
     <li>
      <p>
       <strong>
        缺点
       </strong>
       ：
       <br/>
       无法解决循环引用问题（如对象 A 引用 B，B 也引用 A）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Java 未采用
       </strong>
       ：主流 JVM 均使用
       <strong>
        可达性分析算法
       </strong>
       。
      </p>
     </li>
    </ul>
    <h3 id="2.%20%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88JVM%20%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%EF%BC%89" name="2.%20%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88JVM%20%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%EF%BC%89">
     <strong>
      2. 可达性分析算法（JVM 实际使用）
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        原理
       </strong>
       ：
       <br/>
       从
       <strong>
        GC Roots
       </strong>
       出发，遍历对象引用链。若对象无法被 GC Roots 关联，则判定为可回收。
      </p>
     </li>
     <li>
      <p>
       <strong>
        GC Roots 对象类型
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         虚拟机栈中的局部变量（如方法参数、局部变量）。
        </p>
       </li>
       <li>
        <p>
         方法区中静态变量引用的对象。
        </p>
       </li>
       <li>
        <p>
         方法区中常量引用的对象（如字符串常量池）。
        </p>
       </li>
       <li>
        <p>
         本地方法栈中 JNI 引用的对象（Native 方法）。
        </p>
       </li>
       <li>
        <p>
         同步锁持有的对象（
         <code>
          synchronized
         </code>
         锁对象）。
        </p>
       </li>
       <li>
        <p>
         Java 虚拟机内部对象（如系统类加载器、异常对象）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="3.%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9C%E7%BC%93%E5%88%91%E2%80%9D%E6%9C%BA%E5%88%B6" name="3.%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9C%E7%BC%93%E5%88%91%E2%80%9D%E6%9C%BA%E5%88%B6">
     <strong>
      3. 对象的“缓刑”机制
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         finalize()
        </code>
        方法
       </strong>
       ：
       <br/>
       若对象重写
       <code>
        finalize()
       </code>
       且未被调用过，JVM 会将其放入
       <code>
        F-Queue
       </code>
       ，由 Finalizer 线程触发该方法。
      </p>
     </li>
     <li>
      <p>
       <strong>
        逃脱机会
       </strong>
       ：
       <br/>
       在
       <code>
        finalize()
       </code>
       中重新建立与 GC Roots 的引用链，可避免被回收（
       <strong>
        仅一次
       </strong>
       ）。
      </p>
     </li>
    </ul>
    <pre><code class="language-java">public class RescueObject {
    public static RescueObject hook;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        hook = this; // 在 finalize 中自我拯救
    }
}</code></pre>
    <hr/>
    <h2 id="%E4%BA%8C%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" name="%E4%BA%8C%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">
     <strong>
      二、引用类型与回收策略
     </strong>
    </h2>
    <p>
     Java 提供
     <strong>
      四种引用类型
     </strong>
     ，控制对象生命周期与回收优先级：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         引用类型
        </strong>
       </th>
       <th>
        <strong>
         特点
        </strong>
       </th>
       <th>
        <strong>
         回收时机
        </strong>
       </th>
       <th>
        <strong>
         典型场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         强引用
        </strong>
       </td>
       <td>
        <code>
         Object obj = new Object()
        </code>
        ，默认引用类型
       </td>
       <td>
        对象不可达时回收
       </td>
       <td>
        普通对象创建
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         软引用
        </strong>
       </td>
       <td>
        <code>
         SoftReference&lt;Object&gt; ref = new SoftReference&lt;&gt;(obj)
        </code>
       </td>
       <td>
        内存不足时回收（OOM 前触发）
       </td>
       <td>
        缓存（如图片缓存）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         弱引用
        </strong>
       </td>
       <td>
        <code>
         WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(obj)
        </code>
       </td>
       <td>
        下一次 GC 时回收
       </td>
       <td>
        临时缓存（如 WeakHashMap）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         虚引用
        </strong>
       </td>
       <td>
        <code>
         PhantomReference&lt;Object&gt; ref = new PhantomReference&lt;&gt;(obj, queue)
        </code>
       </td>
       <td>
        随时可能回收，需配合 ReferenceQueue 使用
       </td>
       <td>
        堆外内存回收监听（如 DirectByteBuffer）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h2 id="%E4%B8%89%E3%80%81%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F" name="%E4%B8%89%E3%80%81%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F">
     <strong>
      三、何时触发垃圾回收？
     </strong>
    </h2>
    <p>
     GC 触发时机由
     <strong>
      内存区域分配策略
     </strong>
     和
     <strong>
      JVM 配置参数
     </strong>
     共同决定：
    </p>
    <h3 id="1.%20%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" name="1.%20%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">
     <strong>
      1. 分代回收策略
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         区域
        </strong>
       </th>
       <th>
        <strong>
         GC 类型
        </strong>
       </th>
       <th>
        <strong>
         触发条件
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        新生代
       </td>
       <td>
        <strong>
         Minor GC
        </strong>
       </td>
       <td>
        Eden 区空间不足
       </td>
      </tr>
      <tr>
       <td>
        老年代
       </td>
       <td>
        <strong>
         Major GC
        </strong>
       </td>
       <td>
        老年代空间不足（通常伴随 Full GC）
       </td>
      </tr>
      <tr>
       <td>
        整堆
       </td>
       <td>
        <strong>
         Full GC
        </strong>
       </td>
       <td>
        方法区不足、老年代空间不足、手动调用
        <code>
         System.gc()
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="2.%20%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="2.%20%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
     <strong>
      2. 手动触发与注意事项
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         System.gc()
        </code>
       </strong>
       ：建议 JVM 触发 Full GC（
       <strong>
        不保证立即执行
       </strong>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        风险
       </strong>
       ：频繁 Full GC 会导致应用停顿（Stop-The-World），需谨慎使用。
      </p>
     </li>
    </ul>
    <hr/>
    <h2 id="%E5%9B%9B%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0" name="%E5%9B%9B%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0">
     <strong>
      四、垃圾回收算法与实现
     </strong>
    </h2>
    <h3 id="1.%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94" name="1.%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94">
     <strong>
      1. 基础算法对比
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         算法
        </strong>
       </th>
       <th>
        <strong>
         步骤
        </strong>
       </th>
       <th>
        <strong>
         优点
        </strong>
       </th>
       <th>
        <strong>
         缺点
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         标记-清除
        </strong>
       </td>
       <td>
        标记存活对象 → 清除未标记对象
       </td>
       <td>
        简单
       </td>
       <td>
        内存碎片化
       </td>
       <td>
        老年代（CMS）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         复制算法
        </strong>
       </td>
       <td>
        存活对象复制到新区域 → 清空原区域
       </td>
       <td>
        无碎片，高效
       </td>
       <td>
        内存利用率 50%
       </td>
       <td>
        新生代（Survivor）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         标记-整理
        </strong>
       </td>
       <td>
        标记存活对象 → 整理到内存一端
       </td>
       <td>
        无碎片化
       </td>
       <td>
        整理耗时
       </td>
       <td>
        老年代（Serial Old）
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="2.%20%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA" name="2.%20%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA">
     <strong>
      2. 分代收集理论
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        弱分代假说
       </strong>
       ：绝大多数对象朝生夕灭（新生代）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        强分代假说
       </strong>
       ：熬过多次 GC 的对象难以消亡（老年代）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        分代设计
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          新生代
         </strong>
         ：使用复制算法（Eden + Survivor）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          老年代
         </strong>
         ：使用标记-清除或标记-整理算法。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="3.%20%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%9AApple%E5%BC%8F%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95" name="3.%20%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%9AApple%E5%BC%8F%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">
     <strong>
      3. 新生代回收：Apple式复制算法
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        内存划分
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Eden : Survivor1 : Survivor2 = 8:1:1（默认）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        回收流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         新对象分配至 Eden 区。
        </p>
       </li>
       <li>
        <p>
         Eden 满时触发 Minor GC，存活对象复制到 Survivor1。
        </p>
       </li>
       <li>
        <p>
         下次 Minor GC 时，Eden 和 Survivor1 存活对象复制到 Survivor2，并清空原区域。
        </p>
       </li>
       <li>
        <p>
         对象年龄达到阈值（默认 15）后晋升老年代。
        </p>
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h2 id="%E4%BA%94%E3%80%81%E4%B8%BB%E6%B5%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3" name="%E4%BA%94%E3%80%81%E4%B8%BB%E6%B5%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3">
     <strong>
      五、主流垃圾收集器详解
     </strong>
    </h2>
    <h3 id="1.%20CMS%20%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%BD%8E%E5%81%9C%E9%A1%BF%E4%BC%98%E5%85%88%EF%BC%89" name="1.%20CMS%20%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%BD%8E%E5%81%9C%E9%A1%BF%E4%BC%98%E5%85%88%EF%BC%89">
     <strong>
      1. CMS 收集器（低停顿优先）
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        目标
       </strong>
       ：最小化应用停顿时间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        算法
       </strong>
       ：标记-清除。
      </p>
     </li>
     <li>
      <p>
       <strong>
        工作流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         <strong>
          初始标记
         </strong>
         （STW）：标记 GC Roots 直接关联对象。
        </p>
       </li>
       <li>
        <p>
         <strong>
          并发标记
         </strong>
         ：遍历对象图（与用户线程并发）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          重新标记
         </strong>
         （STW）：修正并发标记期间变动的引用。
        </p>
       </li>
       <li>
        <p>
         <strong>
          并发清除
         </strong>
         ：清理垃圾（与用户线程并发）。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         内存碎片化（需定期 Full GC 整理）。
        </p>
       </li>
       <li>
        <p>
         并发阶段占用 CPU 资源。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="2.%20G1%20%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%B9%B3%E8%A1%A1%E5%90%9E%E5%90%90%E4%B8%8E%E5%BB%B6%E8%BF%9F%EF%BC%89" name="2.%20G1%20%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%B9%B3%E8%A1%A1%E5%90%9E%E5%90%90%E4%B8%8E%E5%BB%B6%E8%BF%9F%EF%BC%89">
     <strong>
      2. G1 收集器（平衡吞吐与延迟）
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        目标
       </strong>
       ：可预测的停顿时间（如 200ms 内）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        内存布局
       </strong>
       ：将堆划分为多个 Region（默认 2048 个）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        工作流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         <strong>
          初始标记
         </strong>
         （STW）：标记 GC Roots 直接关联对象。
        </p>
       </li>
       <li>
        <p>
         <strong>
          并发标记
         </strong>
         ：遍历对象图（与用户线程并发）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          最终标记
         </strong>
         （STW）：处理剩余引用变更。
        </p>
       </li>
       <li>
        <p>
         <strong>
          筛选回收
         </strong>
         （STW）：选择性价比高的 Region 回收。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        优势
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         支持大内存（TB 级）。
        </p>
       </li>
       <li>
        <p>
         通过 Region 划分减少碎片化。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="3.%20%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94" name="3.%20%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94">
     <strong>
      3. 收集器对比
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         收集器
        </strong>
       </th>
       <th>
        <strong>
         算法
        </strong>
       </th>
       <th>
        <strong>
         区域
        </strong>
       </th>
       <th>
        <strong>
         特点
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        CMS
       </td>
       <td>
        标记-清除
       </td>
       <td>
        老年代
       </td>
       <td>
        低停顿，但碎片化严重
       </td>
       <td>
        响应敏感型应用
       </td>
      </tr>
      <tr>
       <td>
        G1
       </td>
       <td>
        标记-整理
       </td>
       <td>
        全堆
       </td>
       <td>
        可预测停顿，兼顾吞吐与延迟
       </td>
       <td>
        大内存、低延迟应用
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h2 id="%E5%85%AD%E3%80%81%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90" name="%E5%85%AD%E3%80%81%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90">
     <strong>
      六、调优建议与工具推荐
     </strong>
    </h2>
    <h3 id="1.%20%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B" name="1.%20%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B">
     <strong>
      1. 参数配置示例
     </strong>
    </h3>
    <pre><code class="language-bash"># 使用 G1 收集器，堆内存 4G，目标停顿 200ms
java -Xmx4G -Xms4G -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar app.jar

# 启用 CMS 收集器
-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode</code></pre>
    <h3 id="2.%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5" name="2.%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5">
     <strong>
      2. 常见问题排查
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        频繁 Full GC
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         检查内存泄漏（如静态集合未清理）。
        </p>
       </li>
       <li>
        <p>
         调整新生代与老年代比例（
         <code>
          -XX:NewRatio
         </code>
         ）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        长时间 STW
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         切换低延迟收集器（如 G1/ZGC）。
        </p>
       </li>
       <li>
        <p>
         减少堆内存大小（权衡吞吐与停顿）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="3.%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90" name="3.%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90">
     <strong>
      3. 工具推荐
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        监控工具
       </strong>
       ：VisualVM、JConsole、Prometheus + Grafana。
      </p>
     </li>
     <li>
      <p>
       <strong>
        日志分析
       </strong>
       ：GCeasy、GCViewer。
      </p>
     </li>
     <li>
      <p>
       <strong>
        诊断工具
       </strong>
       ：Arthas、MAT（Memory Analyzer Tool）。
      </p>
     </li>
    </ul>
    <hr/>
    <h2 id="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93" name="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93">
     <strong>
      七、总结
     </strong>
    </h2>
    <ul>
     <li>
      <p>
       <strong>
        生死判定
       </strong>
       ：可达性分析是核心，
       <code>
        finalize()
       </code>
       是最后的逃生机会。
      </p>
     </li>
     <li>
      <p>
       <strong>
        引用分级
       </strong>
       ：软、弱引用优化内存敏感场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        算法选择
       </strong>
       ：分代理论平衡效率与资源利用率。
      </p>
     </li>
     <li>
      <p>
       <strong>
        收集器选型
       </strong>
       ：CMS 适合低延迟，G1 适合大内存与可预测停顿。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      核心原则
     </strong>
     ：结合业务需求与监控数据动态调优，避免盲目配置。
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f4a6f754a7a2f:61727469636c652f64657461696c732f313436313030363733" class_="artid" style="display:none">
 </p>
</div>


