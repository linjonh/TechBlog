---
layout: post
title: "ROS基础,话题通信模式以及自定义话题消息编程案例服务通信模式,分布式通信"
date: 2024-04-01 09:21:53 +0800
description: "ROS通信机制(1)节点(Node)-软件模块(2)节点管理器( ROS Master)ーー控制中心"
keywords: "话题模型与通讯模型的区别"
categories: ['Ros']
tags: ['Ros', 'Ros', 'Ros', 'Ros']
artid: "106183819"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=106183819
    alt: "ROS基础,话题通信模式以及自定义话题消息编程案例服务通信模式,分布式通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=106183819
featuredImagePreview: https://bing.ee123.net/img/rand?artid=106183819
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ROS基础，话题通信模式以及自定义话题消息编程案例、服务通信模式，分布式通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="1.ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;">
     <a href="#1.ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6" rel="nofollow">
      1.ROS通信机制
     </a>
    </p>
    <p id="1.1%20ROS%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F--%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;">
     <a href="#1.1%20ROS%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F--%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B" rel="nofollow">
      1.1 ROS通信模式--话题通信模型
     </a>
    </p>
    <p id="%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;">
     <a href="#%E5%AE%9E%E4%BE%8B" rel="nofollow">
      实例：通过话题模式通信
     </a>
    </p>
    <p id="1.1.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF-toc" style="margin-left:80px;">
     <a href="#1.1.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF" rel="nofollow">
      1.1.1 自定义话题消息
     </a>
    </p>
    <p id="1.2%20ROS%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F--%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;">
     <a href="#1.2%20ROS%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F--%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B" rel="nofollow">
      1.2 ROS通信模式--服务通信模型
     </a>
    </p>
    <p id="%E5%AE%9E%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;">
     <a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1" rel="nofollow">
      实例：通过服务模式进行通信
     </a>
    </p>
    <p id="1.3%20%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;">
     <a href="#1.3%20%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">
      1.3 话题通信模型与服务通信模式的区别
     </a>
    </p>
    <p id="1.4%20ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-%E5%8A%A8%E4%BD%9C-toc" style="margin-left:80px;">
     <a href="#1.4%20ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-%E5%8A%A8%E4%BD%9C" rel="nofollow">
      1.4 ROS通信机制-动作
     </a>
    </p>
    <p id="%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;">
     <a href="#%E7%A4%BA%E4%BE%8B" rel="nofollow">
      实例：经典案例洗盘子
     </a>
    </p>
    <p id="1.5%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;">
     <a href="#1.5%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1" rel="nofollow">
      1.5 分布式通信
     </a>
    </p>
    <p style="margin-left:80px;">
    </p>
    <h3 id="1.ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">
     1.ROS通信机制
    </h3>
    <p>
     (1)节点(Node)-软件模块
     <br/>
     (2)节点管理器( ROS Master)ーー控制中心,提供参数管理
     <br/>
     (3)话题( Topic)一一异步通信机制,传输消息( Message)
     <br/>
     (4)服务( Service)-ー同步通信机制,传输请求/应答数据
     <br/>
     <img alt="" height="308" src="https://i-blog.csdnimg.cn/blog_migrate/bc6fa967ae0cba5ffd41356513db1da3.png" width="892"/>
    </p>
    <h4 id="1.1%20ROS%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F--%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B">
     1.1 ROS通信模式--话题通信模型
    </h4>
    <p>
     <strong>
      流畅梳理：
     </strong>
    </p>
    <ul>
     <li>
      &gt; Talker注册（又叫发布者，说话一方）
     </li>
     <li>
      &gt; Listener注册（又叫订阅者，听话的一方）
     </li>
     <li>
      &gt; ROS Master进行信息匹配
     </li>
     <li>
      &gt; Listener发送连接请求
     </li>
     <li>
      &gt; Talker确认连接请求
     </li>
     <li>
      &gt; 建立网络连接
     </li>
     <li>
      &gt; Talkerl向 Listener发布数据
     </li>
    </ul>
    <p>
     无论是Listener还是Talker，都不能直接进行通信，需由ROS Master代发。Listener向ROS Master询问（专业点称作订阅 subscribe）叫bar的话题（topic），若存在发布该话题的Talker，ROS Master响应给Listener，Listener与Talker建立TCP连接并通信。
    </p>
    <p style="text-align:center;">
     <img alt="" height="639" src="https://i-blog.csdnimg.cn/blog_migrate/9f32448cd0727c0fcc7d9492cbdbe268.png" width="792"/>
    </p>
    <p>
     <strong>
      备注
     </strong>
     ：
    </p>
    <p>
     RPC是远程过程调用（Remote Procedure Call）的缩写形式，支持异构型分布式系统间的通讯
    </p>
    <p>
     TCP是传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
    </p>
    <h4 id="%E5%AE%9E%E4%BE%8B">
     实例：通过话题模式通信
    </h4>
    <p>
     下面通过一个小的实例来理解topic通信
    </p>
    <p>
     <strong>
      1）创建工作空间与功能包
     </strong>
    </p>
    <p>
     注意source的时候要看看当前的shell默认解释器是什么，通过echo $SHELL查看，我用的是zsh
    </p>
    <pre><code class="language-bash">$ source /opt/ros/kinetic/setup.zsh
$ mkdir -p ~/catkin_ws/src
$ cd ~/catkin_ws/src
$ catkin_init_workspace
$ cd ~/catkin_ws
$ catkin_make 
$ souce ~/catkiin_ws/devel/setup.zsh
$ cd ~/catkin_ws/src
$ catkin_create_pkg test1 rospy roscpp
$ cd ~/catkin_ws
$ catkin_make
$ source devel/setup.zsh</code></pre>
    <p>
     <strong>
      2）创建  Listener 和 Talker
     </strong>
    </p>
    <p>
     <strong>
      Listener
     </strong>
    </p>
    <pre><code class="language-cpp">/**
 * 该例程将订阅chatter话题，消息类型String
 */
 
#include "ros/ros.h"
#include "std_msgs/String.h"

// 接收到订阅的消息后，会进入消息回调函数
void chatterCallback(const std_msgs::String::ConstPtr&amp; msg)
{
  // 将接收到的消息打印出来
  ROS_INFO("I heard: [%s]", msg-&gt;data.c_str());
}

int main(int argc, char **argv)
{
  // 初始化ROS节点
  ros::init(argc, argv, "listener");

  // 创建节点句柄
  ros::NodeHandle n;

  // 创建一个Subscriber，订阅名为chatter的topic，注册回调函数chatterCallback
  ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);

  // 循环等待回调函数
  ros::spin();

  return 0;
}</code></pre>
    <p>
     <strong>
      节点句柄的作用：
     </strong>
    </p>
    <p>
     1）自动地启动和关闭
     <br/>
     在节点初始化和关闭一节中,使用ros::NodeHandle管理节点的内部引用,使启动和关闭一个节点变得简单.
     <br/>
     在创建时,如果一个内部节点没有被启动,节点句柄将启动该节点.一旦所有的节点句柄实例被销毁,那么节点将被自动关闭.
     <br/>
     2）名字空间
     <br/>
     节点句柄允许给构造器明确一个名字空间
     <br/>
     ros::NodeHandle nh("my_namespace");
     <br/>
     这使节点拥有相对名字&lt;node_namespace&gt;/my_namespace,而不仅仅是&lt;node_namespace&gt;
     <br/>
     也可以给节点句柄明确一个父节点句柄和一个紧跟的名字空间
     <br/>
     ros::NodeHandle nh1("ns1");
     <br/>
     ros::NodeHandle nh2(nh1, "ns2");
     <br/>
     这使节点句柄nh2进入&lt;node_namespace&gt;/nh1/nh2名字空间下
     <br/>
     全局名字空间
     <br/>
     ros::NodeHandle nh("/my_global_namespace");
    </p>
    <p>
     <strong>
      ros::spin()的作用：
     </strong>
     这篇文章讲的非常详细
     <a href="https://www.cnblogs.com/liu-fa/p/5925381.html" rel="nofollow">
      https://www.cnblogs.com/liu-fa/p/5925381.html
     </a>
    </p>
    <p>
     <strong>
      ros::Subscriber：
     </strong>
     用于订阅话题
    </p>
    <p>
    </p>
    <p>
     <strong>
      Talker
     </strong>
    </p>
    <pre><code class="language-cpp">/**
 * 该例程将发布chatter话题，消息类型String
 */
 
#include &lt;sstream&gt;
#include "ros/ros.h"
#include "std_msgs/String.h"

int main(int argc, char **argv)
{
  // ROS节点初始化
  ros::init(argc, argv, "talker");
  
  // 创建节点句柄
  ros::NodeHandle n;
  
  // 创建一个Publisher，发布名为chatter的topic，消息类型为std_msgs::String
  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;("chatter", 1000);

  // 设置循环的频率
  ros::Rate loop_rate(10);

  int count = 0;
  while (ros::ok())
  {
	// 初始化std_msgs::String类型的消息
    std_msgs::String msg;
    std::stringstream ss;
    ss &lt;&lt; "hello world " &lt;&lt; count;
    msg.data = ss.str();

	// 发布消息
    ROS_INFO("%s", msg.data.c_str());
    chatter_pub.publish(msg);

	// 循环等待回调函数
    ros::spinOnce();
	
	// 按照循环频率延时
    loop_rate.sleep();
    ++count;
  }

  return 0;
}</code></pre>
    <p>
     <strong>
      ros::Publisher
     </strong>
     ：发布话题
    </p>
    <p>
     <strong>
      ros::Rate loop_rate(10)：
     </strong>
     发布频率，10HZ/s
    </p>
    <p>
     <strong>
      ros::spinOnce()：
     </strong>
     发布一次后等待订阅者接收，假设这里的发布频率为loop_rata(10)，10hz/s，若是不定义消息池，发布一次要等待订阅者接收，这里肯定存在延时，如果网络比较慢就会造成比较严重的延时。那么就需要一个缓存池，先把消息丢缓存池里，让它持续不断的发布，
     <strong>
     </strong>
     对于有些传输特别快的消息，尤其需要注意合理控制消息池大小和ros::spinOnce()执行频率; 比如消息送达频率为10Hz,接收方的ros::spinOnce()的回调频率为5Hz，那么消息池的大小就一定要大于2，才能保证数据不丢失，无延迟。这里的消息池1000，足够大了
    </p>
    <p>
     <strong>
      3）添加到CmakeLists.txt
     </strong>
     <br/>
     在ROS中但凡编写了程序文件都需要添加给CmakeLists.txt，否则编译时将找不到文件，在CmakeLists.txt末尾添加：
    </p>
    <pre><code class="language-bash">add_executable(talker src/talker.cpp)
target_link_libraries(talker ${catkin_LIBRARIES})
#add_dependencies(talker ${PROJECT_NAME}_generate_messages_cpp)

add_executable(listener src/listener.cpp)
target_link_libraries(listener ${catkin_LIBRARIES})</code></pre>
    <p>
     编译
    </p>
    <pre><code class="language-bash">$ catkin_make </code></pre>
    <p>
     不报错代表编译成功
    </p>
    <p style="text-align:center;">
     <img alt="" height="696" src="https://i-blog.csdnimg.cn/blog_migrate/8360cbd0bfa7aaf6df51d7e708193176.png" width="736"/>
    </p>
    <p>
     <strong>
      4）执行
     </strong>
    </p>
    <p>
     打开三个终端，第一个终端输入roscore，创建master进程，其余两个终端分别输入：
    </p>
    <pre><code class="language-bash">//终端1
$ roscore

//终端2
$ rosrun test1 listener

//终端3
$ rosrun test1 talker</code></pre>
    <p>
     <span style="color:#f33b45;">
      注意:test1为我创建的功能包名，你要确认自己的功能包名叫什么
     </span>
    </p>
    <p>
     感受一下话题模式的效果：
    </p>
    <p>
     <img alt="" height="763" src="https://i-blog.csdnimg.cn/blog_migrate/23f0207a69a7f3e8793a3adf274f992b.png" width="905"/>
    </p>
    <p>
    </p>
    <h4 id="1.1.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF">
     1.1.1 自定义话题消息
    </h4>
    <p>
     <strong>
      1）创建消息文件
     </strong>
    </p>
    <p>
     在功能包下创建msg文件夹并创建一个后缀为msg的消息文件
    </p>
    <pre><code class="language-bash">$ cd ~/catkin_make/src
$ mkdir msg
$ touch Person.msg</code></pre>
    <p>
     向Person.msg中添加：
    </p>
    <p>
     ROS系统的变量类型是独立一档的，下面演示的是一些基础类型，如string,int类型。我们下面定义一个关于人的消息类型
    </p>
    <pre><code class="language-bash">string name
uint8  sex
uint8  age

uint8 unknown = 0
uint8 male    = 1
uint8 female  = 2</code></pre>
    <p>
     <span style="color:#f33b45;">
      提示：uint8 unknown = 0 代表给一个整形的变量添加一个常量
     </span>
    </p>
    <p>
     <strong>
      2）在package.xml中添加功能包依赖
     </strong>
    </p>
    <p>
     如果有该项就不要添加了
    </p>
    <div>
     <pre><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;
&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code></pre>
     <p>
      <strong>
       3）在CMakeLists.txt中添加编译选项
      </strong>
     </p>
     <p>
      <strong>
       找到find_package()在尾部添加，找到catkin_package在尾部添加
      </strong>
     </p>
    </div>
    <div>
     <pre><code>find_package( ... std_msgs message_generation)

catkin_package(CATKIN_DEPENDS ... std_msgs message_runtime)

add_message_files(FILES Person.msg)
generate_messages(DEPENDENCIES std_msgs)</code></pre>
     <p style="text-align:center;">
      <img alt="" height="108" src="https://i-blog.csdnimg.cn/blog_migrate/e9366daee9f6df87884531addedd5b3e.png" width="420"/>
     </p>
     <p style="text-align:center;">
      <img alt="" height="110" src="https://i-blog.csdnimg.cn/blog_migrate/844342a7703ffe1fa40ed8fe438b2ff5.png" width="523"/>
     </p>
     <p>
      <strong>
       4）编译以及source
      </strong>
     </p>
     <p>
      之前也说了，但凡在ROS工作空间中做的修改都需要进行编译与source，谨记
     </p>
     <pre><code class="language-bash">$ catkin_make
$ source devel/setup.zsh</code></pre>
     <p>
      <strong>
       5）查看
      </strong>
     </p>
     <p>
      可通过rosmsg查看该消息信息
     </p>
     <pre><code>$ rosmsg show Person</code></pre>
     <p style="text-align:center;">
      <img alt="" height="138" src="https://i-blog.csdnimg.cn/blog_migrate/8fa3eb6b370aa3c2441d6d4bf76d4cc5.png" width="209"/>
     </p>
     <p>
      <strong>
       6）如何使用
      </strong>
     </p>
     <p>
      要使用自定义的消息，需要导入消息头 #include "test1/Person.h"
     </p>
     <p>
      通过工作空间名：消息文件名来创建消息对象，如：test1::Person p1
     </p>
     <p>
      修改listener程序
     </p>
     <pre><code class="language-cpp">/**
 * 该例程将发布chatter话题，消息类型String
 */
 
#include &lt;sstream&gt;
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "test1/Person.h"

int main(int argc, char **argv)
{
  // ROS节点初始化
  ros::init(argc, argv, "talker");
  
  // 创建节点句柄
  ros::NodeHandle n;
  
  // 创建一个Publisher，发布名为chatter的topic，消息类型为std_msgs::String
 
  //ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;("chatter", 1000);
  
  ros::Publisher chatter_pub = n.advertise&lt;test1::Person&gt;("person", 1000);

  // 设置循环的频率
  ros::Rate loop_rate(10);

  int count = 0;
  while (ros::ok())
  {
	// 初始化std_msgs::String类型的消息
    test1::Person p1;
    p1.name="libai";
    p1.sex=1;
    p1.age=11;

	// 发布消息
    ROS_INFO("%s,%d,%d", p1.name.c_str(),p1.age,p1.sex);
    chatter_pub.publish(p1);

	// 循环等待回调函数
    ros::spinOnce();
	
	// 按照循环频率延时
    loop_rate.sleep();
    ++count;
  }

  return 0;
}</code></pre>
     <p>
      修改talker程序
     </p>
     <pre><code class="language-cpp">/**
 * 该例程将订阅chatter话题，消息类型String
 */
 
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "test1/Person.h"

// 接收到订阅的消息后，会进入消息回调函数
void chatterCallback(const test1::Person::ConstPtr&amp; person)
{
  // 将接收到的消息打印出来
  ROS_INFO("I heard: [%s,%d,%d]", person-&gt;name.c_str(),person-&gt;age,person-&gt;sex);
}

int main(int argc, char **argv)
{
  // 初始化ROS节点
  ros::init(argc, argv, "listener");

  // 创建节点句柄
  ros::NodeHandle n;

  // 创建一个Subscriber，订阅名为chatter的topic，注册回调函数chatterCallback
  ros::Subscriber sub = n.subscribe("person", 1000, chatterCallback);

  // 循环等待回调函数
  ros::spin();

  return 0;
}</code></pre>
     <p>
      改完记得编译并source，效果如下：
     </p>
     <p>
      <img alt="" height="865" src="https://i-blog.csdnimg.cn/blog_migrate/cd97e478173395592eb504a7735af4f0.png" width="889"/>
     </p>
    </div>
    <h4 id="1.2%20ROS%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F--%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B">
     1.2 ROS通信模式--服务通信模型
    </h4>
    <ul>
     <li>
      &gt; Talker注册（又叫发布者，说话一方）
     </li>
     <li>
      &gt; Listener注册（又叫订阅者，听话的一方）
     </li>
     <li>
      &gt; ROS Master进行信息匹配
     </li>
     <li>
      &gt; 建立网络连接
     </li>
     <li>
      &gt; Talkerl向 Listener发布服务应答数据
     </li>
    </ul>
    <p>
     与话题通信模式不同的是，ROS Master在步骤2返回的是TCP/IP和端口号（话题通信模式返回的是RPC和端口号）
    </p>
    <p style="text-align:center;">
     <img alt="" height="648" src="https://i-blog.csdnimg.cn/blog_migrate/83230c63daba443c901993fc884f5119.png" width="793"/>
    </p>
    <h4>
    </h4>
    <h4 id="%E5%AE%9E%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1">
     实例：通过服务模式进行通信
    </h4>
    <p>
     <span style="color:#f33b45;">
      注意：本实例紧跟上面实例，所使用的工作空间和功能包名一致
     </span>
    </p>
    <p>
     <strong>
      1）实例说明
     </strong>
    </p>
    <p>
     本实例创建两个程序文件，server.cpp与client.cpp，client传两个整数给server，server用来计算两个值的和。还需要创建一个自定义消息，与话题消息不同的是，服务消息以srv结尾
    </p>
    <p>
     <strong>
      2）创建自定义消息
     </strong>
    </p>
    <pre><code>$ cd ~/catkin_ws/src
$ mkdir srv
$ cd srv
$ touch AddTwoInts.srv</code></pre>
    <p>
     int64 a b sum为三个64位的int整形，中间三个斜杆起到分隔作用，上面的部分作为输入参数，下面作为输出结果。
    </p>
    <pre><code>int64 a
int64 b
---
int64 sum</code></pre>
    <p>
     <strong>
      3）编写server.cpp 与 client.cpp
     </strong>
    </p>
    <pre><code class="language-bash">$ cd ~/catkin_ws/test1/src
$ touch server.cpp client.cpp</code></pre>
    <p>
     server.cpp
    </p>
    <pre><code class="language-cpp">/**
 * AddTwoInts Server
 */
 
#include "ros/ros.h"
#include "test1/AddTwoInts.h"

// service回调函数，输入参数req，输出参数res
bool add(test1::AddTwoInts::Request  &amp;req,
         test1::AddTwoInts::Response &amp;res)
{
  // 将输入参数中的请求数据相加，结果放到应答变量中
  res.sum = req.a + req.b;
  ROS_INFO("request: x=%ld, y=%ld", (long int)req.a, (long int)req.b);
  ROS_INFO("sending back response: [%ld]", (long int)res.sum);
  
  return true;
}

int main(int argc, char **argv)
{
  // ROS节点初始化
  ros::init(argc, argv, "add_two_ints_server");
  
  // 创建节点句柄
  ros::NodeHandle n;

  // 创建一个名为add_two_ints的server，注册回调函数add()
  ros::ServiceServer service = n.advertiseService("add_two_ints", add);
  
  // 循环等待回调函数
  ROS_INFO("Ready to add two ints.");
  ros::spin();

  return 0;
}
</code></pre>
    <p>
     <strong>
      #include "test1/AddTwoInts.h"：
     </strong>
     导入自定义消息类型
    </p>
    <p>
     <strong>
      test1::AddTwoInts::Request：
     </strong>
     创建自定义消息类型的Request对象，格式为 功能包：自定义消息类型文件名：Request。
    </p>
    <p>
     服务模式下的自定义消息类型有Request和Response对象，根据我们定义的类型，三斜杠上方的作为Request的参数，下方的作为Response
    </p>
    <p>
     <strong>
      ros::ServiceServer service ：
     </strong>
     创建服务对象的server端对象
    </p>
    <p>
     client.cpp
    </p>
    <pre><code class="language-cpp">/**
 * AddTwoInts Client
 */
 
#include &lt;cstdlib&gt;
#include "ros/ros.h"
#include "test1/AddTwoInts.h"

int main(int argc, char **argv)
{
  // ROS节点初始化
  ros::init(argc, argv, "add_two_ints_client");
  
  // 从终端命令行获取两个加数
  if (argc != 3)
  {
    ROS_INFO("usage: add_two_ints_client X Y");
    return 1;
  }

  // 创建节点句柄
  ros::NodeHandle n;
  
  // 创建一个client，请求add_two_int service，service消息类型是test1::AddTwoInts
  ros::ServiceClient client = n.serviceClient&lt;test1::AddTwoInts&gt;("add_two_ints");
  
  // 创建test1::AddTwoInts类型的service消息
  test1::AddTwoInts srv;
  //atoll(argv[]) 接收参数
  srv.request.a = atoll(argv[1]);
  srv.request.b = atoll(argv[2]);
  
  // 发布service请求，等待加法运算的应答结果
  if (client.call(srv))
  {
    ROS_INFO("Sum: %ld", (long int)srv.response.sum);
  }
  else
  {
    ROS_ERROR("Failed to call service add_two_ints");
    return 1;
  }

  return 0;
}
</code></pre>
    <p>
     <strong>
      ros::ServiceClient client
     </strong>
     ：创建服务类型的client端对象
    </p>
    <p>
     <strong>
      client.call(srv)：
     </strong>
     通过call方法向请求服务端，传递自定义消息类型，请求成功访问1否则0
    </p>
    <p>
     <strong>
      srv.response.sum：
     </strong>
     输出response
    </p>
    <p>
     <strong>
      4）修改CMakeLists.txt和Package.xml
     </strong>
    </p>
    <p>
     在Package.xml填入
    </p>
    <pre><code class="language-bash">&lt;build_depend&gt;message_generation&lt;/build_depend&gt; 
&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code></pre>
    <p>
     修改CMakeLists.txt
    </p>
    <p>
     在find_package和catkin_package尾部加入消息类型的依赖，添加add_service_files（）
    </p>
    <p>
     再就是把两个写好的client.cpp和server.cpp添加进来。
    </p>
    <p>
     add_dependencies(client ${PROJECT_NAME}_gencpp)由于是用c++写的，需要注入gencpp依赖，若是python就写genpy，但是要声明要项目名前缀，这些操作都是基础，注意一下格式即可。
    </p>
    <pre><code class="language-bash">find_package( ... message_generation)

catkin_package(CATKIN_DEPENDS ... message_runtime)

add_service_files(FILES AddTwoInts.srv)

add_executable(server src/server.cpp)
target_link_libraries(server ${catkin_LIBRARIES})
add_dependencies(client ${PROJECT_NAME}_gencpp)

add_executable(client src/client.cpp)
target_link_libraries(client ${catkin_LIBRARIES})
add_dependencies(client ${PROJECT_NAME}_gencpp)
</code></pre>
    <p>
     <strong>
      5）编译
     </strong>
    </p>
    <p>
     不报错代表编译成功
    </p>
    <pre><code class="language-bash">$ cd ~/catkin_ws
$ catkin_make
$ source ~/catkin_ws/devel/setup.zsh</code></pre>
    <p>
     <strong>
      6）执行
     </strong>
    </p>
    <p>
     开三个终端，分别起roscore，rosrun server ,rosrun client
    </p>
    <pre><code class="language-bash">$ roscore
$ rosrun test1 server
$ rosrun test1 client 1 2</code></pre>
    <p>
     <img alt="" height="847" src="https://i-blog.csdnimg.cn/blog_migrate/b9322482517f22e8a047771ed827596a.png" width="867"/>
    </p>
    <p>
    </p>
    <h4 id="1.3%20%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">
     1.3 话题通信模型与服务通信模式的区别
    </h4>
    <p>
     在同步性上，话题模式采用异步通信，数据传输的可靠性比较低，若考虑高精度传输，对传输质量要求较高的话应该选择服务模式。
    </p>
    <p>
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/blog_migrate/87360171e604a06c33919edef81e90f3.png" width="1200"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h4 id="1.4%20ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-%E5%8A%A8%E4%BD%9C">
     1.4 ROS通信机制-动作
    </h4>
    <p>
     动作（action）是一种带有带有连续反馈的通信机制，可在任务过程中止运行，基于ROS的消息机制实现。
    </p>
    <p style="text-align:center;">
     <img alt="" height="269" src="https://i-blog.csdnimg.cn/blog_migrate/6e5132231a5bb02f3dc0d982448f541c.png" width="751"/>
    </p>
    <p>
     <strong>
      Action的接口
     </strong>
    </p>
    <ul>
     <li>
      goal:发布任务目标
     </li>
     <li>
      cancel：请求取消任务
     </li>
     <li>
      status：通知客户端当前状态
     </li>
     <li>
      feedback：周期反馈任务运行的监控数据
     </li>
     <li>
      result：向客户端发送任务的执行结果（只发布一次）
     </li>
    </ul>
    <p>
    </p>
    <p style="text-align:center;">
     <img alt="" height="295" src="https://i-blog.csdnimg.cn/blog_migrate/07c3221eee79f55d6b7108fa5bccbbee.png" width="443"/>
    </p>
    <p>
    </p>
    <h4 id="%E7%A4%BA%E4%BE%8B">
     实例：经典案例洗盘子
    </h4>
    <p>
     下面是一个洗盘子的案例。把洗盘子当做一个动作
    </p>
    <p>
     goal对应洗盘子这个动作，result对应洗盘子的结果，feedback作为实时反馈，我们希望服务器(server）给我们洗盘子，client作为发起洗盘子动作的一方，当client发布一个goal，server收到后开始执行洗盘子动作，并实时反馈洗盘子的结果，直到希望后发布动作结束，result
    </p>
    <p>
     <strong>
      1) action文件
     </strong>
    </p>
    <p>
     action通信模式需要用到后缀名为.action的文件，分别定义goal目标，result结果和feedback反馈，以---分割
    </p>
    <pre><code># Define the goal
uint32 dishwasher_id  # Specify which dishwasher we want to use
---
# Define the result
uint32 total_dishes_cleaned
---
# Define a feedback message
float32 percent_complete</code></pre>
    <p>
     <strong>
      2 ) server
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &lt;actionlib/server/simple_action_server.h&gt;
#include "test1/DoDishesAction.h"

typedef actionlib::SimpleActionServer&lt;test1::DoDishesAction&gt; Server;

// 收到action的goal后调用该回调函数
void execute(const test1::DoDishesGoalConstPtr&amp; goal, Server* as)
{
    ros::Rate r(1);
    test1::DoDishesFeedback feedback;

    ROS_INFO("Dishwasher %d is working.", goal-&gt;dishwasher_id);

    // 假设洗盘子的进度，并且按照1hz的频率发布进度feedback
    for(int i=1; i&lt;=10; i++)
    {
        feedback.percent_complete = i * 10;
        as-&gt;publishFeedback(feedback);
        r.sleep();
    }

    // 当action完成后，向客户端返回结果
    ROS_INFO("Dishwasher %d finish working.", goal-&gt;dishwasher_id);
    as-&gt;setSucceeded();
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "do_dishes_server");
    ros::NodeHandle n;

    // 定义一个服务器
    Server server(n, "do_dishes", boost::bind(&amp;execute, _1, &amp;server), false);
    
    // 服务器开始运行
    server.start();

    ros::spin();

    return 0;
}</code></pre>
    <p>
     <strong>
      typedef actionlib::SimpleActionServer&lt;test1::DoDishesAction&gt; Server：
     </strong>
     声明Server的类型为actionlib::SimpleActionServer&lt;test1::DoDishesAction&gt; ，typedef可为已有类型取一个新的名字，如声明typedef int myint后，可用通过myint 创建变量myint a =1;
    </p>
    <p>
     <strong>
      const test1::DoDishesGoalConstPtr&amp; goal：
     </strong>
     DoDishesGoalConstPtr是动作通信模式中的关于goal动作的封装
     <strong>
      。
     </strong>
     关于ConstPtr可看这篇文章
     <a href="https://blog.csdn.net/kantswang/article/details/82947669">
      https://blog.csdn.net/kantswang/article/details/82947669
     </a>
    </p>
    <p>
     <strong>
      test1::DoDishesFeedback feedback：
     </strong>
     当我们创建了DoDishes.action后，在编译时将生成DoDishesFeedback（[  0%] Built target _test1_generate_messages_check_deps_DoDishesActionFeedback），通过feedback可调用DoDishes.action定义的变量（Define a feedback message）
    </p>
    <p>
     <strong>
      as-&gt;publishFeedback(feedback)
     </strong>
     ：Server* as，as是个Server类对象，引用sever类中的publishFeedback方法，用于反馈当前状况
    </p>
    <p>
     <strong>
      as-&gt;setSucceeded()
     </strong>
     ：Server类中的成功反馈方法
    </p>
    <p>
     <strong>
      Server server(n, "do_dishes", boost::bind(&amp;execute, _1, &amp;server), false)：
     </strong>
     关于SimpleActionServer的详细使用方式参考官方文档
     <strong>
      ，
     </strong>
     <a href="http://docs.ros.org/diamondback/api/actionlib/html/classactionlib_1_1SimpleActionServer.html" rel="nofollow">
      http://docs.ros.org/diamondback/api/actionlib/html/classactionlib_1_1SimpleActionServer.html
     </a>
     。在此我们使用的是是一种标准构造方式，第一个参数传句柄，第二个定义服务名（类似与话题名）；第三传入一个回调方法，关于 boost::bind(&amp;execute, _1, &amp;server),调用boost:bind做函数，变量绑定，实际需要传入的参数是execute对象（回调上述定义的execute方法），execute传入两个参数goal和server，execute方法中的const test1::DoDishesGoalConstPtr&amp; goal是一个常数（const），所以_1作为标识符（也叫占位符），无实际意义；第四个参数是否立即执行，不立即执行需要调用server.start()方法，
    </p>
    <p>
    </p>
    <p>
     <strong>
      3）client
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;actionlib/client/simple_action_client.h&gt;
#include "test1/DoDishesAction.h"

typedef actionlib::SimpleActionClient&lt;test1::DoDishesAction&gt; Client;

// 当action完成后会调用该回调函数一次
void doneCb(const actionlib::SimpleClientGoalState&amp; state,
        const test1::DoDishesResultConstPtr&amp; result)
{
    ROS_INFO("Yay! The dishes are now clean");
    ros::shutdown();
}

// 当action激活后会调用该回调函数一次
void activeCb()
{
    ROS_INFO("Goal just went active");
}

// 收到feedback后调用该回调函数
void feedbackCb(const test1::DoDishesFeedbackConstPtr&amp; feedback)
{
    ROS_INFO(" percent_complete : %f ", feedback-&gt;percent_complete);
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "do_dishes_client");

    // 定义一个客户端
    Client client("do_dishes", true);

    // 等待服务器端
    ROS_INFO("Waiting for action server to start.");
    client.waitForServer();
    ROS_INFO("Action server started, sending goal.");

    // 创建一个action的goal
    test1::DoDishesGoal goal;
    goal.dishwasher_id = 1;

    // 发送action的goal给服务器端，并且设置回调函数
    client.sendGoal(goal,  &amp;doneCb, &amp;activeCb, &amp;feedbackCb);

    ros::spin();

    return 0;
}
</code></pre>
    <p>
     <strong>
      client.sendGoal(goal,  &amp;doneCb, &amp;activeCb, &amp;feedbackCb)：
     </strong>
     这是client.sendGoal创建的标准模板（文档
     <a href="http://docs.ros.org/jade/api/actionlib/html/classactionlib_1_1SimpleActionClient.html#add37ef9123bfa8e3aca818e725e40c3c" rel="nofollow">
      http://docs.ros.org/jade/api/actionlib/html/classactionlib_1_1SimpleActionClient.html#add37ef9123bfa8e3aca818e725e40c3c
     </a>
     <strong>
      ）
     </strong>
    </p>
    <p>
     <img alt="" height="426" src="https://i-blog.csdnimg.cn/blog_migrate/8d8baa95f1a3acf744c1ecd8010ed74f.png" width="1200"/>
    </p>
    <p>
     <strong>
      &amp;doneCb：
     </strong>
     结束动作的Cb（callBack回调，下文同）
    </p>
    <p>
     <strong>
      &amp;activeCb：
     </strong>
     开始动作的Cb
    </p>
    <p>
     <strong>
      &amp;feedbackCb：
     </strong>
     实时反馈的Cb
    </p>
    <p>
     具体如何去定义这些函数由使用者决定，你也可以什么也不写，仅创建这些函数并调用，实际的作用你可以下文的执行中看到
    </p>
    <p>
     <strong>
      client.waitForServer()
     </strong>
     ：客户端等待服务端响应
    </p>
    <p>
     <strong>
      4）编译
     </strong>
    </p>
    <p>
     编译前修改Package.xml和CMakeList.txt
    </p>
    <p>
     Package.xml添加（动作通信模式必须导入的两个库）：
    </p>
    <blockquote>
     <div>
      <span style="color:#000000;">
       &lt;build_depend&gt;actionlib&lt;/build_depend&gt;
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       &lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       &lt;exec_depend&gt;actionlib&lt;/exec_depend&gt;
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       &lt;exec_depend&gt;actionlib_msgs&lt;/exec_depend&gt;
      </span>
     </div>
    </blockquote>
    <p>
     CMakeList.txt添加
    </p>
    <blockquote>
     <div>
      <span style="color:#000000;">
       find_package(catkin REQUIRED actionlib_msgs actionlib)
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       add_action_files(DIRECTORY action FILES DoDishes.action)
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       generate_messages(DEPENDENCIES actionlib_msgs)
      </span>
     </div>
     <div>
     </div>
     <div>
      <div>
       <span style="color:#000000;">
        add_executable(server src/server.cpp)
       </span>
      </div>
      <div>
       <span style="color:#000000;">
        target_link_libraries(server ${catkin_LIBRARIES})
       </span>
      </div>
      <div>
       <span style="color:#000000;">
        add_dependencies(server ${PROJECT_NAME}_gencpp)
       </span>
      </div>
      <div>
       <span style="color:#000000;">
        add_executable(client src/client.cpp)
       </span>
      </div>
      <div>
       <span style="color:#000000;">
        target_link_libraries(client ${catkin_LIBRARIES})
       </span>
      </div>
      <div>
       <span style="color:#000000;">
        add_dependencies(client ${PROJECT_NAME}_gencpp)
       </span>
      </div>
     </div>
    </blockquote>
    <div>
    </div>
    <p>
     <strong>
      5）执行
     </strong>
    </p>
    <p>
     开启三个终端，一roscore，二rosrun test1 DoDishes_server,三rosrun test1 DoDishes_client，实际执行效果对照程序进行观察
    </p>
    <p>
     <img alt="" height="854" src="https://i-blog.csdnimg.cn/blog_migrate/00ccf0c730a157e62026c350c85d4419.png" width="1003"/>
    </p>
    <h4 id="1.5%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1">
     1.5 分布式通信
    </h4>
    <p>
     ROS是一种分布式软件框架，节点之间通过松耦合的方式进行组合。我们可以在本地配置机端的ip来实现对远程机端的控制
    </p>
    <p>
     说白了ROS分布式通信机制就是在自己的电脑上操作ROS机端，而不需要ssh，因为ssh对图形支持不太友好，通过ROS提供的通信机制，你可以在本地调用rqt,rviz等工具，非常方便
    </p>
    <p>
     <strong>
      操作方式：
     </strong>
    </p>
    <p>
     <strong>
      1）设置IP地址，确保底层链路的连通
     </strong>
    </p>
    <p>
     假设有两台装有ROS系统的ubuntu系统，U1与U2
    </p>
    <p>
     U1 ip : 192.168.1.100
    </p>
    <p>
     U2 ip：192.168.1.200
    </p>
    <p>
     <strong>
      2）设置master主机
     </strong>
    </p>
    <p>
     若U1作为机端（master），在U2端输入:
    </p>
    <blockquote>
     <p>
      $ export ROS_MASTE_URI=http://192.168.1.100:11311
     </p>
     <p>
      $ export ROS_HOSTNAME=192.168.1.200
     </p>
    </blockquote>
    <p>
     ROS_MASTE_URI设置http协议访问机端，ROS_HOSTNAME设置本地访问的ip，同时声明了是谁对机端进行操作，声明这两条后就可以在本地调试机端。
    </p>
    <h4>
    </h4>
    <h4>
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f636b3738343130313737372f:61727469636c652f64657461696c732f313036313833383139" class_="artid" style="display:none">
 </p>
</div>


