---
layout: post
title: "RabbitMQ介绍以及基本使用"
date: 2025-03-10 12:31:32 +0800
description: "消息队列是一种用于在分布式系统中进行通信的技术。它是一种存储和转发消息的中间件，可以用于将应用程序之间的通信解耦，从而实现高效的异步通信。消息队列允许发送者将消息发送到队列中，而接收者则可以从队列中获取消息并进行处理。这种方式可以帮助系统实现高可用性、高性能、松耦合和可伸缩性。消息队列通常包括生产者（发送消息的应用程序）、消费者（接收消息的应用程序）和队列（存储消息的缓冲区）。RabbitMQ：是由erlang语言开发，基于AMQP(高级消息队列协议)协议实现的一种消息队列。市面。"
keywords: "消息队列"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['Ruby', 'Rabbitmq', 'Qt']
artid: "146150710"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146150710
    alt: "RabbitMQ介绍以及基本使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146150710
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146150710
cover: https://bing.ee123.net/img/rand?artid=146150710
image: https://bing.ee123.net/img/rand?artid=146150710
img: https://bing.ee123.net/img/rand?artid=146150710
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ介绍以及基本使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h5>
     <a id="_4">
     </a>
     文章目录
    </h5>
    <p>
     <a href="#%E4%B8%80%E3%80%81pandas%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">
      一、什么是消息队列？
     </a>
    </p>
    <p>
     <a href="#%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E4%BC%98%E7%82%B9%EF%BC%89" rel="nofollow">
      二、消息队列的作用（优点）
     </a>
    </p>
    <p>
     <a href="#1%E3%80%81%E8%A7%A3%E8%80%A6" rel="nofollow">
      1、解耦
     </a>
    </p>
    <p>
     <a href="#2%E3%80%81%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0" rel="nofollow">
      2、流量削峰
     </a>
    </p>
    <p>
     <a href="#3%E3%80%81%E5%BC%82%E6%AD%A5" rel="nofollow">
      3、异步
     </a>
    </p>
    <p>
     <a href="#4%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7" rel="nofollow">
      4、顺序性
     </a>
    </p>
    <p>
     <a href="#%E4%B8%89%E3%80%81RabbitMQ%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" rel="nofollow">
      三、RabbitMQ基本结构
     </a>
    </p>
    <p>
     <a href="#%E5%9B%9B%E3%80%81RabbitMQ%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F" rel="nofollow">
      四、RabbitMQ队列模式
     </a>
    </p>
    <p>
     <a href="#1%E3%80%81%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F" rel="nofollow">
      1、简单队列模式
     </a>
    </p>
    <p>
     <a href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F" rel="nofollow">
      2、工作队列模式
     </a>
    </p>
    <p>
     <a href="#3%E3%80%81%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F" rel="nofollow">
      3、发布/订阅模式
     </a>
    </p>
    <p>
     <a href="#4%E3%80%81%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F" rel="nofollow">
      4、路由模式
     </a>
    </p>
    <p>
     <a href="#5%E3%80%81%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F" rel="nofollow">
      5、主题模式
     </a>
    </p>
    <p>
     <a href="#6%E3%80%81RPC%E6%A8%A1%E5%BC%8F" rel="nofollow">
      6、RPC模式
     </a>
    </p>
    <p>
     <a href="#7%E3%80%81%E5%8F%91%E5%B8%83%E8%80%85%E7%A1%AE%E8%AE%A4%E6%A8%A1%E5%BC%8F" rel="nofollow">
      7、发布者确认模式
     </a>
    </p>
    <p>
     <a href="#%E4%BA%94%E3%80%81RabbitMQ%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0" rel="nofollow">
      五、RabbitMQ相关属性描述
     </a>
    </p>
    <p>
     <a href="#%E6%80%BB%E7%BB%93" rel="nofollow">
      总结
     </a>
    </p>
    <hr/>
    <h3>
     <a id="_42">
     </a>
     一、什么是消息队列？
    </h3>
    <p>
     消息队列是一种用于在分布式系统中进行通信的技术。它是一种存储和转发消息的中间件，可以用
    </p>
    <p>
     于将应用程序之间的通信解耦，从而实现高效的异步通信。消息队列允许发送者将消息发送到队列
    </p>
    <p>
     中，而接收者则可以从队列中获取消息并进行处理。这种方式可以帮助系统实现高可用性、高性
    </p>
    <p>
     能、松耦合和可伸缩性。消息队列通常包括生产者（发送消息的应用程序）、消费者（接收消息的
    </p>
    <p>
     应用程序）和队列（存储消息的缓冲区）。
    </p>
    <p>
     RabbitMQ：是由erlang语言开发，基于AMQP(高级消息队列协议)协议实现的一种消息队列。市面
    </p>
    <p>
     上还有很多消息队列，比如Kafka、RocketMQ、Redis等，各有优劣，本文主要介绍RabbitMQ。
    </p>
    <p>
     官方文档：
     <a href="https://www.rabbitmq.com/tutorials" rel="nofollow" title="RabbitMQ Tutorials | RabbitMQ">
      RabbitMQ Tutorials | RabbitMQ
     </a>
    </p>
    <h3>
     <a id="_61">
     </a>
     二、消息队列的作用（优点）
    </h3>
    <h5>
     <a id="1_64">
     </a>
     1、解耦
    </h5>
    <p>
     应用程序解耦，通过引入消息队列，不同的应用程序之间可以通过消息队列进行通信，而无需直接
    </p>
    <p>
     调用对方的接口或方法。这样可以降低系统中各个应用程序之间的耦合度，使得它们可以独立演化
    </p>
    <p>
     和扩展，而不会因为对方的变化而受到影响。
    </p>
    <h5>
     <a id="2_72">
     </a>
     2、流量削峰
    </h5>
    <p>
     消息队列可以作为一个缓冲区，暂时存储流入的消息，直到系统有足够的资源来处理它们。当系统
    </p>
    <p>
     出现流量高峰时，消息队列可以暂时存储过多的消息，以平滑处理流量的波动，避免系统被突发的
    </p>
    <p>
     高负载压垮。
    </p>
    <h5>
     <a id="3_80">
     </a>
     3、异步
    </h5>
    <p>
     发送者在发送消息后可以立即继续执行其他操作，而不需要等待接收者的响应。这样可以提高系统
    </p>
    <p>
     的并发性和响应速度。也可以帮助提高系统的吞吐量，特别是在面对大量请求或处理复杂计算时。
    </p>
    <p>
     发送者可以并行地向多个接收者发送消息，而不会因为等待接收者的响应而阻塞。
    </p>
    <h5>
     <a id="4_88">
     </a>
     4、顺序性
    </h5>
    <p>
     虽然并不是所有消息队列都能保证消息的绝对顺序性，但是在许多情况下，消息队列可以保证消息
    </p>
    <p>
     的相对顺序性。即按照发送顺序进行处理，对某些场景要求顺序执行很适合。
    </p>
    <h3>
     <a id="RabbitMQ_94">
     </a>
     三、RabbitMQ基本结构
    </h3>
    <p>
     名称
    </p>
    <p>
     描述
    </p>
    <p>
     Connection（连接 ）
    </p>
    <p>
     连接是生产者和消费者与RabbitMQ之间的连接。每个生产者和消费者都需要与RabbitMQ建立一个连接，以便发送和接收消息。连接通常是长连接，可以重用以提高性能和效率。
    </p>
    <p>
     Channel（信道）
    </p>
    <p>
     Channel是连接（Connection）内的逻辑通道，用于完成大部分 AMQP 操作，如声明队列、发送和接收消息等。在 RabbitMQ 中引入 Channel（信道）的主要目的是为了提高系统的性能、灵活性和效率。使用 Channel 可以避免频繁地创建和销毁连接，因为一个连接可以包含多个 Channel。这样可以减少连接的开销，节省系统资源，并提高性能。
    </p>
    <p>
     Exchange（交换机）
    </p>
    <p>
     交换机是消息的接收和分发中心，负责接收生产者发送的消息，并根据指定的路由规则发送到一个或多个队列中。
    </p>
    <p>
     （
     <strong>
      Exchange相当于Queue的代理，可以设置不同的写入策略，写入到对应的队列中。对于队列的写入，更加灵活
     </strong>
     ）
    </p>
    <p>
     交换机的类型有：fanout扇出、topic主题、direct直接
    </p>
    <p>
     Queue（队列）
    </p>
    <p>
     队列是消息的缓存区，用于存储交换机发送的消息。生产者发送的消息最终会被存储在队列中，等待消费者进行消费。队列可以持久化到磁盘，以确保消息不会在RabbitMQ宕机或重启后丢失。
    </p>
    <p>
     Producer（生产者）
    </p>
    <p>
     生产者是发送消息到RabbitMQ的应用程序。生产者负责创建消息并将其发送到RabbitMQ的消息队列中。
    </p>
    <p>
     Consumer（消费者）
    </p>
    <p>
     消费者是从RabbitMQ队列中接收消息并进行处理的应用程序。消费者可以订阅一个或多个队列，并在消息到达队列时接收并处理它们。消费者负责监听队列中的消息，并将其取出进行处理。
    </p>
    <h3>
     <a id="RabbitMQ_129">
     </a>
     四、RabbitMQ队列模式
    </h3>
    <p>
     基于Exchange交换机，RabbitMQ截至目前有七种队列模式。
    </p>
    <h5>
     <a id="1_134">
     </a>
     1、简单队列模式
    </h5>
    <p>
     一个消息生产者，一个消息消费者，一个队列。也称为点对点模式。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/75d0abbc0d618d2a63144ca3017859ef.png"/>
    </p>
    <p>
     图中P代表生产者，C代表消费者，Queue是队列名称。
    </p>
    <p>
     我们看到是没有Exchange的，但是RabbitMQ也会有一个默认的交换机。这个默认的交换机通常被
    </p>
    <p>
     称为"amq.default"或者""（空字符串），是RabbitMQ自动创建的，用于在没有指定交换机的情况
    </p>
    <p>
     下将消息发送到队列。
    </p>
    <pre><code>//生产者
var factory = new ConnectionFactory { HostName = "localhost"}; //初始化连接信息
using var connection = factory.CreateConnection();  //创建连接
using var channel = connection.CreateModel(); //创建信道

//声明一个队列，并将信道与队列绑定
channel.QueueDeclare(queue: "hello",
                     durable: false,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);
//发送消息的内容
string message = $"Hello World!";
var body = Encoding.UTF8.GetBytes(message);

//信道绑定交换机
channel.BasicPublish(exchange: string.Empty,
                     routingKey: string.Empty,
                     basicProperties: null,
                     body: body);

Console.WriteLine($" [x] Sent {message}");

Console.WriteLine(" Press [enter] to exit.");


//消费者
var factory = new ConnectionFactory { HostName = "localhost" };
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

channel.QueueDeclare(queue: "hello",
                     durable: false,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);

Console.WriteLine(" [*] Waiting for messages.");

var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =&gt;
{
    var body = ea.Body.ToArray();
    var message = Encoding.UTF8.GetString(body);
    Console.WriteLine($" [x] Received {message}");
};
channel.BasicConsume(queue: "hello",
                     autoAck: true,
                     consumer: consumer);

Console.WriteLine(" Press [enter] to exit.");
</code></pre>
    <p>
     此时就会生产者发送一条消息，消费者就会接收一条消息。
    </p>
    <h5>
     <a id="2_202">
     </a>
     2、工作队列模式
    </h5>
    <p>
     _工作队列又叫做任务队列，正常_会按顺序把消息发送给每一个订阅的消费者，平均而言，每个消费
    </p>
    <p>
     者将获得相同数量的消息。（不是P发送一条消息，C1和C2都会收到，而是第一条C1消费，第二
    </p>
    <p>
     条C2消费。每个消息只会被一个消费者接收和处理）。
    </p>
    <p>
     这样的好处是可以提高吞吐量，因为生产者发送了很多消息，但是消费者只有一个，消费者处理很
    </p>
    <p>
     慢，就会造成消息积压。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6d5b70418bc6af8c03c667ec840941e0.png"/>
    </p>
    <pre><code>//生产者
var factory = new ConnectionFactory { HostName = "localhost"};
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

channel.QueueDeclare(queue: "task_queue",
                     durable: true,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);

var message = $"work queue";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: string.Empty,
                 routingKey: string.Empty,
                 basicProperties: null,
                 body: body);
Console.WriteLine($" [x] Sent {message}");

Console.WriteLine(" Press [enter] to exit.");

//消费者
var factory = new ConnectionFactory { HostName = "localhost" };
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

channel.QueueDeclare(queue: "task_queue",
                     durable: true,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);

Console.WriteLine(" [*] Waiting for messages.");

var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =&gt;
{
    byte[] body = ea.Body.ToArray();
    var message = Encoding.UTF8.GetString(body);
    Console.WriteLine($" [x] Received {message}");

    channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);
};
channel.BasicConsume(queue: "task_queue",
                     autoAck: false,
                     consumer: consumer);

Console.WriteLine(" Press [enter] to exit.");
</code></pre>
    <p>
     工作队列与简单队列一致，会有一个默认的交换机。
    </p>
    <h5>
     <a id="3_267">
     </a>
     3、发布/订阅模式
    </h5>
    <p>
     发布/订阅模式是一种消息传递模式，它允许发送者（发布者）将消息发布到多个接收者（订阅
    </p>
    <p>
     者）。
     <strong>
      消息传递模型的核心思想是生产者从不直接向队列发送任何消息。实际上，生产者通常根本
     </strong>
    </p>
    <p>
     <strong>
      不知道消息是否会被传递到任何队列
     </strong>
     。
    </p>
    <p>
     所以消息传递模式，发布者不需要指定队列。
    </p>
    <p>
     发布/订阅模式交换机类型为Fanout。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/3dda02fefb8549c95f29451ef126977a.png"/>
    </p>
    <pre><code>//发布者
var factory = new ConnectionFactory { HostName = "localhost"};
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

//声明一个交换机，叫做logs，并且交换机的类型是Fanout
channel.ExchangeDeclare(exchange: "logs", type: ExchangeType.Fanout);

var message = "publish_subscribe";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: "logs",
                     routingKey: string.Empty,
                     basicProperties: null,
                     body: body);
Console.WriteLine($" [x] Sent {message}");

Console.WriteLine(" Press [enter] to exit.");

//接收者
var factory = new ConnectionFactory { HostName = "localhost"};
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

channel.ExchangeDeclare(exchange: "logs", type: ExchangeType.Fanout);

//创建一个具有生成名称的非持久、独占、自动删除队列
var queueName = channel.QueueDeclare().QueueName;
channel.QueueBind(queue: queueName,
                  exchange: "logs",
                  routingKey: string.Empty);

Console.WriteLine(" [*] Waiting for logs.");

var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =&gt;
{
    byte[] body = ea.Body.ToArray();
    var message = Encoding.UTF8.GetString(body);
    Console.WriteLine($" [x] {message}");
};
channel.BasicConsume(queue: queueName,
                     autoAck: false,
                     consumer: consumer);

Console.WriteLine(" Press [enter] to exit.");
</code></pre>
    <p>
     <strong>
      注
     </strong>
     ：如果发布者已经发布消息到交换机，但还没有队列绑定到交换机，消息将会丢失。
    </p>
    <h5>
     <a id="4_329">
     </a>
     4、路由模式
    </h5>
    <p>
     路由模式也是一种消息传递模式，是基于消息的路由键（routing key）来将消息从交换机
    </p>
    <p>
     （exchange）发送到一个或多个队列中。相比较于发布/订阅模式，路由模式多了一个routing key
    </p>
    <p>
     的概念。
    </p>
    <p>
     路由模式交换机类型为Direct。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/3098bec334dfcc0d6c4c726705382a2e.png"/>
    </p>
    <pre><code>//生产者
var factory = new ConnectionFactory { HostName = "localhost"};
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

//定义交换机名称以及类型为Direct
channel.ExchangeDeclare(exchange: "direct_logs", type: ExchangeType.Direct);

//定义路由键
string routingKey = "direct_test";

//发送消息体
string message  = "direct_message";
var body = Encoding.UTF8.GetBytes(message);

channel.BasicPublish(exchange: "direct_logs",
                     routingKey: routingKey,
                     basicProperties: null,
                     body: body);
Console.WriteLine($" [x] Sent '{routingKey}':'{message}'");

Console.WriteLine(" Press [enter] to exit.");


//消费者
var factory = new ConnectionFactory { HostName = "localhost" };
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

channel.ExchangeDeclare(exchange: "direct_logs", type: ExchangeType.Direct);

//创建一个具有生成名称的非持久、独占、自动删除队列
var queueName = channel.QueueDeclare().QueueName;

//路由键集合
var routeKeyArr = new string[] { "direct_test", "direct_test2" };

foreach (var routeKey in routeKeyArr)
{
    channel.QueueBind(queue: queueName,
                      exchange: "direct_logs",
                      routingKey: routeKey);
}

Console.WriteLine(" [*] Waiting for messages.");

var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =&gt;
{
    var body = ea.Body.ToArray();
    var message = Encoding.UTF8.GetString(body);
    var routingKey = ea.RoutingKey;
    Console.WriteLine($" [x] Received '{routingKey}':'{message}'");
};
channel.BasicConsume(queue: queueName,
                     autoAck: true,
                     consumer: consumer);

Console.WriteLine(" Press [enter] to exit.");
</code></pre>
    <p>
     <strong>
      路由模式，消费者可以监听多个路由键
     </strong>
     。
    </p>
    <h5>
     <a id="5_405">
     </a>
     5、主题模式
    </h5>
    <p>
     基于路由模式，仍然有局限性——它不能基于多个标准进行路由。也就是一个消费者只能接收完全
    </p>
    <p>
     与routing key相匹配的交换机。主题模式主要解决路由模式的不足，可以模糊匹配routing key。
    </p>
    <p>
     路由模式交换机类型为Topic。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b5e650594b7d2c2a968a43e3e59d63d8.png"/>
    </p>
    <p>
     在生产者方面，基于
     <strong>
      .
     </strong>
     作为分隔符，用于routing key。比如“
     <code>
      stock.usd.nyse
     </code>
     ”、“
     <code>
      nyse.vmw
     </code>
     ”、
    </p>
    <p>
     “
     <code>
      quick.orange.rabbit
     </code>
     ”。可以是任何单词，但最多只有255 个字节。
    </p>
    <p>
     在消费者方面，绑定routing key有两种重要的情况：
    </p>
    <p>
     （1）*(星号)：匹配一个单词。
    </p>
    <p>
     具体语法：
    </p>
    <pre><code>var routeing_key = "info.debug.error";

//匹配 info
"info.*.*"
//匹配debug
"*.debug.*"
//匹配error
"*.*.error"
</code></pre>
    <p>
     （2）#(散列)：匹配零个或多个单词。
    </p>
    <p>
     具体语法：
    </p>
    <pre><code>var routeing_key = "info.debug.error";

//匹配 info
"info.#"
//匹配debug
"#.debug.#"
//匹配error
"*.*.error"
</code></pre>
    <h5>
     <a id="6RPC_447">
     </a>
     6、RPC模式
    </h5>
    <p>
     RPC模式又叫"
     <strong>
      请求/回复模式
     </strong>
     "。
    </p>
    <p>
     RPC（Remote Procedure Call，远程过程调用）是一种用于在分布式系统中进行通信的技术。它
    </p>
    <p>
     允许一个进程（或线程）调用另一个进程（或线程）的过程（函数或方法），就像调用本地函数一
    </p>
    <p>
     样，而不需要开发者显式处理底层通信细节。
    </p>
    <p>
     （就是生产者发送一条消息，消费者端执行某个方法，获取值的同时，并返回到生产者。）
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/8d77082f5faf777625096facd042c343.png"/>
    </p>
    <pre><code>//生产者
var factory = new ConnectionFactory { HostName = "localhost"};
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

//定义接收返回结果的队列
var replyQueueName = channel.QueueDeclare().QueueName;
var consumer = new EventingBasicConsumer(channel);

consumer.Received += (model, ea) =&gt;
{
    var body = ea.Body.ToArray();
    var response = Encoding.UTF8.GetString(body);
    Console.WriteLine(" [.] Got '{0}'", response);
};

//发送消息
var correlationId = Guid.NewGuid().ToString(); //消息唯一性
var props = channel.CreateBasicProperties();
props.CorrelationId = correlationId;
props.ReplyTo = replyQueueName; //回调队列名称

string message = "30";
var messageBytes = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(
    exchange: "",
    routingKey: "rpc_queue",
    basicProperties: props,
    body: messageBytes);

channel.BasicConsume(
    consumer: consumer,
    queue: replyQueueName,
    autoAck: true);


//消费者
var factory = new ConnectionFactory { HostName = "localhost" };
using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

channel.QueueDeclare(queue: "rpc_queue",
                             durable: false,
                             exclusive: false,
                             autoDelete: false,
                             arguments: null);
channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);
var consumer = new EventingBasicConsumer(channel);
channel.BasicConsume(queue: "rpc_queue",
                     autoAck: false,
                     consumer: consumer);
Console.WriteLine(" [x] Awaiting RPC requests");
consumer.Received += (model, ea) =&gt;
{
    string response = string.Empty;

    var body = ea.Body.ToArray();
    var props = ea.BasicProperties;
    var replyProps = channel.CreateBasicProperties();
    replyProps.CorrelationId = props.CorrelationId;

    try
    {
        var message = Encoding.UTF8.GetString(body);
        int n = int.Parse(message);
        Console.WriteLine($" [.] Fib({message})");
        response = FibHelper.Fib(n).ToString();
    }
    catch (Exception e)
    {
        Console.WriteLine($" [.] {e.Message}");
        response = string.Empty;
    }
    finally
    {
        //回调到生产者队列
        var responseBytes = Encoding.UTF8.GetBytes(response);
        channel.BasicPublish(exchange: string.Empty,
                             routingKey: props.ReplyTo,
                             basicProperties: replyProps,
                             body: responseBytes);
        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);
    }
};


//执行函数，并返回结果
public class FibHelper
{
     public static int Fib(int n)
     {
         if (n == 0 || n == 1)
            return n;
         return Fib(n - 1) + Fib(n - 2);
     }
}
</code></pre>
    <p>
     RPC模式不是消息传递模式，消息只会被一个消费者消费。
    </p>
    <h5>
     <a id="7_562">
     </a>
     7、发布者确认模式
    </h5>
    <p>
     发布者确认模式（Publisher Confirmation）是 RabbitMQ 提供的一种机制，用于确保消息被成功
    </p>
    <p>
     发送到交换机（exchange）并被接收到，以及确保消息被正确地路由到队列中。在传统的消息发
    </p>
    <p>
     布过程中，发布者发送消息到交换机后，并不知道消息是否已经被正确地处理。为了解决这个问
    </p>
    <p>
     题，RabbitMQ 提供了发布者确认模式，允许发布者确认消息是否已经被成功接收到。
    </p>
    <pre><code>//生产者
var factory = new ConnectionFactory() { HostName = "localhost" };
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    // 设置信道为确认模式
    channel.ConfirmSelect();

    // 声明一个队列
    channel.QueueDeclare(queue: "hello",
                         durable: false,
                         exclusive: false,
                         autoDelete: false,
                         arguments: null);

    // 消息内容
    string message = "Hello World!";
    var body = Encoding.UTF8.GetBytes(message);

    try
    {
        // 发送消息
        channel.BasicPublish(exchange: "",
                             routingKey: "",
                             basicProperties: null,
                             body: body);

        // 等待消息确认
        if (channel.WaitForConfirms())
        {
            Console.WriteLine(" [x] Sent {0}", message);
        }
        else
        {
            Console.WriteLine(" [x] Failed to send {0}", message);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"An error occurred: {ex.Message}");
    }
}

Console.WriteLine(" Press [enter] to exit.");
Console.ReadLine();

//消费者
var factory = new ConnectionFactory() { HostName = "localhost" };
using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    // 声明一个队列
    channel.QueueDeclare(queue: "hello",
                         durable: false,
                         exclusive: false,
                         autoDelete: false,
                         arguments: null);

    // 创建消费者
    var consumer = new EventingBasicConsumer(channel);

    // 消费消息
    consumer.Received += (model, ea) =&gt;
    {
        var body = ea.Body;
        var message = Encoding.UTF8.GetString(body);
        Console.WriteLine(" [x] Received {0}", message);
    };

    // 消费者开始接收消息
    channel.BasicConsume(queue: "hello",
                         autoAck: true,
                         consumer: consumer);

    Console.WriteLine(" Press [enter] to exit.");
    Console.ReadLine();
}
</code></pre>
    <h3>
     <a id="RabbitMQ_650">
     </a>
     五、RabbitMQ相关属性描述
    </h3>
    <p>
     上述代码中，有很多属性的设置，下面解释一下。
    </p>
    <p>
     名称
    </p>
    <p>
     值
    </p>
    <p>
     描述
    </p>
    <p>
     durable
    </p>
    <p>
     布尔
    </p>
    <p>
     队列是否持久化。如果将队列声明为持久化，那么当 RabbitMQ 服务器重启时，队列将被重新声明。持久化队列中的消息会被存储在磁盘上，因此即使在服务器重启后，消息也不会丢失。
    </p>
    <p>
     exclusive
    </p>
    <p>
     布尔
    </p>
    <p>
     是否为排他队列。当队列被声明为排他时，只有声明该队列的连接（connection）才能使用它。一旦连接关闭，排他队列就会被删除。这种队列通常是用于临时任务，只允许声明它的连接使用，不会被其他连接访问。
    </p>
    <p>
     autoDelete
    </p>
    <p>
     布尔
    </p>
    <p>
     队列是否自动删除。如果将队列声明为自动删除，则在最后一个连接订阅它的消费者取消订阅后，队列将被自动删除。这种属性通常与临时队列一起使用，以确保在不再需要队列时它会被清理。
    </p>
    <p>
     arguments
    </p>
    <p>
     类
    </p>
    <p>
     用于设置队列或交换机的额外参数的选项。这些参数可以用于定制化队列或交换机的行为，以满足特定的需求。比如，设置队列的最大长度、消息在队列中的最大存活时间。
    </p>
    <p>
     autoAck
    </p>
    <p>
     布尔
    </p>
    <p>
     消息是否自动确认。它是指在消费者从队列中接收到消息后，是否自动确认消息的消费。当设置为
     <code>
      true
     </code>
     时，表示消费者会自动确认收到的消息，此时队列中表示该消息已被消费成功了。当设置为
     <code>
      false
     </code>
     时，表示消费者需要显式地调用确认方法来告知 RabbitMQ 已经成功处理了消息，否则消息将被重新放回队列，等待其他消费者处理。
    </p>
    <p>
     basicProperties
    </p>
    <p>
     类
    </p>
    <p>
     是指在发布消息时可以携带的消息属性。这些属性包含了有关消息的元数据信息，例如消息的优先级、消息的过期时间、消息的类型等等。
    </p>
    <hr/>
    <h3>
     <a id="_699">
     </a>
     总结
    </h3>
    <p>
     RabbitMQ 是一个消息队列，主要作用就是异步、顺序性、削峰等。
    </p>
    <p>
     七种队列模式，可以根据不同的场景具体使用。
    </p>
    <h6>
     <a id="1__706">
     </a>
     <strong>
      1. 简单队列模式
     </strong>
    </h6>
    <p>
     最简单的消息模式。一个生产者发送消息到一个队列，一个消费者从队列中接收消息并处理。适用
    </p>
    <p>
     于单个生产者-单个消费者的简单场景。
    </p>
    <p>
     <strong>
      2. 工作队列模式
     </strong>
    </p>
    <p>
     多个消费者共同消费消息。消费者从队列中取出消息并处理，消息会平均地分配给消费者。
    </p>
    <p>
     是基于简单队列模式的缺点，做了提升。适用于负载均衡和任务分发的场景。
    </p>
    <p>
     <strong>
      3. 发布/订阅模式
     </strong>
    </p>
    <p>
     生产者将消息发送到交换机，交换机将消息广播到所有与之绑定的队列。多个消费者可以订阅不同
    </p>
    <p>
     的队列，从而接收消息的副本。适用于消息广播和通知的场景。
    </p>
    <p>
     <strong>
      4. 路由模式
     </strong>
    </p>
    <p>
     生产者发送消息到交换机，并使用路由键指定消息的目标队列。交换机根据消息的路由键将消息路
    </p>
    <p>
     由到与之匹配的队列中。适用于根据消息内容进行精确路由的场景。
    </p>
    <p>
     <strong>
      5. 主题模式
     </strong>
    </p>
    <p>
     类似于路由模式，但是路由键可以使用通配符进行匹配。适用于消息的多样化路由和灵活的匹配需
    </p>
    <p>
     求。
    </p>
    <p>
     <strong>
      6. RPC模式
     </strong>
    </p>
    <p>
     客户端（RPC请求者）发送请求消息到队列中，并等待服务器（RPC响应者）返回响应消息。
    </p>
    <p>
     服务器监听请求队列，处理请求并将响应发送回客户端指定的队列。适用于需要请求-响应式通信
    </p>
    <p>
     的场景，类似于远程调用。
    </p>
    <h6>
     <a id="7__744">
     </a>
     <strong>
      7.
     </strong>
     发布者确认模式
    </h6>
    <p>
     发布者确认模式是 RabbitMQ 提供的一种机制，用于确保消息在发送到交换机并被路由到队列时的
    </p>
    <p>
     可靠性。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343832333439302f:61727469636c652f64657461696c732f313436313530373130" class_="artid" style="display:none">
 </p>
</div>


