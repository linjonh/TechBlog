---
layout: post
title: "框架源码私享笔记02Mybatis核心框架原理-一条SQL透析核心组件功能特性"
date: 2025-03-13 17:09:04 +0800
description: "本文详细解构了MyBatis的工作机制，包括解析配置、创建连接、执行SQL、结果封装和关闭连接等步骤。文章还介绍了MyBatis的五大核心功能特性：支持动态SQL、缓存机制（一级和二级缓存）、插件扩展、延迟加载和SQL注解，帮助读者深入了解其高效灵活的设计理念。"
keywords: "框架源码私享笔记(02)Mybatis核心框架原理 | 一条SQL透析核心组件功能特性"
categories: ['框架源码私享笔记']
tags: ['Tomcat', 'Sql', 'Spring', 'Mybatis', 'Java', 'Boot']
artid: "146236509"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146236509
    alt: "框架源码私享笔记02Mybatis核心框架原理-一条SQL透析核心组件功能特性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146236509
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146236509
cover: https://bing.ee123.net/img/rand?artid=146236509
image: https://bing.ee123.net/img/rand?artid=146236509
img: https://bing.ee123.net/img/rand?artid=146236509
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     框架源码私享笔记(02)Mybatis核心框架原理 | 一条SQL透析核心组件功能特性
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      最近在思考一个问题：如何能够更好的分享主流框架源码学习笔记（主要是源码部分）?让有缘刷到的同学既可以有所收获，还能保持对相关技术架构探讨学习热情和兴趣。以及自己也保持较高的分享热情和动力。
     </p>
     <p>
      今天尝试用一个SQL查询作为引子，去解构Mybatis的核心原理和关键源码处理流程。这种更加贴合工作实践方式，相信可以降低探索核心源码门槛。
     </p>
    </blockquote>
    <hr/>
    <p>
     <strong>
      一、前言背景
     </strong>
    </p>
    <p>
     <strong>
      二、Mybatis概述
     </strong>
    </p>
    <p>
     <strong>
      三、Mybatis的核心原理
     </strong>
    </p>
    <p>
     <strong>
      3.1 Mybatis核心功能处理流程
     </strong>
    </p>
    <p>
     3.1.1 解析配置-加载并解析Mapper配置文件
    </p>
    <p>
     3.1.2 创建连接-创建SqlSessionFactory并获取sqlSession连接
    </p>
    <p>
     3.1.3 执行SQL语句-Executor
    </p>
    <p>
     3.1.4 结果数据封装 MapperStatement &amp; ResultSetHandler
    </p>
    <p>
     3.1.5 关闭连接
    </p>
    <p>
     <strong>
      四、核心功能特性
     </strong>
    </p>
    <p>
     <strong>
      4.1 支持动态灵活的SQL
     </strong>
    </p>
    <p>
     <strong>
      4.2 详解一级、二级缓存机制
     </strong>
    </p>
    <p>
     4.2.1 二级缓存为什么默认不开启？
    </p>
    <p>
     <strong>
      4.3 支持插件扩展
     </strong>
    </p>
    <p>
     <strong>
      4.4 延迟加载
     </strong>
    </p>
    <p>
     <strong>
      4.5 SQL注解
     </strong>
    </p>
    <hr/>
    <p name="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%E8%83%8C%E6%99%AF">
     <span style="color:#4da8ee">
      【公众号搜索：拉丁解牛说技术】欢迎一起交流讨论。
     </span>
    </p>
    <h3 id="4cou6" name="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%E8%83%8C%E6%99%AF">
     <strong>
      一、前言背景
     </strong>
    </h3>
    <p>
     在10多年前，那时候刚开始工作，移动互联网还没发展起来，Mybatis还没流行，后端应用开发，主流用的是SSH框架。回想那时候的Hibernate、Spring，配置多又杂，其实对新手并不友好。然而相比手写JDBC连接管理、繁琐的结果数据转换，让SSH当年也是火了好几年。
    </p>
    <p>
     随着Hibernate和Mybatis的不断发展，研发人员成功解放手写JDBC数据库连接查询相关研发工作。他们都是优秀的ORM对象关系映射管理框架，也就是持久层框架。但是Hibernate存在对复杂sql关系支持弱、不支持存储过程、性能差、调优难、全表映射复杂等问题，用的人越来越少。
    </p>
    <p>
     而后起之秀Mybatis，当今最经典ORM框架，由于其灵活易用、好扩展、支持复杂SQL、出色的性能，较好的平衡对象关系映射管理和SQL编写支持，称为半ORM框架，已经成功替代Hibernate。
    </p>
    <p>
     今天我们梳理Mybatis的核心原理和工作流程，以及重点分析它的一些核心功能特性。
    </p>
    <h3 id="ej048" name="%E4%BA%8C%E3%80%81Mybatis%E6%A6%82%E8%BF%B0">
     <strong>
      二、Mybatis概述
     </strong>
    </h3>
    <p>
     Mybatis是一个持久层框架，具体就是用来
     <strong>
      操作数据库数据，并转换成目标对象
     </strong>
     的技术框架。它的核心在于将表数据和对象实例进行关联映射，也就是ORM（object relation Mapping）。
    </p>
    <p>
     Mybatis之所以可以替换Hibernate，主要是支持SQL定制、高级的映射管理功能、缓存机制、还有存储过程(由于大数据技术发展，目前存储过程用的人也越来越少，但是在那个年代支持存储过程非常实用)。Mybatis灵活可扩展高性能的特性，让我们开发读写数据，几乎不需要编程，主要做的工作就是编写Mapper配置文件，把SQL和对象关系映射管理好，就可以实现CRUD。而多类型数据库的切换迁移，对系统应用来说，简单到只需要替换JDBC的驱动。
    </p>
    <h3 id="3ea3f" name="%E4%B8%89%E3%80%81Mybatis%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">
     <strong>
      三、Mybatis的核心原理
     </strong>
    </h3>
    <p>
     如上所述，Mybatis核心工作就是
     <strong>
      帮助研发人员对数据库的读写操作，简化成面向对象操作。
     </strong>
    </p>
    <p>
     对于一个完全不懂Mybatis或者ORM的人来说，如果要实现读写数据库，该怎么实现？这个相信很多人都能回答：通过jdbc连接数据库、执行SQL、解析sql数据结果，就三个步骤完成。
    </p>
    <p>
     而Mybatis的核心原理逻辑更加细化，但整体也是类似以上三个步骤。毕竟大家目标一致，只是实现过程不同而已。
    </p>
    <p>
     接下来我们用一个非常简单的demo，就是通过Mybatis去读数据库数据，demo就只有几行代码，然后循序渐进了解Mybatis的核心工作原理，以及核心源码组件功能。
    </p>
    <pre><code>
package com.lading.mybaties;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class MyBatisDemo {
    public static void main(String[] args) throws IOException {
        InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        try (SqlSession sqlSession = sqlSessionFactory.openSession()) {
            sqlSession.selectOne("com.lading.mapper.UserMapper.getUserById", 1);
        }
    }
}</code></pre>
    <h4 id="3u98d" name="3.1-Mybatis%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">
     <strong>
      3.1 Mybatis核心功能处理流程
     </strong>
    </h4>
    <p>
     Mybatis整体框架，基于面向对象思想去实现与数据库表数据交互，它的核心步骤按顺序处理有以下五个。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="476" src="https://i-blog.csdnimg.cn/img_convert/009cc8d113adf53b8c9ea9ca05ba4e0f.png" width="1300"/>
    </p>
    <h5 id="frm1f" name="3.1.1-%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE-%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%A7%A3%E6%9E%90Mapper%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">
     <strong>
      3.1.1 解析配置-加载并解析Mapper配置文件
     </strong>
    </h5>
    <p>
     Mybatis通过SqlSessionFactoryBuilder来加载解析配置文件，并生SqlSessionFactory。
    </p>
    <p>
     <strong>
      SqlSessionFactoryBuilder是Mybatis的入口类
     </strong>
     ，类似tomcat的org.apache.catalina.startup.Bootstrap 启动类。
    </p>
    <p>
     比如我们项目只有Mybatis包、jdbc驱动，想要基于Mybatis去读写数据，首先需要通过以下三行代码去解析你的Mybatis相关配置文件，以及构建一个SqlSessionFactory，为后续创建数据库连接和读写做准备。
    </p>
    <pre><code>String resource = "mybatis-config.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre>
    <p>
     这三行代码里最后一行，看源码会发现，里面做了非常多的工作，细无巨细的把Mybatis管理配置文件、还有对象sql映射Mapper文件一一解析，包括properties、settings、environment、mapper等标签数据，以及业务相关的mapper文件里的resultMap、CURD 标签都会转成configration对象属性。
    </p>
    <p>
     <strong>
      最后利用解析结果数据存放的对象configration去实例化构建sql 会话工厂：
     </strong>
    </p>
    <p>
     new DefaultSqlSessionFactory(config)。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="261" src="https://i-blog.csdnimg.cn/img_convert/0bb01d7af2df578f59d10e98b0a2be14.png" width="626"/>
    </p>
    <h5 id="5nb58" name="3.1.2-%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5-%E5%88%9B%E5%BB%BASqlSessionFactory%E5%B9%B6%E8%8E%B7%E5%8F%96sqlSession%E8%BF%9E%E6%8E%A5">
     <strong>
      3.1.2 创建连接-创建SqlSessionFactory并获取sqlSession连接
     </strong>
    </h5>
    <p>
     解析完成配置文件后，Mybatis框架已经清晰知道Mybatis的基础配置信息、连接数据库的类型、用户密码信息，还有相关表映射关系。
    </p>
    <p>
     通过SqlSessionFactoryBuilder构建了session工厂实例SqlSessionFactory，看名字可以知道是通过建造者模式去实例化该对象。
    </p>
    <p>
     SqlSessionFactory是Mybatis的核心接口，它就是用来负责实现管理会话连接。
    </p>
    <p>
     在应用启动或者需要用到Mybatis读写数据时候，就生成一个实例DefaultSqlSessionFactory（它是session工厂接口唯一实现类）。
    </p>
    <p>
     SqlSessionFactory，通常在应用里是全局唯一并共享。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="118" src="https://i-blog.csdnimg.cn/img_convert/1ab1c2183851ae6bfa8bfc1ba841f584.png" width="686"/>
    </p>
    <p>
     然后通过会话工厂实例sqlSessionFactory去开启一个session连接：
    </p>
    <p>
     SqlSession sqlSession = sqlSessionFactory.openSession();
    </p>
    <p>
     SqlSession就是真正负责执行sql、并且管理事务的核心功能类，它底层是jdbc的连接。
    </p>
    <p>
     <strong>
      session每次用完就关闭，需要用的时候再次新建。但是Mybatis也有实现对应的连接池，如果配置了连接池就不会关闭
     </strong>
     。 Mybatis的连接池，后面出一篇文章专门分享Mybatis如何管理连接池。
    </p>
    <p>
     比如，通过session去查询用户ID=1的用户数据：
    </p>
    <pre><code>SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User ladingUser = userMapper.selectUserById(1);
System.out.println(ladingUser);</code></pre>
    <h5 id="873t2" name="3.1.3-%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5-Executor">
     <strong>
      3.1.3 执行SQL语句-Executor
     </strong>
    </h5>
    <p>
     在3.1.2里，看起来sql session执行了sql查询，但是DefaultSqlSession里面封装了一个Executor执行器。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="560" src="https://i-blog.csdnimg.cn/img_convert/86e0160997bd9e00a86f2a3f2654a9c0.png" width="841"/>
    </p>
    <p>
     Executor执行器，它是真正负责执行sql的打工人，里面有一个抽象类BaseExecutor，通过模板方法模式去共享自己的模板方法能力。另外三个子类去继承实现不同的db操作。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="195" src="https://i-blog.csdnimg.cn/img_convert/bb66ca32ad8cb664043aa9bd6ac09d46.png" width="812"/>
    </p>
    <p>
     这三个执行器的主要区别在于：
    </p>
    <p>
     SimpleExecutor，是一个最简单的执行器，每次执行sql都新建一个Statement对象。
    </p>
    <p>
     比如它里面的query方法源码：
    </p>
    <pre><code>@Override
public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, 
RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
  // JDBC中 Statement接口
  Statement stmt = null;
  try {
    // 获取到Configuration对象
    Configuration configuration = ms.getConfiguration();
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
    // 里面创建Connection代理对象，新增这个Statement
    stmt = prepareStatement(handler, ms.getStatementLog());
    // 执行查询，封装结果集
    return handler.query(stmt, resultHandler);
  } finally {
    closeStatement(stmt);
  }
}</code></pre>
    <p>
    </p>
    <p>
     ReuseExecutor，顾名思义是可复用执行器。特点是，复用预处器PreparedStatement。
    </p>
    <p>
     比如获取预处理Statement的方法源码：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="372" src="https://i-blog.csdnimg.cn/img_convert/1a16b117ec3099c9c531cc5b38da9fca.png" width="889"/>
    </p>
    <p>
     而BatchExcutor，叫做批量执行器，支持批量处理SQL语句。
    </p>
    <h5 id="51u7j" name="3.1.4-%E7%BB%93%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85-MapperStatement-&amp;-ResultSetHandler">
     <strong>
      3.1.4 结果数据封装 MapperStatement &amp; ResultSetHandler
     </strong>
    </h5>
    <p>
     结果数据封装逻辑里面相对繁琐。实际上在Excutor执行sql之前，也依赖mapperStatement去封装sql语句、sql的入参。底层通过jdbc connection执行sql后，通过ResultSetHandler和TypeHandler去解析封装结果数据。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="367" src="https://i-blog.csdnimg.cn/img_convert/a1e0c57852a7f35c1ba11def91a3aff5.png" width="1345"/>
    </p>
    <h5 id="uhff" name="3.1.5-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5">
     <strong>
      3.1.5 关闭连接
     </strong>
    </h5>
    <p>
     最后是关闭sqlsession，释放资源。如果是配置应用连接池，就是归还连接操作。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="299" src="https://i-blog.csdnimg.cn/img_convert/eeebae50738b17da3c1c524e443f5581.png" width="1229"/>
    </p>
    <h3 id="6dum8" name="%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7">
     <strong>
      四、核心功能特性
     </strong>
    </h3>
    <h4 id="5j7le" name="4.1-%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E7%81%B5%E6%B4%BB%E7%9A%84SQL">
     <strong>
      4.1 支持动态灵活的SQL
     </strong>
    </h4>
    <p>
     直接允许在mapper xml文件配置动态的sql。包括if、where、choose、when、foreach等多种动态条件。这个能力让Mybatis成功支持复杂关联sql处理。
    </p>
    <h4 id="1cgmp" name="4.2-%E8%AF%A6%E8%A7%A3%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">
     <strong>
      4.2 详解一级、二级缓存机制
     </strong>
    </h4>
    <p>
     Mybatis支持缓存，大幅提升数据库查询性能。默认开启一级缓存，关闭二级缓存。
    </p>
    <p>
     <strong>
      一级缓存：
     </strong>
     是基于sqlsession去实现，同一个sql session多次查询，会复用相同sql 的缓存结果。底层是通过把一个SQL的id、名称、入参计算得到一个唯一key，并和结果数据存入一个map里。
    </p>
    <p>
     当同一个sql session后面重复的查询，就会判断缓存是否有数据，如果有就直接返回，不再继续从数据库里查询数据，大幅提升单个sql session里的重复查询效率。
    </p>
    <p>
     如果在一个sql session里出现了update、delete、insert、或者commit、close session操作，就会自动去清空缓存，确保没有脏数据在Mybatis一级缓存里。
    </p>
    <p>
     该缓存默认开启。如果要关闭，可以通过flushCache=true去关闭。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="119" src="https://i-blog.csdnimg.cn/img_convert/632294959d596f9a7bc6f2e16dbe6a86.png" width="705"/>
    </p>
    <p>
     <strong>
      二级缓存：
     </strong>
     是基于mapper，也就是命名空间级别的缓存。相当于sqlSessionFactory级别，比一级缓存sqlSession更高一个层级。在同一个mapper下，所有session会话产生的缓存数据统一在mapper里命名空间管理。多个mapper的二级缓存互不干扰。
    </p>
    <p>
     二级缓存，默认是关闭的。可以在mapper里，新增cache标签就可以开启。
    </p>
    <pre><code>&lt;mapper namespace="com.lading.mapper.UserMapper"&gt;
&lt;!--启用二级缓存--&gt;
&lt;cache eviction="FIFO" flushInterval="30000" readOnly="true"/&gt;
&lt;/mapper&gt;</code></pre>
    <p>
    </p>
    <h5 id="3e28m" name="4.2.1-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%BC%80%E5%90%AF%EF%BC%9F">
     <strong>
      4.2.1 二级缓存为什么默认不开启？
     </strong>
    </h5>
    <p>
     之所以默认关闭，主要因为二级缓存可能有脏读。
    </p>
    <p>
     正因为所有session会话产生的缓存数据，统一在mapper里命名空间管理，
     <strong>
      多个mapper的二级缓存互不干扰
     </strong>
     。这里就可能导致研发人员如果在另一个mapper新增或者修改了数据，其他地方mapper缓存的数据就没有被自动更新，就会造成生产故障。
    </p>
    <p>
     当然这个Mybatis有提供相关配置，支持关联mapper同步被动去清空二级缓存，避免干扰。
    </p>
    <h4 id="e21i4" name="4.3-%E6%94%AF%E6%8C%81%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95">
     <strong>
      4.3 支持插件扩展
     </strong>
    </h4>
    <p>
     Mybatis允许研发人员在核心组件中插入自定义的逻辑，比如分页、拦截器、性能监控插件功能 。
    </p>
    <p>
     插件的开发，可以通过实现 org.apache.ibatis.pluginInterceptor接口，然后实现里面 intercept、plugin 和 setProperties方法来新增插件功能。
    </p>
    <p>
     比如增加一个执行sql监控功能。
    </p>
    <pre><code>package com.lading.mybaties;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;

import java.util.Properties;

public class TimeMonitorPlugin implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = invocation.proceed(); // 执行目标方法
        long endTime = System.currentTimeMillis();
        System.out.println("SQL 执行耗时: " + (endTime - startTime) + "ms");
        return result;
    }

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {
        // 可以设置拦截器的属性
    }
}</code></pre>
    <p>
    </p>
    <p>
     在 mybatis-config.xml 文件中注册自定义拦截器：
    </p>
    <pre><code>&lt;plugins&gt;
&lt;plugin interceptor="lading.mybaties.TimeMonitorPlugin"/&gt;
&lt;/plugins&gt;</code></pre>
    <p>
     sql查询的时候就会打印sql执行时间。
    </p>
    <h4 id="viuk" name="4.4-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD">
     <strong>
      4.4 延迟加载
     </strong>
    </h4>
    <p>
     可以控制关联对象，在需要用到的时候才去加载。比如1-n的场景，一个学生有多门课程信息。查询一个学生基本信息的时候，如果没有用到课程列表，就不需要在关联查询里把课程列表页拉出去，提升了查询效率。
    </p>
    <pre><code>//fetchType=lazy开启延迟加载
&lt;association property="xxx" fetchType="lazy"&gt;</code></pre>
    <p>
     这个延迟加载功能，和Springboot通过@lazy注解去解决循环依赖问题，有类似异曲同工的作用。
    </p>
    <h4 id="brdg6" name="4.5-SQL%E6%B3%A8%E8%A7%A3">
     <strong>
      4.5 SQL注解
     </strong>
    </h4>
    <p>
     MyBatis 也支持使用注解来配置 SQL 映射，从而简化 XML 配置，可以实现零xml配置文件去操作数据库数据。常用的注解包括常规的CURD：
    </p>
    <p>
     @Select
    </p>
    <p>
     @Insert
    </p>
    <p>
     @Update
    </p>
    <p>
     @Delete
    </p>
    <p>
     还有，@Results结果映射注解。
    </p>
    <p>
     比如通过名称去查询用户：
    </p>
    <pre><code>@Select("SELECT * FROM user WHERE name = #{name}")
@Results({
    @Result(property = "id", column = "id"),
    @Result(property = "name", column = "name")
})
User selectUserByName(String name);</code></pre>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6161353330353132332f:61727469636c652f64657461696c732f313436323336353039" class_="artid" style="display:none">
 </p>
</div>


