---
layout: post
title: "汇编基础2"
date: 2025-09-09T18:11:57+0800
description: "本文介绍了ARM汇编中的函数调用、指针操作和异常处理机制。函数调用通过BL指令实现，参数通过R0-R3传递，超过4个参数需压栈处理。指针操作使用LDR/STR指令进行内存读写。异常处理部分详细说明了ARM的异常向量表结构，包括复位、未定义指令、SWI中断等8种异常类型及其处理流程，重点展示了通过修改CPSR寄存器实现模式切换的方法。文中还提供了完整的启动代码示例，包含堆栈初始化、模式设置和异常处理框架的实现。"
keywords: "汇编基础2"
categories: ['未分类']
tags: ['汇编']
artid: "151352876"
arturl: "https://blog.csdn.net/y08270130/article/details/151352876"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151352876
    alt: "汇编基础2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151352876
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151352876
cover: https://bing.ee123.net/img/rand?artid=151352876
image: https://bing.ee123.net/img/rand?artid=151352876
img: https://bing.ee123.net/img/rand?artid=151352876
---



# 汇编基础2

## 1.函数调用

> ```
>
> fun0
> 	mov r4, #100
> 	bx lr
>
> get_MaxNum
> 	cmp r0, r1
> 	stmfd sp!, {r0-r12, lr}    //入栈
> 	bl fun0                    //调用fun0函数
> 	ldmfd sp!, {r0-r12, lr}    //出栈
> 	movge r3, r0
> 	movlt r3, r1
> 	bx lr
> main
> 	ldr sp, =0x40001000
>
> 	mov r0, #100
> 	mov r1, #200
> 	mov r2, #100
> 	stmfd sp!, {r0-r12, lr}
> 	bl get_MaxNum	
> 	ldmfd sp!, {r0-r12, lr}
> ```

## 2.指针

> ```
>
> c语言：
> unsigned int *p
>
> 汇编：
> ldr r1, =0x40000fff //给的地址
> ldr r3，=0x11223344 //给的值
>
> str r3, [r1]    //将r3存储到r1里面
> ldr r0, [r1]    //将r1指向的值给到r0
> ```

## 3.调用.c文件函数

> ```
>
> .c文件：
> extern int fun(int a, int b)
> {
>     return a+b;
> }
>
> .s文件
>
>     ldr sp, =0x40001000
>     import fun            //添加函数
>
>     stmdf sp!, {r0-r12, lr}
>     mov r0, #10            ;参数a = 10
>     mov r1, #20            ;参数b = 20
>     mov r2, #30            
>     bl fun                //调用函数
>     ldmdf sp!, {r0-r12, lr}
>
> ```
>
> **注意：**
>
> 1.a和b的参数取决于r0和r1，而与r2没关系，若是给多个寄存器赋值，也只会按顺序传入参数
>
> 2.若是传入的参数大于四个就得进行压栈
>
> ```
>
> .c文件：
> extern int fun(int a, int b, int c, int d, int e)
> {
>     return a+b+c+d+e;
> }
>
> .s文件
>
>     ldr sp, =0x40001000
>     import fun            //添加函数
>
>     stmdf sp!, {r0-r12, lr}
>     mov r0, #10            ;参数a = 10
>     mov r1, #20            ;参数b = 20
>     mov r2, #30
>     mov r3, #40
>     mov r4, #50
>     stmdf sp!, {r4}            
>     bl fun                //调用函数
>     ldmdf sp!, {r4}
>     ldmdf sp!, {r0-r12, lr}
>
> ```

## 4.arm启动代码

> ```
>
> 	preserve8
> 	area reset, code, readonly
> 	code32
> 	entry
>
> 	ldr pc, =start_hander
> 	ldr pc, =undefine_hander
> 	ldr pc, =software_hander
> 	ldr pc, =prefetch_hander
> 	ldr pc, =data_hander
> 	nop
> 	ldr pc, =irq_hander
> 	ldr pc, =fiq_hander        //ARM 架构的异常向量表实现
>
> undefine_hander
> 	b undefine_hander
>
> 	import software_vector    //添加.c文件里面的software_vector函数
> software_hander
> 	stmfd sp!, {r0-r12, lr}
> 	bl software_vector        //调用.c文件里面的software_vector函数
> 	ldmfd sp!, {r0-r12, lr}
> 	bx lr
>
> prefetch_hander
> 	b prefetch_hander
>
> data_hander
> 	b data_hander
>
> irq_hander
> 	b irq_hander
>
> fiq_hander
> 	b fiq_hander
>
> 	export asm_swi_fun
> asm_swi_fun
> 	swi #7    //软件中断  立即数执行对应服务
> 	bx lr
>
> start_hander                //上电或者复位的处理函数
> 	ldr sp, =0x40001000     //初始化sp
> 	import main             //添加.c文件的main函数
> 	msr r0, cpsr            //读取当前程序状态寄存器（CPSR）到 R0
> 	bic r0, r0, #(0x1f << 0)//清除 CPSR 的“模式位”（低 5 位，0x1f = 0b11111）
> 	bic r0, r0, #(1 << 7)   //清除 CPSR 的“中断禁止位 I”（第 7 位），允许 IRQ 中断
> 	orr r0, r0, #(0x10 << 0)//设置“模式位”为 User 模式（0x10 = 0b10000，对应 User 模式）
> 	msr cpsr_c, r0          //将修改后的 R0 写入 CPSR 的“控制位域”（cpsr_c 表示只更新控制位）
>
> 	ldr sp, =0x40001000
> 	sub sp, sp, #1024
>
> 	b main
>
> 	end
> ```

### 4.1 ARM的异常向量表

> | 异常向量地址 | 异常类型 | 代码中的处理函数 | 作用 |
> | --- | --- | --- | --- |
> | 0x00000000 | 复位异常（Reset） | `start_hander` | 系统上电 / 复位时执行，初始化硬件 |
> | 0x00000004 | 未定义指令异常 | `undefine_hander` | 执行无效指令时触发（如未实现指令） |
> | 0x00000008 | 软件中断（SWI） | `software_hander` | 触发 SWI 时跳转到系统调用处理 |
> | 0x0000000C | 预取指异常 | `prefetch_hander` | 指令预取失败（如地址无效） |
> | 0x00000010 | 数据访问异常 | `data_hander` | 数据读写失败（如越界、无权限） |
> | 0x00000014 | 保留（Reserved） | `nop`（空指令） | ARM 架构预留，暂不使用 |
> | 0x00000018 | 外部中断（IRQ） | `irq_hander` | 外部硬件触发中断（如按键、定时器） |
> | 0x0000001C | 快速中断（FIQ） | `fiq_hander` | 高优先级中断（如紧急硬件事件） |



