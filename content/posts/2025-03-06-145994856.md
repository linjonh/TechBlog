---
layout: post
title: "BUUCTF逆向刷题笔记1-12"
date: 2025-03-06 20:53:29 +0800
description: "请见小库里的blog。"
keywords: "BUUCTF逆向刷题笔记（1-12）"
categories: ['未分类']
tags: ['笔记']
artid: "145994856"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145994856
    alt: "BUUCTF逆向刷题笔记1-12"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145994856
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145994856
cover: https://bing.ee123.net/img/rand?artid=145994856
image: https://bing.ee123.net/img/rand?artid=145994856
img: https://bing.ee123.net/img/rand?artid=145994856
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     BUUCTF逆向刷题笔记（1-12）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     easyre、内涵的软件、xor、不一样的flag：
    </h2>
    <p>
     <a href="https://blog.csdn.net/zzh258369/article/details/144326705?spm=1001.2014.3001.5502" title="buuctf reverse部分题解（实时更新）_reverse 题解-CSDN博客">
      buuctf reverse部分题解（实时更新）_reverse 题解-CSDN博客
     </a>
    </p>
    <p>
     请见小库里的blog。
    </p>
    <h2>
     reverse1
    </h2>
    <p>
     查壳发现没有，而且是64位
    </p>
    <p>
     <img alt="" height="237" src="https://i-blog.csdnimg.cn/direct/ca96f3822ef047dea50acb3780fbbe91.png" width="670"/>
    </p>
    <p>
     粗略改一下部分函数名，看看主要逻辑。
    </p>
    <p>
     <img alt="" height="901" src="https://i-blog.csdnimg.cn/direct/ce6907b7b49c434186ae81e4b359a0f3.png" width="1006"/>
    </p>
    <p>
     第一个for循环暂时不知道干什么的，但是一眼就看到最后几行的strcmp。 看来就是str1和str2的比较，str1是我们自己输入的，那么主要就是分析str2。第二个for循环明显是把o变成0（需要按r转换一下字符）。双击str2就知道str2的内容。
    </p>
    <h2>
     reverse2
    </h2>
    <p>
     查出来是64位。可以放虚拟机运行一下看看，进去就是直接输入flag。
    </p>
    <p>
     <img alt="" height="220" src="https://i-blog.csdnimg.cn/direct/721d41fd9ad84dccbb9fc28c5940ca61.png" width="845"/>
    </p>
    <p>
    </p>
    <p>
     我们拖进IDA看看。
    </p>
    <p>
     <img alt="" height="688" src="https://i-blog.csdnimg.cn/direct/cba56fa26642449680dc6b2f0bf0b3f0.png" width="950"/>
    </p>
    <p>
     一样的字符替换逻辑。SHIFT+F12就可以看到原始的flag。 替换即可。
    </p>
    <h2>
     新年快乐
    </h2>
    <p>
     光看代码什么也看不出，看看能不能通过动调拿到信息。
    </p>
    <p>
     <img alt="" height="682" src="https://i-blog.csdnimg.cn/direct/3b2447a22f424687950779b1aa57a91b.png" width="675"/>
    </p>
    <p>
     题目上说就是一个字符串！ 在看了一下发现有壳，忘记脱壳了！！！脱完壳直接就看出来答案了，服了。
    </p>
    <h2>
     reverse3
    </h2>
    <p>
     查壳，是32位。
    </p>
    <p>
     <img alt="" height="234" src="https://i-blog.csdnimg.cn/direct/37cdd8fb9f7c406a94f6677739961e0c.png" width="764"/>
    </p>
    <p>
     看一下关键代码。看样子是输入了一个字符串，经过sub_4110BE函数处理之后，又获得了一个Destination字符串，并且来比较。那么我们看看这个函数的逻辑是什么。点进去发现一个全局变量，有如下编码表。怀疑是base64编码。
    </p>
    <p>
     <img alt="" height="67" src="https://i-blog.csdnimg.cn/direct/f9ec5293a52d48b3a171ff17a2648ffb.png" width="823"/>
    </p>
    <p>
     <img alt="" height="549" src="https://i-blog.csdnimg.cn/direct/b9298666c86d4a07a5959a8cf4873e3e.png" width="611"/>
    </p>
    <p>
     注意有个for循环，估计是将这个Destination字符串前11位每一位都加了1，我们只需要搞个脚本给他返回去即可。Str2就是我们需要比较的字符串，其实我们已经有这个字符串的值，所以写脚本也是比较好写的。然后base解码即可。
    </p>
    <pre><code class="language-python">import base64
a='e3nifIH9b_C@n@dH'
c=''
for i in range(0,len(a)):
    c+=(chr(ord(a[i])-i))
print('base64:'+c)
c=bytes(c,encoding='utf-8')
mydecode=base64.b64decode(c)
print('flag'+str(mydecode,encoding='utf-8'))</code></pre>
    <p>
     上述代码运行结果：
    </p>
    <p>
     <img alt="" height="58" src="https://i-blog.csdnimg.cn/direct/bae7564e31a84afe8b539dfcb057ba1a.png" width="263"/>
    </p>
    <h2>
     helloword
    </h2>
    <p>
     <img alt="" height="465" src="https://i-blog.csdnimg.cn/direct/9f6ff79f41ef40ec929e12dad3ac81e4.png" width="305"/>
    </p>
    <p>
     这是一个apk文件，进去啥玩意都没有。所以猜测藏在了安装包里了flag。
    </p>
    <p>
     <img alt="" height="1022" src="https://i-blog.csdnimg.cn/direct/ac4fdb52e6e3478d8ad70090f3db54e7.png" width="1420"/>
    </p>
    <p>
     还算简单，mainActivity里面就是flag。
    </p>
    <h2 style="background-color:transparent">
     SimpleRev
    </h2>
    <p>
     这是一个64位ELF文件。下面是关键代码。
    </p>
    <p>
     有一个考点，IDA会把内存的数据自动转为大端序，有时候伪代码却不会，所以要谨慎小心！
    </p>
    <pre><code class="language-cpp">unsigned __int64 Decry()
{
  char input; // [rsp+Fh] [rbp-51h]
  int v2; // [rsp+10h] [rbp-50h]
  int v3; // [rsp+14h] [rbp-4Ch]
  int i; // [rsp+18h] [rbp-48h]
  int keylen; // [rsp+1Ch] [rbp-44h]
  char src[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h]
  int v8; // [rsp+30h] [rbp-30h]
  __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF
  int v10; // [rsp+50h] [rbp-10h]
  unsigned __int64 v11; // [rsp+58h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  *(_QWORD *)src = 0x534C43444ELL;
  v7 = 0LL;
  v8 = 0;
  v9[0] = 0x776F646168LL;
  v9[1] = 0LL;
  v10 = 0;
  text = join(key3, (const char *)v9);          // kills--key3
  strcpy(key, key1);                            // adsfk key1
  strcat(key, src);
  v2 = 0;
  v3 = 0;
  getchar();
  keylen = strlen(key);
  for ( i = 0; i &lt; keylen; ++i )
  {
    if ( key[v3 % keylen] &gt; '@' &amp;&amp; key[v3 % keylen] &lt;= 'Z' )
      key[i] = key[v3 % keylen] + 32;
    ++v3;
  }
  printf("Please input your flag:");
  while ( 1 )
  {
    input = getchar();
    if ( input == '\n' )
      break;
    if ( input == 32 )
    {
      ++v2;
    }
    else
    {
      if ( input &lt;= '`' || input &gt; 'z' )
      {
        if ( input &gt; '@' &amp;&amp; input &lt;= 'Z' )
        {
          str2[v2] = (input - 39 - key[v3 % keylen] + 97) % 26 + 97;
          ++v3;
        }
      }
      else
      {
        str2[v2] = (input - 39 - key[v3 % keylen] + 97) % 26 + 97;
        ++v3;
      }
      if ( !(v3 % keylen) )
        putchar(32);
      ++v2;
    }
  }
  if ( !strcmp(text, str2) )
    puts("Congratulation!\n");
  else
    puts("Try again!\n");
  return __readfsqword(0x28u) ^ v11;
}</code></pre>
    <p>
     这就是一个自己写的算法，接下来进行仔细分析。
    </p>
    <p>
     首先，在末尾可以看出比较的是text，所以我们先给text求出来。程序自定义了一个join函数，实际上就是拼接俩字符串。这也是个小端序文件要注意。此外，v9应该理解为字符串，因为其最后一个是0，相当于0x0。编写脚本求出text先。
    </p>
    <p>
     <img alt="" height="172" src="https://i-blog.csdnimg.cn/direct/93ac7601a55043f88ab4d42b9ba02687.png" width="350"/>
    </p>
    <p>
     看程序代码，str2明显是需要求出来。str2会和key相等。根据算法来看，我们应该先求出key，再考虑具体的算法。所以接下来计算key。
    </p>
    <p>
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/108568cce57e4174a8ecef2315771c1a.png" width="327"/>
    </p>
    <p>
     程序这段代码实现了对key的进一步操作，就是转为小写。（注意ASCII码+32）v3只是一个计数器罢了。最终key是adsfkndcls。
    </p>
    <p>
     <img alt="" height="158" src="https://i-blog.csdnimg.cn/direct/2ea70ff8c99c43c9804cae8abe647459.png" width="687"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     接下来就可以看看是如何利用key来生成str2的。
    </p>
    <p>
     <img alt="" height="661" src="https://i-blog.csdnimg.cn/direct/ae13ab70364e4b02a3d746c920412c46.png" width="931"/>
    </p>
    <p>
     <span style="color:#0d0016">
      这看似是一个死循环，其实根据putchar(32)来看只要v3和keylen相等就可以跳过了，也就是说每一次循环v2都++，v2控制的是str里面的字符串。而v3则是一个计数器，只要数值超过keylen就会break了。str2我们也知道等于text，key我们也知道了。后面的%26+97相当于转为小写而已。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      我们可以用爆破的思路（因为有%26）可以见
     </span>
     <a href="https://blog.csdn.net/2303_80796023/article/details/140237215" title="Buuctf之SimpleRev做法-CSDN博客">
      Buuctf之SimpleRev做法-CSDN博客
     </a>
    </p>
    <p>
     下面给出脚本。
    </p>
    <pre><code class="language-cpp"> 
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int main()
{
	char key[] = "adsfkndcls";
	char text[] = "killshadow";
	for (int i = 0; i &lt; 10; i++)   //10代表的是key的长度
	{
		for (int j = 65; j &lt;= 122; j++)
		{
			//依次遍历爆破，把控好j的取值
			if (j &gt;= 'A' &amp;&amp; j &lt;= 'Z' || j &gt;= 'a' &amp;&amp; j &lt;= 'z')
			{
				if (text[i] == (j - 39 - key[i ] + 97) % 26 + 97)
				{
					printf("%c", j);
					break;
				}
			}
		}
	}
	return 0;
}</code></pre>
    <p>
     python:
     <br/>
    </p>
    <pre><code class="language-python">key = "adsfkndcls"
text = "killshadow"

i=0
# 遍历 text 中的每个字符
while(i&lt;10):
    # 当 j 小于等于 122 时进行循环
    j = 65
    while j &lt;= 122:
        # 检查 j 是否为字母的 ASCII 码值
        if (ord('A') &lt;= j &lt;= ord('Z')) or (ord('a') &lt;= j &lt;= ord('z')):
            # 计算比较的值
            compare_char = chr((j - 39 - ord(key[i]) + 97) % 26 + 97)
            # 如果比较的值等于 text 中的当前字符
            if text[i] == compare_char:
                # 打印 j 对应的字符
                print(chr(j),end='')
                break
        # j 加 1
        j += 1
    i+=1</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h2>
     [GXYCTF2019]luck_guy
    </h2>
    <p>
     直接进入关键函数看看。
    </p>
    <pre><code class="language-cpp">unsigned __int64 get_flag()
{
  unsigned int v0; // eax
  int i; // [rsp+4h] [rbp-3Ch]
  int j; // [rsp+8h] [rbp-38h]
  __int64 s; // [rsp+10h] [rbp-30h] BYREF
  char v5; // [rsp+18h] [rbp-28h]
  unsigned __int64 v6; // [rsp+38h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v0 = time(0LL);
  srand(v0);
  for ( i = 0; i &lt;= 4; ++i )
  {
    switch ( rand() % 200 )
    {
      case 1:
        puts("OK, it's flag:");
        memset(&amp;s, 0, 0x28uLL);
        strcat((char *)&amp;s, f1);
        strcat((char *)&amp;s, &amp;f2);
        printf("%s", (const char *)&amp;s);
        break;
      case 2:
        printf("Solar not like you");
        break;
      case 3:
        printf("Solar want a girlfriend");
        break;
      case 4:
        s = 0x7F666F6067756369LL;
        v5 = 0;
        strcat(&amp;f2, (const char *)&amp;s);
        break;
      case 5:
        for ( j = 0; j &lt;= 7; ++j )
        {
          if ( j % 2 == 1 )
            *(&amp;f2 + j) -= 2;
          else
            --*(&amp;f2 + j);
        }
        break;
      default:
        puts("emmm,you can't find flag 23333");
        break;
    }
  }
  return __readfsqword(0x28u) ^ v6;
}</code></pre>
    <p>
     首先题目是一个随机数生成，我们肯定不可能赌运气一遍遍地运行的。分析一下switch函数的几个子项，case 1直接显示出来了flag。首先f1已经知道了，主要就是看f2怎么来搞得。主要看情况4和情况5.他们应该控制着f2。
    </p>
    <p>
     <img alt="" height="330" src="https://i-blog.csdnimg.cn/direct/0aea26ca07cd4391aca345e5033d4e5a.png" width="448"/>
    </p>
    <p>
     首先要注意，checksec检查出来是小端序，所以s这个应该是小端序储存，也就是阅读习惯与咱们是相反的。然后f2被赋值为s。5应该是在4之后对f2进行操作。我们可以根据这个算法写出python脚本。得到结果和F1拼接即可。
    </p>
    <pre><code class="language-python">s = [0x69, 0x63, 0x75, 0x67, 0x60, 0x6F, 0x66, 0x7F]
# 手动转换一下，因为本身是小端序储存，转到python顺序需要更改。
result = []
for i, value in enumerate(s):
    if i % 2 == 1:
        result.append(chr(value - 2))
    else:
        result.append(chr(value - 1))

# 打印结果
result_str = ''.join(result)
print(result_str)</code></pre>
    <h2>
     Java逆向解密
    </h2>
    <p>
     反编译class看看：
    </p>
    <p>
     <img alt="" height="897" src="https://i-blog.csdnimg.cn/direct/05612b60329c464fb8c133d7ca656cee.png" width="1712"/>
    </p>
    <p>
     分析一下，最下面是一个if验证输入的内容是否和KEYlist相等。main 方法应该就是一个输入了。我们主要看Encrypt。看到主要算法估计是c加上个@的ascii码再异或32.这样的话思路就很清晰了。
    </p>
    <pre><code class="language-python">a=[180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65]
b=''
for i in a:
    b+=chr((i^32)-ord('@'))
    #i^32需要加括号 因为运算优先级的问题
print(b)</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f776c6d743636362f:61727469636c652f64657461696c732f313435393934383536" class_="artid" style="display:none">
 </p>
</div>


