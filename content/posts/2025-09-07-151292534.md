---
layout: post
title: "一个Java的main方法在JVM中的执行流程"
date: 2025-09-07T18:22:08+0800
description: "​​​​：你执行。Java编译器将源代码编译成JVM能理解的字节码，存储在文件中。这个文件包含了一个​​，里面有各种符号引用，比如这个字符串的字面量、Systemoutprintln等类名、方法名和字段名。​​：你执行。操作系统会启动JVM进程。​​：JVM通过​​ 来加载HelloWorld类。​​：首先，启动类加载器会去加载JAVA_HOME/lib下的核心类库，如java.lang包（包括ObjectStringSystem等）。​​：然后，应用程序类加载器开始工作，它在你的CLASSPATH。"
keywords: "一个Java的main方法在JVM中的执行流程"
categories: ['Jvm']
tags: ['开发语言', 'Jvm', 'Java']
artid: "151292534"
arturl: "https://blog.csdn.net/2301_77574331/article/details/151292534"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151292534
    alt: "一个Java的main方法在JVM中的执行流程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151292534
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151292534
cover: https://bing.ee123.net/img/rand?artid=151292534
image: https://bing.ee123.net/img/rand?artid=151292534
img: https://bing.ee123.net/img/rand?artid=151292534
---



# 一个Java的main方法在JVM中的执行流程



一个Java的`main`方法在JVM中的执行流程可以分为​**​四大阶段​**​：​**​加载 -> 链接 -> 初始化 -> 执行​**​。

```

// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        String message = "Hello, JVM!";
        System.out.println(message);
    }
}
```

## 第一阶段：加载 (Loading)

​**​目标：找到并加载类的二进制数据。​**​

1. 1.

   ​**​编译​**​：你执行 `javac HelloWorld.java`。Java编译器将源代码编译成JVM能理解的字节码，存储在 `HelloWorld.class`文件中。这个文件包含了一个​**​类常量池（Constant Pool）​**​，里面有各种符号引用，比如 `Hello, JVM!`这个字符串的字面量、`System`/`out`/`println`等类名、方法名和字段名。
2. 2.

   ​**​启动JVM​**​：你执行 `java HelloWorld`。操作系统会启动JVM进程。
3. 3.

   ​**​寻找类​**​：JVM通过​**​类加载器（ClassLoader）​**​ 来加载 `HelloWorld`类。

   * •

     ​**​ Bootstrap ClassLoader​**​：首先，启动类加载器会去加载JAVA_HOME/lib下的核心类库，如 `java.lang`包（包括`Object`, `String`, `System`等）。
   * •

     ​**​ Application ClassLoader​**​：然后，应用程序类加载器开始工作，它在你的`CLASSPATH`（默认是当前目录）下寻找 `HelloWorld.class`文件。
4. 4.

   ​**​创建Class对象​**​：JVM成功读取 `HelloWorld.class`的二进制字节流后，会将其转换为​**​方法区（Metaspace）​**​ 中的运行时数据结构，并同时在 ​**​Java堆（Heap）​**​ 中创建一个 `java.lang.Class`对象，作为方法区这些数据的访问入口。这个 `Class`对象封装了类的所有元信息（如方法、字段等）。

---

## 第二阶段：链接 (Linking)

​**​目标：将加载到方法区的二进制数据合并到JVM运行时状态中。​**​ 此阶段细分为三步：

1. 1.

   ​**​验证 (Verification)​**​：JVM会严格检查 `HelloWorld.class`文件的格式、元数据、字节码等是否符合规范且不会危害JVM自身安全。这是一个非常重要的安全屏障。
2. 2.

   ​**​准备 (Preparation)​**​：JVM为​**​类的静态变量（static variables）​**​ 在方法区分配内存并设置​**​初始值​**​（零值）。注意，这里是初始值，不是代码中赋的值。

   * •

     例如，如果类里有 `static int value = 123;`，在准备阶段，`value`会被赋值为 `0`。真正的赋值 `123`要等到后面的初始化阶段。
3. 3.

   ​**​解析 (Resolution)​**​：JVM将​**​类常量池​**​中的​**​符号引用（Symbolic References）​**​ 替换为​**​直接引用（Direct References）​**​。

   * •

     ​**​符号引用​**​：就是一种约定好的形式来表示引用的目标，比如 `java/lang/System.out`。
   * •

     ​**​直接引用​**​：就是一个直接指向目标的指针、偏移量或句柄。
   * •

     例如，在这一步，`System.out`这个符号引用会被解析为 `java.io.PrintStream`对象在堆内存中的实际地址。

---

## 第三阶段：初始化 (Initialization)

​**​目标：执行类的构造器 `<clinit>()`方法，为静态变量赋予程序设定的初始值。​**​

1. 1.

   到了这一步，JVM才开始真正执行你写在Java代码中的静态语句和静态变量赋值。
2. 2.

   JVM会收集类中的所有​**​静态变量的赋值动作​**​和​**​静态代码块（static {}）​**​，合并生成一个唯一的 `<clinit>()`方法。
3. 3.

   JVM会确保 `<clinit>()`方法在多线程环境下被正确地加锁同步执行，所以类初始化是线程安全的。
4. 4.

   在我们的 `HelloWorld`例子中，没有静态变量和静态代码块，所以 `<clinit>()`方法是空的，但这一步依然会发生。

---

## 第四阶段：执行 (Execution & Runtime)

​**​目标：创建线程，执行字节码。​**​

1. 1.

   ​**​主线程​**​：JVM会为 `main`方法创建一个​**​主线程​**​。该线程拥有自己的​**​程序计数器（PC）​**​ 和 ​**​Java虚拟机栈（JVM Stack）​**​。
2. 2.

   ​**​栈帧​**​：线程的每个方法调用都会在虚拟机栈中创建一个​**​栈帧（Stack Frame）​**​，用于存储​**​局部变量表​**​、​**​操作数栈​**​、​**​动态链接​**​、​**​方法返回地址​**​等信息。`main`方法是程序入口，所以第一个被压入栈的栈帧就是 `main`方法的栈帧。
3. 3.

   ​**​执行引擎​**​：JVM的​**​执行引擎​**​开始解释执行 `main`方法栈帧中的字节码。

   * •

     `String message = "Hello, JVM!";`

     + •

       执行引擎遇到字面量 `"Hello, JVM!"`时，会去​**​字符串常量池（String Table，位于堆中）​**​ 中寻找。如果找不到，就在堆中创建一个String对象并将其引用驻留在常量池中，然后将该引用存入 `main`栈帧的局部变量表 `message`中。
   * •

     `System.out.println(message);`

     + •

       执行引擎通过之前在​**​解析阶段​**​已经转换好的​**​直接引用​**​，快速地找到 `System.out`对应的 `PrintStream`对象。
     + •

       然后调用该对象的 `println`方法，将局部变量 `message`的引用（指向堆中的String对象）作为参数传入。
4. 4.

   ​**​本地方法调用​**​：`println`方法底层是一个​**​本地方法（Native Method）​**​，调用的是操作系统本身的IO能力，将字符串输出到控制台。
5. 5.

   ​**​方法返回​**​：`main`方法执行完毕，其栈帧从虚拟机栈中弹出。主线程结束。
6. 6.

   ​**​JVM退出​**​：所有​**​非守护线程​**​都结束后，JVM进程终止。



