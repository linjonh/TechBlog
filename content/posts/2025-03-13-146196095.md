---
layout: post
title: "Python函数式编程"
date: 2025-03-13 00:00:00 +0800
description: "函数式编程（Functional Programming, FP）是一种编程范式，强调通过纯函数、不可变数据和声明式风格来构建程序。Python 虽然不是纯函数式语言，但提供了丰富的函数式编程工具。"
keywords: "Python:函数式编程"
categories: ['未分类']
tags: ['算法', '开发语言', 'Python']
artid: "146196095"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146196095
    alt: "Python函数式编程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146196095
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146196095
cover: https://bing.ee123.net/img/rand?artid=146196095
image: https://bing.ee123.net/img/rand?artid=146196095
img: https://bing.ee123.net/img/rand?artid=146196095
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python:函数式编程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      函数式编程（Functional Programming, FP）是一种编程范式，强调通过纯函数、不可变数据和声明式风格来构建程序。Python 虽然不是纯函数式语言，但提供了丰富的函数式编程工具。(简单来说是，函数约等于模块功能）
     </p>
    </blockquote>
    <hr/>
    <h4>
     ​
     <strong>
      一、函数式编程的核心原则
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       ​
       <strong>
        纯函数（Pure Functions）​
       </strong>
      </p>
      <ul>
       <li>
        相同输入永远得到相同输出。
       </li>
       <li>
        无副作用（不修改外部状态，如全局变量）。
       </li>
       <li>
        ​
        <strong>
         示例
        </strong>
        ：
        <code>
         add = lambda x, y: x + y
        </code>
        是纯函数。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        不可变数据（Immutable Data）​
       </strong>
      </p>
      <ul>
       <li>
        数据一旦创建不可修改，任何操作生成新数据。
       </li>
       <li>
        ​
        <strong>
         示例
        </strong>
        ：Python 的元组（Tuple）是不可变的。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        函数是一等对象（First-Class Functions）​
       </strong>
      </p>
      <ul>
       <li>
        函数可以像变量一样传递、赋值和返回。
       </li>
       <li>
        ​
        <strong>
         示例
        </strong>
        ：将函数作为参数传给另一个函数。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        声明式风格（Declarative Style）​
       </strong>
      </p>
      <ul>
       <li>
        关注“做什么”而非“如何做”（对比命令式编程）。
       </li>
       <li>
        ​
        <strong>
         示例
        </strong>
        ：用
        <code>
         map
        </code>
        替代
        <code>
         for
        </code>
        循环。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     ​
     <strong>
      二、Python 中的函数式工具
     </strong>
    </h4>
    <h5>
     1. ​
     <strong>
      Lambda 函数
     </strong>
    </h5>
    <ul>
     <li>
      匿名函数，用于简单操作。
     </li>
     <li>
      ​
      <strong>
       语法
      </strong>
      ：
      <code>
       lambda 参数: 表达式
      </code>
     </li>
     <li>
      ​
      <strong>
       示例
      </strong>
      ：
      <pre><code>square = lambda x: x**2
print(square(3))  # 输出 9</code></pre>
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      高阶函数（Higher-Order Functions）​
     </strong>
    </h5>
    <ul>
     <li>
      接收函数作为参数或返回函数的函数。
     </li>
     <li>
      ​
      <strong>
       常用高阶函数
      </strong>
      ：
      <ul>
       <li>
        ​
        <code>
         map(func, iterable)
        </code>
        <br/>
        将函数应用到每个元素，返回迭代器。
        <pre><code>nums = [1, 2, 3]
squared = map(lambda x: x**2, nums)
print(list(squared))  # [1, 4, 9]</code></pre>
       </li>
       <li>
        ​
        <code>
         filter(func, iterable)
        </code>
        <br/>
        过滤符合条件的元素。
        <pre><code>evens = filter(lambda x: x % 2 == 0, nums)
print(list(evens))  # [2]</code></pre>
       </li>
       <li>
        ​
        <code>
         reduce(func, iterable, initial)
        </code>
        <br/>
        累积计算结果（需从
        <code>
         functools
        </code>
        导入）。
        <pre><code>from functools import reduce
sum_all = reduce(lambda acc, x: acc + x, nums, 0)
print(sum_all)  # 6</code></pre>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     3. ​
     <strong>
      列表推导式与生成器表达式
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       列表推导式
      </strong>
      ​（替代
      <code>
       map
      </code>
      和
      <code>
       filter
      </code>
      ）：
      <pre><code>squared = [x**2 for x in nums if x &gt; 1]  # [4, 9]</code></pre>
     </li>
     <li>
      ​
      <strong>
       生成器表达式
      </strong>
      ​（惰性求值，节省内存）：
      <pre><code>gen = (x**2 for x in nums)
print(next(gen))  # 1</code></pre>
     </li>
    </ul>
    <h5>
     4. ​
     <strong>
      闭包（Closure）​
     </strong>
    </h5>
    <ul>
     <li>
      函数捕获并携带外部作用域的变量。
     </li>
     <li>
      ​
      <strong>
       示例
      </strong>
      ：
      <pre><code>def make_adder(n):
    def adder(x):
        return x + n  # 捕获外部变量 n
    return adder

add5 = make_adder(5)
print(add5(3))  # 8</code></pre>
     </li>
    </ul>
    <h5>
     5. ​
     <strong>
      装饰器（Decorators）​
     </strong>
    </h5>
    <ul>
     <li>
      修改或增强函数的行为。
     </li>
     <li>
      ​
      <strong>
       示例
      </strong>
      ：记录函数执行时间：
      <pre><code>import time

def timer(func):
    def wrapper(*args, ​**kwargs):
        start = time.time()
        result = func(*args, ​**kwargs)
        end = time.time()
        print(f"{func.__name__} 执行耗时: {end - start:.2f}秒")
        return result
    return wrapper

@timer
def heavy_computation():
    time.sleep(1)

heavy_computation()  # 输出耗时</code></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      三、函数式编程的进阶工具
     </strong>
    </h4>
    <h5>
     1. ​
     <code>
      functools
     </code>
     模块
    </h5>
    <ul>
     <li>
      ​
      <code>
       partial
      </code>
      ：固定函数的部分参数，生成新函数。
      <pre><code>from functools import partial
add_10 = partial(lambda x, y: x + y, 10)
print(add_10(5))  # 15</code></pre>
     </li>
     <li>
      ​
      <code>
       lru_cache
      </code>
      ：缓存函数结果，优化递归或重复计算。
      <pre><code>from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)</code></pre>
     </li>
    </ul>
    <h5>
     2. ​
     <code>
      itertools
     </code>
     模块
    </h5>
    <ul>
     <li>
      提供高效迭代器工具：
      <pre><code>from itertools import permutations, chain

# 排列组合
print(list(permutations('AB', 2)))  # [('A','B'), ('B','A')]

# 连接多个可迭代对象
combined = chain([1, 2], ['a', 'b'])
print(list(combined))  # [1, 2, 'a', 'b']</code></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      四、函数式编程的典型应用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       ​
       <strong>
        数据处理流水线
       </strong>
      </p>
      <pre><code># 使用 map、filter 和 reduce 处理数据
data = [1, 2, 3, 4, 5]
pipeline = reduce(
    lambda acc, x: acc + x,
    map(lambda x: x*2, filter(lambda x: x % 2 == 0, data)),
    0
)
print(pipeline)  # (2 * 2 + 4 * 2) = 12</code></pre>
     </li>
     <li>
      <p>
       ​
       <strong>
        惰性求值与生成器
       </strong>
      </p>
      <pre><code># 处理大型文件时逐行读取
def read_large_file(file_path):
    with open(file_path) as f:
        for line in f:
            yield line.strip()

lines = read_large_file("data.txt")</code></pre>
     </li>
     <li>
      <p>
       ​
       <strong>
        并发与并行
       </strong>
      </p>
      <ul>
       <li>
        纯函数无副作用，适合多线程/多进程。
       </li>
       <li>
        ​
        <strong>
         示例
        </strong>
        ：使用
        <code>
         multiprocessing.Pool.map
        </code>
        并行计算。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     ​
     <strong>
      五、函数式编程的优缺点
     </strong>
    </h4>
    <h5>
     ✅ ​
     <strong>
      优点
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       简洁性
      </strong>
      ：用更少的代码表达复杂逻辑。
     </li>
     <li>
      ​
      <strong>
       可测试性
      </strong>
      ：纯函数易于单元测试。
     </li>
     <li>
      ​
      <strong>
       可维护性
      </strong>
      ：减少副作用和状态变更。
     </li>
    </ul>
    <h5>
     ❌ ​
     <strong>
      缺点
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       性能问题
      </strong>
      ：某些场景（如递归）效率低于循环。
     </li>
     <li>
      ​
      <strong>
       学习曲线
      </strong>
      ：需要适应声明式思维。
     </li>
     <li>
      ​
      <strong>
       调试困难
      </strong>
      ：链式调用可能增加调试复杂度。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      六、函数式编程 vs 面向对象编程
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        ​
        <strong>
         函数式编程
        </strong>
       </th>
       <th>
        ​
        <strong>
         面向对象编程
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        通过函数组合解决问题
       </td>
       <td>
        通过对象和类组织逻辑
       </td>
      </tr>
      <tr>
       <td>
        强调无状态和不可变数据
       </td>
       <td>
        强调封装和状态管理
       </td>
      </tr>
      <tr>
       <td>
        适合数据处理和数学计算
       </td>
       <td>
        适合复杂系统建模
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     ​
     <strong>
      七、学习建议
     </strong>
    </h4>
    <ol>
     <li>
      ​
      <strong>
       从简单开始
      </strong>
      ：先用
      <code>
       map
      </code>
      /
      <code>
       filter
      </code>
      替代
      <code>
       for
      </code>
      循环。
     </li>
     <li>
      ​
      <strong>
       理解副作用
      </strong>
      ：尽量编写纯函数。
     </li>
     <li>
      ​
      <strong>
       掌握工具链
      </strong>
      ：熟练使用
      <code>
       functools
      </code>
      和
      <code>
       itertools
      </code>
      。
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323733373438362f:61727469636c652f64657461696c732f313436313936303935" class_="artid" style="display:none">
 </p>
</div>


