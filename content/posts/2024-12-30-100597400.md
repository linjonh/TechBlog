---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f796b723136386167652f:61727469636c652f64657461696c732f313030353937343030"
layout: post
title: "unity游戏生成与修改so文件教程"
date: 2024-12-30 00:00:00 +0800
description: "本文主要介绍如何对unity3d引擎制作的游戏进行修改。包含了apk文件安装后在手机中的位置分析、修"
keywords: "libunity.so"
categories: ['学习', 'Unity', 'C']
tags: ['无标签']
artid: "100597400"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=100597400
    alt: "unity游戏生成与修改so文件教程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=100597400
featuredImagePreview: https://bing.ee123.net/img/rand?artid=100597400
---

# unity游戏生成与修改so文件教程

|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 本文主要介绍如何对unity3d引擎制作的游戏进行修改。包含了apk文件安装后在手机中的位置分析、修改游戏时遇见内联函数之坑时的解决办法，以及so文件的原理介绍与解析修改。并将实例教学如何修改unity3d游戏（想学崩坏3修改的同学请注意啦）。教程是给入门新手看的，请大神绕道勿喷。文章的核心内容在最后利用Il2CppDumper的部分，前面清楚的话可直接绕到最后看。（因为手机截图下来的图片分辨率太大。看起来排版会不太舒服，可以直接到文章最后下载文档查看，排版会舒服很多）   ****基础知识****    ****0x1.apk安装后在手机中的目录****   **apk安装后会在两个包下生成相关包：data/data/、data/app/。**    这里拿网易云音乐的安装目录举例。Data/App目录下通常会有三个文件：    1.lib文件夹  （包含so库文件）、    2.oat文件夹  （OAT文件是一种  android  私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本    地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART    里面运行  ）  、    3.  base.apk启动包。  【其中apk启动包是不允许重命名或删除的，因为app运行时其实就是链接到这个启动包，然后才能继续启动操作。这个启动包用beyond对比后可以发现，与原安装包没有任何不同，所以就相当与apk的原版安装包】。                        Data/data目录下一般是存储lib文件夹（保护so库文件）以及其他数据文件、缓存等。只需要知道这里的lib实际上与data/app目录下的lib目录中内容是一样的。    游戏在运行的时候，一般都会载入dada/data目录中的lib与data/app中的lib，通常来说只需要修改data/data中的lib文件夹中的so文件即可达到成功修改的效果。当然也有一小部分游戏根本不读取data/data目录下的lib文件夹，待会会讲到。          ****0x2.** **U** **nity3D中的资源路径****  |  |  | | --- | --- | | Application.dataPath | 此属性用于返回程序的数据文件所在文件夹的路径。例如在Editor中就是Assets了。 | | Application.streamingAssetsPath | 此属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。 | | Application.persistentDataPath | 此属性用于返回一个持久化数据存储目录的路径，可以在此路径下存储一些持久化的数据文件。 | | Application.temporaryCachePath | 此属性用于返回一个临时数据的缓存目录。 |  **android平台**  |  |  | | --- | --- | | Application.dataPath | /data/app/xxx.xxx.xxx.apk | | Application.streamingAssetsPath | jar:file:///data/app/xxx.xxx.xxx.apk/!/assets | | Application.persistentDataPath | /data/data/xxx.xxx.xxx/files | | Application.temporaryCachePath | /data/data/xxx.xxx.xxx/cache |  **IOS平台**  |  |  | | --- | --- | | Application.dataPath | Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data | | Application.streamingAssetsPath | Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw | | Application.persistentDataPath | Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents | | Application.temporaryCachePath | Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches |     ****0x3.** **C#的inline内联函数优化****   虽然C#不支持inline，但是JIT支持自动inline，即将IL转成真正机器码时，会自动将某些函数进行inline展开，只是条件非常苛刻，网上提到JIT自动进行inline展开的一些选择依据：   1）函数内部有循环语句、catch语句等复杂结构，都不做inline优化。   2）函数体比较长的不做inline优化，只有比较简单的才可能inline优化。（有人说IL不足32字节才做inline），   2）编译成机器码时，inline展开的代码比函数调用更短的，一定做inline。（注:如果参数多而代码少，就符合此情况）   这里为什么要讲内联函数呢，加入如果游戏中有一个读取人物攻击力的函数，其内部代码十分简单，结果被编译为机器码的时候变为了内联函数。那么这个时候要来修改就十分麻烦了，因为你找到那个读取人物攻击力的函数是没有用的，修改了也是白修改，只能到每一处调用这个函数的地方逐行修改。   好了，说了这么多，下面从开始unity3d游戏开发的的角度逐渐逆向分析。     **一、 **通过unity3d打包生成libil2cpp.so：****   1.如何识别u3d游戏？打开解压包，如果lib文件夹下有libunity.so就证明这是一个unity3d游戏。   2.要修改Unity3d游戏，首先就要对其游戏代码存放位置有一个基本的了解。Unity3d生成游戏的游戏主逻辑一般放在三个地方：libil2cpp.so、Assembly-CSharp.dll、lua脚本。   【对于libil2cpp.so来说：我们知道，unity3d最大的一个特点是一次制作，多平台部署，而这一核心功能是靠Mono实现的。但是在2014年年中的时候，Unity3D引出了IL2CPP的概念，IL2CPP，英文意思即Intermediate Language to cpp，就是把IL中间语言转换成CPP文件。】   上面所说的这三个地方通常来说是唯一的，即只会出现一种情况。这是由unity3d引擎的生成方式决定的。下面通过开发者的角度对unity3d生成游戏进行实例讲解：     新建unity3d工程，工程命名为HelloCPP！：         利用ugui创建两个text，一个为“CoinUI”显示“金币”，一个为“Coin”显示金币值，并创建脚本GameManager，绑定在MainCamera中。     脚本GameManager代码如下：  1. using System.Collections; 2. using System.Collections.Generic; 3. using UnityEngine.UI; 4. using UnityEngine;  7. public class GameManager : MonoBehaviour {  10. private GameObject coin; 11. void Start () { 12. coin = GameObject.Find("Coin"); 14. } 15. private int GetCoin() 16. { 17. return 50; 19. } 20. public void ChangeCoin() 21. { 22. float v = GetCoin(); 23. coin.GetComponent<Text>().text = v.ToString(); 24. } 25. } 26. 方法与按钮事件绑定。那么当点击按钮的时候就会更新一次</font>ui。</font></font></font>  *复制代码*    代码中的GetCoin方法放回一个50的数值，当游戏运行起来的时候，脚本会将ui界面中Coin的值改为50，如下：        好了，游戏逻辑已经写完了，保存场景，直接打包，点击主菜单file>BuildSetting进入打包界面，选择转化为android平台，并点击playersetting进入配置界面：   这里我把PackageName设置为com.hellocpp。   然后页面下拉，找到scriptingbackend：             这里的scriptingBackend就是设置生成游戏的游戏逻辑存放方式，如果选择默认的Mono2x的话，会在反编译后的apk的assets\bin\Data\Managed目录下找到Assembly-CSharp.dll文件，也就是大多数unity游戏逻辑存放的位置，这种情况下，lib文件夹下是没有libil2cpp.so文件的。如果是选择IL2CPP的话，会在lib文件夹下生成libil2cpp.so文件，并在assets\bin\Data\Managed\Metadata目录下生成global-metadata.dat配置文件。        对于生成Assembly-CSharp.dll文件的情况来说，用reflector很容易修改，这里略过，直接讲解生成libil2cpp.so文件的情况。把生成的apk直接拖入ide中反编译，进入根目录后，进入lib文件夹中观察。      ****二、对生成的apk进行反编译分析****     直接把apk拖入ide，然后进入lib文件夹查看                  **三、 **对Il2CppDumper.exe工具的介绍****    出现上述情况的原因与unity引擎中的MetadataCache.cpp相关，打开u3d目录，可找到MetadataCache.cpp：        意思就是在生成libil2cpp.so时，u3d同时会在目录assets\bin\Data\Managed\Metadata下生产资源文件global-metadata.dat。游戏中使用的字符串都被保存在了一个叫global-metadata.dat的资源文件里，只有在动态运行时才会将这些字符串读入内存。这使得用IDA对游戏进行静态分析变得更加困难。那么为了解决这个困难，有人造了轮子，即Il2CppDumper.exe。此可读取global-metadata.dat文件中的信息，并与libil2cpp.so结合起来。         **相关源码可看国外大神的分析：还原使用IL2CPP编译的unity游戏的symbol（一）**   【https://www.nevermoe.com/?p=572】以及（github：https://github.com/nevermoe/unity\_metadata\_loader）与github：https://github.com/Perfare/Il2CppDumper）     好了，如果你觉得这个看起来过于麻烦的话，可以直接略过，只要学会使用其工具化下来的exe就行了。     这里为了方便下载直接使用，我已经把exe文件生成出来了，会直接打包到百度云。   这个exe文件主要是通过对global-metadata.dat与so文件的结合自动生成相关函数与其对应在ida中的偏移地址。（相关原理其实就是分析global-metadata.dat，这里是自动帮我们省去了这个步骤）。     使用方法：   打开Il2CppDumper.exe，会弹出一个窗口，第一个选择lib2cpp.so，第二个选择global-metadata.dat，然后按下键盘键2，就会自动完成后续的操作了。               生成的文件就是这个dump.cs,我们点进去后直接搜索coin，定位到这里：        下面的数字就是偏移量，复制511f50后进入ida，按g键进入到相关地址   发现代码没有展开的话，按一下c键就可以了。      可以看到，他这里是返回了50。那么，这个时候我们就兴奋了，这里就是我们要修改的地方！讲道理把这里的0x32修改为0xFF00后，我们在游戏中点击按钮，显现的值就应该变为65280了：      用hex二进制修改器修改后，命名为libil2cpp改.so。   接下来可以直接把so替换掉原so然后打包回编译，但这种办法遇到apk有签名验证或其他乱七八糟的检验时不好操作。这里我们使用另一种部分，即先安装apk到手机，然后进去根目录下去手动把so给替换掉(手机需root)。     把apk与修改后的so一起扔进手机：               安装apk后，先打开来看看，点击按钮后，金币为50        好了，接下来就是替换so了。在前面的基础知识中我们讲到，apk安装后，会在data/data与data/app下分别生成自己的包文件。并且两个文件夹下都有lib，里面封装了一样的so库文件。那么我们是去替换哪一个呢？答案：两个都试试。   因为有些app只读取data/app/com.hellocpp目录下的lib文件夹信息，不读取data下的文件夹信息，比如这个apk。你会发现你直接把data/data下的com.hellocpp包给删掉也是完全可以运行的，但是如果你删了app目录下的com.hellocpp/lib，立刻无法运行。   我们把原so重命名为libil2cpp.so原，然后把改后的so命名为libil2cpp.so      大功告成，我们重新打开游戏，然后会发现。   没有任何变化（心凉）        正常情况这样修改后就应该会成功了的，但是这里为什么依然没有任何变化呢。   这里又涉及到前面说的基础知识，当这种情况发生的时候，很可能就是函数内联了。   你修改函数本体是没有任何效果的，因为这个函数被调用它的函数内置了。你必须找到所有调用这个函数的地方，去找到相关点修改。这个就需要去看汇编代码了。   我们也可以动态调试的时候在getcoin（）方法处下一个断点，然后ida动态调试，会发现按钮按下时确实没有断下来（限于篇幅请读者自行尝试）。或者我们直接把那个函数本体给nop掉，会发现程序依旧正常运行，这都说明了函数确实内联了。     内联了的函数很难分析，我遇到了就只能跑路，这里只是点出其位置，再深入的分析就要去好好读代码了，不多分析（如果有大神会的话麻烦评论区指点指点）     这里我直接找到这个地方，改为mov r0，0      再次替换后运行结果确实变为0了：           ****实例二****   好了，分析完上面这个核心处存在内联函数的apk，我们下面来一个最常见的apk修改实例。   仍然是上面这个apk的功能，但不同的是为了防止其编译的时候又被当成内联函数编译了，我在方法GetCoin()内增加了一个循环和几个debug，确保其不被当作内联。其他功能不变。依旧是在GetCoin()中返回50，然后在ChangeCoin()修改ui界面的数值。   代码如下：        然后同样步骤打包生成apk，但把包名改为了com.HellobanInline   生成apk后直接扔进ide中反编译，然后把global-metadata.dat与libil2cpp.so拿出来，用Il2CppDumper.exe把函数名生成出来：      打开dump.cs，搜索GetCoin()        函数位置在偏移511d48上。      因为方法是返回一个int值的数值，我们直接让其返回0xff00，也就是65280.        用hex二进制文件修改后把文件命名【libil2cpp改.so】。与apk一起扔到手机中。   Apk安装完成后，进入data/app中的包com.HellobanInline-1的lib/arm中，把【libil2cpp改.so】复制进来，重命名如下：   【这里对为什么包名后面有一个-1做一下解释：这是因为复制版本覆盖。一般来说第一次安装的话包名后缀-1，第二次覆盖安装就会多一个相同包名后缀为-2，再次覆盖安装又会变为-1……】          好了，大功告成，这个时候充满期待的打开apk吧。点击按钮后数值已经由50变为了65280！   效果图：     * 市面上绝大部分游戏都是直接生成c#方法名后到ida中直接修改就生效了，像实例一的比较少见，但有助与深入理解。       一般生成方法名后，就看修改经验或游戏开发经验了，比较火的u3d游戏有很多，比如崩坏3的修改，你可以搜索方法名“GetBaseAttack”，修改为一个超大值，那么你人物就一击十几亿，防御十几亿，生命十几亿了。对于崩二的话，其加了爱加密的壳，并且似乎有检验so是否被篡改，若有高人能跳过检测希望能告诉我一下，十分感谢！然后再其他的游戏修改也都是这套路，多多熟悉就会了。           大概就这些内容吧，自己罗里吧嗦的，感觉篇幅有点累赘了。       [size=10.5000pt]                       百度云链接：   链接：https://pan.baidu.com/s/1htaB64k 密码：xrf3   解压密码www.52pojie.cn       world文档：  http://pan.baidu.com/s/1i5EC5pj 密码：ja84 |

[图片1.png](https://www.52pojie.cn/forum.php?mod=attachment&aid=ODk5MTczfDcxZWMzNDQ1fDE1Njc4MzM3MDB8MHw2MTg1MTU%3D&nothumb=yes)
*(78.43 KB, 下载次数: 10)*

![图片1.png](https://i-blog.csdnimg.cn/blog_migrate/6e3285832bbbc6dbbe86714481b0f230.png)