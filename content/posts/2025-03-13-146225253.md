---
layout: post
title: "ARM64-架构地址空间分配深度解析"
date: 2025-03-13 11:03:47 +0800
description: "ARM64架构在地址空间设计上的选择，反映了其在性能、功耗、成本与扩展性之间的平衡。通过合理的地址空间划分和优化的内存映射机制，ARM64处理器在保持良好兼容性的同时，为系统设计提供了高度的灵活性。"
keywords: "ARM64 架构地址空间分配深度解析"
categories: ['计算机组成原理', '操作系统']
tags: ['Windows', 'Linux', 'Arm']
artid: "146225253"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146225253
    alt: "ARM64-架构地址空间分配深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146225253
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146225253
cover: https://bing.ee123.net/img/rand?artid=146225253
image: https://bing.ee123.net/img/rand?artid=146225253
img: https://bing.ee123.net/img/rand?artid=146225253
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ARM64 架构地址空间分配深度解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_ARMv8__0">
     </a>
     一、寻址空间选择的技术逻辑（基于 ARMv8 架构）
    </h3>
    <h4>
     <a id="LPAE__1">
     </a>
     地址空间截断的工程实现（LPAE 技术）
    </h4>
    <p>
     在计算架构设计中，ARM64架构选择使用48位/52位虚拟地址空间而非完整的64位寻址，这一决策体现了硬件设计者在性能、功耗、成本与实际需求之间的平衡。具体如下：
    </p>
    <h5>
     <a id="_4">
     </a>
     硬件实现与成本优化
    </h5>
    <ul>
     <li>
      <strong>
       64位地址空间的实际利用率
      </strong>
      ：
      <code>
       2^64
      </code>
      （16EB）的理论寻址空间远超当前应用的需求，即使48位地址（256TB）也远远超过现有硬件的物理内存容量。
     </li>
     <li>
      <strong>
       页表层级优化
      </strong>
      ：更大的地址空间需要更多的页表层级，这将带来内存管理复杂度和地址转换开销的增加。通过限制虚拟地址空间，可以在硬件设计上优化页表结构，降低实现复杂度。
     </li>
    </ul>
    <p>
     如下表所示，对 48 位和 64 位地址位宽的情况进行了对比。
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        <strong>
         地址位宽
        </strong>
       </th>
       <th align="left">
        <strong>
         页表级数
        </strong>
       </th>
       <th align="left">
        <strong>
         页大小
        </strong>
       </th>
       <th align="left">
        <strong>
         转换开销
        </strong>
       </th>
       <th align="left">
        <strong>
         典型场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="left">
        48 位
       </td>
       <td align="left">
        3 级
       </td>
       <td align="left">
        4KB/1GB
       </td>
       <td align="left">
        12ns
       </td>
       <td align="left">
        手机 / 通用服务器
       </td>
      </tr>
      <tr>
       <td align="left">
        64 位
       </td>
       <td align="left">
        4 级
       </td>
       <td align="left">
        4KB
       </td>
       <td align="left">
        16ns
       </td>
       <td align="left">
        超算（极少使用）
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     <a id="_16">
     </a>
     架构设计的前瞻性
    </h5>
    <ul>
     <li>
      <strong>
       硬件架构的演进
      </strong>
      ：处理器架构的设计往往超前于操作系统的发展。ARM64架构在设计时就考虑了未来扩展的可能，同时保持合理的地址空间配置。
     </li>
     <li>
      <strong>
       操作系统适配
      </strong>
      ：Linux、Windows等主流操作系统在64位系统中采用48位虚拟地址空间，正是基于硬件架构的实际能力进行优化设计。
     </li>
    </ul>
    <h5>
     <a id="_20">
     </a>
     系统优化与兼容性
    </h5>
    <ul>
     <li>
      <strong>
       操作系统层面的优化
      </strong>
      ：通过分段页表配置（如39位、48位、52位），操作系统可以在性能与扩展性之间取得平衡。
     </li>
     <li>
      <strong>
       软件兼容性保障
      </strong>
      ：x86_64和ARM64架构均采用48位虚拟地址空间，这种一致性简化了内核映射设计。例如，虚拟地址（VA）和物理地址（PA）的低48位直接对应关系，降低了系统实现复杂度。
     </li>
    </ul>
    <h3>
     <a id="48_24">
     </a>
     二、48位寻址空间的物理地址分配逻辑
    </h3>
    <h4>
     <a id="_25">
     </a>
     功能区域划分（地址总线视角）
    </h4>
    <p>
     以ARM标准内存映射为例，48位寻址空间被划分为多个功能区域，每个区域分配特定的用途。
    </p>
    <pre><code class="prism language-dart"><span class="token number">0</span>x0000_0000_0000 ──┬── <span class="token number">0</span>x0001_FFFFFFFF （<span class="token number">512</span>MB QSPI 启动程序存储位置）
                   ├── <span class="token number">0</span>x0002_8000_0000 ── <span class="token number">0</span>x0002_FFFFFFFF （<span class="token number">128</span>MB 通用寄存器）
                   ├── <span class="token number">0</span>x0003_0000_0000 ── <span class="token number">0</span>x0003_9FFF_FFFF （<span class="token number">160</span>MB 调试）
                   ├── <span class="token number">0</span>x0003_A000_0000 ── <span class="token number">0</span>x0003_AFFF_FFFF （<span class="token number">16</span>MB 片内网络）
                   ├── <span class="token number">0</span>x0004_0000_0000 ── <span class="token number">0</span>x0007_FFFFFFFF （<span class="token number">1</span>GB <span class="token class-name">PCIe</span> MEM32）
                   ├── <span class="token number">0</span>x0008_0000_0000 ── <span class="token number">0</span>x000F_FFFFFFFF （<span class="token number">2</span>GB 主内存）
                   ├── <span class="token number">0</span>x0010_0000_0000 ── <span class="token number">0</span>x00FF_FFFFFFFF （<span class="token number">60</span>GB 保留）
                   ├── <span class="token number">0</span>x0100_0000_0000 ── <span class="token number">0</span>x01FF_FFFFFFFF （<span class="token number">64</span>GB <span class="token class-name">PCIe</span> MEM64）
                   └── <span class="token number">0</span>x0200_0000_0000 ── <span class="token number">0</span>xFFFF_FFFFFFFF （<span class="token number">15</span>TB<span class="token operator">+</span><span class="token number">768</span>GB 扩展内存）
</code></pre>
    <h4>
     <a id="_40">
     </a>
     关键区域技术解析
    </h4>
    <ol>
     <li>
      32 位 PCI 设备的地址约束
     </li>
    </ol>
    <ul>
     <li>
      **基础限制：**32位PCI设备的基址寄存器（BAR）只能地址编码0x00000000~0xFFFFFFFF（4GB）。
     </li>
     <li>
      <strong>
       映射需求
      </strong>
      ：即使在48位寻址环境下，32位设备的寄存器/内存空间必须映射到低32位，以保证设备的兼容性和正确识别。
     </li>
     <li>
      <strong>
       实际分配
      </strong>
      ：因此通常在虚拟地址空间中保留一段空间作为PCIe 32位空间。
      <ul>
       <li>
        例如0x000_40000000~0x000_7FFFFFFF。
       </li>
      </ul>
     </li>
    </ul>
    <ol start="2">
     <li>
      主内存的对齐策略
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       起始地址选择
      </strong>
      ：0x8000_0000_0000 源于 ARM 架构的
      <code>
       MemAttr
      </code>
      默认配置（下区地址镜像）；
     </li>
     <li>
      从0x000_80000000开始到0x000_FFFFFFFF，提供2GB的直接寻址空间，用于片外DDR存储器（如LPDDR5/LPDDR4X）。
     </li>
    </ul>
    <ol start="3">
     <li>
      扩展内存空间
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       功能定位
      </strong>
      ：用于支持大吞吐量的DMA数据传输，例如GPU显存、高速缓存等。
     </li>
     <li>
      <strong>
       实现机制
      </strong>
      ：通过地址翻译或I/O页表映射技术，支持超过48位物理地址的内存扩展，为系统提供更大的可用空间。
     </li>
    </ul>
    <h3>
     <a id="_53">
     </a>
     三、总结
    </h3>
    <p>
     ARM64架构在地址空间设计上的选择，反映了其在性能、功耗、成本与扩展性之间的平衡。通过合理的地址空间划分和优化的内存映射机制，ARM64处理器在保持良好兼容性的同时，为系统设计提供了高度的灵活性。
    </p>
    <h3>
     <a id="_56">
     </a>
     四、对物理地址和内存寻址的反思与理解
    </h3>
    <p>
     在学习计算机系统时，我对物理地址和内存寻址机制存在严重的误解，这主要源于早期学习资料的局限性。回想过去，我曾误以为物理地址空间的大小完全由物理内存的容量决定，认为在物理内存为4GB的情况下，32位系统的CPU刚好能够充分利用其寻址能力。这种想法忽视了现代计算机体系结构中更为复杂的内存管理机制。
    </p>
    <h4>
     <a id="_59">
     </a>
     误区一：物理地址空间与物理内存容量的混淆
    </h4>
    <p>
     我曾经错误地认为，物理地址空间的大小直接等于物理内存的容量。例如，在4GB物理内存的系统中，32位CPU的寻址能力刚好满足这一需求。然而，这种理解是不全面的。实际上，物理地址空间是CPU能够寻址的内存范围，它与物理内存的容量是两个不同的概念。
     <br/>
     在x86-64（即64位）系统中，物理地址空间的大小远超4GB。现代x86-64处理器支持高达48位的物理地址，这意味着物理地址空间可以达到2
     <sup>
      48
     </sup>
     字节，即256TB。即使系统中安装的物理内存只有4GB，CPU的寻址能力仍然远远超过这一数值。
    </p>
    <h4>
     <a id="_63">
     </a>
     误区二：混淆内存空间与外设空间
    </h4>
    <p>
     我之前误以为所有设备加载到系统后，它们的寄存器空间和外设内存空间都位于DDR内存空间中。这种理解是错误的。实际上，系统中的外设（如显卡、网卡等）拥有自己的寄存器空间和内存空间，这些空间与主内存（DDR内存）是分开的，通过I/O地址空间或MMIO（内存映射I/O）进行访问。
    </p>
    <h4>
     <a id="_66">
     </a>
     正确认识
    </h4>
    <p>
     随着对x86-64架构的深入了解，我认识到以下几点：
    </p>
    <ol>
     <li>
      <strong>
       物理地址空间
      </strong>
      ：物理地址空间是CPU能够寻址的内存范围，与物理内存的容量无关。物理内存容量由内存条的物理容量决定，而物理地址空间由CPU的寻址能力决定。
     </li>
     <li>
      <strong>
       虚拟地址空间
      </strong>
      ：在现代操作系统中，应用程序使用的是虚拟地址，通过虚拟内存管理机制映射到物理地址。虚拟地址空间的大小由CPU的寻址能力决定，而物理地址空间则是虚拟地址的实际映射目标。
     </li>
     <li>
      <strong>
       内存与外设的区别
      </strong>
      ：内存（RAM）用于存储程序和数据，而外设的寄存器和内存空间通过I/O地址空间实现独立访问，不会占用主内存空间。
     </li>
    </ol>
    <p>
     实在是惭愧惭愧。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373334343132352f:61727469636c652f64657461696c732f313436323235323533" class_="artid" style="display:none">
 </p>
</div>


