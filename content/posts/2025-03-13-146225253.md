---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373334343132352f:61727469636c652f64657461696c732f313436323235323533"
layout: post
title: "ARM64-架构地址空间分配深度解析"
date: 2025-03-13 11:03:47 +0800
description: "ARM64架构在地址空间设计上的选择，反映了其在性能、功耗、成本与扩展性之间的平衡。通过合理的地址空间划分和优化的内存映射机制，ARM64处理器在保持良好兼容性的同时，为系统设计提供了高度的灵活性。"
keywords: "ARM64 架构地址空间分配深度解析"
categories: ['计算机组成原理', '操作系统']
tags: ['Windows', 'Linux', 'Arm']
artid: "146225253"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146225253
    alt: "ARM64-架构地址空间分配深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146225253
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146225253
cover: https://bing.ee123.net/img/rand?artid=146225253
image: https://bing.ee123.net/img/rand?artid=146225253
img: https://bing.ee123.net/img/rand?artid=146225253
---

# ARM64 架构地址空间分配深度解析

### 一、寻址空间选择的技术逻辑（基于 ARMv8 架构）

#### 地址空间截断的工程实现（LPAE 技术）

在计算架构设计中，ARM64架构选择使用48位/52位虚拟地址空间而非完整的64位寻址，这一决策体现了硬件设计者在性能、功耗、成本与实际需求之间的平衡。具体如下：

##### 硬件实现与成本优化

* **64位地址空间的实际利用率**
  ：
  `2^64`
  （16EB）的理论寻址空间远超当前应用的需求，即使48位地址（256TB）也远远超过现有硬件的物理内存容量。
* **页表层级优化**
  ：更大的地址空间需要更多的页表层级，这将带来内存管理复杂度和地址转换开销的增加。通过限制虚拟地址空间，可以在硬件设计上优化页表结构，降低实现复杂度。

如下表所示，对 48 位和 64 位地址位宽的情况进行了对比。

| **地址位宽** | **页表级数** | **页大小** | **转换开销** | **典型场景** |
| --- | --- | --- | --- | --- |
| 48 位 | 3 级 | 4KB/1GB | 12ns | 手机 / 通用服务器 |
| 64 位 | 4 级 | 4KB | 16ns | 超算（极少使用） |

##### 架构设计的前瞻性

* **硬件架构的演进**
  ：处理器架构的设计往往超前于操作系统的发展。ARM64架构在设计时就考虑了未来扩展的可能，同时保持合理的地址空间配置。
* **操作系统适配**
  ：Linux、Windows等主流操作系统在64位系统中采用48位虚拟地址空间，正是基于硬件架构的实际能力进行优化设计。

##### 系统优化与兼容性

* **操作系统层面的优化**
  ：通过分段页表配置（如39位、48位、52位），操作系统可以在性能与扩展性之间取得平衡。
* **软件兼容性保障**
  ：x86\_64和ARM64架构均采用48位虚拟地址空间，这种一致性简化了内核映射设计。例如，虚拟地址（VA）和物理地址（PA）的低48位直接对应关系，降低了系统实现复杂度。

### 二、48位寻址空间的物理地址分配逻辑

#### 功能区域划分（地址总线视角）

以ARM标准内存映射为例，48位寻址空间被划分为多个功能区域，每个区域分配特定的用途。

```dart
0x0000_0000_0000 ──┬── 0x0001_FFFFFFFF （512MB QSPI 启动程序存储位置）
                   ├── 0x0002_8000_0000 ── 0x0002_FFFFFFFF （128MB 通用寄存器）
                   ├── 0x0003_0000_0000 ── 0x0003_9FFF_FFFF （160MB 调试）
                   ├── 0x0003_A000_0000 ── 0x0003_AFFF_FFFF （16MB 片内网络）
                   ├── 0x0004_0000_0000 ── 0x0007_FFFFFFFF （1GB PCIe MEM32）
                   ├── 0x0008_0000_0000 ── 0x000F_FFFFFFFF （2GB 主内存）
                   ├── 0x0010_0000_0000 ── 0x00FF_FFFFFFFF （60GB 保留）
                   ├── 0x0100_0000_0000 ── 0x01FF_FFFFFFFF （64GB PCIe MEM64）
                   └── 0x0200_0000_0000 ── 0xFFFF_FFFFFFFF （15TB+768GB 扩展内存）

```

#### 关键区域技术解析

1. 32 位 PCI 设备的地址约束

* \*\*基础限制：\*\*32位PCI设备的基址寄存器（BAR）只能地址编码0x00000000~0xFFFFFFFF（4GB）。
* **映射需求**
  ：即使在48位寻址环境下，32位设备的寄存器/内存空间必须映射到低32位，以保证设备的兼容性和正确识别。
* **实际分配**
  ：因此通常在虚拟地址空间中保留一段空间作为PCIe 32位空间。
  + 例如0x000\_40000000~0x000\_7FFFFFFF。

2. 主内存的对齐策略

* **起始地址选择**
  ：0x8000\_0000\_0000 源于 ARM 架构的
  `MemAttr`
  默认配置（下区地址镜像）；
* 从0x000\_80000000开始到0x000\_FFFFFFFF，提供2GB的直接寻址空间，用于片外DDR存储器（如LPDDR5/LPDDR4X）。

3. 扩展内存空间

* **功能定位**
  ：用于支持大吞吐量的DMA数据传输，例如GPU显存、高速缓存等。
* **实现机制**
  ：通过地址翻译或I/O页表映射技术，支持超过48位物理地址的内存扩展，为系统提供更大的可用空间。

### 三、总结

ARM64架构在地址空间设计上的选择，反映了其在性能、功耗、成本与扩展性之间的平衡。通过合理的地址空间划分和优化的内存映射机制，ARM64处理器在保持良好兼容性的同时，为系统设计提供了高度的灵活性。

### 四、对物理地址和内存寻址的反思与理解

在学习计算机系统时，我对物理地址和内存寻址机制存在严重的误解，这主要源于早期学习资料的局限性。回想过去，我曾误以为物理地址空间的大小完全由物理内存的容量决定，认为在物理内存为4GB的情况下，32位系统的CPU刚好能够充分利用其寻址能力。这种想法忽视了现代计算机体系结构中更为复杂的内存管理机制。

#### 误区一：物理地址空间与物理内存容量的混淆

我曾经错误地认为，物理地址空间的大小直接等于物理内存的容量。例如，在4GB物理内存的系统中，32位CPU的寻址能力刚好满足这一需求。然而，这种理解是不全面的。实际上，物理地址空间是CPU能够寻址的内存范围，它与物理内存的容量是两个不同的概念。
  
在x86-64（即64位）系统中，物理地址空间的大小远超4GB。现代x86-64处理器支持高达48位的物理地址，这意味着物理地址空间可以达到2
48
字节，即256TB。即使系统中安装的物理内存只有4GB，CPU的寻址能力仍然远远超过这一数值。

#### 误区二：混淆内存空间与外设空间

我之前误以为所有设备加载到系统后，它们的寄存器空间和外设内存空间都位于DDR内存空间中。这种理解是错误的。实际上，系统中的外设（如显卡、网卡等）拥有自己的寄存器空间和内存空间，这些空间与主内存（DDR内存）是分开的，通过I/O地址空间或MMIO（内存映射I/O）进行访问。

#### 正确认识

随着对x86-64架构的深入了解，我认识到以下几点：

1. **物理地址空间**
   ：物理地址空间是CPU能够寻址的内存范围，与物理内存的容量无关。物理内存容量由内存条的物理容量决定，而物理地址空间由CPU的寻址能力决定。
2. **虚拟地址空间**
   ：在现代操作系统中，应用程序使用的是虚拟地址，通过虚拟内存管理机制映射到物理地址。虚拟地址空间的大小由CPU的寻址能力决定，而物理地址空间则是虚拟地址的实际映射目标。
3. **内存与外设的区别**
   ：内存（RAM）用于存储程序和数据，而外设的寄存器和内存空间通过I/O地址空间实现独立访问，不会占用主内存空间。

实在是惭愧惭愧。