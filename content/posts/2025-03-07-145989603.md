---
layout: post
title: "MySQL进阶-分析查询语句EXPLAIN"
date: 2025-03-07 15:18:39 +0800
description: "下边我们看一个连接查询的执行计划，可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的。"
keywords: "MySQL进阶-分析查询语句EXPLAIN"
categories: ['未分类']
tags: ['数据库', 'Mysql']
artid: "145989603"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145989603
    alt: "MySQL进阶-分析查询语句EXPLAIN"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145989603
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145989603
cover: https://bing.ee123.net/img/rand?artid=145989603
image: https://bing.ee123.net/img/rand?artid=145989603
img: https://bing.ee123.net/img/rand?artid=145989603
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL进阶-分析查询语句EXPLAIN
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     概述
    </h2>
    <p>
     <img alt="" height="249" src="https://i-blog.csdnimg.cn/direct/fd5eade742064549ac95b8f1827b72c1.png" width="867"/>
    </p>
    <h3>
     <strong>
      能做什么？
     </strong>
    </h3>
    <blockquote>
     <ul>
      <li>
       <p>
        表的读取顺序
       </p>
      </li>
      <li>
       <p>
        数据读取操作的操作类型
       </p>
      </li>
      <li>
       <p>
        哪些索引可以使用
       </p>
      </li>
      <li>
       <p>
        哪些索引被实际使用
       </p>
      </li>
      <li>
       <p>
        表之间的引用
       </p>
      </li>
      <li>
       <p>
        每张表有多少行被优化器查询
       </p>
      </li>
     </ul>
    </blockquote>
    <h3>
     <strong>
      官网介绍
     </strong>
    </h3>
    <p>
     <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" rel="nofollow" title="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">
      https://dev.mysql.com/doc/refman/5.7/en/explain-output.html
     </a>
    </p>
    <p>
     <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" rel="nofollow" title="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">
      https://dev.mysql.com/doc/refman/8.0/en/explain-output.html
     </a>
    </p>
    <p>
     <img alt="" height="857" src="https://i-blog.csdnimg.cn/direct/11b8695346d84a4da0bb005262245cab.png" width="1561"/>
    </p>
    <h3>
     <strong>
      版本情况
     </strong>
    </h3>
    <blockquote>
     <ul>
      <li>
       <p>
        MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE， DELETE
       </p>
      </li>
      <li>
       <p>
        在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。
        <strong>
         在5.7版本后，默认explain直接显示partitions和 filtered中的信息。
        </strong>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3>
    </h3>
    <h2 style="background-color:transparent">
     基本语法
    </h2>
    <p>
     EXPLAIN 或 DESCRIBE语句的语法形式如下：
    </p>
    <blockquote>
     <p>
      EXPLAIN SELECT select_options
      <br/>
      或者
      <br/>
      DESCRIBE SELECT select_options
     </p>
    </blockquote>
    <p>
     如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT 1;</code></pre>
    <p>
     <img alt="" height="255" src="https://i-blog.csdnimg.cn/direct/aac11dfeb4964c00aa1675780c91723a.png" width="863"/>
    </p>
    <p>
     EXPLAIN 语句输出的各个列的作用如下：
    </p>
    <p>
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/direct/f8e331549ce54266af7300d31490d554.png" width="753"/>
    </p>
    <h2>
     EXPLAIN各列作用
    </h2>
    <h3>
     table
    </h3>
    <blockquote>
     <p>
      不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql &gt; EXPLAIN SELECT * FROM s1;</code></pre>
    <p>
     <img alt="" height="122" src="https://i-blog.csdnimg.cn/direct/17c19f79099046d5afc25bf5802806b0.png" width="752"/>
    </p>
    <blockquote>
     <p>
      这个查询语句只涉及对s1表的单表查询，所以
      <code>
       EXPLAIN
      </code>
      输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。下边我们看一个连接查询的执行计划，可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql &gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code></pre>
    <p>
     <img alt="" height="126" src="https://i-blog.csdnimg.cn/direct/1db464912ef247eeaf9dc85655eca068.png" width="858"/>
    </p>
    <h3>
     id
    </h3>
    <p>
     我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句：
    </p>
    <pre><code class="language-sql">SELECT * FROM s1 WHERE key1 = 'a';</code></pre>
    <p>
     稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：
    </p>
    <pre><code class="language-sql">SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key1
WHERE s1.common_field = 'a';</code></pre>
    <p>
     但是下边两种情况下在一条查询语句中会出现多个SELECT关键字
    </p>
    <blockquote>
     <ul>
      <li>
       当查询语句有子查询时
      </li>
      <li>
       用union 来连接时
      </li>
     </ul>
    </blockquote>
    <p>
     <img alt="" height="364" src="https://i-blog.csdnimg.cn/direct/88ec28f0be3b48efb2c62c080522f9dd.png" width="870"/>
    </p>
    <pre><code class="language-sql">mysql &gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';</code></pre>
    <p>
     <img alt="" height="116" src="https://i-blog.csdnimg.cn/direct/1737951221714a1290ad430e259863d3.png" width="750"/>
    </p>
    <p>
     对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code></pre>
    <p>
     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/614923290d864e559a95253b822c01f0.png" width="741"/>
    </p>
    <p>
     <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/7919f3e98b0648b9bcc097bd1da21fe9.png" width="863"/>
    </p>
    <pre><code class="language-sql"># 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  
mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');</code></pre>
    <p>
     <img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/84671c5ade3140b2bdbed57deeb16469.png" width="942"/>
    </p>
    <p>
     可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的
     <code>
      id
     </code>
     值全部是1，这就表明
     <code>
      查询优化器将子查询转换为了连接查询
     </code>
     。
    </p>
    <p>
     对于包含
     <code>
      UNION
     </code>
     子句的查询语句来说，每个
     <code>
      SELECT
     </code>
     关键字对应一个
     <code>
      id
     </code>
     值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：
    </p>
    <blockquote>
     <p>
      <strong>
       使用union是把多个查询的结果集合起来并对结果集中的记录进行去重，使用临时表的方式对结果集进行去重
      </strong>
      ，所以在查询执行计划时就多了一条id为空的记录，表示这是为了合并两个查询的结果集而创建的。
     </p>
    </blockquote>
    <pre><code class="language-sql"># Union去重
mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code></pre>
    <p>
     <img alt="" height="172" src="https://i-blog.csdnimg.cn/direct/6b50ca6cbac649fdbc38743d10a5e139.png" width="933"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2; </code></pre>
    <p>
     <img alt="" height="178" src="https://i-blog.csdnimg.cn/direct/b311a2c9025e45ec929cf007b02b8464.png" width="930"/>
     <strong>
      小结:
     </strong>
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        id如果相同，可以认为是一组，
        <strong>
         从上往下顺序执行
        </strong>
       </p>
      </li>
      <li>
       <p>
        在所有组中，
        <strong>
         id值越大，优先级越高，越先执行
        </strong>
       </p>
      </li>
      <li>
       <p>
        关注点：id号每个号码，表示一趟独立的查询,
        <strong>
         一个sql的查询趟数越少越好
        </strong>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3>
     select_type
    </h3>
    <p>
     <img alt="" height="187" src="https://i-blog.csdnimg.cn/direct/602b6a55d6204223979bba449faf2c00.png" width="855"/>
    </p>
    <p>
     <img alt="" height="581" src="https://i-blog.csdnimg.cn/direct/e66ee3763fb54d118664294820a87de7.png" width="700"/>
    </p>
    <ul>
     <li>
      SIMPLE
     </li>
    </ul>
    <p>
     查询语句中不包含
     <code>
      UNION
     </code>
     或者子查询的查询都算作是
     <code>
      SIMPLE
     </code>
     类型，比方说下边这个单表查询
     <code>
      select_type
     </code>
     的值就是
     <code>
      SIMPLE
     </code>
     :
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1;</code></pre>
    <p>
     <img alt="" height="137" src="https://i-blog.csdnimg.cn/direct/07893b306fb344d492f335e71e6066a8.png" width="863"/>
    </p>
    <ul>
     <li>
      PRIMARY
     </li>
    </ul>
    <blockquote>
     <p>
      对于包含
      <code>
       UNION、UNION ALL
      </code>
      或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的
      <code>
       select_type
      </code>
      的值就是
      <code>
       PRIMARY。
      </code>
      从结果中可以看到，最左边的小查询
      <code>
       SELECT * FROM s1
      </code>
      对应的是执行计划中的第一条记录，它的
      <code>
       select_type
      </code>
      的值就是
      <code>
       PRIMARY
      </code>
      。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code></pre>
    <p>
     <img alt="" height="158" src="https://i-blog.csdnimg.cn/direct/f689a4e3d07344d3bb37558e50928f16.png" width="827"/>
    </p>
    <ul>
     <li>
      UNION
     </li>
    </ul>
    <blockquote>
     <p>
      对于包含
      <code>
       UNION
      </code>
      或者
      <code>
       UNION ALL
      </code>
      的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的
      <code>
       select_type
      </code>
      值就是UNION，可以对比上一个例子的效果。
     </p>
    </blockquote>
    <ul>
     <li>
      UNION RESULT
     </li>
    </ul>
    <blockquote>
     <p>
      MySQL 选择使用临时表来完成
      <code>
       UNION
      </code>
      查询的去重工作，针对该临时表的查询的
      <code>
       select_type
      </code>
      就是
      <code>
       UNION RESULT
      </code>
      , 例子上边有。
     </p>
    </blockquote>
    <p>
     <img alt="" height="172" src="https://i-blog.csdnimg.cn/direct/6b50ca6cbac649fdbc38743d10a5e139.png" width="933"/>
    </p>
    <ul>
     <li>
      SUBQUERY
     </li>
    </ul>
    <blockquote>
     <p>
      如果包含子查询的查询语句不能够转为对应的
      <code>
       semi-join
      </code>
      的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个
      <code>
       SELECT
      </code>
      关键字代表的那个查询的
      <code>
       select_type
      </code>
      就是
      <code>
       SUBQUERY
      </code>
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';</code></pre>
    <p>
     <img alt="" height="139" src="https://i-blog.csdnimg.cn/direct/3a1da85784004d50b7e7845e501291da.png" width="822"/>
    </p>
    <ul>
     <li>
      DEPENDENT SUBQUERY
     </li>
    </ul>
    <blockquote>
     <p>
      当子查询是相关子查询的时候，
      <strong>
       即子查询内部与外部的表是有关联的
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-sql"> mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';</code></pre>
    <ul>
     <li>
      DEPENDENT UNION
     </li>
    </ul>
    <blockquote>
     <p>
      同关联子查询
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');</code></pre>
    <ul>
     <li>
      DERIVED
     </li>
    </ul>
    <blockquote>
     <p>
      从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是
      <strong>
       DERIVED, 说明该子查询是以物化的方式执行的
      </strong>
      。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;</code></pre>
    <p>
     <img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/deddd2236a3a43d8a6d1d6f78b083167.png" width="824"/>
    </p>
    <ul>
     <li>
      MATERIALIZED
     </li>
    </ul>
    <blockquote>
     <p>
      当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的
      <code>
       select_type
      </code>
      属性就是DERIVED，比如下边这个查询：
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</code></pre>
    <p>
     <img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/c8e8a078d35b4fe1a162f6e7afc16b92.png" width="825"/>
    </p>
    <h3>
     type
    </h3>
    <p>
     执行计划的一条记录就代表着MySQL对某个表的
     <code>
      执行查询时的访问方法
     </code>
     , 又称“访问类型”，其中的
     <code>
      type
     </code>
     列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到
     <code>
      type
     </code>
     列的值是
     <code>
      ref
     </code>
     ，表明
     <code>
      MySQL
     </code>
     即将使用
     <code>
      ref
     </code>
     访问方法来执行对
     <code>
      s1
     </code>
     表的查询。
    </p>
    <blockquote>
     <p>
      完整的访问方法如下：
      <code>
       system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL
      </code>
      。
     </p>
    </blockquote>
    <ul>
     <li>
      <h4>
       <code>
        system
       </code>
      </h4>
     </li>
    </ul>
    <p>
     当表中
     <code>
      只有一条记录
     </code>
     并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是
     <code>
      system
     </code>
     。比方说我们新建一个
     <code>
      MyISAM
     </code>
     表，并为其插入一条记录：
    </p>
    <pre><code class="language-sql">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;
Query OK, 0 rows affected (0.05 sec)

mysql&gt; INSERT INTO t VALUES(1);
Query OK, 1 row affected (0.01 sec)</code></pre>
    <p>
     然后我们看一下查询这个表的执行计划，可以看到
     <code>
      type
     </code>
     列的值就是
     <code>
      system
     </code>
     了，
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM t;</code></pre>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/1699116206284adcabb8cbd3f715f353.png" width="828"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        const
       </code>
      </h4>
     </li>
    </ul>
    <p>
     当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是
     <code>
      const
     </code>
     , 比如：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;</code></pre>
    <p>
     <img alt="" height="121" src="https://i-blog.csdnimg.cn/direct/00420d7142ca420eb2c8dcc4b4a7887d.png" width="825"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        eq_ref
       </code>
      </h4>
     </li>
    </ul>
    <blockquote>
     <p>
      在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是
      <code>
       eq_ref。
      </code>
      从执行计划的结果中可以看出
      <strong>
       ，MySQL打算将s2作为驱动表，s1作为被驱动表
      </strong>
      ，重点关注s1的访问 方法是
      <code>
       eq_ref
      </code>
      ，表明在访问s1表的时候可以
      <strong>
       <code>
        通过主键的等值匹配
       </code>
       来进行访问。
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</code></pre>
    <p>
     <img alt="" height="140" src="https://i-blog.csdnimg.cn/direct/3fa68e1433fb40678860eef3201c3d84.png" width="819"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        ref
       </code>
      </h4>
     </li>
    </ul>
    <p>
     当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是
     <code>
      ref
     </code>
     ，比方说下边这个查询：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';</code></pre>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/02e72cbecf5a4b0ab446ef7c4b67f084.png" width="823"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        fulltext
       </code>
      </h4>
     </li>
    </ul>
    <blockquote>
     <p>
      全文索引
     </p>
    </blockquote>
    <ul>
     <li>
      <h4>
       <code>
        ref_or_null
       </code>
      </h4>
     </li>
    </ul>
    <blockquote>
     <p>
      当对普通二级索引进行等值匹配查询，该索引列的值也可以是
      <code>
       NULL
      </code>
      值时，那么对该表的访问方法就可能是
      <code>
       ref_or_null
      </code>
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;</code></pre>
    <p>
     <img alt="" height="110" src="https://i-blog.csdnimg.cn/direct/4277f1f005fc48ed901d8295950d1134.png" width="822"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        index_merge
       </code>
      </h4>
     </li>
    </ul>
    <blockquote>
     <p>
      一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用
      <code>
       Interseation、union、Sort-Union
      </code>
      这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的。从执行计划的
      <code>
       type
      </code>
      列的值是
      <code>
       index_merge
      </code>
      就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';</code></pre>
    <p>
     <img alt="" height="105" src="https://i-blog.csdnimg.cn/direct/78c882d640bf4f939e186703a5dbf1d3.png" width="1026"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        unique_subquery
       </code>
      </h4>
     </li>
    </ul>
    <blockquote>
     <p>
      类似于两表连接中被驱动表的
      <code>
       eq_ref
      </code>
      访问方法，
      <code>
       unique_subquery
      </code>
      是针对在一些包含
      <code>
       IN
      </code>
      子查询的查询语句中，如果查询优化器决定将
      <code>
       IN
      </code>
      子查询转换为
      <code>
       EXISTS
      </code>
      子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的
      <code>
       type
      </code>
      列的值就是
      <code>
       unique_subquery
      </code>
      ，比如下边的这个查询语句：
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';</code></pre>
    <p>
     <img alt="" height="154" src="https://i-blog.csdnimg.cn/direct/e14f271042664e37b82925052ee58939.png" width="1032"/>
    </p>
    <ul>
     <li>
      <h4>
       <code>
        index_subquery
       </code>
      </h4>
     </li>
    </ul>
    <blockquote>
     <p>
      <code>
       index_subquery
      </code>
      与
      <code>
       unique_subquery
      </code>
      类似，只不过访问子查询中的表时使用的是普通的索引
     </p>
    </blockquote>
    <h4>
     <code>
      range
     </code>
    </h4>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');</code></pre>
    <p>
     <img alt="" height="129" src="https://i-blog.csdnimg.cn/direct/23e66388584e4c66ab4e348a434942b5.png" width="964"/>
    </p>
    <p>
     或者：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'a' AND key1 &lt; 'b';</code></pre>
    <p>
     <img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/ba7eff6c652f4545948918ed5841e588.png" width="966"/>
    </p>
    <h4>
     <code>
      index
     </code>
    </h4>
    <blockquote>
     <p>
      当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是
      <code>
       index
      </code>
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';</code></pre>
    <h4 style="background-color:transparent">
     <img alt="" height="126" src="https://i-blog.csdnimg.cn/direct/99783086bc7d4a7abdb6c2fa6ebdcf69.png" width="968"/>
     <code>
      ALL
     </code>
    </h4>
    <p>
     最熟悉的全表扫描，就不多说了，直接看例子：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1;</code></pre>
    <p>
     <img alt="" height="151" src="https://i-blog.csdnimg.cn/direct/e63ab1d5f5de459da9e350c027377529.png" width="962"/>
    </p>
    <p>
     <strong>
      小结:
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       结果值从最好到最坏依次是：
      </strong>
     </p>
     <p>
      <strong>
       system &gt; const &gt; eq_ref &gt; ref
      </strong>
      &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL
     </p>
     <p>
      <strong>
       其中比较重要的几个提取出来（见上图中的粗体）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）
      </strong>
     </p>
    </blockquote>
    <h3>
     possible_keys和key
    </h3>
    <blockquote>
     <p>
      在EXPLAIN语句输出的执行计划中，
      <code>
       possible_keys
      </code>
      列表示在某个查询语句中，对某个列执行
      <code>
       单表查询时可能用到的索引
      </code>
      有哪些。
      <strong>
       一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。
       <code>
        key
       </code>
       列表示
       <code>
        实际用到的索引
       </code>
       有哪些
      </strong>
      ，
      <strong>
       如果为NULL，则没有使用索引
      </strong>
      。执行计划的
      <code>
       possible_keys
      </code>
      列的值是
      <code>
       idx_key1, idx_key3
      </code>
      ，表示该查询可能使用到
      <code>
       idx_key1, idx_key3
      </code>
      两个索引，然后
      <code>
       key
      </code>
      列的值是
      <code>
       idx_key3
      </code>
      ，表示经过查询优化器计算使用不同索引的成本后，最后决定采用
      <code>
       idx_key3
      </code>
      。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z' AND key3 = 'a';</code></pre>
    <p>
     <img alt="" height="139" src="https://i-blog.csdnimg.cn/direct/7f2bd0a573b3436e874db972d518dffa.png" width="1012"/>
    </p>
    <h3>
     key_len
    </h3>
    <p>
     实际使用到的索引长度 (即：字节数)，帮你检查
     <code>
      是否充分的利用了索引
     </code>
     ，
     <code>
      值越大越好
     </code>
     ，主要针对于联合索引，有一定的参考意义。
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;</code></pre>
    <blockquote>
     <p>
      int 占四个字节
     </p>
    </blockquote>
    <p>
     <img alt="" height="143" src="https://i-blog.csdnimg.cn/direct/d6f9861351664bf7a9837c62fc5606c1.png" width="949"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</code></pre>
    <blockquote>
     <p>
      key2上有一个唯一性约束，是否为NULL占用一个字节，那么就是5个字节
     </p>
    </blockquote>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/589d7c3c314d4432896a47c2a07ead75.png" width="943"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';</code></pre>
    <blockquote>
     <p>
      key1 VARCHAR(100) 一个字符占3个字节，100*3，是否为NULL占用一个字节，varchar的长度信息占两个字节。
     </p>
    </blockquote>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/620a56782be148818d9a219a97dfe900.png" width="954"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a';</code></pre>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/ff25c9c2c528421f8c4e587fd03451c7.png" width="952"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a' AND key_part2 = 'b';</code></pre>
    <p>
     <img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/081445b734314a3b9af9207da1923caf.png" width="956"/>
    </p>
    <h3>
     ref
    </h3>
    <blockquote>
     <p>
      ref列展示得就是与索引列作等值匹配的数据结构是什么，到底是常数还是
     </p>
    </blockquote>
    <p>
     <img alt="" height="139" src="https://i-blog.csdnimg.cn/direct/f39da9e0bb0042cdb83daa42701c07b4.png" width="865"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';</code></pre>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/6480a94f11c841ca9ac99b6057f9b16b.png" width="952"/>
    </p>
    <p>
     可以看到
     <code>
      ref
     </code>
     列的值是
     <code>
      const
     </code>
     ，表明在使用
     <code>
      idx_key1
     </code>
     索引执行查询时，与
     <code>
      key1
     </code>
     列作等值匹配的对象是一个常数，当然有时候更复杂一点:
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</code></pre>
    <p>
     <img alt="" height="163" src="https://i-blog.csdnimg.cn/direct/97803d2d06ba48ae97083721c16b8815.png" width="952"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</code></pre>
    <p>
     <img alt="" height="149" src="https://i-blog.csdnimg.cn/direct/d09683f4a54748d785cdf99036055dff.png" width="954"/>
    </p>
    <h3>
     rows
    </h3>
    <p>
     预估的需要读取的记录条数，
     <code>
      值越小越好
     </code>
     。
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z';</code></pre>
    <p>
     <img alt="" height="129" src="https://i-blog.csdnimg.cn/direct/c9e90d2022824a949979efcd8d2ee0a0.png" width="951"/>
    </p>
    <h3>
     filtered
    </h3>
    <blockquote>
     <p>
      某个表经过搜索条件过滤后剩余记录条数的百分比，如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z' AND common_field = 'a';</code></pre>
    <p>
     <img alt="" height="121" src="https://i-blog.csdnimg.cn/direct/a88a984b8dec41dfbc3a32267aa10ac2.png" width="958"/>
    </p>
    <p>
     对于单表查询来说，这个filtered的值没有什么意义，我们
     <code>
      更关注在连接查询中驱动表对应的执行计划记录的filtered值
     </code>
     ，它决定了被驱动表要执行的次数 (即: rows * filtered)
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a';</code></pre>
    <blockquote>
     <p>
      从执行计划中可以看出来，查询优化器打算把
      <code>
       s1
      </code>
      作为驱动表，
      <code>
       s2
      </code>
      当做被驱动表。我们可以看到驱动表
      <code>
       s1
      </code>
      表的执行计划的
      <code>
       rows
      </code>
      列为
      <code>
       9688
      </code>
      ，filtered列为
      <code>
       10.00
      </code>
      ，这意味着驱动表
      <code>
       s1
      </code>
      的扇出值就是
      <code>
       9688 x 10.00% = 968.8
      </code>
      ，这说明还要对被驱动表执行大约
      <code>
       968
      </code>
      次查询。
     </p>
    </blockquote>
    <p>
     <img alt="" height="88" src="https://i-blog.csdnimg.cn/direct/508d9f05a4034c6095c6d2be919badb2.png" width="1094"/>
    </p>
    <h3 style="background-color:transparent">
     Extra
    </h3>
    <blockquote>
     <p>
      顾名思义，
      <code>
       Extra
      </code>
      列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来
      <code>
       更准确的理解MySQL到底将如何执行给定的查询语句
      </code>
      。MySQL提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。
     </p>
    </blockquote>
    <ul>
     <li>
      <code>
       No tables used
      </code>
     </li>
    </ul>
    <p>
     当查询语句没有
     <code>
      FROM
     </code>
     子句时将会提示该额外信息，比如：
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT 1;</code></pre>
    <p>
     <img alt="" height="146" src="https://i-blog.csdnimg.cn/direct/9392215b0cbb43b6adde2bc0a75e45eb.png" width="961"/>
    </p>
    <ul>
     <li>
      <code>
       Impossible WHERE
      </code>
     </li>
    </ul>
    <p>
     当查询语句的
     <code>
      WHERE
     </code>
     子句永远为
     <code>
      FALSE
     </code>
     时将会提示该额外信息
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;</code></pre>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/2fa1a77cb40c43e391ad63ed2182c4a6.png" width="902"/>
    </p>
    <ul>
     <li>
      <code>
       Using where
      </code>
     </li>
    </ul>
    <blockquote>
     <p>
      表示该查询语句使用了非索引字段的查询条件，即使使用了索引，有非索引的查询条件也是如此。
     </p>
    </blockquote>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/e78b36e214ab41cebfbd59506a901b22.png" width="827"/>
     <img alt="" height="142" src="https://i-blog.csdnimg.cn/direct/9ccdecf878f844698cdb50a8a153be88.png" width="909"/>
    </p>
    <p>
     <img alt="" height="114" src="https://i-blog.csdnimg.cn/direct/a9b0101f11a945ba8b79c02f294e5867.png" width="843"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a'; </code></pre>
    <p>
     <img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/0c8381bbd40c4005957835f984b4e72b.png" width="897"/>
    </p>
    <ul>
     <li>
      <code>
       No matching min/max row
      </code>
     </li>
    </ul>
    <blockquote>
     <p>
      当查询列表处有
      <code>
       MIN
      </code>
      或者
      <code>
       MAX
      </code>
      聚合函数，但是并没有符合
      <code>
       WHERE
      </code>
      子句中的搜索条件的记录时。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg';</code></pre>
    <p>
     <img alt="" height="129" src="https://i-blog.csdnimg.cn/direct/1643b6e746f44b8590f796b1f640132d.png" width="901"/>
    </p>
    <ul>
     <li>
      Using index
     </li>
    </ul>
    <blockquote>
     <p>
      当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在
      <code>
       Extra
      </code>
      列将会提示该额外信息。比方说下边这个查询中只需要用到
      <code>
       idx_key1
      </code>
      而不需要回表操作。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';</code></pre>
    <p>
     <img alt="" height="135" src="https://i-blog.csdnimg.cn/direct/ae252f7a29184485827fcffa4b172134.png" width="901"/>
    </p>
    <ul>
     <li>
      <code>
       Using index condition
      </code>
     </li>
    </ul>
    <p>
     有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：
    </p>
    <pre><code class="language-sql">SELECT * FROM s1 WHERE key1 &gt; 'z' AND key1 LIKE '%a';</code></pre>
    <blockquote>
     <p>
      模糊查询会使索引失效，之前的处理是，先处理key1这个范围查询，然后立马根据范围查询所得到的二级索引去进行回文匹配。
      <strong>
       现在的处理逻辑是，处理完范围查询后，就对得到的二级索引判断是否满足模糊查询的条件，如果不符合的，就不进行回表操作，这样省略了大量回表操作，减少随机IO。 这个改进就是
       <span style="color:#fe2c24">
        索引条件下推，
       </span>
       <span style="color:#0d0016">
        当mysql使用了
       </span>
       <span style="color:#fe2c24">
        索引条件下推
       </span>
       <span style="color:#0d0016">
        ，就会显示
       </span>
      </strong>
      <span style="color:#0d0016">
       <code>
        Using index condition
       </code>
      </span>
     </p>
    </blockquote>
    <p>
     <img alt="" height="365" src="https://i-blog.csdnimg.cn/direct/891a4abe7c4346ca98c867a4907c8266.png" width="832"/>
    </p>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/53e2ef3816e8416b9901fbd4a5d0050b.png" width="903"/>
    </p>
    <ul>
     <li>
      <code>
       Using join buffer (Block Nested Loop)
      </code>
     </li>
    </ul>
    <blockquote>
     <p>
      在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫
      <code>
       join buffer
      </code>
      的内存块来加快查询速度，也就是我们所讲的
      <code>
       基于块的嵌套循环算法
      </code>
      。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;</code></pre>
    <p>
     <img alt="" height="123" src="https://i-blog.csdnimg.cn/direct/31f1c3c726be4050aac19d6630ebdb36.png" width="907"/>
    </p>
    <ul>
     <li>
      <code>
       Not exists
      </code>
     </li>
    </ul>
    <blockquote>
     <p>
      当我们使用左(外)连接时，如果
      <code>
       WHERE
      </code>
      子句中包含要求被驱动表的某个列等于
      <code>
       NULL
      </code>
      值的搜索条件，而且那个列是不允许存储
      <code>
       NULL
      </code>
      值的，那么在该表的执行计划的Extra列就会提示这个信息。
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;</code></pre>
    <p>
     <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/de001e3134004f1299ba728f4b9d42fd.png" width="904"/>
    </p>
    <ul>
     <li>
      <code>
       Using intersect(...) 、 Using union(...) 和 Using sort_union(...)
      </code>
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       如果执行计划的
       <code>
        Extra
       </code>
       列出现了
       <code>
        Using intersect(...)
       </code>
       提示，说明准备使用
       <code>
        Intersect
       </code>
       索引合并的方式执行查询，括号中的
       <code>
        ...
       </code>
       表示需要进行索引合并的索引名称；
      </li>
      <li>
       如果出现
       <code>
        Using union(...)
       </code>
       提示，说明准备使用
       <code>
        Union
       </code>
       索引合并的方式执行查询;
      </li>
      <li>
       如果出现
       <code>
        Using sort_union(...)
       </code>
       提示，说明准备使用
       <code>
        Sort-Union
       </code>
       索引合并的方式执行查询。
      </li>
     </ul>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';</code></pre>
    <p>
     <img alt="" height="92" src="https://i-blog.csdnimg.cn/direct/7e62c83965904b88ae10219af1e87ff1.png" width="907"/>
    </p>
    <ul>
     <li>
      <code>
       Zero limit
      </code>
     </li>
    </ul>
    <p>
     当我们的
     <code>
      LIMIT
     </code>
     子句的参数为
     <code>
      0
     </code>
     时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 LIMIT 0;</code></pre>
    <p>
     <img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/740489658c8b442f94c0e5ef79f3515b.png" width="903"/>
    </p>
    <ul>
     <li>
      <code>
       Using filesort
      </code>
     </li>
    </ul>
    <blockquote>
     <p>
      有一些情况下对结果集中的记录进行排序是可以使用到索引的。
      <strong>
       如果在内存或者磁盘中进行排序那就统称为文件排序。
      </strong>
      需要注意的是，如果查询中需要使用
      <code>
       filesort
      </code>
      的方式进行排序的记录非常多，那么
      <strong>
       这个过程是很耗费性能的，我们最好想办法
       <code>
        将使用文件排序的执行方式改为索引进行排序
       </code>
       。
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</code></pre>
    <p>
     <img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/9ba66171bbcb41799c84e6252bd8af06.png" width="902"/>
    </p>
    <p>
     <img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/4bcd05843d8f49a7b9c3e06d355e4e6a.png" width="798"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</code></pre>
    <p>
     <img alt="" height="137" src="https://i-blog.csdnimg.cn/direct/83c38de7f9534cd1b691d24281efacd7.png" width="901"/>
    </p>
    <ul>
     <li>
      <code>
       Using temporary
      </code>
     </li>
    </ul>
    <p>
     <img alt="" height="110" src="https://i-blog.csdnimg.cn/direct/792a96dd0d874a4084923c20d715c8bf.png" width="798"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;</code></pre>
    <p>
     <img alt="" height="129" src="https://i-blog.csdnimg.cn/direct/2ee231621abf4c8483aed5c085d653eb.png" width="902"/>
    </p>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;</code></pre>
    <p>
     <img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/ca4404f05a4b4c938844a9a123dfbd92.png" width="899"/>
    </p>
    <blockquote>
     <p>
      执行计划中出现
      <code>
       Using temporary
      </code>
      并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们
      <strong>
       <code>
        最好能使用索引来替代掉使用临时表
       </code>
      </strong>
      ，比方说下边这个包含
      <code>
       GROUP BY
      </code>
      子句的查询就不需要使用临时表：
     </p>
    </blockquote>
    <pre><code class="language-sql">mysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</code></pre>
    <p>
     <img alt="" height="135" src="https://i-blog.csdnimg.cn/direct/e5d2e62ac9fa493a90179356c1c57d6e.png" width="903"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36343133333133302f:61727469636c652f64657461696c732f313435393839363033" class_="artid" style="display:none">
 </p>
</div>


