---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353931323330372f:61727469636c652f64657461696c732f313038363631343739"
layout: post
title: "软件测试必问必背面试题"
date: 2020-10-30 22:16:29 +0800
description: "+次，点赞1.5k次，收藏1.软件测试必问必背面试题01 软件测试理论部分1.1"
keywords: "软件测试人员考试题目"
categories: ['软件测试工程师面试合集']
tags: ['面试', '软件测试']
artid: "108661479"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=108661479
    alt: "软件测试必问必背面试题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=108661479
featuredImagePreview: https://bing.ee123.net/img/rand?artid=108661479
---

# 软件测试必问必背面试题

<https://blog.csdn.net/weixin_45912307/article/details/108661479>

#### 

* + - [01 软件测试理论部分](#01__2)
    - * [1.1 测试概念](#11__3)
      * [1.2 软件开发模型](#12__77)
      * + [1. 软件生命周期](#1__79)
        + [2. 瀑布模型](#2__83)
        + [3 . 快速原型模型(现在特别流行模式) Axure 软件](#3___Axure__92)
        + [4. 增量模型(最常用开发模型之一)](#4___100)
        + [5. 迭代模型 开发进度快](#5____104)
        + [6. 螺旋模型](#6__117)
      * [1.3 软件测试模型](#13__127)
      * + [1. v模型](#1_v_128)
        + [2. w模型](#2__w_139)
        + [3. h模型](#3_h_151)
        + [4. x模型](#4_x_160)
        + [5. 软件测试生命周期](#5__168)
      * [1.4设计用例方法](#14_185)
      * [1.5 测试分类](#15__203)
      * + [1.按开发阶段划分](#1_204)
        + [2.按测试技术划分](#2_219)
        + [3. 按代码运行划分](#3__227)
        + [4. 按软件特性](#4__233)
        + [5. 其他测试](#5__238)
    - [02shell编程和命令部分](#02shell_243)
    - * [2.1shell常用命令](#21shell_244)
      * [2.2 linux三剑客：grep、sed、awk 、[find]](#22_linuxgrepsedawk_find_288)
    - [03 数据库部分](#03__307)
    - * + [3.1概念](#31_308)
      * [3.2表结构操作](#32_363)
      * [1.修改表结构](#1_377)
      * [3.3数据库增删改查](#33_389)
      * + [3.1.1 DML-INSERT](#311_DMLINSERT_392)
        + [3.1.2. 删除 delete](#312___delete_400)
        + [3.3.3 DML--UPDATE 更新](#333_DMLUPDATE__405)
        + [3.3.4. select 查询](#334_select__412)
      * [3.4 数据库表连接查询：子查询、内连接、外连接](#34__445)
      * [3.4数据库视图、索引、事务](#34_534)
      * + [3.4.1 事务处理](#341___535)
        + [3.4.2 索引](#342__555)
        + [3.4.3 视图](#343__638)
        + [3.4.4 存储过程](#344__674)
    - [04 计算机网络部分](#04__704)
    - [05 web和app自动化](#05_webapp_826)
    - * [1. web元素定位七种方式](#1_web_827)
      * [2. app元素定位3种方式](#2_app3_841)
      * [3. adb常用命令](#3_adb_845)
      * [3. 键盘操作常用函数](#3__884)
      * [4. 鼠标操作常用函数](#4__894)
      * [5. selenium 原理](#5_selenium__900)
      * [6. apppium：](#6_apppium_902)
      * [7. fixture](#7_fixture_910)
    - [06 python语法和高级编程](#06_python_916)
    - [07数据结构和算法](#07_917)
    - [7.1 概念](#71__918)
    - [7.2必考算法题](#72_955)

#### 01 软件测试理论部分

##### 1.1 测试概念

**1. 请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试**

* 单元测试：完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码
* 集成测试：通过测试发现与模块接口有关的问题
* 系统测试：是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件
* 回归测试：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性
* 验收测试：这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。
  `验收测试包括Alpha测试和Beta测试。`
  + **Alpha测试**
    ：是由用户在开发者的场所来进行的，在一个受控的环境中进行。并且在开发者对用户的指导下进行测试，开发者负责记录发现的错误和使用中遇到的问题
  + **Beta测试**
    ：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场。由用户记录在测试中遇到的一系列问题，并定期报给开发者。

**2. 什么是黑盒？什么是白盒？黑盒和白盒的测试方法分别有哪些？**

* `黑盒:`
  黑盒测试也称功能测试或数据驱动测试。
  `把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，对程序接口进行测试。“黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试`
  + `常用的黑盒测试方法`
    ：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。
* `白盒测试:`
  也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试
  + `常用白盒测试方法：`
    - 静态测试：不用运行程序的测试;
    - 动态测试：需要执行代码，通过运行程序找到问题;
  + `逻辑覆盖包括`
    :语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖
    - 1.语句覆盖每条语句至少执行一次。
    - 2.判定覆盖每个判定的每个分支至少执行一次。
    - 3.条件覆盖每个判定的每个条件应取到各种可能的值。
    - 4.判定/条件覆盖同时满足判定覆盖条件覆盖。
    - 5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。
    - 6.路径覆盖使程序中每一条可能的路径至少执行一次。

**3. 测试流程：**

* 需求测试->概要设计测试->详细设计测试->单元测试->集成测试->系统测试->验收测试

**4. app测试性能指标**

* 内存
* cpu
* 流量
* 启动速度

**5. web测试和app测试不同点**

* **系统架构方面：**

  + web项目，一般都是b/s架构，基于浏览器的
  + app项目，则是c/s的，必须要有客户端，用户需要安装客户端。
  + `web测试只要更新了服务器端，客户端就会同步会更新。App项目 则需要客户端和服务器都更新`
* **性能方面:**

  + web页面主要会关注响应时间
  + 而app则还需要关心流量、电量、CPU、GPU、Memory等。
* **兼容方面：**

  + web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统方面的兼容
  + app测试则要看
    `分辨率，屏幕尺寸，操作系统、网络`
    。
  + web测试是基于浏览器的所以不必考虑安装卸载。
  + 而app是客户端的，则
    `必须测试安装、更新、卸载`
    。除了常规的安装、更新、卸载还要考虑到
    `异常场景:包括安装时的中断、弱网、安装后删除安装文件 。`

**6. 缺陷按优先级分为哪些类型？ p1-p5 面试重点**

* 缺陷必须立即解决
* 缺陷要求正常排队等待修复
* 缺陷可以在方便时被纠正
* 下一个版本修复
* 不修复

**7. 测试用例的内容是什么？ 面试重点**

* 用例编号
* 测试概述或用例标题
* 优先级
* 前置条件
* 输入数据
* 测试步骤
* 预期结果

**8. 测试结束的标准是什么？ 面试重点**

* 全部测试用例都被执行完成
* 未修改bug都被确认或置为应有状态，暂缓修改的问题都有详尽的解析
* 测试报告编写完成
* 测试收尾工作结束
* 测试总结完成
* 项目处于试运行或上线阶段
* 在测试计划中定义结束的标准：在一定性能下平稳运行多少天、本版本没有严重bug，普通buh数量在多少个以下，bug修复百分之多少以上
    
  ；实际测试达到上述要求，由项目、开发、测试经理共同签字，认同测试结束，版本即可发布。

##### 1.2 软件开发模型

软件生命周期： 从软件最初构思到最终消亡(退役)的过程。

###### 1. 软件生命周期

`立项 ---需求分析 ---设计、编码、测试 ---发布 ---运行维护 ---淘汰`
  
软件立项===》可行性研究 ===》需求分析 ===》概要设计 ===》详细设计 ===》编码实现 ===》单元测试 ===》集成测试 ===》系统测试 ===》验收测试 ==》运行维护

###### 2. 瀑布模型

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a5d685828b3e2a5eecf290fe94e9b83e.png#pic_center)

```
缺点：
	1. 各阶段划分完全固定，阶段之间产生大量文档，极大增加工作量
	2. 由于开发模型是线性的，用户只有等到整个过程的末期才能看到开发结果，增加开发风险
	3. 不适应用户需求变化

```

###### 3 . 快速原型模型(现在特别流行模式) Axure 软件

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fb16c0001b7a0e159305390b3cb4097b.png#pic_center)

```
1. 原理：迅速搭建一个可以运行的软件原型，以便理解和澄清问题，使开发人员与用户达成共识，最后在确定需求基础上开发客户满意的软件产品
2. 特点：`适合预先不能确切定义需求的软件系统的开发`
3. 优点： ` 克服瀑布模型缺点，减少由于软件需求不明确带来的开发风险 `

```

###### 4. 增量模型(最常用开发模型之一)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/edaa1a803f313105587afefea869a8e1.png#pic_center)
  
`分批次地分析、设计、编码和测试这些增量组件。`

###### 5. 迭代模型 开发进度快

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9b9301b8e37cbce1fe15d374373998df.png#pic_center)

```
1. 原理
	`强调开发的深入 ---优化过程
	`开发迭代是一次完整地经过所有工作流程的过程：需求分析、设计、实施和测试工作流程
2. 优点
	降低在一个增量上的开支风险
	降低产品无法按照既定进度进入市场的风险
	加快开发工作进度`
	适应需求变化快的场景`

```

###### 6. 螺旋模型

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e83ad5e57f111671778798313d8d74d8.png#pic_center)

```
1. 原理：
   兼顾了快速模型的迭代的特征以及瀑布模型的系统化与严格监控
2. 优点
	最大特点：引入其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减少损失
	适合大型昂贵的系统级的软件应用

```

##### 1.3 软件测试模型

###### 1. v模型

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/16dfc3bf40c0c6e0b4bfa675a7dd53e5.png#pic_center)

```
1. 原理：揭示开发过程和测试过程中各阶段的对应关系
2. 缺点与不足：
	仅把测试过程作为需求分析、系统设计及编码之后的一个阶段，忽略了测试对需求分析、系统设计的验证
	需求的满足情况一直到后期验收测试才被验证
	没有体现出“尽早和不断地进行软件测试”原则

```

###### 2. w模型

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/22d8e3393da1ded9471b69c58eca4cb5.png#pic_center)

```
1. 由两个 v 字模型组成，分别代表测试与开发过程，明确表示了测试与开发并行关系
2. 优点：
	测试活动与软件开发同步进行
	测试对象不仅是程序，包括需求与设计
	尽早发现软件缺陷可降低软件开发成本
3. 局限性：无法支持迭代开发模型（没有循环过程）

```

###### 3. h模型

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/62aa993103282bd04aff49581a527255.png#pic_center)

```
1. 将测试活动完全独立出来，形成一个完全独立的流程
2. 只要测试条件成熟了，测试准备活动完成了，测试执行活动就可以进行了
3. 软件测试要尽早准备，尽早执行，不同测试活动可按某个次序先后进行，也可反复进行（迭代）

```

###### 4. x模型

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9fc9a5557317de829a1078ea69c3938b.png#pic_center)

```
1. 针对单独的程序片段进行相互分离的编码和测试；
2. 定位了探索性测试，这是不进行事先计划的特殊类型的测试；

```

###### 5. 软件测试生命周期

获取测试需求
  
编写测试计划
  
制定测试方案
  
开发与设计测试用例
  
执行测试
  
提交缺陷报告
  
测试分析与评审
  
提交测试总结
  
准备下一版本测试

**6. 简述缺陷的生命周期？ 面试重点**

* 软件测试人员提交缺陷报告；
* 测试负责人审核后将缺陷分配给相关开发人员修复
* 缺陷被修改后有测试人员根据缺陷报告中修改记录进行返测
* 返测通过的缺陷由负责人关闭；
* 返测未通过的缺陷直接返回给开发人员重新修改，然后再由测试人员返测，直到测试和开发达成一致处理意见。

##### 1.4设计用例方法

**1. 黑盒测试**

* 等价类划分法
    
  将系统的输入域划分为若干部分，然后从每个部分选取少量代表性数据进行测试。等价类可以划分为
  `有效等价类和无效等价类`
* 边界值分析法
    
  是通过优先选择不同等价类间的边界值覆盖有效等价类和无效等价类来更有效的进行测试，因此该方法要和等价类划分法结合使用。
* 正交试验法
    
  正交是从大量的试验点中挑选出适量的、有代表性的点
* 状态迁移法
    
  是对一个状态在给定的条件内能够产生需要的状态变化，有没有出现不可达的状态和非法的状态
* 判定表分析法
    
  判定表是分析和表达多种输入条件下系统执行不同动作的工具，
* 因果图法
    
  因果图是用于描述系统输入输出之间的因果关系、约束关系。

**2. 白盒测试**

* `静态`
  :
* `动态`
  ：逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试

##### 1.5 测试分类

###### 1.按开发阶段划分

* **单元测试(模块测试)**
    
  `针对软件设计的最小单位---程序模块进行正确性校验的测试工作。`
    
  `目的：检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误。`
    
  `单元测试需要从程序内部结构出发设计测试用例`
    
  `多个模块平行独立地进行单元测试`
* **集成测试(组装测试)：**
  有序、递增的测试，持续不断的过程，持续时间比较长
    
  在单元测试基础上，将所有程序模块进行有序、递增的测试。
    
  基础测试是检验程序单元或部件的接口关系，逐步成为符合概要设计要求的程序部件或整个系统
* **确认测试(有效性测试)----时间短**
    
  在模拟环境下，验证软件所有功能和性能及其他特性是否与用户预期要求一致。
* **系统测试：**
    
  在真实系统运行环境下，检查完整的程序系统能否和系统(硬件、外设、网络和系统软件、支持平台)正确配置、连接，最终满足用户的所有需求
* **验收测试**
    
  按项目任务书或合同、供需双方约定的验收依据文档进行的对整个系统的测试与评审，决定是否接收或拒收系统；

###### 2.按测试技术划分

* 黑盒测试(80%)
    
  通过软件外部表现来发现其缺陷和错误。
  `黑盒测试把测试对象看出一个黑盒子，完全不考虑程序内部结构和处理过程。在程序界面处进行测试，只是检查程序是否按照需求规格说明书的规定正常实现`
* 白盒测试(结构测试)：不管黑盒测试做得有多完全，白盒测试也有必要做
    
  `通过对程序内部结构和分析、检测来寻找问题。`
    
  `把测试看成一个透明的盒子里，检测是否所有结构及路径都是正确的，检查软件内部动作是否按照设计说明的规定正常进行`
* 灰盒测试(接口测试)
    
  `关注输出对输入的正确性`

###### 3. 按代码运行划分

* 静态测试：不实际运行被测对象，而是静态检查程序代码、界面或文档中可能存在错误的过程
* 代码测试：主要测试代码是否符合相应的标准和规范
* 界面测试：主要测试软件的实际界面与需求中的说明是否相符
* 文档测试：主要测试用户手册和需求说明是否真正符合用户的实际需求
* 动态测试： 实际运行被测对象，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程，所以我们
  `判断一个测试属于动态还是静态测试，唯一标准就是看是否运行程序`

###### 4. 按软件特性

* 功能测试(黑盒测试)：黑盒测试一方面，检查实际软件功能是否符合用户需求
* 性能测试：关注软件中某一功能在指定的时间、空间条件下，是否使用正常
    
  主要有时间性能和空间性能
* 安全性测试：验证按在系统内的包含机制能否在实际应用中对系统进行保护使之不被非法入侵，不受各种因素干扰

###### 5. 其他测试

* 回归测试：对软件新版本测试时，重复执行之前某一个重要版本的测试用例(测试过程)
    
  目的：验证之前版本产生所有缺陷是否已被修复；确认修复这些缺陷没后引发新的缺陷
* 冒烟测试(可行性测试)：先验证一下软件基本功能是否实现，在对一个新版本进行系统大规模测试

#### 02shell编程和命令部分

##### 2.1shell常用命令

**1. 怎么用shell命令查看行号**

* 获取文本对应文本的行号,可以用grep，也可以用sed
  + grep -n “xxx” a.txt | cut -d “:” -f 1
  + sed -n -e ‘/xxx/=’ a.txt

**2. 怎么查进程id**

* shell获取进程ID的方法有三种：
  + 1、ps -A |grep “cmdname”| awk ‘{print $1}’
  + 2、pidof “cmdname”
  + 3、pgrep “cmdname”

**3. 网络相关常用命令**

* `ifconnfig：`
  查看网卡配置信息
* `route`
  显示路由表
* `netstat:`
  查看本地计算机所使用的网络服务状况
* `ping:`
  测试本地计算机与目标主机是否连接 如ping 127.0.0.1

**4. linux查看进程**

* ps a 显示现行终端机下的所有程序，包括其他用户的程序。
* ps u 以用户为主的格式来显示程序状况。
* ps x 显示所有程序，不以终端机来区分。
* 最常用的方法是ps -aux

**5. top**

* 用于实时显示 process 的动态。
* 语法：
  `top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]`

**6. 查看磁盘**

* df命令参数功能：检查文件系统的磁盘空间占用情况
* du：检查磁盘空间使用量
* fdisk：用于磁盘分区

**7. 查看端口号、进程的指令是？动态查看日志的指令？怎么判断一个端口存不存在，磁盘满了怎么处理，删除一个目录下的txt文件，你还熟悉其他什么linux指令？**

* 查看端口号命令：
  + `netstat –tunlp|grep 端口号`
  + `lsof -i:端口号`
* 查看进程指令
  + `ps -ef |grep 进程`
  + -e 　显示所有程序。
  + -f 　 显示UID,PPIP,C与STIME栏位。
* 动态查看日志
  + 1、先切换到：cd usr/local/tomcat5/logs
  + 2、tail -f catalina.out

##### 2.2 linux三剑客：grep、sed、awk 、[find]

1. `grep：指定文件中搜索特定的内容，并将含有这些内容的行标准输出`

* 格式：grep [options] 文件名
* [options]主要参数：
  + －c：只输出匹配行的计数
  + －i：不区分大小写（只适用于单字符）
  + －h：查询多文件时不显示文件名
  + －l：查询多文件时只输出包含匹配字符的文件名
  + －n：显示匹配行及行号
  + －s：不显示不存在或无匹配文本的错误信息
  + －v：显示不包含匹配文本的所有行
  + -e：使用正则匹配
  + -E：使用扩展正则
  + `--color=auto`
    ：将

2. sed 流文本编辑器
3. awk 文本和数据处理，
4. `find作用是在目录中搜索文件，它的使用权限是所有用户。`

* 格式：
  `find [path][options][expression]`
  + path指定目录路径。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。

#### 03 数据库部分

###### 3.1概念

**1. 主键：**
主关键字primary key
  
`针对一个表来说的，主键修饰的列：唯一，不能重复，不能为空；一个表中只能只有一个主键`

**2. 外键：**
  
`针对两个表来说，加强表与表之间联系`

**3. 关系模型的规范化：**
关系模式要满足的条件称为规范化形式，范式(NF)

* **目的：消除储存异常，减少数据冗余，保证数据完整性和存储效率**
* `如果关系 R 的所有属性均为简单属性，每个属性是不可再分的(无重复的列），则 R 满足第一范式`
* `第二范式(2NF)：关系 R 满足第一范式，每一个非主键关键字段完全依赖于主键，则称 R 满足第二范式`
* `第三范式(3NF):关系 R 满足第二范式，且非关键字段之间不存在依赖关系，则称满足第三范式。(从表只能引用主表中一个列)`
* **总结：**
  `一个基本的关系型数据库，需要满足第一范式；一个完整的关系型数据库要满足第三范式`

**4. 唯一约束**

* 特征：
    
  不允许出现重复的值，但是可以为多个 null
    
  同一个表中可以有多个唯一约束
    
  如果不给唯一约束名称，就默认和列名相同

**5. 非空约束**

* 格式：
  `列名 数据类型 not null`
* 一个表里面也可以有多个非空约束

**6. 默认约束**
default 一个表中可以有多个默认约束

**7. 外键约束**

* 表的外键值必须在主表中能找到
* 当主表记录被从表参照时，主表的记录将不允许删除
* 如果要删除数据，需要先删除表中依赖该记录的数据（删从表记录）
* 主表：被引用的表(被参照的表) zhu
* 从表：应用的表 外键约束建立在表里面 cong
* 被引用的列，要么主键约束，要么唯一约束
* **注意**
  ：在引用过程中，主表和从表的来个两个列的数据必须保持一致。(内容也要保持一致)

**8. 检查约束**
  
描述：限制某个列的取值范围 年龄 18-25 性别：要么男或女

**9. 主键、外键作用，索引的优点与不足**

* 主键
    
  表中的唯一标示键
    
  作用：保证实体的完整性，加快数据库的操作速度。
* 外键：主键的从属，表示两个表之间的联系
    
  作用：作用外键可以建立数据之间的关联，避免冗余
* 索引：
  + 优点
    - 通过创建唯一性的索引，保证表中数据唯一性
    - 加速数据的检索速度
    - 加快表与表之间的连接
    - 使用优化隐藏器，提供系统性能
  + 缺点：
    - 创建索引需要时间，
    - 索引需要占用物理空间
    - 当对表中数据进行修改时，索引也要动态维护，减低数据的维护速度。

##### 3.2表结构操作

**1. 表的创建语法**

```
   create table 表名(
   属性名1 数据类型 [约束条件],
   属性名2 数据类型 [约束条件],
   属性名3 数据类型 [约束条件]
   );

```

**2. 删除表**
  
`drop table 表名;`

**3. 删除多个表**
  
`drop table 表名 1,表名 2 ...`

##### 1.修改表结构

**1. 添加列(属性)**
  
`alter table 表名 add 属性名 数据类型;`

**2. 删除表(属性)**
  
`alter table 表名 drop 属性名;`

**3. 修改属性：数据类型**
  
`alter table 表名 modify 属性名 数据类型;`

**4. 修改字段名**
  
`alter table 表名 change 旧字段名 新字段名 数据类型;`

##### 3.3数据库增删改查

* `create alter drop desc`
  主要针对表结构来说的
* `insert delete update select`
  主要针对表中的数据来进行操作的

###### 3.1.1 DML-INSERT

insert 插入 值和列一一对应关系

* 格式 1：
    
  `insert into 表名(列名 1,列名 2 ...) values(值 1,值 2 ...);`
* 格式 2：
    
  `insert into 表名 values(值 1,值 2 ...);`
* 格式 3：
    
  `insert into 表名 values(值 1,值 2,值 3 ...),(值 1,值 2,值 3 ...);`

###### 3.1.2. 删除 delete

* 格式 1：代表清空表内的数据
    
  `delete from 表名;`
* 格式 2：
    
  **有条件的进行删除**
  ：
  `delete from 表名 where 条件;`

###### 3.3.3 DML–UPDATE 更新

* 格式 1
    
  `update table_name set 字段=值;`
* 格式 2
    
  `update table_name set 字段=值,字段=值;`
* 格式 3
    
  `update table_name set 字段=值,字段=值 where 条件;`

###### 3.3.4. select 查询

**1.基本格式**
:

* `select 列名 from 表名;`
* `select 列名 1,列名 2,列名 3 ... form 表名;`

**1. 使用关键字 distinct 查询**

* 在查询返回结果中删除重复行
* 语法：
  `select distinct 列名称 from 表名称;`
    
  只针对一个列去重

**2. 使用别名查询**

* 根据需要对数据显示的标题进行修改
    
  格式：
  `select 列名1 '别名',列名2 '别名',... from 表名;`
* AS 关键字连接列表达式和指定的别名
    
  `select 列名 as '别名' from 表名;`

**3. 条件查询**

* 格式：
  `select 列名 from 表名 where 条件;`
* 如果在查询过程中，有多个条件，可以使用 and 或 or 进行连接
* and 连接 —》同时满足； or 连接 ------只满足其一

**4. 范围搜索范围**

* 在范围之内
    
  `select 列名 from where 列名 between 开始值 and 结束值`
* 不在范围之内
    
  `select 列名 from 表名 where 列名 not between 开始值 and 结束值;`

**5. 列表搜索条件**

* `in`
  : 只要匹配到括号里任意一个值就会有查询结果；
  + 格式：
    `select 列名 from 表名 where 列名 in (值 1,值 2,值 3 ...)`
* `not in`
  ：
  + 格式：
    `select 列名 from 表名 where 列名 not in(值 1,值 2,值 3);`

##### 3.4 数据库表连接查询：子查询、内连接、外连接

**1. 多表查询**

* 去重
  + 显式

    ```
    	 select [distinct] A.列名,B.列名,C.列名,... from C 
    	 join A on A.key=C.FKeyA 
    	 join B on B.key=C.FKeyA and B.key=A.key
    	 [GROUP BY 字段名]

    ```
  + 隐式

    ```
    	select [distinct] A.列名,B.列名,C.列名,... from 表A,
    	表B,
    	表C
    	 where 表A.字段1 = 表B.字段1 and
    	 表B.字段2 = 表C.字段2 and ....
    	 [GROUP BY 表名.字段名]

    ```
* 排序

  ```
  select  A.列名,B.列名,C.列名,... from C 
   join A on A.key=C.FKeyA 
   join B on B.key=C.FKeyA and B.key=A.key
  [ORDER BY 表名.字段名]

  ```

**2. 子查询**

* 子查询只返回一个值
* 子查询首选使用in做匹配
* 子查询在其他查询结果的基础上提供了一种有效的方式来表示where字句的条件 。
* 子查询的selec查询总是使用圆括号括起来。
* 对于子查询来说，外查询条件要什么，子查询就查什么。 一一对应的关系。
* 子查询结果分类：
  + 标量子查询(子查询结果为单个值)：
    - 子查询返回的结果是单个值〔数字、字符串、日期等)
    - 常用操作符：= <> > >= <= <
  + 列子查询(子查询结果为一列)：子查询返回的结果是一列
    - 常用操作符：in、not in、any、some、all

    ```
    	select 列表名 from 表名 where 字段名 > all (子查询语句);
    	select 列表名 from 表名 where 字段名 > any (子查询语句);

    ```

    ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6757fe13c5526d492c3a54d9084e34f4.png)
  + 行子查询(子查询结果为一行)：
    - 常用操作符：=、<>、 in、not in
    - `select 字段名,... from 表名A where (字段名1,字段名2,...) = (select 字段名1值，字段名2值,... from 表名B where 条件)`
  + 表子查询(子查询结果为多行多列)：in
    - `select 字段名,... from 表名A where (字段名1,字段名2,...) in (select 字段名1值，字段名2值,... from 表名B where 条件)`

**3. 内连接**
：只有匹配到的情况下才会返回结果值

* 格式一(隐式)：

  ```
  from 表名1.列名1,表名1.列名2,表名2.列名1,表名2.列名2... 
  form 表名1,表名2
  where 表名1.列=表名2.列; //列为相同的列

  ```
* 格式二(显式):

  ```
  select 表名1.列名1,表名1.列名2,表名2.列名1,表名2.列名2... 
  from 表名1 inner join 表名2
  on 表名1.列=表名2.列

  ```

**4. 外连接**

* **外部连接会返回from字句中提到的至少一个表或视图中的所有行**
* 左连接：显示左边所有行。如果左表的某行在右表中没有找到匹配的行，则结果集中的右表相对应位置为null。

  ```
  select 表名1.列名1,表名1.列名2,表名2.列名1,表名2.列名2
  from 表名1 left outer join 表名2
  on 表名1.列=表名2.列; //列为大家共有的列

  ```
* 右连接：
  `显示右边所有行`

  ```
  right outer join
  select 表名1.列名1,表名1.列名2,表名2.列名1,表名2.列名2
  from 表名1 right outer join 表名2
  on 表名1.列=表名2.列; 

  ```
* 区分是左连接还是右连接：左连接以坐标为参考，左表没有则返回null，右连接以右表为参考，右表没有则返回null

**5.联合查询**

* 把多次查询的结果合并起来，形成一个新的查询结果集
* 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。
* union all会将全部的数据直接合并在一起，union 会对合并之后的数据去重。

  ```
  select 字段名 from 表A ....
  UNION [ALL]
  select 字段名 from 表B ...;

  ```

##### 3.4数据库视图、索引、事务

###### 3.4.1 事务处理

事务：一组操作的集合，由一系列语句构成的逻辑工作单元。是一个不可分割的工作单元，事务把所有操作作为一个整体一起向系统提交或撤销操作请求，这些请求要么同时成功，要么同时失败

**1. 事务的四个属性**

* 原子性：对数据库所做操作要么全部执行，要么全部取消
* 一致性：事务完成时候，必须使所有数据保持一致状态
* 隔离性：事务所作的修改必须和其他事务所作修改隔离
* 持久性：事务提交后，对数据库所做操作永久保存

**2. 事务操作**

* 查看事务提交方式：
  `SELECT @@autocommit ;`
* 设置事务提交方式：
  `SET @@autocommit = 0 ;`
* 开启事务：
  `START TRANSACTION`
  或
  `BEGIN`
* 提交事务：
  `commit`
  ：
* 撤销语句：
  `rollback`
  ：

**3. 并发事务引发的问题**

* 脏读：一个事务可以读到另一个事务未提交的数据
* 不可重复读：一个事务先后读取同一条记录，但读取的数据不一样
* 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”

###### 3.4.2 索引

**1. 定义：**
索引（index）是帮助MySQL高效获取数据的数据结构(有序)

**2. 创建索引主要作用**

* `加快数据索引`
* `保证数据唯一性`
* `表与表之间参照完整性`
* `在使用group by、order by子句进行查询时，利用索引可以减少排序和分组时间。`

**3. 索引不足之处**

* 建立索引，系统要占用大约为表的1.2倍的硬盘和内存空间来保存索引。
* 更新数据的时候，系统必须要有额外的时间来同时对索引进行更新，以维持数据和索引的一致性。

**4. 索引是否必须：**

* `创建索引需要占用数据空间并花费一定时间`
* `遍历索引会减慢数据修改速度`

**5. 索引结构分类**

* B+Tree索引：
  + 相对于B-tree的区别：1）所有数据都出现在叶子节点上；2）叶子节点形成一个单向链表
  + 在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能
* Hash索引：
  + 采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中
  + 高性能，底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询，只支持memory引擎
  + 如果两个(或多个)键值，映射到一个相同的槽位上，就产生了hash冲突（也称为hash碰撞），可以通过链表来解决
  + 特点：
    - 只能用于对等比较(==,in)，不支持范围查询（between，>,<,…)
    - 无法利用索引完成排序操作
    - 查询效率高，通常只需要检索一次就可以了，效率通常高于B+tree
* R-tree索引（空间索引）：主要用于地理空间数据类型，只支持MyISAM引擎
* Full-text（全文索引）：是一种通过建立倒排索引,快速匹配文档的方式

**6.索引分类**

* 主键索引：对于表中主键创建的索引，默认自动创建，有且只有一个
* 唯一索引：避免同一个表中某数据列中的值重复，可以有多个
* 常规索引：快速定位特定数据，可以有多个
* 全文索引：查找文本中的关键字，可以有多个

**6. 选择创建索引的数据列**

* `连接中频繁使用的列`
* `定义有主键和外键的列`
* `在指定范围中快速或频繁查询的列`
* `需要按排序顺序快速或频繁检索的列`

**7.聚合索引和辅助索引的区别？**

* 聚合索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，必须有且只有一个
* 辅助索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键(id)，可以存多个

**8. 创建索引**

* `create [UNIQUE|FULLTEXT] index 索引的名字 on 表名(列名);`
* 创建唯一索引:
    
  `create unique index 索引名字 on 表名(列名);`

**9. 删除索引**

* `drop index index_name on table_name;`
* `drop index 索引名字 on 表名;`

**10.sql索引优化**

* 查看sql执行频次：
  `show global STATUS like 'Com_______';`
* 慢查询日志
  + show variables like ‘slow\_query\_log’; # 查询是否打开了慢查询开关

  ```
  # find / -name -type f 'my.cnf'
  vi /etc/mysql/my.cnf
  # 开启慢查询日志查询开关
  slow_qurey_log=1
  # 设置慢日志时间
  long_query_time=1

  ```

  + systemctl restart mysql; # 重启mysql

  ```
  cd /var/lib/mysql
  tail -f xxxslow.log

  ```
* 查看 sql耗时

  ```
  select @@have_profiling; 			  # 是否支持profile操作
  select @@profiling # profiling		  # 开关是否已开启
  set profiling=1; 					  # 开启profiling
  show profiles;						  # 查看执行耗时
  show profile for query query_id; 	  # 查着指定query_id的SQL语句各个阶段的耗时情况
  show profile cpu for query query_id;  # 查看指定query_id的SQL语句CPU的使用情况

  ```

###### 3.4.3 视图

**1.视图定义**
：
`基于某个查询结果的虚表，是从一个或多个表或视图导出的表，视图数据的修改也会影响原表的数据`
insert update delete
  
**2.视图优点**

* `简化操作`
  ：使用数据库视图向最终用户和外部应用程序隐藏底层表的复杂性。通过数据库视图，只需要使用简单的 SQL 语句，不需要编写具有许多连接的复杂语句
* `安全性`
  ：
  + 将基表中重要的字段信息/敏感数据，可以不通过视图给用户
  + 允许创建只读视图以向特定用户公开只读数据，用户只能在只读视图中检索数据，但不能对其进行更新
* `独立性`
  ：视图可以使应用程序和数据库表在一定程度上独立

**3.视图缺点**

* `性能差`
  ：从数据库视图查询数据速度变慢，特别是如果视图是基于其他视图创建的
* `修改限制`
  ：
  + 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于比较复杂的试图,可能是不可修改的
  + 每当更改与视图关联的基本表的结构时，也必须更改视图

**4.视图语句**

* 创建视图
    
  `create view 视图名字 as select 语句;`
* 修改视图
    
  `alter view 视图名`
* 在视图中插入一行数据
    
  `insert into 视图名字 vulues(值1,值2...);`
* 修改视图数据
    
  `update 视图名字 set 列=值 where 条件;`
* 删除视图中数据
    
  `delete from 视图名字 where 条件;`
* 删除视图
    
  `drop view 视图名字;`
* 删除多个视图"
    
  `drop view 视图名1,视图名2,视图名3;`

###### 3.4.4 存储过程

**1.存储过程定义**
  
事先经过编译并存储在数据库中的一段sql语句的集合。减少数据在数据库和应用服务器之间的传输，提高数据处理的效率

**2.存储过程特点**

* 封装、复用
* 可以接收参数，也可以返回参数
* 减少网络交互，效率提升

**3.存储过程基本语法**

* 创建

  ```
  create PROCEDURE 存储过程名称([参数列表])
  BEGIN
  		sql语句
  END;

  ```
* 调用

  ```
  call 存储过程名称([参数]);

  ```
* 查看

  ```
  SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = '数据库名称'; -- 查询指定数据库的存储过程及状态信息 
  SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义

  ```
* 删除

  ```
  DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；

  ```

#### 04 计算机网络部分

**1. 三次握手，四次挥手过程**

* `三次握手：`
  + `第一次握手`
    ：客户端发送syn包(syn=1，seq=x)到服务器，并进入SYN\_SENT状态，等待服务器确认；
  + `第二次握手`
    ：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN\_RECV状态；
  + `第三次握手：`
    客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
      
    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

* `四次挥手:`
  断开一个TCP连接则需要“四次挥手”。
  + `第一次挥手：`
    主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
  + `第二次挥手：`
    被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
      
    -
    `第三次挥手：`
    被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
  + `第四次挥手：`
    主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

**2. OSI，TCP/IP，五层协议的体系结构，以及各层协议**

* OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
* TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。
* 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。
* 每层作用
  + 物理层：
    `传输二进制比特流`
  + 数据链路层：
    `负责将上层数据封装成帧`
  + 网络层：
    `负责路由寻址和广播 ；广播：发送消息和接收消息`
      
    \*传输层：
    `负责建立一个可靠的端到端的连接；端到端：发送到接收 ；过程：建立、维护、撤销(拆除)`
  + 会话层：
    `负责建立维护拆除会话，为端应用之间提供控制功能(可靠性)`
  + 表示层：
    `完成对传输数据格式转换：格式化；发：加密；接：解密；发：压缩，接：解压缩`
  + 应用层：
    `对应用软件提供网络支持`

**3. cookie、session、token**

* `cookie:在客户端存储在客户端用于存储会话信息的`
* session：在服务器端，
  `记录用户的请求状态，`
  一般默认时间30min
  + session\_id会存在cookie中，每次请求cookie中所有信息都会传递给服务器，服务器通过session\_id来识别是否是同一个用户请求，不是同一个用户的话，就会要求重新登录
* `token：访问权限，保存在客户端本地`
  + 鉴权：访问的接口是否正常，是否非法访问绕过前端。
    `防止跳过页面直接访问接口**token**`
  + 授权：是否具有访问接口的权限。 唯一全局动态的 。

**4. 常用状态码**

* 100系列：请求已收到继续处理；
* 200系列:表示成功

  + 200：正常，服务器正确响应了请求
* 300系列：资源重定向；

  + 301:永久重定向；请求的网页已永久移动到新位置
  + 302：2临时重定向；被请求文档已经临时移至别处，此文档新的url在location响应头中给出
  + 303：浏览器对于POST的响应进行重定向至新的url
  + 307：浏览器对于GET的响应重定向至新的url
* 400系列：客户端错误：

  + 400：错误请求；服务器不理解请求的语法。
  + 401：未授权；如请求参数、方法、格式等
  + 403：拒绝访问；服务器理解客户的请求，但拒绝处理它（没有权限）
  + 404：请求资源不存在
* 500系列：服务器端出错

  + 500：服务器内部错误
  + 501：尚未实施；服务器不具备完成请求的功能
  + 502:服务器网关错误
  + 503：服务器由于维护或者负载过重未能应答
  + 504请求超时

**5. http请求头和响应头**

* http请求及其结构：
    
  请求信息包含：
  `请求行(request) 请求头部header 、空行和请求数据组成`
* 响应及其结构
    
  响应组成：
  `状态行、响应头报文、空行和响应正文`

**6. IP地址的分类**

* A类地址：以0开头， 第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）；
* B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；
* C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；
* D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）
* E类地址：保留
* 以下是留用的内部私有地址：

  + A类 10.0.0.0–10.255.255.255
  + B类 172.16.0.0–172.31.255.255
  + C类 192.168.0.0–192.168.255.255

**7. 常见一些词汇**

* `ARP:地址解析协议`
  （Address Resolution Protocol）
* `RARP:反地址解析协议`
  (Reverse Address Resolution Protocol）将ip地址转换为物理地址
* `FTP:文件传输协议`
  （File Transfer Protocol）
* `HTTP：超文本传输协议`
  （Hyper Text Transfer Protocol）
* `TCP:传输控制协议(`
  Transmission Control Protocol)
* `UDP:用户数据报协议`
  （User Datagram Protocol）

**8. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？**
  
建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。
  
`（1）TCP的三次握手过程：`
主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。
  
`（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。`
失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
  
（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。

**9. 常用四种请求方法**

* get：
* post
* put
* delete

**. get和post区别**

* GET - 从指定的资源请求数据。请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&连接
* POST - 向指定的资源提交要被处理的数据。POST请求会把请求的数据放置在HTTP请求包的包体中

**10. http和https区别**

* `HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。`
* HTTPS和HTTP的区别主要如下：
  + https需要到cat申请证书，需要交费
  + http是超文本传输协议，信息明文传输，https具有安全性的ssl加密传输协议
  + http和https使用完全不同的连接方式和端口号，前者80，后者443
  + http连接简单、无状态；https可进行加密传输、身份验证网络协议

**11. 请你说一下分布式和集群的概念。**
  
分布式：是指将不同的业务分布在不同的地方，
  
集群：是指将几台服务器集中在一起，实现同一业务。

分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的。集群有组织性，一台服务器垮了，其它的服务器可以顶上来，而分布式的每一个节点，都完成不同的业务，一个节点垮了，哪这个业务就不可访问了。

**12. 路由寻址(路由)：**
  
在路由器中，从一个接口接收到数据包，根据数据包所携带的目的地址进行定向转发到另一个接口的过程。

**13. HTTP协议工作原理**
  
浏览器作为HTTP客户端通过URL向http服务端即web服务器发送所有请求
  
web服务器根据接收到的请求后，向客户端发送响应信息

#### 05 web和app自动化

##### 1. web元素定位七种方式

1. 优先使用的6种
     
   find\_element\_by\_id (返回一个元素)
     
   find\_element(s)\_by\_class\_name (根据类名获取元素列表)
     
   find\_element(s)\_by\_name (根据标签的name属性值返回包含标签对象元素的列表)
     
   find\_element(s)\_by\_link\_text (根据连接文本获取元素列表)
     
   find\_element(s)\_by\_partial\_link\_text (根据链接包含的文本获取元素列表)
     
   find\_element(s)\_by\_tag\_name (根据标签名获取元素列表)
     
   find\_element(s)\_by\_css\_selector 根据css选择器获取
2. 万不得已下使用的两个
     
   find\_element(s)\_by\_css\_selector (根据css选择器来获取元素列表)
     
   find\_element(s)\_by\_xpath (返回一个包含元素的列表)

##### 2. app元素定位3种方式

by\_id
  
by\_class\_name
  
by\_xpath

##### 3. adb常用命令

* **adb 帮助**
  ：
  `adb --help`
* **启动adb 服务**
  ：
  `adb start-server`
* **关闭adb 服务**
  ：
  `adb kill-server`
* **获取设备号**
  ：
  `adb devices`
* **获取系统版本**
  ：
  `adb shell getprop ro.build.version.release`
* **发送文件到手机**
  ：
  `adb push 电脑端⽂件路径/需要发送的文件,手机端存储的路径`

  + adb push C:\Users\win\Desktop\xx.png /sdcard
* **从手机拉取文件**
  :
  `adb pull 手机端的路径/拉取文件名 电脑端存储文件路径`

  + adb pull /sdcard/xx.png C:\Users\win\Desktop
* **查看手机运行日志**
  :
  `adb logcat`
* **进入到手机终端**
  :
  `adb shell`
* **安装app到手机**
  :
  `adb install 路径/xxx.apk`
* **卸载手机app**
  :
  `adb uninstall app`
* **获取app启动包名和启动名**
  (⚠手机需要先打开对应app)

  1. **Mac/Linux:**
     `adb shell dumpsys window windows | grep mFocusedApp`
  2. **在 Windows 终端运⾏**
     ：
     `adb shell dumpsys window w | findstr mCurrent`
* **获取app启动时间:**
  `adb shell am start -W 包名/.启动名`
* **查看设备ip地址：**

  + `adb shell ifconfig wlan0`
  + `adb shell netcfg`
* **查看设备cpu信息：**
  `adb shell cat /proc/cpuinfo`
* **查看设备内存信息：**
  `adb shell cat /proc/meminfo`
* **点亮屏幕：**
  `adb shell input keyevent 224`
* **熄灭屏幕：**
  `adb shell input keyevent 223`

##### 3. 键盘操作常用函数

1. send\_keys(Keys.BACK\_SPACE)删除键（BackSpace）
2. send\_keys(Keys.SPACE)空格键(Space)
3. send\_keys(Keys.TAB)制表键(Tab)
4. send\_keys(Keys.ESCAPE)回退键（Esc）
5. send\_keys(Keys.ENTER)回车键（Enter）
6. send\_keys(Keys.CONTROL,‘a’) 全选（Ctrl+A）
7. send\_keys(Keys.CONTROL,‘c’)复制（Ctrl+C）
8. send\_keys(Keys.CONTROL,‘v’) 全选（Ctrl+V）
9. send\_keys(Keys.CONTROL,‘x’)复制（Ctrl+X）

##### 4. 鼠标操作常用函数

1. context\_click() 右击 --> 此方法模拟鼠标右键点击效果
2. double\_click() 双击 --> 此方法模拟双标双击效果
3. drag\_and\_drop() 拖动 --> 此方法模拟双标拖动效果
4. move\_to\_element() 悬停 --> 此方法模拟鼠标悬停效果
5. perform() 执行 --> 此方法用来执行以上所有鼠标方法

##### 5. selenium 原理

##### 6. apppium：

`开源、跨平台的UI自动化测试工具，`
支持多种语言编写的测试脚本
  
原理：
  
1. test scripts(测试脚本发送一个请求到appium server)
  
2. appium server接收到请求后进行解析并把请求转发给 bootstrap.jar。
  
3. jar接收到appium的命令，调用UIAutomator命令实现操作
  
4. 最终结果由bootstrap.jar返回给Appium server。

##### 7. fixture

1 .必须继承unittest.TestCase类，setUp、tearDown才是一个Fixture；
  
2. setUp：一般做初始化工作，比如：实例化浏览器、浏览器最大化、隐式等待设置
  
3. tearDown：一般做结束工作，比如：退出登录、关闭浏览器
  
4. 如果一个测试类有多个test开头方法，则每个方法执行之前都会运行setUp、结束时运行tearDown

#### 06 python语法和高级编程

#### 07数据结构和算法

#### 7.1 概念

**1. 几种基本的数据结构：链表、栈、队列、树**

* `链表是一种物理存储单元上非连续、非顺序的存储结构`
  ，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
* 栈和队列是比较特殊的线性表
  + `栈是只允许在一端插入和删除的表，后进先出`
  + `队列:先进先出。只允许在头部进行删除操作，在尾部进行插入操作`
* 树：树型结构是一类非线性数据结构

**2. 请回答数组和链表的区别，以及优缺点**

* 1.数组：
  + `将元素在内存中连续存放`
    ，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。
  + 如果应用
    `需要快速访问数据，很少插入和删除元素，就应该用数组。`
* 2.链表：
  + `链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起`
  + `如果应用需要经常插入和删除元素就需要用链表。`

**3. 有哪些排序算法**

* `1.冒泡排序：`
  通过与相邻元素的比较和交换来把小的数交换到最前面。时间复杂度为O(n^2)，空间复杂度是O(1)。
* `2. 选择排序：`
  在一次排序后把最小的元素放到最前面。选择排序是通过对整体的选择，只有在确定了最小数的前提下才进行交换。选择排序的时间复杂度为O(n^2),空间复杂度是O(1)属于不稳定排序.
* `3. 插入排序：`
  通过比较找到合适的位置插入元素来达到排序的目的。
  `注意在插入一个数的时候要保证这个数前面的数已经有序。`
  时间复杂度也是O(n^2)，空间复杂度为O(1)。是稳定排序
* `4. 快速排序:`
  快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。一般选取第一个数作为基准数。复杂度是O(nlgn)。空间复杂度是O（logn）属于不稳定算法。

**4. 堆和栈的区别**

* `堆栈空间分配区别：`
  + 1、
    `栈（操作系统）：由操作系统自动分配释放，`
    存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
  + 2、
    `堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，`
    分配方式倒是类似于链表。
* `堆栈缓存方式区别：`
  + 1、栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；
  + 2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
* `堆栈数据结构区别：`
  + 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
  + 栈（数据结构）：一种先进后出的数据结构。

**5. 请问你知道什么加密算法吗**

* 常见的加密算法分为三类，
  `对称加密算法，非对称加密算法，Hash算法`
  + 对称加密，指加密和解密使用相同密钥的加密算法
  + Hash算法：
    `它是一种单向算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一Hash值，但不能通过这个Hash值重新获得目标信息。`
    常见的有MD4、MD5

#### 7.2必考算法题

**1. 冒泡算法**

```
num = [1, 5, 10, 58, 12, 2]
for i in range(len(num)-1):  # 比较n-1轮，n为元素个数
    for j in range(len(num)-1-i):  # 剩余两两进行比较的次数
        if num[j] < num[j + 1]:
            num[j + 1], num[j] = num[j], num[j + 1]

```

**2. 打印99乘法表**

```
for i in range(1,10):
    for j in range(1,i+1):
        print("{}*{}={}".format(i,j,i*j),end=' ')
    print()

```

**3. 杨辉三角**
\*\*

```
massage = '''
杨辉三角，本质上是二项式(a+b)的n次方展开后各项的系数排成的三角形。其性质包括：每行的端点数为1， 一个数也为1；每个数等于它左上方和上方的两数之和。
'''
l = [[0] * i for i in range(1, 31)]
for i in range(30):
    for j in range(i + 1):
        if j == 0 or i == j:
            l[i][j] = 1
        else:
            l[i][j] = l[i - 1][j - 1] + l[i - 1][j]

n = int(input())
for i in range(n):
    for j in range(i + 1):
        print('{:>5d}'.format(l[i][j]), end='')
    print()

```

**4. 水仙花**

```
massage = """
求100-999 所有的"水仙花数"。所谓"水仙花数"是指一个三位数，其各位数字立方和等于该数本身。 
例如： 153 是一个"水仙花数"，153 = 1^3 + 5^3 + 3^3，因此 153 就是一个水仙花数
"""
l = []
for i in range(100,1000):
    a = i // 100
    b = (i%100) // 10
    c = i % 10
    if a**3 + b**3 + c**3 == i:
        l.append(i)
for i in range(len(l)):
    print(l[i],end = " ")
  
 # 输出结果 153 370 371 407 

```

**5. 金字塔图案**

```
massage = '''
打印用“*”组成的金字塔图案。
输入描述:
多组输入，一个整数（2~20），表示金字塔边的长度，即“*”的数量，也表示输出行数。

输出描述:
针对每行输入，输出用“*”组成的金字塔，每个“*”后面有一个空格。
'''
while True:
    try:
        n = int(input())
        for i in range(n):
            print(' ' * (n - i-1) + '* ' * (i + 1))

    except:
        break

```

**6. 波非那契数列**

```
def fib(lenght):
    a, b = 0, 1
    n = 0
    while n < lenght:
        yield b
        a,b = b,a+b
        n += 1
gen = fib(9)
for i in gen:
    print(i,end=' ')

```

**7. 序列中整数去重**

```
massage = '''
题目描述
给定一个整数序列，把其中的重复的整数去掉，并将去重后的序列从小到达排序输出。
输入描述:
第一行，输入一个整数n，表示序列有n个整数。
第二行输入n个整数（每个整数大于等于1，小于等于1000），整数之间用空格分隔。
输出描述:
去重并且从小到大排列的整数序列，整数之间用空格分隔。
'''
n = int(input())
l = list(map(int, input().split()))
new_l = sorted(set(l))
for i in new_l:
    print(i, end=' ')

```

**8. 数字直角三角形图案**

```
massage = '''
打印用数字组成的数字三角形图案。
输入描述:
多组输入，一个整数（3~20），表示数字三角形边的长度，即数字的数量，也表示输出行数。
输出描述:
针对每行输入，输出用数字组成的对应长度的数字三角形，每个数字后面有一个空格。
'''
while True:
    try:
        n = int(input())
        for i in range(n):
            for j in range(1,i+1):
                print(j,end=' ')
            print()
    except:
        break
       
 """

```

**9. 一行代码实现1~100的和**

```
print(sum([i for i in range(1,101)]))

```

**10. 反向输出一个字符串**

```
# 法1
s = str(input("请输入一个需要排序字符串："))
# new_s = s[-1::-1]
new_s = s[::-1]
print(new_s)

# 法2
str = list(input('input a string:'))
str.reverse()#该方法没有返回值，若打印则出现None,但会对列表元素进行反向排序。因此用print(list)来查看排序即可
print(''.join(str))

```