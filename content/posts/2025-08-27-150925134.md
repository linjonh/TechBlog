---
layout: post
title: "Node.js4-http模块基础"
date: 2025-08-27T15:57:27+0800
description: "下面我们来学nodejs中的http模块。在此之前，你需要有一定的网络知识储备，能知道http，IP，端口是什么并且它们之间的关系。如果还不清楚或比较模糊，可以查看下面的文章：下面我们开始学习。"
keywords: "Node.js（4）—— http模块基础"
categories: ['未分类']
tags: ['网络协议', 'Node', 'Http']
artid: "150925134"
arturl: "https://blog.csdn.net/2401_87687835/article/details/150925134"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150925134
    alt: "Node.js4-http模块基础"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150925134
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150925134
cover: https://bing.ee123.net/img/rand?artid=150925134
image: https://bing.ee123.net/img/rand?artid=150925134
img: https://bing.ee123.net/img/rand?artid=150925134
---



# Node.js（4）—— http模块基础

下面我们来学nodejs中的http模块。在此之前，你需要有一定的网络知识储备，能知道http，IP，端口是什么并且它们之间的关系。如果还不清楚或比较模糊，可以查看下面的文章：  
 [HTTP协议与IP](https://blog.csdn.net/2401_87687835/article/details/150860264?spm=1001.2014.3001.5501 "HTTP协议与IP")

下面我们开始学习。

**目录**

[创建一个HTTP服务端](#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E7%AB%AF)

[向本机端口发送请求](#%E5%90%91%E6%9C%AC%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82)

[HTTP服务的注意事项](#HTTP%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)

[1、如何关闭服务器？](#1%E3%80%81%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F)

[2、如何实现代码的修改更新？](#2%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%AE%E6%94%B9%E6%9B%B4%E6%96%B0%EF%BC%9F)

[3、响应内容中文乱码](#3%E3%80%81%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81)

[4、端口号被占用](#4%E3%80%81%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8)

[5、HTTP协议默认端口](#5%E3%80%81HTTP%E5%8D%8F%E8%AE%AE%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3)

[在浏览器中查看报文](#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%8A%A5%E6%96%87)

---

## 创建一个HTTP服务端

有了HTTP服务端后，我们就能处理浏览器发送过来的请求，并且可以返回响应。和前端开发不同，我们无法随时在浏览器中渲染看到我们编写的结果，因此我们需要逐渐习惯后端开发时的编写习惯。

1、导入http模块

```
const http = require('http');

```

这部分和之前的导入模块相同。

2、创建服务对象

创建服务对象我们使用 **createServer** 方法来创建，其返回结果为一个对象。代码为：

```
const server = http.createServer();
```

该方法有一个实参，它是一个函数；该函数又接受两个形参，为 request 和 response。request是浏览器发送的请求报文的封装对象，可以获取到请求报文的相关内容。

而response则是对响应报文的封装对象，可以为浏览器设置响应结果。

这里我们说明一下，request和rresponse只是参数名称，我们可以自己为参数命名。

下面我们简单书写一下函数：

```
const server = http.createServer((request,response) => {
    response.end('Hello HTTP Server');//设置响应体并结束响应
});
```

后面我们还会详细讲解如何去编写，这里我们就留个印象，要知道这么写的目的是什么。

3、监听端口，启动服务

直接看代码：

```
server.listen();
```

listen是对象里面的一个方法，需要往里面传入两个参数：一个数值和回调函数。具体如下：

```
server.listen(9000,() => {
    console.log('服务器已成功启动...');
});
```

数值表示端口号，上面代码表示端口号为9000。当然其他端口也可行，这里我们选取9000。直接运行上述代码查看结果:  
 ![](https://i-blog.csdnimg.cn/direct/825eda940540493095ea1c06593b1940.png)

这样我们就成功运行了。当服务器启动成功以后才会执行回调函数内的代码。（response）

现在，端口9000就已经被我们的服务器占用了。将来只要有程序往9000端口发送http请求，回调函数就就会被执行。我们知道，浏览器会向服务器发送http请求；下面我们使用本机的IP试着发送请求。

## 向本机端口发送请求

向本机端口发送请求，我们首先要知道本机的IP地址。而本机回环地址就是我们当前计算机，即本机的地址。IP为：127.0.0.1。下面我们打开浏览器，输入IP发送我们的http请求。

```
http://127.0.0.1:9000/
```

在网址栏输入上述代码，跳转后我们就能看到执行了回调函数之后的页面。

![](https://i-blog.csdnimg.cn/direct/b5f4be8da71445e38e7d02b387b90a6d.png)

## HTTP服务的注意事项

#### 1、如何关闭服务器？

启动服务之后，我们使用 Crtl + C 就能停止运行。

#### 2、如何实现代码的修改更新？

如果我们想对代码进行修改后服务器也会做出对应修改该怎么办呢？比如我们把之前的 'Hello HTTP Server' 修改为'Hello World!'：

```
const http = require('http');
const server = http.createServer((request,response) => {
    response.end('Hello World!');//设置响应体并结束响应
});
server.listen(9000,() => {
    console.log('服务器已成功启动...');
});
```

直接修改后发现页面没有变化。这时我们需要关闭当前服务器并再次启动才会实现更新。即重启服务。

![](https://i-blog.csdnimg.cn/direct/77bb586b3b8645328dc69b0283673142.png)

#### 3、响应内容中文乱码

我们再次修改文本内容，这次我们使用中文 “你好” 来替换文本。

```
response.end('你好');
```

重启服务器，发现出现了奇怪的结果：  
 ![](https://i-blog.csdnimg.cn/direct/4a4d4e50a3d84602a26b78554a5ba9b0.png)

感兴趣可以多尝试一些中文文本，会看到都会出现乱码。这里是因为字符集的问题。我们在前面多加入一行代码：

```
response.setHeader('content-type','text/html;charset=utf-8');
```

这段代码是什么意思呢？它表示在发送请求报文时，多加入一个键名为 conten.type 的响应头；返回的内为HTML，并且字符的格式为 utf-8 。这样浏览器就会按照utf-8字符集的规范来解析字符了。下面我们重启一下服务，发现回归正常：  
 ![](https://i-blog.csdnimg.cn/direct/b586f1660b29482b885a019337c0b42c.png)

#### 4、端口号被占用

我们在vscode中保持服务器不断开，新打开一个终端，启动文件会发现出现报错：

![](https://i-blog.csdnimg.cn/direct/fdacfc752e6048f3883b6905400b4a07.png)

这时就是端口已经被占用的情况。我们在另一个终端已经使用了9000端口，不能再被其他的使用。解决这个问题有两个方法，一是停止正在启动的端口；二是修改端口号。

#### 5、HTTP协议默认端口

HTTP协议的默认端口为80。如果我们不设置端口号，请求就会默认向80端口发送请求。再补充一下 https协议的默认端口为443。

## 在浏览器中查看报文

我们在之前运行的页面上打开控制台应用，选择网络：

![](https://i-blog.csdnimg.cn/direct/1ce9454625d14fa38cb78315950864f1.png)

之后我们启动服务器就能看到出现了两个请求：

![](https://i-blog.csdnimg.cn/direct/0d3773f0901546bd81a41bcd31daf49e.png)

我们先看下面那个 favicon.ico ，这个其实是谷歌浏览器的默认行为，在打开网页时它都会发送这样一个请求。

![](https://i-blog.csdnimg.cn/direct/6c9a31bc58684d4dba68c337bc029d7a.png)

我们再来看向本机发送的请求，有三个大的分类项；我们打开请求标头，就能看到报文的内容了。但打开后发现没有请求行，我们点击原始（源代码），就能看到初始的代码，也就能看见请求行了。

![](https://i-blog.csdnimg.cn/direct/014593aea85d4118a7e9efee7b3e66a6.png)

那么请求体怎么看呢？我们需要另外建立一个文件：  
 ![](https://i-blog.csdnimg.cn/direct/bca4276ba6d14dd580aa09a65e72787b.png)

如图所示我们快速建立一个html文件，如下书写一个表单：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <form action="http://127.0.0.1:9000" method="post">
        <input type="text" name="username">
        <input type="password" name="password">
        <input type="submit" value="提交">
    </form>
</body>
</html>
```

之后打开网页，输入对应的信息后提交后就会像对应端口发送一个Post请求。

![](https://i-blog.csdnimg.cn/direct/89420d4b2b174d24906ef297d741cada.png)

提交后我们能在控制台看到多出来一个“负载”标签页，里面存放我们刚刚输入的信息：  
 ![](https://i-blog.csdnimg.cn/direct/209c45e433d645daaf1ece8b4422760e.png)

这就是格式化之后的请求体内容。如果想要查看原始的内容，点击查看源即可：

```
username=123&password=123456
```



