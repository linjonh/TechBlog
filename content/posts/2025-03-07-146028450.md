---
layout: post
title: "Java基础关键_018_集合二"
date: 2025-03-07 10:52:50 +0800
description: "Java基础关键内容之集合详解。"
keywords: "Java基础关键_018_集合（二）"
categories: ['Java']
tags: ['Java']
artid: "146028450"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146028450
    alt: "Java基础关键_018_集合二"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146028450
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146028450
cover: https://bing.ee123.net/img/rand?artid=146028450
image: https://bing.ee123.net/img/rand?artid=146028450
img: https://bing.ee123.net/img/rand?artid=146028450
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java基础关键_018_集合（二）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E6%B3%9B%E5%9E%8B%20%E2%80%BB" name="%E4%B8%80%E3%80%81%E6%B3%9B%E5%9E%8B%20%E2%80%BB" style="background-color:transparent">
     <span style="color:#be191c">
      一、泛型 ※
     </span>
    </h2>
    <h3 id="1.%E8%AF%B4%E6%98%8E" name="1.%E8%AF%B4%E6%98%8E">
     1.说明
    </h3>
    <blockquote>
     <ol>
      <li>
       jdk 5 新增，属于编译阶段功能；
      </li>
      <li>
       不使用泛型，会导致代码冗长，从集合中抽取的元素若要访问子类中特有的方法，需要向下转型；
      </li>
      <li>
       泛型可以在开发时指定集合中存储的数据类型；
      </li>
      <li>
       使用泛型除了可以简化代码，避免类型转换操作之外，还可以在编译时进行类型检查，避免了在运行时出现类型错误的问题；
      </li>
      <li>
       jdk 7 之后，可以省略表达式后面的泛型类型。
      </li>
     </ol>
    </blockquote>
    <hr/>
    <h3 id="2.%E5%AE%9E%E4%BE%8B%C2%A0" name="2.%E5%AE%9E%E4%BE%8B%C2%A0">
     2.实例
    </h3>
    <pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) {
//        Collection&lt;Person&gt; c = new ArrayList&lt;Person&gt;();   //  jdk 1.7之前，必须写后面的泛型类型
        Collection&lt;Person&gt; c = new ArrayList&lt;&gt;();   //  jdk 1.7之后，可以省略后面的泛型类型
        // Collection&lt;Person&gt; c = new ArrayList&lt;Person&gt;();
        Person p1 = new Person("张三");
        Person p2 = new Person("李四");
        Person p3 = new Person("王五");
        c.add(p1);
        c.add(p2);
        c.add(p3);
//        c.add("赵六");    // 报错，类型不匹配
        Iterator&lt;Person&gt; iterator = c.iterator();
        while (iterator.hasNext()) {
            Person p = iterator.next();
            p.eat();
        }
        /*
         * 张三正在吃饭！
         * 李四正在吃饭！
         * 王五正在吃饭！
         * */
    }
}</code></pre>
    <hr/>
    <h3 id="3.%E6%93%A6%E9%99%A4%E4%B8%8E%E8%A1%A5%E5%81%BF" name="3.%E6%93%A6%E9%99%A4%E4%B8%8E%E8%A1%A5%E5%81%BF">
     3.擦除与补偿
    </h3>
    <blockquote>
     <ol>
      <li>
       <p>
        泛型的出现提高了编译时的安全性，在编译时对数据类型进行检查，属于编译时期的技术。加载类时，会将泛型擦除，擦除后类型为 Object 类型；
       </p>
      </li>
      <li>
       <p>
        泛型擦除是为了让 jdk 5 与之前版本的 jdk 能够兼容同一个类加载器；
       </p>
      </li>
      <li>
       <p>
        因为泛型擦除后，变为 Object 类型。为了保证获得集合元素类型为实际类型，虚拟机会根据元素实际类型自动进行向下转型，这一过程称为泛型补偿。
       </p>
      </li>
     </ol>
    </blockquote>
    <hr/>
    <h3 id="%C2%A04.%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89" name="%C2%A04.%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89" style="background-color:transparent">
     4.泛型的定义
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E7%B1%BB%E5%AE%9A%E4%B9%89" name="%EF%BC%881%EF%BC%89%E7%B1%BB%E5%AE%9A%E4%B9%89">
     （1）类定义
    </h4>
    <pre><code class="language-java">public class GenericTest&lt;T&gt; {
    private T name;

    public T getName() {
        return name;
    }

    public void setName(T name) {
        this.name = name;
    }

    public GenericTest(T name) {
        this.name = name;
    }

    public static void main(String[] args) {
        GenericTest&lt;String&gt; gt = new GenericTest&lt;&gt;("张三");
        System.out.println(gt.getName());
//        GenericTest&lt;String&gt; gt1 = new GenericTest&lt;&gt;(123);   // 报错，类型不匹配，应该是String类型
    }
}
</code></pre>
    <hr/>
    <h4 id="%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89" name="%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89">
     （2）静态方法定义
    </h4>
    <pre><code class="language-java">public class GenericTest {
    public static &lt;E&gt; void test(E[] elts) {
        for (E elt : elts) {
            System.out.print(elt + "\t");
        }
        // 1	2	3	4	5
    }

    public static void main(String[] args) {
        Integer[] ints = {1, 2, 3, 4, 5};
        GenericTest.test(ints);
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%883%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" name="%EF%BC%883%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89">
     （3）接口定义
    </h4>
    <pre><code class="language-java">public interface GenericTest01&lt;T&gt; {
    String get(T t);
}</code></pre>
    <pre><code class="language-java">public class GenericTest01Impl implements GenericTest01&lt;GenericTest01Impl&gt; {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public GenericTest01Impl(String name) {
        this.name = name;
    }

    @Override
    public String get(GenericTest01Impl gti) {
        return getName();
    }

    public static void main(String[] args) {
        GenericTest01Impl gt = new GenericTest01Impl("GenericTest01Impl");
        System.out.println(gt.get(gt));    // GenericTest01Impl
    }
}</code></pre>
    <hr/>
    <h3 id="5.%E9%80%9A%E9%85%8D%E7%AC%A6" name="5.%E9%80%9A%E9%85%8D%E7%AC%A6">
     5.通配符
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E6%97%A0%E9%99%90%E5%AE%9A" name="%EF%BC%881%EF%BC%89%E6%97%A0%E9%99%90%E5%AE%9A">
     （1）无限定
    </h4>
    <blockquote>
     <p>
      【 &lt;?&gt; 】，其中 【 ? 】 可以是任意引用数据类型。
     </p>
    </blockquote>
    <pre><code class="language-java">public class GenericTest {
    public static void get(ArrayList&lt;?&gt; list) {
    }

    public static void main(String[] args) {
        get(new ArrayList&lt;String&gt;());
        get(new ArrayList&lt;Integer&gt;());
        get(new ArrayList&lt;Double&gt;());
        get(new ArrayList&lt;Object&gt;());
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%882%EF%BC%89%E4%B8%8A%E9%99%90" name="%EF%BC%882%EF%BC%89%E4%B8%8A%E9%99%90">
     （2）上限
    </h4>
    <blockquote>
     <p>
      【 &lt;? extends T&gt; 】，其中 【 ? 】 必须是 T 及其子类。
     </p>
    </blockquote>
    <pre><code class="language-java">public class GenericTest {
    public static void get(ArrayList&lt;? extends Number&gt; list) {
    }

    public static void main(String[] args) {
//        get(new ArrayList&lt;String&gt;());   // 报错, 不能将类型为java.util.ArrayList&lt;java.lang.String&gt;的表达式赋给类型为java.util.ArrayList&lt;? extends java.lang.Number&gt;的变量
        get(new ArrayList&lt;Integer&gt;());
        get(new ArrayList&lt;Double&gt;());
//        get(new ArrayList&lt;Object&gt;());   // 报错, 不能将类型为java.util.ArrayList&lt;java.lang.Object&gt;的表达式赋给类型为java.util.ArrayList&lt;? extends java.lang.Number&gt;的变量
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%883%EF%BC%89%E4%B8%8B%E9%99%90" name="%EF%BC%883%EF%BC%89%E4%B8%8B%E9%99%90">
     （3）下限
    </h4>
    <blockquote>
     <p>
      【 &lt;? super T&gt; 】，其中 【 ? 】 必须是 T 及其父类。
     </p>
    </blockquote>
    <pre><code class="language-java">public class GenericTest {
    public static void get(ArrayList&lt;? super Number&gt; list) {
    }

    public static void main(String[] args) {
//        get(new ArrayList&lt;String&gt;());  // 报错，不允许
//        get(new ArrayList&lt;Double&gt;());   // 报错，不允许
        get(new ArrayList&lt;Object&gt;());
        get(new ArrayList&lt;Number&gt;());
    }
}</code></pre>
    <hr/>
    <h2 id="%E4%BA%8C%E3%80%81%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8" name="%E4%BA%8C%E3%80%81%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8">
     二、集合迭代的并发修改异常
    </h2>
    <h3 id="1.%E7%A4%BA%E4%BE%8B" name="1.%E7%A4%BA%E4%BE%8B">
     1.示例
    </h3>
    <blockquote>
     <p>
      在进行集合迭代需要三个步骤，可以参考
      <a class="link-info" href="https://mp.csdn.net/mp_blog/creation/editor/145969869" title="Java基础关键_017_集合（一）">
       Java基础关键_017_集合（一）
      </a>
      ，但是在删除集合中的元素时，会抛出并发修改异常，示例如下：
     </p>
    </blockquote>
    <pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext()) {
            String name = iterator.next();
            if (name.equals("李四")) {
                list.remove(name);  // 调用集合remove方法删除元素会报错 java.util.ConcurrentModificationException（并发修改异常）
            }
            System.out.println(name);
        }
    }
}</code></pre>
    <blockquote>
     <p>
      面对以上异常，应该怎么做呢？
     </p>
     <p>
      应该将集合的 remove 方法替换为迭代器的 remove 方法，在第二次迭代时就会发现“李四”被删除了，示例如下：
     </p>
    </blockquote>
    <pre><code class="language-java">public class GenericTest {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext()) {
            String name = iterator.next();
            if (name.equals("李四")) {
                iterator.remove();  // 调用迭代器的remove方法删除当前元素
            }
        }
        Iterator&lt;String&gt; iterator1 = list.iterator();
        while (iterator1.hasNext()) {
            String name = iterator1.next();
            System.out.println(name);
        }
    }
}</code></pre>
    <hr/>
    <h3 id="2.%E8%AF%B4%E6%98%8E" name="2.%E8%AF%B4%E6%98%8E">
     2.说明
    </h3>
    <blockquote>
     <p>
      因为使用迭代器遍历，而使用集合删除操作去删除，底层为防止多线程导致的错误发生，所以抛出并发修改异常，这一机制称为快速失败，即 fail-fast 。
     </p>
    </blockquote>
    <hr/>
    <h3 id="3.%20fail-fast%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" name="3.%20fail-fast%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">
     3. fail-fast 机制实现原理
    </h3>
    <blockquote>
     <ol>
      <li>
       <p>
        集合中设置有 modCount 属性，记录修改次数使用集合对象进行 增、删、改 操作时，modCount 会加 1 ；
       </p>
      </li>
      <li>
       <p>
        获取迭代器对象时，会初始化一个 expectedModCount 属性，并将其值初始化为 modCount ；
       </p>
      </li>
      <li>
       <p>
        当使用集合的 remove 方法删除元素时，会导致 modCount 加 1 ，而 expectedModCount 不变；
       </p>
      </li>
      <li>
       <p>
        当 modCount 和 expectedModCount 值不相等时，底层代码会抛出并发修改异常。
       </p>
      </li>
     </ol>
    </blockquote>
    <hr/>
    <h2 id="%E4%B8%89%E3%80%81List%20%E6%8E%A5%E5%8F%A3" name="%E4%B8%89%E3%80%81List%20%E6%8E%A5%E5%8F%A3">
     三、List 接口
    </h2>
    <h3 id="1.%E7%89%B9%E7%82%B9" name="1.%E7%89%B9%E7%82%B9">
     1.特点
    </h3>
    <blockquote>
     <p>
      有序、可重复。
     </p>
    </blockquote>
    <hr/>
    <h3 id="2.%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB" name="2.%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB">
     2.常见实现类
    </h3>
    <blockquote>
     <ol>
      <li>
       ArrayList：数组；
      </li>
      <li>
       Vector、Stack：线程安全的数组；
      </li>
      <li>
       <p>
        LinkedList：双向链表。
       </p>
      </li>
     </ol>
    </blockquote>
    <hr/>
    <h3 id="3.%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95" name="3.%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95">
     3.特有方法
    </h3>
    <blockquote>
     <p>
      只适合在 List 中使用，都与下标有关。
     </p>
    </blockquote>
    <h4 id="%EF%BC%881%EF%BC%89add(int%20index%2C%20E%20element)%C2%A0" name="%EF%BC%881%EF%BC%89add(int%20index%2C%20E%20element)%C2%A0">
     （1）add(int index, E element)
    </h4>
    <blockquote>
     <p>
      在指定索引处插入元素。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add(1, "赵六");

        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + "\t");
        }
        // 张三	赵六	李四	王五	
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%882%EF%BC%89%C2%A0set(int%20index%2C%20E%20element)%C2%A0" name="%EF%BC%882%EF%BC%89%C2%A0set(int%20index%2C%20E%20element)%C2%A0">
     （2） set(int index, E element)
    </h4>
    <blockquote>
     <p>
      修改索引处的元素。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.set(0, "赵六");

        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + "\t");
        }
        // 赵六	李四	王五
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%883%EF%BC%89%20get(int%20index%EF%BC%89" name="%EF%BC%883%EF%BC%89%20get(int%20index%EF%BC%89">
     （3） get(int index）
    </h4>
    <blockquote>
     <p>
      根据索引获取元素。List 集合独特的遍历方式：通过下标遍历。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        System.out.println(list.get(1));    // 李四
    }
}
</code></pre>
    <hr/>
    <h4 id="%EF%BC%884%EF%BC%89remove(int%20index%EF%BC%89" name="%EF%BC%884%EF%BC%89remove(int%20index%EF%BC%89">
     （4）remove(int index）
    </h4>
    <blockquote>
     <p>
      删除索引处的元素。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.remove(1);
        for (String s : list) {
            System.out.println(s);
        }
        // 张三
        // 王五
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%885%EF%BC%89indexOf(Object%20o)" name="%EF%BC%885%EF%BC%89indexOf(Object%20o)">
     （5）indexOf(Object o)
    </h4>
    <blockquote>
     <p>
      获取对象 o 在集合中第一次出现的索引。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("张三");
        list.add("王五");
        System.out.println(list.indexOf("张三")); // 0
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%886%EF%BC%89lastIndexOf(Object%20o)" name="%EF%BC%886%EF%BC%89lastIndexOf(Object%20o)">
     （6）lastIndexOf(Object o)
    </h4>
    <blockquote>
     <p>
      获取对象 o 在集合中最后一次出现的索引。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("张三");
        list.add("王五");
        System.out.println(list.lastIndexOf("张三")); // 2
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%887%EF%BC%89subList(int%20fromIndex%2C%20int%20toIndex)" name="%EF%BC%887%EF%BC%89subList(int%20fromIndex%2C%20int%20toIndex)">
     （7）subList(int fromIndex, int toIndex)
    </h4>
    <blockquote>
     <p>
      截取子 List 集合，生成一个新的集合，范围是 [ fromIndex, toIndex )。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("张三");
        list.add("王五");
        System.out.println(list.subList(1, 3)); // [李四, 张三]
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%888%EF%BC%89of(E...%20elements)" name="%EF%BC%888%EF%BC%89of(E...%20elements)">
     （8）of(E... elements)
    </h4>
    <blockquote>
     <p>
      静态方法，返回包含任意数量元素的不可修改列表，所获取的集合是只读的。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; strings = List.of("H", "e", "l", "l", "o");
        strings.set(1, "Q");    // 报错，java.lang.UnsupportedOperationException
    }
}</code></pre>
    <hr/>
    <h3 id="4.%E7%89%B9%E6%9C%89%E8%BF%AD%E4%BB%A3" name="4.%E7%89%B9%E6%9C%89%E8%BF%AD%E4%BB%A3">
     4.特有迭代
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89listIterator()" name="%EF%BC%881%EF%BC%89listIterator()">
     （1）listIterator()
    </h4>
    <blockquote>
     <p>
      获取 List 集合特有的迭代器。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        /*
         * 通用迭代器
         * */
        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();
            System.out.print("Iterator:" + next + "\t");
        }
        // Iterator:张三	Iterator:李四	Iterator:王五	Iterator:赵六
        System.out.println();

        /*
         * 特有迭代器
         * */
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            String next = listIterator.next();
            System.out.print("ListIterator:" + next + "\t");
        }
        // ListIterator:张三	ListIterator:李四	ListIterator:王五	ListIterator:赵六
    }
}</code></pre>
    <hr/>
    <h4 id="%EF%BC%882%EF%BC%89%C2%A0listIterator(int%20index)" name="%EF%BC%882%EF%BC%89%C2%A0listIterator(int%20index)">
     （2） listIterator(int index)
    </h4>
    <blockquote>
     <p>
      从列表指定位置开始，返回列表中元素的列表迭代器。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        /*
         * 特有迭代器
         * */
        ListIterator&lt;String&gt; listIterator = list.listIterator(2);
        while (listIterator.hasNext()) {
            String next = listIterator.next();
            System.out.print(next + "\t");
        }
        // 王五	赵六
    }
}</code></pre>
    <hr/>
    <h2 id="5.%C2%A0ListIterator%20%E7%9A%84%E6%96%B9%E6%B3%95" name="5.%C2%A0ListIterator%20%E7%9A%84%E6%96%B9%E6%B3%95" style="background-color:transparent">
     四、ListIterator 的方法
    </h2>
    <h3 id="%EF%BC%881%EF%BC%89hasNext()" name="%EF%BC%881%EF%BC%89hasNext()">
     1.hasNext()
    </h3>
    <blockquote>
     <p>
      通用方法，判断当前指向位置是否有元素。
     </p>
    </blockquote>
    <hr/>
    <h3 id="%EF%BC%882%EF%BC%89next()" name="%EF%BC%882%EF%BC%89next()">
     2.next()
    </h3>
    <blockquote>
     <p>
      通用方法，将当前指向元素返回，并指向下一位。
     </p>
    </blockquote>
    <hr/>
    <h3 id="%EF%BC%883%EF%BC%89remove()" name="%EF%BC%883%EF%BC%89remove()">
     3.remove()
    </h3>
    <blockquote>
     <p>
      通用方法，删除上一次 next() 方法返回的数据。必须先调用 next() 方法或 previous() 方法，否则会报错。
     </p>
    </blockquote>
    <hr/>
    <h3 id="%EF%BC%884%EF%BC%89add(E%20e)%C2%A0" name="%EF%BC%884%EF%BC%89add(E%20e)%C2%A0">
     4.add(E e)
    </h3>
    <blockquote>
     <p>
      特有方法，将元素添加到指向位置，然后指向下一位。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            if ("王五".equals(listIterator.next())){
                listIterator.add("冯七");
            }
        }
        System.out.println(list);   // [张三, 李四, 王五, 冯七, 赵六]
    }
}</code></pre>
    <hr/>
    <h3 id="%EF%BC%885%EF%BC%89hasPrevious()" name="%EF%BC%885%EF%BC%89hasPrevious()">
     5.hasPrevious()
    </h3>
    <blockquote>
     <p>
      特有方法，判断当前指向位置的上一个位置是否存在元素。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        System.out.println(listIterator.hasPrevious()); // false
        while (listIterator.hasNext()) {
            listIterator.next();
        }
        System.out.println(listIterator.hasPrevious()); // true
    }
}
</code></pre>
    <hr/>
    <h3 id="%EF%BC%886%EF%BC%89previous()" name="%EF%BC%886%EF%BC%89previous()">
     6.previous()
    </h3>
    <blockquote>
     <p>
      特有方法，获取上一个元素，即指向上一个元素并返回。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            listIterator.next();
        }
        System.out.println(listIterator.previous()); // 赵六
        System.out.println(listIterator.previous()); // 王五
    }
}</code></pre>
    <hr/>
    <h3 id="%EF%BC%887%EF%BC%89nextIndex()" name="%EF%BC%887%EF%BC%89nextIndex()">
     7.nextIndex()
    </h3>
    <blockquote>
     <p>
      特有方法，获取指向位置的下标。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            listIterator.next();
        }
        System.out.println(listIterator.nextIndex()); // 4
        System.out.println(listIterator.previous()); // 赵六
        System.out.println(listIterator.nextIndex()); // 3

    }
}</code></pre>
    <hr/>
    <h3 id="%EF%BC%888%EF%BC%89previousIndex()" name="%EF%BC%888%EF%BC%89previousIndex()">
     8.previousIndex()
    </h3>
    <blockquote>
     <p>
      特有方法，获取指向位置的上一个位置的下标。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            listIterator.next();
        }
        System.out.println(listIterator.previousIndex()); // 3
        System.out.println(listIterator.previous()); // 赵六
        System.out.println(listIterator.previousIndex()); // 2

    }
}</code></pre>
    <hr/>
    <h3 id="%EF%BC%889%EF%BC%89set(E%20e)" name="%EF%BC%889%EF%BC%89set(E%20e)">
     9.set(E e)
    </h3>
    <blockquote>
     <p>
      特有方法，修改上一次 next() 方法返回的数据。必须先调用 next() 方法或 previous() 方法，否则会报错。
     </p>
    </blockquote>
    <pre><code class="language-java">public class ListTest {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        ListIterator&lt;String&gt; listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            if ("王五".equals(listIterator.next())) {
                listIterator.set("冯七");
            }
        }
        System.out.println(list);   // [张三, 李四, 冯七, 赵六]
    }
}</code></pre>
    <hr/>
    <h2 id="%E4%BA%94%E3%80%81%E6%AF%94%E8%BE%83%C2%A0" name="%E4%BA%94%E3%80%81%E6%AF%94%E8%BE%83%C2%A0">
     五、比较
    </h2>
    <h3 id="1.%E5%9B%9E%E9%A1%BE%E6%95%B0%E7%BB%84%20Comparable%20%E6%AF%94%E8%BE%83" name="1.%E5%9B%9E%E9%A1%BE%E6%95%B0%E7%BB%84%20Comparable%20%E6%AF%94%E8%BE%83" style="background-color:transparent">
     1.回顾数组 Comparable 比较
    </h3>
    <pre><code class="language-java">public class Student implements Comparable&lt;Student&gt;{
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Student o) {
//        return this.age - o.age;    // 比较规则, 年龄升序

//        return o.age - this.age;    // 比较规则, 年龄降序

//        return this.name.compareTo(o.name);    // 比较规则，姓名升序

        return o.name.compareTo(this.name);    // 比较规则，姓名降序
    }
}
</code></pre>
    <pre><code class="language-java">public class ComparableTest {
    public static void main(String[] args) {
        Student s1 = new Student("张三", 18);
        Student s2 = new Student("李四", 22);
        Student s3 = new Student("王五", 7);
        Student[] students = {s1, s2, s3};
        Arrays.sort(students);
        System.out.println(Arrays.toString(students));
    }
}</code></pre>
    <hr/>
    <h3 id="2.%E9%9B%86%E5%90%88%20Comparator%20%E6%AF%94%E8%BE%83" name="2.%E9%9B%86%E5%90%88%20Comparator%20%E6%AF%94%E8%BE%83" style="background-color:transparent">
     2.集合 Comparator 比较
    </h3>
    <pre><code class="language-java">public class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}</code></pre>
    <pre><code class="language-java">public class StudentComparator implements Comparator&lt;Student&gt; {

    @Override
    public int compare(Student o1, Student o2) {
         return o1.getAge() - o2.getAge();   // 排序规则，年龄升序

//        return o2.getAge() - o1.getAge();   // 排序规则，年龄降序

//        return o1.getName().compareTo(o2.getName());    // 排序规则，姓名升序

//        return o2.getName().compareTo(o1.getName());    // 排序规则，姓名降序
    }
}
</code></pre>
    <pre><code class="language-java">public class ComparatorTest {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;();
        students.add(new Student("张三", 18));
        students.add(new Student("李四", 22));
        students.add(new Student("王五", 7));
        students.sort(new StudentComparator());
        ListIterator&lt;Student&gt; iterator = students.listIterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f6c755f7368616f5f66656e672f:61727469636c652f64657461696c732f313436303238343530" class_="artid" style="display:none">
 </p>
</div>


