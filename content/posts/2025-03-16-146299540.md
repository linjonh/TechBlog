---
layout: post
title: "一次Linux下-.net-调试经历"
date: 2025-03-16 19:41:21 +0800
description: "我甚至认为这个api收到了 .net 的路径影响，因为linux调用 .net 形如  dotnet ./MyApp.dll    这个api在查找ini时用的是 dotnet 的路径，而显示的时候用的是dll的路径。所以我们回过头，再去看之前的错误，我们认为我们一直在调用init函数，其实调用的是 setCallback(*pCallback) 函数， 我们以为传入的是字符串，但是api认为你传入的是pCallback, 而且最。但是，Linux的反汇编已经说了， init 的位置是 第4个函数！"
keywords: "一次Linux下 .net 调试经历"
categories: ['Vc', 'Debug', 'C']
tags: ['Linux', '.Net']
artid: "146299540"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146299540
    alt: "一次Linux下-.net-调试经历"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146299540
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146299540
cover: https://bing.ee123.net/img/rand?artid=146299540
image: https://bing.ee123.net/img/rand?artid=146299540
img: https://bing.ee123.net/img/rand?artid=146299540
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     一次Linux下 .net 调试经历
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      背景
     </strong>
     ：
     <br/>
     Xt160Api, 之前在windows下用.net调用，没有任何问题。
     <br/>
     但是移植到Linux去后，.net程序 调用 init(config_path) 总是报错 /root/test 找不到 traderApi.ini (/root/test 是程序目录) 然后退出程序
    </p>
    <p>
     <strong>
      解决过程
     </strong>
     :
     <br/>
     于是考虑是不是参数传错了，但是无论这个参数是什么， 报错内容始终如此。
     <br/>
     甚至某些情况下，比如加了几句Console.WriteLIne(app_exe_folder) 还会出现段错误，这个问题至今也没想明白。
     <br/>
     尊崇爱因斯坦的指导意见： 不要做相同的事情，期望得到不同的结果
     <br/>
     用Visual Studio远程编译 Linux C++ 程序 调用 init函数 。 发现 confg_path 可以被识别，如果config_path下没有ini存在，他会报错没有在 config_path下找到 traderApi.ini 而不是 .net 那样永远显示: /root/test 下找不到traderApi.ini
     <br/>
     这个让我极度困惑，我甚至尝试用 unsafe模式，硬编码字符串，传入 init的参数, 但是输出依旧。
    </p>
    <p>
     我甚至认为这个api收到了 .net 的路径影响，因为linux调用 .net 形如 dotnet ./MyApp.dll 这个api在查找ini时用的是 dotnet 的路径，而显示的时候用的是dll的路径。（最后证明这个逻辑完全不对） 所以我在 dotnet 的文件夹下添加了 traderApi.ini ， 依旧如故。
    </p>
    <p>
     于是我又转而认为2点，
    </p>
    <ol>
     <li>
      api 的指针有问题，可能我的EntryPoint写错了？
     </li>
     <li>
      虚表有问题，什么地方写错了？但是 init 函数是第3个函数，前2个是 析构函数，setCallbak 函数， 之后就是 init 函数
     </li>
    </ol>
    <p>
     非常疑惑，而且沮丧，觉得很无聊，甚至在想是不是.net core 3.1的bug? 要不要换.net8试试？ 搞得我很烦。
     <br/>
     但是还是掩盖烦躁，开始用c++写 so文件 TestSO.so
     <br/>
     如下:
     <br/>
     test.cpp:
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mylib.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"XtTraderApi.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>

<span class="token keyword">extern</span> <span class="token string">"C"</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">MyInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> api<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token string">"start start!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> xt_api <span class="token operator">=</span> <span class="token punctuation">(</span>xti<span class="token double-colon punctuation">::</span>XtTraderApi<span class="token operator">*</span><span class="token punctuation">)</span>api<span class="token punctuation">;</span>
		xt_api<span class="token operator">-&gt;</span><span class="token function">init</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ok ok ok\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
		<span class="token comment">//auto xtApi = (xti::XtTraderApi*)api;</span>
		<span class="token comment">//xtApi-&gt;init(path);</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     mylib.h
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">MYLIB_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MYLIB_H</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token keyword">extern</span> <span class="token string">"C"</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

	<span class="token comment">// 声明 MyInit 函数</span>
	<span class="token keyword">void</span> <span class="token function">MyInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> api<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// MYLIB_H</span></span>
</code></pre>
    <p>
     远程编译后，把 so文件送入 /lib64 (映射后实际位置为/usr/lib64)
     <br/>
     然后 ldconfig
     <br/>
     最后用 ldconfig -p | grep libTest确认生效:
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/327cf339b1254d8e9380cabade686bec.png">
      <br/>
      接下去先用c++ 程序调用TestSO.so, 传入 api的地址和config_path，一切正常！
      <br/>
      说明so文件运行正确。
      <br/>
      接下去就用C#程序调用TestSO.so, 传入 .net 中根据EntryPoint得到的 api地址，这次在so文件中调用 init函数居然一切正常！！
      <br/>
      这样我们几乎就确定了那个我们认为最不可能有问题的
      <strong>
       虚表
      </strong>
      问题了！
      <br/>
      但是怎么会？如果虚表有问题，说明函数地址是错的，调用不应该是直接崩溃，或者输出的是其他信息，怎么会返回 init函数的错误信息呢？
      <br/>
      觉得非常不可思议，不可能啊。（但是，就是如此，原因很难想象）
     </img>
    </p>
    <p>
     如果虚表有问题，我还是只能从 C++ 是如何调用 api-&gt;init 的代码，反汇编，看看 init 在虚表中的位置。
     <br/>
     Visual Studio 支持 Linux 远程反汇编 nice！
     <br/>
     api-&gt;init 的汇编如下:
    </p>
    <pre><code class="prism language-bash">0x0000000000400fc1 e8 8a fe ff ff       callq  0x400e50 <span class="token operator">&lt;</span>_ZN3xti11XtTraderApi17createXtTraderApiEPKc@plt<span class="token operator">&gt;</span> 
0x0000000000400fc6 <span class="token number">48</span> <span class="token number">89</span> <span class="token number">45</span> c0          mov    %rax,-0x40<span class="token punctuation">(</span>%rbp<span class="token punctuation">)</span> 
0x0000000000400fca <span class="token number">48</span> 8b <span class="token number">45</span> c0          mov    -0x40<span class="token punctuation">(</span>%rbp<span class="token punctuation">)</span>,%rax 
0x0000000000400fce <span class="token number">48</span> 8b 00             mov    <span class="token punctuation">(</span>%rax<span class="token punctuation">)</span>,%rax 
0x0000000000400fd1 <span class="token number">48</span> <span class="token number">83</span> c0 <span class="token number">18</span>          <span class="token function">add</span>    <span class="token variable">$0x18</span>,%rax 
0x0000000000400fd1 <span class="token number">48</span> <span class="token number">83</span> c0 <span class="token number">18</span>          <span class="token function">add</span>    <span class="token variable">$0x18</span>,%rax 
0x0000000000400fd5 <span class="token number">48</span> 8b <span class="token number">10</span>             mov    <span class="token punctuation">(</span>%rax<span class="token punctuation">)</span>,%rdx 
0x0000000000400fd8 <span class="token number">48</span> 8b <span class="token number">45</span> c0          mov    -0x40<span class="token punctuation">(</span>%rbp<span class="token punctuation">)</span>,%rax 
0x0000000000400fdc be <span class="token number">80</span> 7f <span class="token number">40</span> 00       mov    <span class="token variable">$0x407f80</span>,%esi 
0x0000000000400fe1 <span class="token number">48</span> <span class="token number">89</span> c7             mov    %rax,%rdi 
0x0000000000400fe4 ff d2                callq  *%rdx
</code></pre>
    <p>
     注意这两句不知道为什么被Visual Studio 重复了2行，注意看他们地址是一样的，说明是一条指令，而不是两条指令。
     <br/>
     而且这条语句极其重要，确定了init函数在虚表的位置。
    </p>
    <pre><code class="prism language-bash">0x0000000000400fd1 <span class="token number">48</span> <span class="token number">83</span> c0 <span class="token number">18</span>          <span class="token function">add</span>    <span class="token variable">$0x18</span>,%rax 
0x0000000000400fd1 <span class="token number">48</span> <span class="token number">83</span> c0 <span class="token number">18</span>          <span class="token function">add</span>    <span class="token variable">$0x18</span>,%rax 
</code></pre>
    <p>
     神奇的是，deepseek直接把他们正确的识别为了1条语句。下面是他的解答：
    </p>
    <p>
     This is a more complex snippet of x86-64 assembly code. Let’s break it down step by step:
    </p>
    <ol>
     <li>
      0x0000000000400fc1 e8 8a fe ff ff callq 0x400e50
      <a href="mailto:_ZN3xti11XtTraderApi17createXtTraderApiEPKc@plt" rel="nofollow">
       _ZN3xti11XtTraderApi17createXtTraderApiEPKc@plt
      </a>
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fc1
      <br/>
      Opcode: e8 8a fe ff ff
     </p>
     <p>
      Instruction: callq 0x400e50
     </p>
     <p>
      Description: This calls the function
      <br/>
      _ZN3xti11XtTraderApi17createXtTraderApiEPKc located at address 0x400e50. The function name is mangled and corresponds to a C++ method
      <br/>
      xti::XtTraderApi::createXtTraderApi(char const*). The @plt indicates
      <br/>
      that this is a dynamically linked function via the Procedure Linkage
      <br/>
      Table (PLT).
     </p>
     <p>
      Purpose: This is likely creating an instance of the XtTraderApi class.
     </p>
    </blockquote>
    <ol start="2">
     <li>
      0x0000000000400fc6 48 89 45 c0 mov %rax,-0x40(%rbp)
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fc6
     </p>
     <p>
      Opcode: 48 89 45 c0
     </p>
     <p>
      Instruction: mov %rax, -0x40(%rbp)
     </p>
     <p>
      Description: The return value of the createXtTraderApi function
      <br/>
      (stored in rax) is moved into the memory location at -0x40 bytes
      <br/>
      offset from the base pointer (rbp). This is likely storing the pointer
      <br/>
      to the newly created XtTraderApi object in a local variable.
     </p>
    </blockquote>
    <ol start="3">
     <li>
      0x0000000000400fca 48 8b 45 c0 mov -0x40(%rbp),%rax
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fca
     </p>
     <p>
      Opcode: 48 8b 45 c0
     </p>
     <p>
      Instruction: mov -0x40(%rbp), %rax
     </p>
     <p>
      Description: The pointer to the XtTraderApi object (stored at
      <br/>
      -0x40(%rbp)) is loaded back into the rax register.
     </p>
    </blockquote>
    <ol start="4">
     <li>
      0x0000000000400fce 48 8b 00 mov (%rax),%rax
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fce
     </p>
     <p>
      Opcode: 48 8b 00
     </p>
     <p>
      Instruction: mov (%rax), %rax
     </p>
     <p>
      Description: This dereferences the pointer in rax (which points to the
      <br/>
      XtTraderApi object) and loads the value at that memory location into
      <br/>
      rax. In C++ terms, this is likely accessing the vtable (virtual table)
      <br/>
      pointer of the XtTraderApi object, which is typically the first member
      <br/>
      of an object with virtual methods.
     </p>
    </blockquote>
    <ol start="5">
     <li>
      0x0000000000400fd1 48 83 c0 18 add $0x18,%rax
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fd1
     </p>
     <p>
      Opcode: 48 83 c0 18
     </p>
     <p>
      Instruction: add $0x18, %rax
     </p>
     <p>
      Description: This adds 0x18 (24 in decimal) to the value in rax. Since
      <br/>
      rax currently holds the vtable pointer, this is likely calculating the
      <br/>
      address of a specific entry in the vtable. The offset 0x18 suggests
      <br/>
      that this is the 4th entry in the vtable (assuming each entry is 8
      <br/>
      bytes on a 64-bit system).
     </p>
    </blockquote>
    <ol start="6">
     <li>
      0x0000000000400fd5 48 8b 10 mov (%rax),%rdx
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fd5
     </p>
     <p>
      Opcode: 48 8b 10
     </p>
     <p>
      Instruction: mov (%rax), %rdx
     </p>
     <p>
      Description: This dereferences the address in rax (which now points to
      <br/>
      a specific vtable entry) and loads the value at that memory location
      <br/>
      into rdx. This value is likely a function pointer corresponding to a
      <br/>
      virtual method in the XtTraderApi class.
     </p>
    </blockquote>
    <ol start="7">
     <li>
      0x0000000000400fd8 48 8b 45 c0 mov -0x40(%rbp),%rax
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fd8
     </p>
     <p>
      Opcode: 48 8b 45 c0
     </p>
     <p>
      Instruction: mov -0x40(%rbp), %rax
     </p>
     <p>
      Description: The pointer to the XtTraderApi object (stored at
      <br/>
      -0x40(%rbp)) is loaded back into rax. This is likely preparing the this pointer for the virtual method call.
     </p>
    </blockquote>
    <ol start="8">
     <li>
      0x0000000000400fdc be 80 7f 40 00 mov $0x407f80,%esi
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fdc
     </p>
     <p>
      Opcode: be 80 7f 40 00
     </p>
     <p>
      Instruction: mov $0x407f80, %esi
     </p>
     <p>
      Description: The immediate value 0x407f80 is moved into the esi
      <br/>
      register. This is likely an argument being passed to the virtual
      <br/>
      method.
     </p>
    </blockquote>
    <ol start="9">
     <li>
      0x0000000000400fe1 48 89 c7 mov %rax,%rdi
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fe1
     </p>
     <p>
      Opcode: 48 89 c7
     </p>
     <p>
      Instruction: mov %rax, %rdi
     </p>
     <p>
      Description: The pointer to the XtTraderApi object (in rax) is moved
      <br/>
      into rdi. In the System V AMD64 ABI, rdi is used for the first
      <br/>
      argument to a function, which in this case is the this pointer for the
      <br/>
      virtual method call.
     </p>
    </blockquote>
    <ol start="10">
     <li>
      0x0000000000400fe4 ff d2 callq *%rdx
     </li>
    </ol>
    <blockquote>
     <p>
      Address: 0x0000000000400fe4
     </p>
     <p>
      Opcode: ff d2
     </p>
     <p>
      Instruction: callq *%rdx
     </p>
     <p>
      Description: This calls the function whose address is stored in rdx.
      <br/>
      Since rdx holds a function pointer from the vtable, this is invoking a
      <br/>
      virtual method of the XtTraderApi object.
     </p>
    </blockquote>
    <p>
     <strong>
      Summary:
      <br/>
      A XtTraderApi object is created, and its pointer is stored on the stack.
      <br/>
      The vtable pointer of the object is accessed.
      <br/>
      A specific virtual method (at offset 0x18 in the vtable) is resolved.
      <br/>
      The virtual method is called with the XtTraderApi object (this pointer) as the first argument and 0x407f80 as the second argument.
      <br/>
      This is typical C++ behavior for calling a virtual method on an object. The vtable is used to dynamically resolve the correct method to call at runtime.
     </strong>
    </p>
    <p>
     因此我们确定了 init 函数在虚表中的位置是 0x18 也就是24， 那么24/8 = 3 , 所以是 0,8,16,24 在虚表中是第4个！
    </p>
    <p>
     但是，但是，我们的虚表显示，ini是第3个函数，也就是位置 16 的那个函数！？ windows下也用这个虚表，而且我们其他工程都是虚表（windows与linux)一致的啊！
     <br/>
     这是怎么回事！！！？？
     <br/>
     下面展示部分头文件，大家看看能明白怎么回事吗:
    </p>
    <pre><code class="prism language-cpp"> <span class="token keyword">class</span> <span class="token class-name">XT_API_EXPORT</span> XtTraderApi
 <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">public</span><span class="token operator">:</span>
     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">XtTraderApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

     <span class="token comment">/**
     * @brief 获取XtTraderApi实例
     * @param [in] address XtApiService监听端口
     */</span>
     <span class="token keyword">static</span> XtTraderApi<span class="token operator">*</span> <span class="token function">createXtTraderApi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">/**
     * @brief 设置数据回调对象
     * @param [in] pCallback XtTraderApiCallback类实例
     */</span>
     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">setCallback</span><span class="token punctuation">(</span>XtTraderApiCallback<span class="token operator">*</span> pCallback<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

     <span class="token comment">/**
     * @brief 创建api实例，并进行初始化
     * @param [in] configFilePath 配置文件夹目录，默认是"../config"，运行目录上一层的config下
     */</span>
     <span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> configFilePath <span class="token operator">=</span> <span class="token string">"../config"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     你看， 析构函数，static函数， setCallback, init 但是 那个 static函数不可能写在虚表里啊，windows下就是被撇除的，所以是
     <strong>
      析构函数，setCallback, init
     </strong>
     这个次序啊。
     <br/>
     但是，Linux的反汇编已经说了， init 的位置是 第4个函数！！也就是 static函数 也被算在虚表里了。LINUX 下！
     <br/>
     服了，之前其他工程，头文件类声明中的确没有 static函数。。。。。。。
     <br/>
     <strong>
      这个在 windows中和Linux中实现是不一样的！！！
     </strong>
     <br/>
     所以我们回过头，再去看之前的错误，我们认为我们一直在调用init函数，其实调用的是 setCallback(*pCallback) 函数， 我们以为传入的是字符串，但是api认为你传入的是pCallback, 而且最
     <strong>
      搞笑
     </strong>
     的是， setCallback 函数会检查 traderApi.ini 是否被加载过，没有则显示的错误和 init 显示的错误一致！
     <br/>
     这错误显示太没有逻辑了！直接误导我了几天！！！！！！
     <br/>
     于是修改了虚表， all done!
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f6e6f7273642f:61727469636c652f64657461696c732f313436323939353430" class_="artid" style="display:none">
 </p>
</div>


