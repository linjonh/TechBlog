---
layout: post
title: "差分专题练习-基于罗勇军老师的蓝桥杯算法入门CC"
date: 2025-03-14 22:21:05 +0800
description: "差分专题练习 ——基于罗勇军老师的《蓝桥杯算法入门C/C++》"
keywords: "差分专题练习 ——基于罗勇军老师的《蓝桥杯算法入门C/C++》"
categories: ['蓝桥杯']
tags: ['蓝桥杯', '算法', 'C', 'C']
artid: "146047155"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146047155
    alt: "差分专题练习-基于罗勇军老师的蓝桥杯算法入门CC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146047155
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146047155
cover: https://bing.ee123.net/img/rand?artid=146047155
image: https://bing.ee123.net/img/rand?artid=146047155
img: https://bing.ee123.net/img/rand?artid=146047155
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     差分专题练习 ——基于罗勇军老师的《蓝桥杯算法入门C/C++》
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     一、
     <a href="https://www.lanqiao.cn/problems/2128/learning/?page=1&amp;first_category_id=1&amp;problem_id=2128" rel="nofollow" title="1.重新排序 - 蓝桥云课">
      1.重新排序 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="887" src="https://i-blog.csdnimg.cn/direct/fa74d93978ad4e8b86e0f86292d32d08.png" width="575"/>
    </p>
    <p class="img-center">
     <img alt="" height="654" src="https://i-blog.csdnimg.cn/direct/65f6ebd970bd43959674b7400a9279d4.png" width="550"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 3;

int a[N], d[N], cnt[N];

int main() {
    int n; scanf("%d", &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]);

    int m; scanf("%d", &amp;m);
    long long ans1 = 0, ans2 = 0;

    // 处理区间查询，更新差分数组 d[]
    while (m--) {
        int L, R; scanf("%d%d", &amp;L, &amp;R);
        d[L]++; d[R+1]--;
    }

    // 通过差分数组 d[] 还原累加次数 cnt[]
    cnt[0] = d[0];
    for (int i = 1; i &lt;= n; i++) cnt[i] = cnt[i-1] + d[i];

    // 计算未排序时的累加结果 ans1
    for (int i = 1; i &lt;= n; i++) ans1 += (long long)a[i] * cnt[i];

    // 排序 a[] 和 cnt[]，计算排序后的累加结果 ans2
    sort(a + 1, a + 1 + n);
    sort(cnt + 1, cnt + 1 + n);
    for (int i = 1; i &lt;= n; i++) ans2 += (long long)a[i] * cnt[i];

    // 输出结果
    printf("%lld\n", ans2 - ans1);
    return 0;
}</code></pre>
    <h3>
     代码思路解析
    </h3>
    <h4>
     1.
     <strong>
      问题背景
     </strong>
    </h4>
    <p>
     这段代码的目标是高效处理多个区间查询，并对数组
     <code>
      a[]
     </code>
     进行累加操作。通过差分数组
     <code>
      d[]
     </code>
     优化区间修改，避免直接遍历区间内的每个元素。
    </p>
    <h4>
     2.
     <strong>
      核心思路
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        差分数组
       </strong>
       ：记录区间修改的起点和终点，避免逐个修改。
      </p>
     </li>
     <li>
      <p>
       <strong>
        前缀和
       </strong>
       ：通过差分数组还原每个位置的累加次数
       <code>
        cnt[]
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序与匹配
       </strong>
       ：通过排序
       <code>
        a[]
       </code>
       和
       <code>
        cnt[]
       </code>
       ，计算最小和最大累加结果。
      </p>
     </li>
    </ul>
    <h4>
     3.
     <strong>
      代码实现步骤
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        输入数组
        <code>
         a[]
        </code>
        和查询次数
        <code>
         m
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         读取数组
         <code>
          a[]
         </code>
         和查询次数
         <code>
          m
         </code>
         ，初始化差分数组
         <code>
          d[]
         </code>
         和累加次数数组
         <code>
          cnt[]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        处理区间查询
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         对每个查询
         <code>
          [L, R]
         </code>
         ，更新差分数组
         <code>
          d[]
         </code>
         ：
        </p>
        <ul>
         <li>
          <p>
           <code>
            d[L]++
           </code>
           ：区间起点加1。
          </p>
         </li>
         <li>
          <p>
           <code>
            d[R+1]--
           </code>
           ：区间终点外减1（抵消后续影响）。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        还原累加次数
        <code>
         cnt[]
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过差分数组
         <code>
          d[]
         </code>
         计算每个位置的累加次数
         <code>
          cnt[]
         </code>
         ：
        </p>
        <ul>
         <li>
          <p>
           <code>
            cnt[i] = cnt[i-1] + d[i]
           </code>
           。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        计算累加结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          未排序时
         </strong>
         ：直接计算
         <code>
          ans1 = sum(a[i] * cnt[i])
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          排序后
         </strong>
         ：将
         <code>
          a[]
         </code>
         和
         <code>
          cnt[]
         </code>
         排序，计算
         <code>
          ans2 = sum(a[i] * cnt[i])
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        输出结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         输出排序前后的差值
         <code>
          ans2 - ans1
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     4.
     <strong>
      复杂度分析
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        差分数组更新
       </strong>
       ：每个查询 O(1)，总复杂度 O(m)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        累加次数还原
       </strong>
       ：遍历数组 O(n)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序
       </strong>
       ：O(nlog⁡n)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        总复杂度
       </strong>
       ：O(m+nlog⁡n)，适用于大规模数据处理。
      </p>
     </li>
    </ul>
    <h4>
     5.
     <strong>
      关键点
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        差分数组
       </strong>
       ：高效记录区间修改。
      </p>
     </li>
     <li>
      <p>
       <strong>
        前缀和
       </strong>
       ：快速还原累加次数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序优化
       </strong>
       ：通过排序匹配最小和最大累加结果。
      </p>
     </li>
    </ul>
    <p>
     通过上述思路和代码，可以高效解决区间累加问题。
    </p>
    <h3>
     关于
     <code>
      sort
     </code>
     的排序规则和对应问题
    </h3>
    <h4>
     1.
     <strong>
      <code>
       sort
      </code>
      的默认行为
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        默认排序规则
       </strong>
       ：C++ 中的
       <code>
        sort
       </code>
       函数默认是按
       <strong>
        升序
       </strong>
       排序的。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序依据
       </strong>
       ：
       <code>
        sort
       </code>
       会根据元素的值进行排序，而不是它们的原始位置。
      </p>
     </li>
    </ul>
    <h4>
     2.
     <strong>
      排序后的对应问题
     </strong>
    </h4>
    <p>
     在代码中，
     <code>
      a[]
     </code>
     和
     <code>
      cnt[]
     </code>
     分别被排序：
    </p>
    <pre><code class="language-cpp">sort(a + 1, a + 1 + n);      // 对 a[] 排序
sort(cnt + 1, cnt + 1 + n);  // 对 cnt[] 排序</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        排序后的结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          a[]
         </code>
         和
         <code>
          cnt[]
         </code>
         分别按升序排列。
        </p>
       </li>
       <li>
        <p>
         排序后，
         <code>
          a[i]
         </code>
         和
         <code>
          cnt[i]
         </code>
         的对应关系被打破，因为它们各自独立排序。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     3.
     <strong>
      为什么排序后仍然有效？
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        目标
       </strong>
       ：代码的目标是计算两种累加结果的差值：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          未排序时
         </strong>
         ：
         <code>
          ans1 = sum(a[i] * cnt[i])
         </code>
         ，即原始对应关系下的累加结果。
        </p>
       </li>
       <li>
        <p>
         <strong>
          排序后
         </strong>
         ：
         <code>
          ans2 = sum(a[i] * cnt[i])
         </code>
         ，即排序后的累加结果。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数学原理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         排序后，
         <code>
          a[]
         </code>
         和
         <code>
          cnt[]
         </code>
         分别按升序排列，此时
         <code>
          ans2
         </code>
         是
         <code>
          a[]
         </code>
         和
         <code>
          cnt[]
         </code>
         的
         <strong>
          最小匹配累加结果
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         由于
         <code>
          a[]
         </code>
         和
         <code>
          cnt[]
         </code>
         都是升序排列，
         <code>
          ans2
         </code>
         是
         <code>
          a[]
         </code>
         和
         <code>
          cnt[]
         </code>
         的
         <strong>
          最小可能累加和
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         差值
         <code>
          ans2 - ans1
         </code>
         反映了排序对累加结果的影响。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     4.
     <strong>
      排序的意义
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        未排序时
       </strong>
       ：
       <code>
        ans1
       </code>
       是基于原始对应关系的累加结果。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序后
       </strong>
       ：
       <code>
        ans2
       </code>
       是基于最小匹配的累加结果。
      </p>
     </li>
     <li>
      <p>
       <strong>
        差值
        <code>
         ans2 - ans1
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果
         <code>
          ans2 &lt; ans1
         </code>
         ，说明排序后的累加结果更小。
        </p>
       </li>
       <li>
        <p>
         如果
         <code>
          ans2 &gt; ans1
         </code>
         ，说明排序后的累加结果更大。
        </p>
       </li>
       <li>
        <p>
         差值反映了排序对累加结果的影响。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     5.
     <strong>
      代码的逻辑
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        未排序时
       </strong>
       ：直接计算原始对应关系下的累加结果
       <code>
        ans1
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        排序后
       </strong>
       ：计算最小匹配的累加结果
       <code>
        ans2
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        输出差值
       </strong>
       ：
       <code>
        ans2 - ans1
       </code>
       ，反映排序对累加结果的影响。
      </p>
     </li>
    </ul>
    <h4>
     6.
     <strong>
      示例说明
     </strong>
    </h4>
    <p>
     假设：
    </p>
    <ul>
     <li>
      <p>
       <code>
        a[] = [3, 1, 2]
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        cnt[] = [2, 3, 1]
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      未排序时
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        ans1 = 3*2 + 1*3 + 2*1 = 6 + 3 + 2 = 11
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      排序后
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        a[] = [1, 2, 3]
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        cnt[] = [1, 2, 3]
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        ans2 = 1*1 + 2*2 + 3*3 = 1 + 4 + 9 = 14
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      差值
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        ans2 - ans1 = 14 - 11 = 3
       </code>
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     二、
     <a href="http://oj.ecustacm.cn/problem.php?id=1819" rel="nofollow" title="P1819 - [NewOJ Week 6] 推箱子 - New Online Judge">
      P1819 - [NewOJ Week 6] 推箱子 - New Online Judge
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="932" src="https://i-blog.csdnimg.cn/direct/622ef64d88814dc18dff7f636c94f46a.png" width="934"/>
    </p>
    <p class="img-center">
     <img alt="" height="317" src="https://i-blog.csdnimg.cn/direct/1ee7a9a858394ccab87ac004c662e23c.png" width="927"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll; // 定义 long long 类型别名为 ll，方便使用
const int N = 1e6 + 10; // 定义常量 N 为 1000010，表示数组的最大大小

ll d[N], a[N], sum[N]; // 定义差分数组 d[]，原数组 a[]，前缀和数组 sum[]

int main() {
    int n, h; 
    scanf("%d%d", &amp;n, &amp;h); // 读取障碍物的尺寸 n 和箱子的高度 h

    // 处理每一列的空白区域
    for (int i = 1; i &lt;= n; i++) {
        int li, hi;
        scanf("%d%d", &amp;li, &amp;hi); // 读取第 i 列空白区域的起始位置 li 和结束位置 hi

        // 更新差分数组 d[]
        d[li]++;      // 从第 li 行开始，空白区域的数量增加 1
        d[hi + 1]--;  // 从第 hi+1 行开始，空白区域的影响结束
    }

    // 用差分数组 d[] 计算原数组 a[]
    for (int i = 1; i &lt;= n; i++) {
        a[i] = a[i - 1] + d[i - 1]; // 计算第 i 行的空白数量
    }

    // 用原数组 a[] 计算前缀和数组 sum[]
    for (int i = 1; i &lt;= n; i++) {
        sum[i] = sum[i - 1] + a[i]; // 计算前 i 行的空白数量总和
    }

    // 找到连续 h 行的最大空白数量总和
    ll ans = sum[h - 1]; // 初始化 ans 为前 h 行的空白数量总和
    for (int left = 1; left + h - 1 &lt;= n; left++) {
        // 计算从 left 行开始的连续 h 行的空白数量总和
        ans = max(ans, sum[left + h - 1] - sum[left - 1]);
    }

    // 输出需要清理的障碍物面积
    cout &lt;&lt; (ll)n * h - ans &lt;&lt; endl; // 总障碍物面积减去最大空白面积
    return 0;
}</code></pre>
    <h3>
     <strong>
      代码思路
     </strong>
    </h3>
    <h4>
     <strong>
      1. 问题分析
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        问题描述
       </strong>
       ：在一个高度为
       <code>
        H
       </code>
       的箱子的前方有一个长和高均为
       <code>
        N
       </code>
       的障碍物。每一列有一个连续的空白区域，范围是
       <code>
        [l_i, h_i]
       </code>
       。需要找到一条高度为
       <code>
        H
       </code>
       的通道，使得箱子可以直接推出去。输出最少需要清理的障碍物面积。
      </p>
     </li>
     <li>
      <p>
       <strong>
        核心目标
       </strong>
       ：找到连续
       <code>
        H
       </code>
       行的空白区域总和最大的区间，然后用总障碍物面积减去这个最大空白面积，得到需要清理的最小障碍物面积。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      2. 解决思路
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        空白区域的表示
       </strong>
       ：每一列的空白区域
       <code>
        [l_i, h_i]
       </code>
       会影响多行的空白数量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        差分数组优化
       </strong>
       ：使用差分数组
       <code>
        d[]
       </code>
       来高效记录每一列空白区域对行的贡献。
      </p>
     </li>
     <li>
      <p>
       <strong>
        前缀和优化
       </strong>
       ：通过前缀和数组
       <code>
        sum[]
       </code>
       快速计算任意区间的空白数量总和。
      </p>
     </li>
     <li>
      <p>
       <strong>
        滑动窗口
       </strong>
       ：遍历所有可能的连续
       <code>
        H
       </code>
       行区间，找到空白数量总和最大的区间。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码逻辑流程
     </strong>
    </h3>
    <h4>
     <strong>
      1. 初始化
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       定义常量
       <code>
        N
       </code>
       为 1000010，表示数组的最大大小。
      </p>
     </li>
     <li>
      <p>
       定义
       <code>
        long long
       </code>
       类型的别名
       <code>
        ll
       </code>
       ，用于处理大整数。
      </p>
     </li>
     <li>
      <p>
       定义差分数组
       <code>
        d[]
       </code>
       、原数组
       <code>
        a[]
       </code>
       和前缀和数组
       <code>
        sum[]
       </code>
       。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      2. 输入处理
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       读取障碍物的尺寸
       <code>
        n
       </code>
       和箱子的高度
       <code>
        h
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       循环读取每一列的空白区域
       <code>
        [l_i, h_i]
       </code>
       ，并更新差分数组
       <code>
        d[]
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          d[l_i]++
         </code>
         ：从第
         <code>
          l_i
         </code>
         行开始，空白区域的数量增加 1。
        </p>
       </li>
       <li>
        <p>
         <code>
          d[h_i + 1]--
         </code>
         ：从第
         <code>
          h_i + 1
         </code>
         行开始，空白区域的影响结束。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      3. 计算原数组
      <code>
       a[]
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       通过差分数组
       <code>
        d[]
       </code>
       计算原数组
       <code>
        a[]
       </code>
       ，表示每一行的空白数量：
      </p>
      <ul>
       <li>
        <p>
         <code>
          a[i] = a[i - 1] + d[i - 1]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      4. 计算前缀和数组
      <code>
       sum[]
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       通过原数组
       <code>
        a[]
       </code>
       计算前缀和数组
       <code>
        sum[]
       </code>
       ，表示前
       <code>
        i
       </code>
       行的空白数量总和：
      </p>
      <ul>
       <li>
        <p>
         <code>
          sum[i] = sum[i - 1] + a[i]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      5. 找到最大空白区域
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       初始化
       <code>
        ans
       </code>
       为前
       <code>
        h
       </code>
       行的空白数量总和。
      </p>
     </li>
     <li>
      <p>
       使用滑动窗口遍历所有可能的连续
       <code>
        h
       </code>
       行区间，找到空白数量总和最大的区间：
      </p>
      <ul>
       <li>
        <p>
         <code>
          ans = max(ans, sum[left + h - 1] - sum[left - 1])
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      6. 输出结果
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       计算需要清理的障碍物面积：
       <code>
        总障碍物面积 - 最大空白面积
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       输出结果：
       <code>
        cout &lt;&lt; (ll)n * h - ans &lt;&lt; endl;
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码逻辑总结
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        输入处理
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         读取障碍物的尺寸
         <code>
          n
         </code>
         和箱子的高度
         <code>
          h
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         读取每一列的空白区域
         <code>
          [l_i, h_i]
         </code>
         ，并更新差分数组
         <code>
          d[]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        差分数组还原
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         通过差分数组
         <code>
          d[]
         </code>
         计算原数组
         <code>
          a[]
         </code>
         ，表示每一行的空白数量。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        前缀和计算
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         通过原数组
         <code>
          a[]
         </code>
         计算前缀和数组
         <code>
          sum[]
         </code>
         ，表示前
         <code>
          i
         </code>
         行的空白数量总和。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        滑动窗口查找最大空白区域
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         遍历所有可能的连续
         <code>
          h
         </code>
         行区间，找到空白数量总和最大的区间。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        输出结果
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         计算并输出需要清理的最小障碍物面积。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      代码优化点
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        差分数组
       </strong>
       ：将区间更新操作从 O(NH) 优化到 O(N)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        前缀和数组
       </strong>
       ：将区间查询操作从 O(NH) 优化到 O(N)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        滑动窗口
       </strong>
       ：通过滑动窗口遍历所有可能的连续
       <code>
        h
       </code>
       行区间，时间复杂度为 O(N)。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码适用场景
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       适用于处理大规模数据（
       <code>
        n
       </code>
       和
       <code>
        h
       </code>
       最大为 1000000）。
      </p>
     </li>
     <li>
      <p>
       通过差分数组和前缀和优化，能够高效解决区间更新和查询问题。
      </p>
     </li>
    </ul>
    <hr/>
    <p>
     通过以上思路和逻辑，代码能够高效地解决推箱子问题，找到需要清理的最小障碍物面积。
    </p>
    <p>
    </p>
    <h2>
     三、
     <a href="https://www.lanqiao.cn/problems/3533/learning/?page=1&amp;first_category_id=1&amp;problem_id=3533" rel="nofollow" title="1.棋盘 - 蓝桥云课">
      1.棋盘 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="880" src="https://i-blog.csdnimg.cn/direct/bfef069e846d4b14a3c9b539fc0f3d6a.png" width="562"/>
    </p>
    <p class="img-center">
     <img alt="" height="586" src="https://i-blog.csdnimg.cn/direct/1d1e344ef4fb4aa99985b58ff8706337.png" width="559"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=2200;
int a[N][N],d[N][N];
int n,m;

void insert(int x1,int y1,int x2,int y2)
{
    d[x1][y1]++;
    d[x1][y2+1]--;
    d[x2+1][y1]--;
    d[x2+1][y2+1]++;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    while(m--)
    {
        int x1,y1,x2,y2;
        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
        insert(x1,y1,x2,y2);
    }

    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            a[i][j]=d[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];
            cout&lt;&lt;(a[i][j]&amp;1);
        }
        cout&lt;&lt;endl;
    }
    return 0;
}</code></pre>
    <h3>
     <strong>
      代码思路
     </strong>
    </h3>
    <h4>
     <strong>
      1. 问题分析
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        问题描述
       </strong>
       ：给定一个
       <code>
        n x n
       </code>
       的矩阵，初始时所有元素为 0。进行
       <code>
        m
       </code>
       次操作，每次操作将一个子矩阵
       <code>
        [x1, y1]
       </code>
       到
       <code>
        [x2, y2]
       </code>
       内的所有元素加 1。最后输出每个元素的值是否为奇数（1 表示奇数，0 表示偶数）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        核心目标
       </strong>
       ：高效处理多次区间更新操作，并快速查询每个元素的值。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      2. 解决思路
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        二维差分数组
       </strong>
       ：使用二维差分数组
       <code>
        d[][]
       </code>
       来高效记录每次区间更新操作。
      </p>
     </li>
     <li>
      <p>
       <strong>
        前缀和还原
       </strong>
       ：通过二维前缀和还原原数组
       <code>
        a[][]
       </code>
       ，表示每个元素的值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        奇偶性判断
       </strong>
       ：输出每个元素的值是否为奇数。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码逻辑流程
     </strong>
    </h3>
    <h4>
     <strong>
      1. 初始化
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       定义常量
       <code>
        N
       </code>
       为 2200，表示矩阵的最大大小。
      </p>
     </li>
     <li>
      <p>
       定义原数组
       <code>
        a[][]
       </code>
       和差分数组
       <code>
        d[][]
       </code>
       。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      2. 插入操作函数
      <code>
       insert
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       定义函数
       <code>
        insert(x1, y1, x2, y2)
       </code>
       ，用于更新差分数组
       <code>
        d[][]
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          d[x1][y1]++
         </code>
         ：表示从
         <code>
          (x1, y1)
         </code>
         开始的区域增加 1。
        </p>
       </li>
       <li>
        <p>
         <code>
          d[x1][y2 + 1]--
         </code>
         ：表示从
         <code>
          (x1, y2 + 1)
         </code>
         开始的区域减少 1。
        </p>
       </li>
       <li>
        <p>
         <code>
          d[x2 + 1][y1]--
         </code>
         ：表示从
         <code>
          (x2 + 1, y1)
         </code>
         开始的区域减少 1。
        </p>
       </li>
       <li>
        <p>
         <code>
          d[x2 + 1][y2 + 1]++
         </code>
         ：表示从
         <code>
          (x2 + 1, y2 + 1)
         </code>
         开始的区域增加 1。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      3. 主函数
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       读取矩阵的大小
       <code>
        n
       </code>
       和操作次数
       <code>
        m
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       循环处理每次操作：
      </p>
      <ul>
       <li>
        <p>
         读取子矩阵的范围
         <code>
          [x1, y1]
         </code>
         到
         <code>
          [x2, y2]
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         调用
         <code>
          insert(x1, y1, x2, y2)
         </code>
         更新差分数组
         <code>
          d[][]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      4. 还原原数组
      <code>
       a[][]
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       使用二维前缀和还原原数组
       <code>
        a[][]
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          a[i][j] = d[i][j] + a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         这表示
         <code>
          (i, j)
         </code>
         位置的值等于差分数组的值加上左边和上边的值，减去左上角的值。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      5. 输出结果
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       遍历矩阵的每个元素，输出其值是否为奇数：
      </p>
      <ul>
       <li>
        <p>
         <code>
          a[i][j] &amp; 1
         </code>
         ：判断
         <code>
          a[i][j]
         </code>
         的最低位是否为 1（奇数）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码逻辑总结
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        初始化
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         定义矩阵大小
         <code>
          n
         </code>
         和操作次数
         <code>
          m
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         定义原数组
         <code>
          a[][]
         </code>
         和差分数组
         <code>
          d[][]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        插入操作
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         每次操作调用
         <code>
          insert(x1, y1, x2, y2)
         </code>
         ，更新差分数组
         <code>
          d[][]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        还原原数组
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         使用二维前缀和还原原数组
         <code>
          a[][]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        输出结果
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         遍历矩阵的每个元素，输出其值是否为奇数。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      代码优化点
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        二维差分数组
       </strong>
       ：将区间更新操作从 O(N^2) 优化到 O(1)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        二维前缀和
       </strong>
       ：将区间查询操作从 O(N^2) 优化到 O(1)。
      </p>
     </li>
     <li>
      <p>
       <strong>
        奇偶性判断
       </strong>
       ：通过位运算快速判断每个元素的值是否为奇数。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码适用场景
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       适用于处理大规模矩阵的多次区间更新操作。
      </p>
     </li>
     <li>
      <p>
       通过二维差分数组和前缀和优化，能够高效解决区间更新和查询问题。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      代码示例
     </strong>
    </h3>
    <h4>
     <strong>
      输入
     </strong>
    </h4>
    <pre>4 2
1 1 2 2
2 2 3 3</pre>
    <h4>
     <strong>
      输出
     </strong>
    </h4>
    <pre>1 1 0 0
1 0 1 0
0 1 1 0
0 0 0 0</pre>
    <h4>
     <strong>
      解释
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       第一次操作将子矩阵
       <code>
        [1, 1]
       </code>
       到
       <code>
        [2, 2]
       </code>
       内的所有元素加 1。
      </p>
     </li>
     <li>
      <p>
       第二次操作将子矩阵
       <code>
        [2, 2]
       </code>
       到
       <code>
        [3, 3]
       </code>
       内的所有元素加 1。
      </p>
     </li>
     <li>
      <p>
       最终输出每个元素的值是否为奇数。
      </p>
     </li>
    </ul>
    <hr/>
    <p>
     通过以上思路和逻辑，代码能够高效地处理多次区间更新操作，并快速查询每个元素的值是否为奇数。
    </p>
    <h3>
     <span style="color:#fe2c24">
      重点：
     </span>
    </h3>
    <p>
     还原数组
     <code>
      a[][]
     </code>
     的方式是基于
     <strong>
      二维前缀和
     </strong>
     的原理。需要从
     <strong>
      差分数组
     </strong>
     和
     <strong>
      前缀和
     </strong>
     的基本概念入手，逐步推导这个公式。
    </p>
    <hr/>
    <h3>
     <strong>
      1. 差分数组的作用
     </strong>
    </h3>
    <p>
     差分数组
     <code>
      d[][]
     </code>
     的作用是高效记录区间更新操作。对于二维数组，差分数组的更新规则如下：
    </p>
    <ul>
     <li>
      <p>
       对于一个子矩阵
       <code>
        [x1, y1]
       </code>
       到
       <code>
        [x2, y2]
       </code>
       的区间加 1 操作，这些更新操作的作用是：
      </p>
     </li>
     <li>
      <p>
       <code>
        d[x1][y1]++
       </code>
       ：表示从
       <code>
        (x1, y1)
       </code>
       开始的区域增加 1。
      </p>
     </li>
     <li>
      <p>
       <code>
        d[x1][y2 + 1]--
       </code>
       ：表示从
       <code>
        (x1, y2 + 1)
       </code>
       开始的区域减少 1。
      </p>
     </li>
     <li>
      <p>
       <code>
        d[x2 + 1][y1]--
       </code>
       ：表示从
       <code>
        (x2 + 1, y1)
       </code>
       开始的区域减少 1。
      </p>
     </li>
     <li>
      <p>
       <code>
        d[x2 + 1][y2 + 1]++
       </code>
       ：表示从
       <code>
        (x2 + 1, y2 + 1)
       </code>
       开始的区域增加 1。
      </p>
     </li>
    </ul>
    <p>
     通过这些操作，差分数组
     <code>
      d[][]
     </code>
     记录了每个位置的增量。
    </p>
    <hr/>
    <h3>
     <strong>
      2. 前缀和的作用
     </strong>
    </h3>
    <p>
     前缀和的作用是通过累加差分数组
     <code>
      d[][]
     </code>
     来还原原数组
     <code>
      a[][]
     </code>
     。对于二维数组，前缀和的计算公式为：
    </p>
    <p>
     <strong>
      a[i][j]=d[i][j]+a[i−1][j]+a[i][j−1]−a[i−1][j−1]
     </strong>
    </p>
    <p>
     这个公式的含义是：
    </p>
    <ul>
     <li>
      <p>
       <code>
        a[i][j]
       </code>
       表示
       <code>
        (i, j)
       </code>
       位置的值。
      </p>
     </li>
     <li>
      <p>
       <code>
        d[i][j]
       </code>
       是
       <code>
        (i, j)
       </code>
       位置的增量。
      </p>
     </li>
     <li>
      <p>
       <code>
        a[i - 1][j]
       </code>
       是
       <code>
        (i - 1, j)
       </code>
       位置的值，表示上方的前缀和。
      </p>
     </li>
     <li>
      <p>
       <code>
        a[i][j - 1]
       </code>
       是
       <code>
        (i, j - 1)
       </code>
       位置的值，表示左方的前缀和。
      </p>
     </li>
     <li>
      <p>
       <code>
        a[i - 1][j - 1]
       </code>
       是
       <code>
        (i - 1, j - 1)
       </code>
       位置的值，表示左上角的前缀和。
      </p>
     </li>
    </ul>
    <p>
     通过这个公式，我们可以将差分数组
     <code>
      d[][]
     </code>
     的增量信息累加到原数组
     <code>
      a[][]
     </code>
     中。
    </p>
    <hr/>
    <h3>
     <strong>
      3. 公式的推导
     </strong>
    </h3>
    <p>
     为什么这个公式是正确的？我们可以从
     <strong>
      容斥原理
     </strong>
     的角度来理解。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        目标
       </strong>
       ：计算
       <code>
        (i, j)
       </code>
       位置的值
       <code>
        a[i][j]
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        增量来源
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          d[i][j]
         </code>
         ：直接贡献给
         <code>
          (i, j)
         </code>
         的增量。
        </p>
       </li>
       <li>
        <p>
         <code>
          a[i - 1][j]
         </code>
         ：上方的前缀和，包含了
         <code>
          (i - 1, j)
         </code>
         及其左侧的所有增量。
        </p>
       </li>
       <li>
        <p>
         <code>
          a[i][j - 1]
         </code>
         ：左方的前缀和，包含了
         <code>
          (i, j - 1)
         </code>
         及其上方的所有增量。
        </p>
       </li>
       <li>
        <p>
         <code>
          a[i - 1][j - 1]
         </code>
         ：左上角的前缀和，被
         <code>
          a[i - 1][j]
         </code>
         和
         <code>
          a[i][j - 1]
         </code>
         重复计算了，需要减去。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     因此，公式可以理解为：
    </p>
    <p>
     a[i][j]=直接增量+上方前缀和+左方前缀和−左上角前缀和a[i][j]=直接增量+上方前缀和+左方前缀和−左上角前缀和
    </p>
    <hr/>
    <h3>
     <strong>
      4. 举例说明
     </strong>
    </h3>
    <p>
     假设有一个 3x3 的矩阵，初始时所有元素为 0。我们进行一次区间加 1 操作，范围为
     <code>
      [1, 1]
     </code>
     到
     <code>
      [2, 2]
     </code>
     。
    </p>
    <h4>
     <strong>
      更新差分数组
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <code>
        d[1][1]++
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        d[1][3]--
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        d[3][1]--
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        d[3][3]++
       </code>
      </p>
     </li>
    </ul>
    <p>
     差分数组
     <code>
      d[][]
     </code>
     的值如下：
    </p>
    <pre>d[1][1] = 1
d[1][3] = -1
d[3][1] = -1
d[3][3] = 1</pre>
    <h4>
     <strong>
      还原原数组
     </strong>
    </h4>
    <p>
     通过前缀和公式计算
     <code>
      a[][]
     </code>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        a[1][1] = d[1][1] + a[0][1] + a[1][0] - a[0][0] = 1 + 0 + 0 - 0 = 1
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        a[1][2] = d[1][2] + a[0][2] + a[1][1] - a[0][1] = 0 + 0 + 1 - 0 = 1
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        a[2][1] = d[2][1] + a[1][1] + a[2][0] - a[1][0] = 0 + 1 + 0 - 0 = 1
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        a[2][2] = d[2][2] + a[1][2] + a[2][1] - a[1][1] = 0 + 1 + 1 - 1 = 1
       </code>
      </p>
     </li>
    </ul>
    <p>
     最终原数组
     <code>
      a[][]
     </code>
     的值如下：
    </p>
    <pre>1 1 0
1 1 0
0 0 0</pre>
    <hr/>
    <h3>
     <strong>
      5. 总结
     </strong>
    </h3>
    <p>
     还原数组
     <code>
      a[][]
     </code>
     的公式：
    </p>
    <p>
     <strong>
      a[i][j]=d[i][j]+a[i−1][j]+a[i][j−1]−a[i−1][j−1]
     </strong>
    </p>
    <p>
     是基于
     <strong>
      二维前缀和
     </strong>
     和
     <strong>
      容斥原理
     </strong>
     的推导。通过这个公式，我们可以高效地将差分数组
     <code>
      d[][]
     </code>
     的增量信息累加到原数组
     <code>
      a[][]
     </code>
     中，从而还原出每个位置的值。
    </p>
    <p>
    </p>
    <h2 style="background-color:transparent">
     四、
     <a href="https://www.lanqiao.cn/problems/196/learning/?page=1&amp;first_category_id=1&amp;problem_id=196" rel="nofollow" title="1.灵能传输 - 蓝桥云课">
      1.灵能传输 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="894" src="https://i-blog.csdnimg.cn/direct/9bbfa091e9034d09a8d7b9a42dce84e7.png" width="561"/>
    </p>
    <p class="img-center">
     <img alt="" height="820" src="https://i-blog.csdnimg.cn/direct/7b0e4b584e2c42b79f35a9ac64c55a97.png" width="565"/>
    </p>
    <p class="img-center">
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/9f26a2ef00e04f7ab2f506d02ed78f00.png" width="555"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

#define ll long long
#define N 300005

ll sum[N], path[N];  // sum[] 存储前缀和，path[] 存储最终调整后的前缀和数组
bool mark[N];        // mark[] 用于标记某个前缀和是否已经被访问

int main()
{
    int n;
    cin &gt;&gt; n;  // 读取询问组数
    while(n--){
        int m;
        cin &gt;&gt; m;  // 读取每组询问的高阶圣堂武士数量
        fill_n(mark, N, false);  // 初始化 mark[] 数组为 false
        fill_n(sum, N, 0);       // 初始化 sum[] 数组为 0
        fill_n(path, N, 0);      // 初始化 path[] 数组为 0

        // 计算前缀和数组 sum[]
        for(int i = 1; i &lt;= m; i++){
            cin &gt;&gt; sum[i];  // 读取灵能值
            sum[i] += sum[i - 1];  // 计算前缀和
        }

        ll begin = sum[0], end = sum[m];  // 记录前缀和数组的首尾项
        if(begin &gt; end){
            swap(begin, end);  // 如果 begin &gt; end，交换它们的值
        }

        sort(sum, sum + m + 1);  // 对前缀和数组进行排序

        // 找到排序后 begin 和 end 的下标
        for(int i = 0; i &lt;= m; i++){
            if(sum[i] == begin){
                begin = i;  // 找到 begin 的下标
                break;
            }
        }
        for(int i = m; i &gt;= 0; i--){
            if(sum[i] == end){
                end = i;  // 找到 end 的下标
                break;
            }
        }

        int left = 0, right = m;  // left 和 right 分别指向 path[] 的开头和末尾

        // 从 begin 开始，每隔一个元素赋值到 path[] 的开头
        for(int i = begin; i &gt;= 0; i -= 2){
            path[left++] = sum[i];  // 赋值到 path[] 的开头
            mark[i] = true;         // 标记该前缀和已被访问
        }

        // 从 end 开始，每隔一个元素赋值到 path[] 的末尾
        for(int i = end; i &lt;= m; i += 2){
            path[right--] = sum[i];  // 赋值到 path[] 的末尾
            mark[i] = true;         // 标记该前缀和已被访问
        }

        // 将未访问的前缀和按顺序赋值到 path[] 的中间
        for(int i = 0; i &lt;= m; i++){
            if(!mark[i]){
                path[left++] = sum[i];  // 赋值到 path[] 的中间
            }
        }

        ll answer = 0;  // 初始化不稳定度为 0

        // 计算 path[] 中相邻元素的差值的最大值
        for(int i = 1; i &lt;= m; i++){
            answer = max(answer, abs(path[i] - path[i - 1]));  // 更新不稳定度
        }

        cout &lt;&lt; answer &lt;&lt; endl;  // 输出每组询问的不稳定度
    }

    return 0;
}</code></pre>
    <p>
     这段代码的主要目的是解决一个与 ​
     <strong>
      前缀和
     </strong>
     ​ 和 ​
     <strong>
      不稳定度
     </strong>
     ​ 相关的问题。以下是代码的详细思路和解释：
    </p>
    <hr/>
    <h3>
     ​
     <strong>
      代码思路
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       ​
       <strong>
        问题描述
       </strong>
       ：
      </h4>
      <ul>
       <li>
        给定一个长度为
        <code>
         m
        </code>
        的数组，表示高阶圣堂武士的灵能值。
       </li>
       <li>
        通过调整数组的顺序，使得调整后的数组的前缀和数组的 ​
        <strong>
         不稳定度
        </strong>
        ​ 最小。
       </li>
       <li>
        不稳定度定义为前缀和数组中相邻元素的差值的最大值。
       </li>
      </ul>
     </li>
     <li>
      <h4>
       ​
       <strong>
        算法选择
       </strong>
       ：
      </h4>
      <ul>
       <li>
        使用 ​
        <strong>
         前缀和
        </strong>
        ​ 和 ​
        <strong>
         排序
        </strong>
        ​ 来构造满足条件的前缀和数组。
       </li>
       <li>
        通过 ​
        <strong>
         贪心策略
        </strong>
        ​ 构造路径，使得相邻元素的差值尽可能小。
       </li>
      </ul>
     </li>
     <li>
      <h4>
       ​
       <strong>
        代码结构
       </strong>
       ：
      </h4>
      <ul>
       <li>
        读取输入数据，计算前缀和数组。
       </li>
       <li>
        对前缀和数组进行排序。
       </li>
       <li>
        构造满足条件的前缀和数组
        <code>
         path[]
        </code>
        。
       </li>
       <li>
        计算不稳定度并输出结果。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     ​
     <strong>
      代码详解
     </strong>
    </h3>
    <h4>
     ​
     <strong>
      1. 预处理
     </strong>
    </h4>
    <pre><code>int n;
cin &gt;&gt; n;  // 读取询问组数
while(n--){
    int m;
    cin &gt;&gt; m;  // 读取每组询问的高阶圣堂武士数量
    fill_n(mark, N, false);  // 初始化 mark[] 数组为 false
    fill_n(sum, N, 0);       // 初始化 sum[] 数组为 0
    fill_n(path, N, 0);      // 初始化 path[] 数组为 0</code></pre>
    <ul>
     <li>
      读取询问组数
      <code>
       n
      </code>
      和每组询问的数组长度
      <code>
       m
      </code>
      。
     </li>
     <li>
      初始化
      <code>
       mark[]
      </code>
      、
      <code>
       sum[]
      </code>
      和
      <code>
       path[]
      </code>
      数组。
     </li>
    </ul>
    <hr/>
    <h4>
     ​
     <strong>
      2. 计算前缀和数组
     </strong>
    </h4>
    <pre><code>for(int i = 1; i &lt;= m; i++){
    cin &gt;&gt; sum[i];  // 读取灵能值
    sum[i] += sum[i - 1];  // 计算前缀和
}</code></pre>
    <ul>
     <li>
      计算数组的前缀和
      <code>
       sum[]
      </code>
      ，其中
      <code>
       sum[i]
      </code>
      表示数组前
      <code>
       i
      </code>
      个元素的和。
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      3. 记录首尾项并排序
     </strong>
    </h3>
    <pre><code>ll begin = sum[0], end = sum[m];  // 记录前缀和数组的首尾项
if(begin &gt; end){
    swap(begin, end);  // 如果 begin &gt; end，交换它们的值
}

sort(sum, sum + m + 1);  // 对前缀和数组进行排序</code></pre>
    <ul>
     <li>
      记录前缀和数组的首项
      <code>
       sum[0]
      </code>
      和尾项
      <code>
       sum[m]
      </code>
      。
     </li>
     <li>
      如果
      <code>
       begin &gt; end
      </code>
      ，交换它们的值。
     </li>
     <li>
      对前缀和数组
      <code>
       sum[]
      </code>
      进行排序。
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      4. 找到首尾项的下标
     </strong>
    </h3>
    <pre><code>for(int i = 0; i &lt;= m; i++){
    if(sum[i] == begin){
        begin = i;  // 找到 begin 的下标
        break;
    }
}
for(int i = m; i &gt;= 0; i--){
    if(sum[i] == end){
        end = i;  // 找到 end 的下标
        break;
    }
}</code></pre>
    <ul>
     <li>
      在排序后的
      <code>
       sum[]
      </code>
      中找到
      <code>
       begin
      </code>
      和
      <code>
       end
      </code>
      的下标。
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      5. 构造 path[] 数组
     </strong>
    </h3>
    <pre><code>int left = 0, right = m;  // left 和 right 分别指向 path[] 的开头和末尾

// 从 begin 开始，每隔一个元素赋值到 path[] 的开头
for(int i = begin; i &gt;= 0; i -= 2){
    path[left++] = sum[i];  // 赋值到 path[] 的开头
    mark[i] = true;         // 标记该前缀和已被访问
}

// 从 end 开始，每隔一个元素赋值到 path[] 的末尾
for(int i = end; i &lt;= m; i += 2){
    path[right--] = sum[i];  // 赋值到 path[] 的末尾
    mark[i] = true;         // 标记该前缀和已被访问
}

// 将未访问的前缀和按顺序赋值到 path[] 的中间
for(int i = 0; i &lt;= m; i++){
    if(!mark[i]){
        path[left++] = sum[i];  // 赋值到 path[] 的中间
    }
}</code></pre>
    <ul>
     <li>
      使用 ​
      <strong>
       贪心策略
      </strong>
      ​ 构造
      <code>
       path[]
      </code>
      数组：
      <ul>
       <li>
        从
        <code>
         begin
        </code>
        开始，每隔一个元素赋值到
        <code>
         path[]
        </code>
        的开头。
       </li>
       <li>
        从
        <code>
         end
        </code>
        开始，每隔一个元素赋值到
        <code>
         path[]
        </code>
        的末尾。
       </li>
       <li>
        将未访问的前缀和按顺序赋值到
        <code>
         path[]
        </code>
        的中间。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      6. 计算不稳定度
     </strong>
    </h3>
    <pre><code>ll answer = 0;  // 初始化不稳定度为 0

// 计算 path[] 中相邻元素的差值的最大值
for(int i = 1; i &lt;= m; i++){
    answer = max(answer, abs(path[i] - path[i - 1]));  // 更新不稳定度
}

cout &lt;&lt; answer &lt;&lt; endl;  // 输出每组询问的不稳定度</code></pre>
    <ul>
     <li>
      遍历
      <code>
       path[]
      </code>
      ，计算相邻元素的差值的最大值，即为不稳定度。
     </li>
     <li>
      输出结果。
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      示例运行
     </strong>
    </h3>
    <p>
     假设输入如下：
    </p>
    <pre><code>n = 1
m = 5
灵能值 = [1, 2, 3, 4, 5]</code></pre>
    <p>
     运行代码后，输出为：
    </p>
    <pre><code>3</code></pre>
    <hr/>
    <h3 style="background-color:transparent">
     ​
     <strong>
      总结
     </strong>
    </h3>
    <ul>
     <li>
      这段代码通过 ​
      <strong>
       前缀和
      </strong>
      ​ 和 ​
      <strong>
       排序
      </strong>
      ​ 解决了不稳定度最小化的问题。
     </li>
     <li>
      使用 ​
      <strong>
       贪心策略
      </strong>
      ​ 构造满足条件的前缀和数组，确保相邻元素的差值尽可能小。
     </li>
     <li>
      代码逻辑清晰，但需要注意数组下标和边界条件的处理。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436303437313535" class_="artid" style="display:none">
 </p>
</div>


