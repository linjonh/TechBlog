---
layout: post
title: "谈谈List,Set,Map的区别"
date: 2025-03-12 16:54:59 +0800
description: "基于动态数组实现，支持快速随机访问，但插入和删除效率较低（需要移动元素）。：基于双向链表实现，支持高效的插入和删除操作，但随机访问效率较低。：基于红黑树实现，元素按自然顺序或指定的比较器排序。：基于红黑树实现，按键的自然顺序或指定的比较器排序。：基于哈希表实现，提供快速的插入、删除和查找操作。：基于哈希表实现，提供快速的插入、删除和查找操作。是一个有序集合，元素的插入顺序和访问顺序一致。不允许存储重复的元素，重复添加的元素会被忽略。：基于哈希表和链表实现，保持插入顺序或访问顺序。"
keywords: "谈谈List,Set,Map的区别"
categories: ['面试Java部分']
tags: ['Java']
artid: "146209468"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146209468
    alt: "谈谈List,Set,Map的区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146209468
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146209468
cover: https://bing.ee123.net/img/rand?artid=146209468
image: https://bing.ee123.net/img/rand?artid=146209468
img: https://bing.ee123.net/img/rand?artid=146209468
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     谈谈List,Set,Map的区别
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <code>
      List
     </code>
     、
     <code>
      Set
     </code>
     和
     <code>
      Map
     </code>
     是 Java 集合框架（Java Collections Framework）中的三种主要接口，它们各自有不同的特点和用途。以下是它们的区别和使用场景的详细解释：
    </p>
    <hr/>
    <h4>
     <strong>
      1. List（列表）
     </strong>
    </h4>
    <h5>
     <strong>
      1.1 特点
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        有序集合
       </strong>
       ：
       <code>
        List
       </code>
       是一个有序集合，元素的插入顺序和访问顺序一致。
      </p>
     </li>
     <li>
      <p>
       <strong>
        允许重复
       </strong>
       ：
       <code>
        List
       </code>
       允许存储重复的元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        索引访问
       </strong>
       ：可以通过索引（index）快速访问元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        典型实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          <code>
           ArrayList
          </code>
         </strong>
         ：基于动态数组实现，支持快速随机访问，但插入和删除效率较低（需要移动元素）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           LinkedList
          </code>
         </strong>
         ：基于双向链表实现，支持高效的插入和删除操作，但随机访问效率较低。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           Vector
          </code>
         </strong>
         ：类似于
         <code>
          ArrayList
         </code>
         ，但线程安全（已较少使用，推荐使用
         <code>
          Collections.synchronizedList
         </code>
         或
         <code>
          CopyOnWriteArrayList
         </code>
         ）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      1.2 使用场景
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        需要有序存储元素
       </strong>
       ：例如，存储一系列用户操作的记录。
      </p>
     </li>
     <li>
      <p>
       <strong>
        需要频繁访问元素
       </strong>
       ：例如，通过索引快速获取元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        允许重复元素
       </strong>
       ：例如，存储多个相同的成绩记录。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      1.3 示例代码
     </strong>
    </h5>
    <p>
     java复制
    </p>
    <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("Java");
list.add("Python");
list.add("Java"); // 允许重复

System.out.println(list.get(1)); // 访问索引为 1 的元素：Python</code></pre>
    <hr/>
    <h4>
     <strong>
      2. Set（集合）
     </strong>
    </h4>
    <h5>
     <strong>
      2.1 特点
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        无序集合
       </strong>
       ：
       <code>
        Set
       </code>
       是一个无序集合，不保证元素的插入顺序。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不允许重复
       </strong>
       ：
       <code>
        Set
       </code>
       不允许存储重复的元素，重复添加的元素会被忽略。
      </p>
     </li>
     <li>
      <p>
       <strong>
        典型实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          <code>
           HashSet
          </code>
         </strong>
         ：基于哈希表实现，提供快速的插入、删除和查找操作。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           LinkedHashSet
          </code>
         </strong>
         ：基于哈希表和链表实现，保持插入顺序。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           TreeSet
          </code>
         </strong>
         ：基于红黑树实现，元素按自然顺序或指定的比较器排序。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      2.2 使用场景
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        需要去重
       </strong>
       ：例如，存储一组不重复的用户 ID。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不需要顺序
       </strong>
       ：例如，存储一组随机的标签。
      </p>
     </li>
     <li>
      <p>
       <strong>
        需要快速查找
       </strong>
       ：例如，检查某个元素是否存在于集合中。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      2.3 示例代码
     </strong>
    </h5>
    <p>
     java复制
    </p>
    <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();
set.add("Java");
set.add("Python");
set.add("Java"); // 重复元素会被忽略

System.out.println(set); // 输出：[Java, Python]</code></pre>
    <hr/>
    <h4>
     <strong>
      3. Map（映射）
     </strong>
    </h4>
    <h5>
     <strong>
      3.1 特点
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        键值对存储
       </strong>
       ：
       <code>
        Map
       </code>
       是一种键值对（Key-Value）的集合，每个键映射到一个值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        键唯一
       </strong>
       ：键必须是唯一的，但值可以重复。
      </p>
     </li>
     <li>
      <p>
       <strong>
        无序集合
       </strong>
       ：
       <code>
        Map
       </code>
       不保证键值对的顺序（某些实现如
       <code>
        TreeMap
       </code>
       和
       <code>
        LinkedHashMap
       </code>
       除外）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        典型实现
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          <code>
           HashMap
          </code>
         </strong>
         ：基于哈希表实现，提供快速的插入、删除和查找操作。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           TreeMap
          </code>
         </strong>
         ：基于红黑树实现，按键的自然顺序或指定的比较器排序。
        </p>
       </li>
       <li>
        <p>
         <strong>
          <code>
           LinkedHashMap
          </code>
         </strong>
         ：基于哈希表和链表实现，保持插入顺序或访问顺序。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      3.2 使用场景
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        需要键值对存储
       </strong>
       ：例如，存储用户 ID 和用户信息的映射。
      </p>
     </li>
     <li>
      <p>
       <strong>
        需要快速查找
       </strong>
       ：例如，根据键快速获取对应的值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        需要保持顺序
       </strong>
       ：例如，使用
       <code>
        LinkedHashMap
       </code>
       保持插入顺序。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      3.3 示例代码
     </strong>
    </h5>
    <p>
     java复制
    </p>
    <pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("Java", 10);
map.put("Python", 20);
map.put("Java", 30); // 键重复时会覆盖值

System.out.println(map.get("Java")); // 输出：30</code></pre>
    <hr/>
    <h4>
     <strong>
      4. List、Set 和 Map 的区别
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        List
       </th>
       <th>
        Set
       </th>
       <th>
        Map
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         存储方式
        </strong>
       </td>
       <td>
        有序集合，允许重复
       </td>
       <td>
        无序集合，不允许重复
       </td>
       <td>
        键值对集合，键唯一
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         典型用途
        </strong>
       </td>
       <td>
        存储有序数据，允许重复
       </td>
       <td>
        存储唯一数据，去重
       </td>
       <td>
        存储键值对，快速查找
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         插入顺序
        </strong>
       </td>
       <td>
        保持插入顺序
       </td>
       <td>
        不保证顺序（
        <code>
         LinkedHashSet
        </code>
        和
        <code>
         TreeSet
        </code>
        除外）
       </td>
       <td>
        不保证顺序（
        <code>
         LinkedHashMap
        </code>
        和
        <code>
         TreeMap
        </code>
        除外）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         性能
        </strong>
       </td>
       <td>
        随机访问快（
        <code>
         ArrayList
        </code>
        ）
       </td>
       <td>
        插入和查找快（
        <code>
         HashSet
        </code>
        ）
       </td>
       <td>
        插入和查找快（
        <code>
         HashMap
        </code>
        ）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         线程安全
        </strong>
       </td>
       <td>
        需手动同步（
        <code>
         Vector
        </code>
        ）
       </td>
       <td>
        需手动同步（
        <code>
         Collections.synchronizedSet
        </code>
        ）
       </td>
       <td>
        需手动同步（
        <code>
         Collections.synchronizedMap
        </code>
        ）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         典型实现
        </strong>
       </td>
       <td>
        <code>
         ArrayList
        </code>
        、
        <code>
         LinkedList
        </code>
       </td>
       <td>
        <code>
         HashSet
        </code>
        、
        <code>
         LinkedHashSet
        </code>
        、
        <code>
         TreeSet
        </code>
       </td>
       <td>
        <code>
         HashMap
        </code>
        、
        <code>
         TreeMap
        </code>
        、
        <code>
         LinkedHashMap
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      5. 总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         List
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         有序集合，允许重复。
        </p>
       </li>
       <li>
        <p>
         适合需要有序存储和频繁访问元素的场景。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         Set
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         无序集合，不允许重复。
        </p>
       </li>
       <li>
        <p>
         适合需要去重和快速查找的场景。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         Map
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         键值对集合，键唯一。
        </p>
       </li>
       <li>
        <p>
         适合需要根据键快速查找值的场景。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     在实际开发中，选择合适的集合类型取决于具体需求。例如：
    </p>
    <ul>
     <li>
      <p>
       如果需要存储有序的重复数据，使用
       <code>
        List
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       如果需要存储唯一数据，使用
       <code>
        Set
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       如果需要存储键值对关系，使用
       <code>
        Map
       </code>
       。
      </p>
     </li>
    </ul>
    <p>
     如果你还有其他问题，欢迎继续提问！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f64616e67616f6465616979692f:61727469636c652f64657461696c732f313436323039343638" class_="artid" style="display:none">
 </p>
</div>


