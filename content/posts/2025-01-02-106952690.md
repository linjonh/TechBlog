---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33393732373933362f:61727469636c652f64657461696c732f313036393532363930"
layout: post
title: "测试面试笔试题-大集合"
date: 2025-01-02 16:06:15 +08:00
description: "测试工程师面试/笔试题BAT_图片尺寸验证:最大700*800像"
keywords: "图片尺寸验证:最大700*800像素(此为百度数据"
categories: ['面试题', '笔试题', 'Python']
tags: ['黑盒测试', '软件测试', '数据库']
artid: "106952690"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=106952690
    alt: "测试面试笔试题-大集合"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=106952690
featuredImagePreview: https://bing.ee123.net/img/rand?artid=106952690
---

# 测试面试/笔试题 大集合

## 一、测试理论

### 1.1、软件测试的目的

* 从用户的角度出发

  ```
    普遍希望通过软件测试暴露软件中隐藏的错误和缺陷，以考虑是否可接受该产品。

  ```
* 从软件开发者的角度出发

  ```
    则希望测试成为表明软件产品中不存在错误的过程，验证该软件已正确地实现了用户的要求，确立人们对软件质量的信心。

  ```

### 1.2、软件测试的原则

* 应当把“尽早地和不断地进行软件测试”作为软件开发者和测试人员的座右铭。
* 测试用例应由测试输入数据和对应的预期输出结果这两部分组成。
* 程序员应避免检查自己的程序。
* 在设计测试用例时，应当包括合理的输入条件和不合理的输入条件。
* 充分注意测试中的群集现象。经验表明，测试后程序中残存的错误数目与该程序中已发现的错误数目成正比。
* 严格执行测试计划，排除测试的随意性。
* 应当对每一个测试结果做全面检查。
* 妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便。

### 1.3、软件测试的对象

```
    软件测试并不等于程序测试。软件测试应贯穿于软件定义与开发的整个期间。
    需求分析、概要设计、详细设计以及程序编码等各阶段所得到的文档，包括需求规格说明、概要设计规格说明、详细设计规格说明以及源程序，都应成为软件测试的对象。

```

### 1.4、测试分为哪几个阶段

```
    单元测试
    集成测试
    确认测试
    系统测试
    验收测试

```

### 1.5、软件测试的流程是什么

* 需求调查

  ```
    全面了解系统概况、应用领域、软件开发周期、软件开发环境、开发组织、时间安排、功能需求、性能需求、质量需求及测试要求等。根据系统概况进行项目所需的人员、时间和工作量估计以及项目报价

  ```
* 制定初步的项目计划
* 测试准备

  ```
    组织测试团队、培训、建立测试和管理环境等

  ```
* 测试设计

  ```
    按照测试要求进行每个测试项的测试设计，包括测试用例的设计和测试脚本的开发等

  ```
* 测试实施

  ```
    按照测试计划实施测试

  ```
* 测试评估

  ```
    根据测试的结果，出具测试评估报告

  ```

### 1.6、单元测试的测试对象、目的、测试依据、测试方法

* 测试对象是：模块内部的程序错误
* 目的是：消除局部模块逻辑和功能上的错误和缺陷
* 测试依据是：模块的详细设计
* 测试方法是：采用白盒测试。

### 1.7、常见的黑盒测试用例 设计方法

#### 1.7.1、等价类划分

```
    划分等价类: 等价类是指某个输入域的子集合.在该子集合中,各个输入数据对于揭露程序中的错误都是等效的.并合理地假定:测试某等价类的代表值就等于对这一类其它值的测试.因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件,就可以用少量代表性的测试数据.取得较好的测试结果.等价类划分可有两种不同的情况:有效等价类和无效等价类.

```

#### 1.7.2、边界值分析法

```
    边界值分析方法是对等价类划分方法的补充。测试工作经验告诉我,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误.
    使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.应当选取正好等于,刚刚大于或刚刚小于边界的值作为测试数据,而不是选取等价类中的典型值或任意值作为测试数据.

```

#### 1.7.3、错误推测法

```
    基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法.
    错误推测方法的基本思想: 列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例-例如, 在单元测试时曾列出的许多在模块中常见的错误-以前产品测试中曾经发现的错误等, 这些就是经验的总结。还有, 输入数据和输出数据为0的情况。输入表格为空格或输入表格只有一行-这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例.

```

#### 1.7.4、因果图方法

```
    等价类划分方法和边界值分析方法,都是着重考虑输入条件,但未考虑输入条件之间的联系, 相互组合等-考虑输入条件之间的相互组合,可能会产生一些新的情况-但要检查输入条件的组合不是一件容易的事情, 即使把所有输入条件划分成等价类,他们之间的组合情况也相当多-因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例-这就需要利用因果图（逻辑模型）-因果图方法最终生成的就是判定表-它适合于检查程序输入条件的各种组合情况.

```

#### 1.7.5、正交表分析法

```
    有时候，可能因为大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。

```

#### 1.7.6、场景分析方法

```
    指根据用户场景来模拟用户的操作步骤，这个比较类似因果图，但是可能执行的深度和可行性更好。

```

### 1.8、一条软件缺陷（或者叫bug）记录都包含了哪些内容？如何提交高质量的软件缺陷（bug）记录

```bash
　　1-在传统的bugzilla中，bug描述应该包括以下的信息
　　2-和bug产生对应的软件版本
　　3-开发的接口人员
　　4-bug的优先级
　　5-bug的严重程度
　　6-bug可能属于的模块，如果不能确认，可以用开发人员来判断
　　7-bug标题，需要清晰的描述现象
　　8-bug描述，需要尽量给出重新bug的步骤
　　9-bug附件中能给出相关的日志和截图

```

```
    高质量的bug记录就是指很容易理解的bug记录，所以，对于描述的要求高，能提供的信息多且准确，很好的帮助开发人员定位。

```

### 1.9、当开发人员说不是BUG时，你如何应付？

```
    开发人员说不是BUG，有2种情况，一是需求没有确定，所以我可以这么做，这个时候可以找来产品经理进行确认，需不需要改动。3方商量确定好后再看要不要改。二是这种情况不可能发生，所以不需要修改，这个时候，我可以先尽可能的说出是BUG的一句是什么？如果被用户发现或出了问题，会有什么不良结果？程序员可能会给你很多理由，你可以对他的解释进行反驳。如果还是不行，那我可以给这个问题提出来，跟开发经理和测试经理进行确认，如果要修改就改，如果不要修改就不改。其实有些真的不是BUG，我也只是建议的方式写进测试文档中，如果开发人员不修改也没有大问题。如果不是BUG的话，一定要坚持自己的立场，让问题得到最后的确认

```

### 1.10、根据你的经验说说你对软件测试/质量保证的理解

```
    软件质量保证与测试是根据软件开发阶段的规格说明和程序的内部结构而精心设计的一批测试用例(即输入数据和预期的输出结果)，并根据这些测试用例去运行程序，以发现错误的过程。它是对应用程序的各个方面进行测试以检查其功能、语言有效性及其外观排布。

```

## 二、测试设计类

### 2.1、如何测试朋友圈

```
    从以下点分析：功能测试、可靠性、易用性、效率、可维护性、可移植性

```

#### 2.1.1、功能测试

* 朋友圈发送
* 朋友圈浏览

##### 2.1.1.1、发送功能

* 只发送文本

  ```
    a、考虑文本长度：1-1500字符、超出最大字符长度 【边界值分析】
    b、考虑文本类型：纯中文、纯数字、纯字母、纯字符、纯表情（微信表情/手机自带表情）、混合类型、包含url链接
    c、文本是否支持复制粘贴
    d、为空验证 

  ```
* 只发送图片

  ```
    a、本地相册选择/拍摄
    b、图片数量验证：1-9张图片、超出9张
    c、图片格式验证：常见图片格式jpg、png、动态gif图片、不支持的图片格式【文件】
    d、图片尺寸验证：最大700*800像素、超出最大尺寸范围是否压缩
    e、图片大小验证：1-300kb、超出300kb
    f、图片的预览验证：点击支持预览大图、多张图片支持左右滑动预览
    g、图片的增删改操作
    h、为空验证

  ```
* 只发送视频

  ```
    a、本地相册选择/拍摄
    b、视频秒数验证：1-10s，超出10s
    c、视频个数验证：1个，超出1个
    d、视频格式验证：支持的视频格式，例mp4、不支持的视频格式
    e、视频大小验证：苹果400kb以内、Android200-300kb、超出规定大小
    f、视频预览增删改操作
    g、为空验证

  ```
* 组合验证

  ```
    a、发送文本+图片：输入满足要求的文本、图片进行一次验证
    b、发送文本+视频：输入满足要求的文本、视频进行一次验证
    c、发送图片+视频：不支持发送
    d、朋友圈发送内容是否有限制，例如涉及黄赌毒等敏感字

  ```
* 所在位置

  ```
    a、不显示位置：发送到朋友圈动态不显示位置
    b、选择对应位置：搜索支持、自动定位、手动编辑
    c、点击取消，返回上一级页面

  ```
* 谁可以看

  ```
    a、设置公开：所有朋友可见
    b、设置私密（仅自己可见）：自己查看朋友圈-可见、好友查看朋友圈-不可见
    c、设置部分可见（部分朋友可见）：选择的部分好友-可见、不被选择的好友-不可见、是否有人数上限
    d、设置不给谁看（选中的朋友不可见）：不被选中的朋友-可见、被选中的朋友-不可见、是否有人数上限
    e、点击取消，返回发送页面

  ```
* 提醒谁看

  ```
    a、提醒单人/提醒多人：被提醒的朋友-收到消息提醒、未被提醒-未有消息提醒
    b、是否有人数上限
    c、点击取消，返回发送页面

  ```
* 同步QQ空间：默认不同步、同步到QQ空间
* 取消发送操作

  ```
    a、选择相机，点击取消，返回朋友圈页面
    b、进入朋友圈发送页面，选择文本图片，点击取消

  ```
* 朋友圈当天发送次数是否有上限限制

##### 2.1.1.2、查看功能

* 文本查看：

  ```
    a、过长文本内容是否隐藏，并支持查看全文
    b、右键选择复制、收藏、翻译
    c、url链接是否支持点击跳转网页

  ```
* 图片查看

  ```
    a、小图右键支持收藏/编辑
    b、点击支持大图浏览
    c、选择发送给朋友、收藏、保存图片、编辑
    d、多张图片支持左右滑动浏览

  ```
* 视频查看

  ```
    a、右键视频支持静音播放/搜藏
    b、点击视频播放按键支持播放视频
    c、选择发送给朋友、收藏、保存视频、编辑

  ```
* 分享动态浏览：QQ空间/公众号文章/非腾讯产品分享后朋友圈是否正常显示
* 赞：点赞、取消点赞
* 评论

  ```
    a、评论长度：评论字数合理长度、评论超过字数上限
    b、评论类型：纯中文、纯数字、纯字母、纯字符、纯表情（微信表情/手机自带表情）、混合类型、包含url链接；
    c、评论是否支持复制粘贴
    d、为空验证
    e、发表评论后删除
    f、评论回复操作

  ```
* 删除朋友圈动态
* 更换相册封面
* 刷新是否正常获取新动态
* 上滑是否加载更多
* 朋友圈小红点提示

#### 2.1.2、界面/易用性测试

* 页面布局设计是否跟产品原型图/ui效果图一致 【测试人员】
* 功能操作是否简便，页面布局排版风格是否美观合理，提示语相关信息是否易于理解 【用户使用】

#### 2.1.3、中断测试

* 服务端业务中断

  ```
    a) 核心功能  
    b) 当前功能存在实时数据交换，例发朋友圈、浏览朋友圈进行中断，是否容易出现崩溃

  ```
* APP端中断

  ```
    a) 前后台切换、锁屏解锁、断网重连、app切换、来电话/来短信中断、插拔耳机线/数据线

  ```

#### 2.1.4、网络测试

* 三大运营商不同网络制式测试
* 网络切换测试：WIFI/5G/4G/3G/2G
* 无网测试：对于缓存在本地的数据，部分朋友圈信息是否支持浏览
* 弱网测试

  ```
    a、延时：页面响应时间是否可接受、不同网络制式是否区分超时时长、出现请求超时，是否给予相应的提示

    b、丢包：有无超时重连机制、如果未响应，是否给予相应提示

    c、页面呈现的完整性验证

  ```

#### 2.1.5、兼容性测试

* Android手机端、苹果手机端、pad版（主流）功能界面显示是否正常
* 各平台朋友圈展示数据是否一致

#### 2.1.6、安全测试

* 发送朋友圈时，文本输入脚本代码，是否出现异常

#### 2.1.7、性能测试

* 服务器性能测试

  ```
    可通过loadrunner/jmeter工具实现，主要关注TPS、响应时间、吞吐量、CPU、内存等

  ```
* app客户端性能测试

  ```
    可通过GT工具实现，运行时关注cpu、内存、流量、电量等占用率

  ```
* app压力稳定性测试

  ```
    通过monkey工具实现，频繁发送朋友圈，浏览朋友圈请求，是否容易发生崩溃

  ```

### 2.2、测试百度搜索引擎

```
    从以下几点分析：功能测试、性能测试、易用性测试、界面测试、安全性测试、兼容性测试、其它测试

```

#### 2.2.1、功能测试

* 输入
* 搜索

##### 2.2.1.1、输入内容

* 输入不同形式的内容：字符，图片，音频等输入字符，是否有默认的高频相关字符在下拉菜单中显示出来
* 内容为空
* 内容含有特殊字符，如空格等。输入前后的空格是否能够忽略，但不能忽略中间的空格
* 内容含有非法字符
* 反复输入相同的数据，如5次以上，看处理是否正确

##### 2.2.1.2、搜索长度

```
    内容在指定长度之内；
    内容在指定长度之外，观察系统能够正确进行截取。
    只能输入允许的字符串长度。百度最长为XX个字

```

##### 2.2.1.3 其它测试

* 搜索框是否支持快捷键：复制，粘贴等
* 是否支持回车进行搜索
* 是否可以删除重输
* 是否可以在搜索界面继续输入
* 链接测试：页面上的链接都可连接至正确的页面
* 搜索历史内容记录，便于查找检索过的内容

#### 2.2.2、性能测试

* 在网络情况良好的前提下，页面的跳转需要多长时间
* 在网络情况不好的前提下，页面的跳转需要多少时间
* 对搜索引擎进行加压测试
* 搜索页面打开的速度是否满足设计要求
* 搜索出结果消耗的时间，是否满足设计要求

#### 2.2.3、界面测试

* UI显示是否正确
* 页面布局，页面样式检查
* 组件，控件位置放置是否合适，
* 是否支持快捷键
* Tab键切换焦点顺序正确性
* 已查看过的结果链接，链接的颜色要灰化处理，和没有点击过的结果链接区分
* 当结果数量庞大时，页面的分页布局合理

#### 2.2.4、安全性测试

* SQL注入攻击防范
* 脚本注入测试
* 被删除、加密、授权的数据，不允许被查出来的，是否有安全控制设计
* 敏感内容的检索是禁止的

#### 2.2.5、兼容性测试

* 不同操作系统平台：Windows系统，MacOS系统
* 不同浏览器：Firefox，Chrome，IE，及其各个版本
* 不同移动端：IOS，Android
* 不同分辨率

#### 2.2.6、易用性测试

* 对用户是否友好
* 是否有在线帮助文档

### 2.3、如何测试阿里商品搜索功能

```
    从以下几点分析：功能测试、性能测试、易用性测试、界面测试、安全性测试、兼容性测试、其它测试

```

#### 2.3.1 功能测试

* 输入
* 搜索

##### 2.3.1.1、输入内容

* 边界值验证：在允许的字符串长度内外，验证系统的处理
* 超长字符串输入，系统是否会截取允许的长度来检验结果
* 合法的字符串长度后，加空格验证检索结果
* 多个关键字中间加入空格，逗号，tab验证系统的结果是否正确
* 验证每种合法的输入，结果是否正确
* 多次输入相同的内容，查看系统的检索结果是否一致
* 特殊字符、转义字符、html脚本等需要做处理
    
  -敏感词汇，提示用户无权限等
* 输入的内容是否支持快捷键操作等
* 只能输入允许的字符串长度等
* 输入链接是否正确跳转
* 是否可以输入数字，英文，中文
* 是否可以混合输入数字英文中文
* 输入拼音也可以进行检索

##### 2.3.1.2、 搜索内容

* 搜索内容为空，验证系统如何处理
* 搜索内容为空格，查看系统如何处理
* 是否支持检索内容的复制、粘贴、编辑等操作
* 是否支持回车键搜索
* 搜索的历史纪录是否显示在下面
* 搜索内容有没有联想功能
* 语音搜索的内容是否匹配
* 断网时，无法搜索
* 进行图片搜索时可以选择拍照或从相册中选取图片进行搜索
* 如果从相册中选取图片进行搜索，图上的大小是否有限制，最大为多少
* 搜索框边上有相机图片，便于图片搜索
* 点击清空历史记录，搜索框是否会清空历史记
* 能否识别图片中的内容
* 点击搜索，显示搜索界面

#### 2.3.2、界面测试

* 查看UI是否显示正确，布局是否合理
* 是否有错别字
* 搜索结果显示的布局是否美观
* 已查看的结果链接，链接的颜色要灰化处理，
* 结果数量庞大时，页面的分页布局是否合理
* 界面的颜色搭配是否合理

#### 2.3.3、安全性测试

* 脚本的禁用
* SQL的注入，检索SQL SELECT语句等
* 敏感内容的检索是禁止的
* 特殊字符的检索
* 被删除、加密、授权的数据，不允许被查出来
* 是否有安全设计控制

#### 2.3.4、兼容性测试

* 多平台Windows，mac
* 移动平台android，ios
* 多浏览器火狐、chrome、IE等

#### 2.3.5、性能测试

* 搜索页面的链接打开速度的时间
* 搜索出结果消耗时间
* 弱网时搜索的响应时间
* 不同网速下搜索时的响应时间2G/3G/4G/5G/WIFI

#### 2.3.6、易用性

* 有联想功能
* 搜索内容与搜索结果的匹配程度
* 支持拍照搜索，语音搜索

### 2.4、淘宝购物车下单测试

```
    从以下几点分析：功能测试、性能测试、易用性测试、界面测试、安全性测试、兼容性测试、其它测试

```

#### 2.4.1、功能测试

* 购物车
* 下单
* 支付

##### 2.4.1.1、购物车–>下单

* 商品全选
* 商品选择部分
* 根据商家选择商品
* 商品库存不足
* 改变商品数量[边界值分析][考虑商家限购]
* 改变商品规格[套餐]
* 商品管理：删除商品、编辑数量
* 计算价格是否准确
* 结算选择商品

##### 2.4.1.2、下单–>支付

* 收货地址的选择
* 收货地址的管理[增加、删除、编辑、选择]
* 展示商品信息是否正确
* 商品配送方式的选择
* 商品的配送时间选择
* 备注测试

  ```
    a、支持输入字符、表情、图片
    b、支持最大输入
    c、输入空格，前后空格、空

  ```
* 红包抵扣
* 优惠券抵扣
* 提交订单

##### 2.4.1.3、支付订单

* 选择支付方式

  ```
    a、支付宝
    b、花呗
    c、银行卡
    d、快捷支付

  ```
* 输入支付密码 0-4次

  ```
    a、1-3 次输入正确支付成功
    b、>3 次支付失败

  ```
* 指纹支付
* 待付款页支付

#### 2.4.2、性能测试

* 页面的打开速度的时间
* 支付结果消耗时间
* 弱网时的响应时间
* 不同网速下的响应时间2G/3G/4G/5G/WIFI

#### 2.4.3、界面测试

* UI显示是否正确
* 页面布局，页面样式检查
* 组件，控件位置放置是否合适，
* 是否支持快捷键
* 当结果数量庞大时，页面的分页布局合理

#### 2.4.4、安全性测试

* SQL注入攻击防范
* 脚本注入测试
* 被删除、加密、授权的数据，不允许被查出来的，是否有安全控制设计
* 支付安全
* 用户信息安全

#### 2.4.5、兼容性测试

* 不同操作系统平台：Windows系统，MacOS系统
* 不同浏览器：Firefox，Chrome，IE，及其各个版本
* 不同移动端：IOS，Android
* 不同分辨率

#### 2.4.6、易用性测试

* 对用户是否友好
* 是否有在线帮助文档

### 2.5、ATM取款取款问题

```
    场景法设计用例

```

* 插卡

> 卡无效（卡已被销户或非银行卡）----> 退卡

> 卡有效 ------> 输入密码

* 密码

> 输入密码错误次数 > 3 -----> 退卡

> 输入密码错误次数 < 3 -----> 取款

* 取款

> 取款金额 > 账户余额 ------> 提示用户 -------> 修改取款金额 ------> 出钞

> 取款金额 < 账户余额 ------> 出钞 ------> 打印凭条

> ATM 现金不足 ------> 提示用户 -------> 修改取款金额 ------> 出钞 ------> 打印凭条

> ATM 无现金 ------> 退卡

* 打印凭条

> 是 ------> 等待凭条 -------> 退卡

> 否 ------> 退卡

* 退卡

> 取卡

> 吞卡

### 2.6、微信聊天测试问题

#### 2.6.1、功能测试设计

##### 2.6.1.1、单聊

* 发送文字、图片、表情、小视频、语音 发送是否 OK？ 接受是否 OK？
* 发送文字、图片、表情、小视频、语音 长度最大值测试
* 是否支持文件发送？最大值？文件类型？
* 是否支持语音转化为文字？
* 是否支持撤回？超时撤回？不超时撤回？
* 是否支持重发？
* 语音、视频提示音测试？
* 语音、视屏 接通提试音、超时提示音、回铃音？
* 视频 切换语音测试
* 视频 前后摄像头切换测试
* 视频、语音最小化、最大化测试
* 发送、接送放聊天记录 顺序
* 非好友 是否可以发送消息
* 非好友是否提示加为好友
* 未读消息统计、提示
* 置顶功能 单个、多个

##### 2.6.1.2、群聊

* 发送文字、图片、表情、小视频、语音 群组成员是否均可收到
* @ 个人、多人、全部 是否有提醒 ？
* 邀请、踢出 群成员
* 发起群视频，所有人是否可以加入？
* 群视频切换语音
* 群人员最大值测试
* 群消息未读统计、提示
* 群消息免打扰
* 置顶功能 单个、多个

#### 2.6.2、异常测试

* 视频、语音通话中网络一方网络异常
* 视频、语音拨打多方处于离线状态、再次上线
* 视频、语音时 电话、短信进入
* 发送消息界面 视屏、语音、电话进入，挂断后是否回到发送消息界面
* 听筒、扬声器、耳机、蓝牙耳机 切换测试

### 2.7 测试电梯

* 功能：

  ```
    上升、下降、停止、开门、关门、梯内电话、灯光、指示灯等；

  ```
* 性能：

  ```
    速度、反应时间、关门时间等；

  ```
* 压力：

  ```
    超载、尖锐物碰撞电梯壁等；

  ```
* 安全：

  ```
    停电、报警装置、轿箱停靠位置、有人扒门时的情况等；

  ```
* 可用性：

  ```
    按键高度、操作是否方便、舒适程度等；

  ```
* UI：

  ```
    美观程度、光滑程度、形状、质感等；

  ```
* 稳定性：

  ```
    长时间运行情况等；

  ```
* 兼容性：

  ```
    不同电压是否可工作、不同类型电话是否可安装等。

  ```

### 2.8 web 和 app 测试区别

* 系统结构方面

  > web:b/s架构

  > app:c/s结构
* 性能方面

  > web 监测 响应时间、CPU、Memory

  > app 监测 测响应时间、CPU、Memory、流量、电量
* 兼容方面

```bash
web
　　1. 浏览器（火狐、谷歌、IE等）
　　2. 操作系统（Windows7、Windows10、Linux等）

```

```bash
app
　　1. 设备系统:iOS（ipad、iphone）、Android（三星、华为、联想等） 、Windows（Win7、Win8）、OSX（Mac）
　　2. 手机设备可根据 手机型号、分辨率不同

```

* APP有专项测试

```bash
　　1. 干扰测试：中断，来电，短信，关机，重启等
　　2. 弱网络测试（模拟2g、3g、4g，wifi网络状态以及丢包情况）；网络切换测试（网络断开后重连、3g切换到4g/wifi 等）
　　3. 安装、更新、卸载
　　安装：需考虑安装时的中断、弱网、安装后删除安装文件等情况
　　卸载：需考虑 卸载后是否删除app相关的文件
　　更新：分强制更新、非强制更新、增量包更新、断点续传、弱网状态下更新
　　4. 界面操作：关于手机端测试，需注意手势，横竖屏切换，多点触控，前后台切换
　　5. 安全测试：安装包是否可反编译代码、安装包是否签名、权限设置，例如访问通讯录等
　　6. 边界测试：可用存储空间少、没有SD卡/双SD卡、飞行模式、系统时间有误、第三方依赖（QQ、微信登录）等
　　7. 权限测试：设置某个App是否可以获取该权限，例如是否可访问通讯录、相册、照相机等

```

* 测试工具方面

> 自动化工具

```
    APP - Appium
    Web - Selenium

```

> 性能测试工具

```
    APP - JMeter;
    Web - LR、JMeter

```

### 2.9 测试工具

* 常用的接口测试工具是什么

  ```
    Postman、Jemter

  ```
* 如何抓取手机端的数据包

  ```
    使用 Fiddler 工具

  ```
* UI 自动化测试如何切换原生界面 webview 界面

  ```
    1.查看当前页面的具柄：
    contexts = driver.contexts
    print contexts
    如果当前界面有webview， 也就是混合界面，一般会展示native 和什么什么webview
    【注意：如果明明是混合页面，但获取具柄之后只有native，问问开发是不没开webview调试】
    2.要想操作webview上的元素，第一步需要切换环境（跟selenium的切换iframe,切换handle思路是一样）
    3.切换方法：switch_to.context(参数是webview的context)
    由于第二步已经获取到contexts是一个list对象，取这个list的第二个参数就行，也就是contexts[1]

  ```
* Appium 底层架构和底层所使用的自动化框架有哪些

  ```
    UIAutomator框架
    Selenium框架

  ```
* 设计一套APP自动化测试框架

> 框架需要解决的问题：

```bash
• 渠道包->多渠道包核心用例自动化

• 多设备覆盖安装，安装卸载更新等测试

• 多设备核心用例适配测试

• 验证主要页面（包括webview）检查是否加载成功

• 离线主流程覆盖

```

> 一些重复性操作可以通过框架简单实现

```bash
框架目标定位：

• 让Tester无需编写代码 通过简单数据驱动方式实现通用简单的自动化

• 跟开发约定一些UI上的元素标准和规范建立自动化规范流程化

• 结合实时抓包组件和性能监控插件方便分节点定位问题

• 自动异常捕获，CrashLog收集汇总等等

• 每一步都有Log、截图（甚至做到录制）方便复现问题

• 实行单台服务器多设备并行 根据配置不同机型执行不同case 并统一会汇总报告

```

## 三、计算机网络

### 3.1、ISO/OSI七层网络模型

| 名称 | 协议 |
| --- | --- |
| 应用层 | http ftp tftp smtp |
| 表示层 | telnet |
| 会话层 | dns smtp |
| 传输层 | tcp udp |
| 网络层 | ip arp icmp |
| 数据链路层 | ppp 以太网 |
| 物理层 | 3E |

### 3.2、TCP三次握手

* 第一次握手

  ```
    建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）

  ```
* 第二次握手

  ```
    服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态

  ```
* 第三次握手

  ```
    客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手

  ```

### 3.3、TCP&UDP 区别 应用

* 相同

  ```
    工作于：网络传输层

  ```
* 区别

> 安全

```
    tcp  安全 3次握手，资源较多
    udp 不可靠 ，资源较少 

```

> 信道

```
    tcp  逻辑信道全双工可靠信道
    udp  逻辑信道不可靠信道

```

* 应用

  ```
    tcp  点到点通信 【FTP HTTP】
    udp 一对一  一对多  多对一 【广播 通信】

  ```

### 3.4、输入URL到页面加载都发生了什么

* DNS解析

  ```
     按以下路径解析DNS：浏览器缓存，系统缓存（host），路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓

  ```
* TCP连接（3次握手）

  ```
    ①源端->远端：你好，我想跟你连接可以吗？（SYN=1,seq=x）

    ②远端->源端：可以，你确定要连接是吧？（SYN=1,ACK=1,seq=y,ack=x+1）

    ③源端->远端：确定，我们连接吧！（ACK=1,seq=x+1,ack=y+1）

  ```
* 发送HTTP请求

  ```
     发送 HTTP Request ：请求方式 （GET、POST、PUT、DELETE）、请求 路径 （URL）、请求头（Header）、请求体（Body）

  ```
* 服务器处理请求并返回HTTP报文

  ```
     服务器返回 HTTP Response : 响应状态码 （2XX、4XX、5XX）、响应头 （Response Header）、响应体 (Response Body)

    1xx：指示信息–表示请求已接收，继续处理
    2xx：成功–表示请求已被成功接收、理解、接受
    3xx：重定向–要完成请求必须进行更进一步的操作
    4xx：客户端错误–请求有语法错误或请求无法实现
    5xx：服务器端错误–服务器未能实现合法的请求

  ```
* 浏览器解析渲染页面

  ```
    页面HTML、CSS、JS代码渲染

  ```
* 连接结束（四次握手）

  ```
    第一次挥手：双方交流的差不多了，此时客户端也已经结尾了，接下来要断开通信连接，所以告诉服务端“我说完了（FIN）”，此时自身形成等待结束连接的状态。 

    第二次挥手：服务端知道客户端已经没话说了，服务端此时还有两句话要给客户端说“我知道你说完了（ACK），我再说两句&*…%￥”…

    第三次挥手：此时客户端洗耳恭听继续处于等待结束的状态，服务器端也说完了，自身此时处于等待关闭连接的状态，并对告诉客户端，“我说完了，咱们断了吧（FIN）”。 
    
    第四次挥手：客户端收知道服务端也说完了，也要告诉服务端一声（ACK）

  ```

## 四、LIUNX 相关

### 4.1、查找文件

```bash
find / -name XXXX

```

### 4.2、判断进程

```bash
ps -ef|grep xxx 
lsof -i:port   #查看端口
netstat -anp|grep port   #查看端口

```

### 4.3、Linux 常用命令

```bash
mkdir touch rm mv cp rename ls cat vim tail yum date less more 

```

### 4.4、如何获取进程的CPU和mem 使用率

```bash
ps -aux | grep process

```

### 4.5、如何查看文件中 good 所在行 和下两行

```bash
grep -A 100 -B 100  '要查找的字符'  被查的文件file
-A after 后面
-B before 前面

grep -A 2 'good' XXXX

```

### 4.6、查找某文件夹下所有文件中某个字符的个数

```bash
grep 'xxx' * | wc -l

```

### 4.7、你使用过的数据存储有哪些？

```bash
mysql  psql  redis  es hbase

```

### 4.8、redis 存储的数据结构有那些？

```bash
字符  哈希  列表  集合  有序集合   (键值对)

```

### 4.9、ES 中的 mapping

```bash
类似 数据库中的表字段  数据类型
ES 索引 相当于 数据库中的表名

```

### 4.10、判断手机安装特定APP

```bash
adb shell pm list packages | grep XXX

```

### 4.11、ADB命令

```bash
adb devices  #查询pc链接的所有android 设备
adb shell  # 命令行
adb shell pm list packages  #列出手机装的所有 app 的包名
adb shell pm list packages -f #列出手机装的所有 app 的包安装位置
adb push local remote
adb pull remote local
adb shell getprop ro.product.model #查看设备型号
adb shell getprop ro.build.version.release  #查看 Android 系统版本
adb shell wm size  #查看屏幕分辨率

```

### 4.12、Nginx 日志获取某个接口平均响应时间

```bash
grep "keyword" access.log | awk '{print  $NF}' | grep -P '\d{3}?$' | awk '{sum += $0;}END {if(sum==0)print 0;else print sum/NR}'

```

## 五、SQL 类

### 5.1、事物

* 原子性(Atomicity)：事务中的所有元素作为一个整体提交或回滚，是不可折分的，事务是一个完整的操作。
* 一致性(Consistemcy)：事物完成时，数据必须是一致的，也就是说，和事物开始之前，数据存储中的数据处于一致状态。保证数据的无损。
* 隔离性(Isolation)：对数据进行修改的多个事务是彼此隔离的。这表明事务必须是独立的，不应该以任何方式来影响其他事务。
* 持久性(Durability)：事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留，真实的修改了数据库。

### 5.2、SQL基础

* sql 语句中的select 语句中，用于对结果元组进行排序的是（ ORDER BY ）子句

> ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。
>   
> ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。

```sql
语法：
SELECT[ALL|DISTINCT]＜目标列表达式＞…
FROM＜基本表＞…
[WHILE＜条件表达式＞]
[CROUP BY＜列名1＞]
[ORDER BY＜列名2＞[ASC|DESCT]
其中的ORDER BY用于对结果元组进行排序。

```

* 在select 语句中，需要对分组 情况应满足的条件判断时，应使用 （ HAVING ）子句

> HAVING语句通常与GROUP BY语句联合使用，用来过滤由GROUP BY语句返回的记录集。HAVING语句的存在弥补了WHERE关键字不能与聚合函数联合使用的不足。

```sql
语法：
SELECT column1, column2, ... column_n, aggregate_function (expression)
FROM tables
WHERE predicates
GROUP BY column1, column2, ... column_n
HAVING condition1 ... condition_n;

```

– 数据库操作描述的是系统的动态特性，主要分为查询、（插入）、（删除）、（修改）四种操作。

> 增删改查

```sql
语法：
插入：INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...)
删除：DELETE FROM table_name
WHERE some_column=some_value;
修改：UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value
查询：SELECT column_name,column_name
FROM table_name

```

### 5.3、SQL选择题

* 数据库中存储的是（C）

A、数据 B、数据模型 C、数据以及数据直接的关联 D、信息

* 数据库系统的核心是 （C）

A．数据库管理员 B．用户 C．数据库管理系统 D．硬件系统

> 数据库系统是指引进数据库后的计算机系统，数据库系统能实现有组织地、动态地存储大量相关数据，提供数据处理和信息资源共享。数据库系统由5部分组成，分别是硬件系统、数据库、数据库管理系统及相关软件、数据库管理员和用户，其核心是数据库管理系统.

* 数据库管理系统（DBMS）的主要功能（B）

A．修改数据库 B．定义数据库 C．应用数据库 D．保护数据库

> （1）数据定义功能。DBMS提供相应数据语言来定义（DDL）数据库结构，它们是刻画数据库框架，并被保存在数据字典中。

> （2）数据存取功能。DBMS提供数据操纵语言（DML），实现对数据库数据的基本存取操作：检索，插入，修改和删除。

> （3）数据库运行管理功能。DBMS提供数据控制功能，即是数据的安全性、完整性和并发控制等对数据库运行进行有效地控制和管理，以确保数据正确有效。

> （4）数据库的建立和维护功能。包括数据库初始数据的装入，数据库的转储、恢复、重组织，系统性能监视、分析等功能。

> （5）数据库的传输。DBMS提供处理数据的传输，实现用户程序与DBMS之间的通信，通常与操作系统协调完成。

* 数据库系统数据的数据独立性指 （D ）

A. 不会因为数据的变化而影响应用程序

B. 不会因为存储策略的变化而影响存储结构

C. 不会因为某些存储结构的变化而影响其他的存储结构

D. 不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序

### 5.4、如何加快查询速度

```bash
a 优化查询语句，避免全查扫描  (where 及 order by)
b 建立数据索引  
c 数据库集群

```

## 六、编程题

### 6.1、不引入第三方变量 交换 x、y 取值

```bash
def test(x,y):
    x,y = y,x
    print (x,y)
    return x,y

if __name__ == '__main__':
    test(5,7)

```

### 6.2、二分法查找

```bash
def find_search(list, key):
    left = 0     # 左边界
    right = len(list) - 1   # 右边界
    while left <= right:
        mid = (left + right) // 2  # 取得中间索引
        print (mid)
        if key > list[mid]:
            left = mid + 1
        elif key < list[mid]:
            right = mid - 1
        else:
            return mid
    else:
        return -1
if __name__ == '__main__':
    list = [0,5,1]
    find_search(list, 5)

```

### 6.3、冒泡排序

```bash
def test2(list):
    num = len(list) - 1
    while num < 0 :
        for i in num :
            if list[i] > list[i+1]:
                list[i],list[i+1] = list[i+1],list[i]
    num = -1
    print (list)
if __name__ == '__main__':
    list = [1,3,6,8,10,4,16,20,60]   
    test2(list)

```

### 6.4、判断字符串是否回文

```bash
def test3(str):
    if str == str[::-1]:
        print ("OK")
        return 1
    else:
        return -1
if __name__ == '__main__':
    test3("123321")    

```

### 6.5、数据结构

* 数据结构

  ```
      相互之间存在一种或多种特定关系的数据元素的集合。简单理解：数据结构就是描述对象间逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构！

  ```
* 数组

  ```
      数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的

  ```
* 链表

  ```
     链表是在非连续的内存单元中保存数据，并且通过指针将各个内存单元链接在一起，最有一个节点的指针指向 NULL 。链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。在链表中查找第 n 个数据以及查找指定的数据的时间复杂度是 O(N) ，但是插入和删除数据的时间复杂度是 O(1) ，因为只需要调整指针就可以

  ```
* 堆栈

  ```
    堆栈实现了一种后进先出的语义 (LIFO) 。可以使用数组或者是链表来实现它： 对于堆栈中的数据的所有操作都是在栈的顶部完成的，只可以查看栈顶部的数据，只能够向栈的顶部压入数据，也只能从栈的顶部弹出数据。

  ```
* 队列

  ```
    队列实现了先入先出的语义 (FIFO) 。队列也可以使用数组和链表来实现：队列只允许在队尾添加数据，在队头删除数据。但是可以查看队头和队尾的数据。还有一种是双端队列，在两端都可以插入和删除。

  ```
* 二叉树

  ```
    每个节点至多只有两个子树的结构，在父节点中有指向左右子树的指针
    先序遍历：根–左–右
    中序遍历：左–根–右
    后序遍历：左–右–根
      查找二叉树：左子树的值小于根节点的值，右子树的值大于根节点的值，在插入数据时，从根节点开始往下比较，小于比较值则放在左边，大于比较值放在右边。插入一个值的时间复杂度是O(logn)
    平衡二叉树：左右子树的高度差的绝对值不超过1

  ```

#### 6.6、Python 数据结构（4）

* list

  ```
    列表中的每个元素都可变的，意味着可以对每个元素进行修改和删除；
    列表是有序的，每个元素的位置是确定的，可以用索引去访问每个元素；
    列表中的元素可以是Python中的任何对象；
    可以为任意对象就意味着元素可以是字符串、整数、元组、也可以是list等Python中的对象。

  ```
* tuple

  ```
    Tuple一经初始化，就不能修改，没有List中的append(), insert(), pop()等修改的方法，只能对元素进行查询

  ```
* dict

  ```
    字典中的数据必须以键值对的形式出现，即k,v： 
    key:必须是可哈希的值，比如intmstring,float,tuple,但是，list,set,dict不行 
    value:任何值
    键不可重复，值可重复
    键若重复字典中只会记该键对应的最后一个值

    字典中键(key)是不可变的，何为不可变对象，不能进行修改；而值(value)是可以修改的，可以是任何对象。
    在dict中是根据key来计算value的存储位置，如果每次计算相同的  key得出的结果不同，那dict内部就完全混乱了。

  ```
* set

  ```
    集合更接近数学上集合的概念。集合中每个元素都是无序的、不重复的任意对象。可以通过集合去判断数据的从属关系，也可以通过集合把数据结构中重复的元素减掉。集合可做集合运算，可添加和删除元素。
    集合内数据无序，即无法使用索引和分片
    集合内部数据元素具有唯一性，可以用来排除重复数据
    集合内的数据:str,int,float,tuple集合等，即内部只能放置可哈希数据

  ```

#### 6.7、 Python 数据数据类型（6）

* Number数据类型

  ```
    int整型　　float浮点型　　bool布尔型　　complex复数类型

  ```
* 容器数据类型

  ```
    str  字符串型　　list  列表型　　tuple  元组型　　set集合型dict字典型

  ```

#### 6.8、 死锁

* 定义

  ```
    多个进程在执行过程中，因争夺同类资源且资源分配不当而造成的一种互相等待的现象，若无外力作用，它们都将永远无法继续执行，这种状态称为死锁，这些处于等待状态的进程称为死锁进程

  ```
* 产生条件

  ```
    互斥条件：进程对所分配到的资源进行排他性使用，即一段时间内，某资源只能被一个进程占用。如果此时还有其他进程请求该资源，则进程只能等待，直至占有资源的进程用毕释放。
    请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此请求进程被阻塞，但对自己已获得的资源保持不放。
    不可抢占条件：进程已获得的资源在未使用完成之前不能被抢占，只能在进程使用完成时由自己释放。
    循环等待条件：在发生死锁时，必存在一个进程——资源的循环链，即进程的集合{P0，P1，P2，…Pn}中的P0正在等待P1占用的资源，P1正在等待P2占用的资源，……Pn正在等待P0占用的资源。

  ```
* 处理死锁的方法

  ```
    预防死锁：这是一种较简单和直观的实现预防方法。该方法通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个来预防产生死锁。预防死锁是一种较易实现的方法，已被广泛使用。

    避免死锁：同样是属于事先预防策略，但它并不是事先采取各种限制措施，去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法防治系统进入不安全状态，从而可以避免发生死锁。

    检测死锁：这种方法无需事先采取任何限制性措施，允许进程在运行过程中发生死锁。但可以通过检测机构及时检测出死锁的发生，然后采取相应的措施，把进程从死锁中解脱出来。

    解除死锁：当系统检测到系统中已经发生了死锁时，就采取相应的措施，将进程从死锁状态中解脱出来。常用的方法就是撤消一些进程，回收他们的资源，将他们分配给已处于阻塞状态的进程，使其能继续运行。

  ```