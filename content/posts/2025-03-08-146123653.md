---
layout: post
title: "Java后端高频面经SpringSpringBootMyBatis"
date: 2025-03-08 21:57:11 +0800
description: "是一个基于 Spring 的项目，它封装了 Spring 和其他相关技术（如 Spring MVC、Spring Data、Spring Security 等），提供自动配置、快速项目启动器、内嵌服务器三大功能，使开发者能够快速启动和构建 Spring 应用。Mybatis 在处理 ${} 时，只是创建普通的 SQL语句，然后在执行 SQL语句时 MvBatis 将参数直接拼入到 SQL里，不能防止 SQL注入，因为参数直接拼接到 SQL语句中，如果参数未经过验证、过滤，可能会导致安全问题。"
keywords: "Java后端高频面经——Spring、SpringBoot、MyBatis"
categories: ['高频面经']
tags: ['面试', '开发语言', 'Spring', 'Spring', 'Mybatis', 'Java', 'Boot']
artid: "146123653"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123653
    alt: "Java后端高频面经SpringSpringBootMyBatis"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123653
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123653
cover: https://bing.ee123.net/img/rand?artid=146123653
image: https://bing.ee123.net/img/rand?artid=146123653
img: https://bing.ee123.net/img/rand?artid=146123653
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java后端高频面经——Spring、SpringBoot、MyBatis
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <ol>
     <li>
      <p>
       Spring定义一个Bean有哪些方法？依赖注入有哪些方法？
      </p>
      <p>
       （1）定义Bean的方法
      </p>
      <ul>
       <li>
        <p>
         注解定义Bean，@Component
        </p>
        <p>
         用于标记一个类作为Spring的bean。当一个类被@Component注解标记时，Spring会将其实例化为一个bean，并将其添加到Spring容器中。
        </p>
       </li>
       <li>
        <p>
         配置文件定义Bean
        </p>
       </li>
      </ul>
      <p>
       （2）依赖注入的方法
      </p>
      <ul>
       <li>
        <strong>
         字段（Field）
        </strong>
        ：最直接地在类的字段上使用。
       </li>
      </ul>
      <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">MyDependency</span> myDependency<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <ul>
       <li>
        <strong>
         构造器（Constructor）
        </strong>
        ：在构造器上使用，用于构造器注入。
       </li>
      </ul>
      <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">MyDependency</span> myDependency<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token class-name">MyDependency</span> myDependency<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>myDependency <span class="token operator">=</span> myDependency<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      <ul>
       <li>
        <strong>
         方法（Method）
        </strong>
        ：也可以在一个方法上使用，通常是一个 setter 方法。
       </li>
      </ul>
      <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">MyDependency</span> myDependency<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMyDependency</span><span class="token punctuation">(</span><span class="token class-name">MyDependency</span> myDependency<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>myDependency <span class="token operator">=</span> myDependency<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       介绍IOC、AOP、反射
      </p>
      <p>
       （1）IOC
      </p>
      <p>
       ​ Spring IOC容器通过
      </p>
      <p>
       ​ ①封装对象的创建（将对象的创建过程交给Spring管理，从而实现了控制反转）和生命周期管理（管理对象的初始化和销毁过程），
      </p>
      <p>
       ​ ②使用依赖注入来解耦对象之间的依赖关系（通过 Spring 容器将类 A 所依赖的 B 的实例注入到 A 中，这样 A 和 B 不再直接依赖，而是通过容器来提供），
      </p>
      <p>
       ​ ③利用反射和配置元数据动态地创建和管理对象（当 Spring 容器启动时，它会根据配置文件或注解（元数据）扫描类的信息，通过反射技术实例化对象，而不需要编写具体的
       <code>
        new
       </code>
       代码。反射让 Spring 能够动态地操作类的构造函数、方法等），
      </p>
      <p>
       ​ ④同时提供作用域管理功能（对象的生命周期和可见性范围。Spring 提供了多种作用域，容器会根据作用域来管理对象的实例化、销毁等过程。Singleton（单例）、Prototype（原型）、Request、Session、Application 等作用域）。
      </p>
      <p>
       （2）AOP
      </p>
      <p>
       ​ 面向切面编程，AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑（例如事务处理、日志管理、权限控制等）封装起来，以减少系统的重复代码，降低模块间的耦合度。
      </p>
      <p>
       ​ 两个例子：权限校验拦截器、动态切换数据源。
      </p>
      <p>
       ​ Spring AOP的实现依赖于
       <strong>
        动态代理技术
       </strong>
       。动态代理是在运行时动态生成代理对象，而不是在编译时。
      </p>
      <table>
       <thead>
        <tr>
         <th>
          注解
         </th>
         <th>
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          @Aspect
         </td>
         <td>
          用于定义切面，标注在切面类上。
         </td>
        </tr>
        <tr>
         <td>
          @Pointcut
         </td>
         <td>
          定义切点，标注在方法上，用于指定连接点。
         </td>
        </tr>
        <tr>
         <td>
          @Before
         </td>
         <td>
          在方法执行之前执行通知。
         </td>
        </tr>
        <tr>
         <td>
          @After
         </td>
         <td>
          在方法执行之后执行通知。
         </td>
        </tr>
        <tr>
         <td>
          @Around
         </td>
         <td>
          在方法执行前后都执行通知。
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       （3）反射
      </p>
      <p>
       ​ 允许在运行时动态地查询和操作类、方法、字段等信息，并且能够通过反射来调用类中的方法或修改类的属性。反射机制的核心原理是：
       <strong>
        通过
        <code>
         Class
        </code>
        类来获取类的结构信息
       </strong>
       ，并且使用这些信息在运行时动态地操作类的对象。IOC、DI、动态代理就是用到了反射。
      </p>
      <p>
       ①获取class对象：可以通过类的
       <code>
        Class
       </code>
       对象来访问类的信息。
      </p>
      <pre><code class="prism language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//括号里的内容可以是程序运行时才输入的内容</span>
</code></pre>
      <p>
       ②查询类的结构信息：通过
       <code>
        Class
       </code>
       对象，可以获取类的构造方法、方法、字段、接口、父类等信息。
      </p>
      <pre><code class="prism language-java"><span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取所有公共方法</span>
<span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取所有公共字段</span>
<span class="token class-name">Constructor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> constructors <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取所有公共构造函数</span>
</code></pre>
      <p>
       ③动态创建对象
      </p>
      <pre><code class="prism language-java"><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取无参构造</span>
<span class="token class-name">Object</span> instance <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用构造函数创建对象实例</span>
</code></pre>
      <p>
       ④调用方法
      </p>
      <pre><code class="prism language-java"><span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"myMethod"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果是私有方法，需要设置访问权限</span>
method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"parameter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用方法</span>
</code></pre>
     </li>
     <li>
      <p>
       介绍动态代理、静态代理？
      </p>
      <p>
       ​ 代理模式是设计模式中的一种，它通过提供代理对象来控制对原对象的访问。代理对象充当中介，通常在请求实际操作之前或之后做一些额外的工作（例如检查权限、缓存结果、延迟加载等）。
      </p>
      <p>
       ​
       <strong>
        控制访问
       </strong>
       ：代理可以控制对实际对象的访问，增加额外的功能（如安全性、权限管理、日志记录等）。
      </p>
      <p>
       ​
       <strong>
        延迟加载
       </strong>
       ：通过代理，可以延迟初始化或执行耗时的操作，直到真正需要时才执行。
      </p>
      <p>
       ​
       <strong>
        性能优化
       </strong>
       ：代理对象可以缓存结果，减少重复计算或请求，提高性能。
      </p>
      <p>
       ​
       <strong>
        增强功能
       </strong>
       ：代理对象可以在不修改原对象代码的情况下，为其增加新的功能，如事务管理、日志记录等。
      </p>
      <p>
       （1）动态代理
      </p>
      <p>
       <strong>
        动态代理
       </strong>
       是在运行时创建代理对象，代理对象在运行时被动态地生成，因此不需要在编译时就确定代理类。Java 提供了两种方式来实现动态代理：
      </p>
      <ol>
       <li>
        JDK 动态代理
        <ul>
         <li>
          通过
          <code>
           java.lang.reflect.Proxy
          </code>
          类和
          <code>
           InvocationHandler
          </code>
          接口动态生成代理类。JDK 动态代理
          <strong>
           要求目标类实现一个接口
          </strong>
          。
         </li>
        </ul>
       </li>
       <li>
        CGLIB（Code Generation Library）代理
        <ul>
         <li>
          通过字节码生成技术，动态创建目标类的子类来实现代理。CGLIB
          <strong>
           代理不要求目标类实现接口
          </strong>
          ，而是通过继承目标类来实现代理。
         </li>
        </ul>
       </li>
      </ol>
      <p>
       （2）静态代理
      </p>
      <p>
       ​ 代理类是在编译时就已经写好并且确定的。是由开发者手动编写的，并且在程序运行之前就已经存在。例如，你在编写代码时就知道你需要一个
       <code>
        Proxy
       </code>
       类，它会代理
       <code>
        RealSubject
       </code>
       类的方法。在静态代理中，代理类和目标类的关系是固定的，编译时就已经确定。
      </p>
      <p>
       ​ 代理模式是JAVA的一种设计模式，而AOP是Spring框架中的一个特性，是使用了动态代理来实现的。
      </p>
     </li>
     <li>
      <p>
       Spring的循环依赖的原因以及解决方法；（众安）
      </p>
      <p>
       循环依赖指的是两个类中的属性相互依赖对方：例如 A 类中有 B 属性，B 类中有 A属性，从而形成了一个依赖闭环。
      </p>
      <p>
       Spring中的循环依赖问题有三种情况：
      </p>
      <ul>
       <li>
        第一种：通过构造方法进行依赖注入时产生的循环依赖问题。
       </li>
       <li>
        第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。
       </li>
       <li>
        第三种：通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。
       </li>
      </ul>
      <blockquote>
       <p>
        <strong>
         单例模式
        </strong>
        适用于
        <strong>
         全局唯一的资源管理
        </strong>
        ，如配置管理、日志记录、数据库连接池等。它的特点是保证类在全局范围内只有一个实例，所有地方都使用同一个对象。
       </p>
       <p>
        <strong>
         多例模式
        </strong>
        适用于
        <strong>
         需要多个独立实例
        </strong>
        的场景，如用户会话、任务调度、订单管理等。每个实例有自己的状态和行为，不共享数据。
       </p>
      </blockquote>
      <p>
       只有【第三种方式】的循环依赖问题被 Spring 解决了，其他两种方式在遇到循环依赖问题时，Spring都会产生异常。
      </p>
      <p>
       （1）Spring实例化Bean：Spring尝试创建A的实例，发现A依赖B，因此需要实例化B。Spring在创建B时，发现B依赖A，但此时A还没有完成初始化，所以Spring会创建A的空对象并将其放入
       <code>
        singletonObjects
       </code>
       一级缓存中并开始创建B。
      </p>
      <p>
       （3）循环依赖暴露
      </p>
      <ul>
       <li>
        当Spring尝试创建B时，由于A还没有完全初始化，Spring会把A实例（未完全初始化）提前暴露到
        <code>
         earlySingletonObjects
        </code>
        二级缓存中，这时A成为一个半初始化的Bean。
       </li>
       <li>
        B可以通过
        <code>
         earlySingletonObjects
        </code>
        二级缓存获得这个提前暴露的A对象，从而完成B的依赖注入。
       </li>
      </ul>
      <p>
       （3）初始化Bean
      </p>
      <ul>
       <li>
        <p>
         依赖注入完成后，Spring继续初始化B（如调用
         <code>
          @PostConstruct
         </code>
         等），然后将B放入三级
         <code>
          singletonFactories
         </code>
         缓存中，表示B已经完全初始化。
        </p>
       </li>
       <li>
        <p>
         Spring继续完成A的初始化工作，注入B，完成生命周期的其他部分，并将A放入三级
         <code>
          singletonFactories
         </code>
         缓存中，表示A也已经完全初始化。
        </p>
       </li>
      </ul>
      <p>
       （4）总结
      </p>
      <ul>
       <li>
        在依赖注入过程中，Spring通过
        <code>
         earlySingletonObjects
        </code>
        二级缓存提供了B对A的依赖，通过
        <code>
         singletonFactories
        </code>
        三级缓存提供了A对B的依赖，从而打破了循环依赖。
       </li>
      </ul>
     </li>
     <li>
      <p>
       列举几个Spring常用的注解？（美团）
      </p>
      <table>
       <thead>
        <tr>
         <th>
          注解
         </th>
         <th>
          作用
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          @Autowired
         </td>
         <td>
          自动装配bean，当Spring容器中存在与要注入的属性类型匹配的bean时，它会自动将bean注入到属性中
         </td>
        </tr>
        <tr>
         <td>
          @Component
         </td>
         <td>
          Spring会将一个类实例化为一个bean，并将其添加到Spring容器中。
         </td>
        </tr>
        <tr>
         <td>
          @Configuration
         </td>
         <td>
          用于标记一个类作为Spring的配置类，配置类可以包含@Bean注解的方法，用于定义和配置bean，作为全局配置。
         </td>
        </tr>
        <tr>
         <td>
          @Bean
         </td>
         <td>
          用于标记一个方法作为Spring的bean工厂方法，当一个方法被@Bean注解标记时，Spring会将该方法的返回值作为一个bean,并将其添加到Spring容器中
         </td>
        </tr>
        <tr>
         <td>
          @Service
         </td>
         <td>
          用于标记服务层的bean，是@Component注解的特例，一般标记在业务service的实现类。
         </td>
        </tr>
        <tr>
         <td>
          @Repository
         </td>
         <td>
          用于标记数据访问层的bean,它也是@Component注解的特例。
         </td>
        </tr>
        <tr>
         <td>
          @Controller
         </td>
         <td>
          用于标记控制层的bean，它也是@Component注解的特例。
         </td>
        </tr>
       </tbody>
      </table>
     </li>
     <li>
      <p>
       spring、springboot、SpringMVC的区别及关系？（康泰）
      </p>
      <p>
       <strong>
        Spring
       </strong>
       是一个全面的应用开发框架，提供了全面的基础设施和功能支持。
      </p>
      <p>
       <strong>
        Spring MVC
       </strong>
       是 Spring 框架中的一个模块，专门用于 Web 开发，采用 MVC 模式来处理 Web 请求和响应。它依赖于 Spring 框架的核心功能，如 IoC 和 AOP。
      </p>
      <p>
       <strong>
        Spring Boot
       </strong>
       是一个基于 Spring 的项目，它封装了 Spring 和其他相关技术（如 Spring MVC、Spring Data、Spring Security 等），提供自动配置、快速项目启动器、内嵌服务器三大功能，使开发者能够快速启动和构建 Spring 应用。
      </p>
      <ul>
       <li>
        自动配置
       </li>
       <li>
        快速项目启动器，通过引入不同的 Starter，可以快速集成常用的框架和库（如数据库、消息队列、Web 开发等），极大地提高了开发效率。
       </li>
       <li>
        内嵌服务器（Tomcat、Jetty、Undertow），无需额外配置，即可将应用打包成可执行的 JAR 文件，方便部署和运行。
       </li>
      </ul>
      <p>
       Spring+Spring MVC = Spring Boot
      </p>
     </li>
     <li>
      <p>
       springboot的自动配置原理？（美团、得物）springBoot启动机制，启动之后做了哪些步骤？（B站）
      </p>
     </li>
     <li>
      <p>
       SpringBoot重要注解
      </p>
      <table>
       <thead>
        <tr>
         <th>
         </th>
         <th>
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          @SpringBootApplication
         </td>
         <td>
          用于标注主应用程序类，标识一个Spring Boot应用程序的入口点，同时启用自动配置和组件扫描。
         </td>
        </tr>
        <tr>
         <td>
          @Controller
         </td>
         <td>
          标识控制器类，处理HTTP请求。
         </td>
        </tr>
        <tr>
         <td>
          @RestController
         </td>
         <td>
          结合@Controller和@ResponseBody，返回RESTful风格的数据。
         </td>
        </tr>
        <tr>
         <td>
          @Service
         </td>
         <td>
          标识服务类，通常用于标记业务逻辑层。
         </td>
        </tr>
        <tr>
         <td>
          @Repository
         </td>
         <td>
          标识数据访问组件，通常用于标记数据访问层。
         </td>
        </tr>
        <tr>
         <td>
          @Component
         </td>
         <td>
          通用的Spring组件注解，表示一个受Spring管理的组件。
         </td>
        </tr>
        <tr>
         <td>
          @Autowired
         </td>
         <td>
          用于自动装配Spring Bean。
         </td>
        </tr>
        <tr>
         <td>
          @Value
         </td>
         <td>
          用于注入配置属性值。
         </td>
        </tr>
        <tr>
         <td>
          @RequestMapping
         </td>
         <td>
          用于映射HTTP请求路径到Controller的处理方法。
         </td>
        </tr>
        <tr>
         <td>
          @GetMapping、@PostMapping、@PutMapping、@DeleteMapping
         </td>
         <td>
          简化@RequestMapping的GET、POST、PUT和DELETE请求。
         </td>
        </tr>
        <tr>
         <td>
          @Configuration
         </td>
         <td>
          用于指定一个类为配置类，其中定义的bean会被Spring容器管理。
         </td>
        </tr>
       </tbody>
      </table>
     </li>
     <li>
      <p>
       怎么用原生的MyBatis去查询？
      </p>
      <p>
       （1）配置MyBatis： 在配置文件中配置数据源、MyBatis的Mapper文件位置等信息。
      </p>
      <p>
       （2）创建实体类：创建与数据库表对应的实体类，字段名和类型需与数据库表保持一致。
      </p>
      <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">,</span>
	<span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">,</span>
	<span class="token comment">// Getters and setters</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       （3）编写SQL映射文件：在resources目录下创建XML文件，定义SQL语句和映射关系。
      </p>
      <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserById<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.model.User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	SELECT * FROM users WHERE id = #{id}
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span>
</code></pre>
      <p>
       （4）编写DAO接口：创建DAO接口，定义查询方法。
      </p>
      <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">User</span> <span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       （5）编写具体的SQL查询语句：在XML文件中编写对应的SQL语句。
      </p>
      <p>
       （6）调用查询方法：在服务层或控制层中调用DAO接口中的方法进行查询。
      </p>
      <pre><code class="prism language-java"><span class="token comment">// 在Service层中调用</span>
<span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <p>
       MyBatis里的 # 和 $ 的区别?
      </p>
     </li>
    </ol>
    <ul>
     <li>
      <p>
       Mybatis 在处理 #{}时，会创建预编译的 SQL 语句，将 SQL 中的 #{} 替换为?号，在执行 SQL 时会为预编译 SQL 中的占位符(?)赋值，调用 PreparedStatement 的 set 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止SQL注入，提供更高的安全性，适合传递参数值。
      </p>
     </li>
     <li>
      <p>
       Mybatis 在处理 ${} 时，只是创建普通的 SQL语句，然后在执行 SQL语句时 MvBatis 将参数直接拼入到 SQL里，不能防止 SQL注入，因为参数直接拼接到 SQL语句中，如果参数未经过验证、过滤，可能会导致安全问题。
      </p>
      <p>
       比如：
      </p>
      <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserByUsername<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    SELECT * FROM users WHERE username = '${username}'
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre>
      <p>
       在这个查询中，
       <code>
        ${username}
       </code>
       会直接被传入的
       <code>
        username
       </code>
       值替换，假如传入的
       <code>
        username
       </code>
       是恶意的，例如
       <code>
        "' OR 1=1"
       </code>
       ，查询语句就变成了：
      </p>
      <pre><code class="prism language-mysql">SELECT * FROM users WHERE username = '' OR 1=1
</code></pre>
      <p>
       这就是典型的
       <strong>
        SQL 注入
       </strong>
       ，因为
       <code>
        $
       </code>
       直接拼接了参数值，导致不安全的 SQL 被执行。
      </p>
      <p>
       大多数情况下都应该使用
       <code>
        #
       </code>
       ，特别是涉及到用户输入的值时。它可以安全地处理用户输入，避免 SQL 注入。只有在确实需要拼接动态 SQL 的结构部分（如表名、列名）时，才应该使用
       <code>
        $
       </code>
       。
      </p>
     </li>
    </ul>
    <ol start="11">
     <li>
      <p>
       MybatisPlus和Mybatis的区别？（百度）
      </p>
      <p>
       MybatisPlus是一个基于MyBatis的增强工具库。
      </p>
      <ul>
       <li>
        CRUD操作:MybatisPlus通过继承BaseMapper接口，提供了一系列内置的快捷方法，使得CRUD操作更加简单，无需编写重复的SQL语句。
       </li>
       <li>
        代码生成器:MvbatisPlus提供了代码生成器功能，可以根据数据库表结构自动生成实体类、Mapper接口以及XML映射文件，减少了手动编写的工作量。
       </li>
       <li>
        通用方法封装:MybatisPlus封装了许多常用的方法，如条件构造器、排序、分页查询等，简化了开发过程，提高了开发效率。
       </li>
       <li>
        分页插件:MybatisPlus内置了分页插件，支持各种数据库的分页查询，开发者可以轻松实现分页功能，而在传统的MyBatis中，需要开发者自己手动实现分页逻辑。
       </li>
       <li>
        多租户支持:MvbatisPlus提供了多租户的支持，可以轻松实现多租户数据隔离的功能。
       </li>
       <li>
        注解支持:MvbatisPlus引入了更多的注解支持，使得开发者可以通过注解来配置实体与数据库表之间的映射关系，减少了XML配置文件的编写。
       </li>
      </ul>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34393432363131352f:61727469636c652f64657461696c732f313436313233363533" class_="artid" style="display:none">
 </p>
</div>


