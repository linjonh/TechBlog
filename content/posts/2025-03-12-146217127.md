---
layout: post
title: "SpringPostConstruct详解"
date: 2025-03-12 22:53:07 +0800
description: "在 Java 开发中，尤其是在基于 Spring 框架的项目里，我们常常会遇到需要在对象创建并完成依赖注入后，执行一些初始化操作的场景。注解正是为解决此类问题而诞生的，它为我们提供了一种便捷且优雅的方式来处理对象的初始化逻辑。是JSR-250规范定义的注解，用于标记在对象构造完成且依赖注入完成后执行的初始化方法。在Spring框架中的执行顺序为：构造函数 -> @Autowired依赖注入 -> @PostConstruct方法 -> Bean初始化完成。"
keywords: "【Spring】@PostConstruct详解"
categories: ['Spring']
tags: ['学习', '后端', 'Spring', 'Java']
artid: "146217127"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146217127
    alt: "SpringPostConstruct详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146217127
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146217127
cover: https://bing.ee123.net/img/rand?artid=146217127
image: https://bing.ee123.net/img/rand?artid=146217127
img: https://bing.ee123.net/img/rand?artid=146217127
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Spring】@PostConstruct详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在 Java 开发中，尤其是在基于 Spring 框架的项目里，我们常常会遇到需要在对象创建并完成依赖注入后，执行一些初始化操作的场景。
     <code>
      @PostConstruct
     </code>
     注解正是为解决此类问题而诞生的，它为我们提供了一种便捷且优雅的方式来处理对象的初始化逻辑。
     <code>
      @PostConstruct
     </code>
     是JSR-250规范定义的注解，用于标记在对象构造完成且依赖注入完成后执行的初始化方法。在Spring框架中的执行顺序为：构造函数 -&gt; @Autowired依赖注入 -&gt; @PostConstruct方法 -&gt; Bean初始化完成
    </p>
    <h2>
     <a id="PostConstruct__2">
     </a>
     一、@PostConstruct 基础概念
    </h2>
    <p>
     @PostConstruct 是 Java EE 提供的JSR-250规范注解，的注解，作用是标记一个方法，该方法会在对象被创建并且依赖注入完成之后，在构造函数执行完毕后自动调用，无需手动调用。这使得我们能够在对象可用之前，完成一些必要的初始化工作，比如加载配置文件、建立数据库连接、初始化缓存等。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2882dcaba52b499f99409a6310cdd89c.png"/>
    </p>
    <p>
     根据官方代码的注释我们可以看出
    </p>
    <ol>
     <li>
      <code>
       @PostConstruct
      </code>
      注解用于需要在完成依赖注入后执行以执行任何初始化的方法。
     </li>
     <li>
      所有支持依赖关系注入的类都必须支持此注解。就算注解所在的类不请求注入任何资源，也必须调用带有
      <code>
       @PostConstruct
      </code>
      注释的方法。
     </li>
    </ol>
    <p>
     <strong>
      使用条件：
     </strong>
    </p>
    <ul>
     <li>
      只有一个方法可以被
      <code>
       @PostConstruct
      </code>
      标注注解（经测试，在Springboot环境中不生效，可以多个方法标记）
     </li>
     <li>
      <code>
       @PostConstruct
      </code>
      注解的方法不能有参数，除非是在拦截器类中，在这种情况下，它采用 Interceptors 规范定义的 InvocationContext 对象。
      <br/>
      如果是拦截器类上定义的话，方法必须具有以下签名：
      <ol>
       <li>
        <p>
         <code>
          void &lt;METHOD&gt;（InvocationContext）
         </code>
        </p>
       </li>
       <li>
        <p>
         <code>
          Object &lt;METHOD&gt;（InvocationContext） throws Exception
         </code>
        </p>
        <p>
         注意：PostConstruct 拦截器方法不得引发应用程序异常，但如果相同的拦截器方法除了生命周期事件之外还插入到业务或超时方法上，则可以声明它抛出检查异常，包括
         <code>
          java.lang.Exception
         </code>
         。如果 PostConstruct 拦截器方法返回一个值，则容器将忽略该值。
        </p>
       </li>
      </ol>
     </li>
     <li>
      在非拦截器的类上
      <code>
       @PostConstruct
      </code>
      注解定义的方法返回值必须是void
     </li>
     <li>
      <code>
       @PostConstruct
      </code>
      注解的方法访问修饰符可以是 public、protected、package private 或 private，即所有访问级别都可以。
     </li>
     <li>
      <code>
       @PostConstruct
      </code>
      注解的方法不能用
      <code>
       static
      </code>
      修饰，除了在Application客户端中。
     </li>
     <li>
      <code>
       @PostConstruct
      </code>
      注解的方法可以
      <code>
       final
      </code>
      修饰
     </li>
     <li>
      <code>
       @PostConstruct
      </code>
      注解的方法不能抛出未经检查的异常(unchecked exception)
     </li>
    </ul>
    <h2>
     <a id="_26">
     </a>
     二、核心原理与执行顺序
    </h2>
    <h3>
     <a id="_27">
     </a>
     执行顺序
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/316680cbea6f4aacb7ccf05d90391287.png"/>
    </p>
    <p>
     @PostConstruct用于标记在对象构造完成且依赖注入完成后执行的初始化方法。在Spring框架中的执行顺序为：
     <br/>
     构造函数 -&gt; @Autowired依赖注入 -&gt; @PostConstruct方法 -&gt; Bean初始化完成 -&gt; destory方法
    </p>
    <h3>
     <a id="_32">
     </a>
     源码分析
    </h3>
    <p>
     进入
     <code>
      @PostConstruct
     </code>
     的源码中，发现只有
     <code>
      CommonAnnotationBeanPostProcessor
     </code>
     这个类的下面方法用到
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e6a9a2a956754860be8f59394e3e1035.png"/>
    </p>
    <p>
     这个方法也很简单，就是把这个注解赋值到
     <code>
      CommonAnnotationBeanPostProcessor
     </code>
     的父类
     <code>
      InitDestroyAnnotationBeanPostProcessor
     </code>
     中的
     <code>
      initAnnotationType
     </code>
     字段
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e62bd87ef50b4591879f186fee43825e.png"/>
    </p>
    <p>
     那么字段又在哪里使用呢？ 很巧，只有
     <code>
      InitDestroyAnnotationBeanPostProcessor
     </code>
     中使用，那我们直接看使用的方法
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9ad763c23154483aa4c90ff66e47a4e4.png">
      <br/>
      <code>
       buildLifecycleMetadata
      </code>
      方法主要做了
     </img>
    </p>
    <ol>
     <li>
      先判断这个类或类中方法或字段是否有
      <code>
       initAnnotationType
      </code>
      和
      <code>
       destroyAnnotationType
      </code>
      注解
     </li>
     <li>
      将该类以及所有父类的所有方法
      <code>
       initAnnotationType
      </code>
      和
      <code>
       destroyAnnotationType
      </code>
      注解的方法，作为参数创建
      <code>
       LifecycleElement
      </code>
      对象并存入
      <code>
       currInitMethods
      </code>
      和
      <code>
       currDestroyMethods
      </code>
      中
     </li>
     <li>
      把上面的初始化和销毁方法方法作为参数创建
      <code>
       LifecycleMetadata
      </code>
      对象
     </li>
    </ol>
    <p>
     通过上面步骤，我们就可以发现，在Spring中有多个初始化方法是不会报错的，相反而是全部存入
     <code>
      currInitMethods
     </code>
     集合中，并且所有的父类都会存入这个集合，
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1b3a4f4e6934469fa51f592faab1421e.png"/>
    </p>
    <p>
     其中在第二步创建
     <code>
      LifecycleElement
     </code>
     对象时，可以神奇的发现这里，如果方法的参数数量不为0就会抛出异常，这就和使用条件中的
     <code>
      @PostConstruct
     </code>
     注解的方法不能有参数相对应了。
    </p>
    <p>
     那么
     <code>
      buildLifecycleMetadata
     </code>
     方法又在哪里被使用？
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/aecccebd2f4848c09203c6454c4b02b1.png"/>
    </p>
    <p>
     可以看到这个方法主要是从
     <code>
      lifecycleMetadataCache
     </code>
     中获取某个类的
     <code>
      LifecycleMetadata
     </code>
     ，如果
     <code>
      lifecycleMetadataCache
     </code>
     为空，那么就调用最开始的方法，否则就会从
     <code>
      lifecycleMetadataCache
     </code>
     尝试获取，如果获取不到则通过大名鼎鼎的
     <code>
      Double-Check
     </code>
     方式，也就是双重检索单例模式，并且使用了
     <code>
      ConcurrentHashMap
     </code>
     ，来防止并发问题，
     <code>
      ConcurrentHashMap
     </code>
     如何防止并发可看相关文章。
    </p>
    <h2>
     <a id="_58">
     </a>
     三、使用示例
    </h2>
    <p>
     以下通过一个简单的 Spring Boot 项目示例来展示
     <code>
      @PostConstruct
     </code>
     的用法。
    </p>
    <p>
     首先，创建一个普通的 Java 类，并在其中定义一个带有
     <code>
      @PostConstruct
     </code>
     注解的方法：
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostConstructTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">PostConstructTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>userMapper <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"autowired"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"PostConstruct1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"PostConstruct2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     然后，启动 Spring Boot 应用程序，观察控制台输出：
    </p>
    <pre><code>2025-03-12 22:40:48.529   c.a.mpdemo1010.config.PostConstructTest  : Constructor
2025-03-12 22:40:49.378   c.a.mpdemo1010.config.PostConstructTest  : autowired
2025-03-12 22:40:49.378  c.a.mpdemo1010.config.PostConstructTest  : PostConstruct1
2025-03-12 22:40:49.378   c.a.mpdemo1010.config.PostConstructTest  : PostConstruct2
</code></pre>
    <p>
     从输出结果可以清晰地看到，构造函数先被调用，随后
     <code>
      @PostConstruct
     </code>
     注解的方法被调用。这表明
     <code>
      @PostConstruct
     </code>
     注解的方法确实是在对象创建和依赖注入完成之后执行的。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7171323633323234363532382f:61727469636c652f64657461696c732f313436323137313237" class_="artid" style="display:none">
 </p>
</div>


