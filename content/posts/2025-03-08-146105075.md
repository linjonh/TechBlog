---
layout: post
title: "Spring七AOP-代理模式"
date: 2025-03-08 14:01:43 +0800
description: "静态代理是通过手动编写一个“替身类”（代理类），在不修改原始类代码的前提下，为其添加额外功能（如日志、权限校验），使用时通过代理类间接调用原始类。：在不修改原始对象代码的前提下，添加新功能（如日志记录、性能统计）。：限制或增强对原始对象的访问（如权限校验）。：在需要时才初始化复杂对象（如大文件加载）。：隐藏底层复杂逻辑，对外提供简洁接口。：在方法调用前后自动记录日志。：调用方法前检查用户权限。"
keywords: "Spring（七）AOP-代理模式"
categories: ['Ssm']
tags: ['后端', 'Spring', 'Java']
artid: "146105075"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146105075
    alt: "Spring七AOP-代理模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146105075
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146105075
cover: https://bing.ee123.net/img/rand?artid=146105075
image: https://bing.ee123.net/img/rand?artid=146105075
img: https://bing.ee123.net/img/rand?artid=146105075
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring（七）AOP-代理模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     <strong>
      概念：AOP 面向切面编程(Aspect-Oriented Programming）
     </strong>
    </p>
    <p>
     <strong>
      面向切面编程，能够将那些与业务无关，却为业务模块所调用的逻辑封装起来，以减少系统代码的重复度，减少模块之间的耦合度。
     </strong>
    </p>
    <hr/>
    <h2 id="%E4%B8%80%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" name="%E4%B8%80%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">
     代理模式
    </h2>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         对比维度
        </strong>
       </th>
       <th>
        <strong>
         静态代理
        </strong>
       </th>
       <th>
        <strong>
         动态代理
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         代理关系确定时机
        </strong>
       </td>
       <td>
        <strong>
         编码期间
        </strong>
        ：代理类需手动编写，明确代理目标
       </td>
       <td>
        <strong>
         运行期间
        </strong>
        ：代理类由程序动态生成，无需预定义
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         实现方式
        </strong>
       </td>
       <td>
        代理类与目标类实现
        <strong>
         相同接口
        </strong>
        （或继承目标类），并通过
        <strong>
         组合
        </strong>
        持有目标对象
       </td>
       <td>
        通过
        <strong>
         反射
        </strong>
        （JDK动态代理）或
        <strong>
         字节码生成
        </strong>
        （CGLIB）动态拦截目标对象方法
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         代理范围
        </strong>
       </td>
       <td>
        - 仅能代理
        <strong>
         同一接口/父类
        </strong>
        的类
        <br/>
        - 需为每个目标类单独编写代理类
       </td>
       <td>
        -
        <strong>
         JDK动态代理
        </strong>
        ：代理接口实现类
        <br/>
        -
        <strong>
         CGLIB
        </strong>
        ：代理无接口类（非final类）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         代码复杂度
        </strong>
       </td>
       <td>
        - 代码简单直观，适合新手
        <br/>
        - 需手动维护代理类
       </td>
       <td>
        - 需理解反射/字节码机制
        <br/>
        - 框架（如Spring）可简化开发
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         性能
        </strong>
       </td>
       <td>
        - 直接调用目标方法，
        <strong>
         无反射开销
        </strong>
        <br/>
        - 性能更高
       </td>
       <td>
        -
        <strong>
         JDK动态代理
        </strong>
        ：反射调用性能较低
        <br/>
        -
        <strong>
         CGLIB
        </strong>
        ：首次生成代理类较慢
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         灵活性
        </strong>
       </td>
       <td>
        - 扩展功能固定，仅针对特定类
        <br/>
        - 接口变动需同步修改代理类
       </td>
       <td>
        - 可批量代理多个类，统一添加功能（如日志、事务）
        <br/>
        - 接口变动自动适配
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         典型应用场景
        </strong>
       </td>
       <td>
        - 代理少量固定类
        <br/>
        - 高频调用场景（如核心服务）
       </td>
       <td>
        - 框架级功能扩展（Spring AOP）
        <br/>
        - 需统一管理多个类的增强逻辑
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <u>
      <em>
       <strong>
        静态代理：编码期间就决定好了代理关系
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        定义：代理对象是目标对象的子类型，代理对象本省并不是目标对象，而是将目标作为自己的属性
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        优点：同一种类型的所有对象都能代理
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        缺点：范围太小
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        动态代理：运行期间才决定好了代理关系
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        定义：目标对象会在执行期间被动态拦截，插入指定逻辑
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        优点：可以代理世间万物
       </strong>
      </em>
     </u>
    </p>
    <p>
     <u>
      <em>
       <strong>
        缺点：复杂不好写
       </strong>
      </em>
     </u>
    </p>
    <h2 id="%E4%B8%80%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86" name="%E4%B8%80%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">
     一 静态代理
    </h2>
    <p>
     静态代理是通过手动编写一个“替身类”（代理类），在不修改原始类代码的前提下，为其添加额外功能（如日志、权限校验），使用时通过代理类间接调用原始类。
    </p>
    <h4 id="%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8" name="%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8">
     <strong>
      一、核心作用
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        控制访问
       </strong>
       ：限制或增强对原始对象的访问（如权限校验）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        功能扩展
       </strong>
       ：在不修改原始对象代码的前提下，添加新功能（如日志记录、性能统计）。
      </p>
     </li>
    </ol>
    <hr/>
    <h4 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" name="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">
     <strong>
      二、使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        日志记录
       </strong>
       ：在方法调用前后自动记录日志。
      </p>
     </li>
     <li>
      <p>
       <strong>
        权限校验
       </strong>
       ：调用方法前检查用户权限。
      </p>
     </li>
     <li>
      <p>
       <strong>
        延迟加载
       </strong>
       ：在需要时才初始化复杂对象（如大文件加载）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        简化复杂操作
       </strong>
       ：隐藏底层复杂逻辑，对外提供简洁接口。
      </p>
     </li>
     <li>
      <p>
       <strong>
        避坑提示
       </strong>
       ：如果系统中有大量需要代理的类，建议改用动态代理（如JDK动态代理或CGLIB）。
      </p>
     </li>
    </ol>
    <p>
     代码实现：
    </p>
    <p>
     定义接口：
    </p>
    <pre><code class="language-java">package org.example.spring02.MathMethod;

public interface MathCalculator {

    //定义四则运算
    public int div(int a, int b);

    public int mul(int a, int b);

    public int sub(int a, int b);

    public int add(int a, int b);
    
}
</code></pre>
    <p>
     实现类：
     <br/>
    </p>
    <pre><code class="language-java">package org.example.spring02.MathMethod.MIm;

import org.example.spring02.MathMethod.MathCalculator;
import org.springframework.stereotype.Component;

@Component
public class MathCalculatorImpl implements MathCalculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int sub(int a, int b) {
        return a - b;
    }

    @Override
    public int mul(int a, int b) {
        return a * b;
    }

    @Override
    public int div(int a, int b) {
        return a / b;
    }

}
</code></pre>
    <p>
     静态代理类：
    </p>
    <pre><code class="language-java">package org.example.spring02.MathMethod.proxy.statics;

import lombok.Data;
import org.example.spring02.MathMethod.MathCalculator;


/**
 * 静态代理类，实现了MathCalculator接口
 * 本类用于在不修改原始类的情况下，增加额外的功能处理，如日志、权限校验等
*/
 @Data
public class CalculatorStaticProxy implements MathCalculator {

    // 被代理对象
    private MathCalculator target;


    public CalculatorStaticProxy(MathCalculator mc) {
        this.target = mc;
    }


    @Override
    public int div(int a, int b) {
        //书写日志
        System.out.println("div被调用了，参数是：" + a + "，" + b);
        System.out.println("div被调用了，结果是：" + target.div(a, b));
        return target.div(a, b);
    }

    @Override
    public int mul(int a, int b) {
        System.out.println("mul被调用了，参数是：" + a + "，" + b);
        System.out.println("mul被调用了，结果是：" + target.mul(a, b));
        return target.mul(a, b);
    }

    @Override
    public int sub(int a, int b) {
        System.out.println("sub被调用了，参数是：" + a + "，" + b);
        System.out.println("sub被调用了，结果是：" + target.sub(a, b));
        return target.sub(a, b);
    }

    @Override
    public int add(int a, int b) {
        System.out.println("add被调用了，参数是：" + a + "，" + b);
        System.out.println("add被调用了，结果是：" + target.add(a, b));
        return target.add(a, b);
    }
}
</code></pre>
    <p>
     测试类：
    </p>
    <pre><code class="language-java">    // JUnit测试方法，用于测试MathCalculator的功能
    @Test
    void test01() {
        // 创建MathCalculator的实例对象
        MathCalculator target = new MathCalculatorImpl();
        // 调用add方法进行加法运算，并打印结果
        int add1 = target.add(1, 3);
        System.out.println(add1);
        // 分隔符，用于区分不同的测试部分
        System.out.println("======");
        // 创建静态代理对象，并传入目标对象
        CalculatorStaticProxy calculatorStaticProxy = new CalculatorStaticProxy(target);
        // 通过静态代理对象调用add方法进行加法运算，并打印结果
        int add = calculatorStaticProxy.add(1, 3);
        System.out.println(add);
    }</code></pre>
    <p>
     运行展示：
     <br/>
     <img alt="" height="480" src="https://i-blog.csdnimg.cn/direct/1253476df70947be95cfda80be31df81.png" width="1593"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" name="%E4%BA%8C%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">
     二 动态代理
    </h2>
    <p>
     <strong>
      动态代理：JDK动态代理目标对象必须有接口，代理的也只是接口规定的方法
     </strong>
    </p>
    <p>
     <strong>
      动态代理：是在运行时通过反射或字节码技术自动生成代理类，无需手动编写“替身类”，即可为多个目标对象统一添加功能（如日志、事务管理）。
     </strong>
    </p>
    <p>
     <strong>
      拦截处理：动态代理对象在调用原生对象的方法时，通过统一的入口（如
      <code>
       InvocationHandler.invoke()
      </code>
      ）拦截方法调用，从而实现对参数、方法执行过程和返回结果的增强或修改
     </strong>
     。
    </p>
    <h4 id="%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8" name="%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8">
     <strong>
      一、核心作用
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        统一扩展功能
       </strong>
       ：批量对多个类添加相同的增强逻辑。
      </p>
     </li>
     <li>
      <p>
       <strong>
        解耦代码
       </strong>
       ：将核心业务逻辑与辅助功能（如权限校验）分离。
      </p>
     </li>
     <li>
      <p>
       <strong>
        动态适配
       </strong>
       ：运行时根据需求灵活生成代理对象。
      </p>
     </li>
    </ol>
    <hr/>
    <h4 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" name="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">
     <strong>
      二、使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        框架级功能扩展
       </strong>
       ：如Spring AOP（日志、事务、权限）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        RPC调用
       </strong>
       ：隐藏网络通信细节，让远程调用像本地调用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        接口监控
       </strong>
       ：统计接口调用耗时、成功率等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Mock测试
       </strong>
       ：动态生成测试用的代理对象。
      </p>
     </li>
    </ol>
    <p>
     <img alt="" height="528" src="https://i-blog.csdnimg.cn/direct/75a4a35ebdb7416a91ef2f658f114adf.png" width="964"/>
    </p>
    <p>
     <strong>
      1. ClassLoader loader
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：
       <br/>
       动态代理生成的字节码需要被类加载器加载到 JVM 中。使用目标对象的类加载器可确保代理类能访问目标类及其接口。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
     </li>
    </ul>
    <pre><code class="language-java">// 目标对象
UserService target = new UserServiceImpl();
// 使用目标对象的类加载器
ClassLoader loader = target.getClass().getClassLoader();</code></pre>
    <p>
     <strong>
      2.Class&lt;?&gt;[] interfaces
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：
       <br/>
       指定代理类需要实现的接口。代理对象会实现这些接口的所有方法，并将方法调用委托给
       <code>
        InvocationHandler
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
     </li>
    </ul>
    <pre><code class="language-java">// 目标对象实现的接口
Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</code></pre>
    <p>
     <strong>
      3.InvocationHandler h
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：
       <br/>
       定义代理逻辑的核心处理器。所有通过代理对象调用的方法，都会触发
       <code>
        invoke()
       </code>
       方法，开发者可在此插入增强逻辑。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
     </li>
    </ul>
    <pre><code class="language-java">InvocationHandler handler = new InvocationHandler() {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 增强逻辑（如记录日志）
        System.out.println("调用方法: " + method.getName());
        // 调用目标对象的方法
        return method.invoke(target, args);
    }
};</code></pre>
    <h3 id="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%EF%BC%88%E5%88%9D%E5%A7%8B%EF%BC%89" name="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%EF%BC%88%E5%88%9D%E5%A7%8B%EF%BC%89">
     <strong>
      具体实现：（初始）
     </strong>
    </h3>
    <pre><code class="language-java">    @Test
    void test02() {
        // 原生对象
        MathCalculator target = new MathCalculatorImpl();
        int add1 = target.add(1, 3);
        System.out.println("原生对象");
        System.out.println(add1);

        //创建动态代理
        /*
          三个参数
          proxy:代理对象-&gt;相当于明星的代理人
          method:代理对象调用目标对象的方法
          args:方法调用传递的参数
         */
        InvocationHandler invocationHandler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                // 调用目标对象的方法并返回
                System.out.println("动态代理InvocationHandler的invoke中定义的");
                System.out.println("[日志] 调用了方法: " + method.getName());
                System.out.println("[日志] 获得参数: " + Arrays.toString(args));
                return method.invoke(target, args);
            }
        };
        /*
            三个参数
            ClassLoader：确保代理类的正确加载。
            Interfaces：定义代理类的行为范围（基于接口）。
            InvocationHandler：实现动态代理的核心逻辑（AOP 的基础）。
         */
        MathCalculator proxy = (MathCalculator) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                invocationHandler
        );
        int add = proxy.add(1, 3);
        System.out.println(add);

    }</code></pre>
    <h3 id="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%EF%BC%88%E6%94%B9%E8%BF%9B%EF%BC%89" name="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%EF%BC%88%E6%94%B9%E8%BF%9B%EF%BC%89">
     <strong>
      具体实现：（改进）
     </strong>
    </h3>
    <p>
    </p>
    <h4 id="%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91" name="%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91">
     <strong>
      一、核心业务逻辑
     </strong>
    </h4>
    <h5 id="1.%20%E6%8E%A5%E5%8F%A3%C2%A0MathCalculator" name="1.%20%E6%8E%A5%E5%8F%A3%C2%A0MathCalculator">
     <strong>
      1. 接口
      <code>
       MathCalculator
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：定义业务契约，明确四则运算的规范。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关键点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         声明了加减乘除四个方法。
        </p>
       </li>
       <li>
        <p>
         作为动态代理的接口约束（JDK动态代理必须基于接口）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="2.%20%E5%AE%9E%E7%8E%B0%E7%B1%BB%C2%A0MathCalculatorImpl" name="2.%20%E5%AE%9E%E7%8E%B0%E7%B1%BB%C2%A0MathCalculatorImpl">
     <strong>
      2. 实现类
      <code>
       MathCalculatorImpl
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：具体实现四则运算的业务逻辑。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关键点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          @Component
         </code>
         标注为 Spring 组件（若配合 Spring 使用）。
        </p>
       </li>
       <li>
        <p>
         实现了
         <code>
          MathCalculator
         </code>
         接口中的方法。
        </p>
       </li>
       <li>
        <p>
         是动态代理的目标对象（原生对象）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     接口
    </p>
    <pre><code class="language-java">package org.example.spring02.MathMethod;

public interface MathCalculator {

    //定义四则运算
    public int div(int a, int b);

    public int mul(int a, int b);

    public int sub(int a, int b);

    public int add(int a, int b);

}
</code></pre>
    <p>
     实现类
    </p>
    <pre><code class="language-java">package org.example.spring02.MathMethod.MIm;

import org.example.spring02.MathMethod.MathCalculator;
import org.springframework.stereotype.Component;

@Component
public class MathCalculatorImpl implements MathCalculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int sub(int a, int b) {
        return a - b;
    }

    @Override
    public int mul(int a, int b) {
        return a * b;
    }

    @Override
    public int div(int a, int b) {
        return a / b;
    }

}
</code></pre>
    <h4 id="%E4%BA%8C%E3%80%81%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E6%A8%A1%E5%9D%97" name="%E4%BA%8C%E3%80%81%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E6%A8%A1%E5%9D%97">
     <strong>
      二、日志工具模块
     </strong>
    </h4>
    <h5 id="%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB%C2%A0logUtils" name="%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB%C2%A0logUtils">
     <strong>
      日志工具类
      <code>
       logUtils
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：提供静态方法统一管理日志格式。
      </p>
     </li>
     <li>
      <p>
       <strong>
        核心方法
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          logStart()
         </code>
         ：记录方法开始执行的日志（含方法名和参数）。
        </p>
       </li>
       <li>
        <p>
         <code>
          logEnd()
         </code>
         ：记录方法正常结束的日志（含结果）。
        </p>
       </li>
       <li>
        <p>
         <code>
          logException()
         </code>
         ：记录方法执行异常的日志。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        设计亮点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          Object... args
         </code>
         支持可变参数，适配不同方法的参数。
        </p>
       </li>
       <li>
        <p>
         通过
         <code>
          Arrays.toString(args)
         </code>
         格式化参数输出。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="language-java">package org.example.spring02.log;

import java.util.Arrays;

public class logUtils {
    public static void logStart(String name , Object... args){
        System.out.println("开始执行方法："+name+"，参数："+ Arrays.toString(args));
    }
    public static void logEnd(String name , Object result){
        System.out.println("方法："+name+"，执行结果："+result);
    }
    public static void logException(String name , Exception e){
        System.out.println("方法："+name+"，执行异常："+e.getMessage());
    }
    public static void logEnd(){
        System.out.println("方法执行结束");
    }

}
</code></pre>
    <h4 id="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9D%97" name="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9D%97">
     <strong>
      三、动态代理模块
     </strong>
    </h4>
    <h5 id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%C2%A0DynamicProxy" name="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%C2%A0DynamicProxy">
     <strong>
      动态代理类
      <code>
       DynamicProxy
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：生成代理对象，为原生对象的方法调用添加日志增强逻辑。
      </p>
     </li>
    </ul>
    <pre><code class="language-java">package org.example.spring02.MathMethod.proxy.dynamic;

import org.example.spring02.log.logUtils;

import java.lang.reflect.Proxy;
import java.util.Arrays;

public class DynamicProxy {
    public static  Object newProxyInstance(Object target) {
         return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                (proxy, method, args) -&gt; {
                    System.out.println("动态代理开始");
                    System.out.println("[日志] 调用了方法: " + method.getName());
                    logUtils.logStart(method.getName(), args);
                    System.out.println("[日志] 获得参数: " + Arrays.toString(args));
                    return method.invoke(target, args);
                }
        );
    }
}
</code></pre>
    <h4 id="%E5%9B%9B%E3%80%81%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9D%97" name="%E5%9B%9B%E3%80%81%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9D%97">
     <strong>
      四、测试验证模块
     </strong>
    </h4>
    <h5 id="%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%C2%A0test03()" name="%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%C2%A0test03()">
     <strong>
      测试方法
      <code>
       test03()
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：验证动态代理的日志增强功能是否生效。
      </p>
     </li>
    </ul>
    <pre><code class="language-java">    @Test
    void test03(){
        MathCalculator o = (MathCalculator) DynamicProxy.newProxyInstance(new MathCalculatorImpl());
        int add = o.add(1, 3);
        System.out.println(add);

    }</code></pre>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37393834373833312f:61727469636c652f64657461696c732f313436313035303735" class_="artid" style="display:none">
 </p>
</div>


