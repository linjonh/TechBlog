---
layout: post
title: "Go沉思录朝花夕拾探究-Go-接口型函数"
date: 2025-03-11 17:05:15 +0800
description: "接口型函数是Go语言中一种优雅的设计模式，它允许将普通函数转换为接口类型，从而实现接口。其核心是定义一个与接口方法签名相同的函数类型，并为该函数类型实现接口方法。这种模式使代码更加简洁灵活，既可以用函数直接实现接口（通过类型转换），也可以用结构体实现接口，适用于接口只有单一方法的场景。在标准库中，如net/http包的Handler和HandlerFunc就是典型应用，它使API设计更加灵活，提高了代码的可读性和可维护性。"
keywords: "【Go沉思录】朝花夕拾：探究 Go 接口型函数"
categories: ['Go']
tags: ['接口型函数', '函数式编程', 'Golang']
artid: "146182167"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146182167
    alt: "Go沉思录朝花夕拾探究-Go-接口型函数"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146182167
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146182167
cover: https://bing.ee123.net/img/rand?artid=146182167
image: https://bing.ee123.net/img/rand?artid=146182167
img: https://bing.ee123.net/img/rand?artid=146182167
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Go沉思录】朝花夕拾：探究 Go 接口型函数
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d25f488a0907407ebb798de75458a970.png"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_5">
     </a>
     序
    </h2>
    <p>
     之前写Geecache的时候，遇到了接口型函数，当时没有搞懂，现在重新回过头研究复习Geecache的时候，发现看得懂一些了，刚好能梳理下。
    </p>
    <p>
     什么是接口型函数？比如下面这个 。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0b8ab8917a4b4e6eba0dad0c89f0fe85.png"/>
    </p>
    <h2>
     <a id="1_11">
     </a>
     1.接口型函数
    </h2>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Getter <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// A GetterFunc implements Getter with a function.</span>
<span class="token keyword">type</span> GetterFunc <span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

<span class="token comment">// Get implements Getter interface function</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f GetterFunc<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     还是上面图中的代码，我们来看看。
    </p>
    <p>
     首先定义了一个接口
     <code>
      Getter
     </code>
     ，只包含一个方法
     <code>
      Get(key string) ([]byte, error)
     </code>
     ，紧接着定义了一个
     <strong>
      函数类型
     </strong>
     <code>
      GetterFunc
     </code>
     ，
     <code>
      GetterFunc
     </code>
     参数和返回值与
     <code>
      Getter
     </code>
     中
     <code>
      Get
     </code>
     方法是一致的。
    </p>
    <p>
     而且 GetterFunc 还定义了
     <code>
      Get
     </code>
     方式，并在
     <code>
      Get
     </code>
     方法中
     <strong>
      调用自己
     </strong>
     ，这样就实现了接口
     <code>
      Getter
     </code>
     。所以
     <code>
      GetterFunc
     </code>
     是一个实现了接口的函数类型，简称为
     <strong>
      接口型函数
     </strong>
     。
    </p>
    <p>
     接口型函数
     <strong>
      只能应用于接口内部只定义了一个方法的情况
     </strong>
     ，例如接口
     <code>
      Getter
     </code>
     内部有且只有一个方法
     <code>
      Get
     </code>
     。既然只有一个方法，为什么还要多此一举，封装为一个接口呢？
    </p>
    <p>
     <strong>
      定义参数的时候，直接用
      <code>
       GetterFunc
      </code>
      这个函数类型不就好了，让用户直接传入一个函数作为参数，不更简单吗？
     </strong>
    </p>
    <p>
     看案例之前，我们再梳理一下原理。
    </p>
    <ul>
     <li>
      首先定义了一个接口
      <code>
       Getter
      </code>
      ，它要求实现一个 Get 方法
     </li>
     <li>
      然后定义了一个函数类型
      <code>
       GetterFunc
      </code>
      ，其签名与 Get 方法相同
     </li>
     <li>
      最关键的是，为
      <code>
       GetterFunc
      </code>
      类型实现了
      <code>
       Get
      </code>
      方法，该方法内部直接调用函数本身。
     </li>
    </ul>
    <p>
     这样，任何符合
     <code>
      GetterFunc
     </code>
     签名的函数都可以被转换为 Getter 接口类型，从而进行使用。
    </p>
    <hr/>
    <h3>
     <a id="_44">
     </a>
     案例
    </h3>
    <p>
     假设
     <code>
      GetFromSource
     </code>
     的作用是从某数据源获取结果，接口类型
     <code>
      Getter
     </code>
     是其中一个参数，代表某数据源：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">GetFromSource</span><span class="token punctuation">(</span>getter Getter<span class="token punctuation">,</span> key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{<!-- --></span>
	buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> getter<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> buf
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="1_GetterFunc__59">
     </a>
     方式1 GetterFunc 类型的函数作为参数
    </h3>
    <p>
     我们可以用多种方式来实现这个这个函数。
    </p>
    <p>
     比如方式一：
     <code>
      GetterFunc
     </code>
     类型的函数作为参数。下面就是用一个匿名函数（GetterFunc类型）来作为参数。使用
     <code>
      GetterFunc()
     </code>
     将这个匿名函数转换为
     <code>
      GetterFunc
     </code>
     类型，这样它就实现了 Getter 接口
    </p>
    <pre><code class="prism language-go"><span class="token function">GetFromSource</span><span class="token punctuation">(</span><span class="token function">GetterFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     也可以用普通的函数。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">GetFromSource</span><span class="token punctuation">(</span><span class="token function">GetterFunc</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将
     <code>
      test
     </code>
     函数强制转换为
     <code>
      GetterFunc
     </code>
     ，而
     <code>
      GetterFunc
     </code>
     实现了接口
     <code>
      Getter
     </code>
     ，是一个合法的参数。
    </p>
    <p>
     本质上，上面两种方式是类型转换，在go中我们定义了一个新类型，可以用这个新的类型名作为函数来进行类型转换，比如下面 字符串类型转换。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> String <span class="token builtin">string</span>

<span class="token comment">// 将普通字符串转换为 String 类型</span>
str <span class="token operator">:=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"1234"</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     我们把“函数”也看做是一种类型，（字符串、整数这些都是类型），那么也可以实现 函数 类型转换，比如。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> GetterFunc <span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>

<span class="token comment">// 将匿名函数转换为 GetterFunc 类型</span>
getter <span class="token operator">:=</span> <span class="token function">GetterFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     这两种情况本质上是相同的：都是将一个值转换为自定义类型。区别在于一个转换的是函数，另一个转换的是字符串。
    </p>
    <pre><code class="prism language-go"><span class="token comment">// 使用普通函数作为数据源</span>
<span class="token keyword">func</span> <span class="token function">dbGetter</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 从数据库获取数据</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"value from db"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将函数转换为Getter接口</span>
<span class="token keyword">var</span> getter Getter <span class="token operator">=</span> <span class="token function">GetterFunc</span><span class="token punctuation">(</span>dbGetter<span class="token punctuation">)</span>

<span class="token comment">// 现在可以在任何需要Getter接口的地方使用</span>
data<span class="token punctuation">,</span> err <span class="token operator">:=</span> getter<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"some_key"</span><span class="token punctuation">)</span>
</code></pre>
    <h3>
     <a id="2__Getter__119">
     </a>
     方式2 实现了 Getter 接口的结构体作为参数
    </h3>
    <pre><code class="prism language-go"><span class="token keyword">type</span> DB <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span> url <span class="token builtin">string</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>db <span class="token operator">*</span>DB<span class="token punctuation">)</span> <span class="token function">Query</span><span class="token punctuation">(</span>sql <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>
	<span class="token keyword">return</span> <span class="token string">"hello"</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>db <span class="token operator">*</span>DB<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>
	v <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token string">"SELECT NAME FROM TABLE WHEN NAME= ?"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">GetFromSource</span><span class="token punctuation">(</span><span class="token function">new</span><span class="token punctuation">(</span>DB<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     DB 实现了接口
     <code>
      Getter
     </code>
     ，也是一个合法参数。这种方式适用于逻辑较为复杂的场景，如果对数据库的操作需要很多信息，地址、用户名、密码，还有很多中间状态需要保持，比如超时、重连、加锁等等。这种情况下，更适合封装为一个结构体作为参数。
    </p>
    <hr/>
    <h3>
     <a id="_142">
     </a>
     价值
    </h3>
    <p>
     <strong>
      综上，这样，既能够将普通的函数类型（需类型转换）作为参数，也可以将结构体作为参数，使用更为灵活，可读性在使用函数（方式1）的时候某种程度上会更好，这就是接口型函数的价值。
     </strong>
    </p>
    <h2>
     <a id="2nethttp_150">
     </a>
     2.net/http包中的使用场景
    </h2>
    <p>
     上面的特性，在标准库中用得很多，
     <code>
      net/http
     </code>
     的
     <code>
      Handler
     </code>
     和
     <code>
      HandlerFunc
     </code>
     就是一个典型。
    </p>
    <p>
     看看
     <code>
      Handler
     </code>
     定义。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     我们可以
     <code>
      http.Handle
     </code>
     来映射请求路径和处理函数，Handle 的定义如下所示。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span>
</code></pre>
    <p>
     这里需要的第二参数是接口类型
     <code>
      Handler
     </code>
     。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">home</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">)</span>
	<span class="token boolean">_</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello, index page"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/home"</span><span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>home<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     通常还有另一个函数，
     <code>
      http.HandleFunc
     </code>
     ，
     <code>
      HandleFunc
     </code>
     的定义如下：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     第二个参数是一个普通的函数类型，那可以直接将
     <code>
      home
     </code>
     传递给
     <code>
      HandleFunc
     </code>
     ，实现代码如下。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/home"</span><span class="token punctuation">,</span> home<span class="token punctuation">)</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     看看
     <code>
      HandleFunc
     </code>
     的内部实现逻辑。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     可以看到，
     <code>
      mux.Handle(pattern, HandlerFunc(handler))
     </code>
    </p>
    <p>
     两种写法是完全等价的，内部将第二种写法转换为了第一种写法。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f7468656169706f7765722f:61727469636c652f64657461696c732f313436313832313637" class_="artid" style="display:none">
 </p>
</div>


