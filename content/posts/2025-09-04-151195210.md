---
layout: post
title: "OPENCV复习第二期"
date: 2025-09-04T22:31:14+0800
description: "【代码】OPENCV复习第二期。"
keywords: "OPENCV复习第二期"
categories: ['未分类']
tags: ['计算机视觉', '人工智能', 'Opencv']
artid: "151195210"
arturl: "https://blog.csdn.net/2501_91113915/article/details/151195210"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151195210
    alt: "OPENCV复习第二期"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151195210
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151195210
cover: https://bing.ee123.net/img/rand?artid=151195210
image: https://bing.ee123.net/img/rand?artid=151195210
img: https://bing.ee123.net/img/rand?artid=151195210
---



# OPENCV复习第二期

#### 主要算法说明

1. **Sobel 算子**

   * 用于计算图像的梯度（边缘），分别检测 x 方向（水平）和 y 方向（垂直）的边缘
   * `cv2.Sobel(yt, cv2.CV_64F, dx=1, dy=0)`：计算 x 方向梯度（dx=1, dy=0）
   * `cv2.Sobel(yt, cv2.CV_64F, dx=0, dy=1)`：计算 y 方向梯度（dx=0, dy=1）
   * 使用`cv2.CV_64F`是为了保留梯度的正负值（边缘可能是亮到暗或暗到亮）
   * `cv2.convertScaleAbs()`：将梯度值转换为绝对值并转为 8 位图像（便于显示）
   * `cv2.addWeighted()`：将 x 和 y 方向的边缘图像融合，得到完整边缘
2. **Scharr 算子**

   * 是 Sobel 算子的改进版，在 3x3 卷积核下具有更高的精度，对边缘的检测更敏感
   * 使用方式与 Sobel 类似：`cv2.Scharr(yt, cv2.CV_64F, dx=1, dy=0)`
   * 适用于需要更精确边缘检测的场景
3. **Laplacian 算子**

   * 基于图像的二阶导数，对图像中的快速变化（边缘）更敏感
   * `cv2.Laplacian(yt, cv2.CV_64F)`：直接计算图像的拉普拉斯变换
   * 对噪声较敏感，通常需要先进行平滑处理
4. **Canny 边缘检测**

   * 一种多阶段的边缘检测算法，能有效抑制噪声并检测出真正的边缘
   * `cv2.Canny(yt, 80, 120)`：两个阈值分别为低阈值和高阈值
     + 低于低阈值的像素被丢弃
     + 高于高阈值的像素被保留为边缘
     + 介于两者之间的像素，若与边缘像素相连则保留



