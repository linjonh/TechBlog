---
layout: post
title: "17-C-语言宏进阶必看从宏替换避坑到宏函数用法,不定参数模拟实现一次搞定"
date: 2025-09-04T09:55:38+0800
description: "本文详细介绍了C语言预处理的相关知识，主要包括预定义符号和宏定义的使用。预定义符号如__FILE__、__LINE__等可在编译时获取文件信息；宏定义(#define)用于文本替换，可定义常量、带参数宏和复杂表达式。文章重点讲解了宏替换规则、宏与函数的区别、#和##运算符的使用技巧，以及可变参数宏的实现方法。通过大量示例说明了宏定义中的常见问题和注意事项，如括号使用、参数类型无关性、字符串化和符号拼接等特性，帮助开发者正确使用预处理功能提高代码效率。"
keywords: "17 C 语言宏进阶必看：从宏替换避坑到宏函数用法，不定参数模拟实现一次搞定"
categories: ['C']
tags: ['预处理', '文本替换', 'C']
artid: "151173485"
arturl: "https://blog.csdn.net/2301_76755408/article/details/151173485"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151173485
    alt: "17-C-语言宏进阶必看从宏替换避坑到宏函数用法,不定参数模拟实现一次搞定"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151173485
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151173485
cover: https://bing.ee123.net/img/rand?artid=151173485
image: https://bing.ee123.net/img/rand?artid=151173485
img: https://bing.ee123.net/img/rand?artid=151173485
---



# 17 C 语言宏进阶必看：从宏替换避坑到宏函数用法，不定参数模拟实现一次搞定



### 预处理详解

#### 1. 预定义符号

```

//C语⾔设置了⼀些预定义符号，可以直接使⽤，预定义符号也是在预处理期间处理的。
__FILE__ //进⾏编译的源⽂件--预处理阶段被替换成指向文件名字符串的指针--char* 类型的变量
__LINE__ //⽂件当前的⾏号 --预处理阶段替换成使用该预处理符号所在的行号--unsigned int 类型
__DATE__ //⽂件被编译的⽇期
__TIME__ //⽂件被编译的时间
__STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义
```

#### 2 #define 定义常量

##### 宏替换注意点：

1 只能替换在同一行的内容，如果内容太长可以在每一行结尾用 \表示绪行

2 宏替换本质上就是文本替换在预处理阶段就替换完成了，c语言代码叫编译型语言是因为在没有编译之前

代码就是文本文件，是可以进行替换的。替换之后再做语法检查

基本语法：

> #define name stuff 1//这个只是宏替换的模板，后面使用到name字段按照这个模板替换成stuff 1

举个例⼦：

```

#define MAX 1000
#define reg register //为 register这个关键字，创建⼀个简短的名字
#define do_forever for(;;) //⽤更形象的符号来替换⼀种实现
#define CASE break;case //在写case语句的时候⾃动把 break写上。
// 如果定义的 stuff过⻓，可以分成⼏⾏写，除了最后⼀⾏外，每⾏的后⾯都加⼀个反斜杠(续⾏符)。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \
date:%s\ttime:%s\n" ,\
__FILE__,__LINE__ , \
__DATE__,__TIME__ )
```

##### 思考：在define定义标识符的时候，要不要在最后加上 ; ?

```

//⽐如：
#define MAX 1000;
#define MAX 1000

//建议不要加上 ; ,这样容易导致问题。
//⽐如下⾯的场景：
if(condition)
max = MAX;
else
max = 0;

//如果是加了分号的情况，等替换后，if和else之间就是2条语句，⽽没有⼤括号的时候，if后边只能有⼀
//条语句。这⾥会出现语法错误。
```

#### 3 #define定义宏

#define机制包括了⼀个规定，允许把参数替换到⽂本中，这种实现通常称为宏（macro）或定义宏 下⾯是宏的申明⽅式：

> #define name( parament-list ) stuff

其中的 parament-list 是⼀个由逗号隔开的符号表，它们可能出现在stuff中。 注意： **参数列表的左括号必须与name紧邻，如果两者之间有任何空⽩存在，参数列表就会被解释为stuff的** **⼀部分。**

##### 举例：

> #define SQUARE( x ) x * x

这个宏接收⼀个参数 x .如果在上述声明之后，你把 SQUARE( 5 ); 置于程序中，预处理器就会⽤下⾯这个表达式替换上⾯的表达式：

5 * 5

警告： 这个宏存在⼀个问题： 观察下⾯的代码段：

> int a = 5;  
> printf("%d\n" ,SQUARE( a + 1) );

乍⼀看，你可能觉得这段代码将打印36，事实上它将打印11，为什么呢？? 替换⽂本时，参数x被替换成a+1,所以这条语句实际上变成了：

> printf ("%d\n",a + 1 * a + 1 );

这样就⽐较清晰了，由替换产⽣的表达式并没有按照预想的次序进⾏求值。 在宏定义上加上两个括号，这个问题便轻松的解决了：

> #define SQUARE(x) (x) * (x)

这样预处理之后就产⽣了预期的效果：

> printf ("%d\n",(a + 1) * (a + 1) );

#### 4 宏替换的规则

在程序中扩展#define定义符号和宏时，需要涉及⼏个步骤。

1. **在调⽤宏时，⾸先对参数进⾏检查，看看是否包含任何由#define定义的符号。如果是，它们⾸先** **被替换。**
2. **替换⽂本随后被插⼊到程序中原来⽂本的位置。对于宏，参数名被他们的值所替换。**
3. **最后，再次对结果⽂件进⾏扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上** **述处理过程。** **注意：**
4. **宏参数和#define定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。**
5. **当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。**

#### 5 宏函数和函数 的对⽐

##### 注意点宏函数

宏函数的参数的替换是没有类型检查的，只是把参数替换进去最后编译才进行类型检查。是把宏参数做文本替换，替换掉后面的整个文本中的宏参数文本，比如：

```

#define MAX(a, b) ((a)>(b)?(a):(b)) 

int x=1,y=2;
//文本a和b替换成x,y，后面的文本中的a,b也被替换成x,y
MAX(x,y) ---替换成((x)>(y)?(x):(y)) 
//a,b-->1,2
MAX(1,2) ---替换成((1)>(2)?(1):(2)) 
//a,b -->1,2
MAX(1,x) --- ((1)>(x)?(1):(x)) 
```

宏通常被应⽤于执⾏简单的运算。 ⽐如在两个数中找出较⼤的⼀个时，写成下⾯的宏，更有优势⼀些。

> #define MAX(a, b) ((a)>(b)?(a):(b))

那为什么不⽤函数来完成这个任务？ 原因有⼆：

1. ⽤于调⽤函数和从函数返回的代码可能⽐实际执⾏这个⼩型计算⼯作所需要的时间更多。所以宏⽐ 函数在程序的规模和速度⽅⾯更胜⼀筹。
2. **更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使⽤。反之** **这个宏可以适⽤于整形、⻓整型、浮点型等可以⽤于 > 来⽐较的类型。宏的参数是类型⽆关的。** 和函数相⽐宏的劣势：
3. 每次使⽤宏的时候，⼀份宏定义的代码将插⼊到程序中。除⾮宏⽐较短，否则可能⼤幅度增加程序 的⻓度。
4. 宏是没法调试的。
5. 宏由于类型⽆关，也就不够严谨。
6. 宏可能会带来运算符优先级的问题，导致程容易出现错。 宏有时候可以做函数做不到的事情。⽐如：宏的参数可以出现类型，但是函数做不到。

```


#define MALLOC(num, type)\
(type )malloc(num sizeof(type))
...
//使⽤
MALLOC(10, int); //类型作为参数
//预处理器替换之后：
(int * )malloc(10 sizeof(int));
```

#### 6 #和##

##### 1 #运算符

#运算符将宏的⼀个参数转换为字符串字⾯量。它仅允许出现在带参数的宏的替换列表中。 #运算符所执⾏的操作可以理解为”字符串化“。 当我们有⼀个变量 int a = 10; 的时候，我们想打印出： the value of a is 10 . 就可以写：

```

//首先把a文本替换掉宏函数中的n文本，然后在把后面的文本中的n文本也替换成a文本
//最后整体替换文本，宏函数替换成后面一整个文本
#define PRINT(n) printf("the value of "#n " is %d", n); 
int a=1;
PRINT(a);// the value of a is 10 .
```

当我们按照下⾯的⽅式调⽤的时候： PRINT(a);//当我们把a替换到宏的体内时，就出现了#a，⽽#a就是转换为 字符串"a"，同时两个字符串是会被合并为一个字符串的，比如：

> "abs""sad" ->"abssad"    "add"fff"dsa" --> "addfffdsa"

##### 2 ##运算符

可以把位于它两边的符号合成⼀个符号，它允许宏定义从分离的⽂本⽚段创建标识符。 ## 被称为记号粘合 这样的连接必须产⽣⼀个合法的标识符。否则其结果就是未定义的。这⾥我们想想，写⼀个函数求2个数的较⼤值的时候，不同的数据类型就得写不同的函数。⽐如：

```

int int_max(int x, int y)
{
return x>y?x:y;
}
float float_max(float x, float y)
{
return x>yx:y;
}
```

但是这样写起来太繁琐了，现在我们这样写代码试试： //宏定义

> #define GENERIC_MAX(type) \  
> type type##_max(type x, type y)\  
> { \  
> return (x>y?x:y); \  
> }

**使⽤宏，定义不同函数** **GENERIC_MAX(int) //替换到宏体内后int##*max ⽣成了新的符号 int_max做函数名 GENERIC_MAX(float) //替换到宏体内后float##*max ⽣成了新的符号 float_max做函数名**

```


GENERIC_MAX(int) 
/*
预处理被文本替换成
int int_max(int x,int y)
{
    return ((x)>(y)?(x):(y));
}

*/
GENERIC_MAX(float)
int main()
{
//调⽤函数
int m = int_max(2, 3);
printf("%d\n", m);
float fm = float_max(3.5f, 4.5f);
printf("%f\n", fm);
return 0;
}
输出：
3
4.500000
```

###### 不定参数的传参使用##

```

#include<stdio.h>

//__FILE__ :预处理符号，在预处理阶段替换成当前符号所在的文件名类型为字符串
//__LINE__ :预处理符号, 在预处理阶段替换成当前符号所在的文件的具体行数类型为int

//不定宏参数的使用: ... 可变参数符号，不确定传入的参数是多少，在宏定义中通常搭配##__VA_ARGS__使用
//Print(fmt,...) 预处理替换时 Print(fmt,...)中的fmt 替换printf中的fmt ,"jjjj"替换 ...
//##__VA_ARGS__：若可变参数为空，C99标准要求逗号必须保留（可能引发语法错误）。
//GCC/Clang通过##__VA_ARGS__优化,展开时自动去掉前面的逗号
//传入Print(不定参数) 通过##__VA_ARGS__替换到printf函数中
//当多个字符串写在一起时编译预处理时会自动把多个字符串拼接在一起
//"ddd""dasd""asdsa" --> "ddddsdadsadsa"
#define Print(fmt,...) printf("[%s %d]"fmt"\n",__FILE__,__LINE__,##__VA_ARGS__)
int main()
{
    printf("[%s %d] %s\n",__FILE__,__LINE__,"jhhh");
    Print("%s","jjjj");
    Print("gggg");//传入的可变参数为空
    Print("ddd""fff");
    return 0;
}
```



