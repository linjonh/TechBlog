---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333832343138382f:61727469636c652f64657461696c732f313238363038373037"
layout: post
title: "UCOS简单介绍"
date: 2024-09-28 09:32:00 +08:00
description: "UCOSII 的前身是 UCOS，最早出自于1992 年美国嵌入式系统专家 Jean J.Labro"
keywords: "UCOS,UCOSII,实时操作系统"
categories: ['Ucos']
tags: ['操作系统', 'Ucos', 'Rtos']
artid: "128608707"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=128608707
    alt: "UCOS简单介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=128608707
featuredImagePreview: https://bing.ee123.net/img/rand?artid=128608707
---

# UCOS简单介绍

## 什么是UCOS？

UCOSII 的前身是 UCOS，最早出自于
**1992 年**
美国嵌入式系统专家 Jean J.Labrosse 在《嵌入式系统编程》杂志的 5 月和 6 月刊上刊登的文章连载，并把 UCOS 的源码发布在该杂志的BBS 上。

UCOSII 是一个可以
**基于 ROM 运行的、可裁减的、抢占式、实时多任务内核**
，具有高度可移植性，特别适合于微处理器和控制器，是和很多商业操作系统性能相当的实时操作系统(RTOS)。为了提供最好的移植性能，UCOSII 最大程度上使用
**ANSI C**
语言进行开发，并且已经移植到近 40 多种处理器体系上，涵盖了从 8 位到 64 位各种 CPU(包括 DSP)。

UCOSII 是专门为计算机的嵌入式应用设计的，
**绝大部分代码是用 C 语言编写的**
。
**CPU 硬件相关部分是用汇编语言编写的**
、总量约
**200 行的汇编语言**
部分被压缩到最低限度，为的是便于移植到任何一种其它的 CPU 上。用户只要有标准的
**ANSI 的 C 交叉编译器，有汇编器、连接器等软件工具，就可以将 UCOSII 嵌人到开发的产品中**
。UCOSII 具有执行效率高、占用空间小、实时性能优良和可扩展性强等特点， 最小内核可编译至 2KB 。UCOSII 已经移植到了几乎所有知名的 CPU 上。

## 体系结构

UCOSII 构思巧妙。结构简洁精练，可读性强，同时又具备了实时操作系统的全部功能，虽然它只是一个内核，但非常适合初次接触嵌入式实时操作系统的朋友，可以说是麻雀虽小，五脏俱全。UCOSII（V2.91 版本）体系结构如图所示：

![](https://i-blog.csdnimg.cn/blog_migrate/b7a391f5cc6e3e6929cc2e0b456a79ee.png)

从上图可以看出，UCOSII 的移植，
**我们只需要修改：os\_cpu.h、os\_cpu\_a.asm 和 os\_cpu.c等三个文件即可。**

* os\_cpu.h，进行数据类型的定义，以及处理器相关代码和几个函数原型；
* os\_cpu\_a.asm，是移植过程中需要汇编完成的一些函数，主要就是任务切换函数；
* os\_cpu.c，定义一些用户 HOOK 函数。

图中
**定时器的作用是为 UCOSII 提供系统时钟节拍，实现任务切换和任务延时等功能**
。这个时钟节拍由 OS\_TICKS\_PER\_SEC（在 os\_cfg.h 中定义）设置，一般我们设置 UCOSII 的系统时钟节拍为 1ms~100ms，具体根据你所用处理器和使用需要来设置。

## 支持多少任务？

UCOSII 早期版本只支持 64 个任务，但是
**从 2.80 版本开始，支持任务数提高到 255 个**
，不过对我们来说一般 64 个任务都是足够多了，一般很难用到这么多个任务。

**UCOSII 保留了最高4 个优先级和最低 4 个优先级的总共 8 个任务**
，用于拓展使用，但实际上，UCOSII 一般只占用了最低 2 个优先级，分别用于空闲任务（倒数第一）和统计任务（倒数第二），所以剩下给我们使用的任务最多可达 255-2=25（V2.91）。

## 如何实现任务并发？

**UCOS 是怎样实现多任务并发工作的呢？**
外部中断相信大家都比较熟悉了。CPU 在执行一段用户代码的时候，如果此时发生了外部中断，那么先进行现场保护，之后转向中断服务程序执行，执行完成后恢复现场，从中断处开始执行原来的用户代码。
**Ucos 的原理本质上也是这样的，当一个任务 A 正在执行的时候，如果他释放了 cpu 控制权，先对任务 A 进行现场保护，然后从任务就绪表中查找其他就绪任务去执行，等到任务 A 的等待时间到了，它可能重新获得cpu 控制权，这个时候恢复任务 A 的现场，从而继续执行任务 A，这样看起来就好像两个任务同时执行了。**
实际上，任何时候，只有一个任务可以获得 cpu 控制权。

所谓的
**任务，其实就是一个死循环函数**
，该函数实现一定的功能，一个工程可以有很多这样的任务（最多 255 个），UCOSII 对这些任务进行调度管理，让这些任务可以
**并发工作**
（注意不是同时工作！！，并发只是各任务轮流占用 CPU，而不是同时占用，任何时候还是只有 1个任务能够占用 CPU），这就是 UCOSII 最基本的功能。

```cpp
void MyTask (void *pdata)
{ 
    任务准备工作…
    While(1)//死循环
    { 任务 MyTask 实体代码;
     	OSTimeDlyHMSM(x,x,x,x);//调用任务延时函数，释放 cpu 控制权，
    }
}
```

这个实时操作系统到底有啥用呢?

比如：MP3 实验，在 MP3 播放的时候，我们还希望显示歌词，如果是 1 个死循环（一个任务），那么很可能在显示歌词的时候，MP3 声音出现停顿（尤其是高码率的时候），这主要是歌词显示占用太长时间，导致 VS1053 由于不能及时得到数据而停顿。而如果用 UCOSII 来处理，那么我们可以分 2 个任务，MP3 播放一个任务（优先级高），歌词显示一个任务（优先级低）。这样，由于 MP3 任务的优先级高于歌词显示任务，MP3 任务可以打断歌词显示任务，从而及时给 VS1053 提供数据，保证音频不断，而显示歌词又能顺利进行。这就是 UCOSII 带来的好处。

## 几个相关概念

### 优先级

任务优先级，这个概念比较好理解，ucos 中，每个任务都有唯一的一个优先级。优先级是任务的唯一标识。

在 UCOSII 中，使用 CPU 的时候，优先级高（数值小）的任务比优先级低的任务具有优先使用权，即
**任务就绪表中总是优先级最高的任务获得 CPU 使用权，只有高优先级的任务让出 CPU 使用权（比如延时）时，低优先级的任务才能获得 CPU 使用权**
。

UCOSII 不支持多个任务优先级相同，也就是每个任务的优先级必须不一样。

### 任务堆栈

任务堆栈，就是存储器中的连续存储空间。为了
**满足任务切换和响应中断时保存 CPU 寄存器中的内容以及任务调用其他函数时的需要，每个任务都有自己的堆栈**
。在创建任务的时候，任务堆栈是任务创建的一个重要入口参数。

### 任务控制块 OS\_TCB

任务控制块 OS\_TCB，用来
**记录任务堆栈指针，任务当前状态以及任务优先级等任务属性**
。UCOSII 的任何任务都是通过任务控制块（TCB）的东西来控制的，一旦任务创建了，任务控制块 OS\_TCB 就会被赋值。

每个任务管理块有 3 个最重要的参数：

* 1，任务函数指针；
* 2，任务堆栈指针；
* 3，任务优先级；

任务控制块就是任务在系统里面的身份证（UCOSII 通过优先级识别任务）。

### 任务就绪表

任务就绪表，简而言之就是用来记录系统中所有处于就绪状态的任务。它是一个位图，系统中每个任务都在这个位图中占据一个进制位，该位置的状态（1 或者 0）就表示任务是否处于就绪状态。

### 任务调度

任务调度的
**作用一是在任务就绪表中查找优先级最高的就绪任务，二是实现任务的切换**
。

比如说，当一个任务释放 cpu 控制权后，进行一次任务调度，这个时候任务调度器首先要去任务就绪表查询优先级最高的就绪任务，查到之后，进行一次任务切换，转而去执行下一个任务。

## 5种状态

UCOSII 的每个任务都是一个死循环。每个任务都处在以下 5 种状态之一的状态下，这 5种状态是：
**睡眠状态、 就绪状态、 运行状态、 等待状态(等待某一事件发生)和中断服务状态**
。

![](https://i-blog.csdnimg.cn/blog_migrate/039c4f6a27bdf77532b2c7c4cb159f9b.png)

1. 睡眠状态，任务在没有被配备任务控制块或被剥夺了任务控制块时的状态。
2. 就绪状态，系统为任务配备了任务控制块且在任务就绪表中进行了就绪登记，任务已经准备好了，但由于该任务的优先级比正在运行的任务的优先级低， 还暂时不能运行，这时任务的状态叫做就绪状态。
3. 运行状态，该任务获得 CPU 使用权，并正在运行中，此时的任务状态叫做运行状态。
4. 等待状态，正在运行的任务，需要等待一段时间或需要等待一个事件发生再运行时，该任务就会把 CPU 的使用权让给别的任务而使任务进入等待状态。
5. 中断服务状态，一个正在运行的任务一旦响应中断申请就会中止运行而去执行中断服务程序，这时任务的状态叫做中断服务状态

## 与任务相关的几个函数

### **建立任务函数**

如果想让 UCOSII 管理用户的任务，必须先建立任务。UCOSII 提供了我们 2 个建立任务的函数：OSTaskCreat 和 OSTaskCreateExt，我们一般用 OSTaskCreat 函数来创建任务，该函数原型为：

```cpp
OSTaskCreate(void(*task)(void*pd), void*pdata, OS_STK*ptos, INTU prio)。
```

该函数包括 4 个参数：

* task：是指向任务代码的指针；
* pdata：是任务开始执行时，传递给任务的参数的指针；
* ptos：是分配给任务的堆栈的栈顶指针；
* prio 是分配给任务的优先级。

每个任务都有自己的堆栈，堆栈必须申明为 OS\_STK 类型，并且由连续的内存空间组成。可以静态分配堆栈空间，也可以动态分配堆栈空间。

### **任务删除函数**

所谓的任务删除，其实就是把任务置于睡眠状态，并不是把任务代码给删除了。UCOSII提供的任务删除函数原型为：

```cpp
INT8U OSTaskDel(INT8U prio)；
```

其中参数 prio 就是我们要删除的任务的优先级，可见该函数是通过任务优先级来实现任务删除的。

特别注意：任务不能随便删除，必须在确保被删除任务的资源被释放的前提下才能删除！

### **请求任务删除函数**

前面提到，必须确保被删除任务的资源被释放的前提下才能将其删除，所以我们通过向被删除任务发送删除请求，来实现任务释放自身占用资源后再删除。UCOSII 提供的请求删除任务函数原型为：

```cpp
INT8U OSTaskDelReq(INT8U prio)；
```

同样还是通过优先级来确定被请求删除任务。

### **改变任务的优先级函数**

UCOSII 在建立任务时，会分配给任务一个优先级，但是这个优先级并不是一成不变的，而是可以通过调用 UCOSII 提供的函数修改。UCOSII 提供的任务优先级修改函数原型为：

```cpp
INT8U OSTaskChangePrio(INT8U oldprio, INT8U newprio)；
```

### 任务挂起函数

任务挂起和任务删除有点类似，但是又有区别，任务挂起只是将被挂起任务的就绪标志删除，并做任务挂起记录，并没有将任务控制块任务控制块链表里面删除，也不需要释放其资源，而任务删除则必须先释放被删除任务的资源，并将被删除任务的任务控制块也给删了。被挂起的任务，在恢复（解挂）后可以继续运行。UCOSII 提供的任务挂起函数原型为：

```cpp
INT8U OSTaskSuspend(INT8U prio)；
```

### 任务恢复函数

有任务挂起函数，就有任务恢复函数，通过该函数将被挂起的任务恢复，让调度器能够重新调度该函数。UCOSII 提供的任务恢复函数原型为：

```cpp
INT8U OSTaskResume(INT8U prio)；
```

### **任务信息查询**

在应用程序中我们经常要了解任务信息，查询任务信息函数原型为：

```cpp
INT8U OSTaskQuery(INT8U prio,OS_TCB *pdata);
```

这个函数获得的是对应任务的 OS\_TCB 中内容的拷贝。

从上面这些函数我们可以看出，对于每个任务，有一个非常关键的参数就是任务优先级 prio,在UCOS 中，任务优先级可以用来作为任务的唯一标识，所以任务优先级对任务而言是唯一的，而且是不可重复的。