---
layout: post
title: "蓝桥杯速成-3.数据结构"
date: 2025-03-15 20:14:12 +0800
description: "蓝桥杯倒数27天！选择合适的数据结构才能事半功倍！"
keywords: "【蓝桥杯速成】| 3.数据结构"
categories: ['未分类']
tags: ['蓝桥杯', '算法', '数据结构']
artid: "146282655"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146282655
    alt: "蓝桥杯速成-3.数据结构"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146282655
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146282655
cover: https://bing.ee123.net/img/rand?artid=146282655
image: https://bing.ee123.net/img/rand?artid=146282655
img: https://bing.ee123.net/img/rand?artid=146282655
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【蓝桥杯速成】| 3.数据结构
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     题目一：两数之和
    </h2>
    <h3>
     问题描述
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/two-sum/description/" rel="nofollow" title="1. 两数之和 - 力扣（LeetCode）">
      1. 两数之和 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     给定一个整数数组
     <code>
      nums
     </code>
     和一个整数目标值
     <code>
      target
     </code>
     ，请你在该数组中找出
     <strong>
      和为目标值
     </strong>
     <em>
      <code>
       target
      </code>
     </em>
     的那
     <strong>
      两个
     </strong>
     整数，并返回它们的数组下标。
    </p>
    <p>
     你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
    </p>
    <p>
     你可以按任意顺序返回答案。
    </p>
    <h3>
     解题步骤
    </h3>
    <p>
     从数组中找出和为目标值的两个数字，返回其数组下标
    </p>
    <p>
     用最简单的思维就是嵌套循环来一套，
    </p>
    <p>
     遍历到一个以后，再去遍历下一个符合要求的，即可暴力求解
    </p>
    <pre><code class="language-cpp">int size=nums.size();
for(int i=0;i&lt;size;i++){
    for(int j=i+1;j&lt;size;j++){
        if(nums[i]+nums[j] == target){
            return {i,j}
        }
    }
}</code></pre>
    <p>
     暴力解法固然方便，但如果有时间限制呢？O(n^2)可经不起考验
    </p>
    <p>
     那么如何使用更小的时间复杂度解决问题呢？
    </p>
    <p>
     我们得换一种数据结构来解决
    </p>
    <p>
     考虑值的同时还需要记录下标，这种既要又要的条件只有哈希表能满足
    </p>
    <p>
     选择unordered_map，以nums数组的值 作为键，数组的索引 作为值
    </p>
    <p>
     这样可以调用map的find函数，实现直接定一求一，不需要再去遍历，就减小了时间复杂度
    </p>
    <pre><code class="language-cpp">unordered_map&lt;int,int&gt; record;
for(int i=0;i&lt;nums.size();i++){
    record[nums[i]]=i;
}</code></pre>
    <p>
     已经转存完毕！那么可以开始找可以配对的值了
    </p>
    <pre><code class="language-cpp">for(int i =0;i&lt;size;i++){
    if(record.find(target-nums[i]) ！= record.end() ){
        if(record.find(target-nums[i]) ！= i){
            return{record[target-nums[i]],i};
        }
    }
} </code></pre>
    <p>
     观察上面两个循环，发现是一样的，为了进一步简化代码，可以边存边找
    </p>
    <pre><code class="language-cpp">for(i=0;i&lt;nums.size();i++){
    auto iter = record.find(target-nums[i]);//iter为迭代器，遍历键值对
    if(iter != record.end()){
        return{iter-&gt;second,i};//每个键值对包含两个部分：键（first）和值（second）
    }else{
        record.insert(pair&lt;int, int&gt;(nums[i], i));//把该索引和元素转化为一对存入记录中
    }
}</code></pre>
    <hr/>
    <h2>
     题目二：有效的括号
    </h2>
    <h3>
     问题描述
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="20. 有效的括号 - 力扣（LeetCode）">
      20. 有效的括号 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     给定一个只包括
     <code>
      '('
     </code>
     ，
     <code>
      ')'
     </code>
     ，
     <code>
      '{'
     </code>
     ，
     <code>
      '}'
     </code>
     ，
     <code>
      '['
     </code>
     ，
     <code>
      ']'
     </code>
     的字符串
     <code>
      s
     </code>
     ，判断字符串是否有效。
    </p>
    <p>
     有效字符串需满足：
    </p>
    <ol>
     <li>
      左括号必须用相同类型的右括号闭合。
     </li>
     <li>
      左括号必须以正确的顺序闭合。
     </li>
     <li>
      每个右括号都有一个对应的相同类型的左括号。
     </li>
    </ol>
    <h3>
     解题步骤
    </h3>
    <p>
     这个题目就是典型的栈的应用，利用后进先出原则，可以很方便的完成括号配对
    </p>
    <p>
     具体操作为：
    </p>
    <p>
     先初始化一个空栈，按顺序读入括号
    </p>
    <p>
     是右括号就存入，是左括号就弹出栈顶元素进行匹配，
    </p>
    <p>
     匹配正确则弹出，不正确就return false
    </p>
    <pre><code class="language-cpp">stack&lt;char&gt; r;
//先修理一下
if(s.size()%2){//不能被2整除肯定有多的
    return false;
}
        
for(char c:s){
    if(c=='{' || c=='(' || c=='[')
         r.push(c);
    if(c=='}'){
        if (r.empty()) return false;  // 栈为空，无法匹配
        char temp=r.top();//获取栈顶元素
        r.pop();
        if(temp != '{')
            return false;
    }
    if(c==')'){
        if (r.empty()) return false;  // 栈为空，无法匹配
        char temp=r.top();//获取栈顶元素
        r.pop();
        if(temp != '(')
            return false;
        }
    if(c==']'){
         if (r.empty()) return false;  // 栈为空，无法匹配
         char temp=r.top();//获取栈顶元素
         r.pop();
         if(temp != '[')
             return false;
    }
}
return r.empty();//如果最后栈不为空就会返回false，为空就有效</code></pre>
    <p>
     在这个代码实现过程中，有几个需要注意的点，
    </p>
    <p>
     一开始可以做个初步判断，如果匹配那么字符串长度一定为偶数
    </p>
    <p>
     后续匹配过程要避免空栈错误，假如输入是"}["这一类，不加if (r.empty()) return false;这行代码一定报错
    </p>
    <p>
     再就是这个代码目前看来重复思路很多，还可以进一步优化
    </p>
    <p>
     目前的代码为了体现相应代码的匹配逻辑，才有了三个if
    </p>
    <p>
     为了统一这个匹配逻辑，在一个if中解决三类括号
    </p>
    <p>
     我们可以在遍历到右括号时存入相应左括号，这样遇到左括号直接进行匹配即可，不需要管它是什么类型(堪比秦始皇统一六国的壮举啊！！！)
    </p>
    <pre><code class="language-cpp">stack&lt;char&gt; r;
//剪枝操作
if(s.size()%2){//不能被2整除肯定有多的
    return false;
}
for(char c:s){
 //存入所有左括号的对应右括号，这样后续只需要匹配就可以
    if(c=='{')   r.push('}');
    else if(c=='[')  r.push(']');
    else if(c=='(')  r.push(')');

    //开始匹配
    else if(r.empty() || r.top()!=c){
        return false;
    }
    else r.pop();//匹配了就弹出该元素
} 
return r.empty();//如果最后栈不为空就会返回false，为空就有效</code></pre>
    <hr/>
    <h2>
     总结
    </h2>
    <p>
     <strong>
      一般来说哈希表都是用来快速判断一个元素是否出现集合里
     </strong>
     。
    </p>
    <p>
     <strong>
      栈用于匹配问题
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37363733393234332f:61727469636c652f64657461696c732f313436323832363535" class_="artid" style="display:none">
 </p>
</div>


