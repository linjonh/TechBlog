---
layout: post
title: "传统算法与遗传算法的特点"
date: 2024-11-26 21:23:42 +0800
description: "传统算法与遗传算法的特点    我们知道，传统的优化方法主要有三种:枚举法、启发式算法和搜索算法:1"
keywords: "传统优化算法和遗传算法的特点"
categories: ['遗传算法']
tags: ['无标签']
artid: "21536171"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=21536171
    alt: "传统算法与遗传算法的特点"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=21536171
featuredImagePreview: https://bing.ee123.net/img/rand?artid=21536171
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     传统算法与遗传算法的特点
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 align="center">
     <span style="font-size:32px">
      传统算法与遗传算法的特点
     </span>
    </h2>
    <p>
     <span style="font-size:14px">
      <span style="font-family:Calibri">
      </span>
      我们知道，传统的优化方法主要有三种
      <span style="font-family:Calibri">
       :
      </span>
      枚举法、启发式算法和搜索算法
      <span style="font-family:Calibri">
       :
      </span>
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      1.
     </span>
     <span style="font-size:14px">
      <strong>
       枚举法：
      </strong>
      枚举出可行解集合内的所有可行解，以求出精确最优解。对于连续函数，该方法要求先对其进行离散化处理。这样就可能因离散处理而永远达不到最优解。此外，当枚举空间比较大时，该方法的求解效率比较低。有时甚至在目前先进计算工具上无法求解。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      2.
     </span>
     <span style="font-size:14px">
      <strong>
       启发式算法：
      </strong>
      寻求一种能产生可行解的启发式规则，以找到一个最优解或近似最优解。该方法的求解效率比较高，但对每一个需求解的问题必须找出其特有的启发式规则，这个启发式规则一般无通用性，不适合于其他问题。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      3.
     </span>
     <span style="font-size:14px">
      <strong>
       搜索算法
      </strong>
      ：寻求一种搜索算法，该算法在可行解集合的一个子集内进行搜索操作，以找到问题的最优解或者近似最优解。该方法虽然保证不了一定能够得到问题的最优解，但若适当地利用一些启发知识，就可在近似解的质量和效率上达到一种较好的平衡。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
     </span>
     随着问题种类的不同以及问题规模的扩大，要寻求一种能以有限的代价来解决搜索和优化的通用方法，遗传算法正是为我们提供的一个有效的途径，它不同于传统的搜索和优化方法。主要区别在于
     <span style="font-family:Calibri">
      :
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      1.
     </span>
     <span style="font-size:14px">
      <strong>
       自组织、自适应和自学习性
       <span style="font-family:Calibri">
        (
       </span>
       智能性
       <span style="font-family:Calibri">
        )
       </span>
      </strong>
      ：应用遗传算法求解问题时，在编码方案、适应度函数及遗传算子确定后，算法将利用进化过程中获得的信息自行组织搜索。由于基于自然的选择策略为“适者生存，不适应者被淘汰”，因而适应度大的个体具有较高的生存概率。通常，适应度大的个体具有更适应环境的基因结构，再通过基因重组和基因突变等遗传操作，就可能产生更适应环境的后代。进化算法的这种自组织、自适应特征，使它同时具有能根据环境变化来自动发现环境的特性和规律的能力、自然选择消除了算法设计过程中的一个最大障碍，即需要事先描述问题的全部特点，并要说明针对问题的不同特点算法应采取的措施。因此，利用遗传算法的方法，我们可以解决那些夏杂的非结构化间题。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      2.
     </span>
     <span style="font-size:14px">
      <strong>
       遗传算法的本质并行性
      </strong>
      ：遗传算法按并行方式搜索一个种群数目的点，而不是单点。它的并行性表现在两个方面，一是
      <u>
       遗传算法是内在并行性
      </u>
      <span style="font-family:Calibri">
       (inherent parallelism).
      </span>
      即遗传算法本身非常适合大规模并行。最简单的并行方式是让几百甚至数千台计算机各自进行独立种群的演化计算
      <span style="font-family:Calibri">
       .
      </span>
      ，运行过程中甚至不进行任何通信
      <span style="font-family:Calibri">
       (
      </span>
      独立的种群之间若有少量的通信一般会带来更好的结果
      <span style="font-family:Calibri">
       )
      </span>
      。等到运算结束时才通信比较，选取最佳个体。这种并行处理方式对并行系统结构没有什么限制和要求，可以说，遗传算法适合在目前所有的并行机或分布式系统上进行并行处理，而且对并行效率没有太大影响。二是
      <u>
       遗传算法的内含并行性
      </u>
      <span style="font-family:Calibri">
       (implicit parallelism)
      </span>
      。由于遗传算法采用种群的方式组织搜索，因而可同时搜索解空间内的多个区域，并相互交流信息。使用这种搜索方式，虽然每次只执行与种群规模
      <span style="font-family:Calibri">
       n
      </span>
      成比例的计算，但实质上已进行了大约
     </span>
     <span style="font-size:14px">
      次有效搜索，这就使遗传算法能以较少的计算获得较大的收益。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      3.
     </span>
     <span style="font-size:14px">
      遗传算法不需要求导或其他辅助知识，而只需要影响搜索方向的目标函数和相应的适应度函数。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      4.
     </span>
     <span style="font-size:14px">
      遗传算法强调慨率转换规则，而不是确定的转换规则。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      5.
     </span>
     <span style="font-size:14px">
      遗传算法可以更加直接地应用。
     </span>
    </p>
    <p>
     <span style="font-family:Calibri; font-size:14px">
      6.
     </span>
     <span style="font-size:14px">
      遗传算法对给定问题，可以产生许多的潜在解，最终选择可以由使用者确定
      <span style="font-family:Calibri">
       (
      </span>
      在某些特殊情况下，如多目标优化问题不止一个解存在，有一组
      <span style="font-family:Calibri">
       pareto
      </span>
      最优解。这种遗传算法对于确认可替代解集而言是特别合适的
      <span style="font-family:Calibri">
       )
      </span>
      。
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f75303132353436343033:2f61727469636c652f64657461696c732f3231353336313731" class_="artid" style="display:none">
 </p>
</div>


