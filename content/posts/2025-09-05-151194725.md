---
layout: post
title: "C语言制作扫雷游戏拓展版赋源码"
date: 2025-09-05T01:47:55+0800
description: "本文介绍了C语言实现扫雷游戏的三个新功能扩展：难度选择、标记功能和区域展开功能。通过修改基础版扫雷代码，新增了难度选择菜单（简单9x9/10雷、中等16x16/40雷、困难30x16/99雷及自定义模式），采用100x100数组兼容不同难度。标记功能实现了右键标记雷区的交互，包含标记/取消标记两种操作。区域展开功能采用DFS算法实现点击空白区域自动展开安全区域的效果。文章详细讲解了各功能实现的代码逻辑，重点说明了递归展开算法的实现方法，最终版本扫雷游戏接近网页版功能，仅缺少计时功能。"
keywords: "C语言制作扫雷游戏（拓展版赋源码）"
categories: ['C']
tags: ['算法', '游戏', 'C']
artid: "151194725"
arturl: "https://blog.csdn.net/lingran__/article/details/151194725"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151194725
    alt: "C语言制作扫雷游戏拓展版赋源码"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151194725
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151194725
cover: https://bing.ee123.net/img/rand?artid=151194725
image: https://bing.ee123.net/img/rand?artid=151194725
img: https://bing.ee123.net/img/rand?artid=151194725
---



# C语言制作扫雷游戏（拓展版赋源码）



**目录**

[引言：](#%E5%BC%95%E8%A8%80%EF%BC%9A)

[三个新功能实现](#%E4%B8%89%E4%B8%AA%E6%96%B0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0)

[1.可以选择难度或自定义](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E9%9A%BE%E5%BA%A6%E6%88%96%E8%87%AA%E5%AE%9A%E4%B9%89)

[实现难点解析](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90)

[代码实现（附源码）](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89)

[扫雷.c](#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%89%AB%E9%9B%B7.c)

[game.h](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20game.h)

[game.c](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20game.c)

[2.对选择位置进行标记或取消标记](#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.%E5%AF%B9%E9%80%89%E6%8B%A9%E4%BD%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E6%A0%87%E8%AE%B0%E6%88%96%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0)

[一.框架](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%B8%80.%E6%A1%86%E6%9E%B6)

[我们先理一下思路](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%88%91%E4%BB%AC%E5%85%88%E7%90%86%E4%B8%80%E4%B8%8B%E6%80%9D%E8%B7%AF)

[如何构造框架](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E6%A1%86%E6%9E%B6)

[二.取消标记函数](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BA%8C.%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0%E5%87%BD%E6%95%B0)

[三.标记函数](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%B8%89.%E6%A0%87%E8%AE%B0%E5%87%BD%E6%95%B0)

[四.加入清屏，进行优化](#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9B%9B.%E5%8A%A0%E5%85%A5%E6%B8%85%E5%B1%8F%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96)

[源码](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%BA%90%E7%A0%81)

[game.c](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20game.c)

[3.点的铺开（相比其他较难）](#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E7%82%B9%E7%9A%84%E9%93%BA%E5%BC%80)

[拓展版源码](#%E6%8B%93%E5%B1%95%E7%89%88%E6%BA%90%E7%A0%81)

[game.h](#game.h)

[game.c](#game.c)

[扫雷.c](#%E6%89%AB%E9%9B%B7.c)

[结语：](#%E7%BB%93%E8%AF%AD%EF%BC%9A)

---

## 引言：

        那么，本篇我们来对之前的基础版扫雷进行拓展，来实现一个相比于网页版的扫雷，只少了一个计时功能的扫雷游戏。总代码量约为450行左右，并不会很多

**那么，没看过扫雷基础篇的请移步[C语言制作扫雷游戏（基础版赋源码）-CSDN博客](https://blog.csdn.net/lingran__/article/details/151135159?spm=1001.2014.3001.5501 "C语言制作扫雷游戏（基础版赋源码）-CSDN博客")看完再来看这篇，因为该篇代码是基于基础版扫雷代码改编而来**

那么，接下来，我们进入正文（红色部分是老代码，绿色为更改后代码，后面就不强调啦）

![](https://i-blog.csdnimg.cn/direct/3173f5840e1b4cd6a680e054526655f4.png)

## 三个新功能实现

**我推荐从上往下依次看这四个功能如何实现**，因为一开始是基础版的源码，然后呢，我会按着一步步的顺序将基础版的源码进行优化与功能实现，**可以把基础版的三个文件的源码复制到你的编译器中，然后跟着我的思路进行更改时，对比也比较清晰**，从上往下看就不会遗漏有些代码的更改与变化，最后的完整代码是一步一步改下来的，那么我们开始 

### 1.可以选择难度或自定义

        首先，我们先进行最简单的一个功能的实现，那就是选择难度与自定义难度，那我们把它拆分成选择难度和自定义难度俩个块来进行处理

#### 

#### 实现难点解析

        首先是选择难度，这个十分简单，我们先来确定一个各个难度的长宽与雷的数量

        在基础篇中，我们是只有一个9*9的格子，然后雷的数量是10个，那么，我们就当这个是easy难度，我是这么设置难度划分的

**简单：9*9的格子，10个雷**

**中等：16*16的格子，40个雷**

**困难：30*16的格子，99个雷**

那么，我们先看**变量**

        在基础版中因为只有一个9*9的格子，所以我们只用了下图中红色区域的代码，用Chang来表示棋盘的长，用Kuan来表示棋盘的宽，Changs和Kuans表示数组的大小，然后用Leisum来表示棋盘中雷的个数

**因为有了不同难度的选择，所以我们可以将宏定义把简单，中等，困难的长度，宽度和雷数都进行定义，然后在之后的程序中因为选择的不同来使用不用的宏名**（宏定义定义的变量）即可，为了方便理解，可以像我这样在前面加上一个前缀E表示简单，M表示中等，H表示困难，如图

![](https://i-blog.csdnimg.cn/direct/ef9a6b87378b4d0bbee3ea0fd2f75d92.png)

        那么，大小方面搞定了，那么数组应该怎么创建呢，如果像基础版那个样子写的话，那数组创建又是个大问题了，这里就有2种方案了，我是用的第二种方案

**一.根据输入的值，选择出难度后，然后创建一个数组，数组中的数字用宏名来顶替，就跟之前基础版的一样，但是，因为有第四种情况，就是自定义的情况，变量可创不了数组（后面传递数组时难以接收，因为你不知道接收时的形参函数部分的列里该写什么，但列又不能省略），所以又要为了第四段专门再写一段代码**，**而且最主要的是，若创建的数组大小不一，那么在调用函数传递数组时候，就需要写多个函数了，会使代码及其冗杂，这就很影响代码的可读性了，而且因为自定义的存在，之后还是会创建第二种方法的数组**，所以我选择的是第二种方法，当然，如果想要用第一种方法的话也可以尝试一下，就是game.c里的代码长度可能会很长

**二.在选择前，先创建100*100的二维数组，这样不管选择哪个难度，都可以进行操作（因为自定义范围肯定会限制，太大不利于游玩，一般都限制在50*16左右）**

  如图，即可

![](https://i-blog.csdnimg.cn/direct/8947fae100024881b49f1078255d4c1b.png)

那么问题都解决了，我们来进行代码实现

#### 代码实现（附源码）

        扫雷.c

        我们先对**扫雷.c**进行操作，对基础版扫雷的框架进行更改，因为有难度选择了，**那我们先自定义一个Level函数用于输出选择难度的菜单**，如图

![](https://i-blog.csdnimg.cn/direct/f5f2c32f89294811a2e9614a922fd18e.png)

        菜单创建完后，接下来就是 **game**函数内部的更改了，代码如下，首先我们先创建四个变量

**input    用于选择难度特判**

**chang和kuan  用于自定义难度时输入长和宽**

**lei        用于自定义难度时雷数量的输入**

      1.接下来我们先使用**do while语句**，让用户根据提示输入信息，若输入有问题就其实用户重新输入，直到按要求输入位置

        2.而后，我们创建俩个数组，只是数组的范围变化了一下，变为了100*100，代表的意思依旧如基础版一样，**cun表示暗盘，show表示明盘**

        3.接下来再通过**switch语句**，根据**input**的值跳转到对应的情况中，**case 1,2,3都是同样的情况，只需要将函数中的参数变一下就可以了**，这部分如何操作以及函数里每个参数分别代表什么在基础版里已经讲过了，就不过多赘述了，**case 4**的自定义也是如此，**只是需要多加上一步输入雷盘的长与宽与雷的个数，并根据输入情况进行反馈，直至符合要求后跳出do while循环**，然后再进行同样的操作即可

        下面就是扫雷.c的源码，其余部分不用变动

```
void Lelve()
{
	printf("************************\n");
	printf("*** 1.easy(9*9 10)   ***\n");
	printf("*** 2.mid(16*16 40)  ***\n");
	printf("*** 3.hard(30*16 99) ***\n");
	printf("*** 4.自定义         ***\n");
	printf("************************\n");
}

void game()
{
	int input = 0;
	int chang = 0, kuan = 0, lei = 0;
	Lelve();
	printf("请选择:");
	do 
	{
		scanf("%d", &input);
		if (input < 1 || input>4)
		{
			printf("输入有误，请重新输入:");
			continue;
		}
		break;
	} while (1);
	char cun[100][100] = { 0 };
	char show[100][100] = { 0 };
	switch (input)
	{
	case 1:
		chu(cun, EKuans, EChangs, '0');
		chu(show, EKuans, EChangs, '*');

		//布置雷
		set(cun, EKuan, EChang, ELeisum);

		//打印棋盘
		print(show, EKuan, EChang);


		//排查雷
		Findlei(cun, show, EKuan, EChang, ELeisum);
		break;

	case 2:
		chu(cun, MKuans, MChangs, '0');
		chu(show, MKuans, MChangs, '*');

		//布置雷
		set(cun, MKuan, MChang, MLeisum);

		//打印棋盘
		print(show, MKuan, MChang);


		//排查雷
		Findlei(cun, show, MKuan, MChang, MLeisum);
		break;

	case 3:
		chu(cun, HKuans, HChangs, '0');
		chu(show, HKuans, HChangs, '*');

		//布置雷
		set(cun, HKuan, HChang, HLeisum);

		//打印棋盘
		print(show, HKuan, HChang);


		//排查雷
		Findlei(cun, show, HKuan, HChang, HLeisum);
		break;

	case 4:
		printf("请输入长度 宽度 雷的个数（长<=50 宽<=16 雷数<长*宽）\n");//过大控制台太小，屏幕会乱跳，不好操控
		do
		{
			scanf("%d %d %d", &chang, &kuan, &lei);
			if (chang > 50 || chang < 1 || kuan>50 || kuan < 1 || chang * kuan <= lei)
			{
				printf("输入有误，请重新输入：");
				continue;
			}
			break;
		} while (1);
		chu(cun, kuan+2, chang+2, '0');
		chu(show, kuan+2, chang+2, '*');

		//布置雷
		set(cun, kuan, chang, lei);


		//打印棋盘
		print(show, kuan, chang);



		//排查雷
		Findlei(cun, show, kuan, chang, lei);
		break;
	}
}
```

        那么扫雷.c里的更改已经完成了，接下来就是通过更改game,h和game.c中的函数来实现即可，那么这边就只是改个参数的事情了，这边就直接放代码啦（**只有Findlie函数部分略有变化，多了一个参数，里面也变了一点点，但很明了，看一眼就知道了，就不多赘述啦**），自己比对一下函数部分哟

        game.h

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define EChang 9//好处是，想更改棋盘大小时候直接改这里就好了，不用在程序里一个个改，方便很多
#define EKuan 9

#define MChang 16
#define MKuan 16

#define HChang 30
#define HKuan 16

#define EChangs EChang+2
#define EKuans EKuan+2

#define MChangs MChang+2
#define MKuans MKuan+2

#define HChangs HChang+2
#define HKuans HKuan+2

#define ELeisum 10
#define MLeisum 40
#define HLeisum 99

void chu(char arr[][100], int hang, int lie, char fu);

void print(char arr[][100], int lie, int hang);

void set(char arr[][100], int hang, int lie, int ge);

void Findlei(char yin[][100], char xian[][100], int lie, int hang, int leisum);
```

        game.c

        game.c中，除了game.h的变化，就只有print函数（**改了输出格式，因为有多位数了，不该输出格式会使打印出来的对不齐**）和FIndlie函数里面发生了略微变化，但因为变化目的很明显，也很易懂，就直接放源码啦

```
#define _CRT_SECURE_NO_WARNINGS
 
#include "game.h"

//初始化棋盘
void chu(char arr[][100],int hang,int lie,char fu)
{
	for (int i = 0; i < hang; i++)
	{
		for (int j = 0; j < lie; j++)
			arr[i][j] = fu;
	}
}

//打印棋盘
void print(char arr[][100], int hang, int lie)
{
	for (int i = 0; i <= lie; i++)
		printf("%d ", i);
		printf("%2d ", i);
	printf("\n");
	for (int i = 1; i <= hang; i++)
	{
		printf("%d ", i);
		printf("%2d ", i);
		for (int j = 1; j <= lie; j++)
			printf("%c ", arr[i][j]);
			printf("%2c ", arr[i][j]);
		printf("\n");
	}
}

//布置雷
void set(char arr[][100],int hang,int lie,int ge)
{
	while (ge--)
	{
		int h = 1 + rand() % hang;
		int l = 1 + rand() % lie;
		if (arr[h][l] == '0')
		{
			arr[h][l] = '1';
		}
		else
			ge++;
	}
}



void Findlei(char yin[][100], char xian[][100], int hang, int lie,int leisum)
{
	int x = 0, y = 0;
	int ge = 0;
	while (1)
	{
		printf("请输入要排查的坐标(行 列)：");
		scanf("%d %d", &x, &y);
		if (x<1 || x>hang || y<1 || y>lie)
			printf("输入的坐标有误，请重新输入:");
		else if (xian[x][y] != '*')
			printf("该坐标已排查过，请重新输入：");
		else
		{
			if (yin[x][y] == '1')
			{
				system("cls");
				printf("很遗憾，你被炸死了，游戏结束\n");
				print(yin, hang, lie);
				break;
			}
			else
			{
				int fang[8][2] = { {0,1},{0,-1},{-1,0},{1,0},{1,1},{1,-1},{-1,1},{-1,-1} };
				xian[x][y] = '0';
				for (int i = 0; i < 8; i++)
				{
					if (yin[x + fang[i][0]][y + fang[i][1]] == '1')
						xian[x][y]++;
				}
				ge++;
				system("cls");
				if (ge + Leisum == Kuan * Chang)
				print(xian, hang, lie);
				if (ge + leisum == hang * lie)
				{
					printf("恭喜你，排雷成功\n");
					break;
				}
			}
		}
	}
}
```

**那么这部分完成后，现在的代码就多出可以选择难度和自定义的功能啦，那么，网页版有插旗子标记，我们也不能少，接下来，我们来讲对棋盘进行标记与取消标记**

![](https://i-blog.csdnimg.cn/direct/d617adcd623f40b6a29a9c0b610b6c2b.png)

---

### 2.对选择位置进行标记或取消标记

**这一部分在game.c里实现**

        那么这部分开始就比较要吃点逻辑了，我打算分三步来讲，先把框架讲清楚后，再分别讲标记与取消标记这俩个函数

#### 一.框架

**我们先理一下思路**

        总所周知，在我们原先的代码里，我们不管进不进行模式选择，到最后都会输出一次棋盘，然后再进入Findlei函数之中，

        那么我们想要在排查雷之前，先询问一下意向，是排雷，还是标点，还是取消标点，这块部分，就可以在Findlei函数中实现，只需要放在排雷的前面执行即可；

        然后因为在网页游戏中，玩扫雷标点是想标就标，想把标的点去掉就去掉，然后或者进行扫雷，扫雷前可以无限次的进行标点或者取消标点，只要标点的数量不超过雷的数量即可

        那么大致要求已经说完了，我们来看看怎么打，首先来看下我的代码，如图，我们结合代码来分析（红绿代码更有辨识度，就用图片了）

        如何构造框架

        我们多创建2个变量

        biaoji        代表目前盘上标记的个数

        input        用于特判标记还是取消标记还是排雷

        首先，依旧是跟一样的while语句，知识要在排雷前进行选择的操作，那么，我们就要给他菜单，即代码中的Choose函数

        然后因为要进行提示，并且判断输入是否合理，合理的话就进行对应的操作，这个时候我们就用到了我们的**do while循环来判断输入的合理性**和我们的**switch语句来进入要执行对应操作的分支语句，以及通过biaoji的值的变化来判断是否符合要求。**

![](https://i-blog.csdnimg.cn/direct/2a8ac29a8fef45b9aeb497ca22eef3e1.png)

![](https://i-blog.csdnimg.cn/direct/e7fde2faa6a14ac1b3396aaca25e70d2.png)

**执行完这些操作后，代码的框架就基本构筑完成了，代码中的Biaolei函数便是标记雷函数的具体实现，Clearlei函数便是取消标记雷的具体实现，因为取消标记雷更好实现，那我们先讲取消标记函数**

#### 二.取消标记函数

        取消标记函数我们只需要做到在这个函数中先命名俩个变量

        我就命名了x,y来表示坐标

        然后进入while循环，提示输入取消标记的坐标，直至输入的坐标符合要求，就跳出循环，将对应的那个点位赋值为 ' * '即可，最后在进行一次打印就可以了，因为若进入了这个语句，就不会去排雷的部分，自然就不会打印了，所以需要在这边写上print函数来打印暗盘

       代码如下，十分简单         ![](https://i-blog.csdnimg.cn/direct/efbf7c8d415b46ad9ecf09fe870af087.png)

#### 三.标记函数

        如果取消标记函数弄懂了，再看这个就会简单很多，这个函数就是需要多一层操作

        先给代码，然后我来围绕代码来讲，应该更容易懂

        首先，先创建三个变量

        一个x,一个y，用来表示想要标记的坐标

        还有一个type  用来表示判断想要标记的坐标类型是？还是！

        然后套一层while循环，若输入不满足要求，就反馈相应信息要求重新输入，直到满足要求为止，跳出循环

        跳出循环后，进入menubiao函数，给出提示，然后依旧与往常一样，用while循环套上，进行输入，直到输入满足条件跳出

        然后用switch语句进行跳转，进入想要执行的语句中，然后通过x,y的坐标，将那个位置的明盘上的‘*’赋值成对应符号

        最后再进行一次输出，即可，至于为什么要输出一次明盘，原因和取消标记函数里一样

![](https://i-blog.csdnimg.cn/direct/b7d7fc0fadb045658b070e1022d40b5e.png)

![](https://i-blog.csdnimg.cn/direct/36babb74672b475abb69db12c66d58c3.png)

#### 四.加入清屏，进行优化

        这个功能到这里来说就已经实现完毕了，但我们在运行时，会发现输出会很乱，这时候，就要稍稍改变一下代码的顺序，再插入清屏，实现运行代码时的那种清爽感了，这里就不细讲啦，跟着下面的代码看，很容易就理解啦

![](https://i-blog.csdnimg.cn/direct/cd3c66b2c42c438f8c62cf6e44923b56.png)

![](https://i-blog.csdnimg.cn/direct/24d2c186f066408b838ab09b5797882e.png)

![](https://i-blog.csdnimg.cn/direct/9a38a64dd55243e69ea514697675b728.png)

那么，对选择位置进行标记或取消标记的这个功能也实现啦，我把实现这个功能后的源码发出来

#### 源码

**因为这个功能并没有改动game.c与扫雷.c，那俩个的码就不发啦**

        game.c

```
#define _CRT_SECURE_NO_WARNINGS

#include "game.h"

//初始化棋盘
void chu(char arr[][100], int hang, int lie, char fu)
{
	for (int i = 0; i < hang; i++)
	{
		for (int j = 0; j < lie; j++)
			arr[i][j] = fu;
	}
}

//打印棋盘
void print(char arr[][100], int hang, int lie)
{
	for (int i = 0; i <= lie; i++)
		printf("%2d ", i);
	printf("\n");
	for (int i = 1; i <= hang; i++)
	{
		printf("%2d ", i);
		for (int j = 1; j <= lie; j++)
			printf("%2c ", arr[i][j]);
		printf("\n");
	}
}

//布置雷
void set(char arr[][100], int hang, int lie, int ge)
{
	while (ge--)
	{
		int h = 1 + rand() % hang;
		int l = 1 + rand() % lie;
		if (arr[h][l] == '0')
		{
			arr[h][l] = '1';
		}
		else
			ge++;
	}
}


static void Choose()
{
	printf("******************\n");
	printf("*** 1.标记     ***\n");
	printf("*** 2.取消标记 ***\n");
	printf("*** 0.排雷     ***\n");
	printf("******************\n");
}

static void menubiao()
{
	printf("*********************\n");
	printf("**** 1.?(不确定) ****\n");
	printf("**** 2.！(肯定)  ****\n");
	printf("*********************\n");
}

//标记雷
void Biaolei(char arr[][100], int hang, int lie)
{
	int x = 0, y = 0;
	int type = 0;
	while (1)
	{
		printf("请输入要标记的坐标：");
		scanf("%d %d", &x, &y);
		if (x<1 || x>hang || y<1 || y>lie)
		{
			printf("输入的坐标有误，请重新输入\n");
			continue;
		}
		else if (arr[x][y] == '?' || arr[x][y] == '!')
		{
			printf("该位置已被标记，请重新输入\n");
			continue;
		}
		else if (arr[x][y] != '*')
		{
			printf("该坐标已被排查，无法标记，请重新输入\n");
			continue;
		}
		break;
	}
	menubiao();
	do
	{
		printf("请输入要标记的类型：");
		scanf("%d", &type);
		if (type != 1 && type != 2)
		{
			printf("不存在该选项，请重新输入\n");
			continue;
		}
		break;
	} while (1);

	switch (type)
	{
	case 1:
		arr[x][y] = '?';
		print(arr, hang, lie);
		break;
	case 2:
		arr[x][y] = '!';
		print(arr, hang, lie);
		break;
	}
}

//取消标记雷
void Clearlei(char arr[][100], int hang, int lie)
{
	int x = 0, y = 0;
	int type = 0;
	while (1)
	{
		printf("请输入要取消标记的坐标：");
		scanf("%d %d", &x, &y);
		if (x<1 || x>hang || y<1 || y>lie)
		{
			printf("输入的坐标有误，请重新输入\n");
			continue;
		}
		else if (arr[x][y] != '?' && arr[x][y] != '!')
		{
			printf("该位置未被标记，请重新输入\n");
			continue;
		}
		break;
	}
	arr[x][y] = '*';
	print(arr, hang, lie);
}

//排查，标记雷
void Findlei(char yin[][100], char xian[][100], int hang, int lie, int leisum)
{
	int x = 0, y = 0;
	int ge = 0;
	int biaoji = 0;
	int input = 0;

	while (1)
	{
		do
		{
			system("cls");
			print(xian, hang, lie);
			Choose();
			printf("请选择：");
			scanf("%d", &input);
			if (input != 1 && input != 2 && input != 0)
			{
				printf("输入有误，请重新输入\n");
			}
			if (biaoji >= leisum && input == 1)
			{
				printf("标记个数已超出雷数，请重新选择\n");
				continue;
			}
			if (biaoji <= 0 && input == 2)
			{
				printf("已经没有可以取消标记的点了，请重新选择\n");
				continue;
			}
			switch (input)
			{
			case 1:
				Biaolei(xian, hang, lie);
				biaoji++;
				break;
			case 2:
				Clearlei(xian, hang, lie);
				biaoji--;
				break;
			default:
				break;
			}
		} while (input);
		
		do
		{
			printf("请输入要排查的坐标(行 列)：");
			scanf("%d %d", &x, &y);
			if (x<1 || x>hang || y<1 || y>lie)
			{
				printf("输入的坐标有误，请重新输入\n");
				continue;
			}
			else if (xian[x][y] == '?' || xian[x][y] == '!')
			{
				printf("该位置已被标记，请重新输入\n");
				continue;
			}
			else if (xian[x][y] != '*')
			{
				printf("该坐标已排查过，请重新输入\n");
				continue;
			}
			break;
		} while (1);

		if (yin[x][y] == '1')
		{
			system("cls");
			printf("很遗憾，你被炸死了，游戏结束\n");
			print(yin, hang, lie);
			break;
		}
		else
		{
			int fang[8][2] = { {0,1},{0,-1},{-1,0},{1,0},{1,1},{1,-1},{-1,1},{-1,-1} };
			xian[x][y] = '0';
			for (int i = 0; i < 8; i++)
			{
				if (yin[x + fang[i][0]][y + fang[i][1]] == '1')
					xian[x][y]++;
			}
			ge++;
			system("cls");
			print(xian, hang, lie);
			if (ge + leisum == hang * lie)
			{
				printf("恭喜你，排雷成功\n");
				break;
			}
		}
	}
}
```

那么，这个功能也结束啦，最后一个功能，也是最难的一个功能，那便是实现像网页版那样的点一个点，铺开一片。

![](https://i-blog.csdnimg.cn/direct/66024e231b3a4b86bd58dd8ad8bdf98d.png)

---

### 3.点的铺开（相比其他较难）

        这个部分的实现用到了函数的递归，也涉及一点的算法，**与前俩个部分相比，这个功能的实现呈指数型上升，因为搜索这个知识具体来讲的话在这篇文章里很难讲清楚，所以这里我主要是讲思路，然后dfs,bfs这种搜索有空我会专门出一篇来讲解，所以，如果初学者代码没看懂也没关系，**我用的是**深度搜索（即dfs）**来实现这个功能的

**首先，因为我们实现这个为了使内存损耗小，需要用到bool类型的数组，所以我们需要先在game.h的头文件内加入#include <stdbool.h>这一行代码**

        ok，说回正题，这个部分，虽然是这三个功能中最难实现的，但代码却是最简短的，如图，上图是自定义函数，下图是Findlei函数中略微改变的部分。

        那么，我来简单说下这部分的思路，首先将方位数组（就那个fang数组）放在全局变量中，这样可以保证进入zhanlei函数时也可以使用，然后将当前坐标的访问标记成1，然后算出当前坐标附近有没有雷，如果有雷，就不进入函数，如果没雷，就进入zhanlei函数，然后通过八个方位来进行深搜，然后深搜过程中也不能忘了排雷个数的++,然后当程序运行完后，就展开一片了，函数功能也就实现了

![](https://i-blog.csdnimg.cn/direct/2dc16ea7debd47428bdb247f56e1485a.png)

![](https://i-blog.csdnimg.cn/direct/eea70865dda84c6aa24d8fdbc3370f07.png)

当然，如果直接这样就结束，肯定也会有bug,就比如如果雷的个数在展开的那个函数中加到了排雷要求数，他判断排雷成功后，会直接输出明盘，但其实明盘那时候还并不是扫雷的最终结果，所以要输出暗盘，所以只需要再补上这么一行就可以啦

![](https://i-blog.csdnimg.cn/direct/7ad9791850a641ed9d2d2ad4dc846819.png)

         那么，到此，扫雷的所有功能讲解就全部讲完啦，接下来，最终版源码附上

![](https://i-blog.csdnimg.cn/direct/bbbd54cc97314a80a877ac536a41efe2.png)

## 拓展版源码

### game.h

```
#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>
#define EChang 9//好处是，想更改棋盘大小时候直接改这里就好了，不用在程序里一个个改，方便很多
#define EKuan 9

#define MChang 16
#define MKuan 16

#define HChang 30
#define HKuan 16

#define EChangs EChang+2
#define EKuans EKuan+2

#define MChangs MChang+2
#define MKuans MKuan+2

#define HChangs HChang+2
#define HKuans HKuan+2

#define ELeisum 10
#define MLeisum 40
#define HLeisum 99

void chu(char arr[][100], int hang, int lie, char fu);

void print(char arr[][100], int lie, int hang);

void set(char arr[][100], int hang, int lie, int ge);

void Findlei(char yin[][100], char xian[][100], int lie, int hang, int leisum);
```

### game.c

```
#define _CRT_SECURE_NO_WARNINGS

#include "game.h"

//初始化棋盘
void chu(char arr[][100],int hang,int lie,char fu)
{
	for (int i = 0; i < hang; i++)
	{
		for (int j = 0; j < lie; j++)
			arr[i][j] = fu;
	}
}

//打印棋盘
void print(char arr[][100], int hang, int lie)
{
	for (int i = 0; i <= lie; i++)
		printf("%2d ", i);
	printf("\n");
	for (int i = 1; i <= hang; i++)
	{
		printf("%2d ", i);
		for (int j = 1; j <= lie; j++)
			printf("%2c ", arr[i][j]);
		printf("\n");
	}
}

//布置雷
void set(char arr[][100],int hang,int lie,int ge)
{
	while (ge--)
	{
		int h = 1 + rand() % hang;
		int l = 1 + rand() % lie;
		if (arr[h][l] == '0')
		{
			arr[h][l] = '1';
		}
		else
			ge++;
	}
}


static void Choose()
{
	printf("******************\n");
	printf("*** 1.标记     ***\n");
	printf("*** 2.取消标记 ***\n");
	printf("*** 0.排雷     ***\n");
	printf("******************\n");
}

static void menubiao()
{
	printf("*********************\n");
	printf("**** 1.?(不确定) ****\n");
	printf("**** 2.！(肯定)  ****\n");
	printf("*********************\n");
}

//标记雷
void Biaolei(char arr[][100],int hang,int lie)
{
	int x = 0, y = 0;
	int type = 0;
	while (1)
	{
		printf("请输入要标记的坐标：");
		scanf("%d %d", &x, &y);
		if (x<1 || x>hang || y<1 || y>lie)
		{
			printf("输入的坐标有误，请重新输入\n");
			continue;
		}
		else if (arr[x][y] == '?' || arr[x][y] == '!')
		{
			printf("该位置已被标记，请重新输入\n");
			continue;
		}
		else if (arr[x][y] != '*')
		{
			printf("该坐标已被排查，无法标记，请重新输入\n");
			continue;
		}
		break;
	}
	menubiao();
	do
	{
		printf("请输入要标记的类型：");
		scanf("%d", &type);
		if (type != 1 && type != 2)
		{
			printf("不存在该选项，请重新输入\n");
			continue;
		}
		break;
	} while (1);

	switch (type)
	{
	case 1:
		arr[x][y] = '?';
		print(arr, hang, lie);
		break;
	case 2:
		arr[x][y] = '!';
		print(arr, hang, lie);
		break;
	}
}

//取消标记雷
void Clearlei(char arr[][100], int hang, int lie)
{
	int x = 0, y = 0;
	int type = 0;
	while (1)
	{
		printf("请输入要取消标记的坐标：");
		scanf("%d %d", &x, &y);
		if (x<1 || x>hang || y<1 || y>lie)
		{
			printf("输入的坐标有误，请重新输入\n");
			continue;
		}
		else if (arr[x][y] != '?' && arr[x][y] != '!')
		{
			printf("该位置未被标记，请重新输入\n");
			continue;
		}
		break;
	}
	arr[x][y] = '*';
	print(arr, hang, lie);
}

//展开
bool vis[100][100];
int fang[8][2] = { {0,1},{0,-1},{-1,0},{1,0},{1,1},{1,-1},{-1,1},{-1,-1} };
void zhanlei(char yin[][100], char xian[][100], int hang, int lie, int x, int y, int* ge)
{
	if (xian[x][y] != '0')
		return;
	for (int i = 0; i < 8; i++)
	{
		int x1 = x + fang[i][0];
		int y1 = y + fang[i][1];
		if (!vis[x1][y1] && yin[x1][y1] != '1' && x1 >= 1 && x1 <= hang && y1 >= 1 && y1 <= lie)
		{
			(*ge)++;
			xian[x1][y1] = '0';
			vis[x1][y1] = 1;
			for (int i = 0; i < 8; i++)
			{
				if (yin[x1 + fang[i][0]][y1 + fang[i][1]] == '1')
					xian[x1][y1]++;
			}
			zhanlei(yin, xian, hang, lie, x1, y1, ge);
		}
	}
}

//排查雷
void Findlei(char yin[][100], char xian[][100], int hang, int lie,int leisum)
{
	int x = 0, y = 0;
	int ge = 0;
	int biaoji = 0;
	int input = 0;

	while (1)
	{
		do
		{
			system("cls");
			print(xian, hang, lie);
			Choose();
			printf("请选择：");
			scanf("%d", &input);
			if (input != 1 && input != 2 && input != 0)
			{
				printf("输入有误，请重新输入\n");
			}
			if (biaoji >= leisum && input == 1)
			{
				printf("标记个数已超出雷数，请重新选择\n");
				continue;
			}
			if (biaoji <= 0 && input == 2)
			{
				printf("已经没有可以取消标记的点了，请重新选择\n");
				continue;
			}
			switch (input)
			{
			case 1:
				Biaolei(xian, hang, lie);
				biaoji++;
				break;
			case 2:
				Clearlei(xian, hang, lie);
				biaoji--;
				break;
			default:
				break;
			}
		} while (input);

		do
		{
			printf("请输入要排查的坐标(行 列)：");
			scanf("%d %d", &x, &y);
			if (x<1 || x>hang || y<1 || y>lie)
			{
				printf("输入的坐标有误，请重新输入\n");
				continue;
			}
			else if (xian[x][y] == '?' || xian[x][y] == '!')
			{
				printf("该位置已被标记，请重新输入\n");
				continue;
			}
			else if (xian[x][y] != '*')
			{
				printf("该坐标已排查过，请重新输入\n");
				continue;
			}
			break;
		} while (1);

		if (yin[x][y] == '1')
		{
			system("cls");
			printf("很遗憾，你被炸死了，游戏结束\n");
			print(yin, hang, lie);
			break;
		}
		else
		{
			xian[x][y] = '0';
			vis[x][y] = 1;
			for (int i = 0; i < 8; i++)
			{
				if (yin[x + fang[i][0]][y + fang[i][1]] == '1')
					xian[x][y]++;
			}
			ge++;
			if(xian[x][y]=='0')
				zhanlei(yin, xian, hang, lie, x, y, &ge);
			system("cls");
			print(xian, hang, lie);
			if (ge + leisum == hang * lie)
			{
				system("cls");
				print(yin, hang, lie);
				printf("恭喜你，排雷成功\n");
				break;
			}
		}

	}
}
```

### 扫雷.c

```
#define _CRT_SECURE_NO_WARNINGS

#include "game.h"
void menu()
{
	printf("********************\n");
	printf("*****  1.play  *****\n");
	printf("*****  0.exit  *****\n");
	printf("********************\n");
}

void Lelve()
{
	printf("************************\n");
	printf("*** 1.easy(9*9 10)   ***\n");
	printf("*** 2.mid(16*16 40)  ***\n");
	printf("*** 3.hard(30*16 99) ***\n");
	printf("*** 4.自定义         ***\n");
	printf("************************\n");
}

void game()
{
	//初始化函数
	int input = 0;
	int chang = 0, kuan = 0, lei = 0;
	Lelve();
	printf("请选择:");
	do 
	{
		scanf("%d", &input);
		if (input < 1 || input>4)
		{
			printf("输入有误，请重新输入:");
			continue;
		}
		break;
	} while (1);
	char cun[100][100] = { 0 };
	char show[100][100] = { 0 };
	switch (input)
	{
	case 1:
		chu(cun, EKuans, EChangs, '0');
		chu(show, EKuans, EChangs, '*');

		//布置雷
		set(cun, EKuan, EChang, ELeisum);

		//打印棋盘
		print(show, EKuan, EChang);


		//排查雷，标记雷
		Findlei(cun, show, EKuan, EChang, ELeisum);
		break;

	case 2:
		chu(cun, MKuans, MChangs, '0');
		chu(show, MKuans, MChangs, '*');

		//布置雷
		set(cun, MKuan, MChang, MLeisum);

		//打印棋盘
		print(show, MKuan, MChang);


		//排查雷
		Findlei(cun, show, MKuan, MChang, MLeisum);
		break;

	case 3:
		chu(cun, HKuans, HChangs, '0');
		chu(show, HKuans, HChangs, '*');

		//布置雷
		set(cun, HKuan, HChang, HLeisum);

		//打印棋盘
		print(show, HKuan, HChang);


		//排查雷
		Findlei(cun, show, HKuan, HChang, HLeisum);
		break;

	case 4:
		printf("请输入长度 宽度 雷的个数（长<=50 宽<=16 雷数<长*宽）\n");//过大控制台太小，屏幕会乱跳，不好操控
		do
		{
			scanf("%d %d %d", &chang, &kuan, &lei);
			if (chang > 50 || chang < 1 || kuan>50 || kuan < 1 || chang * kuan <= lei)
			{
				printf("输入有误，请重新输入：");
				continue;
			}
			break;
		} while (1);
		chu(cun, kuan+2, chang+2, '0');
		chu(show, kuan+2, chang+2, '*');

		//布置雷
		set(cun, kuan, chang, lei);

		//打印棋盘
		print(show, kuan, chang);


		//排查雷
		Findlei(cun, show, kuan, chang, lei);
		break;
	}
}

void test()
{
	srand((unsigned int)time(NULL));
	int input = 0;
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			system("cls");
			printf("游戏开始\n");
			game();
			break;
		case 0:
			system("cls");
			printf("欢迎下次游玩\n");
			break;
		default:
			printf("输入错误，请重新输入\n");
			break;
		}
	} while (input);
}

int main()
{
	test();
	return 0;
}
```

## 结语：

        那么本篇文章的内容就到此为止啦，希望对你有所帮助，谢谢观看啦，如果觉得有帮助可以转发给朋友一起看哟，毕竟一个人走的快，一群人走的远嘛，有竞争对手才有动力嘛

![](https://i-blog.csdnimg.cn/direct/eab9909c5f4f44048d640b1fd85c5e0c.png)



