---
layout: post
title: "MySQL是怎么运行的二索引"
date: 2025-03-11 01:43:19 +0800
description: "引擎层有支持索引，如InnoDB和MyISAM，区别就是InnoDB支持事务、外键和行锁。"
keywords: "【MySQL是怎么运行的】二、索引"
categories: ['Sql']
tags: ['数据库', 'Mysql', 'Android']
artid: "145866965"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145866965
    alt: "MySQL是怎么运行的二索引"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145866965
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145866965
cover: https://bing.ee123.net/img/rand?artid=145866965
image: https://bing.ee123.net/img/rand?artid=145866965
img: https://bing.ee123.net/img/rand?artid=145866965
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【MySQL是怎么运行的】二、索引
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     引擎层有支持索引，如InnoDB和MyISAM，区别就是InnoDB支持事务、外键和行锁
    </p>
    <h2>
     <a id="_1">
     </a>
     索引物理结构
    </h2>
    <p>
     页：一页16KB，一页包含了多行记录
     <br/>
     行：包含元数据和真实数据
     <br/>
     元数据：
    </p>
    <ol>
     <li>
      record_type（记录的类型，0-普通，1-目录项，2-最小，3-最大）
     </li>
     <li>
      next_record(下一条记录)
      <br/>
      真实数据：c1，c2，c3，其他信息
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e04af81fcf58401083b20cc2bf8f3637.png"/>
     </li>
    </ol>
    <pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> s1
<span class="token punctuation">(</span>
    id           <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    key1         <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key2         <span class="token keyword">INT</span><span class="token punctuation">,</span>
    key3         <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part1    <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part2    <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part3    <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    common_field <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> idx_key2 <span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key3 <span class="token punctuation">(</span>key3<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">,</span> key_part3<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span>
  <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span>
</code></pre>
    <p>
     上述的表一行占用的大小为：
     <br/>
     **元数据：**行头信息5B+事务ID6B+回滚指针7B+7个边长字段7B=25B
     <br/>
     **真实数据：**id和key2是int类型，固定4B，其他字段都是varchar类型100
     <em>
      3+1=301B。总共4B+301B
     </em>
     7=1814B
     <br/>
     总计：1814B+25B=1839B≈1.8KB
    </p>
    <h2>
     <a id="_33">
     </a>
     索引设计原则
    </h2>
    <ol>
     <li>
      读多写少的字段，如mtime就不行
     </li>
     <li>
      数据量较大（100w）、查询比较频繁（where，group by）的表建立索引，不建议db排序
     </li>
     <li>
      尽量选择区分度高的列（如身份证号，性别不行，重复度大于10%也不行）作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
     </li>
     <li>
      字符串类型的字段，字段的长度较长，考虑前缀索引
     </li>
     <li>
      尽量使用联合索引，较少单例索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
     </li>
    </ol>
    <h2>
     <a id="_39">
     </a>
     索引失效场景
    </h2>
    <ol>
     <li>
      不符合最左匹配原则、模糊查询%加在前面
     </li>
     <li>
      索引上有函数或类型不匹配
     </li>
     <li>
      &lt;&gt;, or两侧有非索引字段
     </li>
    </ol>
    <h2>
     <a id="_43">
     </a>
     索引判断姿势
    </h2>
    <p>
     explain sql
     <br/>
     type：针对单表的访问方法
    </p>
    <ol>
     <li>
      <p>
       结果值从最好到最坏依次是:
       <br/>
       system &gt; ⭐️const️ &gt; eq_ref &gt; ⭐️ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; ⭐️range（底线） &gt; index &gt; ALL
       <br/>
       const️：唯一键等于，如select * from s1 where key2=?
       <br/>
       ref: 二级索引等于，如select * from s1 where key3=?
       <br/>
       range: 范围查询，如select * from s1 where key3 in (?,?)
      </p>
     </li>
     <li>
      <p>
       rows
       <br/>
       预估的需要读取的记录条数，走索引后的筛选出来的行数,值越小越好，代表走索引筛选的数量多，索引效率高
      </p>
     </li>
     <li>
      <p>
       filtered
       <br/>
       某个表经过搜索条件过滤后剩余记录条数的百分比，值越大越好，代表大多数结果都是通过索引查出来的，而不是服务层筛选的
      </p>
     </li>
     <li>
      <p>
       Extra
       <br/>
       一些额外的信息
      </p>
     </li>
    </ol>
    <ul>
     <li>
      Using where: 当我们使用全表扫描来执行对某个表的查询，并且该语句的
      <code>
       WHERE
      </code>
      子句中有针对该表的搜索条件时
     </li>
     <li>
      Using index: 使用了覆盖索引
     </li>
     <li>
      Using index condition：使用了索引下推
     </li>
     <li>
      Using union：索引合并，使用多个索引来取交集、并集后进行回表的优化操作
     </li>
     <li>
      Using filesort：文件排序，出现这个说明sql中有排序字段，要避免
     </li>
    </ul>
    <h2>
     <a id="_66">
     </a>
     索引如何优化
    </h2>
    <ol>
     <li>
      没索引就建索引
     </li>
     <li>
      有索引但失效了就改sql，让索引生效。或强制InnoDB走预期索引
     </li>
    </ol>
    <h2>
     <a id="sql_69">
     </a>
     慢sql
    </h2>
    <p>
     慢sql包含读和写，一般超过100ms的执行时间我们都认为是慢sql。
     <br/>
     慢查一般从索引方向治理
     <br/>
     慢写一般从锁方向治理
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343438343636382f:61727469636c652f64657461696c732f313435383636393635" class_="artid" style="display:none">
 </p>
</div>


