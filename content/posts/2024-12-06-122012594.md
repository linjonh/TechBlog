---
layout: post
title: "java.lang.OutOfMemoryError-unable-to-create-new-native-thread"
date: 2024-12-06 12:47:53 +0800
description: "java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOf"
keywords: "java.lang.outofmemoryerror: unable to create new native thread"
categories: ['Linux']
tags: ['开发语言', '后端', 'Jvm', 'Java']
artid: "122012594"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122012594
    alt: "java.lang.OutOfMemoryError-unable-to-create-new-native-thread"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=122012594
featuredImagePreview: https://bing.ee123.net/img/rand?artid=122012594
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java.lang.OutOfMemoryError: unable to create new native thread
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOfMemoryError: unable to create new native thread是很常见的一种，这类错误通常发生在应用试图创建新线程时。
    </p>
    <p>
     <strong>
      可能原因
     </strong>
    </p>
    <ol>
     <li>
      系统内存耗尽，无法为新线程分配内存
     </li>
     <li>
      你的应用创建太多线程，创建线程数超过了操作系统的承受得限制
     </li>
     <li>
      你的服务器并不允许你的应用程序创建这么多线程，linux系统默认允许单个进程可以创建的线程数是1024个，你的应用创建超过这个数量，就会报java.lang.OutOfMemoryError: unable to create new native thread异常。
     </li>
    </ol>
    <p>
     <strong>
      分析命令
     </strong>
    </p>
    <p>
     <span style="color:#0d0016;">
      <span style="background-color:#ff9900;">
       注意：是在当前使用得用户下排查：因为同账号会不会有不同限制
      </span>
     </span>
     <br/>
     1.我们用ulimit命令查看一下系统的对进程资源的控制：
    </p>
    <pre><code class="language-java">#查看当前用户进程资源最大限制
ulimit –u

#查看更多详情的话，可以用这个命令
ulimit -a

#进程可用最大虚拟内存
ulimit -v

#最大栈大小
ulimit -s</code></pre>
    <p>
     输出如下：
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/ea62c5c4cb9bf8f86f80725e1a71f51a.png"/>
    </p>
    <p>
     2.查看当前用户创建了多少线程：
    </p>
    <pre><code>#查看系统现在的线程数命令
ps -eLf | wc -l
1413</code></pre>
    <p>
     从上图可以看出，似乎是
     <strong>
      max user processes
     </strong>
     数不足？
     <br/>
     3.使用ulimit 命令,把
     <strong>
      max user processes
     </strong>
     放大一倍试试：
    </p>
    <pre><code>ulimit -u 2048</code></pre>
    <p style="text-align:center;">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/0d450f631ea1572378eff75aa06c8e47.png"/>
    </p>
    <p>
     问题接解决
    </p>
    <p>
     另外一种方法：
    </p>
    <p>
     (因为我这里只是想临时改变当前shell的设置，要是想永久设置要修改/etc/security/limits.conf文件或者/etc/security/limits.d/20-nproc.conf)。
    </p>
    <p>
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/blog_migrate/74bf2757babd9e3e2ba3af3cc4b478d3.png" width="481">
      <br/>
      <span style="color:#fe2c24;">
       <strong>
        重点：
       </strong>
      </span>
      虽然对iibs和root设置了unlimited，但是也不意味着可以无限增长，因为这个最大可用量是系统决定的，它的具体值受到物理内存页个数等限制
     </img>
    </p>
    <p>
     <strong>
      解决方案
     </strong>
    </p>
    <p>
     1. 排查应用是否创建了过多的线程
    </p>
    <p>
     通过jstack确定应用创建了多少线程？超量创建的线程的堆栈信息是怎样的？谁创建了这些线程？一旦明确了这些问题，便很容易解决。
    </p>
    <p>
     2. 调整操作系统线程数阈值
     <br/>
     操作系统会限制进程允许创建的线程数，使用ulimit -u命令查看限制。某些服务器上此阈值设置的过小，比如1024。一旦应用创建超过1024个线程，就会遇到java.lang.OutOfMemoryError: unable to create new native thread问题。如果是这种情况，可以调大操作系统线程数阈值。
     <br/>
     <br/>
     3. 增加机器内存
     <br/>
     如果上述两项未能排除问题，可能是正常增长的业务确实需要更多内存来创建更多线程。如果是这种情况，增加机器内存。
     <br/>
     <br/>
     4. 减小堆内存
     <br/>
     一个老司机也经常忽略的非常重要的知识点：在JAVA语言里，你创建一个线程，会在JVM内存创建一个内存对象的同时创建一个操作系统线程，而这个系统线程的内存不是使用JVM内存的，而是使用系统中剩下的内存建立的。也就是你给JVM内存越多，那么你能创建的线程数就越少，也就是越容易发生这个异常。这就说明不是JVM内存不够，而是因为线程消耗的是系统内存，那么系统内存充裕但是依然创建失败，所以一定是其他方面有问题。因为任何系统可以运行的线程数量都有有限的。线程不在堆内存上创建，线程在堆内存之外的内存上创建。所以如果分配了堆内存之后只剩下很少的可用内存，依然可能遇到java.lang.OutOfMemoryError: unable to create new native thread。考虑如下场景：系统总内存6G，堆内存分配了5G，永久代512M。在这种情况下，JVM占用了5.5G内存，系统进程、其他用户进程和线程将共用剩下的0.5G内存，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减小堆内存。
    </p>
    <p>
     (MaxProcessMemory – JVMMemory – ResverdOsMemory)/ ThreadStackSizk = 线程数量
     <br/>
     MaxProcessMemory：一个进程最多使用的内存大小
     <br/>
     JVMMemory：JVM的Heap大小，也就是堆，因为你也只能设置堆的大小，这个的值是堆的最小值+PermGen的大小
     <br/>
     ResverdOsMemory：操作系统保留的内存，也就是内核使用的，一般为120M。
     <br/>
     ThreadStackSizk：线程栈的大小，单位为字节byte 所以上面的公式要统一换成字节来计算。系统有64G内存，就算不适用公式计算也应该知道内存是绝对够用的。那到底是什么问题？
     <br/>
     <br/>
     5. 减少进程数
     <br/>
     这和减小堆内存原理相似。考虑如下场景：系统总内存32G，java进程数5个，每个进程的堆内存6G。在这种情况下，java进程总共占用30G内存，仅剩下2G内存用于系统进程、其他用户进程和线程，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减少每台机器上的进程数。
    </p>
    <p>
     <br/>
     6. 减小单个线程栈大小（-Xss参数设置）
    </p>
    <p>
     线程会占用内存，如果每个线程都占用更多内存，整体上将消耗更多的内存。每个线程默认占用内存大小取决于JVM实现。可以利用-Xss参数限制线程内存大小，降低总内存消耗。例如，JVM默认每个线程占用1M内存，应用有500个线程，那么将消耗500M内存空间。如果实际上256K内存足够线程正常运行，配置-Xss256k，那么500个线程将只需要消耗125M内存。（注意，如果-Xss设置的过低，将会产生java.lang.StackOverflowError错误）
    </p>
    <p>
     <strong>
      参考：
     </strong>
    </p>
    <p>
     https://blog.fastthread.io/2016/07/06/troubleshoot-outofmemoryerror-unable-to-create-new-native-thread/
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_30642305/article/details/94924279?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.fixedcolumn&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.fixedcolumn" title="java.lang.OutOfMemoryError: unable to create new native thread问题排查以及当前系统最大进程数量..._weixin_30642305的博客-CSDN博客">
      java.lang.OutOfMemoryError: unable to create new native thread问题排查以及当前系统最大进程数量..._weixin_30642305的博客-CSDN博客
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f476f6447726561743139393338332f:61727469636c652f64657461696c732f313232303132353934" class_="artid" style="display:none">
 </p>
</div>


