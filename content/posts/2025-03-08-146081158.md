---
layout: post
title: "Linux-信号"
date: 2025-03-08 14:49:57 +0800
description: "本篇文章主要带大家学习了Linux信号的基本概念，产生方式，和内核结构，操作接口，掌握捕捉的原理并理解用户态和内核态的区别，也扩展了子进程回收的新方式和特例。"
keywords: "Linux 信号"
categories: ['Linux']
tags: ['Linux']
artid: "146081158"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146081158
    alt: "Linux-信号"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146081158
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146081158
cover: https://bing.ee123.net/img/rand?artid=146081158
image: https://bing.ee123.net/img/rand?artid=146081158
img: https://bing.ee123.net/img/rand?artid=146081158
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux 信号
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" name="1.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" style="background-color:transparent">
     1. 基本概念
    </h2>
    <p>
     <span style="color:#fe2c24">
      <strong>
       信号是进程之间 事件
      </strong>
     </span>
     <span style="color:#956fe7">
      <strong>
       异步
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       通知的一种方式。
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
      </strong>
     </span>
     <span style="color:#0d0016">
      在目标进程运行时，操作系统（OS）可以将
      <strong>
       特定信号
      </strong>
     </span>
     <span style="color:#38d8f0">
      <strong>
       “传递”
      </strong>
     </span>
     <span style="color:#0d0016">
      给该进程，
      <strong>
       执行对应的动作
      </strong>
      。
     </span>
    </p>
    <p>
     查看Linux系统中有那些信号：
     <strong>
      kill -l
      <span style="color:#be191c">
       【宏】
      </span>
     </strong>
     <img alt="" height="846" src="https://i-blog.csdnimg.cn/direct/7e85177ec334452a861d8a9d1fc09821.png" width="2103"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       发现：没有 0， 32， 33号信号
      </strong>
     </span>
    </p>
    <p>
     （本文的介绍专注于 1-31 号信号类型的学习）
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       执行对应的动作 即 怎么处理：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       1. 默认行为
      </strong>
     </span>
     （OS制定）详情可使用 man 7 signal 阅览
     <strong>
      （大多数为终止这个进程）
     </strong>
    </p>
    <p>
     <strong>
      2. 提供一个信号处理函数
     </strong>
     --- 这种方式称为
     <span style="color:#38d8f0">
      <strong>
       捕捉（Catch）
      </strong>
     </span>
     一个信号 【要求内核在处理该信号时切换到用户态执行这个处理函数（后面详细介绍）】
    </p>
    <p>
     <strong>
      3. 忽略此信号
     </strong>
    </p>
    <p>
     系统调用接口：
     <img alt="" height="480" src="https://i-blog.csdnimg.cn/direct/90959a794f8943f9bcb0a20f18bb996f.png" width="1650"/>
    </p>
    <p>
     或者使用 更加灵活的
     <strong>
      sigaction ,
     </strong>
     但使用的细致和复杂度也随之增加
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       注意：SIGKILL(9) 和 SIGSTOP(19) 不能捕捉！
      </span>
     </strong>
    </p>
    <h2 id="2.%20%E5%87%A0%E7%A7%8D%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F%C2%A0" name="2.%20%E5%87%A0%E7%A7%8D%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F%C2%A0" style="background-color:transparent">
     2. 几种产生方式
    </h2>
    <p>
     <strong>
      1. 键盘
     </strong>
     <img alt="" height="738" src="https://i-blog.csdnimg.cn/direct/08cfbec6233e4f1eb884c79151fdbe66.png" width="2262"/>
    </p>
    <p>
     <strong>
      Ctrl + c
     </strong>
     产生的信号【SIGINT（2）】只能发给前台进程。一般的程序代码不做特殊处理，在Shell启动的都是前台进程；
     <strong>
      一个命令后面加个&amp;可以放到后台运行,这样Shell不必等待进程 结束就可以接受新的命令,启动新的进程。
     </strong>
    </p>
    <p>
     Shell可以
     <strong>
      同时
     </strong>
     运行一个前台进程和任意多个后台进程,只有前台进程才能接到像这样的信号，比如还有
     <strong>
      Ctrl + \
     </strong>
     表示【SIGQUIT (3)】，
     <strong>
      Ctrl + z
     </strong>
     表示【SIGSTOP（19)】
    </p>
    <p>
     前台进程在运行过程中用户随时可能按下这些快捷键 或者 后面提到的方式, 这个进程都能收到
     <strong>
      指定信号
     </strong>
     , 并在用户空间代码执行
     <strong>
      对应的动作
     </strong>
     ,
     <span style="color:#956fe7">
      <strong>
       所以信号相对于进程的控制流程来说是异步 (Asynchronous)
      </strong>
     </span>
     的。
    </p>
    <p>
     <strong>
      2. 调用函数接口
     </strong>
    </p>
    <p>
     <img alt="" height="372" src="https://i-blog.csdnimg.cn/direct/fa434f79278144e4b951336d82dedbf3.png" width="2019"/>
    </p>
    <p>
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/f787ffd959564f34a50eb81d60a3fc9c.png" width="1980"/>
    </p>
    <p>
     <img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/83aa6e4e4e1d461c9ee9e28f91647066.png" width="1896"/>
    </p>
    <p>
     <strong>
      3. 软件条件
     </strong>
    </p>
    <p>
     <strong>
      通常表示程序运行中的异常 或 需要特定响应的事件。
     </strong>
    </p>
    <p>
     举例：
    </p>
    <p>
     1. 管道的同步机制：读端关闭，写端尝试写入 已经没有意义，OS发送 SIGPIPE（13）终止写端
    </p>
    <p>
     <span style="color:#ff9900">
      <strong>
       2. “闹钟”
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;unistd.h&gt;

       unsigned int alarm(unsigned int seconds);</code></pre>
    <p>
     调用这个函数可以设定一个
     <strong>
      “闹钟”
     </strong>
     也就是告诉内核在 seconds 秒之后给当前进程 发送
     <strong>
      SIGALRM（14）
     </strong>
     信号，该信号的默认处理动作是终止当前进程。
    </p>
    <p>
     它的返回值为0 或者 前一个闹钟剩余的秒数
    </p>
    <p>
     <strong>
      当设置参数 seconds == 0时 表示 取消该闹钟
     </strong>
    </p>
    <p>
     <strong>
      4. 硬件异常产生信号
     </strong>
    </p>
    <p>
     硬件异常以某种方式可以
     <strong>
      被硬件检测
     </strong>
     到并通知内核，然后内核向当前进程发送适当的信号。
    </p>
    <p>
     例如，当前进程执行了
     <strong>
      除以0
     </strong>
     的指令，CPU的运算单元会产生异常，内核将这个异常解释为
     <strong>
      SIGFEP（8）
     </strong>
     信号发送给进程，默认终止进程。
    </p>
    <p>
     再比如，当前进程访问了
     <strong>
      非法内存地址
     </strong>
     （越界，空指针/野指针的解引用， ...）, MMU会产生异常，内核将这个异常解释 成
     <strong>
      SIGSEGV（11）
     </strong>
     号信号发送给进程，默认终止进程。
    </p>
    <p>
     . . . . . .
    </p>
    <h2 id="3.%20Core%20Dump" name="3.%20Core%20Dump" style="background-color:transparent">
     3. Core Dump
    </h2>
    <p>
     当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部保存到磁盘上, 文件名通常是core (不同的系统可能不同), 这叫做Core Dump。
    </p>
    <p>
     进程异常终止通常是因为有Bug, 比如非法内存访问导致段错误, 事后可以
     <strong>
      用调试器检查core文件以查清错误原因
     </strong>
     ,这叫做Post-mortem Debug
     <strong>
      （事后调试）
     </strong>
     。
    </p>
    <p>
     一个进程允许产生多大的core文件取决于进程的Resource Limit(这个信息保存 在PCB中)。
    </p>
    <p>
     默认是不允许产生core文件的, 因为core文件中可能包含用户密码等敏感信息, 不安全。在开发调试阶段可以用ulimit命令改变这个限制,允许 产生core文件。
    </p>
    <p>
     首先用ulimit命令改变Shell进程的Resource Limit,允许core文件最大为1024KB:
    </p>
    <p>
     <strong>
      ulimit -c 查看 core file size 大小
     </strong>
    </p>
    <p>
     <strong>
      修改： ulimit -c 1024
     </strong>
    </p>
    <p>
     然后尝试写一个异常代码，或者给它发送信号比如 SIGFEP
    </p>
    <p>
     运行失败后，就可以看到对应的 core文件
    </p>
    <p>
     使用以下命令启动 GDB 并加载可执行文件和 core 文件：
    </p>
    <pre><code class="language-bash">db your_program（崩溃的可执行文件） core</code></pre>
    <p>
     查看程序崩溃位置：
    </p>
    <pre><code class="language-bash">(gdb) bt</code></pre>
    <p>
     <a class="link-info" href="https://blog.csdn.net/m0_74171054/article/details/143505472" title="  更多gdb的调试操作可点击前往小编的另一篇文章《Linux基础开发工具》查看。">
      更多gdb的调试操作可点击前往小编的另一篇文章《Linux基础开发工具》查看。
     </a>
    </p>
    <h2 id="4.%20%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3" name="4.%20%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3" style="background-color:transparent">
     4. 内核结构和操作接口
    </h2>
    <p>
     首先，对上面提到的内容做总结表述
    </p>
    <p>
     1. 实际执行信号的处理动作称为
     <strong>
      信号递达（Delivery）
     </strong>
    </p>
    <p>
     2. 信号从产生到递达之间的状态称为
     <strong>
      信号未决（Pending）
     </strong>
    </p>
    <p>
     3. 进程可以选择
     <strong>
      阻塞（Block）
     </strong>
     某个信号，即
     <strong>
      屏蔽
     </strong>
     ：可以收到，但不 递达
    </p>
    <p>
     4. 被阻塞的信号将始终保持在未决状态，直到进程解除对此信号的阻塞， 才递达
    </p>
    <p>
     <span style="color:#ff9900">
      <strong>
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       需要
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       注意
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       的是：忽略 也是递达的方式之一，和阻塞不是同一个概念！
      </strong>
     </span>
    </p>
    <p>
     信号在内核中的表示示意图：
    </p>
    <p>
     <img alt="" height="663" src="https://i-blog.csdnimg.cn/direct/8e6fbabf564c4cbaa7a35f088d4a19da.png" width="2130"/>
    </p>
    <p>
     开头所说，
     <span style="color:#0d0016">
      操作系统（OS）可以将
      <strong>
       特定信号
      </strong>
     </span>
     <span style="color:#38d8f0">
      <strong>
       “传递”
      </strong>
     </span>
     <span style="color:#0d0016">
      给某个进程 ，其 “传递” 的意思是：OS修改该进程对应的内核数据结构（如上），记录信号状态。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      每个信号有两个标志位分别表示 阻塞（Block）和 未决（Pending）,还有一个函数指针 指向 递达动作。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      收到信号时，内核在进程控制块中设置该信号的未决标志，直到信号递达才修改该标志。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
     </span>
     从上图来看, 每个信号只有一个bit的未决标志,非0即1,
     <strong>
      不记录该信号产生了多少次
     </strong>
     , 阻塞标志也是这样表示的。
    </p>
    <p>
     因此, 未决和阻塞标志可以用
     <span style="color:#1c7331">
      <strong>
       相同的数据类型sigset_t
      </strong>
     </span>
     来存储, sigset_t 称为
     <span style="color:#1c7331">
      <strong>
       信号集
      </strong>
     </span>
     , 这个类型可以表示每个信号 的
     <strong>
      “有效”
     </strong>
     或
     <strong>
      “无效”状态
     </strong>
     , 在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞,而在未决信号集中 “有 效”和“无效”的含义是该信号是否处于未决状态。
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       阻塞信号集也叫做当 前进程的信号屏蔽字(Signal Mask)。
      </strong>
     </span>
    </p>
    <p>
     至于这个类型内部如何存储这些bit则依赖于系统实现, 从使用者的角度是不必关心的, 使用者只能调用以下函数来操作sigset_ t变量, 而不应该对它的内部数据做任何解释, 比如用printf直接打印sigset_t变量是没有意义的：
    </p>
    <pre><code class="language-cpp">#include &lt;signal.h&gt;
 int sigemptyset(sigset_t *set);
 int sigfillset(sigset_t *set);
 int sigaddset (sigset_t *set, int signo);
 int sigdelset(sigset_t *set, int signo);
 int sigismember（const sigset_t *set, int signo);</code></pre>
    <p>
     函数 sigemptyset 初始化set所指向的信号集, 使其中所有信号的对应bit清零, 表示该信号集不包含 任何有 效信号。
    </p>
    <p>
     函数 sigfillset 初始化set所指向的信号集, 使其中所有信号的对应bit为1，表示该信号集的有效信号包括系统支持的所有信号。
    </p>
    <p>
     <strong>
      注意
     </strong>
     , 在使用sigset_ t类型的变量之前, 一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的状态。初始化sigset_t变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。
    </p>
    <p>
     这四个函数都是成功返回0,出错返回-1。
    </p>
    <p>
     sigismember是一个布尔函数, 用于判断一个信号集的有效信号中是否包含某种信号, 若包含则返回1, 不包含则返回0, 出错返回-1。
    </p>
    <p>
     对 sigset_t 类型的变量做好设置后，就可以用下面的两个函数接口，把 它数据 修改到进程内核结构中，影响进行的执行：
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       1. sigprocmask
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;signal.h&gt;
 int sigprocmask(int how, const sigset_t *set, sigset_t *oset); 
返回值:若成功则为0,若出错则为-1</code></pre>
    <p>
     如果oset是非空指针, 则读取进程的当前信号屏蔽字通过oset参数传出。
    </p>
    <p>
     如果set是非空指针, 则更改进程的信号屏蔽字, 参数
     <strong>
      how
     </strong>
     指示如何更改：
    </p>
    <p>
     <strong>
      SIG_BLOCK ：
     </strong>
     当前集合和set参数的并集
    </p>
    <p>
     <strong>
      SIG_UNBLOCK ：
     </strong>
     将
     <code>
      set
     </code>
     信号集中的信号从当前进程的信号屏蔽字中移除
    </p>
    <p>
     <strong>
      SIG_SETMASK ：
     </strong>
     重新设置当前进程的信号屏蔽字为 set
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       2. sigpending
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;signal.h&gt;

    int sigpending(sigset_t *set);
</code></pre>
    <p>
     读取当前进程的未决信号集,通过set参数传出; 调用成功则返回0,出错则返回-1。
    </p>
    <h2 id="5.%C2%A0%20%E6%8D%95%E6%8D%89%E7%9A%84%E5%8E%9F%E7%90%86" name="5.%C2%A0%20%E6%8D%95%E6%8D%89%E7%9A%84%E5%8E%9F%E7%90%86">
     5.  捕捉的原理
    </h2>
    <p>
     到这，我们还有最后一个问题没有解决：信号的处理（递达）时机？
    </p>
    <p>
     <strong>
      —— 通常是内核态 到 用户态的切换过程中
     </strong>
    </p>
    <p>
     关于什么是 内核态，什么是用户态，简单来说就是：
    </p>
    <p>
     用户态执行受限的操作，访问受限的资源
    </p>
    <p>
     内核态可执行所以操作，访问所有资源
    </p>
    <p>
     <strong>
      举个例子：
     </strong>
    </p>
    <p>
     比如涉及到：read(), write(), wait() 等操作；进程调度切换时，重新获得CPU，进行上下文切换时；...... 都会导致进程进入内核态
    </p>
    <p>
     因为硬件上有相关机制来标识和支持两种状态，通常是寄存器，比如序状态字寄存器（
     <strong>
      PSW
     </strong>
     ）或状态寄存器（
     <strong>
      S
     </strong>
     R）等，其中的某些位可以用来表示当前处理器处于用户态还是内核态。
    </p>
    <p>
     <strong>
      至于为什么这样做的根本原因就是：OS作为软硬件资源的管理者，负责整个计算机的安全和稳定，用户的一切操作都不能跨过它，特别是涉及到底层文件数据的敏感性操作，软硬件需要统筹提供一些安全策略和机制。
     </strong>
    </p>
    <p>
     下面是一张过程示意图：
     <img alt="" height="1530" src="https://i-blog.csdnimg.cn/direct/7ca026c71ac04c66a157f1a8be3e648b.png" width="1944"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       这里需要特别解释的是
      </strong>
     </span>
     ：信号的产生是异步的，它可以在进程执行的任何时刻发生，与进程当前正在执行的代码路径（如
     <code>
      main
     </code>
     函数中的代码）没有直接的顺序关系。 也就是说
     <strong>
      sighandler
     </strong>
     和
     <strong>
      main
     </strong>
     函数使用
     <strong>
      不同的堆栈空间
     </strong>
     , 它们之间不存在调用和被调用的关系, 是
     <strong>
      两个独立的控制流程，
     </strong>
     所以：递达动作结束后，还要返回内核态，读取内核保存的当前进程上下文数据，保证返回用户态后从正确的位置继续。
    </p>
    <p>
     至于是怎么做到的，你还记得下面的 地址空间图吗：
     <img alt="" height="1419" src="https://i-blog.csdnimg.cn/direct/d4da0263f9294ddfb3dc4c4b11a88563.png" width="2160"/>
    </p>
    <h2 id="6.%20SIGCHLD%20(17)%E4%BF%A1%E5%8F%B7%C2%A0" name="6.%20SIGCHLD%20(17)%E4%BF%A1%E5%8F%B7%C2%A0">
     6. SIGCHLD (17)信号
    </h2>
    <p>
     用wait和waitpid函数清理僵尸进程, 父进程可以阻塞等待子进程结束, 也可以非阻塞地查询是否有子进程结束等待清理(也就是轮询的方式)。
    </p>
    <p>
     采用第一种方式, 父进程阻塞了就不能处理自己的工作了; 采用第二种方式, 父进程在处理自己的工作的同时还要记得时不时地轮询一 下, 程序实现复杂。
    </p>
    <p>
     其实,
     <strong>
      <span style="color:#fe2c24">
       子进程在终止时会给父进程发SIGCHLD信号,该信号的默认处理动作是忽略,
      </span>
     </strong>
     父进程可以自 定义SIGCHLD信号的处理函数, 这样父进程只需专心处理自己的工作, 不必关心子进程了, 子进程 终止时会通知父进程, 父进程在信号处理函数中调用wait清理子进程即可。
    </p>
    <p>
     但是事实上, 由于
     <strong>
      UNIX 的历史原因,
     </strong>
     要想不产生僵尸进程还有另外一种办法: 父进程调用sigaction将SIGCHLD的处理动作置为
     <span style="color:#fe2c24">
      <strong>
       SIG_IGN
      </strong>
     </span>
     , 这样fork出来的子进程在终止时会自动清理掉, 不会产生僵尸进程,也不会通知父进程。
    </p>
    <p>
     系统默认的忽略动作和用户用sigaction函数自定义的忽略通常是没有区别的, 但这是一个
     <span style="color:#fe2c24">
      <strong>
       特例
      </strong>
     </span>
     。此方法对于Linux可用, 但不保证在其它UNIX系统上都可用。
    </p>
    <p>
    </p>
    <p>
     本篇分享到这就结束了，如果对你有所帮助，就是对小编最大的鼓励，可以的话，点赞+收藏并分享给你的小伙伴一起学习吧！
    </p>
    <p>
     关注小编，持续更新中......
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343137313035342f:61727469636c652f64657461696c732f313436303831313538" class_="artid" style="display:none">
 </p>
</div>


