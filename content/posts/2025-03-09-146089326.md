---
layout: post
title: "Server-7-,Docker-Nginx实战,端口映射问题-解决端口映射冲突与配置难题-"
date: 2025-03-09 09:00:00 +0800
description: "⭐在现代Web开发中，Docker已经成为部署应用的标准工具之一。它提供了便捷的环境隔离和快速部署的能力，使得开发者能够更加专注于代码本身而不是服务器配置。本文将围绕如何在Docker环境中部署Nginx服务展开讨论，并详细讲解如何解决遇到的端口映射冲突、配置文件挂载等问题。"
keywords: "docker 设置nginx 81 端口"
categories: ['Server']
tags: ['服务器', '前端', 'Nginx', 'Docker']
artid: "146089326"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146089326
    alt: "Server-7-,Docker-Nginx实战,端口映射问题-解决端口映射冲突与配置难题-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146089326
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146089326
cover: https://bing.ee123.net/img/rand?artid=146089326
image: https://bing.ee123.net/img/rand?artid=146089326
img: https://bing.ee123.net/img/rand?artid=146089326
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Server 7 ，Docker Nginx实战，端口映射问题（ 解决端口映射冲突与配置难题 ）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3 id="%E7%9B%AE%E5%BD%95" name="%E7%9B%AE%E5%BD%95">
     目录
    </h3>
    <p>
    </p>
    <h6 id="%E5%BC%95%E8%A8%80-toc" name="tableOfContents" style="margin-left:40px">
     <a href="#%E5%BC%95%E8%A8%80" rel="nofollow">
      <span style="color:#956fe7">
       引言
      </span>
     </a>
    </h6>
    <h6 id="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E-toc" name="tableOfContents" style="margin-left:40px">
     <a href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E" rel="nofollow">
      <span style="color:#956fe7">
       一、环境说明
      </span>
     </a>
    </h6>
    <h6 id="%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc" name="tableOfContents" style="margin-left:40px">
     <a href="#%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" rel="nofollow">
      <span style="color:#956fe7">
       二、问题描述
      </span>
     </a>
    </h6>
    <h6 id="%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" name="tableOfContents" style="margin-left:40px">
     <a href="#%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">
      <span style="color:#956fe7">
       三、解决方案
      </span>
     </a>
    </h6>
    <h6 id="3.0%20%E7%AB%AF%E5%8F%A3%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E-toc" name="tableOfContents" style="margin-left:80px">
     <a href="#3.0%20%E7%AB%AF%E5%8F%A3%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E" rel="nofollow">
      <span style="color:#956fe7">
       3.0 端口详细说明
      </span>
     </a>
    </h6>
    <h6 id="3.1%C2%A0%E6%A3%80%E6%9F%A5%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%C2%A0-toc" name="tableOfContents" style="margin-left:80px">
     <a href="#3.1%C2%A0%E6%A3%80%E6%9F%A5%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%C2%A0" rel="nofollow">
      <span style="color:#956fe7">
       3.1 检查端口占用情况
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A0%20%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A0%20%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3" rel="nofollow">
      <span style="color:#956fe7">
       ① 确认服务端口
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A1%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%8D%A0%E7%94%A8-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A1%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%8D%A0%E7%94%A8" rel="nofollow">
      <span style="color:#956fe7">
       ② 停止移除占用
      </span>
     </a>
    </h6>
    <h6 id="3.2%C2%A0%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8-toc" name="tableOfContents" style="margin-left:80px">
     <a href="#3.2%C2%A0%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8" rel="nofollow">
      <span style="color:#956fe7">
       3.2 停止移除容器
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A0%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A0%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8" rel="nofollow">
      <span style="color:#956fe7">
       ① 停止移除容器
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A1%20%E8%BF%90%E8%A1%8C%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A1%20%E8%BF%90%E8%A1%8C%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">
      <span style="color:#956fe7">
       ② 运行新的容器
      </span>
     </a>
    </h6>
    <h6 id="3.3%C2%A0%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81-toc" name="tableOfContents" style="margin-left:80px">
     <a href="#3.3%C2%A0%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81" rel="nofollow">
      <span style="color:#956fe7">
       3.3 处理命名冲突
      </span>
     </a>
    </h6>
    <h6 id="3.4%C2%A0%E5%90%AF%E5%8A%A8%E6%96%B0%E7%9A%84Nginx%E5%AE%B9%E5%99%A8-toc" name="tableOfContents" style="margin-left:80px">
     <a href="#3.4%C2%A0%E5%90%AF%E5%8A%A8%E6%96%B0%E7%9A%84Nginx%E5%AE%B9%E5%99%A8" rel="nofollow">
      <span style="color:#956fe7">
       3.4 启动新的Nginx容器
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A0%20%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A0%20%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8" rel="nofollow">
      <span style="color:#956fe7">
       ① 启动容器
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A1%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A1%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">
      <span style="color:#956fe7">
       ② 注意事项
      </span>
     </a>
    </h6>
    <h6 id="%E2%91%A2%20%E6%98%A0%E5%B0%84%E5%85%B6%E5%AE%83-toc" name="tableOfContents" style="margin-left:120px">
     <a href="#%E2%91%A2%20%E6%98%A0%E5%B0%84%E5%85%B6%E5%AE%83" rel="nofollow">
      <span style="color:#956fe7">
       ③ 映射其它
      </span>
     </a>
    </h6>
    <h6 id="3.5%C2%A0%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-toc" name="tableOfContents" style="margin-left:80px">
     <a href="#3.5%C2%A0%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C" rel="nofollow">
      <span style="color:#956fe7">
       3.5 验证服务是否正常工作
      </span>
     </a>
    </h6>
    <h6 id="%E5%9B%9B%E3%80%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-toc" name="tableOfContents" style="margin-left:40px">
     <a href="#%E5%9B%9B%E3%80%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93" rel="nofollow">
      <span style="color:#956fe7">
       四、命令总结
      </span>
     </a>
    </h6>
    <h6 id="%E4%BA%94%E3%80%81%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93-toc" name="tableOfContents" style="margin-left:40px">
     <a href="#%E4%BA%94%E3%80%81%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93" rel="nofollow">
      <span style="color:#956fe7">
       五、本文总结
      </span>
     </a>
    </h6>
    <p>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/d8ec2774f3b44e5ab9f88d9f3aad18ea.gif"/>
    </p>
    <p>
    </p>
    <h4 id="" name="">
    </h4>
    <h3 id="%E5%BC%95%E8%A8%80" name="%E5%BC%95%E8%A8%80">
     前言
    </h3>
    <p>
     在现代Web开发中，Docker已经成为部署应用的标准工具之一。它提供了便捷的环境隔离和快速部署的能力，使得开发者能够更加专注于代码本身，而不是服务器配置。这里将围绕如何在Docker环境中部署Nginx服务展开讨论，并详细讲解如何解决遇到的端口映射冲突、配置文件挂载等问题。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="338" src="https://i-blog.csdnimg.cn/direct/c59596d0980b48a5b3252bb04b79dadc.png" width="601"/>
    </p>
    <p>
    </p>
    <h3 id="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E" name="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E">
     一、环境说明
    </h3>
    <ul>
     <li>
      <span style="color:#494949">
       操作系统：Linux Ubuntu（ 乌班图 ）
      </span>
     </li>
     <li>
      <span style="color:#494949">
       Docker版本：最新稳定版
      </span>
     </li>
     <li>
      <span style="color:#494949">
       Nginx配置文件位置：/usr/local/develop/docker-app/nginx/conf/nginx.conf
      </span>
     </li>
     <li>
      <span style="color:#494949">
       网站根目录位置：/usr/local/develop/docker-app/nginx/html/xz_control
      </span>
     </li>
     <li>
      <span style="color:#494949">
       nginx.conf 配置文件
      </span>
     </li>
    </ul>
    <pre><code class="language-cpp">user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    #include /etc/nginx/conf.d/*.conf;

    server {
    	listen       80;       # 配置监听的端口
    	listen  [::]:80;
    	server_name  localhost;    # 配置的域名
      
    	# system one
    	location / {
    		root   /usr/share/nginx/html/xitong;  # 网站根目录
    		index  index.html index.htm;   # 默认首页文件
    		# 前端加载404问题
    		try_files $uri $uri/ /index.html;
    	}
    	
    	location ^~/prod-api/{
    		proxy_pass http://192.168.110.40:9012/;
    	}
    	location ^~/prodpy-api/{
    		proxy_pass http://192.168.0.43:7777/;
    	}
    }

    server {
    	listen       81;       # 配置监听的端口
    	listen  [::]:81;
    	server_name  localhost;    # 配置的域名
      
    	# system two
    	location / {
    		root   /usr/share/nginx/html/xz_control;  # 网站根目录
    		index  index.html index.htm;   # 默认首页文件
    		# 前端加载404问题
    		try_files $uri $uri/ /index.html;
    	}
    	
    	location ^~/prod-api/{
    		proxy_pass http://192.168.110.40:9011/;
    	}
    	location ^~/prodpy-api/{
    		proxy_pass http://192.168.0.43:7777/;
    	}
    }
    
}</code></pre>
    <p>
     <span style="color:#494949">
      这里的nginx.conf文件，配置了两个
      <code>
       server
      </code>
      块，分别监听80和81端口。在Docker容器中运行这个配置，并正确地映射主机的端口到容器内的相应端口时，遇到问题。
     </span>
    </p>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <h3 id="%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" name="%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">
     二、问题描述
    </h3>
    <blockquote>
     <p>
      <span style="color:#fe2c24">
       在尝试通过Docker运行Nginx服务时，遇到了端口81 已经被其他服务占用的问题，同时发现名为nginx-new的容器名称已被使用，导致无法直接启动新的容器。
      </span>
     </p>
    </blockquote>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <h3 id="%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" name="%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">
     三、解决方案
    </h3>
    <h4 id="3.0%20%E7%AB%AF%E5%8F%A3%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E" name="3.0%20%E7%AB%AF%E5%8F%A3%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E">
     3.0 端口详细说明
    </h4>
    <p>
     端口就像是家里不同房间的门牌号，每个门牌号对应着家里不同的房间。在计算机的世界里，端口就是这样一个概念，它帮助电脑区分不同应用程序或服务的“房间”。总共有65536个这样的“房间”，从0到65535编号。
    </p>
    <p>
     其中一些“房间”有特别的用途，比如
     <span style="background-color:#ffd900">
      HTTP（超文本传输协议）使用80号端口，这是当你访问一个网站时，默认用来传输网页内容的通道；而HTTPS（安全的超文本传输协议），用于加密和安全地浏览网页，则默认使用443号端口。
     </span>
     通过这些特定的端口号，电脑能够准确无误地把数据送到正确的应用程序手中，就像邮递员根据地址把包裹送到正确的家门口一样。这样，无论你是浏览网页、发送邮件还是进行在线聊天，都能顺利进行而不发生混乱。
    </p>
    <h4 id="3.1%C2%A0%E6%A3%80%E6%9F%A5%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%C2%A0" name="3.1%C2%A0%E6%A3%80%E6%9F%A5%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%C2%A0">
     3.1 检查端口占用情况
    </h4>
    <h5 id="%E2%91%A0%20%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3" name="%E2%91%A0%20%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3">
     ① 确认服务端口
    </h5>
    <p>
     首先，我们需要确认哪些服务正在使用81端口
    </p>
    <p>
     查找占用80端口的进程：
    </p>
    <pre><code class="language-cpp">sudo lsof -i :80</code></pre>
    <p>
     查找占用81端口的进程：
    </p>
    <pre><code class="language-cpp">sudo lsof -i :81</code></pre>
    <p>
     实际执行和响应（执行成功）：
    </p>
    <blockquote>
     <p>
      xingdun@xingdun-ThinkStation-P330:~$ sudo lsof -i :81
     </p>
     <p>
     </p>
     <p>
      <span style="color:#4da8ee">
       COMMAND      PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
       <br/>
       docker-pr 127483 root    4u  IPv4 739301      0t0  TCP *:81 (LISTEN)
       <br/>
       docker-pr 127491 root    4u  IPv6 742405      0t0  TCP *:81 (LISTEN)
      </span>
     </p>
     <p>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      从这里的输出可以看到，端口81已经被一个Docker进程（
      <code>
       docker-pr
      </code>
      ）占用。具体来说，PID为127483和127491的进程正在监听81端口。这意味着您需要停止相关的容器以释放81端口，或者选择将新容器的端口映射到主机上的其他未被占用的端口。
     </span>
    </p>
    <h5 id="%E2%91%A1%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%8D%A0%E7%94%A8" name="%E2%91%A1%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%8D%A0%E7%94%A8">
     ② 停止移除占用
    </h5>
    <p>
     这里来停止并移除占用81端口的容器
    </p>
    <p>
     首先，需要找出哪个容器正在使用这些端口。该命令会列出所有发布（即映射）了81端口的容器：
    </p>
    <pre><code class="language-cpp">docker ps --filter "publish=81"</code></pre>
    <p>
     实际执行和响应（执行成功）：
    </p>
    <blockquote>
     <p>
      xingdun@xingdun-ThinkStation-P330:~$ docker ps --filter "publish=81"
     </p>
     <p>
     </p>
     <p>
      <span style="color:#4da8ee">
       CONTAINER ID   IMAGE     COMMAND                   CREATED          STATUS          PORTS                                       NAMES
       <br/>
       69b39f5df9a5   nginx     "/docker-entrypoint.…"   20 minutes ago   Up 20 minutes   80/tcp, 0.0.0.0:81-&gt;81/tcp, :::81-&gt;81/tcp   my-nginx
      </span>
     </p>
     <p>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      根据响应信息，有一个名为
      <code>
       my-nginx
      </code>
      的容器正在使用81端口。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <span style="background-color:#ffd900">
       这里并没有直接的矛盾或额外的冲突。
      </span>
      <code>
       <span style="background-color:#ffd900">
        lsof
       </span>
      </code>
      <span style="background-color:#ffd900">
       输出中的
      </span>
      <code>
       <span style="background-color:#ffd900">
        docker-pr
       </span>
      </code>
      <span style="background-color:#ffd900">
       进程是 Docker 内部用于处理端口映射的进程，它们与
      </span>
      <code>
       <span style="background-color:#ffd900">
        docker ps
       </span>
      </code>
      <span style="background-color:#ffd900">
       显示的
      </span>
      <code>
       <span style="background-color:#ffd900">
        my-nginx
       </span>
      </code>
      <span style="background-color:#ffd900">
       容器直接相关。也就是说，正是
      </span>
      <code>
       <span style="background-color:#ffd900">
        my-nginx
       </span>
      </code>
      <span style="background-color:#ffd900">
       容器通过 Docker 的端口映射机制占用了主机的81端口，而
      </span>
      <code>
       <span style="background-color:#ffd900">
        docker-pr
       </span>
      </code>
      <span style="background-color:#ffd900">
       是实现这一映射的进程。
      </span>
     </span>
    </p>
    <h4 id="3.2%C2%A0%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8" name="3.2%C2%A0%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8">
     3.2 停止移除容器
    </h4>
    <p>
     停止并移除现有的
     <code>
      my-nginx
     </code>
     容器
    </p>
    <p>
     如果您不再需要现有的
     <code>
      my-nginx
     </code>
     容器，可以先停止并移除它以释放81端口。
    </p>
    <h5 id="%E2%91%A0%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8" name="%E2%91%A0%20%E5%81%9C%E6%AD%A2%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8">
     ① 停止移除容器
    </h5>
    <p>
     停止并移除现有的
     <code>
      my-nginx
     </code>
     容器
    </p>
    <p>
     该命令，用于停止一个正在运行的容器，这里表示它将会停止名为
     <code>
      my-nginx
     </code>
     的容器：
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">docker stop my-nginx
</code></pre>
    <p>
    </p>
    <p>
     该命令，用于移除一个已经停止的容器，这里表示它将会移除名为
     <code>
      my-nginx
     </code>
     的容器：
    </p>
    <pre><code class="language-cpp">docker rm my-nginx</code></pre>
    <h5 id="%E2%91%A1%20%E8%BF%90%E8%A1%8C%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8" name="%E2%91%A1%20%E8%BF%90%E8%A1%8C%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8">
     ② 运行新的容器
    </h5>
    <p>
     运行新的
     <code>
      nginx-new
     </code>
     容器
    </p>
    <blockquote>
     <p>
      docker run --name nginx-new \
      <br/>
      -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xitong:/usr/share/nginx/html/xitong:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
      <br/>
      -p 80:80 -p 81:81 \
      <br/>
      -d nginx
     </p>
    </blockquote>
    <p>
     各参数的作用
    </p>
    <blockquote>
     <ul>
      <li>
       <span style="color:#494949">
        <code>
         docker run
        </code>
        : 运行一个新的容器。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         --name nginx-new
        </code>
        : 给容器命名为
        <code>
         nginx-new
        </code>
        。这使得你可以通过这个名字来引用这个容器，而不是使用其ID。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro
        </code>
        : 将主机上的
        <code>
         /usr/local/develop/docker-app/nginx/conf/nginx.conf
        </code>
        文件挂载到容器内的
        <code>
         /etc/nginx/nginx.conf
        </code>
        路径下，且以只读模式 (
        <code>
         ro
        </code>
        ) 挂载。这意味着容器会使用你指定的Nginx配置文件而不是默认的配置文件。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         -v /usr/local/develop/docker-app/nginx/html/xitong:/usr/share/nginx/html/xitong:ro
        </code>
        : 将主机上的
        <code>
         /usr/local/develop/docker-app/nginx/html/xitong
        </code>
        目录挂载到容器内的
        <code>
         /usr/share/nginx/html/xitong
        </code>
        路径下，同样以只读模式挂载。这样做的目的是让Nginx能够访问你的网站根目录下的内容。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro
        </code>
        : 类似地，将另一个网站根目录挂载到容器内相应的路径下。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         -p 80:80
        </code>
        : 将主机的80端口映射到容器内的80端口。这意味着任何发送到主机80端口的请求都会被转发到容器内的80端口上运行的服务（在这个例子中是Nginx）。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         -p 81:81
        </code>
        : 同样地，将主机的81端口映射到容器内的81端口，允许外部访问容器内监听在81端口上的服务。
       </span>
      </li>
      <li>
       <span style="color:#494949">
        <code>
         -d nginx
        </code>
        : 使用官方的
        <code>
         nginx
        </code>
        镜像以后台模式 (
        <code>
         detached mode
        </code>
        , 简写为
        <code>
         -d
        </code>
        ) 启动容器。
       </span>
      </li>
     </ul>
    </blockquote>
    <p>
     这条命令的主要功能包括：
    </p>
    <ol>
     <li>
      <span style="color:#494949">
       <strong>
        创建并命名一个新容器
       </strong>
       (
       <code>
        nginx-new
       </code>
       )。
      </span>
     </li>
     <li>
      <span style="color:#494949">
       <strong>
        挂载自定义的Nginx配置文件
       </strong>
       到容器内部，覆盖默认配置。
      </span>
     </li>
     <li>
      <span style="color:#494949">
       <strong>
        挂载两个不同的网站根目录
       </strong>
       到容器内部，以便Nginx可以提供这些网站的内容。
      </span>
     </li>
     <li>
      <span style="color:#494949">
       <strong>
        设置端口映射
       </strong>
       ，使得可以通过主机的80和81端口访问容器内的Nginx服务。
      </span>
     </li>
     <li>
      <span style="color:#494949">
       <strong>
        以后台模式启动容器
       </strong>
       使用官方的 Nginx 镜像。
      </span>
     </li>
    </ol>
    <p>
     通过这种方式，可以利用Docker容器技术，来部署具有特定配置的Nginx服务器，并且可以方便地管理和扩展这种部署方式。
    </p>
    <p>
     实际执行和响应（执行报错）：
    </p>
    <blockquote>
     <p>
      xingdun@xingdun-ThinkStation-P330:~$ docker run --name nginx-new \
      <br/>
      -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xitong:/usr/share/nginx/html/xitong:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
      <br/>
      -p 80:80 -p 81:81 \
      <br/>
      -d nginx
     </p>
     <p>
      <br/>
      docker:
      <span style="color:#fe2c24">
       Error response from daemon: Conflict. The container name "/nginx-new" is already in use by container "6f3f3841caae693acf44de52904ee14dcaa6e9e17e0f0b2c37023e3198d9ac49". You have to remove (or rename) that container to be able to reuse that name.
       <br/>
       See 'docker run --help'.
      </span>
     </p>
     <p>
     </p>
    </blockquote>
    <p>
     从错误信息来看，名为
     <code>
      nginx-new
     </code>
     的容器名称已经被占用。这意味着之前有一个名为
     <code>
      nginx-new
     </code>
     的容器已经存在，即使它可能没有成功启动或者已经被停止了。您需要先处理这个现有的容器，才能使用相同的名字来运行新的容器。
    </p>
    <h4 id="3.3%C2%A0%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81" name="3.3%C2%A0%E5%A4%84%E7%90%86%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81">
     3.3 处理命名冲突
    </h4>
    <p>
     由于存在名为
     <code>
      nginx-new
     </code>
     的容器，我们需要先停止移除现有的同名容器。
    </p>
    <p>
     该命令，用于停止一个正在运行的容器，这里表示它将会停止名为
     <code>
      nginx-new
     </code>
     的容器：
    </p>
    <pre><code>docker stop nginx-new
</code></pre>
    <p>
     该命令，用于移除一个已经停止的容器，这里表示它将会移除名为
     <code>
      nginx-new
     </code>
     的容器：
    </p>
    <pre><code>docker rm nginx-new</code></pre>
    <h4 id="3.4%C2%A0%E5%90%AF%E5%8A%A8%E6%96%B0%E7%9A%84Nginx%E5%AE%B9%E5%99%A8" name="3.4%C2%A0%E5%90%AF%E5%8A%A8%E6%96%B0%E7%9A%84Nginx%E5%AE%B9%E5%99%A8">
     3.4 启动新的Nginx容器
    </h4>
    <h5 id="%E2%91%A0%20%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8" name="%E2%91%A0%20%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8">
     <strong>
      ① 启动容器
     </strong>
    </h5>
    <p>
     接下来，我们可以使用以下命令，来启动一个新的Nginx容器，并正确地挂载配置文件和网站根目录，同时进行端口映射：
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       docker run --name nginx-new \
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       -v /usr/local/develop/docker-app/nginx/html/xitong:/usr/share/nginx/html/xitong:ro \
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       -p 80:80 -p 81:81 \
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       -d ngin
      </span>
     </p>
    </blockquote>
    <p>
     实际执行和响应（执行成功）：
    </p>
    <blockquote>
     <p>
      xingdun@xingdun-ThinkStation-P330:~$ docker run --name nginx-new \
     </p>
     <p>
      -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
     </p>
     <p>
      -v /usr/local/develop/docker-app/nginx/html/xitong:/usr/share/nginx/html/xitong:ro \
     </p>
     <p>
      -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
     </p>
     <p>
      -p 80:80 -p 81:81 \
     </p>
     <p>
      -d nginx
     </p>
     <p>
     </p>
     <p>
      <span style="color:#4da8ee">
       844f3be41d4d26dcb188e87ca85a4c184a2b83621313f16bb2e381c500c28
      </span>
     </p>
     <p>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      这里表示已经成功地运行了新的 Docker 容器
      <code>
       nginx-new
      </code>
      ，并且没有出现错误信息。Docker 返回了一个容器 ID (
      <code>
       844f3be41d4d26dcb188e87ca85a4c184a41a84e5a2b836f16bb2e381c500c28
      </code>
      )，这表明容器已经被正确创建并以后台模式启动。
     </span>
    </p>
    <h5 id="%E2%91%A1%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="%E2%91%A1%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
     <strong>
      ② 注意事项
     </strong>
    </h5>
    <blockquote>
     <ul>
      <li>
       <code>
        -v
       </code>
       参数用于挂载主机上的文件或目录到容器内，
       <code>
        ro
       </code>
       表示只读模式。
      </li>
      <li>
       <code>
        -p
       </code>
       参数用于端口映射，确保外部可以访问容器内的服务。
      </li>
      <li>
       <code>
        -d
       </code>
       参数表示以后台模式运行容器。
      </li>
     </ul>
    </blockquote>
    <h5 id="%E2%91%A2%20%E6%98%A0%E5%B0%84%E5%85%B6%E5%AE%83" name="%E2%91%A2%20%E6%98%A0%E5%B0%84%E5%85%B6%E5%AE%83">
     ③ 映射其它
    </h5>
    <p>
     还可以选择将新容器的81端口映射到主机上的其他未被占用的端口，例如8081：
    </p>
    <blockquote>
     <p>
      docker run --name nginx-new \
      <br/>
      -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xitong:/usr/share/nginx/html/xitong:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
      <br/>
      -p 80:80 -p 8081:81 \
      <br/>
      -d nginx
     </p>
    </blockquote>
    <h4 id="3.5%C2%A0%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C" name="3.5%C2%A0%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C">
     3.5 验证服务是否正常工作
    </h4>
    <p>
     在执行
     <code>
      docker run
     </code>
     命令后，Docker 会基于 Nginx 镜像创建并启动一个新的容器，并且该容器会自动运行 Nginx 服务。由于
     <code>
      -d
     </code>
     参数的作用，这个容器会在后台运行。因此，在正常情况下，执行完这条命令后不需要手动重启 Nginx。启动容器后，可以通过浏览器输入 IP + 81 端口进行访问​：192.168.xxx.40:81​前端系统页面。
    </p>
    <p>
     不过，有几种情况可能需要重新加载或重启 Nginx：
    </p>
    <p>
     <strong>
      ① 配置文件更新
     </strong>
    </p>
    <p>
     如果您修改了挂载到容器内的 Nginx 配置文件（例如
     <code>
      /usr/local/develop/docker-app/nginx/conf/nginx.conf
     </code>
     ），则需要让 Nginx 重新加载配置。可以通过以下命令进入正在运行的容器，并发送重载信号：
    </p>
    <pre><code class="language-cpp">docker exec nginx-new nginx -s reload</code></pre>
    <p>
     这条命令会让
     <span style="background-color:#ffd900">
      Nginx 重新加载配置文件而不停止服务
     </span>
     。
    </p>
    <p>
     <span style="color:#4da8ee">
      <code>
       运行结果如果是
      </code>
      <strong>
       <code>
        [notice] 42#42: signal process started
       </code>
      </strong>
      ：这是 Nginx 日志中的一个通知消息，表示它已经收到重新加载信号，并且已经开始处理该请求。这里的
      <code>
       42#42
      </code>
      指的是进程ID和工作进程ID，表明哪个进程正在处理此操作。
     </span>
    </p>
    <p>
     <strong>
      ② Nginx 容器停止或异常退出
     </strong>
    </p>
    <p>
     如果容器内的 Nginx 服务因某种原因停止了，您可以重启整个
    </p>
    <pre><code class="language-cpp">docker restart nginx-new</code></pre>
    <p>
     这将
     <span style="background-color:#ffd900">
      重启容器及其内部的所有服务
     </span>
     ，包括 Nginx。
    </p>
    <p>
     <strong>
      ③ 验证 Nginx 是否正常工作
     </strong>
    </p>
    <p>
     如果您想检查 Nginx 是否正确地启动并且没有遇到任何错误，可以查看容器的日志：
    </p>
    <pre><code class="language-cpp">docker logs nginx-new</code></pre>
    <p>
     如果发现有任何错误信息，根据错误提示进行相应的修正可能是必要的。
    </p>
    <p>
     <span style="background-color:#ffd900">
      注意这里的nginx-new是容器名称。
     </span>
    </p>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <h3 id="%E5%9B%9B%E3%80%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93" name="%E5%9B%9B%E3%80%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93">
     四、命令总结
    </h3>
    <p>
     为了便于理解和应用每条命令的作用，这里来总结并排序
    </p>
    <p>
     <strong>
      1. 查看端口占用情况
     </strong>
    </p>
    <pre><code class="language-cpp">sudo lsof -i :81</code></pre>
    <p>
     查看81端口使用情况。
    </p>
    <p>
     <strong>
      2. 列出占用指定端口的容器
     </strong>
    </p>
    <pre><code class="language-cpp">docker ps --filter "publish=81"</code></pre>
    <p>
     查找使用81端口的容器。
    </p>
    <p>
     <strong>
      3. 停止指定容器
     </strong>
    </p>
    <pre><code class="language-cpp">docker stop my-nginx</code></pre>
    <p>
     停止名为
     <code>
      my-nginx
     </code>
     的容器。
    </p>
    <p>
     <strong>
      4. 移除指定容器
     </strong>
    </p>
    <pre><code class="language-cpp">docker rm my-nginx</code></pre>
    <p>
     删除名为
     <code>
      my-nginx
     </code>
     的容器。
    </p>
    <p>
     <strong>
      5. 运行新的Nginx容器
     </strong>
    </p>
    <blockquote>
     <p>
      docker run --name nginx-new \
      <br/>
      -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
      <br/>
      -p 81:81 \
      <br/>
      -d nginx
     </p>
    </blockquote>
    <p>
     启动新Nginx容器并映射端口。
    </p>
    <p>
     <strong>
      6. 运行新容器并映射到不同端口
     </strong>
    </p>
    <blockquote>
     <p>
      docker run --name nginx-new \
      <br/>
      -v /usr/local/develop/docker-app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \
      <br/>
      -v /usr/local/develop/docker-app/nginx/html/xz_control:/usr/share/nginx/html/xz_control:ro \
      <br/>
      -p 8081:81 \
      <br/>
      -d nginx
     </p>
    </blockquote>
    <p>
     映射至未占用端口（如8081）。
    </p>
    <p>
     <strong>
      7. Nginx 容器停止或异常退出
     </strong>
    </p>
    <pre><code class="language-cpp">docker restart nginx-new</code></pre>
    <p>
     重启容器及其内部的所有服务。
    </p>
    <p>
     <strong>
      8. 重新加载 Nginx 配置
     </strong>
    </p>
    <pre><code class="language-cpp">docker exec nginx-new nginx -s reload</code></pre>
    <p>
     重新加载Nginx配置文件，只针对 Nginx。
    </p>
    <p>
     这些命令覆盖了从检查端口占用、管理Docker容器、到调试和维护Nginx服务的全过程。希望对你有所帮助！
    </p>
    <p>
    </p>
    <hr/>
    <h4 id="" name="">
    </h4>
    <h3 id="%E4%BA%94%E3%80%81%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93" name="%E4%BA%94%E3%80%81%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93">
     五、本文总结
    </h3>
    <p>
     通过上述步骤，我们成功解决了Docker中部署Nginx服务时遇到的端口映射冲突问题。同时，我们也学会了，如何正确挂载配置文件和网站根目录，确保服务按照预期运行。希望这里能帮助到同样面临这些问题的你。如果有任何疑问或需要进一步的帮助，请随时留言交流！
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7366413eb540471598f1710acb138e93.gif"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36353739333137302f:61727469636c652f64657461696c732f313436303839333236" class_="artid" style="display:none">
 </p>
</div>


