---
layout: post
title: "Linux内核学习一Vmware虚拟机安装Ubuntu20.4系统及QEMU模拟ARM64-Linux"
date: 2025-03-09 16:40:14 +0800
description: "本次实验学习“奔跑吧Linux内核”课件及资料，参照实验指导书中的第1章中的实验1-1到1-6的内容，进行学习理解和模仿实践。在实验过程中经历了很多次失败，感悟很多，推荐大家利用deepseek，kimi等大模型来处理报错，在这个过程之中，除了copy大模型给出的解决方法，也要重点学习一下它的思路（如下图），否则下一次还是可能会经历同样的错误。"
keywords: "Linux内核学习（一）——Vmware虚拟机安装Ubuntu20.4系统及QEMU模拟ARM64 Linux"
categories: ['未分类']
tags: ['学习', 'Linux']
artid: "146045615"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146045615
    alt: "Linux内核学习一Vmware虚拟机安装Ubuntu20.4系统及QEMU模拟ARM64-Linux"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146045615
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146045615
cover: https://bing.ee123.net/img/rand?artid=146045615
image: https://bing.ee123.net/img/rand?artid=146045615
img: https://bing.ee123.net/img/rand?artid=146045615
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux内核学习（一）——Vmware虚拟机安装Ubuntu20.4系统及QEMU模拟ARM64 Linux
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="LinuxVmwareUbuntu204QEMUARM64_Linux_0">
     </a>
     Linux内核学习（一）——Vmware虚拟机安装Ubuntu20.4系统及QEMU模拟ARM64 Linux
    </h2>
    <p>
     <strong>
      小编有话说：
     </strong>
     <br/>
     在实验进行前，建议大家提前去学习快照功能，具体原因如下：
     <br/>
     1.因为我们在虚拟机上面完成实验的时候，经常会因为马虎或者资料寻找错误导致整个实验报废，如果不使用快照，很有可能会导致之前那的努力白费；
     <br/>
     2.如果想深入学习命令行，可以启动同样的快照，在不同的命令行操作下编译，更能深刻理解其中的含义。
     <br/>
     学习博客：https://zhuanlan.zhihu.com/p/196701930 ， https://www.cnblogs.com/liuyuelinfighting/p/15484974.html
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/055c24f8a55d4448b67e823b34142f6c.png"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_11">
     </a>
     一.实验目的
    </h2>
    <ol>
     <li>
      掌握 VMware 虚拟机软件的基本使用方法。
     </li>
     <li>
      学习在虚拟机中安装 Ubuntu 20.04 Desktop 系统。
     </li>
     <li>
      熟悉 Linux 系统的初始配置及快照管理。
     </li>
    </ol>
    <h2>
     <a id="_16">
     </a>
     二.实验
    </h2>
    <h3>
     <a id="11Ubuntu_Linux_2004_18">
     </a>
     （一）实验1.1
     <strong>
      Ubuntu Linux 20.04系统的安装
     </strong>
    </h3>
    <h4>
     <a id="_19">
     </a>
     实验目的
    </h4>
    <p>
     Ubuntu Linux 20.04系统的安装
    </p>
    <h4>
     <a id="_23">
     </a>
     实验步骤
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        创建虚拟机
       </strong>
      </p>
      <ul>
       <li>
        打开 VMware，选择
        <code>
         创建新的虚拟机
        </code>
        →
        <code>
         典型配置
        </code>
        → 选择 ISO 文件路径。
       </li>
       <li>
        设置用户名和密码（例如：
        <code>
         user/123456
        </code>
        ）。
       </li>
       <li>
        指定虚拟机名称和存储位置（如
        <code>
         D:\VM\Ubuntu20.04
        </code>
        ）。
       </li>
       <li>
        分配硬件资源：4 核 CPU、4GB 内存、50GB 硬盘。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        安装 Ubuntu 系统
       </strong>
      </p>
      <ul>
       <li>
        <p>
         启动虚拟机，进入 Ubuntu 安装界面：
        </p>
       </li>
       <li>
        <p>
         安装完成后重启系统。
         <br/>
         学习链接：https://blog.csdn.net/Z_Date/article/details/137855618?utm_source=miniapp_weixin
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_12_Ubuntu_Linux__37">
     </a>
     （二）实验 1-2：给 Ubuntu Linux 系统更换心脏（内核升级）
    </h3>
    <h4>
     <a id="_39">
     </a>
     实验目的
    </h4>
    <ol>
     <li>
      通过本实验学会如何给Linux系统更换最新版本的Linux内核。
     </li>
     <li>
      如何编译和安装Linux内核
     </li>
    </ol>
    <h4>
     <a id="_45">
     </a>
     实验步骤
    </h4>
    <p>
     以下是给Ubuntu Linux系统更换最新内核的具体操作步骤：
    </p>
    <hr/>
    <h4>
     <a id="1__50">
     </a>
     1. 安装依赖包
    </h4>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libncurses5-dev libssl-dev build-essential openssl flex bison dwarves
<span class="token comment"># 或者使用以下命令安装所有编译依赖</span>
<span class="token function">sudo</span> <span class="token function">apt</span> build-dep <span class="token parameter variable">-y</span> linux-image-generic
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/af48f3cc42ed4173989d6dcee601b33a.png">
      <br/>
      如果遇到这种情况，完整操作如下：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3dc931c529d945788e12d125c61bae60.png"/>
     </img>
    </p>
    <p>
     <strong>
      解决方案
     </strong>
     <br/>
     出现
     <code>
      E: 必须在 sources.list 中指定代码源 (deb-src) URI
     </code>
     错误时，说明系统缺少源代码仓库的配置。以下是分步解决方法：
    </p>
    <hr/>
    <h6>
     <a id="_debsrc__66">
     </a>
     启用 deb-src 仓库
    </h6>
    <ol>
     <li>
      <p>
       <strong>
        备份当前的源列表文件
       </strong>
       （可选）：
      </p>
      <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        编辑
        <code>
         sources.list
        </code>
        文件
       </strong>
       ：
      </p>
      <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /etc/apt/sources.list  <span class="token comment"># 使用 nano 编辑器，也可替换为 vim 或 gedit</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        添加或取消注释 deb-src 行
       </strong>
       ：
      </p>
      <ul>
       <li>
        找到已有的
        <code>
         deb
        </code>
        行（例如）：
        <pre><code>deb http://archive.ubuntu.com/ubuntu focal main restricted
</code></pre>
       </li>
       <li>
        在下方添加对应的
        <code>
         deb-src
        </code>
        行：
        <pre><code>deb-src http://archive.ubuntu.com/ubuntu focal main restricted
</code></pre>
       </li>
       <li>
        如果已有
        <code>
         deb-src
        </code>
        行但被注释（以
        <code>
         #
        </code>
        开头），删除
        <code>
         #
        </code>
        取消注释。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        保存并退出编辑器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <strong>
         nano
        </strong>
        ：按
        <code>
         Ctrl + O
        </code>
        保存，
        <code>
         Ctrl + X
        </code>
        退出。
       </li>
       <li>
        <strong>
         vim
        </strong>
        ：按
        <code>
         :wq
        </code>
        保存并退出。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h6>
     <a id="_94">
     </a>
     更新软件包列表
    </h6>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update
</code></pre>
    <hr/>
    <h6>
     <a id="_101">
     </a>
     验证操作
    </h6>
    <p>
     重新执行之前出错的命令（
     <code>
      sudo apt build-dep linux-image-generic
     </code>
     ），检查是否仍然报错。
    </p>
    <hr/>
    <h4>
     <a id="2__110">
     </a>
     2. 下载最新内核源码
    </h4>
    <ul>
     <li>
      访问
      <a href="https://www.kernel.org/" rel="nofollow">
       内核官网
      </a>
      或
      <a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" rel="nofollow">
       清华镜像站
      </a>
      查找最新稳定版（例如
      <code>
       5.10.15
      </code>
      ）。
     </li>
     <li>
      <strong>
       在此之前一定自己要创建文件夹！！！！（否则后面会因为找不到文件使命令失效）
      </strong>
     </li>
     <li>
     </li>
     <li>
      完整操作如下：
     </li>
    </ul>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> ~/kernel          <span class="token comment"># 进入自定义目录（需提前创建：mkdir ~/kernel）</span>
<span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.10.15.tar.xz

</code></pre>
    <hr/>
    <h4>
     <a id="3__123">
     </a>
     3. 解压内核源码
    </h4>
    <pre><code class="prism language-bash"><span class="token function">tar</span> <span class="token parameter variable">-xvf</span> linux-5.10.15.tar.xz
<span class="token builtin class-name">cd</span> linux-5.10.15
</code></pre>
    <hr/>
    <h4>
     <a id="4__131">
     </a>
     4. 配置内核选项
    </h4>
    <ul>
     <li>
      <strong>
       方法1
      </strong>
      （推荐，基于当前系统配置）：
     </li>
     <li>
      建议操作之前先查看自己下载的内核版本
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6cd0dfe77561400d9f133d61cac779e1.png">
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/65be736c30c04672a57776e26811ec43.png"/>
      </img>
     </li>
    </ul>
    <pre><code class="prism language-bash"><span class="token function">cp</span> /boot/config-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">)</span></span> .config
<span class="token function">make</span> olddefconfig
</code></pre>
    <ul>
     <li>
      <strong>
       方法2
      </strong>
      （默认设置）：
     </li>
    </ul>
    <pre><code class="prism language-bash"><span class="token function">make</span> defconfig  
</code></pre>
    <hr/>
    <p>
     <strong>
      如果出错，那基本原因就是前面指定代码源那一步出错了，建议删除之前下载的镜像，重新从建立文件夹操作（在没弄清楚命令行具体含义和作用之前，不建议直接在现有基础上改，会越改越乱！）
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/148ffc2cfd124b2183689015179ed266.png"/>
    </p>
    <h4>
     <a id="5__150">
     </a>
     5. 编译内核
    </h4>
    <ul>
     <li>
      使用多线程编译（根据CPU核心数调整
      <code>
       -j8
      </code>
      ，例如8线程）：
     </li>
    </ul>
    <pre><code class="prism language-bash"><span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span>  <span class="token comment"># 或者手动指定：make -j8</span>
</code></pre>
    <ul>
     <li>
      此过程可能耗时较长（30分钟至数小时），确保系统电源稳定。
      <br/>
      如果遇到这，按下列提示操作：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/223f35f632094d9d8611ce5856892983.png"/>
     </li>
    </ul>
    <p>
     <strong>
      解决方法
     </strong>
    </p>
    <h5>
     <a id="_161">
     </a>
     安装缺失的依赖库
    </h5>
    <p>
     执行以下命令安装
     <code>
      libelf
     </code>
     开发包：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libelf-dev elfutils
</code></pre>
    <p>
     （如果系统是CentOS/RHEL，则使用：
     <code>
      sudo yum install elfutils-libelf-devel
     </code>
     ）
    </p>
    <hr/>
    <h5>
     <a id="_170">
     </a>
     清理编译环境并重新编译
    </h5>
    <p>
     安装依赖后，重新执行完整编译流程：
    </p>
    <pre><code class="prism language-bash"><span class="token function">make</span> clean                          <span class="token comment"># 清理旧编译文件</span>
<span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span>                     <span class="token comment"># 重新编译内核，确保无报错</span>
</code></pre>
    <hr/>
    <h4>
     <a id="6__181">
     </a>
     6. 安装内核模块
    </h4>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">make</span> modules_install
</code></pre>
    <hr/>
    <h4>
     <a id="7__188">
     </a>
     7. 安装内核
    </h4>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre>
    <hr/>
    <h4>
     <a id="8_GRUB_195">
     </a>
     8. 更新引导加载程序（GRUB）
    </h4>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> update-initramfs <span class="token parameter variable">-c</span> <span class="token parameter variable">-k</span> <span class="token number">5.10</span>.15  <span class="token comment"># 替换为实际内核版本号</span>
<span class="token function">sudo</span> <span class="token function">update-grub</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/aed5684dc04f481d97d25fb7e8aa7921.png"/>
    </p>
    <hr/>
    <h4>
     <a id="9__204">
     </a>
     9. 重启并验证
    </h4>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">reboot</span>
</code></pre>
    <ul>
     <li>
      重启后执行以下命令检查内核版本：
     </li>
    </ul>
    <pre><code class="prism language-bash"><span class="token function">uname</span> <span class="token parameter variable">-r</span>
</code></pre>
    <p>
     输出应为新安装的内核版本（如
     <code>
      5.10.15
     </code>
     ）。
    </p>
    <hr/>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b572fb053952475ea817db6df65b3b7c.png"/>
    </p>
    <p>
     <strong>
      注意事项
     </strong>
     <br/>
     这里有一些
     <strong>
      DeepSeek
     </strong>
     给出的常见错误，可以借鉴：（建议大家看它给出的解决步骤之前，先看它的思考分析过程，因为有时候我们表述不清，AI生成的内容会有出错）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ff1c4c6fc69f419a922693b44823ebd9.png"/>
    </p>
    <hr/>
    <p>
     通过以上步骤即可完成Ubuntu Linux内核的编译和更换。
    </p>
    <h3>
     <a id="_13_QEMU__ARM64_Linux__232">
     </a>
     (三）实验 1-3：使用 QEMU 虚拟机运行 ARM64 Linux 系统并编译内核模块
    </h3>
    <hr/>
    <h4>
     <a id="_236">
     </a>
     实验目的
    </h4>
    <ol>
     <li>
      学习如何编译 ARM64 版本的 Linux 内核镜像。
     </li>
     <li>
      掌握在 QEMU 虚拟机上运行 ARM64 Linux 系统的流程。
     </li>
     <li>
      实践编译并加载最简单的内核模块
      <code>
       hello_world
      </code>
      ，验证模块功能。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_245">
     </a>
     实验步骤
    </h4>
    <h4>
     <a id="1_aarch64__246">
     </a>
     1.安装 aarch64 交叉编译工具：
    </h4>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> gcc-aarch64-linux-gnu
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libncurses5-dev build-essential <span class="token function">git</span> bison flex libssl-dev
</code></pre>
    <h4>
     <a id="2QEMU_254">
     </a>
     2.安装QEMU
    </h4>
    <p>
     在终端中输入 sudo apt install qemu-system-arm安装
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu-system-arm
</code></pre>
    <p>
     安装完成后，输入 qemu-system-aarch64 --version 来查看 qemu版本
    </p>
    <pre><code class="prism language-bash">qemu-system-aarch64 <span class="token parameter variable">--version</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/162123d7427c4357adfa40956b39f97d.png"/>
    </p>
    <h4>
     <a id="3QEMU_267">
     </a>
     3.启动QEMU
    </h4>
    <h5>
     <a id="_268">
     </a>
     创建共享文件目录
    </h5>
    <pre><code class="prism language-bash"><span class="token function">mkdir</span> kmodules

</code></pre>
    <h5>
     <a id="_274">
     </a>
     安装预编译内核
    </h5>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> linux-image-generic
</code></pre>
    <h5>
     <a id="_280">
     </a>
     确定内核位置
    </h5>
    <pre><code class="prism language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> /boot
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8113c1c5bfb44606928d97eefdabdae9.png"/>
     <br/>
     在我的 /boot 目录下，内核文件的名称是 vmlinuz-5.4.0-208-generic。那么我可以尝试使用这个文件来启动 QEMU。
     <br/>
     <strong>
      注意：
     </strong>
     <br/>
     若没有权限，可以调整：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> +r /boot/vmlinuz-5.4.0-208-generic
</code></pre>
    <p>
     若无挂载路径，可以创建该目录：
    </p>
    <pre><code class="prism language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/xm/kmodules
</code></pre>
    <h5>
     <a id="QEMU_299">
     </a>
     运行QEMU模拟器
    </h5>
    <p>
     在内核源码目录下执行下面命令（一次性输入）
    </p>
    <pre><code class="prism language-bash">qemu-system-aarch64 <span class="token parameter variable">-machine</span> virt <span class="token parameter variable">-cpu</span> cortex-a57 <span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt <span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token parameter variable">-kernel</span> /boot/vmlinuz-5.4.0-208-generic <span class="token parameter variable">-append</span> <span class="token string">"console=ttyAMA0 loglevel=8 root=/dev/vda rw"</span> <span class="token parameter variable">-nographic</span> <span class="token parameter variable">-d</span> int,cpu_reset <span class="token parameter variable">-drive</span> <span class="token assign-left variable">file</span><span class="token operator">=</span>/home/xm/disk.img,format<span class="token operator">=</span>qcow2,if<span class="token operator">=</span>virtio <span class="token parameter variable">-fsdev</span> local,id<span class="token operator">=</span>km_dev,path<span class="token operator">=</span>/home/xm/kmodules,security_model<span class="token operator">=</span>none <span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>km_dev,mount_tag<span class="token operator">=</span>kmount

</code></pre>
    <p>
     如果出现错误，说明没有创建虚拟磁盘文件：
    </p>
    <pre><code class="prism language-bash">qemu-img create <span class="token parameter variable">-f</span> qcow2 /home/xm/disk.img 10G
</code></pre>
    <h5>
     <a id="QEMU_313">
     </a>
     退出QEMU模拟器
    </h5>
    <pre><code class="prism language-bash">poweroff

</code></pre>
    <h4>
     <a id="4QEMU_319">
     </a>
     4.编译一个简单的内核模块并在QEMU上运行
    </h4>
    <p>
     在根目录下创建一个文件夹module_test，并编写一个简单的hello.c代码
    </p>
    <pre><code class="prism language-bash">// 包含内核模块编程所需的头文件
<span class="token comment">#include &lt;linux/init.h&gt;  // 包含模块初始化和退出函数的宏</span>
<span class="token comment">#include &lt;linux/module.h&gt;  // 包含模块相关的宏和函数</span>
<span class="token comment">#include &lt;linux/kernel.h&gt;  // 包含内核打印函数 printk 的头文件</span>

// 模块初始化函数
// 当模块被加载到内核时，此函数会被调用
static int __init test_init<span class="token punctuation">(</span>void<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    // 在内核日志中打印 <span class="token string">"hello world!"</span>
    printk<span class="token punctuation">(</span><span class="token string">"hello world!<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    // 返回 <span class="token number">0</span> 表示初始化成功
    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    

// 模块退出函数
// 当模块从内核中卸载时，此函数会被调用
static void __exit test_exit<span class="token punctuation">(</span>void<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    // 在内核日志中打印 <span class="token string">"hello exit!"</span>
    printk<span class="token punctuation">(</span><span class="token string">"hello exit!<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

// 注册模块的初始化函数
// 当模块被加载时，test_init 函数会被调用
module_init<span class="token punctuation">(</span>test_init<span class="token punctuation">)</span><span class="token punctuation">;</span>

// 注册模块的退出函数
// 当模块被卸载时，test_exit 函数会被调用
module_exit<span class="token punctuation">(</span>test_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

// 声明模块的许可证
// GPL 是 GNU 通用公共许可证，表示这是一个开源模块
MODULE_LICENSE<span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
    <p>
     再编写Makefile文件
    </p>
    <pre><code class="prism language-bash"><span class="token comment"># 设置目标架构为 ARM64</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64

<span class="token comment"># 设置交叉编译工具链前缀为 aarch64-linux-gnu-</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu-

<span class="token comment"># 定义内核源码目录</span>
KERNEL_DIR ?<span class="token operator">=</span> /home/xm/linux-6.13.5

<span class="token comment"># 定义要编译的内核模块目标文件</span>
<span class="token comment"># obj-m 表示将 hello.c 编译为内核模块 hello.ko</span>
obj-m :<span class="token operator">=</span> hello.o

<span class="token comment"># 默认目标：编译内核模块</span>
modules:
	<span class="token comment"># 调用内核源码目录的 Makefile，编译当前目录下的模块</span>
	<span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> <span class="token variable"><span class="token variable">$(</span>KERNEL_DIR<span class="token variable">)</span></span> <span class="token assign-left variable">M</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token environment constant">PWD</span><span class="token variable">)</span></span> modules

<span class="token comment"># 清理目标：删除编译生成的文件</span>
clean:
	<span class="token comment"># 调用内核源码目录的 Makefile，清理当前目录下的生成文件</span>
	<span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> <span class="token variable"><span class="token variable">$(</span>KERNEL_DIR<span class="token variable">)</span></span> <span class="token assign-left variable">M</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token environment constant">PWD</span><span class="token variable">)</span></span> clean

<span class="token comment"># 安装目标：将编译好的内核模块复制到指定目录</span>
install:
	<span class="token comment"># 将当前目录下所有的 .ko 文件复制到内核源码目录的 kmodules 子目录中</span>
	<span class="token function">cp</span> *.ko <span class="token variable"><span class="token variable">$(</span>KERNEL_DIR<span class="token variable">)</span></span>/kmodules

</code></pre>
    <p>
     编译module，拷贝到共享目录
    </p>
    <pre><code class="prism language-bash"><span class="token function">make</span> modules
<span class="token function">make</span> <span class="token function">install</span> 

</code></pre>
    <p>
     启动QEMU
    </p>
    <pre><code class="prism language-bash">qemu-system-aarch64 
<span class="token parameter variable">-machine</span> virt 
<span class="token parameter variable">-cpu</span> cortex-a57 
<span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt  
<span class="token parameter variable">-m</span> <span class="token number">1024</span> 
<span class="token parameter variable">-smp</span> <span class="token number">4</span> 
<span class="token parameter variable">-kernel</span> arch/arm64/boot/Image 
<span class="token parameter variable">--append</span> <span class="token string">"rdinit=/linuxrc root=/dev/vda rw console=ttyAMA0 loglevel=8"</span>  
<span class="token parameter variable">-nographic</span>  
<span class="token parameter variable">--fsdev</span> local,id<span class="token operator">=</span>kmod_dev,path<span class="token operator">=</span><span class="token environment constant">$PWD</span>/kmodules,security_model<span class="token operator">=</span>none  
<span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>kmod_dev,mount_tag<span class="token operator">=</span>kmod_mount

<span class="token function">ls</span> /mnt

</code></pre>
    <h3>
     <a id="14Ubuntu_416">
     </a>
     （四）实验1-4：创建基于Ubuntu的根文件系统
    </h3>
    <h4>
     <a id="_417">
     </a>
     实验目的
    </h4>
    <p>
     创建关于Ubuntu linux的根文件系统
    </p>
    <h4>
     <a id="_421">
     </a>
     实验步骤
    </h4>
    <h4>
     <a id="1BusyBox_422">
     </a>
     1.BusyBox构建根文件系统
    </h4>
    <p>
     1）下载BusyBox源码
     <br/>
     BusyBox是一个集成了大量的Linux命令（如ls、mv、ifconfig 等命令）和工具的软件。借助BusyBox，进行配置和编译，就可以方便的构建一个嵌入Linux平台所需要的根文件系统。
    </p>
    <p>
     可在BusyBox官网 https://busybox.net/ 下载源码。
    </p>
    <p>
     将压缩包拖拽到Ubuntu虚拟机中的桌面或文件夹中，并解压
    </p>
    <pre><code class="prism language-bash"><span class="token function">tar</span> <span class="token parameter variable">-vxjf</span> busybox-1.37.0.tar.bz2
</code></pre>
    <h4>
     <a id="2_435">
     </a>
     2.制定编译工具链
    </h4>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> busybox-1.37.0
<span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64
<span class="token builtin class-name">export</span> <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu-
//检测是否配置成功
<span class="token builtin class-name">echo</span> $ ARCH
<span class="token builtin class-name">echo</span> <span class="token variable">$CROSS_COMPILE</span>
</code></pre>
    <h4>
     <a id="3BusyBox_447">
     </a>
     3.配置编译BusyBox
    </h4>
    <p>
     修改源码以支持中文显示（可选）：
     <br/>
     打开文件 /libbb/printable_string.c，注释掉 printable_string 函数中 if (c &gt;= 0x7f) break; 的代码行。
     <br/>
     打开文件 /libbb/unicode.c，修改 unicode_conv_to_printable2 函数中的相关代码。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c0b80c2b9b44456ca79f4c7f3073a073.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5cf4483defcb4fd3941024c926d473c1.png"/>
     <br/>
     <strong>
      安装交叉编译工具链
     </strong>
     <br/>
     你需要安装适用于 ARM64 架构的交叉编译工具链。在 Ubuntu 或 Debian 系统上，可以运行以下命令：
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc-aarch64-linux-gnu
</code></pre>
    <p>
     <strong>
      配置busybox：有以下几种配置选项，一般使用默认配置即可
     </strong>
    </p>
    <pre><code class="prism language-bash">
<span class="token function">make</span> defconfig  	<span class="token comment">#使用默认配置</span>
<span class="token function">make</span> menuconfig		<span class="token comment">#打开图形化配置界面</span>
</code></pre>
    <p>
     如果出现这个错误，把终端窗口放大就行。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f5995f0ece47444f8d6ac422008d0914.png"/>
    </p>
    <p>
     ** 设置Settings -&gt; Build static binary (no shared libs)
     <br/>
     设置Settings -&gt; Support Unicode，使能busybox的unicode编码以支持中文**
    </p>
    <p>
     编译busybox：配置好busybox以后就可以编译了，输入如下命令
    </p>
    <pre><code class="prism language-bash">
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">make</span>
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">CONFIG_PREFIX</span><span class="token operator">=</span>/home/xm/linux/rootfs
<span class="token comment">#CONFIG_PREFIX指定编译结果的存放目录</span>
</code></pre>
    <p>
     如果出现这样的错误，操作如下：（我们下载的很多压缩包都是有bug或者和我们的操作版本不兼容的，出现这种本身自带的文件编译错误，可以直接找到位置更改）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a7fd18ce315e475094f01f8a745900d8.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e0b4a83419ca4ccb8cb25d9418b31269.png"/>
    </p>
    <p>
     编译完成以后，busybox的所有工具和文件就会被安装到rootfs目录中，如下图；rootfs目录下有bin、sbin和usr三个目录，以及linuxrc文件。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d81c6712d1534555aac691a88b0b8d9e.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a4c9d840747942969ee0b0b5e35b4bc4.png"/>
    </p>
    <h4>
     <a id="4_497">
     </a>
     4.创建需要的目录
    </h4>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span>  ~/linux/rootfs
<span class="token function">mkdir</span> dev etc lib sys proc tmp var home root mnt
</code></pre>
    <p>
     <strong>
      创建
      <code>
       profile
      </code>
      文件并添加内容
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /etc

<span class="token function">sudo</span> <span class="token function">nano</span> /etc/profile
</code></pre>
    <p>
     将以下内容复制粘贴到
     <code>
      profile
     </code>
     文件中：
    </p>
    <pre><code class="prism language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">HOSTNAME</span></span><span class="token operator">=</span>user
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span>root
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/home
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"[<span class="token environment constant">$USER</span>@<span class="token environment constant">$HOSTNAME</span> \W]\# "</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin
<span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/lib:/usr/lib:<span class="token variable">$LD_LIBRARY_PATH</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span> LD_LIBRARY_PATH
</code></pre>
    <p>
     保存并退出：
    </p>
    <ul>
     <li>
      按下
      <code>
       Ctrl + O
      </code>
      保存文件。
     </li>
     <li>
      按下
      <code>
       Enter
      </code>
      确认文件名。
     </li>
     <li>
      按下
      <code>
       Ctrl + X
      </code>
      退出
      <code>
       nano
      </code>
      。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c712b62f442f4bb4b6000414401ad205.png"/>
     </li>
    </ul>
    <p>
     <strong>
      创建
      <code>
       inittab
      </code>
      文件并添加内容
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /etc
<span class="token function">sudo</span> <span class="token function">nano</span> inittab
</code></pre>
    <p>
     将以下内容复制粘贴到
     <code>
      inittab
     </code>
     文件中：
    </p>
    <pre><code class="prism language-bash">::sysinit:/etc/init.d/rcS
::respawn:-/bin/sh
::askfirst:-/bin/sh
::ctrlaltdel:/bin/umount <span class="token parameter variable">-a</span> <span class="token parameter variable">-r</span>
</code></pre>
    <p>
     保存并退出：
    </p>
    <ul>
     <li>
      按下
      <code>
       Ctrl + O
      </code>
      保存文件。
     </li>
     <li>
      按下
      <code>
       Enter
      </code>
      确认文件名。
     </li>
     <li>
      按下
      <code>
       Ctrl + X
      </code>
      退出
      <code>
       nano
      </code>
      。
     </li>
    </ul>
    <p>
     <strong>
      创建
      <code>
       fstab
      </code>
      文件并添加内容
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /etc
<span class="token function">sudo</span> <span class="token function">nano</span> fstab
</code></pre>
    <p>
     将以下内容复制粘贴到
     <code>
      fstab
     </code>
     文件中：
    </p>
    <pre><code class="prism language-bash"><span class="token comment">#device  mount-point    type     options   dump   fsck order</span>
proc /proc proc defaults <span class="token number">0</span> <span class="token number">0</span>
tmpfs /tmp tmpfs defaults <span class="token number">0</span> <span class="token number">0</span>
sysfs /sys sysfs defaults <span class="token number">0</span> <span class="token number">0</span>
tmpfs /dev tmpfs defaults <span class="token number">0</span> <span class="token number">0</span>
debugfs /sys/kernel/debug debugfs defaults <span class="token number">0</span> <span class="token number">0</span>
kmod_mount /mnt 9p <span class="token assign-left variable">trans</span><span class="token operator">=</span>virtio <span class="token number">0</span> <span class="token number">0</span>
</code></pre>
    <p>
     保存并退出：
    </p>
    <ul>
     <li>
      按下
      <code>
       Ctrl + O
      </code>
      保存文件。
     </li>
     <li>
      按下
      <code>
       Enter
      </code>
      确认文件名。
     </li>
     <li>
      按下
      <code>
       Ctrl + X
      </code>
      退出
      <code>
       nano
      </code>
      。
     </li>
    </ul>
    <p>
     <strong>
      创建
      <code>
       init.d
      </code>
      目录并在其中创建
      <code>
       rcS
      </code>
      文件
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /etc
<span class="token function">mkdir</span> init.d
<span class="token builtin class-name">cd</span> init.d
<span class="token function">sudo</span> <span class="token function">nano</span> rcS
</code></pre>
    <p>
     将以下内容复制粘贴到
     <code>
      rcS
     </code>
     文件中：
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> init.d

<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /sys
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /tmp
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /proc
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /mnt
/bin/mount <span class="token parameter variable">-a</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /dev/pts
<span class="token function">mount</span> <span class="token parameter variable">-t</span> devpts devpts /dev/pts
<span class="token builtin class-name">echo</span> /sbin/mdev <span class="token operator">&gt;</span> /proc/sys/kernel/hotplug
mdev <span class="token parameter variable">-s</span>
</code></pre>
    <p>
     保存并退出：
    </p>
    <ul>
     <li>
      按下
      <code>
       Ctrl + O
      </code>
      保存文件。
     </li>
     <li>
      按下
      <code>
       Enter
      </code>
      确认文件名。
     </li>
     <li>
      按下
      <code>
       Ctrl + X
      </code>
      退出
      <code>
       nano
      </code>
      。
     </li>
    </ul>
    <p>
     <strong>
      添加权限
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">777</span> rcS
</code></pre>
    <p>
     <strong>
      检查
      <code>
       etc
      </code>
      目录结构
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> tree
<span class="token function">sudo</span> tree /etc
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/65248bec55384fefa6d4c56da00c5d1a.png"/>
    </p>
    <p>
     <strong>
      创建
      <code>
       dev
      </code>
      目录下的必要文件
     </strong>
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /dev
<span class="token function">sudo</span> <span class="token function">mknod</span> console c <span class="token number">5</span> <span class="token number">1</span>
</code></pre>
    <p>
     检查是否创建成功：
    </p>
    <pre><code class="prism language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> /dev/console
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/31b92feb46c14aedbecc2ef3f08f47d3.png"/>
    </p>
    <h4>
     <a id="5_lib__616">
     </a>
     5.复制动态库文件到
     <code>
      lib
     </code>
     目录
    </h4>
    <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /lib
<span class="token function">sudo</span> <span class="token function">cp</span> /usr/aarch64-linux-gnu/lib/*.so* <span class="token parameter variable">-a</span> <span class="token builtin class-name">.</span>
</code></pre>
    <p>
     检查当前目录是否包含了
     <code>
      .so
     </code>
     文件：
    </p>
    <pre><code class="prism language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> *.so*
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e74178ad44af4cc5ade8a20d09cba32b.png"/>
    </p>
    <h3>
     <a id="_16_ARM64_Linux__629">
     </a>
     （五）实验 1-6：编译和运行一个 ARM64 Linux 最小系统
    </h3>
    <h4>
     <a id="_631">
     </a>
     实验目的
    </h4>
    <p>
     本实验旨在指导你如何编译一个 ARM64 架构的 Linux 内核，并使用 QEMU 虚拟机运行该内核，同时加载一个简单的内核模块进行测试。
    </p>
    <h4>
     <a id="_634">
     </a>
     实验步骤
    </h4>
    <p>
     可以继承实验1-4的快照
    </p>
    <h4>
     <a id="1__636">
     </a>
     1. 编译内核源码
    </h4>
    <p>
     <strong>
      下载和解压源码
     </strong>
    </p>
    <ol>
     <li>
      访问 Linux 内核官网（https://www.kernel.org/），找到你需要的内核版本（如 linux-6.13.6.tar.xz）。
     </li>
     <li>
      使用
      <code>
       wget
      </code>
      命令下载源码：
      <pre><code class="prism language-bash"><span class="token function">wget</span> https://www.kernel.org/pub/linux/kernel/v6.x/linux-6.13.6.tar.xz
</code></pre>
     </li>
     <li>
      解压源码：
      <pre><code class="prism language-bash"><span class="token function">tar</span> xvf linux-6.13.6.tar.xz
</code></pre>
     </li>
    </ol>
    <p>
     <strong>
      指定编译工具
     </strong>
    </p>
    <ol>
     <li>
      设置架构为 arm64，并指定交叉编译工具链前缀为 aarch64-linux-gnu-：
      <pre><code class="prism language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64
<span class="token builtin class-name">export</span> <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu-
</code></pre>
     </li>
    </ol>
    <p>
     <strong>
      将根文件系统放到源码根目录
     </strong>
    </p>
    <ol>
     <li>
      使用
      <code>
       sudo cp
      </code>
      命令将构建好的根文件系统复制到内核源码根目录下：
      <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> ~/linux/rootfs rootfs_arm64 <span class="token parameter variable">-a</span>
</code></pre>
     </li>
    </ol>
    <p>
     <strong>
      配置生成.config
     </strong>
    </p>
    <ol>
     <li>
      运行
      <code>
       make defconfig
      </code>
      生成默认配置文件：
      <pre><code class="prism language-bash"><span class="token function">make</span> defconfig
</code></pre>
     </li>
     <li>
      运行
      <code>
       make menuconfig
      </code>
      打开图形化配置界面，进行以下配置：
      <ul>
       <li>
        添加 hotplug 支持：
        <pre><code>Device Drivers
    -&gt; Generic Driver Options
        -&gt; Support for uevent helper
            (/sbin/hotplug) path to uevent helper
</code></pre>
       </li>
       <li>
        添加 initramfs 支持：
        <pre><code>General setup ---&gt;
    [*]Initial RAM filesystem and RAM disk(initramfs/initrd) support
    (_install_arm64) Initramfs souce file(s)
</code></pre>
       </li>
       <li>
        配置 Virtual address space：
        <pre><code>Kernel Features  ---&gt;
    Page size(4KB)  ---&gt;
    Virtual address space size(48-bit)---&gt;
</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      编译
     </strong>
    </p>
    <ol>
     <li>
      运行
      <code>
       make all -j8
      </code>
      进行编译，
      <code>
       -j8
      </code>
      表示使用 8 个线程进行并行编译：
      <pre><code class="prism language-bash"><span class="token function">make</span> all <span class="token parameter variable">-j8</span>
</code></pre>
     </li>
    </ol>
    <h4>
     <a id="2__QEMU_694">
     </a>
     2. 启动 QEMU
    </h4>
    <ol>
     <li>
      运行以下命令启动 QEMU 虚拟机：
      <pre><code class="prism language-bash">qemu-system-aarch64 <span class="token parameter variable">-machine</span> virt <span class="token parameter variable">-cpu</span> cortex-a57 <span class="token parameter variable">-machine</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>virt <span class="token parameter variable">-m</span> <span class="token number">1024</span> <span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token parameter variable">-kernel</span> arch/arm64/boot/Image <span class="token parameter variable">--append</span> <span class="token string">"rdinit=/linuxrc root=/dev/vda rw console=ttyAMA0 loglevel=8"</span> <span class="token parameter variable">-nographic</span> <span class="token parameter variable">--fsdev</span> local,id<span class="token operator">=</span>kmod_dev,path<span class="token operator">=</span><span class="token environment constant">$PWD</span>/kmodules,security_model<span class="token operator">=</span>none <span class="token parameter variable">-device</span> virtio-9p-device,fsdev<span class="token operator">=</span>kmod_dev,mount_tag<span class="token operator">=</span>kmod_mount
</code></pre>
     </li>
    </ol>
    <h4>
     <a id="3__QEMU__700">
     </a>
     3. 编译一个简单的内核模块并在 QEMU 上运行
    </h4>
    <p>
     <strong>
      创建
      <code>
       module_test
      </code>
      文件夹并编写
      <code>
       hello.c
      </code>
      和
      <code>
       Makefile
      </code>
      文件
     </strong>
    </p>
    <ol>
     <li>
      创建
      <code>
       module_test
      </code>
      文件夹：
      <pre><code class="prism language-bash"><span class="token function">mkdir</span> module_test
<span class="token builtin class-name">cd</span> module_test
</code></pre>
     </li>
     <li>
      编写
      <code>
       hello.c
      </code>
      文件，内容如下：
      <pre><code class="prism language-c"><span class="token comment">// 包含内核模块编程所需的头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span>  <span class="token comment">// 包含模块初始化和退出函数的宏</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span>  <span class="token comment">// 包含模块相关的宏和函数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span>  <span class="token comment">// 包含内核打印函数 printk 的头文件</span></span>

<span class="token comment">// 模块初始化函数</span>
<span class="token comment">// 当模块被加载到内核时，此函数会被调用</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在内核日志中打印 "hello world!"</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 返回 0 表示初始化成功</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    

<span class="token comment">// 模块退出函数</span>
<span class="token comment">// 当模块从内核中卸载时，此函数会被调用</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">test_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 在内核日志中打印 "hello exit!"</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"hello exit!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 注册模块的初始化函数</span>
<span class="token comment">// 当模块被加载时，test_init 函数会被调用</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>test_init<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 注册模块的退出函数</span>
<span class="token comment">// 当模块被卸载时，test_exit 函数会被调用</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>test_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 声明模块的许可证</span>
<span class="token comment">// GPL 是 GNU 通用公共许可证，表示这是一个开源模块</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      编写
      <code>
       Makefile
      </code>
      文件，内容如下：
      <pre><code># 设置目标架构为 ARM64
export ARCH=arm64

# 设置交叉编译工具链前缀为 aarch64-linux-gnu-
export CROSS_COMPILE=aarch64-linux-gnu-

# 定义内核源码目录
KERNEL_DIR ?= /home/xm/linux-6.13.6

# 定义要编译的内核模块目标文件
# obj-m 表示将 hello.c 编译为内核模块 hello.ko
obj-m := hello.o

# 默认目标：编译内核模块
modules:
    # 调用内核源码目录的 Makefile，编译当前目录下的模块
    $(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules

# 清理目标：删除编译生成的文件
clean:
    # 调用内核源码目录的 Makefile，清理当前目录下的生成文件
    $(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean

# 安装目标：将编译好的内核模块复制到指定目录
install:
    # 将当前目录下所有的 .ko 文件复制到内核源码目录的 kmodules 子目录中
    cp *.ko $(KERNEL_DIR)/kmodules
</code></pre>
     </li>
    </ol>
    <p>
     <strong>
      编译模块并拷贝到共享目录
     </strong>
    </p>
    <ol>
     <li>
      运行
      <code>
       make modules
      </code>
      编译模块：
      <pre><code class="prism language-bash"><span class="token function">make</span> modules
</code></pre>
     </li>
     <li>
      运行
      <code>
       make install
      </code>
      将编译好的模块拷贝到内核源码目录的
      <code>
       kmodules
      </code>
      子目录中：
      <pre><code class="prism language-bash"><span class="token function">make</span> <span class="token function">install</span>
</code></pre>
     </li>
    </ol>
    <p>
     <strong>
      启动 QEMU 并在 QEMU 中执行模块的插入与卸载
     </strong>
    </p>
    <ol>
     <li>
      启动 QEMU 虚拟机（同上一步骤）。
     </li>
     <li>
      在 QEMU 中执行以下命令插入模块：
      <pre><code class="prism language-bash">insmod hello.ko
</code></pre>
     </li>
     <li>
      查看内核日志，确认模块加载成功：
      <pre><code class="prism language-bash"><span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">tail</span>
</code></pre>
     </li>
     <li>
      卸载模块：
      <pre><code class="prism language-bash">rmmod hello.ko
</code></pre>
     </li>
     <li>
      再次查看内核日志，确认模块卸载成功：
      <pre><code class="prism language-bash"><span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">tail</span>
</code></pre>
     </li>
    </ol>
    <h2>
     <a id="_805">
     </a>
     三.总结
    </h2>
    <p>
     本次实验学习“奔跑吧Linux内核”课件及资料，参照实验指导书中的第1章中的实验1-1到1-6的内容，进行学习理解和模仿实践。在实验过程中经历了很多次失败，感悟很多，推荐大家利用deepseek，kimi等大模型来处理报错，在这个过程之中，除了copy大模型给出的解决方法，也要重点学习一下它的思路（如下图），否则下一次还是可能会经历同样的错误。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2e8c25264cd54e07bdf535e97ee99ac8.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f43796e746869613034303333302f:61727469636c652f64657461696c732f313436303435363135" class_="artid" style="display:none">
 </p>
</div>


