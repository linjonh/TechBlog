---
layout: post
title: "C-WPF-基础知识学习四"
date: 2025-03-13 11:15:21 +0800
description: "在这个例子中，我们定义了一个名为MyProperty的依赖属性，类型为int，所属的类型是MyControl，默认值为 0。通过GetValue和SetValue方法来获取和设置依赖属性的值。"
keywords: "C# WPF 基础知识学习(四)"
categories: ['未分类']
tags: ['学习', 'Wpf', 'C']
artid: "146225823"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146225823
    alt: "C-WPF-基础知识学习四"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146225823
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146225823
cover: https://bing.ee123.net/img/rand?artid=146225823
image: https://bing.ee123.net/img/rand?artid=146225823
img: https://bing.ee123.net/img/rand?artid=146225823
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# WPF 基础知识学习(四)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     五、样式和模板
    </h3>
    <h4>
     5.1 样式基础
    </h4>
    <p>
     样式是一种用于集中设置 UI 元素属性的机制，可以将一组属性应用到多个元素上，实现统一的外观风格。样式可以定义在资源字典中，也可以直接在 XAML 文件中定义。
    </p>
    <h4>
     5.1 样式基础
    </h4>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Style x:Key="MyButtonStyle" TargetType="Button"&gt;
        &lt;Setter Property="Background" Value="LightGreen"/&gt;
        &lt;Setter Property="Foreground" Value="Black"/&gt;
        &lt;Setter Property="FontSize" Value="16"/&gt;
        &lt;Setter Property="Padding" Value="10"/&gt;
    &lt;/Style&gt;
&lt;/Window.Resources&gt;
&lt;Button Style="{StaticResource MyButtonStyle}" Content="Styled Button"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个例子中，我们在
     <code>
      Window.Resources
     </code>
     里定义了一个名为
     <code>
      MyButtonStyle
     </code>
     的样式，其目标类型是
     <code>
      Button
     </code>
     。通过
     <code>
      Setter
     </code>
     元素，我们设置了按钮的背景色、前景色、字体大小和内边距。然后将这个样式应用到一个按钮上，使得该按钮具有我们所定义的外观。
    </p>
    <h5>
     样式继承
    </h5>
    <p>
     样式可以继承其他样式的属性，通过
     <code>
      BasedOn
     </code>
     属性来实现。例如：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Style x:Key="BaseButtonStyle" TargetType="Button"&gt;
        &lt;Setter Property="Background" Value="LightBlue"/&gt;
        &lt;Setter Property="Foreground" Value="White"/&gt;
    &lt;/Style&gt;
    &lt;Style x:Key="DerivedButtonStyle" TargetType="Button" BasedOn="{StaticResource BaseButtonStyle}"&gt;
        &lt;Setter Property="FontSize" Value="18"/&gt;
    &lt;/Style&gt;
&lt;/Window.Resources&gt;
&lt;Button Style="{StaticResource DerivedButtonStyle}" Content="Inherited Styled Button"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     这里
     <code>
      DerivedButtonStyle
     </code>
     继承了
     <code>
      BaseButtonStyle
     </code>
     的属性，同时又添加了自己的
     <code>
      FontSize
     </code>
     属性。这样可以提高样式的复用性，避免重复定义相同的属性。
    </p>
    <h4>
     5.2 隐式样式
    </h4>
    <p>
     隐式样式是一种不指定
     <code>
      x:Key
     </code>
     的样式，它会自动应用到所有指定
     <code>
      TargetType
     </code>
     的元素上。例如：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Style TargetType="TextBox"&gt;
        &lt;Setter Property="Background" Value="LightYellow"/&gt;
        &lt;Setter Property="BorderBrush" Value="Gray"/&gt;
        &lt;Setter Property="BorderThickness" Value="1"/&gt;
    &lt;/Style&gt;
&lt;/Window.Resources&gt;
&lt;TextBox Text="Implicit Styled TextBox"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个窗口中的所有
     <code>
      TextBox
     </code>
     都会自动应用这个样式，无需显式地指定样式。
    </p>
    <h4>
     5.3 模板基础
    </h4>
    <h5>
     5.3.1 ControlTemplate
    </h5>
    <p>
     <code>
      ControlTemplate
     </code>
     用于自定义控件的外观。它可以完全改变控件的可视化结构，而不仅仅是设置属性。例如，自定义一个按钮的模板：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;ControlTemplate x:Key="CustomButtonTemplate" TargetType="Button"&gt;
        &lt;Border x:Name="border" Background="{TemplateBinding Background}" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"&gt;
            &lt;ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/&gt;
        &lt;/Border&gt;
        &lt;ControlTemplate.Triggers&gt;
            &lt;Trigger Property="IsMouseOver" Value="True"&gt;
                &lt;Setter TargetName="border" Property="Background" Value="LightGray"/&gt;
            &lt;/Trigger&gt;
            &lt;Trigger Property="IsPressed" Value="True"&gt;
                &lt;Setter TargetName="border" Property="Background" Value="DarkGray"/&gt;
            &lt;/Trigger&gt;
        &lt;/ControlTemplate.Triggers&gt;
    &lt;/ControlTemplate&gt;
&lt;/Window.Resources&gt;
&lt;Button Template="{StaticResource CustomButtonTemplate}" Content="Custom Button"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个模板中，我们使用
     <code>
      Border
     </code>
     元素作为按钮的外层容器，通过
     <code>
      TemplateBinding
     </code>
     将
     <code>
      Border
     </code>
     的属性绑定到按钮的属性上。
     <code>
      ContentPresenter
     </code>
     用于显示按钮的内容。
     <code>
      ControlTemplate.Triggers
     </code>
     部分定义了触发条件，当鼠标悬停或按钮被按下时，改变
     <code>
      Border
     </code>
     的背景色。
    </p>
    <h5>
     5.3.2 DataTemplate
    </h5>
    <p>
     <code>
      DataTemplate
     </code>
     用于定义数据项的呈现方式。当我们将一个集合绑定到一个列表控件（如
     <code>
      ListView
     </code>
     、
     <code>
      ComboBox
     </code>
     等）时，
     <code>
      DataTemplate
     </code>
     可以决定每个数据项在界面上的显示形式。例如：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;DataTemplate x:Key="PersonDataTemplate"&gt;
        &lt;StackPanel Orientation="Horizontal"&gt;
            &lt;TextBlock Text="{Binding Name}" Margin="5"/&gt;
            &lt;TextBlock Text="{Binding Age}" Margin="5"/&gt;
        &lt;/StackPanel&gt;
    &lt;/DataTemplate&gt;
&lt;/Window.Resources&gt;
&lt;ListBox ItemsSource="{Binding Persons}" ItemTemplate="{StaticResource PersonDataTemplate}"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     假设
     <code>
      Persons
     </code>
     是一个包含
     <code>
      Person
     </code>
     对象的集合，每个
     <code>
      Person
     </code>
     对象有
     <code>
      Name
     </code>
     和
     <code>
      Age
     </code>
     属性。
     <code>
      PersonDataTemplate
     </code>
     定义了每个
     <code>
      Person
     </code>
     对象在
     <code>
      ListBox
     </code>
     中的显示方式，即使用一个水平的
     <code>
      StackPanel
     </code>
     显示姓名和年龄。
    </p>
    <h4>
     5.4 资源字典
    </h4>
    <p>
     资源字典是一种用于集中管理样式、模板、画笔等资源的机制。可以将资源字典定义在单独的
     <code>
      .xaml
     </code>
     文件中，然后在多个 XAML 文件中引用。
    </p>
    <h5>
     创建资源字典文件
    </h5>
    <p>
     创建一个名为
     <code>
      MyResources.xaml
     </code>
     的文件，内容如下：
    </p>
    <pre><code class="language-XML">&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
    &lt;Style x:Key="SharedButtonStyle" TargetType="Button"&gt;
        &lt;Setter Property="Background" Value="Orange"/&gt;
        &lt;Setter Property="Foreground" Value="White"/&gt;
    &lt;/Style&gt;
    &lt;DataTemplate x:Key="SharedDataTemplate"&gt;
        &lt;TextBlock Text="{Binding SomeProperty}" Foreground="Red"/&gt;
    &lt;/DataTemplate&gt;
&lt;/ResourceDictionary&gt;
</code></pre>
    <h5>
     在 XAML 文件中引用资源字典
    </h5>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;ResourceDictionary&gt;
        &lt;ResourceDictionary.MergedDictionaries&gt;
            &lt;ResourceDictionary Source="MyResources.xaml"/&gt;
        &lt;/ResourceDictionary.MergedDictionaries&gt;
    &lt;/ResourceDictionary&gt;
&lt;/Window.Resources&gt;
&lt;Button Style="{StaticResource SharedButtonStyle}" Content="Shared Styled Button"/&gt;
&lt;ListBox ItemsSource="{Binding SomeCollection}" ItemTemplate="{StaticResource SharedDataTemplate}"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     通过这种方式，我们可以在多个窗口或控件中共享资源，提高代码的可维护性和复用性。
    </p>
    <h3>
     六、动画和多媒体
    </h3>
    <h4>
     6.1 动画基础
    </h4>
    <p>
     WPF 的动画系统允许开发者对 UI 元素的属性进行动态变化，从而创建出各种生动的效果。动画主要分为线性动画、关键帧动画和路径动画。
    </p>
    <h5>
     6.1.1 线性动画
    </h5>
    <p>
     线性动画是最简单的动画类型，它在指定的时间内从一个值线性变化到另一个值。例如，实现一个按钮在点击时逐渐变大的动画：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Storyboard x:Key="GrowButtonAnimation"&gt;
        &lt;DoubleAnimation Storyboard.TargetProperty="Width"
                         From="100" To="150" Duration="0:0:1"/&gt;
        &lt;DoubleAnimation Storyboard.TargetProperty="Height"
                         From="50" To="75" Duration="0:0:1"/&gt;
    &lt;/Storyboard&gt;
&lt;/Window.Resources&gt;
&lt;Button Content="Animate Me" Click="Button_Click"&gt;
    &lt;Button.Triggers&gt;
        &lt;EventTrigger RoutedEvent="Button.Click"&gt;
            &lt;BeginStoryboard Storyboard="{StaticResource GrowButtonAnimation}"/&gt;
        &lt;/EventTrigger&gt;
    &lt;/Button.Triggers&gt;
&lt;/Button&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个例子中，我们定义了一个
     <code>
      Storyboard
     </code>
     ，其中包含两个
     <code>
      DoubleAnimation
     </code>
     ，分别对按钮的
     <code>
      Width
     </code>
     和
     <code>
      Height
     </code>
     属性进行动画处理。
     <code>
      From
     </code>
     属性指定起始值，
     <code>
      To
     </code>
     属性指定结束值，
     <code>
      Duration
     </code>
     属性指定动画的持续时间。当按钮被点击时，触发
     <code>
      EventTrigger
     </code>
     ，开始播放动画。
    </p>
    <h5>
     6.1.2 关键帧动画
    </h5>
    <p>
     关键帧动画允许在动画过程中定义多个关键帧，每个关键帧指定一个特定的时间点和属性值。例如，实现一个按钮在不同时间点改变颜色的动画：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Storyboard x:Key="ColorAnimationStoryboard"&gt;
        &lt;ColorAnimationUsingKeyFrames Storyboard.TargetProperty="(Control.Background).(SolidColorBrush.Color)" Duration="0:0:3"&gt;
            &lt;LinearColorKeyFrame Value="Red" KeyTime="0:0:0"/&gt;
            &lt;LinearColorKeyFrame Value="Green" KeyTime="0:0:1"/&gt;
            &lt;LinearColorKeyFrame Value="Blue" KeyTime="0:0:2"/&gt;
            &lt;LinearColorKeyFrame Value="Yellow" KeyTime="0:0:3"/&gt;
        &lt;/ColorAnimationUsingKeyFrames&gt;
    &lt;/Storyboard&gt;
&lt;/Window.Resources&gt;
&lt;Button Content="Color Animate" Click="Button_Click_1"&gt;
    &lt;Button.Triggers&gt;
        &lt;EventTrigger RoutedEvent="Button.Click"&gt;
            &lt;BeginStoryboard Storyboard="{StaticResource ColorAnimationStoryboard}"/&gt;
        &lt;/EventTrigger&gt;
    &lt;/Button.Triggers&gt;
&lt;/Button&gt;
</code></pre>
    <p>
    </p>
    <p>
     这里使用
     <code>
      ColorAnimationUsingKeyFrames
     </code>
     定义了一个颜色动画，通过
     <code>
      LinearColorKeyFrame
     </code>
     指定了不同时间点的颜色值。动画会在指定的时间内依次过渡到各个关键帧的颜色。
    </p>
    <h5>
     6.1.3 路径动画
    </h5>
    <p>
     路径动画允许元素沿着指定的路径移动。例如，让一个椭圆沿着一个圆形路径移动：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;Storyboard x:Key="PathAnimationStoryboard"&gt;
        &lt;PointAnimationUsingPath Storyboard.TargetProperty="(Canvas.LeftProperty)"
                                 Storyboard.TargetName="ellipse"
                                 Duration="0:0:5"
                                 RepeatBehavior="Forever"&gt;
            &lt;PointAnimationUsingPath.PathGeometry&gt;
                &lt;EllipseGeometry Center="200,200" RadiusX="100" RadiusY="100"/&gt;
            &lt;/PointAnimationUsingPath.PathGeometry&gt;
        &lt;/PointAnimationUsingPath&gt;
        &lt;PointAnimationUsingPath Storyboard.TargetProperty="(Canvas.TopProperty)"
                                 Storyboard.TargetName="ellipse"
                                 Duration="0:0:5"
                                 RepeatBehavior="Forever"&gt;
            &lt;PointAnimationUsingPath.PathGeometry&gt;
                &lt;EllipseGeometry Center="200,200" RadiusX="100" RadiusY="100"/&gt;
            &lt;/PointAnimationUsingPath.PathGeometry&gt;
        &lt;/PointAnimationUsingPath&gt;
    &lt;/Storyboard&gt;
&lt;/Window.Resources&gt;
&lt;Canvas&gt;
    &lt;Ellipse x:Name="ellipse" Width="20" Height="20" Fill="Red" Canvas.Left="100" Canvas.Top="100"/&gt;
    &lt;Button Content="Start Animation" Canvas.Left="10" Canvas.Top="10" Click="Button_Click_2"&gt;
        &lt;Button.Triggers&gt;
            &lt;EventTrigger RoutedEvent="Button.Click"&gt;
                &lt;BeginStoryboard Storyboard="{StaticResource PathAnimationStoryboard}"/&gt;
            &lt;/EventTrigger&gt;
        &lt;/Button.Triggers&gt;
    &lt;/Button&gt;
&lt;/Canvas&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，使用
     <code>
      PointAnimationUsingPath
     </code>
     让椭圆沿着一个圆形路径移动，路径由
     <code>
      EllipseGeometry
     </code>
     定义。
     <code>
      RepeatBehavior="Forever"
     </code>
     表示动画会无限循环播放。
    </p>
    <h4>
     6.2 多媒体支持
    </h4>
    <p>
     WPF 提供了对多媒体的支持，包括音频和视频的播放。可以使用
     <code>
      MediaElement
     </code>
     控件来播放多媒体文件。
    </p>
    <h5>
     播放视频
    </h5>
    <pre><code class="language-XML">&lt;MediaElement Source="video.mp4" Width="640" Height="360"
              LoadedBehavior="Play" UnloadedBehavior="Stop"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     在这个示例中，
     <code>
      MediaElement
     </code>
     控件的
     <code>
      Source
     </code>
     属性指定了要播放的视频文件的路径。
     <code>
      LoadedBehavior
     </code>
     属性设置为
     <code>
      Play
     </code>
     表示当控件加载完成后自动播放视频，
     <code>
      UnloadedBehavior
     </code>
     属性设置为
     <code>
      Stop
     </code>
     表示当控件卸载时停止播放视频。
    </p>
    <h5>
     播放音频
    </h5>
    <pre><code class="language-XML">&lt;MediaElement Source="audio.mp3" Width="0" Height="0"
              LoadedBehavior="Play" UnloadedBehavior="Stop"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     对于音频播放，我们可以将控件的宽度和高度设置为 0，使其在界面上不可见。同样，通过
     <code>
      Source
     </code>
     属性指定音频文件的路径，通过
     <code>
      LoadedBehavior
     </code>
     和
     <code>
      UnloadedBehavior
     </code>
     属性控制播放和停止行为。
    </p>
    <h3>
     七、命令系统
    </h3>
    <h4>
     7.1 命令基础
    </h4>
    <p>
     WPF 的命令系统提供了一种将用户操作（如按钮点击、菜单项选择等）与业务逻辑分离的机制。命令是一种抽象的操作，它定义了操作的执行逻辑和是否可以执行的判断逻辑。
    </p>
    <h4>
     7.2 实现命令
    </h4>
    <p>
     WPF 中常用的命令实现方式是使用
     <code>
      RelayCommand
     </code>
     类，它是一个自定义的命令类，实现了
     <code>
      ICommand
     </code>
     接口。
    </p>
    <h5>
     RelayCommand 类的实现
    </h5>
    <pre><code class="language-cs">public class RelayCommand : ICommand
{
    private readonly Action&lt;object&gt; _execute;
    private readonly Predicate&lt;object&gt; _canExecute;

    public RelayCommand(Action&lt;object&gt; execute, Predicate&lt;object&gt; canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }

    public void Execute(object parameter)
    {
        _execute(parameter);
    }
}
</code></pre>
    <h5>
     在 ViewModel 中使用 RelayCommand
    </h5>
    <pre><code class="language-cs">public class MainViewModel
{
    public RelayCommand MyCommand { get; set; }

    public MainViewModel()
    {
        MyCommand = new RelayCommand(ExecuteMyCommand, CanExecuteMyCommand);
    }

    private void ExecuteMyCommand(object parameter)
    {
        // 执行命令的逻辑
        MessageBox.Show("Command executed!");
    }

    private bool CanExecuteMyCommand(object parameter)
    {
        // 判断命令是否可以执行的逻辑
        return true;
    }
}
</code></pre>
    <h5>
     在 XAML 中绑定命令
    </h5>
    <pre><code class="language-XML">&lt;Button Content="Execute Command" Command="{Binding MyCommand}"/&gt;
</code></pre>
    <p>
    </p>
    <p>
     当按钮被点击时，会调用
     <code>
      MainViewModel
     </code>
     中的
     <code>
      ExecuteMyCommand
     </code>
     方法。
    </p>
    <h4>
     7.3 系统命令
    </h4>
    <p>
     WPF 还提供了一些内置的系统命令，如
     <code>
      ApplicationCommands.New
     </code>
     、
     <code>
      ApplicationCommands.Open
     </code>
     、
     <code>
      ApplicationCommands.Save
     </code>
     等。这些命令可以直接在 XAML 中使用，并且会自动处理一些常见的操作，如快捷键绑定、命令状态更新等。
    </p>
    <pre><code class="language-XML">&lt;Menu&gt;
    &lt;MenuItem Header="File"&gt;
        &lt;MenuItem Header="New" Command="{x:Static ApplicationCommands.New}"/&gt;
        &lt;MenuItem Header="Open" Command="{x:Static ApplicationCommands.Open}"/&gt;
        &lt;MenuItem Header="Save" Command="{x:Static ApplicationCommands.Save}"/&gt;
    &lt;/MenuItem&gt;
&lt;/Menu&gt;
</code></pre>
    <p>
    </p>
    <p>
     通过使用系统命令，我们可以快速实现一些常见的功能，提高开发效率。
    </p>
    <h3>
     八、依赖属性和路由事件
    </h3>
    <h4>
     8.1 依赖属性
    </h4>
    <h5>
     8.1.1 依赖属性基础
    </h5>
    <p>
     依赖属性是 WPF 中的一种特殊属性，它的行为不同于普通的.NET 属性。依赖属性由
     <code>
      DependencyProperty
     </code>
     类表示，它支持数据绑定、样式设置、动画等功能。依赖属性的值可以由多种因素决定，如默认值、样式设置、数据绑定等。
    </p>
    <h5>
     8.1.2 定义依赖属性
    </h5>
    <p>
     要定义一个依赖属性，需要遵循以下步骤：
    </p>
    <pre><code class="language-cs">public class MyControl : Control
{
    public static readonly DependencyProperty MyPropertyProperty =
        DependencyProperty.Register("MyProperty", typeof(int), typeof(MyControl), new PropertyMetadata(0));

    public int MyProperty
    {
        get { return (int)GetValue(MyPropertyProperty); }
        set { SetValue(MyPropertyProperty, value); }
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在这个例子中，我们定义了一个名为
     <code>
      MyProperty
     </code>
     的依赖属性，类型为
     <code>
      int
     </code>
     ，所属的类型是
     <code>
      MyControl
     </code>
     ，默认值为 0。通过
     <code>
      GetValue
     </code>
     和
     <code>
      SetValue
     </code>
     方法来获取和设置依赖属性的值。
    </p>
    <h5>
     8.1.3 依赖属性的用途
    </h5>
    <p>
     依赖属性的主要用途包括：
    </p>
    <ul>
     <li>
      <strong>
       数据绑定
      </strong>
      ：依赖属性可以作为数据绑定的目标，实现 UI 元素与数据源的双向绑定。
     </li>
     <li>
      <strong>
       样式设置
      </strong>
      ：可以在样式中设置依赖属性的值，实现统一的外观风格。
     </li>
     <li>
      <strong>
       动画效果
      </strong>
      ：可以对依赖属性进行动画处理，创建各种动态效果。
     </li>
    </ul>
    <h4>
     8.2 路由事件
    </h4>
    <h5>
     8.2.1 路由事件基础
    </h5>
    <p>
     路由事件是 WPF 中一种特殊的事件机制，它允许事件在元素树中进行传播。路由事件有三种传播方式：冒泡、隧道和直接。
    </p>
    <ul>
     <li>
      <strong>
       冒泡事件
      </strong>
      ：事件从事件源开始，向上级元素依次传播，直到到达根元素或事件被处理。
     </li>
     <li>
      <strong>
       隧道事件
      </strong>
      ：事件从根元素开始，向下级元素依次传播，直到到达事件源或事件被处理。
     </li>
     <li>
      <strong>
       直接事件
      </strong>
      ：事件只在事件源上触发，不会在元素树中传播。
     </li>
    </ul>
    <h5 style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/0e8a39eb72bc4997a0b34d4f3a5ce050.png"/>
    </h5>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34343937353831342f:61727469636c652f64657461696c732f313436323235383233" class_="artid" style="display:none">
 </p>
</div>


