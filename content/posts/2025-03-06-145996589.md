---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303735343230332f:61727469636c652f64657461696c732f313435393936353839"
layout: post
title: "è“æ¡¥æ¯åµŒå…¥å¼ç»„ç¬¬ä¸ƒå±Šçœèµ›é¢˜ç›®è§£æSTM32G431RBT6å®ç°æºç "
date: 2025-03-06 08:00:00 +0800
description: "STM32G431RBT6å®ç°åµŒå…¥å¼ç»„ç¬¬ä¸ƒå±Šé¢˜ç›®è§£æ+æºç ã€‚"
keywords: "è“æ¡¥æ¯åµŒå…¥å¼ç»„ç¬¬ä¸ƒå±Šçœèµ›é¢˜ç›®è§£æ+STM32G431RBT6å®ç°æºç "
categories: ['å•ç‰‡æœº']
tags: ['è“æ¡¥æ¯', 'å­¦ä¹ ', 'å•ç‰‡æœº', 'Stm', 'C']
artid: "145996589"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145996589
    alt: "è“æ¡¥æ¯åµŒå…¥å¼ç»„ç¬¬ä¸ƒå±Šçœèµ›é¢˜ç›®è§£æSTM32G431RBT6å®ç°æºç "
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145996589
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145996589
cover: https://bing.ee123.net/img/rand?artid=145996589
image: https://bing.ee123.net/img/rand?artid=145996589
img: https://bing.ee123.net/img/rand?artid=145996589
---

# è“æ¡¥æ¯åµŒå…¥å¼ç»„ç¬¬ä¸ƒå±Šçœèµ›é¢˜ç›®è§£æ+STM32G431RBT6å®ç°æºç 

å‰è¨€ï¼šSTM32G431RBT6å®ç°åµŒå…¥å¼ç»„ç¬¬ä¸ƒå±Šé¢˜ç›®è§£æ+æºç ï¼Œæœ¬æ–‡é»˜è®¤è¯»è€…å…·å¤‡åŸºç¡€çš„stm32çŸ¥è¯†ã€‚æ–‡ç« æœ«å°¾æœ‰ç¬¬ä¸ƒå±Šé¢˜ç›®ã€‚

## 1.é¢˜ç›®è§£æ

### 1.1 åˆ†è€Œæ²»ä¹‹ï¼Œè—•æ–­ä¸è¿

è¿˜æ˜¯é‚£å¥è¯ï¼Œå°†ä¸åŒæ¨¡å—è¿›è¡Œå°è£…ï¼Œé€šè¿‡å˜é‡è¿›è¡Œæ¨¡å—é—´çš„åˆä½œã€‚

### 1.2 æ¨¡å—åŒ–æ€ç»´å¯¼å›¾

ä¸‹å›¾æ ¹æ®é¢˜ç›®æ¢³ç†ã€‚ç¬¬å…­å±Šæ²¡æœ‰å†™è¿™ä¹ˆè¯¦ç»†ï¼ˆä¸»è¦æ˜¯æ‡’ğŸ˜€ï¼‰ã€‚
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/2be6fdefdd314408aea9a4ac52152b19.png)

### 1.3 æ¨¡å—è§£æ

æ•´åˆæ¨¡å—ï¼Œé€»è¾‘æ€ç»´ã€‚

#### 1.3.1 KEYæ¨¡å—

B1ï¼šç•Œé¢1ï¼Œ2ä¹‹é—´åˆ‡æ¢ï¼Œæ–¹æ³•ï¼šè®¡æ•°ï¼›0ï¼šè¡¨ç¤ºç•Œé¢1ï¼Œ1ï¼šè¡¨ç¤ºç•Œé¢2ã€‚
  
B2ï¼šä¸‰ç§é˜ˆå€¼ä½ä¹‹é—´åˆ‡æ¢ï¼Œæ–¹æ³•ï¼šè®¡æ•°ï¼›0ï¼šè¡¨ç¤ºT1ï¼Œ1ï¼šè¡¨ç¤ºT2ï¼Œ2ï¼šè¡¨ç¤ºT3ã€‚
  
B3ï¼šæ¯æ¬¡åŠ 5ï¼Œä¸Šé™95ï¼ˆå„é˜ˆå€¼ä¹‹é—´è¿˜åº”è¯¥T1<T2<T3ï¼Œ ä½†æ˜¯æˆ‘æ²¡å†™ğŸ˜…ï¼‰ã€‚
  
B4ï¼šæ¯æ¬¡å‡5ï¼Œä¸‹é™5ã€‚

```c
//B1ï¼ŒB4ï¼ŒB3éƒ½æ˜¯åŒæ ·çš„æ ¼å¼
if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET) //B1
    {
        if(HAL_GetTick() - tick > KEY_REDUCTION){    //æŒ‰é”®æ¶ˆæŠ–
            tick = HAL_GetTick();
              keyS->bits.B1 ^= 1;    
//            keyS->bits.B1++;
//            if(keyS->bits.B1 == 2) keyS->bits.B1 = 0;
            while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET); //å®ç°æŒ‰ä¸‹ä¸€æ¬¡åªè®¡æ•°ä¸€æ¬¡
        }
    }
//B2å¤šäº†ä¸€ç§çŠ¶æ€
else if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET) //B2
    {
        if(HAL_GetTick() - tick > KEY_REDUCTION){
            tick = HAL_GetTick();
            keyS->bits.B2++;
            if(keyS->bits.B2 == 3) keyS->bits.B2 = 0;
            while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);
        }
    }

```

#### 1.3.2 ADCæ¨¡å—

é‡‡é›†å¯è°ƒç”µä½å™¨ç”µå‹ã€‚é»˜è®¤10æ¬¡ä¸ºä¸€ç»„è¿›è¡Œä¸€æ¬¡æ»¤æ³¢ã€‚
  
å‡å¦‚ä½¿ç”¨0.2sæ—¶åŸºæ¥å¼€å¯adcé‡‡é›†ï¼Œé‡‡é›†10æ¬¡éœ€2så“åº”å¤ªæ…¢ï¼Œæ”¾åœ¨systickä¸­æ–­ä¸­ï¼Œç¨‹åºå†™åˆ°åé¢æ—¶é—´1msæ˜¾çŸ­ï¼Œæˆ‘å°±å¤šä½¿ç”¨äº†ä¸€ä¸ªtimäº§ç”Ÿ0.5sæ—¶åŸºï¼Œä¸ç”¨ç™½ä¸ç”¨ã€‚ä¹Ÿå¯ä½¿ç”¨ä¸€ä¸ª0.5çš„å°±è¡Œï¼Œç´¯è®¡4æ¬¡å°±æ‰§è¡Œä¸€æ¬¡éœ€0.2sæ—¶åŸºæ¨¡å—ã€‚ä¹Ÿå¯ä½¿ç”¨dmaé‡‡é›†ã€‚

```c
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
    if(adc_smp_flag < (FILTER_LEN+1))
    {
        adc_smp_flag++;
        adc_smp_vtg.smp_val[adc_smp_flag] = HAL_ADC_GetValue(hadc);
        if(adc_smp_flag == (FILTER_LEN+1))
        {
            adc_smp_flag =0;
            filter_process(&adc_smp_vtg);    //ç´¯åŠ ç›¸é™¤
        }
    }
}

typedef struct{
    uint32_t smp_val[FILTER_LEN];
    uint32_t filter_val;
} adc_smp_t;

```

#### 1.3.3 IICæ¨¡å—

å®Œæˆeepromä¸­æ•°æ®çš„è¯»å†™ã€‚å¼€å‘æ¿çš„PB6å’ŒPB7è®¾ç½®ä¸º
**å¼€æ¼è¾“å‡º**
ï¼Œä½¿ç”¨è½¯ä»¶æ¨¡æ‹Ÿå®ç°å•å­—èŠ‚æ•°æ®çš„è¯»å†™ã€‚
**æ³¨æ„ï¼šé­”æœ¯æ£’->c\c+Â±>optimizationé€‰é¡¹è¦è®¾ç½®æˆ-O0ï¼Œè¦ä¸ç„¶ä»£ç æ‰§è¡Œåå¾—ä¸åˆ°æƒ³è¦çš„ç»“æœã€‚**
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/60d05ee4785c4cc89735369b7aecdaff.png)
  
*å…·ä½“å®ç°çœ‹ç¬¬äºŒéƒ¨åˆ†æºç ã€‚*

```c
/* è½¯ä»¶æ¨¡æ‹Ÿå®ç°at24c02å•å­—èŠ‚å†™å…¥ */
void at24c02_write(uint8_t addr, uint8_t data){
  ...
}

/* è½¯ä»¶æ¨¡æ‹Ÿå®ç°at24c02å•å­—èŠ‚è¯»å– */
uint8_t at24c02_read(uint8_t addr){
  ...
}

/* i2cå‘eepromå†™å…¥data */
void iic_write()
{
    ...
}
...


```

#### 1.3.4 UARTæ¨¡å—

UARTæ¥æ”¶PCç«¯æŸ¥è¯¢ç â€™Câ€™, â€˜Sâ€™ï¼Œåšå‡ºç›¸åº”çš„å›åº”ã€‚
  
*å…·ä½“å®ç°çœ‹ç¬¬äºŒéƒ¨åˆ†æºç ã€‚*

```c
//ä¸­æ–­è§¦å‘å›è°ƒå‡½æ•°
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
  ...
}
//å®šæ—¶ä¸ŠæŠ¥æ•°æ®
void uart_inform_PC()
{
 ...
}

```

#### 1.3.5 LCDæ¨¡å—

å°†æ¶‰åŠåˆ°çš„æ•°æ®æ˜¾ç¤ºåˆ°lcdå±å¹•ä¸Šï¼Œä»½ç•Œé¢1å’Œç•Œé¢2ã€‚
  
*å…·ä½“å®ç°çœ‹ç¬¬äºŒéƒ¨åˆ†æºç ã€‚*

```c
void lcd_process()
{
    if
    {
        //1ï¼šif ç•Œé¢1ï¼Œ2åˆ‡æ¢æ¸…å±
        //2ï¼šLCDæ˜¾ç¤ºæ•°æ®
        //3ï¼šifè®¾ç½®é˜ˆå€¼æˆåŠŸååˆ‡æ¢åˆ°ç•Œé¢1ï¼Œå°†set_throså†™å…¥eeprom
    }
    else
    {
        //1ï¼šif ç•Œé¢1ï¼Œ2åˆ‡æ¢æ¸…å±
        //2ï¼šif æ˜¾ç¤ºthros1ä¸ºç»¿è‰²+è®¾ç½®è¯¥é˜ˆå€¼
        //3ï¼šelse if æ˜¾ç¤ºthros2ä¸ºç»¿è‰²+è®¾ç½®è¯¥é˜ˆå€¼
        //4ï¼šelse if æ˜¾ç¤ºthros3ä¸ºç»¿è‰²+è®¾ç½®è¯¥é˜ˆå€¼
    }
}

```

#### 1.3.6 LEDæ¨¡å—

è¿™å±Šé¢˜ç›®æˆ‘æ„Ÿè§‰éš¾åº¦å°±åœ¨ledçš„å¤„ç†ä¸Šé¢ï¼Œçœ‹ç€é¢˜ç›®è¦æ±‚éå¸¸ç®€å•ï¼Œæ­£å¸¸æ€è·¯å½“äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™ï¼Œä½¿ç”¨HAL\_GPIO\_TogglePin()ç¿»è½¬ledå¯¹åº”å¼•è„šç”µå¹³å°±è¡Œï¼Œä½†æ˜¯æˆ‘ä»¬ä½¿ç”¨åˆ°äº†lcdå±å¹•ï¼Œlcdå±å¹•ä¹Ÿä½¿ç”¨åˆ°PC8-PC15è¿™äº›å¼•è„šï¼Œæ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡å†™å…¥ledçŠ¶æ€çš„æ—¶å€™å¯¹å…¶ä»–ledå¼•è„šä¹Ÿå¾—è€ƒè™‘ã€‚æˆ‘å°±è¢«ç»•è¿›å»äº†ï¼Œæ•´äº†æˆ‘2ä¸ªå¤šå°æ—¶ã€‚è¿˜æ˜¯å› ä¸ºé€»è¾‘æ€ç»´ä¸å¤Ÿå¼ºï¼Œä»£ç å†™å°‘äº†ğŸ˜¶ã€‚
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/16b8b95ceee64384ad575f3c71a41b3d.png)
  
ä¸‰ç§äº‹ä»¶ç›¸äº’ä¹‹é—´ä¿æŒç‹¬ç«‹ã€‚æˆ‘ä»¬åˆ†æä¸€ä¸‹ä¸‰ä¸ªäº‹ä»¶ä¹‹é—´çš„å…³ç³»ï¼š
  
LD1ï¼šæ¯éš”1säº®ç­é—ªçƒï¼Œäº‹ä»¶å‘¨æœŸæ€§è§¦å‘ã€‚
  
LD2ï¼š0.2sé—´éš”é—ªçƒ5æ¬¡ï¼Œä½†æ˜¯äº‹ä»¶è§¦å‘æ²¡æœ‰å‘¨æœŸæ€§ï¼Œæ¶²ä½ç­‰çº§å˜åŒ–è§¦å‘ä¸€æ¬¡ã€‚
  
LD3ï¼š0.2sé—´éš”é—ªçƒ5æ¬¡ï¼Œä½†æ˜¯äº‹ä»¶è§¦å‘æ²¡æœ‰å‘¨æœŸæ€§ï¼Œæ¥æ”¶åˆ°æŸ¥è¯¢æŒ‡ä»¤è§¦å‘ä¸€æ¬¡ã€‚
  
æ‰€ä»¥ä¸‰äº‹ä»¶ç›¸äº’ç‹¬ç«‹ï¼Œå¯èƒ½åŒæ—¶è§¦å‘ï¼Œå¯ä»¥ä¸€æ¬¡è§¦å‘å…¶ä¸­çš„éšæœºä¸¤ä¸ªï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªï¼Œä¹Ÿå¯èƒ½æ˜¯éƒ½æ²¡å‘ç”Ÿã€‚æ‰€ä»¥è¿™æ ·å°±æ„æˆäº†8ç§æƒ…å†µã€‚
  
æˆ‘ä»¬å‡è®¾ä¸€ä¸ªuint8\_t tempå˜é‡ï¼ŒLD1ä»£è¡¨ç¬¬1ä½ï¼ˆäº‹ä»¶1ï¼‰ï¼ŒLD2ä»£è¡¨ç¬¬2ä½ï¼ˆäº‹ä»¶2ï¼‰ï¼ŒLD3ä»£è¡¨ç¬¬3ä½ï¼ˆäº‹ä»¶3ï¼‰ï¼Œå¯¹åº”ä½ç½®1è¡¨ç¤ºè¯¥äº‹ä»¶å‘ç”Ÿï¼Œéœ€æ‰§è¡Œè¯¥äº‹ä»¶ã€‚è¿™æ ·æˆ‘å°±å¾—åˆ°äº†8ç§æƒ…å†µï¼š
  
111ï¼šä»£è¡¨ä¸‰ç§äº‹ä»¶åŒæ—¶å‘ç”Ÿï¼›
  
110ï¼šä»£è¡¨äº‹ä»¶3ï¼Œäº‹ä»¶2å‘ç”Ÿï¼›
  
ä¾æ­¤ç±»æ¨â€¦
  
000ï¼šä»£è¡¨éƒ½ä¸å‘ç”Ÿã€‚
  
æœ€åæ ¹æ®è¿™å…«ç§æƒ…å†µå†™å…¥å¯¹åº”çš„ç”µå¹³çŠ¶æ€å°±å¯ä»¥äº†ã€‚

```c
void led_process()
{
    uint8_t temp = 0;
    uint8_t new_liq_level = liq_level_process(iic_liq_thros);
    
    ld1_tim_flag++;
    if(ld1_tim_flag == 5){
        temp |= 1;     
        ld1_state_flag ^= 1;
    }
    if(old_liq_level != new_liq_level)
    {
        temp |= 2;
        ld2_tim_flag++;
        ld2_state_flag ^= 1;
        if(ld2_tim_flag == 1) uart_inform_PC(new_liq_level);
    }
    if(uart_rec_flag == 1)
    {
        temp |= 4;
        ld3_tim_flag++;
        ld3_state_flag ^= 1;
    }
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
    
    if(temp == 0) GPIOC->ODR = 0xff00;
    else if(temp == 1)
    {        
        GPIOC->ODR = 0xfe00 ^ (ld1_state_flag << 8);
    }
    else if(temp == 2)
    {
        GPIOC->ODR = 0xfd00 ^ (ld2_state_flag << 9);
    }
    else if(temp == 3)
    {
        GPIOC->ODR = 0xfc00 ^ ((ld1_state_flag + (ld2_state_flag << 1)) << 8);
    }
    else if(temp == 4)
    {
        GPIOC->ODR = 0xfb00 ^ (ld3_state_flag << 10);       
    }
    else if(temp == 5)
    {
        GPIOC->ODR = 0xfa00 ^ ((ld1_state_flag + (ld3_state_flag << 2)) << 8);
    }
    else if(temp == 6)
    {
        GPIOC->ODR = 0xfa00 ^ (((ld2_state_flag<<1) + (ld3_state_flag << 2)) << 8);
        
    }
    else if(temp == 7)
    {
        GPIOC->ODR = 0xfa00 ^ ((ld1_state_flag + (ld2_state_flag<<1) + (ld3_state_flag << 2)) << 8);  
    }
    
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
    //äº‹ä»¶å®Œæˆä¹‹åç»“æŸè®¾ç½®å¯¹åº”æ ‡å¿—ä½ã€‚
    if(ld1_tim_flag == 5){
        ld1_tim_flag = 0;
    }
    if(ld2_tim_flag == 10)
    {
        old_liq_level = new_liq_level;
        ld2_tim_flag = 0;
    }
    if(ld3_tim_flag == 10)
    {
        uart_rec_flag = 0;
        ld3_tim_flag = 0;
    }
}

```

#### 1.3.7 TIMæ¨¡å—

170MHzçš„é¢‘ç‡ï¼Œé¢„åˆ†é¢‘å€¼å¡«å†™16ï¼Œé‡è£…è½½å¯„å­˜å™¨å¡«å†™1999999å®ç°0.2sæ—¶åŸºï¼›
  
é¢„åˆ†é¢‘å€¼å¡«å†™16ï¼Œé‡è£…è½½å¯„å­˜å™¨å¡«å†™499999å®ç°0.05sæ—¶åŸºã€‚
  
0.2sçš„æ—¶åŸºï¼Œç”¨åœ¨ledæ¨¡å—ã€‚
  
0.05sçš„æ—¶åŸºç”¨åœ¨uartï¼Œadcä¸Šã€‚
  
*å…·ä½“å®ç°çœ‹ç¬¬äºŒéƒ¨åˆ†æºç ã€‚*

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    static uint8_t test_val = 0;
    if(htim == &htim2)   //tim2
    {
        led_process();    //ledå¤„ç†å‡½æ•°
    }
    else{     //tim3
        HAL_ADC_Start_IT(&hadc2);
        HAL_UARTEx_ReceiveToIdle_IT(&huart1, &uart_rec_char, 1);
    }
}

```

## 2.æºç 

æˆ‘æ‰€æœ‰çš„å®ç°éƒ½åœ¨main.cæ–‡ä»¶ä¸­ã€‚

```c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "adc.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
#include "i2c_hal.h"
#include "lcd.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define FILTER_LEN 10
#define KEY_REDUCTION 20
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
typedef struct{
    uint32_t smp_val[FILTER_LEN];
    uint32_t filter_val;
} adc_smp_t;
adc_smp_t adc_smp_vtg = {0};        //å°†ADCé‡‡é›†çš„æ•°æ®æ”¶é›†FILTER_LENä¸ªï¼Œä¹‹åä¼šè¿›è¡Œå‡å€¼æ»¤æ³¢

typedef union{
    uint8_t keys;
    struct{
        uint8_t B1:2;
        uint8_t B2:2;
        uint8_t B3:2;
        uint8_t B4:2;
    }bits;
}key_state_t;
key_state_t key_state = {0};       //è¡¨ç¤ºæŒ‰é”®çŠ¶æ€

/*
adc_smp_flagï¼šä¿è¯é‡‡é›†FILTER_LENä¸ªæ•°æ®ä¹‹åè¿›è¡Œæ»¤æ³¢
key_add_sub_flagï¼Œ b3_b4_flagï¼šæ§åˆ¶æŒ‰é”®B3,B4åŠ å‡æ“ä½œã€‚
lcd_clear_flagï¼šåœ¨ç•Œé¢1å’Œç•Œé¢2ä¹‹é—´åˆ‡æ¢æ—¶å€™çš„æ¸…å±æ ‡å¿—ä½ã€‚
set_thros_flagï¼šB1æŒ‰ä¸‹è¿”å›ç•Œé¢1åï¼Œè®¾ç½®é˜ˆå€¼æˆåŠŸï¼Œå°†è®¾ç½®é˜ˆå€¼å†™å…¥eeprom
uart_rec_flagï¼šæ¥æ”¶åˆ°pcæŸ¥è¯¢æŒ‡ä»¤åï¼Œæ§åˆ¶ld3æ ‡å¿—
old_liq_levelï¼šè®°ä½ä¸Šä¸€æ¬¡çš„levelå€¼ï¼Œé€šçŸ¥pcç«¯æ—¶çŸ¥é“æ˜¯Uè¿˜æ˜¯Dï¼Œè¿˜æœ‰é…åˆæ§åˆ¶ld2
*/
uint8_t adc_smp_flag = 0, key_add_sub_flag = 100, b3_b4_flag = 100, 
            lcd_clear_flag = 0, set_thros_flag = 0, uart_rec_flag = 0, old_liq_level = 0;
/* åœ¨lcdä¸Šæ˜¾ç¤ºæ•°æ®ï¼Œé…åˆsprinfä½¿ç”¨ */
char lcd_HOR[30] = {0}, lcd_thros[30] = {0}, uart_resp[30] = {0};
/*
    iic_liq_throsï¼šå®æ—¶å€¼
    set_throsï¼šæ›´æ”¹é˜ˆå€¼æ—¶åšä¸­é—´å€¼
*/
uint8_t iic_liq_thros[3] = {30, 50, 70}, set_thros[3] = {0};
/*
    ldi_tim_flagï¼š0.2såŠ ä¸€ï¼Œæ§åˆ¶ldié—ªçƒæ¬¡æ•°
    ldi_state_flagï¼šæ”¹å˜å¯¹åº”ldiçš„çŠ¶æ€æ ‡å¿—ï¼Œå¯¹åº”å‘¨æœŸç­‰é—´éš”1010...äº¤æ›¿å˜åŒ–
*/
uint16_t ld1_tim_flag = 0,   ld2_tim_flag = 0,   ld3_tim_flag = 0,
         ld1_state_flag = 0, ld2_state_flag = 0, ld3_state_flag = 0;
/* æ¥æ”¶pcç«¯å‘æ¥çš„æŸ¥è¯¢ä¿¡å· */
uint8_t uart_rec_char;

void filter_process(adc_smp_t *adcSmp);
void lcd_process();
void at24c02_write(uint8_t addr, uint8_t data);
uint8_t at24c02_read(uint8_t addr);
void iic_write(uint8_t* data);
void iic_read(uint8_t* data);
void key_process(key_state_t *keyS);
void set_thros_process(uint8_t *des, uint8_t index);
void led_process();
uint8_t cmp_thros(uint8_t *a);
uint32_t liq_level_process(uint8_t* liq_thros);
void iic1_process();
void uart_inform_PC(uint8_t level);
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */
    LCD_Init();
    LCD_Clear(Black);
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC2_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_USART1_UART_Init();
  /* USER CODE BEGIN 2 */
    HAL_TIM_Base_Start_IT(&htim2);    //tim2äº§ç”Ÿ200msæ—¶åŸº
    HAL_TIM_Base_Start_IT(&htim3);    //tim3äº§ç”Ÿ50msæ—¶åŸº
    HAL_ADC_Start_IT(&hadc2);
    HAL_UARTEx_ReceiveToIdle_IT(&huart1, &uart_rec_char, 1);
    
    //æ£€æŸ¥eepromå¯¹åº”æ•°æ®å†…å­˜ä¸­æ•°æ®æ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œåº”å¯¹ç¬¬ä¸€æ¬¡åœ¨æ¿å­ä¸‹è½½è¯¥ç¨‹åºï¼Œeepromå¯¹åº”å†…å­˜ä½ç½®æ•°æ®ä¸æ­£ç¡®çš„é—®é¢˜
    iic_read(set_thros);
    if(cmp_thros(set_thros))
    {
        iic_write(iic_liq_thros);
    }else{
       iic_read(iic_liq_thros); 
    }
    
    for(int i=0;i<3;i++)
    {
        set_thros[i] = iic_liq_thros[i];
    }   
    
    old_liq_level = liq_level_process(iic_liq_thros);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

      key_process(&key_state);
      lcd_process();
      
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */
/*
void lcd_process()
{
    if
    {
        1ï¼šif ç•Œé¢1ï¼Œ2åˆ‡æ¢æ¸…å±
        2ï¼šLCDæ˜¾ç¤ºæ•°æ®
        3ï¼šifè®¾ç½®é˜ˆå€¼æˆåŠŸååˆ‡æ¢åˆ°ç•Œé¢1ï¼Œå°†set_throså†™å…¥eeprom
    }
    else
    {
        1ï¼šif ç•Œé¢1ï¼Œ2åˆ‡æ¢æ¸…å±
        2ï¼šif æ˜¾ç¤ºthros1ä¸ºç»¿è‰²+è®¾ç½®è¯¥é˜ˆå€¼
        3ï¼šelse if æ˜¾ç¤ºthros2ä¸ºç»¿è‰²+è®¾ç½®è¯¥é˜ˆå€¼
        4ï¼šelse if æ˜¾ç¤ºthros3ä¸ºç»¿è‰²+è®¾ç½®è¯¥é˜ˆå€¼
    }
}
*/
void lcd_process()
{
    if(key_state.bits.B1 == 0)
    {
        if(lcd_clear_flag == 0)
        {
            LCD_Clear(Black);
            lcd_clear_flag = 1;
        }
        LCD_DisplayStringLine(Line1, "  Liquid Level");
        sprintf(lcd_HOR, "  Height:%dcm", adc_smp_vtg.filter_val*100/4096);
        LCD_DisplayStringLine(Line2, (uint8_t*)lcd_HOR);
        sprintf(lcd_HOR, "  ADC:%.2fV", adc_smp_vtg.filter_val*3.3/4096);
        LCD_DisplayStringLine(Line3, (uint8_t*)lcd_HOR);
        sprintf(lcd_HOR, "  Level: %d", liq_level_process(iic_liq_thros));
        LCD_DisplayStringLine(Line4, (uint8_t*)lcd_HOR);
        if(set_thros_flag==1)
        {
            set_thros_flag = 0;
            iic_write(set_thros);
            iic_read(iic_liq_thros);
        }
    }
    else
    {
        if(lcd_clear_flag == 1)
        {
            LCD_Clear(Black);
            lcd_clear_flag = 0;
        }
        LCD_DisplayStringLine(Line1, "    Parameter Setup");
        if(key_state.bits.B2 == 0){
            LCD_SetTextColor(Green);
            sprintf(lcd_thros, "  Throsouth 1:%2dcm", set_thros[0]);
            LCD_DisplayStringLine(Line3, (uint8_t*)lcd_thros);
            LCD_SetTextColor(Black);
            sprintf(lcd_thros, "  Throsouth 2:%2dcm", set_thros[1]);
            LCD_DisplayStringLine(Line4, (uint8_t*)lcd_thros);
            sprintf(lcd_thros, "  Throsouth 2:%2dcm", set_thros[2]);
            LCD_DisplayStringLine(Line5, (uint8_t*)lcd_thros);
            if(b3_b4_flag != key_add_sub_flag){
                set_thros_process(set_thros, 0);
            }
        }
        else if(key_state.bits.B2 == 1){
            sprintf(lcd_thros, "  Throsouth 1:%2dcm", set_thros[0]);
            LCD_DisplayStringLine(Line3, (uint8_t*)lcd_thros);
            LCD_SetTextColor(Green);
            sprintf(lcd_thros, "  Throsouth 2:%2dcm", set_thros[1]);
            LCD_DisplayStringLine(Line4, (uint8_t*)lcd_thros);
            LCD_SetTextColor(Black);
            sprintf(lcd_thros, "  Throsouth 2:%2dcm", set_thros[2]);
            LCD_DisplayStringLine(Line5, (uint8_t*)lcd_thros);
            if(b3_b4_flag != key_add_sub_flag){ 
                set_thros_process(set_thros, 1);
            }
        }
        else if(key_state.bits.B2 == 2){
            sprintf(lcd_thros, "  Throsouth 1:%2dcm", set_thros[0]);
            LCD_DisplayStringLine(Line3, (uint8_t*)lcd_thros);
            sprintf(lcd_thros, "  Throsouth 2:%2dcm", set_thros[1]);
            LCD_DisplayStringLine(Line4, (uint8_t*)lcd_thros);
            LCD_SetTextColor(Green);
            sprintf(lcd_thros, "  Throsouth 2:%2dcm", set_thros[2]);
            LCD_DisplayStringLine(Line5, (uint8_t*)lcd_thros);
            LCD_SetTextColor(Black);
            if(b3_b4_flag != key_add_sub_flag){ 
                set_thros_process(set_thros, 2);
            }
        }
    }
    
}

/* è½¯ç”²æ¨¡æ‹Ÿiicåè®®å†™å…¥1byte */
void at24c02_write(uint8_t addr, uint8_t data)
{
    I2CStart();
    I2CSendByte(0xa0);
    I2CWaitAck();
    I2CSendByte(addr);
    I2CWaitAck();
    I2CSendByte(data);
    I2CWaitAck();
    I2CStop();
}
/* è½¯ä»¶æ¨¡æ‹Ÿiicåè®®è¯»å–1byte */
uint8_t at24c02_read(uint8_t addr)
{
    uint8_t data;
    I2CStart();
    I2CSendByte(0xa0);
    I2CWaitAck();
    I2CSendByte(addr);
    I2CWaitAck();
    I2CStart();
    I2CSendByte(0xa1);
    I2CWaitAck();
    data = I2CReceiveByte();
    I2CSendNotAck();
    I2CStop();
    return data;
}

/* å†™å…¥æ•°æ® */
void iic_write(uint8_t* data)
{
    for(int i=0; i<3; i++)
    {
        at24c02_write(i, data[i]);
        HAL_Delay(3);
    }
}

/* è¯»å–æ•°æ® */
void iic_read(uint8_t* data)
{
    uint8_t temp = 0;
    for(int i=0; i<3; i++)
    {
        temp = at24c02_read(i);
        data[i] = temp;
        HAL_Delay(3);
    }
}

/* éªŒè¯è¯»å‡ºæ•°æ®æ˜¯å¦æ­£å¸¸ */
uint8_t cmp_thros(uint8_t *a)
{
    for(int i=0; i<3; i++)
    {
        if(a[i] < 5 || a[i] > 95) return 1;
    }
    return 0;
}

/* æ£€æµ‹æ¶²æ·±ç­‰çº§ */
uint32_t liq_level_process(uint8_t* liq_thros)
{
    uint32_t temp = adc_smp_vtg.filter_val*100/4096;
    if(temp <= liq_thros[0]) return 0;
    else if(temp > liq_thros[0] && temp <= liq_thros[1]) return 1;
    else if(temp > liq_thros[1] && temp <= liq_thros[2]) return 2;
    else return 3;
}

/* è¯»å–BiæŒ‰é”®çŠ¶æ€ */
void key_process(key_state_t *keyS)
{
    uint32_t tick = 0;
    if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET) //B1
    {
        if(HAL_GetTick() - tick > KEY_REDUCTION){
            tick = HAL_GetTick();
              keyS->bits.B1 ^= 1;
//            keyS->bits.B1++;
//            if(keyS->bits.B1 == 2) keyS->bits.B1 = 0;
            while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);
        }
    }
    else if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET) //B2
    {
        if(HAL_GetTick() - tick > KEY_REDUCTION){
            tick = HAL_GetTick();
            keyS->bits.B2++;
            if(keyS->bits.B2 == 3) keyS->bits.B2 = 0;
            while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);
        }
    }
    else if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2) == GPIO_PIN_RESET) //B3
    {
        if(HAL_GetTick() - tick > KEY_REDUCTION){
            tick = HAL_GetTick();
            keyS->bits.B3 ^= 1;
//            keyS->bits.B3++;
//            if(keyS->bits.B3 == 2) keyS->bits.B3 = 0;
            key_add_sub_flag++;
            while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2) == GPIO_PIN_RESET);
        }
    }
    else if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) //B1
    {
        if(HAL_GetTick() - tick > KEY_REDUCTION){
            tick = HAL_GetTick();
            keyS->bits.B4 ^= 1;
//            keyS->bits.B4++;
//            if(keyS->bits.B4 == 2) keyS->bits.B4 = 0;
            key_add_sub_flag--;
            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET);
        }
    }
}

/* è®¾ç½®é˜ˆå€¼ */
void set_thros_process(uint8_t *des, uint8_t index)
{
    if(key_add_sub_flag>b3_b4_flag && (des[index]>=5 && des[index]<=95))
    {        
        des[index] += 5;
        if(des[index] == 100) des[index] = 95;
    }
    else if(key_add_sub_flag<b3_b4_flag && (des[index]>=5 && des[index]<=95))
    {
        des[index] -= 5;
        if(des[index] == 0) des[index] = 5;
    }
    set_thros_flag = 1;
    b3_b4_flag = key_add_sub_flag;

}

/* 
void led_process()
{
    1ï¼šå‰é¢3ifè®¾ç½®3ç§äº‹ä»¶æ˜¯å¦å‘ç”Ÿ
    2ï¼š3ç§äº‹ä»¶ç›¸äº’ç»„åˆå½¢æˆ8ç§æ··åˆäº‹ä»¶
    3ï¼šæœ€å3ifè®¾ç½®ç›¸å…³æ ‡å¿—ä½
}
*/
void led_process()
{
    uint8_t temp = 0;
    uint8_t new_liq_level = liq_level_process(iic_liq_thros);
    
    ld1_tim_flag++;
    if(ld1_tim_flag == 5){
        temp |= 1;     
        ld1_state_flag ^= 1;
    }
    if(old_liq_level != new_liq_level)
    {
        temp |= 2;
        ld2_tim_flag++;
        ld2_state_flag ^= 1;
        if(ld2_tim_flag == 1) uart_inform_PC(new_liq_level);
    }
    if(uart_rec_flag == 1)
    {
        temp |= 4;
        ld3_tim_flag++;
        ld3_state_flag ^= 1;
    }
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
    
    if(temp == 0) GPIOC->ODR = 0xff00;
    else if(temp == 1)
    {        
        GPIOC->ODR = 0xfe00 ^ (ld1_state_flag << 8);
    }
    else if(temp == 2)
    {
        GPIOC->ODR = 0xfd00 ^ (ld2_state_flag << 9);
    }
    else if(temp == 3)
    {
        GPIOC->ODR = 0xfc00 ^ ((ld1_state_flag + (ld2_state_flag << 1)) << 8);
    }
    else if(temp == 4)
    {
        GPIOC->ODR = 0xfb00 ^ (ld3_state_flag << 10);       
    }
    else if(temp == 5)
    {
        GPIOC->ODR = 0xfa00 ^ ((ld1_state_flag + (ld3_state_flag << 2)) << 8);
    }
    else if(temp == 6)
    {
        GPIOC->ODR = 0xfa00 ^ (((ld2_state_flag<<1) + (ld3_state_flag << 2)) << 8);
        
    }
    else if(temp == 7)
    {
        GPIOC->ODR = 0xfa00 ^ ((ld1_state_flag + (ld2_state_flag<<1) + (ld3_state_flag << 2)) << 8);  
    }
    
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
    if(ld1_tim_flag == 5){
        ld1_tim_flag = 0;
    }
    if(ld2_tim_flag == 10)
    {
        old_liq_level = new_liq_level;
        ld2_tim_flag = 0;
    }
    if(ld3_tim_flag == 10)
    {
        uart_rec_flag = 0;
        ld3_tim_flag = 0;
    }
}

/* å‘pcç«¯å‘é€æ•°æ® */
void uart_inform_PC(uint8_t level)
{
    if(old_liq_level<level)
    {
        sprintf(uart_resp, "A:H%2d+L%1d+U\r\n", adc_smp_vtg.filter_val*100/4096, liq_level_process(iic_liq_thros));
        HAL_UART_Transmit_IT(&huart1, (uint8_t*)uart_resp, 12);
    }else if(old_liq_level>level)
    {
        sprintf(uart_resp, "A:H%2d+L%1d+D\r\n", adc_smp_vtg.filter_val*100/4096, liq_level_process(iic_liq_thros));
        HAL_UART_Transmit_IT(&huart1, (uint8_t*)uart_resp, 12);
    }
}

/* å®šæ—¶å™¨æ—¶åŸºä¸­æ–­å›è°ƒå‡½æ•° */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    static uint8_t test_val = 0;
    if(htim == &htim2)
    {
        led_process();
    }
    else{
        HAL_ADC_Start_IT(&hadc2);
        HAL_UARTEx_ReceiveToIdle_IT(&huart1, &uart_rec_char, 1);
    }

}

/* uartæ¥æ”¶äº‹ä»¶ä¸­æ–­å›è°ƒå‡½æ•° */
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
    if(uart_rec_char == 'C')
    {
        uart_rec_flag = 1;
        sprintf(uart_resp, "C:H%2d+L%1d\r\n", adc_smp_vtg.filter_val*100/4096, liq_level_process(iic_liq_thros));
        HAL_UART_Transmit_IT(huart, (uint8_t*)uart_resp, 9);
    }
    else if(uart_rec_char == 'S')
    {
        uart_rec_flag = 1;
        sprintf(uart_resp, "S:TL%2d+TM%2d+TH%2d\r\n", iic_liq_thros[0], iic_liq_thros[1], iic_liq_thros[2]);
        HAL_UART_Transmit_IT(huart, (uint8_t*)uart_resp, 18);
    }
}

/* adcè§„åˆ™ç»„è½¬æ¢å®Œæˆä¸­æ–­å›è°ƒå‡½æ•° */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
    if(adc_smp_flag < (FILTER_LEN+1))
    {
        adc_smp_flag++;
        adc_smp_vtg.smp_val[adc_smp_flag] = HAL_ADC_GetValue(hadc);
        if(adc_smp_flag == (FILTER_LEN+1))
        {
            adc_smp_flag =0;
            filter_process(&adc_smp_vtg);
        }
    }
}

/* adcé‡‡é›†å€¼è¿›è¡Œæ»¤æ³¢ */
void filter_process(adc_smp_t *adcSmp)
{
    uint32_t temp = 0;
    for(int i=0;i<FILTER_LEN;i++)
    {
        temp += adcSmp->smp_val[i];
    }
    adcSmp->filter_val = temp/10;

}

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */


```

## 3.ç¬¬ä¸ƒå±Šé¢˜ç›®

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/9bcb7a647feb43de8aeb6713c2821d5e.png)
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/9e0763d60cad4d3f8a85852cf7d07e17.png)
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/a4caae68a7a846b386a7ec11ff8891b0.png)
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/b5a3ab5e81e34eba885fd05258607d47.png)
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/16b8b95ceee64384ad575f3c71a41b3d.png)