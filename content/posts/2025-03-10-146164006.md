---
layout: post
title: "javase集合框架List篇"
date: 2025-03-10 22:20:53 +0800
description: "参考http://xdclass.net"
keywords: "javase集合框架List篇"
categories: ['面试专题']
tags: ['List', 'Java']
artid: "146164006"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146164006
    alt: "javase集合框架List篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146164006
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146164006
cover: https://bing.ee123.net/img/rand?artid=146164006
image: https://bing.ee123.net/img/rand?artid=146164006
img: https://bing.ee123.net/img/rand?artid=146164006
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     javase集合框架List篇
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     一、Vector和ArrayList、LinkedList联系和区别，分别的使用场景
    </p>
    <p>
     ArrayList：底层是数组实现，线程不安全，查询和修改非常快，但是增加和删除慢
    </p>
    <p>
     LinkedList: 底层是双向链表，线程不安全，查询和修改速度慢，但是增加和删除速度快
    </p>
    <p>
     Vector: 底层是数组实现，线程安全的，操作的时候使用synchronized进行加锁
    </p>
    <p>
     使用场景：
    </p>
    <ul>
     <li>
      Vector已经很少用了
     </li>
     <li>
      增加和删除场景多则用LinkedList
     </li>
     <li>
      查询和修改多则用ArrayList
     </li>
    </ul>
    <p>
     二、如果需要保证线程安全，ArrayList应该怎么做，有几种方式
    </p>
    <p>
     方式一：使用
     <code>
      Collections.synchronizedList（
     </code>
     synchronized加锁）
    </p>
    <p>
     List&lt;String&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;&gt;());
    </p>
    <p>
     方式二：使用
     <code>
      CopyOnWriteArrayList（
     </code>
     ReentrantLock加锁）
    </p>
    <p>
     List&lt;String&gt; cowList = new CopyOnWriteArrayList&lt;&gt;();
    </p>
    <p>
     三、CopyOnWriteArrayList和 Collections.synchronizedList实现线程安全的区别以及它们的使用场景
    </p>
    <p>
     CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等)，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里面用ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组
    </p>
    <p>
     使用场景：读高性能，适用读操作，读操作远远大于写操作的场景中使用(因为读的时候是不需要加锁的，直接获取，删除和增加是需要加锁的, 读多写少)
    </p>
    <p>
     Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步锁
    </p>
    <p>
     使用场景：读操作性能并不如CopyOnWriteArrayList（因为读操作的时候有加锁）
    </p>
    <p>
     四、CopyOnWriteArrayList的设计思想以及它有什么缺点
    </p>
    <p>
     设计思想：读写分离+最终一致，读的时候是读旧的数组
    </p>
    <p>
     缺点：内存占用问题,写时复制机制,内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象,如果对象大则容易发生Yong GC和Full GC
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363233313739342f:61727469636c652f64657461696c732f313436313634303036" class_="artid" style="display:none">
 </p>
</div>


