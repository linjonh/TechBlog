---
layout: post
title: "FFMPEG音视频解码流程MP4音视频文件流读取"
date: 2025-01-18 22:18:47 +0800
description: "原文地址：https://www.cnblogs.com/CoderTian/p/6791638.h"
keywords: "ffmpeg读取mp4文件"
categories: ['C']
tags: ['Video', 'Ffmpeg', 'Codec', 'C', 'Audio']
artid: "79474754"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=79474754
    alt: "FFMPEG音视频解码流程MP4音视频文件流读取"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=79474754
featuredImagePreview: https://bing.ee123.net/img/rand?artid=79474754
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     FFMPEG音视频解码流程&amp;MP4音视频文件流读取
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     原文地址：
     <a href="https://www.cnblogs.com/CoderTian/p/6791638.html" rel="nofollow">
      https://www.cnblogs.com/CoderTian/p/6791638.html
     </a>
     <br/>
    </p>
    <h2>
     1.播放多媒体文件步骤
    </h2>
    <p>
     通常情况下，我们下载的视频文件如MP4，MKV、FLV等都属于封装格式，就是把音视频数据按照相应的规范，打包成一个文本文件。我们可以使用MediaInfo这个工具查看媒体文件的相关信息。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6a76e5e0c2c9e123e3de92d48b7d57f8.png"/>
    </p>
    <p>
     所以当我们播放一个媒体文件时，通常需要经过以下几个步骤
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/006c937b583926ed31cbb868faa345f7.png"/>
    </p>
    <p>
     ①解封装(Demuxing)：就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。
    </p>
    <p>
     ②解码(Decode)：就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3等，视频的压缩编码标准则包含H.264，MPEG2等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV、RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。
    </p>
    <p>
     ③音视频同步：就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的音频和视频数据，并将音视频频数据送至系统的显卡和声卡播放出来(Render)。
    </p>
    <h2>
     2.FFMPEG音视频解码
    </h2>
    <p>
     通过上面对媒体文件播放步骤的了解，我们在解码多媒体文件的时候需要经过两个步骤，即解封装(Demuxing)和解码(Decode)。下面就来看一下FFMPEG解码媒体文件的时候是怎样做这两个步骤的。
    </p>
    <p>
     <img alt="" src="https://images2015.cnblogs.com/blog/708332/201705/708332-20170501122019226-1848388459.png"/>
    </p>
    <p>
     在使用FFMPEG解码媒体文件之前，我们首先需要注册FFMPEG的各种组件，通过
    </p>
    <div class="cnblogs_code">
     <pre>av_register_all();</pre>
    </div>
    <div>
     这个函数，可以注册所有支持的容器和对应的codec。之后我们通过
    </div>
    <div class="cnblogs_code">
     <pre>AVFormatContext *pFormatCtx =<span style="color:#000000;"> avformat_alloc_context();
avformat_open_input(</span>&amp;<span style="color:#000000;">pFormatCtx,input_cstr,NULL,NULL);
avformat_find_stream_info(pFormatCtx,NULL);</span></pre>
    </div>
    <p>
     来打开一个媒体文件，并获得媒体文件封装格式的上下文。之后我们就可以通过遍历定义在libavformat/avformat.h里保存着媒体文件中封装的流数量的nb_streams在媒体文件中分离出音视频流。
    </p>
    <p>
     分离出音视频流之后，就可以对音视频流分别进行解码了，这里先以视频解码为例,我们可以遍历AVStream找到codec_type为AVMEDIA_TYPE_VIDEO的的AVStream即为视频流的索引值。
    </p>
    <div class="cnblogs_code">
     <pre><span style="color:#008000;">//</span><span style="color:#008000;">视频解码，需要找到视频对应的AVStream所在pFormatCtx-&gt;streams的索引位置</span>
    <span style="color:#0000ff;">int</span> video_stream_idx = -<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> i = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">for</span>(; i &lt; pFormatCtx-&gt;nb_streams;i++<span style="color:#000000;">){
        </span><span style="color:#008000;">//</span><span style="color:#008000;">根据类型判断，是否是视频流</span>
        <span style="color:#0000ff;">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type ==<span style="color:#000000;"> AVMEDIA_TYPE_VIDEO){
            video_stream_idx </span>=<span style="color:#000000;"> i;
            </span><span style="color:#0000ff;">break</span><span style="color:#000000;">;
        }
    }</span></pre>
    </div>
    <p>
     然后我们就可以通过AVStream来找到对应的AVCodecContext即编解码器的上下文。之后就可以通过这个上下文，使用
    </p>
    <div class="cnblogs_code">
     <pre>avcodec_find_decoder()</pre>
    </div>
    <p>
     来找到对应的解码器，再通过
    </p>
    <div class="cnblogs_code">
     <pre>avcodec_open2()</pre>
    </div>
    <p>
     来打开解码器，AVFormatContext、AVStream、AVCodecContext、AVCodec四者之间的关系为
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/d478ba6494836e573be95a0660c168c8.png"/>
    </p>
    <p>
     打开解码器之后，就可以循环的将一帧待解码的数据AVPacket送给
    </p>
    <div class="cnblogs_code">
     <pre>avcodec_decode_video2()</pre>
    </div>
    <p>
     进行解码，解码之后的数据存放在AVFrame里面。
    </p>
    <h2>
     3.示例代码
    </h2>
    <h3>
     3.1.视频解码
    </h3>
    <div class="cnblogs_code">
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy">
       <br/>
      </span>
     </div>
     <pre>#include &lt;stdio.h&gt;<span style="color:#000000;">
#include </span>&lt;stdlib.h&gt;
<span style="color:#008000;">//</span><span style="color:#008000;">编码</span>
#include <span style="color:#800000;">"</span><span style="color:#800000;">libavcodec/avcodec.h</span><span style="color:#800000;">"</span>
<span style="color:#008000;">//</span><span style="color:#008000;">封装格式处理</span>
#include <span style="color:#800000;">"</span><span style="color:#800000;">libavformat/avformat.h</span><span style="color:#800000;">"</span>
<span style="color:#008000;">//</span><span style="color:#008000;">像素处理</span>
#include <span style="color:#800000;">"</span><span style="color:#800000;">libswscale/swscale.h</span><span style="color:#800000;">"</span>

<span style="color:#0000ff;">int</span><span style="color:#000000;"> main()
{
    </span><span style="color:#008000;">//</span><span style="color:#008000;">获取输入输出文件名</span>
    <span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span> *input = <span style="color:#800000;">"</span><span style="color:#800000;">test.mp4</span><span style="color:#800000;">"</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span> *output = <span style="color:#800000;">"</span><span style="color:#800000;">test.yuv</span><span style="color:#800000;">"</span><span style="color:#000000;">;

    </span><span style="color:#008000;">//</span><span style="color:#008000;">1.注册所有组件</span>
<span style="color:#000000;">    av_register_all();

    </span><span style="color:#008000;">//</span><span style="color:#008000;">封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息</span>
    AVFormatContext *pFormatCtx =<span style="color:#000000;"> avformat_alloc_context();

    </span><span style="color:#008000;">//</span><span style="color:#008000;">2.打开输入视频文件</span>
    <span style="color:#0000ff;">if</span> (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != <span style="color:#800080;">0</span><span style="color:#000000;">)
    {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>,<span style="color:#800000;">"</span><span style="color:#800000;">无法打开输入视频文件</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }

    </span><span style="color:#008000;">//</span><span style="color:#008000;">3.获取视频文件信息</span>
    <span style="color:#0000ff;">if</span> (avformat_find_stream_info(pFormatCtx,NULL) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
    {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>,<span style="color:#800000;">"</span><span style="color:#800000;">无法获取视频文件信息</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }

    </span><span style="color:#008000;">//</span><span style="color:#008000;">获取视频流的索引位置
    </span><span style="color:#008000;">//</span><span style="color:#008000;">遍历所有类型的流（音频流、视频流、字幕流），找到视频流</span>
    <span style="color:#0000ff;">int</span> v_stream_idx = -<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> i = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">number of streams</span>
    <span style="color:#0000ff;">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++<span style="color:#000000;">)
    {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">流的类型</span>
        <span style="color:#0000ff;">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type ==<span style="color:#000000;"> AVMEDIA_TYPE_VIDEO)
        {
            v_stream_idx </span>=<span style="color:#000000;"> i;
            </span><span style="color:#0000ff;">break</span><span style="color:#000000;">;
        }
    }

    </span><span style="color:#0000ff;">if</span> (v_stream_idx == -<span style="color:#800080;">1</span><span style="color:#000000;">)
    {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>,<span style="color:#800000;">"</span><span style="color:#800000;">找不到视频流\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }

    </span><span style="color:#008000;">//</span><span style="color:#008000;">只有知道视频的编码方式，才能够根据编码方式去找到解码器
    </span><span style="color:#008000;">//</span><span style="color:#008000;">获取视频流中的编解码上下文</span>
    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;<span style="color:#000000;">codec;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">4.根据编解码上下文中的编码id查找对应的解码</span>
    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;<span style="color:#000000;">codec_id);
    </span><span style="color:#0000ff;">if</span> (pCodec ==<span style="color:#000000;"> NULL)
    {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>,<span style="color:#800000;">"</span><span style="color:#800000;">找不到解码器\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }

    </span><span style="color:#008000;">//</span><span style="color:#008000;">5.打开解码器</span>
    <span style="color:#0000ff;">if</span> (avcodec_open2(pCodecCtx,pCodec,NULL)&lt;<span style="color:#800080;">0</span><span style="color:#000000;">)
    {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>,<span style="color:#800000;">"</span><span style="color:#800000;">解码器无法打开\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }

    </span><span style="color:#008000;">//</span><span style="color:#008000;">输出视频信息</span>
    printf(<span style="color:#800000;">"</span><span style="color:#800000;">视频的文件格式：%s</span><span style="color:#800000;">"</span>,pFormatCtx-&gt;iformat-&gt;<span style="color:#000000;">name);
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">视频时长：%d</span><span style="color:#800000;">"</span>, (pFormatCtx-&gt;duration)/<span style="color:#800080;">1000000</span><span style="color:#000000;">);
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">视频的宽高：%d,%d</span><span style="color:#800000;">"</span>,pCodecCtx-&gt;width,pCodecCtx-&gt;<span style="color:#000000;">height);
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">解码器的名称：%s</span><span style="color:#800000;">"</span>,pCodec-&gt;<span style="color:#000000;">name);

    </span><span style="color:#008000;">//</span><span style="color:#008000;">准备读取
    </span><span style="color:#008000;">//</span><span style="color:#008000;">AVPacket用于存储一帧一帧的压缩数据（H264）
    </span><span style="color:#008000;">//</span><span style="color:#008000;">缓冲区，开辟空间</span>
    AVPacket *packet = (AVPacket*)av_malloc(<span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(AVPacket));

    </span><span style="color:#008000;">//</span><span style="color:#008000;">AVFrame用于存储解码后的像素数据(YUV)
    </span><span style="color:#008000;">//</span><span style="color:#008000;">内存分配</span>
    AVFrame *pFrame =<span style="color:#000000;"> av_frame_alloc();
    </span><span style="color:#008000;">//</span><span style="color:#008000;">YUV420</span>
    AVFrame *pFrameYUV =<span style="color:#000000;"> av_frame_alloc();
    </span><span style="color:#008000;">//</span><span style="color:#008000;">只有指定了AVFrame的像素格式、画面大小才能真正分配内存
    </span><span style="color:#008000;">//</span><span style="color:#008000;">缓冲区分配内存</span>
    uint8_t *out_buffer = (uint8_t *)av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;<span style="color:#000000;">height));
    </span><span style="color:#008000;">//</span><span style="color:#008000;">初始化缓冲区</span>
    avpicture_fill((AVPicture *)pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;<span style="color:#000000;">height);

    </span><span style="color:#008000;">//</span><span style="color:#008000;">用于转码（缩放）的参数，转之前的宽高，转之后的宽高，格式等</span>
    <span style="color:#0000ff;">struct</span> SwsContext *sws_ctx = sws_getContext(pCodecCtx-&gt;width,pCodecCtx-&gt;height,pCodecCtx-&gt;<span style="color:#000000;">pix_fmt,
                                                pCodecCtx</span>-&gt;width, pCodecCtx-&gt;<span style="color:#000000;">height, AV_PIX_FMT_YUV420P,
                                                SWS_BICUBIC, NULL, NULL, NULL);
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> got_picture, ret;

    FILE </span>*fp_yuv = fopen(output, <span style="color:#800000;">"</span><span style="color:#800000;">wb+</span><span style="color:#800000;">"</span><span style="color:#000000;">);

    </span><span style="color:#0000ff;">int</span> frame_count = <span style="color:#800080;">0</span><span style="color:#000000;">;

    </span><span style="color:#008000;">//</span><span style="color:#008000;">6.一帧一帧的读取压缩数据</span>
    <span style="color:#0000ff;">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span style="color:#800080;">0</span><span style="color:#000000;">)
    {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">只要视频压缩数据（根据流的索引位置判断）</span>
        <span style="color:#0000ff;">if</span> (packet-&gt;stream_index ==<span style="color:#000000;"> v_stream_idx)
        {
            </span><span style="color:#008000;">//</span><span style="color:#008000;">7.解码一帧视频压缩数据，得到视频像素数据</span>
            ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;<span style="color:#000000;">got_picture, packet);
            </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
            {
                printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>,<span style="color:#800000;">"</span><span style="color:#800000;">解码错误</span><span style="color:#800000;">"</span><span style="color:#000000;">);
                </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
            }

            </span><span style="color:#008000;">//</span><span style="color:#008000;">为0说明解码完成，非0正在解码</span>
            <span style="color:#0000ff;">if</span><span style="color:#000000;"> (got_picture)
            {
                </span><span style="color:#008000;">//</span><span style="color:#008000;">AVFrame转为像素格式YUV420，宽高
                </span><span style="color:#008000;">//</span><span style="color:#008000;">2 6输入、输出数据
                </span><span style="color:#008000;">//</span><span style="color:#008000;">3 7输入、输出画面一行的数据的大小 AVFrame 转换是一行一行转换的
                </span><span style="color:#008000;">//</span><span style="color:#008000;">4 输入数据第一列要转码的位置 从0开始
                </span><span style="color:#008000;">//</span><span style="color:#008000;">5 输入画面的高度</span>
                sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, <span style="color:#800080;">0</span>, pCodecCtx-&gt;<span style="color:#000000;">height,
                          pFrameYUV</span>-&gt;data, pFrameYUV-&gt;<span style="color:#000000;">linesize);

                </span><span style="color:#008000;">//</span><span style="color:#008000;">输出到YUV文件
                </span><span style="color:#008000;">//</span><span style="color:#008000;">AVFrame像素帧写入文件
                </span><span style="color:#008000;">//</span><span style="color:#008000;">data解码后的图像像素数据（音频采样数据）
                </span><span style="color:#008000;">//</span><span style="color:#008000;">Y 亮度 UV 色度（压缩了） 人对亮度更加敏感
                </span><span style="color:#008000;">//</span><span style="color:#008000;">U V 个数是Y的1/4</span>
                <span style="color:#0000ff;">int</span> y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;<span style="color:#000000;">height;
                fwrite(pFrameYUV</span>-&gt;data[<span style="color:#800080;">0</span>], <span style="color:#800080;">1</span><span style="color:#000000;">, y_size, fp_yuv);
                fwrite(pFrameYUV</span>-&gt;data[<span style="color:#800080;">1</span>], <span style="color:#800080;">1</span>, y_size / <span style="color:#800080;">4</span><span style="color:#000000;">, fp_yuv);
                fwrite(pFrameYUV</span>-&gt;data[<span style="color:#800080;">2</span>], <span style="color:#800080;">1</span>, y_size / <span style="color:#800080;">4</span><span style="color:#000000;">, fp_yuv);

                frame_count</span>++<span style="color:#000000;">;
                printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">解码第%d帧\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,frame_count);
            }
        }

        </span><span style="color:#008000;">//</span><span style="color:#008000;">释放资源</span>
<span style="color:#000000;">        av_free_packet(packet);
    }

    fclose(fp_yuv);

    av_frame_free(</span>&amp;<span style="color:#000000;">pFrame);

    avcodec_close(pCodecCtx);

    avformat_free_context(pFormatCtx);

}</span></pre>
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy">
       <br/>
      </span>
     </div>
    </div>
    <h3>
     3.2.音频解码
    </h3>
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy">
      <br/>
     </span>
    </div>
    <pre>#include &lt;stdlib.h&gt;<span style="color:#000000;">
#include </span>&lt;stdio.h&gt;<span style="color:#000000;">
#include </span>&lt;unistd.h&gt;

<span style="color:#008000;">//</span><span style="color:#008000;">封装格式</span>
#include <span style="color:#800000;">"</span><span style="color:#800000;">libavformat/avformat.h</span><span style="color:#800000;">"</span>
<span style="color:#008000;">//</span><span style="color:#008000;">解码</span>
#include <span style="color:#800000;">"</span><span style="color:#800000;">libavcodec/avcodec.h</span><span style="color:#800000;">"</span>
<span style="color:#008000;">//</span><span style="color:#008000;">缩放</span>
#include <span style="color:#800000;">"</span><span style="color:#800000;">libswscale/swscale.h</span><span style="color:#800000;">"</span><span style="color:#000000;">
#include </span><span style="color:#800000;">"</span><span style="color:#800000;">libswresample/swresample.h</span><span style="color:#800000;">"</span>

<span style="color:#0000ff;">int</span> main (<span style="color:#0000ff;">void</span><span style="color:#000000;">)
{

    </span><span style="color:#008000;">//</span><span style="color:#008000;">1.注册组件</span>
<span style="color:#000000;">    av_register_all();
    </span><span style="color:#008000;">//</span><span style="color:#008000;">封装格式上下文</span>
    AVFormatContext *pFormatCtx =<span style="color:#000000;"> avformat_alloc_context();

    </span><span style="color:#008000;">//</span><span style="color:#008000;">2.打开输入音频文件</span>
    <span style="color:#0000ff;">if</span> (avformat_open_input(&amp;pFormatCtx, <span style="color:#800000;">"</span><span style="color:#800000;">test.mp3</span><span style="color:#800000;">"</span>, NULL, NULL) != <span style="color:#800080;">0</span><span style="color:#000000;">) {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">打开输入音频文件失败</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }
    </span><span style="color:#008000;">//</span><span style="color:#008000;">3.获取音频信息</span>
    <span style="color:#0000ff;">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">) {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">获取音频信息失败</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }

    </span><span style="color:#008000;">//</span><span style="color:#008000;">音频解码，需要找到对应的AVStream所在的pFormatCtx-&gt;streams的索引位置</span>
    <span style="color:#0000ff;">int</span> audio_stream_idx = -<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">int</span> i = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++<span style="color:#000000;">) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">根据类型判断是否是音频流</span>
        <span style="color:#0000ff;">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type ==<span style="color:#000000;"> AVMEDIA_TYPE_AUDIO) {
            audio_stream_idx </span>=<span style="color:#000000;"> i;
            </span><span style="color:#0000ff;">break</span><span style="color:#000000;">;
        }
    }
    </span><span style="color:#008000;">//</span><span style="color:#008000;">4.获取解码器
    </span><span style="color:#008000;">//</span><span style="color:#008000;">根据索引拿到对应的流,根据流拿到解码器上下文</span>
    AVCodecContext *pCodeCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;<span style="color:#000000;">codec;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">再根据上下文拿到编解码id，通过该id拿到解码器</span>
    AVCodec *pCodec = avcodec_find_decoder(pCodeCtx-&gt;<span style="color:#000000;">codec_id);
    </span><span style="color:#0000ff;">if</span> (pCodec ==<span style="color:#000000;"> NULL) {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">无法解码</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }
    </span><span style="color:#008000;">//</span><span style="color:#008000;">5.打开解码器</span>
    <span style="color:#0000ff;">if</span> (avcodec_open2(pCodeCtx, pCodec, NULL) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">) {
        printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">编码器无法打开</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }
    </span><span style="color:#008000;">//</span><span style="color:#008000;">编码数据</span>
    AVPacket *packet = av_malloc(<span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(AVPacket));
    </span><span style="color:#008000;">//</span><span style="color:#008000;">解压缩数据</span>
    AVFrame *frame =<span style="color:#000000;"> av_frame_alloc();
    
    </span><span style="color:#008000;">//</span><span style="color:#008000;">frame-&gt;16bit 44100 PCM 统一音频采样格式与采样率</span>
    SwrContext *swrCtx =<span style="color:#000000;"> swr_alloc();
    </span><span style="color:#008000;">//</span><span style="color:#008000;">重采样设置选项-----------------------------------------------------------start
    </span><span style="color:#008000;">//</span><span style="color:#008000;">输入的采样格式</span>
    <span style="color:#0000ff;">enum</span> AVSampleFormat in_sample_fmt = pCodeCtx-&gt;<span style="color:#000000;">sample_fmt;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">输出的采样格式 16bit PCM</span>
    <span style="color:#0000ff;">enum</span> AVSampleFormat out_sample_fmt =<span style="color:#000000;"> AV_SAMPLE_FMT_S16;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">输入的采样率</span>
    <span style="color:#0000ff;">int</span> in_sample_rate = pCodeCtx-&gt;<span style="color:#000000;">sample_rate;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">输出的采样率</span>
    <span style="color:#0000ff;">int</span> out_sample_rate = <span style="color:#800080;">44100</span><span style="color:#000000;">;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">输入的声道布局</span>
    uint64_t in_ch_layout = pCodeCtx-&gt;<span style="color:#000000;">channel_layout;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">输出的声道布局</span>
    uint64_t out_ch_layout =<span style="color:#000000;"> AV_CH_LAYOUT_MONO;

    swr_alloc_set_opts(swrCtx, out_ch_layout, out_sample_fmt, out_sample_rate, in_ch_layout, in_sample_fmt,
            in_sample_rate, </span><span style="color:#800080;">0</span><span style="color:#000000;">, NULL);
    swr_init(swrCtx);
    </span><span style="color:#008000;">//</span><span style="color:#008000;">重采样设置选项-----------------------------------------------------------end
    </span><span style="color:#008000;">//</span><span style="color:#008000;">获取输出的声道个数</span>
    <span style="color:#0000ff;">int</span> out_channel_nb =<span style="color:#000000;"> av_get_channel_layout_nb_channels(out_ch_layout);
    </span><span style="color:#008000;">//</span><span style="color:#008000;">存储pcm数据</span>
    uint8_t *out_buffer = (uint8_t *) av_malloc(<span style="color:#800080;">2</span> * <span style="color:#800080;">44100</span><span style="color:#000000;">);
    FILE </span>*fp_pcm = fopen(<span style="color:#800000;">"</span><span style="color:#800000;">out.pcm</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">wb</span><span style="color:#800000;">"</span><span style="color:#000000;">);
    </span><span style="color:#0000ff;">int</span> ret, got_frame, framecount = <span style="color:#800080;">0</span><span style="color:#000000;">;
    </span><span style="color:#008000;">//</span><span style="color:#008000;">6.一帧一帧读取压缩的音频数据AVPacket</span>
    <span style="color:#0000ff;">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span style="color:#800080;">0</span><span style="color:#000000;">) {
        </span><span style="color:#0000ff;">if</span> (packet-&gt;stream_index ==<span style="color:#000000;"> audio_stream_idx) {
            </span><span style="color:#008000;">//</span><span style="color:#008000;">解码AVPacket-&gt;AVFrame</span>
            ret = avcodec_decode_audio4(pCodeCtx, frame, &amp;<span style="color:#000000;">got_frame, packet);
            </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">) {
                printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%s</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">解码完成</span><span style="color:#800000;">"</span><span style="color:#000000;">);
            }
            </span><span style="color:#008000;">//</span><span style="color:#008000;">非0，正在解码</span>
            <span style="color:#0000ff;">if</span><span style="color:#000000;"> (got_frame) {
                printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">解码%d帧</span><span style="color:#800000;">"</span>, framecount++<span style="color:#000000;">);
                swr_convert(swrCtx, </span>&amp;out_buffer, <span style="color:#800080;">2</span> * <span style="color:#800080;">44100</span>, frame-&gt;data, frame-&gt;<span style="color:#000000;">nb_samples);
                </span><span style="color:#008000;">//</span><span style="color:#008000;">获取sample的size</span>
                <span style="color:#0000ff;">int</span> out_buffer_size = av_samples_get_buffer_size(NULL, out_channel_nb, frame-&gt;<span style="color:#000000;">nb_samples,
                        out_sample_fmt, </span><span style="color:#800080;">1</span><span style="color:#000000;">);
                </span><span style="color:#008000;">//</span><span style="color:#008000;">写入文件进行测试</span>
                fwrite(out_buffer, <span style="color:#800080;">1</span><span style="color:#000000;">, out_buffer_size, fp_pcm);
            }
        }
        av_free_packet(packet);
    }
    fclose(fp_pcm);
    av_frame_free(</span>&amp;<span style="color:#000000;">frame);
    av_free(out_buffer);
    swr_free(</span>&amp;<span style="color:#000000;">swrCtx);
    avcodec_close(pCodeCtx);
    avformat_close_input(</span>&amp;<span style="color:#000000;">pFormatCtx);
    </span><span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span><span style="color:#000000;">;
}</span></pre>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f626f6f6e7961:2f61727469636c652f64657461696c732f3739343734373534" class_="artid" style="display:none">
 </p>
</div>


