---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f7869616e677869313230342f:61727469636c652f64657461696c732f313139383631313537"
layout: post
title: "常用黑盒测试方法"
date: 2021-08-23 02:38:01 +0800
description: "定义：黑盒测试又称功能测试。黑盒测试就是把测试对象看成一个不能打开的黑盒子，在完全不考虑程序的内部结"
keywords: "黑盒测试方法有哪些"
categories: ['功能测试']
tags: ['黑盒测试', '软件测试', '测试类型', '测试工程师']
artid: "119861157"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=119861157
    alt: "常用黑盒测试方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=119861157
featuredImagePreview: https://bing.ee123.net/img/rand?artid=119861157
---

# 常用黑盒测试方法

定义：黑盒测试又称功能测试。黑盒测试就是把测试对象看成一个不能打开的黑盒子，在完全不考虑程序的内部结构和处理过程的情况下，只依据程序的需求规格说明书，检查程序的功能是否符合他的功能说明。

黑盒测试主要发现的缺陷类型：

1、功能错误或遗漏；

2、界面错误；

3、数据库错误；

4、性能错误；

5、初始化和终止错误。

黑盒测试的基本思路：

黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的，又称为数据驱动测试。 黑盒测试是在程序外部接口进行的测试。

黑盒测试选择测试数据：

1、理论上，黑盒测试只有采用穷举输入测试，把所有可能的输入都作为测试情况考虑，才能查出程序中所有的错误。

2、实际上，测试情况有无穷多个，我们不仅要测试所有正常的输入，而且还要对那些不合法但可能的输入进行测试，穷举是不可能的。

3、因此，要有针对性的进行测试，必须精心设计测试用例，从数量极大的可用测试数据中挑选典型的测试数据，使用这些测试数据高效率地把隐藏的错误揭露出来。

黑盒测试的方法：

等价类划分法、边界值分析法、判定表法、因果图法、场景法、错误推测法、功能图法

下面对每一种测试方法进行了简单的整理，其中有参考其他文章。

## 一、等价类划分法

1、
**定义**
：等价类划分的方法就是将程序的输入域划分为若干部分，也可以说是若干个等价类，然后从各个部分中选取少数代表性数据进行测试。

2、
**等价类**
：是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的。测试某等价类的代表值就等价于对这一类其他值的测试。

3、
**有效等价类与无效等价类**
：

对于程序的规格来说，是输入数据构成的集合

|  |  |  |
| --- | --- | --- |
| 等价类 | 输入 | 关注点 |
| 有效等价类 | 合理的、有意义的 | 功能和性能 |
| 无效等价类 | 不合理的、无意义的 | 异常处理 |

设计测试用例时，要同时考虑有效等价类和无效等价类的设计。软件不能只接收合理的数据，还要经受意外的考验，接受无效的或不合理的数据，这样软件才能具有较高的可靠性。

把所有可能的输入数据划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。

它是一种典型的、常用的黑盒测试方法。

4、
**等价类划分法步骤**

1）划分等价类（有时需细化）

2）建立等价类表，等价类进行编号

3）通过等价类导出测试用例

5、
**如何划分等价类——等价类种类**

1）按双边区间划分：如果输入条件规定了取值范围，或值的个数，则可以确立一个有效等价类和两个无效等价类

2）按取值划分：如果规定了输入数据的一组值（假定n个），且程序要对每一个输入值分别进行处理的情况下，可确定n个有效等价类（每个值确定一个有效等价类）和一个无效等价类（所有不允许的输入值的集合）。

3）按单边区间划分：如果输入条件规定了输入值的集合，这时可确立一个有效等价类和一个无效等价类。

4）按限制条件/ 规则划分：如果规定了输入数据必须遵守的规则或限制条件，可确定一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）

6、
**按处理方式细分等价类**

在已划分的等价类中，各元素在程序中的处理方式不同的情况下，则应再将该等价类进一步划分为更小的等价类，并建立等价类表。

7、
**建立等价类表，并对等价类编号**

在确认等价类之后，建立等价类表，列出所有划分出的等价类，如下表

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
| 输入条件 | 有效等价类 | 编号 | 无效等价类 | 编号 |
| 年龄 | 正整数 | E01 | 负数 | E04 |
| 小数 | E05 |
| 字母 | E06 |
| 字符 | E07 |
| 汉字 | E08 |
| (0,150) | E02 | >=150 | E09 |
| <=0 | E10 |
| 非空 | E03 | 空 | E11 |

8、
**等价类导出测试用例**

|  |  |  |
| --- | --- | --- |
| 编号 | 有效输入 | 覆盖有效等价类 |
| U01 | 50 | E01、E02、E03 |
| 编号 | 无效输入 | 覆盖无效等价类 |
| U02 | -40 | E04 |
| U03 | 10.3 | E05 |
| U04 | “G” | E06 |
| U05 | “\*” | E07 |
| U06 | “年” | E08 |
| U07 | 150 | E09 |
| U08 | 0 | E10 |
| U09 | 空 | E11 |

9、
**导出测试用例的原则**

从划分出的等价类中按以下原则设计测试用例：

1）编号唯一；

2）尽可能多地覆盖尚未覆盖的有效等价类；

3）仅覆盖一个尚未覆盖的无效等价类；

4）覆盖所有的有效和无效等价类

10、
**弱健壮等价类测试用例设计法**

1）对于有效等价类，从每个有效等价类选取一个值。

2）对于无效等价类，使用一个无效值，并保持其余的值都是有效的。

11、
**为什么两种等价类的覆盖方式不一样？**

1）对于有效等价类，采取尽量覆盖的方式是为了全面考察软件的功能。

2）对于无效等价类、采取每次只覆盖一个的方式是因为：通常程序发现一类错误后就不再检查是否还有其他错误。

## 二、边界值分析法

1、
**定义：**

边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。

2、
**边界点**
：

1）边界是指相对于输入等价类和输出等价类而言，稍高于、稍低于其边界值的一些特定情况。

2）边界点分为上点、内点和离点。

3、
**与等价划分法的区别：**

1)边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。

2)边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。

3）等价类划分法是从某个等价类中人选一个座位测试数据，而边界值分析法是在每个边界上有针对性的选择测试数据

长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。 使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。

例如：

程序员只处理了1-10位的情况，忘记对10位进行处理；

程序员把≤误写成了＜，计数器发生少计数一次。

4、
**如何选择测试数据？（选择测试数据的原则）**

1）如果输入条件规定了值的范围，则应取刚达到这个范围的边界值，以及刚刚超越这个范围边界的值作为测试输入数据。

例如：程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。

测试数据取7个点应取10、25及50，还应取10.01,49.99,9.99及50.01

测试数据取5个点应取10、25及50，还应取9.99及50.01

重量可以是小数，没有规定小数点个数时默认取两位

2）如果输入条件规定了值的个数，则用最大个数，最小个数，比最小个数少1，比最大个数多1的数作为测试数据。

例如，一个输入文件应包括1-255个记录。

测试数据可取1和255，还应取0及256等

3）根据规格中每个输出条件，使用原则1，如果输出条件规定了值的范围，则应取刚达到这个范围的边界值，以及刚刚超越这个范围边界的值作为测试输入数据。

例如，程序的规格说明要求计算出“每月绩效奖金为0至1165.25元”。

测试用例可取0.00及1165.25，还可取-0.01及1165.26等。

4）根据规格中每个输出条件，使用原则2，如果输出条件规定了值的个数，则用最大个数、最小个数，比最小个数少1，比最大个数多1的数作为测试数据。

例如，情报检索系统，要求每次“最少显示1条、最多显示4条情报摘要”。

这时我们应考虑的测试用例包括1和4，还应包括0和5等。

5）如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。

例如，程序系统设计文档中，上传的图片：图片格式、图片名字、图片大小、图片是否有效…

6）分析规格说明，找出其他可能的边界条件

例如，特殊边界值：默认值、空值、空格、零、无效数据等

5、
**边界值检验的主要类型**

|  |  |
| --- | --- |
| 边界类型 | 输入 |
| 数字 | 最大、最小 |
| 字符 | 首位、末位 |
| 位置 | 上、下 |
| 重量 | 最高、最低 |
| 速度 | 最快、最慢 |
| 方位 | 最高、最低 |
| 尺寸 | 最长、最短 |
| 空间 | 空、满 |
| … | … |

在多数情况下，边界值条件是基于应用程序的功能设计而需要考虑的因素，可以从软件的需求规格或常识中得到，也是最终用户可以很容易发现问题的。

还有没有从软件规格说明中看不到的边界值呢？

**6、内部边界值**

有些边界值条件在软件内部，用户几乎看不到，但同时确实属于检验范畴内的边界条件，成为内部边界条件或次边界值条件。

常见的内部边界值条件有下面两种：

1）数值的边界值

2）字符的边界值

在实际的测试用例中，需要将基本的软件设计要求和程序定义的要求结合起来，即结合基本边界值条件和内部边界值条件来设计有效的测试用例。

计算机是基于二进制进行工作的，因此，软件的任何数值运算都有一定的范围限制。

|  |  |
| --- | --- |
| 项 | 范围或值 |
| 位（bit） | 0或1 |
| 字节（byte） | 0-255 |
| 字（Word） | 0-65535（单字）或0-4294967295（双字） |

例如，程序有一个输入变量x的范围是（0,10000），但是在程序内部，当想x≤255时，用一个字节表示，当x>255时用一个字表示，那么，255就是一个内部边界值。

7、
**边界条件设计测试用例步骤**

1）确定边界情况

通常输入或输出等价类的边界就是应该着重测试的边界情况。

2）选取测试数据

选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值。

例如：程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。

测试数据取7个点应取10、25及50，还应取10.01,49.99,9.99及50.01

|  |  |  |  |
| --- | --- | --- | --- |
| 测试用例 | X | 输入数据 | 预期输出 |
| T1 | Xmin- | 9.99 | F1 |
| T2 | Xmin | 10 | F2 |
| T3 | Xmin+ | 10.01 | F3 |
| T4 | Xnom | 25 | F4 |
| T5 | Xmax- | 49.99 | F5 |
| T6 | Xmax | 50 | F6 |
| T7 | Xmax+ | 50.01 | F7 |

例如：对于函数F（x1，x2），其输入变量x1和x2的取值边界定义如下：

a≤x1≤b；c≤x2≤d

其中两个变量都为正数。

|  |  |  |  |
| --- | --- | --- | --- |
| 编号 | X1 | X2 | F（x1，x2） |
| 1 | ab | c | F(ab,c) |
| 2 | ab | d | F(ab,d) |
| 3 | ab | cd |  |
| 4 | ab | c- |  |
| 5 | ab | d+ |  |
| 6 | a | cd |  |
| 7 | b | cd |  |
| 8 | a- | cd |  |
| 9 | b+ | cd |  |

8、
**边界条件测试用例设计法**

基于边界的方法是根据定义域来实现的，最终演变成一般边界值条件测试、健壮性测试、最坏情况测试和健壮最坏情况测试四种技术。

1）一般边界值条件测试：

（1）每次保留程序中一个变量，让其余的变量取正常值，被保留的变量依次取min、min+、nom、max-、max

（2）对程序中的每个变量重复（n个变量的测试用例个数为4n+1个）

2）健壮性测试：

（1）每次保留程序中一个变量，让其余的变量取正常值，被保留的变量依次取min-、min、min+、nom、max-、max、max+。

（2）对程序中的每个变量重复（n个变量的测试用例个数为6n+1个）

3）最坏情况测试：

（1）所有变量均可去min、min+、nom、max-、max+这五个边界值中的任何一个。（组合）

（2）测试用例为五个集合的笛卡尔乘积。对于一个n变量函数，该方法生成的测试用例数为5的n次方个。

4）健壮最坏情况测试：

（1）所有变量均可取min-、min、min+、nom、max-、max、max+这7个边界值中的任何一个。

（2）测试用例为7个集合的笛卡尔乘积。对于一个n变量函数，该方法生成的测试用例数为7的n次方个。

**笛卡尔乘积**
是指在数学中，两个
[集合](https://baike.baidu.com/item/%E9%9B%86%E5%90%88 "集合")
X和Y的笛卡尔积（Cartesian product），又称
[直积](https://baike.baidu.com/item/%E7%9B%B4%E7%A7%AF/6537064 "直积")
，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能
[有序对](https://baike.baidu.com/item/%E6%9C%89%E5%BA%8F%E5%AF%B9 "有序对")
的其中一个成员。假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。

## 三、判定表法

1、
**定义：**

判定表(decision table)，是指一个表格，用于显示条件和条件导致动作的集合。是分析和表达多逻辑条件下执行不同操作的工具。

2、
**为什么要有判定表法？**

前面我们讲到的等价类划分，边界值分析这些方法都只是单个的输入测试，并没有什么逻辑和组合关系，但是我们的程序又是多种多样的复杂关系，所以我们需要一种方法来适用多种组合。

3、
**判定表的几个基本条件：**

条件桩：列出问题的所有条件

动作桩：列出可能采取的所有操作

条件项：列出所有条件的取值

动作项：所有取值条件下输出的情况通常：0表示某条件不出现，1表示某条件出现

4、
**如何使用判定表？**

让我们来看一下这个例子：

拿最近抖音比较热门的关于现在老师是否合格为题

怎样算一个好老师？有责任心、关爱学生、肯定是一个好老师；但是只要是不把教学放在首位肯定不是一个老师

那么根据上面的题目，我们首先分析一下条件桩有哪些？

1）有责任心

2）关爱学生

3）不把教学放在首位

一般来讲 如果有n个条件，那么我们的输入条件就是2n次方

|  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  |  | 情况1 | 情况2 | 情况3 | 情况4 | 情况5 | 情况6 | 情况7 | 情况8 |
| 输入条件 | 有责任心 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 关爱学生 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1 |
| 不把教学放在首位 | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 |
| 输出条件 | 好老师 | 1 |  | 1 |  |  | 1 |  | 1 |
| 差老师 |  | 1 |  | 1 | 1 |  | 1 |  |

可以得出以上8种情况，那么我们再来看，只要是不把教学放首位的肯定都是差老师，可以得出有4种情况其实是一样的。

最终简化:

|  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- |
|  |  | 情况1 | 情况2 | 情况3 | 情况6 | 情况8 |
| 输入条件 | 有责任心 | 1 | 1 | 1 | 0 | 0 |
| 关爱学生 | 1 | 1 | 0 | 0 | 1 |
| 不把教学放在首位 | 1 | 0 | 1 | 1 | 1 |
| 输出条件 | 好老师 | 1 |  | 1 | 1 | 1 |
| 差老师 |  | 1 |  |  |  |

1）有责任心，关爱学生，把教学放首位：好老师

2）不把教学放首位：差老师

3）有责任心，不关爱学生，把教学放首位：好老师

4）无责任心，不关爱学生，把教学放首位：好老师

5）无责任心，关爱学生，把教学放首位：好老师

## 四、因果图法

1、
**定义：**

因果图法就是把复杂的逻辑关系转化成判定表的系统化方法，从该图中可以产生测试数据。其中，原因是表示输入条件，结果是对输入执行的一系列计算后得到的输出。     因果图法最终生成的就是判定表，它适合于检查软件输入条件的各种组合情况

2、
**因果图分类：**

第一类：因果关系（输入和输出之间的逻辑关系）

1）恒等：输入：a，输出：b ，满足条件a ，则输出b

2）非：   输入：a，输出：b ，满足条件a，则不能输出b

3）或：多个输入条件只要满足一个或一个以上就可以得到某个结果（符号V）

例如：入学考试：a条件会c语言，b条件会java，c条件会C#，以上条件满足一个就可以入学

4）与：多个输入同时满足才能得到某个结果（符号倒V）

例如：就业推荐：a条件为51学员，b条件为三个阶段考试合格，c条件为出勤率达到90%，则会推荐就业

第二类：原因与原因之间的关系（输入与输入之间的制约关系）

1）E的关系exclusive  互斥：多个输入至多只能有一个为真，不可以同时都为真，可以同时都不为真（只能一个为真，可以都为假）

2）I的关系  inclusive 包容：多个输入至少有一个为真，可以同时都为真，但是不可以同时都不为真（至少一个为真，不能同时为假）

3）O的关系 Only       唯一：多个输入有且只能有一个为真，不可以同时都为真，也不可以同时都不为真

4）R的关系 ruquire  要求：有两个输入a，b ，a为真则要求b 为真，a为假则对b不做要求

例如：早教机构：小朋友a ,父母b

如果小朋友到早教中心上课，则要求父母陪护

如果小朋友不到早教中心上课，则父母可以来参观也可以不来参观

第三类：结果与结果之间的关系（输出与输出之间的制约关系）

1）M关系  强制的关系：输入a，b ，如果a为真则强制b为假，a为假则对b不做强制

3、
**因果图的使用步骤**

1）划分需求规格片段

2）找出输入输出

3）分析输入与输出之间的关系，画出因果图（包括因果之间关系，原因与原因，结果与结果之间的关系）

4）把因果图转换成判定表

5）简化判定表

6）用判定表中的每一项生成测试用例（结合等价、边界值）

4、
**因果图法的优缺点**

优点：

1）等价类法尽管各个输入条件可能出错的情况都考虑到了，但是多个输入条件组合起来出错的情况却被忽略了

因果图法是一个全排列组合的方法

2） 因果图法能够帮助我们按照一定步骤，高效的选择测试用例，设计多个输入条件组合用例

因为考虑了条件与结果之间的关系，从而更高效

3）因果图分析还能为我们指出，程序规格说明描述中存在什么问题

基于规格的测试

缺点：

1）输入条件与输出结果的因果关系，有时难以从软件需求规格说明书得到

2）即使得到了这些因果关系，也会因为因果关系复杂导致因果图非常庞大，测试用例数目及其庞大（工作量大）

## 五、场景法

1、
**定义：**

通过运用场景来对系统的功能点或业务流程的描述，从而提高测试效果的一种方法。（加入要你从A点走到B点，其中一种走法是你在大路上从头到尾每一步都走得很漂亮，路上鸟语花香。还有很多种走法是你走了其他的小路，但是最终还是走到了B点，即使中间你摔倒过、绕过了一条河、走过一座桥等。这些都属于场景。）

![](https://i-blog.csdnimg.cn/blog_migrate/d34891db84ef510fc16cdf733a0ecaa1.png)

2、
**场景法组成：**

1）基本流：基本事件

如图中间的黑色直线，基本流是经过用例最简单的路径，即无任何的差错，程序从开始直接执行到结束的流程，通常来讲，一个业务只存在一个基本流，并且基本流只有一个起点和一个终点

2）备选流：分支事件

如图中间黑色直线两旁的彩色线条，备选流为除了基本流之外的各个支流，包含了多种不同情况。例如：一个备选流可开始于基本流，在某个特定条件下执行，然后重新加入基本流中（备选流1和备选流3）；也可以开始于另一个备选流（备选流2）；也可以终止用例不在加入到基本流中（备选流2和备选流4）

3、
**场景组合：**

按上图组合多个不同的场景：

场景1：基本流

场景2：基本流 备选流1

场景3：基本流 备选流1 备选流2

场景4：基本流 备选流3

场景5：基本流 备选流3 备选流1

场景6：基本流 备选流3 备选流1 备选流2

场景7：基本流 备选流4

场景8：基本流 备选流3 备选流4

4、
**用例设计步骤**

1）分析需求，确定出软件的基本流和各项备选流。

2） 依据基本流和各项备选流，生成不同的场景。

3）针对生成的各场景，设计相应的测试用例。

4）重新审核生成的测试用例，去掉多余的部分，并针对最终确定出的测试用例，设计测试数据。

5、
**案例分析**

例子：分析ATM取款机的场景流程，并设计测试用例和测试数据

基本流：

1）插入磁卡

2）ATM验证账户正确

3） 输入密码正确，通过验证

4）输入取款金额

5）取出金额

6）取卡

备选流一：账户不存在或者受限制

备选流二：密码不正确，还有输入机会

备选流三：密码不正确，没有输入机会

备选流四：卡中余额不足

备选流五：ATM机中余额不足

备选流六：超过每日最大提款限额

备选流七：输入金额非100的倍数

采用场景法进行测试用例的设计：

![](https://i-blog.csdnimg.cn/blog_migrate/59c982f89e7a12b27d8aee5cb20d551d.png)

![](https://i-blog.csdnimg.cn/blog_migrate/53900bb67fe4a67477b1a01d0709291e.png)

## 六、错误推测法

1、
**定义：**

基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。

2、
**基本思想：**

列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。

3、
**实例**

1）例如,输入数据和输出数据为0的情况；输入表格为空格或输入表格只有一行。这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。

2）例如，前面例子中成绩报告的程序，采用错误推测法还可补充设计一些测试用例：

（1） 程序是否把空格作为回答

（2）在回答记录中混有标准答案记录

（3） 除了标题记录外，还有一些的记录最后一个字符即不是2也不是3

（4）有两个学生的学号相同

（5）试题数是负数

3）例如，测试手机终端的通话功能，可以设计各种通话失败的情况来补充测试用例：

（1）无SIM 卡插入时进行呼出（非紧急呼叫）

（2）插入已欠费SIM卡进行呼出

（3）射频器件损坏或无信号区域插入有效SIM卡呼出

（4）网络正常，插入有效SIM卡，呼出无效号码（如1、888、333333、不输入任何号码等）

（5）网络正常，插入有效SIM卡，使用“快速拨号”功能呼出设置无效号码的数字

## 七、功能图法

1、
**定义：**

功能图方法是用功能图形象的描述程序的功能说明，并机械的生成功能图的测试用例。功能图由状态迁移图和逻辑功能模型构成。

程序的功能说明通常由动态说明和静态说明组成， 动态说明描述的是输入数据的次序和转移的次序，而静态说明描述的是输入条件与输出条件之间的对应关系。当程序中过于复杂并且存在大量的组合时，仅仅使用静态说明设计的测试用例，往往是考虑不够的，所以采用动态说明来补充一定的测试用例时必要的。而功能图法就是使用动态描述来生成测试用例的方法，其本质是一种白盒和黑盒测试方法组合的测试用例设计方法。

2、
**其中状态迁移图和逻辑功能模型的相关描述如下：**

1）状态迁移图用于表示输入数据序列以及相应的输出数据。在状态迁移图中，由输入数据和当前状态决定输出数据和后续状态。

2）逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系。逻辑功能模型仅用于描述静态说明，输出数据仅由输入数据决定。测试用例则是由测试中经过一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成。

3、
**状态迁移图法导出测试用例的步骤**

1）明确状态节点。 分析被测对象的测试特性及需求规格说明书，明确被测对象的状态节点数量及相互迁移关系。

2）绘制状态迁移图。 利用圆圈表示状态节点，有向箭头表示状态间的迁移关系，根据需要在箭头旁边标识迁移条件。可以利用绘图软件绘制状态迁移图。

3）绘制状态迁移树。 根据状态迁移图，按照广度优先和深度优先搜索绘制状态迁移树。首先确定起始节点和终止节点，在绘制时，当路径上遇到终止节点时，不再扩展，遇到已经出现的节点也停止扩展。

4）抽取测试路径设计用例。 根据绘制好的状态迁移树，提取测试路径，从左到右，横向抽取，每条路径构成一条测试规则，然后再利用等价类和边界值等测试用例设计方法设计具体的测试用例。

4、
**实例：**

一个编辑文本的软件中有可以改变字体颜色的功能，其中可选的颜色共有黑、红、蓝三种颜色。想要测试这个功能，首先，分析上述需求可以得出，该功能共有三种状态，假设红色为起始状态，那么可以得到如下的状态迁移图：

![](https://i-blog.csdnimg.cn/blog_migrate/5be17cf62d9c7935b6fe6099a5949075.png)

根据上述的状态迁移图，绘制出如下的状态迁移树：

![](https://i-blog.csdnimg.cn/blog_migrate/7e51edc5e46b3a701727339e4f982a0d.png)

然后，从状态迁移树中，可以生成以下规则：

![](https://i-blog.csdnimg.cn/blog_migrate/2894ace86820dd8624052df12a7748ee.png)

根据以上测试用例规则，可以生成以下测试用例：

![](https://i-blog.csdnimg.cn/blog_migrate/d84bc86b070bffd62baa1d66c968584d.png)