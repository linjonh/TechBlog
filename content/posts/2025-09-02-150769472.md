---
layout: post
title: "linux_工具"
date: 2025-09-02T09:18:23+0800
description: "ok，这里我已经通过gcc编译出了一个可执行文件test，这个test是基于test.c这个文件生成的，所以这个test.c就是test的依赖文件，test就是test.c的目标文件，那么test和test.c 就可以构成一个依赖关系。这是Makefile中的一个关键字，她的作用是修饰这个目标文件，这个目标文件总是被执行的，把它放到依赖关系的上面，就可以使每一次的make都会执行到这一个依赖关系。云服务器里的连接一般都是国外的连接，访问的时候可能会很慢，所以一般都是用国内的yum源镜像，"
keywords: "linux_工具"
categories: ['未分类']
tags: ['运维', '服务器', 'Linux']
artid: "150769472"
arturl: "https://blog.csdn.net/m0_53697204/article/details/150769472"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150769472
    alt: "linux_工具"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150769472
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150769472
cover: https://bing.ee123.net/img/rand?artid=150769472
image: https://bing.ee123.net/img/rand?artid=150769472
img: https://bing.ee123.net/img/rand?artid=150769472
---



# linux_工具

## 程序的开发

```
yum / vim / gcc，g++ / make / makefile / git / gdb

```

### Linux 软件安装包 yum

当我们在手机上从应用商店里下载软件安装包的时候，都是从云服务器上把安装包下载到本地。然后在进行安装的。yum在linux中就类似于手机中的应用商店。

```
yum list | grep sl   //搜索名字里带有sl的应用

```

安装：yum install 软件名  
 卸载：yum remove 软件名

正如我们手机上的软件管家一样，yum是怎么知道去哪里下载的呢？

```
这些软件管家必须知道各个软件的下载地址（一般都是内置下载链接的地址——配置文件），yum有自己的配置文件（yum源），
查看自己设备的yum源 ：ls /etc/yum.repos.d/

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/328f908e01c54e24839c45a98d9b20b0.png)

如何更新自己的yum源

```
1.先将自己的CentOS-Base.repo做一个备份，
2. 进入yum源配置文件所在的文件夹—— cd /etc/yum.repos.d/
3. 下载163的yum源配置文件到上面这个文件夹里——wget http：//网址(可以从网上找)
4. 将镜像源的配置文件重命名 mv CentOS-Base.repo
5. 运行yum clear all & yum makecache 生成缓存

```

如果像安装的软件找不到，有可能是在扩展的yum源中：epel.repo  
 sudo yum install -y epel-release # 根据你的基本yum源，找到匹配的扩展yum源  
 sudo yum install -y 即可！

### vim

vim是一款多模式的编辑器，各种模式互相切换。

1. vim 最小集

   命令模式：默认打开的模式  
    插入模式：命令模式 i 进入处插入模式，（还有其他的字符，暂时不加上了，不用那么多）  
    底行模式：命令模式 shift ： 进入底行模式  
    替换模式：命令模式shift r 进入替换模式  
    视图模式：  
    任何模式想进入命令模式就是无脑ESC
2. vim指令集

   ```
    命令模式下
    yy/nyy复制当前行/当前行在内的若干行，p/np粘贴，u撤销刚刚的操作，ctrl+r 对撤销进行撤销，dd/ndd剪切，shift g将光标定位到末尾，
    gg定位到开始，n shift g（G）定位到第n行,w\b按照单词为单位进行前后移动， shift $ 将光标定位到文档行的结尾，shift ^ 将光标定位到
    文档行的开始，shift ~ 切换大小写，r替换光标位置的字符，nr连续n个字符被替换（从光标处开始），x往后删，shift x（X）往前删。
    光标移动用HJKL左下上右。
    底行模式下
    set nu/nonu 显示行号，
    !+命令可以在不退出vim的情况下执行命令
    %s/搜索目标/替换目标/g ：可以全文搜索，并用替换目标进行替换。
    /key：全文搜索key
    vs file：分屏，光标在哪边就编辑哪边，ctrl+ww，切换光标到不同的界面

   ```
3. vim配置

   ```
    a. 自己配置
    vim在启动的时候，会自动在当前用户的目录下寻找配置文件，如果没有，就是默认，/home/vimtest。
    自己配置的时候，先在当前用户的目录下新建.vimrc，从网上搜想要的配置，复制粘贴到.vimrc中
    b.自动化配置（目前只支持CentOS 7.x）
    curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh && bash ./install.sh
    复制粘贴这个连接到命令行中，回车即可
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bf2ca711dccf4c1e81987cda4457a683.png)

   ```

### gcc/g++使用

#### gcc

gcc -o ：**后面**跟着形成的可执行程序的名称，  
 （1）预处理（头文件展开，条件编译，宏替换，去注释）

```
-E：做完预处理这一步就停下，不进行后续的步骤，生成的文件一般是.i文件

```

（2）编译（c语言汇编语言）

```
-S:做完编译停下，生成.s文件

```

（3）汇编（汇编->可重定位目标二进制文件，不可以被执行 .obj .bin）

```
-c ：只将我们自己的代码进行翻译成二进制目标文件，形成.o文件

```

（4）链接（将我们自己形成的.obj文件和库文件某种合并，形成可执行程序）

```
gcc：直接生成可执行文件，目前不用带选项

```

ldd可以检测我们最后形成的可执行程序用了哪些库  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/13c4afe800c24d978969169aa711ea00.png)

#### 库

库分两种 – 库本质也是文件：  
 1.静态库：libXXXXXX.a  
 2.动态库: libXXXXX.so

```
上面这两种是在linux中，在windows中，静态库后缀.lib  ，动态库后缀.ddl

```

动静态库：

```
1.库分为静态库（专门让编译器对用户的程序进行静态连接的）和动态库（专门让编译器对用户的程序进行动态连接的)
2.静态库和静态链接：链接的时候，拷贝静态库中我所需要的代码到我自己的可执行程序中
3.动态库和动态链接：链接的时候，拷贝动态库中的地址到我自己的可执行程序中相关的位置去。
4.静态库连接成功后，即使静态库被删除，也不会影响程序独立运行。
5.动态库连接成功：还是会依赖动态库，一旦动态库缺失，程序就无法独立运行！
6.因为自身拷贝的问题，比较浪费空间
7.真正的实现只在库中，比较节省空间
8.Linux默认使用的是动态库和动态链接！

```

### 自动化构建工具make/Makefile

make是一个专门为Makefile写的命令，Makefile 是一个文件（一般位于当前的源代码路径下）

#### make

make会默认执行Makefile文件里面的第一个默认依赖关系，什么是依赖关系，我来举个例子  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/57a51b0eab8440988d538d1c6aa74270.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a6162820ab7a4278bdd3ed4c4b467223.png)

.PHONY：总是被执行的！  
 这是Makefile中的一个关键字，她的作用是修饰这个目标文件，这个目标文件总是被执行的，把它放到依赖关系的上面，就可以使每一次的make都会执行到这一个依赖关系。  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/298f7e2003354d90b0c240e88273894c.png)  
 上面有两个.PHONY，但单独使用make的时候依旧只会运行第一个依赖关系和依赖规则



