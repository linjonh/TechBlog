---
layout: post
title: "Rust语言基础知识详解九"
date: 2025-03-10 14:32:31 +0800
description: "对rust中枚举类型进行介绍"
keywords: "Rust语言基础知识详解【九】"
categories: ['Rust']
tags: ['开发语言', 'Rust']
artid: "146153976"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146153976
    alt: "Rust语言基础知识详解九"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146153976
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146153976
cover: https://bing.ee123.net/img/rand?artid=146153976
image: https://bing.ee123.net/img/rand?artid=146153976
img: https://bing.ee123.net/img/rand?artid=146153976
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Rust语言基础知识详解【九】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     继上一章对复合类型中的结构体做了详细的介绍之后，本节将介绍枚举类型这个部分。
    </p>
    <h2 style="background-color:transparent">
     枚举
    </h2>
    <p>
     枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个
     <strong>
      枚举类型
     </strong>
     ，例如扑克牌花色：
    </p>
    <p>
     这里需要注意的是：枚举名和里面的枚举值的首字母最好都要大写，符合规范。
    </p>
    <pre><code class="language-rust">enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}</code></pre>
    <p>
     如果在此之前你没有在其它语言中使用过枚举，那么可能需要花费一些时间来理解这些概念，一旦上手，就会发现枚举的强大，甚至对它爱不释手，枚举虽好，可不要滥用哦。
    </p>
    <p>
     再回到之前创建的
     <code>
      PokerSuit
     </code>
     ，扑克总共有四种花色，而这里我们枚举出所有的可能值，这也正是
     <code>
      枚举
     </code>
     名称的由来。
    </p>
    <p>
     任何一张扑克，它的花色肯定会落在四种花色中，而且也只会落在其中一个花色上，这种特性非常适合枚举的使用，因为
     <strong>
      枚举值
     </strong>
     只可能是其中某一个成员。抽象来看，四种花色尽管是不同的花色，但是它们都是扑克花色这个概念，因此当某个函数处理扑克花色时，可以把它们当作相同的类型进行传参。
    </p>
    <p>
     对之前的
     <code>
      枚举类型
     </code>
     和
     <code>
      枚举值
     </code>
     进行了重点标注，这是因为容易混淆相应的概念，总而言之：
     <strong>
      枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例。
     </strong>
    </p>
    <h3>
     枚举值
    </h3>
    <p>
     现在来创建
     <code>
      PokerSuit
     </code>
     枚举类型的两个成员实例：
    </p>
    <pre><code class="language-rust">let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;</code></pre>
    <p>
     我们通过
     <code>
      ::
     </code>
     操作符来访问
     <code>
      PokerSuit
     </code>
     下的具体成员，从代码可以清晰看出，
     <code>
      heart
     </code>
     和
     <code>
      diamond
     </code>
     都是
     <code>
      PokerSuit
     </code>
     枚举类型的，接着可以定义一个函数来使用它们：
    </p>
    <pre><code class="language-rust">fn main() {
    let heart = PokerSuit::Hearts;
    let diamond = PokerSuit::Diamonds;
​
    print_suit(heart);
    print_suit(diamond);
}
​
fn print_suit(card: PokerSuit) {
    // 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug
    println!("{:?}",card);
}</code></pre>
    <p>
     <code>
      print_suit
     </code>
     函数的参数类型是
     <code>
      PokerSuit
     </code>
     ，因此我们可以把
     <code>
      heart
     </code>
     和
     <code>
      diamond
     </code>
     传给它，虽然
     <code>
      heart
     </code>
     是基于
     <code>
      PokerSuit
     </code>
     下的
     <code>
      Hearts
     </code>
     成员实例化的，但是它是货真价实的
     <code>
      PokerSuit
     </code>
     枚举类型。
    </p>
    <p>
     接下来，我们想让扑克牌变得更加实用，那么需要给每张牌赋予一个值：
     <code>
      A
     </code>
     (1)-
     <code>
      K
     </code>
     (13)，这样再加上花色，就是一张真实的扑克牌了，例如红心 A。
    </p>
    <p>
     目前来说，枚举值还不能带有值，因此先用结构体来实现：
    </p>
    <pre><code class="language-rust">enum PokerSuit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}
​
struct PokerCard {
    suit: PokerSuit,
    value: u8
}
​
fn main() {
   let c1 = PokerCard {
       suit: PokerSuit::Clubs,
       value: 1,
   };
   let c2 = PokerCard {
       suit: PokerSuit::Diamonds,
       value: 12,
   };
}</code></pre>
    <p>
     这段代码很好的完成了它的使命，通过结构体
     <code>
      PokerCard
     </code>
     来代表一张牌，结构体的
     <code>
      suit
     </code>
     字段表示牌的花色，类型是
     <code>
      PokerSuit
     </code>
     枚举类型，
     <code>
      value
     </code>
     字段代表扑克牌的数值。
    </p>
    <p>
     其实这样做不是很简洁，还有简洁得多的方式来实现：
    </p>
    <pre><code class="language-rust">enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}
​
fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(13);
}</code></pre>
    <p>
     直接将数据信息关联到枚举成员上，省去近一半的代码，这种实现是不是更优雅？
    </p>
    <p>
     不仅如此，同一个枚举类型下的不同成员还能持有不同的数据类型，例如让某些花色打印
     <code>
      1-13
     </code>
     的字样，另外的花色打印上
     <code>
      A-K
     </code>
     的字样：
    </p>
    <pre><code class="language-rust">enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(char),
    Hearts(char),
}
​
fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds('A');
}</code></pre>
    <p>
     回想一下，遇到这种不同类型的情况，再用我们之前的结构体实现方式，可行吗？也许可行，但是会复杂很多。
    </p>
    <p>
     再来看一个来自标准库中的例子：
    </p>
    <pre><code class="language-rust">struct Ipv4Addr {
    // --snip--
}
​
struct Ipv6Addr {
    // --snip--
}
​
enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}</code></pre>
    <p>
     这个例子跟我们之前的扑克牌很像，只不过枚举成员包含的类型更复杂了，变成了结构体：分别通过
     <code>
      Ipv4Addr
     </code>
     和
     <code>
      Ipv6Addr
     </code>
     来定义两种不同的 IP 数据。
    </p>
    <p>
     从这些例子可以看出，
     <strong>
      任何类型的数据都可以放入枚举成员中
     </strong>
     ：例如字符串、数值、结构体甚至另一个枚举。
    </p>
    <p>
     增加一些挑战？先看以下代码：
    </p>
    <pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
​
fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}</code></pre>
    <p>
     该枚举类型代表一条消息，它包含四个不同的成员：
    </p>
    <ul>
     <li>
      <p>
       <code>
        Quit
       </code>
       没有任何关联数据
      </p>
     </li>
     <li>
      <p>
       <code>
        Move
       </code>
       包含一个匿名结构体
      </p>
     </li>
     <li>
      <p>
       <code>
        Write
       </code>
       包含一个
       <code>
        String
       </code>
       字符串
      </p>
     </li>
     <li>
      <p>
       <code>
        ChangeColor
       </code>
       包含三个
       <code>
        i32
       </code>
      </p>
     </li>
    </ul>
    <p>
     当然，我们也可以用结构体的方式来定义这些消息：
    </p>
    <pre><code class="language-rust">struct QuitMessage; // 单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体</code></pre>
    <p>
     由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受 4 个不同的结构体作为参数。
    </p>
    <p>
     而且从代码规范角度来看，枚举的实现更简洁，代码内聚性更强，不像结构体的实现，分散在各个地方。
    </p>
    <h3>
     同一化类型
    </h3>
    <p>
     最后，再用一个实际项目中的简化片段，来结束枚举类型的语法学习。
    </p>
    <p>
     例如我们有一个 WEB 服务，需要接受用户的长连接，假设连接有两种：
     <code>
      TcpStream
     </code>
     和
     <code>
      TlsStream
     </code>
     ，但是我们希望对这两个连接的处理流程相同，也就是用同一个函数来处理这两个连接，代码如下：
    </p>
    <pre><code class="language-rust">fn new (stream: TcpStream) {
  let mut s = stream;
  if tls {
    s = negotiate_tls(stream)
  }
​
  // websocket是一个WebSocket&lt;TcpStream&gt;或者
  //   WebSocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;类型
  websocket = WebSocket::from_raw_socket(
    s, ......)
}</code></pre>
    <p>
     此时，枚举类型就能帮上大忙：
    </p>
    <pre><code class="language-rust">enum Websocket {
  Tcp(Websocket&lt;TcpStream&gt;),
  Tls(Websocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;),
}</code></pre>
    <h3>
     Option 枚举用于处理空值
    </h3>
    <p>
     在其它编程语言中，往往都有一个
     <code>
      null
     </code>
     关键字，该关键字用于表明一个变量当前的值为空（不是零值，例如整型的零值是 0），也就是不存在值。当你对这些
     <code>
      null
     </code>
     进行操作时，例如调用一个方法，就会直接抛出
     <strong>
      null 异常
     </strong>
     ，导致程序的崩溃，因此我们在编程时需要格外的小心去处理这些
     <code>
      null
     </code>
     空值。
    </p>
    <p>
     尽管如此，空值的表达依然非常有意义，因为空值表示当前时刻变量的值是缺失的。有鉴于此，Rust 吸取了众多教训，决定抛弃
     <code>
      null
     </code>
     ，而改为使用
     <code>
      Option
     </code>
     枚举变量来表述这种结果。
    </p>
    <p>
     <code>
      Option
     </code>
     枚举包含两个成员，一个成员表示含有值：
     <code>
      Some(T)
     </code>
     , 另一个表示没有值：
     <code>
      None
     </code>
     ，定义如下：
    </p>
    <pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}</code></pre>
    <p>
     其中
     <code>
      T
     </code>
     是泛型参数，
     <code>
      Some(T)
     </code>
     表示该枚举成员的数据类型是
     <code>
      T
     </code>
     ，换句话说，
     <code>
      Some
     </code>
     可以包含任何类型的数据。
    </p>
    <p>
     <code>
      Option&lt;T&gt;
     </code>
     枚举是如此有用以至于它被包含在了
     <code>
      prelude
     </code>
     （prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入）之中，你不需要将其显式引入作用域。另外，它的成员
     <code>
      Some
     </code>
     和
     <code>
      None
     </code>
     也是如此，无需使用
     <code>
      Option::
     </code>
     前缀就可直接使用
     <code>
      Some
     </code>
     和
     <code>
      None
     </code>
     。总之，不能因为
     <code>
      Some(T)
     </code>
     和
     <code>
      None
     </code>
     中没有
     <code>
      Option::
     </code>
     的身影，就否认它们是
     <code>
      Option
     </code>
     下的卧龙凤雏。
    </p>
    <p>
     再来看以下代码：
    </p>
    <pre><code class="language-rust">let some_number = Some(5);
let some_string = Some("a string");
​
let absent_number: Option&lt;i32&gt; = None;</code></pre>
    <p>
     如果使用
     <code>
      None
     </code>
     而不是
     <code>
      Some
     </code>
     ，需要告诉 Rust
     <code>
      Option&lt;T&gt;
     </code>
     是什么类型的，因为编译器只通过
     <code>
      None
     </code>
     值无法推断出
     <code>
      Some
     </code>
     成员保存的值的类型。
    </p>
    <p>
     当有一个
     <code>
      Some
     </code>
     值时，我们就知道存在一个值，而这个值保存在
     <code>
      Some
     </code>
     中。当有个
     <code>
      None
     </code>
     值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，
     <code>
      Option&lt;T&gt;
     </code>
     为什么就比空值要好呢？
    </p>
    <p>
     简而言之，因为
     <code>
      Option&lt;T&gt;
     </code>
     和
     <code>
      T
     </code>
     （这里
     <code>
      T
     </code>
     可以是任何类型）是不同的类型，例如，这段代码不能编译，因为它尝试将
     <code>
      Option&lt;i8&gt;
     </code>
     (
     <code>
      Option&lt;T&gt;
     </code>
     ) 与
     <code>
      i8
     </code>
     (
     <code>
      T
     </code>
     ) 相加：
    </p>
    <pre><code class="language-rust">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);
​
let sum = x + y;</code></pre>
    <p>
     如果运行这些代码，将得到类似这样的错误信息：
    </p>
    <pre><code class="language-bash">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |</code></pre>
    <p>
     很好！事实上，错误信息意味着 Rust 不知道该如何将
     <code>
      Option&lt;i8&gt;
     </code>
     与
     <code>
      i8
     </code>
     相加，因为它们的类型不同。当在 Rust 中拥有一个像
     <code>
      i8
     </code>
     这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用
     <code>
      Option&lt;i8&gt;
     </code>
     （或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。
    </p>
    <p>
     换句话说，在对
     <code>
      Option&lt;T&gt;
     </code>
     进行
     <code>
      T
     </code>
     的运算之前必须将其转换为
     <code>
      T
     </code>
     。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。
    </p>
    <p>
     不再担心会错误的使用一个空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的
     <code>
      Option&lt;T&gt;
     </code>
     中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是
     <code>
      Option&lt;T&gt;
     </code>
     类型，你就
     <strong>
      可以
     </strong>
     安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。
    </p>
    <p>
     那么当有一个
     <code>
      Option&lt;T&gt;
     </code>
     的值时，如何从
     <code>
      Some
     </code>
     成员中取出
     <code>
      T
     </code>
     的值来使用它呢？
     <code>
      Option&lt;T&gt;
     </code>
     枚举拥有大量用于各种情况的方法：你可以查看
     <a href="https://doc.rust-lang.org/std/option/enum.Option.html" rel="nofollow" title="它的文档">
      它的文档
     </a>
     。熟悉
     <code>
      Option&lt;T&gt;
     </code>
     的方法将对你的 Rust 之旅非常有用。
    </p>
    <p>
     总的来说，为了使用
     <code>
      Option&lt;T&gt;
     </code>
     值，需要编写处理每个成员的代码。你想要一些代码只当拥有
     <code>
      Some(T)
     </code>
     值时运行，允许这些代码使用其中的
     <code>
      T
     </code>
     。也希望一些代码在值为
     <code>
      None
     </code>
     时运行，这些代码并没有一个可用的
     <code>
      T
     </code>
     值。
     <code>
      match
     </code>
     表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。
    </p>
    <p>
     这里先简单看一下
     <code>
      match
     </code>
     的大致模样，在模式匹配中会详细讲解：
    </p>
    <pre><code class="language-rust">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}
​
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);</code></pre>
    <p>
     <code>
      plus_one
     </code>
     通过
     <code>
      match
     </code>
     来处理不同
     <code>
      Option
     </code>
     的情况。
    </p>
    <h3>
     ​
    </h3>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35383638343231312f:61727469636c652f64657461696c732f313436313533393736" class_="artid" style="display:none">
 </p>
</div>


