---
layout: post
title: "matlab和FPGA联合仿真时读写.txt文件数据的方法"
date: 2025-03-08 10:04:08 +08:00
description: "在FPGA开发过程中，往往需要将MATLAB生成的数据作为原始激励灌入FPGA进行仿真。为了验证FPGA计算是否正确，又需要将FPGA计算结果导入MATLAB绘图与MATLAB计算结果对比。下面是MATLAB“写.txt”、“读.txt”，Verilog“读.txt”、“写.txt”的代码。.txt中的数据是二进制的。"
keywords: "matlab和FPGA联合仿真时读写.txt文件数据的方法"
categories: ['未分类']
tags: ['开发语言', 'Matlab', 'Fpga']
artid: "146111388"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146111388
    alt: "matlab和FPGA联合仿真时读写.txt文件数据的方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146111388
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146111388
cover: https://bing.ee123.net/img/rand?artid=146111388
image: https://bing.ee123.net/img/rand?artid=146111388
img: https://bing.ee123.net/img/rand?artid=146111388
---

# matlab和FPGA联合仿真时读写.txt文件数据的方法
在FPGA开发过程中，往往需要将MATLAB生成的数据作为原始激励灌入FPGA进行仿真。为了验证FPGA计算是否正确，又需要将FPGA计算结果导入MATLAB绘图与MATLAB计算结果对比。
下面是MATLAB“写.txt”、“读.txt”，Verilog“读.txt”、“写.txt”的代码。.txt中的数据是二进制的。
#### 1.MATLAB导出数据生成.txt文件：
function Write\_data(filename,n,data)%filename:存储地址。n:二进制位宽。data:数据
data=round(data);
for i=1:length(data)
if(data(i)<0)
data(i)=data(i)+2^n;
end
end
bin\_data=dec2bin(data,n);
fid=fopen(filename,'wt');
for j=1:size(bin\_data,1)%size(array,1)表示矩阵array的行数。size(array,2)表示列数
fprintf(fid,'%s\n',bin\_data(j,:));%array(i,:)表示提取矩阵array的第i行的所有元素
end
fclose(fid);
end
#### 2.MATLAB读取.txt文件导入数据：
function [data\_bin2dec]=Read\_Data(filename,T)%T表示.txt中的二进制位宽
data\_bin\_txt=textread(filename,'%s');
MAX\_DATA=2^(T-1);%判断正负的阈值
data\_bin2dec=zeros(length(data\_bin\_txt),1);%一个列向量
for i=1:length(data\_bin\_txt)
if(convert\_bin2dec(data\_bin\_txt(i),0)>MAX\_DATA)
data\_bin2dec(i)=convert\_bin2dec(data\_bin\_txt(i),1)-2^T;
else
data\_bin2dec(i)=convert\_bin2dec(data\_bin\_txt(i),0);
end
end
end
%%
function [x]=convert\_bin2dec(bintring,sign)
if sign==0
x=bin2dec(bintring);
else
x=num2cell(bin2dec(bintring));
bin\_size=size(bintring,2);
y=x;
y=cellfun(@(y,bin\_size)cal\_sign\_y(y,bin\_size),y,num2cell(ones(size(y,1),1)*bin\_size));
x=y;
end
end
%%
function y\_i=cal\_sign\_y(y\_i,bin\_size)
if y\_i>=2^(bin\_size-1)
y\_i=y\_i-2^bin\_size;
end
end
#### 3.FPGA读取.txt文件导入数据：
reg [WIDTH-1:0] mem\_a[DEPTH:0];
initial $readmemb("C:/xxx/xxx/xxx.txt",mem\_a);//将.txt文件读到数组mem\_a中
task data\_stream();//生成数据流，用于RTL仿真
integer i;
for(i=0;i<DEPTH;i=i+1)begin
din\_valid=1;
din=mem\_a[i];
#20;
din\_valid=0;
din=din;
#80;
end
endtask
Verilog在读.txt文件时，只能识别16进制、二进制。不要求每个数据单独占一行，但要有空格。
#### 4.FPGA导出数据保存到.txt文件中：
integer bt;
initial begin
bt=$fopen("C:/xxx/xxx/fpga\_out.txt"","wb");
end
always@(posedge clk)begin
if(dout\_valid)
$fdisplay(bt,"%b",data\_out);
end
$fdisplay(bt,存储形式,想要存的数据)；
生成的fpga\_out.txt会自动换行；
![](https://i-blog.csdnimg.cn/direct/ad7b7607eae0404d82cec3508bbedac9.png)
#### 另外.FPGA读.txt，并串行输出模仿串行通信总线时：
![](https://i-blog.csdnimg.cn/direct/fb934ceea7c048fd9f14a1cfc52c422f.png)
![](https://i-blog.csdnimg.cn/direct/87696506b2da4b8c8b33119c540a7159.png)