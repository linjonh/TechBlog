---
layout: post
title: "Docker基础知识介绍"
date: 2025-03-16 16:34:03 +0800
description: "基础镜像 centos，Docker 绝大部分的基础镜像都是 scratch ，相当于Java 的 Object#把宿主机当前上下文的hello.txt拷贝到容器/usr/local/路径下#把java与tomcat添加到容器中#安装vim编辑器#设置工作访问时候的WORKDIR路径，登录落脚点#配置java与tomcat环境变量#容器运行时监听的端口#启动时运行tomcat。"
keywords: "Docker基础知识介绍"
categories: ['Docker']
tags: ['运维', '容器', 'Docker']
artid: "146296861"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296861
    alt: "Docker基础知识介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296861
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296861
cover: https://bing.ee123.net/img/rand?artid=146296861
image: https://bing.ee123.net/img/rand?artid=146296861
img: https://bing.ee123.net/img/rand?artid=146296861
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Docker基础知识介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Docker_0">
     </a>
     Docker基础篇
    </h2>
    <p>
     必须要在Linux环境下才能运行，windows下运行也是安装虚拟机后才能下载安装运行
    </p>
    <h3>
     <a id="_3">
     </a>
     下载安装
    </h3>
    <blockquote>
     <p>
      linux 依次执行下边步骤
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       更新 yum
       <code>
        yum update
       </code>
      </p>
     </li>
     <li>
      <p>
       卸载旧的Docker
      </p>
      <pre><code class="prism language-sh">yum remove <span class="token function">docker</span> <span class="token punctuation">\</span>
          docker-client <span class="token punctuation">\</span>
          docker-client-latest <span class="token punctuation">\</span>
          docker-common <span class="token punctuation">\</span>
          docker-latest <span class="token punctuation">\</span>
          docker-latest-logrotate <span class="token punctuation">\</span>
          docker-logrotate <span class="token punctuation">\</span>
          docker-engine
</code></pre>
     </li>
     <li>
      <p>
       安装必要的工具
       <code>
        yum install -y yum-utils device-mapper-persistent-data lvm2
       </code>
      </p>
     </li>
     <li>
      <p>
       配置镜像地址
       <code>
        yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
       </code>
      </p>
     </li>
     <li>
      <p>
       安装
       <code>
        yum install docker-ce
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        docker -v
       </code>
       查看版本
      </p>
     </li>
     <li>
      <p>
       <code>
        docker info
       </code>
       查看信息
      </p>
     </li>
     <li>
      <p>
       打开阿里云，登录，控制台，镜像服务，有安装 相关步骤。
      </p>
     </li>
     <li>
      <p>
       镜像仓库配置，官方是https://hub.docker.com/ 我们可以配置阿里云的镜像加速器
      </p>
     </li>
     <li>
      <p>
       <code>
        sudo systemctl daemon-reload
       </code>
       重新加载镜像配置
      </p>
     </li>
     <li>
      <p>
       <code>
        sudo systemctl restart docker
       </code>
       启动 docker 适用于centos环境
      </p>
     </li>
     <li>
      <p>
       <code>
        docker version
       </code>
       查看版本
      </p>
     </li>
     <li>
      <p>
       <code>
        docker info
       </code>
       查看详细信息
      </p>
     </li>
     <li>
      <p>
       <code>
        docker --help
       </code>
       帮助命令
      </p>
     </li>
    </ul>
    <h3>
     <a id="Docker__45">
     </a>
     Docker 架构图
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/18daacabd9a7418e8ed295401eb481e3.png"/>
    </p>
    <h3>
     <a id="_49">
     </a>
     镜像
    </h3>
    <blockquote>
     <p>
      镜像下载版本可以在https://hub.docker.com中搜索
     </p>
    </blockquote>
    <ul>
     <li>
      <code>
       docker images
      </code>
      查看已有镜像
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8ab44b32545a41b092c95f815bec424c.png"/>
    </p>
    <ul>
     <li>
      <p>
       <code>
        docker search [redis]
       </code>
       在仓库中搜索镜像
      </p>
     </li>
     <li>
      <p>
       <code>
        docker pull redis:5.0
       </code>
       下载镜像 [镜像名：版本号]
      </p>
     </li>
     <li>
      <p>
       <code>
        docker rmi [image id]
       </code>
       删除镜像
      </p>
     </li>
     <li>
      <p>
       <code>
        docker rmi [镜像名：版本号]
       </code>
       删除镜像
      </p>
     </li>
     <li>
      <p>
       <code>
        docker images -q
       </code>
       查看所有镜像的ID
      </p>
     </li>
     <li>
      <p>
       docker rmi
       <code>
        docker images -q
       </code>
       把所有有镜像的ID 当作参数传入rmi命令，删除所有镜像
      </p>
     </li>
    </ul>
    <h3>
     <a id="_69">
     </a>
     容器
    </h3>
    <blockquote>
     <p>
      可以通过镜像创建容器
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       <code>
        docker run -it --name [容器名] -v [容器内部路径]:[宿主机路径] [镜像名] /bin/bash
       </code>
      </p>
      <pre><code class="prism language-shell">  <span class="token comment"># 使用centos创建一个名字为MyCentOS的容器，并且直接进入到命令行。</span>
  <span class="token comment"># -i: 交互式操作。</span>
  <span class="token comment"># -t: 终端。/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</span>
  <span class="token comment"># 通过-i -t 创建的容器，创建完成皇后会直接进入到容器，退出后容器直接关闭</span>
<span class="token function">docker</span> run <span class="token parameter variable">-i</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">--name</span> MyCentOS centos:7 /bin/bash

</code></pre>
     </li>
     <li>
      <p>
       exit 退出容器，并且停止
      </p>
     </li>
     <li>
      <p>
       <code>
        Ctrl+P+Q
       </code>
       退出容器，但是不停止容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker ps
       </code>
       查看当前正在运行的容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker ps -a
       </code>
       查看所有容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker run -i -d --name CentOS centos:7
       </code>
       创建容器，并在后台运行
      </p>
     </li>
     <li>
      <p>
       <code>
        docker exec -i -t CentOS /bin/bash
       </code>
       进入容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker stop [容器名]
       </code>
       停止容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker kill [容器名]
       </code>
       强制停止容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker start [容器名]
       </code>
       启动容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker restart [容器名]
       </code>
       重启容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker rm [容器名或容器ID]
       </code>
       删除容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker inspect [容器名]
       </code>
       查看容器信息
      </p>
     </li>
     <li>
      <p>
       <code>
        docker top [容器名]
       </code>
       查看容器内部的进程
      </p>
     </li>
     <li>
      <p>
       <code>
        systemctl enable docker
       </code>
       配置开机自启动
      </p>
     </li>
    </ul>
    <h3>
     <a id="_112">
     </a>
     数据卷
    </h3>
    <blockquote>
     <p>
      相当于是一个文件系统（磁盘），可以挂载到容器中，宿主机中，用于文件的交换
     </p>
    </blockquote>
    <ul>
     <li>
      创建容器并挂载数据卷
      <code>
       docker run -it --name MyCentOS -v /root/data:/root/data_container centos:7 /bin/bash
      </code>
      <ul>
       <li>
        /root/data 宿主机的目录，没有则会创建
       </li>
       <li>
        /root/data_container 代表容器的目录，没有会自动创建
       </li>
      </ul>
     </li>
     <li>
      创建只读容器加参数 ro (ReadOnly简写)
      <code>
       docker run -it --name MyCentOS -v /root/data:/root/data_container:ro centos:7 /bin/bash
      </code>
     </li>
    </ul>
    <h3>
     <a id="_121">
     </a>
     数据卷容器
    </h3>
    <blockquote>
     <p>
      一个容器挂载数据卷，其它容器通过挂载这个容器实现数据共享，这个容器就是数据卷容器
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       操作命令
      </p>
      <pre><code class="prism language-shell"><span class="token comment"># docker run -it --name [容器名] -v [容器内部路径]:[宿主机路径] [镜像名] /bin/bash</span>
<span class="token comment"># docker run -it --name [容器名] --volumes-from [容器卷名字] [镜像名] /bin/bash</span>

<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> DataCentOS <span class="token parameter variable">-v</span> /data:/data centos /bin/bash
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> CentOS01 --volumes-from DataCentOS centos /bin/bash
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> CentOS02 --volumes-from DataCentOS centos /bin/bash
</code></pre>
     </li>
    </ul>
    <h3>
     <a id="DockerFile_136">
     </a>
     DockerFile
    </h3>
    <blockquote>
     <p>
      DockerFile 是用来构建Docker镜像的构建文件，是一系列命令和参数构成的脚本文件
     </p>
    </blockquote>
    <h4>
     <a id="_140">
     </a>
     指令规则
    </h4>
    <ul>
     <li>
      每条保留字指令都必须为大写字母，且后面要跟随至少一个参数
     </li>
     <li>
      指令按照从上到下顺序执行
     </li>
     <li>
      <code>
       #
      </code>
      表示注释
     </li>
     <li>
      每条指令都会创建一个新的镜像层，并对镜像提交
     </li>
    </ul>
    <h4>
     <a id="_147">
     </a>
     执行流程
    </h4>
    <ol>
     <li>
      docker从基础镜像运行一个容器
     </li>
     <li>
      执行一条指令并对容器作出修改
     </li>
     <li>
      执行类似docker commit的操作提交一个新的镜像层
     </li>
     <li>
      docker再基于刚提交的镜像运行一个新的容器
     </li>
     <li>
      执行dockerfile中的下一条指令直到所有指令都执行完成
     </li>
    </ol>
    <h4>
     <a id="_155">
     </a>
     常见关键字
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th align="left">
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        FROM
       </td>
       <td align="left">
        基础镜像，当前新镜像是基于哪个镜像的,有继承的意味
       </td>
      </tr>
      <tr>
       <td>
        MAINTAINER
       </td>
       <td align="left">
        镜像维护者的姓名和邮箱地址
       </td>
      </tr>
      <tr>
       <td>
        RUN
       </td>
       <td align="left">
        容器构建时需要运行的命令
       </td>
      </tr>
      <tr>
       <td>
        EXPOSE
       </td>
       <td align="left">
        当前容器对外暴露的端口
       </td>
      </tr>
      <tr>
       <td>
        WORKDIR
       </td>
       <td align="left">
        指定在创建容器后，终端默认登录的进来工作目录，一个落脚点
       </td>
      </tr>
      <tr>
       <td>
        ENV
       </td>
       <td align="left">
        用来在构建镜像过程中设置环境变量
       </td>
      </tr>
      <tr>
       <td>
        ADD
       </td>
       <td align="left">
        将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包
       </td>
      </tr>
      <tr>
       <td>
        COPY
       </td>
       <td align="left">
        类似ADD，拷贝文件和目录到镜像中。
        <br/>
        将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置
        <br/>
        COPY src dest
        <br/>
        COPY [“src”,“dest”]
       </td>
      </tr>
      <tr>
       <td>
        VOLUME
       </td>
       <td align="left">
        容器数据卷，用于数据保存和持久化工作
       </td>
      </tr>
      <tr>
       <td>
        CMD
       </td>
       <td align="left">
        指定一个容器启动时要运行的命令
        <br/>
        Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换
       </td>
      </tr>
      <tr>
       <td>
        ENTRYPOINT
       </td>
       <td align="left">
        指定一个容器启动时要运行的命令
        <br/>
        ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数
       </td>
      </tr>
      <tr>
       <td>
        ONBUILD
       </td>
       <td align="left">
        当构建一个被继承的Dockerfile时运行命令,父镜像在被子继承后父镜像的onbuild被触发
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="DockerFile_174">
     </a>
     自定义DockerFile
    </h4>
    <pre><code class="prism language-shell"><span class="token comment"># 基础镜像 centos，Docker 绝大部分的基础镜像都是 scratch ，相当于Java 的 Object</span>
FROM         centos
MAINTAINER    bobo<span class="token operator">&lt;</span>dengpbs@163.com<span class="token operator">&gt;</span>
<span class="token comment">#把宿主机当前上下文的hello.txt拷贝到容器/usr/local/路径下</span>
COPY readme.txt /usr/local/helloincontainer.txt
<span class="token comment">#把java与tomcat添加到容器中</span>
ADD jdk-8u73-linux-x64.tar.gz /usr/local/
ADD apache-tomcat-8.5.71.tar.gz /usr/local/
<span class="token comment">#安装vim编辑器</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span>
<span class="token comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span>
ENV MYPATH /usr/local
WORKDIR <span class="token variable">$MYPATH</span>
<span class="token comment">#配置java与tomcat环境变量</span>
ENV JAVA_HOME /usr/local/jdk1.8.0_73
ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.71
ENV CATALINA_BASE /usr/local/apache-tomcat-8.5.71
ENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/bin
<span class="token comment">#容器运行时监听的端口</span>
EXPOSE  <span class="token number">8080</span>
<span class="token comment">#启动时运行tomcat</span>
<span class="token comment"># ENTRYPOINT ["/usr/local/apache-tomcat-8.0.47/bin/startup.sh" ]</span>
<span class="token comment"># CMD ["/usr/local/apache-tomcat-8.0.47/bin/catalina.sh","run"]</span>
CMD /usr/local/apache-tomcat-8.5.71/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> <span class="token parameter variable">-F</span> /usr/local/apache-tomcat-8.0.47/bin/logs/catalina.out
</code></pre>
    <h4>
     <a id="_204">
     </a>
     通过脚本生成镜像文件
    </h4>
    <pre><code class="prism language-shell"><span class="token comment"># 注意，命令最后有一个 点 字符</span>
<span class="token function">docker</span> build <span class="token parameter variable">-f</span> dockerfile名称 <span class="token parameter variable">-t</span> 镜像名:TAG <span class="token builtin class-name">.</span>
</code></pre>
    <h4>
     <a id="_211">
     </a>
     镜像历史
    </h4>
    <pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">history</span> 镜像名
</code></pre>
    <p>
     卸载Docker
    </p>
    <pre><code>yum remove docker \
          docker-client \
          docker-client-latest \
          docker-common \
          docker-latest \
          docker-latest-logrotate \
          docker-logrotate \
          docker-engine
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33393730313230352f:61727469636c652f64657461696c732f313436323936383631" class_="artid" style="display:none">
 </p>
</div>


