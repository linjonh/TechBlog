---
layout: post
title: "Redis-源码分析-内部数据结构-ziplist"
date: 2025-03-13 15:41:21 +0800
description: "如果提到双向链表，我们应该很熟悉，那么 redis 如何实现双向链表呢，和普通的双向链表有什么区别呢，为什么说 redis 的 ziplist 充分体现了 redis 对内存的高效利用？"
keywords: "Redis 源码分析-内部数据结构 ziplist"
categories: ['Redis']
tags: ['链表', '数据结构', '数据库', 'Ziplist', 'Redis']
artid: "146232853"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146232853
    alt: "Redis-源码分析-内部数据结构-ziplist"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146232853
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146232853
cover: https://bing.ee123.net/img/rand?artid=146232853
image: https://bing.ee123.net/img/rand?artid=146232853
img: https://bing.ee123.net/img/rand?artid=146232853
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis 源码分析-内部数据结构 ziplist
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Redis__ziplist_0">
     </a>
     Redis 源码分析-内部数据结构 ziplist
    </h2>
    <p>
     如果提到双向链表，我们应该很熟悉，每一个对象都有三个字段
    </p>
    <ul>
     <li>
      指向前驱节点的指针
     </li>
     <li>
      指向后向节点的指针
     </li>
     <li>
      该节点的数据
     </li>
    </ul>
    <p>
     双向链表可以在两端执行 O(1) 级别的操作，缺点是可能产生内存碎片，对空间利用率低(每个节点除了存储数据还要存指向相邻节点的指针)
    </p>
    <p>
     而 ziplist 就是一个特殊编码的双向链表，为什么说特殊呢？
    </p>
    <ul>
     <li>
      ziplist 每个节点没有使用前后指针
     </li>
     <li>
      ziplist 整体分配一大块内存
     </li>
     <li>
      ziplist 中的每个元素会根据实际情况分配不同大小的空间，充分体现了Redis对于存储效率的追求
     </li>
    </ul>
    <h3>
     <a id="ziplist_18">
     </a>
     ziplist
    </h3>
    <p>
     以下是官方的注释信息：
    </p>
    <pre><code class="prism language-c"> <span class="token operator">*</span> ZIPLIST OVERALL LAYOUT
 <span class="token operator">*</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> The general layout of the ziplist is as follows<span class="token operator">:</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">&lt;</span>zlbytes<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>zltail<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>zllen<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>entry<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>entry<span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;</span>entry<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>zlend<span class="token operator">&gt;</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> NOTE<span class="token operator">:</span> all fields are stored in little endian<span class="token punctuation">,</span> <span class="token keyword">if</span> not specified otherwise<span class="token punctuation">.</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">&lt;</span><span class="token class-name">uint32_t</span> zlbytes<span class="token operator">&gt;</span> is an <span class="token keyword">unsigned</span> integer to hold the number of bytes that
 <span class="token operator">*</span> the ziplist occupies<span class="token punctuation">,</span> including the four bytes of the zlbytes field itself<span class="token punctuation">.</span>
 <span class="token operator">*</span> This value needs to be stored to be able to resize the entire structure
 <span class="token operator">*</span> without the need to traverse it first<span class="token punctuation">.</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">&lt;</span><span class="token class-name">uint32_t</span> zltail<span class="token operator">&gt;</span> is the offset to the last entry in the list<span class="token punctuation">.</span> This allows
 <span class="token operator">*</span> a pop operation on the far side of the list without the need <span class="token keyword">for</span> full
 <span class="token operator">*</span> traversal<span class="token punctuation">.</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">&lt;</span><span class="token class-name">uint16_t</span> zllen<span class="token operator">&gt;</span> is the number of entries<span class="token punctuation">.</span> When there are more than
 <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">16</span><span class="token operator">-</span><span class="token number">2</span> entries<span class="token punctuation">,</span> this value is set to <span class="token number">2</span><span class="token operator">^</span><span class="token number">16</span><span class="token operator">-</span><span class="token number">1</span> and we need to traverse the
 <span class="token operator">*</span> entire list to know how many items it holds<span class="token punctuation">.</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">&lt;</span><span class="token class-name">uint8_t</span> zlend<span class="token operator">&gt;</span> is a special entry representing the end of the ziplist<span class="token punctuation">.</span>
 <span class="token operator">*</span> Is encoded as a single byte equal to <span class="token number">255.</span> No other normal entry starts
 <span class="token operator">*</span> with a byte set to the value of <span class="token number">255.</span>
</code></pre>
    <p>
     大概意思是说，ziplist 通常长下面这个样子：
    </p>
    <p>
     <img alt="image-20250313110018679" src="https://i-blog.csdnimg.cn/img_convert/073af5eeabbac436e8878ef9f598072e.png"/>
    </p>
    <ul>
     <li>
      zlbytes：4 字节，ziplistBytes，标识该 ziplist 的长度
     </li>
     <li>
      zltail：4 字节，ziplistTail，标识尾节点偏移量
     </li>
     <li>
      zllen：2字节，ziplistLen，zipList 中的 entry 个数
     </li>
     <li>
      zlend：1字节，ziplistEnd，结束标识，
      <code>
       固定值 255
      </code>
     </li>
    </ul>
    <p>
     根据这个定义，我们可以很容易的找到这个 ziplist 的首项和尾项，起始指针偏移 10 字节就是头节点，偏移 zltail 值对应的字节就是尾节点，不过你可能有其他的问题：zllen 字段只有 2 字节，那 ziplist 是不是只能存 2
     <sup>
      16
     </sup>
     -1 个元素呢，这个问题的答案我们放在最后说，另外，请注意 zlend 的默认值 255，接下来会用到
    </p>
    <h3>
     <a id="ziplist_entry_63">
     </a>
     ziplist entry
    </h3>
    <p>
     我们思考一个这样的问题，链表能够进行双向便利是存储了指向相邻节点的指针，那 ziplist 没有这样的指针，该怎么进行遍历呢？
    </p>
    <p>
     <code>
      ziplist中每个元素使用一个字段标识了前一个元素的长度，一个字段标识了本元素的长度
     </code>
     ，这样只要找到其中的任意一个元素，都可以进行双向遍历了。
    </p>
    <p>
     ziplist 中的元素我们叫 entry，其结构如下：
    </p>
    <pre><code class="prism language-c"> <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">&lt;</span>prevlen from <span class="token number">0</span> to <span class="token number">253</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>encoding<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>entry<span class="token operator">&gt;</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">00</span>pppppp<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">1</span> byte
 <span class="token operator">*</span>      String value with length less than or equal to <span class="token number">63</span> <span class="token function">bytes</span> <span class="token punctuation">(</span><span class="token number">6</span> bits<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span>      <span class="token string">"pppppp"</span> represents the <span class="token keyword">unsigned</span> <span class="token number">6</span> bit length<span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">01</span>pppppp<span class="token operator">|</span>qqqqqqqq<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">2</span> bytes
 <span class="token operator">*</span>      String value with length less than or equal to <span class="token number">16383</span> <span class="token function">bytes</span> <span class="token punctuation">(</span><span class="token number">14</span> bits<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span>      IMPORTANT<span class="token operator">:</span> The <span class="token number">14</span> bit number is stored in big endian<span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">10000000</span><span class="token operator">|</span>qqqqqqqq<span class="token operator">|</span>rrrrrrrr<span class="token operator">|</span>ssssssss<span class="token operator">|</span>tttttttt<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">5</span> bytes
 <span class="token operator">*</span>      String value with length greater than or equal to <span class="token number">16384</span> bytes<span class="token punctuation">.</span>
 <span class="token operator">*</span>      Only the <span class="token number">4</span> bytes following the first byte represents the length
 <span class="token operator">*</span>      up to <span class="token number">32</span><span class="token operator">^</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1.</span> The <span class="token number">6</span> lower bits of the first byte are not used and
 <span class="token operator">*</span>      are set to zero<span class="token punctuation">.</span>
 <span class="token operator">*</span>      IMPORTANT<span class="token operator">:</span> The <span class="token number">32</span> bit number is stored in big endian<span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">11000000</span><span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">3</span> bytes
 <span class="token operator">*</span>      Integer encoded as <span class="token class-name">int16_t</span> <span class="token punctuation">(</span><span class="token number">2</span> bytes<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">11010000</span><span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">5</span> bytes
 <span class="token operator">*</span>      Integer encoded as <span class="token class-name">int32_t</span> <span class="token punctuation">(</span><span class="token number">4</span> bytes<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">11100000</span><span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">9</span> bytes
 <span class="token operator">*</span>      Integer encoded as <span class="token class-name">int64_t</span> <span class="token punctuation">(</span><span class="token number">8</span> bytes<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">11110000</span><span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">4</span> bytes
 <span class="token operator">*</span>      Integer encoded as <span class="token number">24</span> bit <span class="token keyword">signed</span> <span class="token punctuation">(</span><span class="token number">3</span> bytes<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">11111110</span><span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">2</span> bytes
 <span class="token operator">*</span>      Integer encoded as <span class="token number">8</span> bit <span class="token keyword">signed</span> <span class="token punctuation">(</span><span class="token number">1</span> byte<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">1111</span>xxxx<span class="token operator">|</span> <span class="token operator">-</span> <span class="token punctuation">(</span>with xxxx between <span class="token number">0000</span> and <span class="token number">1101</span><span class="token punctuation">)</span> immediate <span class="token number">4</span> bit integer<span class="token punctuation">.</span>
 <span class="token operator">*</span>      Unsigned integer from <span class="token number">0</span> to <span class="token number">12.</span> The encoded value is actually from
 <span class="token operator">*</span>      <span class="token number">1</span> to <span class="token number">13</span> because <span class="token number">0000</span> and <span class="token number">1111</span> can not be used<span class="token punctuation">,</span> so <span class="token number">1</span> should be
 <span class="token operator">*</span>      subtracted from the encoded <span class="token number">4</span> bit value to obtain the right value<span class="token punctuation">.</span>
 <span class="token operator">*</span> <span class="token operator">|</span><span class="token number">11111111</span><span class="token operator">|</span> <span class="token operator">-</span> End of ziplist special entry<span class="token punctuation">.</span>
</code></pre>
    <p>
     <img alt="image-20250313131315802" src="https://i-blog.csdnimg.cn/img_convert/a87e3937feefd00f3e638677f66e200a.png"/>
    </p>
    <ul>
     <li>
      prevlen 前一项的长度，是一个 0 ～ 253 的值
     </li>
     <li>
      encoding 当前项的编码
     </li>
     <li>
      data 存放真正的数据
     </li>
    </ul>
    <p>
     我在最开始提到：ziplist 中的每个元素会根据实际情况分配不同大小的空间，充分体现了Redis对于存储效率的追求。这是什么意思呢？以下就是 ziplist 最繁琐的部分了：
    </p>
    <p>
     针对 prevlen 字段，如果说前一个 entry 非常小，不足 254 字节，那么 1 个字节就可以存下，prevlen 字段就用一个字节来存储；否则，prevlen 占用 5 字节，第 1 字节定义为特殊值 254，标识该字段占用 5 个字节，真正的长度在后面 4 字节。为什么不用 255 呢，原因是 255 就是我们上面提到的 zlend 标识，同时 254 也被赋予了特殊意义。
    </p>
    <p>
     针对 encoding 字段，更复杂，共有以下 9 种情况：
    </p>
    <ol>
     <li>
      |00pppppp| - 1 byte。第1个字节最高两个 bit 是00，那么
      <code>
       &lt;encoding&gt;
      </code>
      字段只有1个字节，剩余的 6 个 bit 用来表示长度值，最高可以表示 63 (2
      <sup>
       6
      </sup>
      -1)。
     </li>
     <li>
      |01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么
      <code>
       &lt;encoding&gt;
      </code>
      字段占2个字节，总共有14个 bit 用来表示长度值，最高可以表示 16383 (2
      <sup>
       14
      </sup>
      -1)。
     </li>
     <li>
      |10**__**|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个 bit 是 10，那么
      <code>
       encoding
      </code>
      字段占 5 个字节，总共使用 32 个 bit 来表示长度值（6个 bit 舍弃不用），最高可以表示 2
      <sup>
       32
      </sup>
      -1。需要注意的是：在前三种情况下，
      <code>
       &lt;data&gt;
      </code>
      都是按字符串来存储的；从下面第4种情况开始，
      <code>
       &lt;data&gt;
      </code>
      开始变为按整数来存储了。
     </li>
     <li>
      |11000000| - 1 byte。
      <code>
       &lt;encoding&gt;
      </code>
      字段占用1个字节，值为0xC0，后面的数据
      <code>
       &lt;data&gt;
      </code>
      存储为 2 个字节的int16_t类型。
     </li>
     <li>
      |11010000| - 1 byte。
      <code>
       &lt;encoding&gt;
      </code>
      字段占用1个字节，值为0xD0，后面的数据
      <code>
       &lt;data&gt;
      </code>
      存储为 4 个字节的int32_t类型。
     </li>
     <li>
      |11100000| - 1 byte。
      <code>
       &lt;encoding&gt;
      </code>
      字段占用1个字节，值为0xE0，后面的数据
      <code>
       &lt;data&gt;
      </code>
      存储为 8 个字节的int64_t类型。
     </li>
     <li>
      |11110000| - 1 byte。
      <code>
       &lt;encoding&gt;
      </code>
      字段占用1个字节，值为0xF0，后面的数据
      <code>
       &lt;data&gt;
      </code>
      存储为 3 个字节长的整数。
     </li>
     <li>
      |11111110| - 1 byte。
      <code>
       &lt;encoding&gt;
      </code>
      字段占用1个字节，值为0xFE，后面的数据
      <code>
       &lt;data&gt;
      </code>
      存储为 1 个字节的整数。
     </li>
     <li>
      |1111xxxx| - - (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从 1 到 13 一共 13 个值，这时就用这 13 个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的
      <code>
       &lt;data&gt;
      </code>
      字段来表示真正的数据了，而是
      <code>
       &lt;encoding&gt;
      </code>
      和
      <code>
       &lt;data&gt;
      </code>
      合二为一了。另外，由于xxxx只能取 0001 和 1101 这 13 个值了
      <code>
       （其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突）
      </code>
      ，而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去 1 才是它所要表示的那个整数数据的值
     </li>
    </ol>
    <h3>
     <a id="_126">
     </a>
     关键代码分析
    </h3>
    <ol>
     <li>
      创建函数
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 分配头空间和尾空间 11 字节</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bytes <span class="token operator">=</span> ZIPLIST_HEADER_SIZE <span class="token operator">+</span> ZIPLIST_END_SIZE<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">ZIPLIST_BYTES</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>ZIPLIST_HEADER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ZIPLIST_LENGTH</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 将列表尾设置为特定标识 255</span>
    zl<span class="token punctuation">[</span>bytes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ZIP_END<span class="token punctuation">;</span>
    <span class="token keyword">return</span> zl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="2">
     <li>
      插入函数
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> slen<span class="token punctuation">,</span> <span class="token keyword">int</span> where<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">// 注意,这里 p 对应的不是头节点就是尾节点</span>
    p <span class="token operator">=</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> ZIPLIST_HEAD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">ZIPLIST_ENTRY_HEAD</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ZIPLIST_ENTRY_END</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">__ziplistInsert</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span> p<span class="token punctuation">,</span> s<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token comment">/**
 * 对 zipilst 执行插入操作，在指定的位置 p 插入一段新的数据
 * @param zl
 * @param p     ziplist 中某一个数据项的起始位置，或者在向尾端插入的时候，它指向 ziplist 的结束标记 &lt;zlend&gt;
 * @param s     待插入数据的地址指针
 * @param slen  待插入数据长度
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">__ziplistInsert</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> slen<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">size_t</span> curlen <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">ZIPLIST_BYTES</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> reqlen<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevlensize<span class="token punctuation">,</span> prevlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> offset<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nextdiff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">123456789</span><span class="token punctuation">;</span> <span class="token comment">/* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */</span>
    zlentry tail<span class="token punctuation">;</span>

    <span class="token comment">// 查找前一个条目的长度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果 p 不是 ziplist 的结束标志，从 p 中解码出前一个条目的长度</span>
        <span class="token function">ZIP_DECODE_PREVLEN</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> prevlensize<span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果 p 是结束标志，获取 ziplist 的尾部条目并提取该尾部条目的长度</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptail <span class="token operator">=</span> <span class="token function">ZIPLIST_ENTRY_TAIL</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            prevlen <span class="token operator">=</span> <span class="token function">zipRawEntryLength</span><span class="token punctuation">(</span>ptail<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 尝试将待插入的条目 s 编码为整数。如果成功，则返回所需的编码大小；否则，使用字符串长度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zipTryEncoding</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> slen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 根据 encoding 编码类型,返回该编码类型对应的数据部分需要的字节数</span>
        reqlen <span class="token operator">=</span> <span class="token function">zipIntSize</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        reqlen <span class="token operator">=</span> slen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 还需要记录 （记录上一个条目的长度需要的字节数 1 or 5）</span>
    reqlen <span class="token operator">+=</span> <span class="token function">zipStorePrevEntryLength</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前条目的实际长度</span>
    reqlen <span class="token operator">+=</span> <span class="token function">zipStoreEntryEncoding</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断下一个条目是否能够容纳当前条目的长度。如果不能，需要调整下一个条目的长度字节数所需的空间。</span>
    <span class="token keyword">int</span> forcelarge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    nextdiff <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">zipPrevLenByteDiff</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> reqlen<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextdiff <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">4</span> <span class="token operator">&amp;&amp;</span> reqlen <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        nextdiff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        forcelarge <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 计算插入位置的偏移量，并调整 ziplist 的大小，以容纳新的条目</span>
    offset <span class="token operator">=</span> p <span class="token operator">-</span> zl<span class="token punctuation">;</span>
    zl <span class="token operator">=</span> <span class="token function">ziplistResize</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span> curlen <span class="token operator">+</span> reqlen <span class="token operator">+</span> nextdiff<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p <span class="token operator">=</span> zl <span class="token operator">+</span> offset<span class="token punctuation">;</span>

    <span class="token comment">// 如果 p 不是 ziplist 结束，则移动内存以为新的条目腾出空间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/* Subtract one because of the ZIP_END bytes */</span>
        <span class="token function">memmove</span><span class="token punctuation">(</span>p <span class="token operator">+</span> reqlen<span class="token punctuation">,</span> p <span class="token operator">-</span> nextdiff<span class="token punctuation">,</span> curlen <span class="token operator">-</span> offset <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> nextdiff<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Encode this entry's raw length in the next entry. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>forcelarge<span class="token punctuation">)</span>
            <span class="token function">zipStorePrevEntryLengthLarge</span><span class="token punctuation">(</span>p <span class="token operator">+</span> reqlen<span class="token punctuation">,</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">zipStorePrevEntryLength</span><span class="token punctuation">(</span>p <span class="token operator">+</span> reqlen<span class="token punctuation">,</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Update offset for tail */</span>
        <span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span>
                <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* When the tail contains more than one entry, we need to take
         * "nextdiff" in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset. */</span>
        <span class="token function">zipEntry</span><span class="token punctuation">(</span>p <span class="token operator">+</span> reqlen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>reqlen <span class="token operator">+</span> tail<span class="token punctuation">.</span>headersize <span class="token operator">+</span> tail<span class="token punctuation">.</span>len<span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span>
                    <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> nextdiff<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 更新尾指针以反映新条目的插入</span>
        <span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>p <span class="token operator">-</span> zl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果 nextdiff 不为零，表示后续条目的长度发生了变化，因此需要级联更新</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextdiff <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        offset <span class="token operator">=</span> p <span class="token operator">-</span> zl<span class="token punctuation">;</span>
        zl <span class="token operator">=</span> <span class="token function">__ziplistCascadeUpdate</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span> p <span class="token operator">+</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> zl <span class="token operator">+</span> offset<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 写入新条目</span>
    p <span class="token operator">+=</span> <span class="token function">zipStorePrevEntryLength</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p <span class="token operator">+=</span> <span class="token function">zipStoreEntryEncoding</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ZIP_IS_STR</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> s<span class="token punctuation">,</span> slen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">zipSaveInteger</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> value<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 增加 ziplist 的长度计数并返回更新后的 ziplist</span>
    <span class="token function">ZIPLIST_INCR_LENGTH</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> zl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     主要逻辑分析如下：
    </p>
    <ul>
     <li>
      查找前一个元素的长度，计算
      <code>
       prevlen
      </code>
     </li>
     <li>
      计算当前数据项占用的总字节数
      <code>
       reqlen
      </code>
      ，它包含三部分：
      <code>
       &lt;prevlen&gt;
      </code>
      ,
      <code>
       &lt;encoding&gt;
      </code>
      和真正的数据。其中的数据部分会通过调用
      <code>
       zipTryEncoding
      </code>
      先来尝试转成整数，否则直接返回字符串长度
     </li>
     <li>
      判断下一个条目的
      <code>
       prevlen
      </code>
      是否能够容纳当前条目的长度。如果不能，需要调整下一个条目的长度字节数所需的空间，同时由于下一个条目的
      <code>
       prevlen
      </code>
      长度变化，可能导致后续元素的
      <code>
       prevlen
      </code>
      也需要进行级联更新
     </li>
     <li>
      计算出了最终需要的空间，调用
      <code>
       ziplistResize
      </code>
      去扩容，并把 p 后的元素继续移动，插入新元素，增加 ziplist 中的元素数量并返回更新后的 ziplist
     </li>
    </ul>
    <p>
     hash 随着数据的增大，其底层数据结构的实现是会发生变化的，当然存储效率也就不同。在 field 比较少，各个 value 值也比较小的时候，hash 采用 ziplist 来实现；而随着 field 增多和 value 值增大，hash 可能会变成dict 来实现，原因如下：
    </p>
    <ul>
     <li>
      ziplist 查询元素时只能进行遍历，效率较低，在整体数量不多时不明显，一旦数量过大，就会影响效率
     </li>
     <li>
      当元素越来越多或越来越大时，插入元素可能会引起较大的内存拷贝，如由于 prevlen 而引起的级联更新
     </li>
    </ul>
    <p>
     而这个大或者多的定义是什么呢？
    </p>
    <p>
     最大
     <code>
      键值对
     </code>
     数量(注意是键值对，如果是 ziplist 中的 zllen，其实是 1024)
    </p>
    <ul>
     <li>
      <pre><code class="prism language-c">hash_max_ziplist_entries 	<span class="token comment">// 512</span>
</code></pre>
     </li>
    </ul>
    <p>
     最大元素长度，插入的任意一个 value 的长度超过 64
    </p>
    <ul>
     <li>
      <pre><code class="prism language-c">hash_max_ziplist_value		<span class="token comment">// 64</span>
</code></pre>
     </li>
    </ul>
    <p>
     回答最开始的问题：zllen 只有 2 字节，所以最多存 2
     <sup>
      16
     </sup>
     - 1 个元素吗，答案是否定的，如果 zllen = 2
     <sup>
      16
     </sup>
     - 1，此时该字段就无效了，如果想知道具体数量，就需要遍历来查了。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35363531373235332f:61727469636c652f64657461696c732f313436323332383533" class_="artid" style="display:none">
 </p>
</div>


