---
layout: post
title: "xlua-运行原理"
date: 2025-03-13 17:55:53 +0800
description: "【代码】xlua 运行原理。"
keywords: "xlua 运行原理"
categories: ['Xlua']
tags: ['Unity', 'C']
artid: "146230130"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146230130
    alt: "xlua-运行原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146230130
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146230130
cover: https://bing.ee123.net/img/rand?artid=146230130
image: https://bing.ee123.net/img/rand?artid=146230130
img: https://bing.ee123.net/img/rand?artid=146230130
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     xlua 运行原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <ol>
      <li>
       iOS限制App的二进制代码要一次性的包含在App内，也就是AOT，不支持JIT
      </li>
      <li>
       Lua代码作为资源文件，玩家下载，不涉及字节码，所以可以做热更
      </li>
      <li>
       Lua代码通过Lua虚拟机解释执行（解释成机器码），并在虚拟机内部管理变量，使用的是LuaVM
      </li>
      <li>
       Lua虚拟机比如Lua5.3、Lua5.2 由c语言编写，在android下编译成.so文件、iOS下编译成.a文件，内置到包里面
       <ol>
        <li>
         在Android开发中，`.so`文件也是动态链接库文件，通常用于包含用C或C++编写的本地代码。这些文件是通过Android NDK（Native Development Kit）生成的，允许开发者在应用中使用高性能的本地代码。
        </li>
       </ol>
      </li>
      <li>
       XLua通过Wrap文件实现Lua调用C#，原理就是把C#函数压入堆栈，让Lua执行
      </li>
     </ol>
    </blockquote>
    <h4>
     <strong>
      Wrap 文件的执行原理
     </strong>
    </h4>
    <h5>
     <strong>
      注册阶段：Lua虚拟机启动时
     </strong>
     ‌
    </h5>
    <ul>
     <li>
      ‌
      <strong>
       触发时机
      </strong>
      ‌：在App启动过程中，‌
      <strong>
       首次初始化Lua虚拟机
      </strong>
      ‌（如调用
      <code>
       new LuaEnv()
      </code>
      ）时，执行
      <code>
       LuaBinder.Bind()
      </code>
      方法，加载所有Wrap文件的注册逻辑‌。
     </li>
     <li>
      ‌
      <strong>
       核心步骤
      </strong>
      ‌：
      <ol>
       <li>
        Wrap文件中的
        <code>
         Register()
        </code>
        方法被调用，通过
        <code>
         LuaState.BeginClass()
        </code>
        和
        <code>
         LuaState.RegFunction()
        </code>
        等接口，将C#类的方法、属性映射到Lua虚拟机的全局表中‌。
       </li>
       <li>
        C#方法被转换为Lua可识别的函数指针，并压入Lua虚拟栈，完成Lua层对C#方法的绑定‌。
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h5>
     ‌
     <strong>
      执行示例
     </strong>
     ‌
    </h5>
    <p>
     以UnityEngine_GameObjectWrap.cs为例：
    </p>
    <ul>
     <li>
      ‌
      <strong>
       注册逻辑
      </strong>
      ‌：在
      <code>
       Register()
      </code>
      方法中，调用
      <code>
       L.RegFunction("SetActive", SetActive)
      </code>
      ，将C#的
      <code>
       GameObject.SetActive()
      </code>
      方法映射为Lua中的
      <code>
       SetActive
      </code>
      函数‌。
     </li>
     <li>
      ‌
      <strong>
       结果
      </strong>
      ‌：Lua虚拟机启动后，Lua脚本可直接通过
      <code>
       CS.UnityEngine.GameObject.SetActive()
      </code>
      调用C#原生方法‌。
     </li>
    </ul>
    <p>
     参考：
     <a href="https://blog.csdn.net/qq_37672438/article/details/146231027?sharetype=blogdetail&amp;sharerId=146231027&amp;sharerefer=PC&amp;sharesource=qq_37672438&amp;sharefrom=mp_from_link" title="C C++ 为什么称为Native代码、虚拟机-CSDN博客">
      C C++ 为什么称为Native代码、虚拟机-CSDN博客
     </a>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373637323433382f:61727469636c652f64657461696c732f313436323330313330" class_="artid" style="display:none">
 </p>
</div>


