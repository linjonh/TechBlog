---
layout: post
title: "刷leetcode-hot100-动态规划3.10"
date: 2025-03-10 17:46:46 +0800
description: "INT_MAX) 防止INT_MAX+1溢出【其实也就是 j <= sqrt(i)】2.j<=sqrt(i)，\"<=\"，要不然1没法遍历到完全平方数1；前提简要：昨天尝试，没什么想法，本来觉得maybe先求一下sqrt(n)，确定一下阈值【其实也对】wordDict =[\"a\",\"abc\",\"b\",\"cd\"]在实操过程中，i/j/wordDict[j].size()我一直绕不清楚，太绕了……一般dp[n]遍历到n是更新的是dp[n],要不然逻辑太混乱。,要不然dp[1]没法是1，？【回溯：分隔回文串？"
keywords: "刷leetcode hot100--动态规划3.10"
categories: ['未分类']
tags: ['算法', '动态规划', 'Leetcode']
artid: "146144671"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146144671
    alt: "刷leetcode-hot100-动态规划3.10"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146144671
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146144671
cover: https://bing.ee123.net/img/rand?artid=146144671
image: https://bing.ee123.net/img/rand?artid=146144671
img: https://bing.ee123.net/img/rand?artid=146144671
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     刷leetcode hot100--动态规划3.10
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     继续昨天的完全平方数[13:20]【确实和零钱兑换一脉相承】
    </h3>
    <p>
     前提简要：昨天尝试，没什么想法，本来觉得maybe先求一下sqrt(n)，确定一下阈值【其实也对】
    </p>
    <p>
     然后不知道怎么求sqrt了？？--&gt;直接调用sqrt(n) 或者 用二分查找
    </p>
    <hr/>
    <p>
     进入正题：
    </p>
    <p>
     dp[n]表示和为n的完全平方数最小数量
    </p>
    <p>
     dp[n] = min{dp[n-i*i]+1,dp[n]}
    </p>
    <p>
     初始化 dp[n]--&gt;INT_MAX
    </p>
    <p>
     第一版代码问题【编译不过】：1.
     <span style="background-color:#ffd900">
      dp[0]=0
     </span>
     ,要不然dp[1]没法是1，
     <strong>
      所以还是要带入代码验算几个dp，
      <span style="background-color:#ffd900">
       dp不能全初始化为INT_MAX/0，要不然没法迭代
      </span>
     </strong>
    </p>
    <p>
     2.j&lt;=sqrt(i)，"&lt;="，要不然1没法遍历到完全平方数1；“sqrt(i)”防止i-j*j&lt;0,数组索引不合法
    </p>
    <p>
     3.
     <span style="background-color:#ffd900">
      if (dp[i - j * j] != INT_MAX) 防止INT_MAX+1溢出【其实也就是 j &lt;= sqrt(i)】
     </span>
    </p>
    <pre><code>class Solution {
public:
    int numSquares(int n) {
        // 完全想不到和动态规划什么关系
        // 完全平方数，如何开方
        // 和为n的完全平方数最小数量--&gt;dp[n]表示和为n的完全平方数最小数量
        // dp[n] = min{dp[n-i*i]+1,dp[n]}但是不会超出时间限制吗
        // ？初始化
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        // 遍历
        for (int i = 1; i &lt;= n; i++) {           // dp[n]
            for (int j = 1; j &lt;= sqrt(i); j++) { // j^2 &lt;=e.g.1

               // if (dp[i - j * j] != INT_MAX) {
                    dp[i] = min(dp[i - j * j] + 1, dp[i]);
                //}
            }
        }

        return dp[n];
    }
};</code></pre>
    <h3>
     第二题：单词拆分
    </h3>
    <p>
     【回溯：分隔回文串？？？】
    </p>
    <p>
     <span style="background-color:#ffd900">
      回顾：c++中关于字符串的函数
     </span>
    </p>
    <p>
     <a href="https://blog.csdn.net/2301_76653605/article/details/141790794?spm=1011.2415.3001.5331" title="C++知识回顾-CSDN博客">
     </a>
     <a href="https://blog.csdn.net/2301_76653605/article/details/141790794?spm=1011.2415.3001.5331" title="C++知识回顾-CSDN博客">
     </a>
    </p>
    <p>
     1.s1.substr(2,5); // 结果：23456-----参数2：从s1[2]开始截取，参数5表示：截取多长
    </p>
    <p>
     2.
     <code>
      s.end()
     </code>
     适用于
     <strong>
      标准容器（如
      <code>
       std::string
      </code>
      和
      <code>
       std::vector
      </code>
      ）或支持
      <code>
       end()
      </code>
      成员函数的自定义类
     </strong>
    </p>
    <p>
     <strong>
      set的find返回的也是迭代器，string的find返回的是string首字母下标
     </strong>
    </p>
    <p>
     题的思路：1.dp[n]表示前n个字符是否可以用已知wordDict表示
    </p>
    <p>
     2.初始化：dp[0] = true,其他false
    </p>
    <p>
     3.遍历顺序：排列数--&gt;先遍历背包，再遍历物品【我的初始循环i，更新                                        i+wordDict[j].size()-1的dp，这个思路比较混乱，虽然也能行的通；
    </p>
    <p>
     一般思路是更新dp[i]】
    </p>
    <h4>
     初版代码问题：
    </h4>
    <p>
     卒于s ="abcd"；wordDict =["a","abc","b","cd"]
    </p>
    <p>
     输出1,3,2，
    </p>
    <p>
     <s>
      好吧，为什么呢 ，不理解
     </s>
    </p>
    <p>
     <strong>
      我悟了！！！！！
     </strong>
    </p>
    <p>
     <span style="background-color:null">
      for(int j = 0;
      <strong>
       j&lt;wordDict.size() &amp;&amp; i+wordDict[j].size()-1&lt;=s.size()
      </strong>
      ;j++){
      <!-- -->
     </span>
    </p>
    <p>
     <span style="background-color:null">
      中
     </span>
    </p>
    <p>
     <strong>
      <span style="background-color:null">
       j&lt;wordDict.size() &amp;&amp; i+wordDict[j].size()-1&lt;=s.size()
      </span>
     </strong>
    </p>
    <p>
     <span style="background-color:#ffd900">
      如果for中某一时刻不满足这个条件，for结束循环，退出，即j=1不满足的话，就不会有j=2了
     </span>
    </p>
    <p>
     所以正确的做法是：
    </p>
    <blockquote>
     <p>
      for(int j = 0; j &lt; wordDict.size(); j++) {
      <!-- -->
      <br/>
      if ((i + wordDict[j].size() - 1) &lt;= s.size()) {
      <!-- -->
      <br/>
     </p>
    </blockquote>
    <p>
     <span style="background-color:#ffd900">
      这告诉我们，for的条件里不要塞太多。。。
     </span>
    </p>
    <pre><code>class Solution {
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
        //字符串操作
        //依旧不知道和动态规划的关系
        //看代码随想录说想成背包【s】和物品【wordDict】
        //难道不是检验wordDict有没有和s重合的，然后去除,检测重合--&gt;for{for{}} OR s.find("");
        //dp[n]表示从本字符串从第一个字符到第n个是否可以由这些单词组成
        vector&lt;bool&gt; dp(s.size()+1,false);//bool
        dp[0] = true;
        //dp[n] = dp[i] &amp;&amp; s[i...wordDict[j].size()+i-1].find(wordDict[j])
        for(int i = 1;i&lt;=s.size();i++){//第一个字符下标为0
            for(int j = 0;j&lt;wordDict.size() &amp;&amp; i+wordDict[j].size()-1&lt;=s.size() ;j++){
                string sub = s.substr(i-1,wordDict[j].size());
                if(sub == wordDict[j]){
                    if(dp[i-1] == true){
                        dp[wordDict[j].size()+i-1] = true;
                        cout&lt;&lt;wordDict[j].size()+i-1&lt;&lt;endl;
                    }
                }
            }
        }
        return dp[s.size()];
        
    }
};</code></pre>
    <h4>
     <strong>
      比较正常的思路。。
     </strong>
     ：
    </h4>
    <p>
     一般dp[n]遍历到n是更新的是dp[n],要不然逻辑太混乱
    </p>
    <p>
     在实操过程中，i/j/wordDict[j].size()我一直绕不清楚，太绕了……
    </p>
    <p>
     如果顺应初始化dp（size（），false）会好一点
    </p>
    <pre><code>class Solution {
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
        //字符串操作
        //依旧不知道和动态规划的关系
        //看代码随想录说想成背包【s】和物品【wordDict】
        //难道不是检验wordDict有没有和s重合的，然后去除,检测重合--&gt;for{for{}} OR s.find("");
        //dp[n]表示从本字符串从第一个字符到第n个是否可以由这些单词组成
        vector&lt;bool&gt; dp(s.size()+1,false);//bool
        dp[0] = true;
        unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());
        //dp[n] = dp[i] &amp;&amp; s[i...wordDict[j].size()+i-1].find(wordDict[j])
        for(int i = 1;i&lt;=s.size();i++){//第一个字符下标为0
            for(int j = 1;j&lt;=i;j++){
                //j-1..i-1
               string word = s.substr(j-1, i - j +1); 
                if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j-1]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
        
    }
};</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363635333630352f:61727469636c652f64657461696c732f313436313434363731" class_="artid" style="display:none">
 </p>
</div>


