---
layout: post
title: "A算法-JAVA实现"
date: 2025-01-23 01:16:47 +0800
description: "A*算法 java实现  本文内容参考于   ——  [ 理解A*寻路算法具体过程 ]  A算法是一"
keywords: "java a*算法"
categories: ['算法']
tags: ['算法', 'Java', 'A']
artid: "51897970"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51897970
    alt: "A算法-JAVA实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51897970
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51897970
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     A*算法 JAVA实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3 id="a算法的java实现">
     A*算法的java实现
    </h3>
    <blockquote>
     <p>
      本文内容参考于 ——
      <a href="http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html" rel="nofollow noopener noreferrer" target="_blank">
       [ 理解A*寻路算法具体过程 ]
      </a>
     </p>
    </blockquote>
    <p>
     <em>
      A*算法是一种启发式最小代价寻路算法，本文是在参考博文的基础上了解A*算法思想之后，使用java实现的，做个记录。
     </em>
     <br/>
     <strong>
      整个过程抽象：
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs bash">把起始格添加到 <span class="hljs-string">"开启列表"</span> 
<span class="hljs-keyword">do</span> 
{ 
       寻找开启列表中F值最低的格子, 我们称它为当前格. 
       把它切换到关闭列表. 
       对当前格相邻的<span class="hljs-number">8</span>格中的每一个 
          <span class="hljs-keyword">if</span> (它不可通过 || 已经在 <span class="hljs-string">"关闭列表"</span> 中) 
          { 
                什么也不做. 
          } 
          <span class="hljs-keyword">if</span> (它不在开启列表中) 
          { 
                把它添加进 <span class="hljs-string">"开启列表"</span>, 把当前格作为这一格的父节点, 计算这一格的 FGH 
          }
          <span class="hljs-keyword">if</span> (它已经在开启列表中) 
          { 
                <span class="hljs-keyword">if</span> (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
                    { 
                            把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. 
                    } 
          }
          目标格已经在 <span class="hljs-string">"开启列表"</span>, 这时候路径被找到跳出循环；
} <span class="hljs-keyword">while</span>(开启列表不为空) 
如果开启列表已经空了,目标格没找到 说明路径不存在.
最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.</code></pre>
    <p>
     <strong>
      注：这个实现支持斜着走， 如果要实现不支持走沿对角的斜线，可以在此实现的基础上稍作修改即可实现。
     </strong>
    </p>
    <hr/>
    <p>
     JAVA实现的代码如下：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Scanner;
<span class="hljs-keyword">import</span> java.util.Stack;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AStarAlgorithm</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] DIREC = {<!-- -->{-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>}, {-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>}, {<!-- --><span class="hljs-number">0</span>, <span class="hljs-number">1</span>}, {<!-- --><span class="hljs-number">1</span>, <span class="hljs-number">1</span>}, 
        {<!-- --><span class="hljs-number">1</span>, <span class="hljs-number">0</span>}, {<!-- --><span class="hljs-number">1</span>, -<span class="hljs-number">1</span>}, {<!-- --><span class="hljs-number">0</span>, -<span class="hljs-number">1</span>}, {-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>}};

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.println(<span class="hljs-string">"please enter (rows cols x1 y1 x2 y2): "</span>);
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rows = scanner.nextInt();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cols = scanner.nextInt();
        <span class="hljs-keyword">int</span> x1 = scanner.nextInt();
        <span class="hljs-keyword">int</span> y1 = scanner.nextInt();
        <span class="hljs-keyword">int</span> x2 = scanner.nextInt();
        <span class="hljs-keyword">int</span> y2 = scanner.nextInt();
        scanner.close();

        <span class="hljs-comment">// generate a two-dimension array filled with 0</span>
        <span class="hljs-keyword">int</span> map[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {
            <span class="hljs-keyword">int</span> tmp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];
            Arrays.fill(tmp, <span class="hljs-number">0</span>);
            map[i] = tmp;
        }
        <span class="hljs-keyword">int</span> midr = rows / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> midc = cols / <span class="hljs-number">2</span>;
        <span class="hljs-comment">/*map[midr - 1][midc] = 1;
        map[midr][midc] = 1;
        map[midr + 1][midc] = 1;*/</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows - <span class="hljs-number">1</span>; i++) {
            map[i][midc] = <span class="hljs-number">1</span>;
        }
        map[<span class="hljs-number">2</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>;
        map[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>;
        map[<span class="hljs-number">4</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>;
        map[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>;


        findPath(map, x1, y1, x2, y2);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPath</span>(<span class="hljs-keyword">int</span>[][] map, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2) {
        List&lt;Position&gt; openList = <span class="hljs-keyword">new</span> ArrayList&lt;AStarAlgorithm.Position&gt;();
        List&lt;Position&gt; closeList = <span class="hljs-keyword">new</span> ArrayList&lt;AStarAlgorithm.Position&gt;();
        <span class="hljs-keyword">boolean</span> findFlag = <span class="hljs-keyword">false</span>;
        Position termPos = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 起始点</span>
        Position startPos = <span class="hljs-keyword">new</span> Position(x1, y1, calcH(x1, y1, x2, y2));
        openList.add(startPos);
        do {
            <span class="hljs-comment">// 通过在开启列表中找到F值最小的点作为当前点</span>
            Position currentPos = openList.get(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; openList.size(); i++) {
                <span class="hljs-keyword">if</span> (currentPos.F &gt; openList.get(i).F) {
                    currentPos = openList.get(i);
                }
            }
            <span class="hljs-comment">// 将找到的当前点放到关闭列表中，并从开启列表中删除</span>
            closeList.add(currentPos);
            openList.remove(currentPos);

            <span class="hljs-comment">//遍历当前点对应的8个相邻点</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; DIREC.length; i++) {
                <span class="hljs-keyword">int</span> tmpX = currentPos.row + DIREC[i][<span class="hljs-number">0</span>];
                <span class="hljs-keyword">int</span> tmpY = currentPos.col + DIREC[i][<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (tmpX &lt; <span class="hljs-number">0</span> || tmpX &gt;= map.length || tmpY &lt; <span class="hljs-number">0</span> || tmpY &gt;= map[<span class="hljs-number">0</span>].length) {
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-comment">//创建对应的点</span>
                Position tmpPos = <span class="hljs-keyword">new</span> Position(tmpX, tmpY, calcH(tmpX, tmpY, x2, y2), currentPos);
                <span class="hljs-comment">//map中对应的格子中的值为1（障碍）， 或对应的点已经在关闭列表中</span>
                <span class="hljs-keyword">if</span> (map[tmpX][tmpY] == <span class="hljs-number">1</span> || closeList.contains(tmpPos)) {
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-comment">//如果不在开启列表中，则加入到开启列表</span>
                <span class="hljs-keyword">if</span> (!openList.contains(tmpPos)) {
                    openList.add(tmpPos);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 如果已经存在开启列表中，则用G值考察新的路径是否更好，如果该路径更好，则把父节点改成当前格并从新计算FGH</span>
                    Position prePos = <span class="hljs-keyword">null</span>;
                    <span class="hljs-keyword">for</span> (Position pos : openList) {
                        <span class="hljs-keyword">if</span> (pos.row == tmpX &amp;&amp; pos.col == tmpY) {
                            prePos = pos;
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (tmpPos.G &lt; prePos.G) {
                        prePos.setFaPos(currentPos);
                    }
                }
            }
            <span class="hljs-comment">// 判断终点是否在开启列表中</span>
            <span class="hljs-keyword">for</span> (Position tpos : openList) {
                <span class="hljs-keyword">if</span> (tpos.row == x2 &amp;&amp; tpos.col == y2) {
                    termPos = tpos;
                    findFlag = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

        } <span class="hljs-keyword">while</span>(openList.size() != <span class="hljs-number">0</span>);

        <span class="hljs-keyword">if</span>(!findFlag) {
            System.out.println(<span class="hljs-string">"no valid path!"</span>);
            <span class="hljs-keyword">return</span>;
        }

        Stack&lt;String&gt; resStack = <span class="hljs-keyword">new</span> Stack&lt;String&gt;();
        String pattern = <span class="hljs-string">"(%d, %d)"</span>;
        <span class="hljs-keyword">if</span> (termPos != <span class="hljs-keyword">null</span>) {
            resStack.push(String.format(pattern, termPos.row, termPos.col));
            <span class="hljs-keyword">while</span>(termPos.fa != <span class="hljs-keyword">null</span>) {
                termPos = termPos.fa;
                resStack.push(String.format(pattern, termPos.row, termPos.col));
            }
        }
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span> (!resStack.empty()) {
            sb.append(resStack.pop());
            <span class="hljs-keyword">if</span> (!resStack.empty()) {
                sb.append(<span class="hljs-string">" -&gt; "</span>);
            }
        }
        System.out.println(sb.toString());
    }

    <span class="hljs-javadoc">/**
     * 计算某个格子的H值
     *<span class="hljs-javadoctag"> @param</span> x
     *<span class="hljs-javadoctag"> @param</span> y
     *<span class="hljs-javadoctag"> @param</span> tx 终点的x值
     *<span class="hljs-javadoctag"> @param</span> ty 终点的y值
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcH</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> tx, <span class="hljs-keyword">int</span> ty) {
        <span class="hljs-keyword">int</span> diff = Math.abs(x - tx) + Math.abs(y - ty);
        <span class="hljs-keyword">return</span> diff * <span class="hljs-number">10</span>;
    }


    <span class="hljs-keyword">static</span> class Position {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> F;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> G;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> H;
        <span class="hljs-keyword">public</span> Position fa;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> row;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> col;

        <span class="hljs-keyword">public</span> <span class="hljs-title">Position</span>() {
        }

        <span class="hljs-keyword">public</span> <span class="hljs-title">Position</span>(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> H) {
            <span class="hljs-keyword">this</span>(row, col, H, <span class="hljs-keyword">null</span>);
        }

        <span class="hljs-keyword">public</span> <span class="hljs-title">Position</span>(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> H, Position pos) {
            <span class="hljs-keyword">this</span>.H = H;
            <span class="hljs-keyword">this</span>.row = row;
            <span class="hljs-keyword">this</span>.col = col;
            <span class="hljs-keyword">this</span>.fa = pos;
            <span class="hljs-keyword">this</span>.G = calcG();
            <span class="hljs-keyword">this</span>.F = G + H;
        }

        <span class="hljs-javadoc">/** 
         * 计算某个点到起始点的代价G
         *<span class="hljs-javadoctag"> @return</span>
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcG</span>() {
            <span class="hljs-keyword">if</span> (fa == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (fa.row != <span class="hljs-keyword">this</span>.row &amp;&amp; fa.col !=  <span class="hljs-keyword">this</span>.col) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">14</span> + fa.G;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> + fa.G;
        } 

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFaPos</span>(Position pos) {
            <span class="hljs-keyword">this</span>.fa = pos;
            <span class="hljs-keyword">this</span>.G = calcG();
            <span class="hljs-keyword">this</span>.F = G + H;
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span>(Object obj) {
            <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            <span class="hljs-keyword">if</span> (!(obj <span class="hljs-keyword">instanceof</span> Position)) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            Position pos = (Position) obj;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.row == pos.row &amp;&amp; <span class="hljs-keyword">this</span>.col == pos.col;
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span>() {
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> prime = <span class="hljs-number">31</span>;
            <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
            result = prime * result + row;
            result = prime * result + col;
            <span class="hljs-keyword">return</span> result;
        }

    }

}
</code></pre>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6c6473746172746e6f77:2f61727469636c652f64657461696c732f3531383937393730" class_="artid" style="display:none">
 </p>
</div>


