---
layout: post
title: "动态规划-区间dpdfs-最长回文子序列leetcode-516"
date: 2025-03-14 22:27:11 +0800
description: "选或者不选 从两侧向内缩小问题规模"
keywords: "(动态规划 区间dp/dfs 最长回文子序列）leetcode 516"
categories: ['未分类']
tags: ['深度优先', '动态规划', 'Leetcode']
artid: "146268457"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268457
    alt: "动态规划-区间dpdfs-最长回文子序列leetcode-516"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268457
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268457
cover: https://bing.ee123.net/img/rand?artid=146268457
image: https://bing.ee123.net/img/rand?artid=146268457
img: https://bing.ee123.net/img/rand?artid=146268457
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     (动态规划 区间dp/dfs 最长回文子序列）leetcode 516
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     思路来源
     <a class="link-info" href="https://www.bilibili.com/video/BV1Gs4y1E7EU/?spm_id_from=333.1007.top_right_bar_window_history.content.click" rel="nofollow" title="灵茶山艾府">
      灵茶山艾府
     </a>
    </p>
    <p>
     <img alt="" height="518" src="https://i-blog.csdnimg.cn/direct/2ae26a05dc39464496517f0c68e9e3d4.png" width="1393"/>
    </p>
    <p>
     题目要求找到最长 回文 子序列
    </p>
    <p>
     <img alt="" height="237" src="https://i-blog.csdnimg.cn/direct/ad461e957d954326bed977aaa4cb9bfd.png" width="331"/>
    </p>
    <p>
     选或者不选 从两侧向内缩小问题规模、
    </p>
    <p>
     if(s[i]==s[j])
    </p>
    <p>
     return dfs(i+1,j-1)+2//从0--s.size()的最长公共子序列的长度为，1--s.size()-1的最长公共子序列的长度+2
    </p>
    <p>
     else
    </p>
    <p>
     if(s[i]!=s[j])
    </p>
    <p>
     return max(dfs(i+1,j),dfs(i,j-1));
    </p>
    <p>
     不相同，左右两边的字符分别消掉对方再比较最大值
    </p>
    <p>
    </p>
    <p>
     边界条件
    </p>
    <p>
     if i&gt;j
    </p>
    <p>
     return 0
    </p>
    <p>
     if(i==j)
    </p>
    <p>
     return 1;
    </p>
    <p>
     利用记忆化搜索
    </p>
    <p>
     代码如下
    </p>
    <pre><code class="language-cpp">class Solution {
    vector&lt;vector&lt;int&gt;&gt;used;
int dfs(string &amp;s,int i,int j)
{
    
    if (i == j)
        return 1;
    if (i &gt; j)
        return 0;
    if(used[i][j]!=-1)
    return used[i][j];
    if (s[i] != s[j])
    {
        used[i][j]=max(dfs(s, i + 1, j), dfs(s, i, j - 1));

    }
    else
    {
        used[i][j]=dfs(s, i + 1, j -1)+2;
    }

return used[i][j];
}
public:

    int longestPalindromeSubseq(string s) {
       used=vector&lt;vector&lt;int&gt;&gt;(s.size()+1,vector&lt;int&gt;(s.size()+1,-1));
        return dfs(s,0,s.size()-1);
    }
};</code></pre>
    <p>
    </p>
    <p>
     然后是改成递推
    </p>
    <p>
     这里用的是二维数组，每个数组的含义是
    </p>
    <p>
     从下标i到j的范围，最长的回文子序列
    </p>
    <p>
     ai解释：
    </p>
    <ul>
     <li>
      i 是子串的起点，j 是子串的终点。
     </li>
     <li>
      dp[i][j] 的值依赖于更小的子问题，如 dp[i+1][j] 或 dp[i][j-1]。
     </li>
     <li>
      dp[i][j] 的值依赖于更小的子问题，如 dp[i+1][j] 或 dp[i][j-1]。
     </li>
     <li>
      <p style="margin-left:0; margin-right:0">
       <strong>
        例子
       </strong>
       假设 s = "abdbca"，我们看 dp[1][4]，也就是子串 "bdb"：
      </p>
     </li>
     <li>
      s[1] = 'b'，s[4] = 'b'，满足 s[i] == s[j]。
     </li>
     <li>
      去掉 s[1] 和 s[4] 后，s[2:3] = "d"，这个子串的最长回文子序列是 1。
     </li>
     <li>
      所以 dp[1][4] = dp[2][3] + 2 = 1 + 2 = 3（即 "bdb"）。
     </li>
    </ul>
    <p>
     <img alt="" height="450" src="https://i-blog.csdnimg.cn/direct/e8892711f9ce4f5c96eb0865956e75be.png" width="1639"/>
    </p>
    <p>
     代码如下：
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
vector&lt;vector&lt;int&gt;&gt;dp(n+ 1, vector&lt;int&gt;(n + 1, 0));  
for (int i = 0;i &lt; n;i++)
{
    dp[i][i] = 1;
}

for(int i = n - 1;i &gt;= 0;i--)
{
    for (int j = i + 1;j &lt; n;j++)
    {
        if (s[i] == s[j])
        {
            dp[i][j]=dp[i + 1][j - 1] + 2;
        }
        else
        {
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);

        }
    }
}
return dp[0][n-1];
    }
};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430335f38373134303732352f:61727469636c652f64657461696c732f313436323638343537" class_="artid" style="display:none">
 </p>
</div>


