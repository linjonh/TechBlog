---
layout: post
title: "STM32-HAL库实战轻松实现串口通信驱动蓝牙模块与ESP8266开发"
date: 2025-03-13 15:34:56 +0800
description: "本文通过详细的步骤介绍了如何在STM32F103C8T6上使用HAL库进行串口通信，并展示了如何通过串口驱动蓝牙模块（HC-08）和WiFi模块（ESP8266）。这些技术为实现无线通信功能提供了坚实的基础，适用于各种嵌入式系统应用。"
keywords: "stm32可以用蓝牙做串口吗"
categories: ['嵌入式开发笔记']
tags: ['嵌入式硬件', '单片机', 'Stm']
artid: "146227794"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146227794
    alt: "STM32-HAL库实战轻松实现串口通信驱动蓝牙模块与ESP8266开发"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146227794
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146227794
cover: https://bing.ee123.net/img/rand?artid=146227794
image: https://bing.ee123.net/img/rand?artid=146227794
img: https://bing.ee123.net/img/rand?artid=146227794
---

# STM32 HAL库实战：轻松实现串口通信驱动蓝牙模块与ESP8266开发
## STM32 HAL库实战：轻松实现串口通信驱动蓝牙模块与ESP8266开发
\* \* \*
### 引言
STM32F103C8T6作为一款性能强劲的32位微控制器，广泛应用于各类嵌入式系统。本文将详细介绍如何使用STM32F103C8T6的HAL库进行串口通信，并展示如何通过串口驱动蓝牙模块（如HC-05）和WiFi模块（如ESP8266），实现无线通信功能。
\* \* \*
### 一、串口通信基础
#### 1.1 串口通信原理
串口通信是一种广泛使用的通信方式，通过一根发送线（TX）和一根接收线（RX）进行数据传输。STM32F103C8T6提供了多个USART（通用同步异步收发器）接口，支持全双工通信。
#### 1.2 HAL库配置串口
\* ##### \*\*串口初始化设置\*\* ：
在HAL库中，串口通信的配置主要包括波特率设置、数据位、停止位和校验位等。以下是一个基本的串口初始化代码示例：
UART\_HandleTypeDef uart1\_handle; /\* UART1句柄 \*/
/\*\*
\* @brief 串口1初始化函数
\* @param baudrate: 波特率, 根据自己需要设置波特率值
\* @retval 无
\*/
void uart1\_init(uint32\_t baudrate)
{
/\*UART1 初始化设置\*/
uart1\_handle.Instance = USART1; /\* USART1 \*/
uart1\_handle.Init.BaudRate = baudrate; /\* 波特率 \*/
uart1\_handle.Init.WordLength = UART\_WORDLENGTH\_8B; /\* 字长为8位数据格式 \*/
uart1\_handle.Init.StopBits = UART\_STOPBITS\_1; /\* 一个停止位 \*/
uart1\_handle.Init.Parity = UART\_PARITY\_NONE; /\* 无奇偶校验位 \*/
uart1\_handle.Init.HwFlowCtl = UART\_HWCONTROL\_NONE; /\* 无硬件流控 \*/
uart1\_handle.Init.Mode = UART\_MODE\_TX\_RX; /\* 收发模式 \*/
HAL\_UART\_Init(&uart1\_handle); /\* HAL\_UART\_Init()会使能UART1 \*/
}
\* ##### 串口底层初始化：
在以下代码中，当函数调用HAL\_UART\_Init()函数时，就会自动调用 ‌HAL\_UART\_MspInit()‌，以完成底层硬件相关的配置。
在下方代码中，我们配置与硬件相关的部分，例如：
\* 使能UART和GPIO的时钟。
\* 初始化TX/RX引脚（配置为复用功能）。
\* 配置中断（串口中断和总线空闲中断）。
/\*\*
\* @brief UART底层初始化函数
\* @param huart: UART句柄类型指针
\* @note 此函数会被HAL\_UART\_Init()调用
\* 完成时钟使能，引脚配置，中断配置
\* @retval 无
\*/
void HAL\_UART\_MspInit(UART\_HandleTypeDef \*huart)
{
GPIO\_InitTypeDef gpio\_init\_struct;
if (huart->Instance == USART1) /\* 如果是串口1，进行串口1 MSP初始化 \*/
{
\_\_HAL\_RCC\_GPIOA\_CLK\_ENABLE(); /\* 使能串口TX脚时钟 \*/
\_\_HAL\_RCC\_USART1\_CLK\_ENABLE(); /\* 使能串口时钟 \*/
gpio\_init\_struct.Pin = GPIO\_PIN\_9; /\* 串口发送引脚号 \*/
gpio\_init\_struct.Mode = GPIO\_MODE\_AF\_PP; /\* 复用推挽输出 \*/
gpio\_init\_struct.Pull = GPIO\_PULLUP; /\* 上拉 \*/
gpio\_init\_struct.Speed = GPIO\_SPEED\_FREQ\_HIGH; /\* IO速度设置为高速 \*/
HAL\_GPIO\_Init(GPIOA, &gpio\_init\_struct);
gpio\_init\_struct.Pin = GPIO\_PIN\_10; /\* 串口RX脚 模式设置 \*/
gpio\_init\_struct.Mode = GPIO\_MODE\_AF\_INPUT;
HAL\_GPIO\_Init(GPIOA, &gpio\_init\_struct); /\* 串口RX脚 必须设置成输入模式 \*/
HAL\_NVIC\_EnableIRQ(USART1\_IRQn); /\* 使能USART1中断通道 \*/
HAL\_NVIC\_SetPriority(USART1\_IRQn, 3, 3); /\* 组2，最低优先级:抢占优先级3，子优先级3 \*/
\_\_HAL\_UART\_ENABLE\_IT(huart, UART\_IT\_RXNE); /\* 使能UART1接收中断 \*/
\_\_HAL\_UART\_ENABLE\_IT(huart, UART\_IT\_IDLE); /\* 使能UART1总线空闲中断 \*/
}
}
\* ##### 串口中断处理函数:
这边暂时体供串口1的中断处理函数。由于我们串口1开启了两个中断：
\* \* 接收寄存器非空触发中断
\* 串口空闲线路中断
我们在以下中断处理函数中，处理这两个中断。接收非空中断触发时，将接收到的数据进行缓存到数组中，当触发空闲中断说明数据接收完毕，则将数据打印出来。这边使用printf函数，需要堆fputc函数进行该写。
#define UART1\_RX\_BUF\_SIZE 128 //
#define UART1\_TX\_BUF\_SIZE 64
uint8\_t uart1\_rx\_buf[UART1\_RX\_BUF\_SIZE]; /\* UART1接收缓冲区 \*/
/\*\*
\* @brief UART1接收缓冲区清除
\* @param 无
\* @retval 无
\*/
void uart1\_rx\_clear(void)
{
memset(uart1\_rx\_buf, 0, sizeof(uart1\_rx\_buf)); /\* 清空接收缓冲区 \*/
uart1\_rx\_len = 0; /\* 接收计数器清零 \*/
}
/\*\*
\* @brief 串口1中断服务函数
\* @note 在此使用接收中断及空闲中断，实现不定长数据收发
\* @param 无
\* @retval 无
\*/
void HAL\_UART\_MspInit(UART\_HandleTypeDef \*huart)
{
GPIO\_InitTypeDef gpio\_init\_struct;
if (huart->Instance == USART1) /\* 如果是串口1，进行串口1 MSP初始化 \*/
{
\_\_HAL\_RCC\_GPIOA\_CLK\_ENABLE(); /\* 使能串口TX脚时钟 \*/
\_\_HAL\_RCC\_USART1\_CLK\_ENABLE(); /\* 使能串口时钟 \*/
gpio\_init\_struct.Pin = GPIO\_PIN\_9; /\* 串口发送引脚号 \*/
gpio\_init\_struct.Mode = GPIO\_MODE\_AF\_PP; /\* 复用推挽输出 \*/
gpio\_init\_struct.Pull = GPIO\_PULLUP; /\* 上拉 \*/
gpio\_init\_struct.Speed = GPIO\_SPEED\_FREQ\_HIGH; /\* IO速度设置为高速 \*/
HAL\_GPIO\_Init(GPIOA, &gpio\_init\_struct);
gpio\_init\_struct.Pin = GPIO\_PIN\_10; /\* 串口RX脚 模式设置 \*/
gpio\_init\_struct.Mode = GPIO\_MODE\_AF\_INPUT;
HAL\_GPIO\_Init(GPIOA, &gpio\_init\_struct); /\* 串口RX脚 必须设置成输入模式 \*/
HAL\_NVIC\_EnableIRQ(USART1\_IRQn); /\* 使能USART1中断通道 \*/
HAL\_NVIC\_SetPriority(USART1\_IRQn, 3, 3); /\* 组2，最低优先级:抢占优先级3，子优先级3 \*/
\_\_HAL\_UART\_ENABLE\_IT(huart, UART\_IT\_RXNE); /\* 使能UART1接收中断 \*/
\_\_HAL\_UART\_ENABLE\_IT(huart, UART\_IT\_IDLE); /\* 使能UART1总线空闲中断 \*/
}
else if (huart->Instance == USART2) /\* 如果是串口2，进行串口2 MSP初始化 \*/
{
\_\_HAL\_RCC\_GPIOA\_CLK\_ENABLE(); /\* 使能串口TX脚时钟 \*/
\_\_HAL\_RCC\_USART2\_CLK\_ENABLE(); /\* 使能串口时钟 \*/
gpio\_init\_struct.Pin = GPIO\_PIN\_2; /\* 串口发送引脚号 \*/
gpio\_init\_struct.Mode = GPIO\_MODE\_AF\_PP; /\* 复用推挽输出 \*/
gpio\_init\_struct.Pull = GPIO\_PULLUP; /\* 上拉 \*/
gpio\_init\_struct.Speed = GPIO\_SPEED\_FREQ\_HIGH; /\* IO速度设置为高速 \*/
HAL\_GPIO\_Init(GPIOA, &gpio\_init\_struct);
gpio\_init\_struct.Pin = GPIO\_PIN\_3; /\* 串口RX脚 模式设置 \*/
gpio\_init\_struct.Mode = GPIO\_MODE\_AF\_INPUT;
HAL\_GPIO\_Init(GPIOA, &gpio\_init\_struct); /\* 串口RX脚 必须设置成输入模式 \*/
HAL\_NVIC\_EnableIRQ(USART2\_IRQn); /\* 使能USART2中断通道 \*/
HAL\_NVIC\_SetPriority(USART2\_IRQn, 3, 3); /\* 组2，最低优先级:抢占优先级3，子优先级3 \*/
\_\_HAL\_UART\_ENABLE\_IT(huart, UART\_IT\_RXNE); /\* 使能UART2接收中断 \*/
\_\_HAL\_UART\_ENABLE\_IT(huart, UART\_IT\_IDLE); /\* 使能UART2总线空闲中断 \*/
}
}
\* ##### 改写fputc函数
我们改写fputc函数，这样就可以直接使用printf函数进行串口打印。
/\*\*
\* @brief 重定义fputc函数
\* @note printf函数最终会通过调用fputc输出字符串到串口
\*/
int fputc(int ch, FILE \*f)
{
while ((USART1->SR & 0X40) == 0); /\* 等待上一个字符发送完成 \*/
USART1->DR = (uint8\_t)ch; /\* 将要发送的字符 ch 写入到DR寄存器 \*/
return ch;
}
做完这些操作，编译时也记得打开使用MicroLIB。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/37aefbe628f9446782188596c227f431.png)
至此，我们可以使用printf函数直接利用CH340单片机给电脑发送串口消息。
### 二、驱动蓝牙模块（HC-08）
#### 2.1 硬件连接
将HC-08蓝牙模块的TX引脚连接到STM32的RX引脚，将HC-08的RX引脚连接到STM32的TX引脚。同时，确保蓝牙模块和STM32共地。
#### 2.2 软件配置
在串口初始化完成后，可以通过串口发送AT指令来配置HC-08蓝牙模块。例如，设置蓝牙模块的名称和配对密码，
我们使用串口二与之交叉相连。
\* ##### 初始化函数
UART\_HandleTypeDef uart2\_handle= {0};
void bt\_init(uint32\_t baudrate)
{
/\*uart2 初始化设置\*/
uart2\_handle.Instance = USART2; /\* USART1 \*/
uart2\_handle.Init.BaudRate = baudrate; /\* 波特率 \*/
uart2\_handle.Init.WordLength = UART\_WORDLENGTH\_8B; /\* 字长为8位数据格式 \*/
uart2\_handle.Init.StopBits = UART\_STOPBITS\_1; /\* 一个停止位 \*/
uart2\_handle.Init.Parity = UART\_PARITY\_NONE; /\* 无奇偶校验位 \*/
uart2\_handle.Init.HwFlowCtl = UART\_HWCONTROL\_NONE; /\* 无硬件流控 \*/
uart2\_handle.Init.Mode = UART\_MODE\_TX\_RX; /\* 收发模式 \*/
HAL\_UART\_Init(&uart2\_handle); /\* HAL\_UART\_Init()会使能uart2 \*/
}
\* ##### 中断处理函数
/\*\*
\* @brief uart2接收缓冲区清除
\* @param 无
\* @retval 无
\*/
void uart2\_rx\_clear(void)
{
memset(uart2\_rx\_buf, 0, sizeof(uart2\_rx\_buf)); /\* 清空接收缓冲区 \*/
uart2\_rx\_len = 0; /\* 接收计数器清零 \*/
}
/\*\*
\* @brief 串口2中断服务函数
\* @note 在此使用接收中断及空闲中断，实现不定长数据收发
\* @param 无
\* @retval 无
\*/
void USART2\_IRQHandler(void)
{
uint8\_t receive\_data = 0;
if(\_\_HAL\_UART\_GET\_FLAG(&uart2\_handle, UART\_FLAG\_RXNE) != RESET){ /\* 获取接收RXNE标志位是否被置位 \*/
if(uart2\_rx\_len >= sizeof(uart2\_rx\_buf)) /\* 如果接收的字符数大于接收缓冲区大小， \*/
uart2\_rx\_len = 0; /\* 则将接收计数器清零 \*/
HAL\_UART\_Receive(&uart2\_handle, &receive\_data, 1, 1000); /\* 接收一个字符 \*/
uart2\_rx\_buf[uart2\_rx\_len++] = receive\_data; /\* 将接收到的字符保存在接收缓冲区 \*/
}
if (\_\_HAL\_UART\_GET\_FLAG(&uart2\_handle, UART\_FLAG\_IDLE) != RESET) /\* 获取接收空闲中断标志位是否被置位 \*/
{
printf("bt recv: %s\r\n", uart2\_rx\_buf); /\* 将接收到的数据打印出来 \*/
uart2\_rx\_clear();
\_\_HAL\_UART\_CLEAR\_IDLEFLAG(&uart2\_handle); /\* 清除UART总线空闲中断 \*/
}
}
\* ##### 重写蓝牙发送函数
#include "stdarg.h"
void bt\_send(char \* format, ...)
{
uint8\_t send\_buf[128] ={0};
va\_list arg;
va\_start(arg, format);
vsprintf((char \*)send\_buf, format, arg);
va\_end(arg);
HAL\_UART\_Transmit(&uart2\_handle, send\_buf, sizeof(send\_buf), 100);
}
#### 2.3 数据收发
配置完成后，即可通过串口与蓝牙模块进行数据收发。例如：
int main(void)
{
HAL\_Init(); /\* 初始化HAL库 \*/
stm32\_clock\_init(RCC\_PLL\_MUL9); /\* 设置时钟, 72Mhz \*/
uart1\_init(115200);
bt\_init(115200);
printf("hello world!\r\n");
uint8\_t i = 0;
while(1)
{
bt\_send("hello, bt%d\r\n", i++);
delay\_ms(500);
}
}
### 三、驱动WiFi模块（ESP8266）
为避免文章过长，ESP8266的驱动，本文暂时只讲最简单的连接测试，他的几种连接方式放在明天的文章中，进行详细介绍。
#### 3.1 硬件连接
将ESP8266模块的TX引脚连接到STM32的RX引脚，将ESP8266的RX引脚连接到STM32的TX引脚。同时，确保ESP8266的VCC、GND正确连接。
#### 3.2 软件配置
ESP8266的配置相对复杂，需要通过串口发送AT指令进行WiFi连接和TCP/UDP通信设置。
在这个案例中，我们接收连续字符串不采用空闲中断，所以在`HAL\_UART\_MspInit`函数中，我们将串口2的IDLE中断注释。
以下是一个简单的WiFi连接示例：
\* ##### \*\*串口初始化\*\*
#define ESP8266\_RX\_BUF\_SIZE 128
#define ESP8266\_TX\_BUF\_SIZE 64
#define ESP8266\_EOK 0
#define ESP8266\_ERROR 1
#define ESP8266\_ETIMEOUT 2
#define ESP8266\_EINVAL 3
UART\_HandleTypeDef esp8266\_handle = {0};
void esp8266\_uart\_init(uint32\_t baudrate)
{
esp8266\_handle.Instance = USART2;
esp8266\_handle.Init.BaudRate = baudrate;
esp8266\_handle.Init.WordLength = UART\_WORDLENGTH\_8B;
esp8266\_handle.Init.StopBits = UART\_STOPBITS\_1;
esp8266\_handle.Init.Parity = UART\_PARITY\_NONE;
esp8266\_handle.Init.HwFlowCtl = UART\_HWCONTROL\_NONE;
esp8266\_handle.Init.Mode = UART\_MODE\_TX\_RX;
HAL\_UART\_Init(&esp8266\_handle);
}
\* ##### 中断函数
uint8\_t esp8266\_rx\_buf[ESP8266\_RX\_BUF\_SIZE];
uint16\_t esp8266\_cnt = 0, esp8266\_cntPre = 0;
void USART2\_IRQHandler(void)
{
uint8\_t receive\_data = 0;
if(\_\_HAL\_UART\_GET\_FLAG(&esp8266\_handle, UART\_FLAG\_RXNE) != RESET)
{
if(esp8266\_cnt >= sizeof(esp8266\_rx\_buf))
esp8266\_cnt = 0;
HAL\_UART\_Receive(&esp8266\_handle, &receive\_data, 1, 1000);
esp8266\_rx\_buf[esp8266\_cnt++] = receive\_data;
//uart1\_cnt++;
//HAL\_UART\_Transmit(&uart1\_handle, &receive\_data, 1, 1000);
}
}
\* ##### 判断函数
uint8\_t esp8266\_wait\_receive(void)
{
if(esp8266\_cnt == 0)
return ESP8266\_ERROR;
if(esp8266\_cnt == esp8266\_cntPre)
{
esp8266\_cnt = 0;
return ESP8266\_EOK;
}
esp8266\_cntPre = esp8266\_cnt;
return ESP8266\_ERROR;
}
\* ##### 清除函数
void esp8266\_rx\_clear(void)
{
memset(esp8266\_rx\_buf, 0, sizeof(esp8266\_rx\_buf));
esp8266\_cnt = 0;
}
\* ##### 接收函数
void esp8266\_receive\_data(void)
{
if(esp8266\_wait\_receive() == ESP8266\_EOK)
{
printf("esp8266 recv: %s\r\n", esp8266\_rx\_buf);
esp8266\_rx\_clear();
}
}
\* ##### 发送函数
uint8\_t esp8266\_send\_command(char \*cmd, char \*res)
{
uint8\_t time\_out = 250;
esp8266\_rx\_clear();
HAL\_UART\_Transmit(&esp8266\_handle, (uint8\_t \*)cmd, strlen(cmd), 100);
while(time\_out--)
{
if(esp8266\_wait\_receive() == ESP8266\_EOK)
{
if(strstr((const char\*)esp8266\_rx\_buf, res) != NULL)
return ESP8266\_EOK;
}
delay\_ms(10);
}
return ESP8266\_ERROR;
}
\* ##### 测试函数
void esp8266\_test(void)
{
if(esp8266\_send\_command("AT", "OK") == ESP8266\_EOK)
printf("esp8266 test: %s\r\n", esp8266\_rx\_buf);
}
#### 3.3 数据收发
WiFi连接成功后，即可通过串口与ESP8266进行TCP/UDP数据收发。例如，发送数据到服务器：
#include "sys.h"
#include "delay.h"
#include "uart1.h"
#include "esp8266.h"
int main(void)
{
HAL\_Init(); /\* 初始化HAL库 \*/
stm32\_clock\_init(RCC\_PLL\_MUL9); /\* 设置时钟, 72Mhz \*/
uart1\_init(115200);
esp8266\_init(115200);
printf("hello world!\r\n");
while(1)
{
esp8266\_test();
delay\_ms(10);
}
}
### 四、总结
本文通过详细的步骤介绍了如何在STM32F103C8T6上使用HAL库进行串口通信，并展示了如何通过串口驱动蓝牙模块（HC-08）和WiFi模块（ESP8266）。这些技术为实现无线通信功能提供了坚实的基础，适用于各种嵌入式系统应用。