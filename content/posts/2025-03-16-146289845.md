---
layout: post
title: "Kotlin-inline函数特效"
date: 2025-03-16 07:05:36 +0800
description: "在 Kotlin 里，inline关键字主要用于内联函数与内联属性。"
keywords: "Kotlin-inline函数特效"
categories: ['Kotlin']
tags: ['开发语言', 'Kotlin', 'Android']
artid: "146289845"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146289845
    alt: "Kotlin-inline函数特效"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146289845
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146289845
cover: https://bing.ee123.net/img/rand?artid=146289845
image: https://bing.ee123.net/img/rand?artid=146289845
img: https://bing.ee123.net/img/rand?artid=146289845
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Kotlin-inline函数特效
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     在 Kotlin 里，
     <code>
      inline
     </code>
     关键字主要用于内联函数与内联属性。下面为你详细介绍：
    </p>
    <h4>
     内联函数
    </h4>
    <p>
     使用
     <code>
      inline
     </code>
     关键字修饰的函数，在编译时，
     <span style="color:#4da8ee">
      编译器会把函数调用处替换成函数体本身
     </span>
     ，
     <span style="color:#fe2c24">
      而不是常规的函数调用过程
     </span>
     。这样做的好处是能减少函数调用的开销，特别是在使用高阶函数时效果显著。
     <span style="color:#4da8ee">
      和C语言的宏替换有殊途同归。
     </span>
    </p>
    <pre><code class="language-Kotlin">    @Test
    fun main3() {
        inlineFun {
            println("hello")
        }
    }


    private inline fun inlineFun(call: () -&gt; Unit) {
        call.invoke()
    }
</code></pre>
    <h5>
     代码解释
    </h5>
    <ul>
     <li>
      当
      <code>
       inlineFun
      </code>
      被调用时，编译器会直接把
      <code>
       inlineFun
      </code>
      的函数体插入到调用处，避免了函数调用的开销。
     </li>
     <li>
      内联函数特别适合与 Lambda 表达式配合使用，因为 Lambda 表达式会带来额外的对象创建和调用开销，使用内联函数可以消除这些开销。
     </li>
    </ul>
    <h5>
     noinline
    </h5>
    <p>
     若内联函数里包含多个 Lambda 表达式参数，而你不希望所有的 Lambda 表达式都被内联，可以使用
     <code>
      noinline
     </code>
     关键字修饰不需要内联的 Lambda 表达式。
    </p>
    <pre><code>inline fun multipleLambda(block1: () -&gt; Unit, noinline block2: () -&gt; Unit) {
    block1()
    block2()
}</code></pre>
    <h4>
     适用场景
    </h4>
    <ul>
     <li>
      <strong>
       高阶函数
      </strong>
      ：当函数接收 Lambda 表达式作为参数时，使用内联函数可以避免 Lambda 表达式带来的额外开销。
     </li>
     <li>
      <strong>
       频繁调用的小函数
      </strong>
      ：对于一些经常被调用且函数体较小的函数，使用内联函数可以提高性能。
     </li>
    </ul>
    <h4>
     注意事项
    </h4>
    <ul>
     <li>
      内联函数会增加生成代码的大小，因为函数体被复制到每个调用处。所以，对于函数体较大的函数，不建议使用内联。
     </li>
     <li>
      内联函数不能包含非局部返回，除非 Lambda 表达式被标记为
      <code>
       crossinline
      </code>
     </li>
    </ul>
    <h4>
     非局部返回限制
    </h4>
    <ul>
     <li>
      <strong>
       默认情况
      </strong>
      ：内联函数中的 Lambda 表达式可以使用非局部返回（也就是直接从包含该 Lambda 表达式的函数中返回）。不过，这也带来了一定的限制。例如下面的代码：
     </li>
    </ul>
    <pre><code>fun main() {
    inlineFunction {
        println("执行 Lambda 表达式")
        return // 这里会直接从 main 函数返回
    }
    println("这行代码不会被执行")
}

inline fun inlineFunction(block: () -&gt; Unit) {
    block()
}</code></pre>
    <ul>
     <li>
      <strong>
       <code>
        crossinline
       </code>
       修饰符
      </strong>
      ：若不希望 Lambda 表达式中出现非局部返回，可以使用
      <code>
       crossinline
      </code>
      修饰符。示例如下：
     </li>
    </ul>
    <pre><code>inline fun inlineFunction(crossinline block: () -&gt; Unit) {
    val anotherBlock = {
        block()
    }
    anotherBlock()
}

fun main() {
    inlineFunction {
        println("执行 Lambda 表达式")
        // return  // 这里使用 return 会报错，因为 block 被 crossinline 修饰
    }
    println("这行代码会被执行")
}</code></pre>
    <h4>
     类型参数限制
    </h4>
    <p>
     内联函数的类型参数不能用作实际类型。也就是说，不能在运行时获取内联函数类型参数的实际类型。例如：
    </p>
    <pre><code>inline fun &lt;T&gt; printType() {
    // 这里不能获取 T 的实际类型
    // println(T::class)  // 这样写会报错
}</code></pre>
    <h4>
     4. 不支持私有和内部函数
    </h4>
    <p>
     内联函数通常不能是私有或内部函数
     <span style="color:#4da8ee">
      （除非它们是在类内部定义的，并且只在该类内部使用
     </span>
     ）。因为内联函数的代码会被复制到调用处，私有和内部函数的访问限制在这种情况下会变得难以处理。
    </p>
    <h4>
     5. 递归调用限制
    </h4>
    <p>
     内联函数不适合进行递归调用。因为内联函数会在编译时展开，如果进行递归调用，会导致代码无限膨胀，最终可能会导致编译错误或生成非常大的代码文件。例如：
    </p>
    <pre><code>inline fun recursiveInlineFunction(n: Int): Int {
    return if (n == 0) 1 else n * recursiveInlineFunction(n - 1)
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f7368616f6875617a756f2f:61727469636c652f64657461696c732f313436323839383435" class_="artid" style="display:none">
 </p>
</div>


