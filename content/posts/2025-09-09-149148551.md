---
layout: post
title: "贪心算法day7"
date: 2025-09-09T00:22:53+0800
description: "【贪心算法】day7：55. 跳跃游戏、134. 加油站、738. 单调递增的数字"
keywords: "【贪心算法】day7"
categories: ['未分类']
tags: ['贪心算法', '算法', 'Leetcode', 'C']
artid: "149148551"
arturl: "https://blog.csdn.net/tan_run/article/details/149148551"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=149148551
    alt: "贪心算法day7"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=149148551
featuredImagePreview: https://bing.ee123.net/img/rand?artid=149148551
cover: https://bing.ee123.net/img/rand?artid=149148551
image: https://bing.ee123.net/img/rand?artid=149148551
img: https://bing.ee123.net/img/rand?artid=149148551
---



# 【贪心算法】day7



📝前言说明：

* 本专栏主要记录本人的**贪心算法**学习以及LeetCode刷题记录，按专题划分
* 每题主要记录：（1）本人解法 + 本人屎山代码；（2）优质解法 + 优质代码；（3）精益求精，更好的解法和独特的思想（如果有的话）；（4）贪心策略正确性的 “证明”
* 文章中的理解仅为个人理解。如有错误，感谢纠错

> 🎬个人简介：努力学习ing  
>  📋本专栏：[C++刷题专栏](https://blog.csdn.net/tan_run/category_12917016.html)  
>  📋其他专栏：[C语言入门基础](https://blog.csdn.net/tan_run/category_12506809.html)，[python入门基础](https://blog.csdn.net/tan_run/category_12597882.html)，[C++学习笔记](https://blog.csdn.net/tan_run/category_12910423.html)，[Linux](https://blog.csdn.net/tan_run/category_12918758.html)  
>  🎀CSDN主页 [愚润泽](https://blog.csdn.net/tan_run?spm=1010.2135.3001.5421)

**你可以点击下方链接，进行其他贪心算法题目的学习**

| 点击链接 | 开始学习 |
| --- | --- |
| [贪心day1](https://blog.csdn.net/tan_run/article/details/149126061?spm=1011.2415.3001.5331) | [贪心day2](https://blog.csdn.net/tan_run/article/details/149148490?spm=1011.2415.3001.5331) |
| [贪心day3](https://blog.csdn.net/tan_run/article/details/149148503?spm=1011.2415.3001.5331) | [贪心day4](https://blog.csdn.net/tan_run/article/details/149148522?spm=1011.2415.3001.5331) |
| [贪心day5](https://blog.csdn.net/tan_run/article/details/149148529?spm=1011.2415.3001.5331) | [贪心day6](https://blog.csdn.net/tan_run/article/details/149148543?spm=1011.2415.3001.5331) |
| [贪心day7](https://blog.csdn.net/tan_run/article/details/149148551?spm=1011.2415.3001.5331) | [贪心day8](https://blog.csdn.net/tan_run/article/details/149148559?spm=1011.2415.3001.5331) |
| [贪心day9](https://blog.csdn.net/tan_run/article/details/149148568?spm=1011.2415.3001.5331) | [贪心day10](https://blog.csdn.net/tan_run/article/details/149148600?spm=1011.2415.3001.5331) |

**也可以点击下面连接，学习其他算法**

| 点击链接 | 开始学习 |
| --- | --- |
| [优选专题](https://blog.csdn.net/tan_run/category_12948755.html) | [动态规划](https://blog.csdn.net/tan_run/category_12960027.html) |
| [递归、搜索与回溯](https://blog.csdn.net/tan_run/category_12960031.html) | [贪心算法](https://blog.csdn.net/tan_run/category_12960040.html) |

---

## 55. 跳跃游戏

题目链接：<https://leetcode.cn/problems/jump-game/description/>  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fac1ca3a5d244150b129f8b2fcc80fa4.png)

### 个人解

思路：

* 和上一题一样

屎山代码：

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) 
    {
        int n = nums.size(), left = 0, right = 0;
        int maxpos = 0;
        while(left <= right && right < n) // 当还有 "起点"
        {
            for(int i = left; i <= right; i++)
                maxpos = max(maxpos, i + nums[i]);
            left = right + 1;
            right = maxpos;
        }
        if(maxpos < n - 1) return false;
        return true;
    }
};

```

**时间复杂度：
O
(
n
)
O(n)
O(n)  
 空间复杂度：
O
(
1
)
O(1)
O(1)**

---

## 134. 加油站

题目链接：<https://leetcode.cn/problems/gas-station/description/>  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cd2e3756167f477e8ee6e15ac21c42d5.png)

---

### 优质解

思路：

* 题目要求：**按顺序绕环路行驶一周**
* 暴力解法：枚举所有起点，从起点开始遍历一遍
* 贪心优化：如果从点`i`开始出发，走了`step`步以后，失败了，则代表`[i, i + step]`区间的点都不能作为起点（因为失败一定是下一步不够油了，区间内的所有点作为起点的时候原始油为`0`，更不够）

代码：

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        for(int i = 0; i < n; i++)
        {
            int step = 0;
            int res = 0;
            for(; step < n; step++)
            {
                int nxt = (i + step) % n; // 防止越界
                res = res + gas[nxt] - cost[nxt];
                if(res < 0)
                {
                    i = i + step; // 贪心优化
                    break;
                }
            }
            if(res >= 0) return i;
        }
        return -1;
    }
};

```

**时间复杂度：
O
(
n
)
O(n)
O(n)  
 空间复杂度：
O
(
1
)
O(1)
O(1)**

---

## 738. 单调递增的数字

题目链接：<https://leetcode.cn/problems/monotone-increasing-digits/description/>  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/182f0236a6ad4651a9a22dfc53e4895a.png)

### 优质解

思路：

* 暴力解法：从 `n` 开始枚举到 `0`，然后判断数字是否是递增的，如果是：即为得到的“最大”递增数
* 贪心策略（对于"原数"）：
  + 如果高位单调递增，则不去修改（因为我们是要找“最大数”，修改行为肯定是"该位减小"，极有可能破坏递增）
  + 当发现第一个“不递增”的位置时，无法通过增大后一位来实现“递增”（因为这时候比原来的数大了），只能降低本位，然后把后面的数全填`9`即可
    - 但是，如果修改位置的前一个位置与本位相同，修改后会破坏递增，此时，需要递归的往前调整（即：其实是修改这些连续相同数中的“第一个”数）
* （判断是否“递增”）技巧：
  + 转换成字符串，然后双指针
  + 用`%10` 和 `/10`

屎山代码：

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int m) {
        string s = to_string(m);
        int n = s.size();
        int i = 0;
        while(i < n - 1 && s[i] <= s[i + 1]) i++;
        if(i == n - 1) return m; // 特殊情况，不需要修改
        while(i - 1 >= 0 && s[i - 1] == s[i]) i--;
        s[i]--;
        for(int j = i + 1; j < n; j++) s[j]  = '9';
        return stoi(s);
    }
};

```

**时间复杂度：
O
(
n
)
O(n)
O(n)  
 空间复杂度：
O
(
n
)
O(n)
O(n)**

---

> 🌈我的分享也就到此结束啦🌈  
>  要是我的分享也能对你的学习起到帮助，那简直是太酷啦！  
>  若有不足，还请大家多多指正，我们一起学习交流！  
>  📢公主，王子：点赞👍→收藏⭐→关注🔍  
>  感谢大家的观看和支持！祝大家都能得偿所愿，天天开心！！！



