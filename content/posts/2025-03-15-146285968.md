---
layout: post
title: "图论并查集的学习和使用"
date: 2025-03-15 22:37:58 +0800
description: "并查集是一种树形的数据结构，一般用来处理集合的合并，查询操作。"
keywords: "【图论】并查集的学习和使用"
categories: ['C']
tags: ['算法', '学习', '图论']
artid: "146285968"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146285968
    alt: "图论并查集的学习和使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146285968
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146285968
cover: https://bing.ee123.net/img/rand?artid=146285968
image: https://bing.ee123.net/img/rand?artid=146285968
img: https://bing.ee123.net/img/rand?artid=146285968
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【图论】并查集的学习和使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" name="%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
     并查集是什么？
    </h2>
    <p>
     是一种树形的数据结构，一般用来处理集合的合并，查询操作。
    </p>
    <h2 id="%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90" name="%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90">
     举个例子
    </h2>
    <p>
     告诉你1的父节点是2 2的父节点是3 4的父节点是5 6没有父节点 那么可以画出
    </p>
    <p>
     <img alt="" height="1080" src="https://i-blog.csdnimg.cn/direct/c25b4e4b76b74fc1aa60f5a1525fcfd3.jpeg" width="1554"/>
    </p>
    <p>
     三个集合，或者说是树 。然后我们一般用并查集判断：①有几棵树 也就是有几个集合 ② 两个点是否同属于一个集合 ③一个点是不是属于这棵树
    </p>
    <h2 id="%E7%BB%84%E6%88%90" name="%E7%BB%84%E6%88%90">
     组成
    </h2>
    <p>
     主要是通过一个父亲数组和一个find函数、一个union函数实现的。
    </p>
    <h3 id="%E7%88%B6%E4%BA%B2%E6%95%B0%E7%BB%84%EF%BC%9A" name="%E7%88%B6%E4%BA%B2%E6%95%B0%E7%BB%84%EF%BC%9A">
     父亲数组：
    </h3>
    <p>
     记录一个节点的父结点 初始化为自己 也就是一开始自己就是自己的父结点 自己单独属于一个集合
    </p>
    <h3 id="find%E5%87%BD%E6%95%B0%EF%BC%9A" name="find%E5%87%BD%E6%95%B0%EF%BC%9A">
     find函数：
    </h3>
    <p>
     根据邻接关系 找到一个结点的根结点 如果两个结点的通过find函数寻找出来的结点相同 则同属一个集合
    </p>
    <h3 id="union%E5%87%BD%E6%95%B0%EF%BC%9A" name="union%E5%87%BD%E6%95%B0%EF%BC%9A">
     union函数：
    </h3>
    <p>
     遍历邻接关系时 将两个邻接的结点父亲数组更新的作用 具体来说 判断若两个结点通过find函数寻找出来的根节点不相同 也就是不属于一个集合 则将一个集合并入另一个集合 通过把前一个结点的根节点 的父亲数组 标记为第二个结点的根节点 则两个集合就合并了
    </p>
    <h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" name="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">
     代码实现：
    </h2>
    <h3 id="fa%5B%5D%20%E5%88%9D%E5%A7%8B%E5%8C%96code%3A" name="fa%5B%5D%20%E5%88%9D%E5%A7%8B%E5%8C%96code%3A">
     fa[] 初始化code:
    </h3>
    <pre><code class="language-cpp">for(int i=0;i&lt;n;++i)
       fa[i]=i;</code></pre>
    <h3 id="find%20code%EF%BC%9A" name="find%20code%EF%BC%9A">
     find code：
    </h3>
    <h4 id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%3A" name="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%3A">
     递归实现:
    </h4>
    <pre><code class="language-cpp">int finds(int a){
    if(a!=fa[a]){
        fa[a]=finds(fa[a]);
    }
    return fa[a];
}</code></pre>
    <h4 id="%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%3A" name="%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%3A">
     非递归实现:
    </h4>
    <pre><code class="language-cpp">int finds(int a){
    while(a!=fa[a]){
        a=fa[a];
    }
    return fa[a];
}</code></pre>
    <p>
     详细解释：一个结点 只有父结点是自己 也就是fa[]数组中是自己 才能称为根节点 finds函数就是判断一个结点是否为根结点 如果不是 就继续向上finds他的父节点 看是不是根结点 直到找到根节点 返回 这个根节点可以称之为一个集合的标志
    </p>
    <h3 id="union%20code%20%3A" name="union%20code%20%3A">
     union code :
    </h3>
    <pre><code class="language-cpp">void unions(int x,int y){
    int fx=finds(x);
    int fy=finds(y);
    if(fx!=fy){
        fa[fx]=fy;
    }
}</code></pre>
    <p>
     详细解释：unions函数是用于遍历邻接关系时 更新集合关系。传入两个结点 找到他们的根节点 也就是他们所属集合的标志 判断是否相同 也就是判断是否从属于一个集合 如果不属于一个集合 则把第一个集合的根节点 的父亲结点 更新为 第二个集合的根节点。也就是把第一个集合和第二个集合合并 并且根节点保留为第二个集合的根节点 。
    </p>
    <h2 id="%E7%94%BB%E5%9B%BE%E6%A8%A1%E6%8B%9F%EF%BC%9A" name="%E7%94%BB%E5%9B%BE%E6%A8%A1%E6%8B%9F%EF%BC%9A">
     画图模拟：
    </h2>
    <p>
     <img alt="" height="1554" src="https://i-blog.csdnimg.cn/direct/daa1321af2b5425c8c51401b360cdbfb.jpeg" width="1080">
      <img alt="" height="1554" src="https://i-blog.csdnimg.cn/direct/37a3fd5b52984813a53fd5e87c315b7d.jpeg" width="1080"/>
     </img>
    </p>
    <p>
     ①我们要判断两个点是否属于一个集合 只要用find函数即可
    </p>
    <p>
     ②我们要判断共有几个集合 只要看fa数组中有几个 i=fa[i]即可 因为fa[i]等于i 代表是集合里的根结点 一个集合只有一个根结点 所以根结点数即为集合数量
    </p>
    <h2 id="%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%EF%BC%9A" name="%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%EF%BC%9A">
     路径压缩：
    </h2>
    <p>
     可以观察到 每次调用find函数都需要经历一串长长的递归 这正是函数时间花费的地方 考虑优化的地方 我们可以直接把fa[i]数组标记为i结点所属集合的根节点 也就是把整条路径上的fa[i]数组都标记为根节点 按上面画图的例题来说 就是把fa[1] fa[3] fa[4] 全部标记为4 这样调用find函数的时候就特别快，一步到位。要想完成这个操作 只要在find函数后加一步 每次find的时候 找到了根节点的值 保存 再用一个while循环向上查找 把整条路径上的结点的fa[]值都更新为找到的根节点
    </p>
    <h3 id="%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9Code%EF%BC%9A" name="%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9Code%EF%BC%9A">
     路径压缩Code：
    </h3>
    <pre><code class="language-cpp">int new_finds(int a){
    int aa=a;//保存一下查找的点 也就是路径的底部
    if(a!=fa[a]){
        fa[a]=finds(fa[a]);//找到了根节点
    }
    while(aa!=fa[a]){//向上更新整条路径
        int temp=fa[aa];//先存储路径的下一个点
        fa[aa]=fa[a];//路径压缩一个
        aa=temp;//再压缩下一个点
        
    }
    return fa[a];
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36323333353632392f:61727469636c652f64657461696c732f313436323835393638" class_="artid" style="display:none">
 </p>
</div>


