---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333630333736382f:61727469636c652f64657461696c732f313436323037343233"
layout: post
title: "动态规划-第2篇"
date: 2025-03-12 20:15:08 +08:00
description: "在上一篇文章中，我们了解了动态规划的基本概念和解决问题的基本思路。通过分解问题、存储子问题的解，动态规划为我们提供了高效的解决方案。然而，动态规划并不是一成不变的，它有很多不同的技巧和变种，能够应对各类复杂问题。在本篇文章中，我们将深入探讨一些常见的动态规划问题及其解法，学习如何巧妙地设计状态转移方程，优化空间复杂度，并进一步掌握动态规划的核心思想。通过具体实例，你将能够更好地理解如何在实际开发中运用动态规划来解决复杂问题。🌼🌼。"
keywords: "动态规划-第2篇"
categories: ['Leetcode']
tags: ['算法', '动态规划', 'C']
artid: "146207423"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146207423
    alt: "动态规划-第2篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146207423
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146207423
cover: https://bing.ee123.net/img/rand?artid=146207423
image: https://bing.ee123.net/img/rand?artid=146207423
img: https://bing.ee123.net/img/rand?artid=146207423
---

# 动态规划-第2篇

> 前言：在上一篇文章中，我们了解了动态规划的基本概念和解决问题的基本思路。通过分解问题、存储子问题的解，动态规划为我们提供了高效的解决方案。然而，动态规划并不是一成不变的，它有很多不同的技巧和变种，能够应对各类复杂问题。
>
> 在本篇文章中，我们将深入探讨一些常见的动态规划问题及其解法，学习如何巧妙地设计状态转移方程，优化空间复杂度，并进一步掌握动态规划的核心思想。通过具体实例，你将能够更好地理解如何在实际开发中运用动态规划来解决复杂问题。🌼🌼

##### 7. 礼物的最⼤价值（medium）

###### 1. 题⽬链接： [LCR 166. 珠宝的最高价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/ "LCR 166. 珠宝的最高价值")

###### 2.解法（动态规划）：

算法思路：

1. 状态表⽰：

对于这种「路径类」的问题，我们的状态表⽰⼀般有两种形式：

i. 从 [i, j] 位置出发，巴拉巴拉；

ii. 从起始位置出发，到达 [i, j] 位置，巴拉巴拉。

这⾥选择第⼆种定义状态表⽰的⽅式：

**dp[i][j] 表⽰：⾛到 [i, j] 位置处，此时的最⼤价值。**

2. 状态转移⽅程：

对于 dp[i][j] ，我们发现想要到达 [i, j] 位置，有两种⽅式：

i. 从 [i, j] 位置的上⽅ [i - 1, j] 位置，向下⾛⼀步，此时到达 [i, j] 位置能

拿到的礼物价值为 dp[i - 1][j] + grid[i][j] ；

ii. 从 [i, j] 位置的左边 [i, j - 1] 位置，向右⾛⼀步，此时到达 [i, j] 位置能拿到的礼物价值为 dp[i][j -1] + grid[i][j]

我们要的是最⼤值，因此状态转移⽅程为：

**dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] 。**

3. 初始化：

可以在最前⾯加上⼀个「辅助结点」，帮助我们初始化。使⽤这种技巧要注意两个点：

i. 辅助结点⾥⾯的值要「保证后续填表是正确的」；

ii. 「下标的映射关系」。

在本题中，「添加⼀⾏」，并且「添加⼀列」后，所有的值都为 0 即可。

4. 填表顺序：

根据「状态转移⽅程」，填表的顺序是「从上往下填写每⼀⾏」，「每⼀⾏从左往右」。

5. 返回值：

根据「状态表⽰」，我们应该返回 dp[m][n] 的值。

###### 3.C++ 算法代码：

```cpp
class Solution {
public:
    int jewelleryValue(vector<vector<int>>& vv) {
         int m=vv.size();
        int n=vv[0].size();

        vector<vector<int>>dp(m+1,vector<int>(n+1));

        dp[0][0]=0;

        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                
                dp[i][j]=max(dp[i-1][j],dp[i][j-1])+vv[i-1][j-1];
            }
        }

        return dp[m][n];
    }
};
```

##### 8.下降路径最⼩和（medium）

###### 1. 题⽬链接： [931. 下降路径最小和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-falling-path-sum/ "931. 下降路径最小和 - 力扣（LeetCode）")

###### **2. 解法（动态规划）：**

算法思路：

关于这⼀类题，由于我们做过类似的，因此「状态表⽰」以及「状态转移」是⽐较容易分析出来的。

⽐较难的地⽅可能就是对于「边界条件」的处理。

1. 状态表⽰：

对于这种「路径类」的问题，我们的状态表⽰⼀般有两种形式：

i. 从 [i, j] 位置出发，到达⽬标位置有多少种⽅式；

ii. 从起始位置出发，到达 [i, j] 位置，⼀共有多少种⽅式

这⾥选择第⼆种定义状态表⽰的⽅式：

dp[i][j] 表⽰：到达 [i, j] 位置时，所有下降路径中的最⼩和。

2. 状态转移⽅程：

对于普遍位置 [i, j] ，根据题意得，到达 [i, j] 位置可能有三种情况： i. 从正上⽅ [i - 1, j] 位置转移到 [i, j] 位置；

ii. 从左上⽅ [i - 1, j - 1] 位置转移到 [i, j] 位置；

iii. 从右上⽅ [i - 1, j + 1] 位置转移到 [i, j] 位置；

我们要的是三种情况下的「最⼩值」，然后再加上矩阵在 [i, j] 位置的值。

于是
dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j]
。

3. 初始化：

**可以在最前⾯加上⼀个「辅助结点」，帮助我们初始化。使⽤这种技巧要注意两个点：**

i. 辅助结点⾥⾯的值要「保证后续填表是正确的」；

ii. 「下标的映射关系」。

在本题中，需要「加上⼀⾏」，并且「加上两列」。所有的位置都初始化为⽆穷⼤，然后将第⼀⾏

初始化为 0 即可。

4. 填表顺序：

根据「状态表⽰」，填表的顺序是「从上往下」。

5. 返回值：

注意这⾥不是返回 dp[m][n] 的值！

题⽬要求「只要到达最后⼀⾏」就⾏了，因此这⾥应该返回
「 dp 表中最后⼀⾏的最⼩值」
。

###### 3.C++ 算法代码

```cpp
class Solution
{
public:
int minFallingPathSum(vector<vector<int>>& matrix)
{
// 1. 创建 dp 表
// 2. 初始化
// 3. 填表
// 4. 返回结果
int n = matrix.size();
vector<vector<int>> dp(n + 1, vector<int>(n + 2, INT_MAX));
// 初始化第⼀⾏
for(int j = 0; j < n + 2; j++) dp[0][j] = 0;

for(int i = 1; i <= n; i++)
for(int j = 1; j <= n; j++)
dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i - 1][j
+ 1])) + matrix[i - 1][j - 1];
int ret = INT_MAX;
for(int j = 1; j <= n; j++)
ret = min(ret, dp[n][j]);
return ret;
}
}
```

##### 9. 最⼩路径和（medium）

###### 1.题目链接： [64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/description/ "64. 最小路径和 - 力扣（LeetCode）")

###### 2.  解法（动态规划）：

算法思路：

像这种表格形式的动态规划，是⾮常容易得到「状态表⽰」以及「状态转移⽅程」的，可以归结到

「不同路径」⼀类的题⾥⾯。

1. 状态表⽰：

对于这种路径类的问题，我们的状态表⽰⼀般有两种形式：

i. 从 [i, j] 位置出发，巴拉巴拉；

ii. 从起始位置出发，到达 [i, j] 位置，巴拉巴拉。

这⾥选择第⼆种定义状态表⽰的⽅式：

dp[i][j] 表⽰：到达 [i, j] 位置处，最⼩路径和是多少。

2. 状态转移：

简单分析⼀下。如果 dp[i][j] 表⽰到达 到达 [i, j] 位置处的最⼩路径和，那么到达 [i, j] 位置之前的⼀⼩步，有两种情况：

i. 从 [i - 1, j] 向下⾛⼀步，转移到 [i, j] 位置；

ii. 从 [i, j - 1] 向右⾛⼀步，转移到 [i, j] 位置。

由于到 [i, j] 位置两种情况，并且我们要找的是最⼩路径，因此只需要这两种情况下的最⼩值，再加上 [i, j] 位置上本⾝的值即可。

也就是：
**dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]**

3. 初始化：

可以在最前⾯加上⼀个「辅助结点」，帮助我们初始化。使⽤这种技巧要注意两个点：

i. 辅助结点⾥⾯的值要「保证后续填表是正确的」；

ii. 「下标的映射关系」。

在本题中，「添加⼀⾏」，并且「添加⼀列」后，所有位置的值可以初始化为⽆穷⼤，然后让 dp[0][1] = dp[1][0] = 1 即可。

4. 填表顺序：

根据「状态转移⽅程」的推导来看，填表的顺序就是「从上往下」填每⼀⾏，每⼀⾏「从左往

后」。

5. 返回值：

根据「状态表⽰」，我们要返回的结果是 dp[m][n] 。

###### 3.C++ 算法代码：

```cpp
class Solution
{
public:
int minPathSum(vector<vector<int>>& grid)
{
// 1. 创建 dp 表
// 2. 初始化
// 3. 填表
// 4. 返回结果
int m = grid.size(), n = grid[0].size();
vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
dp[0][1] = dp[1][0] = 0;
for(int i = 1; i <= m; i++)
for(int j = 1; j <= n; j++)
dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j -
1];
return dp[m][n];
}
}
```

##### 10. 地下城游戏（hard）

###### 1. 题⽬链接： [174. 地下城游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/dungeon-game/description/ "174. 地下城游戏 - 力扣（LeetCode）")

###### 2. 解法（动态规划）：

算法思路：

1. 状态表⽰：

这道题如果我们定义成：从起点开始，到达 [i, j] 位置的时候，所需的最低初始健康点数。那么我们分析状态转移的时候会有⼀个问题：那就是我们当前的健康点数还会受到后⾯的路径的影响。也就是从上往下的状态转移不能很好地解决问题。

这个时候我们要换⼀种状态表⽰：从 [i, j] 位置出发，到达终点时所需要的最低初始健康点

数。这样我们在分析状态转移的时候，后续的最佳状态就已经知晓。

综上所述，定义状态表⽰为：

dp[i][j] 表⽰：从 [i, j] 位置出发，到达终点时所需的最低初始健康点数。

2. 状态转移⽅程：

对于 dp[i][j] ，从 [i, j] 位置出发，下⼀步会有两种选择（为了⽅便理解，设 dp[i] [j] 的最终答案是 x）：

i. ⾛到右边，然后⾛向终点

那么我们在 [i, j] 位置的最低健康点数加上这⼀个位置的消耗，应该要⼤于等于右边位置的最低健康点数，也就是： x + dungeon[i][j] >= dp[i][j + 1] 。

通过移项可得： x >= dp[i][j + 1] - dungeon[i][j] 。因为我们要的是最⼩值，因此这种情况下的 x = dp[i][j + 1] - dungeon[i][j] ；

ii. ⾛到下边，然后⾛向终点

那么我们在 [i, j] 位置的最低健康点数加上这⼀个位置的消耗，应该要⼤于等于下边位置的最低健康点数，也就是： x + dungeon[i][j] >= dp[i + 1][j] 。

通过移项可得： x >= dp[i + 1][j] - dungeon[i][j] 。因为我们要的是最⼩值，因此这种情况下的 x = dp[i + 1][j] - dungeon[i][j] ；

综上所述，我们需要的是两种情况下的最⼩值，因此可得状态转移⽅程为：

dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]

但是，如果当前位置的 dungeon[i][j] 是⼀个⽐较⼤的正数的话， dp[i][j] 的值可能变

成 0 或者负数。也就是最低点数会⼩于 1 ，那么骑⼠就会死亡。因此我们求出来的

如果⼩于等于 0 的话，说明此时的最低初始值应该为 1 。处理这种情况仅需让  dp[i] [j]  与  1  取⼀个最⼤值即可：

dp[i][j] = max(1, dp[i][j])

3. 初始化：

可以在最前⾯加上⼀个「辅助结点」，帮助我们初始化。使⽤这种技巧要注意两个点：

i. 辅助结点⾥⾯的值要「保证后续填表是正确的」；

ii. 「下标的映射关系」。

在本题中，在 dp 表最后⾯添加⼀⾏，并且添加⼀列后，
**所有的值都先初始化为⽆穷⼤，然后让 dp[m][n - 1] = dp[m - 1][n] = 1 即可。**

4. 填表顺序：

根据「状态转移⽅程」，
我们需要「从下往上填每⼀⾏」，「每⼀⾏从右往左」
。

5. 返回值：

根据「状态表⽰」，
**我们需要返回 dp[0][0] 的值。**

###### 3.C++ 算法代码：

```cpp
class Solution
{
public:
int calculateMinimumHP(vector<vector<int>>& dungeon)
{
int m = dungeon.size(), n = dungeon[0].size();
// 建表 + 初始化
vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
dp[m][n - 1] = dp[m - 1][n] = 1;
// 填表
for(int i = m - 1; i >= 0; i--)
for(int j = n - 1; j >= 0; j--)
{
dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
dp[i][j] = max(1, dp[i][j]);
}
// 返回结果
return dp[0][0];
}
}
```

**简单多状态 dp 问题**

##### 11. 按摩师（easy）

打家劫舍问题的变形~ ⼩偷变成了按摩师

###### 1. 题⽬链接： [面试题 17.16. 按摩师](https://leetcode.cn/problems/the-masseuse-lcci/ "面试题 17.16. 按摩师")

###### 2. 解法（动态规划）：

算法思路：

1. 状态表⽰：

对于简单的线性 dp ，我们可以⽤「经验 + 题⽬要求」来定义状态表⽰：

i. 以某个位置为结尾，巴拉巴拉；

ii. 以某个位置为起点，巴拉巴拉。

这⾥我们选择⽐较常⽤的⽅式，以某个位置为结尾，结合题⽬要求，定义⼀个状态表⽰：

dp[i] 表⽰：选择到 i 位置时，此时的最⻓预约时⻓。

但是我们这个题在 i 位置的时候，会⾯临「选择」或者「不选择」两种抉择，所依赖的状态需要

细分：

▪ f[i] 表⽰：选择到 i 位置时， nums[i] 必选，此时的最⻓预约时⻓；

▪ g[i] 表⽰：选择到 i 位置时， nums[i] 不选，此时的最⻓预约时⻓。

2. 状态转移⽅程：

因为状态表⽰定义了两个，因此我们的状态转移⽅程也要分析两个：

对于 f[i] ：

▪ 如果 nums[i] 必选，那么我们仅需知道 i - 1 位置在不选的情况下的最⻓预约时⻓，

然后加上 nums[i] 即可，因此
**f[i] = g[i - 1] + nums[i] 。**

对于 g[i] ：

▪ 如果 nums[i] 不选，那么 i - 1 位置上选或者不选都可以。因此，我们需要知道 i置上选或者不选两种情况下的最⻓时⻓，因此
**g[i] = max(f[i - 1], g[i])**

3. 初始化：

这道题的初始化⽐较简单，因此⽆需加辅助节点，仅需初始化
f[0] = nums[0], g[0] = 0即可
。

4. 填表顺序

根据「状态转移⽅程」得「从左往右，两个表⼀起填」。

5. 返回值

根据「状态表⽰」，应该返回
**max(f[n - 1], g[n - 1]) 。**

###### 3.C++ 算法代码：

```cpp
class Solution {
public:
int massage(vector<int>& nums) {
// 1. 创建⼀个 dp 表
// 2. 初始化
// 3. 填表
// 4. 返回值
int n = nums.size();
if(n == 0) return 0; // 处理边界条件
vector<int> f(n);
auto g = f;
f[0] = nums[0];
for(int i = 1; i < n; i++)
{
f[i] = g[i - 1] + nums[i];
g[i] = max(f[i - 1], g[i - 1]);
}
return max(f[n - 1], g[n - 1]);
}
};
```

##### 12. 打家劫舍II （medium）

###### 1.题目链接： [213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/ "213. 打家劫舍 II - 力扣（LeetCode）")

###### 2. 解法（动态规划）

算法思路：

这⼀个问题是「打家劫舍I」问题的变形。

上⼀个问题是⼀个「单排」的模式，这⼀个问题是⼀个「环形」的模式，也就是⾸尾是相连的。但

是我们可以将「环形」问题转化为「两个单排」问题：

a. 偷第⼀个房屋时的最⼤⾦额 x ，此时不能偷最后⼀个房⼦，因此就是偷 [0, n - 2] 区间的房⼦；

b. 不偷第⼀个房屋时的最⼤⾦额 y ，此时可以偷最后⼀个房⼦，因此就是偷 [1, n - 1] 区间的房⼦；

两种情况下的「最⼤值」，就是最终的结果。

因此，问题就转化成求「两次单排结果的最⼤值」

###### 3. C++算法代码：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) 
    {
     int n=nums.size();

     int f1=test(nums,2,n-2)+nums[0];//第一个偷的话

     int g1=test(nums,1,n-1);//第一个不偷的话

     return max(f1,g1);

    }

    int test(vector<int>& nums,int left,int right)//与按摩问题一样
    {
        if(left>right)
          return 0;

        int n=nums.size();

        vector<int> f(n);
        f[left]=nums[left];

        auto g=f;
        g[left]=0;

        for(int i=left+1;i<=right;i++)
        {
            f[i]=g[i-1]+nums[i];

            g[i]=max(f[i-1],g[i-1]);
        }
        return max(f[right],g[right]);
    }
};
```