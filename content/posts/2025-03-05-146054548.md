---
layout: post
title: "PTA-L2一些题目"
date: 2025-03-05 23:12:49 +0800
description: "那么，我们如果让每条轨道尽可能长就能保证轨道数最少------也就是说，我们要尽可能的找最长降序序列。给出两个点后，我们先把其中一个的所有祖先全部找到，然后再找另一个的祖先，如果这个后者的其中一个祖先在前者的祖先中被访问到了，且不超过5步的话，那麽就是有血缘关系的。注意到，找最长降序序列的时候，我们是8-4-2-1、5-3、9-6、7，现在这个数能放那个就放哪个，尽可能往前面找，如果都放不了就新开一个。写懵了，这里代码看个乐子就行，纯翻译题面。水题，排个序，然后前缀和，左右两部分做差就行。"
keywords: "PTA L2一些题目"
categories: ['未分类']
tags: ['数据结构']
artid: "146054548"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146054548
    alt: "PTA-L2一些题目"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146054548
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146054548
cover: https://bing.ee123.net/img/rand?artid=146054548
image: https://bing.ee123.net/img/rand?artid=146054548
img: https://bing.ee123.net/img/rand?artid=146054548
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     PTA L2一些题目
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805063166312448&amp;page=1" rel="nofollow" title="L2-014 列车调度 - 团体程序设计天梯赛-练习集">
      L2-014 列车调度 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     样例是怎么来的呢？通过题目我们知道每一条轨道的车牌号必须是依次递减的。那么，我们如果让每条轨道尽可能长就能保证轨道数最少------也就是说，我们要尽可能的找最长降序序列。
    </p>
    <p>
     但是1e5数据量还是太大了，暴力找会超时。
    </p>
    <p>
     注意到，找最长降序序列的时候，我们是8-4-2-1、5-3、9-6、7，现在这个数能放那个就放哪个，尽可能往前面找，如果都放不了就新开一个
    </p>
    <p>
     于是，考虑二分，找现在所有轨道队尾车牌号大于当前车牌号的那条。可以分析出队尾车牌号是单调的
    </p>
    <pre><code class="language-cpp">int n,a[N];
vector &lt;int&gt; vec;
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        int p = lower_bound(vec.begin(),vec.end(),a[i])-vec.begin();
        if(p==vec.size()) vec.pb(a[i]);
        else vec[p] = a[i];
    }
    cout&lt;&lt;vec.size()&lt;&lt;endl;
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805062432309248&amp;page=1" rel="nofollow" title="L2-015 互评成绩 - 团体程序设计天梯赛-练习集">
      L2-015 互评成绩 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     模拟水题，大一在学c的时候就做过（）
    </p>
    <pre><code class="language-cpp">int n,k,m;
vector  &lt;double&gt; ans;
void solve()
{
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        vector &lt;double&gt; tmp;
        for(int j = 0;j&lt;k;j++)
        {
            double x;
            cin&gt;&gt;x;
            tmp.push_back(x);
        }
        sort(tmp.begin(),tmp.end());
        double sum=0;
        for(int j=1;j&lt;=k-2;j++)
        {
            sum+=tmp[j];
        }
        ans.push_back(sum/(1.0*(k-2)));
    }
    sort(ans.begin(),ans.end());
    for(int i=ans.size()-m;i&lt;ans.size();i++)
    {
        printf("%.3f",ans[i]);
        if(i&lt;ans.size()-1) cout&lt;&lt;" ";
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805061769609216&amp;page=1" rel="nofollow" title="L2-016 愿天下有情人都是失散多年的兄妹 - 团体程序设计天梯赛-练习集">
      L2-016 愿天下有情人都是失散多年的兄妹 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     看似并查集实则不然，是类似于树求深度
    </p>
    <p>
     给出两个点后，我们先把其中一个的所有祖先全部找到，然后再找另一个的祖先，如果这个后者的其中一个祖先在前者的祖先中被访问到了，且不超过5步的话，那麽就是有血缘关系的
    </p>
    <p>
     坑点是要记录一下父母的性别（）
    </p>
    <pre><code class="language-cpp">int head[N], IDX = 0;struct NODE{int t, ne, w=0;}ed[N];
void add(int s,int t){
    ed[++IDX].ne = head[s]; ed[IDX].t = t; head[s] = IDX;
    //ed[IDX].w = w;
}
int n;
bool sx[N];
map &lt;int,bool&gt; vis;
bool dfs(int now,int st)
{
    if(st&gt;5)
    {
        return 0;
    }
    bool f=0;
    if(vis[now]==1)
    {
        return 1;
    }
    vis[now]=1;
    for(int i=head[now];i;i=ed[i].ne)
    {
        int t = ed[i].t;
        f=dfs(t,st+1);
        if(f==1) break;
    }
    return f;
}
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        int a,c,d;
        char b;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
        sx[a] = (b=='M');
        if(c!=-1) add(a,c),sx[c]=1;//傻逼
        if(d!=-1) add(a,d);
    }
    int q;
    cin&gt;&gt;q;

    while(q--)
    {
        int a,b;
        vis.clear();
        cin&gt;&gt;a&gt;&gt;b;
        if(sx[a]==sx[b])
        {
            cout&lt;&lt;"Never Mind"&lt;&lt;endl;
            continue;
        }
        dfs(a,1);
        if(dfs(b,1))
        {
            cout&lt;&lt;"No"&lt;&lt;endl;
        }
        else
        {
            cout&lt;&lt;"Yes"&lt;&lt;endl;
        }
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805061056577536&amp;page=1" rel="nofollow" title="L2-017 人以群分 - 团体程序设计天梯赛-练习集">
      L2-017 人以群分 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     水题，排个序，然后前缀和，左右两部分做差就行
    </p>
    <pre><code class="language-cpp">int n,a[N];
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
    }
    sort(a+1,a+n+1);
    for(int i=1;i&lt;=n;i++)
    {
        a[i] += a[i-1];
    }
    printf("Outgoing #: %d\n",n/2+n%2);
    printf("Introverted #: %d\n",n/2);
    printf("Diff = %d",a[n]-a[n/2]*2);
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805059731177472&amp;page=1" rel="nofollow" title="L2-019 悄悄关注 - 团体程序设计天梯赛-练习集">
      L2-019 悄悄关注 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     模拟水题
    </p>
    <pre><code class="language-cpp">int n,m;
typedef pair&lt;string,int&gt;PSI;
map&lt;string ,int&gt; hs;
PSI a[N];
bool cmp(string a,string b)
{
    return a&lt;b;
}
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        string s;
        cin&gt;&gt;s;
        hs[s]++;
    }
    cin&gt;&gt;m;
    int ave=0;
    for(int i=1;i&lt;=m;i++)
    {
        cin&gt;&gt;a[i].fi&gt;&gt;a[i].se;
        ave+=a[i].se;
    }
    ave/=m;
    vector&lt;string&gt;ans;
    for(int i=1;i&lt;=m;i++)
    {
        if(hs[a[i].fi]==0 &amp;&amp; a[i].se&gt;ave)
        {
            ans.pb(a[i].fi);
        }
    }
    sort(ans.begin(),ans.end(),cmp);
    if(ans.size()==0)
    {
        cout&lt;&lt;"Bing Mei You"&lt;&lt;endl;
    }
    else
    {
        for(auto it : ans)
        {
            cout&lt;&lt;it&lt;&lt;endl;
        }
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805059118809088&amp;page=1" rel="nofollow" title="L2-020 功夫传人 - 团体程序设计天梯赛-练习集">
      L2-020 功夫传人 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     建出一棵树，叶子节点的权值要在削减传下来后乘倍数。注意精度
    </p>
    <pre><code class="language-cpp">int head[N], IDX = 0;struct NODE{int t, ne, w=0;}ed[N];
void add(int s,int t){
    ed[++IDX].ne = head[s]; ed[IDX].t = t; head[s] = IDX;
    //ed[IDX].w = w;
}
int n;
double k1,r;
double fd[N],wg[N];
void dfs(int now,double v)
{
    if(fd[now]&gt;0)
    {
        wg[now] = v*fd[now];
        return ;
    }
    wg[now] = v;
    for(int i=head[now];i;i=ed[i].ne)
    {
        int t = ed[i].t;
        dfs(t,v*(100.0-r)/100.0);
    }
}
void solve()
{
    cin&gt;&gt;n&gt;&gt;k1&gt;&gt;r;
    for(int i=0;i&lt;n;i++)
    {
        int k;
        cin&gt;&gt;k;
        if(k==0)
        {
            cin&gt;&gt;fd[i];
        }
        else
        {
            for(int j=1;j&lt;=k;j++)
            {
                int x;
                cin&gt;&gt;x;
                add(i,x);
            }
        }
    }

    dfs(0,k1);
    double sum=0;
    for(int i=0;i&lt;n;i++)
    {
        if(fd[i]&gt;0)
        {
            sum+=wg[i];
        }
    }
    printf("%.0f",floor(sum));
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805058485469184&amp;page=1" rel="nofollow" title="L2-021 点赞狂魔 - 团体程序设计天梯赛-练习集">
      L2-021 点赞狂魔 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     模拟
    </p>
    <pre><code class="language-cpp">int n,a;
string name[105];
long long sum[105],ave[105];
int srank[105],averank[105];
int cmp1(long long x,long long y)
{
    if(sum[x]!=sum[y])
    {
        return sum[x]&gt;sum[y];
    }
    else if(ave[x]!=ave[y])
    {
        return ave[x]&lt;ave[y];
    }
}
set &lt;int&gt; s;
int main()
{
    int n,k;
    int i,j;
    long long total;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;name[i]&gt;&gt;k;
        srank[i]=i;averank[i]=i;
        total=0;
        for(j=0;j&lt;k;j++)
        {
            cin&gt;&gt;a;s.insert(a);
        }

        sum[i]=s.size();
        ave[i]=k;
        s.clear();
    }
    sort(srank+1,srank+n+1,cmp1);
    //sort(averank+1,averank+n+1,cmp1);
    if(n&gt;=3)
    {
        for(i=1;i&lt;=2;i++)
        {
            cout&lt;&lt;name[srank[i]]&lt;&lt;' ';
        }
        cout&lt;&lt;name[srank[3]]&lt;&lt;endl;
    }
    else
    {
        for(i=1;i&lt;=3;i++)
        {
            if(i&lt;=n)cout&lt;&lt;name[srank[i]]&lt;&lt;' ';
            else
            {
                if(i!=3)
                cout&lt;&lt;'-'&lt;&lt;' ';
            }
            if(i==3)
            {
                cout&lt;&lt;'-'&lt;&lt;endl;
            }
        }
    }
}
</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805057860517888&amp;page=1" rel="nofollow" title="L2-022 重排链表 - 团体程序设计天梯赛-练习集">
      L2-022 重排链表 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     很有意思的一道题，有了上次的教训我们应在所有结点都输入完后再处理前驱。
    </p>
    <p>
     使用一个数组记录每个地址在当前链表中的位置，每次插入只需要从两边往中间交换即可，可以证明每次插入不会影响其他节点的相对位置
    </p>
    <pre><code class="language-cpp">int n,k1;
int kv[N],ne[N],pre[N];
int p[N];
int cnt ;
void dfs(int now,int idx)//处理前驱
{
    if(now == -1) return;
    cnt = max(cnt,idx);
    pre[ne[now]] = now;
    p[idx] = now;
    dfs(ne[now],idx+1);
}
void ist(int a,int b)//b插到a前面
{
    int ka = p[a];
    int kb = p[b];
    if(pre[ka]==-1)
    {
        k1 = kb;
    }
    ne[pre[kb]] = ne[kb];
    ne[pre[ka]] = kb;
    pre[ka] = kb;
    pre[kb] = pre[ka];
    ne[kb] = ka;
}
void dfs1(int now)输出新链表
{
    if(now == -1)
    {
        return ;
    }
    //cout&lt;&lt;now&lt;&lt;' '&lt;&lt;kv[now]&lt;&lt;' '&lt;&lt;ne[now]&lt;&lt;endl;
    printf("%05d %d ",now,kv[now]);
    if(ne[now]!=-1)
    {
        printf("%05d\n",ne[now]);
    }
    else
    {
        printf("-1\n");
    }
    dfs1(ne[now]);
}
void solve()
{
    cin&gt;&gt;k1&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        kv[a] = b;
        ne[a] = c;
    }
    pre[k1] = -1;
    dfs(k1,1);
    int l=1,r=cnt;
    //cout&lt;&lt;cnt&lt;&lt;endl;
    while(l&lt;r)
    {
        //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;
        //cout&lt;&lt;p[l]&lt;&lt;' '&lt;&lt;p[r]&lt;&lt;endl;
        ist(l,r);
        //dfs(k1,1);
        //dfs1(k1);
        l++,r--;
        //cout&lt;&lt;endl;
    }
    dfs1(k1);
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805057298481152&amp;page=1" rel="nofollow" title="L2-023 图着色问题 - 团体程序设计天梯赛-练习集">
      L2-023 图着色问题 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     使用链式前向星，实际上建单向图就可以，无向图疑似会tle（）。
    </p>
    <p>
     对于每个方案，遍历每一个点的相邻点，只要有一组有相同颜色就不行
    </p>
    <pre><code class="language-cpp">int head[N], IDX = 0;struct NODE{int t, ne, w=0;}ed[N];
void add(int s,int t){
    ed[++IDX].ne = head[s]; ed[IDX].t = t; head[s] = IDX;
    //ed[IDX].w = w;
}
int v,e,k;
int c[N];
void solve()
{
    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;
    for(int i=1;i&lt;=e;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
    }
    int q;cin&gt;&gt;q;
    set&lt;int&gt;st;
    while(q--)
    {
        st.clear();
        for(int i=1;i&lt;=v;i++) cin&gt;&gt;c[i],st.emplace(c[i]);
        if(st.size()!=k)
        {
            cout&lt;&lt;"No"&lt;&lt;endl;
            continue;
        }
        bool f=1;
        for(int i=1;i&lt;=v;i++)
        {
            for(int j=head[i];j;j=ed[j].ne)
            {
                int t=ed[j].t;
                if(c[i] == c[t])
                {
                    f=0;
                    break;
                }
            }
            if(f==0) break;
        }
        cout&lt;&lt;(f?"Yes":"No")&lt;&lt;endl;
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805056736444416&amp;page=1" rel="nofollow" title="L2-024 部落 - 团体程序设计天梯赛-练习集">
      L2-024 部落 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     ？并查集板子
    </p>
    <p>
     统计人数用个set存就行。每一个圈子的每一个人都只需要与第一个人合并即可
    </p>
    <pre><code class="language-cpp">int FA[N];
int _fi(int x){return (FA[x] == x) ? x : FA[x] = _fi(FA[x]);}
void uni(int x, int y){int xx = _fi(x), yy = _fi(y);if (xx != yy) FA[xx] = yy;}
int n;
set&lt;int&gt;st;
int a[N];
void solve()
{
    for(int i=1;i&lt;=10000;i++)
    {
        FA[i] = i;
    }
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        int k;
        cin&gt;&gt;k;
        for(int j=1;j&lt;=k;j++)
        {
            cin&gt;&gt;a[j];
            uni(a[j],a[1]);
            st.emplace(a[j]);
        }
    }
    int q,cnt=0;
    for(int i=1;i&lt;=st.size();i++)
    {
        if(_fi(i) == i )
        {
            cnt++;
        }
    }
    cout&lt;&lt;st.size()&lt;&lt;' '&lt;&lt;cnt&lt;&lt;endl;
    cin&gt;&gt;q;
    while(q--)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(_fi(a) == _fi(b))
        {
            cout&lt;&lt;"Y"&lt;&lt;endl;
        }
        else
        {
            cout&lt;&lt;"N"&lt;&lt;endl;
        }
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805056195379200&amp;page=1" rel="nofollow" title="L2-025 分而治之 - 团体程序设计天梯赛-练习集">
      L2-025 分而治之 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     跟上面图着色问题差不多，这里只需要判断每个还存在的点有没有相邻点即可
    </p>
    <pre><code class="language-cpp">int head[N], IDX = 0;struct NODE{int t, ne, w=0;}ed[N];
void add(int s,int t){
    ed[++IDX].ne = head[s]; ed[IDX].t = t; head[s] = IDX;
    //ed[IDX].w = w;
}
int n,m,k;
map &lt;int ,bool&gt; hs;
void solve()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
        add(b,a);
    }
    cin&gt;&gt;k;
    while(k--)
    {
        hs.clear();
        int u;
        cin&gt;&gt;u;
        for(int i=1;i&lt;=u;i++)
        {
            int x;
            cin&gt;&gt;x;
            hs[x] = 1;
        }
        bool f = 1;
        for(int i=1;i&lt;=n;i++)
        {
            if(!hs[i])
            {
                for(int j=head[i];j;j=ed[j].ne)
                {
                    int t = ed[j].t;
                    if(!hs[t])
                    {
                        f=0;
                        break;
                    }
                }
                if(!f) break;
            }
        }
        cout&lt;&lt;(f?"YES":"NO")&lt;&lt;endl;
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805055679479808&amp;page=1" rel="nofollow" title="L2-026 小字辈 - 团体程序设计天梯赛-练习集">
      L2-026 小字辈 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     建树求高度
    </p>
    <pre><code class="language-cpp">void add(int s,int t)
{
    ed[++idx].ne = head[s];
    ed[idx].t = t;
    head[s] = idx;
}
int n;
int a[N];
int deep=0,dp[N],root;
void dfs(int now,int d)
{
    dp[now] = d;
    deep = max(deep,d);
    for(int i=head[now];i;i=ed[i].ne)
    {
        int t = ed[i].t;
        dfs(t,d+1);
    }
}
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        if(a[i]==-1)
        {
            root = i;
        }
        else
            add(a[i],i);
    }
    dfs(root,1);
    cout&lt;&lt;deep&lt;&lt;endl;
    vector &lt;int&gt; ans;
    for(int i=1;i&lt;=n;i++)
    {
        if(dp[i] == deep)
        {
            ans.push_back(i);
        }
    }
    for(int i=0;i&lt;ans.size();i++)
    {
        cout&lt;&lt;ans[i];
        if(i&lt;ans.size()-1) cout&lt;&lt;' ';
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805055176163328&amp;page=1" rel="nofollow" title="L2-027 名人堂与代金券 - 团体程序设计天梯赛-练习集">
      L2-027 名人堂与代金券 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     模拟，最后输出的时候注意一下名次就行
    </p>
    <pre><code class="language-cpp">int n,g,k;
typedef pair&lt;string,int&gt; PSI;
vector &lt;PSI&gt; vec,ans;
int sum = 0;
bool cmp(PSI x,PSI y)
{
    if(x.se==y.se)
    {
        return x.fi&lt;y.fi;
    }
    else
    {
        return x.se&gt;y.se;
    }
}
void solve()
{
    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;
    for(int i=1;i&lt;=n;i++)
    {
        string s;
        int sc;
        cin&gt;&gt;s&gt;&gt;sc;
        vec.pb({s,sc});
        if(sc&gt;=60 &amp;&amp; sc&lt;g) sum+=20;
        else if(sc&gt;=g) sum+=50;
    }
    cout&lt;&lt;sum&lt;&lt;endl;
    sort(vec.begin(),vec.end(),cmp);
    int p=1,cnt=1;
    for(int i=0;i&lt;vec.size();i++)
    {
        cout&lt;&lt;p&lt;&lt;' '&lt;&lt;vec[i].fi&lt;&lt;' '&lt;&lt;vec[i].se&lt;&lt;endl;
        cnt++;
        if(i&lt;vec.size()-1&amp;&amp;vec[i+1].se&lt;vec[i].se) p=cnt;
        if(p&gt;k) break;
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805054698012672&amp;page=1" rel="nofollow" title="L2-028 秀恩爱分得快 - 团体程序设计天梯赛-练习集">
      L2-028 秀恩爱分得快 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     很牛逼的模拟题，光是数据处理就很头疼。用邻接表（？）存一下每两个点之间的亲密度
    </p>
    <p>
     后面就按题意处理即可
    </p>
    <pre><code class="language-cpp">int n,m,a,b;
double mp[1005][1005];
bool sx[N];
int kk[N];
typedef pair&lt;int,double&gt; PID;
vector &lt;PID&gt; va,vb;
bool cmp(PID x,PID y)
{
    if(abs(x.se-y.se)&lt;1e-9)
    {
        return x.fi&lt;x.fi;
    }
    else
    {
        return x.se&gt;y.se;
    }
}
void solve()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    {
        int k;
        cin&gt;&gt;k;
        double add = 1.0/k;
        for(int j=1;j&lt;=k;j++)
        {
            string s;
            cin&gt;&gt;s;
            int id = abs(stoi(s));
            kk[j] = id;
            if(s[0] != '-')
            {
                sx[id] = 1;
            }
        }
        for(int j=1;j&lt;=k;j++)
        {
            for(int jj=j+1;jj&lt;=k;jj++)
            {
                mp[kk[j]][kk[jj]] += add;
                mp[kk[jj]][kk[j]] += add;
            }
        }
    }
    string sa,sb;
    cin&gt;&gt;sa&gt;&gt;sb;
    a = abs(stoi(sa));
    b = abs(stoi(sb));
    sx[a] = (sa[0]!='-');
    sx[b] = (sb[0]!='-');
    double now = mp[a][b];
    double topa=0,topb=0;
    for(int i=0;i&lt;n;i++)
    {
        if(sx[a]!=sx[i])
        {
            va.pb({i,mp[a][i]});
            topa = max(topa,mp[a][i]);
        }
        if(sx[b]!=sx[i])
        {
            vb.pb({i,mp[b][i]});
            topb = max(topb,mp[b][i]);
        }
    }
    if(topa == topb &amp;&amp; topa == now)
    {
        if(sx[a]==0)
        cout&lt;&lt;'-'&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;endl;
        else
        {
            cout&lt;&lt;a&lt;&lt;' '&lt;&lt;"-"&lt;&lt;b&lt;&lt;endl;
        }
        return ;
    }
    for(int i=0;i&lt;n;i++)
    {
        if(mp[a][i]==topa &amp;&amp; sx[i]!=sx[a])
        {
            cout&lt;&lt;(sx[a]?"":"-")&lt;&lt;a&lt;&lt;' '&lt;&lt;(sx[i]?"":"-")&lt;&lt;i&lt;&lt;endl;
        }
    }
    for(int i=0;i&lt;n;i++)
    {
        if(mp[b][i]==topb &amp;&amp; sx[i]!=sx[b])
        {
            cout&lt;&lt;(sx[b]?"":"-")&lt;&lt;b&lt;&lt;' '&lt;&lt;(sx[i]?"":"-")&lt;&lt;i&lt;&lt;endl;
        }
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1111914599412858886&amp;page=1" rel="nofollow" title="L2-029 特立独行的幸福 - 团体程序设计天梯赛-练习集">
      L2-029 特立独行的幸福 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     写懵了，这里代码看个乐子就行，纯翻译题面。数据量只有1000，直接暴力
    </p>
    <pre><code class="language-cpp">int a,b;
map&lt;int,int&gt;hs,pl;
bool prime(int x)
{
    if(x==1) return 0;
    for(int i=2;i*i&lt;=x;i++)
    {
        if(x%i==0)
        {
            return 0;
        }
    }
    return 1;
}
int fun(int x)
{
    int res = 0,y=x;
    while(y)
    {
        int tmp = y%10;
        res+=tmp*tmp;
        y/=10;
    }
    return res;
}
void dfs(int x)
{
    //cout&lt;&lt;x&lt;&lt;endl;
    int res = x,cnt=1;
    int y = x;
    int f = 1;
    map &lt;int,bool&gt; hss;
    hss[x] = 1;
    while(res!=1)
    {
        //cout&lt;&lt;res&lt;&lt;endl;
        int tmp = fun(res);
        cnt++;
        res = tmp;
        if(hss[res] == 1)
        {
            f=0;
            break;
        }
        hss[res] = 1;
    }
    if(res==1)
    {
        pl[x]=--cnt;
        hs[x]=0x3f3f3f3f;
        res = x;
        while(res!=1)
        {
            int tmp = fun(res);
            res = tmp;
            hs[res] = 1;
        }
        return ;
    }
    if(f==0)
    {
        hs[x] = -1;
        res = fun(x);
        while(hs[res] != -1)
        {
            hs[res]=-1;
            int tmp = fun(res);
            res = tmp;
        }
    }
}
void solve()
{
    cin&gt;&gt;a&gt;&gt;b;
    int f = 0;
    for(int i=a;i&lt;=b;i++)
    {
        //cout&lt;&lt;prime(i)&lt;&lt;endl;
        if(hs[i] == -1) continue;
        if(hs[i] == 0x3f3f3f3f)
        {
            //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;(pl[i]*(prime(i)?2:1))&lt;&lt;endl;
            //f=1;
        }
        else if(hs[i]==0)
            dfs(i);
    }
    for(int i=a;i&lt;=b;i++)
    {
        if(hs[i] == -1) continue;
        if(hs[i] == 0x3f3f3f3f)
        {
            cout&lt;&lt;i&lt;&lt;' '&lt;&lt;(pl[i]*(prime(i)?2:1))&lt;&lt;endl;
            f=1;
        }
    }
    if(!f) cout&lt;&lt;"SAD"&lt;&lt;endl;
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1111914599412858888&amp;page=1" rel="nofollow" title="L2-031 深入虎穴 - 团体程序设计天梯赛-练习集">
      L2-031 深入虎穴 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     建树求高度
    </p>
    <pre><code class="language-cpp">int head[N], IDX = 0;struct NODE{int t, ne, w=0;}ed[N];
void add(int s,int t){
    ed[++IDX].ne = head[s]; ed[IDX].t = t; head[s] = IDX;
    //ed[IDX].w = w;
}
int n,rd[N];
int ans,ansd=0;
void dfs(int now,int dpp)
{
    if(dpp&gt;ansd)
    {
        ansd=dpp;
        ans = now;
    }
    for(int i=head[now];i;i=ed[i].ne)
    {
        dfs(ed[i].t,dpp+1);
    }
}
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        int k;
        cin&gt;&gt;k;
        for(int j=1;j&lt;=k;j++)
        {
            int x;
            cin&gt;&gt;x;
            add(i,x);
            rd[x]++;
        }
    }
    int rt;
    for(int i=1;i&lt;=n;i++)
    {
        if(rd[i]==0)
        {
            rt=i;
            break;
        }
    }
    dfs(rt,1);
    cout&lt;&lt;ans&lt;&lt;endl;
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1111914599412858889&amp;page=1" rel="nofollow" title="L2-032 彩虹瓶 - 团体程序设计天梯赛-练习集">
      L2-032 彩虹瓶 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     用stack模拟就行，栈满了也不要停止输入（）。不要忘记如果栈还有东西就尽量往外拿
    </p>
    <pre><code class="language-cpp">int n,m,k;
stack&lt;int&gt; st;
int now;
void solve()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    while(k--)
    {
        while(!st.empty())
        {
            st.pop();
        }
        bool f = 0;
        now = 1;
        for(int i=1;i&lt;=n;i++)
        {
            int x;
            cin&gt;&gt;x;
            //cout&lt;&lt;now&lt;&lt;endl;
            if(x == now)
            {
                now++;
                while(!st.empty()&amp;&amp;st.top()==now)
                {
                    st.pop();
                    now++;
                }
            }
            else
            {
                if(st.size()==m)
                {
                    f=0;
                    continue;
                }
                st.push(x);
            }
        }
        while(!st.empty()&amp;&amp;st.top()==now)
        {
            st.pop();
            now++;
        }
        if(now == n+1) f=1;
        cout&lt;&lt;((f==1)?"YES":"NO")&lt;&lt;endl;
    }
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1336215880692482056&amp;page=1" rel="nofollow" title="L2-033 简单计算器 - 团体程序设计天梯赛-练习集">
      L2-033 简单计算器 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     栈入门题
    </p>
    <pre><code class="language-cpp">stack &lt;int&gt; s1;
stack &lt;char&gt; s2;
int n;
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        cin&gt;&gt;x;
        s1.push(x);
    }
    for(int i=1;i&lt;n;i++)
    {
        char c;
        cin&gt;&gt;c;
        s2.push(c);
    }
    while(s2.size())
    {
        int na,nb;
        na = s1.top();
        s1.pop();
        nb = s1.top();
        s1.pop();
        char op = s2.top();
        s2.pop();
        if(op=='+')
        {
            s1.push(na+nb);
        }
        else if(op =='-')
        {
            s1.push(nb-na);
        }
        else if(op == '*')
        {
            s1.push(na*nb);
        }
        else
        {
            if(na == 0)
            {
                cout&lt;&lt;"ERROR: "&lt;&lt;nb&lt;&lt;'/'&lt;&lt;na&lt;&lt;endl;
                return ;
            }
            else
            {
                s1.push(nb/na);
            }
        }
    }
    cout&lt;&lt;s1.top()&lt;&lt;endl;
}</code></pre>
    <p>
     <a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1336215880692482058&amp;page=1" rel="nofollow" title="L2-035 完全二叉树的层序遍历 - 团体程序设计天梯赛-练习集">
      L2-035 完全二叉树的层序遍历 - 团体程序设计天梯赛-练习集
     </a>
    </p>
    <p>
     建树之后，使用bfs层次遍历就行了
    </p>
    <pre><code class="language-cpp">int n,hx[N];
struct TREE
{
    int v,l,r;
}tr[N];
int hdx;
int build(int idx)
{
    if(idx&gt;n)
        return 0;
    tr[idx].v = hx[hdx];
    hdx--;
    tr[idx].r = build(idx*2+1);
    tr[idx].l = build(idx*2);
    return idx;
}
vector &lt;int&gt; ans;
void bfs(int rt)
{
    queue &lt;int&gt; q;
    q.push(rt);
    while(!q.empty())
    {
        int now = q.front();
        q.pop();
        ans.pb(tr[now].v);
        if(tr[now].l!=0)
        {
            q.push(tr[now].l);
        }
        if(tr[now].r!=0)
        {
            q.push(tr[now].r);
        }
    }
}
void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;hx[i];
    }
    hdx=n;
    int rt = build(1);
    bfs(rt);
    for(int i=0;i&lt;ans.size();i++)
    {
        cout&lt;&lt;ans[i]&lt;&lt;(i&lt;ans.size()-1?" ":"\n");
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393931373437342f:61727469636c652f64657461696c732f313436303534353438" class_="artid" style="display:none">
 </p>
</div>


