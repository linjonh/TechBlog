---
layout: post
title: "Mock测试详细教程入门这一篇就够了"
date: 2025-01-06 15:42:11 +0800
description: "mock测试1.pngMock测试就是在测试活动中，对于某些不容易"
keywords: "mock测试"
categories: ['面试', '软件测试面试', '软件测试']
tags: ['软件测试', '测试工具', 'Java']
artid: "143117493"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=143117493
    alt: "Mock测试详细教程入门这一篇就够了"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=143117493
featuredImagePreview: https://bing.ee123.net/img/rand?artid=143117493
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Mock测试详细教程入门这一篇就够了
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     1、什么是
     <a href="https://so.csdn.net/so/search?q=mock%E6%B5%8B%E8%AF%95&amp;spm=1001.2101.3001.7020" title="mock测试">
      mock测试
     </a>
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/2636627b2f156d557299f28e3dbff064.png"/>
    </p>
    <p>
     1.png
    </p>
    <p>
     <a href="https://so.csdn.net/so/search?q=Mock%E6%B5%8B%E8%AF%95&amp;spm=1001.2101.3001.7020" title="Mock测试">
      Mock测试
     </a>
     就是在
     <strong>
      测试
     </strong>
     活动中，对于某些不容易构造或者不容易获取的比较复杂的数据/场景，用一个
     <a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E7%9A%84&amp;spm=1001.2101.3001.7020" title="虚拟的">
      虚拟的
     </a>
     对象(
     <a href="https://so.csdn.net/so/search?q=Mock&amp;spm=1001.2101.3001.7020" title="Mock">
      Mock
     </a>
     对象)来创建用于测试的测试方法。
    </p>
    <h4>
     <a name="t1">
     </a>
     2、为什么要进行Mock测试
    </h4>
    <p>
     <a href="https://so.csdn.net/so/search?q=Mock&amp;spm=1001.2101.3001.7020" title="Mock">
      Mock
     </a>
     是为了解决不同的单元之间由于耦合而难于开发、测试的问题。所以，Mock既能出现在
     <strong>
      单元测试
     </strong>
     中，也会出现在集成测试、
     <strong>
      系统测试
     </strong>
     过程中。
    </p>
    <p>
     Mock最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。
    </p>
    <h4>
     <a name="t2">
     </a>
     3、Mock适用场景
    </h4>
    <p>
     1、需要将当前被测单元和其依赖模块独立开来，构造一个独立的测试环境，不关注被测单元的依赖对象，只关注被测单元的功能逻辑。
    </p>
    <p>
     2、被测单元依赖的模块尚未开发完成A，而被测单元需要依赖模块的返回值进行后续处理。
    </p>
    <p>
     3、前后端项目中，后端接口开发完成之前，接口联调
    </p>
    <p>
     4、依赖的上游项目的接口尚未开发完成，需要接口联调测试
    </p>
    <p>
     5、被测单元依赖的对象较难模拟或者构造比较复杂
    </p>
    <p>
     如: 支付业务的异常条件很多，但是模拟这种异常条件很复杂或者无法模拟.
    </p>
    <p>
     4、代码实例
    </p>
    <p>
     <strong>
      新建测试工程
     </strong>
    </p>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        package com.echo.mockito;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        public class demo {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //新建一个测试方法
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        public int add(int a,  int b){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        return a + b;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     <strong>
      构建mock测试方法
     </strong>
    </p>
    <p>
     选中测试类，右键选中generate
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b36fa41b13d1c32ef90d2ed1a12134b0.png"/>
    </p>
    <p>
     2.png
    </p>
    <p>
     点击test
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/5e742a1b6ddaec30edd6af55d6fe9aba.png"/>
    </p>
    <p>
     3.png
    </p>
    <p>
     点击ok后就会在test目录下生成对应的测试方法，和真实的目录是对应的
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/cb14518f76e2ea7b74acc8cb8b1a39ea.png"/>
    </p>
    <p>
     4.png
    </p>
    <p>
     5、参数方法说明
    </p>
    <p>
     @BeforeEach
    </p>
    <p>
     用在测试前准备，测试前会构建很多的环境配置或者基础配置，都可以在这里设置。
    </p>
    <p>
     @AfterEach
    </p>
    <p>
     用于测试后设置。
    </p>
    <p>
     @Mock
    </p>
    <p>
     注解可以理解为对 mock 方法的一个替代，不会走真实的方法，模拟真实方法的行为。使用该注解时，要使用MockitoAnnotations.openMocks(this)  方法，让注解生效。
    </p>
    <p>
     @Spy
    </p>
    <p>
     1、被Spy的对象会走真实的方法，而mock对象不会，
    </p>
    <p>
     2、spy方法的参数是对象实例，mock的参数是class。
    </p>
    <p>
     @InjectMocks
    </p>
    <p>
     用于将@Mock标记的模拟变量注入到测试类中。
    </p>
    <p>
     MockitoAnnotations.openMocks(this)
    </p>
    <p>
     开启mock，配合以上两个注解进行测试。一般放在@BeforeEach 中，在测试前开启，这样不用在每个方法中都的开启了。
    </p>
    <p>
     Mockito.when(demo.add(1,2)).thenReturn(3)：打桩
    </p>
    <p>
     mock核心，可以设置要测试的方法的结果，这样就会忽略真实方法的执行结果，后续的测试都是基于打桩结果执行。
    </p>
    <p>
     Mockito.when(demo.add(1,2)).thenThrow(new RuntimeException());
    </p>
    <p>
     用于模拟异常。
    </p>
    <p>
     Assertions.assertEquals(3,demo.add(1,2))：断言
    </p>
    <p>
     测试的主要方式，结果基于此判断。(期望值，实际值)。
    </p>
    <h6>
     <a name="t3">
     </a>
     6、简单测试
    </h6>
    <p>
     打桩测试  设置方法返回4  ，而实际执行为3 ，测试不通过。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/3aedf90b93e6947df46563f22cf4295f.png"/>
    </p>
    <p>
     5.png
    </p>
    <p>
     不打桩测试  因为是spy方式，会走真实的方法  ，测试通过。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/0bef048f9c985ca52ba327bfea939f8c.png"/>
    </p>
    <p>
     6.png
    </p>
    <p>
     如果是mock方式，如果不打桩会有默认值，测试会不通过，可以试一下。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6ab9e65e617bbdec6b481187df61da27.png"/>
    </p>
    <p>
     7.png
    </p>
    <p>
     7、测试方法说明
    </p>
    <p>
     详细调用看代码，一般会以下几种：
    </p>
    <ul>
     <li>
      <p>
       打桩测试
      </p>
     </li>
     <li>
      <p>
       异常测试
      </p>
     </li>
     <li>
      <p>
       真实方法调用
      </p>
     </li>
    </ul>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        package com.echo.mockito;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.AfterEach;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.Assertions;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.BeforeEach;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.Test;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.Mock;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.Mockito;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.MockitoAnnotations;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.Spy;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        class demoTest {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Mock
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo demo;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //测试前开启mock
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @BeforeEach
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void setUp() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        MockitoAnnotations.openMocks(this);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void add() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //mock 打桩，就是不管真实的方法如何执行，我们可以自行假设该方法执行的结果
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //后续的测试都是基于打桩结果来走
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // Mockito.when(demo.add(1,2)).thenReturn(4);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // Assertions.assertEquals(3,demo.add(1,2));
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //当测试方法出现异常，测试方法  如果有try{}catch{} 则可以测试异常是否正常
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //Mockito.when(demo.add(1,1)).thenThrow(new RuntimeException());
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //调用真实的方法
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Mockito.when(demo.add(1,1)).thenCallRealMethod();
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertEquals(2,demo.add(1,1));
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @AfterEach
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void after(){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        System.out.println("测试结束");
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     8、Mock静态方法
    </p>
    <p>
     之前的版本中是不允许模拟测试静态方法的，如果需要测试静态方法，需要替换新的mock依赖，注释掉目前有的依赖，会有冲突。
    </p>
    <p>
     静态方法测试要用mock的MockedStatic类构建测试方法。
    </p>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;!--   &lt;dependency&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;groupId&gt;org.mockito&lt;/groupId&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;version&gt;4.6.1&lt;/version&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;/dependency&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        --&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;dependency&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;groupId&gt;org.mockito&lt;/groupId&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;artifactId&gt;mockito-inline&lt;/artifactId&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;version&gt;4.3.1&lt;/version&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;scope&gt;test&lt;/scope&gt;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        &lt;/dependency&gt;
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        package com.echo.mockito.Util;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.Assertions;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.BeforeEach;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.Test;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.MockedStatic;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.Mockito;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import java.util.Arrays;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import static org.junit.jupiter.api.Assertions.*;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        class StaticUtilsTest {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @BeforeEach
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void setUp() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // 有参静态方法构建
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void range() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        MockedStatic   demo = Mockito.mockStatic(StaticUtils.class);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //打桩
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo.when(()-&gt;StaticUtils.range(2,6)).thenReturn(Arrays.asList(10,11,12));
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertTrue(StaticUtils.range(2,6).contains(11));
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // 无参静态方法构建
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void name() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        MockedStatic   demo = Mockito.mockStatic(StaticUtils.class);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //打桩
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo.when(StaticUtils::name).thenReturn("dhmw");
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertEquals("dhmw",StaticUtils.name());
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     问题：单个的方法执行是没有问题的，但是我们在类上全部执行的时候，发现报错。
    </p>
    <p>
     提示static mocking is already registered in the current thread  To create a new mock, the existing static mock registration must be deregistered
    </p>
    <p>
     意思就是说，每个方法需要有自己的static mock 对象，不允许公用。一起执行的时候，第一个方法占了对象，第二个方法就没有办法再占了。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/27ea684441c720fd3be708458d7f25df.png"/>
    </p>
    <p>
     8.png
    </p>
    <p>
     解决：每个方法执行完毕后就直接关闭mock对象 demo.close()。相当于是单例的。用完后就的释放，下一个方法才能接着使用。
    </p>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void range() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        MockedStatic   demo = Mockito.mockStatic(StaticUtils.class);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //打桩
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo.when(()-&gt;StaticUtils.range(2,6)).thenReturn(Arrays.asList(10,11,12));
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertTrue(StaticUtils.range(2,6).contains(11));
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //关闭
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo.close();
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // 无参静态方法构建
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void name() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        MockedStatic   demo = Mockito.mockStatic(StaticUtils.class);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //打桩
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo.when(StaticUtils::name).thenReturn("dhmw");
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertEquals("dhmw",StaticUtils.name());
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //关闭
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        demo.close();
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     9、提升测试覆盖率
    </p>
    <p>
     案例：数据统计系统，地推人员输入客户的姓名和
     <strong>
      手机
     </strong>
     号码，最后构建用户对象存入数据表。
    </p>
    <p>
     <strong>
      业务代码如下：
     </strong>
    </p>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        package com.echo.mockito.service.impl;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import com.echo.mockito.dao.UserDao;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import com.echo.mockito.service.RegistrationService;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import com.echo.mockito.vo.User;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.springframework.beans.factory.annotation.Autowired;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import javax.xml.bind.ValidationException;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import java.sql.SQLException;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        public class RegistrationServiceImpl implements RegistrationService {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Autowired
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        UserDao userDao;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Override
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        public User register(String name, String phone) throws Exception {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        if (name == null || name.length() == 0){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        throw new ValidationException("name 不能为空");
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        if (phone == null || phone.length() ==0 ){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        throw new ValidationException("phone 不能为空");
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        User user;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        try {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        user = userDao.save(name,phone);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }catch (Exception e){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        throw  new Exception("SqlException thrown" + e.getMessage());
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        return user;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <ol>
     <li>
      <p>
       <code>
        package com.echo.mockito.dao;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import com.echo.mockito.vo.User;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        public class UserDao {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        public User save(String name,String phnoe){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        User user = new User();
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        user.setName(name);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        return user;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     <strong>
      生成相应的测试代码，此时有几个问题需要思考。
     </strong>
    </p>
    <p>
     1、测试的类是RegistrationServiceImpl但是里面的userDao如何注入到测试类中？
    </p>
    <p>
     2、因为需要测试覆盖度，需要考虑该测试类中总共有几种情况需要测试。
    </p>
    <p>
     （1）：两个if抛出了两个异常，总共是2种情况要测试。
    </p>
    <p>
     （2）：保存
     <strong>
      数据库
     </strong>
     分为正常保存和异常保存，总共2种情况测试。
    </p>
    <p>
     综上所述，必须完成这四种情况的测试，才能覆盖所有代码。
    </p>
    <p>
     <strong>
      相同的方法，我们生成
      <strong>
       测试用例
      </strong>
      .代码中有详细的说明，每一种情况都有测试用例。
     </strong>
    </p>
    <ol>
     <li>
     </li>
     <li>
      <p>
       <code>
        package com.echo.mockito.service.impl;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import com.echo.mockito.dao.UserDao;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import com.echo.mockito.vo.User;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.Assertions;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.BeforeEach;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.junit.jupiter.api.Test;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import org.mockito.*;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import javax.xml.bind.ValidationException;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import java.sql.SQLException;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        import static org.junit.jupiter.api.Assertions.*;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        class RegistrationServiceImplTest {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @InjectMocks     //RegistrationServiceImpl 实例中注入@Mock标记的类，此处是注入userDao
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Spy
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        private RegistrationServiceImpl registrationService;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Mock
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        private  UserDao userDao;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @BeforeEach
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void setUp() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        MockitoAnnotations.openMocks(this);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void register() throws Exception {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  第一种 name  异常情况   测试   start ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        String name = null;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        String phone = "1234";
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        try {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        registrationService.register(name,phone);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }catch (Exception e){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertTrue(e instanceof ValidationException);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  name  异常情况   测试   end  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  第二种 phone  异常情况   测试   start  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        name = "111";
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        phone = null;
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        try {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        registrationService.register(name,phone);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }catch (Exception e){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertTrue(e instanceof ValidationException);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  phone  异常情况   测试   start  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  第三种 userDao.save   正常情况   测试   start  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        name = "111";
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        phone = "111";
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //正常保存测试  打桩  走真实的方法
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Mockito.when(userDao.save(name,phone)).thenCallRealMethod();
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        User user =  registrationService.register(name,phone);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertEquals("111",user.getName());
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  userDao.save   正常情况   测试   end  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------   第四种 userDao.save   异常情况   测试   start  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        //异常保存测试  打桩   通过thenThrow 抛出异常  测试异常是否被捕获
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Mockito.when(userDao.save(name,phone)).thenThrow(new RuntimeException());
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        try {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        registrationService.register(name,phone);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }catch (Exception e){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        Assertions.assertTrue(e instanceof Exception);
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        // ------------------  userDao.save   异常情况   测试   end  ------------------------
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     如上所示：上面提到的第一个问题，如何注入测试类中的成员变量，是通过@InjectMocks 注解即可完成。
    </p>
    <p>
     测试覆盖率方法如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/436fc73b8af5645c1c460a45bdbb659e.png"/>
    </p>
    <p>
     9.png
    </p>
    <p>
     测试结果如下：
    </p>
    <p>
     1、右边部分会显示测试覆盖率。
    </p>
    <p>
     2、真实代码绿色代表已覆盖测试，红色代表未覆盖测试。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/500267f4c751a0b09a13ac6fc2cf337e.png"/>
    </p>
    <p>
     11.png
    </p>
    <p>
     如果所有的测试情况都100%覆盖，结果如下：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6939ed3c0f272c242e6043c535016313.png"/>
    </p>
    <p>
     12.png
    </p>
    <p>
     综上所述就是覆盖测试的方法，总结如下：
    </p>
    <p>
     1、根据业务代码，分析出所有需要测试的情况。
    </p>
    <p>
     2、根据不同的测试情况，编写具体的测试代码。
    </p>
    <p>
     3、针对每一种情况，可以编写具体的测试代码，然后通过打桩，断言等方式，穷尽所有的清册情况即可。
    </p>
    <p>
     问题：
    </p>
    <p>
     1、如果真实代码 方法级别有 throws Exception  那么同样的，测试方法也必须方法级别要抛出异常，不然测试会报错。
    </p>
    <ol>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        void register() throws Exception {
        <!-- -->
       </code>
      </p>
     </li>
    </ol>
    <p>
     2、保存数据库分为正常和异常，那么先测正常分支，然后在测试异常分支，如果顺序反了，测试先抛出异常，正常的分支就不会执行，这样会导致测试覆盖不全。
    </p>
    <p>
     <strong>
      感谢每一个认真阅读我文章的人！！！
     </strong>
    </p>
    <p>
     作为一位过来人也是希望大家少走一些弯路，如果你不想再体验一次学习时找不到资料，没人解答问题，坚持几天便放弃的感受的话，在这里我给大家分享一些自动化测试的学习资源，希望能给你前进的路上带来帮助。
    </p>
    <p>
     <img alt="" src="https://img-blog.csdnimg.cn/direct/5fb98e37cc1b4f2bae72457589697c91.png"/>
    </p>
    <h6>
     软件测试面试文档
    </h6>
    <p>
     我们学习必然是为了找到高薪的工作，下面这些
     <a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E8%AF%95%E9%A2%98&amp;spm=1001.2101.3001.7020" title="面试题">
      面试题
     </a>
     是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/514965e1ab1148dfb4c04768ea1b9cbd.jpeg"/>
    </p>
    <p>
     <img alt="" height="385" src="https://img-blog.csdnimg.cn/694b35de52e6493c99f913729355584f.png" width="786"/>
    </p>
    <p>
     视频文档获取方式：
     <br/>
     这份文档和视频资料，对于想从事【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！以上均可以分享，点下方小卡片即可自行领取。
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303131393537392f:61727469636c652f64657461696c732f313433313137343933" class_="artid" style="display:none">
 </p>
</div>


