---
layout: post
title: "Java-设计模式观察者模式"
date: 2025-03-11 17:14:05 +0800
description: "一、模式定义观察者模式属于行为型设计模式，用于建立对象间的一对多依赖关系。当主题(Subject)状态变化时，所有依赖的观察者(Observer)会自动收到通知并更新。二、核心角色Subject(主题)维护观察者列表，提供添加/删除观察者的方法定义通知观察者的方法Observer(观察者接口)定义更新接口，用于接收主题通知..."
keywords: "Java 设计模式：观察者模式"
categories: ['未分类']
tags: ['设计模式', '观察者模式', '开发语言', 'Java']
artid: "146194333"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146194333
    alt: "Java-设计模式观察者模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146194333
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146194333
cover: https://bing.ee123.net/img/rand?artid=146194333
image: https://bing.ee123.net/img/rand?artid=146194333
img: https://bing.ee123.net/img/rand?artid=146194333
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java 设计模式：观察者模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div class="article-content-wrap" style="font-size: 16px;">
     <div class="artical-content-bak main-content editor-side-new">
      <div class="con editor-preview-side" id="result">
       <div class="editor-container container am-engine" id="container">
        <h6>
         一、模式定义
        </h6>
        <p>
         <strong>
          观察者模式
         </strong>
         属于
         <strong>
          行为型设计模式
         </strong>
         ，用于建立对象间的
         <strong>
          一对多依赖关系
         </strong>
         。当主题(Subject)状态变化时，所有依赖的观察者(Observer)会自动收到通知并更新。
        </p>
        <h6>
         二、核心角色
        </h6>
        <ol>
         <li>
          <strong>
           Subject(主题)
          </strong>
         </li>
        </ol>
        <ul>
         <li>
          维护观察者列表，提供添加/删除观察者的方法
         </li>
         <li>
          定义通知观察者的方法
         </li>
        </ul>
        <ol start="2">
         <li>
          <strong>
           Observer(观察者接口)
          </strong>
         </li>
        </ol>
        <ul>
         <li>
          定义更新接口，用于接收主题通知
         </li>
        </ul>
        <ol start="3">
         <li>
          <strong>
           ConcreteSubject(具体主题)
          </strong>
         </li>
        </ol>
        <ul>
         <li>
          存储具体状态信息
         </li>
         <li>
          状态改变时触发通知
         </li>
        </ul>
        <ol start="4">
         <li>
          <strong>
           ConcreteObserver(具体观察者)
          </strong>
         </li>
        </ol>
        <ul>
         <li>
          实现更新逻辑，保持与主题状态同步
         </li>
        </ul>
        <h6>
         三、经典实现(以气象站为例)
        </h6>
        <div>
         <div class="code-toolbar">
          <div class="hljs-cto">
           <div class="operation_box">
            <button class="copy_btn disable">
             登录后复制
            </button>
            <a class="downloadCode" title="登录后一键下载全文代码">
             <i class="iconblog blogimport">
             </i>
            </a>
           </div>
           <pre class="has" tabindex="0"><code class="language-plain has-numbering" id="code_id_0">// 1. 主题接口
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

// 2. 观察者接口
interface Observer {
    void update(float temp, float humidity, float pressure);
}

// 3. 具体主题实现
class WeatherData implements Subject {
    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();
    private float temperature;
    private float humidity;
    private float pressure;

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }

    public void measurementsChanged() {
        notifyObservers();
    }

    public void setMeasurements(float temp, float humidity, float pressure) {
        this.temperature = temp;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}

// 4. 具体观察者实现
class CurrentConditionsDisplay implements Observer {
    private float temperature;
    private float humidity;

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        this.temperature = temp;
        this.humidity = humidity;
        display();
    }

    public void display() {
        System.out.println("Current conditions: " + temperature 
            + "°C and " + humidity + "% humidity");
    }
}

// 5. 使用示例
public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay display = new CurrentConditionsDisplay(weatherData);
        
        weatherData.setMeasurements(25.5f, 65, 1013.1f);
        weatherData.setMeasurements(26.8f, 70, 1012.5f);
    }
}</code></pre>
           <ul class="pre-numbering">
            <li>
             1.
            </li>
            <li>
             2.
            </li>
            <li>
             3.
            </li>
            <li>
             4.
            </li>
            <li>
             5.
            </li>
            <li>
             6.
            </li>
            <li>
             7.
            </li>
            <li>
             8.
            </li>
            <li>
             9.
            </li>
            <li>
             10.
            </li>
            <li>
             11.
            </li>
            <li>
             12.
            </li>
            <li>
             13.
            </li>
            <li>
             14.
            </li>
            <li>
             15.
            </li>
            <li>
             16.
            </li>
            <li>
             17.
            </li>
            <li>
             18.
            </li>
            <li>
             19.
            </li>
            <li>
             20.
            </li>
            <li>
             21.
            </li>
            <li>
             22.
            </li>
            <li>
             23.
            </li>
            <li>
             24.
            </li>
            <li>
             25.
            </li>
            <li>
             26.
            </li>
            <li>
             27.
            </li>
            <li>
             28.
            </li>
            <li>
             29.
            </li>
            <li>
             30.
            </li>
            <li>
             31.
            </li>
            <li>
             32.
            </li>
            <li>
             33.
            </li>
            <li>
             34.
            </li>
            <li>
             35.
            </li>
            <li>
             36.
            </li>
            <li>
             37.
            </li>
            <li>
             38.
            </li>
            <li>
             39.
            </li>
            <li>
             40.
            </li>
            <li>
             41.
            </li>
            <li>
             42.
            </li>
            <li>
             43.
            </li>
            <li>
             44.
            </li>
            <li>
             45.
            </li>
            <li>
             46.
            </li>
            <li>
             47.
            </li>
            <li>
             48.
            </li>
            <li>
             49.
            </li>
            <li>
             50.
            </li>
            <li>
             51.
            </li>
            <li>
             52.
            </li>
            <li>
             53.
            </li>
            <li>
             54.
            </li>
            <li>
             55.
            </li>
            <li>
             56.
            </li>
            <li>
             57.
            </li>
            <li>
             58.
            </li>
            <li>
             59.
            </li>
            <li>
             60.
            </li>
            <li>
             61.
            </li>
            <li>
             62.
            </li>
            <li>
             63.
            </li>
            <li>
             64.
            </li>
            <li>
             65.
            </li>
            <li>
             66.
            </li>
            <li>
             67.
            </li>
            <li>
             68.
            </li>
            <li>
             69.
            </li>
            <li>
             70.
            </li>
            <li>
             71.
            </li>
            <li>
             72.
            </li>
            <li>
             73.
            </li>
            <li>
             74.
            </li>
            <li>
             75.
            </li>
            <li>
             76.
            </li>
            <li>
             77.
            </li>
            <li>
             78.
            </li>
            <li>
             79.
            </li>
            <li>
             80.
            </li>
           </ul>
          </div>
         </div>
        </div>
        <h6>
         四、两种通知模型对比
        </h6>
        <div>
         <table class="data-table">
          <colgroup>
           <col/>
           <col/>
           <col/>
          </colgroup>
          <tbody>
           <tr>
            <td>
             <p>
              特性
             </p>
            </td>
            <td>
             <p>
              推模型(Push)
             </p>
            </td>
            <td>
             <p>
              拉模型(Pull)
             </p>
            </td>
           </tr>
           <tr>
            <td>
             <p>
              数据传递方式
             </p>
            </td>
            <td>
             <p>
              主题主动发送完整数据
             </p>
            </td>
            <td>
             <p>
              观察者从主题拉取所需数据
             </p>
            </td>
           </tr>
           <tr>
            <td>
             <p>
              实现复杂度
             </p>
            </td>
            <td>
             <p>
              观察者可能收到不需要的数据
             </p>
            </td>
            <td>
             <p>
              观察者按需获取数据，需要维护主题引用
             </p>
            </td>
           </tr>
           <tr>
            <td>
             <p>
              耦合度
             </p>
            </td>
            <td>
             <p>
              观察者依赖具体数据结构
             </p>
            </td>
            <td>
             <p>
              观察者只需知道主题存在
             </p>
            </td>
           </tr>
           <tr>
            <td>
             <p>
              性能考量
             </p>
            </td>
            <td>
             <p>
              可能传输冗余数据
             </p>
            </td>
            <td>
             <p>
              需要多次调用获取方法
             </p>
            </td>
           </tr>
          </tbody>
         </table>
        </div>
        <p>
         <strong>
          拉模型改进示例：
         </strong>
        </p>
        <div>
         <div class="code-toolbar">
          <div class="hljs-cto">
           <div class="operation_box">
            <button class="copy_btn disable">
             登录后复制
            </button>
            <a class="downloadCode" title="登录后一键下载全文代码">
             <i class="iconblog blogimport">
             </i>
            </a>
           </div>
           <pre class="has" tabindex="0"><code class="language-plain has-numbering" id="code_id_1">interface Subject {
    // 新增获取状态的方法
    float getTemperature();
    float getHumidity();
    float getPressure();
}

class WeatherData implements Subject {
    // 保持原有接口不变
    // 新增状态获取方法...
}

class CurrentConditionsDisplay implements Observer {
    private Subject weatherData;

    public CurrentConditionsDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    @Override
    public void update() {
        this.temperature = weatherData.getTemperature();
        this.humidity = weatherData.getHumidity();
        display();
    }
}</code></pre>
           <ul class="pre-numbering">
            <li>
             1.
            </li>
            <li>
             2.
            </li>
            <li>
             3.
            </li>
            <li>
             4.
            </li>
            <li>
             5.
            </li>
            <li>
             6.
            </li>
            <li>
             7.
            </li>
            <li>
             8.
            </li>
            <li>
             9.
            </li>
            <li>
             10.
            </li>
            <li>
             11.
            </li>
            <li>
             12.
            </li>
            <li>
             13.
            </li>
            <li>
             14.
            </li>
            <li>
             15.
            </li>
            <li>
             16.
            </li>
            <li>
             17.
            </li>
            <li>
             18.
            </li>
            <li>
             19.
            </li>
            <li>
             20.
            </li>
            <li>
             21.
            </li>
            <li>
             22.
            </li>
            <li>
             23.
            </li>
            <li>
             24.
            </li>
            <li>
             25.
            </li>
            <li>
             26.
            </li>
            <li>
             27.
            </li>
           </ul>
          </div>
         </div>
        </div>
        <h6>
         五、Java内置支持
        </h6>
        <div>
         <div class="code-toolbar">
          <div class="hljs-cto">
           <div class="operation_box">
            <button class="copy_btn disable">
             登录后复制
            </button>
            <a class="downloadCode" title="登录后一键下载全文代码">
             <i class="iconblog blogimport">
             </i>
            </a>
           </div>
           <pre class="has" tabindex="0"><code class="language-plain has-numbering" id="code_id_2">// 已过时，不推荐使用，仅作了解
import java.util.Observable;
import java.util.Observer;

class WeatherData extends Observable {
    public void measurementsChanged() {
        setChanged();  // 必须调用
        notifyObservers();  // 无参为拉模型
        // notifyObservers(data);  // 带参为推模型
    }
}

class Display implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        if (o instanceof WeatherData) {
            // 拉取数据
            WeatherData wd = (WeatherData) o;
            // 或使用arg参数获取推送数据
        }
    }
}</code></pre>
           <ul class="pre-numbering">
            <li>
             1.
            </li>
            <li>
             2.
            </li>
            <li>
             3.
            </li>
            <li>
             4.
            </li>
            <li>
             5.
            </li>
            <li>
             6.
            </li>
            <li>
             7.
            </li>
            <li>
             8.
            </li>
            <li>
             9.
            </li>
            <li>
             10.
            </li>
            <li>
             11.
            </li>
            <li>
             12.
            </li>
            <li>
             13.
            </li>
            <li>
             14.
            </li>
            <li>
             15.
            </li>
            <li>
             16.
            </li>
            <li>
             17.
            </li>
            <li>
             18.
            </li>
            <li>
             19.
            </li>
            <li>
             20.
            </li>
            <li>
             21.
            </li>
            <li>
             22.
            </li>
           </ul>
          </div>
         </div>
        </div>
        <h6>
         六、模式优劣分析
        </h6>
        <p>
         <strong>
          优势：
         </strong>
        </p>
        <ul>
         <li>
          符合开闭原则：新增观察者无需修改主题
         </li>
         <li>
          运行时动态建立对象关系
         </li>
         <li>
          实现抽象耦合，主题无需知道具体观察者
         </li>
        </ul>
        <p>
         <strong>
          劣势：
         </strong>
        </p>
        <ul>
         <li>
          通知顺序不可控
         </li>
         <li>
          频繁更新可能影响性能
         </li>
         <li>
          循环依赖风险
         </li>
        </ul>
        <h6>
         七、应用场景
        </h6>
        <ol>
         <li>
          跨系统事件通知(如订单状态更新)
         </li>
         <li>
          GUI事件处理(按钮点击监听)
         </li>
         <li>
          实时数据监控(股票价格变动)
         </li>
         <li>
          游戏中的成就系统解锁
         </li>
         <li>
          分布式配置中心(配置变更通知)
         </li>
        </ol>
        <h6>
         八、高级应用技巧
        </h6>
        <ol>
         <li>
          <strong>
           异步观察者
          </strong>
          ：
          <br/>
          使用线程池处理通知，避免阻塞主题线程
         </li>
        </ol>
        <div>
         <div class="code-toolbar">
          <div class="hljs-cto">
           <div class="operation_box">
            <button class="copy_btn disable">
             登录后复制
            </button>
            <a class="downloadCode" title="登录后一键下载全文代码">
             <i class="iconblog blogimport">
             </i>
            </a>
           </div>
           <pre class="has" tabindex="0"><code class="language-plain has-numbering" id="code_id_3">ExecutorService executor = Executors.newCachedThreadPool();

void notifyObservers() {
    for (Observer o : observers) {
        executor.execute(() -&gt; o.update(...));
    }
}</code></pre>
           <ul class="pre-numbering">
            <li>
             1.
            </li>
            <li>
             2.
            </li>
            <li>
             3.
            </li>
            <li>
             4.
            </li>
            <li>
             5.
            </li>
            <li>
             6.
            </li>
            <li>
             7.
            </li>
           </ul>
          </div>
         </div>
        </div>
        <ol>
         <li>
          <strong>
           防止失效监听
          </strong>
          ：
          <br/>
          使用弱引用(WeakReference)存储观察者，防止内存泄漏
         </li>
         <li>
          <strong>
           保证通知顺序
          </strong>
          ：
          <br/>
          使用PriorityQueue实现带优先级的观察者队列
         </li>
         <li>
          <strong>
           跨进程观察者
          </strong>
          ：
          <br/>
          结合消息队列(如RabbitMQ、Kafka)实现分布式观察者模式
         </li>
        </ol>
        <h6>
         九、相关模式对比
        </h6>
        <ol>
         <li>
          <strong>
           中介者模式
          </strong>
          vs 观察者模式
          <br/>
          中介者集中处理对象间通信，而观察者建立直接订阅关系
         </li>
         <li>
          <strong>
           发布-订阅模式
          </strong>
          vs 观察者模式
          <br/>
          发布-订阅通过消息代理解耦，观察者是直接通信
         </li>
        </ol>
        <h6>
         十、最佳实践建议
        </h6>
        <ol>
         <li>
          优先使用拉模型，降低耦合度
         </li>
         <li>
          为观察者接口设计合适的更新粒度
         </li>
         <li>
          考虑使用CopyOnWriteArrayList保证线程安全
         </li>
         <li>
          对于复杂场景，建议使用Guava的EventBus或Spring事件机制
         </li>
        </ol>
       </div>
      </div>
     </div>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f4a6176615f66656e7869616e672f:61727469636c652f64657461696c732f313436313934333333" class_="artid" style="display:none">
 </p>
</div>


