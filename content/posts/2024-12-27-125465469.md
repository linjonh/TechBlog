---
layout: post
title: "JNIJNAjava-调用cc-动态链接库-全套操作踩坑集锦"
date: 2024-12-27 19:59:00 +0800
description: "jna jni java结构体 Java调用动态链接库_java jni jna"
keywords: "java jni jna"
categories: ['未分类']
tags: ['Java', 'C', 'C']
artid: "125465469"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=125465469
  alt: "JNIJNAjava-调用cc-动态链接库-全套操作踩坑集锦"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=125465469
featuredImagePreview: https://bing.ee123.net/img/rand?artid=125465469
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     （JNI/JNA）java 调用c/c++ 动态链接库 全套操作+踩坑集锦
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      第一篇文章终于写完…跨行三年，一直都是看别人的文章…今天咱终于自己写了一篇，自己总结的，希望能给你一点点帮助，如有错误，希望指出，立马改正。
     </strong>
    </p>
    <h3>
     <a id="0__1">
     </a>
     0 前言
    </h3>
    <p>
     Java代码是跨平台的，其与硬件环境彻底“隔离”，为了实现这个目的，JDK1.0开始就包含了一个本地方法接口，它允许JAVA程序调用C/C++写的程序，许多第三方的程序和JAVA类库。如：java.lang,java.io,java.net等都依赖于本地方法来访问底层系统环境的特征。但是这有两个问题：
    </p>
    <blockquote>
     <p>
      1、本地方法想访问C中的结构（structures）一样访问对象中的字段。尽管如此，JVM规范并没有定义对象怎么样在内存中实现。如果一个给定的JVM实现布局对象时，和本地方法假设的不一样，那你就不得不重新编写本地方法库。
      <br/>
      2、因为本地方法可以保持对JVM中对象的直接指针，所以，JDK1.0中的本地方法采用了一种保守的GC策略。
     </p>
    </blockquote>
    <p>
     为了解决这两个问题，JDK1.1中出现了JNI，这就为java代码调用c/c++动态链接库提供了一种方法。
    </p>
    <h3>
     <a id="1_JNI_8">
     </a>
     1 JNI
    </h3>
    <p>
     若调用本地的C/C++的动态链接库，我们首先要通过java实现自己的本地方法，我们只需要利用JNI提供的关键字native把方法声明为是本地方法（由其他语言是实现的方法），然后再利用c/c++实现一个有相同方法名的动态链接库，并放在指定目录下即可供Java调用即可。
     <br/>
     Window环境下生成动态链接库为.dll，需要配置头文件.h,详细实现过程看这篇文章，非常详细，博主亲测可实现
     <a href="https://blog.csdn.net/weixin_51763233/article/details/122205288">
      https://blog.csdn.net/weixin_51763233/article/details/122205288
     </a>
     <br/>
     Linux环境下生成动态链接库为.so,和windw环境差不多，详细过程看这篇文章，博主亲测可实现：
     <a href="https://zhuanlan.zhihu.com/p/465601205" rel="nofollow">
      https://zhuanlan.zhihu.com/p/465601205
     </a>
    </p>
    <p>
     <strong>
      总结一下调用分为五部：
     </strong>
    </p>
    <ol>
     <li>
      java类中申请一个本地方法
     </li>
     <li>
      运行javah以获取包含该方法的C声明的头文件
     </li>
     <li>
      c/c++实现本地方法
     </li>
     <li>
      讲dll/so放在共享类库中
     </li>
     <li>
      java程序加载该类库
     </li>
    </ol>
    <p>
     <img alt="JAVA技术核心卷2" src="https://i-blog.csdnimg.cn/blog_migrate/29cd7262f6169948b7cdd41d2fab3a28.png#pic_center">
      <br/>
      <strong>
       注意
      </strong>
      ：如果用c++实现本地方法，需要用extern ”C“来声明，这样是为了不让使用c++编译器来编译本地方法，因为c++编译器编译可能会给方法加上后缀，导致Java无法找到本地方法的实现。
     </img>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">void</span> <span class="token function">externC</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     其实Java和c/c++不能互通的原因主要是数据类型的问题，jni解决了这个问题，jni定义了一系列JNI数据类型，Java和c/c++数据类型通过JNI定义的数据类型进行转换：
     <br/>
     例如：在进行数字传递的时候，我们知道在不同的平台c中int型所占字节数是不一样的，所以JNI定义了jint；
     <br/>
     又例如：那个c文件中的jstring数据类型就是java传入的String对象，经过jni函数的转化就能成为c的char*。
    </p>
    <p>
     对应关系类型(部分)：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        Java类型
       </th>
       <th>
        JNI类型
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        boolean
       </td>
       <td>
        jboolean
       </td>
       <td>
        unsigned char
       </td>
      </tr>
      <tr>
       <td>
        byte
       </td>
       <td>
        jbyte
       </td>
       <td>
        signed 8 bits
       </td>
      </tr>
      <tr>
       <td>
        char
       </td>
       <td>
        jchar
       </td>
       <td>
        unsigned 16 bits
       </td>
      </tr>
      <tr>
       <td>
        short
       </td>
       <td>
        jshort
       </td>
       <td>
        signed 16 bits
       </td>
      </tr>
      <tr>
       <td>
        int
       </td>
       <td>
        jint
       </td>
       <td>
        signed 32 bits
       </td>
      </tr>
      <tr>
       <td>
        long
       </td>
       <td>
        jlong
       </td>
       <td>
        signed 64 bits
       </td>
      </tr>
      <tr>
       <td>
        float
       </td>
       <td>
        jfloat
       </td>
       <td>
        32 bits
       </td>
      </tr>
      <tr>
       <td>
        double
       </td>
       <td>
        jdouble
       </td>
       <td>
        64 bits
       </td>
      </tr>
      <tr>
       <td>
        void
       </td>
       <td>
        void
       </td>
       <td>
        N/A
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     到此关于JNI，博主就介绍到这里，声明一点JNI是一个Java和其他语言互调的技术，也就是说你当然可以用JNI实现其他语言调用java程序，想继续深究的同学可以参考《Java核心技术（卷2）》最后一章”本地方法“。
    </p>
    <h3>
     <a id="2_JNA_50">
     </a>
     2 JNA
    </h3>
    <p>
     JNI虽然实现了Java调用C/C++动态链接库，但是还是比较复杂的，尤其各种是数据类型的映射，于是乎，它来了-JNA(Java Native Access)。
    </p>
    <blockquote>
     <p>
      JNA（Java Native Access ）提供一组Java工具类用于在运行期间动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native/JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。JNA(Java Native Access)框架是一个开源的Java框架，是SUN公司主导开发的，建立在经典的JNI的基础之上的一个框架。
     </p>
    </blockquote>
    <p>
     JNA可以让你像调用一般java方法一样直接调用本地方法。就和直接执行本地方法差不多，而且调用本地方法还不用额外的其他处理或者配置什么的，也不需要多余的引用或者编码，使用很方便。具体使用方法不在赘述，入门使用看这篇文章：
     <a href="https://blog.csdn.net/zhan107876/article/details/121051129">
      https://blog.csdn.net/zhan107876/article/details/121051129
     </a>
    </p>
    <p>
     JNA虽然使用起来方便，但坑也着实的多:
     <br/>
     <strong>
      JNA指针
     </strong>
     <br/>
     java是值传递的，没有指针（地址）的概念，但是c/c++是有指针的，有时候我们需要把变量传递过去然后获取变量新的值，这个时候我们必须引入指针的概念。好在JNA中引入了Pointer（com.sun.jna.Pointer）。Pointer是JNA中引入的类，用来表示native方法中的指针。
     <br/>
     native方法中的指针实际上就是一个地址，这个地址就是真正对象的内存地址。
    </p>
    <p>
     举个例子（参考
     <a href="https://blog.csdn.net/zhan107876/article/details/121056384">
      https://blog.csdn.net/zhan107876/article/details/121056384
     </a>
     ）：如果我们需要调用一个动态链接库，其实现这样的一个函数：
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">/**
 * 返回a+b的值
 * 同时c和msg通过参数返回
 */</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>msg <span class="token operator">=</span> string<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     如果我们使用jna这么调用：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloJNA</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * 定义一个接口，默认的是继承Library ，如果动态链接库里的函数是以stdcall方式输出的，那么就继承StdCallLibrary
     * 这个接口对应一个动态链接(SO)文件
     */</span>
    <span class="token keyword">public</span> interface LibraryAdd extends Library <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里使用绝对路径加载</span>
        LibraryAdd LIBRARY_ADD <span class="token operator">=</span> Native<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"/program/cpp/libhello.so"</span><span class="token punctuation">,</span> LibraryAdd<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> String msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        String msg <span class="token operator">=</span> <span class="token string">"start"</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用so映射的接口函数</span>
        <span class="token keyword">int</span> add <span class="token operator">=</span> LibraryAdd<span class="token punctuation">.</span>LIBRARY_ADD<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相加结果："</span> <span class="token operator">+</span> add<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre>
<p>
那么不管 add 函数对 c 和 msg 做了何种改变，返回 java 中，值都不会被变更。
</p>
<p>
正确的调用方法是：
</p>
<pre><code class="prism language-cpp"><span class="token comment">/\*\*

- 一个 java 类
- 演示指针传输指针变量
  \*/</span>
  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloJNA_Pointer</span> <span class="token punctuation">{<!-- --></span>

      <span class="token comment">/**
       * 定义一个接口，默认的是继承Library ，如果动态链接库里的函数是以stdcall方式输出的，那么就继承StdCallLibrary
       * 这个接口对应一个动态链接(SO)文件
       */</span>
      <span class="token keyword">public</span> interface LibraryAdd extends Library <span class="token punctuation">{<!-- --></span>

          LibraryAdd LIBRARY_ADD <span class="token operator">=</span> Native<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"/program/cpp/libhello.so"</span><span class="token punctuation">,</span> LibraryAdd<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment">/**
           * 指针变量,用Pointer类型定义
           * c是int*
           * msg是char**
           */</span>
          <span class="token keyword">int</span> <span class="token function">add_c</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> Pointer c<span class="token punctuation">,</span> Pointer msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

          Pointer c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Memory</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          Pointer msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Memory</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 调用so映射的接口函数</span>
          <span class="token keyword">int</span> add <span class="token operator">=</span> LibraryAdd<span class="token punctuation">.</span>LIBRARY_ADD<span class="token punctuation">.</span><span class="token function">add_c</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相加结果："</span> <span class="token operator">+</span> add<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment">// 指针变量</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c的值："</span> <span class="token operator">+</span> c<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 这样才能拿到</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"msg的值："</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          Native<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//手动释放内存</span>
          Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//避免Memory对象被GC时重复执行Nativ.free()方法</span>

          Native<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//手动释放内存</span>
          Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//避免Memory对象被GC时重复执行Nativ.free()方法</span>
      <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>

</code></pre>
<p>
<strong>
注意
</strong>
：在使用 jna 指针的时候需要首先申请一块内存
</p>
<pre><code class="prism language-cpp">Pointer c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Memory</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Pointer msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Memory</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>
最后在使用完之后手动的释放这片内存
</p>
<pre><code class="prism language-cpp">Native<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//手动释放内存</span>
Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//避免 Memory 对象被 GC 时重复执行 Nativ.free()方法</span>
Native<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Pointer<span class="token punctuation">.</span><span class="token function">nativeValue</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre>
<p>
<strong>
JNA 结构体
</strong>
<br/>
java 中没有结构体的概念，但是 c/c++中结构体的使用非常频繁，为了解决这个问题，jna 引入了类 Structure ，如果在 Java 中定义一个结构体，只需要集成这个 Structure 即可。Structure 初次使用，细节比较多，话不多说直接上代码，需要注意的地方会有注释：
</p>
<pre><code class="prism language-cpp"><span class="token comment">//1:使用 FieldOrder 注解标注结构体成员的顺序，切记顺序一定不能弄错，</span>
<span class="token comment">//不然结构体取出来的值会路透不对马嘴，因为结构体成员在内存中是依次排列的，</span>
<span class="token comment">//如果顺序弄错 jvm 照着这个顺序按成员变量的类型取值肯定会错了</span>
@Structure<span class="token punctuation">.</span><span class="token function">FieldOrder</span><span class="token punctuation">(</span>value<span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"beginLoc"</span><span class="token punctuation">,</span><span class="token string">"confidence"</span><span class="token punctuation">,</span><span class="token string">"x"</span><span class="token punctuation">,</span><span class="token string">"y"</span><span class="token punctuation">,</span><span class="token string">"z"</span><span class="token punctuation">,</span><span class="token string">"theta"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PalletLocStruct</span> extends Structure <span class="token punctuation">{<!-- --></span>
<span class="token comment">//2:这个地方必须 public 不能 private</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> beginLoc<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">float</span> confidence <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">float</span> theta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">//3:这个地方具体原理不知道，只知道声明之后，当前结构体可以按照引用或者值取值</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ByReference</span> extends PalletLocStruct implements Structure<span class="token punctuation">.</span>ByReference <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ByValue</span> extends PalletLocStruct implements Structure<span class="token punctuation">.</span>ByValue<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">//4:这个地方表示当前结构体是内存对齐的，因为 c/c++ 的结构体成员多数情况是内存对齐，</span>
<span class="token comment">//可以想象如果 c/c++内存对齐，而 java 没有内存对齐，那取出来的值肯定也对不上</span>
<span class="token keyword">public</span> <span class="token function">PalletLocStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token function">super</span><span class="token punctuation">(</span>ALIGN_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>
上面代码中 1-4 点要非常注意，还有一点需要注意：如果调用动态链接库直接 return 结构体，那么取值会出现一个非常诡异的现象：
<strong>
“取结构体的第一个成员变量没问题，但是第二个成团变量就对不上了”
</strong>
，我的猜想原因应该是 Java 中结构体每个成员在内存中内存顺序不是连续的，导致第一个成员可以正常取值，但是到了第二个就不能正常取值。目前我还没找到解决方法，所以如果想要返回一个结构体，那么最好用指针的方式，把结构体传给动态链接库，然后再取出结构体里面的值。比如我在项目中这样处理：
<br/>
<strong>
c++
</strong>
</p>
<pre><code class="prism language-cpp"> <span class="token keyword">int</span> <span class="token function">palletDetection</span><span class="token punctuation">(</span>palletLoc<span class="token operator">\*</span> palletLoc<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
palletLocs<span class="token operator">-&gt;</span>confidence <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
palletLocs<span class="token operator">-&gt;</span>theta <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
palletLocs<span class="token operator">-&gt;</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
palletLocs<span class="token operator">-&gt;</span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
palletLocs<span class="token operator">-&gt;</span>z <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>
<strong>
java:
</strong>
</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">palletDetection</span><span class="token punctuation">(</span>PalletLocStruct palletLoc<span class="token punctuation">)</span><span class="token punctuation">;</span>

取值：
palletLoc<span class="token punctuation">.</span>beginLoc <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>
<strong>
JNA 数组
</strong>
<br/>
Java 中数组不是一块连续的内存地址，但是在 c/c++中是连续的，所以我们传递 Java 数组的时候，
<strong>
一定要声明一块连续的内存，且要保证这块内存不会够用
</strong>
，比如传递一个结构体数组：
</p>
<pre><code class="prism language-cpp"><span class="token comment">//为调.so 文件规划一片连续的内存空间 长度位 10</span>
PalletLocStruct<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">(</span>PalletLocStruct<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token function">PalletLocStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3>
<a id="_220">
</a>
写在最后
</h3>
<p>
本来感觉万事俱备只待算法，最后部署联调的时候，出现了这个问题：
</p>
<pre><code class="prism language-bash">java.lang.UnsatisfiedLinkError: Unable to load library <span class="token string">'/javaServer/videoSchedule/libpalletDetector.so'</span><span class="token builtin class-name">:</span>

</code></pre>
<p>
一般这个异常多数是路径设置不对导致，排查一下 java 加载.so 文件路径是否正确或者看一下 dll 或 so 的位数是否和 jdk 一致（32/64）。但是我遇到的是另外一种情况，算法同时编译的.so 引用了两外两个.so 库，但是他编译的时候没有把这两个.so 加进来，所以导致无法加载。这里顺便贴个链接，有需要可以看一下嵌套.so 生成
<a href="https://www.freesion.com/article/46841131235/" rel="nofollow">
https://www.freesion.com/article/46841131235/
</a>
</p>

   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f7a6c343330323634372f:61727469636c652f64657461696c732f313235343635343639" class_="artid" style="display:none">
 </p>
</div>
