---
layout: post
title: "Vue.js-前端项目容器化部署实践极简教程"
date: 2022-05-18 13:10:14 +0800
description: "本文介绍了如何使用Docker和docker-compose将Vue.js前端项目进行容器化部署，通"
keywords: "前端容器化部署"
categories: ['编程语言']
tags: ['前端', 'Vue', 'Npm']
artid: "124840030"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=124840030
    alt: "Vue.js-前端项目容器化部署实践极简教程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=124840030
featuredImagePreview: https://bing.ee123.net/img/rand?artid=124840030
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Vue.js 前端项目容器化部署实践极简教程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atelier-sulphurpool-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     大概一周前，在某个「微雨燕双飞」的下午，我正穿梭于熙熙攘攘的车流人海当中，而被雨水濯洗过的天空略显灰白，傍晚亮起的路灯恍惚中有种朝阳初升的错觉，内心更是涌现出一种「一蓑烟雨任平生」的豁达，我还没来得及给这场内心戏添油加醋，兴哥的电话突然打断了我的思绪。一番攀谈交心，我了解到，他想问的是前端容器化部署的相关问题。虽然，靠着兴哥的睿智、果敢，他第二天就想明白了整个事情的来龙去脉；但是，这完全不影响我水一篇博客出来。所以，今天这篇文章，我们来聊聊前端项目的容器化部署，并提供一个极简的实践教程，这里以
     <code>
      Vue.js
     </code>
     为例，希望对大家有所启发。
    </p>
    <p>
     <img alt="你说，这像太阳吗？" src="https://i-blog.csdnimg.cn/blog_migrate/6a883226cc22958609e939e65732fcc9.jpeg#pic_center"/>
    </p>
    <p>
     首先，我们来编写
     <code>
      Dockerfile
     </code>
     ，这里采用的是多阶段构建的做法，第一个阶段，即
     <code>
      build
     </code>
     ，主要是利用
     <a href="https://nodejs.org/en/" rel="nofollow">
      node.js
     </a>
     基础镜像来实现前端项目的发布，所以，你可以看到
     <code>
      package.json
     </code>
     、
     <code>
      npm install
     </code>
     以及考虑到国情的
     <code>
      cnpm install
     </code>
     这些前端项目中喜闻乐见的东西，安装完依赖以后我们通过
     <code>
      npm run build
     </code>
     来完成打包，这取决于你项目中实际使用的脚本或者命令，如果你不喜欢
     <code>
      npm
     </code>
     ，你同样可以用
     <code>
      yarn
     </code>
     来编写这些指令，只要你喜欢就好。做人嘛，最重要的是开心！
    </p>
    <pre><code class="prism language-dockfile"># build
FROM node:lts-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install -g cnpm --registry=https://registry.npm.taobao.org
RUN cnpm install
COPY . .
RUN npm run build

# deploy
FROM nginx:stable-alpine as deploy
COPY --from=build /app/dist/ /usr/nginx/wwwroot
COPY /nginx/nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
</code></pre>
    <p>
     OK，第二个阶段，即
     <code>
      deploy
     </code>
     ，前端发布出来的产物是无法直接在浏览器里打开的，这一点你平时用
     <a href="https://vuejs.org/" rel="nofollow">
      Vue.js
     </a>
     的脚手架的话应该会注意到。所以，此时我们需要一个静态文件服务器来托管这些产物，这些产物通常会被放到
     <code>
      dist
     </code>
     目录，因此，在这一阶段主要就是把这个目录里的内容拷贝到
     <a href="https://nginx.org/en/" rel="nofollow">
      Nginx
     </a>
     下面，这里我们用的是
     <code>
      wwwroot
     </code>
     。当然，如果你还怀念曾经的 LAMP 組合，同样可以替换为
     <a href="https://apache.org/" rel="nofollow">
      Apache
     </a>
     。我们在这个世界的一切努力，无非是为了比别人多一种选择，甚至有时候你完全没有选择。可是在计算机的世界里，你可以尽情地去创造，而这则是我的选择，从我高中在班级电脑上写出第一个 Visual Basic 程序开始，我庆幸能一直坚持这份热爱到现在。
    </p>
    <pre><code class="prism language-conf">worker_processes 1;

events {
    worker_connections  1024;
}

http {
    include  mime.types;
    default_type  application/octet-stream;
    sendfile  on;
    keepalive_timeout  65;
    server {
        listen  80;
        server_name  localhost;
        root /usr/nginx/wwwroot;
        index index.html;
    }
}
</code></pre>
    <p>
     这里提到了
     <code>
      Nginx
     </code>
     ，那么，自然而然地，对于
     <code>
      Nginx
     </code>
     的配置问题就无可避免。可惜，事实是：
     <strong>
      每一个声称配置文件更灵活的人，从来都不会去摆弄配置文件，只有程序员天天和这些配置文件打交道
     </strong>
     。幸运的是，对于简单的静态文件服务器而言，它的配置并不算特别复杂，还记得前面的
     <code>
      wwwroot
     </code>
     吗？其实，它是在这里定义的，对应了
     <code>
      server
     </code>
     节点中的
     <code>
      root
     </code>
     属性，从这里我们可以看到，容器内部默认监听 80 端口，默认页面是 index.html。如果你现在还不太了解 Nginx 的配置文件，相信我，这几个配置已足够你快速上手啦！我不大愿意再写教程的原因是，我不喜欢每个步骤都要截图，并且还要在图上做好标记。显然，对于程序员而言，懒惰是一种美德。
    </p>
    <pre><code class="prism language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">font_mock</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile
    <span class="token key atrule">image</span><span class="token punctuation">:</span> font_mock
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"50001:80"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'/etc/localtime:/etc/localtime:ro'</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token key atrule">envoymesh</span><span class="token punctuation">:</span>
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">envoymesh</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre>
    <p>
     好了，现在万事具备，我们再来写一个
     <code>
      docker-compose.yaml
     </code>
     来对服务进行编排，可以注意到，我们把
     <code>
      50001
     </code>
     端口绑定到了
     <code>
      80
     </code>
     端口，这就和前面呼应上了，对不对？剩下的就没什么好说的啦，不再一一赘述，如果你看不懂，可以先去了解一下
     <a href="https://docs.docker.com/compose/" rel="nofollow">
      docker-compose
     </a>
     。此时，我们运行
     <code>
      docker-compose up
     </code>
     命令，就可以看到下面的结果：
    </p>
    <p>
     <img alt="通过 Docker 部署前端项目" src="https://i-blog.csdnimg.cn/blog_migrate/e627343104a186460d9d238f7465114f.png#pic_center"/>
    </p>
    <p>
     没错，我为了节省写作时间，直接使用了
     <a href="https://blog.yuanpei.me/posts/interface-mock-implemention-using-mock.js-in-vue.js/" rel="nofollow">
      在 Vue.js 中使用 Mock.js 实现接口模拟
     </a>
     这篇文章里的项目，果然，我再次完美发扬了 “懒惰” 这种优秀的美德，总而言之，到这里我们已经成功地通过容器技术部署了一个前端项目，在这个基础上，你还可以接入
     <code>
      Envoy
     </code>
     这个代理层 或者 是为
     <code>
      Nginx
     </code>
     添加
     <code>
      SSL
     </code>
     证书等等…当然，这些都是后话啦，各位比我聪明千倍、万倍的读者朋友们可以进一步去完善它，这篇短浅易懂的文章就当作诸位的入门教程好啦，愿「他山之石，可以攻玉」，谢谢大家，本文完！
    </p>
    <pre><code class="prism language-bash"><span class="token comment"># 创建 CA 密钥</span>
openssl genrsa -out ca.key <span class="token number">1024</span>
<span class="token comment"># 利用 CA 密钥生成自签名 CA 证书</span>
openssl req -new -x509 -days <span class="token number">3650</span> -key ca.key -out ca.crt
<span class="token comment"># 创建服务器端证书密钥</span>
openssl genrsa -des3 -out server.key <span class="token number">1024</span>
<span class="token comment"># 生成服务器端证书</span>
openssl req -new -key server.key -out server.csr
<span class="token comment"># 利用 CA 证书对服务器端证书进行签名</span>
openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key
</code></pre>
    <p>
     此时，我们会得到服务器端证书文件
     <code>
      server.crt
     </code>
     以及密钥文件
     <code>
      server.key
     </code>
     ，我们将其配置到
     <code>
      Nginx
     </code>
     中即可，下面是修改后的
     <code>
      Nginx
     </code>
     配置文件：
    </p>
    <pre><code class="prism language-conf">worker_processes 1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
 
    sendfile        on;
    keepalive_timeout  65;
 
    server {
        listen  80;
        listen  443 ssl;
        server_name  localhost;
        
        # 证书文件
        ssl_certificate      /usr/nginx/ssl/server.crt;
        # 密钥文件
        ssl_certificate_key  /usr/nginx/ssl/server.key;
        # SSL 会话缓存大小为：1M
        ssl_session_cache    shared:SSL:1m;
        # SSL 会话超时时间为：5min
        ssl_session_timeout  5m;
        # 支持 TLS1.0/1.1/1.2 三个版本
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;

        root /usr/nginx/wwwroot;
        index index.html;
    }
}
</code></pre>
    <p>
     需要注意的是，在创建证书时，对应的
     <code>
      Common Name
     </code>
     应该和网站的域名保持一致，这里的示例域名为：
     <code>
      https://www.snowfly.com
     </code>
     ，在本地调试的时候，我们可以通过修改
     <code>
      hosts
     </code>
     文件来进行测试：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/92700c64fe1773cdf538dc1e916b14d6.png#pic_center">
      通常，你需要把自己创建的证书导入到
      <code>
       受信任的根证书颁发机构
      </code>
      这个分类下面，这样，就可以通过
      <code>
       HTTPS
      </code>
      协议访问你的站点啦！
     </img>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e149c75fcc6aaafa6ed0c4f0b591448f.png#pic_center"/>
    </p>
    <blockquote>
     <p>
      番外预告！！！接下来会写一篇关于 ASP.NET Core 单元/集成测试的文章，敬请期待！
     </p>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71696e7975616e7065692f:61727469636c652f64657461696c732f313234383430303330" class_="artid" style="display:none">
 </p>
</div>


