---
layout: post
title: "Linux1入门的开始Linux基本指令"
date: 2025-08-30T23:21:23+0800
description: "摘要： 本文系统介绍了操作系统的基础概念与Linux核心指令。操作系统作为软硬件管理的中间层，核心标准是稳定、高效、安全。Linux采用多叉树目录结构，通过路径（绝对/相对）定位文件。重点讲解了基础指令：ls查看目录内容（含-l、-a等选项）、pwd显示当前路径、cd切换目录、touch创建文件、mkdir建立目录（-p可递归创建）。操作本质是对多叉树的增删查改，而.和..分别表示当前目录与上级目录。掌握这些指令是Linux操作的基础，建议通过实践巩固记忆，为后续深入学习铺垫。"
keywords: "Linux(1)|入门的开始：Linux基本指令"
categories: ['系统与网络编程', '企鹅程序员Linux']
tags: ['Linux', 'Centos']
artid: "150997691"
arturl: "https://blog.csdn.net/black_bear_white/article/details/150997691"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150997691
    alt: "Linux1入门的开始Linux基本指令"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150997691
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150997691
cover: https://bing.ee123.net/img/rand?artid=150997691
image: https://bing.ee123.net/img/rand?artid=150997691
img: https://bing.ee123.net/img/rand?artid=150997691
---



# Linux(1)|入门的开始：Linux基本指令



## 

## 一、浅谈操作系统

### 1、操作系统是什么？

操作系统是一款做软硬件**管理**的软件

![](https://i-blog.csdnimg.cn/direct/bc382ca9e5ad4e758d60f143425b1cb4.png)

我们可以发现除了上面的应用软件，操作系统、设备驱动和硬件都是为软硬件服务的，为了满足用户的不同需求，在操作系统之上需要有各种不同的应用软件。

### 2、一个好的操作系统衡量标准是什么？

假如你是用户，在你进行各种操作的时候，一会系统崩溃蓝屏了，响应操作一会卡顿，一会正常的，你肯定下次不会再考虑使用了，所以操作系统的**稳定**是其中的一个标准；当我们正准备和朋友来一场激情的双人大战时，电脑开机的速度十分龟速，但好在成功开机了，正兴致冲冲的点开游戏时，发现鼠标怎么点击也没有反应，等到右下角弹起鼠标驱动程序加载完成，鼠标这才有了反应，由此一个操作系统的**速度快不快**也是标准之一；在网络时代，我们对于自己的隐私是及其关注的，如果一个操作系统连最基本的**安全**都做不到，那就很难有人使用了。

所以**稳定、速度、安全**是衡量操作系统是否良好的标准。

### 3、为什么要有操作系统？

**操作系统的核心工作：**通过对下管理好软硬件资源的手段，达到对上提供良好的(**稳定、速度、安全**)的操作环境/使用环境

### 4、如何理解我们在计算机上的所有操作？

例如我们c语言的printf->将内容打印到显示屏上

c语言文件操作->对磁盘文件的读写操作等等

我们能发现我们在计算机上的所有行为都会转换成硬件行为！

![](https://i-blog.csdnimg.cn/direct/b63b064a5ec543dab46a2d0497f40aa2.png)

我们所有的行为，全部都要自上而下贯穿计算机的软硬件结构。

这种自上而下打个生动形象的比方，硬件就像下面的“牛马”程序员，设备驱动就像项目经理，管理和分配任务，给我们下面的“牛马”程序员，而操作系统像是我们的大boos，评判和决策项目，将指标丢给我们项目经理也就是设备驱动。

因此，我们也能推断出几乎我们的所有行为，未来都和操作系统直接或间接相关！

### 5、Linux操作系统和windows操作系统

Linux操作系统的特点：纯命令行，当然Linux也有图形化界面，不过早期Linux都是科研人员、专业人员使用的；windows操作系统的特点：图形化界面，为了用户的使用体验，比起一行行命令行，清晰可视化的图像化界面无疑更加，不过我们仍然可以通过win+R，输入cmd打开windows的命令行终端。无论是指令还是图形化界面，本质其实都是相同的。

### 6、是先有指令，还是现有图形化界面？是先有键盘，还是现有鼠标？为什么？

第一个问题肯定是现有指令，后有图形化界面。键盘和鼠标谁先出现呢？通过指令和图形化界面的顺序我们能推断出键盘肯定是先出现的，为什么呢？首先早期计算机是关注输入和输出的，键盘硬件的出现，实现了计算机的输入。可能大家都曾好奇过，为什么键盘的排列顺序这么奇怪，而键盘的前身正是沿用老式打字机排版。鼠标的出现为图形化界面带来实际意义，如果没有鼠标的点击，图形化界面，就发挥不了原本的功能。

## 二、部分基本指令和知识的补充

### 1、ls指令

#### 语法：ls空格[选项]空格[目录或文件]

#### 功能：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息

#### 常见选项：

##### -l：列出文件的详细信息

```

[xzx@instance-157t533k ~]$ mkdir dir1
[xzx@instance-157t533k ~]$ mkdir dir2
[xzx@instance-157t533k ~]$ mkdir text.txt
[xzx@instance-157t533k ~]$ ls -l
total 12
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:39 dir1
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:40 dir2
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:40 text.txt

```

我们通过mkdir新建目录，dir1、dir2和test.txt，通过ls -l，我们能看到目录的名字，目录的最近一次修改时间，目录的内存大小

```

[xzx@instance-157t533k ~]$ ls
dir1  dir2  text.txt

```

而我们单独使用ls只会列出该目录下的所有子目录与文件

同时我们的ls -l 是等价于ll的

```

[xzx@instance-157t533k ~]$ ls -l
total 12
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:39 dir1
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:40 dir2
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:40 text.txt
[xzx@instance-157t533k ~]$ ll
total 12
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:39 dir1
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:40 dir2
drwxrwxr-x 2 xzx xzx 4096 Aug 30 11:40 text.txt

```

可以看到两次的结果是相同的，所以在日常使用中可以简写命名行

##### -a：列出目录下的所有文件，包括以.开头的隐含文件、

```

[xzx@instance-157t533k ~]$ ls -a
.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .config  dir1  dir2  text.txt

```

此时能看到与之前ls展示的文件相比，多出了以.开头的文件和.、..这两个文件(后面在单独解释)

我们的-l -a可以一起使用，并且-l -a 等价与-al等价与-la

```

[xzx@instance-157t533k ~]$ ls -a -l
total 44
drwx------  7 xzx  xzx  4096 Aug 30 11:40 .
drwxr-xr-x. 3 root root 4096 Aug 29 19:42 ..
-rw-------  1 xzx  xzx   216 Aug 30 11:53 .bash_history
-rw-r--r--  1 xzx  xzx    18 Nov 25  2021 .bash_logout
-rw-r--r--  1 xzx  xzx   193 Nov 25  2021 .bash_profile
-rw-r--r--  1 xzx  xzx   231 Nov 25  2021 .bashrc
drwxrwxr-x  3 xzx  xzx  4096 Aug 29 16:24 .cache
drwxrwxr-x  3 xzx  xzx  4096 Aug 29 16:24 .config
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:39 dir1
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:40 dir2
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:40 text.txt
[xzx@instance-157t533k ~]$ ls -al
total 44
drwx------  7 xzx  xzx  4096 Aug 30 11:40 .
drwxr-xr-x. 3 root root 4096 Aug 29 19:42 ..
-rw-------  1 xzx  xzx   237 Aug 30 11:58 .bash_history
-rw-r--r--  1 xzx  xzx    18 Nov 25  2021 .bash_logout
-rw-r--r--  1 xzx  xzx   193 Nov 25  2021 .bash_profile
-rw-r--r--  1 xzx  xzx   231 Nov 25  2021 .bashrc
drwxrwxr-x  3 xzx  xzx  4096 Aug 29 16:24 .cache
drwxrwxr-x  3 xzx  xzx  4096 Aug 29 16:24 .config
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:39 dir1
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:40 dir2
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:40 text.txt
[xzx@instance-157t533k ~]$ ls -la
total 44
drwx------  7 xzx  xzx  4096 Aug 30 11:40 .
drwxr-xr-x. 3 root root 4096 Aug 29 19:42 ..
-rw-------  1 xzx  xzx   256 Aug 30 11:58 .bash_history
-rw-r--r--  1 xzx  xzx    18 Nov 25  2021 .bash_logout
-rw-r--r--  1 xzx  xzx   193 Nov 25  2021 .bash_profile
-rw-r--r--  1 xzx  xzx   231 Nov 25  2021 .bashrc
drwxrwxr-x  3 xzx  xzx  4096 Aug 29 16:24 .cache
drwxrwxr-x  3 xzx  xzx  4096 Aug 29 16:24 .config
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:39 dir1
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:40 dir2
drwxrwxr-x  2 xzx  xzx  4096 Aug 30 11:40 text.txt

```

-al或者-la或者-l -a：列出所有文件，包括隐藏文件的详细信息

**文件类型：以d开头：是一个目录，以-开头：是一个普通文件**

##### **-d：将目录像文件一样显示，而不是显示其下的文件**

```

[xzx@instance-157t533k ~]$ ls
dir1  dir2  text.txt
[xzx@instance-157t533k ~]$ ls -dl
drwx------ 7 xzx xzx 4096 Aug 30 11:40 .

```

我们的ls展示当前目录下我们的子目录，但我们想要知道我们当前目录的详细信息，则可以通过-d -l或者-dl，得到当前目录的详细信息

##### -F：在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表 示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。（目录类型识别）

```

[xzx@instance-157t533k ~]$ ls -aF
./   .bash_history  .bash_profile  .cache/   dir1/  text.txt/
../  .bash_logout   .bashrc        .config/  dir2/

```

### 2、pwd指令

#### 语法：pwd

#### 功能：显示用户当前所在的目录

#### 常用选项：无

```

[xzx@instance-157t533k ~]$ cd dir1
[xzx@instance-157t533k dir1]$ pwd
/home/xzx/dir1
[xzx@instance-157t533k dir1]$ mkdir dirr1
[xzx@instance-157t533k dir1]$ cd dirr1
[xzx@instance-157t533k dirr1]$ pwd
/home/xzx/dir1/dirr1

```

我们通过cd进入到dirr1，pwd打印的结果也证明了我们进入到dirr1目录中

这里展示的路径由“/”分割，所以“/”又叫做路径分隔符

### 一个目录里面可以放多个目录或者普通文件吗？可以的

**由此我们能推断出Linux的整个目录结构：一定是一个多叉树的样子**

#### Linux的目录结构整体是一个多叉树，它的叶子节点一定是空目录或者非目录文件，路上节点一定是分空目录

![](https://i-blog.csdnimg.cn/direct/78862db75b444da5a8929fc820417d7f.png)

**所以我们所有的对文件或者目录的增删查改，本质都是对这颗多叉树的增删查改**

### .和..是什么？

#### Linux下任何一个目录下面都有两个隐藏文件.和..

##### .：表示当前路径

通过pwd：显示当前命令行操作时所处的目录。超级用户/root...，普通用户/home/名字

```

[xzx@instance-157t533k dir1]$ pwd
/home/xzx/dir1
[xzx@instance-157t533k dir1]$ cd .
[xzx@instance-157t533k dir1]$ pwd
/home/xzx/dir1

```

这里使用普通用户演示，cd：进入目录，我们先pwd查看自己当前所在目录，cd .后继续pwd，发现我们所处目录未改变

**而.存在的意义：帮助用户定位当前目录下的一个文件**

##### ..：表示当前路径的上级路径

```

[xzx@instance-157t533k 8_30]$ cd test
[xzx@instance-157t533k test]$ pwd
/home/xzx/8_30/test
[xzx@instance-157t533k test]$ cd ..
[xzx@instance-157t533k 8_30]$ pwd
/home/xzx/8_30

```

我们通过cd进入test目录，pwd显示当前所在目录。cd ..后再pwd，可以看到我们退回到了8_30这个目录

### 借用上面的示例图，我们如何找到test.c这个文件呢？

很明显就像一条路线一样，从/->home->bit->test.c，所以我们定位一个文件，通常用**路径**来进行定位，而路径定位则需要确保**唯一性**。

### 为什么路径定位具有唯一性？

对于任何一个节点都只有一个父节点，由子到父的顺序是**唯一**，所以路径定位具有**唯一性**

### **路径的分类**

#### **1、绝对路径**

对于/home/bit/test.c，这样从根目录(/)开始定位到指定位置，具有唯一的路径，称之为**绝对路径**

#### 2、相对路径

假如我们的lin路径下有一个c++.txt的文件，而我们当前所在目录为/usr/bin，我们从bin到c++.txt，只需要../lin/c++.txt即可，而这种以当前所处的路径为起始参考位置，来进行特定文件的定位，这种路径称为：**相对路径**

相对路径的**缺点**：当所处的路径发生变化，可能会导致相对路径发生变化

### 我们该怎么使用？

#### 1、绝对路径往往比较长，但是能保证不变，一般在固定场景配置文件中使用

#### 2、一般命令行输入，比较常用相对路径

### 3、cd指令

#### 语法：cd空格目录名

#### 功能：改变工作目录。将当前工作目录改变到指定的目录下

#### 常见选项：

##### 1、cd ..：返回上级路径

```

[xzx@instance-157t533k 8_30]$ cd test
[xzx@instance-157t533k test]$ pwd
/home/xzx/8_30/test
[xzx@instance-157t533k test]$ cd ..
[xzx@instance-157t533k 8_30]$ pwd
/home/xzx/8_30
```

##### 2、cd /home/zhangsan/Linux/：绝对路径

##### 3、cd ../lisi/Linux/：相对路径

##### 4、cd ~：进入用户的家目录

```

[xzx@instance-157t533k 8_30]$ pwd
/home/xzx/8_30
[xzx@instance-157t533k 8_30]$ cd ~
[xzx@instance-157t533k ~]$ pwd
/home/xzx

```

###### 家目录的区别：root用户的家目录是/root，普通用户的家目录是/home/xxx这里xxx代表用户的名字

##### 5、cd -：返回最近(上一次)访问的目录

```

[xzx@instance-157t533k 8_30]$ pwd
/home/xzx/8_30
[xzx@instance-157t533k 8_30]$ cd test
[xzx@instance-157t533k test]$ pwd
/home/xzx/8_30/test
[xzx@instance-157t533k test]$ cd -
/home/xzx/8_30

```

### 4、touch指令

#### 语法：touch空格[选项]...文件...

#### 功能：touch命令参数可更改文档或者目录的日期时间，包括存取时间和更改时间，或者建立一个不存在的文件

#### 常见选项：

##### touch空格+文件名：创建一个普通文件

```

[xzx@instance-157t533k 8_30]$ touch data.txt
[xzx@instance-157t533k 8_30]$ ll
total 192
-rw-rw-r-- 1 xzx xzx      0 Aug 30 22:53 data.txt
-rw-rw-r-- 1 xzx xzx 168894 Aug 30 19:55 log.txt
-rw-rw-r-- 1 xzx xzx  16233 Aug 30 20:44 temp.txt
drwxrwxr-x 2 xzx xzx   4096 Aug 30 22:01 test
-rw-rw-r-- 1 xzx xzx    133 Aug 30 18:51 test.c

```

### 5、mkdir指令

#### 语法：mkdir空格[选项]dirname...

#### 功能：在当前目录下创建一个名为“dirname”的目录

#### 常用选项：

```

[xzx@instance-157t533k 8_30]$ mkdir d1
[xzx@instance-157t533k 8_30]$ cd d1
[xzx@instance-157t533k d1]$ mkdir d2
[xzx@instance-157t533k d1]$ cd d2
[xzx@instance-157t533k d2]$ mkdir d3
[xzx@instance-157t533k d2]$ cd d3
[xzx@instance-157t533k d3]$ pwd
/home/xzx/8_30/d1/d2/d3

```

我们想要创建d1/d2/d3这样的路径，如果这样一层一层的创建，显然十分麻烦，此时-p排上用场

##### -p：-p，-parents可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录

```

[xzx@instance-157t533k 8_30]$ mkdir -p d11/d22/d33
[xzx@instance-157t533k 8_30]$ tree
.
├── d1
│   └── d2
│       └── d3
├── d11
│   └── d22
│       └── d33
├── data.txt
├── log.txt
├── temp.txt
├── test
└── test.c

```

通过mkdir -p d11/d22/d33，一次性创立出一整条路经，对于这种树形展示当前目录和文件，下面会单独介绍

### 树形展示

#### 1、xshell是没有自带的，我们输入tree指令没有反应

#### 2、需要一个root账号

#### 3、输入 yum install -y tree 回车后，系统自动开始安装

## 结尾

到这里，关于操作系统的基础认知和 Linux 核心指令的分享就暂告一段落了。从理解操作系统如何充当软硬件的 “中间人”，到亲手用指令操控文件与目录，其实我们每一次输入命令、查看结果的过程，都是在和计算机的底层逻辑对话。

这些基础指令看似简单，却是玩转 Linux 的第一步 —— 后续无论是处理文件、管理进程，还是搭建服务，都离不开这些 “基本功”。如果刚开始记不住所有选项也没关系，多动手尝试`ls -l`看文件详情、用`cd ..`回退目录、拿`mkdir -p`创建层级路径，慢慢就会形成肌肉记忆。

操作系统的世界远不止这些，还有更多底层原理和实用技巧等着探索。希望这篇内容能帮你推开大门，接下来就带着好奇心，继续在指令行里 “折腾” 吧！



