---
layout: post
title: "优选算法合集双指针专题四"
date: 2025-03-15 00:14:47 +0800
description: "题目描述：描述给定一个长度为n的数组a1,a2,....ana1​,a2​,....an​.接下来有q次查询, 每次查询有两个参数l, r.对于每个询问, 请输出al+al+1+....+aral​+al+1​+....+ar​输入描述：第一行包含两个整数n和q.第二行包含n个整数, 表示a1,a2,....ana1​,a2​,....an​.接下来q行,每行包含两个整数   l和r.输出描述：输出q行,每行代表一次查询的结果.示例1输入：3 21 2 41 22 3。"
keywords: "优选算法合集————双指针(专题四)"
categories: ['未分类']
tags: ['算法', '前缀和', 'Java']
artid: "146191447"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146191447
    alt: "优选算法合集双指针专题四"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146191447
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146191447
cover: https://bing.ee123.net/img/rand?artid=146191447
image: https://bing.ee123.net/img/rand?artid=146191447
img: https://bing.ee123.net/img/rand?artid=146191447
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     优选算法合集————双指针(专题四)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1，一维前缀和模版
    </h2>
    <p>
     题目描述：
    </p>
    <p>
     描述
    </p>
    <p>
     给定一个长度为n的数组a1,a2,....ana1​,a2​,....an​.
    </p>
    <p>
     接下来有q次查询, 每次查询有两个参数l, r.
    </p>
    <p>
     对于每个询问, 请输出al+al+1+....+aral​+al+1​+....+ar​
    </p>
    <p>
     输入描述：
    </p>
    <p>
     第一行包含两个整数n和q.
    </p>
    <p>
     第二行包含n个整数, 表示a1,a2,....ana1​,a2​,....an​.
    </p>
    <p>
     接下来q行,每行包含两个整数   l和r.
    </p>
    <p>
     1≤n,q≤1051≤n,q≤105
     <br/>
     −109≤a[i]≤109−109≤a[i]≤109
     <br/>
     1≤l≤r≤n1≤l≤r≤n
    </p>
    <p>
     输出描述：
    </p>
    <p>
     输出q行,每行代表一次查询的结果.
    </p>
    <p>
     示例1
    </p>
    <p>
     输入：
    </p>
    <pre>3 2
1 2 4
1 2
2 3</pre>
    <p>
     复制输出：
    </p>
    <pre>3
6
</pre>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题是前缀和的典型模版，前缀和是什么的，从头开始到当前下标前面所有元素的累加，我们可以把前缀和抽象成一个公式，
    </p>
    <p>
     <img src="https://i-blog.csdnimg.cn/direct/7fd9a6a53b5446c08ed76c84b6a73f31.png"/>
    </p>
    <p>
     这里大家一定一定不能混淆，dp[0]并不是从0下标开始的， 因为dp公式i为0的时候dp[i-1]是不存在的，我们只能从dp[1]开始，dp[1]才是真正对应arr[]数组的0下标，dp公式是怎么来的呢，我们可以观察到，dp[i]的值都是由当前arr[i]的元素和前一个下标的前缀和组成的，
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      直接初始化前缀和公式，使用前缀和公式快速求值；
     </p>
     <p>
      这道题有一些细节问题，题目中要求的是a1到an的值我们从零下标开始拷贝到数组中时不行的，所以我们初始化数组的时候容量要设置为[n+1]；
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int q = in.nextInt();
        int[] arr = new int[n+1];
        for(int i = 1;i&lt;=n;i++){
            arr[i] = in.nextInt();
        }
        long[] dp = new long[n+1];
        for(int i = 1;i&lt;=n;i++){
            dp[i] = dp[i-1] + arr[i];
        }
        while(q&gt;0){
            int l = in.nextInt();
            int r = in.nextInt();
            q--;
            System.out.println(dp[r]-dp[l-1]);
        }
    }
}</code></pre>
    <hr/>
    <h2>
     2，二维前缀和模版
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     描述
    </p>
    <p>
     给你一个 n 行 m 列的矩阵 A ，下标从1开始。
     <br/>
     <br/>
     接下来有 q 次查询，每次查询输入 4 个参数 x1 , y1 , x2 , y2
     <br/>
     <br/>
     请输出以 (x1, y1) 为左上角 , (x2,y2) 为右下角的子矩阵的和，
    </p>
    <p>
     输入描述：
    </p>
    <p>
     第一行包含三个整数n,m,q.
     <br/>
     <br/>
     接下来n行，每行m个整数，代表矩阵的元素
     <br/>
     <br/>
     接下来q行，每行4个整数x1, y1, x2, y2，分别代表这次查询的参数
     <br/>
     <br/>
     1≤n,m≤10001≤n,m≤1000
     <br/>
     1≤q≤1051≤q≤105
     <br/>
     −109≤a[i][j]≤109−109≤a[i][j]≤109
     <br/>
     1≤x1≤x2≤n1≤x1​≤x2​≤n
     <br/>
     1≤y1≤y2≤m1≤y1​≤y2​≤m
    </p>
    <p>
     输出描述：
    </p>
    <p>
     输出q行，每行表示查询结果。
    </p>
    <p>
     示例1
    </p>
    <p>
     输入：
    </p>
    <pre>3 4 3
1 2 3 4
3 2 1 0
1 5 7 8
1 1 2 2
1 1 3 3
1 2 3 4</pre>
    <p>
     复制输出：
    </p>
    <pre>8
25
32</pre>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题给了我们一个n行m列的矩阵，我们要进行q次查询，每次查询输入4个数，分别是x1,y1,x2,y2,我们要根据这4个下标求出（y2-y1+1）*（x2-x1+1）这一区域所有元素的和；
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      暴力解法绝对不可能了，每次找数都是O(n2)的时间复杂度的，q次查询，如果q很大我们根本承担不起，我们引出二维前缀和，这题就是个典型模版，二维前缀和就是从1,1位置到（x，y）位置的所有和，那么这道题怎么解呢：
     </p>
     <p>
      1，列出二维前缀和的状态转移方程
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/1138337c82464bb39ea4b8ed50dabf92.jpeg"/>
     </p>
     <p>
      2，指定我们要的区域列出新的方程
     </p>
     <p>
      这道题还是从1开始的，所以我们dp方程和二维数组是对应的，如果二维数组是0的话就要考虑考虑了；
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/61e2635571b64cf2bd61dccdf2adb2c2.jpeg"/>
     </p>
     <p>
      这里我直接用纸写了，太懒了；
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int q = in.nextInt();
        int[][] arr = new int[n+1][m+1];
        for(int i = 1;i&lt;=n;i++){
            for(int j = 1;j&lt;=m;j++){
                arr[i][j] = in.nextInt();
            }
        }
        long[][] dp = new long[n+1][m+1];
        for(int i = 1;i&lt;=n;i++){
            for(int j = 1;j&lt;=m;j++){
                dp[i][j] = dp[i][j-1]+dp[i-1][j]+arr[i][j]-dp[i-1][j-1];
            }
        }

        while(q&gt;=1){
            int x1 = in.nextInt();
            int y1 = in.nextInt();
            int x2 = in.nextInt();
            int y2 = in.nextInt();
            q--;
            long a = dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1];
            System.out.println(a);
        }
    }
}</code></pre>
    <hr/>
    <h2>
     3，寻找数组的中心下标
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，请计算数组的
     <strong>
      中心下标
     </strong>
     。
    </p>
    <p>
     数组
     <strong>
      中心下标
     </strong>
     <strong>
     </strong>
     是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
    </p>
    <p>
     如果中心下标位于数组最左端，那么左侧数之和视为
     <code>
      0
     </code>
     ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
    </p>
    <p>
     如果数组有多个中心下标，应该返回
     <strong>
      最靠近左边
     </strong>
     的那一个。如果数组不存在中心下标，返回
     <code>
      -1
     </code>
     。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [1,7,3,6,5,6]
<strong>输出：</strong>3
<strong>解释：</strong>
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [1, 2, 3]
<strong>输出：</strong>-1
<strong>解释：</strong>
数组中不存在满足此条件的中心下标。</pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [2, 1, -1]
<strong>输出：</strong>0
<strong>解释：</strong>
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</pre>
    <p>
    </p>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题给了我们一个数组，我们要找到一个下标，使得该下标两边的值都相等。如果使用暴力方法的话，首先要遍历每一个元素，在向左向右遍历是不是相等，时间复杂度为O(n2)，那么有没有更简单的方法呢；
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      这道题我们随便找一个中心下标，左边不就是从头开始到当前i-1元素的前缀和吗，后边我们可以反过来看，是一个从末尾到i+1元素的后缀和，所以我们可以写两个dp数组，值进行一次循环遍历，看看当前下标的两个元素和是否相等，我还是用手写来给大家创建一下前缀和；
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/fe1369f710d6456c94f2cb4a4aeb761d.jpeg"/>
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">class Solution {
    public int pivotIndex(int[] nums) {
        int n = nums.length;
        int[] dp1 = new int[n];
        int[] dp2 = new int[n];
        dp1[0] = 0;
        dp2[0] = 0;
        for(int i=1;i&lt;n;i++){
            dp1[i] = dp1[i-1]+nums[i-1];
        }

        for(int i=n-2;i&gt;=0;i--){
            dp2[i] = dp2[i+1]+nums[i+1];
        }
        for(int i = 0;i&lt;n;i++){
            if(dp1[i]==dp2[i]){
                return i;
            }
        }
        return -1;
    }
}</code></pre>
    <hr/>
    <h2>
     4，除自身以外数组的乘积
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，返回 数组
     <code>
      answer
     </code>
     ，其中
     <code>
      answer[i]
     </code>
     等于
     <code>
      nums
     </code>
     中除
     <code>
      nums[i]
     </code>
     之外其余各元素的乘积 。
    </p>
    <p>
     题目数据
     <strong>
      保证
     </strong>
     数组
     <code>
      nums
     </code>
     之中任意元素的全部前缀元素和后缀的乘积都在
     <strong>
      32 位
     </strong>
     整数范围内。
    </p>
    <p>
     请
     <strong>
      不要使用除法，
     </strong>
     且在
     <code>
      O(n)
     </code>
     时间复杂度内完成此题。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1:
     </strong>
    </p>
    <pre><strong>输入:</strong> nums = <code>[1,2,3,4]</code>
<strong>输出:</strong> <code>[24,12,8,6]</code>
</pre>
    <p>
     <strong>
      示例 2:
     </strong>
    </p>
    <pre><strong>输入:</strong> nums = [-1,1,0,-3,3]
<strong>输出:</strong> [0,0,9,0,0]
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       2 &lt;= nums.length &lt;= 105
      </code>
     </li>
     <li>
      <code>
       -30 &lt;= nums[i] &lt;= 30
      </code>
     </li>
     <li>
      输入
      <strong>
       保证
      </strong>
      数组
      <code>
       answer[i]
      </code>
      在
      <strong>
       32 位
      </strong>
      整数范围内
     </li>
    </ul>
    <p>
    </p>
    <p>
     <strong>
      进阶：
     </strong>
     你可以在
     <code>
      O(1)
     </code>
     的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组
     <strong>
      不被视为
     </strong>
     额外空间。）
    </p>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题跟刚才那道题一模一样，给我们一个数组，把除当前下标的所有乘积放到新数组中，那就是左前缀积和右前缀积；
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      和上一题一样，我们直接上图，注意细节，这道题原数组从0开始；
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/f2bb7ef6cb7a4da5970264018ad00902.jpeg"/>
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] dp1 = new int[n];
        int[] dp2 = new int[n];
        int[] answer = new int[n];
        dp1[0] = 1;
        dp2[n-1] = 1;
        for(int i = 1;i&lt;n;i++){
            dp1[i] = dp1[i-1]*nums[i-1];
        }
        for(int i = n-2;i&gt;=0;i--){
            dp2[i] = dp2[i+1]*nums[i+1];
        }
        for(int i=0;i&lt;n;i++){
            answer[i] = dp1[i]*dp2[i];
        }
        return answer;
    }
}</code></pre>
    <hr/>
    <h2>
     5，和为k的子数组
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     给定一个整数数组和一个整数
     <code>
      k
     </code>
     <strong>
      ，
     </strong>
     请找到该数组中和为
     <code>
      k
     </code>
     <strong>
     </strong>
     的连续子数组的个数。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入:</strong>nums = [1,1,1], k = 2
<strong>输出:</strong> 2
<strong>解释:</strong> 此题 [1,1] 与 [1,1] 为两种不同的情况
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入:</strong>nums = [1,2,3], k = 3
<strong>输出:</strong> 2
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示:
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= nums.length &lt;= 2 * 104
      </code>
     </li>
     <li>
      <code>
       -1000 &lt;= nums[i] &lt;= 1000
      </code>
     </li>
     <li>
      <p>
       <code>
        -107 &lt;= k &lt;= 107
       </code>
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题给了我们一个数组和一个元素k，我们要找到连续且和为k的子数组的个数，
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      这道题我们之前讲过一个方法叫滑动窗口，但是这道题不能用，因为这道题有负数，滑动窗口很适合单调的问题，所以我们要找其他的方法，这道题可以使用前缀和，
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/de0687806ac941369578ba9d96d19af2.jpeg"/>
     </p>
     <p>
      看这个图，我们从头到i下标的前缀和是sum，其中某一个元素j的前缀和为sum-k，那么此时i下标到j下标之后这一段区域不就是k吗，那么我们要创建前缀和数组，用两层循环来一个一个判断i到j的和是k吗，那么我们还不如暴力解决它，当我们从i下标开始找sum-k的时候sum-k是可能存在多个的，我们可以把问题转化成我们从i下标开始，找到sum-k出现的次数，我们可以使用哈希表来记录，前缀和出现的次数，我们每次添加的前缀和都是不同j位置的，我们遍历i的时候，去哈希表寻找sum-k出现的次数，就是寻找有多少个j下标与当前i下标是能够构成dp[i]-dp[j-1]的；
     </p>
     <p>
      我们还要先往哈希表中放个0，怕我们i为n-1的时候前缀和就为k，那sum-k就为0了；
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0;
        int count = 0;
        HashMap&lt;Integer,Integer&gt; hash = new HashMap&lt;&gt;();
        hash.put(0,1);
        for(int i=0;i&lt;nums.length;i++){
            sum+=nums[i];
            count+=hash.getOrDefault(sum-k,0);
            hash.put(sum,hash.getOrDefault(sum,0)+1);
        }
        return count;
    }
}</code></pre>
    <hr/>
    <h2>
     6，和可以被k整除的子数组
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     给定一个整数数组
     <code>
      nums
     </code>
     和一个整数
     <code>
      k
     </code>
     ，返回其中元素之和可被
     <code>
      k
     </code>
     整除的非空
     <strong>
      子数组
     </strong>
     的数目。
    </p>
    <p>
     <strong>
      子数组
     </strong>
     是数组中
     <strong>
      连续
     </strong>
     的部分。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [4,5,0,-2,-3,1], k = 5
<strong>输出：</strong>7
<strong>解释：
</strong>有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
</pre>
    <p>
     <strong>
      示例 2:
     </strong>
    </p>
    <pre><strong>输入:</strong> nums = [5], k = 9
<strong>输出:</strong> 0
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示:
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= nums.length &lt;= 3 * 104
      </code>
     </li>
     <li>
      <code>
       -104 &lt;= nums[i] &lt;= 104
      </code>
     </li>
     <li>
      <code>
       2 &lt;= k &lt;= 104
      </code>
     </li>
    </ul>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题和上一题基本一样，但是这道题我们有两个需要掌握的知识；
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      1，同余定理
     </p>
     <p>
      如果(a-n)%p = k(0)  那么a%p=n%p；
     </p>
     <p>
      2，java中保证负数取模为正数  （a%p+p）%p；
     </p>
     <p>
      感兴趣可以搜一下怎么推出来的，我们用就好了；
     </p>
     <p>
      <img src="https://i-blog.csdnimg.cn/direct/554eb803cbb64f62a324799733e81fe2.jpeg">
       我们知道从头开始到i和从头开始到j的前缀和，当sum-x可以整除k的时候，用同余定理就意味着sum%k = x%k，所以我们就可以把问题转化成当为i下标时，找到与sum%k相等的前缀和%k，
      </img>
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int sum = 0;
        int count = 0;
        HashMap&lt;Integer,Integer&gt; hash = new HashMap&lt;&gt;();
        hash.put(0,1);
        for(int i =0;i&lt;nums.length;i++){
            sum+=nums[i];
            count+=hash.getOrDefault((sum%k+k)%k,0);
            hash.put((sum%k+k)%k,hash.getOrDefault((sum%k+k)%k,0)+1);
        }
        return count;
    }
}</code></pre>
    <hr/>
    <h2>
     7，连续数组
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     给定一个二进制数组
     <code>
      nums
     </code>
     , 找到含有相同数量的
     <code>
      0
     </code>
     和
     <code>
      1
     </code>
     的最长连续子数组，并返回该子数组的长度。
    </p>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,1]
<strong>输出：</strong>2
<strong>说明：</strong>[0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,1,0]
<strong>输出：</strong>2
<strong>说明：</strong>[0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><strong>输入：</strong>nums = [0,1,1,1,1,1,0,0,0]
<strong>输出：</strong>6
<strong>解释：</strong>[1,1,1,0,0,0] 是具有相同数量 0 和 1 的最长连续子数组。</pre>
    <p>
    </p>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= nums.length &lt;= 105
      </code>
     </li>
     <li>
      <code>
       nums[i]
      </code>
      不是
      <code>
       0
      </code>
      就是
      <code>
       1
      </code>
     </li>
    </ul>
    <h3>
     题目解析：
    </h3>
    <p>
     我们可以把所有的0，看成-1，这样就是找和为0的子数组了；
    </p>
    <p>
     这道题呢和前面两道题差不多，但是我们找的不是子数组个数了，而是找下标，
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      和前面两篇一样，注意细节问题，哈希表初始不是（0,1）了，当i为n-1时，前缀和为0，那么说明sum-0，的下标为-1；也就是没有；长度的计算问题，是i-j，
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">class Solution {
    public int findMaxLength(int[] nums) {
        int sum= 0;
        int ret = 0;
        HashMap&lt;Integer,Integer&gt; hash = new HashMap&lt;&gt;();
        hash.put(0,-1);
        for(int i=0;i&lt;nums.length;i++){
            sum += nums[i]==0?-1:1;
            if(hash.containsKey(sum)) ret = Math.max(ret,i-hash.getOrDefault(sum,0));
            else hash.put(sum,i);
        }
        return ret;
    }
}</code></pre>
    <p>
     这里要注意，因为我们找的是最大长度，所以我们只记录第一个符合条件的元素，因为此时能保证
    </p>
    <p>
     i-j是最大的，当我们再次找到sum的时候，说明我们之前已经遇到过了，不需要再添加的哈希表了，我们没遇到的时候才把它添加的哈希表中，为了保证每次都是从最左边的开始，算最大的长度；
    </p>
    <hr/>
    <h2>
     8，矩阵区域和
    </h2>
    <h3>
     题目描述：
    </h3>
    <p>
     给你一个
     <code>
      m x n
     </code>
     的矩阵
     <code>
      mat
     </code>
     和一个整数
     <code>
      k
     </code>
     ，请你返回一个矩阵
     <code>
      answer
     </code>
     ，其中每个
     <code>
      answer[i][j]
     </code>
     是所有满足下述条件的元素
     <code>
      mat[r][c]
     </code>
     的和：
    </p>
    <ul>
     <li>
      <code>
       i - k &lt;= r &lt;= i + k,
      </code>
     </li>
     <li>
      <code>
       j - k &lt;= c &lt;= j + k
      </code>
      且
     </li>
     <li>
      <code>
       (r, c)
      </code>
      在矩阵内。
     </li>
    </ul>
    <p>
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
<strong>输出：</strong>[[12,21,16],[27,45,33],[24,39,28]]
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
<strong>输出：</strong>[[45,45,45],[45,45,45],[45,45,45]]
</pre>
    <p>
    </p>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       m == mat.length
      </code>
     </li>
     <li>
      <code>
       n == mat[i].length
      </code>
     </li>
     <li>
      <code>
       1 &lt;= m, n, k &lt;= 100
      </code>
     </li>
     <li>
      <code>
       1 &lt;= mat[i][j] &lt;= 100
      </code>
     </li>
    </ul>
    <h3>
     题目解析：
    </h3>
    <p>
     这道题给了我们一个mat数组，我们要往answer数组中填写根据mat数组改写的一些数据，具体怎么改写呢，题目给了一个k，我们要根据mat数组上下左右都扩充一个k长度，里面所有数据的和填到answer数组中，太明显了，二维前缀和；
    </p>
    <h3>
     算法思路：
    </h3>
    <blockquote>
     <p>
      这道题我们要创建dp数组，根据原数组来创建dp数组，要注意我们原数组是从0下标开始的，而dp数组是从1，1开始的，所以我们dp数组创建时m，n都要加1，dp数组创建完之后我们就要，根据原数组往answer数组填东西了，我们还记得二维前缀和模版吗，我们求D区域的和就是从坐上下标到右下下标区域的和，这道题也是一样的，左上标是（i-1，j-1）右下标是（i+1，j+1），我们避免越界要在左上取max（0，-）右下（m-1，-）；这样就能避免越界啦，填入的时候也要考虑下标的对应问题；
     </p>
    </blockquote>
    <h3>
     代码实现：
    </h3>
    <pre><code class="language-java">class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int m = mat.length;
        int n = mat[0].length;
        int[][] answer = new int[m][n];
        int[][] dp = new int[m+1][n+1];
        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                dp[i][j] = dp[i][j-1]+dp[i-1][j]+mat[i-1][j-1]-dp[i-1][j-1];
            }
        }

        for(int i=0;i&lt;m;i++){
            for(int j=0;j&lt;n;j++){
                int x1 = Math.max(0,i-k)+1;
                int y1 = Math.max(0,j-k)+1;
                int x2 = Math.min(m-1,i+k)+1;
                int y2 = Math.min(n-1,j+k)+1;
                answer[i][j] = dp[x2][y2] - dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1];
            }
        }
        return answer;

    }
}</code></pre>
    <p>
    </p>
    <hr/>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393038333438312f:61727469636c652f64657461696c732f313436313931343437" class_="artid" style="display:none">
 </p>
</div>


