---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343130353436382f:61727469636c652f64657461696c732f313231343339303234"
layout: post
title: "操作系统内核"
date: 2024-11-28 23:49:46 +08:00
description: "一、内核的含义内核是计算机的应用程序和外部设备之间的连接桥梁，二、内核的功能1）管理进程、线程，决定"
keywords: "操作系统内核的主要功能"
categories: ['操作系统']
tags: ['Windows', 'Linux', 'Java']
artid: "121439024"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=121439024
    alt: "操作系统内核"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=121439024
featuredImagePreview: https://bing.ee123.net/img/rand?artid=121439024
---

# 操作系统内核

### 一、内核的含义

内核是计算机的应用程序和外部设备之间的连接桥梁，内核可让应用程序只需要关心如何与内核交互而不用去关心如何与外部设备之间进行交互。

### 二、内核的功能

1）管理进程、线程，决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒；

2）管理内存，决定内存的分配和回收，也就是内存管理的能⼒；

3）管理硬件设备，为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；

4）提供系统调⽤，如果应⽤程序要运⾏更⾼权限运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与 操作系统之间的接⼝。

### 三、内核态与用户态

3.1 内核态与用户态的含义

内存分为两个区域：内核空间和用户空间

其中，内核空间只有内核程序可以访问；⽤户空间可以专⻔给应⽤程序使⽤。

操作系统有两种不同的运行级别：用户态和核心态。这两种操作级别分别在用户空间和内核空间进行。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

3.2 内核态与用户态的区别3.

**这两种状态的主要差别是：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。**

**3.3 用户态与内核态之间的切换方式**

1）系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。

比如redis在进行持久化操作时，会新建一个fork子进程来将内存快照发送到磁盘中，新建fork子进程需要切换至内核态进行操作，这个过程中用户态和内核态之间的切换采用的是系统调用的方式。

而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。

2）异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态。

必须在多线程操作环境下，如果对于某个加锁的同步代码块，某线程自旋多次仍未能成功获取到同步代码块的锁，则其需要被中断挂起，处理中断异常时，需要切换会内核态，这个过程采用的是异常的方式。

3）外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，

如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作，在键盘寄存器已经准备好了数据，则会以中断的方式通知操作系统，此时，操作系统需要处理这个中断，即接收这个数据，此过程需要切换回内核态。

![](https://i-blog.csdnimg.cn/blog_migrate/3805f0834ab983957e1122d818e579be.png)

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。