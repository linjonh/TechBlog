---
layout: post
title: "Node.js-技术原理分析系列5理解-Node.js-中的-ABI-稳定"
date: 2025-03-12 15:05:22 +0800
description: "首先，我们需要明确的是，并非所有 node 用户都需要关注“ABI 稳定”这一概念。如果一个用户对 node 的使用，只包含纯 JS 代码，那么用户没必要理解这个概念。但是如果直接或间接使用了 V8 ABI，例如使用 addon、libnode、electron 等技术，就需要对这个概念有所理解。本文主要以 addon 场景为例，对这个概念进行介绍。ABI（Application Binary Interface）直译过来是应用程序二进制接口。与常说的 api 类似，都是用于程序之间的交互。"
keywords: "Node.js 技术原理分析系列5——理解 Node.js 中的 ABI 稳定"
categories: ['未分类']
tags: ['前端', 'Node']
artid: "146205630"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146205630
    alt: "Node.js-技术原理分析系列5理解-Node.js-中的-ABI-稳定"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146205630
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146205630
cover: https://bing.ee123.net/img/rand?artid=146205630
image: https://bing.ee123.net/img/rand?artid=146205630
img: https://bing.ee123.net/img/rand?artid=146205630
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Node.js 技术原理分析系列5——理解 Node.js 中的 ABI 稳定
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     Node.js 是一个开源的、跨平台的JavaScript运行时环境，它允许开发者在服务器端运行JavaScript代码。Node.js 是基于Chrome V8引擎构建的，专为高性能、高并发的网络应用而设计，广泛应用于构建服务器端应用程序、网络应用、命令行工具等。
    </p>
    <p>
     本系列将分为9篇文章为大家介绍 Node.js 技术原理：从
     <a href="https://mp.weixin.qq.com/s?__biz=MzU5ODA3OTY5Ng==&amp;mid=2247498508&amp;idx=1&amp;sn=7e992f51177bba4c75ab4806bc882ccc&amp;scene=21#wechat_redirect" rel="nofollow">
      调试能力分析
     </a>
     到
     <a href="https://mp.weixin.qq.com/s?__biz=MzU5ODA3OTY5Ng==&amp;mid=2247498516&amp;idx=1&amp;sn=0be4fd5bf9277d603d4b726ae648eefe&amp;scene=21#wechat_redirect" rel="nofollow">
      内置模块新增
     </a>
     ，从
     <a href="https://mp.weixin.qq.com/s?__biz=MzU5ODA3OTY5Ng==&amp;mid=2247498541&amp;idx=1&amp;sn=5d58e7b1520ba92793fcd6519bf2f108&amp;scene=21#wechat_redirect" rel="nofollow">
      性能分析工具 perf_hooks 的用法
     </a>
     到
     <a href="https://mp.weixin.qq.com/s?__biz=MzU5ODA3OTY5Ng==&amp;mid=2247498602&amp;idx=1&amp;sn=700b62e90ab488ee3f87cbce6ddd304b&amp;scene=21#wechat_redirect" rel="nofollow">
      Chrome DevTools 的性能问题
     </a>
     剖析，再到 ABI 稳定的理解、基于 V8 封装 JavaScript 运行时、模块加载方式探究、内置模块外置以及 Node.js addon 的全面解读等主题，每一篇都干货满满。
    </p>
    <p>
     在上一节中我们探讨了
     <a href="https://mp.weixin.qq.com/s?__biz=MzU5ODA3OTY5Ng==&amp;mid=2247498602&amp;idx=1&amp;sn=700b62e90ab488ee3f87cbce6ddd304b&amp;scene=21#wechat_redirect" rel="nofollow">
      使用 Chrome DevTools 分析 Node.js 性能问题
     </a>
     ，在本节中则主要分享 Node.js 中的 ABI 稳定相关内容，本文内容为本系列第5篇，以下为正文内容。
    </p>
    <h3>
     <a id="_9">
     </a>
     前言
    </h3>
    <p>
     首先，我们需要明确的是，并非所有 node 用户都需要关注“ABI 稳定”这一概念。
    </p>
    <p>
     如果一个用户对 node 的使用，只包含纯 JS 代码，那么用户没必要理解这个概念。 但是如果直接或间接使用了 V8 ABI，例如使用 addon、libnode、electron 等技术，就需要对这个概念有所理解。
    </p>
    <p>
     本文主要以 addon 场景为例，对这个概念进行介绍。
    </p>
    <h3>
     <a id="_ABI__18">
     </a>
     创造 ABI 版本号的动机
    </h3>
    <p>
     先捋清楚一个疑问：
     <br/>
     在我们的认知中，JS（V8）是向下兼容的，旧代码总是能够在高版本的 V8 下运行。而 ABI 也是 V8 的一部分，怎么又不能向下兼容了呢？
     <br/>
     是因为 V8 提供的 JS API 和 ABI 有所不同。JS API 需要遵循 ECMAScript 标准；而 ABI 不需要。
    </p>
    <p>
     即使抛开规范，程序接口一般都是向下兼容的，这是开发者常识，ABI 为什么不呢？
     <br/>
     一方面，V8 是为性能而设计的，保持向下兼容可能会限制优化空间，从而降低性能改进的潜力；另一方面，使用 ABI 的开发者更偏底层，用户更少，不兼容问题影响面小。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/56bc522694724dea8a6c0bed515ff19a.png"/>
    </p>
    <p>
     （图片来源于网络）
    </p>
    <p>
     所以
     <strong>
      问题的根源是 V8 提供的 ABI 无法保持向下兼容。
     </strong>
    </p>
    <p>
     Node.js 引入 V8 的方式是，直接将 V8 代码内置到 Node.js 源码中（deps/v8）。但这不意味着 Node.js 从引入 V8 的时候就独立演进 V8，实际上 deps/v8 中的的代码始终和 V8 的官方仓库保持一致。 Node.js 和 V8 分别由各自的独立团队维护。
     <br/>
     所以二者之间会有兼容性问题。即使 node 会在内部，通过修改源码，消弭一部分兼容性问题，但随着 V8 的迭代，破坏性更新难以避免。这种兼容性问题，node 通过文档来告知用户。
    </p>
    <p>
     注意，node 并非为了处理自身与 V8 ABI 的兼容性问题而创造 ABI 版本号。
    </p>
    <p>
     实际为的是 addon 。
    </p>
    <p>
     由于 V8 ABI 不保证向下兼容，所以随着 V8 的更新，Node.js 生态中的众多 addon 们可能也要被迫更新。
    </p>
    <p>
     以上这是第一重麻烦。 更麻烦的是，V8 频繁更新，各个 addon 维护者也不知道哪个 V8 版本的更新，会导致自己的 addon 也要同步更新。不能指望每个 addon 维护者都是 V8 专家。
    </p>
    <p>
     于是前辈大佬们创造了 ABI 版本号，来解决这些问题。
    </p>
    <h3>
     <a id="_ABI__ABI__55">
     </a>
     什么是 ABI 与 ABI 稳定
    </h3>
    <p>
     ABI（Application Binary Interface）直译过来是应用程序二进制接口。与常说的 api 类似，都是用于程序之间的交互。只是 ABI 更强调交互对象是编译后的二进制文件。
    </p>
    <p>
     在本章，ABI 特指 V8 提供的接口，其实就是 V8 的头文件（deps/v8/include/v8.h）。
    </p>
    <p>
     那么所谓的 ABI 稳定，就是指 V8 提供的二进制接口的稳定。前文有分析过，V8 ABI 不保证向下兼容，换句话说，V8 ABI 是不稳定的。
    </p>
    <p>
     大佬们创造的 ABI 版本号，就是用来表示 V8 提供的 ABI 的稳定性。如果没有大改，至少 v8.h 没有改，ABI 版本号也不会随 V8 版本更新而更新；ABI 版本号变了，说明 V8 有较大改动。
    </p>
    <p>
     ABI 版本号是描述 V8 的，平时把 ABI 版本号放在 Node.js 的属性中，是因为特定版本的 Node.js，使用的 V8 版本是固定的，锁死的。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7a2dc1f072cd47cfab26366eccaf5e5d.png"/>
    </p>
    <p>
     V8 的 ABI 并不保证向下兼容，但 Node.js 通过 ABI 版本号收敛了破坏性更新的发散程度。
    </p>
    <p>
     在实操中，通常 ABI 版本号和 Node.js 主要版本号一一对应。可以理解为 Node.js 开发者，把 V8 的重大更新，放在自己的大版本中更新。这样就再次减少了 addon 更新次数。
    </p>
    <p>
     有了 ABI 版本号以后，addon 开发者只需要盯紧 ABI 版本号。如果 ABI 版本号不更新，自己维护的 addon 也不用更新。
    </p>
    <p>
     比如某个 addon 使用了 v8.h 的 abi1 接口。abi1 接口被移除了，同时 ABI 版本号更新。需要使用 abi1 接口的地方都换成 abi2 接口，这是一种可能的破坏性更新。这种情况下，如果要升级 node（注意 V8 内嵌在 node 中，升级 node 意味着升级 V8），addon 必须重新编译，甚至修改代码。
    </p>
    <p>
     对应关系如下表所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a9aed1ba1ba34c3c91062619f44f561f.png"/>
    </p>
    <h3>
     <a id="_nodeapi_89">
     </a>
     集大成者 node-api
    </h3>
    <p>
     前面关于 ABI 稳定的讲解，都是指 addon 直接使用 V8 ABI 的情况，包括使用 NAN 的情况。
    </p>
    <p>
     ABI 版本号出现以后，又出现了 node-api。node-api 封装了 V8 ABI，使用它的 addon，不再直接使用 V8 ABI，而是使用 node-api 的接口。
    </p>
    <p>
     涉及的众多概念，其关系如下表所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bcda7a49cf884bbc95328abf9eb4a936.png"/>
    </p>
    <p>
     开发者通过 node-api 调用 V8 ABI。
    </p>
    <p>
     node-api 将针对多个 node 版本中 V8 ABI 的变化的兼容性代码逻辑封装在自己内部，从而保证对 addon 暴露的 api 不变，稳定性再次升级。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bc6c8eaa32d74010bd574a328ace7952.png"/>
    </p>
    <p>
     上表是 node-api 版本与 node 版本之间的关系，可以看到高版本的 node 支持所有低版本的 node-api。这意味着，使用任意版本 node-api 的 addon，在自身不使用新特性时，无需因 node/v8 升级而被迫升级。
    </p>
    <p>
     使用 node-api 的 addon，其 package.json 文件中都会有个 binary 字段，标识当前使用的 node-api 版本号。
    </p>
    <pre><code> "binary": {    
    "napi_versions": [7]  
  },
</code></pre>
    <p>
     比如前文例子中，a1 接口改 a2 的操作，可能只需要 node-api 去做，广大 addon 们，只在需要使用 v8 新特性时升级 node；如果不使用新特性，addon 无需更改。
    </p>
    <p>
     另说一点题外话，假设某个 addon 使用了 node-api 8 中的特性，但 binary 继续标识为 7，整套程序运行不会有任何问题。只是应该约定俗成，让使用的 node-api 版本号正确地表示在 binary 字段中。
    </p>
    <h3>
     <a id="_125">
     </a>
     小结
    </h3>
    <p>
     ABI 稳定这个概念非常绕，如果你还是不太理解，可以直接记忆下面的结论：
    </p>
    <p>
     如果你维护或使用的 addon，是直接使用 V8 或基于 NAN 开发的，那么你的 addon 需要注意 V8 ABI 不稳定造成的影响。也就是说使用 addon 时，需要警惕高版本的 nodejs/v8 不兼容你的 addon。
    </p>
    <p>
     如果你维护或使用的 addon，是基于 node-api 开发的，那么你的 addon 不需要注意 V8 ABI 不稳定造成的影响。也就是说使用 addon 时，不用担心高版本的 nodejs/v8 不兼容你的 addon。
     <br/>
     因为只要你的 addon 使用了 node-api，那么它是对 node 版本向上兼容的。只有在你的 addon 内部，需要使用 nodejs/v8 某个新特性时，你需要保证环境中的 nodejs/v8 版本够高。
    </p>
    <p>
     <strong>
      参考资料：
     </strong>
    </p>
    <p>
     <a href="https://nodejs.org/docs/latest-v22.x/api/n-api.html#node-api" rel="nofollow">
      https://nodejs.org/docs/latest-v22.x/api/n-api.html#node-api
     </a>
    </p>
    <p>
     <a href="https://nodejs.org/en/learn/modules/abi-stability" rel="nofollow">
      https://nodejs.org/en/learn/modules/abi-stability
     </a>
    </p>
    <p>
     <a href="https://github.com/electron/node-abi">
      https://github.com/electron/node-abi
     </a>
    </p>
    <hr/>
    <p>
     下一节，将分享《基于 V8 封装一个自己的 JavaScript 运行时》相关内容，请大家持续关注本系列内容~学习完本系列，你将获得：
    </p>
    <ul>
     <li>
      提升调试与性能优化能力
     </li>
     <li>
      深入理解模块化与扩展机制
     </li>
     <li>
      探索底层技术与定制化能力
     </li>
    </ul>
    <p>
     同时欢迎大家给OpenTiny提建议：
     <a href="https://mp.weixin.qq.com/s?__biz=MzU5ODA3OTY5Ng==&amp;mid=2247498532&amp;idx=1&amp;sn=56678cf1078debef902d24c418dda725&amp;scene=21#wechat_redirect" rel="nofollow">
      【OpenTiny调研征集】共创技术未来，分享您的声音！
     </a>
    </p>
    <h3>
     <a id="OpenTiny_155">
     </a>
     关于OpenTiny
    </h3>
    <p>
     欢迎加入 OpenTiny 开源社区。添加微信小助手：opentiny-official 一起参与交流前端技术～
     <br/>
     OpenTiny 官网：
     <strong>
      <a href="https://opentiny.design" rel="nofollow">
       https://opentiny.design
      </a>
     </strong>
     <br/>
     OpenTiny 代码仓库：
     <strong>
      <a href="https://github.com/opentiny">
       https://github.com/opentiny
      </a>
     </strong>
     <br/>
     TinyVue 源码：
     <strong>
      <a href="https://github.com/opentiny/tiny-vue">
       https://github.com/opentiny/tiny-vue
      </a>
     </strong>
     <br/>
     TinyEngine 源码：
     <strong>
      <a href="https://github.com/opentiny/tiny-engine">
       https://github.com/opentiny/tiny-engine
      </a>
     </strong>
     <br/>
     欢迎进入代码仓库 Star🌟TinyEngine、TinyVue、TinyNG、TinyCLI~ 如果你也想要共建，可以进入代码仓库，找到 good first issue标签，一起参与开源贡献~
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f4f70656e54696e792f:61727469636c652f64657461696c732f313436323035363330" class_="artid" style="display:none">
 </p>
</div>


