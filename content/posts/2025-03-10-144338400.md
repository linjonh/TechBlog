---
layout: post
title: "Linux练级宝典-Linux进程概念介绍"
date: 2025-03-10 16:10:15 +0800
description: "这个分裂的进程，也会被创建出来，所以此时就是两个进程，那代码怎么执行的，当然就是共用一份代码，后面会有进程替换（exec），把子进程的执行逻辑脱离出去执行另一个程序，父进程依旧执行老代码。2.所以使用虚拟空间，实际就是在你时间片期间用多少就给你多少，并且通过映射的规则，我们在上层就不用担心，不同的进程的数据被修改了，因为这是操作系统进行维护的。什么是进程优先级，首先我们知道，我们假设了PCB的管理是一个链表，那除了按顺序取走进程外，如果有突发事件，或者优先级高的任务，此时就有了进程优先级的概念。"
keywords: "Linux练级宝典-＞Linux进程概念介绍"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "144338400"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144338400
    alt: "Linux练级宝典-Linux进程概念介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144338400
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144338400
cover: https://bing.ee123.net/img/rand?artid=144338400
image: https://bing.ee123.net/img/rand?artid=144338400
img: https://bing.ee123.net/img/rand?artid=144338400
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux练级宝典-＞Linux进程概念介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="-toc" style="margin-left:0px">
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px">
     <a href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">
      进程基本概念
     </a>
    </p>
    <p id="%C2%A0PCB%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px">
     <a href="#%C2%A0PCB%E6%A6%82%E5%BF%B5" rel="nofollow">
      PCB概念
     </a>
    </p>
    <p id="task_struct-toc" style="margin-left:80px">
     <a href="#task_struct" rel="nofollow">
      task_struct
     </a>
    </p>
    <p id="tack_struct%E5%86%85%E5%AE%B9%E5%88%86%E7%B1%BB-toc" style="margin-left:80px">
     <a href="#tack_struct%E5%86%85%E5%AE%B9%E5%88%86%E7%B1%BB" rel="nofollow">
      tack_struct内容分类
     </a>
    </p>
    <p id="%C2%A0PID%E5%92%8CPPID-toc" style="margin-left:80px">
     <a href="#%C2%A0PID%E5%92%8CPPID" rel="nofollow">
      PID和PPID
     </a>
    </p>
    <p id="fork%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B-toc" style="margin-left:80px">
     <a href="#fork%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B" rel="nofollow">
      fork函数创建子进程
     </a>
    </p>
    <p id="%C2%A0%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px">
     <a href="#%C2%A0%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%A6%82%E5%BF%B5" rel="nofollow">
      进程优先级概念
     </a>
    </p>
    <p id="%C2%A04%E4%B8%AA%E5%90%8D%E8%AF%8D-toc" style="margin-left:80px">
     <a href="#%C2%A04%E4%B8%AA%E5%90%8D%E8%AF%8D" rel="nofollow">
      4个名词
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-toc" style="margin-left:0px">
     <a href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" rel="nofollow">
      进程地址空间
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:80px">
     <a href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow">
      进程地址空间的意义
     </a>
    </p>
    <p id="%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:0px">
     <a href="#%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">
      内核进程调度队列
     </a>
    </p>
    <p id="%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:80px">
     <a href="#%E4%BC%98%E5%85%88%E7%BA%A7" rel="nofollow">
      优先级
     </a>
    </p>
    <p id="%E6%B4%BB%E5%8A%A8%E9%98%9F%E5%88%97-toc" style="margin-left:80px">
     <a href="#%E6%B4%BB%E5%8A%A8%E9%98%9F%E5%88%97" rel="nofollow">
      活动队列
     </a>
    </p>
    <p id="%E8%BF%87%E6%9C%9F%E9%98%9F%E5%88%97-toc" style="margin-left:80px">
     <a href="#%E8%BF%87%E6%9C%9F%E9%98%9F%E5%88%97" rel="nofollow">
      过期队列
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">
     进程基本概念
    </h2>
    <p>
     一个正在执行的程序。担当分配系统资源的实体（CPU时间，内存）。
    </p>
    <p>
     怎么理解？因为我们的进程就是CPU要计算的东西，内存是存储进程的东西并且唯一和CPU打交道的就是内存。（冯诺依曼体系）
    </p>
    <p>
     我们知道通常我们的程序都是存在磁盘里的，但是只有内存能和CPU打交道，即计算运行任务。所以我打开一个软件其实就是把磁盘里的程序加载到内存中了，然后内存在继续去和CPU打交道。
    </p>
    <p>
     <img alt="" height="344" src="https://i-blog.csdnimg.cn/direct/38ff57b5791841dcacd0f20c462d47ad.png" width="1059"/>
    </p>
    <h3 id="%C2%A0PCB%E6%A6%82%E5%BF%B5">
     PCB概念
    </h3>
    <p>
     我们知道我们再使用软件时，我们并不是一次只能打开一个软件，而是一次有多个软件是打开的。那内存就有一个，我们这么多进程怎么管理的？
    </p>
    <p>
     <strong>
      记住6个大字兄弟“先描述，后组织”
     </strong>
     。描述其实就和面向对象思想类似（C语言中没有面向对象的说法），把一个对象用一个结构体封装起来，需要什么变量就加入什么就是描述了。
    </p>
    <p>
     组织也很简单：我们为什么要学数据结构，就是为了组织数据的，也可以说是管理数据。假设我们Linux里面用的是链表，那就会是下面这样的。
    </p>
    <p>
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/2d12ee537460403295c27dae78a9db04.png" width="1075"/>
    </p>
    <p>
     这样一来，我们需要用到哪个进程通过查找就能在这个链表中找到了。那我们怎么知道要找的是哪一个PCB，当然里面的变量中，就有唯一标识PCB的变量叫做PID，下面会解释。
    </p>
    <h4 id="task_struct">
     task_struct
    </h4>
    <p>
     对于上面的PCB是在所有系统对进程的总称，而task_struct就是Linux中对进程的统称。
    </p>
    <h4 id="tack_struct%E5%86%85%E5%AE%B9%E5%88%86%E7%B1%BB">
     tack_struct内容分类
    </h4>
    <ul>
     <li>
      <strong>
       标示符：
      </strong>
      描述本进程的唯一标示符，用来区别其他进程。
     </li>
     <li>
      <strong>
       状态：
      </strong>
      任务状态，退出代码，退出信号等。
     </li>
     <li>
      <strong>
       优先级：
      </strong>
      相对于其他进程的优先级。
     </li>
     <li>
      <strong>
       程序计数器(pc)：
      </strong>
      程序中即将被执行的下一条指令的地址。
     </li>
     <li>
      <strong>
       内存指针：
      </strong>
      包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。
     </li>
     <li>
      <strong>
       上下文数据：
      </strong>
      进程执行时处理器的寄存器中的数据。
     </li>
     <li>
      <strong>
       I/O状态信息：
      </strong>
      包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表。
     </li>
     <li>
      <strong>
       记账信息：
      </strong>
      可能包括处理器时间总和，使用的时钟总和，时间限制，记账号等。
     </li>
     <li>
      其他信息
     </li>
    </ul>
    <p>
     有两条指令关于进程的查询
    </p>
    <blockquote>
     <p>
      1. ps aux ： 这条指令用于查看所有进程信息
     </p>
    </blockquote>
    <p>
     <img alt="" height="321" src="https://i-blog.csdnimg.cn/direct/86ac928d85e64d6cb8d6a8befb580d47.png" width="964"/>
    </p>
    <blockquote>
     <p>
      2.  ps aux | head -1 &amp;&amp; ps aux | grep proc | grep -v grep ：这条指令用于查询单一进程
     </p>
     <p>
      grep指令就是用来查找指定进程的。
     </p>
    </blockquote>
    <p>
     <img alt="" height="53" src="https://i-blog.csdnimg.cn/direct/23412119f8704718a1f3802c6b38246f.png" width="907"/>
    </p>
    <h4 id="%C2%A0PID%E5%92%8CPPID">
     PID和PPID
    </h4>
    <p>
     PID：process ID，就是表示进程的ID，在双链表中查找某一特定进程使用。
    </p>
    <p>
     PPID：parent process ID，表示当前PID的爸爸进程，有什么用呢？下面会说。
    </p>
    <h4 id="fork%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B">
     fork函数创建子进程
    </h4>
    <p>
     fork分叉函数，就和分叉一样，把当前的进程分裂成两个，原进程是分裂出来的进程的父进程。（可以套娃）
    </p>
    <p>
     <img alt="" height="307" src="https://i-blog.csdnimg.cn/direct/cada3fc55edd470cb547d052cb2aea00.png" width="956"/>
    </p>
    <p>
     <img alt="" height="197" src="https://i-blog.csdnimg.cn/direct/d67a58bf86f14c87b9aaea3566183409.png" width="964"/>
    </p>
    <p>
     这个分裂的进程，也会被创建出来，所以此时就是两个进程，那代码怎么执行的，当然就是共用一份代码，后面会有进程替换（exec），把子进程的执行逻辑脱离出去执行另一个程序，父进程依旧执行老代码。
    </p>
    <p>
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/7a9568243c3e407a9e2750143e29a252.png" width="901"/>
    </p>
    <p>
     父子进程的使用的变量是相同的，但是如果子进程有更改变量的操作，此时子进程和父进程的变量就不同了（写时拷贝）。
    </p>
    <p>
     那我们如果想在一份代码中分离父子进程怎么做呢？
    </p>
    <blockquote>
     <p>
      if分流父子进程
     </p>
    </blockquote>
    <p>
     先说说，fork函数的返回值：0，-1，和大于0的值。
    </p>
    <p>
     子进程的fork返回值是0，父进程的fork返回值是子进程的PID（大于0的值）。如果是-1则说明fork出错。
    </p>
    <p>
     所以if分流的做法就是判断fork的返回值。
    </p>
    <p>
     <img alt="" height="601" src="https://i-blog.csdnimg.cn/direct/98fcb20588aa4888be15cc03b97563b0.png" width="968"/>
    </p>
    <h2 id="%C2%A0%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%A6%82%E5%BF%B5">
     进程优先级概念
    </h2>
    <p>
     什么是进程优先级，首先我们知道，我们假设了PCB的管理是一个链表，那除了按顺序取走进程外，如果有突发事件，或者优先级高的任务，此时就有了进程优先级的概念。
    </p>
    <blockquote>
     <p>
      怎么查看进程优先级
     </p>
    </blockquote>
    <p>
     ps -l 指令。
    </p>
    <p>
     <img alt="" height="87" src="https://i-blog.csdnimg.cn/direct/62187da143b54b82ae04397cd4213c8e.png" width="975"/>
    </p>
    <p>
     我们可以看到一个PRI和NI值
    </p>
    <blockquote>
     <p>
      PRI与NI解释
     </p>
    </blockquote>
    <p>
     PRI（priority）代表的就是当前进程的优先级，PRI的值越小优先级越高。
    </p>
    <p>
     NI （nice），代表修改进程优先级的数值。
    </p>
    <p>
     所以NI值是正数，进程优先级PRI增大，所以优先级变低，NI值是负数，同理。
    </p>
    <p>
     NI取值有范围：-19 - 20；PRI的默认值为80；
    </p>
    <blockquote>
     <p>
      renice修改进程的nice值
     </p>
    </blockquote>
    <p>
     renice 就是更改nice值针对某个特定进程。
    </p>
    <p>
     用法：renice + nice值 + PID；
    </p>
    <h4 id="%C2%A04%E4%B8%AA%E5%90%8D%E8%AF%8D">
     4个名词
    </h4>
    <p>
     竞争性：进程是很多的，一台电脑，通常来说只有一个CPU，所以每个进程都有竞争。
    </p>
    <p>
     独立性：每个进程的运行，要有独立的空间独立的资源，使得多进程不受干扰。
    </p>
    <p>
     并行：多个进程在多个CPU下分别同时进行运行。
    </p>
    <p>
     并发：多个进程在一个CPU下采用进程切换的方式，让我们人为感觉多个进程是同时推进的。
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">
     进程地址空间
    </h2>
    <p>
     我们把地址空间看成一把尺子，不同的刻度之间有不同的区域，存储不同的信息。
    </p>
    <p>
     <img alt="" height="566" src="https://i-blog.csdnimg.cn/direct/4284daf92e01432e8cc0c7d01b0d9882.png" width="1137"/>
    </p>
    <p>
     但记住了进程地址空间，里面的空间是虚拟空间，就是操作系统给进程画的大饼，只是让进程以为自己得到了整个内存空间，实际上是进程用多少，才在物理内存中开辟多少。这样就避免了每次都要预先给进程分配好空间才能运行，而是进程用多少开辟多少，增加效率。
    </p>
    <p>
     进程地址空间叫什么呢？mm_struct，（memory_struct）。怎么拿到呢？
    </p>
    <p>
     首先我们知道task_struc是Linux单个进程的描述，这个描述里其实就包含了mm_struct。所以只要找到对应进程的task_struct就能找到对应的mm_struct。
    </p>
    <p>
     <img alt="" height="363" src="https://i-blog.csdnimg.cn/direct/8014f8181ad3436eb959cf9bb12c079b.png" width="967"/>
    </p>
    <p>
     然后刚刚我们不是说进程的地址空间是虚拟的吗？它怎么找到对应的实际的物理内存呢？
    </p>
    <p>
     如上图，我们在查找时1.先去页表中查找这个数据是否存在（页号），存在就去物理内存中直接拿。2.如果这个数据并不存在，那就说明他还在磁盘中，所以此时就会给这个数据一个页号，然后把磁盘的数据拿到内存，此时再给这个数据一个页号（在内存不足以装下内存时的选择）。3.还有一种情况就是，这个数据还没创建，此时就会先创建然后在建立虚拟内存和物理内存的映射。
    </p>
    <p>
     我们上面也有说，子进程和父进程最开始使用的都是同一个变量数据，那更改后进行的写时拷贝是什么意思
    </p>
    <p>
     <img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/0f87306eb76844e59285b045cdfd1c84.png" width="975"/>
    </p>
    <p>
     如上图就是我们重新开辟空间给子进程的变量，此时这个变量归子进程，父进程还是使用原来的变量。节省空间。
    </p>
    <blockquote>
     <p>
      为什么不直接给子进程创建额外的空间？
     </p>
    </blockquote>
    <p>
     很简单 就是因为有些程序是只有读操作的，此时给子进程在创建是不是就没用了，直接去父里面读就好了。
    </p>
    <h4 id="%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%84%8F%E4%B9%89">
     进程地址空间的意义
    </h4>
    <p>
     1.如果进程直接使用物理空间，每次进程切换，都是要切换整个空间给别人，还要保持自己的变量数据是被保护的，维护难度增加。
    </p>
    <p>
     2.所以使用虚拟空间，实际就是在你时间片期间用多少就给你多少，并且通过映射的规则，我们在上层就不用担心，不同的进程的数据被修改了，因为这是操作系统进行维护的。
    </p>
    <h2 id="%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%C2%A0">
     内核进程调度队列
    </h2>
    <p>
     <img alt="" height="630" src="https://i-blog.csdnimg.cn/direct/d500a75b24354d928415ac356c9ec53c.png" width="687"/>
    </p>
    <p>
     CPU中也有一个对应的组织结构。
    </p>
    <h4 id="%E4%BC%98%E5%85%88%E7%BA%A7">
     优先级
    </h4>
    <p>
     我们之前说进程不是有优先级吗？
    </p>
    <p>
     普通优先级：100-139，之前我们nice值是-20 - 19,40个级别
    </p>
    <p>
     实时优先级：0 - 99（现在用不到了），所以我们只有关心普通优先级即可。
    </p>
    <h4 id="%E6%B4%BB%E5%8A%A8%E9%98%9F%E5%88%97">
     活动队列
    </h4>
    <p>
     我们可以看到队列的个数就是140代表每个优先级.活动队列指的是，时间片还没结束的进程都按照优先级排列在活动队列中，nr_active代表表示的是当前具体有几个正在运行的进程。
    </p>
    <blockquote>
     <p>
      调度过程：
     </p>
    </blockquote>
    <p>
     1.遍历140个queue，找到一个非空队列，从0开始遍历！！（优先级）。
    </p>
    <p>
     2.取出第一个进程开始计算运行，本次调度完成。
    </p>
    <p>
     3.一直拿出直到这个队列全部解决，然后继续向后遍历。
    </p>
    <p>
     4.所以看得出我们是一批一批处理的，新来的高优先级，也是要等前面进程处理完，才能运行
    </p>
    <p>
     因为队列数量固定为140个，所以时间复杂度为o1.
    </p>
    <h4 id="%E8%BF%87%E6%9C%9F%E9%98%9F%E5%88%97">
     过期队列
    </h4>
    <p>
     过期队列就是时间片到了还没有执行完，此时这个队列用来维护这些没运行完的队列。
    </p>
    <p>
     结构总体和活动队列一样的。
    </p>
    <blockquote>
     <p>
      那我们如果活动队列全都执行完了之后怎么操作？
     </p>
    </blockquote>
    <p>
     首先我们要知道有两个指针：active_ptr和expired_ptr。顾名思义就是两个指向两个队列的指针。
    </p>
    <p>
     当活动队列执行完后，此时active_ptr指向过期队列，过期队列变为活动队列，反之相同。
    </p>
    <p>
     所以就完成了一次交换，此时再次重新执行。
    </p>
    <p>
     也可以看出内存中的数据一般都是等一次执行完后，CPU去内存中继续取新的程序执行。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f61313237353137343035322f:61727469636c652f64657461696c732f313434333338343030" class_="artid" style="display:none">
 </p>
</div>


