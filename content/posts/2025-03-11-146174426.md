---
layout: post
title: "Linux内核信号处理"
date: 2025-03-11 11:31:29 +0800
description: "信号处理是Linux内核中一个重要的机制，涉及用户态和内核态的交互。通过。"
keywords: "Linux内核信号处理"
categories: ['未分类']
tags: ['Linux']
artid: "146174426"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146174426
    alt: "Linux内核信号处理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146174426
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146174426
cover: https://bing.ee123.net/img/rand?artid=146174426
image: https://bing.ee123.net/img/rand?artid=146174426
img: https://bing.ee123.net/img/rand?artid=146174426
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux内核信号处理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在Linux内核中，信号处理是一个复杂的过程，涉及用户态和内核态的交互。以下是信号处理的详细流程，结合代码和注释进行说明。
    </p>
    <hr/>
    <h4>
     1.
     <strong>
      信号处理的整体流程
     </strong>
    </h4>
    <p>
     信号处理的流程可以分为以下几个步骤：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        信号产生
       </strong>
       ：内核或用户程序发送信号。
      </p>
     </li>
     <li>
      <p>
       <strong>
        信号传递
       </strong>
       ：内核将信号添加到目标进程的信号队列中。
      </p>
     </li>
     <li>
      <p>
       <strong>
        信号检查
       </strong>
       ：在进程从内核态返回到用户态时，内核检查是否有未处理的信号。
      </p>
     </li>
     <li>
      <p>
       <strong>
        信号处理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果进程注册了信号处理函数，内核会调用该函数。
        </p>
       </li>
       <li>
        <p>
         如果没有注册处理函数，内核会执行默认行为（如终止进程、忽略信号等）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        信号处理完成
       </strong>
       ：进程返回到被信号打断的代码位置继续执行。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     2.
     <strong>
      信号处理的代码实现
     </strong>
    </h4>
    <p>
     以下是Linux内核中信号处理的核心代码片段，结合注释进行说明。
    </p>
    <h5>
     （1）
     <strong>
      信号传递
     </strong>
    </h5>
    <p>
     当内核需要向进程发送信号时，会调用
     <code>
      send_signal()
     </code>
     函数。
    </p>
    <pre><code class="language-cpp">// kernel/signal.c
static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t, int group)
{
    struct sigpending *pending;
    struct sigqueue *q;

    // 获取目标进程的信号队列
    pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;

    // 分配一个信号队列项
    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);

    // 将信号添加到队列中
    sigaddset(&amp;pending-&gt;signal, sig);
    list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);

    // 唤醒进程（如果进程处于可中断睡眠）
    signal_wake_up(t, sig == SIGKILL);
    return 0;
}</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         send_signal()
        </code>
       </strong>
       ：将信号添加到目标进程的信号队列中。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         signal_wake_up()
        </code>
       </strong>
       ：如果进程处于可中断睡眠状态，唤醒进程。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     （2）
     <strong>
      信号检查
     </strong>
    </h5>
    <p>
     在进程从内核态返回到用户态时，内核会调用
     <code>
      do_signal()
     </code>
     函数检查是否有未处理的信号。
    </p>
    <pre><code class="language-cpp">// arch/x86/kernel/signal.c
void do_signal(struct pt_regs *regs)
{
    struct ksignal ksig;

    // 检查是否有未处理的信号
    if (get_signal(&amp;ksig)) {
        // 如果有信号，处理信号
        handle_signal(&amp;ksig, regs);
        return;
    }

    // 如果没有信号，恢复执行
    restore_saved_sigmask();
}</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         get_signal()
        </code>
       </strong>
       ：从信号队列中获取一个未处理的信号。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         handle_signal()
        </code>
       </strong>
       ：调用用户注册的信号处理函数。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     （3）
     <strong>
      信号处理
     </strong>
    </h5>
    <p>
     如果进程注册了信号处理函数，内核会调用
     <code>
      handle_signal()
     </code>
     函数。
    </p>
    <pre><code class="language-cpp">// arch/x86/kernel/signal.c
static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
{
    // 设置用户态的信号处理函数
    regs-&gt;ip = (unsigned long) ksig-&gt;ka.sa.sa_handler;
    regs-&gt;sp = (unsigned long) ksig-&gt;ka.sa.sa_restorer;

    // 切换到用户态执行信号处理函数
    return;
}</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         regs-&gt;ip
        </code>
       </strong>
       ：设置指令指针（IP）为信号处理函数的地址。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         regs-&gt;sp
        </code>
       </strong>
       ：设置栈指针（SP）为信号处理函数的栈。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     （4）
     <strong>
      信号处理完成
     </strong>
    </h5>
    <p>
     信号处理函数执行完毕后，进程会返回到被信号打断的代码位置继续执行。
    </p>
    <pre><code class="language-cpp">// arch/x86/kernel/signal.c
void sys_rt_sigreturn(void)
{
    // 恢复被信号打断的上下文
    restore_sigcontext(&amp;current-&gt;thread.regs);

    // 返回到用户态继续执行
    return;
}</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         restore_sigcontext()
        </code>
       </strong>
       ：恢复被信号打断的寄存器上下文。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         sys_rt_sigreturn()
        </code>
       </strong>
       ：返回到用户态继续执行。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     3.
     <strong>
      信号处理的场景和影响
     </strong>
    </h4>
    <h5>
     （1）
     <strong>
      场景1：进程正在运行
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：进程正在执行用户态代码，突然收到信号（如
       <code>
        SIGINT
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         内核将信号添加到进程的信号队列中。
        </p>
       </li>
       <li>
        <p>
         进程从内核态返回到用户态时，检查到未处理的信号。
        </p>
       </li>
       <li>
        <p>
         内核调用用户注册的信号处理函数。
        </p>
       </li>
       <li>
        <p>
         信号处理函数执行完毕后，进程返回到被信号打断的代码位置继续执行。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        影响
       </strong>
       ：进程的执行被信号打断，但会继续执行。
      </p>
     </li>
    </ul>
    <h5>
     （2）
     <strong>
      场景2：进程处于可中断睡眠
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：进程正在等待I/O操作（如
       <code>
        read()
       </code>
       ），突然收到信号（如
       <code>
        SIGTERM
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         内核将信号添加到进程的信号队列中。
        </p>
       </li>
       <li>
        <p>
         内核唤醒进程，并将其状态设置为
         <code>
          TASK_RUNNING
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         进程从内核态返回到用户态时，检查到未处理的信号。
        </p>
       </li>
       <li>
        <p>
         内核调用用户注册的信号处理函数。
        </p>
       </li>
       <li>
        <p>
         信号处理函数执行完毕后，进程返回到被信号打断的代码位置继续执行。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        影响
       </strong>
       ：进程被信号唤醒，I/O操作可能被中断。
      </p>
     </li>
    </ul>
    <h5>
     （3）
     <strong>
      场景3：进程处于不可中断睡眠
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：进程正在等待硬件I/O操作（如磁盘读写），突然收到信号（如
       <code>
        SIGKILL
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         内核将信号添加到进程的信号队列中。
        </p>
       </li>
       <li>
        <p>
         由于进程处于不可中断睡眠状态，信号不会唤醒进程。
        </p>
       </li>
       <li>
        <p>
         进程继续等待硬件I/O操作完成。
        </p>
       </li>
       <li>
        <p>
         硬件I/O操作完成后，进程被唤醒并处理信号。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        影响
       </strong>
       ：信号不会立即生效，进程必须等待硬件操作完成。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     4.
     <strong>
      总结
     </strong>
    </h4>
    <p>
     信号处理是Linux内核中一个重要的机制，涉及用户态和内核态的交互。通过
     <code>
      send_signal()
     </code>
     、
     <code>
      do_signal()
     </code>
     、
     <code>
      handle_signal()
     </code>
     等函数，内核实现了信号的传递、检查和处理。信号处理的具体行为和影响取决于进程的当前状态和信号类型。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f58696e43757272792f:61727469636c652f64657461696c732f313436313734343236" class_="artid" style="display:none">
 </p>
</div>


