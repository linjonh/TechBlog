---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33353831323230352f:61727469636c652f64657461696c732f313436323835313230"
layout: post
title: "ICLR2025-SLMRec-重新思考大语言模型在推荐系统中的价值"
date: 2025-03-15 20:59:39 +0800
description: "问题背景：序列推荐（SR）任务旨在预测用户可能的下一个交互项目。近年来，大型语言模型（LLMs）在SR系统中表现出色，但它们巨大的规模使得在实际平台中应用变得低效和不切实际。研究动机：论文探讨了在SR领域中LLMs的必要性，以及是否存在模型规模和性能之间的不一致性。研究发现LLMs的许多中间层是冗余的。方法提出：基于上述发现，论文提出了一种名为SLMRec的方法，该方法采用简单的知识蒸馏技术来增强小型语言模型（SLMs）在SR任务上的性能。实验设计：论文在大规模行业数据集上进行了广泛的实验，以评"
keywords: "ICLR2025 | SLMRec: 重新思考大语言模型在推荐系统中的价值"
categories: ['推荐算法2', '多模态大模型', 'Llm']
tags: ['自然语言处理', '序列推荐', '大模型']
artid: "146285120"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146285120
    alt: "ICLR2025-SLMRec-重新思考大语言模型在推荐系统中的价值"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146285120
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146285120
cover: https://bing.ee123.net/img/rand?artid=146285120
image: https://bing.ee123.net/img/rand?artid=146285120
img: https://bing.ee123.net/img/rand?artid=146285120
---

# ICLR2025 | SLMRec: 重新思考大语言模型在推荐系统中的价值

## note

问题背景：序列推荐（SR）任务旨在预测用户可能的下一个交互项目。近年来，大型语言模型（LLMs）在SR系统中表现出色，但它们巨大的规模使得在实际平台中应用变得低效和不切实际。

研究动机：论文探讨了在SR领域中LLMs的必要性，以及是否存在模型规模和性能之间的不一致性。研究发现LLMs的许多中间层是冗余的。

方法提出：基于上述发现，论文提出了一种名为SLMRec的方法，该方法采用简单的知识蒸馏技术来增强小型语言模型（SLMs）在SR任务上的性能。

实验设计：论文在大规模行业数据集上进行了广泛的实验，以评估减少参数数量对性能的影响，并发现SLMRec模型即使在使用只有13%的参数量的情况下，也能与大型模型相媲美。

实验结果：SLMRec在保持较小模型大小的同时，实现了与大型模型相当的性能，并在训练和推理时间上分别达到了6.6倍和8.0倍的速度提升。

技术贡献：SLMRec模型的设计正交于其他后训练效率技术（如量化和剪枝），可以与这些技术结合使用，进一步提高效率。

未来工作：论文提出了未来的研究方向，包括将增量学习整合到LLM-based推荐系统中，以及探索多模态信息融合等，以提高模型的适应性和效率。

结论：通过采用知识蒸馏方法，可以有效地提高小型语言模型在序列推荐任务中的性能，同时显著降低模型规模和提高效率，为构建高效推荐系统提供了新的方向。

## 一、研究背景

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/01abf46932f447baa940f3cfd1dca344.png#pic_center)

论文：https://openreview.net/forum?id=G4wARwjF8M
  
代码：https://github.com/WujiangXu/SLMRec

### Q: 这篇论文试图解决什么问题？

A: 这篇论文探讨了在序列推荐（Sequential Recommendation, SR）任务中，大型语言模型（Large Language Models, LLMs）的必要性和效率问题。具体来说，论文试图解决以下几个问题：

* 大型语言模型的规模需求：尽管LLMs在SR任务中表现出色，但目前缺乏关于在SR场景中实际需要多大语言模型的证据。论文试图了解LLMs的规模与其在SR任务上的性能之间的关系。
* 大型模型的效率问题：由于LLMs的庞大规模，它们在需要处理大量日志的日常实际平台中应用是低效且不切实际的。论文探讨了如何提高基于LLM的SR模型的实用性和效率。
* 模型参数的冗余性：论文通过实验发现，LLMs的许多中间层是冗余的。基于这一发现，论文提出了一种方法，通过简化知识蒸馏（Knowledge Distillation, KD）技术，增强小型语言模型（Small Language Models, SLMs）在SR任务上的性能。
* 模型效率与性能的平衡：论文提出了一种新的模型SLMRec，旨在使用更少的参数（仅LLM-based推荐模型的13%）实现与大型模型相当的性能，同时显著提高训练和推理速度。

总的来说，这篇论文的目标是重新评估在序列推荐任务中对大型语言模型的需求，并探索提高小型语言模型性能的有效方法，以实现更高效和实用的推荐系统。

### Q: 有哪些相关研究？

A: 根据论文内容，相关研究主要涉及以下几个领域：

* 序列推荐（Sequential Recommendation, SR）：传统的SR方法主要关注于开发各种时序编码器以捕获用户的短期和长期兴趣。随着大型语言模型（LLMs）的成功，研究人员开始利用开源的LLMs构建推荐系统。
* 知识蒸馏（Knowledge Distillation, KD）：知识蒸馏是一种强大的技术，通过训练一个较小的“学生”模型来模仿一个大型的“教师”模型的预测分布，从而将教师的知识转化为更紧凑、压缩的表示形式。
* 深度语言模型的知识：近期社区对语言模型中的语言属性和知识如何编码感兴趣。一些研究强调知识集中在中间层或最后几层，而其他研究尝试进行知识编辑，并得出信息可能在各层之间非局部存储的结论。
* 模型剪枝（Model Pruning）：模型剪枝是通过
  移除不重要的参数来减小一个训练有素的大型模型的大小
  的基本方法。近期的工作集中在将剪枝方法应用于Transformer架构。
* 参数高效微调（Parameter-Efficient Fine-Tuning, PEFT）：PEFT是一种新技术，旨在在保持最小的计算和内存成本的同时，将大型语言模型（LLMs）调整到特定任务上。

论文中提到的一些具体相关工作包括但不限于：

* BERT4Rec：使用双向自注意力网络来建模用户行为序列。
* SASRec：基于自注意力的顺序模型，通过注意力机制识别用户行为历史中的相关项目。
* Open-P5：一个开源平台，用于促进基于LLM的生成式推荐系统的研究。
* E4SRec：将大型语言模型（LLMs）整合到序列推荐系统中，显著提高了处理项目ID和个性化的能力。

这些研究为本文提出的SLMRec模型提供了理论和技术背景，同时也表明了序列推荐领域的研究进展和挑战。

## 二、SLMRec模型

### G-LLMRec和E-LLMRec

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a59c531b65aa44ab9f14239a400171dd.png#pic_center)
  
前者是传统序列推荐模型，后者利用LLM作为特征提取器，后者分为两类：

* 生成式方法（G-LLMRec）：将物品映射为文本token，将推荐任务转化为基于历史序列的下一个token生成任务（如P5、LLaRA）。其核心思想是通过LLM的生成能力直接预测用户可能交互的物品，类似于自然语言生成中的自回归机制。
* 嵌入式方法（E-LLMRec）：沿用传统推荐框架，利用LLM提取序列的最后一层隐藏表征作为用户偏好表示（如E4SRec），并通过外部适配器计算用户-物品偏好得分。此类方法将LLM视为特征提取器，更贴近BERT等预训练模型的思路，保留了对用户隐式偏好的建模能力。

实验结论：LLMRec方法相较TSR基准模型（如SASRec）可带来近20%的性能提升，但其参数量激增（高达7B+）导致训练与推理成本剧增，严重制约实际部署。提出的SLMRec在性能逼近7B级LLMRec模型的同时，训练/推理速度提升达6.6倍/8.0倍

### 蒸馏过程

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/359db25972be47179951448d7f0f7bf2.png)
  
图1：分层知识蒸馏框架示意图。教师模型（左边）与学生模型（右边）同为E－LLMRec架构，通过对齐隐藏表征实现知识迁移。图中展示了分块策略（每

m
/
n
m / n





m

/

n
层为一组），多监督信号（红色箭头）与损失函数。

为压缩模型规模，本文采用离线知识蒸馏（Offline Knowledge Distillation）策略，其优化目标为：

min
⁡
Θ
s
[
L
c
e
(
Θ
s
)
+
λ
D
k
d
(
Θ
t
,
Θ
s
)
]
\min \_{\Theta\_s}\left[\mathcal{L}\_{c e}\left(\Theta\_s\right)+\lambda \mathcal{D}\_{k d}\left(\Theta\_t, \Theta\_s\right)\right]















Θ









s

​






min

​





[


L










ce

​





(


Θ









s

​


)



+



λ


D










k

d

​





(


Θ









t

​


,




Θ









s

​


)

]

* 教师模型

  f
  t
  (
  Θ
  t
  )
  f\_t\left(\Theta\_t\right)






  f









  t

  ​





  (


  Θ









  t

  ​


  )
  ：完整LLM架构的E－LLMRec模型，预训练后参数固定。
* 学生模型

  f
  s
  (
  Θ
  s
  )
  f\_s\left(\Theta\_s\right)






  f









  s

  ​





  (


  Θ









  s

  ​


  )
  ：轻量化架构（如剪裁层数或隐层维度），需学习逼近教师模型的表征能力。
* 蒸馏损失

  D
  k
  d
  \mathcal{D}\_{k d}






  D










  k

  d

  ​

  ：采用KL散度 衡量教师与学生输出的概率分布差异：

D
k
d
=
∑
u
,
i
p
^
i
(
t
)
log
⁡
p
^
i
(
t
)
p
^
i
(
s
)
\mathcal{D}\_{k d}=\sum\_{u, i} \hat{p}\_i^{(t)} \log \frac{\hat{p}\_i^{(t)}}{\hat{p}\_i^{(s)}}






D










k

d

​




=














u

,

i





∑

​












p





^

​










i






(

t

)

​




lo
g






















p





^

​










i






(

s

)

​




















p





^

​










i






(

t

)

​


​

### 优化目标

1．分层分块策略

* 教师模型：包含

  M
  M





  M
  层解码器，每

  m
  m





  m
  层划分为一个块，共

  B
  =
  ⌊
  M
  m
  ⌋
  B=\left\lfloor\frac{M}{m}\right\rfloor





  B



  =







  ⌊













  m












  M

  ​



  ⌋
  块。
* 学生模型：包含

  N
  N





  N
  层解码器

  (
  N
  <
  M
  )
  (N<M)





  (

  N



  <





  M

  )
  ，每

  n
  n





  n
  层划分为一个块，块数

  B
  B





  B
  与教师模型一致。
* 隐藏表征对齐：

教师第

k
m
k m





km
层与学生第

k
n
k n





kn
层的输出表征需对齐：

H
t
=
{
h
t
m
,
…
,
h
t
M
}
,
H
s
=
{
h
s
n
,
…
,
h
s
N
}
\mathbf{H}\_t=\left\{\mathbf{h}\_t^m, \ldots, \mathbf{h}\_t^M\right\}, \quad \mathbf{H}\_s=\left\{\mathbf{h}\_s^n, \ldots, \mathbf{h}\_s^N\right\}






H









t

​




=







{


h









t





m

​


,



…



,




h









t





M

​



}



,






H









s

​




=







{


h









s





n

​


,



…



,




h









s





N

​



}

2．多粒度蒸馏损失
  
（1）特征方向对齐（余弦相似度）
  
通过余弦相似度约束教师与学生表征的方向一致性：

D
c
o
s
=
1
B
∑
k
=
1
B
h
t
(
k
m
)
⋅
h
s
(
k
n
)
∥
h
t
(
k
m
)
∥
2
⋅
∥
h
s
(
k
n
)
∥
2
\mathcal{D}\_{\mathrm{cos}}=\frac{1}{B} \sum\_{k=1}^B \frac{\mathbf{h}\_t^{(k m)} \cdot \mathbf{h}\_s^{(k n)}}{\left\|\mathbf{h}\_t^{(k m)}\right\|\_2 \cdot\left\|\mathbf{h}\_s^{(k n)}\right\|\_2}






D











cos

​




=
















B











1

​













k

=

1





∑





B

​

































​



h









t






(

km

)

​


















​










2

​




⋅





















​



h









s






(

kn

)

​


















​










2

​













h









t






(

km

)

​




⋅




h









s






(

kn

)

​


​

（2）特征范数对齐（L2距离）
  
最小化教师与学生表征的L2范数差异：

D
n
o
r
m
=
1
B
∑
k
=
1
B
∥
h
t
(
k
m
)
−
h
s
(
k
n
)
∥
2
2
\mathcal{D}\_{\mathrm{norm}}=\frac{1}{B} \sum\_{k=1}^B\left\|\mathbf{h}\_t^{(k m)}-\mathbf{h}\_s^{(k n)}\right\|\_2^2






D











norm

​




=
















B











1

​













k

=

1





∑





B

​






















​



h









t






(

km

)

​




−




h









s






(

kn

)

​


















​










2





2

​

（3）多重监督信号
  
在每块输出层添加适配器

(
W
a
)
\left(W\_a\right)






(


W









a

​


)
，引入中间监督损失：

L
m
s
=
1
B
−
1
∑
k
=
1
B
−
1
L
c
e
(
y
,
p
^
t
(
k
m
)
)
\mathcal{L}\_{\mathrm{ms}}=\frac{1}{B-1} \sum\_{k=1}^{B-1} \mathcal{L}\_{c e}\left(y, \hat{p}\_t^{(k m)}\right)






L











ms

​




=
















B



−



1











1

​













k

=

1





∑






B

−

1

​





L










ce

​






(

y

,











p





^

​










t






(

km

)

​



)

3．联合优化目标

总损失函数整合交叉嫡损失与多粒度蒸馏损失：

min
⁡
Θ
s
,
W
a
[
L
c
e
+
λ
1
D
c
o
s
+
λ
2
D
n
o
r
m
+
λ
3
L
m
s
]
\min \_{\Theta\_s, W\_a}\left[\mathcal{L}\_{c e}+\lambda\_1 \mathcal{D}\_{\mathrm{cos}}+\lambda\_2 \mathcal{D}\_{\mathrm{norm}}+\lambda\_3 \mathcal{L}\_{\mathrm{ms}}\right]















Θ









s

​


,


W









a

​






min

​





[


L










ce

​




+




λ









1

​



D











cos

​




+




λ









2

​



D











norm

​




+




λ









3

​



L











ms

​


]

其中

λ
1
,
λ
2
,
λ
3
\lambda\_1, \lambda\_2, \lambda\_3






λ









1

​


,




λ









2

​


,




λ









3

​

为超参数，控制各损失项的权重。

### 解决方法

A: 论文通过以下几个关键步骤解决大型语言模型在序列推荐任务中的效率和必要性问题：

* 实验探索：首先，论文通过在大规模行业数据集上进行广泛的实验，探索了减少模型参数对性能的影响，并发现LLMs的许多中间层是冗余的。
* 知识蒸馏（Knowledge Distillation, KD）：基于实验发现，论文提出了一种简单的知识蒸馏方法来训练小型语言模型（SLMRec）。这种方法通过将教师模型（大型语言模型）的知识传递给学生模型（小型语言模型），使得学生模型能够学习到与教师模型相似的表示能力。
* 特征对齐：论文采用了基于余弦相似度的损失项（Dcos）和特征范数正则化（Dnorm）来对齐教师模型和学生模型之间的特征方向，确保学生模型能够学习到与教师模型相似的特征表示。
* 多监督信号：为了引导学生模型学习到与推荐任务相关的知识，论文引入了额外的监督信号（Lms），通过学习额外的适配器（adapters）来减少维度，并优化预测结果。
* 模型结构简化：SLMRec模型采用了与教师模型相似的E-LLMRec模型架构，但通过知识蒸馏方法，减少了模型大小，同时保持了竞争力的性能。
* 效率提升：实验结果表明，SLMRec模型在使用仅有大型语言模型13%的参数量的情况下，实现了与大型模型相当的性能，并且在训练和推理时间上分别达到了6.6倍和8.0倍的速度提升。
* 兼容性：SLMRec模型的设计是与大型语言模型中的其他量化和剪枝技术正交的，这意味着它可以与这些技术结合使用，进一步提高效率。

## 三、相关实验

Q: 论文做了哪些实验？

A: 论文中进行了一系列实验来评估提出的方法SLMRec，并回答了几个研究问题（RQs）。以下是论文中提到的主要实验内容：

* 性能比较（RQ1）：比较SLMRec模型与基于大型语言模型（LLM）的推荐模型在大规模行业数据集上的性能。使用了Amazon18数据集的不同类别，并将SLMRec与其他基线模型进行了比较，包括传统的序列推荐方法（如GRU4Rec、BERT4Rec和SASRec）和基于LLM的方法（如Open-P5LLaMa和E4SRec\*）。
* 效率和运行时间比较（RQ2）：评估SLMRec模型与G-LLMRec和E-LLMRec模型在效率和运行时间方面的比较。实验包括训练时间、推理时间、训练参数数量和推理参数数量的测量。
* 知识正则化器的效果（RQ3）：通过消融研究来评估提出的三种知识正则化器（Dcos、Dnorm和Lms）对SLMRec性能的影响。
* 在线知识蒸馏的可行性（RQ4）：研究了在下游推荐任务中同时训练教师模型和SLMRec的可能性，即在线知识蒸馏。
* 块数b的影响：研究了在SLMRec中块数b对模型性能的影响。
* 模型研究：进一步研究了在线知识蒸馏技术和块数b对模型性能的影响。

实验结果表明，SLMRec在保持较小模型大小的同时，实现了与大型语言模型相当的性能，并且在训练和推理时间上都有显著的提升。此外，通过引入不同的知识正则化器，SLMRec能够更好地学习到与推荐任务相关的知识，进一步提升了模型的性能。

### 1. 基线选择

* 传统基线：选用SASRec作为传统序列推荐（TSR）的基准模型，因其在序列建模中表现出色。
* LLM基线：采用嵌入式方法E4SRec作为基于LLM的基线模型，通过预训练权重与适配器实现推荐任务。

### 2. 实验设计

1．传统序列推荐（TSR）部分：

* 使用SASRec预训练的嵌入层（Embedding Layer）获取商品序列的表示。
* 输出用户表示

  h
  u
  h\_u






  h









  u

  ​

  和商品表示

  h
  i
  h\_i






  h









  i

  ​

  。

2．基于LLM的推荐（E－LLMRec）部分：

* 将商品嵌入与提示嵌入（Prompt Embedding ）拼接后输入LLM。
* 利用LLM作为特征提取器（类似BERT），输出最后一层的隐藏表征作为用户偏好表示。
* 与生成式方法（G－LLMRec）不同，保留TSR的预测框架（用户－商品内积计算得分）。

层数裁剪策略对比如下，使用更少层（8 层）的模型实现了几乎等同于（24 层）模型的性能：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/72e04495dc0a4f6eb7b7158a6bafe1ac.png)

数据集：基于Amazon 18数据集进行大规模实验验证，确保工业场景代表性。
  
负采样：对每个用户采样999个负样本+1个正样本，避免评估偏置。
  
参数优化：采用LoRA技术降低计算开销，仅更新部分低秩适配矩阵参数。

### 实验结论

* 模型性能随层数增加而提升
  + 即使仅使用2层的E4SRec，其性能仍显著优于SASRec（NDCG@10提升约12%）。
  + 主要原因包括：
    - 更大隐层维度：LLM隐层维度为4096（VS. SASRec的128），增强了表征能力。
    - 预训练权重初始化：LLM的预训练参数提供了更优的语义先验。
    - 参数高效微调（PEFT）：LoRA技术有效平衡了参数更新与计算效率。
* 中间层存在显著冗余
  + 在 l=8 至 l=24 区间内，性能提升趋缓（NDCG@10差异<2%）
  + 核心结论：8层模型（E4SRec）即可逼近24层模型（E4SRec）的效果，表明大部分中间层对推荐任务贡献有限。

## 四、未来方向

增量学习（Incremental Learning）：当前的SLMRec模型需要重新训练以适应新的场景或数据集。研究如何将增量学习整合到基于LLM的推荐系统中，以提高模型对新情况的适应性和减少对全量数据训练的依赖。

少样本学习（Few-shot Learning）：探索LLMs在少样本学习方面的潜力，以便在面对新数据集或平台的新流量日志时，模型能够更快地适应，而不需要从头开始训练。

多模态信息融合：考虑将用户的语言学信息和视觉信息等多模态数据集成到LLMRec模型中，这可能会进一步提高模型对新场景的适应性。

模型压缩和加速：虽然SLMRec已经在模型大小和效率上取得了进步，但仍有进一步压缩和加速模型的空间，特别是在移动设备或资源受限的环境中。

知识蒸馏的改进：研究更高级的知识蒸馏技术，以更有效地将知识从大型模型传递到小型模型。

模型解释性：提高模型的可解释性，帮助理解模型是如何做出推荐决策的，这对于提高用户信任和满意度至关重要。

跨领域推荐：研究模型在跨领域推荐任务中的性能，以及如何通过迁移学习等技术来提高跨领域的泛化能力。

实时推荐：探索模型在实时推荐场景中的应用，以及如何优化模型以满足实时推荐的需求。

用户隐私保护：研究如何在保护用户隐私的同时进行有效的推荐，例如通过差分隐私或联邦学习等技术。

模型鲁棒性：提高模型对于噪声数据、对抗性攻击等的鲁棒性，确保推荐系统在面对恶意行为时的稳定性。

这些探索点可以帮助推动序列推荐领域的进一步发展，提高推荐系统的性能、效率和用户体验。

## Reference

[1] https://github.com/WujiangXu/SLMRec