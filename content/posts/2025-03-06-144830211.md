---
layout: post
title: "贪心算法一"
date: 2025-03-06 12:44:57 +0800
description: "贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。"
keywords: "贪心算法一"
categories: ['贪心算法']
tags: ['贪心算法', '算法', '推荐算法', '动态规划', 'Leetcode']
artid: "144830211"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144830211
    alt: "贪心算法一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144830211
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144830211
cover: https://bing.ee123.net/img/rand?artid=144830211
image: https://bing.ee123.net/img/rand?artid=144830211
img: https://bing.ee123.net/img/rand?artid=144830211
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     贪心算法一
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      &gt; 作者：დ旧言~
      <br/>
      &gt; 座右铭：松树千年终是朽，槿花一日自为荣。
     </p>
     <p>
      &gt; 目标：了解什么是贪心算法，并且掌握贪心算法。
     </p>
     <p>
      &gt; 毒鸡汤：有些事情，总是不明白，所以我不会坚持。早安!
     </p>
     <p>
      &gt; 专栏选自：
      <a href="https://blog.csdn.net/aalykk/category_12867594.html?spm=1001.2014.3001.5482" title="贪心算法_დ旧言~的博客-CSDN博客">
       贪心算法_დ旧言~的博客-CSDN博客
      </a>
     </p>
     <p>
      &gt; 望小伙伴们点赞👍收藏✨加关注哟💕💕
     </p>
    </blockquote>
    <h2 style="background-color:transparent">
     一、算法讲解
    </h2>
    <p>
     <span style="color:#4da8ee">
      <strong>
       贪心算法的定义：
      </strong>
     </span>
    </p>
    <p>
     贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       解题的一般步骤是：
      </strong>
     </span>
    </p>
    <ol>
     <li>
      建立数学模型来描述问题；
     </li>
     <li>
      把求解的问题分成若干个子问题；
     </li>
     <li>
      对每一子问题求解，得到子问题的局部最优解；
     </li>
     <li>
      把子问题的局部最优解合成原来问题的一个解。
     </li>
    </ol>
    <p>
     如果大家比较了解动态规划，就会发现它们之间的相似之处。最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，大部分情况下这是不可行的。贪心算法和动态规划本质上是对子问题树的一种修剪，两种算法要求问题都具有的一个性质就是子问题最优性(组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的)。
    </p>
    <p>
     动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。而贪心算法是动态规划方法的一个特例，可以证明每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。
    </p>
    <h2 style="background-color:transparent">
     二、算法习题
    </h2>
    <hr/>
    <h3>
     2.1、第一题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/lemonade-change/description/" rel="nofollow" title="860. 柠檬水找零 - 力扣（LeetCode）">
       860. 柠檬水找零 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="1037" src="https://i-blog.csdnimg.cn/direct/4bd2e8faf15a4bb1a551d1c45def0a8f.png" width="1704"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     a. 遇到 5 元钱，直接收下；
    </p>
    <p>
     b. 遇到 10 元钱，找零 5 元钱之后，收下；
    </p>
    <p>
     c. 遇到 20 元钱：
    </p>
    <ol>
     <li>
      先尝试凑 10 + 5 的组合；
     </li>
     <li>
      如果凑不出来，拼凑 5 + 5 + 5 的组合；
     </li>
    </ol>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) 
    {
        int five = 0, ten = 0;
        for (auto x : bills) 
        {
            if (x == 5)
                five++;       // 5 元：直接收下
            else if (x == 10) // 10 元：找零 5 元
            {
                if (five == 0)
                    return false;
                five--;
                ten++;
            } else // 20 元：分情况讨论
            {
                if (ten &amp;&amp; five) // 贪⼼
                {
                    ten--;
                    five--;
                } else if (five &gt;= 3) {
                    five -= 3;
                } else
                    return false;
            }
        }
        return true;
    }
};</code></pre>
    <h3>
     2.2、第二题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/description/" rel="nofollow" title="2208. 将数组和减半的最少操作次数 - 力扣（LeetCode）">
       2208. 将数组和减半的最少操作次数 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="1189" src="https://i-blog.csdnimg.cn/direct/03c29cea25b04017995cf893f3175b34.png" width="1690"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <ol>
     <li>
      每次挑选出「当前」数组中「最⼤」的数，然后「减半」；
     </li>
     <li>
      直到数组和减少到⾄少⼀半为⽌。
     </li>
    </ol>
    <p>
     为了「快速」挑选出数组中最⼤的数，我们可以利⽤「堆」这个数据结构。
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int halveArray(vector&lt;int&gt;&amp; nums) 
    {
        priority_queue&lt;double&gt; heap; // 创建⼀个⼤根堆
        double sum = 0.0;
        for (int x : nums) // 把元素都丢进堆中，并求出累加和
        {
            heap.push(x);
            sum += x;
        }
        sum /= 2.0; // 先算出⽬标和
        int count = 0;
        while (sum &gt; 0) // 依次取出堆顶元素减半，直到减到之前的⼀半以下
        {
            double t = heap.top() / 2.0;
            heap.pop();
            sum -= t;
            count++;
            heap.push(t);
        }
        return count;
    }
};</code></pre>
    <h3>
     2.3、第三题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/largest-number/" rel="nofollow" title="179. 最大数 - 力扣（LeetCode）">
       179. 最大数 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="845" src="https://i-blog.csdnimg.cn/direct/3b5071cfc2604fea883dda83ff495005.png" width="1629"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     <strong>
      可以先优化：
     </strong>
    </p>
    <p>
     将所有的数字当成字符串处理，那么两个数字之间的拼接操作以及⽐较操作就会很⽅便。
    </p>
    <p>
     <strong>
      贪⼼策略：
     </strong>
    </p>
    <p>
     按照题⽬的要求，重新定义⼀个新的排序规则，然后排序即可。
    </p>
    <p>
     <strong>
      排序规则：
     </strong>
    </p>
    <ol>
     <li>
      「A 拼接 B」 ⼤于 「B 拼接 A」，那么 A 在前，B 在后；
     </li>
     <li>
      「A 拼接 B」 等于 「B 拼接 A」，那么 A B 的顺序⽆所谓；
     </li>
     <li>
      「A 拼接 B」 ⼩于 「B 拼接 A」，那么 B 在前，A 在后
     </li>
    </ol>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) 
    {
        // 优化：把所有的数转化成字符串
        vector&lt;string&gt; strs;
        for (int x : nums)
            strs.push_back(to_string(x));
        // 排序
        sort(strs.begin(), strs.end(), [](const string&amp; s1, const string&amp; s2) {
            return s1 + s2 &gt; s2 + s1;
        });
        // 提取结果
        string ret;
        for (auto&amp; s : strs)
            ret += s;
        if (ret[0] == '0')
            return "0";
        return ret;
    }
};</code></pre>
    <h3>
     2.4、第四题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/wiggle-subsequence/description/" rel="nofollow" title="376. 摆动序列 - 力扣（LeetCode）">
       376. 摆动序列 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="1053" src="https://i-blog.csdnimg.cn/direct/65a54f9b531944ccb07921565521eaa5.png" width="1597"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#333333">
      对于某⼀个位置来说：
     </span>
    </p>
    <ul>
     <li>
      如果接下来呈现上升趋势的话，我们让其上升到波峰的位置；
     </li>
     <li>
      <span style="color:#333333">
       如果接下来呈现下降趋势的话，我们让其下降到波⾕的位置。
      </span>
     </li>
     <li>
      <span style="color:#333333">
       因此，如果把整个数组放在「折线图」中，我们统计出所有的波峰以及波⾕的个数即可
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) 
    {
        int n = nums.size();
        if (n &lt; 2)
            return n;
        int ret = 0, left = 0;
        for (int i = 0; i &lt; n - 1; i++) 
        {
            int right = nums[i + 1] - nums[i]; // 计算接下来的趋势
            if (right == 0)
                continue; // 如果⽔平，直接跳过
            if (right * left &lt;= 0)
                ret++; // 累加波峰或者波⾕
            left = right;
        }
        return ret + 1;
    }
};</code></pre>
    <h3>
     2.5、第五题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/longest-increasing-subsequence/" rel="nofollow" title="300. 最长递增子序列 - 力扣（LeetCode）">
       300. 最长递增子序列 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="1014" src="https://i-blog.csdnimg.cn/direct/278f988b34254d008d045b489c3ea1ff.png" width="1556"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <ul>
     <li>
      我们在考虑最⻓递增⼦序列的⻓度的时候，其实并不关⼼这个序列⻓什么样⼦，我们只是关⼼最后⼀个元素是谁。这样新来⼀个元素之后，我们就可以判断是否可以拼接到它的后⾯。
     </li>
     <li>
      因此，我们可以创建⼀个数组，统计⻓度为 x 的递增⼦序列中，最后⼀个元素是谁。为了尽可能让这个序列更⻓，我们仅需统计⻓度为 x 的所有递增序列中最后⼀个元素的「最⼩值」。
     </li>
     <li>
      统计的过程中发现，数组中的数呈现「递增」趋势，因此可以使⽤「⼆分」来查找插⼊位置。
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) 
    {
        int n = nums.size();
        vector&lt;int&gt; ret;
        ret.push_back(nums[0]);
        for (int i = 1; i &lt; n; i++) 
        {
            if (nums[i] &gt; ret.back()) // 如果能接在最后⼀个元素后⾯，直接放
            {
                ret.push_back(nums[i]);
            } else {
                // ⼆分插⼊位置
                int left = 0, right = ret.size() - 1;
                while (left &lt; right) {
                    int mid = (left + right) &gt;&gt; 1;
                    if (ret[mid] &lt; nums[i])
                        left = mid + 1;
                    else
                        right = mid;
                }
                ret[left] = nums[i]; // 放在 left 位置上
            }
        }
        return ret.size();
    }
};</code></pre>
    <h3 style="background-color:transparent">
     2.6、第六题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/increasing-triplet-subsequence/description/" rel="nofollow" title="334. 递增的三元子序列 - 力扣（LeetCode）">
       334. 递增的三元子序列 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="886" src="https://i-blog.csdnimg.cn/direct/f764f7be318f442486bf2c5b5f5098fe.png" width="1648"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     不⽤⼀个数组存数据，仅需两个变量即可。也不⽤⼆分插⼊位置，仅需两次⽐较就可以找到插⼊位
     <br/>
     置。
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public : bool increasingTriplet(vector&lt;int&gt;&amp; nums) 
{
        int a = nums[0], b = INT_MAX;
        for (int i = 1; i &lt; nums.size(); i++) 
        {
            if (nums[i] &gt; b)
                return true;
            else if (nums[i] &gt; a)
                b = nums[i];
            else
                a = nums[i];
        }
        return false;
    }
};</code></pre>
    <h2 style="background-color:transparent">
     三、结束语
     <strong>
     </strong>
    </h2>
    <p>
     今天内容就到这里啦，时间过得很快，大家沉下心来好好学习，会有一定的收获的，大家多多坚持，嘻嘻，成功路上注定孤独，因为坚持的人不多。那请大家举起自己的小手给博主一键三连，有你们的支持是我最大的动力💞💞💞，回见。
    </p>
    <p>
     <img alt="" height="190" src="https://i-blog.csdnimg.cn/blog_migrate/15e0d701305bac519d5e1792f515a055.jpeg" width="200"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f41416c796b6b2f:61727469636c652f64657461696c732f313434383330323131" class_="artid" style="display:none">
 </p>
</div>


