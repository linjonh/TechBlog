---
layout: post
title: "Android自定义View全解析从基础绘制到复杂交互,实战多种自定义View实现"
date: 2025-03-11 09:35:50 +0800
description: "自定义View的类型多种多样，开发者可以根据具体需求选择合适的实现方式。无论是简单的绘制、复杂的动画，还是自定义布局，掌握自定义View的开发技巧都能极大地提升应用的灵活性和用户体验。根据不同的需求，开发者可以创建各种类型的自定义View。自定义绘制View是最基础的自定义View类型，通常用于绘制图形、文本、图像等内容。自定义组合View是通过将多个现有的View组合在一起，形成一个新的复合View。自定义属性View允许开发者在XML中定义和使用自定义属性，以增强View的灵活性。"
keywords: "Android自定义View全解析：从基础绘制到复杂交互，实战多种自定义View实现"
categories: ['未分类']
tags: ['交互', 'Android']
artid: "146170313"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146170313
    alt: "Android自定义View全解析从基础绘制到复杂交互,实战多种自定义View实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146170313
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146170313
cover: https://bing.ee123.net/img/rand?artid=146170313
image: https://bing.ee123.net/img/rand?artid=146170313
img: https://bing.ee123.net/img/rand?artid=146170313
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android自定义View全解析：从基础绘制到复杂交互，实战多种自定义View实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在Android开发中，自定义View的应用场景非常广泛。根据不同的需求，开发者可以创建各种类型的自定义View。以下是几种常见的自定义View类型及其实现思路和示例。
     <br/>
     <strong>
      1. 自定义绘制View
     </strong>
     <br/>
     自定义绘制View是最基础的自定义View类型，通常用于绘制图形、文本、图像等内容。开发者通过重写onDraw()方法，使用Canvas和Paint来实现绘制。
    </p>
    <p>
     <strong>
      示例：自定义圆形View
     </strong>
    </p>
    <pre><code>public class CircleView extends View {
    private Paint paint;

    public CircleView(Context context) {
        super(context);
        init();
    }

    public CircleView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        paint = new Paint();
        paint.setColor(Color.RED);
        paint.setStyle(Paint.Style.FILL);
        paint.setAntiAlias(true); // 抗锯齿
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        int radius = Math.min(getWidth(), getHeight()) / 2;
        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, paint);
    }
}
</code></pre>
    <p>
     <strong>
      使用：
     </strong>
    </p>
    <pre><code>&lt;com.example.CircleView
    android:layout_width="100dp"
    android:layout_height="100dp"/&gt;
</code></pre>
    <p>
     <strong>
      2. 自定义组合View
     </strong>
     <br/>
     自定义组合View是通过将多个现有的View组合在一起，形成一个新的复合View。这种方式通常用于创建复杂的UI组件。
    </p>
    <p>
     <strong>
      示例：自定义标题栏
     </strong>
    </p>
    <pre><code>public class CustomTitleBar extends RelativeLayout {
    private TextView titleText;
    private ImageView backButton;

    public CustomTitleBar(Context context) {
        super(context);
        init(context);
    }

    public CustomTitleBar(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    private void init(Context context) {
        LayoutInflater.from(context).inflate(R.layout.custom_title_bar, this, true);
        titleText = findViewById(R.id.titleText);
        backButton = findViewById(R.id.backButton);

        backButton.setOnClickListener(v -&gt; {
            // 返回按钮点击事件
            if (context instanceof Activity) {
                ((Activity) context).finish();
            }
        });
    }

    public void setTitle(String title) {
        titleText.setText(title);
    }
}
</code></pre>
    <p>
     <strong>
      布局文件：custom_title_bar.xml
     </strong>
    </p>
    <pre><code>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="50dp"
    android:background="@color/colorPrimary"&gt;

    &lt;ImageView
        android:id="@+id/backButton"
        android:layout_width="30dp"
        android:layout_height="30dp"
        android:layout_centerVertical="true"
        android:layout_marginStart="10dp"
        android:src="@drawable/ic_back" /&gt;

    &lt;TextView
        android:id="@+id/titleText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:textColor="@android:color/white"
        android:textSize="18sp" /&gt;
&lt;/RelativeLayout&gt;
</code></pre>
    <p>
     <strong>
      使用：
     </strong>
    </p>
    <pre><code>&lt;com.example.CustomTitleBar
    android:id="@+id/titleBar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/&gt;
</code></pre>
    <p>
     <strong>
      3. 自定义动画View
     </strong>
     <br/>
     自定义动画View通常用于实现复杂的动画效果。开发者可以通过ValueAnimator、ObjectAnimator或PropertyValuesHolder等工具来实现动画。
    </p>
    <p>
     <strong>
      示例：自定义旋转进度条
     </strong>
    </p>
    <pre><code>public class RotatingProgressBar extends View {
    private Paint paint;
    private float rotationAngle = 0;

    public RotatingProgressBar(Context context) {
        super(context);
        init();
    }

    public RotatingProgressBar(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        paint = new Paint();
        paint.setColor(Color.BLUE);
        paint.setStyle(Paint.Style.STROKE);
        paint.setStrokeWidth(10);
        paint.setAntiAlias(true);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        int centerX = getWidth() / 2;
        int centerY = getHeight() / 2;
        int radius = Math.min(centerX, centerY) - 10;

        canvas.save();
        canvas.rotate(rotationAngle, centerX, centerY);
        canvas.drawCircle(centerX, centerY, radius, paint);
        canvas.restore();
    }

    public void startRotation() {
        ValueAnimator animator = ValueAnimator.ofFloat(0, 360);
        animator.setDuration(1000);
        animator.setRepeatCount(ValueAnimator.INFINITE);
        animator.addUpdateListener(animation -&gt; {
            rotationAngle = (float) animation.getAnimatedValue();
            invalidate();
        });
        animator.start();
    }
}
</code></pre>
    <p>
     <strong>
      使用：
     </strong>
    </p>
    <pre><code>RotatingProgressBar progressBar = findViewById(R.id.rotatingProgressBar);
progressBar.startRotation();
</code></pre>
    <p>
     <strong>
      4. 自定义触摸交互View
     </strong>
     <br/>
     自定义触摸交互View通常用于处理用户的触摸事件，例如拖动、缩放、点击等。
    </p>
    <p>
     <strong>
      示例：自定义可拖动View
     </strong>
    </p>
    <pre><code>public class DraggableView extends View {
    private float lastX, lastY;

    public DraggableView(Context context) {
        super(context);
        init();
    }

    public DraggableView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        setBackgroundColor(Color.GREEN);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                lastX = event.getX();
                lastY = event.getY();
                break;
            case MotionEvent.ACTION_MOVE:
                float dx = event.getX() - lastX;
                float dy = event.getY() - lastY;
                setX(getX() + dx);
                setY(getY() + dy);
                break;
        }
        return true;
    }
}
</code></pre>
    <p>
     <strong>
      使用：
     </strong>
    </p>
    <pre><code>&lt;com.example.DraggableView
    android:layout_width="100dp"
    android:layout_height="100dp"/&gt;
</code></pre>
    <p>
     <strong>
      5. 自定义属性View
     </strong>
     <br/>
     自定义属性View允许开发者在XML中定义和使用自定义属性，以增强View的灵活性。
    </p>
    <p>
     <strong>
      示例：自定义带属性的TextView
     </strong>
     <br/>
     <strong>
      在res/values/attrs.xml中定义属性
     </strong>
     ：
    </p>
    <pre><code>&lt;declare-styleable name="CustomTextView"&gt;
    &lt;attr name="customTextColor" format="color" /&gt;
    &lt;attr name="customTextSize" format="dimension" /&gt;
&lt;/declare-styleable&gt;
</code></pre>
    <p>
     <strong>
      在自定义View中解析属性：
     </strong>
    </p>
    <pre><code>public class CustomTextView extends TextView {
    public CustomTextView(Context context) {
        super(context);
        init(null);
    }

    public CustomTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(attrs);
    }

    private void init(AttributeSet attrs) {
        if (attrs != null) {
            TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.CustomTextView);
            int textColor = a.getColor(R.styleable.CustomTextView_customTextColor, Color.BLACK);
            float textSize = a.getDimension(R.styleable.CustomTextView_customTextSize, 16);
            a.recycle();

            setTextColor(textColor);
            setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
        }
    }
}
</code></pre>
    <p>
     <strong>
      在XML中使用：
     </strong>
    </p>
    <pre><code>&lt;com.example.CustomTextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World"
    app:customTextColor="@color/red"
    app:customTextSize="20sp"/&gt;
</code></pre>
    <p>
     <strong>
      6. 自定义ViewGroup
     </strong>
     <br/>
     自定义ViewGroup用于实现复杂的布局逻辑，例如瀑布流布局、环形布局等。
    </p>
    <p>
     <strong>
      示例：自定义流式布局
     </strong>
    </p>
    <pre><code>public class FlowLayout extends ViewGroup {
    public FlowLayout(Context context) {
        super(context);
    }

    public FlowLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        int childCount = getChildCount();
        int width = r - l;
        int x = 0, y = 0;

        for (int i = 0; i &lt; childCount; i++) {
            View child = getChildAt(i);
            if (x + child.getMeasuredWidth() &gt; width) {
                x = 0;
                y += child.getMeasuredHeight();
            }
            child.layout(x, y, x + child.getMeasuredWidth(), y + child.getMeasuredHeight());
            x += child.getMeasuredWidth();
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        measureChildren(widthMeasureSpec, heightMeasureSpec);
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre>
    <p>
     <strong>
      使用：
     </strong>
    </p>
    <pre><code>&lt;com.example.FlowLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"&gt;
    &lt;!-- 添加子View --&gt;
&lt;/com.example.FlowLayout&gt;
</code></pre>
    <p>
     <strong>
      总结
     </strong>
     <br/>
     自定义View的类型多种多样，开发者可以根据具体需求选择合适的实现方式。无论是简单的绘制、复杂的动画，还是自定义布局，掌握自定义View的开发技巧都能极大地提升应用的灵活性和用户体验。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f74616e6777656967756f30333035313938372f:61727469636c652f64657461696c732f313436313730333133" class_="artid" style="display:none">
 </p>
</div>


