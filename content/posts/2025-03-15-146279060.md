---
layout: post
title: "在-C-中使用-Dapper-查询数据并导出-Excel"
date: 2025-03-15 15:06:33 +0800
description: "完整流程查询数据库处理动态对象，存储静态对象 并存入。调用生成 Excel。支持静态 & 动态数据导出，自动解析嵌套对象。"
keywords: "在 C# 中使用 Dapper 查询数据并导出 Excel"
categories: ['.NET/C']
tags: ['数据库', '开发语言', 'Excel', 'C']
artid: "146279060"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146279060
    alt: "在-C-中使用-Dapper-查询数据并导出-Excel"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146279060
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146279060
cover: https://bing.ee123.net/img/rand?artid=146279060
image: https://bing.ee123.net/img/rand?artid=146279060
img: https://bing.ee123.net/img/rand?artid=146279060
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     在 C# 中使用 Dapper 查询数据并导出 Excel
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1. 背景介绍
    </h2>
    <p>
     在项目中，我们经常需要查询数据库中的数据并导出为 Excel 进行分析或存档。本篇文章介绍如何在
     <strong>
      C#
     </strong>
     中使用
     <strong>
      Dapper
     </strong>
     查询 SQL Server 数据，并通过
     <strong>
      EPPlus
     </strong>
     生成 Excel 文件，支持
     <strong>
      动态对象 (
      <code>
       ExpandoObject
      </code>
      ) 和静态实体对象
     </strong>
     的数据导出。
    </p>
    <h3>
     2. 代码结构概览
    </h3>
    <p>
     该实现包括以下部分：
    </p>
    <ol>
     <li>
      <strong>
       数据库查询 (
       <code>
        DapperHelper.Query
       </code>
       )
      </strong>
      ：执行 SQL 查询并返回
      <code>
       DynamicParameters
      </code>
      形式的结果。
     </li>
     <li>
      <strong>
       数据转换 (
       <code>
        ExpandoObject
       </code>
       )
      </strong>
      ：查询结果转换为动态对象。
     </li>
     <li>
      <strong>
       静态对象列表 (
       <code>
        Person
       </code>
       )
      </strong>
      ：示例数据。
     </li>
     <li>
      <strong>
       Excel 导出 (
       <code>
        ExcelHelper.ExportToExcel
       </code>
       )
      </strong>
      ：将数据转换为 Excel 文件，支持
      <strong>
       动态对象和静态对象
      </strong>
      ，自动适配嵌套属性。
     </li>
    </ol>
    <hr/>
    <h3>
     3. 代码实现
    </h3>
    <pre><code class="language-cs">Dictionary&lt;string, object&gt; keyValuePairs = new();</code></pre>
    <ul>
     <li>
      为了方便我们进行多个Sheet和多个数据查询，我这边会把多个数据存储到一个键值对里面，键值对的Key是Sheet的名字，Value是我们查出来的静态或者动态实体内容的集合
     </li>
    </ul>
    <h4>
     3.1 使用 Dapper 查询数据库
    </h4>
    <pre><code class="language-cs">public static async Task&lt;IEnumerable&lt;DynamicParameters&gt;&gt; Query(string sql, object? @params = null, int? commandTimeout = null, CommandType? commandType = null)
{
    string ConnStr = AppConfig.SqlLinks;
    using (var con = new SqlConnection(ConnStr))
    {
        var results = await con.QueryAsync(sql, @params, commandTimeout: commandTimeout, commandType: commandType);
        return results.Select(r =&gt; new DynamicParameters(r));
    }
}
</code></pre>
    <ul>
     <li>
      该方法使用
      <strong>
       Dapper
      </strong>
      查询数据库，并返回
      <code>
       DynamicParameters
      </code>
      。
     </li>
     <li>
      连接字符串从
      <code>
       AppConfig.SqlLinks
      </code>
      获取。
     </li>
     <li>
      我们在不想创建实体对象的情况下直接选择把内容转化为
      <strong>
       动态实体类型
      </strong>
     </li>
    </ul>
    <h4>
     3.2 查询
     <code>
      orders
     </code>
     表并转换为动态对象
    </h4>
    <pre><code class="language-cs">string sql = "Select * From [1booking].[dbo].[orders] With(NoLock)";
var results = await DapperHelper.Query(sql);
if (results.Count() &gt; 0 &amp;&amp; results != null)
{
    var objects = results.Select(r =&gt;
    {
        var expando = new ExpandoObject();
        var dict = (IDictionary&lt;string, object&gt;)expando!;
        foreach (var key in r.ParameterNames)
        {
            dict[key] = r.Get&lt;object&gt;(key);
        }
        return expando;
    });
}
</code></pre>
    <ul>
     <li>
      查询
      <code>
       orders
      </code>
      表，并转换查询结果为
      <strong>
       动态对象 (
       <code>
        ExpandoObject
       </code>
       )
      </strong>
      。
     </li>
     <li>
      我们把他转换为动态对象之后，后续就可以使用它来直接展示
     </li>
     <li>
      把他直接存储键值对中，这个肯定都会存储，我这边就少些一行代码了
     </li>
    </ul>
    <h4>
     3.3 示例：静态对象列表
     <code>
      Person
     </code>
    </h4>
    <pre><code class="language-cs">var people = new List&lt;Person&gt;
{
    new Person
    {
        Id = 1,
        Name = "张三",
        BirthDate = new DateTime(1990, 1, 1),
        Salary = 5000.50m,
        Address = new Address { City = "北京", State = "北京" },
        Info = new Info {A = "2", B = "C"}
    },
    new Person
    {
        Id = 2,
        Name = "李四",
        BirthDate = new DateTime(1985, 5, 12),
        Salary = 8000.75m,
        Address = new Address { City = "上海", State = "上海" },
        Info = new Info {A = "1", B = "B"}
    }
};
</code></pre>
    <ul>
     <li>
      定义
      <strong>
       静态对象
       <code>
        Person，这里都是我的示例，举例说明的，可以是任何静态对象多层嵌套也是没问题的
       </code>
      </strong>
      。
     </li>
     <li>
      把他直接存储键值对中，这个肯定都会存储，我这边就少些一行代码了
     </li>
    </ul>
    <h4>
     3.4 调用 Excel 导出方法
    </h4>
    <pre><code class="language-cs">var excelData = ExcelHelper.ExportToExcel&lt;Task&gt;(keyValuePairs);
</code></pre>
    <ul>
     <li>
      通过
      <code>
       ExcelHelper.ExportToExcel&lt;T&gt;
      </code>
      方法，将
      <code>
       keyValuePairs
      </code>
      导出为 Excel。
     </li>
     <li>
      在这一步也就是调用我们主要的实现方法，这个方法里面主要是处理Excel和我们的实体区分处理。以实现全自动处理不区分类型
     </li>
    </ul>
    <h4>
     3.5 Excel 导出实现 (
     <code>
      ExcelHelper
     </code>
     )
    </h4>
    <pre><code class="language-cs">public static byte[] ExportToExcel&lt;T&gt;(Dictionary&lt;string, object&gt; dataSets)
{
    // 首先我们不能让我们的集合是空的
    if (dataSets == null || !dataSets.Any())
    {
        throw new ArgumentException("数据列表不能为空");
    }
    // 因为这个分商用版和个人版本，一个收费一个不收费，所以我选择个人使用
    ExcelPackage.LicenseContext = OfficeOpenXml.LicenseContext.NonCommercial;
    // 创建一个处理Excel的生命周期
    using (var package = new ExcelPackage())
    {
        // 这一步也就是我上面所说的，如果有多个集合进行区分Sheet处理不同Sheet存放不同集合数据
        foreach (var dataSet in dataSets)
        {
            var sheetName = dataSet.Key;
            var data = dataSet.Value;
            var worksheet = package.Workbook.Worksheets.Add(sheetName);
            
            if (data is IEnumerable&lt;ExpandoObject&gt; dynamicList)
            {// 这一步主要是处理动态集合元素
                // 获取动态集合的属性，这里一般动态元素的类型我们是获取不到的都是null
                var properties = GetAllProperties(dynamicList.FirstOrDefault(), typeof(T));
                for (int i = 0; i &lt; properties.Count; i++)
                {
                    // 写入第一行属性名称
                    worksheet.Cells[1, i + 1].Value = properties[i].DisplayName ?? properties[i].PropertyName;
                }
                for (int row = 0; row &lt; dynamicList.Count(); row++)
                {
                    var item = dynamicList.ElementAt(row);
                    for (int col = 0; col &lt; properties.Count; col++)
                    {
                        // 这一步用来处理嵌套属性
                        worksheet.Cells[row + 2, col + 1].Value = GetNestedPropertyValue(item, properties[col].PropertyName);
                    }
                }
            }
            else if (data is IEnumerable&lt;object&gt; list)
            {// 这一步主要是处理静态集合元素
                // 获取静态集合的属性，像是静态属性，这里是可以获取到的
                var properties = GetAllProperties(list.FirstOrDefault(), typeof(T));
                for (int i = 0; i &lt; properties.Count; i++)
                {
                    // 写入第一行属性名称
                    worksheet.Cells[1, i + 1].Value = properties[i].DisplayName ?? properties[i].PropertyName;
                }
                int row = 2;
                foreach (var item in list)
                {
                    for (int col = 0; col &lt; properties.Count; col++)
                    {
                        // 写入内容
                        worksheet.Cells[row, col + 1].Value = GetNestedPropertyValue(item, properties[col].PropertyName);
                    }
                    row++;
                }
            }
            // 自动调整列宽
            worksheet.Cells.AutoFitColumns();
        }
        // 返回Excel文件的字节数组
        return package.GetAsByteArray();
    }
}

</code></pre>
    <p>
    </p>
    <pre><code class="language-cs">private static List&lt;PropertyMetadata&gt; GetAllProperties(object obj, Type type = null, string prefix = "")
{
    // 处理 动态属性
    if (obj is IDictionary&lt;string, object&gt; dict)
    {
        // 遍历 ExpandoObject 的键值对
        foreach (var key in dict.Keys)
        {
            // 添加属性元数据（ExpandoObject 没有 PropertyInfo）
            properties.Add(new PropertyMetadata(null, key, key));
        }
    }
    // 处理静态属性
    else
    {
        // 获取类型的公共实例属性
        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            // 构造属性名称（考虑前缀）
            var propertyName = string.IsNullOrEmpty(prefix) ? prop.Name : $"{prefix}.{prop.Name}";

            // 处理基本类型属性
            if (prop.PropertyType.IsPrimitive || prop.PropertyType == typeof(string) || prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(decimal))
            {
                // 获取显示名称（DisplayNameAttribute）
                var displayName = prop.GetCustomAttribute&lt;DisplayNameAttribute&gt;()?.DisplayName;
                // 添加属性元数据
                properties.Add(new PropertyMetadata(prop, propertyName, displayName));
            }
            // 处理嵌套对象属性
            else if (prop.PropertyType.IsClass)
            {
                // 递归获取嵌套属性
                properties.AddRange(GetAllProperties(null, prop.PropertyType, propertyName));
            }
        }
    }
    // 返回属性元数据列表
    return properties;
}</code></pre>
    <pre><code class="language-cs">/// &lt;summary&gt;
/// 属性名称（包括前缀）
/// &lt;/summary&gt;
public string PropertyName { get; }

/// &lt;summary&gt;
/// 属性显示名称（DisplayNameAttribute）
/// &lt;/summary&gt;
public string DisplayName { get; }

/// &lt;summary&gt;
/// 构造函数
/// &lt;/summary&gt;
/// &lt;param name="propertyInfo"&gt;PropertyInfo 对象（如果是基本类型，则为 null）&lt;/param&gt;
/// &lt;param name="propertyName"&gt;属性名称（包括前缀）&lt;/param&gt;
/// &lt;param name="displayName"&gt;属性显示名称（DisplayNameAttribute）&lt;/param&gt;
public PropertyMetadata(PropertyInfo propertyInfo, string propertyName, string displayName)
{
    PropertyInfo = propertyInfo;
    PropertyName = propertyName;
    DisplayName = displayName;
}</code></pre>
    <p>
    </p>
    <pre><code class="language-cs">private static object GetNestedPropertyValue(object obj, string propertyName)
{
    // 分割属性名称（支持嵌套属性）
    var props = propertyName.Split('.');

    // 初始化属性值
    object value = obj;

    // 遍历属性名称
    foreach (var prop in props)
    {
        // 检查属性值是否为空
        if (value == null)
        {
            return null; // 如果属性值为空，则返回 null
        }

        // 处理 动态属性，一般这个区分不了类型，后续可以在写入文档的时候区分类型
        if (value is IDictionary&lt;string, object&gt; dict)
        {
            // 尝试获取属性值
            dict.TryGetValue(prop, out value);
        }
        else // 处理静态属性
        {
            // 获取属性信息
            var propertyInfo = value.GetType().GetProperty(prop);

            // 检查属性是否存在
            if (propertyInfo == null)
            {
                return null; // 如果属性不存在，则返回 null
            }

            // 获取属性值
            value = propertyInfo.GetValue(value);
        }
    }

    // 返回属性值
    return value;
}</code></pre>
    <ul>
     <li>
      <strong>
       自动解析动态对象和静态对象
      </strong>
     </li>
     <li>
      <strong>
       支持嵌套对象属性导出
      </strong>
     </li>
     <li>
      <strong>
       格式化 Excel，自动调整列宽
      </strong>
     </li>
    </ul>
    <h4>
     <strong>
      3.6 最后输出结果展示
     </strong>
    </h4>
    <p>
     <img alt="" height="200" src="https://i-blog.csdnimg.cn/direct/d4b3dff2e43c4b81965233b75a8ee2bc.png" width="272">
      <img alt="" height="200" src="https://i-blog.csdnimg.cn/direct/52cd97195dbf4dc29b3c9b972e5989eb.png" width="288"/>
     </img>
    </p>
    <hr/>
    <h3>
     4. 总结
    </h3>
    <h4>
     📌
     <strong>
      完整流程
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       查询数据库
      </strong>
      （
      <code>
       DapperHelper.Query
      </code>
      ）。
     </li>
     <li>
      <strong>
       处理动态对象 (
       <code>
        ExpandoObject
       </code>
       )
      </strong>
      ，并存入
      <code>
       keyValuePairs
      </code>
      。
     </li>
     <li>
      <strong>
       存储静态对象 (
       <code>
        Person
       </code>
       )
      </strong>
      ，并存入
      <code>
       keyValuePairs
      </code>
      。
     </li>
     <li>
      <strong>
       调用
       <code>
        ExcelHelper.ExportToExcel
       </code>
       生成 Excel
      </strong>
      。
     </li>
     <li>
      <strong>
       支持静态 &amp; 动态数据导出
      </strong>
      ，自动解析嵌套对象。
     </li>
    </ol>
    <h4>
     🎯
     <strong>
      适用场景
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      大批量数据导出
     </strong>
     <br/>
     ✅
     <strong>
      动态数据结构（
      <code>
       ExpandoObject
      </code>
      ）
     </strong>
     <br/>
     ✅
     <strong>
      支持嵌套对象
     </strong>
    </p>
    <p>
     希望这篇文章能帮助你在 C# 项目中高效导出 Excel 数据！🚀
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35393138303434322f:61727469636c652f64657461696c732f313436323739303630" class_="artid" style="display:none">
 </p>
</div>


