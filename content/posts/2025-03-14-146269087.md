---
layout: post
title: "k8s基础架构介绍"
date: 2025-03-14 23:03:10 +0800
description: "k8s基础架构介绍"
keywords: "k8s基础架构介绍"
categories: ['Docker']
tags: ['容器', '云原生', 'Kubernetes']
artid: "146269087"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146269087
    alt: "k8s基础架构介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146269087
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146269087
cover: https://bing.ee123.net/img/rand?artid=146269087
image: https://bing.ee123.net/img/rand?artid=146269087
img: https://bing.ee123.net/img/rand?artid=146269087
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     k8s基础架构介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="k8s_0">
     </a>
     k8s基础架构介绍
    </h2>
    <p>
     k8s 是对容器进行编排的一种工具。通过k8s可以实现对容器的编排、部署、更新等
    </p>
    <p>
     学习k8s之前，先了解相关的一些使用和配置k8s的一些工具。
    </p>
    <h3>
     <a id="k8s_5">
     </a>
     k8s的常用工具
    </h3>
    <p>
     在 kubernetes 中，主要有三个日常使用的工具，这些工具使用 kube 前缀命名，这三个工具如下：
    </p>
    <h4>
     <a id="kubeadm_8">
     </a>
     kubeadm
    </h4>
    <p>
     用来初始化集群的指令，能够创建集群,并且添加新的节点。可用其它部署工具替代。
    </p>
    <p>
     具体功能有:
    </p>
    <ol>
     <li>
      <p>
       初始化集群：在控制平面节点（Master 节点）上运行
       <code>
        kubeadm init
       </code>
       ，自动生成集群所需的证书、配置文件和核心组件（如 API Server、Controller Manager、Scheduler 等）。
      </p>
     </li>
     <li>
      <p>
       ​加入节点：生成
       <code>
        kubeadm join
       </code>
       命令，将工作节点（Worker 节点）添加到集群。
      </p>
     </li>
     <li>
      <p>
       升级集群：支持 Kubernetes 版本的升级（如
       <code>
        kubeadm upgrade
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       重置集群：通过
       <code>
        kubeadm reset
       </code>
       清理集群状态。
      </p>
     </li>
    </ol>
    <h4>
     <a id="kubelet_22">
     </a>
     kubelet：
    </h4>
    <p>
     ​运行在每个节点（Master 和 Worker）上的代理，直接与容器运行时（如 Docker、containerd）交互，负责与API-server通信，管理节点上的 Pod 和容器生命周期。具体功能包括
    </p>
    <ol>
     <li>
      <p>
       ​启动/停止容器：根据 Kubernetes API Server 的指令，创建或终止 Pod 中的容器。
      </p>
     </li>
     <li>
      <p>
       监控容器的运行状态，并向 API Server 报告节点和 Pod 的健康状态。
      </p>
     </li>
     <li>
      <p>
       挂载存储卷：按需挂载 Pod 所需的存储卷（如 Persistent Volume）。
      </p>
     </li>
     <li>
      <p>
       ​执行探针：运行
       <code>
        livenessProbe
       </code>
       和
       <code>
        readinessProbe
       </code>
       检查容器状态。
      </p>
     </li>
    </ol>
    <h4>
     <a id="kubectl_34">
     </a>
     kubectl
    </h4>
    <p>
     kubectl：用k8s中的命令行工具，与 kubernetes API-Server 通讯，是我们操作集群的客户端。具体功能有
    </p>
    <ol>
     <li>
      <p>
       创建、删除、更新、查看集群中的资源（如
       <code>
        kubectl create
       </code>
       ,
       <code>
        kubectl delete
       </code>
       ）
      </p>
     </li>
     <li>
      <p>
       ​调试集群：查看 Pod 日志（
       <code>
        kubectl logs
       </code>
       ）、进入容器终端（
       <code>
        kubectl exec
       </code>
       ）、检查资源状态（
       <code>
        kubectl describe
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       通过 YAML 文件声明式管理资源（如
       <code>
        kubectl apply -f deployment.yaml
       </code>
       ）。
      </p>
     </li>
    </ol>
    <p>
     那么我们操纵集群中的节点是怎么办到的呢，其实就是用户通过 kubectl 向 API Server 发送指令，API Server 再将指令传递给 kubelet 执行。
    </p>
    <p>
     讲完常用的工具，接下来，我们就可以一起看一下k8s的架构了。
    </p>
    <h3>
     <a id="k8s__47">
     </a>
     k8s 架构
    </h3>
    <p>
     一个 kubernetes 集群是由一组被称为节点的机器或虚拟机组成，节点有 master、worker 两种类型。一个集群中至少有一个 master 节点，在没有 worker 节点的情况下， Pod 也可以部署到 master 节点上。如果集群中的节点数量非常多，则可考虑扩展 master 节点，使用多个 master 节点控制集群。
    </p>
    <p>
     k8s中的master节点组成了控制平面，worker节点组成了数据平面。
    </p>
    <h4>
     <a id="_53">
     </a>
     控制平面
    </h4>
    <p>
     控制平面由master节点组成。一个maser节点中通常由5个组件，包括
    </p>
    <ol>
     <li>
      <p>
       ​kube-apiserver：集群的“入口”，提供 REST API，接收用户请求（如 kubectl 命令）。
      </p>
     </li>
     <li>
      <p>
       etcd:分布式键值存储数据库，保存集群的所有配置和状态数据。
      </p>
     </li>
     <li>
      <p>
       kube-scheduler：调度 Pod 到合适的节点上运行。
      </p>
     </li>
     <li>
      <p>
       kube-controller-manager：运行各种控制器（如 Deployment、Node 控制器），确保集群处于期望状态。
      </p>
     </li>
     <li>
      <p>
       ​cloud-controller-manager​（可选）：与云平台（如 AWS、GCP）交互，实现云原生功能。
      </p>
     </li>
    </ol>
    <h4>
     <a id="_66">
     </a>
     数据平面
    </h4>
    <p>
     数据平面是 Kubernetes 集群中实际承载工作负载的核心层，由一组 ​工作节点（Worker Node）​ 构成，负责运行用户应用（Pod）并处理计算、存储、网络等实际任务。
    </p>
    <p>
     每个worker节点中，都必须有:
    </p>
    <p>
     kubelet：节点代理，管理本节点上 Pod 的生命周期（创建、终止、重启容器）、监控容器状态（如 CPU/内存使用率），并向控制平面报告节点和 Pod 的健康状态、挂载存储卷（Volume）、执行容器探针（Liveness/Readiness Probe）等。
    </p>
    <p>
     kube-proxy：节点网络代理，维护 Kubernetes 服务的网络规则，确保 Pod 跨节点通信时，流量能正确转发到目标端点（Endpoint）、实现 Service 的负载均衡和网络流量路由（通过 iptables 或 IPVS 规则）。
    </p>
    <h3>
     <a id="k8spod_75">
     </a>
     k8s部署一个pod的完整流程
    </h3>
    <p>
     当用户通过
     <code>
      kubectl create
     </code>
     或
     <code>
      kubectl apply
     </code>
     提交资源声明（如 Deployment、Pod）时，集群会按以下步骤协调资源：
    </p>
    <ol>
     <li>
      <p>
       用户提交指令
      </p>
      <p>
       kubectl 将 YAML 文件内容转换为 API 请求，发送至 ​API Server。
      </p>
     </li>
     <li>
      <p>
       ​API Server 处理请求
      </p>
      <p>
       API Server 对请求进行身份认证（Authentication）、权限校验（Authorization）并将资源定义（如 Pod 规格）持久化到 ​etcd 数据库。
      </p>
     </li>
     <li>
      <p>
       ​调度决策（Scheduler）
      </p>
      <p>
       调度器监听 API Server 的未调度 Pod 事件，执行以下逻辑：
       <br/>
       过滤满足 Pod 资源需求的节点（如 CPU/内存/GPU）。
       <br/>
       根据策略（亲和性、污点容忍、拓扑分布等）为 Pod 选择最优节点。
      </p>
     </li>
     <li>
      <p>
       节点执行（kubelet）
      </p>
      <p>
       目标节点的 ​kubelet 检测到新 Pod 调度到本节点后：
      </p>
      <ul>
       <li>
        从镜像仓库拉取容器镜像（若本地不存在）。
       </li>
       <li>
        调用容器运行时创建容器，挂载存储卷。
       </li>
       <li>
        启动容器并执行探针检查。
       </li>
       <li>
        持续监控容器状态，并上报至 API Server。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​状态反馈与协调（Controller Manager）​
      </p>
      <p>
       ​控制器（如 Deployment Controller）​ 持续监听 Pod 状态，若Pod 异常终止，触发重启或重建（根据重启策略），若期望副本数与实际不符，触发扩缩容操作。
      </p>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36303231343339372f:61727469636c652f64657461696c732f313436323639303837" class_="artid" style="display:none">
 </p>
</div>


