---
layout: post
title: "LeetCode93.-复原-IP-地址DFS-Java"
date: 2025-03-13 16:09:57 +0800
description: "  比较简单，就是暴力dfs模拟就行。注意校验，比如范围，以及前导零，说明该位置只能为0然后继续递归。"
keywords: "LeetCode：93. 复原 IP 地址（DFS Java）"
categories: ['Leetcode']
tags: ['深度优先', 'Tcp', 'Leetcode']
artid: "146234063"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146234063
    alt: "LeetCode93.-复原-IP-地址DFS-Java"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146234063
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146234063
cover: https://bing.ee123.net/img/rand?artid=146234063
image: https://bing.ee123.net/img/rand?artid=146234063
img: https://bing.ee123.net/img/rand?artid=146234063
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LeetCode：93. 复原 IP 地址（DFS Java）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 name="93.%20%E5%A4%8D%E5%8E%9F%20IP%20%E5%9C%B0%E5%9D%80">
     93. 复原 IP 地址
    </h2>
    <h3 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A" name="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A">
     题目描述：
    </h3>
    <p>
     <strong>
      有效 IP 地址
     </strong>
     正好由四个整数（每个整数位于
     <code>
      0
     </code>
     到
     <code>
      255
     </code>
     之间组成，且不能含有前导
     <code>
      0
     </code>
     ），整数之间用
     <code>
      '.'
     </code>
     分隔。
    </p>
    <ul>
     <li>
      例如：
      <code>
       "0.1.2.201"
      </code>
      和
      <code>
       "192.168.1.1"
      </code>
      是
      <strong>
       有效
      </strong>
      IP 地址，但是
      <code>
       "0.011.255.245"
      </code>
      、
      <code>
       "192.168.1.312"
      </code>
      和
      <code>
       "192.168@1.1"
      </code>
      是
      <strong>
       无效
      </strong>
      IP 地址。
     </li>
    </ul>
    <p>
     给定一个只包含数字的字符串
     <code>
      s
     </code>
     ，用以表示一个 IP 地址，返回所有可能的
     <strong>
      有效 IP 地址
     </strong>
     ，这些地址可以通过在
     <code>
      s
     </code>
     中插入
     <code>
      '.'
     </code>
     来形成。你
     <strong>
      不能
     </strong>
     重新排序或删除
     <code>
      s
     </code>
     中的任何数字。你可以按
     <strong>
      任何
     </strong>
     顺序返回答案。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>s = "25525511135"
<strong>输出：</strong>["255.255.11.135","255.255.111.35"]
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>s = "0000"
<strong>输出：</strong>["0.0.0.0"]
</pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><strong>输入：</strong>s = "101023"
<strong>输出：</strong>["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
</pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       1 &lt;= s.length &lt;= 20
      </code>
     </li>
     <li>
      <code>
       s
      </code>
      仅由数字组成
     </li>
    </ul>
    <h3 id="%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9A" name="%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%9A">
     实现代码与解析：
    </h3>
    <h4 id="DFS" name="DFS">
     DFS
    </h4>
    <pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

class Solution {

    public List&lt;String&gt; res = new ArrayList&lt;&gt;();

    public String[] seg = new String[4];

    public List&lt;String&gt; restoreIpAddresses(String s) {

        dfs(s, 0, 0);
        return res;
    }

    private void dfs(String s, int cnt, int cur) {

        if (cnt == 4) {
            if (cur == s.length()) {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i &lt; 4; i++) {
                    sb.append(seg[i]);
                    if (i &lt; 3) {
                        sb.append('.');
                    }
                }
                res.add(sb.toString());
            }
            return;
        }

        if (cur == s.length()) {
            return;
        }

        if (s.charAt(cur) == '0') {
            seg[cnt] = "0";
            dfs(s, cnt + 1, cur + 1);
        }

        int t = 0;
        for (int start = cur; start &lt; s.length(); start ++) {
            t = t * 10 + (s.charAt(start) - '0');
            if (t &gt; 0 &amp;&amp; t &lt;= 255) {
                seg[cnt] = t + "";
                dfs(s, cnt + 1, start + 1);
            } else {
                break;
            }
        }
    }
}</code></pre>
    <h4 id="%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF%EF%BC%9A" name="%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF%EF%BC%9A">
     原理思路：
    </h4>
    <p>
     比较简单，就是暴力dfs模拟就行。注意校验，比如范围，以及前导零，说明该位置只能为0然后继续递归。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f436f736d6f736868687979792f:61727469636c652f64657461696c732f313436323334303633" class_="artid" style="display:none">
 </p>
</div>


