---
layout: post
title: "LEETCODE二叉树的层序遍历JAVA"
date: 2025-03-09 16:51:42 +0800
description: "给你二叉树的根节点root，返回其节点值的。（即逐层地，从左到右访问所有节点）。root = [1][[1]]root = [][][0, 2000]用一个全局列表 ans 表示所有层，其中 ans.get(deep) 对应第 deep 层的节点值集合。每次递归时，deep 表示当前节点所在的层号（从 0 开始）。如果 ans 的大小不足以容纳当前层（即 ans.size() < deep + 1），就添加一个新的空列表。然后将当前节点的值加入对应层的列表中。"
keywords: "LEETCODE:二叉树的层序遍历JAVA"
categories: ['算法']
tags: ['算法', 'Leetcode', 'Java']
artid: "146133929"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146133929
    alt: "LEETCODE二叉树的层序遍历JAVA"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146133929
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146133929
cover: https://bing.ee123.net/img/rand?artid=146133929
image: https://bing.ee123.net/img/rand?artid=146133929
img: https://bing.ee123.net/img/rand?artid=146133929
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LEETCODE:二叉树的层序遍历JAVA
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     102.二叉树的层序遍历
    </h2>
    <blockquote>
     <p>
      给你二叉树的根节点
      <code>
       root
      </code>
      ，返回其节点值的
      <strong>
       层序遍历
      </strong>
      。 （即逐层地，从左到右访问所有节点）。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p class="img-center">
      <img alt="" height="302" src="https://i-blog.csdnimg.cn/img_convert/882baef69392a8695e3b5f5d2a78d0aa.jpeg" width="277"/>
     </p>
     <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[3],[9,20],[15,7]]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中节点数目在范围
       <code>
        [0, 2000]
       </code>
       内
      </li>
      <li>
       <code>
        -1000 &lt;= Node.val &lt;= 1000
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路1
     </strong>
    </p>
    <blockquote>
     <p>
      用一个全局列表 ans 表示所有层，其中 ans.get(deep) 对应第 deep 层的节点值集合。每次递归时，deep 表示当前节点所在的层号（从 0 开始）。如果 ans 的大小不足以容纳当前层（即 ans.size() &lt; deep + 1），就添加一个新的空列表。然后将当前节点的值加入对应层的列表中。
     </p>
    </blockquote>
    <p>
     <strong>
      代码1
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    // 定义一个全局的 List&lt;List&lt;Integer&gt;&gt; 用于存储层序遍历的结果，每一层是一个 List&lt;Integer&gt;
    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
    
    // 主方法，接收二叉树的根节点，返回层序遍历结果
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        Integer deep = 0;  // 初始化深度为 0，表示从根节点所在的第 0 层开始
        fun1(root, deep);  // 调用辅助方法 fun1 开始递归遍历
        return ans;        // 返回最终的层序遍历结果
    }
    
    // 辅助方法，使用递归按深度填充每一层的节点值
    public void fun1(TreeNode root, Integer deep) {
        if (root == null) {  // 如果当前节点为空，直接返回（递归的终止条件）
            return;
        }
        // 检查当前深度是否超出现有层数，如果是，则添加一个新的空列表表示新的一层
        if (ans.size() &lt; deep + 1) {
            ans.add(new ArrayList&lt;&gt;());  // 为新的一层创建一个独立的 ArrayList
        }
        // 将当前节点的值添加到对应深度的列表中
        ans.get(deep).add(root.val);
        // 递归处理左子树，深度加 1（进入下一层）
        fun1(root.left, deep + 1);
        // 递归处理右子树，深度加 1（进入下一层）
        fun1(root.right, deep + 1);
    }
}</code></pre>
    <p>
     <strong>
      解题思路2
     </strong>
    </p>
    <blockquote>
     <p>
      队列遵循“先进先出”（FIFO）的特性，先将根节点入队，然后逐层处理节点。每处理一层时，记录当前队列大小（即该层节点数），依次移除每个节点并访问，同时将其左右子节点加入队列，为下一层做准备。
     </p>
    </blockquote>
    <p>
     <strong>
      代码2
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    // 定义全局结果列表，存储层序遍历的每一层节点值
    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
    // 定义队列，用于按层存储待处理的节点
    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    
    // 主方法，接收二叉树根节点，返回层序遍历结果
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if (root == null) {  // 如果根节点为空，直接返回空的结果列表
            return ans;
        }
        queue.offer(root);   // 将根节点加入队列，作为第一层开始
        while (!queue.isEmpty()) {  // 当队列不为空时，继续处理每一层
            int len = queue.size();  // 获取当前层的节点数量
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();  // 创建当前层的节点值列表
            while (len &gt; 0) {  // 遍历当前层的所有节点
                TreeNode node = new TreeNode();  // 创建一个新节点（多余，稍后改进）
                node = queue.poll();  // 从队列头部移除并获取当前节点（覆盖上面的新节点）
                list.add(node.val);   // 将当前节点值加入当前层列表
                if (node.left != null) queue.offer(node.left);   // 如果有左子节点，加入队列
                if (node.right != null) queue.offer(node.right); // 如果有右子节点，加入队列
                len--;  // 当前层节点计数减 1
            }
            ans.add(list);  // 当前层处理完毕，将其加入结果列表
        }
        return ans;  // 返回完整的层序遍历结果
    }
}</code></pre>
    <h2>
     107.二叉树的层序遍历2
    </h2>
    <blockquote>
     <p>
      给你二叉树的根节点
      <code>
       root
      </code>
      ，返回其节点值
      <strong>
       自底向上的层序遍历
      </strong>
      。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p class="img-center">
      <img alt="" height="302" src="https://i-blog.csdnimg.cn/img_convert/882baef69392a8695e3b5f5d2a78d0aa.jpeg" width="277"/>
     </p>
     <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[15,7],[9,20],[3]]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中节点数目在范围
       <code>
        [0, 2000]
       </code>
       内
      </li>
      <li>
       <code>
        -1000 &lt;= Node.val &lt;= 1000
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
     </p>
     <ul>
      <li>
       先用标准的层序遍历（BFS）从顶向下获取所有层的节点值，存储在 ans 中，结果是从根到叶子的顺序（[[3], [9, 20], [15, 7]]）。
      </li>
      <li>
       使用 Collections.reverse() 将 ans 反转，变成从叶子到根的顺序（[[15, 7], [9, 20], [3]]）。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    // 标准层序遍历（从顶向下）
    private List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();  // 局部变量，避免状态残留
        if (root == null) {
            return ans;
        }
        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();  // 局部队列
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; len; i++) {  // 用 for 循环替代 while
                TreeNode node = queue.poll();  // 直接获取节点
                list.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            ans.add(list);
        }
        return ans;
    }
    
    // 自底向上层序遍历
    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = levelOrder(root);  // 获取从顶向下的结果
        Collections.reverse(result);  // 反转列表，实现自底向上
        return result;
    }
}</code></pre>
    <h2>
     <strong>
      199.二叉树的右视图
     </strong>
    </h2>
    <blockquote>
     <p>
      给定一个二叉树的
      <strong>
       根节点
      </strong>
      <code>
       root
      </code>
      ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
      <strong>
       输入：
      </strong>
      root = [1,2,3,null,5,null,4]
     </p>
     <p>
      <strong>
       输出：
      </strong>
      [1,3,4]
     </p>
     <p>
      <strong>
       解释：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="348" src="https://i-blog.csdnimg.cn/img_convert/d2c7d834e7d8c74c6ee5fcf01ad6c97f.png" width="671"/>
     </p>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <p>
      <strong>
       输入：
      </strong>
      root = [1,2,3,4,null,null,null,5]
     </p>
     <p>
      <strong>
       输出：
      </strong>
      [1,3,4,5]
     </p>
     <p>
      <strong>
       解释：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="443" src="https://i-blog.csdnimg.cn/img_convert/850797b58a6fc421ed26a0427c9e9272.png" width="829"/>
     </p>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <p>
      <strong>
       输入：
      </strong>
      root = [1,null,3]
     </p>
     <p>
      <strong>
       输出：
      </strong>
      [1,3]
     </p>
     <p>
      <strong>
       示例 4：
      </strong>
     </p>
     <p>
      <strong>
       输入：
      </strong>
      root = []
     </p>
     <p>
      <strong>
       输出：
      </strong>
      []
     </p>
     <p>
     </p>
     <p>
      <strong>
       提示:
      </strong>
     </p>
     <ul>
      <li>
       二叉树的节点个数的范围是
       <code>
        [0,100]
       </code>
      </li>
      <li>
       <code>
        -100 &lt;= Node.val &lt;= 100
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <ul>
      <li>
       通过深度参数（deep）跟踪当前节点所在的层号。
      </li>
      <li>
       对于每一层，优先保留最右侧节点的值。递归时先访问左子树，再访问右子树，这样右子树的值会覆盖同一层的左子树值。
      </li>
      <li>
       list 的索引对应层号，list.get(deep) 表示第 deep 层的最右侧节点值。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();  // 局部变量，避免状态残留
        fun1(root, 0, list);  // 传入 list 作为参数
        return list;
    }
    
    private void fun1(TreeNode root, int deep, List&lt;Integer&gt; list) {
        if (root == null) {  // 空节点返回
            return;
        }
        // 确保 list 大小足够当前深度
        while (list.size() &lt;= deep) {
            list.add(0);  // 添加默认值（可以优化）
        }
        list.set(deep, root.val);  // 设置当前深度的值（右子树会覆盖左子树）
        fun1(root.left, deep + 1, list);   // 先递归左子树
        fun1(root.right, deep + 1, list);  // 后递归右子树（右子树值保留）
    }
}</code></pre>
    <h2>
     429.N叉树的层序遍历
    </h2>
    <blockquote>
     <p>
      给定一个 N 叉树，返回其节点值的
      <em>
       层序遍历
      </em>
      。（即从左到右，逐层遍历）。
     </p>
     <p>
      树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="502" src="https://i-blog.csdnimg.cn/img_convert/95ad16df21f87bd9432de87eaf573c3d.png" width="781"/>
     </p>
     <pre><strong>输入：</strong>root = [1,null,3,2,4,null,5,6]
<strong>输出：</strong>[[1],[3,2,4],[5,6]]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="541" src="https://i-blog.csdnimg.cn/img_convert/301c60662a6b31bee7896f9e5b7008de.png" width="596"/>
     </p>
     <pre><strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>输出：</strong>[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树的高度不会超过
       <code>
        1000
       </code>
      </li>
      <li>
       树的节点总数在
       <code>
        [0, 104]
       </code>
       之间
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <ul>
      <li>
       队列遵循“先进先出”（FIFO）特性，先将根节点入队，然后逐层处理节点。
      </li>
      <li>
       每处理一层时，记录当前队列大小（len），依次移除每个节点，访问其值，并将其所有子节点加入队列，为下一层做准备。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    // 主方法，返回 N 叉树的层序遍历结果
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();  // 存储每层节点值的列表
        if (root == null) {  // 如果根节点为空，返回空结果
            return ans;
        }
        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();  // 创建队列用于 BFS
        queue.offer(root);  // 将根节点加入队列，作为第一层
        while (!queue.isEmpty()) {  // 当队列不为空时，继续处理
            int len = queue.size();  // 获取当前层的节点数量
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();  // 存储当前层的节点值
            for (int i = 0; i &lt; len; i++) {  // 遍历当前层的所有节点
                Node node = queue.poll();  // 从队列头部移除并获取当前节点
                list.add(node.val);  // 将节点值加入当前层列表
                for (Node child : node.children) {  // 遍历当前节点的所有子节点
                    if (child != null) {  // 检查子节点非空
                        queue.offer(child);  // 将子节点加入队列，准备下一层
                    }
                }
            }
            ans.add(list);  // 当前层处理完毕，加入结果列表
        }
        return ans;  // 返回完整的层序遍历结果
    }
}</code></pre>
    <h2>
     637.二叉树的层平均值
    </h2>
    <blockquote>
     <p>
      给定一个非空二叉树的根节点
      <code>
       root
      </code>
      , 以数组的形式返回每一层节点的平均值。与实际答案相差
      <code>
       10-5
      </code>
      以内的答案可以被接受。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="302" src="https://i-blog.csdnimg.cn/img_convert/c3b5e9e77f3fa8d38a564011212d8bdf.jpeg" width="277"/>
     </p>
     <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[3.00000,14.50000,11.00000]
<strong>解释：</strong>第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
</pre>
     <p>
      <strong>
       示例 2:
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="302" src="https://i-blog.csdnimg.cn/img_convert/6e394e9ec6bf88ac2687a28f5e2699bd.jpeg" width="292"/>
     </p>
     <pre><strong>输入：</strong>root = [3,9,20,15,7]
<strong>输出：</strong>[3.00000,14.50000,11.00000]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <p>
     </p>
     <ul>
      <li>
       树中节点数量在
       <code>
        [1, 104]
       </code>
       范围内
      </li>
      <li>
       <code>
        -231 &lt;= Node.val &lt;= 231 - 1
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
     </p>
     <ul>
      <li>
       <strong>
        层序遍历部分
       </strong>
       ：使用递归方法 fun1，以深度参数（deep）追踪当前节点所在的层号。全局列表 ans 存储每一层的节点值，ans.get(deep) 表示第 deep 层的节点值集合。递归时，先访问当前节点并记录值，再处理左子树和右子树，通过深度确保节点值按层组织。
      </li>
      <li>
       <strong>
        平均值计算部分
       </strong>
       ：在 averageOfLevels 中，遍历 ans 的每一层，使用 long 变量 sum 累加该层节点值，然后除以节点数（list1.size()）得到平均值，结果以 double 类型存储在 ave 中。
      </li>
      <li>
       <strong>
        执行流程
       </strong>
       ：从根节点开始（deep = 0），递归填充 ans，完成后遍历 ans 计算每层平均值，最终返回 ave。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();  // 定义全局列表，存储每层的节点值
    public List&lt;Double&gt; averageOfLevels(TreeNode root) {
        List&lt;Double&gt; ave = new ArrayList&lt;&gt;();  // 定义结果列表，存储每层的平均值
        levelOrder(root);  // 调用层序遍历方法，填充 ans
        for (List&lt;Integer&gt; list1 : ans) {  // 遍历每一层的节点值列表
            long sum = 0;  // 初始化当前层的总和
            for (int i = 0; i &lt; list1.size(); i++) {  // 遍历当前层的所有节点值
                sum += (Integer) list1.get(i);  // 累加节点值到 sum
            }
            ave.add((double) sum / list1.size());  // 计算当前层平均值并加入结果
        }
        return ave;  // 返回每层平均值的列表
    }
    
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        Integer deep = 0;  // 初始化深度为 0，表示根节点层
        fun1(root, deep);  // 调用递归方法，开始层序遍历
        return ans;  // 返回层序遍历结果
    }
    
    public void fun1(TreeNode root, Integer deep) {
        if (root == null) {  // 如果当前节点为空，返回
            return;
        }
        if (ans.size() &lt; deep + 1) {  // 如果当前深度超出 ans 大小
            ans.add(new ArrayList&lt;&gt;());  // 为新层添加一个空列表
        }
        ans.get(deep).add(root.val);  // 将当前节点值加入对应层的列表
        fun1(root.left, deep + 1);  // 递归处理左子树，深度加 1
        fun1(root.right, deep + 1);  // 递归处理右子树，深度加 1
    }
}</code></pre>
    <h2>
     104.二叉树的最大深度
    </h2>
    <blockquote>
     <p>
      给定一个二叉树
      <code>
       root
      </code>
      ，返回其最大深度。
     </p>
     <p>
      二叉树的
      <strong>
       最大深度
      </strong>
      是指从根节点到最远叶子节点的最长路径上的节点数。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="292" src="https://i-blog.csdnimg.cn/img_convert/dfddcd646b1beb2f9f35defac071b574.jpeg" width="422"/>
     </p>
     <p>
     </p>
     <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>3
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = [1,null,2]
<strong>输出：</strong>2
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中节点的数量在
       <code>
        [0, 104]
       </code>
       区间内。
      </li>
      <li>
       <code>
        -100 &lt;= Node.val &lt;= 100
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
      利用队列的“先进先出”（FIFO）特性，按层遍历二叉树。每处理完一层，深度计数器 length 增加 1，最终 length 表示从根节点到最远叶子节点的层数，即最大深度。
     </p>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();  // 定义双端队列，用于存储待处理的节点
    int length = 0;  // 定义变量，记录二叉树的最大深度
    
    public int maxDepth(TreeNode root) {
        if (root == null) {  // 如果根节点为空，返回深度 0
            return 0;
        }
        deque.offer(root);  // 将根节点加入队列，作为第一层
        while (!deque.isEmpty()) {  // 当队列不为空时，继续处理每一层
            int len = deque.size();  // 获取当前层的节点数量
            length++;  // 每处理一层，深度加 1
            while (len &gt; 0) {  // 遍历当前层的所有节点
                TreeNode node = new TreeNode();  // 创建一个新节点（占位）
                node = deque.poll();  // 从队列头部移除并获取当前节点
                len--;  // 当前层节点计数减 1
                if (node.left != null) deque.offer(node.left);   // 如果有左子节点，加入队列
                if (node.right != null) deque.offer(node.right); // 如果有右子节点，加入队列
            }
        }
        return length;  // 返回二叉树的最大深度
    }
}</code></pre>
    <h2>
     111.二叉树的最小深度
    </h2>
    <blockquote>
     <p>
      给定一个二叉树，找出其最小深度。
     </p>
     <p>
      最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
     </p>
     <p>
      <strong>
       说明：
      </strong>
      叶子节点是指没有子节点的节点。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p class="img-center">
      <img alt="" height="302" src="https://i-blog.csdnimg.cn/img_convert/8cb9cee60340e41ec011a25caebd2fbe.jpeg" width="432"/>
     </p>
     <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>2
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = [2,null,3,null,4,null,5,null,6]
<strong>输出：</strong>5
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中节点数的范围在
       <code>
        [0, 105]
       </code>
       内
      </li>
      <li>
       <code>
        -1000 &lt;= Node.val &lt;= 1000
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
      利用队列的“先进先出”（FIFO）特性，按层遍历二叉树，从根节点开始逐层检查。当遇到第一个叶子节点（没有子节点的节点）时，返回当前深度 length，即为最小深度。
     </p>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();  // 定义双端队列，用于存储待处理的节点
    int length = 0;  // 定义变量，记录当前处理的深度
    
    public int minDepth(TreeNode root) {
        if (root == null) {  // 如果根节点为空，返回深度 0
            return 0;
        }
        deque.offer(root);  // 将根节点加入队列，作为第一层
        while (!deque.isEmpty()) {  // 当队列不为空时，继续处理每一层
            int len = deque.size();  // 获取当前层的节点数量
            length++;  // 每处理一层，深度加 1
            while (len &gt; 0) {  // 遍历当前层的所有节点
                TreeNode node = new TreeNode();  // 创建一个新节点（占位）
                node = deque.poll();  // 从队列头部移除并获取当前节点
                len--;  // 当前层节点计数减 1
                if (node.left == null &amp;&amp; node.right == null) {  // 如果当前节点是叶子节点
                    return length;  // 返回当前深度作为最小深度
                }
                if (node.left != null) deque.offer(node.left);   // 如果有左子节点，加入队列
                if (node.right != null) deque.offer(node.right); // 如果有右子节点，加入队列
            }
        }
        return length;  // 返回最终深度
    }
}</code></pre>
    <h2>
     116.填充每一个节点的下一个右侧节点指针
    </h2>
    <blockquote>
     <p>
      给定一个
      <strong>
       完美二叉树
      </strong>
      ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
     </p>
     <pre>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}</pre>
     <p>
      填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为
      <code>
       NULL
      </code>
      。
     </p>
     <p>
      初始状态下，所有 next 指针都被设置为
      <code>
       NULL
      </code>
      。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="361" src="https://i-blog.csdnimg.cn/img_convert/97e25e280f627827796445d544f99bd0.png" width="1058"/>
     </p>
     <pre><strong>输入：</strong>root = [1,2,3,4,5,6,7]
<strong>输出：</strong>[1,#,2,3,#,4,5,6,7,#]
<strong>解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
</pre>
     <p>
     </p>
     <p>
      <strong>
       示例 2:
      </strong>
     </p>
     <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中节点的数量在
       <code>
        [0, 212 - 1]
       </code>
       范围内
      </li>
      <li>
       <code>
        -1000 &lt;= node.val &lt;= 1000
       </code>
      </li>
     </ul>
     <p>
     </p>
     <p>
      <strong>
       进阶：
      </strong>
     </p>
     <ul>
      <li>
       你只能使用常量级额外空间。
      </li>
      <li>
       使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
      利用队列的“先进先出”（FIFO）特性，按层遍历二叉树。在每一层中，将当前节点的 next 指针设置为队列中的下一个节点（即右侧节点），从而连接同一层的节点。
     </p>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    Deque&lt;Node&gt; deque = new ArrayDeque();  // 定义双端队列，用于存储待处理的节点
    
    public Node connect(Node root) {
        if (root == null) {  // 如果根节点为空，返回 null
            return root;
        }
        deque.offer(root);  // 将根节点加入队列，作为第一层
        while (!deque.isEmpty()) {  // 当队列不为空时，继续处理每一层
            int len = deque.size();  // 获取当前层的节点数量
            while (len &gt; 0) {  // 遍历当前层的所有节点
                Node node = new Node();  // 创建一个新节点（占位）
                node = deque.poll();  // 从队列头部移除并获取当前节点
                len--;  // 当前层节点计数减 1
                if (node.left != null) deque.offer(node.left);   // 如果有左子节点，加入队列
                if (node.right != null) deque.offer(node.right); // 如果有右子节点，加入队列
                if (len != 0) node.next = deque.peek();  // 如果不是当前层最后一个节点，设置 next 指向队列头部节点
            }
        }
        return root;  // 返回填充了 next 指针的根节点
    }
}</code></pre>
    <h2>
     117.填充每一个节点的下一个右侧节点指针2
    </h2>
    <blockquote>
     <p>
      给定一个二叉树：
     </p>
     <pre>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}</pre>
     <p>
      填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为
      <code>
       NULL
      </code>
      。
     </p>
     <p>
      初始状态下，所有 next 指针都被设置为
      <code>
       NULL
      </code>
      。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p class="img-center">
      <img alt="" height="361" src="https://i-blog.csdnimg.cn/img_convert/498b456d12a69e5102ecf8efece74311.png" width="1058"/>
     </p>
     <pre><strong>输入</strong>：root = [1,2,3,4,5,null,7]
<strong>输出：</strong>[1,#,2,3,#,4,5,7,#]
<strong>解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       树中的节点数在范围
       <code>
        [0, 6000]
       </code>
       内
      </li>
      <li>
       <code>
        -100 &lt;= Node.val &lt;= 100
       </code>
      </li>
     </ul>
     <p>
      <strong>
       进阶：
      </strong>
     </p>
     <ul>
      <li>
       你只能使用常量级额外空间。
      </li>
      <li>
       使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
      利用队列的“先进先出”（FIFO）特性，按层遍历二叉树。在每一层中，将当前节点的 next 指针设置为队列中的下一个节点（即右侧节点），从而连接同一层的节点。
     </p>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    Deque&lt;Node&gt; deque = new ArrayDeque();  // 定义双端队列，用于存储待处理的节点
    
    public Node connect(Node root) {
        if (root == null) {  // 如果根节点为空，返回 null
            return root;
        }
        deque.offer(root);  // 将根节点加入队列，作为第一层
        while (!deque.isEmpty()) {  // 当队列不为空时，继续处理每一层
            int len = deque.size();  // 获取当前层的节点数量
            while (len &gt; 0) {  // 遍历当前层的所有节点
                Node node = new Node();  // 创建一个新节点（占位）
                node = deque.poll();  // 从队列头部移除并获取当前节点
                len--;  // 当前层节点计数减 1
                if (node.left != null) deque.offer(node.left);   // 如果有左子节点，加入队列
                if (node.right != null) deque.offer(node.right); // 如果有右子节点，加入队列
                if (len != 0) node.next = deque.peek();  // 如果不是当前层最后一个节点，设置 next 指向队列头部节点
            }
        }
        return root;  // 返回填充了 next 指针的根节点
    }
}</code></pre>
    <h2>
     515.在每个树行中找最大值
    </h2>
    <blockquote>
     <p>
      给定一棵二叉树的根节点
      <code>
       root
      </code>
      ，请找出该二叉树中每一层的最大值。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例1：
      </strong>
     </p>
     <p>
     </p>
     <p class="img-center">
      <img alt="" height="322" src="https://i-blog.csdnimg.cn/img_convert/350beb9df4055daa2ff57dd63ffb18cc.jpeg" width="562"/>
     </p>
     <pre><strong>输入: </strong>root = [1,3,2,5,3,null,9]
<strong>输出: </strong>[1,3,9]
</pre>
     <p>
      <strong>
       示例2：
      </strong>
     </p>
     <pre><strong>输入: </strong>root = [1,2,3]
<strong>输出: </strong>[1,3]
</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       二叉树的节点个数的范围是
       <code>
        [0,104]
       </code>
      </li>
      <li>
       <code>
        -231 &lt;= Node.val &lt;= 231 - 1
       </code>
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      解题思路
     </strong>
    </p>
    <blockquote>
     <p>
      利用队列的“先进先出”（FIFO）特性，按层遍历二叉树。在每一层中，遍历所有节点，比较它们的值，记录最大值，并在层结束时加入结果列表。
     </p>
    </blockquote>
    <p>
     <strong>
      代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();  // 定义全局列表，存储每层的最大值
    Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();  // 定义双端队列，用于存储待处理的节点
    
    public List&lt;Integer&gt; largestValues(TreeNode root) {
        if (root == null) {  // 如果根节点为空，返回空列表
            return ans;
        }
        queue.offer(root);  // 将根节点加入队列，作为第一层
        while (!queue.isEmpty()) {  // 当队列不为空时，继续处理每一层
            int len = queue.size();  // 获取当前层的节点数量
            TreeNode node = new TreeNode();  // 创建一个新节点（占位）
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();  // 创建列表（未使用）
            Integer max = Integer.MIN_VALUE;  // 初始化当前层最大值为最小整数
            while (len &gt; 0) {  // 遍历当前层的所有节点
                node = queue.poll();  // 从队列头部移除并获取当前节点
                if (node.val &gt; max) {  // 如果当前节点值大于 max
                    max = node.val;  // 更新最大值
                }
                len--;  // 当前层节点计数减 1
                if (node.left != null) queue.offer(node.left);   // 如果有左子节点，加入队列
                if (node.right != null) queue.offer(node.right); // 如果有右子节点，加入队列
            }
            ans.add(max);  // 将当前层的最大值加入结果列表
        }
        return ans;  // 返回每层最大值的列表
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35383632383036382f:61727469636c652f64657461696c732f313436313333393239" class_="artid" style="display:none">
 </p>
</div>


