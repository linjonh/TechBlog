---
layout: post
title: "React篇之three渲染"
date: 2025-03-13 16:38:13 +0800
description: "（即由 document.defaultView 返回）上触发。只有在 window 对象上注册的处理器才能接收 resize 事件。：页面宽度变化第一时间都是window.onresize的事件，然而，问题2：拖拽的时候，渲染模型会白屏闪烁，==>解决：加个防抖。需求：拖拽右侧面板，里面的three模型能够自适应。// 100ms 防抖。resize 事件只在 window 对象。"
keywords: "React篇之three渲染"
categories: ['未分类']
tags: ['前端框架', '前端', 'React']
artid: "146235051"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146235051
    alt: "React篇之three渲染"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146235051
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146235051
cover: https://bing.ee123.net/img/rand?artid=146235051
image: https://bing.ee123.net/img/rand?artid=146235051
img: https://bing.ee123.net/img/rand?artid=146235051
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     React篇之three渲染
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     需求：拖拽右侧面板，里面的three模型能够自适应
    </p>
    <pre><code class="language-javascript">import { useEffect, useState, useRef } from 'react'
import './App.css'
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { debounce } from 'lodash';
const CanvasDemo = () =&gt; {
    let camera, scene, renderer, model, face;

    const [leftWidth, setLeftWidth] = useState(300);
    const leftWidthRef = useRef(leftWidth);
    const containerRef = useRef(null);
    const rightRef = useRef(null);
    const isDragging = useRef(false);

    // 更新 leftWidth 时同步更新 leftWidthRef
    useEffect(() =&gt; {
        leftWidthRef.current = leftWidth;
    }, [leftWidth]);

    const handleMouseDown = () =&gt; {
        isDragging.current = true;
    };

    const handleMouseMove = (e) =&gt; {
        if (!isDragging.current) return;
        const containerRect = containerRef?.current?.getBoundingClientRect();
        const newLeftWidth = e.clientX - containerRect.left;
        setLeftWidth(newLeftWidth);
    };

    const handleMouseUp = () =&gt; {
        isDragging.current = false;
    };

    const init = () =&gt; {
        camera = new THREE.PerspectiveCamera(45, (window.innerWidth - leftWidthRef.current) / window.innerHeight, 0.25, 100);
        camera.position.set(- 5, 3, 10);
        camera.lookAt(0, 2, 0);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        scene.fog = new THREE.Fog(0xe0e0e0, 20, 100);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8d8d8d, 3);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.position.set(0, 20, 10);
        scene.add(dirLight);


        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0xcbcbcb, depthWrite: false }));
        mesh.rotation.x = - Math.PI / 2;
        scene.add(mesh);

        const grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        grid.position.set(0, 0, 0); // 将网格放置在场景中心
        scene.add(grid);

        const loader = new GLTFLoader();
        loader.load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', function (gltf) {

            model = gltf.scene;
            scene.add(model);

            // 打印模型信息，调试用
            console.log('Model loaded:', model);

        }, undefined, function (e) {
            console.error(e);
        });

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth - leftWidthRef.current, window.innerHeight);
        rightRef.current?.appendChild(renderer.domElement);
    }
    const debouncedResize = debounce(() =&gt; {
        onWindowResize();
    }, 10); // 100ms 防抖
    const onWindowResize = () =&gt; {
        if (!camera || !renderer) return;
        camera.aspect = (window.innerWidth - leftWidthRef.current) / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - leftWidthRef.current, window.innerHeight);
        // 确保动画持续运行
        requestAnimationFrame(animate);
    }
    useEffect(() =&gt; {
        init();
        animate(); // 启动渲染循环

        if (rightRef.current) {
            const resizeObserver = new ResizeObserver(() =&gt; {
                if (rightRef.current) {
                    debouncedResize();
                }
            });
            resizeObserver.observe(rightRef.current);
            return () =&gt; resizeObserver.disconnect();

        }
    }, [])
    const animate = () =&gt; {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    };

    return (
        &lt;div
            ref={containerRef}
            className="container"
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
        &gt;
            &lt;div className="left-pane" style={<!-- -->{ width: leftWidth }}&gt;
                左侧内容
            &lt;/div&gt;
            &lt;div className="divider" onMouseDown={handleMouseDown}&gt;&lt;/div&gt;
            &lt;div ref={rightRef} className="right-pane"&gt;&lt;/div&gt;
        &lt;/div&gt;
    );
}

export default CanvasDemo</code></pre>
    <pre><code class="language-css">.container {
  display: flex;
  height: 100vh;
  user-select: none;
}
.left-pane {
  background-color: #f0f0f0;
  overflow: auto;
}
.divider {
  width: 5px;
  cursor: ew-resize;
  background-color: #ccc;
}
.right-pane {
  flex-grow: 1;
  background-color: #e0e0e0;
  overflow: auto;
}</code></pre>
    <p>
     <span style="background-color:#fe2c24">
      问题1
     </span>
     ：页面宽度变化第一时间都是window.onresize的事件，然而，
     <span style="color:#fe2c24">
      resize 事件只在 window 对象
     </span>
     （即由 document.defaultView 返回）上触发。只有在 window 对象上注册的处理器才能接收 resize 事件。
    </p>
    <p>
    </p>
    <p>
     所以替换方法为：
    </p>
    <blockquote>
     <p>
      const resizeObserver = new ResizeObserver(() =&gt; {});
     </p>
     <p>
      resizeObserver.observe(dom);
     </p>
     <p>
      return () =&gt; resizeObserver.disconnect();
     </p>
    </blockquote>
    <p>
     问题2：拖拽的时候，渲染模型会白屏闪烁，==&gt;解决：加个防抖
    </p>
    <blockquote>
     <p>
     </p>
     <p>
      const debouncedResize = debounce(() =&gt; {
      <!-- -->
     </p>
     <p>
      onWindowResize();
     </p>
     <p>
      }, 100); // 100ms 防抖
     </p>
    </blockquote>
    <p>
     以上就是解决思路
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f61655f7070707070702f:61727469636c652f64657461696c732f313436323335303531" class_="artid" style="display:none">
 </p>
</div>


