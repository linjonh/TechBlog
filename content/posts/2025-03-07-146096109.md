---
layout: post
title: "Redis-内存淘汰策略深度解析"
date: 2025-03-07 16:05:34 +0800
description: "Redis 的内存淘汰策略决定了在内存不足时，如何选择需要删除的键来释放空间。​基于过期时间的淘汰​（volatile-*）：仅针对设置了过期时间的键。全局淘汰​（allkeys-*）：针对所有键，无论是否设置过期时间。Redis 支持以下 8 种内存淘汰策略​noeviction：默认策略，禁止写入新数据，直接返回错误。​：淘汰最近最少使用（LRU）的设置了过期时间的键。​：淘汰最不经常使用（LFU）的设置了过期时间的键。​：随机淘汰设置了过期时间的键。​。"
keywords: "redis内存淘汰策略"
categories: ['Redis']
tags: ['缓存', '数据库', 'Redis']
artid: "146096109"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146096109
    alt: "Redis-内存淘汰策略深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146096109
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146096109
cover: https://bing.ee123.net/img/rand?artid=146096109
image: https://bing.ee123.net/img/rand?artid=146096109
img: https://bing.ee123.net/img/rand?artid=146096109
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis 内存淘汰策略深度解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     Redis 作为高性能的内存数据库，其内存资源的高效管理直接关系到系统的稳定性和性能。当 Redis 的内存使用达到配置的最大值（maxmemory）时，新的写入操作将触发内存淘汰机制（Eviction Policy），以释放空间存储新数据。本文将深入探讨 Redis 的内存淘汰策略、实现原理、适用场景及最佳实践。
    </p>
    <h2>
     <a id="__1">
     </a>
     一、 内存淘汰策略概述
    </h2>
    <p>
     Redis 的内存淘汰策略决定了在内存不足时，如何选择需要删除的键来释放空间。这些策略可以分为两大类：
    </p>
    <ul>
     <li>
      ​基于过期时间的淘汰​（volatile-*）：仅针对设置了过期时间的键。
     </li>
     <li>
      全局淘汰​（allkeys-*）：针对所有键，无论是否设置过期时间。
     </li>
    </ul>
    <p>
     <strong>
      Redis 支持以下 8 种内存淘汰策略
     </strong>
     ：
    </p>
    <p>
     ​
     <strong>
      noeviction
     </strong>
     ：默认策略，禁止写入新数据，直接返回错误。
     <br/>
     ​
     <strong>
      volatile-lru
     </strong>
     ：淘汰最近最少使用（LRU）的设置了过期时间的键。
     <br/>
     ​
     <strong>
      volatile-lfu
     </strong>
     ：淘汰最不经常使用（LFU）的设置了过期时间的键。
     <br/>
     ​
     <strong>
      volatile-random
     </strong>
     ：随机淘汰设置了过期时间的键。
     <br/>
     ​
     <strong>
      volatile-ttl
     </strong>
     ：优先淘汰剩余生存时间（TTL）最短的键。
     <br/>
     ​
     <strong>
      allkeys-lru
     </strong>
     ：淘汰所有键中最近最少使用的键。
     <br/>
     ​
     <strong>
      allkeys-lfu
     </strong>
     ：淘汰所有键中最不经常使用的键。
     <br/>
     ​
     <strong>
      allkeys-random
     </strong>
     ：随机淘汰任意键。
    </p>
    <h2>
     <a id="_17">
     </a>
     二、内存淘汰策略详解
    </h2>
    <h3>
     <a id="21_noeviction_18">
     </a>
     2.1 ​
     <strong>
      noeviction（不淘汰）​
     </strong>
    </h3>
    <p>
     <strong>
      ​行为
     </strong>
     ：当内存不足时，拒绝所有写入命令（如 SET、LPUSH），但允许读取操作。
     <br/>
     <strong>
      ​适用场景
     </strong>
     ：适用于数据不可丢失的场景（如持久化存储），需确保内存足够或配合持久化机制。
     <br/>
     ​
     <strong>
      缺点
     </strong>
     ：若内存不足且无持久化，可能导致服务不可用。
    </p>
    <h3>
     <a id="22_LRULeast_Recently_Used_22">
     </a>
     2.2 ​LRU（Least Recently Used）​
    </h3>
    <p>
     <strong>
      ​原理
     </strong>
     ：淘汰最近最久未被访问的键。
     <br/>
     <strong>
      ​Redis 实现
     </strong>
     ：Redis 使用近似 LRU 算法，通过随机采样（默认取 5 个键）选择最久未使用的键，而非遍历所有键，以减少计算开销。
     <br/>
     <strong>
      ​适用场景
     </strong>
     ：适用于缓存场景，优先保留热点数据。
     <br/>
     <strong>
      ​命令示例
     </strong>
     ：
    </p>
    <pre><code class="prism language-bash">CONFIG SET maxmemory-policy volatile-lru  <span class="token comment"># 针对带过期时间的键</span>
CONFIG SET maxmemory-policy allkeys-lru   <span class="token comment"># 针对所有键</span>
</code></pre>
    <h3>
     <a id="23_LFULeast_Frequently_Used_33">
     </a>
     2.3 ​LFU（Least Frequently Used）​
    </h3>
    <p>
     <strong>
      ​原理
     </strong>
     ：淘汰访问频率最低的键（Redis 4.0 引入）。
     <br/>
     <strong>
      ​Redis 实现
     </strong>
     ：通过计数器统计键的访问频率，并随时间衰减历史计数，避免长期累积导致无法淘汰旧键。
     <br/>
     <strong>
      ​适用场景
     </strong>
     ：适合长期缓存，如高频访问的静态数据。
     <br/>
     <strong>
      ​命令示例
     </strong>
     ：
    </p>
    <pre><code class="prism language-bash">CONFIG SET maxmemory-policy volatile-lfu  <span class="token comment"># 针对带过期时间的键</span>
CONFIG SET maxmemory-policy allkeys-lfu   <span class="token comment"># 针对所有键</span>
</code></pre>
    <h3>
     <a id="24_TTLTime_To_Live_44">
     </a>
     2.4 ​TTL（Time To Live）​
    </h3>
    <p>
     <strong>
      ​原理
     </strong>
     ：优先淘汰剩余生存时间（TTL）最短的键。
     <br/>
     <strong>
      ​适用场景
     </strong>
     ：适用于明确知道键生命周期的场景（如临时会话数据）。
     <br/>
     ​
     <strong>
      限制
     </strong>
     ：仅对设置了过期时间的键生效。
     <br/>
     <strong>
      ​命令示例
     </strong>
     ：
    </p>
    <pre><code class="prism language-bash">CONFIG SET maxmemory-policy volatile-ttl
</code></pre>
    <h3>
     <a id="25_Random_54">
     </a>
     2.5 ​Random（随机淘汰）​
    </h3>
    <p>
     <strong>
      ​原理
     </strong>
     ：随机选择键进行淘汰。
     <br/>
     <strong>
      ​适用场景
     </strong>
     ：内存压力大且数据重要性均等时，快速释放内存。
     <br/>
     <strong>
      ​命令示例
     </strong>
     ：
    </p>
    <pre><code class="prism language-bash">CONFIG SET maxmemory-policy volatile-random  <span class="token comment"># 针对带过期时间的键</span>
CONFIG SET maxmemory-policy allkeys-random   <span class="token comment"># 针对所有键</span>
</code></pre>
    <h2>
     <a id="__64">
     </a>
     三、 内存淘汰的底层实现
    </h2>
    <h3>
     <a id="31_LRULFU__65">
     </a>
     3.1 ​LRU/LFU 的近似算法
    </h3>
    <ul>
     <li>
      <strong>
       Redis 通过
      </strong>
      ​
      <strong>
       evictionPoolEntry
      </strong>
      ​结构维护候选淘汰键池。每次淘汰时，随机采样一组键，更新其访问时间或频率信息，选择最不活跃的键删除。
     </li>
     <li>
      <strong>
       ​LRU 时钟
      </strong>
      ：Redis 使用全局 24 位时钟（精度为秒）记录键的最近访问时间。内存中每个对象存储与全局时钟的差值（lru字段），而非精确时间戳。
     </li>
     <li>
      ​
      <strong>
       LFU 计数器
      </strong>
      ：每个键的 lru 字段被拆分为两部分：
      <ul>
       <li>
        高 16 位：最近访问时间的分钟级精度。
       </li>
       <li>
        低 8 位：访问频率计数器（0~255），通过概率递增，随时间衰减。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="32__73">
     </a>
     3.2 ​淘汰流程
    </h3>
    <ol>
     <li>
      客户端执行写入命令触发内存检查。
     </li>
     <li>
      Redis 检查 maxmemory 是否已超出。
     </li>
     <li>
      根据配置的策略选择待淘汰键。
     </li>
     <li>
      删除键并触发相关事件（如 evicted 通知）。
     </li>
    </ol>
    <h2>
     <a id="__79">
     </a>
     四、 如何选择合适的内存淘汰策略？
    </h2>
    <h3>
     <a id="41__80">
     </a>
     4.1 ​缓存场景
    </h3>
    <p>
     ​推荐策略：allkeys-lru 或 allkeys-lfu
     <br/>
     ​理由：优先保留热点数据，最大化缓存命中率。
    </p>
    <h3>
     <a id="42__83">
     </a>
     4.2 ​持久化存储
    </h3>
    <p>
     ​推荐策略：noeviction（需确保内存足够或启用持久化）。
     <br/>
     ​替代方案：若允许部分数据丢失，可使用 volatile-lru 结合过期时间。
    </p>
    <h3>
     <a id="43__86">
     </a>
     4.3 ​临时数据场景
    </h3>
    <p>
     ​推荐策略：volatile-ttl
     <br/>
     ​理由：自动清理生命周期明确的数据（如验证码、会话信息）。
    </p>
    <h3>
     <a id="44__89">
     </a>
     4.4 ​混合型数据
    </h3>
    <p>
     ​推荐策略：allkeys-lru + 部分键设置过期时间。
     <br/>
     ​示例：电商系统中，商品详情用 allkeys-lru 缓存，购物车数据设置 TTL。
    </p>
    <h2>
     <a id="_92">
     </a>
     五、最佳实践与注意事项
    </h2>
    <h3>
     <a id="51__93">
     </a>
     5.1 ​配置建议
    </h3>
    <p>
     ​设置合理的 maxmemory：通常为物理内存的 80%~90%，避免 OOM。
     <br/>
     ​监控内存使用：
    </p>
    <pre><code class="prism language-bash">INFO memory  <span class="token comment"># 查看内存指标（used_memory、maxmemory）</span>
INFO stats    <span class="token comment"># 查看 evicted_keys（淘汰键数量）</span>
</code></pre>
    <h3>
     <a id="52__102">
     </a>
     5.2 ​避免大规模淘汰
    </h3>
    <p>
     ​分片设计：通过集群分散数据，减少单个节点的内存压力。
     <br/>
     ​预热缓存：重启后预加载高频数据，避免冷启动时集中淘汰。
    </p>
    <h3>
     <a id="53__105">
     </a>
     5.3 ​常见误区
    </h3>
    <p>
     ​
     <strong>
      volatile-ttl 不依赖惰性删除
     </strong>
     ：该策略仅在内存不足时触发，仍需依赖定期/惰性删除清理过期键。
     <br/>
     ​LFU 计数器并非精确值：访问频率通过概率递增，适用于相对比较而非绝对计数。
    </p>
    <h2>
     <a id="_108">
     </a>
     六、总结
    </h2>
    <p>
     Redis 的内存淘汰策略是平衡内存使用与性能的关键机制。理解不同策略的原理和适用场景，结合业务需求合理配置，可显著提升系统的稳定性和效率。在高并发场景下，建议通过监控工具（如 RedisInsight、Prometheus）实时跟踪内存和淘汰指标，动态调整策略和资源配置。
    </p>
    <p>
     通过本文的深度解析，希望您能掌握 Redis 内存淘汰的核心机制，并在实践中灵活运用，构建高效可靠的 Redis 服务。
    </p>
    <p>
     <strong>
      参考资料
     </strong>
    </p>
    <p>
     Redis 官方文档：https://redis.io/docs/reference/eviction/
     <br/>
     《Redis 设计与实现》——黄健宏
     <br/>
     Redis 源码解析（evict.c、object.c）
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313138363833312f:61727469636c652f64657461696c732f313436303936313039" class_="artid" style="display:none">
 </p>
</div>


