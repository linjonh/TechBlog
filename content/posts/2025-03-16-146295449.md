---
layout: post
title: "笔记代码随想录算法训练营day46LeetCode647.-回文子串516.最长回文子序列-"
date: 2025-03-16 15:36:25 +0800
description: "/ 初始化：dp[i][j]在i=j的时候都得是1，首先看递推公式，i=0的话访问j如果从0开始遍历，那访问-1肯定是访问不到，j从j+1开始遍历，这样的话，dp[i][i] 的情况是遍历不到的.或者就单看dp[i][j] = dp[i + 1][j - 1] + 2，也没有遍历dp[i][i]的准备。// 递推公式：如过s[i]==s[j],那么i,j包括两个数或1个数的情况是回文子串，如果包含超过两个数，那么dp[i+1][j-1]是true的话，也返回true，当然不相等就直接false了。"
keywords: "笔记:代码随想录算法训练营day46:LeetCode647. 回文子串\\516.最长回文子序列 "
categories: ['未分类']
tags: ['笔记']
artid: "146295449"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146295449
    alt: "笔记代码随想录算法训练营day46LeetCode647.-回文子串516.最长回文子序列-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146295449
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146295449
cover: https://bing.ee123.net/img/rand?artid=146295449
image: https://bing.ee123.net/img/rand?artid=146295449
img: https://bing.ee123.net/img/rand?artid=146295449
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     笔记:代码随想录算法训练营day46:LeetCode647. 回文子串\516.最长回文子序列
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     学习资料:
     <a href="https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE" rel="nofollow" title="代码随想录">
      代码随想录
     </a>
    </p>
    <h2 id="_647-回文子串">
     647. 回文子串
    </h2>
    <p>
     <a href="https://leetcode.cn/problems/palindromic-substrings/" rel="nofollow" title="力扣题目链接">
      力扣题目链接
     </a>
    </p>
    <p>
     其实个人感觉这里的动规也是一个双指针的方法
    </p>
    <p>
     // 定义：dp[i][j]表示区间范围为[i,j]左闭右闭的子串是否为回文子串，布尔类型
     <br/>
     // 递推公式：如过s[i]==s[j],那么i,j包括两个数或1个数的情况是回文子串，如果包含超过两个数，那么dp[i+1][j-1]是true的话，也返回true，当然不相等就直接false了
     <br/>
     // 初始化：可以先都初始化为false
     <br/>
     // 遍历顺序：看递推公式
     <br/>
     // 打印
    </p>
    <pre><code class="language-cpp">// 定义：dp[i][j]表示区间范围为[i,j]左闭右闭的子串是否为回文子串，布尔类型
// 递推公式：如过s[i]==s[j],那么i,j包括两个数或1个数的情况是回文子串，如果包含超过两个数，那么dp[i+1][j-1]是true的话，也返回true，当然不相等就直接false了
// 初始化：可以先都初始化为false
// 遍历顺序：看递推公式
// 打印
class Solution {
public:
    int countSubstrings(string s) {
       vector&lt;vector&lt;bool&gt;&gt; dp(s.size(),vector&lt;bool&gt;(s.size(),false));
       int result = 0;              //记录一下，要不最后不知道返回啥 
       for(int i=s.size();i&gt;=0;i--){
            for(int j=i;j&lt;s.size();j++){
                if(s[i]==s[j]){
                    if(j-i&lt;=1){
                        dp[i][j]= true;
                        result++;
                    }
                    else if(dp[i+1][j-1]){
                        dp[i][j]=true;
                        result++;
                    }
                }
            }
        }
        return result;
    }
};</code></pre>
    <p>
     双指针:从中心往两边扩散,以一个数为中心时处理的是奇数的回文子串,以两个数为中心时处理的是偶数的回文子串
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        for(int i=0;i&lt;s.size();i++){
            result+=extend(s,i,i,s.size());     //处理奇数回文子串，如aba
            result+=extend(s,i,i+1,s.size());   //处理偶数回文子串，如abba
        }
        return result;
    }
    int extend(const string&amp; s,int i,int j,int n){
        int res;
        while(i&gt;=0&amp;&amp;j&lt;n&amp;&amp;s[i]==s[j]){
            i--;
            j++;
            res++;
        }
        return res;
    }
};</code></pre>
    <p>
    </p>
    <h2 id="_516-最长回文子序列">
     516.最长回文子序列
    </h2>
    <p>
     <a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" rel="nofollow" title="力扣题目链接">
      力扣题目链接
     </a>
    </p>
    <p>
     思路:
    </p>
    <p>
     // 定义：dp[i][j]表示区间[i][j]左闭右闭内的最长回文子序列
    </p>
    <p>
     // 递推公式：如果s[i]==s[j],那么当前的长度是上一状态dp[i+1][j-1]再加上两个长度，有一种向两侧扩散比较的感觉，否则，就比较去掉s[i]或s[j]的状态，继承dp[i+1][j]或dp[i][j-1].
    </p>
    <p>
     // 初始化：dp[i][j]在i=j的时候都得是1，首先看递推公式，i=0的话访问j如果从0开始遍历，那访问-1肯定是访问不到，j从j+1开始遍历，这样的话，dp[i][i] 的情况是遍历不到的.或者就单看dp[i][j] = dp[i + 1][j - 1] + 2，也没有遍历dp[i][i]的准备
    </p>
    <p>
     // 遍历顺序,j要从i+1开始遍历了
    </p>
    <p>
     // 打印
    </p>
    <pre><code class="language-cpp">// 定义：dp[i][j]表示区间[i][j]左闭右闭内的最长回文子序列
// 递推公式：如果s[i]==s[j],那么当前的长度是上一状态dp[i+1][j-1]再加上两个长度，有一种向两侧扩散比较的感觉，否则，就比较去掉s[i]或s[j]的状态，继承dp[i+1][j]或dp[i][j-1].
// 初始化：dp[i][j]在i=j的时候都得是1，首先看递推公式，i=0的话访问j如果从0开始遍历，那访问-1肯定是访问不到，j要从j+1开始遍历，这样的话，dp[i][i] 的情况是遍历不到的.或者就单看dp[i][j] = dp[i + 1][j - 1] + 2，也没有遍历dp[i][i]的准备
// 遍历顺序,j要从i+1开始遍历了
// 打印
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector&lt;vector&lt;int&gt;&gt; dp(s.size(),vector&lt;int&gt;(s.size(),0));
        for(int i=0;i&lt;s.size();i++){
            dp[i][i] = 1;
        }

        for(int i=s.size()-1;i&gt;=0;i--){
            for(int j=i+1;j&lt;s.size();j++){
                if(s[i]==s[j]){
                    dp[i][j]=dp[i+1][j-1]+2;
                }
                else{
                    dp[i][j]=max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }
        return dp[0][s.size()-1];
    }
};</code></pre>
    <p>
     其实也可以用上一题的方法来初始化,也AC了
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector&lt;vector&lt;int&gt;&gt; dp(s.size(),vector&lt;int&gt;(s.size(),0));
        // for(int i=0;i&lt;s.size();i++){
        //     dp[i][i] = 1;
        // }

        for(int i=s.size()-1;i&gt;=0;i--){
            for(int j=i;j&lt;s.size();j++){
                if(s[i]==s[j]){
                    if(i==j) dp[i][j]=1;       //把初始化放在这里了
                    else{
                    dp[i][j]=dp[i+1][j-1]+2;
                    }
                }
                else{
                    dp[i][j]=max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }
        return dp[0][s.size()-1];
    }</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f6a696e676a696e676a696e67313131312f:61727469636c652f64657461696c732f313436323935343439" class_="artid" style="display:none">
 </p>
</div>


