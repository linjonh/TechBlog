---
layout: post
title: "游戏引擎学习第156天"
date: 2025-03-13 21:49:15 +0800
description: "这次改进通过检查相邻网格单元的密度梯度，并施加相应的扩散力，使粒子的运动更加合理。虽然当前的实现已经比之前更加稳定，但仍然需要进一步优化，才能达到理想的模拟效果。"
keywords: "游戏引擎学习第156天"
categories: ['游戏引擎学习']
tags: ['游戏引擎', '学习']
artid: "146243068"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146243068
    alt: "游戏引擎学习第156天"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146243068
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146243068
cover: https://bing.ee123.net/img/rand?artid=146243068
image: https://bing.ee123.net/img/rand?artid=146243068
img: https://bing.ee123.net/img/rand?artid=146243068
---

# 游戏引擎学习第156天
\*\*仓库:\*\*
## 回顾
昨天的工作主要是展示了如何制作一个基础的粒子系统，可以看到我们制作的粒子系统其实很简单。我们使用了一些现成的资源，而粒子系统的效果看起来还不错。
## 今天的计划
今天我们继续讲解粒子系统，并展示一些可能会用到的其他功能。今天的目标是完成粒子系统的相关内容，给大家更多的直观理解。这两天的内容是关于粒子系统的基础介绍，到了周一我们将开始处理酸性系统和内存管理的部分。
粒子系统的基本概念是，粒子系统就是通过大量的小、低成本的实体来进行模拟。它的核心思想是，通过大量的便宜且快速的元素来解决问题，而不是使用复杂的实体。复杂的实体通常在游戏中扮演多种角色，需要处理大量的模拟逻辑。与此不同，粒子系统则是通过创建大量小而简单的粒子来模拟一些实体不擅长的效果，比如雾、液体、气体等。
昨天我们展示了如何制作一个基本的粒子系统，今天我想进一步扩展昨天的内容，帮助那些可能没有做过粒子系统编程的人，给大家提供更多的理解和使用粒子系统的技巧。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e005d3b91d004dbaa41338b97c790fa5.png#pic_center)
## 添加加速度并考虑它来计算新位置
今天的目标是对粒子系统进行一些扩展，加入更多传统的功能，比如给粒子添加加速度。这样，当粒子发生运动时，我们能够有更多的物理信息来预测它们的行为。
首先，给粒子添加加速度非常简单。我们可以让粒子受到重力的影响，这样粒子就会以一定的速率下落。我们设定的加速度值是-9.8米每秒平方，这就是地球的标准重力加速度。
然后，当我们更新粒子的位置时，我们还需要更新它的速度。为了精确模拟粒子的运动，我们可以采用完整的运动方程式。即通过更新速度后再更新位置的方式，这样的计算会更准确，但对于粒子系统来说，精度要求不会非常高，采用简单的更新方式也能达到不错的效果。
接下来，通过完整的运动方程式，我们将加速度的影响纳入考虑。这种更新方式可以更好地模拟粒子受加速度影响的完整过程，尽管如果我们使用简化的方式，也能得到大致正确的结果。
在添加了加速度后，粒子会表现得像一个水流瀑布一样逐渐向下掉落。但是为了对抗重力的影响，我们可能需要给粒子一个向上的初始速度。通过增加向上的力，粒子就会有更强的上升势能，形成一个更像喷泉的效果。
通过调整粒子的初始速度，我们可以使粒子系统表现得更像一个喷泉，效果也会变得更加生动。在调整过程中，我们不断增加粒子的向上速度，看到效果逐渐向预期方向发展。
此外，除了加速度的变化外，粒子系统还有一些其他重要的物理模拟特性，例如粒子之间的相互作用，或者如何通过不同的模拟方法处理粒子。这些方面也是我们可以进一步扩展和改进的内容。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/551c4b4809ce4cfe8569f98278a432d1.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8913b39121b54257a1c7cbffffb35da0.png#pic_center)
## 让粒子反弹回地面
在粒子系统中，碰撞检测是一个比较复杂的问题，尤其是当粒子与地面碰撞时。理想情况下，粒子在碰到地面时应该会反弹，但是因为粒子系统的目标是快速和高效，所以不能使用复杂的碰撞检测算法。因此，可以使用一种简化的方式来模拟这种效果。
一种简单的方式是检查粒子的y坐标，判断它是否低于地面（即某个指定的y值）。如果是，就反弹粒子，即将其y坐标设置为零，并反转粒子的速度方向，使它朝上运动。这个方法是基于粒子的y值，简单地判断它是否越过了地面线，并且反转其速度，这样粒子就能够模拟出碰撞后的反弹。
但是，这种简单的方法会导致一种不太自然的效果，粒子会快速震荡，因为每次更新时，它都会被强行设置回地面并反弹，形成一种“振动”的效果。这是因为我们没有考虑粒子的速度变化，只是简单地将其位置固定到地面，并立即反弹。
为了得到更自然的反弹效果，可以改进这个过程。首先，当粒子的y坐标小于零时，我们将其y坐标重置为零，并将y方向的速度反转。这是为了模拟粒子的反弹，使它不会直接穿透地面。同时，如果希望保持一些动量，可以在反弹时保留一部分速度，这样粒子就不会停得太快，而是可以继续向上运动一段距离。
通过这种方式，粒子的反弹效果看起来会更加自然，而不像之前那样产生不必要的震荡。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0626ae33be9d4f51a901ab9f6a887c07.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7e1227c8ccd34db6bfa776efd678aacd.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/50b9ddc3c7844c6ca7c16c7a21fac43d.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5b0822133c0c4434b5d5367fd7c5379c.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/62aa955e62844bc986ef53df8db373ec.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5b687f1c1b1e44b58284f7624005d29a.png#pic_center)
## 模拟能量损失
当前，粒子反弹效果已经加入了一个新的物理层面，即使用了“恢复系数”（Coefficient of
Restitution）。这个系数用于控制每次反弹时粒子保留的能量比例，从而模拟出更自然的反弹效果。理论上，物体反弹的高度应该和它掉下的高度一样，但现实中由于空气阻力、能量损失等因素，反弹高度通常会低于原始高度。
当物体与地面碰撞时，能量并不会完全转化为反弹的动能。一部分能量被用于形变（比如球和地面的接触会导致一定程度的变形）。这种能量损失直接影响到反弹的高度，真实的物理世界中，物体的弹性系数决定了反弹后能量的损失程度。
为了简化计算，使用了恢复系数来表示反弹时保留的能量百分比。举个例子，如果恢复系数为0.5，那么粒子反弹时的速度就会减少一半，模拟出真实的能量损失。通过加入这个系数，反弹的粒子更加符合预期的物理行为，形成了类似喷泉的效果。
此外，通过调整初始速度和恢复系数，可以让反弹效果更加自然，比如增加初始速度来增强反弹的力度，或者降低恢复系数使反弹更加柔和。这样通过简单的代码调整，可以让粒子的反弹效果看起来更符合物理规律，同时也不需要复杂的碰撞检测算法。
总的来说，加入恢复系数后，反弹粒子的运动更加自然，且通过适当的调整，可以使得效果更符合预期，不会过于夸张。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/399bc5877bcd4878a5d42cecbb38e4b3.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/899e230c78f04771914035646b219f67.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c4a1fa28c5424396bb5adaebe3688bb9.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/696b5c0c59214f84b62c6b2a310cee5c.png#pic_center)
## 编写特定用途的代码以实现所需行为
在试图模拟喷泉效果时，可以采用一种较为简化的方法来实现。首先，假设我们有一个水流模拟，在其上升至顶点时，我们希望使水流向外散开。为了实现这一效果，可以使用一些“作弊”的方式，简化物理模拟，而不是做真正复杂的物理计算。这种方式并不是通过完全的物理仿真来处理喷泉，而是通过人为的设置某些触发条件和强度来模拟水流的散开。
具体来说，如果水流的速度变为负值，意味着它开始下落时，就可以触发一个外力，使得水流散开。这种外力模拟了喷泉水流在上升到顶点后，由于重力减速，最终水流开始向外扩展的效果。我们可以简单地根据水流的横向位置（例如距离中心线的距离）增加一个加速度，以此模拟水流的外扩效果。
具体实现时，我们可以设定一个条件：当水流的速度为负且其高度超过一定阈值时，施加这个外力。在代码中，可以通过增加一个加速度来让水流逐渐向外扩展。这个加速度的强度可以根据水流距离中心的远近来调节，从而控制水流的扩散程度。对于模拟而言，完全不需要精确的物理计算，而只是通过不断调整这些参数，逐步找到合适的效果。
但是，在实践中，这种方法并不总是完美的。由于我们缺乏实际的物理模拟，调整这些参数往往需要大量的试错。例如，在调整过程中，可能会遇到一些难以解释的行为，例如为什么某些效果出现在不期望的位置。为了改进这些情况，我们可以限制某些效应的应用范围，使得它们只在水流的上升阶段有效，而不是在下落阶段继续作用。
最终，通过多次调整参数，可以得到一个看起来合理的喷泉效果。然而，这种方法的缺点在于它并不完全符合物理规律，因此并不具备真实感。即便如此，依靠这种“黑客式”的方法，还是可以在短时间内得到一个令人满意的视觉效果。
总的来说，这个过程展示了通过手动调整和简化的方式来实现喷泉效果。尽管这种方法不够精确，但它能为那些没有足够时间进行复杂模拟的开发者提供一个快速解决方案。然而，这也凸显了正确物理仿真在这种场景中的重要性。如果能够使用完整的物理模拟，效果会更加真实和自然，但如果时间紧迫，使用这种简单的方式也能够满足一定的需求。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7d507146c0b74bcbb3540ba8bb9879d0.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c33a41833df44d659e19d260a5d95cf8.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e3cd86c0156a422b848ac9075366a52a.png#pic_center)
## 考虑粒子之间的相互作用，而不是将粒子孤立地模拟
我们遇到问题的原因是因为最初的模拟中，所有的粒子都是独立的个体，彼此之间没有任何考虑。它们只是简单地受牛顿运动定律的影响进行运动，没有任何相互作用的模型。
问题的根源在于，当我们有一群上升的粒子和下降的粒子时，粒子之间的密度变得很高。这些粒子会在某个区域内相互挤压。如果我们要对每个粒子进行模拟，就必须考虑到周围区域的其他粒子。具体来说，必须对每个粒子进行一个查询，去查找在该区域内有多少其他粒子。如果这些粒子的数量过多，就需要施加一种排斥力，使得粒子能够远离这些过于密集的区域。
这种方法虽然可以解决粒子之间的相互作用问题，但却会非常消耗计算资源，因为每次计算时需要对每一个粒子进行大量的查询操作。这种处理方式在大规模的粒子模拟中会导致性能问题，因此并不高效。
## 物理模拟的两大原始类别：欧拉方法和拉格朗日方法
在计算机上进行物理模拟时，实际上有两种主要的模拟方法，这两种方法是为了应对粒子密度过高的问题而提出的。这些方法不仅用于游戏中的视觉效果模拟，也用于工程等领域的实际物理模拟。它们分别被称为“欧拉方法”和“拉格朗日方法”。
1. \*\*欧拉方法\*\* ：这种方法是通过固定的空间网格来追踪物理场中的所有粒子。每个粒子的位置随着时间变化，但网格本身不移动。欧拉方法适用于那些可以在固定空间内进行描述的系统，通常用于流体力学等领域。
2. \*\*拉格朗日方法\*\* ：与欧拉方法不同，拉格朗日方法追踪的是每个粒子的轨迹。粒子本身随时间移动，不受固定网格的约束。这种方法更适用于模拟粒子之间有密切相互作用的系统，比如一些复杂的流体或颗粒流动的模拟。
这两种方法各有优势和应用场景，欧拉方法适合描述连续流体，而拉格朗日方法则更适合处理粒子之间相互作用复杂的情况。
## 拉格朗日方法：模拟粒子在空间中的运动
目前我们采用的是一种被称为“拉格朗日方法”（Lagrangian
method）的模拟方式。在拉格朗日方法中，模拟的信息本身会随着空间的配置变化而移动。这意味着，我们所模拟的物体或粒子，实际上是在三维空间中移动的，而不是仅仅固定在一个空间网格上。
具体来说，我们的模拟空间是一个三维空间（x, y,
z），但由于渲染的特殊性，我们当前的“y”轴是向上的。这就构成了一个空间坐标系统，其中包含了大量的粒子。这些粒子不仅仅是用来存储模拟信息的，它们本身也代表了模拟的空间位置。每个粒子都在这些空间点上进行模拟，并且它们的位置随着时间而变化。
在拉格朗日方法中，模拟的核心在于这些粒子本身是移动的，它们的运动和状态随着时间的推移发生变化。模拟过程实际上是这些粒子在空间中不断演化的过程。这与其他一些方法（如欧拉方法）有所不同，因为在欧拉方法中，模拟的空间是固定的，而粒子则在这些固定的空间位置中进行模拟。
## 欧拉方法：模拟特定空间位置上粒子的密度和平均速度
上述内容描述了一种物理仿真方法的思路，主要聚焦于使用固定网格来模拟粒子的运动和行为，而不是直接追踪粒子本身的位置。具体来说，整个模拟过程可以通过以下几个步骤来理解：
1. \*\*固定网格与速度\*\* ：在这种方法中，不再把粒子看作是独立的物体，而是将它们作为一种“密度”与“速度”在网格中的分布。每个网格单元中存储的是该位置的粒子密度（数量）和粒子的平均速度，而不是具体粒子的物理位置。例如，如果在某个网格单元内有5个粒子，且它们的平均上升速度为2米每秒，那么该网格单元存储的数据将是：5（粒子数）和2米每秒（速度）。
2. \*\*网格更新与传播\*\* ：每一帧模拟时，网格中的数据（如粒子密度和速度）将根据模拟规则进行更新，但粒子本身并不在空间中移动。相反，这些网格单元将“传播”它们的数据到相邻的网格单元，从而模拟粒子的运动。例如，如果某个网格单元的密度较高且速度向上，那么它将影响周围网格单元的状态，可能会导致附近的单元添加更多的粒子密度。
3. \*\*模拟步骤\*\* ：这种方法需要根据网格中每个单元的当前状态计算其未来状态。具体来说，模拟步骤包括解决方程或执行一定的计算，以推算每个网格单元的更新值。这样，虽然粒子并没有在空间中直接移动，但网格单元中的密度和速度值会随着每一帧更新而变化。
4. \*\*物理规则与仿真方程\*\* ：这种方法通常涉及到特定的物理规则，例如，当某个网格单元的密度较高且粒子速度较快时，应该向相邻网格单元传播更多的粒子密度。此外，还需要通过数学方程来描述这些物理现象，并通过数值求解方法来推进仿真。
5. \*\*应用与扩展\*\* ：这种固定网格的模拟方法属于物理仿真中的一类，具体来说，类似的方法在流体力学、气体动力学等领域中应用广泛。通过这种方式，可以高效地模拟复杂的物理现象，而不需要直接追踪每个粒子的位置。
总结来说，这种方法本质上是通过网格上的密度和速度信息来间接模拟粒子的运动，而不需要显式地追踪粒子本身。通过不断传播和更新这些信息，仿真系统能够准确模拟复杂的物理行为。
## 拉格朗日方法在处理密度时存在问题
拉格朗日方法在处理密度问题时存在一些明显的不足。密度是指单位体积内的物质数量，而拉格朗日方法本身并不涉及体积的概念，它更侧重于追踪物体的运动和变形。在使用拉格朗日方法时，体积的概念必须额外引入，否则就无法有效地处理与体积相关的物理量，尤其是与密度相关的问题。
具体来说，拉格朗日方法的核心思想是通过固定参考物体的质点来追踪其运动，而这种方法忽略了体积的变化和物体在三维空间中的分布。当涉及到需要考虑体积力（例如密度变化引起的力）时，拉格朗日方法就显得力不从心，因为它并没有内建处理这些问题的机制。在处理涉及密度和体积力的情况时，使用拉格朗日方法可能会遇到困难，导致它在这些问题上的表现不如其他方法。
虽然拉格朗日方法在密度处理上存在不足，但这并不意味着无法解决相关问题。实际上，通过额外的处理手段，比如在拉格朗日框架中引入体积和密度变化的修正，仍然可以进行一些计算和模拟。然而，整体而言，在面对需要考虑体积因素的物理问题时，拉格朗日方法在处理密度时存在一定的劣势。
## 欧拉方法不会跟踪个别粒子的属性
欧拉方法在处理密度和体积的问题时，恰好与拉格朗日方法相反，具有不同的优势和挑战。欧拉方法的主要优势在于，它非常适合处理与体积相关的物理量，因为在欧拉方法中，空间被划分为固定的网格或单元，每个单元的体积是已知的。因此，涉及体积的操作非常简单，尤其是与密度变化有关的操作。
例如，在欧拉方法中，处理密度变化和体积力非常直观。如果某个区域的密度过高，它会倾向于扩散开来，避免过度聚集。通过比较相邻单元格中的密度，可以非常容易地理解如何调整密度。如果一个单元格的密度比另一个单元格高，那么就可以推测密度应该沿着这个方向流动，从而实现物质的重新分布。这种操作相对简单，甚至可以通过一种简单的方式实现：只需要比较单元格中的密度差异，判断哪个单元格密度更高，然后将密度从高的单元格转移到低的单元格。这种方法虽然简单，但也能帮助理解密度是如何在空间中扩展的。
这种处理方法非常符合欧拉方法的特点，因为在欧拉方法中，空间是固定的，物质在这些固定的网格中流动。因此，处理涉及密度变化的问题时，欧拉方法往往更加直接和高效。尽管这种方式并非完全理想，但通过简单的推理和操作，可以有效地进行密度的管理和调节。
总的来说，欧拉方法在处理密度和体积问题时非常方便，尤其是在体积力和密度梯度的应用中。然而，欧拉方法也有它的局限性，主要表现在对于物体变形和运动的处理上，这需要根据具体问题加以权衡和选择。
## 我们将采用混合的欧拉-拉格朗日方法
如果将拉格朗日方法和欧拉方法结合起来，形成一种混合方法，就能结合两者的优点，弥补各自的不足。这种混合方法可以在不同的阶段和方面，使用不同的方案来处理问题。例如，可以在拉格朗日框架下处理物体的运动和变形，而在某些中间步骤中使用欧拉方法来处理与体积和密度相关的问题。
具体来说，拉格朗日方法可以用来追踪物体的质点，进行物体变形和动力学计算。然而，当涉及到需要考虑密度变化或体积效应的情况时，可以通过引入欧拉方法的中间步骤来处理这些问题。欧拉方法本身非常适合处理密度和体积的变化，因为它已经预设了一个固定的空间网格，可以方便地计算密度分布和流动。因此，在这种混合方法中，欧拉方法能够在某些特定的步骤中，帮助处理密度和体积的变化，而不需要重新设计整个计算框架。
这种方法的实现可能会比较复杂，因为需要在不同的计算步骤中交替使用这两种方法，但它提供了一种解决问题的途径：通过结合两种方法的优势，能够更加灵活地处理各种不同的物理现象。虽然在实际应用中可能需要一定的调整和优化，但这种混合方法无疑能为复杂的物理模拟提供更强的能力。
总的来说，混合拉格朗日和欧拉方法，可以让计算既具备处理物体运动和变形的优势，又能有效处理密度和体积效应，从而产生更加精准和有趣的模拟效果。
## 我们可以使用欧拉表示中的密度梯度来计算拉格朗日表示中粒子的水平推力
假设我们使用拉格朗日方法模拟粒子运动，在这种方法中，我们追踪粒子的动态变化。现在，如果想要在模拟中引入一些与粒子密度相关的力，例如当粒子开始聚集时，通过某种方式使其分散开来，我们可以结合拉格朗日方法和欧拉方法来改进模拟。
首先，我们可以在粒子系统的模拟前（或者在某个步骤之后）使用网格进行处理。在网格中，我们计算每个单元格的密度，密度较高的地方说明粒子聚集得比较密集。具体做法是，遍历每个粒子，记录它所在的网格单元格的粒子数量，这样每个网格单元格就有了一个粒子计数。例如，某个单元格可能有20个粒子，另一个单元格可能只有2个。
接下来，我们可以在网格上进行某种更新操作，找出密度较高的单元格。当某个单元格的密度较高时，我们可以通过网格中的密度梯度来计算一个速度或加速度，指引粒子从高密度区域流向低密度区域。这种方式就是通过欧拉方法处理密度变化，再结合拉格朗日方法来模拟粒子的运动。
这样，粒子在模拟过程中不仅会根据自己的运动更新位置，还会受到周围密度的影响，推动它们从密集区域向稀疏区域流动。我们可以通过这种方式，实现粒子在密度变化下的自发分散，而不需要进行复杂的N平方循环。
使用N平方算法的一个问题是，如果每个粒子都要考虑其他所有粒子的相互作用，计算量会非常大。例如，假设有1000个粒子，每个粒子都要考虑1000个粒子，这样就需要进行1000×1000次计算，运算量非常庞大。而通过网格化的方式，我们将问题从N×N的计算变成了更小的计算量，比如通过固定数量的网格单元来处理粒子，每个粒子只需要考虑少量的网格单元。这种方法有效减少了计算量，使得即使粒子数量增加，计算复杂度也不会像N平方那样快速增长。
总的来说，结合拉格朗日方法和欧拉方法，我们可以通过网格化密度计算来优化粒子的模拟，减少不必要的计算复杂度，同时使得模拟更加物理准确。这样可以处理粒子之间的相互作用，同时避免直接计算每对粒子之间的相互作用，从而提高模拟的效率。
## 实现它
在实践中，假设我们尝试将拉格朗日方法与欧拉方法结合起来，模拟粒子的行为。首先，定义一个“粒子单元格”，每个粒子单元格包含几个主要的属性，例如粒子密度、平均速度，以及速度乘以密度等。在模拟过程中，我们将粒子的速度和密度信息结合，通过欧拉方法来处理粒子群体的密度效应。
具体来说，我们会在粒子系统中创建一个二维网格，每个网格单元格代表一个粒子单元格。在每个单元格中，我们记录该区域的密度，以及速度与密度的乘积。这种方法的目标是，随着粒子移动，通过计算这些网格单元格的密度变化和速度变化，来控制粒子的扩散或集聚。
为了实现这一目标，我们需要进行几个步骤：
1. \*\*初始化网格\*\* ：首先创建一个二维数组（比如16x16），并将所有的网格单元格初始化为零。每个网格单元格将存储密度和速度的相关信息。
2. \*\*计算密度和速度\*\* ：我们需要遍历所有粒子，找出每个粒子所在的网格单元格，并将该粒子的位置、密度和速度信息加到相应的单元格中。例如，我们可能假设每个粒子的密度为1，这样每个粒子就贡献一个单位的密度。接着，更新每个网格单元格的速度乘以密度的总和。
3. \*\*计算平均速度\*\* ：通过每个网格单元格的密度和速度的乘积，我们可以计算出该区域的加权平均速度。这种加权平均速度与该区域的密度成正比，用来描述粒子群体的运动状态。
4. \*\*粒子到网格的映射\*\* ：为了确定粒子在哪个网格单元格中，我们需要将粒子的坐标映射到网格坐标上。假设网格的起始点不一定是原点，我们可以通过计算粒子的位置相对于网格原点的偏移量来确定它属于哪个网格单元格。我们使用向下取整（截断）来确保粒子正确地归类到相应的网格单元格。
5. \*\*更新网格数据\*\* ：通过将粒子的位置与网格单元格对应起来，并根据粒子的速度和密度更新网格单元格的数据，我们可以得到一个反映粒子群体状态的网格数据。然后，可以使用这些数据来计算粒子之间的密度梯度，进而控制粒子的运动，使其从高密度区域向低密度区域流动。
6. \*\*避免不必要的计算\*\* ：这种方法的一个优势是，它避免了直接进行 N 2 N^2 N2次粒子间的计算，而是通过网格来减少计算量。在计算密度和速度时，粒子只需要与网格中的几个单元格交互，而不是与所有粒子交互，从而大大提高了计算效率。
总体来说，结合拉格朗日方法和欧拉方法的粒子模拟，可以通过网格化的方式，动态计算和更新粒子的密度和速度。这种方法不仅提高了模拟效率，而且可以处理粒子之间的相互作用，模拟更为真实的物理现象，尤其是在大规模粒子系统中。这种方法是通过多次遍历粒子数据和网格数据，逐步更新模拟结果，最终得到一个物理上更准确的粒子行为模型。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/61b51554608740feaf4185bed6b4d47f.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bdf3f96978624a02a33a17c51a86088d.png#pic_center)
## 绘制密度场
在粒子模拟的过程中，绘制网格和显示计算结果是非常重要的一步，尤其是为了观察模拟过程中各个单元格的密度变化。为了可视化网格，我们可以通过在屏幕上绘制每个网格单元的矩形，矩形的颜色可以根据当前单元格的密度来调整，从而帮助理解粒子的分布情况。
首先，定义网格的范围，并通过遍历网格来计算每个网格单元的密度。每个网格的绘制位置是根据其坐标和网格的偏移量来确定的。绘制的矩形会显示该单元格的网格位置，并且可以根据当前的密度对矩形的颜色进行加权调整。通过调整颜色的透明度（alpha值），可以使得密度较高的单元格显示为更亮的颜色，密度较低的单元格显示为较暗的颜色，从而在可视化上反映出不同密度的区域。
然而，实际操作过程中可能会遇到一些问题，例如网格单元的大小不合适，或者密度计算结果不如预期。在这种情况下，可以通过调整网格的比例因子（grid
scale）来解决尺寸过大的问题。通过缩小网格比例，可以使得每个网格单元更加符合实际的尺寸比例，从而在绘制时避免过大或过小的问题。
此外，还需要注意一些细节，比如坐标系的偏移。在模拟的过程中，网格的原点不一定是坐标系的原点，因此在进行坐标映射时，需要对网格的原点进行适当的偏移调整。计算每个粒子所对应的网格单元时，需要根据粒子的位置和网格的大小来正确映射。为了避免不必要的缩放错误，应该使用网格尺寸的倒数来进行映射，这样才能确保粒子的位置准确映射到正确的网格单元。
通过这些调整后，可以看到一个较为合理的网格绘制效果，密度较高的区域会显示为较亮的颜色，反映出粒子群体在该区域的聚集情况。然而，仍然存在一些视觉上的问题，例如因为模拟中的粒子最终会被重置回其原始位置，导致密度图在某些区域看起来比实际情况要亮，这个问题需要在后续的优化中加以解决。
总体来说，以上过程展示了如何在粒子模拟中实现网格绘制与密度可视化。通过合理的网格划分、密度计算和绘制优化，可以帮助更好地理解粒子在空间中的分布以及它们的相互作用。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/71ab25bfce41468793132a3846db3ade.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b3a5b2a732a74584ac39c7af54e5aa44.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c219c337c51546858230cfd20b7edcb2.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c96f04a818c24a6cb00c512924283066.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9541a2813f5c4bb4b15aa64a776217de.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e10d7425578142f1a5bfa3801422eef7.png#pic_center)
## 根据单元格密度来分散粒子
在粒子模拟过程中，为了进一步优化粒子的运动，我们可以将之前的代码进行抽取，使其成为一个通用的计算模块。在新逻辑中，每个粒子都会被映射到相应的网格单元（cell），然后基于该单元的密度信息来调整粒子的运动，而不需要依赖之前的
`if` 语句判断逻辑。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/18cdb1d09c8548a1b0ede9fbf023b179.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8884e526bf1640d0b6d5fe8599a1f42b.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/66d88dd372f148929be6b45f564752d1.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/abca96c30ecd4f06a71a7a61ecfa9709.png#pic_center)
如果希望让粒子的行为与单元格的密度成比例，可以直接在计算时添加一个与该密度相关的权重因子。例如，调整粒子的推移（proofing
factor），使其与该单元的密度成正比。这样，粒子在高密度区域的受力会更大，而在低密度区域的受力会更小，从而形成一种自然的扩散趋势。
初步运行后，可以观察到粒子确实在向外扩散，但由于力的作用较大，导致整体运动过于剧烈。因此，需要进一步调整力的大小，使其更加平滑。除此之外，还需要解决一个问题，即已经消失的粒子仍然在计算密度时被计入，这会影响整体模拟的准确性。一个简单的解决方案是利用粒子的
`alpha`
值（通常表示生命周期或透明度），让其在密度计算中逐渐减少贡献。当粒子即将消失时，其对密度的贡献也趋近于零，从而防止过时的粒子对计算结果产生影响。
虽然这样能够初步控制密度计算的准确性，但目前仍然存在一个核心问题，即我们尚未处理粒子的方向性。在当前的实现中，粒子只是单纯地根据密度变化向外扩散，而缺乏基于周围环境的动态调整。为了获得更真实的粒子运动效果，需要引入网格的邻近信息，以确定粒子的具体运动方向。当前的方法虽然能够初步实现粒子的散射效果，但因为没有参考邻近网格的信息，导致粒子在高密度区域不断加速远离中心，而不会形成更复杂的流体动力学行为。
此外，粒子在靠近网格边缘时会遇到边界问题，一些粒子可能会受到异常的力或者无法正确处理出界情况。可以通过扩大网格范围来部分缓解这个问题，使得边界效应不会过早地影响粒子的运动。然而，这只是一个权宜之计，根本问题仍然是缺乏基于邻近网格的信息计算合理的受力方向。
为了暂时减少这种异常行为，可以尝试增加一个阈值，确保只有当网格单元的密度超过一定值时才会施加外力，这样可以避免粒子因为微小的密度变化而受到过大的影响。尽管如此，这种方式仍然无法完全解决问题，因为受力机制仍然是单向的，没有考虑相邻网格之间的相互作用。
尽管目前的实现还远未达到理想状态，但从模拟结果来看，粒子确实开始呈现出向外扩散的趋势，尤其是在密度较高的区域，粒子更容易分散。这说明基本的方向是正确的，接下来的关键工作是如何让粒子的运动更加自然，并结合邻近网格的信息来计算合理的受力方向，以达到更符合物理规律的模拟效果。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a8feb3780ddb4c93808aaad5a91ccf86.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/97bbbf28f2f241d3866f08eeafaa6f40.png#pic_center)
## 讨论可能的模拟改进
在当前粒子模拟的实现中，仍然存在一些问题需要解决，以使其更符合实际的物理行为。核心问题在于网格上的计算仍然不够完善，需要进一步对网格进行操作，以确保粒子的运动更加合理。
首先，需要检查粒子的速度（velocity）。如果粒子本身的速度已经指向一个较为空旷的区域，并且即将离开当前网格单元，那么就不需要再额外对其施加分散（disperse）力。当前的实现没有考虑这一点，导致即使粒子已经朝正确的方向移动，仍然可能会受到不必要的额外推动力。
其次，密度的处理也需要进行改进。目前的实现中，粒子的运动并未真正基于密度梯度进行计算，导致它们可能会向任何方向扩散，而不是遵循从高密度区域向低密度区域流动的自然规律。理想情况下，粒子应该仅从高密度区域移动到低密度区域，以确保模拟的合理性。
由于当前的实现并没有考虑这些因素，导致粒子的运动方式在很大程度上是不合理的。尽管可以看到一定程度的分散效果，但它并未真实地模拟粒子的自然运动，仍然存在较大的改进空间。因此，下一步的优化方向应该是：
1. \*\*检查粒子的速度方向\*\* ，避免对已经朝正确方向移动的粒子施加多余的外力。
2. \*\*基于密度梯度进行计算\*\* ，确保粒子只会从高密度区域流向低密度区域，而不是随意扩散。
当前的实现仍然是一个初步的、不够精确的版本，只有在引入基于网格的正确计算后，才能让粒子的运动更符合预期的物理行为。
## 利用密度梯度来获得更好的结果
在当前的粒子模拟中，我们可以快速引入一个相对简单的方法，通过检查网格中的相邻单元（next-door
neighbors）来改进粒子的运动方式。这种方法不会太复杂，并且能够更合理地处理粒子的扩散行为。
#### \*\*改进思路：基于邻居单元的密度梯度计算\*\*
我们可以在网格中引入一个“围裙”（apron）区域，使得所有粒子都始终处于网格的内部，而不会越界。这意味着，我们在计算粒子的行为时，可以确保它们始终有相邻的单元可供参考。
##### \*\*1\. 计算邻近单元的密度\*\*
为了改进当前的扩散模型，我们需要检查一个粒子所在单元的密度，以及该单元周围相邻单元的密度。具体来说，对于每个单元，我们会计算它与四个相邻单元（左、右、上、下）之间的密度差异：
\* \*\*左侧单元（x-1, y）\*\*
\* \*\*右侧单元（x+1, y）\*\*
\* \*\*上方单元（x, y+1）\*\*
\* \*\*下方单元（x, y-1）\*\*
对于每个相邻单元，我们计算密度梯度（density gradient），即当前单元与相邻单元的密度差。
##### \*\*2\. 计算基于密度梯度的扩散力\*\*
一旦获取了密度梯度，我们就可以定义一个 \*\*扩散力（dispersion force）\*\*
，该力的大小与密度梯度成正比，并作用于粒子，使其从高密度区域向低密度区域移动。
\* 例如，如果当前单元的密度 \*\*大于\*\* 左侧单元的密度，那么就会产生一个向左的扩散力，将粒子推动向左侧单元。
\* 相反，如果当前单元的密度 \*\*小于\*\* 左侧单元的密度，就不会向左移动，而是可能会受到其他方向的力作用。
\* 这个逻辑会对所有四个方向（左、右、上、下）进行计算，并合并所有方向上的力，形成最终的扩散力。
##### \*\*3\. 代码逻辑实现\*\*
在代码中，我们首先初始化一个 `dispersion` 变量，并将其初始值设为
`0`。然后，我们遍历当前单元的所有相邻单元，计算密度梯度，并累加相应的扩散力。
\* 如果当前单元的密度高于相邻单元，则向该相邻单元施加推动力。
\* 计算所有相邻单元的贡献后，我们再将最终的扩散力应用到粒子的加速度上，使其基于密度梯度进行运动。
##### \*\*4\. 观察模拟效果\*\*
在代码调整后，我们尝试运行模拟，发现粒子的扩散行为确实变得更加稳定，符合预期。粒子会根据密度梯度进行扩散，而不会随意向任意方向运动。此外，这种方法比之前的“硬编码”扩散方式更加物理真实，并且减少了不必要的随机因素。
虽然目前的扩散模型能够合理地根据密度进行粒子运动，但仍然存在一些问题，比如整体的形状仍然不是完全符合预期的喷泉效果。后续的优化方向可能包括：
1. \*\*调整扩散系数\*\* ，优化粒子扩散的速率，使其更加符合自然现象。
2. \*\*考虑非均匀的扩散力\*\* ，例如基于局部的流体动力学方程进一步改进扩散模型，使其能够形成更自然的流动模式。
3. \*\*结合速度信息\*\* ，不仅基于密度梯度计算扩散力，还要结合粒子的速度方向，确保扩散的合理性。
#### \*\*总结\*\*
这次改进通过检查相邻网格单元的密度梯度，并施加相应的扩散力，使粒子的运动更加合理。虽然当前的实现已经比之前更加稳定，但仍然需要进一步优化，才能达到理想的模拟效果。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e061f81ee0d04501826d55a98a13440b.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/97248b99121b43f5919756339c593fbe.png#pic_center)
## 我们仍然没有使用每个单元格内粒子的平均速度
当前的粒子模拟虽然已经开始展现出一定的效果，但仍然未能完全形成理想的喷泉形状，其主要原因在于我们尚未考虑流体的\*\*速度分布\*\* 对粒子运动的影响。
#### \*\*问题分析：未考虑速度对粒子运动的影响\*\*
在现有的模拟中，粒子的运动仅受密度梯度驱动的扩散力影响，而没有考虑粒子自身的速度。例如，如果某个单元的流体速度已经指向上方，并且粒子即将离开该单元，我们实际上不需要再人为地推动它们移动。
然而，当前的模型中，我们并未检查速度信息，而是简单地基于密度梯度进行扩散计算。因此，某些粒子可能会被额外施加不必要的力，导致整体的模拟效果不够真实，最终呈现的喷泉形状也不够自然。
#### \*\*改进方向：结合速度场信息\*\*
为了让粒子的运动更加符合预期，需要在计算扩散力时，额外考虑\*\*速度场\*\* ，确保粒子不会被错误地推动：
1. \*\*检查粒子的速度方向\*\*
\* 如果粒子的速度已经指向某个低密度区域，则不需要再施加额外的扩散力，因为它们本身已经在向外扩散。
\* 只有当粒子停滞或速度方向与密度梯度不匹配时，才需要施加修正的扩散力。
2. \*\*动态调整扩散力\*\*
\* 在计算密度梯度的基础上，引入一个速度相关因子，确保扩散力不会与速度方向相矛盾。
\* 例如，如果粒子正以高速向上运动，我们可能需要减少向上的扩散力，避免其运动过快或过度扩散。
3. \*\*构建更完整的流体动力学模型\*\*
\* 现有的方法类似于拉格朗日方法（Lagrangian Method），主要依赖于单个粒子的运动特性。
\* 更完整的方法可以结合\*\*欧拉方法（Eulerian Method）\*\* ，在网格上计算速度场，并据此引导粒子的运动，使整体流动更加平滑和自然。
#### \*\*当前进展与未来优化\*\*
尽管现阶段的实现方式仍然较为粗糙，但已经能看到喷泉效果的雏形，说明基本的密度驱动扩散机制是有效的。接下来的优化方向包括：
\* \*\*引入速度场计算\*\* ，避免对已经在正确方向运动的粒子施加多余的力。
\* \*\*优化扩散计算\*\* ，确保扩散方向与粒子速度方向协同工作，而非互相干扰。
\* \*\*进一步调整扩散系数\*\* ，找到一个合适的平衡，使粒子的运动更加平滑，而不是出现突兀的加速或扩散。
#### \*\*总结\*\*
虽然当前模拟仍然存在改进空间，但已经成功构建了一个基本的基于密度梯度的粒子扩散系统，并初步形成喷泉效果。后续的优化将重点放在结合速度信息，使粒子的扩散更加符合流体动力学原理，从而实现更自然的喷泉形状。
## 我想为 dP.x 添加一些摩擦力可能会有所帮助
#### \*\*增加摩擦力以改善粒子运动的稳定性\*\*
在当前的粒子模拟中，粒子在碰撞后的运动存在较大的弹跳现象，特别是在水平方向上。为了减少这种\*\*不必要的横向运动\*\*
，可以在速度计算中加入摩擦力（friction）。
#### \*\*摩擦力的作用\*\*
\* \*\*减少弹跳幅度\*\* ：在粒子碰撞后，横向速度（dp_x）会受到一定的摩擦力影响，从而降低水平方向上的速度，使其更快稳定下来。
\* \*\*改善运动的物理合理性\*\* ：目前的模拟并未准确模拟接触面（contact area）对粒子的影响，因此在碰撞时没有合适的阻力反馈，导致粒子反弹过猛。加入摩擦力可以部分解决这一问题。
#### \*\*实现方式\*\*
1. \*\*调整恢复系数（Coefficient of Restitution）\*\*
\* 恢复系数用于控制碰撞后的速度变化，通常适用于整个速度向量。如果将其应用于整个速度，那么摩擦的作用会影响到垂直和水平两个方向。
\* 但在实际情况中，水平方向的摩擦系数通常较低，因此可以单独设置一个摩擦系数，使水平方向的速度衰减得更快，而垂直方向的速度仍保持一定的恢复力。
2. \*\*单独处理水平方向速度（dp_x）\*\*
\* 采用一个较小的摩擦系数，使水平方向速度逐渐衰减，而不会瞬间消失，以模拟更真实的碰撞行为。
\* 例如，可以在碰撞检测时，对\*\*dp_x 乘以一个小于 1 的衰减因子\*\* ，例如 0.9 或 0.8，使其逐渐降低。
3. \*\*限制负值问题\*\*
\* 在实际计算中，需要确保摩擦力不会导致速度方向错误，例如在代码实现时，不小心让速度变为负值，可能会导致粒子朝错误的方向运动，因此需要特别注意边界条件的处理。
#### \*\*优化与可能的局限性\*\*
\* \*\*摩擦力可以减少水平方向的弹跳，但不会完全消除弹跳\*\* 。如果摩擦力过强，可能会导致粒子运动过于呆滞，影响整体的流动性。
\* \*\*对于粒子系统而言，简单的摩擦力处理已经足够\*\* 。但如果要实现更加真实的流体模拟，仍然需要更复杂的碰撞检测和能量衰减机制，例如基于流体动力学的方法来调整速度。
\* \*\*可以进一步优化碰撞响应\*\* ，例如：
\* 结合粒子与表面的法向方向计算摩擦力
\* 设定不同的摩擦系数，针对不同的材质或环境调整阻力
#### \*\*总结\*\*
加入摩擦力可以有效减少粒子的横向弹跳，使粒子的运动更加平滑、稳定。在实现过程中，调整\*\*摩擦系数\*\* ，\*\*恢复系数\*\* 和\*\*速度边界条件\*\*
是关键，以确保粒子运动既符合物理规律，又不会因为摩擦力过强而显得不自然。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e258083f372540d382b4187891c4c4f2.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f786d3853b8a4071ab0425e86c8fb870.png#pic_center)
## 尝试减小单个单元格的大小
#### \*\*提高网格分辨率的影响及体积计算的重要性\*\*
在当前的粒子模拟中，如果减少单个网格的大小，使得整个网格变得更加密集，会对模拟效果产生一定的影响。然而，在现有的实现方式下，这种调整并不能直接提高模拟的物理正确性，原因在于\*\*体积因素未被考虑\*\*
。
#### \*\*网格密度的变化\*\*
1. \*\*增加网格密度（提高分辨率）\*\*
\* \*\*粒子受力计算更加精细\*\* ：更小的网格意味着可以更细粒度地计算密度变化，使得力的作用更加局部化，从而可能提高模拟的精度。
\* \*\*提高计算开销\*\* ：由于网格数量的增加，计算密度梯度、受力方向等操作的计算量会增加，可能影响性能。
2. \*\*当前实现的问题\*\*
\* \*\*未考虑体积因素\*\* ：目前的力计算方式只是简单地对相邻网格的密度差异进行计算，然后施加相应的力。然而，这种方法忽略了网格体积的影响。
\* \*\*不同网格尺度下的力计算不统一\*\* ：
\* 目前的计算方式假设所有网格的大小相同，因此力的计算与网格大小直接相关。
\* 如果缩小网格，但不调整力的计算方式，那么相同的密度梯度会导致不同强度的力，导致模拟结果不可控。
#### \*\*体积因素的影响\*\*
在一个更合理的物理模拟中，\*\*受力计算需要与网格体积相匹配\*\* ，具体来说：
\* \*\*较小的网格体积意味着粒子在单位时间内需要更小的力变化，以维持合理的运动规律\*\* 。
\* \*\*较大的网格体积意味着相同的密度梯度下，粒子需要更大的力来完成相应的运动\*\* 。
\* 受力计算应该基于单位体积（或单位距离）进行归一化，而不是直接使用密度差值计算力。
#### \*\*如何修正计算方式\*\*
1. \*\*引入体积修正因子\*\*
\* 在计算密度梯度时，加入网格大小的归一化因子，使得不同网格大小下的受力计算保持一致。
\* 例如，如果原来的力计算方式为：
F = k × ( ρ 1 − ρ 2 ) F = k \times (\rho_1 - \rho_2) F=k×(ρ1​−ρ2​)
其中 ρ 1 \rho_1 ρ1​ 和 ρ 2 \rho_2 ρ2​ 是相邻网格的密度， k k k 是某个比例系数。
\* 那么可以改为：
F = k × ( ρ 1 − ρ 2 ) / d F = k \times (\rho_1 - \rho_2) / d F=k×(ρ1​−ρ2​)/d
其中 d d d 是网格中心之间的距离，这样就可以让力的计算不会随网格大小变化而需要重新调整。
2. \*\*确保模拟在不同网格尺度下仍然稳定\*\*
\* 这样调整后，无论网格变大还是变小，模拟的整体行为不会发生剧烈变化，避免每次修改网格分辨率都需要手动调整力的计算方式。
#### \*\*总结\*\*
\* \*\*增加网格密度可以提高模拟的细节\*\* ，但目前的实现方式没有考虑网格体积，导致计算方式对网格大小敏感。
\* \*\*受力计算应该考虑体积归一化\*\* ，这样才能在不同网格尺度下保持一致的物理效果。
\* \*\*修正方式\*\* ：在计算密度梯度时，使用网格间距进行归一化，确保模拟在不同分辨率下仍然稳定。
这种优化可以让整个粒子系统更加灵活，使得我们在调整网格大小时不需要重新调整力的计算方式，同时提升模拟的物理正确性。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e458902a9c454b94aa0bb9c436dc0ace.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a8292c91a8594952928fd56b1544477b.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/94de3c00aaa7482aa468cd3da0c095bc.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2c7527e4f1d4430d85aa79210b642c1d.png#pic_center)
## 头的后部比头部的侧面更适合作为粒子
#### \*\*随机位图渲染与粒子多样性优化\*\*
在当前的粒子系统中，针对粒子的视觉效果，有一些可以提升多样性的方法。其中之一就是\*\*在粒子渲染时引入随机位图\*\*
，使得不同的粒子可以呈现不同的外观，而不是全部使用相同的图像。这种方法可以让系统看起来更加丰富，并增加视觉上的变化。
#### \*\*优化粒子系统的随机位图渲染\*\*
1. \*\*使用随机位图\*\*
\* 在当前方法中，通常会使用一个固定的位图来渲染粒子，但如果我们希望增加变化，可以在获取位图时\*\*随机选择\*\* 一个图像。
\* 可以调用 \*\*`GetRandomBitmapFrom`\*\* 这一方法，从一组位图中随机获取一个图像，以实现更丰富的视觉效果。
\* 这样，每次粒子被创建时，它都可以有一个不同的外观，而不是所有粒子都使用相同的图像。
2. \*\*实现过程\*\*
\* 在获取位图的代码处，替换原本的固定位图选择方式，改为 `GetRandomBitmapFrom(AssetTypeID_Series, StateFlags)`，这样每次获取时，都会随机返回一个不同的位图。
\* 这样可以实现粒子在渲染时不断变化，让画面更加动态化，比如在屏幕上不断闪烁的不同头像或者其他随机元素。
3. \*\*进一步优化：粒子存储自身位图 ID\*\*
\* 如果希望粒子在生成后能够一直保持相同的外观，而不是每次渲染都随机变化，可以在\*\*粒子生成时\*\* 就确定其位图 ID，并将其存储在粒子对象内部。
\* 这样，每个粒子在生命周期内都会保持相同的图像，而不是在每一帧都重新随机选择。
\* 具体做法是：
\* 在粒子生成时，随机选定一个位图 ID，并存储在粒子对象中。
\* 在渲染粒子时，使用存储的位图 ID 而不是重新随机选择。
#### \*\*权衡与取舍\*\*
在设计粒子系统时，需要根据实际需求来做权衡，主要包括以下几点：
1. \*\*计算性能 vs 视觉丰富度\*\*
\* 使用随机位图虽然可以增加视觉变化，但如果每一帧都随机选择位图，会增加一定的计算开销。
\* 解决方案是让粒子在创建时选定位图，而不是在每一帧渲染时都进行随机计算。
2. \*\*存储空间 vs 运行时计算\*\*
\* 让粒子存储自身的位图 ID 会增加粒子数据结构的存储需求，但可以减少运行时的计算。
\* 如果粒子数量较少，这种方式是合理的，但如果粒子数量非常庞大，可能会带来额外的存储开销。
3. \*\*视觉一致性 vs 随机变化\*\*
\* 如果希望粒子在生命周期内保持稳定的外观，可以存储位图 ID。
\* 如果希望粒子外观在整个过程中不断变化，则可以在每一帧都随机选择位图，但要注意可能带来的视觉抖动问题。
#### \*\*总结\*\*
\* \*\*通过`GetRandomBitmapFrom` 使粒子随机选择不同的图像，增强视觉变化。\*\*
\* \*\*如果希望粒子在整个生命周期内保持相同外观，可以在粒子创建时选定位图 ID 并存储。\*\*
\* \*\*根据不同需求权衡计算开销、存储空间与视觉效果，以找到最佳实现方式。\*\*
最终，这种方式能够让粒子系统在保持性能的同时，呈现出更丰富的视觉效果，比如不同形态的粒子闪烁变化，使整个模拟看起来更具动态感。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6b84f4f1dbb6466db739fdfbf47d1897.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fb3547fcc2334b2596ed32f0de6f8cb2.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/90a7aac9c1c54b47b111898a5fccf34b.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/054463b079024575bf17bde273d0c9a0.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/60c8afc690104f81bfcdbe49e4af03b1.png#pic_center)
## 如果你打算改变 GridScale，可能也需要按比例调整 Dc。
#### \*\*网格尺度对物理模拟的影响\*\*
在处理基于网格的物理模拟时，\*\*网格单元的尺寸\*\* （Grid Scale）是一个关键因素，它会影响计算中的\*\*力的大小\*\* 、\*\*密度的变化\*\*
以及\*\*整体的数值稳定性\*\*
。如果不考虑网格尺寸，仅仅简单地计算相邻单元的密度差异并施加一个固定的力，那么当网格尺度发生变化时，整个系统的行为就会变得不合理。
#### \*\*网格尺度的影响\*\*
1. \*\*力的计算必须基于网格单元的物理尺寸\*\*
\* 如果网格单元变小，意味着相同的物理空间被划分成了更多的单元。
\* 在这种情况下，如果仍然使用相同的力计算方式，那么单位时间内施加到粒子上的总力就会大大增加，可能会导致系统不稳定。
\* 解决方案是：\*\*力的计算需要考虑网格单元的大小\*\* ，确保无论网格有多细或多粗，施加的力在物理意义上是一致的。
2. \*\*密度变化与网格分辨率的关系\*\*
\* 当网格变小时，单个网格单元内的粒子数目可能会减少，导致密度计算发生变化。
\* 这意味着在计算密度梯度时，不能简单地使用两个网格单元的密度差值，而是应该结合网格单元的体积进行归一化处理，以保证计算出的密度梯度在不同分辨率下仍然合理。
3. \*\*数值稳定性问题\*\*
\* 如果网格单元的尺寸变化没有正确地调整相应的计算参数（如力、扩散系数等），那么可能会导致模拟出现数值不稳定，比如粒子加速度过大、数值发散等。
\* 因此，所有依赖网格计算的物理参数，都需要进行适当的尺度变换，以适配不同的网格分辨率。
#### \*\*解决方案\*\*
1. \*\*在计算力时引入网格单元尺寸的归一化\*\*
\* 例如，如果计算密度梯度并施加力时，原本是：
F = k × ( ρ left − ρ right ) F = k \times (\rho_{\text{left}} -
\rho_{\text{right}}) F=k×(ρleft​−ρright​)
\* 那么改进后的公式应该包含网格尺度 $ h $ 进行归一化：
F = k × ( ρ left − ρ right ) h F = k \times \frac{(\rho_{\text{left}} -
\rho_{\text{right}})}{h} F=k×h(ρleft​−ρright​)​
\* 这样，在网格尺寸变化时，力的大小也会相应调整，使得整体物理行为保持一致。
2. \*\*密度计算归一化\*\*
\* 计算密度时，需要考虑网格单元的体积 $ V $，避免由于网格划分不同而影响整体密度分布：
ρ = ∑ m V \rho = \frac{\sum m}{V} ρ=V∑m​
\* 这样可以确保即使网格变细，每个单元的密度计算依然保持正确的物理意义。
3. \*\*保持数值稳定性\*\*
\* 在调整网格尺度的同时，所有涉及到的数值参数（如扩散系数、时间步长等）也需要适当调整，以避免不稳定现象的发生。
#### \*\*总结\*\*
\* \*\*网格尺度变化会影响力的计算，因此需要进行归一化处理，使得物理行为在不同尺度下保持一致。\*\*
\* \*\*密度计算需要考虑网格单元的体积，以确保在不同分辨率下计算出的密度具有正确的物理意义。\*\*
\* \*\*在改变网格分辨率时，相关的物理参数（如扩散系数、时间步长等）也需要调整，以保证模拟的数值稳定性。\*\*
通过这些改进，可以确保在不同的网格分辨率下，物理模拟仍然能够保持合理性，避免因网格缩放而导致的不正确行为。
## 如果粒子生成在两个单元格之间会发生什么？这会导致所有粒子不再互相反弹吗？
#### \*\*粒子生成在两个网格单元之间的影响\*\*
在基于网格的粒子系统中，粒子的位置通常被映射到离散的网格单元中，因此\*\*理论上粒子不会真正处于两个单元之间，而是会被归属于某一个单元\*\* 。
#### \*\*粒子归属单元的逻辑\*\*
1. \*\*位置映射\*\*
\* 当粒子被生成时，它的坐标会被转换为网格索引，这通常是通过向下取整（floor）或四舍五入（round）来完成的。
\* 例如，如果网格大小为 1.0，粒子坐标为 ( 2.7 , 3.4 ) (2.7, 3.4) (2.7,3.4)，则可以映射到网格单元 ( 2 , 3 ) (2,3) (2,3) 或 ( 3 , 3 ) (3,3) (3,3) 取决于如何处理坐标。
2. \*\*不会处于两个单元之间\*\*
\* 由于这种映射方式，粒子不会真正处于两个单元之间，而是一定会归属于某个单元。
\* 这意味着不会出现“粒子卡在两个单元之间无法弹开”之类的问题。
#### \*\*可能的误解\*\*
\* \*\*如果粒子在两个单元交界处，是否会影响弹性碰撞？\*\*
\* 不会，因为粒子的运动方程依然是基于网格单元进行计算的，即使它在交界处，它仍然属于某个单元，并按照该单元的规则进行物理计算。
\* \*\*如果网格太粗糙，是否会影响模拟精度？\*\*
\* 可能会，因为网格分辨率较低时，粒子的运动会受到网格结构的影响，导致一些细节上的误差。
#### \*\*总结\*\*
\* \*\*粒子不会真正处于两个网格单元之间，而是会被归属于一个单元。\*\*
\* \*\*网格映射规则决定了粒子如何分配到单元，并不会导致“无法弹开”之类的异常行为。\*\*
\* \*\*网格分辨率可能会影响粒子运动的精度，但不会导致根本性的错误。\*\*
##
关于API设计：你最近强调“先写使用代码”，然后再写实现。虽然压缩编程方法是先写代码然后压缩，必要时将代码拉入函数，允许API在这个过程中演变。它们似乎是两种相互矛盾的方法吗？你怎么决定何时使用哪一个？
#### \*\*压缩导向编程 vs. 先编写使用代码的方法\*\*
在软件开发中，我们可以采用不同的方法来组织代码，其中\*\*压缩导向编程（Compression-Oriented Programming）\*\*和\*\*
先编写使用代码（Write Usage Code First）\*\*看似相互矛盾，但实际上并不冲突，它们适用于不同的场景。
\* \* \*
#### \*\*压缩导向编程（Compression-Oriented Programming）\*\*
\* 适用于\*\*已有大量代码\*\* 的情况下，目标是\*\*减少重复\*\* ，提高代码的复用性和可维护性。
\* 具体做法是：
1. \*\*识别重复代码\*\* ——在已有的代码库中查找相似或相同的代码片段。
2. \*\*提取公共逻辑\*\* ——将这些代码压缩进独立的函数或模块，以减少冗余。
3. \*\*优化结构\*\* ——通过减少代码重复，使代码更加紧凑、模块化，便于维护和扩展。
\* 这种方法的前提是我们已经有足够的代码可以进行分析，并且可以基于已有的实现来进行优化。
\* \* \*
#### \*\*先编写使用代码（Write Usage Code First）\*\*
\* 适用于\*\*从零开始开发\*\* 时，尚未有任何实现的情况下。
\* 这种方法强调：
1. \*\*先写调用代码\*\* ——直接编写期望的接口或API调用，而不去考虑底层实现。
2. \*\*倒推实现\*\* ——根据调用代码的需求，逐步编写对应的函数或类，使代码符合预期的用法。
3. \*\*形成清晰的API\*\* ——确保接口直观、易用，同时避免过早优化或设计过度。
\* 这是一种\*\*自顶向下（Top-Down）\*\*的方法，先定义需求，再进行实现。
\* \* \*
#### \*\*两者的区别与联系\*\*
\*\*方法\*\*| \*\*适用场景\*\*| \*\*核心思想\*\*| \*\*实现方式\*\*
---|---|---|---
\*\*压缩导向编程\*\*| 代码已经存在，需要优化| 识别重复，提取公共逻辑| 代码重构，函数抽取
\*\*先编写使用代码\*\*| 代码尚未实现，需要设计API| 先设计调用方式，再实现功能| 需求驱动，接口优先
\* \*\*两者的本质区别在于信息的起点\*\* ：
\* 如果已有代码，则需要自底向上优化，即“压缩”代码。
\* 如果代码尚未实现，则需要自顶向下构建，即“扩展”代码。
\* \*\*两者并不冲突，而是互补的\*\* ：
\* 在开发初期，通常采用“\*\*先编写使用代码\*\* ”的方法来确定功能需求。
\* 在开发后期或重构阶段，则采用“\*\*压缩导向编程\*\* ”来优化已有代码。
\* \* \*
#### \*\*如何选择使用哪种方法？\*\*
1. \*\*如果已经有很多代码，目标是优化、减少重复\*\* → 采用\*\*压缩导向编程\*\* 。
2. \*\*如果功能尚未实现，目标是定义清晰的接口\*\* → 采用\*\*先编写使用代码\*\* 的方法。
3. \*\*两者可以结合使用\*\* ：
\* 先使用“\*\*先编写使用代码\*\* ”来定义API，开发出初版功能。
\* 随着代码增加，再用“\*\*压缩导向编程\*\* ”来优化结构，提高复用性。
#### \*\*总结\*\*
\* \*\*压缩导向编程\*\* 适用于已有代码的优化，通过减少重复，提高可维护性。
\* \*\*先编写使用代码\*\* 适用于从零开始开发，帮助设计合理的API和接口。
\* \*\*两者并不矛盾，而是适用于不同的开发阶段\*\* ，可以结合使用以提高开发效率和代码质量。
## 是否可以将流体计算分成两帧进行？例如，使用第一帧来累积速度和动量变化，第二帧来解决它们？
是的，可以将计算分为两帧来执行。一个常见的做法是将计算过程分成两个步骤，第一帧用来处理速度和状态的变化（比如速度和物理状态的更新），第二帧则用来解决这些变化（例如通过应用新的速度或更新物体状态）。
这种方法可以在不改变整体计算逻辑的情况下，分摊每帧的工作量，从而提高系统的效率。然而，这种方法并不是一定需要的，是否采用两帧处理取决于具体情况。
采用两帧处理时，可能需要在两个不同的单元之间切换：一个是上一个帧的计算结果，另一个是当前帧的计算结果。虽然这样可以让计算过程分散开来，但它也有潜在的缺点。例如，使用两帧的处理方式会增加内存使用量，从而可能导致缓存性能变差。内存需求增加意味着缓存未必能够有效利用，进而可能导致性能的下降。因此，是否使用这种方法需要谨慎评估，只有在确实能够带来性能提升时才应该采用。
总结来说，将计算分成两帧的方式可以改善某些场景下的性能，但需要仔细考虑内存和缓存的使用情况，以避免带来不必要的性能损失。
## 网格的大小相对于每个粒子是否有很大影响？
网格的大小与实际效果的关系非常重要，确实有很大的影响。这是这类系统中的一个问题，尤其是在计算物理学领域，经常是采用一些近似的方式来处理问题。所以，这些系统对网格大小非常敏感。
如果网格单元太大，模拟的精确度会大大降低，无法捕捉到细节和一些重要的时间变化。另一方面，如果网格单元太小，粒子就难以有效地聚集到这些单元中，导致它们无法进行有效的计算和互动。因此，网格的大小直接影响到模拟的结果，既要避免网格太大，也要避免网格太小。
总结来说，网格的尺寸必须谨慎选择，以确保能够在精确度和计算效率之间取得平衡。
## 如果你现在决定根据密度让粒子反弹，那么如果粒子生成在两个单元格之间，密度会被一分为二，粒子就不再反弹了吗？
关于粒子是否会弹回的问题，确实如你所说，如果粒子的位置位于两个单元格之间，那么它的密度会被分摊，可能导致粒子不再弹回。换句话说，如果粒子流的宽度很大，粒子可能会跨越两个单元格，从而使得弹回的情况无法发生。
对于这种情况，虽然现有的方法并不完美，但可以通过一些技巧来缓解。一个解决办法是给粒子赋予实际的面积，而不是把它看作一个点。这样可以更合理地将粒子的密度分配到四个相邻单元格中，分配的比例根据粒子与各单元格的距离来决定。这样做可以避免粒子“跨越”两个单元格时，密度计算出现问题。
然而，即使采取了这种方法，基于网格的数值方法本身仍然有很多问题。这些方法往往带来不完美的结果，重要的是要接受这个现实——目标是生成某种效果，而不是追求完美。如果效果可以接受，即使方法有些混乱也是可以容忍的。
## 模拟退火是否适用于这个问题？
关于模拟退火的讨论，似乎并不确定具体是哪一个问题需要解决。可能是针对某个特定的技术问题或者效果进行思考，但并没有明确指出是哪一个问题。实际上，如果是讨论如何在模拟退火的动作或效果，通常会面临粒子、物理效果或动画精度等方面的挑战。而在这个对话中，并没有明确提到模拟跪姿所要解决的具体问题。
##
写使用代码先行是否意味着API调用要简洁？这是否会限制你在尝试创建栈上持久对象时的灵活性？所有复杂的持久对象初始化必须在某个地方进行。如果在栈上完成，如何在不使用静态变量的情况下持久化复杂的数据结构？
关于是否先编写使用代码的做法，是否意味着API调用会变得简化的问题，这里讨论的观点是，写使用代码并不会局限于创建持久化的东西。复杂的初始化操作无论是在哪个位置进行，都需要完成。至于复杂数据结构的持久化，如果指的是将数据存放在栈上，那么显然数据不能直接存放在栈上，而是应该存放在适当的生命周期栈上，这样做的目的是为了确保数据能在需要的时间内存在。而对于程序的栈和生命周期栈的区分，需要根据上下文来理解。整体而言，写使用代码并不直接影响持久化数据结构的实现，关键在于如何管理数据的生命周期和存储位置。
## 当前的模拟是在像素空间中吗？
当前的模拟并不是基于像素空间进行的，而是基于米（实际物理单位）来进行的。这意味着模拟中的所有尺寸和物体的位置都使用的是实际的物理单位，而不是像素，这有助于更精确地反映物理世界中的行为和相互作用。
## 预渲染效果是否可行？
对于模拟效果，动态编程的方式比简单地回放艺术家制作的预渲染效果更有价值，因为动态编程可以带来更大的学习和掌控空间。例如，通过编程来实现粒子系统的效果，可以深入理解这些效果是如何在程序中被生成的，而不仅仅是将现有的效果播放出来。通过这种方式，可以让效果更加生动和具有控制性，而不仅仅是将预设效果进行回放。
例如，粒子系统的模拟虽然简单，但其表现出来的水流效果比起最初的黑客式实现已经有了显著的进步。即便只是做了最基本的物理模拟，也能展示出粒子之间的相互作用，比如水流保持一定的分散和排斥，形成更真实的水喷射效果。调整喷射的参数（如喷射速率）可以改变粒子的运动轨迹，进一步增强物理模拟的趣味性。
总的来说，通过自己编写代码来生成模拟效果，不仅能带来更多的控制，还能让人更深刻地理解物理模拟的原理。粒子系统的模拟和效果调整，就是这种编程方式带来的一个有趣的例子。
在过程中，尽管粒子模拟没有达到完美，但通过编程方法解决物理现象带来的难题，已经能得到非常有趣和富有表现力的结果。最终，这些模拟效果既有趣又充满挑战，且能够带来更多的理解和掌控力。