---
layout: post
title: "艾尔登复刻Ep1客户端制作场景切换网络控制"
date: 2025-03-12 14:20:25 +0800
description: "是一个为 Unity 游戏开发提供高级网络功能的 SDK。它的主要作用是允许开发者在其 GameObject 和 MonoBehaviour 工作流中集成网络功能，并且可以与多种底层传输层协议兼容。：ParrelSync 是一个 Unity 编辑器扩展，旨在帮助开发者在没有构建项目的情况下测试多人游戏玩法。通过使用 ParrelSync，开发者可以在多个 Unity 编辑器窗口中同时运行项目，从而快速测试多人游戏的功能和同步问题。"
keywords: "艾尔登复刻Ep1——客户端制作、场景切换、网络控制"
categories: ['未分类']
tags: ['网络', '游戏引擎', '游戏', 'Unity']
artid: "146169907"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146169907
    alt: "艾尔登复刻Ep1客户端制作场景切换网络控制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146169907
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146169907
cover: https://bing.ee123.net/img/rand?artid=146169907
image: https://bing.ee123.net/img/rand?artid=146169907
img: https://bing.ee123.net/img/rand?artid=146169907
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     艾尔登复刻Ep1——客户端制作、场景切换、网络控制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     需要添加的插件内容
    </h2>
    <p>
     <strong>
      Netcode for GameObjects
     </strong>
     ：是一个为 Unity 游戏开发提供高级网络功能的 SDK。它的主要作用是允许开发者在其 GameObject 和 MonoBehaviour 工作流中集成网络功能，并且可以与多种底层传输层协议兼容。
    </p>
    <blockquote>
     <p>
      <strong>
       具体内容请看：
      </strong>
      <a href="https://zhuanlan.zhihu.com/p/669642159" rel="nofollow" title="https://zhuanlan.zhihu.com/p/669642159">
       https://zhuanlan.zhihu.com/p/669642159
      </a>
     </p>
    </blockquote>
    <h2>
    </h2>
    <p>
     <strong>
      ParrelSync
     </strong>
     ：ParrelSync 是一个 Unity 编辑器扩展，旨在帮助开发者在没有构建项目的情况下测试多人游戏玩法。通过使用 ParrelSync，开发者可以在多个 Unity 编辑器窗口中同时运行项目，从而快速测试多人游戏的功能和同步问题。
    </p>
    <blockquote>
     <p>
      <strong>
       具体内容请看：
      </strong>
      <a href="https://blog.csdn.net/gitblog_07332/article/details/142230297" title="ParrelSync 安装和配置指南-CSDN博客">
       ParrelSync 安装和配置指南-CSDN博客
      </a>
     </p>
    </blockquote>
    <p>
    </p>
    <h2>
     客户端制作
    </h2>
    <h3>
     Network manager
    </h3>
    <p>
     添加了Net for work脚本后，可以给物体挂载Network manager脚本。我们需要创建一个空物体，并将该脚本挂载上。
    </p>
    <p>
     <img alt="" height="316" src="https://i-blog.csdnimg.cn/direct/3edf0c3cd8c9496cbe81d3da9fa68e9c.png" width="757"/>
    </p>
    <p>
    </p>
    <h4>
     编写客户端控制脚本
    </h4>
    <blockquote>
     <p>
      这段脚本代码的作用是管理游戏的标题屏幕，提供两个主要功能：
     </p>
     <ol>
      <li>
       <p>
        启动网络会话作为主机（
        <code>
         StartNetworkAsHost
        </code>
        ），允许其他客户端连接。
       </p>
      </li>
      <li>
       <p>
        开始一个新游戏（
        <code>
         StartNewGame
        </code>
        ），加载游戏的初始状态。
       </p>
      </li>
     </ol>
    </blockquote>
    <pre><code>using SG;
using System.Collections;
using System.Collections.Generic;
using Unity.Netcode;
using UnityEngine;


namespace SG
{
    public class TitleScreenManager : MonoBehaviour
    {
        // Start is called before the first frame update
        public void StartNetworkAsHost()
        {
            NetworkManager.Singleton.StartHost();
        }

        public void StartNewGame()
        {
            StartCoroutine(WorldSaveManager.instance.LoadNewGame());
        }

    }

}

</code></pre>
    <blockquote>
     <p>
      <strong>
       命名空间：
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <code>
         namespace SG
        </code>
        ：定义了一个命名空间，用于组织代码，避免命名冲突。
       </p>
       <ul>
        <li>
         <p>
          团队开发中，不同开发者可能会使用相同的标识符名称（如函数、类、变量等），导致命名冲突。命名空间通过为标识符添加一个前缀（即命名空间名称），将标识符限定在一个特定的作用域内，从而避免了全局作用域中的命名冲突。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       StartNetworkAsHost方法：
      </strong>
     </p>
     <ul>
      <li>
       这个方法的作用是启动一个网络主机（Host）。在Unity Netcode中，主机既是服务器又是客户端，可以允许其他客户端连接到它
      </li>
      <li>
       <strong>
        <code>
         NetworkManager.Singleton.StartHost();
        </code>
       </strong>
       :
       <ul>
        <li>
         <p>
          <code>
           NetworkManager
          </code>
          是Unity Netcode（以前称为UNet）中的一个单例类，用于管理网络会话。
         </p>
        </li>
        <li>
         <p>
          <code>
           Singleton
          </code>
          是
          <code>
           NetworkManager
          </code>
          的单例实例，确保在整个应用程序中只有一个
          <code>
           NetworkManager
          </code>
          对象。
         </p>
        </li>
        <li>
         <p>
          <code>
           StartHost()
          </code>
          是
          <code>
           NetworkManager
          </code>
          的一个方法，用于启动主机模式。当用户调用
          <code>
           StartHost()
          </code>
          时，实际上是让用户的电脑设备承担了主机的角色，同时运行服务器和客户端的功能。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       <code>
        StartNewGame
       </code>
       方法：
      </strong>
     </p>
     <ul>
      <li>
       这个方法用于开始一个新游戏。
       <ul>
        <li>
         <p>
          <code>
           WorldSaveManager.instance
          </code>
          ：假设
          <code>
           WorldSaveManager
          </code>
          是一个单例模式的管理器类，
          <code>
           instance
          </code>
          是其唯一的实例。
         </p>
        </li>
        <li>
         <p>
          <code>
           LoadNewGame()
          </code>
          ：这是一个协程方法，用于加载新游戏。协程在Unity中用于执行需要分多个帧完成的操作，通常用于避免主线程阻塞。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <p>
     注意，这个挂载Network Manager脚本的空物体要加入预制体，在Unity中，将脚本挂载在空物体上作为单例管理器是一种常见的设计模式，这种模式能够确保在整个游戏或应用中只有一个实例存在，并且提供了一个全局的访问点，要添加至Asset—prefabs中。
    </p>
    <p>
    </p>
    <h3>
     挂载unity import
    </h3>
    <blockquote>
     <p>
      <img alt="" height="336" src="https://i-blog.csdnimg.cn/direct/454e81d2c8b14c9fb714c714235c8368.png" width="764"/>
     </p>
     <p>
      将 Unity Transport 挂载在 NetworkManager 物体上，是为了让 NetworkManager 使用它来处理网络连接和数据传输。Unity Transport 作为 NetworkManager 的传输层，负责实际的网络通信工作，使得 NetworkManager 能够通过网络与其他客户端或服务器进行交互。
     </p>
    </blockquote>
    <blockquote>
     <p>
      <img alt="" height="875" src="https://i-blog.csdnimg.cn/direct/0d7ae9541310496ca75bb78c6cc6fa12.png" width="485"/>
     </p>
     <p>
      将脚本Unity Transport挂载到Network Transport
     </p>
    </blockquote>
    <p>
    </p>
    <h3>
     编写切换大世界场景脚本
    </h3>
    <p>
     用于Unity游戏引擎中的世界保存管理器（WorldSaveManager）。它的主要功能是管理游戏世界的加载。
    </p>
    <pre><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace SG
{
    public class WorldSaveManager : MonoBehaviour
    {
        // Start is called before the first frame update
        public static WorldSaveManager instance;
        [SerializeField] int worldSceneIndex = 1;

        private void Awake()
        {
            if (instance == null)
            {
                instance = this;
            }
            else
            {
                Destroy(gameObject);
            }
        }

        private void Start()
        {
            DontDestroyOnLoad(gameObject);
        }

        public IEnumerator LoadNewGame()
        {

            AsyncOperation loadOperation = SceneManager.LoadSceneAsync(worldSceneIndex);
            yield return null;
        }
    }
}</code></pre>
    <blockquote>
     <pre><code>[SerializeField] int worldSceneIndex = 1;</code></pre>
     <ul>
      <li>
       <p>
        这是一个Unity提供的特性（Attribute），用于指定一个私有字段（private field）应该在Unity编辑器的Inspector面板中显示并可编辑。
       </p>
      </li>
      <li>
       <p>
        通常情况下，私有字段不会在Inspector面板中显示，但添加了
        <code>
         [SerializeField]
        </code>
        特性后，该字段就会在Inspector中可见，允许你在编辑器中直接修改它的值。
       </p>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <pre><code>private void Start()
{
    DontDestroyOnLoad(gameObject);
}</code></pre>
     <p>
      这是Unity的另一个生命周期方法，在
      <code>
       Awake
      </code>
      之后调用。在这里，它调用了
      <code>
       DontDestroyOnLoad
      </code>
      方法，确保
      <code>
       WorldSaveManager
      </code>
      实例在场景切换时不会被销毁。
     </p>
    </blockquote>
    <blockquote>
     <pre><code>public IEnumerator LoadNewGame()
{
    AsyncOperation loadOperation = SceneManager.LoadSceneAsync(worldSceneIndex);
    yield return null;
} </code></pre>
     <p>
      这段代码的作用是启动一个异步操作，用于加载指定索引的场景。加载过程不会阻塞主线程，游戏可以继续运行，同时场景在后台加载。
     </p>
     <ul>
      <li>
       <p>
        <code>
         SceneManager.LoadSceneAsync(worldSceneIndex)
        </code>
        ：使用Unity的场景管理器异步加载指定索引的场景（这里是
        <code>
         worldSceneIndex
        </code>
        ）。
       </p>
       <ul>
        <li>
         <p>
          <strong>
           <code>
            SceneManager.LoadSceneAsync
           </code>
          </strong>
          :这是Unity引擎中
          <code>
           SceneManager
          </code>
          类的一个静态方法，用于异步加载场景。
         </p>
        </li>
        <li>
         <p>
          <strong>
           <code>
            AsyncOperation
           </code>
          </strong>
          :
          <strong>
           这是一个返回值类型，表示异步操作的对象。
          </strong>
          通过这个对象，可以监听页面加载的进度和状态。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <code>
         yield return null
        </code>
        ：这是一个协程的暂停点，表示在下一帧继续执行。这里可能需要进一步的逻辑来处理场景加载的完成，比如等待加载完成后再继续执行其他操作
       </p>
      </li>
     </ul>
     <p>
      <br/>
      Q1：什么是异步操作？
     </p>
     <p>
      A1：异步操作是指一个操作在启动后，不会立即阻塞当前线程的执行，而是允许当前线程继续处理其他任务，直到该操作完成。
     </p>
     <p>
      异步操作通常用于执行耗时的任务，例如文件读写、网络请求、场景加载等，以避免主线程被阻塞，导致应用程序响应迟缓或卡顿。
      <br/>
      <br/>
      Q2：为什么这里要用异步操作？
     </p>
     <p>
      A2：在Unity中，加载场景是一个耗时的操作，特别是当场景包含大量资源（如模型、纹理、动画等）时。如果使用同步加载（即
      <code>
       SceneManager.LoadScene
      </code>
      ），主线程会被阻塞，直到场景加载完成。这会导致游戏在加载期间出现卡顿，甚至完全冻结，严重影响用户体验。
     </p>
     <p>
      通过使用异步加载（即
      <code>
       SceneManager.LoadSceneAsync
      </code>
      ），场景的加载过程会在后台进行，而主线程可以继续处理其他任务，例如更新UI、播放加载动画、响应用户输入等。这样可以确保游戏在加载场景时仍然保持流畅的运行。
     </p>
    </blockquote>
    <p>
     注意，这个挂载world Save Manager脚本的空物体要加入预制体
    </p>
    <h4>
    </h4>
    <h4>
     如何设置场景序号
    </h4>
    <p>
     1、先将当前客户端场景——save as——保存到Asset——Scene中（相当于另存一份），再删去多余的一份。
    </p>
    <p>
     2、为场景添加序号
    </p>
    <blockquote>
     <p>
      <img alt="" height="164" src="https://i-blog.csdnimg.cn/direct/74921598d16840c1a328e339ec0561c6.png" width="797"/>
     </p>
     <p>
      进入当前场景后，进入Building Setting界面，点击Add Open Scenes
     </p>
    </blockquote>
    <p>
    </p>
    <h3>
     为客户端设置按钮
    </h3>
    <blockquote>
     <p>
      <img alt="" height="261" src="https://i-blog.csdnimg.cn/direct/97d503d52e6e4589bc4a482f79a224ae.png" width="820"/>
     </p>
     <p>
      1、button的第一个设定：使网络会话作为主机（
      <code>
       StartNetworkAsHost
      </code>
      ），允许其他客户端连接。
     </p>
     <p>
      2、button的第二个设定：隐藏Start Game游戏栏
     </p>
     <p>
      3、button的第三个设定：显示New Game游戏栏
     </p>
     <p>
      4、button的第四个设定：
      <code>
       Select
      </code>
      方法会将按钮设置为选中状态，这通常会触发按钮的选中效果（如高亮设置等视觉效果）
     </p>
    </blockquote>
    <blockquote>
     <p>
      <img alt="" height="314" src="https://i-blog.csdnimg.cn/direct/126a0e6e826c40eda1302ca4bf8c05af.png" width="736"/>
     </p>
     <p>
      将Screen Manager脚本挂载至Screen Canvas
     </p>
     <p>
      <br/>
      <img alt="" height="464" src="https://i-blog.csdnimg.cn/direct/e097bdec431f449b91c06f5e02593eed.png" width="722"/>
     </p>
     <p>
      将Screen Canvas物体挂载到New Game游戏栏的按钮上，即点击New Game栏时，进入游戏场景
     </p>
    </blockquote>
    <p>
    </p>
    <h2>
     设置游戏角色管理脚本
    </h2>
    <pre><code>using System.Collections;
using System.Collections.Generic;
using Unity.Netcode;
using UnityEngine;


namespace SG
{
    public class CharacterManger : MonoBehaviour
    {
        public static CharacterManger instance;

        [Header("NETWORK JOIN")]
        [SerializeField] bool startGameAsClient;

        private void Awake()
        {
            if (instance == null)
            {
                instance = this;
            }
            else
            {
                Destroy(gameObject);
            }
        }

        private void Start()
        {
            DontDestroyOnLoad(gameObject);
        }

        private void Update()
        {
            if (startGameAsClient)
            {
                startGameAsClient = false;
                NetworkManager.Singleton.Shutdown();
                NetworkManager.Singleton.StartClient();
            }
        }
    }
}</code></pre>
    <blockquote>
     <pre><code>[Header("NETWORK JOIN")]
[SerializeField] bool startGameAsClient;</code></pre>
     <ul>
      <li>
       <strong>
        <code>
         bool startGameAsClient;
        </code>
       </strong>
       ：一个布尔变量，用于决定游戏启动时是否作为客户端加入游戏
      </li>
      <li>
       <code>
        [Header("NETWORK JOIN")]
       </code>
       的作用是将下面的变量
       <code>
        [SerializeField] bool startGameAsClient;
       </code>
       归类到"NETWORK JOIN"这一部分
       <br/>
       <br/>
       <br/>
       这样在Unity编辑器中，这个变量会显示在检查器面板的"NETWORK JOIN"标题下。
      </li>
      <li>
       <img alt="" height="123" src="https://i-blog.csdnimg.cn/direct/2bd261c594ff4aa7b326ae0100d5c664.png" width="462"/>
      </li>
     </ul>
    </blockquote>
    <p>
    </p>
    <blockquote>
     <pre><code>if (startGameAsClient)
{
    startGameAsClient = false;
    NetworkManager.Singleton.Shutdown();
    NetworkManager.Singleton.StartClient();
}</code></pre>
     <ol>
      <li>
       <p>
        <strong>
         <code>
          if (startGameAsClient)
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          检查
          <code>
           startGameAsClient
          </code>
          是否为
          <code>
           true
          </code>
          。如果是，表示需要以客户端模式加入游戏。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          startGameAsClient = false;
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          将
          <code>
           startGameAsClient
          </code>
          设置为
          <code>
           false
          </code>
          ，以确保这个逻辑只执行一次，避免重复触发。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          NetworkManager.Singleton.Shutdown();
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          调用
          <code>
           NetworkManager
          </code>
          的单例实例的
          <code>
           Shutdown
          </code>
          方法。
         </p>
        </li>
        <li>
         <p>
          <strong>
           作用
          </strong>
          ：关闭当前的网络管理器，清理网络状态。
         </p>
        </li>
        <li>
         <p>
          <strong>
           目的
          </strong>
          ：确保在重新启动客户端连接之前，清除任何现有的网络连接和状态，避免冲突或资源泄漏。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          NetworkManager.Singleton.StartClient();
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          调用
          <code>
           NetworkManager
          </code>
          的单例实例的
          <code>
           StartClient
          </code>
          方法。
         </p>
        </li>
        <li>
         <p>
          <strong>
           作用
          </strong>
          ：以客户端模式启动网络连接，使游戏客户端连接到服务器。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <p>
    </p>
    <h3>
     使动画角色对应网络连接
    </h3>
    <blockquote>
     <p>
      <img alt="" height="188" src="https://i-blog.csdnimg.cn/direct/91be875367aa414b9935a7cb52ec4f36.png" width="721"/>
     </p>
     <p>
      安装了网络插件后，为了让场景角色也有网络效应，我们要给物体加上该组件
     </p>
     <p>
      <br/>
      <br/>
      <img alt="" height="149" src="https://i-blog.csdnimg.cn/direct/87b2502920ef4d26b393f20149206f14.png" width="904"/>
     </p>
     <p>
      将物体挂载到NetworkManager的Player Prefab上，
      <span style="color:#fe2c24">
       <strong>
        但需要注意：不同场景下执行挂载操作产生的效果不同
       </strong>
      </span>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f38303230343139322f:61727469636c652f64657461696c732f313436313639393037" class_="artid" style="display:none">
 </p>
</div>


