---
layout: post
title: "数据结构三链表"
date: 2025-03-14 20:14:03 +0800
description: "为了表示每个数据元素ai与其后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置）。节点包括两个域，其中存储数据元素信息的称为数据域，存储直接后继存储位置有域称为指针域。线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）②先找到插入位置之前的那个位置，然后指向那个位置所指向的下一个位置。③如果p不为空，用指针q记录指针p的后继节点。②找到要删除节点的前置节点p。"
keywords: "数据结构（三）——链表"
categories: ['未分类']
tags: ['链表', '数据结构']
artid: "146261477"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146261477
    alt: "数据结构三链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146261477
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146261477
cover: https://bing.ee123.net/img/rand?artid=146261477
image: https://bing.ee123.net/img/rand?artid=146261477
img: https://bing.ee123.net/img/rand?artid=146261477
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构（三）——链表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     ​ 一、线性表的链式表示——链表
     <br/>
     线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）
     <br/>
     为了表示每个数据元素ai与其后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为节点。
     <br/>
     节点包括两个域，其中存储数据元素信息的称为数据域，存储直接后继存储位置有域称为指针域。指针域中存储的信息称为指针或链。
     <br/>
     n个节点[ai(1&lt;=i&lt;=n)的存储映像]链接成一个链表，即为线性表(a1,a2,a3,...,an)
    </p>
    <p>
     链表存储结构：
     <br/>
     ​
     <img alt="" height="122" src="https://i-blog.csdnimg.cn/direct/7377daf4bd9343429e261891d4213295.png" width="341"/>
    </p>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/69422fcb625d4c35a8172e755018ab07.png" width="765"/>
    </p>
    <p>
    </p>
    <p>
     二、单链表
     <br/>
     ​
     <img alt="" height="185" src="https://i-blog.csdnimg.cn/direct/fac381b8b04e4d19a80f23b57102591c.png" width="769"/>
    </p>
    <p>
     1.单链表——初始化
    </p>
    <p>
     <img alt="" height="380" src="https://i-blog.csdnimg.cn/direct/b7f5e441a893478581b2654e3fdfd1f7.png" width="499"/>
    </p>
    <p>
     <img alt="" height="177" src="https://i-blog.csdnimg.cn/direct/8f5a2a7b664e4f58af84574b8c7a707b.png" width="191"/>
    </p>
    <p>
    </p>
    <p>
     2.单链表(单个方向)——头插法
    </p>
    <p>
     每一次把数据都插在头节点的后面
    </p>
    <p>
     <img alt="" height="384" src="https://i-blog.csdnimg.cn/direct/642738cdbb994b7fbbd837de13d4726d.png" width="802"/>
    </p>
    <p>
     <img alt="" height="376" src="https://i-blog.csdnimg.cn/direct/65b006891af24f628ccbddac16365246.png" width="464"/>
    </p>
    <pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 0;
}

int main()
{
	Node *list = initList(); //初始化链表
	free(list); //释放内存
	insertHead(list,10);
	insertHead(list,20);
	return 1;
}

</code></pre>
    <p>
     原理：
    </p>
    <p>
     ①
    </p>
    <p>
     <img alt="" height="110" src="https://i-blog.csdnimg.cn/direct/d057d1fbdba54a8694d1a9ea591a390e.png" width="775"/>
     ②
    </p>
    <p>
     <img alt="" height="231" src="https://i-blog.csdnimg.cn/direct/2ab6627575f04cfca8111988ea7a8c28.png" width="784"/>
    </p>
    <p>
     ③
    </p>
    <p>
     <img alt="" height="225" src="https://i-blog.csdnimg.cn/direct/89a4d0b5b4094589830169319be76ef0.png" width="776"/>
    </p>
    <p>
    </p>
    <p>
     3.单链表——遍历
    </p>
    <p>
     <img alt="" height="274" src="https://i-blog.csdnimg.cn/direct/b5dcd2246b2e4994ab6dff9dc8a2b840.png" width="607"/>
    </p>
    <p>
     <img alt="" height="85" src="https://i-blog.csdnimg.cn/direct/b65c1d3665474a2bae9344b33555e94a.png" width="760"/>
    </p>
    <pre><code class="language-cs">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L-&gt;next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p-&gt;data); //输出数据
		p = p-&gt;next; //指向下一个节点
	}
	printf("\n");
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	insertHead(list,10);
	insertHead(list,20);
	insertHead(list,30);
	listNode(list);
	return 0;
}

</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="140" src="https://i-blog.csdnimg.cn/direct/9f7bc25df67047149492cbb7b6d3bd58.png" width="750"/>
    </p>
    <p>
     <strong>
      头插法的顺序和排列的顺序是相反的
     </strong>
    </p>
    <p>
    </p>
    <p>
     4.单链表——尾插法
    </p>
    <p>
     <img alt="" height="481" src="https://i-blog.csdnimg.cn/direct/627048b249c641008e6572b9878dce8c.png" width="807"/>
    </p>
    <p>
     <img alt="" height="142" src="https://i-blog.csdnimg.cn/direct/950c12dfcf1143c2a9802802067f1631.png" width="815"/>
    </p>
    <pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L-&gt;next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p-&gt;data); //输出数据
		p = p-&gt;next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p-&gt;next != NULL)
	{
		p = p-&gt;next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p-&gt;data = e; //数据域
	tail-&gt;next = p;
	p-&gt;next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	return 0;
}

</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/82e166d4bcad432ab291c68fc6daf83a.png" width="675"/>
    </p>
    <p>
     原理：
    </p>
    <p>
     ①当前尾节点指向新创建的一个节点
    </p>
    <p>
     <img alt="" height="261" src="https://i-blog.csdnimg.cn/direct/de95e01276e143448e13063759b82f53.png" width="775"/>
    </p>
    <p>
     ②新创建的节点指向NULL
    </p>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/direct/d5e5c3ebadf84063a8f344796e3eab45.png" width="776"/>
    </p>
    <p>
    </p>
    <p>
     5. 在指定位置插入数据
    </p>
    <p>
     <img alt="" height="544" src="https://i-blog.csdnimg.cn/direct/7c82ef9df0d9444d9cff83154597b2a3.png" width="917"/>
    </p>
    <pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L-&gt;next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p-&gt;data); //输出数据
		p = p-&gt;next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p-&gt;next != NULL)
	{
		p = p-&gt;next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p-&gt;data = e; //数据域
	tail-&gt;next = p;
	p-&gt;next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i &lt; pos - 1)  
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q-&gt;data = e;
	q-&gt;next = p-&gt;next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p-&gt;next = q; //把新节点赋值给前一个位置的next
	return 1;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); s
	return 0;
}

</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="179" src="https://i-blog.csdnimg.cn/direct/804747842f9a440a8d74e93b49b83afd.png" width="702"/>
    </p>
    <p>
     原理：
    </p>
    <p>
     ①
    </p>
    <p>
     <img alt="" height="235" src="https://i-blog.csdnimg.cn/direct/a6e7116f204649ceb60b36d783684616.png" width="796"/>
    </p>
    <p>
     ②先找到插入位置之前的那个位置，然后指向那个位置所指向的下一个位置
    </p>
    <p>
     （先找到70，再指向80）
    </p>
    <p>
     <img alt="" height="241" src="https://i-blog.csdnimg.cn/direct/5d2b25b42555400b9066e38af17c78c9.png" width="779"/>
    </p>
    <p>
     ③70指向新的节点
    </p>
    <p>
     <img alt="" height="242" src="https://i-blog.csdnimg.cn/direct/740cc07e671349c789746db778850012.png" width="789"/>
    </p>
    <p>
    </p>
    <p>
     6.删除节点
    </p>
    <p>
     <img alt="" height="612" src="https://i-blog.csdnimg.cn/direct/d898b090b2c2447faa1a74cdd8bce106.png" width="754"/>
    </p>
    <pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L-&gt;next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p-&gt;data); //输出数据
		p = p-&gt;next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p-&gt;next != NULL)
	{
		p = p-&gt;next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p-&gt;data = e; //数据域
	tail-&gt;next = p;
	p-&gt;next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i &lt; pos - 1)  
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q-&gt;data = e;
	q-&gt;next = p-&gt;next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p-&gt;next = q; //把新节点赋值给前一个位置的next
	return 1;
}

//删除指定位置的节点
int deleteNode(Node *L,int pos)
{
	Node *p = L; //要删除节点的前驱
	int i = 0;
	//遍历链表，找到要删除节点的前驱
	while(i &lt; pos - 1)
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	if(p-&gt;next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}
	
	Node *q = p-&gt;next; //q指向要删除的节点
	p-&gt;next = q-&gt;next; //让要删除节点的前驱指向要删除节点的后继
	free(q); //释放要删除节点的内存空间
	return 1;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); 
	deleteNode(list,2);
	listNode(list);
	return 0;
}

</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="185" src="https://i-blog.csdnimg.cn/direct/437d739cee4248e9a420b043720b1af7.png" width="682"/>
    </p>
    <p>
     原理：
    </p>
    <p>
     ①删除70这个节点
    </p>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/7261e7fb779747be9ad93cfde2c9d609.png" width="775"/>
    </p>
    <p>
     ②找到要删除节点的前置节点p
    </p>
    <p>
     <img alt="" height="135" src="https://i-blog.csdnimg.cn/direct/952a9f72457243328f9dc556bf85ad14.png" width="786"/>
    </p>
    <p>
     ③用指针q记录要删除的节点
    </p>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/9fc3bb372aa74d9d85a02fa9afb05ff1.png" width="787"/>
    </p>
    <p>
     ④通过改变p的后继节点实现删除
    </p>
    <p>
     （原本p指向的是70，现在使70直接指向80即可）
    </p>
    <p>
     <img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/7273a7ed26f54da0a9cce0151938f28f.png" width="801"/>
    </p>
    <p>
     ⑤释放删除节点的空间
    </p>
    <p>
     <strong>
      free(q);
     </strong>
    </p>
    <p>
    </p>
    <p>
     7.获取链表长度
    </p>
    <p>
     <img alt="" height="314" src="https://i-blog.csdnimg.cn/direct/b3ab6e91708c4976b9332c825e649d46.png" width="369"/>
    </p>
    <pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L-&gt;next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p-&gt;data); //输出数据
		p = p-&gt;next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p-&gt;next != NULL)
	{
		p = p-&gt;next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p-&gt;data = e; //数据域
	tail-&gt;next = p;
	p-&gt;next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i &lt; pos - 1)  
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q-&gt;data = e;
	q-&gt;next = p-&gt;next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p-&gt;next = q; //把新节点赋值给前一个位置的next
	return 1;
}

//删除指定位置的节点
int deleteNode(Node *L,int pos)
{
	Node *p = L; //要删除节点的前驱
	int i = 0;
	//遍历链表，找到要删除节点的前驱
	while(i &lt; pos - 1)
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	if(p-&gt;next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}
	
	Node *q = p-&gt;next; //q指向要删除的节点
	p-&gt;next = q-&gt;next; //让要删除节点的前驱指向要删除节点的后继
	free(q); //释放要删除节点的内存空间
	return 1;
}

//获取链表长度
int listLength(Node *L)
{
	Node *p = L;
	int len = 0;
	//从头节点循环到尾节点
	while(p != NULL)
	{
		p = p-&gt;next;
		len++;
	}
	return len;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); 
	deleteNode(list,2);
	listNode(list);
	printf("%d\n",listLength(list));
	return 0;
}

</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="211" src="https://i-blog.csdnimg.cn/direct/3cf62f2276dc40b1bed478134540c451.png" width="690"/>
    </p>
    <p>
    </p>
    <p>
     8.释放链表（除头节点之外的所有内容全都释放）
    </p>
    <p>
     <img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/67423cbf6a5944828ff1103a755be9ab.png" width="544"/>
    </p>
    <pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p-&gt;data = e;
	p-&gt;next = L-&gt;next;
	L-&gt;next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L-&gt;next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p-&gt;data); //输出数据
		p = p-&gt;next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p-&gt;next != NULL)
	{
		p = p-&gt;next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p-&gt;data = e; //数据域
	tail-&gt;next = p;
	p-&gt;next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i &lt; pos - 1)  
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q-&gt;data = e;
	q-&gt;next = p-&gt;next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p-&gt;next = q; //把新节点赋值给前一个位置的next
	return 1;
}

//删除指定位置的节点
int deleteNode(Node *L,int pos)
{
	Node *p = L; //要删除节点的前驱
	int i = 0;
	//遍历链表，找到要删除节点的前驱
	while(i &lt; pos - 1)
	{
		p = p-&gt;next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	if(p-&gt;next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}
	
	Node *q = p-&gt;next; //q指向要删除的节点
	p-&gt;next = q-&gt;next; //让要删除节点的前驱指向要删除节点的后继
	free(q); //释放要删除节点的内存空间
	return 1;
}

//获取链表长度
int listLength(Node *L)
{
	//头节点赋值给p
	Node *p = L;
	int len = 0;
	//从头节点循环到尾节点
	while(p != NULL)
	{
		p = p-&gt;next;
		len++;
	}
	return len;
}

//释放链表
void freeList(Node *L)
{
	Node *p = L-&gt;next; //头节点的next赋值给p指针
	Node *q; //声明一个新节点
	
	while(p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
	L-&gt;next = NULL;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); 
	deleteNode(list,2);
	listNode(list);
	printf("%d\n",listLength(list));
	freeList(list);
	printf("%d\n",listLength(list));
	return 0;
}

</code></pre>
    <p>
     运行：
    </p>
    <p>
     <img alt="" height="232" src="https://i-blog.csdnimg.cn/direct/c8760935907249f28dce5bff6942b2ae.png" width="755"/>
    </p>
    <p>
     原理：
    </p>
    <p>
     ①指针p指向头节点后的第一个节点
    </p>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/33a29de0ac294194b78a703acee3cb12.png" width="772"/>
    </p>
    <p>
     ②判断指针p是否指向空节点
    </p>
    <p>
     ③如果p不为空，用指针q记录指针p的后继节点
    </p>
    <p>
     <img alt="" height="145" src="https://i-blog.csdnimg.cn/direct/44993a10343c48a6993aa2fd81f430a5.png" width="781"/>
    </p>
    <p>
     ④释放指针p指向的节点
    </p>
    <p>
     <img alt="" height="121" src="https://i-blog.csdnimg.cn/direct/5036ccbaa8d94788be0c2d92f1f4ec0f.png" width="770"/>
    </p>
    <p>
     ⑤指针p和指针q指向同一个节点，循环上面的操作
    </p>
    <p>
     <img alt="" height="117" src="https://i-blog.csdnimg.cn/direct/9a0e3783a350489aaa02fd15353a7234.png" width="761"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393138383933322f:61727469636c652f64657461696c732f313436323631343737" class_="artid" style="display:none">
 </p>
</div>


