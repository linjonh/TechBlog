---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393138383933322f:61727469636c652f64657461696c732f313436323631343737"
layout: post
title: "数据结构三链表"
date: 2025-03-14 20:14:03 +0800
description: "为了表示每个数据元素ai与其后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置）。节点包括两个域，其中存储数据元素信息的称为数据域，存储直接后继存储位置有域称为指针域。线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）②先找到插入位置之前的那个位置，然后指向那个位置所指向的下一个位置。③如果p不为空，用指针q记录指针p的后继节点。②找到要删除节点的前置节点p。"
keywords: "数据结构（三）——链表"
categories: ['未分类']
tags: ['链表', '数据结构']
artid: "146261477"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146261477
    alt: "数据结构三链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146261477
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146261477
cover: https://bing.ee123.net/img/rand?artid=146261477
image: https://bing.ee123.net/img/rand?artid=146261477
img: https://bing.ee123.net/img/rand?artid=146261477
---

# 数据结构（三）——链表

​ 一、线性表的链式表示——链表
  
线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）
  
为了表示每个数据元素ai与其后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为节点。
  
节点包括两个域，其中存储数据元素信息的称为数据域，存储直接后继存储位置有域称为指针域。指针域中存储的信息称为指针或链。
  
n个节点[ai(1<=i<=n)的存储映像]链接成一个链表，即为线性表(a1,a2,a3,...,an)

链表存储结构：
  
​
![](https://i-blog.csdnimg.cn/direct/7377daf4bd9343429e261891d4213295.png)

![](https://i-blog.csdnimg.cn/direct/69422fcb625d4c35a8172e755018ab07.png)

二、单链表
  
​
![](https://i-blog.csdnimg.cn/direct/fac381b8b04e4d19a80f23b57102591c.png)

1.单链表——初始化

![](https://i-blog.csdnimg.cn/direct/b7f5e441a893478581b2654e3fdfd1f7.png)

![](https://i-blog.csdnimg.cn/direct/8f5a2a7b664e4f58af84574b8c7a707b.png)

2.单链表(单个方向)——头插法

每一次把数据都插在头节点的后面

![](https://i-blog.csdnimg.cn/direct/642738cdbb994b7fbbd837de13d4726d.png)

![](https://i-blog.csdnimg.cn/direct/65b006891af24f628ccbddac16365246.png)

```cpp
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 0;
}

int main()
{
	Node *list = initList(); //初始化链表
	free(list); //释放内存
	insertHead(list,10);
	insertHead(list,20);
	return 1;
}


```

原理：

①

![](https://i-blog.csdnimg.cn/direct/d057d1fbdba54a8694d1a9ea591a390e.png)
②

![](https://i-blog.csdnimg.cn/direct/2ab6627575f04cfca8111988ea7a8c28.png)

③

![](https://i-blog.csdnimg.cn/direct/89a4d0b5b4094589830169319be76ef0.png)

3.单链表——遍历

![](https://i-blog.csdnimg.cn/direct/b5dcd2246b2e4994ab6dff9dc8a2b840.png)

![](https://i-blog.csdnimg.cn/direct/b65c1d3665474a2bae9344b33555e94a.png)

```cs
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L->next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p->data); //输出数据
		p = p->next; //指向下一个节点
	}
	printf("\n");
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	insertHead(list,10);
	insertHead(list,20);
	insertHead(list,30);
	listNode(list);
	return 0;
}


```

运行：

![](https://i-blog.csdnimg.cn/direct/9f7bc25df67047149492cbb7b6d3bd58.png)

**头插法的顺序和排列的顺序是相反的**

4.单链表——尾插法

![](https://i-blog.csdnimg.cn/direct/627048b249c641008e6572b9878dce8c.png)

![](https://i-blog.csdnimg.cn/direct/950c12dfcf1143c2a9802802067f1631.png)

```cpp
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L->next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p->data); //输出数据
		p = p->next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p->data = e; //数据域
	tail->next = p;
	p->next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	return 0;
}


```

运行：

![](https://i-blog.csdnimg.cn/direct/82e166d4bcad432ab291c68fc6daf83a.png)

原理：

①当前尾节点指向新创建的一个节点

![](https://i-blog.csdnimg.cn/direct/de95e01276e143448e13063759b82f53.png)

②新创建的节点指向NULL

![](https://i-blog.csdnimg.cn/direct/d5e5c3ebadf84063a8f344796e3eab45.png)

5. 在指定位置插入数据

![](https://i-blog.csdnimg.cn/direct/7c82ef9df0d9444d9cff83154597b2a3.png)

```cpp
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L->next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p->data); //输出数据
		p = p->next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p->data = e; //数据域
	tail->next = p;
	p->next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i < pos - 1)  
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q->data = e;
	q->next = p->next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p->next = q; //把新节点赋值给前一个位置的next
	return 1;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); s
	return 0;
}


```

运行：

![](https://i-blog.csdnimg.cn/direct/804747842f9a440a8d74e93b49b83afd.png)

原理：

①

![](https://i-blog.csdnimg.cn/direct/a6e7116f204649ceb60b36d783684616.png)

②先找到插入位置之前的那个位置，然后指向那个位置所指向的下一个位置

（先找到70，再指向80）

![](https://i-blog.csdnimg.cn/direct/5d2b25b42555400b9066e38af17c78c9.png)

③70指向新的节点

![](https://i-blog.csdnimg.cn/direct/740cc07e671349c789746db778850012.png)

6.删除节点

![](https://i-blog.csdnimg.cn/direct/d898b090b2c2447faa1a74cdd8bce106.png)

```cpp
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L->next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p->data); //输出数据
		p = p->next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p->data = e; //数据域
	tail->next = p;
	p->next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i < pos - 1)  
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q->data = e;
	q->next = p->next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p->next = q; //把新节点赋值给前一个位置的next
	return 1;
}

//删除指定位置的节点
int deleteNode(Node *L,int pos)
{
	Node *p = L; //要删除节点的前驱
	int i = 0;
	//遍历链表，找到要删除节点的前驱
	while(i < pos - 1)
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	if(p->next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}
	
	Node *q = p->next; //q指向要删除的节点
	p->next = q->next; //让要删除节点的前驱指向要删除节点的后继
	free(q); //释放要删除节点的内存空间
	return 1;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); 
	deleteNode(list,2);
	listNode(list);
	return 0;
}


```

运行：

![](https://i-blog.csdnimg.cn/direct/437d739cee4248e9a420b043720b1af7.png)

原理：

①删除70这个节点

![](https://i-blog.csdnimg.cn/direct/7261e7fb779747be9ad93cfde2c9d609.png)

②找到要删除节点的前置节点p

![](https://i-blog.csdnimg.cn/direct/952a9f72457243328f9dc556bf85ad14.png)

③用指针q记录要删除的节点

![](https://i-blog.csdnimg.cn/direct/9fc3bb372aa74d9d85a02fa9afb05ff1.png)

④通过改变p的后继节点实现删除

（原本p指向的是70，现在使70直接指向80即可）

![](https://i-blog.csdnimg.cn/direct/7273a7ed26f54da0a9cce0151938f28f.png)

⑤释放删除节点的空间

**free(q);**

7.获取链表长度

![](https://i-blog.csdnimg.cn/direct/b3ab6e91708c4976b9332c825e649d46.png)

```cpp
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L->next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p->data); //输出数据
		p = p->next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p->data = e; //数据域
	tail->next = p;
	p->next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i < pos - 1)  
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q->data = e;
	q->next = p->next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p->next = q; //把新节点赋值给前一个位置的next
	return 1;
}

//删除指定位置的节点
int deleteNode(Node *L,int pos)
{
	Node *p = L; //要删除节点的前驱
	int i = 0;
	//遍历链表，找到要删除节点的前驱
	while(i < pos - 1)
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	if(p->next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}
	
	Node *q = p->next; //q指向要删除的节点
	p->next = q->next; //让要删除节点的前驱指向要删除节点的后继
	free(q); //释放要删除节点的内存空间
	return 1;
}

//获取链表长度
int listLength(Node *L)
{
	Node *p = L;
	int len = 0;
	//从头节点循环到尾节点
	while(p != NULL)
	{
		p = p->next;
		len++;
	}
	return len;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); 
	deleteNode(list,2);
	listNode(list);
	printf("%d\n",listLength(list));
	return 0;
}


```

运行：

![](https://i-blog.csdnimg.cn/direct/3cf62f2276dc40b1bed478134540c451.png)

8.释放链表（除头节点之外的所有内容全都释放）

![](https://i-blog.csdnimg.cn/direct/67423cbf6a5944828ff1103a755be9ab.png)

```cpp
#include<stdio.h>
#include <string.h>
#include<stdlib.h>
#define MAXSIZE 100

typedef int ElemType;

//链表存储结构
typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//单链表初始化
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//单链表头插法
int insertHead(Node* L,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//单链表遍历
void listNode(Node* L)
{
	Node *p = L->next; //第一个节点赋值给p指针
	while(p != NULL) //p不为空，即链表有数据
	{
		printf("%d ",p->data); //输出数据
		p = p->next; //指向下一个节点
	}
	printf("\n");
}

//获取尾节点的地址
Node* get_tail(Node *L)
{
	Node *p = L; //把L链表赋值给p指针
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//单链表尾插法
Node* insertTail(Node *tail,ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node)); //创建一块空间并赋值给指针
	p->data = e; //数据域
	tail->next = p;
	p->next = NULL; //使新创建的p节点成为新的尾节点 
	return p;
}

//在指定位置插入数据
int insertNode(Node *L,int pos,ElemType e)
{
	//用来保存插入位置的前驱节点
	Node *p = L;
	int i = 0;
	//遍历这个链表找到插入位置的前驱节点
	while(i < pos - 1)  
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	
	Node *q = (Node*)malloc(sizeof(Node)); //要插入的新节点
	q->data = e;
	q->next = p->next; //插入位置前一个节点的下一个位置赋值给新节点的下一个位置
	p->next = q; //把新节点赋值给前一个位置的next
	return 1;
}

//删除指定位置的节点
int deleteNode(Node *L,int pos)
{
	Node *p = L; //要删除节点的前驱
	int i = 0;
	//遍历链表，找到要删除节点的前驱
	while(i < pos - 1)
	{
		p = p->next;
		i++;
		if(p == NULL)
		{
			return 0;
		}
	}
	if(p->next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}
	
	Node *q = p->next; //q指向要删除的节点
	p->next = q->next; //让要删除节点的前驱指向要删除节点的后继
	free(q); //释放要删除节点的内存空间
	return 1;
}

//获取链表长度
int listLength(Node *L)
{
	//头节点赋值给p
	Node *p = L;
	int len = 0;
	//从头节点循环到尾节点
	while(p != NULL)
	{
		p = p->next;
		len++;
	}
	return len;
}

//释放链表
void freeList(Node *L)
{
	Node *p = L->next; //头节点的next赋值给p指针
	Node *q; //声明一个新节点
	
	while(p != NULL)
	{
		q = p->next;
		free(p);
		p = q;
	}
	L->next = NULL;
}

int main(int argc,char const *argv[])
{
	Node *list = initList(); //初始化链表
	Node *tail = get_tail(list);
	tail = insertTail(tail,10);
	tail = insertTail(tail,20);
	tail = insertTail(tail,30);
	listNode(list);
	insertNode(list,2,15);
	listNode(list); 
	deleteNode(list,2);
	listNode(list);
	printf("%d\n",listLength(list));
	freeList(list);
	printf("%d\n",listLength(list));
	return 0;
}


```

运行：

![](https://i-blog.csdnimg.cn/direct/c8760935907249f28dce5bff6942b2ae.png)

原理：

①指针p指向头节点后的第一个节点

![](https://i-blog.csdnimg.cn/direct/33a29de0ac294194b78a703acee3cb12.png)

②判断指针p是否指向空节点

③如果p不为空，用指针q记录指针p的后继节点

![](https://i-blog.csdnimg.cn/direct/44993a10343c48a6993aa2fd81f430a5.png)

④释放指针p指向的节点

![](https://i-blog.csdnimg.cn/direct/5036ccbaa8d94788be0c2d92f1f4ec0f.png)

⑤指针p和指针q指向同一个节点，循环上面的操作

![](https://i-blog.csdnimg.cn/direct/9a0e3783a350489aaa02fd15353a7234.png)