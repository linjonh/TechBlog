---
layout: post
title: "微服务拆分-远程调用"
date: 2025-03-09 03:05:07 +0800
description: "现在我们已经做了服务的拆分，购物车功能和商品服务功能分别拆分到了两个独立的微服务当中，也就是说代码上面它们是隔离开的，不仅如此，每个微服务将来还会有自己独立的数据库，数据上也是隔离开的。我们在查询购物车列表的时候，它有一个需求，就是不仅仅要查出购物车当中的这些商品信息，同时还要去查到购物车当中这些商品的最新的价格和状态信息，跟购物车当中的快照进行一个对比，从而去提醒用户。字节码泛型会擦除，但是new的对象它的泛型是还在的，这个时候就可以利用反射拿到这个对象上的这个泛型，从而就知道了我们想要的返回值类型。"
keywords: "微服务拆分-远程调用"
categories: ['Java']
tags: ['笔记', '架构', '微服务', '学习', '云原生']
artid: "146123008"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123008
    alt: "微服务拆分-远程调用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123008
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123008
cover: https://bing.ee123.net/img/rand?artid=146123008
image: https://bing.ee123.net/img/rand?artid=146123008
img: https://bing.ee123.net/img/rand?artid=146123008
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微服务拆分-远程调用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     我们在查询购物车列表的时候，它有一个需求，就是不仅仅要查出购物车当中的这些商品信息，同时还要去查到购物车当中这些商品的最新的价格和状态信息，跟购物车当中的快照进行一个对比，从而去提醒用户。
    </p>
    <p>
     <img alt="" height="855" src="https://i-blog.csdnimg.cn/direct/f39449d3b3e443f9b3a457c2d7e786c1.png" width="1656"/>
    </p>
    <p>
     现在我们已经做了服务的拆分，购物车功能和商品服务功能分别拆分到了两个独立的微服务当中，也就是说代码上面它们是隔离开的，不仅如此，每个微服务将来还会有自己独立的数据库，数据上也是隔离开的。一旦微服务进行了拆分，数据产生了隔离，服务之间也产生了隔离，这个时候没有办法像以前那样去做本地调用了。如果要做数据查询，查别人的数据，就必须通过网络调用。
    </p>
    <p>
     <img alt="" height="874" src="https://i-blog.csdnimg.cn/direct/0a7b927346614020a9e3bd62afe324df.png" width="1575"/>
    </p>
    <p>
     问题的关键是我们该怎么样通过java代码，从一个服务向另一个服务发起网络请求查询数据。
    </p>
    <p>
     <img alt="" height="868" src="https://i-blog.csdnimg.cn/direct/8b530e34722c4b53bbf376b4e0f34f81.png" width="1492"/>
    </p>
    <p>
     @RequiredArgsConstructor 必备参数的构造函数，那么这样一来这个注解的作用其实就是给加final的成员变量生成构造函数（常量必须初始化）。
    </p>
    <p>
     new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() {
     <!-- -->
     <br/>
     },
    </p>
    <p>
     字节码泛型会擦除，但是new的对象它的泛型是还在的，这个时候就可以利用反射拿到这个对象上的这个泛型，从而就知道了我们想要的返回值类型。也就是泛型的引用利用这个对象把泛型传过去。
    </p>
    <p>
     CollUtil.join(itemIds,",")自动把这个id集合以逗号拼接变成字符串。
     <img alt="" height="844" src="https://i-blog.csdnimg.cn/direct/b69b6a9a44524d10b726d5a103ae2c63.png" width="1687"/>
    </p>
    <p>
     <img alt="" height="819" src="https://i-blog.csdnimg.cn/direct/ba95d79bb3294f3e89d2f7eb844eb0fb.png" width="1838">
     </img>
    </p>
    <pre><code class="language-java">private void handleCartItems(List&lt;CartVO&gt; vos) {
        //TODO 1.获取商品id
        Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
        // 2.查询商品
//        List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);
        //2.1.利用RestTemplate发起http请求，得到http的响应
        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(
                "http://localhost:8081/items?ids={ids}",
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() {
                },
                Map.of("ids", CollUtil.join(itemIds,","))
        );
        //2.2解析响应
        if (!response.getStatusCode().is2xxSuccessful()){
            //查询失败，直接结束
            return;
        }
        List&lt;ItemDTO&gt; items = response.getBody();
        if (CollUtils.isEmpty(items)) {
            return;
        }
        // 3.转为 id 到 item的map
        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));
        // 4.写入vo
        for (CartVO v : vos) {
            ItemDTO item = itemMap.get(v.getItemId());
            if (item == null) {
                continue;
            }
            v.setNewPrice(item.getPrice());
            v.setStatus(item.getStatus());
            v.setStock(item.getStock());
        }
    }</code></pre>
    <p>
     <img alt="" height="585" src="https://i-blog.csdnimg.cn/direct/580e2552cf4a4d82a0cc53bf2d0897a9.png" width="1881"/>
    </p>
    <p>
     <img alt="" height="581" src="https://i-blog.csdnimg.cn/direct/77499fc80a9541bf899010beac4eb7c3.png" width="1914"/>
    </p>
    <p>
     <img alt="" height="788" src="https://i-blog.csdnimg.cn/direct/5d5e31ec7f8b4561b72bb6c3707b314a.png" width="1917"/>
    </p>
    <p>
     已经实现了从购物车服务到商品服务的远程查询。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35373034373537392f:61727469636c652f64657461696c732f313436313233303038" class_="artid" style="display:none">
 </p>
</div>


