---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34343031373131362f:61727469636c652f64657461696c732f313436323530303338"
layout: post
title: "Llama-LLM的前世今生"
date: 2025-03-14 09:58:02 +08:00
description: "对于未知的 UTF-8 字符，回退到字节级别进行分解。各数据占比如下：English CommonCrawl（67%）、C4（15%）、Github（4.5%）、Wikipedia（4.5%）、Books（4.5%）、ArXiv(2.5%)、Stack Exchange（2%）。现代基础模型的开发包括两个主要阶段：（1） 预训练阶段，使用简单的任务（如下一个单词预测或字幕）对模型进行大规模训练，以及 （2） 训练后阶段，在该阶段，模型被调整为遵循指令，符合人类偏好，并改进特定功能（例如， 编码和推理）。"
keywords: "Llama LLM的前世今生"
categories: ['未分类']
tags: ['Llama']
artid: "146250038"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146250038
    alt: "Llama-LLM的前世今生"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146250038
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146250038
cover: https://bing.ee123.net/img/rand?artid=146250038
image: https://bing.ee123.net/img/rand?artid=146250038
img: https://bing.ee123.net/img/rand?artid=146250038
---

# Llama LLM的前世今生

## 2023.2. LLaMA: Open and Efficient Foundation Language Models

### 成果

* 介绍了LLaMA，一组7B-65B的基础语言模型，在trillions（万亿）个token上进行训练的模型。表明可以专门使用公开的数据集来训练最先进的模型，而无需使用专有且无法访问的数据集。
* LLaMA-13B 在大多数基准测试中的性能都优于 GPT-3 （175B），而 LLaMA-65B 与最佳型号 Chinchilla-70B 和 PaLM-540B 竞争激烈。

### 研究背景、研究动机

最近的研究表明，对于给定的计算预算，最佳性能不是由最大的模型实现的，而是通过基于更多数据训练的较小模型实现的。即针对特定的训练计算预算最好地扩展数据集和模型大小。

训练一个模型，使用比平时训练更多的Token，从而在推理预算下实现最佳性能。 （为后面Qwen、DeepSeek算是做了铺垫）

### 核心内容

* 架构方面
  + 对每个 transformer 子层的输入进行归一化，而不是对输出进行归一化。采用了RMSNorm归一化。
  + 对于激活函数，采用SwiGLU代替ReLU。
  + 去除了绝对位置嵌入，在网络的每一层添加了旋转位置嵌入 （RoPE）
  + 采用因果多头注意力来减少内存使用和运行时间。
* 开源精神

### 实验配置

* 数据：经过分词后，整个数据集大概包含1.4T token。各数据占比如下：English CommonCrawl（67%）、C4（15%）、Github（4.5%）、Wikipedia（4.5%）、Books（4.5%）、ArXiv(2.5%)、Stack Exchange（2%）。
    
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/42e761c56cef482392d6cf0adb121d0c.png)
* 分词器：BPE算法。注意：这里将数字也拆成了单个，比如”123“拆成“1”，“2”，“3”。对于未知的 UTF-8 字符，回退到字节级别进行分解。（假设词汇表中没有字符 € ，在 UTF-8 编码中，€ 的字节表示是 \xe2\x82\xac。因此，€ 会被分解为：[“\xe2”, “\x82”, “\xac”] 。）。
* 采用AdamW优化器，使用余弦学习率，最终学习率为最大学习率的10%，使用的0.1权重衰减和1.0梯度剪裁。

## 2023.7 Llama 2: Open Foundation and Fine-Tuned Chat Models（开源论文goal）

### 成果

* 发布了Llama2，一组预训练和微调的大型语言模型，模型参数从7B到了70B，微调模型称为 Llama 2-Chat，专门针对对话应用场景进行了优化。大多数基准上表现优于现有的开源聊天模型，有可能成为闭源模型的替代。
* 提供了对Llama 2-Chat 进行微调和安全改进的方法
    
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/48462a18f9e54790bb1fb791f4051a25.png)

### 研究背景、研究动机

打破闭源，为社区提供经过安全评估的开源LLM-Chat，并提供方法。

### 核心内容

* 相比于Llama1，将模型的上下文长度增加了一倍，并采用了分组查询注意力。
* SFT。使用余弦学习率，初始学习率为2 ✖{10}^-5，权重衰减为 0.1，批量大小为 64，序列长度为 4096 个token。
  + 对于每个样本，由一个Prompt和一个回答组成。为了防止单个样本长度不够，浪费计算资源，训练时会将多个样本（prompt 和 answer 对）拼接在一起 ，形成一个更长的序列。为了区分拼接后的不同部分，会在 prompt 和 answer 之间插入一个特殊标记 （special token），用于明确标识 prompt 和 answer 的边界。 确保模型能够正确理解每一段文本的角色（用户提问 vs 模型回答）。
  + 梯度更新将Prompt置0。在训练过程中，模型需要学习如何根据 prompt 生成正确的 answer。然而，prompt 是输入数据的一部分，模型不需要“预测”它，因此对 prompt 中的 token 不计算损失（loss = 0）。只有 answer 部分的 token 才参与损失计算，从而优化模型生成的回答能力。
  + 微调了2轮。
* RLHF。
  + 我们要求标注员首先编写一个提示（prompt），然后根据提供的标准在两个采样的模型响应中进行选择。为了最大化多样性，针对某个提示的两个响应是从两个不同的模型变体中采样生成的，并通过调整温度超参数来实现多样化。除了让参与者进行强制选择外，我们还要求标注员标记他们对所选响应相对于另一个响应的偏好程度：他们的选择可以是显著更好、更好、略好或几乎无差别/不确定。
  + 在我们的偏好标注集合中，我们重点关注帮助性（helpfulness）和 安全性（safety） 。帮助性指的是 Llama 2-Chat 的回复是否能够很好地满足用户的需求并提供所需信息；安全性则指的是 Llama 2-Chat 的回复是否安全。例如，“详细说明如何制作炸弹”可能被认为是有帮助的，但根据我们的安全准则，这是不安全的。将帮助性和安全性分开处理，可以让我们为每个维度应用特定的指导原则，并更好地引导标注员。例如，我们的安全标注指南会特别关注对抗性提示（adversarial prompts）等具体问题。
  + 除了标注准则的不同外，在安全标注阶段，我们还额外收集了一个安全标签。这些额外的信息将模型的响应分为以下三类：
    - 首选响应是安全的，而另一个响应不安全 ；
    - 两个响应都是安全的 ；
    - 两个响应都不安全 。
  + 人类标注数据是按周分批次收集的。随着我们收集到更多的偏好数据，我们的奖励模型（Reward Model）得到了改进，并且我们能够逐步训练出更好的 Llama 2-Chat 版本（结果见第 5 节，图 20）。Llama 2-Chat 的改进也改变了模型的数据分布。由于奖励模型的准确性可能会因为未接触到新的样本分布而迅速下降（即出现超专业化问题，Scialom et al., 2020b），因此在每次新的 Llama 2-Chat 微调迭代之前，使用最新的 Llama 2-Chat 版本收集新的偏好数据是非常重要的。这一步有助于使奖励模型保持与最新模型的数据分布一致，并为最新模型提供准确的奖励信号。
  + 奖励模型。作者训练了两个独立的奖励模型，一个针对帮助性进行了优化，一个针对安全。
    - 使用预训练的聊天模型检查点来初始化奖励模型，因为这可以确保两个模型都能从预训练阶段获得的知识中受益。简而言之，奖励模型“知道”聊天模型所知道的内容。这可以避免例如两个模型之间出现信息不匹配的情况，这种信息不匹配可能会导致奖励模型倾向于支持幻觉（hallucinations）。奖励模型的架构和超参数与预训练语言模型相同，只是将用于预测下一个 token 的分类头替换成了一个回归头，用于输出标量奖励值
    - 由于训练数据来自不同的来源，我们对帮助性（Helpfulness）和安全性（Safety）奖励模型尝试了不同的数据混合方案，以确定最佳设置，在训练数据集上训练了一轮。
      * 帮助性奖励模型。最终使用所有 Meta 帮助性数据进行训练，并与等量的其他数据混合，这些数据均匀地从 Meta 安全性数据和开源数据集中采样。
      * 安全性奖励模型 。则使用所有 Meta 安全性和 Anthropic Harmless 数据进行训练，并按 90/10 的比例混合 Meta 帮助性数据和开源帮助性数据。我们发现，在被选中和被拒绝的响应都被认为安全的情况下，包含 10% 帮助性数据的设置特别有助于提高准确性。
  + 微调。用两种主要算法探索了 RLHF 微调：
    - 近端策略优化（PPO, Proximal Policy Optimization）
        
      限制策略更新的步长，确保训练过程稳定且高效。
    - 拒绝采样微调（Rejection Sampling Fine-tuning）
        
      从多个候选输出中选择最优结果来改进模型表现的技术。例如，对于每个输入提示（prompt），让模型生成 K 个不同的响应。使用奖励模型对这些候选输出进行评分，选择得分最高的一个作为“最佳响应”。将该最佳响应视为新的目标输出（即“黄金标准”），并基于此计算损失函数，进行梯度更新。使用这些新生成的目标输出对模型进行微调，从而强化奖励信号。
* 当向 Llama 2-Chat 提供指令时，后续的回复应该始终遵守这些约束条件。然而，最初的基于强化学习从人类反馈（RLHF）训练的模型在经过几轮对话后往往会忘记初始指令， 为了解决这一问题，作者提出了一种非常简单的方法——幽灵注意力（Ghost Attention, GAtt） ，该方法受到上下文蒸馏（Context Distillation, Bai et al., 2022b）的启发，通过对微调数据进行“改造”，帮助注意力机制在多阶段过程中保持聚焦。
    
  GAtt 的关键在于通过修改训练数据，确保模型在每一轮对话中都能重新关注初始指令。具体来说，它利用了以下策略：
  + 重复或强调初始指令 ：在每一轮对话的输入中，将初始指令显式地附加到用户消息中。
  + 零化无关损失 ：为了避免冗余和不匹配问题，GAtt 在训练过程中对与初始指令无关的内容（如中间助手消息）设置损失为 0。

### 实验配置

* 数据集：使用新的公开可用数据组合进行训练。我们还将预训练语料库的大小增加了 40%。2T个token训练。
* 分词器和超参数：和Llama1相比，基本没变

## 3. The Llama 3 Herd of Models

### 成果

* 提出了Llama3，具有 405B 参数（支持8B、70B、405B）和高达 128K 个令牌的上下文窗口。达到了与GPT4相竞争的水平。

### 研究背景、研究动机

现代基础模型的开发包括两个主要阶段：（1） 预训练阶段，使用简单的任务（如下一个单词预测或字幕）对模型进行大规模训练，以及 （2） 训练后阶段，在该阶段，模型被调整为遵循指令，符合人类偏好，并改进特定功能（例如， 编码和推理）。

作者旨在从数据、规模和管理复杂性三个关键杠杆寻求优化

### 核心内容

* 模型架构：Llama 3 405B 使用的架构有 126 层，标记表示维度为 16,384，有 128 个注意力头。与Llama2相比，做出如下改进：

  + 使用具有8个键值头的分组查询注意力，以提高推理速度并减小解码过程中键值缓存的大小。
  + 通过引入注意力掩码，防止同一序列中不同文档之间的自注意力计算。作者发现，在标准预训练阶段，这一改变的影响有限，但在对非常长的序列进行持续预训练时，这一点变得非常重要。
  + 使用具有 128K 令牌的词汇表，来自tiktoken分词器的100Ktoken和28K额外token结合，以更好地支持非英语语言
* 缩放定律：现有的缩放定律存在两个主要问题：

  + 局限性 ：大多数现有研究仅关注下一个词的预测损失（NLL），而未直接预测下游任务的性能。
  + 可靠性不足 ：由于缩放定律通常基于小规模计算预算的实验结果，可能存在噪声和偏差。
      
    作者的目标是通过缩放定律确定旗舰模型的最佳规模，并预测其在下游任务中的性能。提出了解决方案：
  + 第一阶段 ：建立下游任务的负对数似然（NLL）与训练计算量（FLOPs）之间的相关性。 这一步的核心是量化模型在下游任务上的表现如何随计算资源的变化而变化。
  + 第二阶段 ：将下游任务的负对数似然（NLL）与任务准确性（task accuracy）相关联。 在这一阶段，作者不仅利用了缩放定律模型，还引入了使用更高计算预算训练的旧模型（如Llama 2系列模型），以提高预测的准确性。
* 硬件设施的合理安排
* 后训练
    
  后训练策略的核心是一个奖励模型（reward model）和一个语言模型（language model）。首先，我们在预训练检查点的基础上，使用人工标注的偏好数据训练一个奖励模型（详见第 4.1.2 节）。然后，我们通过监督微调（Supervised Fine-Tuning, SFT；详见第 4.1.3 节）对预训练检查点进行微调，并进一步通过直接偏好优化（Direct Preference Optimization, DPO；详见第 4.1.4 节）对检查点进行对齐。
    
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7cfa094080be466ba51d3b4273ed1d8f.png)
* 工具调用

  + 搜索引擎
  + Python解释器
  + 数学引擎

### 实验配置

* 数据集：与之前版本的Llama相比，提高了用于训练前和训练后的数据的数量和质量。将训练Token扩展到15T。
* 预训练：使用AdamW，学习率峰值为8✖10^-5，采用采用 8,000 步的线性 warm-up，并使用余弦学习率调度策略，在 1,200,000 步内将学习率衰减至 8✖10^-7，为了提高训练的稳定性，作者在训练初期使用较小的批量大小（batch size），随后逐步增加以提高效率。具体而言，初始批量大小为 4M 个 token，序列长度为 4,096；在预训练了 252M 个 token 后，作者将批量大小和序列长度加倍，达到 8M 个 token 和 8,192 的序列长度；在预训练了 2.87T 个 token 后，作者再次将批量大小加倍至 16M。我们发现这种训练方法非常稳定：观察到的损失尖峰（loss spikes）很少，且无需干预来纠正模型训练中的发散问题。
  + 上下文预训练：在预训练的最后阶段， 作者在长序列上进行训练，以支持高达 128K 令牌的上下文窗口。 之前并不会对长序列进行训练，因为自注意层中的计算在序列长度上呈二次方增长。作者通过逐步增加支持的上下文长度，进行预训练，直到模型成功适应增加的上下文长度。
  + 退火：在对最后 40M 个令牌进行预训练期间，作者将学习率线性退火为 0，保持 128K 令牌的上下文长度。在这个退火阶段，还调整了数据组合，以对非常高质量的数据源进行上采样，以产生最终的预训练模型。