---
layout: post
title: "Android-Compose-remember-与-ViewModel-保存数据的优缺点对比"
date: 2025-03-11 16:54:41 +0800
description: "在开发 Android 应用时，管理 UI 状态是一个不可避免的话题。Jetpack Compose 提供了两种常见的方式来保存和管理数据：`remember` 和 `ViewModel`。它们各有优缺点，适用于不同的场景。 本文将详细对比这两者在保存数据时的优缺点，帮助你在实际开发中做出更合适的选择。"
keywords: "Android Compose: `remember` 与 `ViewModel` 保存数据的优缺点对比"
categories: ['夯实基础', 'Android']
tags: ['Android']
artid: "146183533"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146183533
    alt: "Android-Compose-remember-与-ViewModel-保存数据的优缺点对比"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146183533
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146183533
cover: https://bing.ee123.net/img/rand?artid=146183533
image: https://bing.ee123.net/img/rand?artid=146183533
img: https://bing.ee123.net/img/rand?artid=146183533
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android Compose: `remember` 与 `ViewModel` 保存数据的优缺点对比
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/422ac0fbb5a84b4c97ba822f756c8bf5.png"/>
    </p>
    <p>
     在开发 Android 应用时，管理 UI 状态是一个不可避免的话题。Jetpack Compose 提供了两种常见的方式来保存和管理数据：
     <code>
      remember
     </code>
     和
     <code>
      ViewModel
     </code>
     。它们各有优缺点，适用于不同的场景。
    </p>
    <p>
     本文将详细对比这两者在保存数据时的优缺点，帮助你在实际开发中做出更合适的选择。
    </p>
    <h3>
     <a id="remember__ViewModel__7">
     </a>
     <code>
      remember
     </code>
     和
     <code>
      ViewModel
     </code>
     的基本概念
    </h3>
    <p>
     在深入对比之前，我们先简单回顾一下这两者的基本概念。
    </p>
    <p>
     <strong>
      <code>
       remember
      </code>
     </strong>
     ：
     <br/>
     <code>
      remember
     </code>
     是 Jetpack Compose 提供的一个工具，用于在 UI 组件重组（Recomposition）过程中缓存数据。当 UI 被重新绘制时，
     <code>
      remember
     </code>
     可以保持一些数据不变，避免不必要的重新计算或数据丢失。
    </p>
    <p>
     <strong>
      <code>
       ViewModel
      </code>
     </strong>
     ：
     <br/>
     <code>
      ViewModel
     </code>
     是 Android Architecture Components 中的一个组件，用于在配置更改（如屏幕旋转）时保存和管理 UI 相关的数据。
     <code>
      ViewModel
     </code>
     通常与
     <code>
      LiveData
     </code>
     或
     <code>
      State
     </code>
     一起使用，它的生命周期跨越了 UI 组件的生命周期，能够确保数据在配置更改后不丢失。
    </p>
    <h3>
     <a id="remember__16">
     </a>
     <code>
      remember
     </code>
     的优缺点
    </h3>
    <h4>
     <a id="_17">
     </a>
     优点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        性能优化
       </strong>
       ：
       <br/>
       <code>
        remember
       </code>
       可以缓存数据，避免每次 UI 组件重组时重新计算或重新创建对象。对于一些不经常改变的数据，
       <code>
        remember
       </code>
       可以显著提高应用的性能，减少不必要的计算。
      </p>
     </li>
     <li>
      <p>
       <strong>
        简单易用
       </strong>
       ：
       <br/>
       使用
       <code>
        remember
       </code>
       保存数据非常简单，只需将数据放在
       <code>
        remember
       </code>
       的函数体内即可。没有复杂的生命周期管理，非常适合简单的场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        轻量级
       </strong>
       ：
       <br/>
       <code>
        remember
       </code>
       不依赖于其他架构组件，不需要创建额外的类或管理额外的线程。它是纯粹的 Compose 解决方案。
      </p>
     </li>
    </ol>
    <h4>
     <a id="_27">
     </a>
     缺点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        生命周期局限性
       </strong>
       ：
       <br/>
       <code>
        remember
       </code>
       的作用范围仅限于当前 Composable 函数的生命周期。如果 Composable 被销毁并重新创建，
       <code>
        remember
       </code>
       会丢失数据。而
       <code>
        ViewModel
       </code>
       是设计为跨 Activity 或 Fragment 生命周期保存数据的，因此更适合长期持久化的数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        适用场景有限
       </strong>
       ：
       <br/>
       <code>
        remember
       </code>
       适用于一些简单的 UI 状态保存，通常不适合保存复杂的业务逻辑或者需要跨多个屏幕共享的数据。对于需要长期保存或跨多个界面共享的数据，
       <code>
        ViewModel
       </code>
       更为合适。
      </p>
     </li>
     <li>
      <p>
       <strong>
        无法处理配置变化
       </strong>
       ：
       <br/>
       如果屏幕旋转或其他配置发生变化，
       <code>
        remember
       </code>
       中的数据会丢失。而
       <code>
        ViewModel
       </code>
       在这些情况下仍然能够保留数据。
      </p>
     </li>
    </ol>
    <h3>
     <a id="ViewModel__37">
     </a>
     <code>
      ViewModel
     </code>
     的优缺点
    </h3>
    <h4>
     <a id="_38">
     </a>
     优点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        跨组件生命周期保存数据
       </strong>
       ：
       <br/>
       <code>
        ViewModel
       </code>
       设计用于在配置更改（如屏幕旋转）时保存数据。它的生命周期是与
       <code>
        Activity
       </code>
       或
       <code>
        Fragment
       </code>
       绑定的，因此适用于跨多个界面或组件的共享数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持复杂的业务逻辑和状态
       </strong>
       ：
       <br/>
       <code>
        ViewModel
       </code>
       更适合保存和管理复杂的业务逻辑和状态。例如，保存从服务器获取的列表数据或用户设置等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        与 Jetpack 架构组件兼容
       </strong>
       ：
       <br/>
       <code>
        ViewModel
       </code>
       可以与
       <code>
        LiveData
       </code>
       、
       <code>
        State
       </code>
       等架构组件结合使用，方便处理异步数据流和 UI 状态的变化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        在配置变化时不丢失数据
       </strong>
       ：
       <br/>
       由于
       <code>
        ViewModel
       </code>
       的生命周期是与
       <code>
        Activity
       </code>
       或
       <code>
        Fragment
       </code>
       绑定的，它在配置变化（如屏幕旋转）时不会丢失数据，能够保证数据的持续性。
      </p>
     </li>
    </ol>
    <h4>
     <a id="_51">
     </a>
     缺点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        相对复杂
       </strong>
       ：
       <br/>
       <code>
        ViewModel
       </code>
       的使用相对复杂，需要更多的代码和架构设计。如果只是需要在一个 Composable 函数内保存一些简单的数据，
       <code>
        remember
       </code>
       会更简洁和高效。
      </p>
     </li>
     <li>
      <p>
       <strong>
        依赖于 ViewModel 相关框架
       </strong>
       ：
       <br/>
       使用
       <code>
        ViewModel
       </code>
       需要依赖 Jetpack 的架构组件，这意味着你需要引入额外的库和依赖，可能增加一些复杂性和包的大小。
      </p>
     </li>
     <li>
      <p>
       <strong>
        过度设计
       </strong>
       ：
       <br/>
       对于一些简单的 UI 状态，使用
       <code>
        ViewModel
       </code>
       可能显得有些过度设计。它更适合需要跨多个界面共享的数据，而对于局部组件的 UI 状态，
       <code>
        remember
       </code>
       是一个更轻量的选择。
      </p>
     </li>
    </ol>
    <h3>
     <a id="remember_vs_ViewModel_61">
     </a>
     <code>
      remember
     </code>
     vs
     <code>
      ViewModel
     </code>
     ：何时使用？
    </h3>
    <p>
     我们来总结一下，什么时候适合使用
     <code>
      remember
     </code>
     ，什么时候适合使用
     <code>
      ViewModel
     </code>
     。
    </p>
    <h4>
     <a id="_remember__64">
     </a>
     使用
     <code>
      remember
     </code>
     的场景：
    </h4>
    <ul>
     <li>
      <strong>
       单个 UI 组件的简单状态管理
      </strong>
      ：例如按钮点击次数、输入框内容等，数据只在当前 Composable 中使用，不需要跨多个屏幕共享。
     </li>
     <li>
      <strong>
       避免不必要的计算
      </strong>
      ：如果你有一些计算比较昂贵的数据，
      <code>
       remember
      </code>
      可以在界面重组时缓存该数据，避免每次重组时重新计算。
     </li>
     <li>
      <strong>
       短生命周期的数据
      </strong>
      ：如果数据只在某个特定 UI 组件生命周期内有效，使用
      <code>
       remember
      </code>
      更合适。
     </li>
    </ul>
    <h4>
     <a id="_ViewModel__69">
     </a>
     使用
     <code>
      ViewModel
     </code>
     的场景：
    </h4>
    <ul>
     <li>
      <strong>
       跨屏幕共享数据
      </strong>
      ：例如用户登录信息、购物车内容等需要在多个 Activity 或 Fragment 中共享的数据。
     </li>
     <li>
      <strong>
       需要长期持久化的数据
      </strong>
      ：例如网络请求结果、数据库数据等，即使发生配置变化（如屏幕旋转），数据也不应丢失。
     </li>
     <li>
      <strong>
       复杂的业务逻辑
      </strong>
      ：如果你需要处理异步数据流、网络请求结果、或者涉及多个 UI 状态的管理，
      <code>
       ViewModel
      </code>
      更加合适。
     </li>
    </ul>
    <h3>
     <a id="remember__ViewModel__74">
     </a>
     示例代码：
     <code>
      remember
     </code>
     与
     <code>
      ViewModel
     </code>
     对比
    </h3>
    <p>
     我们通过一个简单的例子来展示如何使用
     <code>
      remember
     </code>
     和
     <code>
      ViewModel
     </code>
     保存数据。
    </p>
    <h4>
     <a id="_remember_77">
     </a>
     使用
     <code>
      remember
     </code>
     ：
    </h4>
    <pre><code class="prism language-kotlin"> <span class="token annotation builtin">@Composable</span>
 <span class="token keyword">fun</span> <span class="token function">RememberExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">val</span> counter <span class="token operator">=</span> remember <span class="token punctuation">{<!-- --></span> <span class="token function">mutableStateOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
 
     <span class="token function">Column</span><span class="token punctuation">(</span>
         horizontalAlignment <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>CenterHorizontally<span class="token punctuation">,</span>
         modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>
     <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Count: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">counter<span class="token punctuation">.</span>value</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
         <span class="token function">Spacer</span><span class="token punctuation">(</span>modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token function">Button</span><span class="token punctuation">(</span>onClick <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> counter<span class="token punctuation">.</span>value<span class="token operator">++</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Increment"</span></span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

</code></pre>
    <h4>
     <a id="_ViewModel_97">
     </a>
     使用
     <code>
      ViewModel
     </code>
     ：
    </h4>
    <pre><code class="prism language-kotlin"> <span class="token keyword">class</span> CounterViewModel <span class="token operator">:</span> <span class="token function">ViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">private</span> <span class="token keyword">val</span> _counter <span class="token operator">=</span> <span class="token function">mutableStateOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
     <span class="token keyword">val</span> counter<span class="token operator">:</span> State<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token operator">=</span> _counter

     <span class="token keyword">fun</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         _counter<span class="token punctuation">.</span>value<span class="token operator">++</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token annotation builtin">@Composable</span>
 <span class="token keyword">fun</span> <span class="token function">ViewModelExample</span><span class="token punctuation">(</span>viewModel<span class="token operator">:</span> CounterViewModel <span class="token operator">=</span> <span class="token function">viewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token function">Column</span><span class="token punctuation">(</span>
         horizontalAlignment <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>CenterHorizontally<span class="token punctuation">,</span>
         modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>
     <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Count: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">viewModel<span class="token punctuation">.</span>counter<span class="token punctuation">.</span>value</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
         <span class="token function">Spacer</span><span class="token punctuation">(</span>modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token function">Button</span><span class="token punctuation">(</span>onClick <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> viewModel<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Increment"</span></span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_123">
     </a>
     结论
    </h3>
    <p>
     remember 和 ViewModel 都是非常有用的工具，但它们适用于不同的场景：
    </p>
    <ul>
     <li>
      remember 适用于保存简单、局部的 UI 状态，尤其是需要优化性能或避免重复计算时。
     </li>
     <li>
      ViewModel 更适合用于跨多个界面共享数据，或者需要在配置变化后保存数据的场景。
     </li>
    </ul>
    <p>
     在实际开发中，根据数据的生命周期和复杂度来选择合适的工具，能够让你的代码更加简洁高效。如果只是局部的 UI 状态，remember 是一个非常合适的选择；如果是跨界面或需要持久化的数据，ViewModel 会更适合。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34323735313031302f:61727469636c652f64657461696c732f313436313833353333" class_="artid" style="display:none">
 </p>
</div>


