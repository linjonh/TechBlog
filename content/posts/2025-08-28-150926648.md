---
layout: post
title: "Docker-详解示例部署Kafka镜像容器"
date: 2025-08-28T23:46:47+0800
description: "Docker是一个开源的容器化平台，通过将应用程序及其依赖打包成轻量级容器，实现一次构建，到处运行。相比传统虚拟机，Docker容器启动更快（秒级）、资源占用更少（MB级），支持单个宿主机运行数百个容器。文章详细介绍了Docker的核心命令，包括镜像管理（pull/build/push）、容器操作（run/start/stop）、资源限制和网络配置等，并提供了Kafka等应用容器的示例部署方法。Docker已成为开发测试、微服务架构和云原生应用的核心工具。"
keywords: "Docker 详解+示例(部署Kafka镜像容器）"
categories: ['Linux', 'Docker']
tags: ['容器', '命令', 'Linux', 'Kafka', 'Docker', 'Docker', 'Compose', 'Centos']
artid: "150926648"
arturl: "https://blog.csdn.net/2401_84926677/article/details/150926648"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150926648
    alt: "Docker-详解示例部署Kafka镜像容器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150926648
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150926648
cover: https://bing.ee123.net/img/rand?artid=150926648
image: https://bing.ee123.net/img/rand?artid=150926648
img: https://bing.ee123.net/img/rand?artid=150926648
---



# Docker 详解+示例(部署Kafka镜像容器）



## 介 绍

Docker 是一个开源的容器化平台，它的核心目标是解决 “软件在不同环境下运行不一致” 的问题，实现 “**一次构建，到处运行**” 。

它基于 Linux 内核的底层技术，将应用程序及其依赖（如库文件、配置、运行环境等）打包成一个标准化的 “容器”——>这个容器就像一个**轻量级的 “独立沙箱”**，它能够在隔离应用与宿主系统的同时，也隔离不同应用之间的资源和运行环境，这意味着每个应用都如同处于一个独立的空间中，既不会受宿主系统的干扰，也不会与其他应用产生资源冲突或环境干扰。同时又避免了传统虚拟机因包含完整操作系统而导致的体积庞大、启动缓慢问题。

**与传统虚拟机相比，Docker 容器具有显著优势**：启动时间通常以秒级计算（远快于虚拟机的分钟级），单个宿主可同时运行数百个容器（资源利用率更高），且容器体积仅包含应用和依赖（通常为 MB 级，而虚拟机常为 GB 级）。

在**实际场景**中，Docker 已成为开发、测试、部署全流程的核心工具；开发人员可在本地用容器模拟生产环境，避免 “本地能跑、线上报错”；运维人员可通过容器快速实现应用的批量部署、扩容缩容；企业则借助 Docker 构建微服务架构，将复杂应用拆分为多个独立容器，降低耦合度，提升迭代效率。

## Docker 核心命令详解及示例

**1. 基础命令**

| 命令 | 说明 | 示例 |
| --- | --- | --- |
| `docker version` | 查看 Docker 版本信息 | `docker version` |
| `docker info` | 查看 Docker 系统信息 | `docker info` |
| `docker --help` | 查看 Docker 帮助文档 | `docker --help` |

**2. 镜像相关命令**

| 命令 | 说明 | 示例 |
| --- | --- | --- |
| `docker images` | 列出本地镜像 | `docker images` |
| `docker search <镜像名>` | 搜索远程镜像 | `docker search ubuntu` |
| `docker pull <镜像名:标签>` | 拉取远程镜像 | `docker pull ubuntu:20.04` |
| `docker rmi <镜像ID/名称>` | 删除本地镜像 | `docker rmi ubuntu:20.04` |
| `docker build -t <镜像名:标签> <Dockerfile路径>` | 构建镜像 | `docker build -t myapp:1.0 .` |
| `docker tag <原镜像> <新镜像名:标签>` | 为镜像打标签 | `docker tag myapp:1.0 username/myapp:1.0` |
| `docker push <镜像名:标签>` | 推送镜像到仓库 | `docker push username/myapp:1.0` |

**3. 容器相关命令**

| 命令 | 说明 | 示例 |
| --- | --- | --- |
| `docker run [选项] <镜像名>` | 创建并启动容器 | `docker run -it --name mycontainer ubuntu:20.04 /bin/bash` |
| `docker ps` | 列出运行中的容器 | `docker ps` |
| `docker ps -a` | 列出所有容器（包括停止的） | `docker ps -a` |
| `docker start <容器ID/名称>` | 启动已停止的容器 | `docker start mycontainer` |
| `docker stop <容器ID/名称>` | 停止运行中的容器 | `docker stop mycontainer` |
| `docker restart <容器ID/名称>` | 重启容器 | `docker restart mycontainer` |
| `docker rm <容器ID/名称>` | 删除容器 | `docker rm mycontainer` |
| `docker exec [选项] <容器ID/名称> <命令>` | 在运行的容器中执行命令 | `docker exec -it mycontainer /bin/bash` |
| `docker logs <容器ID/名称>` | 查看容器日志 | `docker logs mycontainer` |
| `docker inspect <容器ID/名称>` | 查看容器详细信息 | `docker inspect mycontainer` |
| `docker cp <本地路径> <容器ID/名称>:<容器路径>` | 复制文件到容器 | `docker cp file.txt mycontainer:/root/` |
| `docker cp <容器ID/名称>:<容器路径> <本地路径>` | 从容器复制文件到本地 | `docker cp mycontainer:/root/file.txt .` |

**4. 容器资源限制**

| 命令 | 说明 | 示例 |
| --- | --- | --- |
| `docker run -m <内存大小>` | 限制容器内存 | `docker run -m 512m ubuntu:20.04` |
| `docker run --cpus <CPU核心数>` | 限制容器 CPU | `docker run --cpus 0.5 ubuntu:20.04` |

**5. 网络相关命令**

| 命令 | 说明 | 示例 |
| --- | --- | --- |
| `docker network ls` | 列出网络 | `docker network ls` |
| `docker network create <网络名>` | 创建网络 | `docker network create mynetwork` |
| `docker network connect <网络名> <容器名>` | 连接容器到网络 | `docker network connect mynetwork mycontainer` |
| `docker network disconnect <网络名> <容器名>` | 断开容器与网络的连接 | `docker network disconnect mynetwork mycontainer` |

## 示例：使用 Docker 安装运行 Kafka 镜像容器

### -----> 方式一 docker run

**旧版kafka需要zookeeper支持，新版kafka有kraft不需要zookeeper**

**1.docker run 配置（如下）**

```

docker run -d 
--name kafka-kraft 
-e CLUSTER_ID=whaEHdjVT1Oacl9hnbmn1w 
-e KAFKA_PROCESS_ROLES=broker,controller 
-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093
 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://你的虚拟机ens33地址:9092 
-e KAFKA_CONTROLLER_QUORUM_VOTERS=0@虚拟机回环地址:9093
 -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
 -p 9092:9092
 -p 9093:9093 
confluentinc/cp-kafka:latest
```

**2.docker ps**

**3.docker ps -a**

![](https://i-blog.csdnimg.cn/direct/cc42e40af9b14710a7a90b71f323d3b5.png)

4.docker start 容器名

5.docker ps

![](https://i-blog.csdnimg.cn/direct/3d933e252817460fbe95dc2015661994.png)

### -----> 方式二 docker compose

**旧版kafka需要zookeeper支持，这里使用docker compose进行集群管理。**

**步骤 1：创建工作目录**

首先创建一个专门用于运行 Kafka 的目录，避免文件混乱：

```

mkdir -p ~/docker-kafka
cd ~/docker-kafka
```

**步骤 2：创建 Docker Compose 配置文件**

Kafka 依赖 ZooKeeper 进行集群管理，我们使用 Docker Compose 同时启动这两个服务。

cd进入到kafka目录下，创建 `docker-compose.yml` 文件，并使用vi命令编写保存：

```

version: '3.8'

services:
  # ZooKeeper 服务
  zookeeper:
    image: confluentinc/cp-zookeeper:7.4.0  # 使用指定版本，避免兼容性问题
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181  # 客户端连接端口
      ZOOKEEPER_TICK_TIME: 2000    # 心跳间隔时间（毫秒）
    ports:
      - "2181:2181"  # 映射到宿主机的 2181 端口
    volumes:
      - zookeeper-data:/var/lib/zookeeper/data  # 持久化数据
      - zookeeper-log:/var/lib/zookeeper/log    # 持久化日志
    restart: unless-stopped  # 异常退出时自动重启

  # Kafka 服务
  kafka:
    image: confluentinc/cp-kafka:7.4.0  # 与 ZooKeeper 版本保持一致
    container_name: kafka
    depends_on:
      - zookeeper  # 确保 ZooKeeper 先启动
    ports:
      - "9092:9092"  # 宿主机访问端口
    environment:
      KAFKA_BROKER_ID: 1  #  broker 唯一标识（集群中需不同）
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181  # 连接 ZooKeeper
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: 
        PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_ADVERTISED_LISTENERS: 
        PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      # 内部服务间通信使用 29092 端口，外部访问使用 9092 端口
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1  # 偏移量主题的副本数
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
    volumes:
      - kafka-data:/var/lib/kafka/data  # 持久化 Kafka 数据
    restart: unless-stopped  # 异常退出时自动重启

# 定义持久化卷
volumes:
  zookeeper-data:
  zookeeper-log:
  kafka-data:

```

**步骤 3：启动服务**

在 `docker-compose.yml` 所在目录执行以下命令启动服务：

```

# 后台启动服务（-d 表示 detached 模式）
docker-compose up -d

# 查看启动状态
docker-compose ps
```

## Windows系统访问kafka

**注意：**

**不能直接通过浏览器访问 Kafka 的 9092 端口来操作 Kafka（比如发送 / 接收消息、管理主题等），核心原因是 Kafka 不支持 HTTP 协议（浏览器默认使用 HTTP/HTTPS 协议），它采用的是自定义的二进制协议（基于 TCP），浏览器无法解析这种协议，自然无法直接交互。**

**为什么浏览器无法访问 Kafka？**

1. **协议不兼容**  
   浏览器的核心功能是通过 HTTP/HTTPS 协议与服务器通信（比如访问网页、调用 API），而 Kafka 基于 TCP 实现了一套自定义二进制协议，用于处理消息生产、消费、主题管理等操作，两者协议完全不同，浏览器无法识别 Kafka 的协议格式。
2. **Kafka 无 Web 界面**  
   Kafka 本身是一个 “后端消息中间件”，默认没有内置 Web 管理界面或 HTTP 接口，不像 Nginx、Tomcat 那样可以通过浏览器访问默认页面。即使你在浏览器中输入 `http://Linux服务器IP:9092`，也只会得到 “连接失败” 或 “无法访问” 的提示。

与 Kafka 不同，**RabbitMQ 默认支持通过浏览器访问**—— 因为它内置了一个官方的 Web 管理界面（`RabbitMQ Management Plugin`），该界面基于 HTTP 协议提供服务，浏览器可以直接解析和交互。下面详细说明如何通过浏览器访问 RabbitMQ，以及相关配置和操作。



