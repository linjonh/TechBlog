---
layout: post
title: "TCP三次握手,四次挥手多进程多线程实现并发服务器"
date: 2025-03-08 22:21:57 +0800
description: "SYN、ACK是TCP协议头里面的标志位同步仅在三次握手建立 TCP 连接时有效。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN = 1 和 ACK = 1。因此，SYN 置1 就表示这是一个连接请求或连接接受报文ACK：确认 ACK：仅当 ACK=1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须把 ACK 置1ack。"
keywords: "TCP三次握手，四次挥手；多进程、多线程实现并发服务器"
categories: ['八股', 'Linux']
tags: ['网络', '服务器', 'Tcp']
artid: "146120842"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146120842
    alt: "TCP三次握手,四次挥手多进程多线程实现并发服务器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146120842
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146120842
cover: https://bing.ee123.net/img/rand?artid=146120842
image: https://bing.ee123.net/img/rand?artid=146120842
img: https://bing.ee123.net/img/rand?artid=146120842
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     TCP三次握手，四次挥手；多进程、多线程实现并发服务器
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     三次握手，四次挥手
    </h2>
    <h3>
     <a id="_1">
     </a>
     三次握手示意图：
    </h3>
    <p>
     SYN、ACK是TCP协议头里面的标志位
     <br/>
     同步
     <code>
      SYN：
     </code>
     仅在三次握手建立 TCP 连接时有效。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN = 1 和 ACK = 1。因此，SYN 置1 就表示这是一个连接请求或连接接受报文
     <br/>
     <code>
      ACK
     </code>
     ：确认 ACK：仅当 ACK=1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须把 ACK 置1
     <br/>
     <code>
      ack
     </code>
     是32位确认号，期望收到对方下一个报文段的第一个数据字节的序号每当有ACK了，确认号都要加一
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/401f168bd10b4a8ba4239bd7fff61a7d.png"/>
    </p>
    <p>
     <strong>
      客户端: CLOSED -&gt; SYN-SEND -&gt; ESTABLISHED
      <br/>
      服务端：CLOSED -&gt; LISTEN -&gt; SYN-RECV -&gt; ESTABLISHED
     </strong>
    </p>
    <h4>
     <a id="_10">
     </a>
     为什么不能是其他次数？
    </h4>
    <p>
     通信双方都要知道对方具备发送和接受的能力，这样才是一个良好的关系
     <br/>
     两次可能会导致资源的浪费，因为服务器不知晓发送端是否具有接收信息的能力，所以每一次接收信息他都会发一个确认收到和请求SYN的信息。
     <br/>
     四次是可以的，只是会造成资源的浪费，最后优化成三次
    </p>
    <h3>
     <a id="_14">
     </a>
     四次挥手示意图
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1b83babddf4c462e924cc17036422be3.png">
      <br/>
      无论是hi哪一方都可以主动发出断开连接
      <br/>
      断开连接的一方 ： FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT
      <br/>
      被断开的一方：CLOSE_WAIT -&gt; LAST_ACK
     </img>
    </p>
    <h4>
     <a id="_20">
     </a>
     为什么不能是其他次数？
    </h4>
    <p>
     TCP是全双工通信，可以双向传输数据，任何一方都可以再数据传送结束之后发出连接释放的通知，待接收方确认之后进入半关闭状态。这会可能接收方还有信息要发给请求断链方，因此还没有向对方发一个“我也请求断链”的消息。当接收方发的东西发完之后，接收方就可以向请求断联方发FIN“我要断开”的消息，主动断开连接的一方，最后会进入一个
     <code>
      TIME_WAIT
     </code>
     状态，这个状态会持续
     <code>
      2msl
     </code>
    </p>
    <h4>
     <a id="2ml_22">
     </a>
     为什么要等2ml?
    </h4>
    <p>
     当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方必须处于TIME_WAIT 状态并持续 2MSL 时间这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。因为被断的一方如果没收到主动断一方的最后一个ACK的话，会再次发送一次FIN，这个时间就是留在这里用的。如果不等，一方结束了另一方没结束，那么就一直浪费资源
    </p>
    <h2>
     <a id="TCP_25">
     </a>
     TCP的流量控制
    </h2>
    <ul>
     <li>
      <code>
       滑动窗口
      </code>
      是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构
     </li>
     <li>
      TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着
      <strong>
       接收方还有多大的缓冲区可以用于接收数据
      </strong>
      。
      <strong>
       发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据
      </strong>
      。当滑动窗口为 0时，发送方一般不能再发送数据报
      <br/>
      <strong>
       滑动窗口可以理解为缓冲区
      </strong>
      <br/>
      这个滑动窗门主要是接收方来用的。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/db86107700664e23a9556b29e9362657.png"/>
     </li>
    </ul>
    <h2>
     <a id="TCP_32">
     </a>
     TCP通信实例图：
    </h2>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2c740671366744e098a3223b366d86a2.png">
      <br/>
      win就代表接收方的滑动窗口还有多少空余可以接受的地方，这样发送方也能对应调整
     </img>
    </p>
    <h2>
     <a id="TCP_35">
     </a>
     TCP通信并发
    </h2>
    <h3>
     <a id="_36">
     </a>
     要点
    </h3>
    <ol>
     <li>
      利用多线程或者多进程的方式，实现多个客户端对服务器的访问操作，每次一有客户端连接，就创建新的进程或者线程
     </li>
     <li>
      回收资源，利用信号SIGCHILD+waitpid实现，在循环while(1)内部
     </li>
     <li>
      当每次释放进程资源的时候，会使得创建新进程的while（1)里面的accept被信号软中断，这会导致这个的accept出错，这个时候需要设置当errorno=ENTER的时候，再重新选换一次创建一个新的accept等待阻塞
     </li>
    </ol>
    <h3>
     <a id="_41">
     </a>
     多进程开发
    </h3>
    <h4>
     <a id="_42">
     </a>
     遇到的问题，及解决
    </h4>
    <ul>
     <li>
      断开连接后，服务器端如何处理子进程，回收资源？
      <ul>
       <li>
        使用信号处理
       </li>
      </ul>
     </li>
     <li>
      使用信号捕捉回收子进程资源后，出现服务端
      <code>
       accept: Interrupted system call
      </code>
      ，且不能有新客户端连接，如何解决？
      <ul>
       <li>
        产生
        <code>
         EINTR
        </code>
        信号，具体说明通过
        <code>
         man 2 accept
        </code>
        查看
       </li>
       <li>
        在
        <code>
         accept
        </code>
        返回值处进行判断处理，不输出错误即可
       </li>
      </ul>
     </li>
     <li>
      当停止所有的客户端连接后，出现
      <code>
       read: Connection reset by peer
      </code>
      ，如何解决？
      <ul>
       <li>
        产生的原因：连接断开后的读和写操作引起的
       </li>
       <li>
        简单修改：将客户端中休眠语句的位置进行更改
       </li>
       <li>
        方法：
        <a href="https://blog.csdn.net/xc_zhou/article/details/80950753">
         [261]Connection reset by peer的常见原因及解决办法
        </a>
       </li>
      </ul>
     </li>
     <li>
      解决上一个问题后，服务端出现两次
      <code>
       client closed...
      </code>
      ，如何解决？
      <ul>
       <li>
        是因为在关闭连接后，应该退出循环，所以在该
        <code>
         printf
        </code>
        语句后，添加
        <code>
         break
        </code>
        即可
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_55">
     </a>
     多线程开发
    </h3>
    <h4>
     <a id="_56">
     </a>
     思路
    </h4>
    <ul>
     <li>
      <p>
       服务端使用一个主线程，多个子线程
      </p>
      <ul>
       <li>
        <p>
         主线程负责等待并接受客户端的连接
        </p>
       </li>
       <li>
        <p>
         子线程：完成通信，接受一个客户端连接，就创建一个子进程用于通信
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       客户端不需要改变（同一对一通信）
      </p>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f6879645f617368656c792f:61727469636c652f64657461696c732f313436313230383432" class_="artid" style="display:none">
 </p>
</div>


