---
layout: post
title: "音视频入门基础RTP专题16RTP封装音频时,音频的有效载荷结构"
date: 2025-03-09 12:21:12 +0800
description: "RTP封装音频时，音频的有效载荷结构"
keywords: "音视频入门基础：RTP专题（16）——RTP封装音频时，音频的有效载荷结构"
categories: ['音视频技术']
tags: ['音视频']
artid: "146115481"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146115481
    alt: "音视频入门基础RTP专题16RTP封装音频时,音频的有效载荷结构"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146115481
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146115481
cover: https://bing.ee123.net/img/rand?artid=146115481
image: https://bing.ee123.net/img/rand?artid=146115481
img: https://bing.ee123.net/img/rand?artid=146115481
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     音视频入门基础：RTP专题（16）——RTP封装音频时，音频的有效载荷结构
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、引言
    </h2>
    <p>
     《RFC 3640》和《RFC 6416》分别定义了两种对MPEG-4流的RTP封包方式，这两个文档都可以从RFC官网下载：
     <a href="https://www.rfc-editor.org/" rel="nofollow" title="» RFC Editor">
      » RFC Editor
     </a>
    </p>
    <p>
     本文主要对《RFC 3640》中的音频打包方式进行简介。《RFC 3640》总共有43页，本文下面所说的“页数”是指在pdf阅读器中显示的页数：
    </p>
    <p>
     <img alt="" height="226" src="https://i-blog.csdnimg.cn/direct/6421a5bd762a4a3ab9481f0484274c27.png" width="396"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     二、MPEG Access Units
    </h2>
    <p>
     根据《RFC 3640》第5页，为了传输压缩后的音视频数据，MPEG定义了Access Units（访问单元）。MPEG Access Units（简称AU）是计时信息的最小数据实体。就音频而言，一个AU可代表一个音频帧，就视频而言，一个AU可代表一幅图像。根据定义，MPEG Access Units是八位对齐的。例如，如果音频帧不是八进制对齐的，则必须在帧末插入多达 7个零的填充位，以实现MPEG-4规范要求的八进制对齐的AU。
     <br/>
     MPEG-4解码器必须能够解码使用了这种填充的AU。与MPEG-4规范一致，《RFC 3640》要求每个 MPEG-4第2部分视频的AU包括图像的所有编码数据、编码图像数据之前的任何视频流标题以及其后的任何视频流填充，直至但不包括表示新视频流或下一个AU开始的开始码：
    </p>
    <p>
     <img alt="" height="452" src="https://i-blog.csdnimg.cn/direct/2ceca2c309e74283a8078792a0638cd3.png" width="939"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     三、有效载荷格式的全局结构
    </h2>
    <p>
     根据《RFC 3640》第9页，RTP Header之后的RTP payload包含三个八位对齐的数据部分，其中前两个（AU Header Section和Auxiliary Section）可能为空，如下图所示。
    </p>
    <p>
     第一部分是AU (Access Unit) Header Section，包含一个或多个AU-header；但是，每个AU-header可以是空的，在这种情况下，整个AU Header Section都是空的。
    </p>
    <p>
     第二部分是Auxiliary Section（辅助部分），包含辅助数据；该部分也可以配置为空。
    </p>
    <p>
     第三部分是Access Unit Data Section，包含一个Access Unit的单个片段或一个或多个完整的Access Unit。Access Unit Data Section不得为空：
    </p>
    <p>
     <img alt="" height="550" src="https://i-blog.csdnimg.cn/direct/a27b0469bb074418aacb5032ed959b41.png" width="934"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     四、AU Header Section
    </h2>
    <p>
     根据《RFC 3640》第11页，出现时，AU Header Section由AU-headers-length字段和若干AU-header组成，如下图所示。
    </p>
    <p>
     AU-header使用MIME格式参数配置，可以为空。如果AU-header配置为空，则AU-headers-length字段不应存在，因此AU Header Section为空。如果AU-header未配置为空，则AU报头长度（AU-headers-length）是占两个字节的字段，用于指定紧随其后的AU-header（不包括填充位）的长度（以比特为单位）。
    </p>
    <p>
     每个AU-header都与同一RTP数据包中Access Unit Data Section所含的single Access Unit (fragment)相关联。在AU-header中，AU-header按照 Access Unit Data Section中包含Access Unit的顺序逐位连接。因此，第n个AU-header指的是第n个 AU（片段）。如果连接的 AU-header占用的八进制数不是整数，则必须在末尾插入最多7个零填充位，以实现 AU Header部分的八进制对齐：
    </p>
    <p>
     <img alt="" height="496" src="https://i-blog.csdnimg.cn/direct/958ca9d4d10a454686f15d20671fa02f.png" width="937"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     五、AU-header
    </h2>
    <p>
     根据《RFC 3640》第12页，每个AU-header可包含下图所示的字段。除CTS-flag、DTS-flag和RAP-flag字段外，其他字段的比特长度由MIME格式参数定义。如果MIME格式参数的默认值为零，则不存在相关字段。对于存在且表示参数值的字段，必须选择足够大的比特数，以正确编码会话期间该参数的最大值。
    </p>
    <p>
     如果存在，这些字段必须按照下图所示的顺序出现。在一般情况下，由于CTS-delta和DTS-delta 字段的是否存在分别由CTS-flag和DTS-flag的值指示，因此接收方只能通过解析AU-header来发现 AU-header的大小。
    </p>
    <p>
     如果被使用，AU-header中的AU-Index字段只出现在AU Header Section中的第一个AU-header中；在任何其他 AU-header中，则使用AU-Index-delta字段：
    </p>
    <p>
     <img alt="" height="406" src="https://i-blog.csdnimg.cn/direct/99d537c5855844f7bdf53a7452127b41.png" width="550"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     其中：
    </p>
    <p>
     <strong>
      AU-size
     </strong>
     ： 该字段表示同一RTP数据包中Access Unit Data Section中相关Access Unit的大小（以八位字节为单位）。当 AU-size与 AU fragment（AU片段）相关联时，AU-size表示整个AU的大小，而不是片段的大小。在这种情况下，片段的大小可以通过AU data section的大小得知。可以利用这一点来确定数据包包含的是整个AU还是片段，这在丢失携带AU最后一个片段的数据包后特别有用：
    </p>
    <p>
     <img alt="" height="194" src="https://i-blog.csdnimg.cn/direct/43cd0ad9fdb448e095e79c2aaa4ec38d.png" width="881"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      AU-Index
     </strong>
     ：该字段表示相关Access Unit（片段）的序列号。对于每个（按解码顺序）连续的AU 或AU片段，序列号都递增1。AU-Index字段出现在AU Header Section的第一个AU-header中，但不得出现在该Section的任何后续（非第一个）AU-header中。要对任何此类非第一个 AU-header中的序列号进行编码，应使用AU-Index-delta字段：
    </p>
    <p>
     <img alt="" height="173" src="https://i-blog.csdnimg.cn/direct/4bf17e0f37e7411fb5269c83e3009893.png" width="888"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      AU-Index-delta
     </strong>
     ：该字段是一个无符号整数，用于指定相关AU的序列号与前一个接入单元序列号的差值。因此，对于第n个（n&gt;1）AU，序列号的计算公式为：
    </p>
    <p>
     AU-Index(n) = AU-Index(n-1) + AU-Index-delta(n) + 1
    </p>
    <p>
     如果AU-Index字段出现在AU Header Section的第一个AU-header中，则AU-Index-delta字段必须出现在任何后续（非第一个）AU-header中。当AU-Index-delta的编码值为0时，表示Access Units在解码顺序上是连续的。如果 AU-Index-delta 值大于0，则表示应用了交错：
    </p>
    <p>
     <img alt="" height="311" src="https://i-blog.csdnimg.cn/direct/6b2d12dada7e4e228d78a5681c88bb87.png" width="899"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      CTS-flag
     </strong>
     ：该字段表示是否存在CTS-delta字段。值为1表示存在该字段，值为0表示不存在。如果 CTS-delta字段的信号长度大于零，则每个AU-header中必须有CTS-flag字段。在这种情况下，CTS-flag字段在第一个AU-header中的值必须为0，在所有非第一个AU-header中的值可以为1。对于Access Unit的任何非第一片段，CTS-flag字段应为0：
    </p>
    <p>
     <img alt="" height="239" src="https://i-blog.csdnimg.cn/direct/af61ff1faec546c2978b053fa7686bcd.png" width="897"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      CTS-delta
     </strong>
     ：该字段将CTS的值指定为该RTP数据包RTP header中时间戳的2的补码偏移（delta），从而对CTS进行编码。CTS必须使用与RTP header中时间戳相同的时钟速率：
    </p>
    <p>
     <img alt="" height="104" src="https://i-blog.csdnimg.cn/direct/7053924470174ebba7d5ba3314ba0b82.png" width="884"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      DTS-flag
     </strong>
     ：表示是否存在DTS-delta字段。值为1表示存在DTS-delta，值为0表示不存在。如果 DTS-delta字段的长度信号大于零，则 DTS-flag字段必须出现在每个AU-header中。一个Access Unit的所有片段的 DTS-flag字段必须具有相同的值：
    </p>
    <p>
     <img alt="" height="199" src="https://i-blog.csdnimg.cn/direct/1ee098d17db44343a2bc15bb79704f42.png" width="890"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      DTS-delta
     </strong>
     ：该字段将DTS的值指定为CTS的2的补码偏移（delta）。DTS必须使用与RTP header中时间戳相同的时钟速率。对于Access Unit的所有片段，DTS-delta字段必须具有相同的值：
    </p>
    <p>
     <img alt="" height="109" src="https://i-blog.csdnimg.cn/direct/e2676bbf350148e0b6be798872e8bc36.png" width="892"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      RAP-flag
     </strong>
     ：该字段设置为1时，表示相关的Access Unit为数据流内容提供了一个随机访问点。如果访问单元是分片的，则RAP flag（如果存在）必须为AU的每个非第一分片设置 0：
    </p>
    <p>
     <img alt="" height="114" src="https://i-blog.csdnimg.cn/direct/bd960f290d374755affce60f22c4c383.png" width="859"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      Stream-state
     </strong>
     ：指定MPEG-4系统流的AU的流状态；每个状态由一个模数计数器的值标识。在 《ISO/IEC 14496-1》中，MPEG-4系统流使用AU_SequenceNumber来表示流状态。当流状态改变时，流状态的值必须递增 1。
     <br/>
     注意：不同流的流状态之间不需要任何关系：
    </p>
    <p>
     <img alt="" height="189" src="https://i-blog.csdnimg.cn/direct/f93ddd382bb847878d51085c011a8be6.png" width="910"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     六、The Auxiliary Section
    </h2>
    <p>
     根据《RFC 3640》第14页，Auxiliary Section（辅助部分）由auxiliary-data-size字段和auxiliary-data（辅助数据）字段组成。接收者可以（但不要求）解析auxiliary-data字段；为便于接收者跳过auxiliary-data字段，auxiliary-data-size字段表示auxiliary-data的长度（以比特为单位）。如果 “auxiliary-data-size ”和 “auxiliary-data”字段的连接占用的八进制数不是整数，则必须在auxiliary data后插入最多 7个零填充位，以实现八进制对齐，见下图：
    </p>
    <p>
     <img alt="" height="135" src="https://i-blog.csdnimg.cn/direct/3a07c802b4f84e70b927ea68a28751e1.png" width="810"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     auxiliary-data-size字段的位数可以通过MIME格式参数配置。默认长度为0表示整个Auxiliary Section（辅助段）都不存在。
     <br/>
     auxiliary-data-size字段指定紧随其后的auxiliary-data字段的长度，以位（bit）为单位；auxiliary-data（辅助数据）字段包含的数据格式不是《RFC 3640》规范定义的。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     七、Access Unit Data Section
    </h2>
    <p>
     根据《RFC 3640》第15页，Access Unit Data Section（访问单元数据节）包含完整的Access Unit（访问单元）的整数或一个AU的单个片段。Access Unit Data Section绝不是空的。如果存在多个Access Unit的数据，则将AU连接成一个连续的八位字节字符串。参见下图。Access Unit Data Section内的AU必须按解码顺序排列，但在交错的情况下不一定是连续的。
    </p>
    <p>
     应该调整Access Unit的大小和数量，使生成的RTP包不大于途径的MTU。为了处理较大的数据包，这种有效负载格式依赖于较低的分片层，这可能会导致性能降低：
    </p>
    <p>
     <img alt="" height="365" src="https://i-blog.csdnimg.cn/direct/9b647774d58849c3a708515fa87f99fd.png" width="857"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     当携带多个Access Unit时，每个AU的大小必须提供给接收器。如果AU的大小是可变的，那么每个AU的大小必须在相应AU-header的AU-size字段中显示。但是，如果流的AU大小是恒定的，则不应该使用该机制；相反，固定大小应该通过MIME格式参数“constantSize”来表示。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031343535323130322f:61727469636c652f64657461696c732f313436313135343831" class_="artid" style="display:none">
 </p>
</div>


