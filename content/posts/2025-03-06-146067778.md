---
layout: post
title: "RabbitMQ知识点"
date: 2025-03-06 15:34:55 +0800
description: "资料"
keywords: "RabbitMQ知识点"
categories: ['未分类']
tags: ['分布式', 'Rabbitmq']
artid: "146067778"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146067778
    alt: "RabbitMQ知识点"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146067778
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146067778
cover: https://bing.ee123.net/img/rand?artid=146067778
image: https://bing.ee123.net/img/rand?artid=146067778
img: https://bing.ee123.net/img/rand?artid=146067778
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ知识点
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.为什么需要消息队列？
    </h2>
    <p>
     <img alt="" height="332" src="https://i-blog.csdnimg.cn/direct/150f4d74fcf9483d80a9749be83a13e6.png" width="738"/>
    </p>
    <p>
     <img alt="" height="349" src="https://i-blog.csdnimg.cn/direct/c41d7f9da28b4ab4ab79f0e64fcde6be.png" width="707"/>
    </p>
    <p>
     <img alt="" height="389" src="https://i-blog.csdnimg.cn/direct/a8c06c06fc6e4c4298acca1031758175.png" width="722"/>
    </p>
    <p>
     <img alt="" height="360" src="https://i-blog.csdnimg.cn/direct/0783a34bf6164eddbcdc1887535e4ce6.png" width="683"/>
    </p>
    <p>
     <img alt="" height="390" src="https://i-blog.csdnimg.cn/direct/76e9f2512e794cee870dc6983bb3628a.png" width="750"/>
    </p>
    <p>
     <img alt="" height="319" src="https://i-blog.csdnimg.cn/direct/f662db467b2a43748d33a248195d959c.png" width="692"/>
    </p>
    <p>
     <img alt="" height="373" src="https://i-blog.csdnimg.cn/direct/092e1b8e8ed14bc9969abd324f501a00.png" width="742"/>
    </p>
    <p>
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/495ad5193fad4c69965301cba647eec4.png" width="725"/>
    </p>
    <p>
     <img alt="" height="375" src="https://i-blog.csdnimg.cn/direct/e6c948d1105748749709297cd977a759.png" width="723"/>
    </p>
    <p>
     <img alt="" height="389" src="https://i-blog.csdnimg.cn/direct/18f84b24faf74ddea11f00e05ca0071f.png" width="724"/>
    </p>
    <p>
     <img alt="" height="366" src="https://i-blog.csdnimg.cn/direct/87d0c39fb38f4c19a5e678478d6576ef.png" width="707"/>
    </p>
    <p>
     <img alt="" height="389" src="https://i-blog.csdnimg.cn/direct/504ab9fca2724b6eb8591ef6b9dd6ecc.png" width="766"/>
     <img alt="" height="395" src="https://i-blog.csdnimg.cn/direct/df852a7a092642da851c35df98db2406.png" width="729"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      RabbitMQ体系结构
     </strong>
    </p>
    <h2>
     <img alt="" height="1016" src="https://i-blog.csdnimg.cn/direct/45d9256b81964fa5a3f5f1b2c402a28e.png" width="1773"/>
    </h2>
    <h2>
     操作001：RabbitMQ安装
    </h2>
    <h2>
     二、安装
    </h2>
    <pre><code class="language-bash"># 拉取镜像
docker pull rabbitmq:3.13-management
​
# -d 参数：后台运行 Docker 容器
# --name 参数：设置容器名称
# -p 参数：映射端口号，格式是“宿主机端口号:容器内端口号”。5672供客户端程序访问，15672供后台管理界面访问
# -v 参数：卷映射目录
# -e 参数：设置容器内的环境变量，这里我们设置了登录RabbitMQ管理后台的默认用户和密码
docker run -d \
--name rabbitmq \
-p 5672:5672 \
-p 15672:15672 \
-v rabbitmq-plugin:/plugins \
-e RABBITMQ_DEFAULT_USER=guest \
-e RABBITMQ_DEFAULT_PASS=123456 \
rabbitmq:3.13-management</code></pre>
    <h2>
     二、验证
    </h2>
    <p>
     访问后台管理界面：
     <a href="http://192.168.200.100:15672/" rel="nofollow" title="http://192.168.200.100:15672">
      http://192.168.200.100:15672
     </a>
    </p>
    <p>
     使用上面创建Docker容器时指定的默认用户名、密码登录：
    </p>
    <p>
     <img alt="" height="285" src="https://i-blog.csdnimg.cn/direct/e88c908ba2b34bcd9fb208a7a2c22904.png" width="627"/>
    </p>
    <h2>
     三、可能的问题
    </h2>
    <h3>
     1、问题现象
    </h3>
    <p>
     在使用Docker拉取RabbitMQ镜像的时候，如果遇到提示：missing signature key，那就说明Docker版本太低了，需要升级
    </p>
    <p>
     比如我目前的Docker版本如下图所示：
    </p>
    <p>
    </p>
    <h3>
     2、解决办法
    </h3>
    <blockquote>
     <p>
      基于CentOS7
     </p>
    </blockquote>
    <h4>
     ①卸载当前Docker
    </h4>
    <p>
     更好的办法是安装Docker前曾经给服务器拍摄了快照，此时恢复快照；
    </p>
    <p>
     如果不曾拍摄快照，那只能执行卸载操作了
    </p>
    <pre>yum erase -y docker \
    docker-client \
    docker-client-latest \
    docker-common \
    docker-latest \
    docker-latest-logrotate \
    docker-logrotate \
    docker-selinux \
    docker-engine-selinux \
    docker-engine \
    docker-ce</pre>
    <p>
    </p>
    <h4>
     ②升级yum库
    </h4>
    <pre>yum update -y</pre>
    <p>
    </p>
    <h4>
     ③安装Docker最新版
    </h4>
    <pre>yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</pre>
    <p>
    </p>
    <p>
     如果这一步看到提示：没有可用软件包 docker-ce，那就添加Docker的yum源：
    </p>
    <pre>yum install -y yum-utils
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</pre>
    <p>
    </p>
    <h4>
     ④设置Docker服务
    </h4>
    <pre>systemctl start docker
systemctl enable docker</pre>
    <p>
    </p>
    <h3>
     3、验证
    </h3>
    <p>
     上述操作执行完成后，再次查看Docker版本：
    </p>
    <h2>
     操作002：HelloWorld
    </h2>
    <h2>
     一、目标
    </h2>
    <p>
     生产者发送消息，消费者接收消息，用最简单的方式实现
    </p>
    <p>
     官网说明参见下面超链接：
    </p>
    <p>
     <a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html" rel="nofollow" title='RabbitMQ tutorial - "Hello World!" — RabbitMQ'>
      RabbitMQ tutorial - "Hello World!" — RabbitMQ
     </a>
    </p>
    <p>
     <img alt="" height="128" src="https://i-blog.csdnimg.cn/direct/cb68acbe516141cab52473e23c850a07.png" width="703"/>
    </p>
    <p>
    </p>
    <h2>
     二、具体操作
    </h2>
    <h3>
     1、创建Java工程
    </h3>
    <h4>
     ①消息发送端（生产者）
    </h4>
    <p>
     <img alt="" height="438" src="https://i-blog.csdnimg.cn/direct/34438b841e6e49e8ab24736011b44254.png" width="790"/>
    </p>
    <p>
    </p>
    <h4>
     ②消息接收端（消费者）
    </h4>
    <p>
     <img alt="" height="445" src="https://i-blog.csdnimg.cn/direct/087206682ca4422a9446cd51478e2744.png" width="799"/>
    </p>
    <h4>
     ③添加依赖
    </h4>
    <pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
        &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
        &lt;version&gt;5.20.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h3>
     2、发送消息
    </h3>
    <h4>
     ①Java代码
    </h4>
    <p>
     不用客气，整个代码全部复制——当然，连接信息改成你自己的：
    </p>
    <pre><code class="language-java">package com.atguigu.rabbitmq.simple;  
  
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
  
public class Producer {  
  
    public static void main(String[] args) throws Exception {  
  
        // 创建连接工厂  
        ConnectionFactory connectionFactory = new ConnectionFactory();  
  
        // 设置主机地址  
        connectionFactory.setHost("192.168.200.100");  
  
        // 设置连接端口号：默认为 5672
        connectionFactory.setPort(5672);
  
        // 虚拟主机名称：默认为 /
        connectionFactory.setVirtualHost("/");
  
        // 设置连接用户名；默认为guest  
        connectionFactory.setUsername("guest");
  
        // 设置连接密码；默认为guest  
        connectionFactory.setPassword("123456");
  
        // 创建连接  
        Connection connection = connectionFactory.newConnection();  
  
        // 创建频道  
        Channel channel = connection.createChannel();  
  
        // 声明（创建）队列  
        // queue      参数1：队列名称  
        // durable    参数2：是否定义持久化队列，当 MQ 重启之后还在  
        // exclusive  参数3：是否独占本次连接。若独占，只能有一个消费者监听这个队列且 Connection 关闭时删除这个队列  
        // autoDelete 参数4：是否在不使用的时候自动删除队列，也就是在没有Consumer时自动删除  
        // arguments  参数5：队列其它参数  
        channel.queueDeclare("simple_queue", true, false, false, null);  
  
        // 要发送的信息  
        String message = "你好；小兔子！";  
  
        // 参数1：交换机名称,如果没有指定则使用默认Default Exchange  
        // 参数2：路由key,简单模式可以传递队列名称  
        // 参数3：配置信息  
        // 参数4：消息内容  
        channel.basicPublish("", "simple_queue", null, message.getBytes());  
  
        System.out.println("已发送消息：" + message);  
  
        // 关闭资源  
        channel.close();  
        connection.close();  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h4>
     ②查看效果
    </h4>
    <p>
     <img alt="" height="645" src="https://i-blog.csdnimg.cn/direct/6a011e7701f24cc39e7f3e189f5b65f9.png" width="1430"/>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="1285" src="https://i-blog.csdnimg.cn/direct/fb90a9bf383c4665aec48ee2f4493d07.png" width="1405"/>
    </p>
    <p>
    </p>
    <h3>
     3、接收消息
    </h3>
    <h4>
     ①Java代码
    </h4>
    <p>
     不用客气，整个代码全部复制——当然，连接信息改成你自己的：
    </p>
    <pre><code class="language-java">package com.atguigu.rabbitmq.simple;  
  
import com.rabbitmq.client.*;  
  
import java.io.IOException;  
  
public class Consumer {  
  
    public static void main(String[] args) throws Exception {  
  
        // 1.创建连接工厂  
        ConnectionFactory factory = new ConnectionFactory();  
  
        // 2. 设置参数  
        factory.setHost("192.168.200.100");  
        factory.setPort(5672);  
        factory.setVirtualHost("/");  
        factory.setUsername("guest");
        factory.setPassword("123456");  
  
        // 3. 创建连接 Connection        
        Connection connection = factory.newConnection();  
  
        // 4. 创建Channel  
        Channel channel = connection.createChannel();  
  
        // 5. 创建队列  
        // 如果没有一个名字叫simple_queue的队列，则会创建该队列，如果有则不会创建  
        // 参数1. queue：队列名称  
        // 参数2. durable：是否持久化。如果持久化，则当MQ重启之后还在  
        // 参数3. exclusive：是否独占。  
        // 参数4. autoDelete：是否自动删除。当没有Consumer时，自动删除掉  
        // 参数5. arguments：其它参数。  
        channel.queueDeclare("simple_queue",true,false,false,null);  
  
        // 接收消息  
        DefaultConsumer consumer = new DefaultConsumer(channel){  
  
            // 回调方法,当收到消息后，会自动执行该方法  
            // 参数1. consumerTag：标识  
            // 参数2. envelope：获取一些信息，交换机，路由key...  
            // 参数3. properties：配置信息  
            // 参数4. body：数据  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("consumerTag："+consumerTag);  
                System.out.println("Exchange："+envelope.getExchange());  
                System.out.println("RoutingKey："+envelope.getRoutingKey());  
                System.out.println("properties："+properties);  
                System.out.println("body："+new String(body));  
  
            }  
  
        };  
  
        // 参数1. queue：队列名称  
        // 参数2. autoAck：是否自动确认，类似咱们发短信，发送成功会收到一个确认消息  
        // 参数3. callback：回调对象  
        // 消费者类似一个监听程序，主要是用来监听消息  
        channel.basicConsume("simple_queue",true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h4>
     ②控制台打印
    </h4>
    <blockquote>
     <p>
      consumerTag：amq.ctag-8EB87GaZFP52LKSMcj98UA Exchange： RoutingKey：simple_queue properties：#contentHeader&lt;basic&gt;(content-type=null, content-encoding=null, headers=null, delivery-mode=null, priority=null, correlation-id=null, reply-to=null, expiration=null, message-id=null, timestamp=null, type=null, user-id=null, app-id=null, cluster-id=null) body：你好；小兔子！
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     ③查看后台管理界面
    </h4>
    <p>
     因为消息被消费掉了，所以RabbitMQ服务器上没有了：
    </p>
    <p>
     <img alt="" height="500" src="https://i-blog.csdnimg.cn/direct/7f015440feab4ae2862cbe4d40d4d32b.png" width="1400"/>
    </p>
    <p>
    </p>
    <h2>
     操作003：工作队列模式
    </h2>
    <p>
     Work Queues 本质上我们刚刚写的HelloWorld程序就是这种模式，只是简化到了最简单的情况：• 生产者只有一个 • 发送一个消息 • 消费者也只有一个，消息也只能被这个消费者消费所以HelloWorld也称为简单模式。 现在我们还原一下常规情况： • 生产者发送多个消息 • 由多个消费者来竞争 • 谁抢到算谁的
    </p>
    <p>
     结论： • 多个消费者监听同一个队列，则各消费者之间对同一个消息是竞争的关系。• Work Queues工作模式适用于任务较重或任务较多的情况，多消费者分摊任务可以提高消息处理的效率。
    </p>
    <p>
     <img alt="" height="263" src="https://i-blog.csdnimg.cn/direct/a0ca652883b04a428d68891a0c8c989b.png" width="659"/>
    </p>
    <h2>
     一、生产者代码
    </h2>
    <h3>
     1、封装工具类
    </h3>
    <pre><code class="language-java">package com.atguigu.rabbitmq.util;  
  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
  
public class ConnectionUtil {  
  
    public static final String HOST_ADDRESS = "192.168.200.100";  
  
    public static Connection getConnection() throws Exception {  
  
        // 定义连接工厂  
        ConnectionFactory factory = new ConnectionFactory();  
  
        // 设置服务地址  
        factory.setHost(HOST_ADDRESS);  
  
        // 端口  
        factory.setPort(5672);  
  
        //设置账号信息，用户名、密码、vhost  
        factory.setVirtualHost("/");  
        factory.setUsername("guest");  
        factory.setPassword("123456");  
  
        // 通过工程获取连接  
        Connection connection = factory.newConnection();  
  
        return connection;  
    }  
  
  
  
    public static void main(String[] args) throws Exception {  
  
        Connection con = ConnectionUtil.getConnection();  
  
        // amqp://guest@192.168.200.100:5672/  
        System.out.println(con);  
  
        con.close();  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h3>
     2、编写代码
    </h3>
    <pre><code class="language-java">package com.atguigu.rabbitmq.work;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
  
public class Producer {  
  
    public static final String QUEUE_NAME = "work_queue";  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        channel.queueDeclare(QUEUE_NAME,true,false,false,null);  
  
        for (int i = 1; i &lt;= 10; i++) {  
  
            String body = i+"hello rabbitmq~~~";  
  
            channel.basicPublish("",QUEUE_NAME,null,body.getBytes());  
  
        }  
  
        channel.close();  
  
        connection.close();  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h3>
     3、发送消息效果
    </h3>
    <p class="img-center">
     <img alt="img" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimg60-1698977979067-1.png%3FlastModify%3D1741251027&amp;pos_id=Q9NXaLQs" width="534"/>
    </p>
    <p>
    </p>
    <h2>
     二、消费者代码
    </h2>
    <h3>
     1、编写代码
    </h3>
    <p>
     创建Consumer1和Consumer2。Consumer2只是类名和打印提示不同，代码完全一样。
    </p>
    <pre><code class="language-java">package com.atguigu.rabbitmq.work;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
  
import java.io.IOException;  
  
public class Consumer1 {  
  
    static final String QUEUE_NAME = "work_queue";  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        channel.queueDeclare(QUEUE_NAME,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("Consumer1 body："+new String(body));  
  
            }  
  
        };  
  
        channel.basicConsume(QUEUE_NAME,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
     <strong>
      注意
     </strong>
     ：运行的时候先启动两个消费端程序，然后再启动生产者端程序。 如果已经运行过生产者程序，则手动把work_queue队列删掉。
    </p>
    <p>
    </p>
    <h3>
     2、运行效果
    </h3>
    <p>
     最终两个消费端程序竞争结果如下：
    </p>
    <p class="img-center">
     <img alt="image-20231103103841644" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimage-20231103103841644.png%3FlastModify%3D1741251027&amp;pos_id=mqdIFQA2" width="534"/>
    </p>
    <p>
    </p>
    <h2>
     操作004：发布订阅模式
    </h2>
    <p>
     <img alt="" height="252" src="https://i-blog.csdnimg.cn/direct/0793eca6c4964ac7a520552c8833273b.png" width="930"/>
    </p>
    <p>
     生产者不是把消息直接发送到队列，而是发送到交换机
    </p>
    <p>
     • 交换机接收消息，而如何处理消息取决于交换机的类型• 交换机有如下3种常见类型
    </p>
    <p>
     • Fanout：广播，将消息发送给所有绑定到交换机的队列
    </p>
    <p>
     • Direct：定向，把消息交给符合指定routing key的队列
    </p>
    <p>
     • Topic：通配符，把消息交给符合routing pattern（路由模式）的队列
    </p>
    <p>
     • 注意：Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！
    </p>
    <p>
     组件之间关系：
    </p>
    <p>
     • 生产者把消息发送到交换机
    </p>
    <p>
     • 队列直接和交换机绑定
    </p>
    <p>
     • 工作机制：消息发送到交换机上，就会以广播的形式发送给所有已绑定队列
    </p>
    <p>
     • 理解概念：
    </p>
    <p>
     • Publish：发布，这里就是把消息发送到交换机上
    </p>
    <p>
     • Subscribe：订阅，这里只要把队列和交换机绑定，事实上就形成了一种订阅关系
    </p>
    <h2>
     一、生产者代码
    </h2>
    <pre><code class="language-java">package com.atguigu.rabbitmq.fanout;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.BuiltinExchangeType;  
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
  
public class Producer {  
  
    public static void main(String[] args) throws Exception {  
  
      // 1、获取连接  
        Connection connection = ConnectionUtil.getConnection();  
  
      // 2、创建频道  
        Channel channel = connection.createChannel();  
  
        // 参数1. exchange：交换机名称  
        // 参数2. type：交换机类型  
        //     DIRECT("direct")：定向  
        //     FANOUT("fanout")：扇形（广播），发送消息到每一个与之绑定队列。  
        //     TOPIC("topic")：通配符的方式  
        //     HEADERS("headers")：参数匹配  
        // 参数3. durable：是否持久化  
        // 参数4. autoDelete：自动删除  
        // 参数5. internal：内部使用。一般false  
        // 参数6. arguments：其它参数  
        String exchangeName = "test_fanout";  
  
        // 3、创建交换机  
        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,true,false,false,null);  
  
        // 4、创建队列  
        String queue1Name = "test_fanout_queue1";  
        String queue2Name = "test_fanout_queue2";  
  
        channel.queueDeclare(queue1Name,true,false,false,null);  
        channel.queueDeclare(queue2Name,true,false,false,null);  
  
        // 5、绑定队列和交换机  
      // 参数1. queue：队列名称  
      // 参数2. exchange：交换机名称  
      // 参数3. routingKey：路由键，绑定规则  
      //     如果交换机的类型为fanout，routingKey设置为""  
        channel.queueBind(queue1Name,exchangeName,"");  
        channel.queueBind(queue2Name,exchangeName,"");  
  
        String body = "日志信息：张三调用了findAll方法...日志级别：info...";  
  
        // 6、发送消息  
        channel.basicPublish(exchangeName,"",null,body.getBytes());  
  
        // 7、释放资源  
        channel.close();  
        connection.close();  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h2>
     二、消费者代码
    </h2>
    <h3>
     1、消费者1号
    </h3>
    <pre><code class="language-java">package com.atguigu.rabbitmq.fanout;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
import java.io.IOException;  
  
public class Consumer1 {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String queue1Name = "test_fanout_queue1";  
  
        channel.queueDeclare(queue1Name,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("body："+new String(body));  
                System.out.println("队列 1 消费者 1 将日志信息打印到控制台.....");  
  
            }  
  
        };  
  
        channel.basicConsume(queue1Name,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h3>
     2、消费者2号
    </h3>
    <pre><code class="language-java">package com.atguigu.rabbitmq.fanout;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
import java.io.IOException;  
  
public class Consumer2 {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String queue2Name = "test_fanout_queue2";  
  
        channel.queueDeclare(queue2Name,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("body："+new String(body));  
                System.out.println("队列 2 消费者 2 将日志信息打印到控制台.....");  
  
            }  
  
        };  
  
        channel.basicConsume(queue2Name,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h2>
     三、运行效果
    </h2>
    <p>
     还是先启动消费者，然后再运行生产者程序发送消息：
    </p>
    <p class="img-center">
     <img alt="img" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimg66.png%3FlastModify%3D1741251219&amp;pos_id=VL2P74AQ" width="534"/>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="img" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimg67.png%3FlastModify%3D1741251219&amp;pos_id=IJ7gHkZK" width="534"/>
    </p>
    <p>
    </p>
    <h2>
     四、小结
    </h2>
    <p>
     交换机和队列的绑定关系如下图所示：
    </p>
    <p>
     <img alt="" height="539" src="https://i-blog.csdnimg.cn/direct/2d729a93ad2b430d8311d17c25f90a31.png" width="1209"/>
    </p>
    <p>
     交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。
    </p>
    <p>
     <strong>
      发布订阅模式与工作队列模式的区别：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       工作队列模式本质上是绑定默认交换机
      </p>
     </li>
     <li>
      <p>
       发布订阅模式绑定指定交换机
      </p>
     </li>
     <li>
      <p>
       监听同一个队列的消费端程序彼此之间是竞争关系
      </p>
     </li>
     <li>
      <p>
       绑定同一个交换机的多个队列在发布订阅模式下，消息是广播的，每个队列都能接收到消息
      </p>
     </li>
    </ul>
    <h2>
     操作006-路由模式
    </h2>
    <p>
     <img alt="" height="248" src="https://i-blog.csdnimg.cn/direct/3617df1c384546b2946af162f394fae4.png" width="1058"/>
    </p>
    <p>
     通过『路由绑定』的方式，把交换机和队列关联起来
    </p>
    <p>
     • 交换机和队列通过路由键进行绑定
    </p>
    <p>
     • 生产者发送消息时不仅要指定交换机，还要指定路由键
    </p>
    <p>
     • 交换机接收到消息会发送到路由键绑定的队列
    </p>
    <p>
     • 在编码上与 Publish/Subscribe发布与订阅模式的区别：
    </p>
    <p>
     • 交换机的类型为：Direct
    </p>
    <p>
     • 队列绑定交换机的时候需要指定routing key。
    </p>
    <h2>
     一、生产者代码
    </h2>
    <pre><code class="language-java">package com.atguigu.rabbitmq.routing;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.BuiltinExchangeType;  
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
  
public class Producer {  
  
    public static void main(String[] args) throws Exception {  
  
      Connection connection = ConnectionUtil.getConnection();  
  
      Channel channel = connection.createChannel();  
  
      String exchangeName = "test_direct";  
  
      // 创建交换机  
      channel.exchangeDeclare(exchangeName,BuiltinExchangeType.DIRECT,true,false,false,null);  
  
      // 创建队列  
      String queue1Name = "test_direct_queue1";  
      String queue2Name = "test_direct_queue2";  
  
      // 声明（创建）队列  
      channel.queueDeclare(queue1Name,true,false,false,null);  
      channel.queueDeclare(queue2Name,true,false,false,null);  
  
      // 队列绑定交换机  
      // 队列1绑定error  
      channel.queueBind(queue1Name,exchangeName,"error");  
  
      // 队列2绑定info error warning  
      channel.queueBind(queue2Name,exchangeName,"info");  
      channel.queueBind(queue2Name,exchangeName,"error");  
      channel.queueBind(queue2Name,exchangeName,"warning");  
  
        String message = "日志信息：张三调用了delete方法.错误了,日志级别warning";  
  
        // 发送消息  
        channel.basicPublish(exchangeName,"warning",null,message.getBytes());  
        System.out.println(message);  
  
      // 释放资源  
        channel.close();  
        connection.close();  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h2>
     二、消费者代码
    </h2>
    <h3>
     1、消费者1号
    </h3>
    <pre><code class="language-java">package com.atguigu.rabbitmq.routing;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
import java.io.IOException;  
  
public class Consumer1 {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String queue1Name = "test_direct_queue1";  
  
        channel.queueDeclare(queue1Name,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("body："+new String(body));  
                System.out.println("Consumer1 将日志信息打印到控制台.....");  
  
            }  
  
        };  
  
        channel.basicConsume(queue1Name,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h3>
     2、消费者2号
    </h3>
    <pre><code class="language-java">package com.atguigu.rabbitmq.routing;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
import java.io.IOException;  
  
public class Consumer2 {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String queue2Name = "test_direct_queue2";  
  
        channel.queueDeclare(queue2Name,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("body："+new String(body));  
                System.out.println("Consumer2 将日志信息存储到数据库.....");  
  
            }  
  
        };  
  
        channel.basicConsume(queue2Name,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h2>
     三、运行结果
    </h2>
    <h3>
     1、绑定关系
    </h3>
    <p class="img-center">
     <img alt="img" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimg69.png%3FlastModify%3D1741251249&amp;pos_id=A1z9unlW" width="534"/>
    </p>
    <p>
    </p>
    <h3>
     2、消费消息
    </h3>
    <p>
    </p>
    <h2>
     操作006：主题模式
    </h2>
    <p>
     <img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/a6af09da431741b1a8ef0ce042ee84b9.png" width="1089"/>
    </p>
    <p>
     • Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符
    </p>
    <p>
     • Routingkey一般都是由一个或多个单词组成，多个单词之间以“.”分割，例如：item.insert
    </p>
    <p>
     • 通配符规则：
    </p>
    <p>
     • #：匹配零个或多个词
    </p>
    <p>
     • *：匹配一个词
    </p>
    <h2>
     一、生产者代码
    </h2>
    <pre><code class="language-java">package com.atguigu.rabbitmq.topic;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.BuiltinExchangeType;  
import com.rabbitmq.client.Channel;  
import com.rabbitmq.client.Connection;  
import com.rabbitmq.client.ConnectionFactory;  
  
public class Producer {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String exchangeName = "test_topic";  
  
        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC,true,false,false,null);  
  
        String queue1Name = "test_topic_queue1";  
        String queue2Name = "test_topic_queue2";  
  
        channel.queueDeclare(queue1Name,true,false,false,null);  
        channel.queueDeclare(queue2Name,true,false,false,null);  
  
        // 绑定队列和交换机  
      // 参数1. queue：队列名称  
      // 参数2. exchange：交换机名称  
      // 参数3. routingKey：路由键,绑定规则  
      //      如果交换机的类型为fanout ,routingKey设置为""  
        // routing key 常用格式：系统的名称.日志的级别。  
        // 需求： 所有error级别的日志存入数据库,所有order系统的日志存入数据库  
        channel.queueBind(queue1Name,exchangeName,"#.error");  
        channel.queueBind(queue1Name,exchangeName,"order.*");  
        channel.queueBind(queue2Name,exchangeName,"*.*");  
  
        // 分别发送消息到队列：order.info、goods.info、goods.error  
        String body = "[所在系统：order][日志级别：info][日志内容：订单生成，保存成功]";  
        channel.basicPublish(exchangeName,"order.info",null,body.getBytes());  
  
        body = "[所在系统：goods][日志级别：info][日志内容：商品发布成功]";  
        channel.basicPublish(exchangeName,"goods.info",null,body.getBytes());  
  
        body = "[所在系统：goods][日志级别：error][日志内容：商品发布失败]";  
        channel.basicPublish(exchangeName,"goods.error",null,body.getBytes());  
  
        channel.close();  
        connection.close();  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h2>
     二、消费者代码
    </h2>
    <h3>
     1、消费者1号
    </h3>
    <p>
     消费者1监听队列1：
    </p>
    <pre><code class="language-java">package com.atguigu.rabbitmq.topic;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
import java.io.IOException;  
  
public class Consumer1 {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String QUEUE_NAME = "test_topic_queue1";  
  
        channel.queueDeclare(QUEUE_NAME,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("body："+new String(body));  
  
            }  
  
        };  
  
        channel.basicConsume(QUEUE_NAME,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h3>
     2、消费者2号
    </h3>
    <p>
     消费者2监听队列2：
    </p>
    <pre><code class="language-java">package com.atguigu.rabbitmq.topic;  
  
import com.atguigu.rabbitmq.util.ConnectionUtil;  
import com.rabbitmq.client.*;  
import java.io.IOException;  
  
public class Consumer2 {  
  
    public static void main(String[] args) throws Exception {  
  
        Connection connection = ConnectionUtil.getConnection();  
  
        Channel channel = connection.createChannel();  
  
        String QUEUE_NAME = "test_topic_queue2";  
  
        channel.queueDeclare(QUEUE_NAME,true,false,false,null);  
  
        Consumer consumer = new DefaultConsumer(channel){  
  
            @Override  
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {  
  
                System.out.println("body："+new String(body));  
  
            }  
  
        };  
  
        channel.basicConsume(QUEUE_NAME,true,consumer);  
  
    }  
  
}</code></pre>
    <p>
    </p>
    <h2>
     三、运行效果
    </h2>
    <p>
     队列1：
    </p>
    <p class="img-center">
     <img alt="img" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimg71-1698995061577-1.png%3FlastModify%3D1741251263&amp;pos_id=yRJl20WC" width="534"/>
    </p>
    <p>
     队列2：
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     操作007：整合SpringBoot
    </h2>
    <p>
     搭建环境
    </p>
    <p>
     • 基础设定：交换机名称、队列名称、绑定关系
    </p>
    <p>
     • 发送消息：使用RabbitTemplate
    </p>
    <p>
     • 接收消息：使用@RabbitListener注解
    </p>
    <h3>
     1、消费者工程
    </h3>
    <h4>
     ①创建module
    </h4>
    <h4>
     ②配置POM
    </h4>
    <pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h4>
     ③YAML
    </h4>
    <p>
     增加日志打印的配置：
    </p>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /
logging:
  level:
    com.atguigu.mq.listener.MyMessageListener: info</code></pre>
    <p>
    </p>
    <h4>
     ④主启动类
    </h4>
    <p>
     仿照生产者工程的主启动类，改一下类名即可
    </p>
    <pre><code class="language-java">package com.atguigu.mq;
​
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
​
@SpringBootApplication
public class RabbitMQConsumerMainType {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQConsumerMainType.class, args);
    }
​
}</code></pre>
    <h4>
     ⑤监听器
    </h4>
    <pre><code class="language-java">package com.atguigu.mq.listener;
​
import lombok.extern.slf4j.Slf4j;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
​
@Component
@Slf4j
public class MyMessageListener {
  
    public static final String EXCHANGE_DIRECT = "exchange.direct.order";  
    public static final String ROUTING_KEY = "order";  
    public static final String QUEUE_NAME  = "queue.order";  
  
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = QUEUE_NAME, durable = "true"),
            exchange = @Exchange(value = EXCHANGE_DIRECT),
            key = {ROUTING_KEY}
    ))
    public void processMessage(String dateString,
                               Message message,
                               Channel channel) {
        log.info(dateString);
    }
  
}</code></pre>
    <p>
    </p>
    <h3>
     2、@RabbitListener注解属性对比
    </h3>
    <h4>
     ①bindings属性
    </h4>
    <ul>
     <li>
      <p>
       表面作用：
      </p>
      <ul>
       <li>
        <p>
         指定交换机和队列之间的绑定关系
        </p>
       </li>
       <li>
        <p>
         指定当前方法要监听的队列
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       隐藏效果：如果RabbitMQ服务器上没有这里指定的交换机和队列，那么框架底层的代码会创建它们
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h4>
     ②queues属性
    </h4>
    <pre>@RabbitListener(queues = {QUEUE_ATGUIGU})</pre>
    <ul>
     <li>
      <p>
       作用：指定当前方法要监听的队列
      </p>
     </li>
     <li>
      <p>
       注意：此时框架不会创建相关交换机和队列，必须提前创建好
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     3、生产者工程
    </h3>
    <h4>
     ①创建module
    </h4>
    <p>
    </p>
    <h4>
     ②配置POM
    </h4>
    <pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h4>
     ③YAML
    </h4>
    <pre><code class="language-java">spring: 
  rabbitmq: 
    host: 192.168.200.100
    port: 5672 
    username: guest 
    password: 123456 
    virtual-host: /</code></pre>
    <p>
    </p>
    <h4>
     ④主启动类
    </h4>
    <pre><code class="language-java">package com.atguigu.mq;  
  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
  
@SpringBootApplication
public class RabbitMQProducerMainType {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQProducerMainType.class, args);  
    }
​
}</code></pre>
    <p>
    </p>
    <h4>
     ⑤测试程序
    </h4>
    <pre><code class="language-java">package com.atguigu.mq.test;
  
import org.junit.jupiter.api.Test;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
​
@SpringBootTest  
public class RabbitMQTest {  
  
    public static final String EXCHANGE_DIRECT = "exchange.direct.order";  
    public static final String ROUTING_KEY = "order";
  
    @Autowired  
    private RabbitTemplate rabbitTemplate;
  
    @Test  
    public void testSendMessage() {  
        rabbitTemplate.convertAndSend(  
                EXCHANGE_DIRECT,   
                ROUTING_KEY,   
                "Hello atguigu");  
    }  
  
}</code></pre>
    <h2>
     <span style="color:#fe2c24">
      消息可靠性投递
     </span>
    </h2>
    <h3>
     下单操作的正常流程
    </h3>
    <p>
     <img alt="" height="358" src="https://i-blog.csdnimg.cn/direct/31d9a752ff0a4dfa9d22abd7d3a84e6d.png" width="919"/>
    </p>
    <h4>
     <span style="color:#fe2c24">
      故障情况1
     </span>
    </h4>
    <p>
     消息没有发送到消息队列上
    </p>
    <p>
     后果：消费者拿不到消息，业务功能缺失，数据错误
    </p>
    <p>
     <img alt="" height="153" src="https://i-blog.csdnimg.cn/direct/d87c4ce43ae34ae3b39074f7f0b0c83f.png" width="890"/>
    </p>
    <h4>
     <span style="color:#fe2c24">
      故障情况2
     </span>
    </h4>
    <p>
     消息成功存入消息队列，但是消息队列服务器宕机了
    </p>
    <p>
     原本保存在内存中的消息也丢失了
    </p>
    <p>
     即使服务器重新启动，消息也找不回来了
    </p>
    <p>
     后果：消费者拿不到消息，业务功能缺失，数据错误
    </p>
    <p>
     <img alt="" height="155" src="https://i-blog.csdnimg.cn/direct/eebb544e8f1d416d881ae2c60192de98.png" width="783"/>
    </p>
    <h4>
     <span style="color:#fe2c24">
      故障情况3
     </span>
    </h4>
    <p>
     消息成功存入消息队列，但是消费端出现问题，
    </p>
    <p>
     例如：宕机、抛异常等等后果：业务功能缺失，数据错误
    </p>
    <p>
     <img alt="" height="200" src="https://i-blog.csdnimg.cn/direct/994a7251f2ca491fb1977c325ca3ee42.png" width="932"/>
    </p>
    <h3>
     对症下药
    </h3>
    <p>
     <strong>
      • 故障情况1
     </strong>
     ：消息没有发送到消息队列
    </p>
    <p>
     • 解决思路A：在
     <span style="color:#fe2c24">
      生产者端
     </span>
     进行
     <span style="color:#fe2c24">
      确认
     </span>
     ，具体操作中我们会分别针对交换机和队列来确认，如果没有成功发送到消息队列服务器上，那就可以尝试重新发送
    </p>
    <p>
     • 解决思路B：为目标交换机指定
     <span style="color:#fe2c24">
      备份交换机
     </span>
     ，当目标交换机投递失败时，把消息投递至备份交换机
    </p>
    <p>
     <strong>
      • 故障情况2
     </strong>
     ：消息队列服务器宕机导致内存中消息丢失
    </p>
    <p>
     • 解决思路：
     <span style="color:#fe2c24">
      <strong>
       消息持久化到硬盘
      </strong>
     </span>
     上，哪怕服务器重启也不会导致消息丢失
    </p>
    <p>
     <strong>
      • 故障情况3
     </strong>
     ：消费端宕机或抛异常导致消息没有成功被消费
    </p>
    <p>
     • 消费端消费消息
     <span style="color:#fe2c24">
      成功
     </span>
     ，给服务器返回
     <span style="color:#fe2c24">
      ACK信息
     </span>
     ，然后消息队列
     <span style="color:#fe2c24">
      删除该消息
     </span>
    </p>
    <p>
     • 消费端消费消息
     <span style="color:#fe2c24">
      失败
     </span>
     ，给服务器端返回
     <span style="color:#fe2c24">
      NACK信息
     </span>
     ，同时把消息恢复为
     <span style="color:#fe2c24">
      待消费
     </span>
     的状态，这样就可以再次取回消息，重试一次（当然，这就需要消费端
     <span style="color:#fe2c24">
      接口支持幂等性
     </span>
     ）
    </p>
    <p>
    </p>
    <h2>
     操作008-01-A：生产者端消息确认机制
    </h2>
    <h2>
     一、创建module
    </h2>
    <p>
    </p>
    <h2>
     二、搭建环境
    </h2>
    <h3>
     1、配置POM
    </h3>
    <pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h3>
     2、主启动类
    </h3>
    <p>
     没有特殊设定：
    </p>
    <pre><code class="language-java">package com.atguigu.mq;  
  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
  
@SpringBootApplication
public class RabbitMQProducerMainType {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQProducerMainType.class, args);  
    }
​
}</code></pre>
    <p>
    </p>
    <h3>
     3、YAML
    </h3>
    <p>
     注意：publisher-confirm-type和publisher-returns是两个必须要增加的配置，如果没有则本节功能不生效
    </p>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /
    publisher-confirm-type: CORRELATED # 交换机的确认
    publisher-returns: true # 队列的确认
logging:
  level:
    com.atguigu.mq.config.MQProducerAckConfig: info</code></pre>
    <p>
    </p>
    <h2>
     三、创建配置类
    </h2>
    <h3>
     1、目标
    </h3>
    <p>
     在这里我们为什么要创建这个配置类呢？首先，我们需要声明回调函数来接收RabbitMQ服务器返回的确认信息：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        方法名
       </th>
       <th>
        方法功能
       </th>
       <th>
        所属接口
       </th>
       <th>
        接口所属类
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        confirm()
       </td>
       <td>
        确认消息是否发送到交换机
       </td>
       <td>
        ConfirmCallback
       </td>
       <td>
        RabbitTemplate
       </td>
      </tr>
      <tr>
       <td>
        returnedMessage()
       </td>
       <td>
        确认消息是否发送到队列
       </td>
       <td>
        ReturnsCallback
       </td>
       <td>
        RabbitTemplate
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
     然后，就是对RabbitTemplate的功能进行增强，因为回调函数所在对象必须设置到RabbitTemplate对象中才能生效。
    </p>
    <p>
     原本RabbitTemplate对象并没有生产者端消息确认的功能，要给它设置对应的组件才可以。
    </p>
    <p>
     而设置对应的组件，需要调用RabbitTemplate对象下面两个方法：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        设置组件调用的方法
       </th>
       <th>
        所需对象类型
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        setConfirmCallback()
       </td>
       <td>
        ConfirmCallback接口类型
       </td>
      </tr>
      <tr>
       <td>
        setReturnCallback()
       </td>
       <td>
        ReturnCallback接口类型
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h3>
     2、API说明
    </h3>
    <h4>
     ①ConfirmCallback接口
    </h4>
    <p>
     这是RabbitTemplate内部的一个接口，源代码如下：
    </p>
    <pre><code class="language-java">    /**
     * A callback for publisher confirmations.
     *
     */
    @FunctionalInterface
    public interface ConfirmCallback {
​
        /**
         * Confirmation callback.
         * @param correlationData correlation data for the callback.
         * @param ack true for ack, false for nack
         * @param cause An optional cause, for nack, when available, otherwise null.
         */
        void confirm(@Nullable CorrelationData correlationData, boolean ack, @Nullable String cause);
​
    }</code></pre>
    <p>
     生产者端发送消息之后，回调confirm()方法
    </p>
    <ul>
     <li>
      <p>
       ack参数值为true：表示消息成功发送到了交换机
      </p>
     </li>
     <li>
      <p>
       ack参数值为false：表示消息没有发送到交换机
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h4>
     ②ReturnCallback接口
    </h4>
    <p>
     同样也RabbitTemplate内部的一个接口，源代码如下：
    </p>
    <pre><code class="language-java">    /**
     * A callback for returned messages.
     *
     * @since 2.3
     */
    @FunctionalInterface
    public interface ReturnsCallback {
​
        /**
         * Returned message callback.
         * @param returned the returned message and metadata.
         */
        void returnedMessage(ReturnedMessage returned);
​
    }</code></pre>
    <p>
     注意：接口中的returnedMessage()方法仅在消息没有发送到队列时调用
    </p>
    <p>
     ReturnedMessage类中主要属性含义如下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性名
       </th>
       <th>
        类型
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        message
       </td>
       <td>
        org.springframework.amqp.core.Message
       </td>
       <td>
        消息以及消息相关数据
       </td>
      </tr>
      <tr>
       <td>
        replyCode
       </td>
       <td>
        int
       </td>
       <td>
        应答码，类似于HTTP响应状态码
       </td>
      </tr>
      <tr>
       <td>
        replyText
       </td>
       <td>
        String
       </td>
       <td>
        应答码说明
       </td>
      </tr>
      <tr>
       <td>
        exchange
       </td>
       <td>
        String
       </td>
       <td>
        交换机名称
       </td>
      </tr>
      <tr>
       <td>
        routingKey
       </td>
       <td>
        String
       </td>
       <td>
        路由键名称
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h3>
     3、配置类代码
    </h3>
    <h4>
     ①要点1
    </h4>
    <p>
     加@Component注解，加入IOC容器
    </p>
    <p>
    </p>
    <h4>
     ②要点2
    </h4>
    <p>
     配置类自身实现ConfirmCallback、ReturnCallback这两个接口，然后通过this指针把配置类的对象设置到RabbitTemplate对象中。
    </p>
    <p>
     操作封装到了一个专门的void init()方法中。
    </p>
    <p>
     为了保证这个void init()方法在应用启动时被调用，我们使用@PostConstruct注解来修饰这个方法。
    </p>
    <p>
     关于@PostConstruct注解大家可以参照以下说明：
    </p>
    <blockquote>
     <p>
      @PostConstruct注解是Java中的一个标准注解，它用于指定在对象创建之后立即执行的方法。当使用依赖注入（如Spring框架）或者其他方式创建对象时，@PostConstruct注解可以确保在对象完全初始化之后，执行相应的方法。
     </p>
     <p>
      使用@PostConstruct注解的方法必须满足以下条件：
     </p>
     <ol>
      <li>
       <p>
        方法不能有任何参数。
       </p>
      </li>
      <li>
       <p>
        方法必须是非静态的。
       </p>
      </li>
      <li>
       <p>
        方法不能返回任何值。
       </p>
      </li>
     </ol>
     <p>
      当容器实例化一个带有@PostConstruct注解的Bean时，它会在调用构造函数之后，并在依赖注入完成之前调用被@PostConstruct注解标记的方法。这样，我们可以在该方法中进行一些初始化操作，比如读取配置文件、建立数据库连接等。
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     ③代码
    </h4>
    <p>
     有了以上说明，下面我们就可以展示配置类的整体代码：
    </p>
    <pre><code class="language-java">package com.atguigu.mq.config;
​
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.ReturnedMessage;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
​
@Component
@Slf4j
public class MQProducerAckConfig implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback{
​
    @Autowired
    private RabbitTemplate rabbitTemplate;
​
    @PostConstruct
    public void init() {
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setReturnsCallback(this);
    }
​
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        if (ack) {
            log.info("消息发送到交换机成功！数据：" + correlationData);
        } else {
            log.info("消息发送到交换机失败！数据：" + correlationData + " 原因：" + cause);
        }
    }
​
    @Override
    public void returnedMessage(ReturnedMessage returned) {
        //发送到交换机失败调用的方法
        log.info("消息主体: " + new String(returned.getMessage().getBody()));
        log.info("应答码: " + returned.getReplyCode());
        log.info("描述：" + returned.getReplyText());
        log.info("消息使用的交换器 exchange : " + returned.getExchange());
        log.info("消息使用的路由键 routing : " + returned.getRoutingKey());
    }
}</code></pre>
    <p>
    </p>
    <h2>
     四、发送消息
    </h2>
    <pre><code class="language-java">package com.atguigu.mq.test;
  
import org.junit.jupiter.api.Test;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
​
@SpringBootTest  
public class RabbitMQTest {  
  
    public static final String EXCHANGE_DIRECT = "exchange.direct.order";
    public static final String ROUTING_KEY = "order";
  
    @Autowired  
    private RabbitTemplate rabbitTemplate;
  
    @Test  
    public void testSendMessage() {  
        rabbitTemplate.convertAndSend(  
                EXCHANGE_DIRECT,   
                ROUTING_KEY,   
                "Hello atguigu");  
    }  
  
}</code></pre>
    <p>
     通过调整代码，测试如下三种情况：
    </p>
    <ul>
     <li>
      <p>
       交换机正确、路由键正确
      </p>
     </li>
     <li>
      <p>
       交换机正确、路由键不正确，无法发送到队列
      </p>
     </li>
     <li>
      <p>
       交换机不正确，无法发送到交换机
      </p>
     </li>
    </ul>
    <h2>
     操作008-01-B：备份交换机
    </h2>
    <h2>
     一、创建备份交换机
    </h2>
    <h3>
     1、创建备份交换机
    </h3>
    <p>
     注意：备份交换机一定要选择fanout类型，因为原交换机转入备份交换机时并不会指定路由键
    </p>
    <p>
     <img alt="" height="488" src="https://i-blog.csdnimg.cn/direct/2961ac81df8640a0afd84a865d95b2f8.png" width="1277"/>
    </p>
    <p>
     <img alt="" height="633" src="https://i-blog.csdnimg.cn/direct/497301a5ce3d499a8c98ea09c71cd3b4.png" width="1286"/>
    </p>
    <p>
    </p>
    <h3>
     2、创建备份交换机要绑定的队列
    </h3>
    <h4>
     ①创建队列
    </h4>
    <p>
     <img alt="" height="550" src="https://i-blog.csdnimg.cn/direct/dde0156dbb8e4d759659f6a47d7dbebe.png" width="1232"/>
    </p>
    <p>
     <img alt="" height="348" src="https://i-blog.csdnimg.cn/direct/e7278c6aee934bcf98bfdfed1cf12fec.png" width="1075"/>
    </p>
    <p>
    </p>
    <h4>
     ②绑定交换机
    </h4>
    <p>
     注意：这里是要和备份交换机绑定
    </p>
    <p>
     <img alt="" height="1059" src="https://i-blog.csdnimg.cn/direct/d0984947751a40cd8a75255221026615.png" width="1121"/>
    </p>
    <h3>
     3、针对备份队列创建消费端监听器
    </h3>
    <pre><code class="language-java">    public static final String EXCHANGE_DIRECT_BACKUP = "exchange.direct.order.backup";
    public static final String QUEUE_NAME_BACKUP  = "queue.order.backup";
​
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = QUEUE_NAME_BACKUP, durable = "true"),
            exchange = @Exchange(value = EXCHANGE_DIRECT_BACKUP),
            key = {""}
    ))
    public void processMessageBackup(String dateString,
                                     Message message,
                                     Channel channel) {
        log.info("BackUp: " + dateString);
    }</code></pre>
    <p>
    </p>
    <h2>
     二、设定备份关系
    </h2>
    <h3>
     1、原交换机删除
    </h3>
    <p>
     ·
    </p>
    <p>
     <img alt="" height="684" src="https://i-blog.csdnimg.cn/direct/7b12460c3dd44ef9bc6feb020cc5260d.png" width="1294"/>
    </p>
    <h3>
     2、重新创建原交换机
    </h3>
    <p>
     <img alt="" height="1026" src="https://i-blog.csdnimg.cn/direct/ba085ee84b4548a5bf2e611716460adf.png" width="1311"/>
    </p>
    <h3>
     3、原交换机重新绑定原队列
    </h3>
    <p>
     <img alt="" height="1141" src="https://i-blog.csdnimg.cn/direct/af566464ee5245fda9876877d2775478.png" width="1278"/>
    </p>
    <h2>
     三、测试
    </h2>
    <ul>
     <li>
      <p>
       启动消费者端
      </p>
     </li>
     <li>
      <p>
       发送消息，但是路由键不对，于是转入备份交换机
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     操作008-03：消费端消息确认
    </h2>
    <h2>
     一、ACK
    </h2>
    <p>
     ACK是acknowledge的缩写，表示已确认
    </p>
    <p>
    </p>
    <h2>
     二、默认情况
    </h2>
    <p>
     默认情况下，消费端取回消息后，默认会自动返回ACK确认消息，所以在前面的测试中消息被消费端消费之后，RabbitMQ得到ACK确认信息就会删除消息
    </p>
    <p>
     但实际开发中，消费端根据消息队列投递的消息执行对应的业务，未必都能执行成功，如果希望能够多次重试，那么默认设定就不满足要求了
    </p>
    <p>
     所以还是要修改成手动确认
    </p>
    <p>
    </p>
    <h2>
     三、创建消费端module
    </h2>
    <h3>
     1、配置POM
    </h3>
    <pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h3>
     2、YAML
    </h3>
    <p>
     增加针对监听器的设置：
    </p>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /
    listener:
      simple:
        acknowledge-mode: manual # 把消息确认模式改为手动确认</code></pre>
    <p>
    </p>
    <h3>
     3、主启动类
    </h3>
    <p>
     没有特殊设定：
    </p>
    <pre><code class="language-java">package com.atguigu.mq;
​
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
​
@SpringBootApplication
public class RabbitMQConsumerMainType {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQConsumerMainType.class, args);
    }
​
}</code></pre>
    <p>
    </p>
    <h2>
     四、消费端监听器
    </h2>
    <h3>
     1、创建监听器类
    </h3>
    <pre><code class="language-java">package com.atguigu.mq.listener;
​
import com.rabbitmq.client.Channel;
import org.springframework.amqp.core.Message;
import org.springframework.stereotype.Component;
​
@Component
public class MyMessageListener {
​
    public static final String EXCHANGE_DIRECT = "exchange.direct.order";
    public static final String ROUTING_KEY = "order";
    public static final String QUEUE_NAME  = "queue.order";
​
    public void processMessage(String dataString, Message message, Channel channel) {
​
    }
​
}</code></pre>
    <p>
    </p>
    <h3>
     2、在接收消息的方法上应用注解
    </h3>
    <pre><code class="language-java">// 修饰监听方法
@RabbitListener(
        // 设置绑定关系
        bindings = @QueueBinding(
​
            // 配置队列信息：durable 设置为 true 表示队列持久化；autoDelete 设置为 false 表示关闭自动删除
            value = @Queue(value = QUEUE_NAME, durable = "true", autoDelete = "false"),
​
            // 配置交换机信息：durable 设置为 true 表示队列持久化；autoDelete 设置为 false 表示关闭自动删除
            exchange = @Exchange(value = EXCHANGE_DIRECT, durable = "true", autoDelete = "false"),
​
            // 配置路由键信息
            key = {ROUTING_KEY}
))
public void processMessage(String dataString, Message message, Channel channel) {
​
}</code></pre>
    <p>
    </p>
    <h3>
     3、接收消息方法内部逻辑
    </h3>
    <ul>
     <li>
      <p>
       业务处理成功：手动返回ACK信息，表示消息成功消费
      </p>
     </li>
     <li>
      <p>
       业务处理失败：手动返回NACK信息，表示消息消费失败。此时有两种后续操作供选择：
      </p>
      <ul>
       <li>
        <p>
         把消息重新放回消息队列，RabbitMQ会重新投递这条消息，那么消费端将重新消费这条消息——从而让业务代码再执行一遍
        </p>
       </li>
       <li>
        <p>
         不把消息放回消息队列，返回reject信息表示拒绝，那么这条消息的处理就到此为止
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     4、相关API
    </h3>
    <p>
     先回到PPT理解“deliveryTag：交付标签机制”
    </p>
    <p>
     <img alt="" height="737" src="https://i-blog.csdnimg.cn/direct/1e3a6feb5ea44ef4baae22402133f584.png" width="1428"/>
    </p>
    <p>
     <img alt="" height="744" src="https://i-blog.csdnimg.cn/direct/9b0314adbacb42a2a6b38bed0cb1a092.png" width="1387"/>
    </p>
    <p>
     <img alt="" height="680" src="https://i-blog.csdnimg.cn/direct/e09719011ed14ed184f144a5f0f0de8d.png" width="1357"/>
    </p>
    <p>
     <img alt="" height="1125" src="https://i-blog.csdnimg.cn/direct/f8b9f35261f042848d9b703d74a370f6.png" width="1391"/>
    </p>
    <p>
     <img alt="" height="733" src="https://i-blog.csdnimg.cn/direct/2509cd6fa1fd48a29288bd880a286466.png" width="1353"/>
    </p>
    <p>
     <img alt="" height="684" src="https://i-blog.csdnimg.cn/direct/760b0898847f4af6a35f44116eb5d3f7.png" width="1395"/>
    </p>
    <p>
     <img alt="" height="664" src="https://i-blog.csdnimg.cn/direct/d1c0e14c41d04f73bd7554a825129958.png" width="1342"/>
    </p>
    <p>
     下面我们探讨的三个方法都是来自于com.rabbitmq.client.Channel接口
    </p>
    <h4>
     ①basicAck()方法
    </h4>
    <ul>
     <li>
      <p>
       方法功能：给Broker返回ACK确认信息，表示消息已经在消费端成功消费，这样Broker就可以把消息删除了
      </p>
     </li>
     <li>
      <p>
       参数列表：
      </p>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        参数名称
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        long deliveryTag
       </td>
       <td>
        Broker给每一条进入队列的消息都设定一个唯一标识
       </td>
      </tr>
      <tr>
       <td>
        boolean multiple
       </td>
       <td>
        取值为true：为小于、等于deliveryTag的消息批量返回ACK信息 取值为false：仅为指定的deliveryTag返回ACK信息
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h4>
     ②basicNack()方法
    </h4>
    <ul>
     <li>
      <p>
       方法功能：给Broker返回NACK信息，表示消息在消费端消费失败，此时Broker的后续操作取决于参数requeue的值
      </p>
     </li>
     <li>
      <p>
       参数列表：
      </p>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        参数名称
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        long deliveryTag
       </td>
       <td>
        Broker给每一条进入队列的消息都设定一个唯一标识
       </td>
      </tr>
      <tr>
       <td>
        boolean multiple
       </td>
       <td>
        取值为true：为小于、等于deliveryTag的消息批量返回ACK信息 取值为false：仅为指定的deliveryTag返回ACK信息
       </td>
      </tr>
      <tr>
       <td>
        boolean requeue
       </td>
       <td>
        取值为true：Broker将消息重新放回队列，接下来会重新投递给消费端 取值为false：Broker将消息标记为已消费，不会放回队列
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h4>
     ③basicReject()方法
    </h4>
    <ul>
     <li>
      <p>
       方法功能：根据指定的deliveryTag，对该消息表示拒绝
      </p>
     </li>
     <li>
      <p>
       参数列表：
      </p>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        参数名称
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        long deliveryTag
       </td>
       <td>
        Broker给每一条进入队列的消息都设定一个唯一标识
       </td>
      </tr>
      <tr>
       <td>
        boolean requeue
       </td>
       <td>
        取值为true：Broker将消息重新放回队列，接下来会重新投递给消费端 取值为false：Broker将消息标记为已消费，不会放回队列
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <p>
       basicNack()和basicReject()有啥区别？
      </p>
      <ul>
       <li>
        <p>
         basicNack()有批量操作
        </p>
       </li>
       <li>
        <p>
         basicReject()没有批量操作
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     5、完整代码示例
    </h3>
    <pre><code class="language-java">package com.atguigu.mq.listener;
​
import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
​
import java.io.IOException;
​
@Component
@Slf4j
public class MyMessageListener {
​
    public static final String EXCHANGE_DIRECT = "exchange.direct.order";
    public static final String ROUTING_KEY = "order";
    public static final String QUEUE_NAME  = "queue.order";
​
    // 修饰监听方法
    @RabbitListener(
            // 设置绑定关系
            bindings = @QueueBinding(
​
                // 配置队列信息：durable 设置为 true 表示队列持久化；autoDelete 设置为 false 表示关闭自动删除
                value = @Queue(value = QUEUE_NAME, durable = "true", autoDelete = "false"),
​
                // 配置交换机信息：durable 设置为 true 表示队列持久化；autoDelete 设置为 false 表示关闭自动删除
                exchange = @Exchange(value = EXCHANGE_DIRECT, durable = "true", autoDelete = "false"),
​
                // 配置路由键信息
                key = {ROUTING_KEY}
    ))
    public void processMessage(String dataString, Message message, Channel channel) throws IOException {
​
        // 1、获取当前消息的 deliveryTag 值备用
        long deliveryTag = message.getMessageProperties().getDeliveryTag();
​
        try {
            // 2、正常业务操作
            log.info("消费端接收到消息内容：" + dataString);
            
            // System.out.println(10 / 0);
​
            // 3、给 RabbitMQ 服务器返回 ACK 确认信息
            channel.basicAck(deliveryTag, false);
        } catch (Exception e) {
​
            // 4、获取信息，看当前消息是否曾经被投递过
            Boolean redelivered = message.getMessageProperties().getRedelivered();
​
            if (!redelivered) {
                // 5、requeu ：如果没有被投递过，那就重新放回队列，重新投递，再试一次
                channel.basicNack(deliveryTag, false, true);
            } else {
                // 6、如果已经被投递过，且这一次仍然进入了 catch 块，那么返回拒绝且不再放回队列
                channel.basicReject(deliveryTag, false);
            }
​
        }
    }
​
}</code></pre>
    <p>
    </p>
    <h2>
     五、要点总结
    </h2>
    <ul>
     <li>
      <p>
       要点1：把消息确认模式改为手动确认
      </p>
     </li>
     <li>
      <p>
       要点2：调用Channel对象的方法返回信息
      </p>
      <ul>
       <li>
        <p>
         ACK：Acknowledgement，表示消息处理成功
        </p>
       </li>
       <li>
        <p>
         NACK：Negative Acknowledgement，表示消息处理失败
        </p>
       </li>
       <li>
        <p>
         Reject：拒绝，同样表示消息处理失败
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       要点3：后续操作
      </p>
      <ul>
       <li>
        <p>
         requeue为true：重新放回队列，重新投递，再次尝试
        </p>
       </li>
       <li>
        <p>
         requeue为false：不放回队列，不重新投递
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       要点4：deliveryTag 消息的唯一标识，查找具体某一条消息的依据
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     六、流程梳理
    </h2>
    <p>
     <img alt="" height="1048" src="https://i-blog.csdnimg.cn/direct/f888c5b3b8aa445ab56a367a99e685ba.png" width="1197"/>
    </p>
    <h2>
     七、多啰嗦一句
    </h2>
    <p>
     消费端如果设定消息重新放回队列，Broker重新投递消息，那么消费端就可以再次消费消息，这是一种“重试”机制，这需要消费端代码支持“幂等性”——这属于前置知识，不展开了。
    </p>
    <p>
    </p>
    <h2>
     操作009：Prefetch
    </h2>
    <h2>
     一、思路
    </h2>
    <ul>
     <li>
      <p>
       生产者发送100个消息
      </p>
     </li>
     <li>
      <p>
       对照两种情况：
      </p>
      <ul>
       <li>
        <p>
         消费端没有设置prefetch参数：100个消息被全部取回
        </p>
       </li>
       <li>
        <p>
         消费端设置prefetch参数为1：100个消息慢慢取回
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     二、生产者端代码
    </h2>
    <pre><code class="language-java">@Test  
public void testSendMessage() {
    for (int i = 0; i &lt; 100; i++) {
        rabbitTemplate.convertAndSend(
                EXCHANGE_DIRECT,
                ROUTING_KEY,
                "Hello atguigu" + i);
    }
}</code></pre>
    <p>
    </p>
    <h2>
     三、消费者端代码
    </h2>
    <pre><code class="language-java">// 2、正常业务操作
log.info("消费端接收到消息内容：" + dataString);
​
// System.out.println(10 / 0);
TimeUnit.SECONDS.sleep(1);
​
// 3、给 RabbitMQ 服务器返回 ACK 确认信息
channel.basicAck(deliveryTag, false);</code></pre>
    <p>
    </p>
    <h2>
     四、测试
    </h2>
    <h3>
     1、未使用prefetch
    </h3>
    <ul>
     <li>
      <p>
       不要启动消费端程序，如果正在运行就把它停了
      </p>
     </li>
     <li>
      <p>
       运行生产者端程序发送100条消息
      </p>
     </li>
     <li>
      <p>
       查看队列中消息的情况：
      </p>
     </li>
     <li>
      <p>
       <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/7be528f338ad44f08a9e72579d29523c.png" width="803"/>
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       说明：
      </p>
      <ul>
       <li>
        <p>
         Ready表示已经发送到队列的消息数量
        </p>
       </li>
       <li>
        <p>
         Unacked表示已经发送到消费端但是消费端尚未返回ACK信息的消息数量
        </p>
       </li>
       <li>
        <p>
         Total未被删除的消息总数
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       接下来启动消费端程序，再查看队列情况：
      </p>
     </li>
     <li>
      <p>
       <img alt="" height="118" src="https://i-blog.csdnimg.cn/direct/7047d5c9c9ad40ccbe9df6def6fcd82a.png" width="967"/>
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       能看到消息全部被消费端取走了，正在逐个处理、确认，说明有多少消息消费端就并发处理多少
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     2、设定prefetch
    </h3>
    <h4>
     ①YAML配置
    </h4>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /
    listener:
      simple:
        acknowledge-mode: manual
        prefetch: 1 # 设置每次最多从消息队列服务器取回多少消息</code></pre>
    <p>
    </p>
    <h4>
     ②测试流程
    </h4>
    <ul>
     <li>
      <p>
       停止消费端程序
      </p>
     </li>
     <li>
      <p>
       运行生产者端程序发送100条消息
      </p>
     </li>
     <li>
      <p>
       查看队列中消息的情况：
      </p>
     </li>
     <li>
      <p>
       <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/a081081d75c44bd19bad9f49c508d937.png" width="623"/>
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       接下来启动消费端程序，持续观察队列情况：
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="502" src="https://i-blog.csdnimg.cn/direct/8c0e43f9615e4d6cb088c1ebad42c9da.png" width="556"/>
    </p>
    <p>
    </p>
    <ul>
     <li>
      <p>
       能看到消息不是一次性全部取回的，而是有个过程
      </p>
     </li>
    </ul>
    <h2>
     操作010：消息超时
    </h2>
    <h2>
     一、队列层面设置
    </h2>
    <h3>
     1、设置
    </h3>
    <p>
     <img alt="" height="557" src="https://i-blog.csdnimg.cn/direct/04fe3192728b4ed7b5b5d6dfb03728d5.png" width="1379"/>
    </p>
    <p>
     别忘了设置绑定关系：
    </p>
    <p>
     <img alt="" height="351" src="https://i-blog.csdnimg.cn/direct/881bf249cfaa4e45b45cbaef92355bf3.png" width="1379"/>
    </p>
    <h3>
     2、测试
    </h3>
    <ul>
     <li>
      <p>
       不启动消费端程序
      </p>
     </li>
     <li>
      <p>
       向设置了过期时间的队列中发送100条消息
      </p>
     </li>
     <li>
      <p>
       等10秒后，看是否全部被过期删除
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="223" src="https://i-blog.csdnimg.cn/direct/5fda86606abb4e36be59ce6d93106930.png" width="1457"/>
    </p>
    <h2>
     二、消息层面设置
    </h2>
    <h3>
     1、设置
    </h3>
    <pre><code class="language-java">import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessagePostProcessor;
​
@Test  
public void testSendMessageTTL() {  
  
    // 1、创建消息后置处理器对象  
    MessagePostProcessor messagePostProcessor = (Message message) -&gt; {  
  
        // 设定 TTL 时间，以毫秒为单位
        message.getMessageProperties().setExpiration("5000");  
  
        return message;
    };
  
    // 2、发送消息  
    rabbitTemplate.convertAndSend(    
            EXCHANGE_DIRECT,     
            ROUTING_KEY,     
            "Hello atguigu", messagePostProcessor);    
}</code></pre>
    <p>
    </p>
    <h3>
     2、查看效果
    </h3>
    <p>
     这次我们是发送到普通队列上：
    </p>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/b4591e78da744c798e7061297d5599f7.png" width="1345"/>
    </p>
    <p>
    </p>
    <h2>
     操作011：死信
    </h2>
    <p>
     • 概念：当一个消息无法被消费，它就变成了死信。
    </p>
    <p>
     • 死信产生的原因大致有下面三种：
    </p>
    <p>
     •
     <span style="color:#fe2c24">
      拒绝
     </span>
     ：消费者拒接消息，basicNack()/basicReject()，并且不把消息重新放入原目标队列，requeue=false
    </p>
    <p>
     •
     <span style="color:#fe2c24">
      溢出
     </span>
     ：队列中消息数量到达限制。比如队列最大只能存储10条消息，且现在已经存储了10条，此时如果再发送一条消息进来，根据先进先出原则，队列中最早的消息会变成死信
    </p>
    <p>
     •
     <span style="color:#fe2c24">
      超时
     </span>
     ：消息到达超时时间未被消费
    </p>
    <p>
     • 死信的处理方式大致有下面三种：
    </p>
    <p>
     •
     <span style="color:#38d8f0">
      丢弃
     </span>
     ：对不重要的消息直接丢弃，不做处理
    </p>
    <p>
     •
     <span style="color:#38d8f0">
      入库
     </span>
     ：把死信写入数据库，日后处理
    </p>
    <p>
     •
     <span style="color:#38d8f0">
      监听
     </span>
     ：消息变成死信后进入死信队列，我们专门设置消费端监听死信队列，做后续处理（
     <span style="color:#fe2c24">
      通常采用
     </span>
     ）
    </p>
    <h2>
     一、测试相关准备
    </h2>
    <h3>
     1、创建死信交换机和死信队列
    </h3>
    <p>
     常规设定即可，没有特殊设置：
    </p>
    <ul>
     <li>
      <p>
       死信交换机：exchange.dead.letter.video
      </p>
     </li>
     <li>
      <p>
       死信队列：queue.dead.letter.video
      </p>
     </li>
     <li>
      <p>
       死信路由键：routing.key.dead.letter.video
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h3>
     2、创建正常交换机和正常队列
    </h3>
    <p>
     注意：一定要注意正常队列有诸多限定和设置，这样才能让无法处理的消息进入死信交换机
    </p>
    <p>
    </p>
    <ul>
     <li>
      <p>
       正常交换机：exchange.normal.video
      </p>
     </li>
     <li>
      <p>
       正常队列：queue.normal.video
      </p>
     </li>
     <li>
      <p>
       正常路由键：routing.key.normal.video
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="571" src="https://i-blog.csdnimg.cn/direct/e90080c877924bb6b7683fe6fbd1a7af.png" width="1437"/>
    </p>
    <p>
     全部设置完成后参照如下细节：
    </p>
    <p>
     <img alt="" height="702" src="https://i-blog.csdnimg.cn/direct/74b1b653fad441459a65b578174b8c68.png" width="1374"/>
    </p>
    <h3>
     3、Java代码中的相关常量声明
    </h3>
    <pre><code class="language-java">public static final String EXCHANGE_NORMAL = "exchange.normal.video";  
public static final String EXCHANGE_DEAD_LETTER = "exchange.dead.letter.video";  
  
public static final String ROUTING_KEY_NORMAL = "routing.key.normal.video";  
public static final String ROUTING_KEY_DEAD_LETTER = "routing.key.dead.letter.video";  
  
public static final String QUEUE_NORMAL = "queue.normal.video";  
public static final String QUEUE_DEAD_LETTER = "queue.dead.letter.video";</code></pre>
    <p>
    </p>
    <h2>
     二、消费端拒收消息
    </h2>
    <h3>
     1、发送消息的代码
    </h3>
    <pre><code class="language-java">@Test  
public void testSendMessageButReject() {  
    rabbitTemplate  
            .convertAndSend(  
                    EXCHANGE_NORMAL,  
                    ROUTING_KEY_NORMAL,  
                    "测试死信情况1：消息被拒绝");  
}</code></pre>
    <h3>
     2、接收消息的代码
    </h3>
    <h4>
     ①监听正常队列
    </h4>
    <pre><code class="language-java">@RabbitListener(queues = {QUEUE_NORMAL})
public void processMessageNormal(Message message, Channel channel) throws IOException {
    // 监听正常队列，但是拒绝消息
    log.info("★[normal]消息接收到，但我拒绝。");
    channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);
}</code></pre>
    <p>
    </p>
    <h4>
     ②监听死信队列
    </h4>
    <pre><code class="language-java">@RabbitListener(queues = {QUEUE_DEAD_LETTER})
public void processMessageDead(String dataString, Message message, Channel channel) throws IOException {  
    // 监听死信队列  
    log.info("★[dead letter]dataString = " + dataString);
    log.info("★[dead letter]我是死信监听方法，我接收到了死信消息");
    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
}</code></pre>
    <p>
    </p>
    <h3>
     3、执行结果
    </h3>
    <p>
     <img alt="" height="156" src="https://i-blog.csdnimg.cn/direct/f7af2bc807c4470793408872478802ae.png" width="1196"/>
    </p>
    <h2>
     三、消息数量超过队列容纳极限
    </h2>
    <h3>
     1、发送消息的代码
    </h3>
    <pre><code class="language-java">@Test  
public void testSendMultiMessage() {  
    for (int i = 0; i &lt; 20; i++) {  
        rabbitTemplate.convertAndSend(  
                EXCHANGE_NORMAL,  
                ROUTING_KEY_NORMAL,  
                "测试死信情况2：消息数量超过队列的最大容量" + i);  
    }  
}</code></pre>
    <p>
    </p>
    <h3>
     2、接收消息的代码
    </h3>
    <p>
     消息接收代码不再拒绝消息：
    </p>
    <pre><code class="language-java">@RabbitListener(queues = {QUEUE_NORMAL})
public void processMessageNormal(Message message, Channel channel) throws IOException {
    // 监听正常队列
    log.info("★[normal]消息接收到。");
    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
}</code></pre>
    <p>
     重启微服务使代码修改生效。
    </p>
    <p>
    </p>
    <h3>
     3、执行效果
    </h3>
    <p>
     正常队列的参数如下图所示：
    </p>
    <p>
     <img alt="" height="224" src="https://i-blog.csdnimg.cn/direct/700d103374a041dfba95145b62761f20.png" width="1331"/>
    </p>
    <p>
     生产者发送20条消息之后，消费端死信队列接收到前10条消息：
    </p>
    <p>
     <img alt="" height="812" src="https://i-blog.csdnimg.cn/direct/a08c3ce922da44c697e2c4f8bf67d8d3.png" width="1170"/>
    </p>
    <h2>
     四、消息超时未消费
    </h2>
    <h3>
     1、发送消息的代码
    </h3>
    <p>
     正常发送一条消息即可，所以使用第一个例子的代码。
    </p>
    <pre><code class="language-java">@Test
public void testSendMessageTimeout() {
    rabbitTemplate
            .convertAndSend(
                    EXCHANGE_NORMAL,
                    ROUTING_KEY_NORMAL,
                    "测试死信情况3：消息超时");
}</code></pre>
    <p>
    </p>
    <h3>
     2、执行效果
    </h3>
    <p>
     队列参数生效：
    </p>
    <p>
     <img alt="" height="271" src="https://i-blog.csdnimg.cn/direct/2be78aee7914475ca91e3abea66f716f.png" width="1460"/>
    </p>
    <p>
     因为没有消费端监听程序，所以消息未超时前滞留在队列中：
    </p>
    <p>
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/270f30615b5941d5b53063167c2238cc.png" width="1516"/>
    </p>
    <p>
     消息超时后，进入死信队列：
    </p>
    <p>
     <img alt="" height="121" src="https://i-blog.csdnimg.cn/direct/efb2529075d941e0bbb67ebcd32cdcfa.png" width="1240"/>
    </p>
    <p>
    </p>
    <h2>
     延迟队列
    </h2>
    <p>
     <img alt="" height="429" src="https://i-blog.csdnimg.cn/direct/feb7b50268934de4be7d2693503b4e96.png" width="1136"/>
    </p>
    <p>
     实现思路•
    </p>
    <p>
     方案1：借助消息超时时间+死信队列（就是刚刚我们测试的例子）
    </p>
    <p>
     方案2：给RabbitMQ安装插件
    </p>
    <p>
     <img alt="" height="737" src="https://i-blog.csdnimg.cn/direct/647e87b978024ca788dc31c41a62649e.png" width="1424"/>
    </p>
    <p>
     基于插件的延迟队列
    </p>
    <h2>
     操作012：延迟插件
    </h2>
    <h2>
     一、插件简介
    </h2>
    <ul>
     <li>
      <p>
       官网地址：
       <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" title="GitHub - rabbitmq/rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ">
        GitHub - rabbitmq/rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ
       </a>
      </p>
     </li>
     <li>
      <p>
       延迟极限：最多两天
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     二、插件安装
    </h2>
    <h3>
     1、确定卷映射目录
    </h3>
    <pre><code class="language-java">docker inspect rabbitmq</code></pre>
    <p>
     运行结果：
    </p>
    <pre><code class="language-java">        "Mounts": [
            {
                "Type": "volume",
                "Name": "rabbitmq-plugin",
                "Source": "/var/lib/docker/volumes/rabbitmq-plugin/_data",
                "Destination": "/plugins",
                "Driver": "local",
                "Mode": "z",
                "RW": true,
                "Propagation": ""
            },
            {
                "Type": "volume",
                "Name": "cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11",
                "Source": "/var/lib/docker/volumes/cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11/_data",
                "Destination": "/var/lib/rabbitmq",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ]</code></pre>
    <p>
     和容器内/plugins目录对应的宿主机目录是：/var/lib/docker/volumes/rabbitmq-plugin/_data
    </p>
    <p>
     <strong>
      进入
     </strong>
     /var/lib/docker/volumes/rabbitmq-plugin/_data
    </p>
    <h3>
     2、下载延迟插件
    </h3>
    <p>
     官方文档说明页地址：
     <a href="https://www.rabbitmq.com/community-plugins.html" rel="nofollow" title="Community Plugins | RabbitMQ">
      Community Plugins | RabbitMQ
     </a>
    </p>
    <p>
     <img alt="" height="310" src="https://i-blog.csdnimg.cn/direct/b40a6d3216cc4a3eb8a892f09aabc506.png" width="1479"/>
    </p>
    <p>
     下载插件安装文件：
    </p>
    <pre><code class="language-java">wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3.13.0/rabbitmq_delayed_message_exchange-3.13.0.ez
mv rabbitmq_delayed_message_exchange-3.13.0.ez /var/lib/docker/volumes/rabbitmq-plugin/_data</code></pre>
    <h3>
     3、启用插件
    </h3>
    <pre><code class="language-java"># 登录进入容器内部
docker exec -it rabbitmq /bin/bash
​
# rabbitmq-plugins命令所在目录已经配置到$PATH环境变量中了，可以直接调用
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
​
# 退出Docker容器
exit
​
# 重启Docker容器
docker restart rabbitmq</code></pre>
    <p>
    </p>
    <h3>
     4、确认
    </h3>
    <p>
     确认点1：查看当前节点已启用插件的列表：
    </p>
    <p>
     <img alt="" height="198" src="https://i-blog.csdnimg.cn/direct/200fbf21c20f48b482170c8ec607caf6.png" width="1296"/>
    </p>
    <p>
     确认点2：如果创建新交换机时可以在type中看到x-delayed-message选项，那就说明插件安装好了
    </p>
    <p>
     <img alt="" height="434" src="https://i-blog.csdnimg.cn/direct/d66f892383e14b39842f48f404703f9e.png" width="1406"/>
    </p>
    <h2>
     三、创建交换机
    </h2>
    <p>
     rabbitmq_delayed_message_exchange插件在工作时要求交换机是x-delayed-message类型才可以，创建方式如下：
    </p>
    <p>
     <img alt="" height="471" src="https://i-blog.csdnimg.cn/direct/78b4b2f29b5242d08a1747381a99a94b.png" width="1631"/>
    </p>
    <p>
     关于x-delayed-type参数的理解：
    </p>
    <blockquote>
     <p>
      原本指定交换机类型的地方使用了x-delayed-message这个值，那么这个交换机除了支持延迟消息之外，到底是direct、fanout、topic这些类型中的哪一个呢？
     </p>
     <p>
      这里就额外使用x-delayed-type来指定交换机本身的类型
     </p>
    </blockquote>
    <p>
    </p>
    <h2>
     四、代码测试
    </h2>
    <h3>
     1、生产者端代码
    </h3>
    <pre><code class="language-java">@Test
public void testSendDelayMessage() {
    rabbitTemplate.convertAndSend(
            EXCHANGE_DELAY,
            ROUTING_KEY_DELAY,
            "测试基于插件的延迟消息 [" + new SimpleDateFormat("hh:mm:ss").format(new Date()) + "]",
            messageProcessor -&gt; {
​
                // 设置延迟时间：以毫秒为单位
                messageProcessor.getMessageProperties().setHeader("x-delay", "10000");
​
                return messageProcessor;
            });
}</code></pre>
    <p>
    </p>
    <h3>
     2、消费者端代码
    </h3>
    <h4>
     ①情况A：资源已创建
    </h4>
    <pre><code class="language-java">package com.atguigu.mq.listener;
​
import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
​
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;  
  
@Component  
@Slf4j
public class MyDelayMessageListener {
    
    public static final String QUEUE_DELAY = "queue.delay.video";
    
    @RabbitListener(queues = {QUEUE_DELAY})
    public void process(String dataString, Message message, Channel channel) throws IOException {  
        log.info("[生产者]" + dataString);
        log.info("[消费者]" + new SimpleDateFormat("hh:mm:ss").format(new Date()));
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }
​
}</code></pre>
    <p>
    </p>
    <h4>
     ②情况B：资源未创建
    </h4>
    <pre><code class="language-java">package com.atguigu.mq.listener;  
​
import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;  
import org.springframework.amqp.rabbit.annotation.*;  
import org.springframework.stereotype.Component;  
​
import java.io.IOException;  
import java.text.SimpleDateFormat;  
import java.util.Date;  
  
@Component  
@Slf4j
public class MyDelayMessageListener {  
  
    public static final String EXCHANGE_DELAY = "exchange.delay.video";
    public static final String ROUTING_KEY_DELAY = "routing.key.delay.video";
    public static final String QUEUE_DELAY = "queue.delay.video";
  
    @RabbitListener(bindings = @QueueBinding(  
        value = @Queue(value = QUEUE_DELAY, durable = "true", autoDelete = "false"),  
        exchange = @Exchange(  
                value = EXCHANGE_DELAY,   
                durable = "true",   
                autoDelete = "false",   
                type = "x-delayed-message",   
                arguments = @Argument(name = "x-delayed-type", value = "direct")),  
        key = {ROUTING_KEY_DELAY}  
    ))  
    public void process(String dataString, Message message, Channel channel) throws IOException {  
        log.info("[生产者]" + dataString);  
        log.info("[消费者]" + new SimpleDateFormat("hh:mm:ss").format(new Date()));  
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);  
    }  
​
}</code></pre>
    <p>
    </p>
    <h3>
     3、执行效果
    </h3>
    <h4>
     ①交换机类型
    </h4>
    <p>
     <img alt="" height="93" src="https://i-blog.csdnimg.cn/direct/e82dcb1103d342b0b01c818686ce3e41.png" width="1267"/>
    </p>
    <h4>
     ②生产者端效果
    </h4>
    <p>
     注意：使用rabbitmq_delayed_message_exchange插件后，即使消息成功发送到队列上，也会导致returnedMessage()方法执行
    </p>
    <p>
     <img alt="" height="301" src="https://i-blog.csdnimg.cn/direct/a32e878030dd42cab9cae1f2fcc5f47d.png" width="1230"/>
    </p>
    <h4>
     ③消费者端效果
    </h4>
    <p>
     <img alt="" height="149" src="https://i-blog.csdnimg.cn/direct/4515be181f454925a62b9c5dcc6850f4.png" width="1037"/>
    </p>
    <p>
    </p>
    <h2 style="background-color:transparent">
     操作013：事务消息之生产者端
    </h2>
    <p>
     <img alt="" height="626" src="https://i-blog.csdnimg.cn/direct/73a13242959045a99030c49de9417f56.png" width="1320"/>
    </p>
    <p>
     <img alt="" height="657" src="https://i-blog.csdnimg.cn/direct/3bf67af46dba4cdba87243dceb487397.png" width="1349"/>
    </p>
    <p>
     <img alt="" height="508" src="https://i-blog.csdnimg.cn/direct/13151456cf7b43a9ba5a9580a740a00a.png" width="1155"/>
    </p>
    <h2 style="background-color:transparent">
     一、测试代码
    </h2>
    <h3>
     1、引入依赖
    </h3>
    <pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h3>
     2、yaml配置
    </h3>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /</code></pre>
    <p>
    </p>
    <h3>
     3、主启动类
    </h3>
    <pre><code class="language-java">package com.atguigu.mq;
​
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
​
@SpringBootApplication
public class RabbitMQProducerMainType {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQProducerMainType.class, args);
    }
​
}</code></pre>
    <p>
    </p>
    <h3>
     4、相关配置
    </h3>
    <pre><code class="language-java">package com.atguigu.mq.config;
​
import lombok.Data;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.transaction.RabbitTransactionManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
​
@Configuration
@Data
public class RabbitConfig {
​
    @Bean
    public RabbitTransactionManager transactionManager(CachingConnectionFactory connectionFactory) {
        return new RabbitTransactionManager(connectionFactory);
    }
​
    @Bean
    public RabbitTemplate rabbitTemplate(CachingConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setChannelTransacted(true);
        return rabbitTemplate;
    }
}</code></pre>
    <p>
    </p>
    <h3>
     5、测试代码
    </h3>
    <pre><code class="language-java">package com.atguigu.mq.test;
​
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.boot.test.context.SpringBootTest;
​
@SpringBootTest
@Slf4j
public class RabbitMQTest {
​
    public static final String EXCHANGE_NAME = "exchange.tx.dragon";
    public static final String ROUTING_KEY = "routing.key.tx.dragon";
​
    @Resource
    private RabbitTemplate rabbitTemplate;
​
    @Test
    public void testSendMessageInTx() {
        // 1、发送第一条消息
        rabbitTemplate.convertAndSend(EXCHANGE_NAME, ROUTING_KEY, "I am a dragon(tx msg ~~~01)");
​
        // 2、抛出异常
        log.info("do bad:" + 10 / 0);
​
        // 3、发送第二条消息
        rabbitTemplate.convertAndSend(EXCHANGE_NAME, ROUTING_KEY, "I am a dragon(tx msg ~~~02)");
    }
​
}</code></pre>
    <p>
    </p>
    <h2>
     二、执行测试
    </h2>
    <h3>
     1、未使用事务
    </h3>
    <p>
     抛出异常前的消息发送了，抛异常后的消息没有发送：
    </p>
    <p>
     <img alt="" height="833" src="https://i-blog.csdnimg.cn/direct/44eaf17bbf754d8491595a387e14fdde.png" width="1676"/>
    </p>
    <p>
     为了不影响后续操作，我们直接在管理界面这里把这条消息消费掉：
    </p>
    <p>
     <img alt="" height="383" src="https://i-blog.csdnimg.cn/direct/5db3d9b7b146480c92cfd42dc6e18dcf.png" width="1528"/>
    </p>
    <p>
    </p>
    <h3>
     2、使用事务
    </h3>
    <h4>
     ①说明
    </h4>
    <p>
     因为在junit中给测试方法使用@Transactional注解默认就会回滚，所以回滚操作需要使用@RollBack注解操控
    </p>
    <h4>
     ②测试提交事务的情况
    </h4>
    <pre><code class="language-java">@Test
@Transactional
@Rollback(value = false)
public void testSendMessageInTx() {
    // 1、发送第一条消息
    rabbitTemplate.convertAndSend(EXCHANGE_NAME, ROUTING_KEY, "I am a dragon(tx msg [commit] ~~~01)");
​
    // 2、发送第二条消息
    rabbitTemplate.convertAndSend(EXCHANGE_NAME, ROUTING_KEY, "I am a dragon(tx msg [commit] ~~~02)");
}</code></pre>
    <p>
     <img alt="" height="1194" src="https://i-blog.csdnimg.cn/direct/d7001d8217804cabba897c8009686c1f.png" width="1578"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h4 style="background-color:transparent">
     ③测试回滚事务的情况
    </h4>
    <pre><code class="language-java">@Test
@Transactional
@Rollback(value = true)
public void testSendMessageInTx() {
    // 1、发送第一条消息
    rabbitTemplate.convertAndSend(EXCHANGE_NAME, ROUTING_KEY, "I am a dragon(tx msg [rollback] ~~~01)");
     // 2、抛出异常
        log.info("do bad:" + 10 / 0);
​
    // 3、发送第二条消息
    rabbitTemplate.convertAndSend(EXCHANGE_NAME, ROUTING_KEY, "I am a dragon(tx msg [rollback] ~~~02)");
}</code></pre>
    <p>
     <img alt="" height="323" src="https://i-blog.csdnimg.cn/direct/73e3b11d75c94d0dab550f8eeaef7418.png" width="1535"/>
    </p>
    <p>
    </p>
    <h2>
    </h2>
    <h2>
     操作014：惰性队列
    </h2>
    <p>
     惰性队列：未设置惰性模式时队列的持久化机制
    </p>
    <p>
     • 创建队列时，在Durability这里有两个选项可以选择
    </p>
    <p>
     • Durable：持久化队列，消息会持久化到硬盘上
    </p>
    <p>
     • Transient：临时队列，不做持久化操作，broker重启后消息会丢失
    </p>
    <p>
     <img alt="" height="373" src="https://i-blog.csdnimg.cn/direct/83d11aaec9b84d3384b3d941ea5ea533.png" width="984"/>
    </p>
    <p>
     <strong>
      惰性队列：未设置惰性模式时队列的持久化机制
     </strong>
    </p>
    <p>
     • 那么Durable队列在存入消息之后，是否是立即保存到硬盘呢？
    </p>
    <p>
     答：队列满了，或者mq服务器关闭的时候就会将消息存储到硬盘当中去
    </p>
    <p>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/eb736906323d468884eb59977a71e9ac.png" width="1340"/>
    </p>
    <p>
    </p>
    <h2>
    </h2>
    <h2>
     一、创建惰性队列
    </h2>
    <h3>
     1、官网说明
    </h3>
    <p>
     <img alt="" height="483" src="https://i-blog.csdnimg.cn/direct/88332e33222e43db831e04d99caf2577.png" width="1378"/>
    </p>
    <p>
     <strong>
      惰性队列：短时间提升缓存消息的能力
     </strong>
    </p>
    <p>
     使用惰性队列的主要原因之一是支持非常长的队列（数百万条消息）。由于各种原因，排队可能会变得很长：
    </p>
    <p>
     • 消费者离线/崩溃/停机进行维护
    </p>
    <p>
     • 突然出现消息进入高峰，生产者的速度超过了消费者
    </p>
    <p>
     • 消费者比正常情况慢
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     • 比较下面两个说法是否是相同的意思：
    </p>
    <p>
     • 立即移动到硬盘
    </p>
    <p>
     • 尽早移动到硬盘
    </p>
    <p>
     • 我认为不一样：
    </p>
    <p>
     • 立即：消息刚进入队列时
    </p>
    <p>
     • 尽早：服务器不繁忙时
    </p>
    <p>
     队列可以创建为
     <code>
      默认
     </code>
     或
     <code>
      惰性
     </code>
     模式，模式指定方式是：
    </p>
    <ul>
     <li>
      <p>
       使用队列策略（建议）
      </p>
     </li>
     <li>
      <p>
       设置
       <code>
        queue.declare
       </code>
       参数
      </p>
     </li>
    </ul>
    <p>
     如果策略和队列参数同时指定，那么队列参数有更高优先级。如果队列模式是在声明时通过可选参数指定的，那么只能通过删除队列再重新创建来修改。
    </p>
    <p>
    </p>
    <h3>
     2、基于策略方式设定
    </h3>
    <pre><code class="language-java"># 登录Docker容器
docker exec -it rabbitmq /bin/bash
​
# 运行rabbitmqctl命令
rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues</code></pre>
    <p>
     命令解读：
    </p>
    <ul>
     <li>
      <p>
       rabbitmqctl命令所在目录是：/opt/rabbitmq/sbin，该目录已配置到Path环境变量
      </p>
     </li>
     <li>
      <p>
       set_policy是子命令，表示设置策略
      </p>
     </li>
     <li>
      <p>
       Lazy是当前要设置的策略名称，是我们自己自定义的，不是系统定义的
      </p>
     </li>
     <li>
      <p>
       "^lazy-queue$"是用正则表达式限定的队列名称，凡是名称符合这个正则表达式的队列都会应用这里的设置
      </p>
     </li>
     <li>
      <p>
       '{"queue-mode":"lazy"}'是一个JSON格式的参数设置指定了队列的模式为"lazy"
      </p>
     </li>
     <li>
      <p>
       –-apply-to参数指定该策略将应用于队列（queues）级别
      </p>
     </li>
     <li>
      <p>
       命令执行后，所有名称符合正则表达式的队列都会应用指定策略，包括未来新创建的队列
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
     如果需要修改队列模式可以执行如下命令（不必删除队列再重建）：
    </p>
    <pre>rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"default"}' --apply-to queues</pre>
    <p>
    </p>
    <h3>
     3、在声明队列时使用参数设定
    </h3>
    <ul>
     <li>
      <p>
       参数名称：x-queue-mode
      </p>
     </li>
     <li>
      <p>
       可用参数值：
      </p>
      <ul>
       <li>
        <p>
         default
        </p>
       </li>
       <li>
        <p>
         lazy
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       不设置就是取值为default
      </p>
     </li>
    </ul>
    <p>
     Java代码原生API设置方式：
    </p>
    <pre>Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-queue-mode", "lazy");
channel.queueDeclare("myqueue", false, false, false, args);</pre>
    <p>
    </p>
    <p>
     Java代码注解设置方式：
    </p>
    <pre>@Queue(value = QUEUE_NAME, durable = "true", autoDelete = "false", arguments = {
    @Argument(name = "x-queue-mode", value = "lazy")
})</pre>
    <p>
    </p>
    <h2>
     二、实操演练
    </h2>
    <h3>
     1、生产者端代码
    </h3>
    <h4>
     ①配置POM
    </h4>
    <pre>    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.1.5&lt;/version&gt;
    &lt;/parent&gt;
​
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre>
    <p>
    </p>
    <h4>
     ②配置YAML
    </h4>
    <pre>spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /</pre>
    <p>
    </p>
    <h4>
     ③主启动类
    </h4>
    <pre>package com.atguigu.mq;
​
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
​
@SpringBootApplication
public class RabbitMQLazyProducer {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQLazyProducer.class, args);
    }
​
}</pre>
    <p>
    </p>
    <h4>
     ④发送消息
    </h4>
    <pre>package com.atguigu.mq.test;
​
import jakarta.annotation.Resource;
import org.junit.jupiter.api.Test;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.boot.test.context.SpringBootTest;
​
@SpringBootTest
public class RabbitMQTest {
​
    public static final String EXCHANGE_LAZY_NAME = "exchange.atguigu.lazy";
    public static final String ROUTING_LAZY_KEY = "routing.key.atguigu.lazy";
​
    @Resource
    private RabbitTemplate rabbitTemplate;
​
    @Test
    public void testSendMessage() {
        rabbitTemplate.convertAndSend(EXCHANGE_LAZY_NAME, ROUTING_LAZY_KEY, "I am a message for test lazy queue.");
    }
​
}</pre>
    <p>
    </p>
    <h3>
     2、消费者端代码
    </h3>
    <h4>
     ①配置POM
    </h4>
    <pre>    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.1.5&lt;/version&gt;
    &lt;/parent&gt;
​
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre>
    <p>
    </p>
    <h4>
     ②配置YAML
    </h4>
    <pre>spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /</pre>
    <p>
    </p>
    <h4>
     ③主启动类
    </h4>
    <pre>package com.atguigu.mq;
​
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
​
@SpringBootApplication
public class RabbitMQLazyConsumerMainType {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQLazyConsumerMainType.class, args);
    }
    
}</pre>
    <p>
    </p>
    <h4>
     ④监听器
    </h4>
    <pre>package com.atguigu.mq.listener;
​
import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.*;
import org.springframework.stereotype.Component;
​
@Component
@Slf4j
public class MyLazyMessageProcessor {
​
    public static final String EXCHANGE_LAZY_NAME = "exchange.atguigu.lazy";
    public static final String ROUTING_LAZY_KEY = "routing.key.atguigu.lazy";
    public static final String QUEUE_LAZY_NAME = "queue.atguigu.lazy";
​
    @RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = QUEUE_LAZY_NAME, durable = "true", autoDelete = "false", arguments = {
            @Argument(name = "x-queue-mode", value = "lazy")
        }),
        exchange = @Exchange(value = EXCHANGE_LAZY_NAME, durable = "true", autoDelete = "false"),
        key = {ROUTING_LAZY_KEY}
    ))
    public void processMessageLazy(String data, Message message, Channel channel) {
        log.info("消费端接收到消息：" + data);
    }
​
}</pre>
    <p>
    </p>
    <h2>
     三、测试
    </h2>
    <ul>
     <li>
      <p>
       先启动消费端
      </p>
     </li>
     <li>
      <p>
       基于消费端@RabbitListener注解中的配置，自动创建了队列
      </p>
     </li>
    </ul>
    <p class="img-center">
     <img alt="image-20231110201151470" height="299" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=file%3A%2F%2F%2FD%3A%2FBaiduNetdiskDownload%2Fmq%2Fmarkdown%2Fassets%2Fimage-20231110201151470.png%3FlastModify%3D1741321567&amp;pos_id=zelWgA67" width="534"/>
    </p>
    <ul>
     <li>
      <p>
       发送消息
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     操作015：优先级队列
    </h2>
    <p>
     • 默认情况：基于队列先进先出的特性，通常来说，先入队的先投递
    </p>
    <p>
     • 设置优先级之后：优先级高的消息更大几率先投递
    </p>
    <p>
     • 关键参数：x-max-priority
    </p>
    <p>
     RabbitMQ允许我们使用一个正整数给消息设定优先级
    </p>
    <p>
     • 消息的优先级数值取值范围：1~255
    </p>
    <p>
     • RabbitMQ官网建议在1~5之间设置消息的优先级（优先级越高，占用CPU、内存等资源越多）
    </p>
    <h2 style="background-color:transparent">
    </h2>
    <h2>
     一、创建相关资源
    </h2>
    <h3>
     1、创建交换机
    </h3>
    <p>
     exchange.test.priority
    </p>
    <p>
     <img alt="" height="626" src="https://i-blog.csdnimg.cn/direct/148385628ff644b4b133e779fe083da6.png" width="1190"/>
    </p>
    <h3>
     2、创建队列
    </h3>
    <p>
     queue.test.priority
    </p>
    <p>
     x-max-priority
    </p>
    <p>
     <img alt="" height="1168" src="https://i-blog.csdnimg.cn/direct/3e3d7f31695b4850bac5269da79639fa.png" width="1638"/>
    </p>
    <p>
    </p>
    <h3>
     3、队列绑定交换机
    </h3>
    <p>
     <img alt="" height="1291" src="https://i-blog.csdnimg.cn/direct/6443ac89e46f4d18b502adbe7c5642f7.png" width="1511"/>
    </p>
    <p>
    </p>
    <h2>
     二、生产者发送消息
    </h2>
    <h3>
     1、配置POM
    </h3>
    <pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h3>
     2、配置YAML
    </h3>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /</code></pre>
    <p>
    </p>
    <h3>
     3、主启动类
    </h3>
    <pre><code class="language-java">package com.atguigu.mq;
​
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
​
@SpringBootApplication
public class RabbitMQPriorityProducer {
​
    public static void main(String[] args) {
        SpringApplication.run(RabbitMQPriorityProducer.class, args);
    }
​
}</code></pre>
    <p>
    </p>
    <h3>
     4、发送消息
    </h3>
    <ul>
     <li>
      <p>
       不要启动消费者程序，让多条不同优先级的消息滞留在队列中
      </p>
     </li>
     <li>
      <p>
       第一次发送优先级为1的消息
      </p>
     </li>
     <li>
      <p>
       第二次发送优先级为2的消息
      </p>
     </li>
     <li>
      <p>
       第三次发送优先级为3的消息
      </p>
     </li>
     <li>
      <p>
       先发送的消息优先级低，后发送的消息优先级高，将来看看消费端是不是先收到优先级高的消息
      </p>
     </li>
    </ul>
    <h4>
     ①第一次发送优先级为1的消息
    </h4>
    <pre><code class="language-java">package com.atguigu.mq.test;
​
import jakarta.annotation.Resource;
import org.junit.jupiter.api.Test;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.boot.test.context.SpringBootTest;
​
@SpringBootTest
public class RabbitMQTest {
​
    public static final String EXCHANGE_PRIORITY = "exchange.test.priority";
    public static final String ROUTING_KEY_PRIORITY = "routing.key.test.priority";
​
    @Resource
    private RabbitTemplate rabbitTemplate;
​
    @Test
    public void testSendMessage() {
        rabbitTemplate.convertAndSend(EXCHANGE_PRIORITY, ROUTING_KEY_PRIORITY, "I am a message with priority 1.", message-&gt;{
            message.getMessageProperties().setPriority(1);
            return message;
        });
    }
​
}</code></pre>
    <p>
    </p>
    <h4>
     ②第二次发送优先级为2的消息
    </h4>
    <pre><code class="language-java">@Test
public void testSendMessage() {
    rabbitTemplate.convertAndSend(EXCHANGE_PRIORITY, ROUTING_KEY_PRIORITY, "I am a message with priority 2.", message-&gt;{
        message.getMessageProperties().setPriority(2);
        return message;
    });
}</code></pre>
    <p>
    </p>
    <h4>
     ③第三次发送优先级为3的消息
    </h4>
    <pre><code class="language-java">@Test
public void testSendMessage() {
    rabbitTemplate.convertAndSend(EXCHANGE_PRIORITY, ROUTING_KEY_PRIORITY, "I am a message with priority 3.", message-&gt;{
        message.getMessageProperties().setPriority(3);
        return message;
    });
}</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/27f4a230118744e981e9c04ba5562b3a.png" width="1447"/>
    </p>
    <h2>
     三、消费端接收消息
    </h2>
    <h3>
     1、配置POM
    </h3>
    <pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.5&lt;/version&gt;
&lt;/parent&gt;
​
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <p>
    </p>
    <h3>
     2、配置YAML
    </h3>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: 192.168.200.100
    port: 5672
    username: guest
    password: 123456
    virtual-host: /</code></pre>
    <p>
    </p>
    <h3>
     3、主启动类
    </h3>
    <pre><code class="language-java">package com.atguigu.mq;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RabbitMQPriorityConsumer {

    public static void main(String[] args) {
        SpringApplication.run(RabbitMQPriorityConsumer.class, args);
    }

}</code></pre>
    <p>
    </p>
    <h3>
     4、监听器
    </h3>
    <pre><code class="language-java">package com.atguigu.mq.listener;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.*;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class MyMessageProcessor {

    public static final String QUEUE_PRIORITY = "queue.test.priority";

    @RabbitListener(queues = {QUEUE_PRIORITY})
    public void processPriorityMessage(String data, Message message, Channel channel) throws IOException {
        log.info(data);

        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }

}</code></pre>
    <p>
    </p>
    <h3>
     5、测试效果
    </h3>
    <p>
     对于已经滞留服务器的消息，只要消费端一启动，就能够收到消息队列的投递，打印效果如下：
    </p>
    <p>
     <img alt="" height="356" src="https://i-blog.csdnimg.cn/direct/113bedfacd3941fa96483efcd045885b.png" width="1242"/>
    </p>
    <p>
    </p>
    <h2 style="background-color:transparent">
    </h2>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36323037393831342f:61727469636c652f64657461696c732f313436303637373738" class_="artid" style="display:none">
 </p>
</div>


