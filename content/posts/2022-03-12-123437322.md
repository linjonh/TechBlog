---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333638373831312f:61727469636c652f64657461696c732f313233343337333232"
layout: post
title: "C后端开发系列文章目录"
date: 2022-03-12 01:37:06 +08:00
description: "C++后端开发系列文章目录_c++后端最好的博客"
keywords: "c++后端最好的博客"
categories: ['后端', 'C']
tags: ['网络', '数据结构', '后端', 'C']
artid: "123437322"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=123437322
    alt: "C后端开发系列文章目录"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=123437322
featuredImagePreview: https://bing.ee123.net/img/rand?artid=123437322
---

# C++后端开发系列文章目录

`提示：还有逐步学习更新中`

#### C++后端开发系列文章目录

* [1 精进基石专栏](#1__5)
* + [1.1 数据结构与算法](#11__6)
  + - [1.1.1 随处可见的红黑树](#111__7)
    - [1.1.2 磁盘存储式的B树与B+树](#112_BB_16)
    - [1.1.3 海量数据去重的Hash与BloomFiIter，](#113_HashBloomFiIter_26)
  + [1.2 设计模式](#12__32)
  + - [1.2.1 创建型设计模式](#121__33)
    - [1.2.2 结构型设计模式](#122__39)
  + [1.3 c++新特性](#13_c_46)
  + - [1.3.1 stl容器，智能指针，正则表达式](#131_stl_47)
    - [1.3.2 新特性的线程，协程，原子操作，lambda表达式](#132_lambda_55)
  + [1.4 Linux工程管理](#14_Linux_61)
  + - [1.4.1 Makefile/cmake/configure](#141_Makefilecmakeconfigure_62)
    - [1.4.2 分布式版本控制git](#142_git_72)
    - [1.4.3Linux系统运行时參数命令](#143Linux_77)
* [2 高性能网络设计专栏](#2__97)
* + [2.1 网络编程](#21__98)
  + - [2.1.1 网络io与select，poll，epoll](#211_ioselectpollepoll_99)
    - [2.1.2 reactor的原理与实现](#212_reactor_106)
    - [2.1.3 http服务器的实现](#213_http_113)
    - [2.1.4 websocket协议与服务器实现](#214_websocket_121)
  + [2.2 网络原理](#22__128)
  + - [2.2.1 服务器百万并发实现](#221__129)
    - [2.2.2 redis，memcached，nginx组件](#222_redismemcachednginx_136)
    - [2.2.3 PosixAPI与网络协议栈](#223_PosixAPI_141)
    - [2.2.4UDP的可靠传输协议QUIC](#224UDPQUIC_150)
  + [2.3 自研框架：协程框架NtyCo的实现](#23_NtyCo_158)
  + - [2.3.1 协程设计原理与汇编实现](#231__159)
    - [2.3.2 协程调度器实现与性能测试](#232__168)
  + [2.4 自研框架：用户态协议栈NtyTcp的实现](#24_NtyTcp_177)
  + - [2.4.1 用户态协议栈设计实现](#241__178)
    - [2.4.2 tcp/ip定时器与滑动窗口](#242_tcpip_184)
    - [2.4.3 手把手设计实现epoll](#243_epoll_189)
* [3 基础组件设计专栏](#3__194)
* + [3.1 池式组件](#31__195)
  + - [3.1.1 手写线程池与性能分析](#311__196)
    - [3.1.2 内存池的实现与场景分析](#312__203)
    - [3.1.3 异步请求池的实现](#313__212)
    - [3.1.4 mysql连接池的实现](#314_mysql_218)
  + [3.2 高性能组件](#32__225)
  + - [3.2.1 原子操作CAS与锁实现](#321_CAS_226)
    - [3.2.2 无锁消息队列实现](#322__230)
    - [3.2.3 定时器方红黑树，时间轮，最小堆](#323__235)
    - [3.2.4 手写死锁检测组件](#324__241)
    - [3.2.5 手写内存泄漏检测组件](#325__248)
    - [3.2.6 手把手实现分布式锁](#326__254)
  + [3.3 开源组件](#33__259)
  + - [3.3.1 libevent/libev框架实战的那些坑](#331_libeventlibev_260)
    - [3.3.2 异步日志方案1og4cpp](#332_1og4cpp_266)
    - [3.3.3 应用层协议设计ProtoBuf/Thrift](#333_ProtoBufThrift_271)
* [4.中间件开发专栏](#4_277)
* + [4.1MySQL](#41MySQL_278)
  + - [4.1.0 MySQL 基础](#410_MySQL__279)
    - [4.1.1 SQL语句，索引，视图，存储过程，触发器](#411_SQL_284)
    - [4.1.2 MySQL索引原理以及SQL优化](#412_MySQLSQL_289)
    - [4.1.3 MYSQL事务原理分析](#413_MYSQL_295)
    - [4.1.4 MYSQL缓存策略](#414_MYSQL_304)
  + [4.2 TiDB](#42_TiDB_313)
  + - [4.2.1 TiDB存储引擎的原理](#421_TiDB_314)
    - [4.2.2 TiDB集群方案与Replication原理](#422_TiDBReplication_318)
  + [4.3 Redis](#43_Redis_322)
  + - [4.3.1Redis相关命令详解及其原理](#431Redis_323)
    - [4.3.2 Redis协议与异步方式](#432_Redis_329)
    - [4.3.3 存储原理与数据模型](#433__333)
    - [4.3.4 主从同步与对象模型](#434__341)
  + [4.4 RocksDB](#44_RocksDB_354)
  + - [4.4.1 不一样的kv存储Rocks的使用场景](#441_kvRocks_355)
    - [4.4.2 Rocks的特殊操作](#442_Rocks_363)
  + [4.5 Nginx](#45_Nginx_370)
  + - [4.5.1 Nginx反向代理与季统参数配置conf原理](#451_Nginxconf_372)
    - [4.5.2 Nginx过滤器模块实觋](#452_Nginx_383)
    - [4.5.3 Nginx Handler模块实现](#453_Nginx_Handler_394)
  + [4.6 MongoDB](#46_MongoDB_406)
  + - [4.6.1 接口编程与文档操作](#461__407)
    - [4.6.2 集群方案与持久化备份](#462__414)
* [5 开源框架专栏](#5__427)
* + [5.1 skynet](#51_skynet_428)
  + - [5.1.1 skynet设计原理](#511_skynet_429)
    - [5.1.2 skynet网层封装以及lua/接口编](#512_skynetlua_434)
    - [5.1.3 skynet重要组件以及手撕游戏项目](#513_skynet_439)
  + [5.2 TARS](#52_TARS_444)
  + - [5.2.1 TARS服务模型原理](#521_TARS_445)
    - [5.2.2 TARS公共框架服务与数据库](#522_TARS_450)
    - [5.2.3 数据监控与务性能压测](#523__455)
  + [5.3 DPDK](#53_DPDK_460)
  + - [5.3.1 DPDKE环境与testpmd/13fwd/skeletion](#531_DPDKEtestpmd13fwdskeletion_461)
    - [5.3.2 DPDK的用户态协议栈](#532_DPDK_468)
    - [5.3.3 千万级流量并发的dns处理](#533_dns_475)
    - [5.3.4 高性能数据处理框架vpp](#534_vpp_481)
    - [5.3.5 DPDK的虚拟交换机框架OVS](#535_DPDKOVS_487)
* [6 Rust项目专栏](#6_Rust_494)
* + [6.1 Rust特性精讲](#61_Rust_495)
  + - [6.1.1 Rust Slice类型与泛型](#611_Rust_Slice_496)
    - [6.1.2 Rust文件操作与错误处理](#612_Rust_505)
    - [6.1.3 Rust并发编程与智能指针](#613_Rust_514)
  + [6.2 组件实现](#62__523)
  + - [6.2.1 网卡速度监控](#621__524)
    - [6.2.2 邮件发送](#622__529)
    - [6.2.3 OAuth2 第三方登陆](#623_OAuth2__533)
  + [6.3 第三方库](#63__539)
  + - [6.3.1 Rust异步框架tokio](#631_Rusttokio_540)
    - [6.3.2 Rust web 框架Warp](#632_Rust_web_Warp_547)
    - [6.3.3 Rusthyper](#633_Rusthyper_553)
  + [6.4 Rust项目 DBProxy代理mysql与Redis](#64_Rust_DBProxymysqlRedis_558)
  + - [6.4.1 DBProxy功能分析与设计实现](#641_DBProxy_559)
    - [6.4.2 DBProxy的MySQL代理](#642_DBProxyMySQL_563)
    - [6.4.3 DBProxy的Redis代理](#643_DBProxyRedis_569)
* [9 上线项目实战](#9__577)
* + [9.1 图床共享云存储](#91__578)
  + - [9.1.0 fastfds环境搭建](#910_fastfds_579)
    - [9.1.1 fastdfs架构分析和配置](#911_fastdfs_581)
    - [9.1.2 fastdfs存储原理](#912_fastdfs_586)
    - [9.1.3 分布式fastdfs存储集群部署](#913_fastdfs_591)
    - [9.1.4 高负载nginx/fastcgi](#914_nginxfastcgi_596)
    - [9.1.5文件传输和接口设计](#915_601)
    - [9.1.6 产品上云公网发布/测试用例](#916__606)
  + [9.2 微服务即时通讯](#92__611)
  + - [9.2.1 IM即时通讯项目框架分析和部署](#921_IM_612)
    - [9.2.2 IM消息服务器/文件传输服务器](#922_IM_621)
    - [9.2.3 消息服务器/路由服务器](#923__627)
    - [9.2.4 数据库代理服务器设计](#924__635)
    - [9.2.5 文件服务器和docker部署](#925_docker_643)
    - [9.2.6 产品上云公网发布/公网测试上线](#926__648)

---

## 1 精进基石专栏

### 1.1 数据结构与算法

#### 1.1.1 随处可见的红黑树

[红黑树C代码实现](https://blog.csdn.net/weixin_43687811/article/details/123437517)

> 红黑树的应用场景进程调度cfs，内存管理
>   
> 红黑树的数学证明与推导
>   
> 手撕红黑树的左旋与右旋
>   
> 红黑树添加的实现与添加三种情况的证明
>   
> 红黑树删除的实现与删除四种情况的证明
>   
> 红黑树的线程安全的做法
>   
> 分析红黑树工程实用的特点

#### 1.1.2 磁盘存储式的B树与B+树

> 磁盘结构分析与数据存储原理
>   
> 多叉树的运用以及B树的定义证明
>   
> B树插入的两种分裂
>   
> B树删除的前后借位与节点合并
>   
> 手撕B树的插入，删除，遍历，查找
>   
> B+树的定义与实现
>   
> B+树叶子节点的前后指针
>   
> B+树的应用场景与实用特点
>   
> B+树的线程安全做法

#### 1.1.3 海量数据去重的Hash与BloomFiIter，

> hash的原理与hash函数的实现
>   
> hash的应用场景
>   
> 分布式hash的实现原理
>   
> 海量数据去重布隆过滤器
>   
> 布隆过滤的数学推导与证明

### 1.2 设计模式

#### 1.2.1 创建型设计模式

> 单例模式
>   
> 策略模式
>   
> 观察者模式
>   
> 工厂方法模式与抽象工厂模式
>   
> 原型模式

#### 1.2.2 结构型设计模式

> 适配器模式
>   
> 代理模式
>   
> 责任模式
>   
> 状态模式
>   
> 桥接模式
>   
> 组合模式

### 1.3 c++新特性

#### 1.3.1 stl容器，智能指针，正则表达式

> unordered\_map
>   
> stl容器
>   
> hash的用法与原理
>   
> bitmap
>   
> shared\_ptr,unique\_ptr
>   
> besic\_regex，submatch
>   
> 函数对象板function，bind

#### 1.3.2 新特性的线程，协程，原子操作，lambda表达式

> atomic的用法与原理
>   
> thread\_local与condition\_variable
>   
> 异常处理exception\_ptr
>   
> 错误处理error\_category
>   
> coroutine的用法与原理

### 1.4 Linux工程管理

#### 1.4.1 Makefile/cmake/configure

[Makefile/cmake/configure](https://blog.csdn.net/weixin_43687811/article/details/122706928)

> Makefile的规则与make的工作原理
>   
> 单文件编译与多文件编译
>   
> Makefile的參数传递
>   
> 多目录文件央递归编译与嵌套执行make
>   
> Makefile的通配符，伪目标，文件搜索
>   
> Makefile的操作函数与t特殊语法
>   
> configure生成makefile的原则
>   
> cmake的写法

#### 1.4.2 分布式版本控制git

> git的工作流程
>   
> 创建操作与基本操作
>   
> 分支管理，查看提交历史
>   
> git服务器搭建

#### 1.4.3Linux系统运行时參数命令

> 进程间通信设施状态ipcs
>   
> Linux系统运行时长uptime
>   
> CPU平均负载和磁盘活动iostat
>   
> 监控，收集和汇报系统活动5ar
>   
> 监控多处理器使用情况mpstat
>   
> 监控进程的内存使用情况pmap
>   
> 系统管理员调优和基准测量工具nmon
>   
> 密切关注Linux系统glances
>   
> 查看系统调用strace
>   
> ftp服务器基本信息ftptop
>   
> 电量消耗和电源管理powertop
>   
> 监控mysql的线程和性能mytop
>   
> 系统运行參数分析htop/top/atop
>   
> Linux网络统计监控工具netstat
>   
> 显示和修改网络接口控制器ethtool
>   
> 网络数据包分析利刃tcpdump
>   
> 远程登陆服务的标准协议telnet
>   
> 获取实时网络统计信息iptraf
>   
> 显示主机上网络接口带宽使用情况iftop

## 2 高性能网络设计专栏

### 2.1 网络编程

#### 2.1.1 网络io与select，poll，epoll

[网络io与select，poll，epoll](https://blog.csdn.net/weixin_43687811/article/details/123437507)

> socket与文件描述符的关联
>   
> sigio的异步通知
>   
> 多路复用select/poll
>   
> 手撕epoll单线程，多线程，多进程的多种写法
>   
> 代码实现LT/ET的区别

#### 2.1.2 reactor的原理与实现

[reactor的原理与实现](https://blog.csdn.net/weixin_43687811/article/details/122573696)

> 多进程的多种写法
>   
> reactor针对业务实现的优点
>   
> epoll封装send\_cb/recv\_cb/accept\_cb
>   
> reactor多核实现
>   
> 跨干台(select/epoll/kqueue〕的封装reactor

#### 2.1.3 http服务器的实现

[http服务器的实现](https://blog.csdn.net/weixin_43687811/article/details/123437520)

> reactor sendbuffer与recv buffer封装http协议
>   
> http协议格式
>   
> http2.0与http3.0
>   
> 有限状态机fsm解析http
>   
> https的工作流程
>   
> https证书配置

#### 2.1.4 websocket协议与服务器实现

> reactorsendbuffer与recvbuffer封装websocket协议
>   
> websocket#k手流程
>   
> websocket协议头封装
>   
> tcp分包与粘包的解决方案
>   
> websocket数据流的编解码

### 2.2 网络原理

#### 2.2.1 服务器百万并发实现

[服务器百万并发实现](https://blog.csdn.net/weixin_43687811/article/details/122611756)

> 同步处理与异步处理的数据差异
>   
> 网络io线程池异步处理
>   
> ulimit的fd的百万级别支持
>   
> sysctl.conf的rmem与wmem的调优
>   
> conntrack的原理分析

#### 2.2.2 redis，memcached，nginx组件

> redis单线程reactor的实现
>   
> memcached的多线程master—worker的reactor实现
>   
> nginx的多的实现
>   
> 多进程reactor的坑点，惊群，共享内存

#### 2.2.3 PosixAPI与网络协议栈

> connect，listen，accept与三次握手
>   
> listen参数backlog
>   
> syn泛洪的解决方案
>   
> close与四次挥手
>   
> 11个状态迁移
>   
> 大量close与time\_wait的原因与解决方案
>   
> tcp keepalive与应用层心跳包
>   
> 拥塞控制与滑动窗口

#### 2.2.4UDP的可靠传输协议QUIC

> udp的优缺点
>   
> udp高并发的设计方案
>   
> qq早期为什么选择udp作为通信协议
>   
> udp可靠传输原理
>   
> quic协议的设计原理
>   
> quic的开源quiche
>   
> kcp的设计方案与算法原理

### 2.3 自研框架：协程框架NtyCo的实现

#### 2.3.1 协程设计原理与汇编实现

> 协程存在的3个原因
>   
> 同步与异步性能，服务端异步处理，客户端异步请求
>   
> 协程原语switch，resume，Yield，
>   
> 协程切换的三种实现方式，setjmp/longjmp,ucontext,汇编实现
>   
> 汇编实现，寄存器讲解
>   
> 协程初始启动eip寄存器设置
>   
> 协程栈空间定义，独立栈与共享栈的做法
>   
> 协程结构体定义

#### 2.3.2 协程调度器实现与性能测试

> 调度器的定义分析
>   
> 超时集合，就緒队列，io等待集合的实现
>   
> 协程调度的执行流程
>   
> 协程接口实现，异步流程实现
>   
> hook钩子的实现
>   
> 协程实现mysql请求
>   
> 协程多核方案分析
>   
> 协程性能测试

### 2.4 自研框架：用户态协议栈NtyTcp的实现

#### 2.4.1 用户态协议栈设计实现

> 用户态协议栈的存在场景与实现原理
>   
> netmap开源框架
>   
> eth协议，ip协议，udp协议实现
>   
> arp协议实现
>   
> icmp协议实现

#### 2.4.2 tcp/ip定时器与滑动窗口

> tcp协议头实现
>   
> tcp控制块的实现
>   
> 滑动窗口的实现
>   
> 重传定时器，坚持定时器，timewait定时器,keepalive定时器

#### 2.4.3 手把手设计实现epoll

> epoll数据结构封装与线程安全实现
>   
> 协议栈fd就绪回调实现
>   
> epoll接口实现
>   
> LT/ET的实现

## 3 基础组件设计专栏

### 3.1 池式组件

#### 3.1.1 手写线程池与性能分析

[手写线程池与性能分析](https://blog.csdn.net/weixin_43687811/article/details/122955346)

> 线程池的异步处理使用场景
>   
> 线程池的组成 任务队列 执行队列
>   
> 任务回调与条件等待
>   
> 线程池的动态防缩
>   
> 扩展：nginx线程池实现对比分析

#### 3.1.2 内存池的实现与场景分析

[内存池的实现与场景分析](https://blog.csdn.net/weixin_43687811/article/details/123242575)

> 内存池的应用场景与性能分析
>   
> 内存小块分配与管理
>   
> 内存大块分配与管理
>   
> 手写内存池，结构体封装与API实现
>   
> 避免内存泄漏的两种万能方法
>   
> 定位内存泄漏的3种工具
>   
> 扩展：nginx内存池实现

#### 3.1.3 异步请求池的实现

[异步请求池的实现](https://editor.csdn.net/md/?articleId=123388896)

> 异步请求处理流程
>   
> King式四元组，create，commit，callback，destroy
>   
> 异步请求框来封装
>   
> 应用协议redis/dns/http请求封装

#### 3.1.4 mysql连接池的实现

[mysql连接池的实现](https://blog.csdn.net/weixin_43687811/article/details/123389453)

> 连接池性能的影响的2个因素，tcp连接和mysql认证
>   
> 连接请求归还策略
>   
> 连接超时归还策略
>   
> 接断开重连策略
>   
> 连接数量最优策略

### 3.2 高性能组件

#### 3.2.1 原子操作CAS与锁实现

> 互斥锁的使用场景与原理
>   
> 自旋锁的性能分析
>   
> 原子操作的汇编实现

#### 3.2.2 无锁消息队列实现

> 有锁无锁队列性能
>   
> 内存屏障Barrier
>   
> 数组无锁队列设计实现
>   
> 链表无锁队列设计实现

#### 3.2.3 定时器方红黑树，时间轮，最小堆

> 定时器的使用场景
>   
> 定时器的红黑树存储
>   
> 时间轮的实现
>   
> 最小堆的实现
>   
> 分布式定时器的实现

#### 3.2.4 手写死锁检测组件

> 死锁现象以及原理
>   
> pthread\_mutex\_lock/pthread\_mutex\_unlock disym的实现
>   
> 有向图的构建
>   
> 有向图dfs判断环的存在
>   
> 三个原语操作lock\_before，lock\_after,unlock\_after
>   
> 死锁检程线程的实现

#### 3.2.5 手写内存泄漏检测组件

> 内存泄漏现象
>   
> 第三方内存泄漏与代码内存泄漏
>   
> malloc与free的dlsym实现
>   
> 内存检测策略
>   
> 应用场景测试

#### 3.2.6 手把手实现分布式锁

> 多线程资源竞争，互斥锁，自旋锁
>   
> 加锁的异常情况
>   
> 非公平锁的实现
>   
> 公平锁的实现

### 3.3 开源组件

#### 3.3.1 libevent/libev框架实战的那些坑

> 服务端reactor事件封装
>   
> 1ibevent接口分析event\_base\_new，event\_add,event\_del,event\_base\_loop
>   
> memcached网络模块分析
>   
> libev的主要数据结构EV\_WATCH,EV\_WATCH\_LIST
>   
> libevent与libev性能对比

#### 3.3.2 异步日志方案1og4cpp

> 日志库性能瓶颈分析
>   
> 异步日志库设计与实现
>   
> 批量写入与双缓存冲机制
>   
> 奔溃后的日志找回

#### 3.3.3 应用层协议设计ProtoBuf/Thrift

> IM，云平台，nginx，http，redis协议设计
>   
> 如何保证消完整性
>   
> 手撕protobuf IM通信协议
>   
> protobuf序列化与反序列化
>   
> protobuf编码原理

## 4.中间件开发专栏

### 4.1MySQL

#### 4.1.0 MySQL 基础

[MySQL学习笔记1 概述、常用命令、简单查询、数据处理函数、分组查询](https://blog.csdn.net/weixin_43687811/article/details/122675343)
  
[MySQL学习笔记2 distinct、连接查询、子查询、union、limit](https://blog.csdn.net/weixin_43687811/article/details/122738908)
  
[MySQL学习笔记3 表、存储引擎、事务](https://blog.csdn.net/weixin_43687811/article/details/123216177)
  
[MySQL学习笔记4 索引、视图、DBA命令、数据库三范式](https://blog.csdn.net/weixin_43687811/article/details/123217335)

#### 4.1.1 SQL语句，索引，视图，存储过程，触发器

> MYSQL体系结构，SQL执行流程
>   
> SQL CURD与高级查询
>   
> 视图，触发器，存储过程
>   
> MySQL权限管理

#### 4.1.2 MySQL索引原理以及SQL优化

> 索引，约束以及之间的区别
>   
> B+树，聚集索引和辅助索引
>   
> 最左配原则以及覆盖索引
>   
> 索引失效以及索引优化原则
>   
> EXPLAIN执行计划以及优化选择过程分析

#### 4.1.3 MYSQL事务原理分析

> 事务的ACID特性
>   
> MYSQL-并发问题，不可重复读，幻读
>   
> 事务隔离级别
>   
> 锁的类型，锁算法实现以及锁操作对象
>   
> S锁，X锁，IS锁，IX锁
>   
> 记录锁，间隙锁，next—key lock
>   
> 插入意向锁，自增锁
>   
> MVCC原理剖析

#### 4.1.4 MYSQL缓存策略

> 读写分离，连接池的场景以及其局限
>   
> 缓存策略问题分析
>   
> 缓存策略强一致性解决方案
>   
> 缓存策略最终一致性解决方案
>   
> 2种mysql缓存同步方案从数据与触发器+udf
>   
> 缓存同步开源方案go—mysql—transfer
>   
> 缓存同步开源方案canal原理分析
>   
> 3种缓存故障，缓存击穿，缓存穿透，缓存雪崩

### 4.2 TiDB

#### 4.2.1 TiDB存储引擎的原理

> TiKV的Key-Value存储引擎
>   
> 基于RBAC的权限管理
>   
> 数据加密

#### 4.2.2 TiDB集群方案与Replication原理

> 集群三个组件TiDB Server,PD Server,TiKV Server
>   
> Raft协议讲解
>   
> OLTP与OLAP

### 4.3 Redis

#### 4.3.1Redis相关命令详解及其原理

[Redis安装与命令详解](https://blog.csdn.net/weixin_43687811/article/details/122607925)

> string，set，zset，list，hash
>   
> 分布式锁的实现
>   
> lua脚本解决ACID原子性
>   
> Redis事务的ACID性质分析

#### 4.3.2 Redis协议与异步方式

> Redis协议解析
>   
> 特殊协议操作 订阅发布
>   
> 手撕异步redis协议

#### 4.3.3 存储原理与数据模型

> string的三种编码方式int，raw，embstr
>   
> 双向表的list实现
>   
> 字典的实现，hash函数
>   
> 解决键冲突与rehash
>   
> 跳表的实现与数据论证
>   
> 整数集合实现
>   
> 压缩列表原理证明

#### 4.3.4 主从同步与对象模型

> 对象的类型与编码
>   
> 字符串对象
>   
> 列麦对象
>   
> 哈希对象
>   
> 集合对象
>   
> 有序集合
>   
> 类型检测与命令多态
>   
> 内存回收
>   
> 对象共享
>   
> 对象空转时长
>   
> redis的3种集群方式，主从复制，sential，cluster
>   
> 4种持久化方案

### 4.4 RocksDB

#### 4.4.1 不一样的kv存储Rocks的使用场景

> 前缀搜索
>   
> 低优先级写入
>   
> 生存时间的支持
>   
> Transactions
>   
> 快照存储
>   
> 日志结构的数据库引擎

#### 4.4.2 Rocks的特殊操作

> SST文件格式
>   
> 日志与监控
>   
> 数据压缩
>   
> huge pageTLB的支持
>   
> MemTable的两种实现Skiplist与HashSkiplist
>   
> Lua的支持

### 4.5 Nginx

[Nginx环境搭建](https://editor.csdn.net/md/?articleId=123119927)

#### 4.5.1 Nginx反向代理与季统参数配置conf原理

> Nginx静态文件的配置
>   
> Nginx动态接口代理配置
>   
> Nginx对Mqtt协议转发
>   
> Nginx对Rtmp推拉流
>   
> Openresty对Redis缓存数据代理
>   
> shmem的三种实现方式
>   
> 原子操作
>   
> nginx Channel
>   
> 信号
>   
> 信号量

#### 4.5.2 Nginx过滤器模块实觋

> NginxFilter模块运行原理
>   
> 过滤链表的顺序
>   
> 模块开发数据构ngx\_str\_t，ngx\_list\_t，ngx\_buf\_t，ngx\_chain\_t
>   
> error日志的用法
>   
> ngx\_comondt的讲解
>   
> ngx\_http\_modul\_t的执行流程
>   
> 文件锁，互斥锁
>   
> slab共享内存
>   
> 如何解决"惊群"问题
>   
> 如何实现负载均衡

#### 4.5.3 Nginx Handler模块实现

> Nginx Handler模块运行原理
>   
> ngx\_module\_t/ngx\_http\_module\_t的讲解
>   
> ngx\_http\_top\_body\_filter/ngx\_http\_top\_header\_filter的原理
>   
> ngx\_rbtree\_t的使用方法
>   
> ngx\_rbtree\_t自定义添加方法
>   
> Nginx的核心数据构ngx\_cycle\_t，ngx\_event\_moule\_t
>   
> http求的11个处理阶段
>   
> http包体处理
>   
> http响应发送
>   
> Nginx Upstream机制的设计与实觋
>   
> 模块性能测试

### 4.6 MongoDB

#### 4.6.1 接口编程与文档操作

> 文档/集合/聚合函数操作
>   
> 五种索引做法 单字段索引，复合索引，TTL索引，全文索引，hash索引
>   
> GridFS存储大文件
>   
> WiredTiger存储引擎
>   
> WiredTiger的事务
>   
> journal日志

#### 4.6.2 集群方案与持久化备份

> Master—Slave的三个服务Mongos/config/shard服务
>   
> Replica Set读写策略
>   
> Sharding的实现与原理
>   
> 三种Mongodb性能优化策略 时间同步，磁盘预读功能，内存管理

> 项目：MongoDB跨数据中心的数据复制平台
>   
> 抓取Oplog作日志
>   
> 日志分离
>   
> 日志订阅
>   
> 数据路由
>   
> Cache同步

## 5 开源框架专栏

### 5.1 skynet

#### 5.1.1 skynet设计原理

> 多核并发编程-多线程，多进程，csp模型，actor模型
>   
> actor模型实现-lua服务和c服务
>   
> 消息队列实现
>   
> actor消息调度

#### 5.1.2 skynet网层封装以及lua/接口编

> skynet reactor网络模型封装
>   
> socket/socketchannel封装
>   
> 手撕高性能c服务
>   
> lua编程以及lua/c接口编程

#### 5.1.3 skynet重要组件以及手撕游戏项目

> 基础接口skynet.send，skynet.call，skynet.response
>   
> 广播组件multicastd
>   
> 数据共享组件sharedatad datasheet
>   
> 手撕万人同时在线游戏

### 5.2 TARS

#### 5.2.1 TARS服务模型原理

> TARS服务端与客户端
>   
> HTTP开始以及RPC通信
>   
> 基础组件
>   
> 框架服务解析

#### 5.2.2 TARS公共框架服务与数据库

> TarsCpp组件 智能指针与MySQL操作
>   
> 自定义洺实现高效服务管理
>   
> 服务鉴权避免数据泄漏
>   
> 多种远程调用方式

#### 5.2.3 数据监控与务性能压测

> TarsBenchmark测压利器
>   
> TARS染色日志
>   
> TARS服务信息上报
>   
> DCache分布式存储

### 5.3 DPDK

#### 5.3.1 DPDKE环境与testpmd/13fwd/skeletion

> DPDK环境参数讲解
>   
> 多队列网卡的工作原理
>   
> CPU亲和性
>   
> Burst数据包的优缺点
>   
> DPDK轮询模式，异步中断，轮询模式，混合中断轮询模式
>   
> virtio与vhost

#### 5.3.2 DPDK的用户态协议栈

> 内核网络接口KNI的实现原理
>   
> 接收线程/发送线程/KNI线程
>   
> 内存数据结构rte\_mbuf,rte\_mempool
>   
> 端口数据结构rte\_kni,rte\_kniconf,rte\_kni\_ops,rte\_ethconf
>   
> 协议数据结构rte\_ether\_hdrrte\_ipv4\_hdr,rte\_udp\_hdr
>   
> 数据处理接口rte\_eth\_rx\_burst,rte\_kni\_tx\_burst,rte\_pktmbuf\_mtod

#### 5.3.3 千万级流量并发的dns处理

> udp协议包处理
>   
> dnsf协议实现
>   
> 配置文件解析
>   
> 数据结构rte\_ring
>   
> trex数据包性能测试

#### 5.3.4 高性能数据处理框架vpp

> vpp使用vmxnet3
>   
> DPDK ACL实现数据过滤
>   
> VPP web应用
>   
> vpp基础厍VPP Infra
>   
> 高速查找路由表，CAM表

#### 5.3.5 DPDK的虚拟交换机框架OVS

> OVS三大组件ovs—vswitchd,ovsdb—server,openvswitGh.ko
>   
> OVS报文处理机制
>   
> OVS 4种数据路径
>   
> VXLAN数据协议

## 6 Rust项目专栏

### 6.1 Rust特性精讲

#### 6.1.1 Rust Slice类型与泛型

> let关鍵字
>   
> 数据类型
>   
> 字符串字面量
>   
> 元组定义与构(destructing〕赋值
>   
> Rust堆与栈
>   
> 借用ownership使用
>   
> 切片Slice定义
>   
> 结构体使用与实例化

#### 6.1.2 Rust文件操作与错误处理

> mod关鍵字与模块封装
>   
> use关鍵字
>   
> cargo.toml讲
>   
> Gargo build与cargo run
>   
> Rust集合 Vector，HashMap，HashSet
>   
> 错误处理Recoverable 与 UnRecoverable
>   
> Rust泛型与trait特质
>   
> 文件输入输出流的读写操作

#### 6.1.3 Rust并发编程与智能指针

> 管理器Cargo
>   
> 第三方库引入
>   
> 迭代器Iterator
>   
> 闭包Closure
>   
> Box指针
>   
> Rust线程 thread::spawn
>   
> async 关鍵字与程
>   
> 无栈程与有栈程

### 6.2 组件实现

#### 6.2.1 网卡速度监控

> 网卡监控与速度分析的原理
>   
> Rust调用c接口
>   
> 实时运行速率
>   
> Rust模块封装

#### 6.2.2 邮件发送

> 邮件协议讲解
>   
> SMTP发送与POP3收取
>   
> 邮件内容封装与解析

#### 6.2.3 OAuth2 第三方登陆

> OAuth2授权流程讲解
>   
> http请求与响应解析
>   
> github用户授权登陆
>   
> 微信用户授权登陆
>   
> 微博用户授权登陆

### 6.3 第三方库

#### 6.3.1 Rust异步框架tokio

> tokio的使用场景与引用规范
>   
> tokio库 hyper/tonic/tower/bytes
>   
> tokio多线程与调度器
>   
> 异步tcp/udp
>   
> 实现异步sql请求
>   
> tokio性能测试

#### 6.3.2 Rust web 框架Warp

> warp接口编写规范
>   
> htt实现原理
>   
> 字符串序列化
>   
> 接口路由
>   
> 动态检测与追踪

#### 6.3.3 Rusthyper

> hyper使用场景
>   
> 客户端与服务器实现
>   
> 异步设计
>   
> 性能测试

### 6.4 Rust项目 DBProxy代理mysql与Redis

#### 6.4.1 DBProxy功能分析与设计实现

> 项目需求与组件的运行场景
>   
> 代理的request与response
>   
> Passthrough的实现

#### 6.4.2 DBProxy的MySQL代理

> MySQL协议分析
>   
> SQL执行日志捕获
>   
> 获取sql执行时间
>   
> 记录sql用于后续回滚
>   
> 测试用例

#### 6.4.3 DBProxy的Redis代理

> Redis协议分析
>   
> pipeline的实现
>   
> Redis异步执行
>   
> 与MySQL代理合并封装
>   
> 性能测试与分析

## 9 上线项目实战

### 9.1 图床共享云存储

#### 9.1.0 fastfds环境搭建

[项目搭建](https://blog.csdn.net/weixin_43687811/article/details/123121379)

#### 9.1.1 fastdfs架构分析和配置

> fastdfs架构分析
>   
> 快速配置fastdfs
>   
> 上传文件逻辑分析
>   
> 下载文件逻辑分析

#### 9.1.2 fastdfs存储原理

> tracker，storage分析
>   
> 存储机制
>   
> 支持断点续传
>   
> 相同文件内容只保存一份

#### 9.1.3 分布式fastdfs存储集群部署

> 同步机制
>   
> 线性扩容
>   
> 如何实现高可用
>   
> 负戴均衡

#### 9.1.4 高负载nginx/fastcgi

> fastdfs—nginx-module模块分析
>   
> fastcgi请求与响应
>   
> nginx与fastcgi如何通信
>   
> nginx—fastcgi—fastdfs如何实现上传下戴

#### 9.1.5文件传输和接口设计

> http接口设计
>   
> 图床数据厍设计
>   
> 图床文件上传，下戴，分享功能实现
>   
> 业务流程实现

#### 9.1.6 产品上云公网发布/测试用例

> 使用云服务器的各种坑分析
>   
> fiddler监控http请求，postman模拟请求
>   
> wrk测试接口吞吐量
>   
> jmeter压力测试

### 9.2 微服务即时通讯

#### 9.2.1 IM即时通讯项目框架分析和部署

> 接入层、逻辑层、持久层架构划分
>   
> 消息实时性分析
>   
> 即时通讯数据厍设计
>   
> 单聊、群聊消息原理
>   
> 群成员管理
>   
> 未读消息原理
>   
> 池化技术的使用
>   
> 快配置lM项目

#### 9.2.2 IM消息服务器/文件传输服务器

> protobuf通信协议设计
>   
> 数据厍分表设计
>   
> reactor百万并发模型
>   
> login\_server负载均衡
>   
> 登录请求响应模型

#### 9.2.3 消息服务器/路由服务器

> 请求登陆逻辑
>   
> 最近联会话逻辑
>   
> 查询用户在线主题
>   
> 未读消息机制
>   
> 单聊消息推拉机制
>   
> 群聊消息推拉机制
>   
> 路由转发机制

#### 9.2.4 数据库代理服务器设计

> main函数主流程
>   
> 响应流程
>   
> redis缓存
>   
> 消息计数〔单聊和群聊）
>   
> 未读消息机制
>   
> 群成员管理
>   
> 单聊群聊

#### 9.2.5 文件服务器和docker部署

> 在线文件传输机制分析
>   
> 离线文件传输机制分析
>   
> etcd微服务注册与发现
>   
> docker制作与部署

#### 9.2.6 产品上云公网发布/公网测试上线

> 单元测试案例
>   
> testbench如何设计
>   
> IM项目性能压测
>   
> 定制私有功能
>   
> 云服务器部署