---
layout: post
title: "Linux进程间通信初解匿名管道与命名管道"
date: 2025-03-11 11:48:42 +0800
description: "（1）在 Bash 中创建命名管道/tmp/my_fifo 是命名管道的路径。创建后，可以通过文件操作（如 cat、echo）使用命名管道。# 终端 1：写入数据 echo \"Hello from terminal 1\" > /tmp/my_fifo # 终端 2：读取数据 cat /tmp/my_fifo（2）在代码中创建命名管道复制/tmp/my_fifo 是命名管道的路径。0666 是权限模式，表示所有用户可读写。"
keywords: "Linux——进程间通信初解（匿名管道与命名管道）"
categories: ['未分类']
tags: ['服务器', 'Linux', 'Java']
artid: "146165789"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146165789
    alt: "Linux进程间通信初解匿名管道与命名管道"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146165789
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146165789
cover: https://bing.ee123.net/img/rand?artid=146165789
image: https://bing.ee123.net/img/rand?artid=146165789
img: https://bing.ee123.net/img/rand?artid=146165789
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux——进程间通信初解（匿名管道与命名管道）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_2">
     </a>
     进程间通信
    </h2>
    <h3>
     <a id="_4">
     </a>
     进程通信的概念
    </h3>
    <p>
     在Linux中，进程间通信（IPC，Interprocess Communication）是指多个进程之间进行数据交换和同步的机制。由于进程拥有独立的地址空间，无法直接访问彼此的内存，因此需要借助操作系统提供的IPC机制来实现通信。
    </p>
    <p>
     <code>
      本质上通信就是让不同的进程看到同一份资源，然后对其进程读写操作获取或者写入数据。
     </code>
    </p>
    <h3>
     <a id="_10">
     </a>
     进程间通信的主要方式
    </h3>
    <p>
     Linux中常见的进程间通信方式包括以下几种：
    </p>
    <p>
     <strong>
      管道（Pipe）
     </strong>
    </p>
    <p>
     匿名管道：用于具有亲缘关系的进程间通信（如父子进程）。数据单向流动，一端写，另一端读。
    </p>
    <p>
     命名管道（FIFO）：允许无亲缘关系的进程通过文件系统中的一个特殊文件进行通信。
    </p>
    <p>
     <strong>
      消息队列（Message Queue）
     </strong>
    </p>
    <p>
     消息队列允许进程通过发送和接收消息来通信，消息可以按类型区分，支持异步通信。
    </p>
    <p>
     <strong>
      共享内存（Shared Memory）
     </strong>
    </p>
    <p>
     多个进程共享同一块内存区域，通信速度最快，但需要同步机制（如信号量）来避免竞争条件。
    </p>
    <p>
     <strong>
      信号量（Semaphore）
     </strong>
    </p>
    <p>
     用于进程间的同步，通常与共享内存结合使用，防止多个进程同时访问共享资源。
    </p>
    <p>
     <strong>
      信号（Signal）
     </strong>
    </p>
    <p>
     用于通知进程发生了某种事件，是一种异步通信机制，常用于处理异常或中断。
    </p>
    <p>
     <strong>
      套接字（Socket）
     </strong>
    </p>
    <p>
     可用于不同主机或同一主机上的进程间通信，支持网络通信和本地通信。
    </p>
    <p>
     <strong>
      文件（File）
     </strong>
    </p>
    <p>
     进程可以通过读写文件来交换数据，但效率较低，通常用于简单的通信场景。
    </p>
    <h3>
     <a id="_43">
     </a>
     选择依据
    </h3>
    <p>
     选择IPC方式时，需考虑以下因素：
    </p>
    <p>
     <strong>
      通信关系
     </strong>
     ：是否有亲缘关系。
    </p>
    <p>
     <strong>
      通信方向
     </strong>
     ：单向还是双向。
    </p>
    <p>
     <strong>
      数据量
     </strong>
     ：大数据量适合共享内存或套接字。
    </p>
    <p>
     <strong>
      同步需求
     </strong>
     ：是否需要同步机制。
    </p>
    <p>
     <strong>
      性能要求
     </strong>
     ：共享内存性能最高，文件性能最低。
    </p>
    <h2>
     <a id="_57">
     </a>
     匿名管道
    </h2>
    <h3>
     <a id="_59">
     </a>
     管道的概念
    </h3>
    <p>
     管道（Pipe）是Linux中一种最基本的进程间通信（IPC）机制，主要用于具有亲缘关系的进程（如父子进程）之间的通信。
     <strong>
      管道是单向的
     </strong>
     ，数据只能从一端写入，从另一端读取。（
     <code>
      重复：单向管道
     </code>
     ）
    </p>
    <h3>
     <a id="_62">
     </a>
     管道的本质
    </h3>
    <h4>
     <a id="_64">
     </a>
     管道的本质：内核中的环形缓冲区
    </h4>
    <p>
     匿名管道的本质是 内核中的一块内存缓冲区，这块缓冲区是一个 环形队列（Circular Buffer），用于存储进程间传递的数据。环形队列的特点是：
    </p>
    <ul>
     <li>
      <p>
       数据以 先进先出（FIFO） 的方式存储和读取。
      </p>
     </li>
     <li>
      <p>
       缓冲区的大小是固定的（通常为 64KB）。
      </p>
     </li>
     <li>
      <p>
       内核通过维护 读指针 和 写指针 来管理数据的读写。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_73">
     </a>
     环形缓冲区的工作原理
    </h4>
    <p>
     <strong>
      写操作：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       数据从写指针位置开始写入。
      </p>
     </li>
     <li>
      <p>
       写指针向前移动，如果到达缓冲区末尾，则绕回到缓冲区开头。
      </p>
     </li>
     <li>
      <p>
       如果缓冲区已满，写操作会阻塞，直到有空间可用。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      读操作：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       数据从读指针位置开始读取。
      </p>
     </li>
     <li>
      <p>
       读指针向前移动，如果到达缓冲区末尾，则绕回到缓冲区开头。
      </p>
     </li>
     <li>
      <p>
       如果缓冲区为空，读操作会阻塞，直到有数据可读。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_90">
     </a>
     文件描述符的本质
    </h4>
    <p>
     在 Linux 中，文件描述符（File Descriptor, FD） 是一个非负整数，用于标识一个打开的文件或 I/O 资源。每个进程都有一个文件描述符表，用于记录该进程打开的文件或资源。
    </p>
    <p>
     <strong>
      管道的文件描述符
     </strong>
     <br/>
     当调用 pipe(fd) 时，内核会：
    </p>
    <p>
     创建一个环形缓冲区。
    </p>
    <p>
     分配两个文件描述符：
    </p>
    <ul>
     <li>
      <p>
       fd[0]：读端。
      </p>
     </li>
     <li>
      <p>
       fd[1]：写端。
      </p>
     </li>
    </ul>
    <p>
     将这两个文件描述符与环形缓冲区关联。
    </p>
    <p>
     文件描述符的本质是对内核资源的引用，通过它可以访问内核中的缓冲区。
    </p>
    <h4>
     <a id="_108">
     </a>
     内核如何管理管道
    </h4>
    <p>
     <strong>
      内核数据结构
     </strong>
     <br/>
     在内核中，管道是通过以下数据结构实现的：
    </p>
    <pre><code>struct pipe_inode_info：
</code></pre>
    <p>
     这是管道的核心数据结构，包含环形缓冲区的元信息，如：
    </p>
    <ul>
     <li>
      <p>
       缓冲区的大小。
      </p>
     </li>
     <li>
      <p>
       读指针和写指针的位置。
      </p>
     </li>
     <li>
      <p>
       等待队列（用于阻塞的读写操作）。
      </p>
     </li>
    </ul>
    <p>
     文件
    </p>
    <pre><code>	struct file：
</code></pre>
    <p>
     每个文件描述符对应一个 struct file 对象，其中包含：
    </p>
    <ul>
     <li>
      <p>
       指向 pipe_inode_info 的指针。
      </p>
     </li>
     <li>
      <p>
       文件的打开模式（读或写）。
      </p>
     </li>
    </ul>
    <h4>
     <a id="_133">
     </a>
     内核的工作流程
    </h4>
    <p>
     <strong>
      创建管道：
     </strong>
    </p>
    <p>
     调用 pipe(fd) 时，内核会：
    </p>
    <p>
     1，分配一个 pipe_inode_info 结构。
    </p>
    <p>
     2，创建两个 struct file 对象，分别关联到 fd[0] 和 fd[1]。
    </p>
    <p>
     3，将这两个文件描述符返回给用户进程。
    </p>
    <p>
     <strong>
      写数据：
     </strong>
    </p>
    <p>
     当进程调用 write(fd[1], buffer, size) 时：
    </p>
    <ul>
     <li>
      <p>
       内核检查环形缓冲区是否有足够的空间。
      </p>
     </li>
     <li>
      <p>
       如果有空间，将数据从用户空间拷贝到内核缓冲区。
      </p>
     </li>
     <li>
      <p>
       更新写指针。
      </p>
     </li>
     <li>
      <p>
       如果缓冲区已满，进程会阻塞，直到有空间可用。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      读数据：
     </strong>
    </p>
    <p>
     当进程调用 read(fd[0], buffer, size) 时：
    </p>
    <ul>
     <li>
      <p>
       内核检查环形缓冲区是否有数据可读。
      </p>
     </li>
     <li>
      <p>
       如果有数据，将数据从内核缓冲区拷贝到用户空间。
      </p>
     </li>
     <li>
      <p>
       更新读指针。
      </p>
     </li>
     <li>
      <p>
       如果缓冲区为空，进程会阻塞，直到有数据可读。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      关闭管道：
     </strong>
    </p>
    <p>
     当进程调用 close(fd[0]) 或 close(fd[1]) 时：
    </p>
    <ul>
     <li>
      <p>
       内核释放对应的文件描述符。
      </p>
     </li>
     <li>
      <p>
       如果没有进程再使用管道，内核会释放环形缓冲区。
       <br/>
       <img alt="" src="https://i-blog.csdnimg.cn/direct/519e703f24114dca81d308ec885ca288.png"/>
      </p>
     </li>
    </ul>
    <h4>
     <a id="_176">
     </a>
     管道的阻塞与非阻塞
    </h4>
    <p>
     <strong>
      阻塞模式
     </strong>
     <br/>
     默认情况下，管道的读写操作是阻塞的：
    </p>
    <ul>
     <li>
      <p>
       如果缓冲区为空，读操作会阻塞。
      </p>
     </li>
     <li>
      <p>
       如果缓冲区已满，写操作会阻塞。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      非阻塞模式
     </strong>
     <br/>
     可以通过 fcntl() 将文件描述符设置为非阻塞模式：
    </p>
    <ul>
     <li>
      <p>
       如果缓冲区为空，读操作立即返回 -1，并设置 errno 为 EAGAIN。
      </p>
     </li>
     <li>
      <p>
       如果缓冲区已满，写操作立即返回 -1，并设置 errno 为 EAGAIN。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_191">
     </a>
     管道的局限性
    </h3>
    <p>
     <strong>
      单向通信：
     </strong>
    </p>
    <ul>
     <li>
      管道是单向的，只能一端写，另一端读。如果需要双向通信，需要创建两个管道。
     </li>
    </ul>
    <p>
     <strong>
      亲缘关系：
     </strong>
    </p>
    <ul>
     <li>
      匿名管道只能用于具有亲缘关系的进程（如父子进程）。
     </li>
    </ul>
    <p>
     <strong>
      缓冲区大小有限：
     </strong>
    </p>
    <ul>
     <li>
      管道的缓冲区大小通常为 64KB，超过后会阻塞写操作。
     </li>
    </ul>
    <p>
     <strong>
      数据无格式：
     </strong>
    </p>
    <ul>
     <li>
      管道传输的是字节流，没有消息边界。如果需要结构化数据，需要额外处理。
     </li>
    </ul>
    <h3>
     <a id="_208">
     </a>
     代码实例
    </h3>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 文件描述符数组</span>
    pid_t pid<span class="token punctuation">;</span> <span class="token comment">// 进程ID</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用户空间缓冲区</span>

    <span class="token comment">// 创建管道</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果失败，打印错误信息</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建子进程</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果失败，打印错误信息</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 子进程</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭写端</span>
        <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从管道读取数据</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process received: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印数据</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭读端</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 父进程</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭读端</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Hello from parent process!"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向管道写入数据</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭写端</span>
        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子进程结束</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="_251">
     </a>
     命名管道
    </h2>
    <h3>
     <a id="_253">
     </a>
     概念
    </h3>
    <p>
     命名管道（Named Pipe），也称为 FIFO（First In First Out），是一种特殊的
     <strong>
      文件类型
     </strong>
     ，用于进程间通信（IPC）。与匿名管道不同，命名管道：
    </p>
    <ul>
     <li>
      <p>
       有一个文件系统中的路径名，可以被
       <strong>
        无亲缘关系
       </strong>
       的进程访问。
      </p>
     </li>
     <li>
      <p>
       数据以
       <strong>
        先进先出
       </strong>
       的方式传输。
      </p>
     </li>
     <li>
      <p>
       既可以用于本地进程间通信，也可以用于
       <strong>
        网络通信
       </strong>
       （通过文件系统共享）。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_262">
     </a>
     命名管道的定义方式
    </h3>
    <p>
     <strong>
      （1）在 Bash 中创建命名管道
     </strong>
     <br/>
     在 Bash 中，可以使用 mkfifo 命令创建命名管道：
    </p>
    <pre><code class="prism language-bash"><span class="token function">mkfifo</span> /tmp/my_fifo
</code></pre>
    <p>
     /tmp/my_fifo 是命名管道的路径。
    </p>
    <p>
     创建后，可以通过文件操作（如 cat、echo）使用命名管道。
    </p>
    <p>
     示例：
    </p>
    <pre><code class="prism language-bash"><span class="token comment"># 终端 1：写入数据</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Hello from terminal 1"</span> <span class="token operator">&gt;</span> /tmp/my_fifo


<span class="token comment"># 终端 2：读取数据</span>
<span class="token function">cat</span> /tmp/my_fifo
</code></pre>
    <p>
     <strong>
      （2）在代码中创建命名管道
     </strong>
     <br/>
     在 C 代码中，可以使用 mkfifo() 函数创建命名管道：
    </p>
    <pre><code class="prism language-c">复制
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token string">"/tmp/my_fifo"</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <p>
       /tmp/my_fifo 是命名管道的路径。
      </p>
     </li>
     <li>
      <p>
       0666 是权限模式，表示所有用户可读写。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_297">
     </a>
     命名管道的本质
    </h3>
    <p>
     <strong>
      （1）文件系统中的特殊文件
     </strong>
    </p>
    <ul>
     <li>
      <p>
       命名管道在文件系统中表现为一个特殊文件。
      </p>
     </li>
     <li>
      <p>
       它不存储实际数据，而是作为进程间通信的桥梁。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      （2）内核中的缓冲区
     </strong>
    </p>
    <ul>
     <li>
      <p>
       命名管道在内核中也是一个环形缓冲区，与匿名管道类似。
      </p>
     </li>
     <li>
      <p>
       数据以先进先出的方式传输。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      （3）文件描述符
     </strong>
    </p>
    <ul>
     <li>
      <p>
       进程通过 open() 打开命名管道，获取文件描述符。
      </p>
     </li>
     <li>
      <p>
       通过文件描述符进行读写操作。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_313">
     </a>
     命名管道与匿名管道的不同
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        命名管道（FIFO）
       </th>
       <th>
        匿名管道（Pipe）
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         文件系统可见性
        </strong>
       </td>
       <td>
        是，有一个路径名
       </td>
       <td>
        否，仅存在于内核中
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         进程关系
        </strong>
       </td>
       <td>
        可用于无亲缘关系的进程
       </td>
       <td>
        仅用于具有亲缘关系的进程
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         创建方式
        </strong>
       </td>
       <td>
        通过
        <code>
         mkfifo
        </code>
        命令或
        <code>
         mkfifo()
        </code>
        函数
       </td>
       <td>
        通过
        <code>
         pipe()
        </code>
        系统调用
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         持久性
        </strong>
       </td>
       <td>
        持久存在，直到被删除
       </td>
       <td>
        随进程结束而销毁
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         使用场景
        </strong>
       </td>
       <td>
        本地或网络进程间通信
       </td>
       <td>
        父子进程或兄弟进程间通信
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         通信方向
        </strong>
       </td>
       <td>
        单向或双向（需创建两个 FIFO）
       </td>
       <td>
        单向
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         缓冲区大小
        </strong>
       </td>
       <td>
        通常为 64KB
       </td>
       <td>
        通常为 64KB
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         阻塞行为
        </strong>
       </td>
       <td>
        默认阻塞，可设置为非阻塞
       </td>
       <td>
        默认阻塞，可设置为非阻塞
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         内核实现
        </strong>
       </td>
       <td>
        通过
        <code>
         struct inode
        </code>
        和
        <code>
         struct file
        </code>
        管理
       </td>
       <td>
        通过
        <code>
         pipe_inode_info
        </code>
        管理
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用性
        </strong>
       </td>
       <td>
        适用于无亲缘关系的进程
       </td>
       <td>
        适用于有亲缘关系的进程
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         删除方式
        </strong>
       </td>
       <td>
        使用
        <code>
         unlink()
        </code>
        或
        <code>
         rm
        </code>
        命令删除
       </td>
       <td>
        随进程结束自动销毁
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_331">
     </a>
     命名管道的原理与底层解读
    </h3>
    <p>
     （1）
     <strong>
      内核数据结构
     </strong>
    </p>
    <ul>
     <li>
      <p>
       命名管道在内核中通过 struct inode 和 struct file 管理。
      </p>
     </li>
     <li>
      <p>
       数据存储在环形缓冲区中，与匿名管道类似。
      </p>
     </li>
    </ul>
    <p>
     （2）
     <strong>
      读写操作
     </strong>
     <br/>
     <strong>
      写操作：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       如果管道为空，写操作会阻塞，直到有进程读取数据。
      </p>
     </li>
     <li>
      <p>
       如果管道已满，写操作会阻塞，直到有空间可用。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      读操作：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       如果管道为空，读操作会阻塞，直到有进程写入数据。
      </p>
     </li>
     <li>
      <p>
       如果管道有数据，读操作会立即返回数据。
      </p>
     </li>
    </ul>
    <p>
     （3）
     <strong>
      阻塞与非阻塞模式
     </strong>
    </p>
    <ul>
     <li>
      <p>
       默认情况下，命名管道的读写操作是阻塞的。
      </p>
     </li>
     <li>
      <p>
       可以通过 open() 的 O_NONBLOCK 标志设置为非阻塞模式：
      </p>
     </li>
     <li>
      <p>
       非阻塞模式下，读操作立即返回（即使没有数据）。
      </p>
     </li>
     <li>
      <p>
       非阻塞模式下，写操作立即返回（即使没有空间）。
      </p>
     </li>
    </ul>
    <h3>
     <a id="_359">
     </a>
     通信案例
    </h3>
    <p>
     （1）
     <strong>
      Bash 示例
     </strong>
     <br/>
     终端 1：写入数据
    </p>
    <pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"Hello from terminal 1"</span> <span class="token operator">&gt;</span> /tmp/my_fifo
</code></pre>
    <p>
     终端 2：读取数据
    </p>
    <pre><code class="prism language-bash"><span class="token function">cat</span> /tmp/my_fifo
</code></pre>
    <p>
     （2）
     <strong>
      C 代码示例
     </strong>
     <br/>
     写入进程（writer.c）
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fifo_path <span class="token operator">=</span> <span class="token string">"/tmp/my_fifo"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>message <span class="token operator">=</span> <span class="token string">"Hello from writer process!"</span><span class="token punctuation">;</span>

    <span class="token comment">// 打开命名管道（写模式）</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>fifo_path<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 向命名管道写入数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Writer: Data written to FIFO.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      读取进程（reader.c）
     </strong>
    </p>
    <pre><code class="prism language-c">复制
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fifo_path <span class="token operator">=</span> <span class="token string">"/tmp/my_fifo"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 打开命名管道（读模式）</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>fifo_path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从命名管道读取数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader: Data read from FIFO: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     运行步骤：
    </p>
    <p>
     (1)创建命名管道：
    </p>
    <pre><code class="prism language-bash"><span class="token function">mkfifo</span> /tmp/my_fifo
</code></pre>
    <p>
     (2)编译代码：
    </p>
    <pre><code class="prism language-bash">gcc writer.c <span class="token parameter variable">-o</span> writer
gcc reader.c <span class="token parameter variable">-o</span> reader
</code></pre>
    <p>
     (3)运行读取进程（会阻塞，等待数据）：
    </p>
    <pre><code class="prism language-bash">./reader
</code></pre>
    <p>
     (4)运行写入进程：
    </p>
    <pre><code class="prism language-bash">./writer
</code></pre>
    <p>
     (5)输出：
    </p>
    <pre><code>Writer: Data written to FIFO.
Reader: Data read from FIFO: Hello from writer process!
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33343433343532322f:61727469636c652f64657461696c732f313436313635373839" class_="artid" style="display:none">
 </p>
</div>


