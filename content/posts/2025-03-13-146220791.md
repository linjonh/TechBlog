---
layout: post
title: "HeadFirst系列之HeadFirstJava第18天之深入理解原型模式从问题到解决方案含-Java-代码示例"
date: 2025-03-13 06:19:14 +0800
description: "本篇文章将基于《Head First 设计模式》的内容，深入剖析原型模式的概念、应用场景、优缺点，并结合 JDK 和 Spring 框架的实际应用，提供详细的 Java 代码示例，帮助你掌握这一设计模式的精髓。在软件开发中，我们经常需要创建对象，而有些对象的创建成本较高或者结构较为复杂。，如果需要多次创建相同的用户对象，每次都去查询数据库，会造成资源浪费。，确保复制的是一个新的实例，而不是共享同一个对象。：仅复制对象的基本属性，对于对象引用类型，仅复制。是两个不同的对象，但数据相同。示例来演示原型模式。"
keywords: "【HeadFirst系列之HeadFirstJava】第18天之深入理解原型模式：从问题到解决方案（含 Java 代码示例）"
categories: ['Headfirst', 'Headfirst']
tags: ['原型模式', 'Java']
artid: "146220791"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146220791
    alt: "HeadFirst系列之HeadFirstJava第18天之深入理解原型模式从问题到解决方案含-Java-代码示例"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146220791
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146220791
cover: https://bing.ee123.net/img/rand?artid=146220791
image: https://bing.ee123.net/img/rand?artid=146220791
img: https://bing.ee123.net/img/rand?artid=146220791
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【HeadFirst系列之HeadFirstJava】第18天之深入理解原型模式：从问题到解决方案（含 Java 代码示例）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_Java__0">
     </a>
     <strong>
      深入理解原型模式：从问题到解决方案（含 Java 代码示例）
     </strong>
    </h2>
    <p>
     在软件开发中，我们经常需要创建对象，而有些对象的创建成本较高或者结构较为复杂。
     <strong>
      如何在不破坏封装的前提下，高效地创建对象？
     </strong>
     这正是**原型模式（Prototype Pattern）**要解决的问题。
    </p>
    <p>
     本篇文章将基于《Head First 设计模式》的内容，深入剖析原型模式的概念、应用场景、优缺点，并结合 JDK 和 Spring 框架的实际应用，提供详细的 Java 代码示例，帮助你掌握这一设计模式的精髓。
    </p>
    <hr/>
    <h3>
     <a id="_1__8">
     </a>
     <strong>
      📌 1. 什么是原型模式？
     </strong>
    </h3>
    <p>
     <strong>
      原型模式（Prototype Pattern）
      <strong>
       是一种创建型设计模式，它通过
      </strong>
      复制（克隆）已有对象
     </strong>
     来创建新的对象，而不是通过 new 关键字实例化对象。
    </p>
    <p>
     它的核心思想是
     <strong>
      原型对象提供一个克隆方法，让客户端在需要创建对象时，直接调用该方法来获取副本
     </strong>
     。
    </p>
    <blockquote>
     <p>
      <strong>
       定义
      </strong>
      ：
      <strong>
       用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="_2__17">
     </a>
     <strong>
      📌 2. 传统对象创建的问题
     </strong>
    </h3>
    <p>
     在实际开发中，我们通常通过 new 关键字创建对象：
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     但当对象的初始化成本较高时（如涉及数据库查询、复杂计算等），反复 new 一个新对象会影响性能。
    </p>
    <p>
     比如，一个
     <strong>
      数据库查询返回的用户对象
     </strong>
     ，如果需要多次创建相同的用户对象，每次都去查询数据库，会造成资源浪费。
    </p>
    <p>
     <strong>
      原型模式
     </strong>
     就是为了解决
     <strong>
      高成本对象的重复创建问题
     </strong>
     。
    </p>
    <hr/>
    <h3>
     <a id="_3__30">
     </a>
     <strong>
      📌 3. 原型模式如何解决问题？
     </strong>
    </h3>
    <p>
     原型模式提供了一种
     <strong>
      对象克隆机制
     </strong>
     ，让我们可以
     <strong>
      基于一个已有对象创建新对象，而不必重新执行复杂的初始化逻辑
     </strong>
     。
    </p>
    <p>
     <strong>
      实现方式：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Java 提供
       <code>
        Cloneable
       </code>
       接口
      </strong>
      ，允许对象通过
      <code>
       clone()
      </code>
      方法复制自身。
     </li>
     <li>
      通过**浅拷贝（shallow copy）或深拷贝（deep copy）**实现克隆。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_4_Java__39">
     </a>
     <strong>
      📌 4. Java 原型模式代码示例
     </strong>
    </h3>
    <p>
     我们用一个
     <strong>
      “用户信息”
     </strong>
     示例来演示原型模式。
    </p>
    <h4>
     <a id="_1__42">
     </a>
     <strong>
      🎯 1️⃣ 定义一个可克隆的类
     </strong>
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 浅拷贝</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"User: "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", Age: "</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      clone()
     </code>
     方法调用
     <code>
      super.clone()
     </code>
     ，表示让 JVM 直接拷贝该对象。
    </p>
    <h4>
     <a id="_2__65">
     </a>
     <strong>
      🎯 2️⃣ 进行对象克隆
     </strong>
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">User</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> user1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 克隆 user1</span>

        user1<span class="token punctuation">.</span><span class="token function">showUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user2<span class="token punctuation">.</span><span class="token function">showUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user1 == user2 ? "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>user1 <span class="token operator">==</span> user2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，表明是两个不同对象</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      运行结果：
     </strong>
    </p>
    <pre><code>User: Alice, Age: 25
User: Alice, Age: 25
user1 == user2 ? false
</code></pre>
    <p>
     <strong>
      ✅ 说明：
     </strong>
     克隆后的
     <code>
      user2
     </code>
     和
     <code>
      user1
     </code>
     是两个不同的对象，但数据相同。
    </p>
    <hr/>
    <h3>
     <a id="_5__89">
     </a>
     <strong>
      📌 5. 原型模式的应用场景
     </strong>
    </h3>
    <h4>
     <a id="__90">
     </a>
     <strong>
      ✅ 适用于：
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       创建对象成本较高的场景
      </strong>
      （如数据库查询、网络请求等）。
     </li>
     <li>
      <strong>
       对象结构复杂，且需要避免 new 关键字重复创建
      </strong>
      。
     </li>
     <li>
      <strong>
       系统需要提供多个类似对象，而彼此之间仅有少量差异
      </strong>
      。
     </li>
    </ol>
    <h4>
     <a id="__95">
     </a>
     <strong>
      🚫 不适用于：
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       类中包含复杂对象引用，且不支持深拷贝时
      </strong>
      （浅拷贝可能导致共享引用问题）。
     </li>
     <li>
      <strong>
       对象的克隆逻辑过于复杂，甚至比直接 new 还要耗费性能
      </strong>
      。
     </li>
    </ol>
    <hr/>
    <h3>
     <a id="_6__vs__101">
     </a>
     <strong>
      📌 6. 深拷贝 vs 浅拷贝
     </strong>
    </h3>
    <p>
     <strong>
      浅拷贝（Shallow Copy）
     </strong>
     ：仅复制对象的基本属性，对于对象引用类型，仅复制
     <strong>
      内存地址
     </strong>
     （原对象和克隆对象共享同一个引用对象）。
     <br/>
     <strong>
      深拷贝（Deep Copy）
     </strong>
     ：不仅复制基本属性，还
     <strong>
      创建新的对象实例
     </strong>
     ，保证克隆后的对象互不影响。
    </p>
    <h4>
     <a id="__105">
     </a>
     <strong>
      🎯 深拷贝代码实现
     </strong>
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Person</span> cloned <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cloned<span class="token punctuation">.</span>address <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> address<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 深拷贝</span>
        <span class="token keyword">return</span> cloned<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     深拷贝的关键是
     <strong>
      对引用对象也执行
      <code>
       clone()
      </code>
      方法
     </strong>
     ，确保复制的是一个新的实例，而不是共享同一个对象。
    </p>
    <hr/>
    <h3>
     <a id="_7_JDK__Spring__137">
     </a>
     <strong>
      📌 7. JDK 和 Spring 中的应用
     </strong>
    </h3>
    <h4>
     <a id="_JDK__138">
     </a>
     <strong>
      🎯 JDK 应用
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       <code>
        Object.clone()
       </code>
      </strong>
      ：Java 语言中的
      <code>
       clone()
      </code>
      方法就是原型模式的体现。
     </li>
     <li>
      <strong>
       <code>
        ArrayList.clone()
       </code>
      </strong>
      ：
      <code>
       ArrayList
      </code>
      实现了
      <code>
       Cloneable
      </code>
      接口，可通过
      <code>
       clone()
      </code>
      方法创建副本。
     </li>
    </ol>
    <h4>
     <a id="_Spring__142">
     </a>
     <strong>
      🎯 Spring 框架中的应用
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       Spring Bean 的原型模式（Prototype Scope）
      </strong>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      Spring 提供的
      <code>
       prototype
      </code>
      作用域，每次获取 Bean 都会返回一个新实例，这与原型模式的思想一致。
     </li>
    </ol>
    <hr/>
    <h3>
     <a id="_8__155">
     </a>
     <strong>
      📌 8. 原型模式的优缺点
     </strong>
    </h3>
    <h4>
     <a id="__156">
     </a>
     <strong>
      ✅ 优点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       提高对象创建效率
      </strong>
      ，避免重复初始化高成本对象。
     </li>
     <li>
      <strong>
       封装克隆过程
      </strong>
      ，客户端无需关注对象创建细节。
     </li>
     <li>
      <strong>
       简化对象创建逻辑
      </strong>
      ，减少
      <code>
       new
      </code>
      关键字的使用。
     </li>
    </ol>
    <h4>
     <a id="__161">
     </a>
     <strong>
      🚫 缺点
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       对象的拷贝可能涉及复杂的深拷贝逻辑
      </strong>
      ，容易出错。
     </li>
     <li>
      <strong>
       必须确保所有引用对象都支持克隆
      </strong>
      ，否则容易出现共享引用问题。
     </li>
     <li>
      <strong>
       Java 的
       <code>
        Cloneable
       </code>
       接口设计较为陈旧
      </strong>
      ，官方推荐使用
      <strong>
       序列化
      </strong>
      或者
      <strong>
       手动拷贝构造函数
      </strong>
      来代替
      <code>
       clone()
      </code>
      方法。
     </li>
    </ol>
    <hr/>
    <h3>
     <a id="_9__168">
     </a>
     <strong>
      📌 9. 总结
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       原型模式
      </strong>
      通过
      <strong>
       克隆对象
      </strong>
      代替
      <code>
       new
      </code>
      关键字，适用于
      <strong>
       高成本对象的创建
      </strong>
      。
     </li>
     <li>
      Java 提供
      <code>
       Cloneable
      </code>
      接口支持浅拷贝，深拷贝需要手动实现。
     </li>
     <li>
      <strong>
       JDK 和 Spring
      </strong>
      中都使用了原型模式，例如
      <code>
       clone()
      </code>
      方法、Spring 的 Prototype Scope。
     </li>
    </ul>
    <p>
     <strong>
      💡 原型模式的核心：
     </strong>
     <strong>
      “用复制代替创建，提升对象创建效率！”
     </strong>
     🚀
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f5072696e63653134303637382f:61727469636c652f64657461696c732f313436323230373931" class_="artid" style="display:none">
 </p>
</div>


