---
layout: post
title: "算法专题一双指针"
date: 2025-03-16 21:01:34 +0800
description: "先判断cur位置的值，来决定dest走一步还是两步，然后根据dest的位置来判断是否为最后一位，不是dest最后一位，则cur++，如果dest为最后一位，那么cur现在的位置则是最后一个复写的数。但是我们发现这样我们写的代码还是有问题举一个例子。"
keywords: "算法专题一：双指针"
categories: ['未分类']
tags: ['算法']
artid: "144009912"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144009912
    alt: "算法专题一双指针"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144009912
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144009912
cover: https://bing.ee123.net/img/rand?artid=144009912
image: https://bing.ee123.net/img/rand?artid=144009912
img: https://bing.ee123.net/img/rand?artid=144009912
---

# 算法专题一：双指针

## 1.移动零

![](https://i-blog.csdnimg.cn/direct/cd16786550ee40718bfc5768181a5863.png)

题目链接：[283\. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/
"283. 移动零 - 力扣（LeetCode）")

![](https://i-blog.csdnimg.cn/direct/286f1db4709342ec8949f7f76ce28928.png)

**我们可以定义一个dest，一个cur，dest表示数组中不为零的数的最后一位，cur用来遍历数组**

![](https://i-blog.csdnimg.cn/direct/d2a3a8470be946008f7992afb073bc51.png)

    
    
    class Solution {
        public void moveZeroes(int[] nums) {
    
            for(int cur=0,dest=-1;cur<nums.length;cur++){
                if(nums[cur]!=0){
                    dest++;
                    int tem=nums[dest];
                    nums[dest]=nums[cur];
                    nums[cur]=tem;
                }
            }
        }
    }

## 2.复写零

![](https://i-blog.csdnimg.cn/direct/e5ec24c5215f48b4b641ed16d5149632.png)

题目链接：[1089\. 复写零 - 力扣（LeetCode）](https://leetcode.cn/problems/duplicate-zeros/
"1089. 复写零 - 力扣（LeetCode）")

按正序的方式，判断cur是否为0，如果不是cur++，dest++，如果为0，dest+=2，并且dest经过的两位都赋值为0，会导致后面的数被覆盖，所以我们需要换一种方法。

![](https://i-blog.csdnimg.cn/direct/4112eef5dbf34a439e60791fffd470e3.png)

**我们可以先找到最后一个复写的数**

先判断cur位置的值，来决定dest走一步还是两步，然后根据dest的位置来判断是否为最后一位，不是dest最后一位，则cur++，如果dest为最后一位，那么cur现在的位置则是最后一个复写的数。

![](https://i-blog.csdnimg.cn/direct/69fb13c2515f418f9d6aa52df5eeab73.png)

但是我们发现这样我们写的代码还是有问题

举一个例子

![](https://i-blog.csdnimg.cn/direct/a342e0e7e20a4e879abfdc031c5709f0.png)

**此时dest指向的位置已经发生了越界**

所以我们需要再加上一个判断当cur（n-1）的位置为0，则cur--，dest-=2

**最后我们只需要逆序进行复写就可以了**

![](https://i-blog.csdnimg.cn/direct/916ba49dce1b42fda0924330abf15f34.png)

代码如下：

    
    
    class Solution {
        public void duplicateZeros(int[] arr) {
            int cur=0;
            int dest=-1;
            int n=arr.length;
            while(cur<n){
    
                if(arr[cur]!=0){
                    dest+=1;
                }else{
                    dest+=2;
                }
                if(dest >= n - 1){
                    break;
                }
                cur++;
            }
            if(dest==n){
                arr[n-1]=0;
                dest-=2;
                cur--;
            }
            while(cur>=0){
                if(arr[cur]!=0){
                    arr[dest--]=arr[cur--];
                }else{
                    arr[dest--]=0;
                    arr[dest--]=0;
                    cur--;
                }
            }
        }
    }

## 3.快乐数

![](https://i-blog.csdnimg.cn/direct/5ad8cdd4ec6343509895a9901f6176b6.png)

题目链接：[202\. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/
"202. 快乐数 - 力扣（LeetCode）")

![](https://i-blog.csdnimg.cn/direct/b73aa67a92a04b92a449ae03bee29f79.png)

![](https://i-blog.csdnimg.cn/direct/1d1a4d9ec0e7415fb6bcbad0d5403879.png)

所以我们的算法原理：可以定义一个快指针，一个慢指针，快指针每次走两步，慢指针每次走一步，直至两个指针相遇，如果相遇时的数为1，则是快乐数，如果不是1，就不是快乐数。

代码如下：

    
    
    class Solution {
    
        public int sum(int n){
            int sum=0;
            while(n!=0){
            int t=n%10;
            sum+=t*t;
            n/=10;
            }
            return sum;
        }
        public boolean isHappy(int n) {
            int slow=n;
            int fast=sum(n);
            while(slow!=fast){
                slow=sum(slow);
                fast=sum(sum(fast));
            }
            return slow==1;
        }
    }
    

## 4.盛最多水的容器

![](https://i-blog.csdnimg.cn/direct/da7d488fd1034538adb3a7f098af797e.png)

题目链接：[11\. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-
with-most-water/description/ "11. 盛最多水的容器 - 力扣（LeetCode）")

大家看到这个题目一定会想到这道题的暴力解法，套两层for循环，进行暴力枚举，但是这种解法会超时。O（n2）

我们就要需要找到其中的规律

比如这种情况：

![](https://i-blog.csdnimg.cn/direct/f1259aa9172e429d9713cd57506fda5e.png)

我们从中取出一小部分进行讲解

![](https://i-blog.csdnimg.cn/direct/79e7da96dcaf4afb87b7b76d36ba707c.png)

体积无非就是长 * 宽  
我们通过左右的比较，发现6比3大，我们可以将3的位置往前移动一位。

**这样移动的思想就是，我们如果将6往前移动一位，无非就是三种情况**

  1. 宽度减小，高度不变
  2. 宽度减小，高度也减小
  3. 宽度减小，高度不变

无论我们怎么样移动体积都会减小，所以我们每次将两边较小的进行移动。

代码如下：

    
    
    class Solution {
        public int maxArea(int[] height) {
            int left=0;
            int right=height.length-1;
            int result=0;
            while(left < right){
                int v=Math.min(height[left],height[right]) * (right-left);
                result=Math.max(v,result);
                if(height[left]<height[right]){
                    left++;
                }else{
                    right--;
                }
                
            }
            return result;
            
        }
    }

## 5.有效三角形的个数

![](https://i-blog.csdnimg.cn/direct/232d6e2fe5824c2b901a386512baa99d.png)

题目链接：[611\. 有效三角形的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-
triangle-number/description/ "611. 有效三角形的个数 - 力扣（LeetCode）")

![](https://i-blog.csdnimg.cn/direct/0cd76ba0f0d741ab8a62242a252a47f7.png)

规律

![](https://i-blog.csdnimg.cn/direct/c4a0e4d556334e2eaf5060b45d4fbfc0.png)

    
    
    class Solution {
        public int triangleNumber(int[] nums) {
            Arrays.sort(nums);
            int n=nums.length;
            int total=0;
            for(int i=n-1;i>=2;i--){
                int left=0;
                int right=i-1;
                while(left<right){
                if(nums[left] + nums[right]<=nums[i]){
                    left++;
                }else{
                    total+=right-left;
                    right--;
                }
                }
            }
            return total; 
        }
    }

## 6.和为s的两个数字

![](https://i-blog.csdnimg.cn/direct/2e5771f6dbc44ce1a95116c7f32d43d0.png)

题目链接：[LCR 179. 查找总价格为目标值的两个商品 - 力扣（LeetCode）](https://leetcode.cn/problems/he-
wei-sde-liang-ge-shu-zi-lcof/description/ "LCR 179. 查找总价格为目标值的两个商品 -
力扣（LeetCode）")

![](https://i-blog.csdnimg.cn/direct/6ade9e467ce141f4b17cb6727df9a257.png)

    
    
    class Solution {
        public int[] twoSum(int[] price, int target) {
            int n=price.length;
             int left=0;
            int right=n-1;
            while(left<right){
               
                if(price[left]+price[right]<target){
                    left++;
                }else if(price[left]+price[right]>target){
                    right--;
                }else{
                    return new int[]{price[left],price[right]};
                }
            }
            return new int[]{0};
        }
    }

## 7.三数之和

![](https://i-blog.csdnimg.cn/direct/b1024783687a44ac9ffad0edfddb8263.png)

题目链接：[15\. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/
"15. 三数之和 - 力扣（LeetCode）")

![](https://i-blog.csdnimg.cn/direct/4072b1bdfb374900a960953a10eb09c7.png)

![](https://i-blog.csdnimg.cn/direct/cab9d56f8497496387542b4f94f5c6dc.png)

小优化：

![](https://i-blog.csdnimg.cn/direct/760e208375ca4460a682f5c2c1ce7b2e.png)

![](https://i-blog.csdnimg.cn/direct/e84dc6004d0340968dcf026851773f16.png)

    
    
    class Solution {
        public List<List<Integer>> threeSum(int[] nums) {
            Arrays.sort(nums);
            List<List<Integer>> ret =new ArrayList<>();
            int n=nums.length;
            for(int i=0;i<n;){
                int left=i+1;
                int right=n-1;
                int target=-nums[i];
                if(nums[i]>0){
                    break;
                }
                while(left<right){
                    int sum=nums[left]+nums[right];
                    if(sum>target){
                        right--;
                    }else if(sum<target){
                        left++;
                    }else{
                        ret.add(new ArrayList<Integer>(Arrays.asList(nums[i],nums[left],nums[right])));
                        left++;
                        right--;
                        while(left<right && nums[left]==nums[left-1]){
                            left++;
                        }
                        while(left<right && nums[right]==nums[right+1]){
                            right--;
                        }
                    }
                }
                i++;
                while(i<n-1 && nums[i]==nums[i-1]){
                    i++;
                }
            }
            return ret;
            
        }
    }

## 8.四数之和

题目链接： [18\. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/ "18. 四数之和
- 力扣（LeetCode）")

这个题目跟上一个题目基本一致，唯一的差别就是需要外面在套一层循环，整体思路和思想都是一样的。

![](https://i-blog.csdnimg.cn/direct/cd502c9cbd7d4d4e815bdfcf03e083d0.png)

**注意：要把aim定义为long类型，否则会出现整数溢出的问题**

    
    
    class Solution {
        public List<List<Integer>> fourSum(int[] nums, int target) {
            List<List<Integer>> ret=new ArrayList<>();
            Arrays.sort(nums);
            int n=nums.length;
            for(int i=0;i<n;){
                for(int j=i+1;j<n;){
                    int left=j+1;
                    int right=n-1;
                    long aim=(long)target-nums[i]-nums[j];
                    while(left<right){
                        int sum=nums[left]+nums[right];
                        if(sum>aim){
                            right--;
                        }else if(sum<aim){
                            left++;
                        }else{
                            ret.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                            left++;
                            right--;
                            while(left<right && nums[left]==nums[left-1]){
                                left++;
                            }
                            while(left<right && nums[right]==nums[right+1]){
                                right--;
                            }
                        }
                    }
                    j++;
                    while(j<n && nums[j]==nums[j-1]){
                        j++;
                    }
                }
                i++;
                 while(i<n && nums[i]==nums[i-1]){
                        i++;
                    }
            }
            return ret;
        }
    }

希望能对大家有所帮助！！！

![](https://i-blog.csdnimg.cn/direct/30bab5d8e9f246849b942a3cf9085bee.jpeg)



