---
layout: post
title: "C-Excel开源操作库MiniExcel使用教程"
date: 2025-03-08 18:00:56 +0800
description: "目前主流框架大多需要将数据全载入到内存方便操作，但这会导致内存消耗问题，MiniExcel 尝试以 Stream 角度写底层算法逻辑，能让原本1000多MB占用降低到几MB，避免内存不够情况。逻辑 : 以 Test1,000,000x10.xlsx 做基准与主流框架做性能测试，总共 1,000,000 行 * 10 列笔 “HelloWorld”，文件大小 23 MB。Q. 保存如何取代MiniExcel.SaveAs(path, value)，文件存在系统会报已存在错误?"
keywords: "c#里miniexcel怎么用"
categories: ['未分类']
tags: ['开发语言', 'Excel', 'C']
artid: "146119935"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146119935
    alt: "C-Excel开源操作库MiniExcel使用教程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146119935
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146119935
cover: https://bing.ee123.net/img/rand?artid=146119935
image: https://bing.ee123.net/img/rand?artid=146119935
img: https://bing.ee123.net/img/rand?artid=146119935
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# Excel开源操作库MiniExcel使用教程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     简介
     <br/>
     MiniExcel简单、高效避免OOM的.NET处理Excel查、写、填充数据工具。
    </p>
    <p>
     目前主流框架大多需要将数据全载入到内存方便操作，但这会导致内存消耗问题，MiniExcel 尝试以 Stream 角度写底层算法逻辑，能让原本1000多MB占用降低到几MB，避免内存不够情况。
    </p>
    <p>
     image
    </p>
    <p>
     特点
     <br/>
     低内存耗用，避免OOM、频繁 Full GC 情况
     <br/>
     支持即时操作每行数据
     <br/>
     兼具搭配 LINQ 延迟查询特性，能办到低消耗、快速分页等复杂查询
     <br/>
     轻量，不需要安装 Microsoft Office、COM+，DLL小于150KB
     <br/>
     简便操作的 API 风格
     <br/>
     快速开始
     <br/>
     导入、读取 Excel
     <br/>
     导出 、创建 Excel
     <br/>
     模板填充、创建 Excel
     <br/>
     Excel Column Name/Index/Ignore Attribute
     <br/>
     例子
     <br/>
     安装
     <br/>
     请查看 NuGet
    </p>
    <p>
     更新日志
     <br/>
     请查看 Release Notes
    </p>
    <p>
     TODO
     <br/>
     请查看 TODO
    </p>
    <p>
     性能比较、测试
     <br/>
     Benchmarks 逻辑可以在 MiniExcel.Benchmarks 查看或是提交 PR，运行指令
    </p>
    <p>
     dotnet run -p .\benchmarks\MiniExcel.Benchmarks\ -c Release -f netcoreapp3.1 – -f * --join
    </p>
    <p>
     最后一次运行规格、结果 :
    </p>
    <p>
     BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042
     <br/>
     Intel Core i7-7700 CPU 3.60GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores
     <br/>
     [Host] : .NET Framework 4.8 (4.8.4341.0), X64 RyuJIT
     <br/>
     Job-ZYYABG : .NET Framework 4.8 (4.8.4341.0), X64 RyuJIT
     <br/>
     IterationCount=3 LaunchCount=3 WarmupCount=3
    </p>
    <p>
     Benchmark History : Link
    </p>
    <p>
     导入、查询 Excel 比较
     <br/>
     逻辑 : 以 Test1,000,000x10.xlsx 做基准与主流框架做性能测试，总共 1,000,000 行 * 10 列笔 “HelloWorld”，文件大小 23 MB
    </p>
    <p>
     Library Method 最大内存耗用 平均时间
     <br/>
     MiniExcel ‘MiniExcel QueryFirst’ 0.109 MB 0.0007264 sec
     <br/>
     ExcelDataReader ‘ExcelDataReader QueryFirst’ 15.24 MB 10.66421 sec
     <br/>
     MiniExcel ‘MiniExcel Query’ 17.3 MB 14.17933 sec
     <br/>
     ExcelDataReader ‘ExcelDataReader Query’ 17.3 MB 22.56508 sec
     <br/>
     Epplus ‘Epplus QueryFirst’ 1,452 MB 18.19801 sec
     <br/>
     Epplus ‘Epplus Query’ 1,451 MB 23.64747 sec
     <br/>
     OpenXmlSDK ‘OpenXmlSDK Query’ 1,412 MB 52.00327 sec
     <br/>
     OpenXmlSDK ‘OpenXmlSDK QueryFirst’ 1,413 MB 52.34865 sec
     <br/>
     ClosedXml ‘ClosedXml QueryFirst’ 2,158 MB 66.18897 sec
     <br/>
     ClosedXml ‘ClosedXml Query’ 2,184 MB 191.43412 sec
     <br/>
     导出、创建 Excel 比较
     <br/>
     逻辑 : 创建1千万笔 “HelloWorld”
    </p>
    <p>
     Library Method 最大内存耗用 平均时间
     <br/>
     MiniExcel ‘MiniExcel Create Xlsx’ 15 MB 11.53181 sec
     <br/>
     Epplus ‘Epplus Create Xlsx’ 1,204 MB 22.50971 sec
     <br/>
     OpenXmlSdk ‘OpenXmlSdk Create Xlsx’ 2,621 MB 42.47399 sec
     <br/>
     ClosedXml ‘ClosedXml Create Xlsx’ 7,141 MB 140.93992 sec
     <br/>
     读/导入 Excel
    </p>
    <ol>
     <li>
      Query 查询 Excel 返回强型别 IEnumerable 数据 [Try it]
      <br/>
      public class UserAccount
      <br/>
      {
      <!-- -->
      <br/>
      public Guid ID { get; set; }
      <br/>
      public string Name { get; set; }
      <br/>
      public DateTime BoD { get; set; }
      <br/>
      public int Age { get; set; }
      <br/>
      public bool VIP { get; set; }
      <br/>
      public decimal Points { get; set; }
      <br/>
      }
     </li>
    </ol>
    <p>
     var rows = MiniExcel.Query(path);
    </p>
    <p>
     // or
    </p>
    <p>
     using (var stream = File.OpenRead(path))
     <br/>
     var rows = stream.Query();
    </p>
    <p>
     image
    </p>
    <ol start="2">
     <li>
      Query 查询 Excel 返回Dynamic IEnumerable 数据 [Try it]
      <br/>
      Key 系统预设为 A,B,C,D…Z
      <br/>
      MiniExcel 1
      <br/>
      Github 2
      <br/>
      var rows = MiniExcel.Query(path).ToList();
     </li>
    </ol>
    <p>
     // or
     <br/>
     using (var stream = File.OpenRead(path))
     <br/>
     {
     <!-- -->
     <br/>
     var rows = stream.Query().ToList();
    </p>
    <pre><code>Assert.Equal("MiniExcel", rows[0].A);
Assert.Equal(1, rows[0].B);
Assert.Equal("Github", rows[1].A);
Assert.Equal(2, rows[1].B);
</code></pre>
    <p>
     }
    </p>
    <ol start="3">
     <li>
      查询数据以第一行数据当Key [Try it]
      <br/>
      注意 : 同名以右边数据为准
     </li>
    </ol>
    <p>
     Input Excel :
    </p>
    <p>
     Column1 Column2
     <br/>
     MiniExcel 1
     <br/>
     Github 2
     <br/>
     var rows = MiniExcel.Query(useHeaderRow:true).ToList();
    </p>
    <p>
     // or
    </p>
    <p>
     using (var stream = File.OpenRead(path))
     <br/>
     {
     <!-- -->
     <br/>
     var rows = stream.Query(useHeaderRow:true).ToList();
    </p>
    <pre><code>Assert.Equal("MiniExcel", rows[0].Column1);
Assert.Equal(1, rows[0].Column2);
Assert.Equal("Github", rows[1].Column1);
Assert.Equal(2, rows[1].Column2);
</code></pre>
    <p>
     }
    </p>
    <ol start="4">
     <li>
      Query 查询支援延迟加载(Deferred Execution)，能配合LINQ First/Take/Skip办到低消耗、高效率复杂查询
      <br/>
      举例 : 查询第一笔数据
     </li>
    </ol>
    <p>
     var row = MiniExcel.Query(path).First();
     <br/>
     Assert.Equal(“HelloWorld”, row.A);
    </p>
    <p>
     // or
    </p>
    <p>
     using (var stream = File.OpenRead(path))
     <br/>
     {
     <!-- -->
     <br/>
     var row = stream.Query().First();
     <br/>
     Assert.Equal(“HelloWorld”, row.A);
     <br/>
     }
    </p>
    <p>
     与其他框架效率比较 :
    </p>
    <p>
     queryfirst
    </p>
    <ol start="5">
     <li>
      <p>
       查询指定 Sheet 名称
       <br/>
       MiniExcel.Query(path, sheetName: “SheetName”);
       <br/>
       //or
       <br/>
       stream.Query(sheetName: “SheetName”);
      </p>
     </li>
     <li>
      <p>
       查询所有 Sheet 名称跟数据
       <br/>
       var sheetNames = MiniExcel.GetSheetNames(path);
       <br/>
       foreach (var sheetName in sheetNames)
       <br/>
       {
       <!-- -->
       <br/>
       var rows = MiniExcel.Query(path, sheetName: sheetName);
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       查询所有栏(列)
       <br/>
       var columns = MiniExcel.GetColumns(path); // e.g result : [“A”,“B”…]
      </p>
     </li>
    </ol>
    <p>
     or
    </p>
    <p>
     var columns = MiniExcel.GetColumns(path, useHeaderRow: true);
     <br/>
     // e.g result : [“excel表实际的列名称”,“excel表实际的列名称”…]
    </p>
    <p>
     var cnt = columns.Count; // get column count
    </p>
    <ol start="8">
     <li>
      Dynamic Query 转成 IDictionary&lt;string,object&gt; 数据
      <br/>
      foreach(IDictionary&lt;string,object&gt; row in MiniExcel.Query(path))
      <br/>
      {
      <!-- -->
      <br/>
      //…
      <br/>
      }
     </li>
    </ol>
    <p>
     // or
     <br/>
     var rows = MiniExcel.Query(path).Cast&lt;IDictionary&lt;string,object&gt;&gt;();
    </p>
    <ol start="9">
     <li>
      Query 读 Excel 返回 DataTable
      <br/>
      提醒 : 不建议使用，因为DataTable会将数据全载入内存，失去MiniExcel低内存消耗功能。
     </li>
    </ol>
    <p>
     var table = MiniExcel.QueryAsDataTable(path, useHeaderRow: true);
    </p>
    <p>
     image
    </p>
    <ol start="10">
     <li>
      指定单元格开始读取数据
      <br/>
      MiniExcel.Query(path,useHeaderRow:true,startCell:“B3”)
     </li>
    </ol>
    <p>
     image
    </p>
    <ol start="11">
     <li>
      <p>
       合并的单元格填充
       <br/>
       注意 : 效率相对于没有使用合并填充来说差
       <br/>
       底层原因 : OpenXml 标准将 mergeCells 放在文件最下方，导致需要遍历两次 sheetxml
      </p>
      <p>
       var config = new OpenXmlConfiguration()
       <br/>
       {
       <!-- -->
       <br/>
       FillMergedCells = true
       <br/>
       };
       <br/>
       var rows = MiniExcel.Query(path, configuration: config);
      </p>
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     支持不固定长宽多行列填充
    </p>
    <p>
     image
    </p>
    <ol start="12">
     <li>
      读取大文件硬盘缓存 (Disk-Base Cache - SharedString)
      <br/>
      概念 : MiniExcel 当判断文件 SharedString 大小超过 5MB，预设会使用本地缓存，如 10x100000.xlsx(一百万笔数据)，读取不开启本地缓存需要最高内存使用约195MB，开启后降为65MB。但要特别注意，此优化是以时间换取内存减少，所以读取效率会变慢，此例子读取时间从 7.4 秒提高到 27.2 秒，假如不需要能用以下代码关闭硬盘缓存
     </li>
    </ol>
    <p>
     var config = new OpenXmlConfiguration { EnableSharedStringCache = false };
     <br/>
     MiniExcel.Query(path,configuration: config)
    </p>
    <p>
     也能使用 SharedStringCacheSize 调整 sharedString 文件大小超过指定大小才做硬盘缓存
    </p>
    <p>
     var config = new OpenXmlConfiguration { SharedStringCacheSize=500
     <em>
      1024
     </em>
     1024 };
     <br/>
     MiniExcel.Query(path, configuration: config);
    </p>
    <p>
     image
    </p>
    <p>
     image
    </p>
    <p>
     写/导出 Excel
     <br/>
     必须是非abstract 类别有公开无参数构造函数
     <br/>
     MiniExcel SaveAs 支援 IEnumerable参数延迟查询，除非必要请不要使用 ToList 等方法读取全部数据到内存
     <br/>
     图片 : 是否呼叫 ToList 的内存差别
    </p>
    <p>
     image1. 支持集合&lt;匿名类别&gt;或是&lt;强型别&gt; [Try it]
     <br/>
     var path = Path.Combine(Path.GetTempPath(), $“{Guid.NewGuid()}.xlsx”);
     <br/>
     MiniExcel.SaveAs(path, new[] {
     <!-- -->
     <br/>
     new { Column1 = “MiniExcel”, Column2 = 1 },
     <br/>
     new { Column1 = “Github”, Column2 = 2}
     <br/>
     });
    </p>
    <ol start="2">
     <li>
      IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;
      <br/>
      var values = new List&lt;Dictionary&lt;string, object&gt;&gt;()
      <br/>
      {
      <!-- -->
      <br/>
      new Dictionary&lt;string,object&gt;{
      <!-- -->
      { “Column1”, “MiniExcel” }, { “Column2”, 1 } },
      <br/>
      new Dictionary&lt;string,object&gt;{
      <!-- -->
      { “Column1”, “Github” }, { “Column2”, 2 } }
      <br/>
      };
      <br/>
      MiniExcel.SaveAs(path, values);
     </li>
    </ol>
    <p>
     output :
    </p>
    <p>
     Column1 Column2
     <br/>
     MiniExcel 1
     <br/>
     Github 2
     <br/>
     3. IDataReader
     <br/>
     推荐使用，可以避免载入全部数据到内存
     <br/>
     MiniExcel.SaveAs(path, reader);
    </p>
    <p>
     image
    </p>
    <p>
     推荐 DataReader 多表格导出方式(建议使用 Dapper ExecuteReader )
    </p>
    <p>
     using (var cnn = Connection)
     <br/>
     {
     <!-- -->
     <br/>
     cnn.Open();
     <br/>
     var sheets = new Dictionary&lt;string,object&gt;();
     <br/>
     sheets.Add(“sheet1”, cnn.ExecuteReader(“select 1 id”));
     <br/>
     sheets.Add(“sheet2”, cnn.ExecuteReader(“select 2 id”));
     <br/>
     MiniExcel.SaveAs(“Demo.xlsx”, sheets);
     <br/>
     }
    </p>
    <ol start="4">
     <li>
      Datatable
      <br/>
      不推荐使用，会将数据全载入内存
      <br/>
      优先使用 Caption 当栏位名称
      <br/>
      var path = Path.Combine(Path.GetTempPath(), $“{Guid.NewGuid()}.xlsx”);
      <br/>
      var table = new DataTable();
      <br/>
      {
      <!-- -->
      <br/>
      table.Columns.Add(“Column1”, typeof(string));
      <br/>
      table.Columns.Add(“Column2”, typeof(decimal));
      <br/>
      table.Rows.Add(“MiniExcel”, 1);
      <br/>
      table.Rows.Add(“Github”, 2);
      <br/>
      }
     </li>
    </ol>
    <p>
     MiniExcel.SaveAs(path, table);
    </p>
    <ol start="5">
     <li>
      <p>
       Dapper Query
       <br/>
       不推荐使用，会将数据全载入内存，建议使用ExecuteReader
       <br/>
       using (var connection = GetConnection(connectionString))
       <br/>
       {
       <!-- -->
       <br/>
       var rows = connection.Query(@“select ‘MiniExcel’ as Column1,1 as Column2 union all select ‘Github’,2”);
       <br/>
       MiniExcel.SaveAs(path, rows);
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       SaveAs 支持 Stream，生成文件不落地 [Try it]
       <br/>
       using (var stream = new MemoryStream()) //支持 FileStream,MemoryStream…等
       <br/>
       {
       <!-- -->
       <br/>
       stream.SaveAs(values);
       <br/>
       }
      </p>
     </li>
    </ol>
    <p>
     像是 API 导出 Excel
    </p>
    <p>
     public IActionResult DownloadExcel()
     <br/>
     {
     <!-- -->
     <br/>
     var values = new[] {
     <!-- -->
     <br/>
     new { Column1 = “MiniExcel”, Column2 = 1 },
     <br/>
     new { Column1 = “Github”, Column2 = 2}
     <br/>
     };
    </p>
    <pre><code>var memoryStream = new MemoryStream();
memoryStream.SaveAs(values);
memoryStream.Seek(0, SeekOrigin.Begin);
return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
{
    FileDownloadName = "demo.xlsx"
};
</code></pre>
    <p>
     }
    </p>
    <ol start="7">
     <li>
      创建多个工作表(Sheet)
      <br/>
      // 1. Dictionary&lt;string,object&gt;
      <br/>
      var users = new[] { new { Name = “Jack”, Age = 25 }, new { Name = “Mike”, Age = 44 } };
      <br/>
      var department = new[] { new { ID = “01”, Name = “HR” }, new { ID = “02”, Name = “IT” } };
      <br/>
      var sheets = new Dictionary&lt;string, object&gt;
      <br/>
      {
      <!-- -->
      <br/>
      [“users”] = users,
      <br/>
      [“department”] = department
      <br/>
      };
      <br/>
      MiniExcel.SaveAs(path, sheets);
     </li>
    </ol>
    <p>
     // 2. DataSet
     <br/>
     var sheets = new DataSet();
     <br/>
     sheets.Add(UsersDataTable);
     <br/>
     sheets.Add(DepartmentDataTable);
     <br/>
     //…
     <br/>
     MiniExcel.SaveAs(path, sheets);
    </p>
    <p>
     image
    </p>
    <ol start="8">
     <li>
      表格样式选择
      <br/>
      预设样式为
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     不需要样式
    </p>
    <p>
     var config = new OpenXmlConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     TableStyles = TableStyles.None
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, value,configuration:config);
    </p>
    <p>
     image
    </p>
    <ol start="9">
     <li>
      AutoFilter 筛选
      <br/>
      从 0.19.0 支持，可藉由 OpenXmlConfiguration.AutoFilter 设定，预设为True。关闭 AutoFilter 方式 :
     </li>
    </ol>
    <p>
     MiniExcel.SaveAs(path, value, configuration: new OpenXmlConfiguration() { AutoFilter = false });
    </p>
    <ol start="10">
     <li>
      图片生成
      <br/>
      注意 : 目前此功能不支持避免OOM
     </li>
    </ol>
    <p>
     var value = new[] {
     <!-- -->
     <br/>
     new { Name=“github”,Image=File.ReadAllBytes(PathHelper.GetFile(“images/github_logo.png”))},
     <br/>
     new { Name=“google”,Image=File.ReadAllBytes(PathHelper.GetFile(“images/google_logo.png”))},
     <br/>
     new { Name=“microsoft”,Image=File.ReadAllBytes(PathHelper.GetFile(“images/microsoft_logo.png”))},
     <br/>
     new { Name=“reddit”,Image=File.ReadAllBytes(PathHelper.GetFile(“images/reddit_logo.png”))},
     <br/>
     new { Name=“statck_overflow”,Image=File.ReadAllBytes(PathHelper.GetFile(“images/statck_overflow_logo.png”))},
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, value);
    </p>
    <p>
     image
    </p>
    <ol start="11">
     <li>
      Byte Array 文件导出
      <br/>
      从 1.22.0 开始，当值类型为 byte[] 系统预设会转成保存文件路径以便导入时转回 byte[]，如不想转换可以将 OpenXmlConfiguration.EnableConvertByteArray 改为 false，能提升系统效率。
     </li>
    </ol>
    <p>
     image
    </p>
    <ol start="12">
     <li>
      垂直合并相同的单元格
      <br/>
      只支持 xlsx 格式合并单元格
     </li>
    </ol>
    <p>
     var mergedFilePath = Path.Combine(Path.GetTempPath(), $“{Guid.NewGuid().ToString()}.xlsx”);
    </p>
    <p>
     var path = @“…/…/…/…/…/samples/xlsx/TestMergeSameCells.xlsx”;
    </p>
    <p>
     MiniExcel.MergeSameCells(mergedFilePath, path);
    </p>
    <p>
     var memoryStream = new MemoryStream();
    </p>
    <p>
     var path = @“…/…/…/…/…/samples/xlsx/TestMergeSameCells.xlsx”;
    </p>
    <p>
     memoryStream.MergeSameCells(path);
    </p>
    <p>
     合并前后对比
    </p>
    <p>
     before_merge_cells after_merge_cells
    </p>
    <ol start="13">
     <li>
      是否写入 null values cell
      <br/>
      预设:
     </li>
    </ol>
    <p>
     DataTable dt = new DataTable();
    </p>
    <p>
     /* … */
    </p>
    <p>
     DataRow dr = dt.NewRow();
    </p>
    <p>
     dr[“Name1”] = “Somebody once”;
     <br/>
     dr[“Name2”] = null;
     <br/>
     dr[“Name3”] = “told me.”;
    </p>
    <p>
     dt.Rows.Add(dr);
    </p>
    <p>
     MiniExcel.SaveAs(@“C:\temp\Book1.xlsx”, dt);
    </p>
    <p>
     image
    </p>
    <p>
     &lt;x:row r=“2”&gt;
     <br/>
     &lt;x:c r=“A2” t =“str” s=“2”&gt;
     <br/>
     &lt;x:v&gt;Somebody once&lt;/x:v&gt;
     <br/>
     &lt;/x:c&gt;
     <br/>
     &lt;x:c r=“B2” t =“str” s=“2”&gt;
     <br/>
     &lt;x:v&gt;&lt;/x:v&gt;
     <br/>
     &lt;/x:c&gt;
     <br/>
     &lt;x:c r=“C2” t =“str” s=“2”&gt;
     <br/>
     &lt;x:v&gt;told me.&lt;/x:v&gt;
     <br/>
     &lt;/x:c&gt;
     <br/>
     &lt;/x:row&gt;
    </p>
    <p>
     设定不写入:
    </p>
    <p>
     OpenXmlConfiguration configuration = new OpenXmlConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     EnableWriteNullValueCell = false // Default value is true.
     <br/>
     };
    </p>
    <p>
     MiniExcel.SaveAs(@“C:\temp\Book1.xlsx”, dt, configuration: configuration);
    </p>
    <p>
     image
    </p>
    <p>
     &lt;x:row r=“2”&gt;
     <br/>
     &lt;x:c r=“A2” t =“str” s=“2”&gt;
     <br/>
     &lt;x:v&gt;Somebody once&lt;/x:v&gt;
     <br/>
     &lt;/x:c&gt;
     <br/>
     &lt;x:c r=“B2” s=“2”&gt;&lt;/x:c&gt;
     <br/>
     &lt;x:c r=“C2” t =“str” s=“2”&gt;
     <br/>
     &lt;x:v&gt;told me.&lt;/x:v&gt;
     <br/>
     &lt;/x:c&gt;
     <br/>
     &lt;/x:row&gt;
    </p>
    <p>
     模板填充 Excel
     <br/>
     宣告方式类似 Vue 模板 {
     <!-- -->
     {变量名称}}, 或是集合渲染 {
     <!-- -->
     {集合名称.栏位名称}}
     <br/>
     集合渲染支持 IEnumerable/DataTable/DapperRow
    </p>
    <ol>
     <li>
      基本填充
      <br/>
      模板:
      <br/>
      image
     </li>
    </ol>
    <p>
     最终效果:
     <br/>
     image
    </p>
    <p>
     代码:
    </p>
    <p>
     // 1. By POCO
     <br/>
     var value = new
     <br/>
     {
     <!-- -->
     <br/>
     Name = “Jack”,
     <br/>
     CreateDate = new DateTime(2021, 01, 01),
     <br/>
     VIP = true,
     <br/>
     Points = 123
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <p>
     // 2. By Dictionary
     <br/>
     var value = new Dictionary&lt;string, object&gt;()
     <br/>
     {
     <!-- -->
     <br/>
     [“Name”] = “Jack”,
     <br/>
     [“CreateDate”] = new DateTime(2021, 01, 01),
     <br/>
     [“VIP”] = true,
     <br/>
     [“Points”] = 123
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <ol start="2">
     <li>
      IEnumerable 数据填充
      <br/>
      Note1: 同行从左往右以第一个 IEnumerableUse 当列表来源 (不支持同列多集合)
     </li>
    </ol>
    <p>
     模板:
     <br/>
     image
    </p>
    <p>
     最终效果:
     <br/>
     image
    </p>
    <p>
     代码:
    </p>
    <p>
     //1. By POCO
     <br/>
     var value = new
     <br/>
     {
     <!-- -->
     <br/>
     employees = new[] {
     <!-- -->
     <br/>
     new {name=“Jack”,department=“HR”},
     <br/>
     new {name=“Lisa”,department=“HR”},
     <br/>
     new {name=“John”,department=“HR”},
     <br/>
     new {name=“Mike”,department=“IT”},
     <br/>
     new {name=“Neo”,department=“IT”},
     <br/>
     new {name=“Loan”,department=“IT”}
     <br/>
     }
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <p>
     //2. By Dictionary
     <br/>
     var value = new Dictionary&lt;string, object&gt;()
     <br/>
     {
     <!-- -->
     <br/>
     [“employees”] = new[] {
     <!-- -->
     <br/>
     new {name=“Jack”,department=“HR”},
     <br/>
     new {name=“Lisa”,department=“HR”},
     <br/>
     new {name=“John”,department=“HR”},
     <br/>
     new {name=“Mike”,department=“IT”},
     <br/>
     new {name=“Neo”,department=“IT”},
     <br/>
     new {name=“Loan”,department=“IT”}
     <br/>
     }
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <ol start="3">
     <li>
      复杂数据填充
      <br/>
      Note: 支持多 sheet 填充,并共用同一组参数
     </li>
    </ol>
    <p>
     模板:
    </p>
    <p>
     image
    </p>
    <p>
     最终效果:
    </p>
    <p>
     image
    </p>
    <p>
     代码:
    </p>
    <p>
     // 1. By POCO
     <br/>
     var value = new
     <br/>
     {
     <!-- -->
     <br/>
     title = “FooCompany”,
     <br/>
     managers = new[] {
     <!-- -->
     <br/>
     new {name=“Jack”,department=“HR”},
     <br/>
     new {name=“Loan”,department=“IT”}
     <br/>
     },
     <br/>
     employees = new[] {
     <!-- -->
     <br/>
     new {name=“Wade”,department=“HR”},
     <br/>
     new {name=“Felix”,department=“HR”},
     <br/>
     new {name=“Eric”,department=“IT”},
     <br/>
     new {name=“Keaton”,department=“IT”}
     <br/>
     }
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <p>
     // 2. By Dictionary
     <br/>
     var value = new Dictionary&lt;string, object&gt;()
     <br/>
     {
     <!-- -->
     <br/>
     [“title”] = “FooCompany”,
     <br/>
     [“managers”] = new[] {
     <!-- -->
     <br/>
     new {name=“Jack”,department=“HR”},
     <br/>
     new {name=“Loan”,department=“IT”}
     <br/>
     },
     <br/>
     [“employees”] = new[] {
     <!-- -->
     <br/>
     new {name=“Wade”,department=“HR”},
     <br/>
     new {name=“Felix”,department=“HR”},
     <br/>
     new {name=“Eric”,department=“IT”},
     <br/>
     new {name=“Keaton”,department=“IT”}
     <br/>
     }
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <ol start="4">
     <li>
      大数据填充效率比较
      <br/>
      NOTE: 在 MiniExcel 使用 IEnumerable 延迟 ( 不ToList ) 可以节省内存使用
     </li>
    </ol>
    <p>
     image
    </p>
    <ol start="5">
     <li>
      Cell 值自动类别对应
      <br/>
      模板
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     最终效果
    </p>
    <p>
     image
    </p>
    <p>
     类别
    </p>
    <p>
     public class Poco
     <br/>
     {
     <!-- -->
     <br/>
     public string @string { get; set; }
     <br/>
     public int? @int { get; set; }
     <br/>
     public decimal? @decimal { get; set; }
     <br/>
     public double? @double { get; set; }
     <br/>
     public DateTime? datetime { get; set; }
     <br/>
     public bool? @bool { get; set; }
     <br/>
     public Guid? Guid { get; set; }
     <br/>
     }
    </p>
    <p>
     代码
    </p>
    <p>
     var poco = new TestIEnumerableTypePoco { @string = “string”, @int = 123, @decimal = decimal.Parse(“123.45”), @double = (double)123.33, @datetime = new DateTime(2021, 4, 1), @bool = true, @Guid = Guid.NewGuid() };
     <br/>
     var value = new
     <br/>
     {
     <!-- -->
     <br/>
     Ts = new[] {
     <!-- -->
     <br/>
     poco,
     <br/>
     new TestIEnumerableTypePoco{},
     <br/>
     null,
     <br/>
     poco
     <br/>
     }
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <ol start="6">
     <li>
      Example : 列出 Github 专案
      <br/>
      模板
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     最终效果
    </p>
    <p>
     image
    </p>
    <p>
     代码
    </p>
    <p>
     var projects = new[]
     <br/>
     {
     <!-- -->
     <br/>
     new {Name = “MiniExcel”,Link=“https://github.com/shps951023/MiniExcel”,Star=146, CreateTime=new DateTime(2021,03,01)},
     <br/>
     new {Name = “HtmlTableHelper”,Link=“https://github.com/shps951023/HtmlTableHelper”,Star=16, CreateTime=new DateTime(2020,02,01)},
     <br/>
     new {Name = “PocoClassGenerator”,Link=“https://github.com/shps951023/PocoClassGenerator”,Star=16, CreateTime=new DateTime(2019,03,17)}
     <br/>
     };
     <br/>
     var value = new
     <br/>
     {
     <!-- -->
     <br/>
     User = “ITWeiHan”,
     <br/>
     Projects = projects,
     <br/>
     TotalStar = projects.Sum(s =&gt; s.Star)
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value);
    </p>
    <ol start="7">
     <li>
      <p>
       分组数据填充
       <br/>
       var value = new Dictionary&lt;string, object&gt;()
       <br/>
       {
       <!-- -->
       <br/>
       [“employees”] = new[] {
       <!-- -->
       <br/>
       new {name=“Jack”,department=“HR”},
       <br/>
       new {name=“Jack”,department=“HR”},
       <br/>
       new {name=“John”,department=“HR”},
       <br/>
       new {name=“John”,department=“IT”},
       <br/>
       new {name=“Neo”,department=“IT”},
       <br/>
       new {name=“Loan”,department=“IT”}
       <br/>
       }
       <br/>
       };
       <br/>
       MiniExcel.SaveAsByTemplate(path, templatePath, value);
      </p>
     </li>
     <li>
      <p>
       使用@group tag 和 @header` tag
       <br/>
       Before
      </p>
     </li>
    </ol>
    <p>
     before_with_header
    </p>
    <p>
     After
    </p>
    <p>
     after_with_header
    </p>
    <ol start="2">
     <li>
      使用 @group tag 没有 @header tag
      <br/>
      Before
     </li>
    </ol>
    <p>
     before_without_header
    </p>
    <p>
     After
    </p>
    <p>
     after_without_header
    </p>
    <ol start="3">
     <li>
      没有 @group tag
      <br/>
      Before
     </li>
    </ol>
    <p>
     without_group
    </p>
    <p>
     After
    </p>
    <p>
     without_group_after
    </p>
    <ol start="8">
     <li>
      <p>
       DataTable 当参数
       <br/>
       var managers = new DataTable();
       <br/>
       {
       <!-- -->
       <br/>
       managers.Columns.Add(“name”);
       <br/>
       managers.Columns.Add(“department”);
       <br/>
       managers.Rows.Add(“Jack”, “HR”);
       <br/>
       managers.Rows.Add(“Loan”, “IT”);
       <br/>
       }
       <br/>
       var value = new Dictionary&lt;string, object&gt;()
       <br/>
       {
       <!-- -->
       <br/>
       [“title”] = “FooCompany”,
       <br/>
       [“managers”] = managers,
       <br/>
       };
       <br/>
       MiniExcel.SaveAsByTemplate(path, templatePath, value);
      </p>
     </li>
     <li>
      <p>
       其他
      </p>
     </li>
     <li>
      <p>
       检查模版参数
       <br/>
       从 V1.24.0 版本开始，预设忽略模版不存在的参数Key，IgnoreTemplateParameterMissing 可以决定是否抛出错误
      </p>
     </li>
    </ol>
    <p>
     var config = new OpenXmlConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     IgnoreTemplateParameterMissing = false,
     <br/>
     };
     <br/>
     MiniExcel.SaveAsByTemplate(path, templatePath, value, config)
    </p>
    <p>
     image
    </p>
    <p>
     Excel 列属性 (Excel Column Attribute)
    </p>
    <ol>
     <li>
      指定列名称、指定第几列、是否忽略该列
      <br/>
      Excel例子
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     代码
    </p>
    <p>
     public class ExcelAttributeDemo
     <br/>
     {
     <!-- -->
     <br/>
     [ExcelColumnName(“Column1”)]
     <br/>
     public string Test1 { get; set; }
     <br/>
     [ExcelColumnName(“Column2”)]
     <br/>
     public string Test2 { get; set; }
     <br/>
     [ExcelIgnore]
     <br/>
     public string Test3 { get; set; }
     <br/>
     [ExcelColumnIndex(“I”)] // 系统会自动转换"I"为第8列
     <br/>
     public string Test4 { get; set; }
     <br/>
     public string Test5 { get; } //系统会忽略此列
     <br/>
     public string Test6 { get; private set; } //set非公开,系统会忽略
     <br/>
     [ExcelColumnIndex(3)] // 从0开始索引
     <br/>
     public string Test7 { get; set; }
     <br/>
     }
    </p>
    <p>
     var rows = MiniExcel.Query(path).ToList();
     <br/>
     Assert.Equal(“Column1”, rows[0].Test1);
     <br/>
     Assert.Equal(“Column2”, rows[0].Test2);
     <br/>
     Assert.Null(rows[0].Test3);
     <br/>
     Assert.Equal(“Test7”, rows[0].Test4);
     <br/>
     Assert.Null(rows[0].Test5);
     <br/>
     Assert.Null(rows[0].Test6);
     <br/>
     Assert.Equal(“Test4”, rows[0].Test7);
    </p>
    <ol start="2">
     <li>
      自定义Format格式 (ExcelFormatAttribute)
      <br/>
      從 V0.21.0 開始支持有 ToString(string content) 的類別 format
     </li>
    </ol>
    <p>
     类别
    </p>
    <p>
     public class Dto
     <br/>
     {
     <!-- -->
     <br/>
     public string Name { get; set; }
    </p>
    <pre><code>[ExcelFormat("MMMM dd, yyyy")]
public DateTime InDate { get; set; }
</code></pre>
    <p>
     }
    </p>
    <p>
     代码
    </p>
    <p>
     var value = new Dto[] {
     <!-- -->
     <br/>
     new Issue241Dto{ Name=“Jack”,InDate=new DateTime(2021,01,04)},
     <br/>
     new Issue241Dto{ Name=“Henry”,InDate=new DateTime(2020,04,05)},
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, value);
    </p>
    <p>
     效果
    </p>
    <p>
     image
    </p>
    <p>
     Query 支持自定义格式转换
    </p>
    <p>
     image
    </p>
    <ol start="3">
     <li>
      <p>
       指定列宽(ExcelColumnWidthAttribute)
       <br/>
       public class Dto
       <br/>
       {
       <!-- -->
       <br/>
       [ExcelColumnWidth(20)]
       <br/>
       public int ID { get; set; }
       <br/>
       [ExcelColumnWidth(15.50)]
       <br/>
       public string Name { get; set; }
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       多列名对应同一属性
       <br/>
       public class Dto
       <br/>
       {
       <!-- -->
       <br/>
       [ExcelColumnName(excelColumnName:“EmployeeNo”,aliases:new[] { “EmpNo”,“No” })]
       <br/>
       public string Empno { get; set; }
       <br/>
       public string Name { get; set; }
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute
       <br/>
       从 1.24.0 开始支持 System.ComponentModel.DisplayNameAttribute 等同于 ExcelColumnName.excelColumnNameAttribute 效果
      </p>
     </li>
    </ol>
    <p>
     public class TestIssueI4TXGTDto
     <br/>
     {
     <!-- -->
     <br/>
     public int ID { get; set; }
     <br/>
     public string Name { get; set; }
     <br/>
     [DisplayName(“Specification”)]
     <br/>
     public string Spc { get; set; }
     <br/>
     [DisplayName(“Unit Price”)]
     <br/>
     public decimal Up { get; set; }
     <br/>
     }
    </p>
    <ol start="6">
     <li>
      <p>
       ExcelColumnAttribute
       <br/>
       从 1.26.0 版本开始，可以简化多Attribute写法
      </p>
      <pre><code> public class TestIssueI4ZYUUDto
 {
     [ExcelColumn(Name = "ID",Index =0)]
     public string MyProperty { get; set; }
     [ExcelColumn(Name = "CreateDate", Index = 1,Format ="yyyy-MM",Width =100)]
     public DateTime MyProperty2 { get; set; }
 }
</code></pre>
     </li>
     <li>
      <p>
       DynamicColumnAttribute 动态设定 Column
       <br/>
       从 1.26.0 版本开始，可以动态设定 Column 的属性
      </p>
      <pre><code>     var config = new OpenXmlConfiguration
     {
         DynamicColumns = new DynamicExcelColumn[] { 
             new DynamicExcelColumn("id"){Ignore=true},
             new DynamicExcelColumn("name"){Index=1,Width=10},
             new DynamicExcelColumn("createdate"){Index=0,Format="yyyy-MM-dd",Width=15},
             new DynamicExcelColumn("point"){Index=2,Name="Account Point"},
         }
     };
     var path = PathHelper.GetTempPath();
     var value = new[] { new { id = 1, name = "Jack", createdate = new DateTime(2022, 04, 12) ,point = 123.456} };
     MiniExcel.SaveAs(path, value, configuration: config);
</code></pre>
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     新增、删除、修改
     <br/>
     新增
     <br/>
     v1.28.0 开始支持 CSV 插入新增，在最后一行新增N笔数据
    </p>
    <p>
     // 原始数据
     <br/>
     {
     <!-- -->
     <br/>
     var value = new[] {
     <!-- -->
     <br/>
     new { ID=1,Name =“Jack”,InDate=new DateTime(2021,01,03)},
     <br/>
     new { ID=2,Name =“Henry”,InDate=new DateTime(2020,05,03)},
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, value);
     <br/>
     }
     <br/>
     // 最后一行新增一行数据
     <br/>
     {
     <!-- -->
     <br/>
     var value = new { ID=3,Name = “Mike”, InDate = new DateTime(2021, 04, 23) };
     <br/>
     MiniExcel.Insert(path, value);
     <br/>
     }
     <br/>
     // 最后一行新增N行数据
     <br/>
     {
     <!-- -->
     <br/>
     var value = new[] {
     <!-- -->
     <br/>
     new { ID=4,Name =“Frank”,InDate=new DateTime(2021,06,07)},
     <br/>
     new { ID=5,Name =“Gloria”,InDate=new DateTime(2022,05,03)},
     <br/>
     };
     <br/>
     MiniExcel.Insert(path, value);
     <br/>
     }
    </p>
    <p>
     image
    </p>
    <p>
     删除(未完成)
     <br/>
     修改(未完成)
     <br/>
     Excel 类别自动判断
     <br/>
     MiniExcel 预设会根据文件扩展名判断是 xlsx 还是 csv，但会有失准时候，请自行指定。
     <br/>
     Stream 类别无法判断来源于哪种 excel 请自行指定
     <br/>
     stream.SaveAs(excelType:ExcelType.CSV);
     <br/>
     //or
     <br/>
     stream.SaveAs(excelType:ExcelType.XLSX);
     <br/>
     //or
     <br/>
     stream.Query(excelType:ExcelType.CSV);
     <br/>
     //or
     <br/>
     stream.Query(excelType:ExcelType.XLSX);
    </p>
    <p>
     CSV
     <br/>
     概念
     <br/>
     预设全以字串类型返回，预设不会转换为数字或者日期，除非有强型别定义泛型
     <br/>
     自定分隔符
     <br/>
     预设以 , 作为分隔符，自定义请修改 Seperator 属性
    </p>
    <p>
     var config = new MiniExcelLibs.Csv.CsvConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     Seperator=‘;’
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, values,configuration: config);
    </p>
    <p>
     自定义换行符
     <br/>
     预设以 \r\n 作为换行符，自定义请修改 NewLine 属性
    </p>
    <p>
     var config = new MiniExcelLibs.Csv.CsvConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     NewLine=‘\n’
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, values,configuration: config);
    </p>
    <p>
     在 V1.30.1 版本开始支持动态更换换行符 (thanks @hyzx86)
    </p>
    <p>
     var config = new CsvConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     SplitFn = (row) =&gt; Regex.Split(row,
     <span class="katex--inline">
      KaTeX parse error: Undefined control sequence: \t at position 3: "[\̲t̲,](?=(?:[^\"]|\…
     </span>
     )“)
     <br/>
     .Select(s =&gt; Regex.Replace(s.Replace(”“”“, “””), “^”|“$”, “”)).ToArray()
     <br/>
     };
     <br/>
     var rows = MiniExcel.Query(path, configuration: config).ToList();
    </p>
    <p>
     自定义编码
     <br/>
     预设编码为「从Byte顺序标记检测编码」(detectEncodingFromByteOrderMarks: true)
     <br/>
     有自定义编码需求，请修改 StreamReaderFunc / StreamWriterFunc 属性
     <br/>
     // Read
     <br/>
     var config = new MiniExcelLibs.Csv.CsvConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     StreamReaderFunc = (stream) =&gt; new StreamReader(stream,Encoding.GetEncoding(“gb2312”))
     <br/>
     };
     <br/>
     var rows = MiniExcel.Query(path, true,excelType:ExcelType.CSV,configuration: config);
    </p>
    <p>
     // Write
     <br/>
     var config = new MiniExcelLibs.Csv.CsvConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     StreamWriterFunc = (stream) =&gt; new StreamWriter(stream, Encoding.GetEncoding(“gb2312”))
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, value,excelType:ExcelType.CSV, configuration: config);
    </p>
    <p>
     DataReader
    </p>
    <ol>
     <li>
      <p>
       GetReader
       <br/>
       从 1.23.0 版本开始能获取 DataReader
      </p>
      <p>
       using (var reader = MiniExcel.GetReader(path,true))
       <br/>
       {
       <!-- -->
       <br/>
       while (reader.Read())
       <br/>
       {
       <!-- -->
       <br/>
       for (int i = 0; i &lt; reader.FieldCount; i++)
       <br/>
       {
       <!-- -->
       <br/>
       var value = reader.GetValue(i);
       <br/>
       }
       <br/>
       }
       <br/>
       }
      </p>
     </li>
    </ol>
    <p>
     异步 Async
     <br/>
     从 v0.17.0 版本开始支持异步 (感谢isdaniel ( SHIH,BING-SIOU))
     <br/>
     public static Task SaveAsAsync(string path, object value, bool printHeader = true, string sheetName = “Sheet1”, ExcelType excelType = ExcelType.UNKNOWN, IConfiguration configuration = null)
     <br/>
     public static Task SaveAsAsync(this Stream stream, object value, bool printHeader = true, string sheetName = “Sheet1”, ExcelType excelType = ExcelType.XLSX, IConfiguration configuration = null)
     <br/>
     public static Task&lt;IEnumerable&gt; QueryAsync(string path, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = “A1”, IConfiguration configuration = null)
     <br/>
     public static Task&lt;IEnumerable&gt; QueryAsync(this Stream stream, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = “A1”, IConfiguration configuration = null) where T : class, new()
     <br/>
     public static Task&lt;IEnumerable&gt; QueryAsync(string path, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = “A1”, IConfiguration configuration = null) where T : class, new()
     <br/>
     public static Task&lt;IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;&gt; QueryAsync(this Stream stream, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = “A1”, IConfiguration configuration = null)
     <br/>
     public static Task SaveAsByTemplateAsync(this Stream stream, string templatePath, object value)
     <br/>
     public static Task SaveAsByTemplateAsync(this Stream stream, byte[] templateBytes, object value)
     <br/>
     public static Task SaveAsByTemplateAsync(string path, string templatePath, object value)
     <br/>
     public static Task SaveAsByTemplateAsync(string path, byte[] templateBytes, object value)
     <br/>
     public static Task QueryAsDataTableAsync(string path, bool useHeaderRow = true, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = “A1”, IConfiguration configuration = null)
    </p>
    <p>
     从 v1.25.0 开始支持 cancellationToken。
     <br/>
     其他
    </p>
    <ol>
     <li>
      映射枚举(enum)
      <br/>
      系统会自动映射(注意:大小写不敏感)
     </li>
    </ol>
    <p>
     image
    </p>
    <p>
     从V0.18.0版本开始支持Enum Description
    </p>
    <p>
     public class Dto
     <br/>
     {
     <!-- -->
     <br/>
     public string Name { get; set; }
     <br/>
     public Type UserType { get; set; }
     <br/>
     }
    </p>
    <p>
     public enum Type
     <br/>
     {
     <!-- -->
     <br/>
     [Description(“General User”)]
     <br/>
     V1,
     <br/>
     [Description(“General Administrator”)]
     <br/>
     V2,
     <br/>
     [Description(“Super Administrator”)]
     <br/>
     V3
     <br/>
     }
    </p>
    <p>
     image
    </p>
    <p>
     从 1.30.0 版本开始支持由 Description 转回 Enum 功能，感谢 @KaneLeung
    </p>
    <ol start="2">
     <li>
      <p>
       CSV 转 XLSX 或是 XLSX 转 CSV
       <br/>
       MiniExcel.ConvertXlsxToCsv(xlsxPath, csvPath);
       <br/>
       MiniExcel.ConvertXlsxToCsv(xlsxStream, csvStream);
       <br/>
       MiniExcel.ConvertXlsxToCsv(csvPath, xlsxPath);
       <br/>
       MiniExcel.ConvertXlsxToCsv(csvStream, xlsxStream);
      </p>
     </li>
     <li>
      <p>
       自定义 CultureInfo
       <br/>
       从 1.22.0 版本开始，可以使用以下代码自定义文化信息，系统预设 CultureInfo.InvariantCulture。
      </p>
     </li>
    </ol>
    <p>
     var config = new CsvConfiguration()
     <br/>
     {
     <!-- -->
     <br/>
     Culture = new CultureInfo(“fr-FR”),
     <br/>
     };
     <br/>
     MiniExcel.SaveAs(path, value, configuration: config);
    </p>
    <p>
     //or
     <br/>
     MiniExcel.Query(path, configuration: config);
    </p>
    <ol start="4">
     <li>
      <p>
       导出自定义 Buffer Size
       <br/>
       public abstract class Configuration : IConfiguration
       <br/>
       {
       <!-- -->
       <br/>
       public int BufferSize { get; set; } = 1024 * 512;
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       FastMode
       <br/>
       系统不会限制内存，达到更快的效率
      </p>
     </li>
    </ol>
    <p>
     var config = new OpenXmlConfiguration() { FastMode = true };
     <br/>
     MiniExcel.SaveAs(path, reader,configuration:config);
    </p>
    <p>
     例子
    </p>
    <ol>
     <li>
      SQLite &amp; Dapper 读取大数据新增到数据库
      <br/>
      Note : 请不要呼叫 call ToList/ToArray 等方法，这会将所有数据读到内存内
     </li>
    </ol>
    <p>
     using (var connection = new SQLiteConnection(connectionString))
     <br/>
     {
     <!-- -->
     <br/>
     connection.Open();
     <br/>
     using (var transaction = connection.BeginTransaction())
     <br/>
     using (var stream = File.OpenRead(path))
     <br/>
     {
     <!-- -->
     <br/>
     var rows = stream.Query();
     <br/>
     foreach (var row in rows)
     <br/>
     connection.Execute(“insert into T (A,B) values (@A,@B)”, new { row.A, row.B }, transaction: transaction);
     <br/>
     transaction.Commit();
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     效能: image
    </p>
    <ol start="2">
     <li>
      ASP.NET Core 3.1 下载/上传 Excel Xlsx API Demo Try it
      <br/>
      public class ApiController : Controller
      <br/>
      {
      <!-- -->
      <br/>
      public IActionResult Index()
      <br/>
      {
      <!-- -->
      <br/>
      return new ContentResult
      <br/>
      {
      <!-- -->
      <br/>
      ContentType = “text/html”,
      <br/>
      StatusCode = (int)HttpStatusCode.OK,
      <br/>
      Content = @"
      <br/>
      <a href="api/DownloadExcel" rel="nofollow">
       DownloadExcel
      </a>
      <br/>
      <br/>
      <a href="api/DownloadExcelFromTemplatePath" rel="nofollow">
       DownloadExcelFromTemplatePath
      </a>
      <br/>
      <br/>
      <a href="api/DownloadExcelFromTemplateBytes" rel="nofollow">
       DownloadExcelFromTemplateBytes
      </a>
      <br/>
     </li>
    </ol>
    <p>
     Upload Excel
    </p>
    <br/>
    " }; }
    <pre><code>public IActionResult DownloadExcel()
{
    var values = new[] {
        new { Column1 = "MiniExcel", Column2 = 1 },
        new { Column1 = "Github", Column2 = 2}
    };
    var memoryStream = new MemoryStream();
    memoryStream.SaveAs(values);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    {
        FileDownloadName = "demo.xlsx"
    };
}

public IActionResult DownloadExcelFromTemplatePath()
{
    string templatePath = "TestTemplateComplex.xlsx";

    Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
    {
        ["title"] = "FooCompany",
        ["managers"] = new[] {
            new {name="Jack",department="HR"},
            new {name="Loan",department="IT"}
        },
        ["employees"] = new[] {
            new {name="Wade",department="HR"},
            new {name="Felix",department="HR"},
            new {name="Eric",department="IT"},
            new {name="Keaton",department="IT"}
        }
    };

    MemoryStream memoryStream = new MemoryStream();
    memoryStream.SaveAsByTemplate(templatePath, value);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    {
        FileDownloadName = "demo.xlsx"
    };
}

private static Dictionary&lt;string, Byte[]&gt; TemplateBytesCache = new Dictionary&lt;string, byte[]&gt;();

static ApiController()
{
    string templatePath = "TestTemplateComplex.xlsx";
    byte[] bytes = System.IO.File.ReadAllBytes(templatePath);
    TemplateBytesCache.Add(templatePath, bytes);
}

public IActionResult DownloadExcelFromTemplateBytes()
{
    byte[] bytes = TemplateBytesCache["TestTemplateComplex.xlsx"];

    Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
    {
        ["title"] = "FooCompany",
        ["managers"] = new[] {
            new {name="Jack",department="HR"},
            new {name="Loan",department="IT"}
        },
        ["employees"] = new[] {
            new {name="Wade",department="HR"},
            new {name="Felix",department="HR"},
            new {name="Eric",department="IT"},
            new {name="Keaton",department="IT"}
        }
    };

    MemoryStream memoryStream = new MemoryStream();
    memoryStream.SaveAsByTemplate(bytes, value);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    {
        FileDownloadName = "demo.xlsx"
    };
}

public IActionResult UploadExcel(IFormFile excel)
{
    var stream = new MemoryStream();
    excel.CopyTo(stream);

    foreach (var item in stream.Query(true))
    {
        // do your logic etc.
    }

    return Ok("File uploaded successfully");
}
</code></pre>
    <p>
     }
    </p>
    <ol start="3">
     <li>
      <p>
       分页查询
       <br/>
       void Main()
       <br/>
       {
       <!-- -->
       <br/>
       var rows = MiniExcel.Query(path);
      </p>
      <p>
       Console.WriteLine(“==== No.1 Page
       <mark>
        <mark>
         “);
         <br/>
         Console.WriteLine(Page(rows,pageSize:3,page:1));
         <br/>
         Console.WriteLine(”
        </mark>
       </mark>
       No.50 Page
       <mark>
        <mark>
         “);
         <br/>
         Console.WriteLine(Page(rows,pageSize:3,page:50));
         <br/>
         Console.WriteLine(”
        </mark>
       </mark>
       No.5000 Page ====”);
       <br/>
       Console.WriteLine(Page(rows,pageSize:3,page:5000));
       <br/>
       }
      </p>
     </li>
    </ol>
    <p>
     public static IEnumerable Page(IEnumerable en, int pageSize, int page)
     <br/>
     {
     <!-- -->
     <br/>
     return en.Skip(page * pageSize).Take(pageSize);
     <br/>
     }
    </p>
    <p>
     20210419
    </p>
    <ol start="4">
     <li>
      <p>
       WebForm不落地导出Excel
       <br/>
       var fileName = “Demo.xlsx”;
       <br/>
       var sheetName = “Sheet1”;
       <br/>
       HttpResponse response = HttpContext.Current.Response;
       <br/>
       response.Clear();
       <br/>
       response.ContentType = “application/vnd.openxmlformats-officedocument.spreadsheetml.sheet”;
       <br/>
       response.AddHeader(“Content-Disposition”, $“attachment;filename=”{fileName}“”);
       <br/>
       var values = new[] {
       <!-- -->
       <br/>
       new { Column1 = “MiniExcel”, Column2 = 1 },
       <br/>
       new { Column1 = “Github”, Column2 = 2}
       <br/>
       };
       <br/>
       var memoryStream = new MemoryStream();
       <br/>
       memoryStream.SaveAs(values, sheetName: sheetName);
       <br/>
       memoryStream.Seek(0, SeekOrigin.Begin);
       <br/>
       memoryStream.CopyTo(Response.OutputStream);
       <br/>
       response.End();
      </p>
     </li>
     <li>
      <p>
       动态 i18n 多国语言跟权限管理
       <br/>
       像例子一样，建立一个方法处理 i18n 跟权限管理，并搭配 yield return 返回 IEnumerable&lt;Dictionary&lt;string, object&gt;&gt;，即可达到动态、低内存处理效果
      </p>
     </li>
    </ol>
    <p>
     void Main()
     <br/>
     {
     <!-- -->
     <br/>
     var value = new Order[] {
     <!-- -->
     <br/>
     new Order(){OrderNo = “SO01”,CustomerID=“C001”,ProductID=“P001”,Qty=100,Amt=500},
     <br/>
     new Order(){OrderNo = “SO02”,CustomerID=“C002”,ProductID=“P002”,Qty=300,Amt=400},
     <br/>
     };
    </p>
    <pre><code>Console.WriteLine("en-Us and Sales role");
{
	var path = Path.GetTempPath() + Guid.NewGuid() + ".xlsx";
	var lang = "en-US";
	var role = "Sales";
	MiniExcel.SaveAs(path, GetOrders(lang, role, value));
	MiniExcel.Query(path, true).Dump();
}

Console.WriteLine("zh-CN and PMC role");
{
	var path = Path.GetTempPath() + Guid.NewGuid() + ".xlsx";
	var lang = "zh-CN";
	var role = "PMC";
	MiniExcel.SaveAs(path, GetOrders(lang, role, value));
	MiniExcel.Query(path, true).Dump();
}
</code></pre>
    <p>
     }
    </p>
    <p>
     private IEnumerable&lt;Dictionary&lt;string, object&gt;&gt; GetOrders(string lang, string role, Order[] orders)
     <br/>
     {
     <!-- -->
     <br/>
     foreach (var order in orders)
     <br/>
     {
     <!-- -->
     <br/>
     var newOrder = new Dictionary&lt;string, object&gt;();
    </p>
    <pre><code>	if (lang == "zh-CN")
	{
		newOrder.Add("客户编号", order.CustomerID);
		newOrder.Add("订单编号", order.OrderNo);
		newOrder.Add("产品编号", order.ProductID);
		newOrder.Add("数量", order.Qty);
		if (role == "Sales")
			newOrder.Add("价格", order.Amt);
		yield return newOrder;
	}
	else if (lang == "en-US")
	{
		newOrder.Add("Customer ID", order.CustomerID);
		newOrder.Add("Order No", order.OrderNo);
		newOrder.Add("Product ID", order.ProductID);
		newOrder.Add("Quantity", order.Qty);
		if (role == "Sales")
			newOrder.Add("Amount", order.Amt);
		yield return newOrder;
	}
	else
	{
		throw new InvalidDataException($"lang {lang} wrong");
	}
}
</code></pre>
    <p>
     }
    </p>
    <p>
     public class Order
     <br/>
     {
     <!-- -->
     <br/>
     public string OrderNo { get; set; }
     <br/>
     public string CustomerID { get; set; }
     <br/>
     public decimal Qty { get; set; }
     <br/>
     public string ProductID { get; set; }
     <br/>
     public decimal Amt { get; set; }
     <br/>
     }
    </p>
    <p>
     image
    </p>
    <p>
     FAQ 常见问题
     <br/>
     Q: Excel 表头标题名称跟 class 属性名称不一致，如何对应?
     <br/>
     A. 请使用 ExcelColumnName 作 mapping
    </p>
    <p>
     image
    </p>
    <p>
     Q. 多工作表(sheet)如何导出/查询数据?
     <br/>
     A. 使用 GetSheetNames方法搭配 Query 的 sheetName 参数
    </p>
    <p>
     var sheets = MiniExcel.GetSheetNames(path);
     <br/>
     foreach (var sheet in sheets)
     <br/>
     {
     <!-- -->
     <br/>
     Console.WriteLine($"sheet name : {sheet} ");
     <br/>
     var rows = MiniExcel.Query(path,useHeaderRow:true,sheetName:sheet);
     <br/>
     Console.WriteLine(rows);
     <br/>
     }
    </p>
    <p>
     image
    </p>
    <p>
     Q. 是否使用 Count 会载入全部数据到内存
     <br/>
     不会，图片测试一百万行*十列数据，简单测试，内存最大使用 &lt; 60MB，花费13.65秒
    </p>
    <p>
     image
    </p>
    <p>
     Q. Query如何使用整数索引取值?
     <br/>
     Query 预设索引为字串Key : A,B,C…，想要改为数字索引，请建立以下方法自行转换
    </p>
    <p>
     void Main()
     <br/>
     {
     <!-- -->
     <br/>
     var path = @“D:\git\MiniExcel\samples\xlsx\TestTypeMapping.xlsx”;
     <br/>
     var rows = MiniExcel.Query(path,true);
     <br/>
     foreach (var r in ConvertToIntIndexRows(rows))
     <br/>
     {
     <!-- -->
     <br/>
     Console.Write($“column 0 : {r[0]} ,column 1 : {r[1]}”);
     <br/>
     Console.WriteLine();
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     private IEnumerable&lt;Dictionary&lt;int, object&gt;&gt; ConvertToIntIndexRows(IEnumerable rows)
     <br/>
     {
     <!-- -->
     <br/>
     ICollection keys = null;
     <br/>
     var isFirst = true;
     <br/>
     foreach (IDictionary&lt;string,object&gt; r in rows)
     <br/>
     {
     <!-- -->
     <br/>
     if(isFirst)
     <br/>
     {
     <!-- -->
     <br/>
     keys = r.Keys;
     <br/>
     isFirst = false;
     <br/>
     }
    </p>
    <pre><code>	var dic = new Dictionary&lt;int, object&gt;();
	var index = 0;
	foreach (var key in keys)
		dic[index++] = r[key];
	yield return dic;
}
</code></pre>
    <p>
     }
    </p>
    <p>
     Q. 导出时数组为空时生成没有标题空 Excel
     <br/>
     因为 MiniExcel 使用类似 JSON.NET 动态从值获取类别机制简化 API 操作，没有数据就无法获取类别。可以查看 issue #133 了解。
    </p>
    <p>
     image
    </p>
    <p>
     强型别和 DataTable 会生成表头，但 Dicionary 依旧是空 Excel
    </p>
    <p>
     Q. 如何人为空白行中止遍历?
     <br/>
     常发生人为不小心在最后几行留下空白行情况，MiniExcel可以搭配 LINQ TakeWhile实现空白行中断遍历。
    </p>
    <p>
     image
    </p>
    <p>
     Q. 不想要空白行如何去除?
     <br/>
     image
    </p>
    <p>
     IEnumerable版本
    </p>
    <p>
     public static IEnumerable QueryWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
     <br/>
     {
     <!-- -->
     <br/>
     var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
     <br/>
     foreach (IDictionary&lt;string,object&gt; row in rows)
     <br/>
     {
     <!-- -->
     <br/>
     if(row.Keys.Any(key=&gt;row[key]!=null))
     <br/>
     yield return row;
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     DataTable版本
    </p>
    <p>
     public static DataTable QueryAsDataTableWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
     <br/>
     {
     <!-- -->
     <br/>
     if (sheetName == null &amp;&amp; excelType != ExcelType.CSV) /
     <em>
      Issue #279
     </em>
     /
     <br/>
     sheetName = stream.GetSheetNames().First();
    </p>
    <pre><code>var dt = new DataTable(sheetName);
var first = true;
var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
foreach (IDictionary&lt;string, object&gt; row in rows)
{
	if (first)
	{

		foreach (var key in row.Keys)
		{
			var column = new DataColumn(key, typeof(object)) { Caption = key };
			dt.Columns.Add(column);
		}

		dt.BeginLoadData();
		first = false;
	}

	var newRow = dt.NewRow();
	var isNull=true;
	foreach (var key in row.Keys)
	{
		var _v = row[key];
		if(_v!=null)
			isNull = false;
		newRow[key] = _v; 
	}
	
	if(!isNull)
		dt.Rows.Add(newRow);
}

dt.EndLoadData();
return dt;
</code></pre>
    <p>
     }
    </p>
    <p>
     Q. 保存如何取代MiniExcel.SaveAs(path, value)，文件存在系统会报已存在错误?
     <br/>
     请改以Stream自行管控Stream行为，如
    </p>
    <pre><code>using (var stream = File.Create("Demo.xlsx"))
	MiniExcel.SaveAs(stream,value);
</code></pre>
    <p>
     从V1.25.0版本开始，支持 overwriteFile 參數，方便調整是否要覆蓋已存在文件
    </p>
    <pre><code>MiniExcel.SaveAs(path, value, overwriteFile: true);
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f6b796c657a68616f323031392f:61727469636c652f64657461696c732f313436313139393335" class_="artid" style="display:none">
 </p>
</div>


