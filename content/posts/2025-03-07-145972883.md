---
layout: post
title: "多线程单例模型阻塞队列"
date: 2025-03-07 00:48:38 +0800
description: "在上面图中，生产的速度是一秒一个，而消费的速度是三秒一个，但阻塞队列的大小为4，所以当生产元素减去消费元素>=4的时候，就会进行阻塞，直到差值小于4.而我们对于阻塞队列中有关的的有生产者消费者模型，这个案例十分典型，解释一下什么是生产者消费者模型，在一个阻塞队列中，生产速度大于消费速度，那么当。，直到保证生产量和消费量的差值比阻塞队列的大小还小，这样就能做到生产者和消费者之间的硬性平衡。，有一点十分注意的是，阻塞队列中有offer的方法，但使用这个是不会被阻塞的，就会变成一个普通的队列。"
keywords: "多线程——单例模型、阻塞队列"
categories: ['未分类']
tags: ['开发语言', '单例模式', 'Spring', 'Jvm', 'Java', 'Ee', 'Boot']
artid: "145972883"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145972883
    alt: "多线程单例模型阻塞队列"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145972883
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145972883
cover: https://bing.ee123.net/img/rand?artid=145972883
image: https://bing.ee123.net/img/rand?artid=145972883
img: https://bing.ee123.net/img/rand?artid=145972883
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     多线程——单例模型、阻塞队列
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B" name="%E4%B8%80%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B">
     一、单例模型
    </h2>
    <p>
     单例模式，是
     <span style="background-color:#fe2c24">
      设计模式
     </span>
     （针对问题使用不同方式解决问题）中一种非常经典的模式，而单例模式就如其名字一样，强制要求
     <strong>
      <span style="color:#fe2c24">
       一个类不能创建多个对象
      </span>
      。
     </strong>
    </p>
    <p>
     而单例模型大概分俩种，一种是
     <span style="background-color:#ff9900">
      饿汉模式
     </span>
     ，一种是
     <span style="background-color:#fe2c24">
      懒汉模式
     </span>
     。
    </p>
    <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%201%E3%80%81%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F" name="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%201%E3%80%81%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F">
     1、饿汉模式
    </h3>
    <p>
     饿汉模式，听名字就知道是非常饥饿，而在java中的意思就是在
     <span style="color:#494949">
      <span style="background-color:#4da8ee">
       类加载的同时，创建实例
      </span>
     </span>
     。
    </p>
    <p>
    </p>
    <pre><code class="language-java">class Singleton{
    private static Singleton instance=new Singleton(100);

    public static Singleton getInstance() {
        return instance;
    }

    private Singleton(){

    }

    private Singleton(int n){

    }
}</code></pre>
    <p>
     而在过程中，只能返回一个实例，不能返回多个，不然会报错，这一点在很多场景上都需要. 比如 JDBC 中的 DataSource 实例就只需要一个。
    </p>
    <p>
    </p>
    <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F" name="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F">
     2、懒汉模式
    </h3>
    <p>
     而懒汉模式和饿汉模式恰恰相反，懒汉模式是
     <span style="color:#494949">
      <span style="background-color:#38d8f0">
       使用的时候再创建实例
      </span>
     </span>
     ，不使用不创建实例。同时，懒汉模式也有分为单线程和多线程类。单线程如下：
    </p>
    <p>
    </p>
    <pre><code class="language-java">class SingletonLazy{
    private static SingletonLazy instance=null;
   
    public static SingletonLazy getInstance2(){
        if(instance==null){
            instance=new SingletonLazy();
        }
        return instance;
    }

    private  SingletonLazy(){

    }
}</code></pre>
    <p>
     在上述中懒汉模式是需要用的时候再创建实例，不需要就不用，对于单线程来说这个是可以的，但对于多线程中的话，因为多线程不是
     <span style="color:#ff9900">
      原子性
     </span>
     的，所以在同时调用getInstance2方法的话，就很有可能会导致创建多个实例，所以，为了杜绝这个问题，我们需要加上
     <strong>
      <span style="color:#fe2c24">
       synchronized
      </span>
     </strong>
     来改善这里的线程安全问题。
    </p>
    <p>
    </p>
    <pre><code class="language-java">class SingletonLazy{
    private static volatile SingletonLazy instance=null;
    private static  Object locker=new Object();

    public static  SingletonLazy getInstance(){
        if(instance==null){
            synchronized (locker){
                if (instance==null){
                    instance=new SingletonLazy();
                }
            }
        }
        return instance;
    }

    private  SingletonLazy(){

    }
}</code></pre>
    <p>
     用双重if来降低锁竞争，然后再用voliatile解决可见性问题，这样的话就能解决线程安全问题。
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97" name="%E4%BA%8C%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">
     二、阻塞队列
    </h2>
    <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%201%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86" name="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%201%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86">
     1、阻塞队列原理
    </h3>
    <p>
     阻塞队列是什么？阻塞队列其实就是一种特殊的队列，遵守
     <span style="color:#fe2c24">
      <strong>
       “先进先出”
      </strong>
     </span>
     的原则。
    </p>
    <p>
     我们以图为例子：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="342" src="https://i-blog.csdnimg.cn/direct/20982e6a114c43968ff2401ee344df55.png" width="1000"/>
    </p>
    <p>
     这是一个很普通的客户端A向服务器B发起请求，如果没有阻塞队列的话，那么就直接全部数据一起传输，如果有阻塞的话，就会变成下面情况：
    </p>
    <p>
     <img alt="" height="394" src="https://i-blog.csdnimg.cn/direct/01dbc0b9becb4c01b06dce514a70aae8.png" width="1346"/>
    </p>
    <p>
     在客户端A向客户端B发出请求的时候，中间有阻塞队列，
     <span style="background-color:#38d8f0">
      如果里面队满（阻塞队列存储满），而不能够入队列，直到队列不满。如果队列为空，则不能够出队列，直到队列不为空。
     </span>
    </p>
    <p>
    </p>
    <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%203%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95" name="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%203%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95">
     2、阻塞队列常见用法
    </h3>
    <p>
     阻塞队列最常用的就是put和take方法，
     <span style="color:#fe2c24">
      put方法就是将元素添加到阻塞队列，而take则是拿出来
     </span>
     ，有一点十分注意的是，阻塞队列中有offer的方法，但使用这个是不会被阻塞的，就会变成一个普通的队列。
    </p>
    <p>
    </p>
    <pre><code class="language-java"> public static void main(String[] args) throws InterruptedException {
        BlockingQueue&lt;String&gt; queue=new LinkedBlockingQueue&lt;&gt;(10);
        for (int i = 0; i &lt; 10; i++) {
            queue.put("aaa");
        }
        System.out.println("队列已满");

        for (int i = 0; i &lt; 10; i++) {
            System.out.println(queue.take());
        }
        System.out.println("队列为空");
        queue.take();
    }</code></pre>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="607" src="https://i-blog.csdnimg.cn/direct/e65b46cc6293463eb5bd63c940413c12.png" width="547"/>
    </p>
    <p>
    </p>
    <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B" name="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">
     3、生产者消费者模型
    </h3>
    <p>
     而我们对于阻塞队列中有关的的有生产者消费者模型，这个案例十分典型，解释一下什么是生产者消费者模型，在一个阻塞队列中，生产速度大于消费速度，那么当
     <span style="color:#79c6cd">
      <span style="background-color:#dad5e9">
       生产量和消费量的差值已经是阻塞队列的大小之后，那么就会进行阻塞
      </span>
     </span>
     ，直到保证生产量和消费量的差值比阻塞队列的大小还小，这样就能做到生产者和消费者之间的硬性平衡。以下面为案例：
    </p>
    <p>
    </p>
    <pre><code class="language-java">  public static void main(String[] args) {
        BlockingQueue&lt;Integer&gt; queue=new LinkedBlockingQueue&lt;&gt;(4);
        Thread producer=new Thread(()-&gt;{
            int n=0;
            while (true){
                try {
                    queue.put(n);//offer不会阻塞，put才行
                    System.out.println("生产元素"+n);
                    n++;
                    Thread.sleep(1000);
                }catch(InterruptedException e){
                    throw new RuntimeException(e);
                }
            }
        },"producer");

        Thread consumer=new Thread(()-&gt;{
            while(true){
                try{
                    Integer n=queue.take();
                    System.out.println("消费元素"+n);

                    Thread.sleep(3000);
                }catch(InterruptedException e){
                    throw new RuntimeException(e);
                }
            }
        },"consumer");
        producer.start();
        consumer.start();
    }</code></pre>
    <p>
     在上面图中，生产的速度是一秒一个，而消费的速度是三秒一个，但阻塞队列的大小为4，所以当生产元素减去消费元素&gt;=4的时候，就会进行阻塞，直到差值小于4.
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="763" src="https://i-blog.csdnimg.cn/direct/da99c0a9e6584220a1fe46821057c9a1.png" width="365"/>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f6775673132333435736865682f:61727469636c652f64657461696c732f313435393732383833" class_="artid" style="display:none">
 </p>
</div>


