---
layout: post
title: "JVM中是如何定位一个对象的"
date: 2025-03-11 08:37:06 +0800
description: "在 Java 中，对象定位指的是如何通过引用（Reference）在堆内存中找到对象实例及其元数据（如类型信息）。JVM 主要通过和。"
keywords: "JVM中是如何定位一个对象的"
categories: ['Jvm']
tags: ['Jvm', 'Java']
artid: "146169134"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146169134
    alt: "JVM中是如何定位一个对象的"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146169134
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146169134
cover: https://bing.ee123.net/img/rand?artid=146169134
image: https://bing.ee123.net/img/rand?artid=146169134
img: https://bing.ee123.net/img/rand?artid=146169134
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM中是如何定位一个对象的
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Java 中，对象定位指的是如何通过引用（Reference）在堆内存中找到对象实例及其元数据（如类型信息）。JVM 主要通过
     <strong>
      直接指针访问
     </strong>
     和
     <strong>
      句柄访问
     </strong>
     两种方式实现，各有其优缺点和应用场景：
    </p>
    <hr/>
    <h4>
     一、
     <strong>
      直接指针访问（Direct Pointer）
     </strong>
    </h4>
    <p>
     <strong>
      实现原理
     </strong>
     ：引用变量直接指向堆内存中的对象实例，对象头中存储指向方法区类型信息的指针。
     <br/>
     <strong>
      示意图
     </strong>
     ：
    </p>
    <pre><code>引用变量 → 对象实例数据（包含对象头） → 方法区类型信息 
</code></pre>
    <h5>
     <strong>
      优点
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <strong>
       访问速度快
      </strong>
      ：仅需一次指针跳转即可访问对象实例数据，减少内存寻址开销。
     </li>
     <li>
      <strong>
       内存占用少
      </strong>
      ：无需额外维护句柄池，节省内存空间。
     </li>
    </ol>
    <h5>
     <strong>
      缺点
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <strong>
       对象移动成本高
      </strong>
      ：垃圾回收（如标记-整理算法）时，若对象地址变化，需更新所有引用该对象的指针。
     </li>
     <li>
      <strong>
       内存碎片敏感
      </strong>
      ：频繁的对象创建和回收可能导致内存碎片，影响堆内存管理效率。
     </li>
    </ol>
    <hr/>
    <h4>
     二、
     <strong>
      句柄访问（Handle）
     </strong>
    </h4>
    <p>
     <strong>
      实现原理
     </strong>
     ：引用变量指向句柄池中的句柄，句柄包含对象实例数据的指针和指向方法区类型信息的指针
     <a href="https://blog.51cto.com/u_16175511/6796801" rel="nofollow" title="1">
      1
     </a>
     。
     <br/>
     <strong>
      示意图
     </strong>
     ：
    </p>
    <pre><code>引用变量 → 句柄池（实例数据指针 + 类型信息指针）  
                 ↳ 实例数据 → 对象实例  
                 ↳ 类型信息 → 方法区 
</code></pre>
    <h5>
     <strong>
      优点
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <strong>
       对象移动成本低
      </strong>
      ：垃圾回收时只需更新句柄中的实例数据指针，引用变量无需修改。
     </li>
     <li>
      <strong>
       内存稳定性高
      </strong>
      ：句柄池独立于堆内存，减少内存碎片化问题。
     </li>
    </ol>
    <h5>
     <strong>
      缺点
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <strong>
       访问速度慢
      </strong>
      ：需两次指针跳转（先访问句柄，再访问实例数据），性能开销较大。
     </li>
     <li>
      <strong>
       内存占用高
      </strong>
      ：需额外维护句柄池，增加内存消耗。
     </li>
    </ol>
    <hr/>
    <h4>
     三、
     <strong>
      两种方式的对比与选择
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         对比维度
        </strong>
       </th>
       <th>
        <strong>
         直接指针访问
        </strong>
       </th>
       <th>
        <strong>
         句柄访问
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         访问速度
        </strong>
       </td>
       <td>
        快（一次寻址）
       </td>
       <td>
        慢（两次寻址）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         内存占用
        </strong>
       </td>
       <td>
        低
       </td>
       <td>
        高（需句柄池）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         GC 效率
        </strong>
       </td>
       <td>
        对象移动时需更新所有引用
       </td>
       <td>
        对象移动时仅更新句柄
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        主流 JVM（如 HotSpot）默认选择
       </td>
       <td>
        对 GC 效率要求极高的特定场景
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     <strong>
      实际应用
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <strong>
       HotSpot 虚拟机
      </strong>
      ：默认采用
      <strong>
       直接指针访问
      </strong>
      ，优先保证访问性能。
     </li>
     <li>
      <strong>
       早期 JVM 或特殊场景
      </strong>
      ：可能选择句柄访问，以减少 GC 时的引用更新成本。
     </li>
    </ul>
    <hr/>
    <h4>
     四、
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       直接指针
      </strong>
      ：性能优先，适合大多数场景，但对 GC 算法要求较高。
     </li>
     <li>
      <strong>
       句柄
      </strong>
      ：牺牲性能换取内存管理和 GC 效率，适用于需要频繁对象移动的场景。
     </li>
    </ul>
    <p>
     在实际开发中，开发者无需显式选择对象定位方式，JVM 会根据实现自动优化。理解这两种机制有助于深入分析内存泄漏、GC 性能等问题
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f797975657368656e2f:61727469636c652f64657461696c732f313436313639313334" class_="artid" style="display:none">
 </p>
</div>


