---
layout: post
title: "FFmpeg播放Hls录像控制解码速度"
date: 2025-03-11 13:56:55 +0800
description: "进行hls录像文件播放，播放速度很快，并未按照正常1秒25帧的帧率进行播放；播放速度过快的原因是因为代码中没有根据视频的帧率（Frame Rate）来控制帧的显示时间。HLS 视频通常有一个固定的帧率（例如 25 FPS），而代码在解码后立即显示每一帧，没有考虑帧之间的时间间隔，导致播放速度过快。要解决这个问题，需要在显示每一帧时，根据帧率或帧的时间戳（PTS，Presentation Time Stamp）来控制帧的显示时间。"
keywords: "FFmpeg播放Hls录像控制解码速度"
categories: ['音视频', 'Ffmpeg']
tags: ['Ffmpeg']
artid: "146177313"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146177313
    alt: "FFmpeg播放Hls录像控制解码速度"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146177313
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146177313
cover: https://bing.ee123.net/img/rand?artid=146177313
image: https://bing.ee123.net/img/rand?artid=146177313
img: https://bing.ee123.net/img/rand?artid=146177313
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     FFmpeg播放Hls录像控制解码速度
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     进行hls录像文件播放，播放速度很快，并未按照正常1秒25帧的帧率进行播放；
    </p>
    <p>
     播放速度过快的原因是因为代码中没有根据视频的帧率（Frame Rate）来控制帧的显示时间。HLS 视频通常有一个固定的帧率（例如 25 FPS），而代码在解码后立即显示每一帧，没有考虑帧之间的时间间隔，导致播放速度过快。
    </p>
    <p>
     要解决这个问题，需要在显示每一帧时，根据帧率或帧的时间戳（PTS，Presentation Time Stamp）来控制帧的显示时间。
    </p>
    <h4>
     解决方案
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        计算帧间隔时间
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据视频的帧率（FPS）计算每帧的显示时间。
        </p>
       </li>
       <li>
        <p>
         例如，25 FPS 的视频，每帧的显示时间应为
         <code>
          1 / 25 = 0.04 秒
         </code>
         （40 毫秒）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        使用帧的时间戳（PTS）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         视频帧通常带有时间戳（PTS），表示帧应该在什么时间显示。
        </p>
       </li>
       <li>
        <p>
         通过比较当前时间和帧的 PTS，可以精确控制帧的显示时间。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     代码：
    </h4>
    <pre><code class="language-cpp">#include &lt;chrono&gt;
#include &lt;thread&gt;

// 在显示帧的地方增加帧率控制
auto start_time = std::chrono::steady_clock::now(); // 记录开始时间

while (av_read_frame(format_ctx, &amp;packet) &gt;= 0) {
    if (packet.stream_index == video_stream_index) {
        if (avcodec_send_packet(codec_ctx, &amp;packet) &lt; 0) {
            fprintf(stderr, "Error sending packet for decoding\n");
            return -1;
        }

        while (avcodec_receive_frame(codec_ctx, frame) &gt;= 0) {
            // 转换图像格式为 YUV420P
            sws_scale(sws_ctx, (const uint8_t* const*)frame-&gt;data, frame-&gt;linesize, 0, codec_ctx-&gt;height, frame_yuv-&gt;data, frame_yuv-&gt;linesize);

            // 计算当前帧的显示时间
            double frame_delay = av_q2d(format_ctx-&gt;streams[video_stream_index]-&gt;time_base); // 时间基
            double pts = frame-&gt;pts * frame_delay; // 当前帧的显示时间（秒）

            // 计算已经过去的时间
            auto now = std::chrono::steady_clock::now();
            double elapsed_time = std::chrono::duration&lt;double&gt;(now - start_time).count();

            // 如果当前帧应该在未来显示，则等待
            if (pts &gt; elapsed_time) {
                double sleep_time = pts - elapsed_time;
                std::this_thread::sleep_for(std::chrono::duration&lt;double&gt;(sleep_time));
            }

            // 使用 SDL 显示帧
            SDL_UpdateYUVTexture(
                texture,
                NULL,
                frame_yuv-&gt;data[0],
                frame_yuv-&gt;linesize[0],
                frame_yuv-&gt;data[1],
                frame_yuv-&gt;linesize[1],
                frame_yuv-&gt;data[2],
                frame_yuv-&gt;linesize[2]
            );

            SDL_RenderClear(renderer);
            SDL_RenderCopy(renderer, texture, NULL, NULL);
            SDL_RenderPresent(renderer);
        }
    }

    av_packet_unref(&amp;packet);
}</code></pre>
    <p>
    </p>
    <h4>
     关键点：
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        时间基（Time Base）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          av_q2d(format_ctx-&gt;streams[video_stream_index]-&gt;time_base)
         </code>
         将时间基转换为秒。
        </p>
       </li>
       <li>
        <p>
         帧的 PTS 乘以时间基，得到帧的显示时间（秒）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        帧显示时间控制
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          std::chrono::steady_clock
         </code>
         记录开始时间。
        </p>
       </li>
       <li>
        <p>
         计算当前帧的显示时间（
         <code>
          pts
         </code>
         ）和已经过去的时间（
         <code>
          elapsed_time
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         如果当前帧应该在未来显示，则使用
         <code>
          std::this_thread::sleep_for
         </code>
         等待。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        帧率控制
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过帧的 PTS 和当前时间的比较，确保帧按照正确的时间间隔显示。
        </p>
       </li>
      </ul>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f4c656d6f6e5f44313939392f:61727469636c652f64657461696c732f313436313737333133" class_="artid" style="display:none">
 </p>
</div>


