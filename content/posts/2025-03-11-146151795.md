---
layout: post
title: "Java数据结构第二十二期Map与Set的高效应用之道一"
date: 2025-03-11 21:53:12 +0800
description: "上面的TreeMap传给了m，m是NavigableMap类型的，而NavigableMap又继承了Map，我们再来看add方法，里面的e接收了key，PRESENT接收了value，而这个PRESENT又是一个Object类。对有n个结点的⼆叉搜索树，若每个元素查找的概率相等，则⼆叉搜索树平均查找⻓度是结点在⼆叉搜 索树的深度的函数，即结点越深，则比较次数越多。如果相等，直接返回这个结点。Map是⼀个接⼝类，该类没有继承⾃Collection，该类中存储的是结构的键值对，并且K⼀定是唯一的，不能重复。"
keywords: "Java数据结构第二十二期：Map与Set的高效应用之道(一)"
categories: ['Java']
tags: ['数据结构']
artid: "146151795"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146151795
    alt: "Java数据结构第二十二期Map与Set的高效应用之道一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146151795
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146151795
cover: https://bing.ee123.net/img/rand?artid=146151795
image: https://bing.ee123.net/img/rand?artid=146151795
img: https://bing.ee123.net/img/rand?artid=146151795
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java数据结构第二十二期：Map与Set的高效应用之道(一)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/bd094ac717a144fdac183951e057b968.gif"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/79da1df06e6f41088b9d7300765eb3f7.jpeg"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/0e457b68c18e49078f621c70661bb650.gif"/>
    </p>
    <blockquote>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        专栏：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927/category_12839364.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12839364&amp;sharerefer=PC&amp;sharesource=2401_85198927&amp;sharefrom=from_link" title="Java数据结构秘籍">
         Java数据结构秘籍
        </a>
       </strong>
      </span>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        个人主页：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927?spm=1000.2115.3001.5343" title="手握风云">
         手握风云
        </a>
       </strong>
      </span>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81Map%E5%92%8CSet" name="%E4%B8%80%E3%80%81Map%E5%92%8CSet">
     一、Map和Set
    </h2>
    <h3 id="1.1.%20%E6%A6%82%E5%BF%B5" name="1.1.%20%E6%A6%82%E5%BF%B5">
     1.1. 概念
    </h3>
    <p class="img-center">
     <img alt="" height="408" src="https://i-blog.csdnimg.cn/direct/44fca54c383e4ff28adfad4a5d9e42d1.png" width="1149"/>
    </p>
    <p>
     如果一些场景中需要设计到数据搜素相关的操作时，就需要用到上图中的Map和Set接口。Map用于存储键值对，每个键都映射到一个值，键必须是唯一的，但值可以重复，常见的实现类为HashMap、TreeMap。用于存储不重复的元素。它不允许存储重复的值，但不存储键值对，常见的实现类为HashSet、TreeSet。
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E6%90%9C%E7%B4%A2%E6%A0%91" name="%E4%BA%8C%E3%80%81%E6%90%9C%E7%B4%A2%E6%A0%91">
     二、搜索树
    </h2>
    <h3 id="2.1.%20%E6%A6%82%E5%BF%B5" name="2.1.%20%E6%A6%82%E5%BF%B5">
     2.1. 概念
    </h3>
    <p>
     TreeSet和TreeMap是与二叉搜索树相关的，二叉搜索树底层是用红黑树实现的。二叉搜索树⼜称⼆叉排序树，它或者是⼀棵空树，或者是具有以下性质的⼆叉树：
    </p>
    <ul>
     <li>
      若它的左⼦树不为空，则左⼦树上所有节点的值都⼩于根节点的值；
     </li>
     <li>
      若它的右⼦树不为空，则右⼦树上所有节点的值都⼤于根节点的值；
     </li>
     <li>
      它的左右⼦树也分别为⼆叉搜索树。
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/1530e1ceaa584444aa13225e124c6824.png" width="413"/>
    </p>
    <h3 id="2.2.%20%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C" name="2.2.%20%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C">
     2.2. 查找操作
    </h3>
    <p>
     查找的思路是，让需要查找的值key与结点的值域val进行比较。如果key大于val，就去遍历右子树；如果key小于val，就去遍历左子树；如果相等，直接返回这个结点。
    </p>
    <pre><code class="language-java">    public TreeNode root = null;

    public TreeNode Search(int val) {
        TreeNode cur = root;
        while (cur != null) {
            if (cur.val &gt; val) {
                cur = cur.left;
            } else if (cur.val &lt; val) {
                cur = cur.right;
            } else {
                return cur;
            }
        }
        return null;
    }</code></pre>
    <p>
     上面算法的时间复杂度最好情况下（一棵满二叉树）为
     <img alt="logn" class="mathcode" src="https://latex.csdn.net/eq?logn">
      ，最坏情况下（只有单个分支）时间复杂度为
      <img alt="n" class="mathcode" src="https://latex.csdn.net/eq?n">
       。
      </img>
     </img>
    </p>
    <h3 id="2.2.%20%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C" name="2.2.%20%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">
     2.2. 插入操作
    </h3>
    <p>
     我们在完成插入操作之后，依然要保证这棵树是一棵二叉搜索树。我们把需要插入的数值val先与根结点的值root.val进行比较，大于在右树插入，小于在左树插入。如下图所示，我们需要将70插入进73的左边，70成为61的右子树，而此时的cur已经为空了。但问题来了，程序没有记录下30的位置，所以我们还需要一个p引用来记录cur走过的前一个位置。当cur为空时，如果val大于p.val，则插入p的右边；如果val小于p.val，则插入p的左边。如果这棵树为空，我们插入第一个结点时，直接让root等于插入的结点就可以。
    </p>
    <p class="img-center">
     <img alt="" height="213" src="https://i-blog.csdnimg.cn/direct/6bb0087e4dce4cfda4ea757376f66113.png" width="428"/>
    </p>
    <pre><code class="language-java">    public void Insert(int val) {
        TreeNode newNode = new TreeNode(val);

        if (root == null) {
            root = newNode;
            return;
        }

        TreeNode cur = root;
        TreeNode parent = null;

        while (cur != null) {
            if (cur.val &lt; val) {
                parent = cur;
                cur = cur.right;
            } else if (cur.val &gt; val) {
                parent = cur;
                cur = cur.left;
            } else {
                return;
            }
        }
        if (parent.val &lt; val) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
    }</code></pre>
    <h3 id="2.3.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" name="2.3.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">
     2.3. 删除操作
    </h3>
    <p>
     删除操作相较于前两个来说比较复杂。如果这个节点没有左右结点，就直接置为空；如果这个结点有左孩子结点或者右孩子结点，就直接将孩子结点变为删除结点的父亲结点的子结点。但如果待删除的结点左右都不为空，该怎么办。
    </p>
    <p>
     我们要想删除val，就要先查询到该元素。如果要删除的结点为cur，它的父亲结点为parent。我们先假设cur.left为空，且cur是parent.left，那么parent.left=cur.right；再假设cur是parent.right，那么parent.right=cur.right。如下图所示，我们要删除的结点为61。
    </p>
    <p class="img-center">
     <img alt="" height="293" src="https://i-blog.csdnimg.cn/direct/7611268f07e449ebb7e9fa6803726b8b.png" width="793"/>
    </p>
    <p>
     同理，如果cur.right为空，且cur是parent.left，那么parent.left=cur.left；再假设cur是parent.right，那么parent.right=cur.left。
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">    public void Remove(int val){
        TreeNode cur = root;
        TreeNode parent = null;
        while(cur != null){
            if(cur.val &lt; val){
                parent = cur;
                cur = cur.right;
            }else if(cur.val &gt; val){
                parent = cur;
                cur = cur.left;
            }else{
                RemoveNode(cur,parent);
                return;
            }
        }
    }

    private void RemoveNode(TreeNode cur, TreeNode parent) {
        if(cur.left == null){
            if(cur == root){
                root = root.right;
            }else if(cur == parent.left){
                parent.left = cur.right;
            }else{
                parent.right = cur.right;
            }
        }else if(cur.right == null){
            if(cur == root){
                root = root.left;
            }else if(cur == parent.left){
                parent.left = cur.left;
            }else{
                parent.right = cur.left;
            }
        }
    }</code></pre>
    <p>
     下面是最难的一种情况，就是cur的左右结点都不为空，如果删除，该如何安排它的左右结点。利用替换法，找出一个“替罪羊”，让替换的值去替换我们要删除的结点。比如我们要删除73，在73的左子树找出最大值来替换73，这样就能保证要删除的结点左侧都是比它小的，然后我们去删70。如下图所示，这样就会出现要删除的结点一边为空，一边不为空。
    </p>
    <p class="img-center">
     <img alt="" height="256" src="https://i-blog.csdnimg.cn/direct/2c253b2c0b0042319b586599ad9e406d.png" width="290"/>
    </p>
    <pre><code class="language-java">TreeNode target = cur.right;
TreeNode targetParent = cur;
while(target.left != null){
    targetParent = target;
    target = target.left;
}
targetParent.left = target.right;</code></pre>
    <p>
     代码写到这里，我们还有一种情况没有考虑到。我们看下图这种情况，81的左边为空，无法进入上面的while循环，那么我们就需要用81替换73。
    </p>
    <p class="img-center">
     <img alt="" height="290" src="https://i-blog.csdnimg.cn/direct/d0909e6701fa440cb05d31166556b987.png" width="445"/>
    </p>
    <pre><code class="language-java">    public void Remove(int val) {
        TreeNode cur = root;
        TreeNode parent = null;
        while (cur != null) {
            if (cur.val &lt; val) {
                parent = cur;
                cur = cur.right;
            } else if (cur.val &gt; val) {
                parent = cur;
                cur = cur.left;
            } else {
                RemoveNode(cur, parent);
                return;
            }
        }
    }

    private void RemoveNode(TreeNode cur, TreeNode parent) {
        if (cur.left == null) {
            if (cur == root) {
                root = root.right;
            } else if (cur == parent.left) {
                parent.left = cur.right;
            } else {
                parent.right = cur.right;
            }
        } else if (cur.right == null) {
            if (cur == root) {
                root = root.left;
            } else if (cur == parent.left) {
                parent.left = cur.left;
            } else {
                parent.right = cur.left;
            }
        } else {
            TreeNode target = cur.right;
            TreeNode targetParent = cur;
            while(target.left != null){
                targetParent = target;
                target = target.left;
            }
            if(target == targetParent.left) {
                targetParent.left = target.right;
            }else{
                targetParent.left = target.right;
            }
        }
    }</code></pre>
    <h3 id="2.4.%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" name="2.4.%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">
     2.4. 性能分析
    </h3>
    <p>
     插⼊和删除操作都必须先查找，查找效率代表了⼆叉搜索树中各个操作的性能。 对有n个结点的⼆叉搜索树，若每个元素查找的概率相等，则⼆叉搜索树平均查找⻓度是结点在⼆叉搜 索树的深度的函数，即结点越深，则比较次数越多。
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E6%90%9C%E7%B4%A2" name="%E4%B8%89%E3%80%81%E6%90%9C%E7%B4%A2">
     三、搜索
    </h2>
    <h3 id="3.1.%20%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%9C%BA%E6%99%AF" name="3.1.%20%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%9C%BA%E6%99%AF">
     3.1. 概念及场景
    </h3>
    <p>
     Map和set是⼀种专⻔⽤来进⾏搜索的容器或者数据结构，其搜索的效率与其具体的实例化⼦类有关。以前常见的搜索方式有：直接遍历或者二分查找。但这些只能在特定场景下才能使用，一般的情况下效率相对较低。这两种查找比较适合静态类型的查找，即⼀般不会对区间进⾏插⼊和删除操作了。而现实中的查找比如：根据姓名查询考试成绩或者通讯录中根据姓名查询联系方式。
    </p>
    <h3 id="3.2.%20%E6%A8%A1%E5%9E%8B" name="3.2.%20%E6%A8%A1%E5%9E%8B">
     3.2. 模型
    </h3>
    <p>
     ⼀般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为Key-value的键值对，所以模型会有两种：
    </p>
    <ul>
     <li>
      纯key模型
     </li>
    </ul>
    <p>
     有⼀个英⽂词典，快速查找⼀个单词是否在词典中。
    </p>
    <ul>
     <li>
      . Key-Value 模型
     </li>
    </ul>
    <p>
     统计⽂件中每个单词出现的次数，统计结果是每个单词都有与其对应的次数：&lt;单词，单词出现的次数。
    </p>
    <p>
     Map中存储的就是key-value的键值对，Set中只存储了Key。
    </p>
    <h2 id="%E5%9B%9B%E3%80%81Map" name="%E5%9B%9B%E3%80%81Map" style="background-color:transparent">
     四、Map
    </h2>
    <h3 id="4.1.%20Map%E7%9A%84%E8%AF%B4%E6%98%8E" name="4.1.%20Map%E7%9A%84%E8%AF%B4%E6%98%8E" style="background-color:transparent">
     4.1. Map的说明
    </h3>
    <p>
     Map是⼀个接⼝类，该类没有继承⾃Collection，该类中存储的是结构的键值对，并且K⼀定是唯一的，不能重复。
    </p>
    <pre><code class="language-java">public interface Map&lt;K, V&gt; </code></pre>
    <pre><code class="language-java">    interface Entry&lt;K, V&gt;</code></pre>
    <p class="img-center">
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/ac22cbc1cb5d4e8e99a55ede308c9c92.png" width="431"/>
    </p>
    <p>
     我们可以看下Structure里面，Map内部又实现了一个接口Entry，可以理解为二叉搜索树里的TreeNode。
    </p>
    <h3 id="3.2.%C2%A0Map%E7%9A%84%E4%BD%BF%E7%94%A8" name="3.2.%C2%A0Map%E7%9A%84%E4%BD%BF%E7%94%A8">
     3.2. Map的使用
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td style="text-align:center">
        方法
       </td>
       <td style="text-align:center">
        说明
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        V get(Object key)
       </td>
       <td style="text-align:center">
        返回key对应的value值
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        V getOrDefault(Object key,V defaultValue)
       </td>
       <td style="text-align:center">
        返回key对应的value值，若key不存在，返回默认值
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        V put&lt;key,value&gt;
       </td>
       <td style="text-align:center">
        设置key对应的value
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        V remove&lt;Object key&gt;
       </td>
       <td style="text-align:center">
        删除key的映射关系
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        Set&lt;K&gt; keySet()
       </td>
       <td style="text-align:center">
        返回所有key的不重复集合
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        Collection&lt;V&gt; values()
       </td>
       <td style="text-align:center">
        返回所有value的可重复集合
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()
       </td>
       <td style="text-align:center">
        返回key-value的所有映射关系
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean containsKey(Object key)
       </td>
       <td style="text-align:center">
        判断是否包含key
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean containsKey(Object value)
       </td>
       <td style="text-align:center">
        判断是否包含value
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-java">import java.util.Collection;
import java.util.Set;
import java.util.TreeMap;

public class Solution {
    public static void main(String[] args) {
        TreeMap&lt;Character,Integer&gt; tree1 = new TreeMap&lt;&gt;();
        //底层是二叉搜索树，要想实现插入与删除，进行的是k的比较
        //如果k是其他类，那么这个类必须是可比较的
        tree1.put('a',1);
        tree1.put('b',2);
        tree1.put('c',3);
        tree1.put('d',4);
        tree1.put('e',5);
        tree1.put('a',1);
        tree1.put('b',2);
        tree1.put('c',3);
        tree1.put('x',1);
        tree1.put('y',2);
        tree1.put('z',3);
        System.out.println(tree1.get('a'));//根据key获取value，打印1
        tree1.put('a',10);//设置key对应的value是唯一的

        System.out.println(tree1.get('a'));//打印10
        System.out.println(tree1.get('e'));//返回null

        System.out.println(tree1.getOrDefault('f',6));

        System.out.println(tree1.containsKey('c'));
        System.out.println(tree1.containsKey('f'));

        Set&lt;Character&gt; setTree = tree1.keySet();
        System.out.println(setTree);

        Collection&lt;Integer&gt; collection = tree1.values();
        System.out.println(collection);

        Integer in = tree1.remove('a');
        System.out.println(in);
    }
}</code></pre>
    <p class="img-center">
     <img alt="" height="327" src="https://i-blog.csdnimg.cn/direct/58cb054d5f974b02a18975dc20fa3d4f.png" width="745"/>
    </p>
    <p>
     注意：
    </p>
    <ul>
     <li>
      Map是⼀个接口，不能直接实例化对象，如果要实例化对象只能实例化其实现类TreeMap或者 HashMap
     </li>
     <li>
      在TreeMap中插⼊键值对时，key不能为空，否则就会抛NullPointerException异常，value可以 为空。但是HashMap的key和value都可以为空。
     </li>
     <li>
      Map中键值对的Key不能直接修改，value可以修改，如果要修改key，只能先将该key删除掉，然 后再来进行重新插入。
     </li>
    </ul>
    <h2 id="%E4%BA%94%E3%80%81Set" name="%E4%BA%94%E3%80%81Set">
     五、Set
    </h2>
    <p>
     Set与Map主要的不同有两点：Set是继承⾃Collection的接⼝类，Set中只存储了Key。
    </p>
    <h3 id="5.1.%20Set%E7%9A%84%E4%BD%BF%E7%94%A8" name="5.1.%20Set%E7%9A%84%E4%BD%BF%E7%94%A8">
     5.1. Set的使用
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td style="text-align:center">
        方法
       </td>
       <td style="text-align:center">
        说明
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean add(E,e)
       </td>
       <td style="text-align:center">
        添加元素，但重复元素不会被添加
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        void clear()
       </td>
       <td style="text-align:center">
        清空集合
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean contains(Object o)
       </td>
       <td style="text-align:center">
        判断o是否在集合中
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        Iterator&lt;E&gt; Iterator()
       </td>
       <td style="text-align:center">
        返回迭代器
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean remove(Object o)
       </td>
       <td style="text-align:center">
        删除集合中的o
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        int size()
       </td>
       <td style="text-align:center">
        返回集合中的元素个数
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean isEmpty()
       </td>
       <td style="text-align:center">
        检查集合是否为空
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        Object[] toArray()
       </td>
       <td style="text-align:center">
        将集合中的元素转化成数组
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean containsAll(Collection&lt;?&gt; c)
       </td>
       <td style="text-align:center">
        集合c中的元素是否全部存在于集合set中
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        boolean addAll(Collection&lt;? extends E&gt; c)
       </td>
       <td style="text-align:center">
        将集合c中的元素添加进set中
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-java">import java.util.Iterator;
import java.util.TreeSet;

public class Solution {
    public static void main(String[] args) {
        TreeSet&lt;String&gt; tree = new TreeSet&lt;&gt;();
        System.out.println(tree.isEmpty());//集合是否为空

        tree.add("abc");//添加
        tree.add("def");
        tree.add("hello");
        tree.add("world");
        tree.add("hello");//只能添加一个
        System.out.println(tree);
        System.out.println(tree.isEmpty());

        System.out.println(tree.contains("abc"));//判断是否存在集合中
        System.out.println(tree.contains("bac"));

        System.out.println(tree.size());//获取长度

        String[] array = tree.toArray(new String[3]);//转化成数组
        for (String i: array) {
            System.out.print(i+" ");
        }

        System.out.println();
        tree.remove("world");//删除元素
        System.out.println(tree);

        Iterator&lt;String&gt; it = tree.iterator();
        while (it.hasNext()){
            System.out.print(it.next()+" ");
        }
    }
}</code></pre>
    <p>
     Set中只存储了key，并且要求key⼀定要唯一，TreeSet的底层是使用Map来实现的，其使⽤key与Object的⼀个默认对象作为键值对插⼊到Map中的。我们来看一下TreeSet的构造方法的源码：
    </p>
    <pre><code class="language-java">    public TreeSet() {
        this(new TreeMap&lt;&gt;());
    }</code></pre>
    <pre><code class="language-java">    TreeSet(NavigableMap&lt;E,Object&gt; m) {
        this.m = m;
    }</code></pre>
    <pre><code class="language-java">public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt;</code></pre>
    <pre><code class="language-java">public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt;</code></pre>
    <pre><code class="language-java">    public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }</code></pre>
    <p>
     上面的TreeMap传给了m，m是NavigableMap类型的，而NavigableMap又继承了Map，我们再来看add方法，里面的e接收了key，PRESENT接收了value，而这个PRESENT又是一个Object类。
    </p>
    <pre><code class="language-java">private transient NavigableMap&lt;E,Object&gt; m;</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38353139383932372f:61727469636c652f64657461696c732f313436313531373935" class_="artid" style="display:none">
 </p>
</div>


