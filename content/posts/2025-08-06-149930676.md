---
layout: post
title: "从零开始的云计算生活第三十八天,避坑落井,Docker容器模块"
date: 2025-08-06T11:25:04+0800
description: "Docker，翻译过来就是码头工人Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可抑制的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器完全使用沙盒机制，相互之间不会存在任何接口。几乎没有性能开销，可以很容易的在机器和数据中心运行。最重要的是，他们不依赖于任何语言、框架或者包装系统。Docker是dotCloud公司开源的一个基于LXC的高级容器引擎，源码托管在Github上，基于go语言并且遵从Apache2.0协议开源。GitHub地址。"
keywords: "从零开始的云计算生活——第三十八天，避坑落井，Docker容器模块"
categories: ['异世界的云计算']
tags: ['生活', '容器', 'Docker']
artid: "149930676"
arturl: "https://blog.csdn.net/Britz_Kevin/article/details/149930676"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=149930676
    alt: "从零开始的云计算生活第三十八天,避坑落井,Docker容器模块"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=149930676
featuredImagePreview: https://bing.ee123.net/img/rand?artid=149930676
cover: https://bing.ee123.net/img/rand?artid=149930676
image: https://bing.ee123.net/img/rand?artid=149930676
img: https://bing.ee123.net/img/rand?artid=149930676
---



# 从零开始的云计算生活——第三十八天，避坑落井，Docker容器模块

![](https://i-operation.csdnimg.cn/images/cf31225e169b4512917b2e77694eb0a2.png)Docker容器技术全面入门指南



## 一.故事背景

在综合使用了之前全部的知识完成项目之后，接下来将学习更简单的方法来对之前的命令进行使用，马上进入容器模块

## 二. Docker概述

#### Docker简介

Docker，翻译过来就是码头工人

Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可抑制的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器完全使用**沙盒机制**，相互之间不会存在任何接口。几乎没有性能开销，可以很容易的在机器和数据中心运行。最重要的是，他们不依赖于任何语言、框架或者包装系统。

Docker是dotCloud公司开源的一个基于**LXC**的高级容器引擎，源码托管在Github上，基于**go语言**并且遵从Apache2.0协议开源。 **GitHub地址**：[https://github.com/moby/moby](https://github.com/moby/moby "https://github.com/moby/moby")

LXC主要通过**Kernel的namespace**实现每个用户实例之间的项目隔离，通过**cgroup**实现对资源的配额和调度。

​

名词解释

​

**沙盒：**沙盒也叫沙箱（sandbox）。在计算机领域指一种虚拟技术，而且多用于计算机安全技术。安全软件可以让它在沙盒中运行，如果含有恶意行为，则禁止程序的进一步运行，而这不会对系统造成任何危害。

**LXC：**Linux Container的简写。Linux Container 容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。

**cgroup：**控制组，Control Groups，是一种内核功能，用于限制、统计和隔离一个进程组（process groups）所使用的物理资源，如CPU、内存、磁盘输入输出等。从2.6.24内核引入，它将进程管理从cpuset中剥离出来，并非全新创造的。cgroup提供了一个虚拟文件系统，作为分组管理和各子系统设置的接口。因此，使用cgroup时，必须挂载cgroup文件系统。

**cgroup的主要目的是实现资源限制和进程管理**。通过将进程分组，可以对各个组内的进程进行资源限制，例如CPU、内存和磁盘输入输出等。这有助于确保系统资源得到合理分配，同时也可以避免单个进程过度消耗资源，导致系统性能下降。

​

docker官网: https://www.docker.com   
 docker中文库: https://www.docker.org.cn/

​

#### Docker版本演化与技术特征更新

##### 1、Docker发展历程概述

Docker自2013年诞生以来，经历了从简单的容器工具到完整的容器生态系统的演变过程。其版本演化可以分为四个主要阶段：

###### 1. 初创期（2013-2014）

* 2013年3月：Docker 0.1.0发布，基于LXC技术
* 2014年6月：Docker 1.0发布，标志着生产就绪

###### 2. 成长期（2015-2016）

* 引入Swarm集群管理
* 建立开放容器倡议(OCI)标准

###### 3. 成熟期（2017-2019）

* 采用新的版本命名方案(YY.MM)
* 分化为CE(社区版)和EE(企业版)

###### 4. 现代期（2020至今)

* 深度集成Kubernetes
* 专注于开发者体验和安全增强

##### 2、重大版本技术特征更新

###### Docker 1.0 (2014年6月)

* **核心技术**：从LXC转向libcontainer
* **镜像格式**：建立分层存储体系
* **网络模型**：基础桥接网络支持

###### Docker 1.12 (2016年7月)

* **Swarm模式**：内置容器编排功能
* **服务发现**：内置DNS服务
* **安全增强**：TLS加密通信

###### Docker 17.03 (2017年3月)

* **版本改革**：采用YY.MM版本号
* **多架构支持**：ARM平台正式支持
* **插件系统**：卷和网络插件标准化

###### Docker 18.09 (2018年11月)

* **BuildKit**：实验性下一代构建引擎
* **Rootless模式**：非root用户运行容器
* **cgroups v2**：初步支持新控制组系统

###### Docker 19.03 (2019年7月)

* **GPU支持**：NVIDIA GPU容器化
* **性能优化**：containerd集成改进
* **Windows容器**：完善WSL2支持

###### Docker 20.10 (2020年12月)

* **BuildKit默认**：取代经典构建引擎
* **Compose V2**：重写为Go版本
* **检查点/恢复**：实验性容器状态保存

###### Docker 23.0 (2023年1月)

* **构建革新**：完全移除经典构建引擎
* **镜像管理**：改进垃圾回收机制
* **安全扫描**：内置漏洞扫描工具

##### 3、关键技术演进路线

###### 1. 容器运行时演进

* libcontainer → runc → containerd
* 符合OCI运行时规范
* gVisor、Kata Containers等安全容器支持

###### 2. 构建系统革新

* 传统构建 → BuildKit
* 多阶段构建支持
* 构建缓存优化和并行构建

###### 3. 网络模型发展

* 基础桥接网络 → overlay网络
* Macvlan/IPvlan支持
* 服务网格集成能力

###### 4. 存储驱动优化

* AUFS → overlay2
* 快照和存储配额管理
* 卷插件生态系统

###### 5. 安全增强路径

* 用户命名空间隔离
* Rootless容器模式
* 内容信任和镜像签名

##### 4、当前技术趋势

1. **云原生集成**：与Kubernetes深度整合
2. **开发者体验**：简化本地开发工作流
3. **安全强化**：默认安全配置和策略
4. **性能优化**：资源利用率和启动速度
5. **多平台支持**：ARM、RISC-V等架构

#### Docker容器技术与虚拟机的区别

**相同点**：docker容器技术和虚拟机技术，都是虚拟化技术。

**不同点**：

* 虚拟机技术：

![](https://i-blog.csdnimg.cn/direct/8790052c60da4f6483131216e2ea0e49.png)

* docker容器技术：

![](https://i-blog.csdnimg.cn/direct/91b5996f20c447809417795e775ca2a8.png)

通过图片，我们很明显的看到docker有着比虚拟机更少的抽象层。 由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。所以docker效率比虚拟机效率高。达到了秒级启动的地步。

#### Docker相较于VM的优点

* 比VM小、快，Docker容器的尺寸减小相比于整个虚拟机大大简化了分布到云和分发时间的开销。Docker启动一个容器实例时间仅仅需要几秒钟。
* Docker是一个开放的平台，构建、发布和运行分布式应用程序。
* 开发人员不需要关注具体是哪个Linux操作系统。
* Google、微软（azure）、亚马逊（AWS）、IBM等都支持docker。
* Docker支持Unix/Linux操作系统，也支持Windows和Mac。
* 一次封装，到处运行

#### Docker局限性

Docker用于应用程序时是最有用的，但并不包含数据。日志、数据库等通常放在Docker容器外。一个容器的镜像通常都很小，不用存储大量数据，存储可以通过外部挂载等方式使用，比如：NFS、ipsan、MFS、ceph等 ，或者docker -v 命令进行映射磁盘。 总之，**docker只用于计算，存储交给别人。**

#### Docker通常用于如下场景

* web应用的自动化打包和发布；
* 自动化测试和持续集成、发布；
* 在服务型环境中部署和调整数据库或其他的后台应用；
* 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。

## 三. Docker 架构

**Docker 包括三个基本概念**

* **镜像（Image）**：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
* **容器（Container）**：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
* **仓库（Repository）**：仓库可看成一个代码控制中心，用来保存镜像。

Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。

Docker 容器通过 Docker 镜像来创建。

![](https://i-blog.csdnimg.cn/direct/2bce3d7de7a042a2b265bc4556b4bf44.png)

| 概念 | 说明 |
| --- | --- |
| Docker 镜像(Images) | Docker 镜像是用于创建 Docker 容器的模板，比如 CentOS 系统。 |
| Docker 容器(Container) | 容器是独立运行的一个或一组应用，是镜像运行时的实体。 |
| Docker 客户端(Client) | Docker 客户端通过命令行或者其他工具使用 Docker SDK ([SDK | Docker Docs](https://docs.docker.com/develop/sdk/ "SDK | Docker Docs")) 与 Docker 的守护进程通信。 |
| Docker 主机(Host) | 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 |
| Docker Registry | Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub([https://hub.docker.com](https://hub.docker.com/ "https://hub.docker.com")) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 **<仓库名>:<标签>** 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 **latest** 作为默认标签。 |
| Docker Machine | Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 |

## 四.Docker安装

#### 1、使用官方安装脚本自动安装

```
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
```

#### 2、手动安装

> yum remove runc -y   #rocky8 安装
>
> yum install -y yum-utils  
>  yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  
>  yum install -y docker-ce

![](https://i-blog.csdnimg.cn/direct/a8e2dff577224d64ab62d80ea2f33d69.png)

![](https://i-blog.csdnimg.cn/direct/4e02f5c66675460f9abb0536296b1039.png)

#### 3、启动 Docker

> systemctl start docker
>
> ##通过运行 hello-world 镜像来验证是否正确安装了 Docker Engine-Community
>
> docker run hello-world

![](https://i-blog.csdnimg.cn/direct/ca6b50ab661f4316a31c6fbd4cf2c1a0.png)

#### 4、卸载 Docker

```
##删除安装包
[root@localhost ~]# yum remove docker-ce
##删除镜像、容器、配置文件等内容
[root@localhost ~]# rm -rf /var/lib/docker
```

## 五.Docker 镜像加速

国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务

```
##编辑配置文件
[root@localhost ~]# cat /etc/docker/daemon.json
{
    "registry-mirrors": [
        "https://0vmzj3q6.mirror.aliyuncs.com",
        "https://docker.m.daocloud.io",
        "https://mirror.baidubce.com",
        "https://dockerproxy.com",
        "https://mirror.iscas.ac.cn",
        "https://huecker.io",
        "https://dockerhub.timeweb.cloud",
        "https://noohub.ru",
        "https://vlgh0kqj.mirror.aliyuncs.com"
    ]
}

##重新启动服务
[root@localhost ~]# systemctl daemon-reload
[root@localhost ~]# systemctl restart docker
```

![](https://i-blog.csdnimg.cn/direct/ce7589f6536045d996210ef3d8230811.png)

## 六.Docker命令与镜像、容器管理

### 一、 Docker命令

#### docker命令帮助

![](https://i-blog.csdnimg.cn/direct/bbb73ee0be184ee9baea521827ffaab3.png)

```
[root@zabbix docker]# docker --help
Usage:  docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Common Commands:
  run         Create and run a new container from an image
  exec        Execute a command in a running container
  ps          List containers
  build       Build an image from a Dockerfile
  bake        Build from a file
  pull        Download an image from a registry
  push        Upload an image to a registry
  images      List images
  login       Authenticate to a registry
  logout      Log out from a registry
  search      Search Docker Hub for images
  version     Show the Docker version information
  info        Display system-wide information

Management Commands:
  builder     Manage builds
  buildx*     Docker Buildx
  compose*    Docker Compose
  container   Manage containers
  context     Manage contexts
  image       Manage images
  manifest    Manage Docker image manifests and manifest lists
  network     Manage networks
  plugin      Manage plugins
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Swarm Commands:
  swarm       Manage Swarm

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes

Global Options:
      --config string      Location of client config files (default "/root/.docker")
  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default
                           context set with "docker context use")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket to connect to
  -l, --log-level string   Set the logging level ("debug", "info", "warn", "error", "fatal") (default "info")
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default "/root/.docker/ca.pem")
      --tlscert string     Path to TLS certificate file (default "/root/.docker/cert.pem")
      --tlskey string      Path to TLS key file (default "/root/.docker/key.pem")
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Run 'docker COMMAND --help' for more information on a command.

For more help on how to use Docker, head to https://docs.docker.com/go/guides/
```

#### docker常用子命令（重要）

| 命令字 | 含义 |
| --- | --- |
| run | 从镜像创建并运行新的容器 |
| exec | 在运行的容器中执行命令 |
| ps | 列出容器 |
| build | 从Dockerfile构建镜像 |
| pull | 从注册库下载镜像 |
| push | 将镜像上传到注册库 |
| images | 列出镜像 |
| login | 登录到注册库 |
| logout | 从注册库登出 |
| search | 在Docker Hub搜索镜像 |
| version | 显示Docker版本信息 |
| info | 显示系统全局信息 |

#### docker管理子命令(次要)

| 命令字 | 含义 |
| --- | --- |
| builder | 用于管理构建。 |
| buildx | Docker Buildx是一个可扩展的构建工具，用于构建复杂镜像，支持多种构建环境。 |
| checkpoint | 用于管理检查点。 |
| compose | 用于Docker Compose，这是一个用于定义和部署多容器应用程序的工具。 |
| container | 用于管理容器。 |
| context | 用于管理上下文。 |
| image | 用于管理镜像。 |
| manifest | 用于管理Docker镜像清单和清单列表。 |
| network | 用于管理网络。 |
| plugin | 用于插件管理。 |
| system | 用于管理系统级别的设置和配置。 |
| trust | 用于管理Docker镜像的信任关系，如标记、存储库检查等。 |

#### swarm集群管理子命令（次次要）

| 命令字 | 含义 |
| --- | --- |
| config | 管理Swarm配置。可以使用此子命令创建、更新、删除Swarm的配置文件。 |
| node | 管理Swarm节点。可以使用此子命令查看、添加、删除、重启、升级和管理节点。 |
| secret | 管理Swarm密钥。可以使用此子命令创建、查看、删除和管理Swarm中的密钥。 |
| service | 管理Swarm服务。可以使用此子命令创建、删除、启动、停止、重启和管理服务。 |
| stack | 管理Swarm堆栈。可以使用此子命令创建、删除、列表和管理堆栈。 |
| swarm | 管理Swarm集群。可以使用此子命令查看、启用、禁用、重启和管理Swarm集群。 |

#### docker容器管理子命令（重要）

| 命令字 | 含义 |
| --- | --- |
| attach | 将本地标准输入、输出和错误流附加到正在运行的容器。 |
| commit | 从容器中的更改创建一个新的镜像。 |
| cp | 在容器和本地文件系统之间复制文件/文件夹。 |
| create | 基于镜像创建一个容器，但该容器不会启动，默认处于“created”状态 |
| diff | 查看容器文件系统或目录的更改。 |
| events | 获取来自服务器的实时事件。 |
| export | 导出容器的文件系统为tar归档。 |
| history | 显示镜像的历史记录。 |
| import | 从tar包导入内容以创建文件系统镜像。 |
| inspect | 返回Docker对象的低级别信息。 |
| kill | 杀死一个或多个运行的容器。 |
| load | 从tar归档加载镜像。 |
| logs | 获取容器的日志。 |
| pause | 暂停一个或多个容器的所有进程。 |
| port | 列出容器端口映射或特定的映射。 |
| rename | 重命名容器。 |
| restart | 重新启动一个或多个容器。 |
| rm | 删除一个或多个容器。 |
| rmi | 删除一个或多个镜像。 |
| save | 保存一个或多个镜像到tar归档（默认情况下作为流传输到标准输出）。 -o，指定输出目标路径 |
| start | 启动一个或多个已停止的容器。 |
| stats | 显示实时流容器资源使用统计信息。 |
| stop | 停止一个或多个运行的容器。 |
| tag | 为镜像创建一个标签，该标签引用另一个镜像。 |
| top | 显示正在运行的进程的容器。 |
| unpause | 在一个或多个容器中恢复所有进程。 |
| update | 更新一个或多个容器的配置。 |
| wait | 阻塞直到一个或多个容器停止，然后打印它们的退出代码。 |

#### docker全局选项

| 命令字 | 含义 |
| --- | --- |
| --config string | 指定客户端配置文件的路径（默认是"/root/.docker"）。 |
| -c, --context string | 指定用于连接到Docker daemon的上下文的名称。这个选项会覆盖DOCKER_HOST环境变量和通过"docker context use"设定的默认上下文。 |
| -D, --debug | 启用调试模式，提供更多的日志信息。 |
| -H, --host list | 指定要连接到Docker daemon的套接字。 |
| -l, --log-level string | 设置日志级别（如"debug", "info", "warn", "error", "fatal"）。默认是"info"。 |
| --tls | 使用TLS，由 --tlsverify 选项隐含。 |
| --tlscacert string | 只信任由该CA签名的证书。 |
| --tlscert string | 指定TLS证书文件的路径。 |
| --tlskey string | 指定TLS密钥文件的路径。 |
| --tlsverify | 使用TLS并验证远程服务器。 |
| -v, --version | 打印版本信息并退出。 |

### 二、 docker镜像管理

#### 概述

**docker镜像**是`docker`的核心概念之一，它是用来构建和运行**docker容器**的模板。

类似于虚拟机镜像，可以理解为一个面向Docker引擎的**只读**模板，包含了文件系统。 例如：一个镜像可以包含一个完整的Ubuntu操作系统环境，可以把它称为一个Ubuntu镜像。镜像也可以安装了Apache应用程序，可以把它称为一个Apache镜像。 镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。

**镜像自身是只读的。容器从镜像启动的时候，Docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。**

![](https://i-blog.csdnimg.cn/direct/ceaae6ba63eb4c8faf6ee6be39ecbe6c.png)

#### 核心概念

| 概念 | 含义 |
| --- | --- |
| **镜像标签** | 每个镜像都可以有一个或多个标签，用于区分不同版本的镜像，标签一般由两部分组成，中间用冒号分隔，例如：ubuntu:15.04 |
| **镜像层** | 镜像是由多个镜像层（Layers）组成的，每个镜像层包含了一个文件系统的增量修改，比如新增、删除或修改文件，当docker启动一个容器时，会将这些镜像层叠加在一起，形成一个完整的文件系统 |
| **Dockerfile** | Dockerfile是用来构建docker镜像的文本文件，其中包含了一系列构建指令，比如FROM、RUN、COPY等，通过Dockerfile，可以自动化构建和发布docker镜像 |
| **镜像仓库** | 镜像仓库是用来存储和管理Docker镜像的系统，可以是公共的或私有的。私有镜像仓库通常用于企业内部部署应用程序或保护敏感数据，而公共镜像仓库则可供开发者和用户使用。Docker Hub是Docker官方的公共镜像仓库，包含了大量常用的Docker镜像，可以方便地查找和下载镜像，同时，Docker Hub也支持用户上传和分享自己构建的Docker镜像 |

#### 镜像的分层

docker镜像分为四层，如下图所示：

![](https://i-blog.csdnimg.cn/direct/38f01292add34210912516fad1a0b67d.png)

**镜像分层后的优势**

* 共享宿主机的kernel
* base镜像提供的是最小的Linux发行版（base镜像：不同发行版的/文件系统）
* 同一docker主机支持运行多种Linux发行版
* 采用分层结构的最大好处是：共享资源
* 镜像通过分层，如果本地已经有了，不管这一层属于哪个镜像，因为每一层都有独立的标识（都是唯一的），只要docker判断有这一层，那它就不会进行重复的拉取。包括在上传仓库的时候也是一样的，仓库内存储时也是按照层来存储的，如果远程仓库有这一层了，就不需要重复上传了，节省了带宽。

#### 镜像的特点

docker使用 **Copy-on-Write** 的机制（可写容器层，cow），当我们想保存一个数据的时候，由于镜像是只读的，当我们创建容器时，是在镜像层的上面创建一个可写容器层，所有对容器的修改都会放置在可写容器层上，只要这个容器不被释放，这个数据一直存在，除非把这个容器删掉。如果想保存，把可写容器层进行打包，即把它创建成一个镜像层，一旦成为镜像层它就变成只读模式了（最多127层）。

镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。

添加文件：在容器中创建文件时，新文件被添加到容器层中;

读取文件：在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存;

修改文件：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之;

删除文件：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作;

只有当需要修改时才复制一份数据，这种特性被称作**Copy-on-Write**。**可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。**这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。

#### 镜像的表示

![](https://i-blog.csdnimg.cn/direct/21ea48828150406481200bc18024d44f.png)

**镜像的表示分为四部分**

* 红色的部分是镜像中心域名
* 黄色的部分是镜像命名空间，我们可以根据命名空间进行权限控制等操作
* 绿色是镜像的名称，每个镜像有一个版本（即标签）。
* 蓝色表示版本，laest是最新版

Docker官方的镜像不需要镜像中心的域名，有一些镜像可以省略命名空间。

#### 镜像制作方式

| 方式 | 说明 |
| --- | --- |
| Dockerfile | Dockerfile是一种文本文件，其中包含了一系列构建指令，比如FROM、RUN、COPY等，可以自动化构建和发布Docker镜像 |
| 本地文件 | 可以使用docker load命令将本地文件系统的备份文件导入为Docker镜像，该备份文件可以使用docker |
| 容器生成 | 可以使用docker commit命令从已有的Docker容器创建新的Docker镜像 |
| 镜像仓库下载 | DockerHub是Docker官方的公共镜像仓库，可以从中下载现成的Docker镜像，然后根据需要进行修改和定制，除了DockerHub，还有其他第三方镜像仓库，也可以从中下载Docker镜像，但需要注意镜像的来源和安全性 |

#### 镜像管理命令

![](https://i-blog.csdnimg.cn/direct/2c487c5545384245a7547c38b9b17e73.png)

| 命令 | 描述 | 举例 |
| --- | --- | --- |
| docker images | 列出本地所有镜像 | docker images |
| docker search | 在Docker Hub上搜索镜像 | docker search nginx |
| docker pull | 下载镜像 | docker pull nginx |
| docker push | 上传镜像到Docker Hub或其他镜像仓库 | docker push username/repo:tag |
| docker build | 使用Dockerfile构建新的镜像 | docker build -t myimage:latest . |
| docker tag | 为镜像设置标签 | docker tag myimage:latest myimage:v1.0 |
| docker rmi | 删除镜像 | docker rmi myimage:latest |
| docker inspect | 查看镜像的详细信息 | docker inspect myimage:latest |
| docker history | 查看镜像的历史记录 | docker history myimage:latest |
| docker save | 将镜像保存为tar文件 | docker save myimage:latest -o myimage.tar |
| docker load | 从tar文件中加载镜像 | docker load -i myimage.tar |
| docker commit | 将容器提交为新的镜像 | docker commit container_id myimage:v1.0 |
| docker import | 从tar文件中导入镜像 | docker import myimage.tar myimage:v1.0 |

#### docker images 显示解析

> 仓库名                 标签                  镜像ID                     创建时间              镜像大小

![](https://i-blog.csdnimg.cn/direct/facaca24a2e84f5dbcdb6fbf752fcd2e.png)

#### docker history命令

![](https://i-blog.csdnimg.cn/direct/dc6de31ed4ba402a89b55c799b6fd7d6.png)

| 命令字 | 选项 |
| --- | --- |
| docker history | --format string：使用自定义模板来格式化输出： |
|  | 'table'：以带有列标题的表格格式打印输出（默认值） |
|  | 'table TEMPLATE'：使用给定的Go模板以表格格式打印输出 |
|  | 'json'：以JSON格式打印输出 |
|  | 'TEMPLATE'：使用给定的Go模板打印输出。 |
|  | -H, --human：以可读的格式打印大小和日期（默认为true） |
|  | **--no-trunc：不截断输出** |
|  | **-q, --quiet：仅显示镜像ID** |

![](https://i-blog.csdnimg.cn/direct/834a8701f0264b7cbb7f96d13085bb9a.png)

![](https://i-blog.csdnimg.cn/direct/bd92d865b64e438ca4eee06a19a8a3e2.png)

#### DockerHub

开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。

DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。

国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。

![](https://i-blog.csdnimg.cn/direct/d732655d72b145ba929d802b5457f67b.png)

##### 练习

1）去DockerHub搜索Redis镜像（需要国外服务器）

![](https://i-blog.csdnimg.cn/direct/3ccea75f8f9a42d69c026599309480eb.png)

2）查看Redis镜像的名称和版本

![](https://i-blog.csdnimg.cn/direct/dc0ba92d70d54faf8cf76f1aec0415d3.png)

3）利用docker pull命令拉取镜像

![](https://i-blog.csdnimg.cn/direct/5a00dfe428cb48c3813398500ee21691.png)

4）利用docker save命令将 redis:latest打包为一个redis.tar包

![](https://i-blog.csdnimg.cn/direct/27efd4d7938c4a429e5830a0dd7ceb66.png)

5）利用docker rmi 删除本地的redis:latest

![](https://i-blog.csdnimg.cn/direct/f432241cc4f8408bac0c76009b8534d5.png)

6）利用docker load 重新加载 redis.tar文件

![](https://i-blog.csdnimg.cn/direct/ae2b2cefd31e4b45b9a229de55d363fc.png)

![](https://i-blog.csdnimg.cn/direct/7eebb7f47666416cbbe991a97c96c551.png)

### 三、容器管理

#### 概述

Docker容器（Container）类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。 可以把容器看做一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包而成的应用盒子。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。

因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。

容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。

#### 容器操作命令

![](https://i-blog.csdnimg.cn/direct/4cb6c2ba0b3a451b806f5e8be78b8aeb.png)

##### docker run 命令(相当于合并了create和start两个命令)

| 命令字 | 选项 |
| --- | --- |
| **docker run** | **--name = "Name" 容器名字** |
|  | **-d，--detach 以后台方式运行并且返回ID，启动守护进程式容器** |
|  | **-i 使用交互方式运行容器，通常与t同时使用** |
|  | --privileged 赋予命令扩展权限,一般使用的命令是：/usr/sbin/init |
|  | **-t,--tty 为容器重新分配一个伪输入终端。也即启动交互式容器** |
|  | **-p 指定容器端口 -p 物理机端口:容器端口** |
|  | **-P 随机指定端口** |
|  | **-v 给容器挂载存储卷** |
|  | -a,--attach list：将容器附加到标准输入、标准输出或标准错误。[STDIN/STDOUT/STDERR] |
|  | -- private：在自己独立的cgroup命名空间中运行容器。 |
|  | **-e, --env list：设置环境变量。** |
|  | **-h, --hostname string：容器的主机名。** |
|  | --init：在容器内运行一个init进程，用于信号转发和进程清理工作。（某些镜像不支持，牺牲性能） |
|  | **--restart string：容器退出时要应用的重启策略（默认为"no"）。 on-failure：容器出错后重启 always：不论如何退出都重启 unless-stopped：不管什么退出状态都重启** |
|  | **--rm：当容器退出时自动删除容器。** |

-d后台运行

![](https://i-blog.csdnimg.cn/direct/af4b3c822ca443469c8d0406d1d139fd.png)

退出后保留信息

![](https://i-blog.csdnimg.cn/direct/cf473346531c40418f4c9642ec44fa40.png)

![](https://i-blog.csdnimg.cn/direct/2541766585d7492f8dafe35575d3b9c1.png)

退出后消除信息

![](https://i-blog.csdnimg.cn/direct/775d6297f1344e70adca65085877308e.png)

![](https://i-blog.csdnimg.cn/direct/aaa4f2be156843138135c645f6c7bb08.png)

![](https://i-blog.csdnimg.cn/direct/c732bbdc26434ca5acd7b2d6a3b7d20a.png)

![](https://i-blog.csdnimg.cn/direct/17b5d06fc9e646628bc1771fec59b187.png)

设置主机名

![](https://i-blog.csdnimg.cn/direct/46f4a2346dd84291baada855f40e9874.png)

```
--add-host 列表 添加自定义主机到 IP 的映射（主机：IP）
--annotation 映射 向容器添加注释（传递给 OCI 运行时）
（默认映射列表为空 []）
-a, --attach 列表 附加到标准输入（STDIN）、标准输出（STDOUT）或标准错误（STDERR）
--blkio-weight 无符号 16 位整数 块 I/O（相对权重），取值范围在 10 到 1000 之间，或设为 0 禁用
（默认值为 0）
--blkio-weight-device 列表 块 I/O 权重（相对设备权重）（默认列表为空 []）
--cap-add 列表 添加 Linux 功能
--cap-drop 列表 移除 Linux 功能
--cgroup-parent 字符串 容器可选的父 cgroup
--cgroupns 字符串 要使用的 cgroup 命名空间（主机 | 私有）
' 主机 '：在 Docker 主机的 cgroup 命名空间中运行容器
' 私有 '：在容器自身的私有 cgroup 命名空间中运行容器
''：使用守护进程上默认的 cgroupns-mode 选项所配置的 cgroup 命名空间（默认情况）
--cidfile 字符串 将容器 ID 写入文件
--cpu-period 整数 限制 CPU 的 CFS（完全公平调度器）周期
--cpu-quota 整数 限制 CPU 的 CFS（完全公平调度器）配额
--cpu-rt-period 整数 以微秒为单位限制 CPU 实时周期
--cpu-rt-runtime 整数 以微秒为单位限制 CPU 实时运行时间
-c, --cpu-shares 整数 CPU 份额（相对权重）
--cpus 十进制数 CPU 数量
--cpuset-cpus 字符串 允许执行的 CPU（格式如 0-3、0,1）
--cpuset-mems 字符串 允许执行的内存（格式如 0-3、0,1）
-d, --detach 在后台运行容器并打印容器 ID
--detach-keys 字符串 覆盖用于分离容器的按键序列
--device 列表 向容器添加主机设备
--device-cgroup-rule 列表 向 cgroup 允许的设备列表中添加规则
--device-read-bps 列表 限制从设备读取的速率（每秒字节数）（默认列表为空 []）
--device-read-iops 列表 限制从设备读取的速率（每秒 I/O 次数）（默认列表为空 []）
--device-write-bps 列表 限制向设备写入的速率（每秒字节数）（默认列表为空 []）
--device-write-iops 列表 限制向设备写入的速率（每秒 I/O 次数）（默认列表为空 []）
--disable-content-trust 跳过镜像验证（默认值为真）
--dns 列表 设置自定义 DNS 服务器
--dns-option 列表 设置 DNS 选项
--dns-search 列表 设置自定义 DNS 搜索域
--domainname 字符串 容器的 NIS 域名
--entrypoint 字符串 覆盖镜像的默认入口点（ENTRYPOINT）
-e, --env 列表 设置环境变量
--env-file 列表 读取包含环境变量的文件
--expose 列表 暴露一个端口或端口范围
--gpus GPU 请求 要添加到容器的 GPU 设备（'all' 表示传递所有 GPU）
--group-add 列表 添加要加入的其他组
--health-cmd 字符串 用于检查健康状况的命令
--health-interval 持续时间 运行检查的时间间隔（毫秒 | 秒 | 分 | 时）（默认值为 0 秒）
--health-retries 整数 判定为不健康所需的连续失败次数
--health-start-interval 持续时间 在启动期间运行检查的时间间隔（毫秒 | 秒 | 分 | 时）
（默认值为 0 秒）
--health-start-period 持续时间 容器初始化的启动周期，在开始健康检查失败次数倒计时之前（毫秒 | 秒 | 分 | 时）
（默认值为 0 秒）
--health-timeout 持续时间 允许一次健康检查运行的最长时间（毫秒 | 秒 | 分 | 时）（默认值为 0 秒）
--help 打印使用说明
-h, --hostname 字符串 容器主机名
--init 在容器内运行一个初始化程序，用于转发信号并回收进程
-i, --interactive 即使未附加，也保持标准输入（STDIN）打开
--ip 字符串 IPv4 地址（例如，172.30.100.104）
--ip6 字符串 IPv6 地址（例如，2001:db8::33）
--ipc 字符串 要使用的进程间通信（IPC）模式
--isolation 字符串 容器隔离技术
--kernel-memory 字节数 内核内存限制
-l, --label 列表 在容器上设置元数据
--label-file 列表 读取包含标签的以行分隔的文件
--link 列表 添加到另一个容器的链接
--link-local-ip 列表 容器的 IPv4/IPv6 链路本地地址
--log-driver 字符串 容器的日志驱动程序
--log-opt 列表 日志驱动程序选项
--mac-address 字符串 容器的 MAC 地址（例如，92:d0:c6:0a:29:33）
-m, --memory 字节数 内存限制
--memory-reservation 字节数 内存软限制
--memory-swap 字节数 交换空间限制，等于内存加上交换空间：'-1' 表示启用无限制交换
--memory-swappiness 整数 调整容器内存交换倾向（取值范围 0 到 100）（默认值为 - 1）
--mount 挂载 将文件系统挂载附加到容器
--name 字符串 为容器指定一个名称
--network 网络 将容器连接到网络
--network-alias 列表 为容器添加网络作用域的别名
--no-healthcheck 禁用任何容器指定的健康检查
--oom-kill-disable 禁用内存溢出（OOM）杀手
--oom-score-adj 整数 调整主机的内存溢出（OOM）偏好（取值范围 - 1000 到 1000）
--pid 字符串 要使用的进程 ID（PID）命名空间
--pids-limit 整数 调整容器的进程数量限制（设为 - 1 表示无限制）
--platform 字符串 如果服务器支持多平台，则设置平台
--privileged 赋予此容器扩展权限
-p, --publish 列表 将容器的端口发布到主机
-P, --publish-all 将所有暴露的端口发布到随机端口
--pull 字符串 在运行前拉取镜像（“总是”“缺失时”“从不”）（默认值为 “缺失时”）
-q, --quiet 抑制拉取输出
--read-only 将容器的根文件系统挂载为只读
--restart 字符串 当容器退出时应用的重启策略（默认值为 “不重启”）
--rm 容器退出时自动删除容器
--runtime 字符串 此容器要使用的运行时
--security-opt 列表 安全选项
--shm-size 字节数 /dev/shm 的大小
--sig-proxy 将接收到的信号代理到进程（默认值为真）
--stop-signal 字符串 用于停止容器的信号
--stop-timeout 整数 停止容器的超时时间（以秒为单位）
--storage-opt 列表 容器的存储驱动程序选项
--sysctl 映射 Sysctl 选项（默认映射为空 []）
--tmpfs 列表 挂载临时文件系统（tmpfs）目录
-t, --tty 分配一个伪终端（TTY）
--ulimit 资源限制 资源限制选项（默认列表为空 []）
-u, --user 字符串 用户名或用户 ID（格式：< 名称 | 用户 ID>[:< 组名 | 组 ID>]）
--userns 字符串 要使用的用户命名空间
--uts 字符串 要使用的主机名与域名系统（UTS）命名空间
-v, --volume 列表 绑定挂载一个卷
--volume-driver 字符串 容器可选的卷驱动程序
--volumes-from 列表 从指定的容器挂载卷
-w, --workdir 字符串 容器内的工作目录
```

##### docker exec命令

| 命令字 | 选项 |
| --- | --- |
| docker exec | -d、 --detach分离模式：在后台运行命令 |
|  | -e、 --env-list设置环境变量 --env文件列表读入环境变量的文件 |
|  | **-i、 交互式保持STDIN打开，即使未连接** |
|  | --privileged赋予命令扩展权限 |
|  | **-t、 --tty分配一个伪tty** |
|  | -u、 用户名或UID（格式：<name|uid>:<groupname|gid>） |
|  | -w、 --workdir string容器内的工作目录 |

![](https://i-blog.csdnimg.cn/direct/b4f8bb37610549caab7df5c8bfaeb79f.png)

![](https://i-blog.csdnimg.cn/direct/b50d74a88f1349ce9bbdead51aa9bafd.png)

##### docker logs命令

| 命令字 | 选项 |
| --- | --- |
| docker logs | 查看容器日志 |
|  | --details显示提供给日志的额外详细信息 |
|  | -f、 --follow follow日志输出 |

![](https://i-blog.csdnimg.cn/direct/1a5151ed547642449a000b8045ae34ac.png)

##### docker rename命令

| 命令字 | 选项 |
| --- | --- |
| docker rename 旧名字 新名字 | 给容器重新命名 |

![](https://i-blog.csdnimg.cn/direct/f507751e8b7b4013a22ae31eb68a5158.png)

##### docker top命令

| 命令字 | 选项 |
| --- | --- |
| docker top 容器实例的ID | 查看容器内进程 |

![](https://i-blog.csdnimg.cn/direct/06b5cf32dcd644f1b9f4499cb9f8eb90.png)

##### docker ps 命令

| 命令字 | 选项 |
| --- | --- |
| docker ps | **-a, --all显示所有容器（默认仅显示运行中的容器）** |
|  | -f, --filter filter： 根据提供的条件过滤输出 --format string 使用自定义模板格式化输出： 'table': 以表格格式显示输出，带列标题（默认） 'table TEMPLATE': 使用给定的Go模板以表格格式显示输出 'json': 以JSON格式显示 'TEMPLATE': 使用给定的Go模板显示输出 |
|  | -n, --last int 显示最后创建的n个容器（包括所有状态）（默认-1） |
|  | -l, --latest 显示最新创建的容器（包括所有状态） **--no-trunc 不要截断输出** |
|  | **-q, --quiet 仅显示容器ID** |
|  | -s, --size 显示总文件大小 |

![](https://i-blog.csdnimg.cn/direct/2b141f65a6794c7f9a6574814fcd0ad9.png)

```
容器ID         镜像名称  容器启动时的运行命令             创建时间      容器当前的状态   容器运行时暴漏的端口     容器名称 
CONTAINER ID   IMAGE          COMMAND                   CREATED         STATUS         PORTS                NAMES
f0fe90360be9   redis:latest   "docker-entrypoint.s…"   7 minutes ago   Up 7 minutes   6379/tcp             redis
```

##### docker rm 命令

| 命令字 | 选项 |
| --- | --- |
| docker rm | **-f, --force 强制删除运行中的容器（使用SIGKILL）** |
|  | -l, --link 删除指定的链接 |
|  | **-v, --volumes 删除与容器关联的匿名卷** |
|  | 别名：docker container rm, docker container remove, docker rm |

##### 

正在运行的无法rm删除，可以-f强制删除

![](https://i-blog.csdnimg.cn/direct/a2de45eaa84b4766bbaeaac6c96ab3b5.png)

![](https://i-blog.csdnimg.cn/direct/03544457316447709a3d983c1634710d.png)

##### docker kill 命令

| 命令字 | 选项 |
| --- | --- |
| docker kill | -s, --signal string：向容器发送的信号 |
| 信号类型 | `SIGTERM`：发送终止信号，通常用于请求容器停止运行。 |
|  | `SIGKILL`：发送终止信号，强制终止容器，通常用于紧急情况下快速停止容器。 |
|  | `SIGINT`：发送中断信号，通常与`Ctrl+C`类似，用于触发默认行为。 |

![](https://i-blog.csdnimg.cn/direct/a0595da45cbc4b90b19d4c8919c7a415.png)

##### docker start命令

| 命令字 | 选项 |
| --- | --- |
| docker start | 启动容器 |
|  | -a, --attach：附加STDOUT/STDERR并转发信号 |
|  | --checkpoint string：从此检查点恢复 |
|  | --checkpoint-dir string：使用自定义检查点存储目录 |
|  | --detach-keys string：重写从容器中分离的关键序列 |
|  | -i, --interactive：附加容器的STDIN |

![](https://i-blog.csdnimg.cn/direct/d8e4d41eaef541d8ae71c27f3babcad6.png)

##### docker restart命令

| 命令字 | 选项 |
| --- | --- |
| docker restart | 重启容器 |
|  | -s, --signal string：发送给容器的信号 |
|  | -t, --time int：在终止容器之前等待的秒数 |

![](https://i-blog.csdnimg.cn/direct/d2fd646da8c040d6aba7c6f9a035cbbd.png)

##### docker stop 命令

| 命令字 | 选项 |
| --- | --- |
| docker stop | 停止正在运行的容器 |
|  | -s, --signal string：发送给容器的信号 |
|  | -t, --time int：在终止容器之前等待的秒数 |

![](https://i-blog.csdnimg.cn/direct/8b3f490bffa1443c9f1cfe42808acf01.png)

##### docker inspect命令

`docker inspect` 命令用于查看 Docker 对象（如容器、镜像、网络等）的详细信息。可以使用 Go 模板语法来筛选和格式化输出内容。以下是一些常用的命令示例：

![](https://i-blog.csdnimg.cn/direct/301cd0b0689d4f258880a2783fcd2766.png)

![](https://i-blog.csdnimg.cn/direct/2a91477d0f4946fa9f12e2a8a7905ff3.png)

![](https://i-blog.csdnimg.cn/direct/b3d321c39f1348cf9090ff7598ca9072.png)

##### docker cp 命令

![](https://i-blog.csdnimg.cn/direct/bb067ed13136481fbed5211527acb8e0.png)

#### docker容器创建后的状态

| 状态 | 含义 |
| --- | --- |
| created | 创建但没有运行（docker create imageName） |
| up | 容器正在运行（docker start | docker run | docker restart） |
| Exited | 容器已退出 （docker stop） |
| paused | 容器已暂停 |

1. 0（正常退出）

   * **含义**：这是最理想的退出状态码，表示容器中的应用程序或进程正常结束。通常是因为应用完成了它的任务，例如一个脚本成功执行完毕，或者一个服务器应用在收到正常的关闭信号后，干净利落地退出。
   * 示例：

     + 假设你有一个简单的容器，里面运行一个打印 “Hello, World!” 然后退出的脚本。当脚本执行完打印操作后，它会正常退出，此时容器的退出状态码就是 0。
     + 对于一个 Web 服务器容器，如果它正确地处理了关闭信号（比如`SIGTERM`），完成了所有正在处理的请求，释放了资源，然后退出，也会返回 0。
2. 1（通用错误）

   * **含义**：这是一个比较笼统的错误状态码。它可能表示容器内部的应用程序发生了错误，比如应用程序自身的代码出现了问题，如语法错误、运行时错误（例如除以零错误、空指针引用等），或者应用程序无法正确启动。
   * 示例：

     + 如果容器内运行的是一个 Python 脚本，脚本中有一个语法错误（如缺少冒号、缩进错误等），当尝试运行这个脚本时，容器就会因为脚本无法正确执行而以状态码 1 退出。
     + 若一个 Java 应用程序在启动过程中，由于无法加载某个必需的类而抛出异常，导致启动失败，容器也可能以 1 退出。
3. 137（被强制终止）

   * **含义**：这个状态码通常表示容器被外部信号强制终止。最常见的情况是容器收到了`SIGKILL`信号。这种信号通常是在容器占用过多资源（如内存或 CPU），超出了系统设置的限制，或者系统需要紧急回收资源时发出的。
   * 示例：

     + 当容器的内存使用量不断增长，超过了 Docker 为其设置的内存限制时，Docker 守护进程可能会发送`SIGKILL`信号来终止容器，此时容器就会以 137 状态码退出。
     + 如果在主机系统上使用`docker kill`命令（不带`-s`选项，默认发送`SIGKILL`）来强制终止容器，容器也会以 137 状态码退出。
4. 139（段错误）

   * **含义**：当容器内的应用程序发生段错误（segmentation fault）时，容器会以 139 状态码退出。段错误通常是由于程序试图访问它不应该访问的内存区域，比如访问一个已经释放的指针所指向的内存，或者数组越界访问等。
   * 示例：

     + 在 C 或 C++ 程序中，如果有一个指针没有正确初始化就被用来访问内存，或者一个数组访问超出了其定义的范围，就很可能会导致段错误。当这样的程序在容器中运行时，容器会以 139 状态码退出。

这些是比较常见的 Docker 容器退出状态码，但实际上还有其他状态码，它们都可以帮助你诊断容器退出的原因。在处理容器退出问题时，结合容器的日志和应用程序本身的特性来分析这些状态码是很重要的

## 七.总结

今日只是初步的了解docker，以及一些最基础的命令的使用，之后会更加深入docker的学习。



