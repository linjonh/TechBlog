---
layout: post
title: "stdinvoke详解"
date: 2025-03-14 15:32:10 +0800
description: "std::invoke表示函数调用：只要调用std::invoke，且执行了这个语句，那么就相当于调用了传入的函数对象std::invoke的含义传入一个函数对象及这个函数对象的参数，然后通过std::invoke完成这个函数的调用std::invoke可以实现对函数对象的调用，达到与直接调用函数相同的效果如果要实现类似回调系统、事件系统类似的功能，需要集合模板来实现。"
keywords: "std::invoke详解"
categories: ['C']
tags: ['开发语言', 'Invoke', 'C']
artid: "146256154"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146256154
    alt: "stdinvoke详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146256154
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146256154
cover: https://bing.ee123.net/img/rand?artid=146256154
image: https://bing.ee123.net/img/rand?artid=146256154
img: https://bing.ee123.net/img/rand?artid=146256154
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     std::invoke详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     基础介绍
    </h2>
    <p>
     c++17版本引入了std::invoke特性，这是一个通用的调用包装器，可以统一调用：
    </p>
    <ul>
     <li>
      普通函数
     </li>
     <li>
      成员函数
     </li>
     <li>
      函数对象
     </li>
     <li>
      Lambda表达式
     </li>
     <li>
      <span style="color:#fe2c24">
       指向成员的指针
      </span>
     </li>
    </ul>
    <p>
     它的
     <span style="color:#fe2c24">
      <strong>
       主要作用是提供一个统一的方式来调用各种可调用对象
      </strong>
     </span>
     。
    </p>
    <p>
     std::invoke依赖的头文件：
     <span style="color:#fe2c24">
      <strong>
       #include &lt;functional&gt;
      </strong>
     </span>
    </p>
    <h2>
     基本用法
    </h2>
    <p>
     下面将详细介绍基本用法，即对上节中提到的对象(普通函数、成员函数、函数对象、Lambda表达式等)的调用。
    </p>
    <pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
using namespace std;

//普通函数
void basic_function(int x)
{
    cout &lt;&lt;" 普通函数："&lt;&lt;x&lt;&lt;endl;
}

//具有返回值的普通函数
int add(int a, int b) 
{
    return a + b;
}

//成员函数
class MyClass{
    public:
    void member_function(int x)
    {
        cout &lt;&lt;"成员函数:"&lt;&lt;x&lt;&lt;endl;
    }

    int value = 33;
}

//函数对象
class Functor
{
    public:
        void operator()(int x)
        {
            cout &lt;&lt;"仿函数对象"&lt;&lt;x&lt;&lt;endl;
        }
}

//示例函数
void basic_usage()
{
    //调用普通函数
    std::invoke(basic_function, 5);

    //调用具有返回值的普通函数
    int value = std::invoke(add, 4, 5);

    //调用成员函数
    MyClass obj;
    std::invoke(&amp;MyClass::member_function, obj, 5);
    
    //调用仿函数对象
    Functor funtor;
    std::invoke(funtor, 5);

    //调用lambda表达式
    std::invoke([](int x){
        cout &lt;&lt;"lambda表达式："&lt;&lt;x&lt;&lt;endl;
}, 5);
    
    //访问成员变量,这个成员变量必须时public的
    std::invoke(&amp;Myclass::value, obj);
}</code></pre>
    <h2>
     特性总结
    </h2>
    <p>
     通过上面示例可以得到以下结论：
    </p>
    <ul>
     <li>
      std::invoke表示函数调用：只要调用std::invoke，且执行了这个语句，那么就相当于调用了传入的函数对象
     </li>
     <li>
      std::invoke的含义传入一个函数对象及这个函数对象的参数，然后通过std::invoke完成这个函数的调用
     </li>
    </ul>
    <h2>
     思考：为什么引入std::invoke?
    </h2>
    <h3>
     统一的调用语法
    </h3>
    <p>
     函数对象有多种，比如普通函数，成员函数、仿函数对象，lambda表达式等不同的形式，不同的函数对象的调用方法都不相同，请看下面的例子：
    </p>
    <pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

class Example {
public:
    void method(int x) {
        std::cout &lt;&lt; "Method called: " &lt;&lt; x &lt;&lt; "\n";
    }
    int value = 42;
};

void normal_function(int x) {
    std::cout &lt;&lt; "Function called: " &lt;&lt; x &lt;&lt; "\n";
}

void unified_call_syntax() {
    Example obj;
    
    // 不使用 std::invoke 时的不同调用语法
    normal_function(1);           // 普通函数调用
    obj.method(2);               // 成员函数调用
    int val = obj.value;         // 成员变量访问
    
    // 使用 std::invoke 的统一语法
    std::invoke(normal_function, 1);          // 普通函数
    std::invoke(&amp;Example::method, obj, 2);    // 成员函数
    std::invoke(&amp;Example::value, obj);        // 成员变量
}
</code></pre>
    <p>
     从上面的例子可以看到，如果不使用std::invoke，那么不同的函数对象的对象方法和形式各不相同；但是引入std::invoke后，可以很明显的看到针对不同的函数对象实现了相同的调用形式。
    </p>
    <h3>
     泛型编程的支持
    </h3>
    <p>
     前面的例子是针对不同的函数对象不同调用，但是提到泛型编程，就会涉及不同的函数对象，不同的参数数量和类型。那如何设计一个函数可以实现不同的函数对象类型，不同参数数量和参数类型的调用呢？首先肯定是需要依靠模板实现的。请看下面的例子：
    </p>
    <pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

//函数模板
template&lt;typename F, typename... Args&gt;
decltype(auto) modern_call(F&amp;&amp; f, Args&amp;&amp;... args)
{
    return std::invoke(
    std::forward&lt;F&gt;(f),
    std::forward&lt;Args&gt;(args));
}

//普通函数
void normal_function(int x) 
{
    std::cout &lt;&lt; "Function called: " &lt;&lt; x &lt;&lt; "\n";
}
//示范类
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    double factor = 1.5;
};

void example() {
    Calculator calc;
    
    // 可以统一处理各种可调用对象
    modern_call(normal_function, 1);                  // 普通函数
    modern_call(&amp;Calculator::add, calc, 2, 3);       // 成员函数
    modern_call(&amp;Calculator::factor, calc);          // 成员变量
    modern_call([](int x) { return x * 2; }, 5);    // lambda表达式
}</code></pre>
    <p>
     通过上面的例子可以看到，通过modern_call的封装，实现了不同类型的函数对象的统一调用。可以这样说，若要实现对不同函数对象的统一调用的支持，必须要依靠模板的方式实现对std::invoke的封装。那这种泛型编程的应用场景有哪些呢？
    </p>
    <ul>
     <li>
      回调系统
     </li>
     <li>
      事件系统
     </li>
     <li>
      命令模式
     </li>
    </ul>
    <p>
     具体请看下面的例子：
    </p>
    <pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

// 1. 事件系统
class EventSystem {
public:
    template&lt;typename F, typename... Args&gt;
    void trigger(F&amp;&amp; handler, Args&amp;&amp;... args) {
        std::invoke(
            std::forward&lt;F&gt;(handler),
            std::forward&lt;Args&gt;(args)...
        );
    }
};

// 2. 命令模式
class Command {
    std::function&lt;void()&gt; action;
public:
    template&lt;typename F, typename... Args&gt;
    Command(F&amp;&amp; f, Args&amp;&amp;... args) {
        action = [=]() {
            std::invoke(f, args...);
        };
    }
    
    void execute() { action(); }
};

// 3. 回调系统
class CallbackSystem {
public:
    template&lt;typename Callback, typename... Args&gt;
    void registerCallback(Callback&amp;&amp; cb, Args&amp;&amp;... args) {
        callbacks.emplace_back([=]() {
            std::invoke(cb, args...);
        });
    }
    
    void executeAll() {
        for (auto&amp; callback : callbacks) {
            callback();
        }
    }
    
private:
    std::vector&lt;std::function&lt;void()&gt;&gt; callbacks;
};
</code></pre>
    <p>
     通过上面的例子可以清楚的看到各种场景下的使用方法，但是相同点都是在函数内部都是通过定义函数模板（泛型编程）实现的。
    </p>
    <h3>
     支持智能指针和引用包装器
    </h3>
    <pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

class Service {
public:
    int process(int x) { return x * 2; }
};

void smart_pointer_example() {
    // 智能指针支持
    auto ptr = std::make_shared&lt;Service&gt;();
    auto unique = std::make_unique&lt;Service&gt;();
    
    // std::invoke 可以直接使用智能指针
    int result1 = std::invoke(&amp;Service::process, ptr, 10);
    int result2 = std::invoke(&amp;Service::process, unique, 20);
    
    // 引用包装器支持
    Service service;
    auto ref = std::ref(service);
    int result3 = std::invoke(&amp;Service::process, ref, 30);
}
</code></pre>
    <h2>
     总结
    </h2>
    <p>
     我们需要有两个认识：
    </p>
    <ol>
     <li>
      std::invoke可以实现对函数对象的调用，达到与直接调用函数相同的效果
     </li>
     <li>
      如果要实现类似回调系统、事件系统类似的功能，需要集合模板来实现
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6971616e6368616f2f:61727469636c652f64657461696c732f313436323536313534" class_="artid" style="display:none">
 </p>
</div>


