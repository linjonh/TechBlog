---
layout: post
title: "2.2.3-TCPUDP-QUIC"
date: 2025-03-12 22:01:05 +0800
description: "2.2.3 TCP—UDP-QUIC"
keywords: "2.2.3 TCP—UDP-QUIC"
categories: ['未分类']
tags: ['网络协议', '网络', 'Udp', 'Tcp', 'Linux', 'C']
artid: "146216197"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216197
    alt: "2.2.3-TCPUDP-QUIC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216197
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216197
cover: https://bing.ee123.net/img/rand?artid=146216197
image: https://bing.ee123.net/img/rand?artid=146216197
img: https://bing.ee123.net/img/rand?artid=146216197
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     2.2.3 TCP—UDP-QUIC
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="223_TCPUDPQUIC_1">
     </a>
     2.2.3 TCP—UDP-QUIC
    </h2>
    <h3>
     <a id="1_TCP_3">
     </a>
     1. TCP如何做到可靠性传输
    </h3>
    <h4>
     <a id="1_ACK_4">
     </a>
     1. ACK机制
    </h4>
    <p>
     接收方在成功接收到数据后，会向发送方发送一个确认信号（ACK），告知发送方数据已正确接收。通过ACK机制，发送方可以确认数据是否成功到达接收方，从而决定是否需要重传。
    </p>
    <h4>
     <a id="2__7">
     </a>
     2. 重传机制
    </h4>
    <p>
     重传机制是TCP确保数据可靠传输的核心。当发送方未收到ACK或检测到数据丢失时，会触发重传。主要包括：
    </p>
    <ul>
     <li>
      ​
      <strong>
       超时重传
      </strong>
      ：发送方为每个数据段设置重传计时器（RTO），超时未收到ACK则重传。
     </li>
     <li>
      ​
      <strong>
       快速重传
      </strong>
      ：发送方收到3个重复ACK后，立即重传丢失的数据段，无需等待超时。
     </li>
    </ul>
    <h4>
     <a id="3__12">
     </a>
     3. 序号机制
    </h4>
    <p>
     TCP通过序号机制为每个数据段分配唯一的序列号（Sequence Number），接收方根据序号对数据段进行排序和重组。序号机制确保数据的有序性和完整性，避免数据丢失或乱序。
    </p>
    <h4>
     <a id="4__15">
     </a>
     4. 窗口机制
    </h4>
    <p>
     窗口机制用于控制发送方的数据发送速率，避免接收方缓冲区溢出。主要包括：
    </p>
    <ul>
     <li>
      ​
      <strong>
       接收窗口（RWND）​
      </strong>
      ：接收方告知发送方当前可接收的数据量。
     </li>
     <li>
      ​
      <strong>
       拥塞窗口（CWND）​
      </strong>
      ：发送方根据网络拥塞情况动态调整发送速率。
     </li>
     <li>
      ​
      <strong>
       滑动窗口
      </strong>
      ：发送方在窗口范围内连续发送数据，提高传输效率。
     </li>
    </ul>
    <h4>
     <a id="5__21">
     </a>
     5. 流量机制
    </h4>
    <p>
     流量机制通过控制数据发送速率，避免网络拥塞和接收方过载。主要包括：
    </p>
    <ul>
     <li>
      ​
      <strong>
       流量控制
      </strong>
      ：根据接收方的缓冲区大小动态调整发送速率。
     </li>
     <li>
      ​
      <strong>
       拥塞控制
      </strong>
      ：通过慢启动、拥塞避免等算法，动态调整发送速率，避免网络拥塞。
     </li>
    </ul>
    <h4>
     <a id="6__26">
     </a>
     6. 带宽机制
    </h4>
    <p>
     带宽机制用于优化网络资源利用率，确保数据传输的高效性。主要包括：
    </p>
    <ul>
     <li>
      ​
      <strong>
       带宽分配
      </strong>
      ：根据网络状况和优先级合理分配带宽。
     </li>
     <li>
      ​
      <strong>
       带宽限制
      </strong>
      ：通过流量整形和速率限制，避免带宽滥用。
     </li>
     <li>
      ​
      <strong>
       带宽监测
      </strong>
      ：实时监测网络带宽使用情况，动态调整传输策略。
     </li>
    </ul>
    <h3>
     <a id="2_tcpudp_32">
     </a>
     2. tcp和udp如何选择
    </h3>
    <ol>
     <li>
      <p>
       tcp 面向字节流
       <br/>
       TCP将数据视为连续的字节流，而不是独立的数据包。发送方和接收方之间建立连接后，数据以字节流的形式传输，接收方按顺序接收并重组数据。
       <br/>
       类似打电话
      </p>
     </li>
     <li>
      <p>
       udp 面向报文
       <br/>
       UDP将数据视为独立的数据报（报文），每个数据报都有明确的边界。发送方和接收方之间无需建立连接，数据报直接发送。
       <br/>
       类似发短信，每个信息之间是独立的
      </p>
     </li>
    </ol>
    <h4>
     <a id="1_tcpudp_41">
     </a>
     1. tcp和udp格式对比
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        ​
        <strong>
         特性
        </strong>
       </th>
       <th>
        ​
        <strong>
         TCP
        </strong>
       </th>
       <th>
        ​
        <strong>
         UDP
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ​
        <strong>
         头部长度
        </strong>
       </td>
       <td>
        20字节（不含选项）
       </td>
       <td>
        8字节
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         可靠性
        </strong>
       </td>
       <td>
        可靠传输（确认、重传、排序机制）
       </td>
       <td>
        不可靠传输（无确认、重传机制）
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         连接性
        </strong>
       </td>
       <td>
        面向连接（需三次握手建立连接）
       </td>
       <td>
        无连接（直接发送数据报）
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         数据边界
        </strong>
       </td>
       <td>
        无边界（面向字节流）
       </td>
       <td>
        有边界（面向报文）
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         控制位
        </strong>
       </td>
       <td>
        有（SYN、ACK、FIN等）
       </td>
       <td>
        无
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         流量控制
        </strong>
       </td>
       <td>
        有（窗口机制）
       </td>
       <td>
        无
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         拥塞控制
        </strong>
       </td>
       <td>
        有（慢启动、拥塞避免等）
       </td>
       <td>
        无
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         校验和
        </strong>
       </td>
       <td>
        强制
       </td>
       <td>
        可选
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        文件传输、网页浏览、电子邮件等
       </td>
       <td>
        视频流、语音通话、在线游戏等
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     可靠指的是可以正常收到而且是顺序收到，ARQ协议就是干这个的
    </p>
    <h4>
     <a id="2_ARQAutomatic_Repeat_reQuest_56">
     </a>
     2. ARQ协议（Automatic Repeat reQuest，自动重传请求）
    </h4>
    <p>
     ARQ协议通过
     <strong>
      确认（ACK）和重传机制
     </strong>
     ，确保数据在传输过程中不丢失、不重复、不乱序
    </p>
    <h5>
     <a id="1_ARQ_58">
     </a>
     1. ARQ协议的主要类型
    </h5>
    <p>
     （1）停等ARQ（Stop-and-Wait ARQ）​
     <br/>
     发送方每发送一个数据帧后，等待接收方的ACK。如果收到ACK，则发送下一个帧；如果超时未收到ACK，则重传当前帧
     <br/>
     （2）回退N帧ARQ（Go-Back-N ARQ）​
     <br/>
     发送方可以连续发送多个数据帧，无需等待ACK。如果某个帧丢失或损坏，发送方从该帧开始重传所有后续帧。
     <br/>
     （3）选择性重传ARQ（Selective Repeat ARQ）​
     <br/>
     发送方可以连续发送多个数据帧，接收方对每个帧单独确认。如果某个帧丢失或损坏，发送方仅重传该帧，而不影响其他帧。
    </p>
    <h5>
     <a id="2_ARQ_66">
     </a>
     2. ARQ协议的关键技术
    </h5>
    <ol>
     <li>
      <p>
       ​序号机制
       <br/>
       为每个数据帧分配唯一的序号，用于标识帧的顺序和检测丢失帧。
      </p>
     </li>
     <li>
      <p>
       ​超时机制
       <br/>
       发送方为每个帧设置超时计时器，超时未收到ACK则触发重传。
      </p>
     </li>
     <li>
      <p>
       ​滑动窗口
       <br/>
       通过滑动窗口控制发送方和接收方的缓冲区大小，优化数据传输效率。
      </p>
     </li>
    </ol>
    <h4>
     <a id="3RTTRTO_76">
     </a>
     3.RTT和RTO
    </h4>
    <p>
     RTO（Retransmission Timeout）​：重传超时时间，动态计算，基于RTT（Round-Trip Time，往返时间）。
     <br/>
     ​RTT测量：通过时间戳或ACK的到达时间计算RTT，并更新RTO。
    </p>
    <h4>
     <a id="4__80">
     </a>
     4. 流量控制
    </h4>
    <p>
     对发送方发送速率的控制，称之为流量控制（发的过快就放缓存，再发的多就TM丢了，大量的丢包会极大着浪费网络资源，要保持接收双方动态稳定）
    </p>
    <ol>
     <li>
      通信双方各有两个滑动窗口：
      <br/>
      ​接收窗口：用于接收数据。
      <br/>
      ​发送窗口（拥塞窗口）​：用于发送数据。
      <br/>
      接收窗口大小的通知称为窗口通告。
     </li>
     <li>
      ​接收窗口的动态调整
     </li>
    </ol>
    <p>
     接收窗口的大小不是固定的，而是根据某种算法动态调整，以适应网络环境和发送窗口的变化。
     <br/>
     3. ​接收窗口的优化
    </p>
    <p>
     接收窗口并非越大越好。当窗口达到一定值后，继续增大不会显著减少丢包率，反而会增加内存消耗。因此，接收窗口的大小需要根据网络环境和发送窗口动态调整。
     <br/>
     4. ​发送窗口与接收窗口的关系
    </p>
    <p>
     发送窗口和接收窗口不一定相等。接收方在发送确认报文时会告知发送方其接收窗口大小，发送方据此调整发送窗口。
     <br/>
     由于接收方在处理缓存区数据的同时发送确认报文，因此一般情况下，​接收窗口 ≥ 发送窗口。
    </p>
    <h4>
     <a id="5__100">
     </a>
     5. 拥塞控制
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/30f5bed3a1f04f9eac5e7a188885196b.png#pic_center"/>
    </p>
    <ol>
     <li>
      ​慢开始
     </li>
    </ol>
    <p>
     ​初始阶段：拥塞窗口（cwnd）从1开始，​指数增长​（每轮次翻倍）。
     <br/>
     ​触发条件：连接建立或检测到网络超时（超时视为严重拥塞）。
     <br/>
     ​阈值作用：初始慢开始阈值（ssthresh）决定何时切换至拥塞避免阶段
    </p>
    <ol start="2">
     <li>
      ​拥塞避免（Congestion Avoidance）​
     </li>
    </ol>
    <p>
     ​线性增长：当cwnd ≥ ssthresh时，进入“加法增大”阶段，每轮次cwnd加1。
     <br/>
     ​目标：避免因窗口过快膨胀引发网络拥塞。
    </p>
    <ol start="3">
     <li>
      ​快恢复（Fast Recovery）​
     </li>
    </ol>
    <p>
     ​触发条件：收到3个重复ACK​（轻度拥塞信号）。
     <br/>
     ​行为：
     <br/>
     ​TCP Reno：将cwnd减半（图中从24降至12），更新ssthresh为新值（12），并直接进入拥塞避免​（而非重新慢启动）。
     <br/>
     ​TCP Tahoe​（已废弃）：直接重置cwnd=1并重新慢开始，效率较低。
    </p>
    <h4>
     <a id="6_udp_123">
     </a>
     6. udp并发编程
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/621d480ca7e34eae94d50e9c6d4f2a6c.png#pic_center"/>
    </p>
    <h3>
     <a id="3_udpkcp_128">
     </a>
     3. udp如何可靠，kcp协议在那些方面有优势
    </h3>
    <h4>
     <a id="KCPTCP_131">
     </a>
     KCP能否比TCP有更高的带宽？
    </h4>
    <p>
     在网络通畅的情况下，KCP以10%-20%带宽浪费的代价，换取了比TCP快30%-40%的传输速度。
    </p>
    <h4>
     <a id="KCP_134">
     </a>
     KCP协议的优势
    </h4>
    <ul>
     <li>
      <p>
       ​
       <strong>
        流量不一定最多
       </strong>
       <br/>
       KCP的传输速率可能低于TCP，但延迟更低，适合实时性要求高的场景。
      </p>
     </li>
     <li>
      <p>
       ​
       <strong>
        RTO翻倍 vs 不翻倍
       </strong>
      </p>
      <ul>
       <li>
        TCP超时计算是RTO×2，连续丢三次包后RTO变为×8，非常保守。
       </li>
       <li>
        KCP在快速模式下RTO仅×1.5（实验证明1.5效果较好），显著提升传输速度。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        选择性重传 vs 全部重传
       </strong>
      </p>
      <ul>
       <li>
        TCP丢包时会重传从丢失包开始后的所有数据（Go-Back-N）。
       </li>
       <li>
        KCP采用选择性重传，仅重传真正丢失的数据包，减少冗余。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        快速重传
       </strong>
      </p>
      <ul>
       <li>
        使用快速重传时，无需等待RTO超时。
       </li>
       <li>
        示例：发送端发送1,2,3,4,5，收到ACK:1,3,4,5。当收到ACK3时，KCP知道2被跳过1次；收到ACK4时，知道2被跳过2次，立即重传2号包。
       </li>
       <li>
        参数：
        <code>
         fastresend = 2
        </code>
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        延迟ACK vs 非延迟ACK
       </strong>
      </p>
      <ul>
       <li>
        TCP为了充分利用带宽，延迟发送ACK，导致RTT时间计算偏大，延长丢包判断过程
       </li>
       <li>
        KCP的ACK延迟发送可调节，灵活性更高
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        UNA vs ACK+UNA
       </strong>
      </p>
      <ul>
       <li>
        ARQ模型有两种响应方式：UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到）。
       </li>
       <li>
        仅用UNA会导致全部重传，仅用ACK则增加网络负载
       </li>
       <li>
        KCP协议中，除单独的ACK包外，所有包都携带UNA信息，结合两者优势
        <br/>
        <strong>
         比如：
        </strong>
        <br/>
        发送端发送序列号1、2、3、4、5。
        <br/>
        接收端收到1、2、4、5，丢失3。
        <br/>
        接收端发送UNA=3（表示1、2已接收），并发送ACK=4、ACK=5（确认4、5已接收）。
        <br/>
        发送端根据UNA=3知道3丢失，立即重传3，而无需重传4、5。
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        非退让流控
       </strong>
      </p>
      <ul>
       <li>
        KCP正常模式与TCP一样使用公平退让法则，发送窗口大小由以下四要素决定：
        <ol>
         <li>
          发送缓存大小
         </li>
         <li>
          接收端剩余接收缓存大小
         </li>
         <li>
          丢包退让 (当检测到丢包时，减少发送窗口大小，避免进一步加剧网络拥塞。)
         </li>
         <li>
          慢启动
         </li>
        </ol>
       </li>
       <li>
        在传送及时性要求高的小数据场景中，可通过配置跳过后两步(​丢包退让和慢启动机制会降低发送速率，导致传输延迟增加)，仅用前两项控制发送频率。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     KCP通过牺牲少量带宽，显著提升了传输速度和实时性，特别适合高延迟、高丢包网络环境（如实时音视频、竞技类网游）。
    </p>
    <h4>
     <a id="1_kcp_177">
     </a>
     1. kcp使用
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/08b004f56c10478ea0b999d4fc751bfd.png#pic_center"/>
    </p>
    <h5>
     <a id="1__182">
     </a>
     1. 函数
    </h5>
    <ol>
     <li>
      ​**
      <code>
       kcp_create
      </code>
      **
     </li>
    </ol>
    <ul>
     <li>
      ​
      <strong>
       功能
      </strong>
      ：创建KCP对象。
     </li>
     <li>
      ​
      <strong>
       参数
      </strong>
      ：
      <ul>
       <li>
        <code>
         conv
        </code>
        ：会话ID，用于标识KCP连接。
       </li>
       <li>
        <code>
         user
        </code>
        ：用户自定义数据，通常为NULL。
       </li>
      </ul>
     </li>
     <li>
      ​
      <strong>
       返回值
      </strong>
      ：KCP对象指针。
     </li>
     <li>
      ​
      <strong>
       示例
      </strong>
      ：
      <pre><code class="prism language-c">ikcpcb <span class="token operator">*</span>kcp <span class="token operator">=</span> <span class="token function">ikcp_create</span><span class="token punctuation">(</span>conv<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
    <ol start="2">
     <li>
      ​
      <strong>
       kcp_update
      </strong>
      <br/>
      ​功能：更新KCP状态，触发内部定时任务（如超时重传、窗口更新等）。
      <br/>
      ​参数：
      <br/>
      kcp：KCP对象指针。
      <br/>
      current：当前时间戳（毫秒）。
      <br/>
      ​示例：
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token function">ikcp_update</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ol start="3">
     <li>
      ​
      <strong>
       kcp_send
      </strong>
      <br/>
      ​功能：发送数据。
      <br/>
      ​参数：
      <br/>
      kcp：KCP对象指针。
      <br/>
      buffer：待发送的数据缓冲区。
      <br/>
      len：数据长度。
      <br/>
      ​返回值：成功返回0，失败返回负值。
      <br/>
      ​示例：
     </li>
    </ol>
    <pre><code class="prism language-c++">int ret = ikcp_send(kcp, buffer, len);
</code></pre>
    <ol start="4">
     <li>
      ​
      <strong>
       kcp_input
      </strong>
      <br/>
      ​功能：接收数据并处理（如解析KCP协议头、更新ACK等）。
      <br/>
      ​参数：
      <br/>
      kcp：KCP对象指针。
      <br/>
      data：接收到的数据缓冲区。
      <br/>
      size：数据长度。
      <br/>
      ​返回值：成功返回0，失败返回负值。
      <br/>
      ​示例：
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">ikcp_input</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> data<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ol start="5">
     <li>
      ​
      <strong>
       kcp_recv
      </strong>
      <br/>
      ​功能：从KCP接收缓冲区中读取应用层数据。
      <br/>
      ​参数：
      <br/>
      kcp：KCP对象指针。
      <br/>
      buffer：接收数据的缓冲区。
      <br/>
      len：缓冲区长度。
      <br/>
      ​返回值：实际读取的数据长度。
      <br/>
      ​示例：
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">ikcp_recv</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h5>
     <a id="2_KCP_238">
     </a>
     2. KCP工作流程
    </h5>
    <ol>
     <li>
      ​初始化阶段
      <br/>
      调用kcp_create创建KCP对象。
      <br/>
      设置KCP参数（如窗口大小、超时时间等）。
     </li>
     <li>
      ​数据发送流程
      <br/>
      应用层调用kcp_send发送数据。
      <br/>
      KCP内部将数据分片，添加KCP协议头（24字节）。
      <br/>
      调用output回调函数发送数据包。
      <br/>
      定时调用kcp_update触发重传和窗口更新。
     </li>
     <li>
      ​数据接收流程
      <br/>
      网络层接收到数据包，调用kcp_input处理。
      <br/>
      KCP解析协议头，更新ACK和窗口状态。
      <br/>
      应用层调用kcp_recv读取数据。
     </li>
     <li>
      ​定时任务
      <br/>
      定期调用kcp_update，处理超时重传、窗口更新等任务。
     </li>
    </ol>
    <h5>
     <a id="3__KCP_254">
     </a>
     3. KCP示例代码
    </h5>
    <ol>
     <li>
      ​初始化KCP
     </li>
    </ol>
    <pre><code class="prism language-c">ikcpcb <span class="token operator">*</span>kcp <span class="token operator">=</span> <span class="token function">ikcp_create</span><span class="token punctuation">(</span>conv<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ikcp_wndsize</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置窗口大小</span>
<span class="token function">ikcp_nodelay</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启用快速模式</span>
</code></pre>
    <ol start="2">
     <li>
      ​发送数据
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">"Hello, KCP!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ikcp_send</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ol start="3">
     <li>
      ​接收数据
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">ikcp_recv</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Received: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="4">
     <li>
      ​定时更新
     </li>
    </ol>
    <pre><code class="prism language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">sleep_ms</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ikcp_update</span><span class="token punctuation">(</span>kcp<span class="token punctuation">,</span> <span class="token function">current_ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="5">
     <li>
      集成
     </li>
    </ol>
    <pre><code class="prism language-c++">#include "ikcp.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

// 回调函数：发送 KCP 数据包
int output(const char *buf, int len, ikcpcb *kcp, void *user) {
    int sockfd = *(int*)user;
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8888);
    inet_pton(AF_INET, "127.0.0.1", &amp;addr.sin_addr);
    sendto(sockfd, buf, len, 0, (struct sockaddr*)&amp;addr, sizeof(addr));
    return 0;
}

int main() {
    // 创建 UDP 套接字
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd &lt; 0) {
        perror("socket");
        exit(1);
    }

    // 初始化 KCP 对象
    ikcpcb *kcp = ikcp_create(0x11223344, &amp;sockfd);
    ikcp_wndsize(kcp, 128, 128); // 设置窗口大小
    ikcp_nodelay(kcp, 1, 10, 2, 1); // 启用快速模式
    ikcp_setoutput(kcp, output); // 设置回调函数

    // 发送数据
    char send_buffer[1024];
    int send_len = sprintf(send_buffer, "Hello, KCP!");
    ikcp_send(kcp, send_buffer, send_len);

    // 接收数据
    char recv_buffer[1024];
    while (1) {
        // 接收网络数据
        struct sockaddr_in addr;
        socklen_t addr_len = sizeof(addr);
        int recv_len = recvfrom(sockfd, recv_buffer, sizeof(recv_buffer), 0, (struct sockaddr*)&amp;addr, &amp;addr_len);
        if (recv_len &gt; 0) {
            // 处理 KCP 协议包
            ikcp_input(kcp, recv_buffer, recv_len);

            // 读取应用数据
            int len = ikcp_recv(kcp, recv_buffer, sizeof(recv_buffer));
            if (len &gt; 0) {
                printf("Received: %s\n", recv_buffer);
            }
        }

        // 定时更新 KCP 状态
        ikcp_update(kcp, current_ms());
        usleep(10000); // 10ms
    }

    // 释放 KCP 对象
    ikcp_release(kcp);
    close(sockfd);
    return 0;
}
</code></pre>
    <h3>
     <a id="4_QUIC_354">
     </a>
     4. QUIC
    </h3>
    <h4>
     <a id="1_QUIC_355">
     </a>
     1. QUIC实现可靠传输的核心机制
    </h4>
    <ol>
     <li>
      ​Packet Number严格递增
     </li>
    </ol>
    <p>
     每个数据包分配唯一且严格递增的序列号（Packet Number），即使重传数据包也会使用新序列号。
    </p>
    <ul>
     <li>
      ​优势：
      <br/>
      消除TCP重传歧义问题，精确计算RTT（往返时间），优化超时重传策略。
      <br/>
      支持乱序确认，避免因单个数据包丢失阻塞后续传输（解决队头阻塞）。
     </li>
    </ul>
    <ol start="2">
     <li>
      ​Frame Header设计
     </li>
    </ol>
    <p>
     每个数据包包含多个Frame，通过以下字段保证数据顺序和可靠性：
     <br/>
     ​Stream ID：标识不同的并发数据流（类似HTTP/2的Stream）。
     <br/>
     ​Offset：标记数据在流中的偏移量（类似TCP的序列号）。
     <br/>
     ​Length：数据长度。
    </p>
    <ul>
     <li>
      ​作用：通过Stream ID + Offset唯一标识数据内容，即使重传数据包的Packet Number不同，也能正确重组数据。
     </li>
    </ul>
    <ol start="3">
     <li>
      ​流量控制
     </li>
    </ol>
    <p>
     ​Stream级流量控制：每个Stream独立维护滑动窗口，互不影响。
     <br/>
     ​Connection级流量控制：限制所有Stream的总数据量，防止整体过载。
    </p>
    <ul>
     <li>
      ​实现方式：
      <br/>
      通过WINDOW_UPDATE帧动态调整窗口大小。
      <br/>
      通过BLOCKED帧通知发送方流量阻塞。
     </li>
    </ul>
    <ol start="4">
     <li>
      ​拥塞控制改进
     </li>
    </ol>
    <p>
     默认使用TCP的Cubic算法，同时支持BBR、PCC等算法。
    </p>
    <ul>
     <li>
      ​优势：
      <br/>
      在应用层实现，无需内核支持，灵活升级算法。
      <br/>
      可为不同应用定制拥塞策略（如视频流与文件传输使用不同算法）。
     </li>
    </ul>
    <h4>
     <a id="2_QUICTCP_383">
     </a>
     2. ​QUIC解决TCP的四大缺陷
    </h4>
    <ol>
     <li>
      ​协议升级困难
     </li>
    </ol>
    <p>
     TCP协议栈内置于操作系统，升级依赖内核更新；QUIC在应用层实现，通过更新浏览器或应用即可部署新特性。
     <br/>
     2. ​连接建立延迟
    </p>
    <p>
     ​1-RTT握手：QUIC将TLS 1.3集成到协议中，首次连接仅需1个RTT完成密钥协商和连接建立。
     <br/>
     ​0-RTT恢复：会话恢复时可直接发送数据，无需握手。
     <br/>
     3. ​队头阻塞问题
    </p>
    <p>
     ​Stream独立滑动窗口：每个HTTP请求（Stream）拥有独立窗口，某个Stream丢包不影响其他Stream。
     <br/>
     ​乱序确认：基于Packet Number和Offset，允许接收方乱序确认数据包。
     <br/>
     4. ​网络迁移需重建连接
    </p>
    <p>
     ​连接ID标识：QUIC通过连接ID（而非IP+端口）标识连接，网络切换（如4G转WiFi）时无需重建连接，实现无缝迁移。
    </p>
    <h4>
     <a id="3_QUICHTTP3_398">
     </a>
     3. ​QUIC与HTTP/3的关系
    </h4>
    <p>
     HTTP/3基于QUIC协议，将传输层从TCP替换为QUIC，彻底解决HTTP/2的TCP队头阻塞问题。
     <br/>
     QUIC在UDP报文头部与HTTP数据之间添加三层头部：
    </p>
    <ol>
     <li>
      ​Long/Short Packet Header：管理连接ID与数据包编号。
     </li>
     <li>
      ​QUIC Frame Header：标识Stream及数据偏移。
     </li>
     <li>
      ​HTTP/3帧：承载实际应用数据。
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35323432333439342f:61727469636c652f64657461696c732f313436323136313937" class_="artid" style="display:none">
 </p>
</div>


