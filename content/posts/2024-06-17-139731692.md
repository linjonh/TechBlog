---
layout: post
title: "MS1112é©±åŠ¨å¼€å‘iioæ¡†æ¶"
date: 2024-06-17T09:29:22+0800
description: "æœ¬æ–‡ç« æ˜¯ä»‹ç»iioæ¡†æ¶ï¼Œå¹¶åŸºäºä¹‹å‰ms1112çš„i2cé©±åŠ¨æ¡†æ¶è¿›è¡Œæ”¹å†™åŠæµ‹è¯•"
keywords: "ms1112é©±åŠ¨"
categories: ['Imx']
tags: ['é©±åŠ¨å¼€å‘', 'Ms', 'Iio']
artid: "139731692"
arturl: "https://blog.csdn.net/qq_44647100/article/details/139731692"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=139731692
    alt: "MS1112é©±åŠ¨å¼€å‘iioæ¡†æ¶"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=139731692
featuredImagePreview: https://bing.ee123.net/img/rand?artid=139731692
cover: https://bing.ee123.net/img/rand?artid=139731692
image: https://bing.ee123.net/img/rand?artid=139731692
img: https://bing.ee123.net/img/rand?artid=139731692
---



# MS1112é©±åŠ¨å¼€å‘ï¼ˆiioæ¡†æ¶ï¼‰



ä½œè€…ç®€ä»‹ï¼š ä¸€ä¸ªå¹³å‡¡è€Œä¹äºåˆ†äº«çš„å°æ¯”ç‰¹ï¼Œä¸­å—æ°‘æ—å¤§å­¦é€šä¿¡å·¥ç¨‹ä¸“ä¸šç ”ç©¶ç”Ÿåœ¨è¯»ï¼Œç ”ç©¶æ–¹å‘æ— çº¿è”é‚¦å­¦ä¹   
 æ“…é•¿é¢†åŸŸï¼šé©±åŠ¨å¼€å‘ï¼ŒåµŒå…¥å¼è½¯ä»¶å¼€å‘ï¼ŒBSPå¼€å‘  
 ä½œè€…ä¸»é¡µï¼š[ä¸€ä¸ªå¹³å‡¡è€Œä¹äºåˆ†äº«çš„å°æ¯”ç‰¹çš„ä¸ªäººä¸»é¡µ](https://blog.csdn.net/qq_44647100?type=blog)  
 æ–‡ç« æ”¶å½•ä¸“æ ï¼š[IMX8MP](https://blog.csdn.net/qq_44647100/category_12680974.html?spm=1001.2014.3001.5482),æœ¬ä¸“æ è®°å½•imx8mpå¼€å‘æ¿ï¼Œå­¦ä¹ å¼€å‘è¿‡ç¨‹ä¸­çš„é—®é¢˜åŠè§£å†³æ–¹æ³•è®°å½•  
 æ¬¢è¿å¤§å®¶ç‚¹èµ ğŸ‘ æ”¶è— â­ åŠ å…³æ³¨å“¦ï¼ğŸ’–ğŸ’–

## MS1112é©±åŠ¨å¼€å‘ï¼ˆiioæ¡†æ¶ï¼‰

ms1112é©±åŠ¨ä»£ç åŠæµ‹è¯•ç¨‹åºåœ¨[ms1112é©±åŠ¨](https://download.csdn.net/download/qq_44647100/89404828?spm=1001.2014.3001.5503)ï¼Œå¦‚æœ‰éœ€è¦è‡ªè¡Œä¸‹è½½

### 1.iioæ¡†æ¶ç®€ä»‹

â€‹ IIOå…¨ç§°æ˜¯IndustrialI/Oï¼Œç¿»è¯‘è¿‡æ¥å°±æ˜¯å·¥ä¸šI/Oï¼Œå¤§å®¶ä¸è¦çœ‹åˆ°â€œå·¥ä¸šâ€ä¸¤ä¸ªå­—å°±è§‰å¾—IIOæ˜¯åªç”¨äºå·¥ä¸šé¢†åŸŸçš„ã€‚å¤§å®¶ä¸€èˆ¬åœ¨æœç´¢IIOå­ç³»ç»Ÿçš„æ—¶å€™ï¼Œä¼šå‘ç°å¤§å¤šæ•°è®²çš„éƒ½æ˜¯ADCï¼Œè¿™æ˜¯å› ä¸ºIIOå°±æ˜¯ä¸ºADCç±»ä¼ æ„Ÿå™¨å‡†å¤‡çš„ï¼Œå½“ç„¶äº†DACä¹Ÿæ˜¯å¯ä»¥çš„ã€‚å¤§å®¶å¸¸ç”¨çš„é™€èºä»ªã€åŠ é€Ÿåº¦è®¡ã€ç”µå‹/ç”µæµæµ‹é‡èŠ¯ç‰‡ã€å…‰ç…§ä¼ æ„Ÿå™¨ã€å‹åŠ›ä¼ æ„Ÿå™¨ç­‰å†…éƒ¨éƒ½æ˜¯æœ‰ä¸ªADCï¼Œå†…éƒ¨ADCå°†åŸå§‹çš„æ¨¡æ‹Ÿæ•°æ®è½¬æ¢ä¸ºæ•°å­—é‡ï¼Œç„¶åé€šè¿‡å…¶ä»–çš„é€šä¿¡æ¥å£ï¼Œæ¯”å¦‚IICã€SPIç­‰ä¼ è¾“ç»™SOCã€‚  
 â€‹ å› æ­¤ï¼Œå½“ä½ ä½¿ç”¨çš„ä¼ æ„Ÿå™¨æœ¬è´¨æ˜¯ADCæˆ–DACå™¨ä»¶çš„æ—¶å€™ï¼Œå¯ä»¥ä¼˜å…ˆè€ƒè™‘ä½¿ç”¨IIOé©±åŠ¨æ¡†æ¶ã€‚

#### 1.1 iio_devç»“æ„ä½“

IIOå­ç³»ç»Ÿä½¿ç”¨ç»“æ„ä½“iio_devæ¥æè¿°ä¸€ä¸ªå…·ä½“IIOè®¾å¤‡ï¼Œæ­¤è®¾å¤‡ç»“æ„ä½“å®šä¹‰åœ¨include/linux/iio/iio.hæ–‡ä»¶ä¸­ï¼Œç»“æ„ä½“å†…å®¹å¦‚ä¸‹:

```
571 struct iio_dev {
572         int                             modes;
573         struct device                   dev;
574
575         struct iio_buffer               *buffer;
576         int                             scan_bytes;
577         struct mutex                    mlock;
578
579         const unsigned long             *available_scan_masks;
580         unsigned                        masklength;
581         const unsigned long             *active_scan_mask;
582         bool                            scan_timestamp;
583         struct iio_trigger              *trig;
584         struct iio_poll_func            *pollfunc;
585         struct iio_poll_func            *pollfunc_event;
586
587         struct iio_chan_spec const      *channels;
588         int                             num_channels;
589
590         const char                      *name;
591         const char                      *label;
592         const struct iio_info           *info;
593         const struct iio_buffer_setup_ops       *setup_ops;
594
595         void                            *priv;
596 };

```

æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹iio_devç»“æ„ä½“ä¸­å‡ ä¸ªæ¯”è¾ƒé‡è¦çš„æˆå‘˜å˜é‡ï¼š

ç¬¬571è¡Œï¼Œmodesä¸ºè®¾å¤‡æ”¯æŒçš„æ¨¡å¼ï¼Œå¯é€‰æ‹©çš„æ¨¡å¼å¦‚è¡¨æ‰€ç¤ºï¼š

| æ¨¡å¼ | æè¿° |
| --- | --- |
| INDIO_DRECT_MODE | æä¾›sysfsæ¥å£ |
| INDIO_BUFFER_TRIGGERED | æ”¯æŒç¡¬ä»¶ç¼“å†²è§¦å‘ |
| INDIO_BUFFER_SOFTWARE | æ”¯æŒè½¯ä»¶ç¼“å†²è§¦å‘ |
| INDIO_BUFFER_HARDWARE | æ”¯æŒç¡¬ä»¶ç¼“å†²åŒº |

ç¬¬575è¡Œï¼Œbufferä¸ºç¼“å†²åŒº  
 ç¬¬576è¡Œï¼Œscan_bytesä¸ºæ•è·åˆ°ï¼Œå¹¶ä¸”æä¾›ç»™ç¼“å†²åŒºçš„å­—èŠ‚æ•°ã€‚  
 ç¬¬579è¡Œï¼Œavailable_scan_masksä¸ºå¯é€‰çš„æ‰«æä½æ©ç ï¼Œä½¿ç”¨è§¦å‘ç¼“å†²åŒºçš„æ—¶å€™å¯ä»¥é€šè¿‡è®¾ç½®æ©ç æ¥ç¡®å®šä½¿èƒ½å“ªäº›é€šé“ï¼Œä½¿èƒ½ä»¥åçš„é€šé“ä¼šå°†æ•è·åˆ°çš„æ•°æ®å‘é€åˆ°IIOç¼“å†²åŒºã€‚  
 ç¬¬581è¡Œï¼Œactive_scan_maskä¸ºç¼“å†²åŒºå·²ç»å¼€å¯çš„é€šé“æ©ç ã€‚åªæœ‰è¿™äº›ä½¿èƒ½äº†çš„é€šé“æ•°æ®æ‰èƒ½è¢«å‘é€åˆ°ç¼“å†²åŒºã€‚  
 ç¬¬582è¡Œï¼Œscan_timestampä¸ºæ‰«ææ—¶é—´æˆ³ï¼Œå¦‚æœä½¿èƒ½ä»¥åä¼šå°†æ•è·æ—¶é—´æˆ³æ”¾åˆ°ç¼“å†²åŒºé‡Œé¢ã€‚  
 ç¬¬583è¡Œï¼Œtrigä¸ºIIOè®¾å¤‡å½“å‰è§¦å‘å™¨ï¼Œå½“ä½¿ç”¨ç¼“å†²æ¨¡å¼çš„æ—¶å€™ã€‚  
 ç¬¬584è¡Œï¼Œpollfuncä¸ºä¸€ä¸ªå‡½æ•°ï¼Œåœ¨æ¥æ”¶åˆ°çš„è§¦å‘å™¨ä¸Šè¿è¡Œã€‚  
 ç¬¬587è¡Œï¼Œchannelsä¸ºIIOè®¾å¤‡é€šé“ï¼Œä¸ºiio_chan_specç»“æ„ä½“ç±»å‹ï¼Œç¨åä¼šè¯¦ç»†è®²è§£IIOé€šé“ã€‚  
 ç¬¬588è¡Œï¼Œnum_channelsä¸ºIIOè®¾å¤‡çš„é€šé“æ•°ã€‚  
 ç¬¬590è¡Œï¼Œnameä¸ºIIOè®¾å¤‡åå­—ã€‚  
 ç¬¬592è¡Œï¼Œinfoä¸ºiio_infoç»“æ„ä½“ç±»å‹ï¼Œè¿™ä¸ªç»“æ„ä½“é‡Œé¢æœ‰å¾ˆå¤šå‡½æ•°ï¼Œéœ€è¦é©±åŠ¨å¼€å‘äººå‘˜ç¼–å†™ï¼Œéå¸¸é‡è¦!æˆ‘ä»¬ä»ç”¨æˆ·ç©ºé—´è¯»å–IIOè®¾å¤‡å†…éƒ¨æ•°æ®ï¼Œæœ€ç»ˆè°ƒç”¨çš„å°±æ˜¯iio_infoé‡Œé¢çš„å‡½æ•°ã€‚ç¨åä¼šè¯¦ç»†è®²è§£iio_infoç»“æ„ä½“ã€‚  
 ç¬¬593è¡Œï¼Œsetup_opsä¸º iio_buffer_setup_ops ç»“æ„ä½“ç±»å‹ï¼Œå†…å®¹å¦‚ä¸‹:

```
530 struct iio_buffer_setup_ops {
531         int (*preenable)(struct iio_dev *);
532         int (*postenable)(struct iio_dev *);
533         int (*predisable)(struct iio_dev *);
534         int (*postdisable)(struct iio_dev *);
535         bool (*validate_scan_mask)(struct iio_dev *indio_dev,
536                                    const unsigned long *scan_mask);
537 };

```

å¯ä»¥çœ‹å‡ºiio_buffer_setup_ops é‡Œé¢éƒ½æ˜¯ä¸€äº›å›è°ƒå‡½æ•°ï¼Œåœ¨ä½¿èƒ½æˆ–ç¦ç”¨ç¼“å†²åŒºçš„æ—¶å€™ä¼šè°ƒç”¨è¿™äº›å‡½æ•°ã€‚å¦‚æœæœªæŒ‡å®šçš„è¯å°±é»˜è®¤ä½¿ç”¨iio_triggered_buffer_setup_ops

#### 1.2 iio_infoç»“æ„ä½“

iio_devæœ‰ä¸ªæˆå‘˜å˜é‡: infoï¼Œä¸ºiio_infoç»“æ„ä½“æŒ‡é’ˆå˜é‡ï¼Œè¿™ä¸ªæ˜¯æˆ‘ä»¬åœ¨ç¼–å†™IIOé©±åŠ¨çš„æ—¶å€™éœ€è¦ç€é‡å»å®ç°çš„ï¼Œå› ä¸ºç”¨æˆ·ç©ºé—´å¯¹è®¾å¤‡çš„å…·ä½“æ“ä½œæœ€ç»ˆéƒ½ä¼šåæ˜ åˆ°iio_infoé‡Œé¢ã€‚iio_infoç»“æ„ä½“å®šä¹‰åœ¨ include/linux/iio/liio.hä¸­ï¼Œç»“æ„ä½“å®šä¹‰å¦‚ä¸‹(æœ‰çœç•¥):

```
445 struct iio_info {
446         const struct attribute_group    *event_attrs;
447         const struct attribute_group    *attrs;
448
449         int (*read_raw)(struct iio_dev *indio_dev,
450                         struct iio_chan_spec const *chan,
451                         int *val,
452                         int *val2,
453                         long mask);
454
455         int (*read_raw_multi)(struct iio_dev *indio_dev,
456                         struct iio_chan_spec const *chan,
457                         int max_len,
458                         int *vals,
459                         int *val_len,
460                         long mask);
461
462         int (*read_avail)(struct iio_dev *indio_dev,
463                           struct iio_chan_spec const *chan,
464                           const int **vals,
465                           int *type,
466                           int *length,
467                           long mask);
468
469         int (*write_raw)(struct iio_dev *indio_dev,
470                          struct iio_chan_spec const *chan,
471                          int val,
472                          int val2,
473                          long mask);
474
......
}

```

ç¬¬447è¡Œï¼Œattrsæ˜¯é€šç”¨çš„è®¾å¤‡å±æ€§ã€‚  
 ç¬¬449å’Œ469è¡Œï¼Œåˆ†åˆ«ä¸ºread_rawå’Œ write_rawå‡½æ•°ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°å°±æ˜¯æœ€ç»ˆè¯»å†™è®¾å¤‡å†…éƒ¨æ•°æ®çš„æ“ä½œå‡½æ•°ï¼Œéœ€è¦ç¨‹åºç¼–å†™äººå‘˜å»å®ç°çš„ã€‚æ¯”å¦‚åº”ç”¨è¯»å–ä¸€ä¸ªms1112çš„åŸå§‹æ•°æ®ï¼Œé‚£ä¹ˆæœ€ç»ˆå®Œæˆå·¥ä½œçš„å°±æ˜¯read_rawå‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦åœ¨read_rawå‡½æ•°é‡Œé¢å®ç°å¯¹ms1112èŠ¯ç‰‡çš„è¯»å–æ“ä½œã€‚åŒç†ï¼Œwrite_rawæ˜¯åº”ç”¨ç¨‹åºå‘ms1112èŠ¯ç‰‡å†™æ•°æ®ï¼Œä¸€èˆ¬ç”¨äºé…ç½®èŠ¯ç‰‡ï¼Œæ¯”å¦‚é‡ç¨‹ã€æ•°æ®é€Ÿç‡ç­‰ã€‚è¿™ä¸¤ä¸ªå‡½æ•°çš„å‚æ•°éƒ½æ˜¯ä¸€æ ·çš„ï¼Œæˆ‘ä»¬ä¾æ¬¡æ¥çœ‹ä¸€ä¸‹:  
 indio_dev:éœ€è¦è¯»å†™çš„IIOè®¾å¤‡ã€‚  
 chan:éœ€è¦è¯»å–çš„é€šé“ã€‚  
 valï¼Œval2:å¯¹äºread_rawå‡½æ•°æ¥è¯´ valå’Œ val2è¿™ä¸¤ä¸ªå°±æ˜¯åº”ç”¨ç¨‹åºä»å†…æ ¸ç©ºé—´è¯»å–åˆ°æ•°æ®ï¼Œä¸€èˆ¬å°±æ˜¯ä¼ æ„Ÿå™¨æŒ‡å®šé€šé“å€¼ï¼Œæˆ–è€…ä¼ æ„Ÿå™¨çš„é‡ç¨‹ã€åˆ†è¾¨ç‡ç­‰ã€‚å¯¹äº write_rawæ¥è¯´å°±æ˜¯åº”ç”¨ç¨‹åºå‘è®¾å¤‡å†™å…¥çš„æ•°æ®ã€‚valå’Œ val2å…±åŒç»„æˆå…·ä½“å€¼ï¼Œvalæ˜¯æ•´æ•°éƒ¨åˆ†ï¼Œval2æ˜¯å°æ•°éƒ¨åˆ†ã€‚ä½†æ˜¯val2ä¹Ÿæ˜¯å¯¹å…·ä½“çš„å°æ•°éƒ¨åˆ†æ‰©å¤§Nå€åçš„æ•´æ•°å€¼ï¼Œå› ä¸ºä¸èƒ½ç›´æ¥ä»å†…æ ¸å‘åº”ç”¨ç¨‹åºè¿”å›ä¸€ä¸ªå°æ•°å€¼ã€‚æ¯”å¦‚ç°åœ¨æœ‰ä¸ªå€¼ä¸º1.00236ï¼Œé‚£ä¹ˆvalå°±æ˜¯1ï¼Œvla2ç†è®ºä¸Šæ¥è®²æ˜¯0.00236ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å¯¹0.00236æ‰©å¤§Nå€ï¼Œä½¿å…¶å˜ä¸ºæ•´æ•°ï¼Œè¿™é‡Œæˆ‘ä»¬æ‰©å¤§ 1000000å€ï¼Œé‚£ä¹ˆval2å°±æ˜¯2360ã€‚å› æ­¤val=1ï¼Œval2=2360ã€‚æ‰©å¤§çš„å€æ•°æˆ‘ä»¬ä¸èƒ½éšä¾¿è®¾ç½®ï¼Œè€Œæ˜¯è¦ä½¿ç”¨Linuxå®šä¹‰çš„å€æ•°ï¼ŒLinux å†…æ ¸é‡Œé¢å®šä¹‰çš„æ•°æ®æ‰©å¤§å€æ•°ï¼Œæˆ–è€…è¯´æ•°æ®ç»„åˆå½¢å¼å¦‚è¡¨æ‰€ç¤º:

| ç»„åˆå® | æè¿° |
| --- | --- |
| IIO_VAL_INT | æ•´æ•°å€¼ï¼Œæ²¡æœ‰å°æ•°ã€‚æ¯”å¦‚5000ï¼Œé‚£ä¹ˆå°±æ˜¯val=5000ï¼Œä¸éœ€è¦è®¾ç½®val2 |
| IIO_VAL_INT_PLUS_MICRO | å°æ•°éƒ¨åˆ†æ‰©å¤§1000000å€ï¼Œæ¯”å¦‚1.00236ï¼Œæ­¤æ—¶val=1ï¼Œval2=2360ã€‚ |
| IIO_VAL_INT_PLUS_NANO | å°æ•°éƒ¨åˆ†æ‰©å¤§1000000000å€ï¼ŒåŒæ ·æ˜¯1.00236ï¼Œæ­¤æ—¶val=1ï¼Œval2=2360000ã€‚ |
| IIO_VAL_INT_PLUS_MICRO_DB | dBæ•°æ®ï¼Œå’Œ IIO_VAL_INT_PLUS_MICROæ•°æ®å½¢å¼ä¸€æ ·ï¼Œåªæ˜¯åœ¨åé¢æ·»åŠ  dbã€‚ |
| IIO_VAL_INT_MULITIPLE | å¤šä¸ªæ•´æ•°å€¼ï¼Œæ¯”å¦‚ä¸€æ¬¡è¦ä¼ å›6ä¸ªæ•´æ•°å€¼ï¼Œé‚£ä¹ˆval å’Œval2å°±ä¸å¤Ÿç”¨äº†.æ­¤å®ä¸»è¦ç”¨äºiio_infoçš„read_raw_multiå‡½æ•°ã€‚ |
| IIO_VAL_FRACTIONAL | åˆ†æ•°å€¼ï¼Œä¹Ÿå°±æ˜¯val/val2ã€‚æ¯”å¦‚val=1ï¼Œ val2=4ï¼Œé‚£ä¹ˆå®é™…å€¼å°±æ˜¯1/4ã€‚ |
| IIO_VAL_FRACTIONAL_LOG2 | å€¼ä¸ºval>>val2,ä¹Ÿå°±æ˜¯valå³ç§»val2ä½ã€‚æ¯”å¦‚ val=25600ï¼Œval2=4ï¼Œé‚£ä¹ˆçœŸæ­£çš„å€¼å°±æ˜¯ 25600å³ç§»4ä½ï¹25600>>4=1600. |

â€‹ mask:æ©ç ï¼Œç”¨äºæŒ‡å®šæˆ‘ä»¬è¯»å–çš„æ˜¯ä»€ä¹ˆæ•°æ®ï¼Œæˆ‘ä»¬åªæœ‰è¯»å‡ºåŸå§‹å€¼ä»¥åŠå¯¹åº”çš„åˆ†è¾¨ç‡(é‡ç¨‹)ï¼Œæ‰èƒ½è®¡ç®—å‡ºçœŸå®çš„ç”µå‹å€¼ã€‚æ­¤æ—¶å°±æœ‰ä¸¤ç§æ•°æ®å€¼:ä¼ æ„Ÿå™¨åŸå§‹å€¼ã€åˆ†è¾¨ç‡ã€‚Linux å†…æ ¸ä½¿ç”¨IIO_CHAN_INFO_RAWå’ŒIIO_CHAN_INFO_SCALEè¿™ä¸¤ä¸ªå®æ¥è¡¨ç¤ºåŸå§‹å€¼ä»¥åŠåˆ†è¾¨ç‡ï¼Œè¿™ä¸¤ä¸ªå®å°±æ˜¯æ©ç ã€‚è‡³äºæ¯ä¸ªé€šé“å¯ä»¥é‡‡ç”¨å“ªå‡ ç§æ©ç ï¼Œè¿™ä¸ªåœ¨æˆ‘ä»¬åˆå§‹åŒ–é€šé“çš„æ—¶å€™éœ€è¦é©±åŠ¨ç¼–å†™äººå‘˜è®¾ç½®å¥½ã€‚æ©ç æœ‰å¾ˆå¤šç§ï¼Œç¨åè®²è§£IIOé€šé“çš„æ—¶å€™è¯¦ç»†è®²è§£!  
 â€‹ ç¬¬462è¡Œçš„read_availè¿™ç§å‡½æ•°æŒ‡é’ˆé€šå¸¸ç”¨äºåµŒå…¥å¼ç³»ç»Ÿä¸­ï¼Œç‰¹åˆ«æ˜¯åœ¨é©±åŠ¨ç¨‹åºæˆ–æ•°æ®é‡‡é›†æ¨¡å—ä¸­ã€‚å®ƒå…è®¸ç³»ç»Ÿåœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°é€‰æ‹©æˆ–è°ƒç”¨ä¸åŒçš„è¯»å–å¯ç”¨æ•°æ®çš„å‡½æ•°ï¼Œå…·ä½“æ“ä½œå¯èƒ½æ¶‰åŠä»ä¼ æ„Ÿå™¨æˆ–å…¶ä»–æ•°æ®æºä¸­è·å–æ•°æ®ï¼Œå¹¶å°†æ•°æ®ç±»å‹ã€é•¿åº¦ç­‰ä¿¡æ¯è¿”å›ç»™è°ƒç”¨è€…ã€‚

#### 1.3 iio_chan_specç»“æ„ä½“

â€‹ iioçš„æ ¸å¿ƒå°±æ˜¯é€šé“ï¼Œä¸€ä¸ªä¼ æ„Ÿå™¨å¯èƒ½æœ‰å¤šè·¯æ•°æ®ï¼Œæ¯”å¦‚ä¸€ä¸ªms1112ADCèŠ¯ç‰‡æ”¯æŒ4è·¯æ•°æ®é‡‡é›†ï¼Œé‚£ä¹ˆå®ƒå°±æœ‰4ä¸ªé€šé“ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/24e6014782ff81205d3710076db621f1.png#pic_center)

â€‹ Linuxå†…æ ¸ä½¿ç”¨iio_chan_specç»“æ„ä½“æ¥æè¿°é€šé“ï¼Œå®šä¹‰åœ¨include/linux/iio/iio.hæ–‡ä»¶ä¸­ï¼Œå†…å®¹å¦‚ä¸‹ï¼š

```
238 struct iio_chan_spec {
239         enum iio_chan_type      type;
240         int                     channel;
241         int                     channel2;
242         unsigned long           address;
243         int                     scan_index;
244         struct {
245                 char    sign;
246                 u8      realbits;
247                 u8      storagebits;
248                 u8      shift;
249                 u8      repeat;
250                 enum iio_endian endianness;
251         } scan_type;
252         long                    info_mask_separate;
253         long                    info_mask_separate_available;
254         long                    info_mask_shared_by_type;
255         long                    info_mask_shared_by_type_available;
256         long                    info_mask_shared_by_dir;
257         long                    info_mask_shared_by_dir_available;
258         long                    info_mask_shared_by_all;
259         long                    info_mask_shared_by_all_available;
260         const struct iio_event_spec *event_spec;
261         unsigned int            num_event_specs;
262         const struct iio_chan_spec_ext_info *ext_info;
263         const char              *extend_name;
264         const char              *datasheet_name;
265         unsigned                modified:1;
266         unsigned                indexed:1;
267         unsigned                output:1;
268         unsigned                differential:1;
269 };

```

â€‹ æ¥çœ‹ä¸€ä¸‹iio_chan_specç»“æ„ä½“ä¸­ä¸€äº›æ¯”è¾ƒé‡è¦çš„æˆå‘˜å˜é‡:  
 ç¬¬239è¡Œï¼Œtypeä¸ºé€šé“ç±»å‹,iio_chan_typeæ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œåˆ—ä¸¾å‡ºäº†å¯ä»¥é€‰æ‹©çš„é€šé“ç±»å‹ï¼Œå®šä¹‰åœ¨include/uapi/linux/iio/types.hæ–‡ä»¶é‡Œé¢ï¼Œå†…å®¹å¦‚ä¸‹:

```
enum iio_chan_type {
        IIO_VOLTAGE,                                //ç”µå‹
        IIO_CURRENT,								//ç”µæµ
        IIO_POWER,									//åŠŸç‡
        IIO_ACCEL,									//åŠ é€Ÿåº¦
        IIO_ANGL_VEL,								//è§’é€Ÿåº¦
        IIO_MAGN,									//ç£åœºå¼ºåº¦
        IIO_LIGHT,									//å…‰å¼ºåº¦
        IIO_INTENSITY,								//å¼ºåº¦
        IIO_PROXIMITY,								//æ¥è¿‘åº¦
        IIO_TEMP,									//æ¸©åº¦
        IIO_INCLI,									//å€¾æ–œåº¦
        IIO_ROT,									//æ—‹è½¬
        IIO_ANGL,									//è§’åº¦
        IIO_TIMESTAMP,								//æ—¶é—´æˆ³
        IIO_CAPACITANCE,							//ç”µå®¹
        IIO_ALTVOLTAGE,								//å¤‡ç”¨ç”µå‹
        IIO_CCT,									//è‰²æ¸©
        IIO_PRESSURE,								//å‹åŠ›
        IIO_HUMIDITYRELATIVE,						//ç›¸å¯¹æ¹¿åº¦
        IIO_ACTIVITY,								//æ´»åŠ¨çŠ¶æ€
        IIO_STEPS,									//æ­¥æ•°
        IIO_ENERGY,									//èƒ½é‡
        IIO_DISTANCE,								//è·ç¦»
        IIO_VELOCITY,								//é€Ÿåº¦
        IIO_CONCENTRATION,							//æµ“åº¦
        IIO_RESISTANCE,								//ç”µé˜»
        IIO_PH,										//pH å€¼
        IIO_UVINDEX,								//ç´«å¤–çº¿æŒ‡æ•°
        IIO_ELECTRICALCONDUCTIVITY,					//ç”µå¯¼ç‡	
        IIO_COUNT,									//è®¡æ•°
        IIO_INDEX,									//ç´¢å¼•
        IIO_GRAVITY,								//é‡åŠ›
        IIO_POSITIONRELATIVE,						//ç›¸å¯¹ä½ç½®
        IIO_PHASE,									//ç›¸ä½
        IIO_MASSCONCENTRATION,						//è´¨é‡æµ“åº¦
};


```

å¯ä»¥çœ‹å‡ºï¼Œç›®å‰Linuxå†…æ ¸æ”¯æŒçš„ä¼ æ„Ÿå™¨ç±»å‹éå¸¸ä¸°å¯Œï¼Œè€Œä¸”æ”¯æŒç±»å‹ä¹Ÿä¼šä¸æ–­çš„å¢åŠ ã€‚ms1112æ˜¯ADCï¼Œé‚£å°±æ˜¯IIO_VOLTAGEç±»å‹ã€‚  
 ç»§ç»­æ¥çœ‹iio_chan_specç»“æ„ä½“ï¼Œç¬¬266è¡Œï¼Œå½“æˆå‘˜å˜é‡indexed ä¸º1æ—¶å€™,channelä¸ºé€šé“ç´¢å¼•ã€‚  
 ç¬¬265è¡Œï¼Œå½“æˆå‘˜å˜é‡modifiedä¸º1çš„æ—¶å€™ï¼Œchannel2ä¸ºé€šé“ä¿®é¥°ç¬¦ã€‚é€šé“ä¿®é¥°ç¬¦ä¸»è¦æ˜¯å½±å“sysfsä¸‹çš„é€šé“æ–‡ä»¶åå­—ï¼Œåé¢æˆ‘ä»¬ä¼šè®²è§£sysfsä¸‹é€šé“æ–‡ä»¶åå­—ç»„æˆå½¢å¼ã€‚  
 ç¬¬242è¡Œçš„addressæˆå‘˜å˜é‡ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰ï¼Œä½†æ˜¯ä¸€èˆ¬ä¼šè®¾ç½®ä¸ºæ­¤é€šé“å¯¹åº”çš„èŠ¯ç‰‡æ•°æ®å¯„å­˜å™¨åœ°å€ã€‚address ä¹Ÿå¯ä»¥ç”¨ä½œå…¶ä»–åŠŸèƒ½ï¼Œè‡ªè¡Œé€‰æ‹©ï¼Œä¹Ÿå¯ä»¥ä¸ä½¿ç”¨addressï¼Œä¸€åˆ‡ä»¥å®é™…æƒ…å†µä¸ºå‡†ã€‚  
 ç¬¬243è¡Œï¼Œå½“ä½¿ç”¨è§¦å‘ç¼“å†²åŒºçš„æ—¶å€™ï¼Œscan_indexæ˜¯æ‰«æç´¢å¼•ã€‚  
 ç¬¬244~251ï¼Œscan_typeæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæè¿°äº†æ‰«ææ•°æ®åœ¨ç¼“å†²åŒºä¸­çš„å­˜å‚¨æ ¼å¼ã€‚æˆ‘ä»¬ä¾æ¬¡æ¥çœ‹ä¸€ä¸‹scan_typeå„ä¸ªæˆå‘˜å˜é‡çš„æ¶µä¹‰:  
 scan_type.sign:å¦‚æœä¸ºâ€˜uâ€™è¡¨ç¤ºæ•°æ®ä¸ºæ— ç¬¦å·ç±»å‹ï¼Œä¸ºâ€˜sâ€™çš„è¯ä¸ºæœ‰ç¬¦å·ç±»å‹ã€‚  
 scan_type.realbits:æ•°æ®çœŸå®çš„æœ‰æ•ˆä½æ•°ï¼Œæ¯”å¦‚å¾ˆå¤šä¼ æ„Ÿå™¨è¯´çš„10ä½ADCï¼Œå…¶çœŸå®æœ‰æ•ˆæ•°æ®å°±æ˜¯10ä½ã€‚  
 scan_type.storagebits:å­˜å‚¨ä½æ•°ï¼Œæœ‰æ•ˆä½æ•°+å¡«å……ä½ã€‚æ¯”å¦‚æœ‰äº›ä¼ æ„Ÿå™¨ADCæ˜¯12ä½çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å­˜å‚¨çš„è¯è‚¯å®šè¦ç”¨åˆ°2ä¸ªå­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯16ä½ï¼Œè¿™16ä½å°±æ˜¯å­˜å‚¨ä½æ•°ã€‚  
 scan_type.shift:å³ç§»ä½æ•°ï¼Œä¹Ÿå°±æ˜¯å­˜å‚¨ä½æ•°å’Œæœ‰æ•ˆä½æ•°ä¸ä¸€è‡´çš„æ—¶å€™ï¼Œéœ€è¦å³ç§»çš„ä½æ•°ï¼Œè¿™ä¸ªå‚æ•°ä¸æ€»æ˜¯éœ€è¦ï¼Œä¸€åˆ‡ä»¥å®é™…èŠ¯ç‰‡çš„æ•°æ®æ‰‹å†Œä½æ•°ã€‚  
 scan_type.repeat:å®é™…æˆ–å­˜å‚¨ä½çš„é‡å¤æ•°é‡ã€‚  
 scan_type.endianness:æ•°æ®çš„å¤§å°ç«¯æ¨¡å¼ï¼Œå¯è®¾ç½®ä¸ºIIO_CPUã€IIO_BE(å¤§ç«¯)æˆ–IIO_LE(å°ç«¯)ã€‚  
 ç¬¬252è¡Œï¼Œinfo_mask_separateæ ‡è®°æŸäº›å±æ€§ä¸“å±äºæ­¤é€šé“ï¼Œinclude/linux/iio/types.hæ–‡ä»¶ä¸­çš„iio chan_info_enumæšä¸¾ç±»å‹æè¿°äº†å¯é€‰çš„å±æ€§å€¼ã€‚  
 ç¬¬254è¡Œï¼Œinfo_mask_shared_by_typeæ ‡è®°å¯¼å‡ºçš„ä¿¡æ¯ç”±ç›¸åŒç±»å‹çš„é€šé“å…±äº«ã€‚ä¹Ÿå°±æ˜¯iio_chan_spec.typeæˆå‘˜å˜é‡ç›¸åŒçš„é€šé“ã€‚  
 ç¬¬256è¡Œï¼Œinfo_mask_shared_by_diræ ‡è®°æŸäº›å¯¼å‡ºçš„ä¿¡æ¯ç”±ç›¸åŒæ–¹å‘çš„é€šé“å…±äº«ã€‚  
 ç¬¬258è¡Œï¼Œinfo_mask_shared_by_allè¡¨è®¾è®¡æŸäº›ä¿¡æ¯æ‰€æœ‰çš„é€šé“å…±äº«ï¼Œæ— è®ºè¿™äº›é€šé“çš„ç±»å‹ã€æ–¹å‘å¦‚ä½•ï¼Œå…¨éƒ¨å…±äº«ã€‚  
 ç¬¬265è¡Œï¼Œmodifiedä¸º1çš„æ—¶å€™ï¼Œchannel2ä¸ºé€šé“ä¿®é¥°ç¬¦ã€‚  
 ç¬¬266è¡Œï¼Œindexedä¸º1çš„æ—¶å€™ï¼Œchannelä¸ºé€šé“ç´¢å¼•ã€‚  
 ç¬¬267è¡Œï¼Œoutputè¡¨ç¤ºä¸ºè¾“å‡ºé€šé“ã€‚  
 ç¬¬268è¡Œï¼Œdifferentialè¡¨ç¤ºä¸ºå·®åˆ†é€šé“ã€‚

### 2. ç¨‹åºç¼–å†™

#### 2.1 é©±åŠ¨ç¨‹åºç¼–å†™

ä¸»è¦ç»“æ„ä½“ï¼š

```
static const struct iio_info ms1112_info = {
    .read_raw = ms1112_read_raw,
    .write_raw = ms1112_write_raw,
    .read_avail = ms1112_read_avail,
};

```

```
struct ms1112_data {
        struct ms1112_channel_data channel_data[MS1112_CHANNELS];
        struct ms1112_thresh_data thresh_data[MS1112_CHANNELS];
        const struct ms1112_chip_data *chip;
        struct mutex lock;
        void *private_data;     /* ç§æœ‰æ•°æ® */
        //int16_t value;                /* adcæ•°æ® */
        struct i2c_client *client;
};

```

ä¸»è¦å‡½æ•°ï¼š

```
static int ms1112_get_adc_result(struct ms1112_data *data, int chan, int *val)
{
        int ret, pga, dr , mode;
        unsigned int  mask, cfg;
        ret = 0;

        if (chan < 0 || chan >= MS1112_CHANNELS)
                return -EINVAL;

        mode = data->channel_data[chan].mode;
        pga = data->channel_data[chan].pga;
        dr = data->channel_data[chan].data_rate;
        mask = MS1112_CFG_MUX_MASK | MS1112_CFG_PGA_MASK |
                MS1112_CFG_DR_MASK | MS1112_CFG_MOD_MASK | MS1112_SINGLESHOT << 7;
        cfg = chan << MS1112_CFG_MUX_SHIFT | pga << MS1112_CFG_PGA_SHIFT |
                dr << MS1112_CFG_DR_SHIFT | mode << MS1112_CFG_MOD_SHIFT | MS1112_SINGLESHOT << 7;

        printk("mask = %u\n", mask);
        printk("cfg = %u\n", cfg);

        cfg = (cfg & mask);

#if 0
        ms1112_write_reg(data, MS1112_CFG_REG, MS1112_DEFAULT_CONFIG);
#else
        ms1112_write_reg(data, MS1112_CFG_REG, cfg);
#endif

        ret = ms1112_readdata(data,val);
        if(ret<0)
        {
                printk("Failed to read data!\n");
        }

        return ret;
}

```

```
static int ms1112_read_avail(struct iio_dev *indio_dev,
                              struct iio_chan_spec const *chan,
                              const int **vals, int *type, int *length,
                              long mask)
{
        struct ms1112_data *data = iio_priv(indio_dev);

        if (chan->type != IIO_VOLTAGE)
                return -EINVAL;

        switch (mask) {
        case IIO_CHAN_INFO_SCALE:
                *type = IIO_VAL_FRACTIONAL_LOG2;
                *vals =  data->chip->scale;
                *length = data->chip->scale_len;
                return IIO_AVAIL_LIST;
        case IIO_CHAN_INFO_SAMP_FREQ:
                *type = IIO_VAL_INT;
                *vals = data->chip->data_rate;
                *length = data->chip->data_rate_len;
                return IIO_AVAIL_LIST;
        default:
                return -EINVAL;
        }
}

```

```
static int ms1112_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val, int *val2, long mask)
{
        int ret, idx;
        struct ms1112_data *data = iio_priv(indio_dev);

        mutex_lock(&data->lock);
        switch (mask) {
        case IIO_CHAN_INFO_RAW:

                ret = iio_device_claim_direct_mode(indio_dev);
                if (ret)
                        break;

                ret = ms1112_get_adc_result(data, chan->address, val);
                if (ret < 0) {
                        goto release_direct;
                }

                *val = sign_extend32(*val >> chan->scan_type.shift,
                                     chan->scan_type.realbits - 1);


                ret = IIO_VAL_INT;
release_direct:
                iio_device_release_direct_mode(indio_dev);
                break;

        case IIO_CHAN_INFO_SCALE:
                idx = data->channel_data[chan->address].pga;
                *val = ms1112_fullscale_range[idx];
                *val2 = chan->scan_type.realbits - 1;
                ret = IIO_VAL_FRACTIONAL_LOG2;
                break;
        case IIO_CHAN_INFO_SAMP_FREQ:
                idx = data->channel_data[chan->address].data_rate;
                *val = data->chip->data_rate[idx];
                ret = IIO_VAL_INT;
                break;
        default:
                ret = -EINVAL;
                break;
        }
        mutex_unlock(&data->lock);

        return ret;
}

```

```
static int ms1112_write_raw(struct iio_dev *indio_dev,
                             struct iio_chan_spec const *chan, int val,
                             int val2, long mask)
{
        struct ms1112_data *data = iio_priv(indio_dev);
        int ret;

        mutex_lock(&data->lock);
        switch (mask) {
        case IIO_CHAN_INFO_SCALE:
                ret = ms1112_set_scale(data, chan, val, val2);
                break;
        case IIO_CHAN_INFO_SAMP_FREQ:
                ret = ms1112_set_data_rate(data, chan->address, val);
                break;
        default:
                ret = -EINVAL;
                break;
        }
        mutex_unlock(&data->lock);

        return ret;
}

```

```
static int ms1112_probe(struct i2c_client *client,const struct i2c_device_id *id)
{
    struct iio_dev *indio_dev;
    const struct ms1112_chip_data *chip;
    struct ms1112_data *data;
    int ret;
    int i;

    chip = device_get_match_data(&client->dev);
    if (!chip)
        chip = (const struct ms1112_chip_data *)id->driver_data;
    if (!chip)
        return dev_err_probe(&client->dev, -EINVAL, "Unknown chip\n");

    indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*indio_dev));
    if (!indio_dev)
        return -ENOMEM;

    data = iio_priv(indio_dev);
    i2c_set_clientdata(client, indio_dev);

    mutex_init(&data->lock);

    indio_dev->name = MS1112_DRV_NAME;
    indio_dev->info = chip->info;
    indio_dev->modes = INDIO_DIRECT_MODE;
    indio_dev->channels = chip->channels;
    indio_dev->num_channels = chip->num_channels;
    data->chip = chip;
    data->client = client;

    for (i = 0; i < MS1112_CHANNELS; i++) {
        int realbits = indio_dev->channels[i].scan_type.realbits;

        data->thresh_data[i].low_thresh = -1 << (realbits - 1);
        data->thresh_data[i].high_thresh = (1 << (realbits - 1)) - 1;
    }

    /* we need to keep this ABI the same as used by hwmon ADS1015 driver */
    ms1112_get_channels_config(client);

    ret = iio_device_register(indio_dev);
    printk("ret = %d\n",ret);
    if (ret)
        dev_err(&client->dev, "Failed to register IIO device\n");
    return ret;
}

```

#### 2.2 æµ‹è¯•ç¨‹åº

```
#include <sys/time.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>

/* å­—ç¬¦ä¸²è½¬æ•°å­—ï¼Œå°†æµ®ç‚¹å°æ•°å­—ç¬¦ä¸²è½¬æ¢ä¸ºæµ®ç‚¹æ•°æ•°å€¼ */
#define SENSOR_FLOAT_DATA_GET(ret, index, str, member)\
        ret = file_data_read(file_path[index], str);\
        dev->member = atof(str);\

/* å­—ç¬¦ä¸²è½¬æ•°å­—ï¼Œå°†æ•´æ•°å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°æ•°å€¼ */
#define SENSOR_INT_DATA_GET(ret, index, str, member)\
        ret = file_data_read(file_path[index], str);\
        dev->member = atoi(str);\

/* adc iioæ¡†æ¶å¯¹åº”çš„æ–‡ä»¶è·¯å¾„ */
static char *file_path[] = {
        "/sys/bus/iio/devices/iio:device0/in_voltage1_scale",
        "/sys/bus/iio/devices/iio:device0/in_voltage1_raw",
};

/* æ–‡ä»¶è·¯å¾„ç´¢å¼•ï¼Œè¦å’Œfile_pathé‡Œé¢çš„æ–‡ä»¶é¡ºåºå¯¹åº” */
enum path_index {
        IN_VOLTAGE_SCALE = 0,
        IN_VOLTAGE_RAW,
};

/*
 * ADCæ•°æ®è®¾å¤‡ç»“æ„ä½“
 */
struct adc_dev{
        int raw;
        float scale;
        float act;
};

struct adc_dev ms1112adc;

/*
 * @description : è¯»å–æŒ‡å®šæ–‡ä»¶å†…å®¹
 * @param â€“ filename : è¦è¯»å–çš„æ–‡ä»¶è·¯å¾„
 * @param - str : è¯»å–åˆ°çš„æ–‡ä»¶å­—ç¬¦ä¸²
 *  @return : 0 æˆåŠŸ;å…¶ä»– å¤±è´¥
 */
static int file_data_read(char *filename, char *str)
{
        int ret = 0;
        FILE *data_stream;

        data_stream = fopen(filename, "r"); /* åªè¯»æ‰“å¼€ */
        if(data_stream == NULL) {
                printf("can't open file %s\r\n", filename);
                return -1;
        }

        ret = fscanf(data_stream, "%s", str);
        if(!ret) {
                printf("file read error!\r\n");
        } else if(ret == EOF) {
                /* è¯»åˆ°æ–‡ä»¶æœ«å°¾çš„è¯å°†æ–‡ä»¶æŒ‡é’ˆé‡æ–°è°ƒæ•´åˆ°æ–‡ä»¶å¤´ */
                fseek(data_stream, 0, SEEK_SET);
        }
        fclose(data_stream); /* å…³é—­æ–‡ä»¶ */
        return 0;
}

/*
 *  @description : è·å–ADCæ•°æ®
 *  @param - dev : è®¾å¤‡ç»“æ„ä½“
 *  @return : 0 æˆåŠŸ;å…¶ä»– å¤±è´¥
 */
static int adc_read(struct adc_dev *dev)
{
        int ret = 0;
        char str[50];

        SENSOR_FLOAT_DATA_GET(ret, IN_VOLTAGE_SCALE, str, scale);
        SENSOR_INT_DATA_GET(ret, IN_VOLTAGE_RAW, str, raw);

        /* è½¬æ¢å¾—åˆ°å®é™…ç”µå‹å€¼mV */
        dev->act = (dev->scale * dev->raw)/1000.f;
        return ret;
}

/*
 *  @description : mainä¸»ç¨‹åº
 *  @param â€“ argc : argvæ•°ç»„å…ƒç´ ä¸ªæ•°
 *  @param - argv : å…·ä½“å‚æ•°
 *  @return : 0 æˆåŠŸ;å…¶ä»– å¤±è´¥
 */
int main(int argc, char *argv[])
{
        int ret = 0;

        if (argc != 1) {
                printf("Error Usage!\r\n");
                return -1;
        }

        while (1) {
                ret = adc_read(&ms1112adc);
                if(ret == 0) { /* æ•°æ®è¯»å–æˆåŠŸ */ \
                        printf("ADCåŸå§‹å€¼ï¼š%dï¼Œç”µå‹å€¼ï¼š%.3fV\r\n", ms1112adc.raw, ms1112adc.act);
                }
                usleep(100000); /*100ms */
        }
        return 0;
}

```

### 3. å®éªŒæµ‹è¯•

åŠ è½½é©±åŠ¨åå¯ä»¥çœ‹åˆ°åœ¨å¼€å‘æ¿çš„/sys/bus/iio/devicesä¸‹æœ‰iio:device0è®¾å¤‡ï¼Œè¿™ä¸ªè®¾å¤‡æ­£å¼æˆ‘ä»¬ms1112ADCèŠ¯ç‰‡çš„sysfsæ–‡ä»¶ä¿¡æ¯ï¼Œè¿›å…¥è¯¥ç›®å½•ï¼Œå¯ä»¥æ˜¾ç¤ºè¯¥èŠ¯ç‰‡çš„ç›®å½•ä¿¡æ¯

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/01d661bff5bda4b62bf7ba029c926480.png#pic_center)

è§£é‡Šå¦‚ä¸‹ï¼š  
 in_voltage*_raw:å¯¹åº”è¯¥é€šé“é‡‡æ ·çš„adcåŸå§‹å€¼

in_voltage*_sampling_frequency:å¯¹åº”é€šé“çš„é‡‡æ ·é¢‘ç‡

in_voltage*_scale:ç”¨äºå­˜æ”¾å¯¹åº”é€šé“è¾“å…¥ç”µå‹æ¯”ä¾‹å› å­

ä¸¾ä¸ªä¾‹å­æˆ‘ä»¬`cat in_voltage0_scale`æ˜¾ç¤º0.062500000ï¼Œé‚£è¿™ä¸ªå€¼æ˜¯å¦‚ä½•ç®—å‡ºçš„å‘¢

å…¶å®æˆ‘ä»¬ä¸éš¾å‘ç°ï¼Œ

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/4ba91e810b9db74f909b523434656549.png#pic_center)

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/664b56dcc172992e2b7c9a1b4af76d7d.png#pic_center)

æˆ‘ä»¬çš„ç»“æœå¯„å­˜å™¨ä¸€å…±16ä½ï¼Œæœ€é«˜ä½ä¸ºç¬¦å·ä½ï¼Œå› æ­¤ç»“æœå¯„å­˜å™¨çš„adcé‡‡æ ·å€¼èŒƒå›´ä¸º-215~215,å³-32768-32767ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/22b4c899660fb0bed1aebf978d1fadad.png#pic_center)

æˆ‘ä»¬åœ¨IIO_CHAN_INFO_SCALEæ©ç æƒ…å†µä¸‹ï¼Œè®¾ç½®çš„ç»„åˆå®ä¸ºIIO_VAL_FRACTIONAL_LOG2ï¼Œå€¼ä¸ºval>>val2,ä¹Ÿå°±æ˜¯valå³ç§»val2ä½ã€‚å‡è®¾æ»¡é‡ç¨‹ï¼Œåˆ™valå€¼ä¸º2048ï¼Œval2ä¸º15ï¼Œ2048/(2^15)=0.0625ã€‚åˆšå¥½ç­‰äºin_voltage0_scaleçš„å€¼ã€‚

è¿™é‡Œæˆ‘ä»¬æµ‹è¯•voltage1é€šé“ï¼Œvoltage1ä¸ºAIN1,AIN1æ¥MIKRO-BUS,æˆ‘ä»¬åªéœ€æ¥ä¸€ä¸ªçƒŸé›¾ä¼ æ„Ÿå™¨ï¼Œå³å¯æµ‹è¯•

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/b0eabab906c38a4b7d850cc76e10e300.png#pic_center)

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/a2aeb654bdf89f1563fe9f3903414166.png#pic_center)

çƒŸé›¾ä¼ æ„Ÿå™¨è¿æ¥ï¼š  
 ![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/b114dc839c3d366ba9862a00eb8b00ac.jpeg#pic_center)

è¾“å…¥`insmod ms1112.ko`åŠ è½½é©±åŠ¨ï¼Œ`./adcAPP`è¿è¡Œæµ‹è¯•ç¨‹åº

æˆ‘ä»¬å¯ä»¥ç‚¹ç‡ƒçº¸å¼ ï¼Œè¿›è¡Œæµ‹è¯•

ç‚¹ç‡ƒçº¸å¼ å‰ï¼š  
 ![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/2df1ea163a19f8a2bde8fc661e2a0acb.png#pic_center)

ç‚¹ç‡ƒçº¸å¼ åï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/blog_migrate/656908529815e7a0bfc458e7a4f4b08c.png#pic_center)

æˆ‘ä»¬å‘ç°ç‚¹ç‡ƒåç”µå‹å€¼é™ä½ã€‚



