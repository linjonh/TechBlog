---
layout: post
title: "语法笔记-分析题解语法-二分-unordered_map与vectorpair-快速数组leetocde-1146"
date: 2025-03-11 23:49:04 +0800
description: "核心思路：建立 unordered_map<int, vector<pair<int, int>>> history;  令key为下标 vector存放不同快照引索的值，详看下文的输出"
keywords: "（语法笔记 分析题解语法 二分 “unordered_map与vector＜pair＜＞＞“ 快速数组）leetocde 1146"
categories: ['未分类']
tags: ['算法', '前端', 'C']
artid: "146191908"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146191908
    alt: "语法笔记-分析题解语法-二分-unordered_map与vectorpair-快速数组leetocde-1146"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146191908
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146191908
cover: https://bing.ee123.net/img/rand?artid=146191908
image: https://bing.ee123.net/img/rand?artid=146191908
img: https://bing.ee123.net/img/rand?artid=146191908
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     （语法笔记 分析题解语法 二分 “unordered_map与vector＜pair＜＞＞“ 快速数组）leetocde 1146
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" height="273" src="https://i-blog.csdnimg.cn/direct/6c203737186b4f5a8ced4cbb196ae33c.png" width="357"/>
    </p>
    <p>
     <strong>
      *注：代码和题解思路来源于灵茶山艾府，因为我之前未接触过vector&lt;pair&lt;&gt;&gt;与map的联合使用才写的笔记  链接：
     </strong>
     <a class="link-info" href="https://leetcode.cn/problems/snapshot-array/solutions/2756291/ji-lu-xiu-gai-li-shi-ha-xi-biao-er-fen-c-b1sh" rel="nofollow" title="灵茶山艾府题解">
      灵茶山艾府题解
     </a>
    </p>
    <p>
     <strong>
      核心思路：建立
     </strong>
     unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; history;  令key为下标 vector存放不同快照引索的值，详看下文的输出
    </p>
    <p>
    </p>
    <p>
     unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; history;
    </p>
    <p>
     键：int
    </p>
    <p>
     值：vector&lt;pair&lt;int, int&gt;&gt;
    </p>
    <p>
     history[0] 会访问 history 中键为 0 所对应的 std::vector&lt;std::pair&lt;int, int&gt;&gt;。如果该键不存在，会自动创建一个空的 vector。
    </p>
    <p>
     <br/>
     <br/>
     // 正确访问方式
     <br/>
     if (!history[0].empty()) {
     <!-- -->
     <br/>
     int firstValue = history[0][0].first;  10
     <br/>
     int secondValue = history[0][0].second;  20
     <br/>
     }
    </p>
    <p>
     <br/>
     在代码里，使用 history[0].emplace_back(10, 20); 向 history 中键为 0 对应的 vector 里"插入"了一个 std::pair&lt;int, int&gt; 对象，其值为 (10, 20)。
    </p>
    <p>
     emplace_back(10, 20) 会在这个 vector 的末尾直接构造一个 std::pair&lt;int, int&gt; 对象，这个对象的第一个元素是 10，第二个元素是 20。
    </p>
    <p>
     history[0].emplace_back(10, 20);
     <br/>
     history[0].emplace_back(30, 40);
     <br/>
     history[1].emplace_back(50, 60);
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       unordered_map数组的状态
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       key=index是下标题目说的下标
      </strong>
     </span>
     <br/>
     Key: 0
     <br/>
     (10, 20)
     <span style="color:#fe2c24">
      <strong>
       history[key][0]  history[index][0].first
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       --10快照索引
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       history[index][0].second--
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       20
      </strong>
     </span>
     <br/>
     (30, 40)
     <span style="color:#fe2c24">
      <strong>
       history[key][0]
      </strong>
     </span>
     <br/>
     Key: 1
     <br/>
     (50, 60)
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     代码分析：
    </p>
    <p>
     int j = ranges::lower_bound(h, pair(snap_id + 1, 0)) - h.begin() - 1;
     <br/>
     中 pair(snap_id + 1, 0)
     <br/>
     假设 h 中有如下元素：
     <br/>
     std::vector&lt;std::pair&lt;int, int&gt;&gt; h = { {10, 20}, {30, 40}, {50, 60} };
    </p>
    <p>
     若 snap_id 为 20，那么 std::pair(snap_id + 1, 0) 就是 std::pair(21, 0)。
     <br/>
     std::ranges::lower_bound 算法会依据 std::pair 的第一个元素进行比较，找到第一个大于等于 21 的元素，也就是 (30, 40)。
     <br/>
     在这个过程中，std::pair 的第二个元素 0 并不影响查找结果，它只是占位，保证 std::pair 类型的完整性。
    </p>
    <pre><code class="language-cpp">class SnapshotArray {
   unordered_map&lt;int,vector&lt;pair&lt;int, int&gt;&gt;&gt; history; 
    int c_snap_id=0;
public:
    SnapshotArray(int length) {
    }
    
    void set(int index, int val) {
        history[index].emplace_back(c_snap_id,val);
    }
    
    int snap() {
        return c_snap_id++;
    }
    
    int get(int index, int snap_id) {
        auto &amp;h=history[index];
        int j=ranges::lower_bound(h,pair(snap_id+1,0))-h.begin()-1;
        return j&gt;=0?h[j].second:0;
    }
};

/**
 * Your SnapshotArray object will be instantiated and called as such:
 * SnapshotArray* obj = new SnapshotArray(length);
 * obj-&gt;set(index,val);
 * int param_2 = obj-&gt;snap();
 * int param_3 = obj-&gt;get(index,snap_id);
 */</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430335f38373134303732352f:61727469636c652f64657461696c732f313436313931393038" class_="artid" style="display:none">
 </p>
</div>


