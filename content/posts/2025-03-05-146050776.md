---
layout: post
title: "rabbitmq版本升级并部署高可用"
date: 2025-03-05 19:14:32 +0800
description: "Logrotate下载地址https://centos.pkgs.org/7/centos-x86_64/logrotate-3.8.6-19.el7.x86_64.rpm.html。安装rpm时增加参数–nodeps --force：rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm --nodeps --force。rpm -e --nodeps $(rpm -qa|grep erlang)  //如安装了，则进行卸载。"
keywords: "rabbitmq版本升级并部署高可用"
categories: ['未分类']
tags: ['高可用', '集群', 'Rabbitmq']
artid: "146050776"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146050776
    alt: "rabbitmq版本升级并部署高可用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146050776
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146050776
cover: https://bing.ee123.net/img/rand?artid=146050776
image: https://bing.ee123.net/img/rand?artid=146050776
img: https://bing.ee123.net/img/rand?artid=146050776
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     rabbitmq版本升级并部署高可用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <strong>
      RabbitMQ版本升级
     </strong>
    </h2>
    <h3>
     先检查是否已经安装rabbitmq
    </h3>
    <p>
     rpm -qa|grep rabbitmq|wc -l    //如果结果是0，表示没有安装
    </p>
    <p>
     rpm -e --nodeps $(rpm -qa|grep rabbitmq)  //如安装了，则进行卸载
    </p>
    <h3>
     先检查是否已经安装erlang
    </h3>
    <p>
     rpm -qa|grep erlang|wc -l    //如果结果是0，表示没有安装
    </p>
    <p>
     rpm -e --nodeps $(rpm -qa|grep erlang)  //如安装了，则进行卸载
    </p>
    <h3>
     准备升级后的安装包
    </h3>
    <ul>
     <li>
      去https://dl.bintray.com/rabbitmq/rpm/下载需要rabbitmq包
     </li>
     <li>
      去https://github.com/rabbitmq/erlang-rpm/releases下载对应所需要的erlang包
     </li>
     <li>
      由于rabbitmq需要依赖socat所以需要去此网站https://centos.pkgs.org/查找对应系统的对应版本下载
     </li>
     <li>
      rabbitmq还依赖logrotate，查看下是否安装了，如没安装重复第3步
     </li>
    </ul>
    <p>
     Logrotate下载地址https://centos.pkgs.org/7/centos-x86_64/logrotate-3.8.6-19.el7.x86_64.rpm.html
    </p>
    <pre><code class="language-bash">rpm -qa | grep logrotate</code></pre>
    <h3>
     安装对应包
    </h3>
    <pre><code class="language-bash">rpm -ivh erlang-23.3.4.18-1.el7.x86_64.rpm

####检查是否安装成功
erl
#输入 erl 并用 halt() . 函数退出
rpm -ivh socat-1.7.3.2-2.el7.x86_64.rpm

rpm -ivh rabbitmq-server-3.8.16-1.el7.noarch.rpm</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <h4>
       安装erlang遇到的问题
      </h4>
     </li>
    </ul>
    <p>
     1.错误：依赖检测失败：
    </p>
    <p>
     libsystemd.so.0()(64bit) 被 erlang-21.3.8.9-1.el7.x86_64 需要
    </p>
    <p>
     方案一
    </p>
    <p>
     1.1下载依赖包，网址https://pkgs.org/，搜索libcrypto.so.10，下载对应版本的安装包
    </p>
    <p>
     1.2下载地址如下
    </p>
    <p>
     https://centos.pkgs.org/7/centos-x86_64/openssl-libs-1.0.2k-19.el7.x86_64.rpm.html#:~:text=http%3A//mirror.centos.org/centos/7/os/x86_64/Packages/openssl%2Dlibs%2D1.0.2k%2D19.el7.x86_64.rpm
    </p>
    <p>
     1.3安装命令
    </p>
    <p>
     rpm -ivh openssl-libs-1.0.2k-19.el7.x86_64.rpm
    </p>
    <p>
     安装失败则加参数--force进行强制安装
    </p>
    <p>
     rpm -ivh openssl-libs-1.0.2k-19.el7.x86_64.rpm --force
    </p>
    <p>
     方案二
    </p>
    <p>
     在命令后面添加--nodeps --force参数。该命令的作用是，不再分析包之间的依赖关系而直接安装
    </p>
    <p>
     rpm -ivh erlang-23.3.4.11-1.el7.x86_64.rpm --nodeps --force
    </p>
    <p>
     然后手动安装依赖环境
    </p>
    <p>
     安装socat遇到的错误
    </p>
    <p>
     错误：依赖检测失败：
    </p>
    <p>
     libreadline.so.6()(64bit) 被 socat-1.7.3.2-2.el7.x86_64 需要
    </p>
    <p>
     安装rpm时增加参数–nodeps --force：rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm --nodeps --force
    </p>
    <h4>
     安装rabbitmq遇到的问题
    </h4>
    <p>
     错误1：
    </p>
    <p>
     错误：依赖检测失败：
    </p>
    <p>
     Socat被rabbitmq-server-3.8.16-l.el7.noarch需要
    </p>
    <p>
     方案：安装socat依赖
    </p>
    <p>
     命令：rpm -ivh socat-1.7.3.2-2.el7.x86_64.rpm
    </p>
    <ul>
     <li>
      <p>
       启动rabbitmq
      </p>
     </li>
    </ul>
    <p>
     service rabbitmq-server start//启动
    </p>
    <p>
     service rabbitmq-server stop//停止
    </p>
    <p>
     service rabbitmq-server restart//重启
    </p>
    <ul>
     <li>
      <p>
       启动管理界面
      </p>
     </li>
    </ul>
    <p>
     rabbitmq-plugins enable rabbitmq_management
    </p>
    <ul>
     <li>
      <p>
       1
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      RabbitMQ配置
     </strong>
    </h3>
    <p>
     新启动的mq还不可以远程访问，guest也只能本地访问所以需要一些配置
    </p>
    <ul>
     <li>
      <p>
       添加用户并设置密码
      </p>
     </li>
    </ul>
    <pre><code class="language-bash">rabbitmqctl add_user  super super</code></pre>
    <p>
     添加权限（使admin用户对虚拟主机“/” 具有所有权限）:
    </p>
    <pre><code class="language-bash">rabbitmqctl set_permissions -p “/” super “.*” “.*” “.*”</code></pre>
    <ul>
     <li>
      <p>
       修改用户角色（加入administrator用户组）
      </p>
     </li>
    </ul>
    <p>
     rabbitmqctl set_user_tags super administrator
    </p>
    <p>
     rabbitmqctl set_user_tags {username} {tag ...}
    </p>
    <p>
     至此就可以远程访问了
     <br/>
     4. 管理界面访问地址为 ip:15672(端口号)
    </p>
    <p>
     进入管理界面查看端口号情况
    </p>
    <p>
     <img src="https://i-blog.csdnimg.cn/direct/ff42bbc694304778b49d8f86b880ed97.png"/>
    </p>
    <p>
     注：工程相关配置文件使用的是amqp协议，使用的端口号是5672。
    </p>
    <h3>
     <strong>
      常用命令
     </strong>
    </h3>
    <h4>
     应用的开启关闭
    </h4>
    <pre><code class="language-bash">service rabbitmq-server start//启动

service rabbitmq-server stop//停止

service rabbitmq-server restart//重启</code></pre>
    <h4>
     集群的开启关闭
    </h4>
    <pre><code class="language-bash">rabbitmqctl stop_app //仅关闭应用，不关闭节点

rabbitmqctl start_app //开启应用

rabbitmq -server -detached //启动节点和应用

rabbitmqctl stop //关闭节点和应用</code></pre>
    <p>
    </p>
    <h4>
     插件管理
    </h4>
    <pre><code class="language-bash">rabbitmq-plugins enable  xxx //开启某个插件

rabbitmq-plugins disable xxx //关闭某个插件

rabbitmq-plugins list //插件列表

rabbitmq-plugins set xxx xxx //启用一个或多个插件，禁用其余插件</code></pre>
    <p>
     注意：重启服务器后生效。
    </p>
    <h4>
     用户管理
    </h4>
    <pre><code class="language-bash">rabbitmqctl add_user username pwd //新建用户

rabbitmqctl delete_user username //删除用户

rabbitmqctl list_users //查看用户

rabbitmqctl change_passwor change_password {username} {newpassword} //改密码

rabbitmqctl set_user_tags {username} {tag ...} //设置用户角色 Tag可以为 administrator,monitoring, management</code></pre>
    <h4>
     防火墙
    </h4>
    <pre><code class="language-bash">#### rabbitmq普通用户不能开放防火墙，使用root提前开放5672，15672端口

firewall-cmd --zone=public --add-port=5672/tcp --permanent

firewall-cmd --zone=public --add-port=15672/tcp --permanent

firewall-cmd --reload</code></pre>
    <h2>
     <strong>
      Rabbitmq集群
     </strong>
    </h2>
    <h3>
     <strong>
      修改三台主机名称
     </strong>
    </h3>
    <p>
     注意：需要先设置linux机器别名称
    </p>
    <pre><code class="language-bash">hostnamectl set-hostname 机器别名 --static
systemctl stop rabbitmq-server          #（先停 止mq）

vim /etc/hosts</code></pre>
    <blockquote>
     <p>
      127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
     </p>
     <p>
      ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
     </p>
     <p>
      192.168.200.108 node1
     </p>
     <p>
      192.168.200.109 node2
     </p>
     <p>
      192.168.200.102 node3
     </p>
    </blockquote>
    <h3>
     <strong>
      共享Erlang Cookie
     </strong>
    </h3>
    <p>
     需要将所有机器的.erlang.cookie文件与集群主节点进行同步，同步前需要关闭所有机器的rabbitmq服务
    </p>
    <p>
     # 关闭rabbitmq服务 systemctl stop rabbitmq-server
    </p>
    <p>
     [root@node1 ~]# more /var/lib/rabbitmq/.erlang.cookie
    </p>
    <p>
     PZIJZCVFEXCZCCXPMZFE
    </p>
    <p>
     [root@node2 ~]# more /var/lib/rabbitmq/.erlang.cookie
    </p>
    <p>
     GQJUECIAZXPIYQFBASUT
    </p>
    <p>
     #对比两台主机cookie文件并不一致，集群必须保证一致性#
    </p>
    <p>
     chmod 600 /var/lib/rabbitmq/.erlang.cookie
    </p>
    <h3>
     <strong>
      启动mq服务和erlang
     </strong>
    </h3>
    <p>
     在3台节点上分别都执行命令
    </p>
    <p>
     rabbitmq-server -detached       （3台该命令可以重启mq和erlang）
    </p>
    <p>
     systemctl start rabbitmq-server     （3台启动mq）
    </p>
    <h3>
     <strong>
      集群搭建
     </strong>
     <strong>
     </strong>
     <strong>
     </strong>
     <strong>
     </strong>
     <strong>
     </strong>
     <strong>
     </strong>
    </h3>
    <p>
     以node1为主节点，其余的node2和node3加入主节点
    </p>
    <p>
     # 1.停止服务
     <br/>
     rabbitmqctl stop_app
     <br/>
     # 2.重置状态
     <br/>
     rabbitmqctl reset
     <br/>
     # 3.节点加入, 在一个node加入cluster之前，必须先停止该node的rabbitmq应用，即先执行stop_app
     <br/>
     # node2加入node1, node3加入node2
     <br/>
     rabbitmqctl join_cluster --ram rabbit@node1 //加入到磁盘节点
     <br/>
     # 4.启动服务
     <br/>
     rabbitmqctl start_app
    </p>
    <p>
     #此时一个普通集群就搭建起来了，在任意一个节点查看集群状态
    </p>
    <p>
     rabbitmqctl cluster_status
    </p>
    <p>
     默认的 cluster_name 名字为 rabbit@rabbit1，如果你想进行修改，可以使用以下命令：
    </p>
    <p>
     rabbitmqctl set_cluster_name rabbitmq_cluster
    </p>
    <h3>
     <strong>
      开启镜像集群
     </strong>
    </h3>
    <p>
     以上部署的这种集群，是无法在各个节点之间保存数据的，数据只会保存在接受到消息的节点上当 ram 的节点挂了之后 数据会丢失；这里我们为所有队列开启镜像配置，高可用策略。
    </p>
    <pre><code class="language-bash">####表示开启HA模式 适用于所有的队列

rabbitmqctl set_policy ha-all "^" '{"ha-mode":"all"}'</code></pre>
    <p>
    </p>
    <h3>
     <strong>
      创建集群账号
     </strong>
    </h3>
    <p>
    </p>
    <pre><code class="language-bash">[root@node1 ~]# rabbitmqctl add_user admin 123
 Adding user "admin" ...
 [root@node1 ~]#  rabbitmqctl set_user_tags admin administrator
 Setting tags for user "admin" to [administrator] ...
 [root@node1 ~]# rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
 Setting permissions for user "admin" in vhost "/" ...
 [root@node1 ~]#</code></pre>
    <p>
     步骤
     <br/>
     1.创建用户admin密码123        （生产环境密码必须高难度密码）
     <br/>
     2.给admin用户管理员身份
     <br/>
     3.授予admin用户权限
    </p>
    <h3>
     <strong>
      前期准备
     </strong>
    </h3>
    <h4>
     <strong>
      开启ip转发功能
     </strong>
    </h4>
    <p>
     #查看是否开启转发
    </p>
    <p>
     cat /proc/sys/net/ipv4/ip_forward
    </p>
    <p>
     #返回1代表IP已开启，0 未开启
    </p>
    <p>
     #临时开启
    </p>
    <p>
     echo 1 &gt; /proc/sys/net/ipv4/ip_forward
    </p>
    <p>
     #永久开启
    </p>
    <p>
     vi /etc/sysctl.conf
    </p>
    <p>
     net.ipv4.ip_forward = 1
    </p>
    <p>
     #立即生效
    </p>
    <p>
     sysctl -p /etc/sysctl.conf &amp;
    </p>
    <h4>
     <strong>
      关闭selinux
     </strong>
    </h4>
    <p>
     #查看selinux状态
    </p>
    <p>
     getenforce
    </p>
    <p>
     #永久关闭selinux
    </p>
    <p>
     vi /etc/selinux/config
    </p>
    <p>
     #将 SELINUX=enforcing 改为 SELINUX=disabled
    </p>
    <p>
     #上一个命令需要重启生效，因此建议执行以下命令，临时关闭selinux
    </p>
    <p>
     setenforce 0
    </p>
    <h3>
     <strong>
      HAproxy
     </strong>
     <strong>
     </strong>
     <strong>
     </strong>
     <strong>
     </strong>
    </h3>
    <p>
     我们用haproxy做负载均衡，在两台虚拟机上都安装。
    </p>
    <p>
     #解压haprpxy
     <br/>
     tar xf haproxy-2.9.0.tar.gz
     <br/>
     #进入目录编译安装
     <br/>
     cd haproxy-2.9.0
     <br/>
     make TARGET=linux-glibc  PREFIX=/opt/haproxy-2.9.0
     <br/>
     make install PREFIX=/opt/haproxy-2.9.0
     <br/>
     #设置环境变量并生效
     <br/>
     vim /etc/profile
     <br/>
     export HAPROXY_HOME=/opt/haproxy-2.9.0
     <br/>
     export PATH=$PATH:$HAPROXY_HOME/sbin
     <br/>
     source /etc/profile
     <br/>
     #查看版本验证安装是否成功
     <br/>
     haproxy -v
    </p>
    <p>
     HAProxy version 2.9.0-fddb8c1 2023/12/05 - https://haproxy.org/
    </p>
    <p>
     Status: development branch - not safe for use in production.
    </p>
    <p>
     Known bugs: http://www.haproxy.org/bugs/bugs-2.9.0.html
    </p>
    <p>
     Running on: Linux 3.10.0-1160.36.2.el7.x86_64 #1 SMP Wed Jul 21 11:57:15 UTC 2021 x86_64
    </p>
    <h4>
     <strong>
      配置haproxy文件
     </strong>
    </h4>
    <p>
    </p>
    <pre><code class="language-bash">mkdir /etc/haproxy
 vim /etc/haproxy/haproxy.cfg</code></pre>
    <blockquote>
     <p>
      <br/>
      # 全局配置
      <br/>
      global
      <br/>
      # 日志输出配置、所有日志都记录在本机，通过 local0 进行输出
      <br/>
      log 127.0.0.1 local0 info
      <br/>
      # 最大连接数
      <br/>
      maxconn 4096
      <br/>
      # 改变当前的工作目录
      <br/>
      chroot /opt/haproxy-2.1.10
      <br/>
      # 以指定的 UID 运行 haproxy 进程
      <br/>
      uid 99
      <br/>
      # 以指定的 GID 运行 haproxy 进程
      <br/>
      gid 99
      <br/>
      # 以守护进行的方式运行
      <br/>
      daemon
      <br/>
      # 当前进程的 pid 文件存放位置
      <br/>
      pidfile /opt/haproxy-2.1.10/haproxy.pid
      <br/>
      ​
      <br/>
      # 默认配置
      <br/>
      defaults
      <br/>
      # 应用全局的日志配置
      <br/>
      log global
      <br/>
      # 使用4层代理模式，7层代理模式则为"http"
      <br/>
      mode tcp
      <br/>
      # 日志类别
      <br/>
      option tcplog ##记录TCP请求日志
      <br/>
      # 不记录健康检查的日志信息
      <br/>
      option dontlognull
      <br/>
      # 3次失败则认为服务不可用
      <br/>
      retries 3
      <br/>
      # 每个进程可用的最大连接数
      <br/>
      maxconn 2000
      <br/>
      # 连接超时
      <br/>
      timeout connect 5s
      <br/>
      # 客户端超时
      <br/>
      timeout client 120s
      <br/>
      # 服务端超时
      <br/>
      timeout server 120s
      <br/>
      ​
      <br/>
      # 绑定配置
      <br/>
      listen rabbitmq_cluster
      <br/>
      bind :5672 #绑定端口
      <br/>
      # 配置TCP模式
      <br/>
      mode tcp
     </p>
     <p>
      option tcpka ##是否允许想server和client发送keepalive
      <br/>
      # 采用加权轮询的机制进行负载均衡
      <br/>
      balance roundrobin
      <br/>
      # RabbitMQ 集群节点配置
      <br/>
      server mq-node1 node1:5672 check inter 5000 rise 2 fall 3 weight 1
      <br/>
      server mq-node2 node2:5672 check inter 5000 rise 2 fall 3 weight 1
      <br/>
      server mq-node3 node3:5672 check inter 5000 rise 2 fall 3 weight 1
      <br/>
      ​
      <br/>
      # 配置监控页面
      <br/>
      listen monitor
      <br/>
      bind :8100
      <br/>
      mode http
      <br/>
      option httplog
      <br/>
      stats enable
      <br/>
      stats uri /stats
      <br/>
      stats refresh 5s
     </p>
    </blockquote>
    <p>
     haproxy -f /etc/haproxy/haproxy.cfg -c   #检查配置文件
    </p>
    <p>
     netstat -ntpl启动haproxy前检查端口占用，若占用则更改/etc/haproxy/haproxy.cfg对应的端口号
     <br/>
    </p>
    <pre><code class="language-bash">#启动haproxy配置文件
 haproxy -f /etc/haproxy/haproxy.cfg

#查看Haproxy 启动状态

ps -ef|grep haproxy</code></pre>
    <h4>
     <strong>
      网页访问
     </strong>
    </h4>
    <p>
     访问haproxy网址
     <u>
      http://192.168.200.102:8100/stats
     </u>
     检查是否配置成功，所有节点表示绿色mq集群状态健康。
    </p>
    <h3>
     <strong>
      K
     </strong>
     <strong>
      eepalived
     </strong>
    </h3>
    <p>
     <strong>
      下载keepalived
     </strong>
    </p>
    <p>
     以2.2.8版本为例，如下为下载地址
    </p>
    <p>
     <u>
      https://www.keepalived.org/download.html
     </u>
    </p>
    <p>
     <strong>
      安装依赖软件
     </strong>
    </p>
    <p>
     rpm -qa|grep automake|wc -l 检查没有automake则安装
    </p>
    <p>
     yum -y install automake
    </p>
    <p>
     <strong>
      解压软件
     </strong>
    </p>
    <p>
     tar -xvf keepalived-2.2.8.tar.gz
    </p>
    <p>
     <strong>
      在keepalived-2.2.8目录执行./autogen.sh
     </strong>
    </p>
    <p>
    </p>
    <p>
     ./autogen.sh
    </p>
    <p>
     <strong>
      使用configure命令配置安装目录与核心配置文件所在位置
     </strong>
    </p>
    <p>
     ./configure --prefix=/usr/local/keepalived --sysconf=/etc
    </p>
    <ul>
     <li>
      <p>
       prefix：keepalived安装的位置
      </p>
     </li>
     <li>
      <p>
       sysconf：keepalived核心配置文件所在位置，固定位置，改成其他位置则keepalived启动不了，/var/log/messages中会报错
      </p>
     </li>
    </ul>
    <p>
     <strong>
      安装
     </strong>
    </p>
    <p>
     make &amp;&amp; make install
    </p>
    <p>
    </p>
    <p>
     <strong>
      keepalived配置文件
     </strong>
    </p>
    <p>
     <strong>
      I
     </strong>
     <strong>
      fconfig查看网卡
     </strong>
    </p>
    <p>
     vim /etc/keepalived/keepalived.conf
    </p>
    <p>
     <strong>
      部分配置信息（只显示使用到的）：
     </strong>
    </p>
    <blockquote>
     <p>
      global_defs {
      <!-- -->
     </p>
     <p>
      # 路由id,主备节点不能相同
     </p>
     <p>
      router_id node1
     </p>
     <p>
      vrrp_skip_check_adv_addr
     </p>
     <p>
      # 使用 unicast_src_ip 需要注释 vrrp_strict，而且也可以进行 ping 测试
     </p>
     <p>
      #vrrp_strict
     </p>
     <p>
      vrrp_garp_interval 0
     </p>
     <p>
      vrrp_gna_interval 0
     </p>
     <p>
      }
     </p>
     <p>
     </p>
     <p>
      # 自定义监控脚本
     </p>
     <p>
      vrrp_script chk_haproxy {
      <!-- -->
     </p>
     <p>
      # 脚本位置
     </p>
     <p>
      script "/etc/keepalived/haproxy_check.sh"
     </p>
     <p>
      # 脚本执行的时间间隔
     </p>
     <p>
      interval 5
     </p>
     <p>
      # 权重
     </p>
     <p>
      weight 10
     </p>
     <p>
      }
     </p>
     <p>
     </p>
     <p>
      vrrp_instance VI_1 {
      <!-- -->
     </p>
     <p>
      # Keepalived的角色，MASTER 表示主节点，BACKUP 表示备份节点
     </p>
     <p>
      state MASTER
     </p>
     <p>
     </p>
     <p>
      # 指定监测的网卡，可以使用 ifconfig 进行查看
     </p>
     <p>
      interface ens192
     </p>
     <p>
      #指定发送单播的源IP
     </p>
     <p>
      mcast_src_ip 10.9.37.104 # 当前主机ip
     </p>
     <p>
     </p>
     <p>
      # 虚拟路由的id，主备节点需要设置为相同
     </p>
     <p>
      virtual_router_id 51
     </p>
     <p>
     </p>
     <p>
      # 优先级，主节点的优先级需要设置比备份节点高
     </p>
     <p>
      priority 100
     </p>
     <p>
     </p>
     <p>
      # 设置主备之间的检查时间，单位为秒
     </p>
     <p>
      advert_int 1
     </p>
     <p>
      # 定义验证类型和密码
     </p>
     <p>
      authentication {
      <!-- -->
     </p>
     <p>
      auth_type PASS
     </p>
     <p>
      auth_pass w123456
     </p>
     <p>
      }
     </p>
     <p>
     </p>
     <p>
      # 调用上面自定义的监控脚本
     </p>
     <p>
      track_script {
      <!-- -->
     </p>
     <p>
      chk_haproxy
     </p>
     <p>
      }
     </p>
     <p>
      unicast_peer {
      <!-- -->
     </p>
     <p>
      #指定接收单播的对方目标主机IP
     </p>
     <p>
      172.21.9.203
     </p>
     <p>
      172.21.9.202
     </p>
     <p>
      }
     </p>
     <p>
      virtual_ipaddress {
      <!-- -->
     </p>
     <p>
      # 虚拟IP地址，可以设置多个
     </p>
     <p>
      10.9.37.199
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
    </blockquote>
    <p>
     <strong>
      /etc/keepalived/script/check_haproxy.sh内容
     </strong>
    </p>
    <p>
     <strong>
      vim
     </strong>
     <strong>
      /etc/keepalived/script/check_haproxy.sh
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       #!/bin/bash
      </strong>
     </p>
     <p>
      <strong>
       LOGFILE="/var/log/keepalived-haproxy-status.log"
      </strong>
     </p>
     <p>
      <strong>
       date &gt;&gt; $LOGFILE
      </strong>
     </p>
     <p>
      <strong>
       A=`ps -C haproxy --no-header |wc -l`
      </strong>
     </p>
     <p>
      <strong>
       # 判断haproxy是否已经启动
      </strong>
     </p>
     <p>
      <strong>
       if [ $A -eq 0 ];then
      </strong>
     </p>
     <p>
      <strong>
       #如果没有启动，则启动
      </strong>
     </p>
     <p>
      <strong>
       echo "warning: restart haproxy" &gt;&gt; $LOGFILE
      </strong>
     </p>
     <p>
      <strong>
       haproxy -f /etc/haproxy/haproxy.cfg
      </strong>
     </p>
     <p>
      <strong>
       fi
      </strong>
     </p>
     <p>
      <strong>
       #睡眠3秒以便haproxy完全启动
      </strong>
     </p>
     <p>
      <strong>
       sleep
      </strong>
      <strong>
       3
      </strong>
     </p>
     <p>
      <strong>
       #如果haproxy还是没有启动，此时需要将本机的keepalived服务停掉，以便让VIP自动漂移到另外一台haproxy
      </strong>
     </p>
     <p>
      <strong>
       if [ $A -eq 0 ];then
      </strong>
     </p>
     <p>
      <strong>
       echo "fail: check_haproxy status" &gt;&gt; $LOGFILE
      </strong>
     </p>
     <p>
      <strong>
       systemctl stop keepalived
      </strong>
     </p>
     <p>
      <strong>
       fi
      </strong>
     </p>
     <p>
      <strong>
       else
      </strong>
     </p>
     <p>
      <strong>
       echo "success: check_haproxy status" &gt;&gt; $LOGFILE
      </strong>
     </p>
     <p>
      <strong>
       fi
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      说明：
     </strong>
     <br/>
     Keepalived组之间的心跳检查并不能察觉到HAproxy负载是否正常，所以需要使用此脚本。
     <br/>
     在Keepalived主机上，开启此脚本检测HAproxy是否正常工作，如正常工作，记录日志。
     <br/>
     如进程不存在，则尝试重启HAproxy，三秒后检测，如果还没有则关掉主Keepalived，此时备Keepalived检测到主Keepalive挂掉，接管VIP，继续服务。
    </p>
    <p>
     #给脚本添加执行权限
     <br/>
     chmod +x /etc/keepalived/script/check_haproxy.sh
    </p>
    <p>
     #配置ip转发
     <br/>
     echo "net.ipv4.ip_nonlocal_bind = 1" &gt;&gt; /etc/sysctl.conf
     <br/>
     #生效
     <br/>
     sysctl -p
    </p>
    <p>
     #启动keepalived并设置开机自启
     <br/>
     systemctl start keepalived
     <br/>
     systemctl enable keepalived
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f6c696861696d696e675f323030382f:61727469636c652f64657461696c732f313436303530373736" class_="artid" style="display:none">
 </p>
</div>


