---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353733313834352f:61727469636c652f64657461696c732f313436323931323734"
layout: post
title: "嵌入式八股硬件篇"
date: 2025-03-16 10:07:11 +08:00
description: "2026嵌入式秋招八股汇总"
keywords: "嵌入式八股硬件篇"
categories: ['嵌入式八股']
tags: ['嵌入式硬件', 'Stm', 'C', 'Arm']
artid: "146291274"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146291274
    alt: "嵌入式八股硬件篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146291274
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146291274
cover: https://bing.ee123.net/img/rand?artid=146291274
image: https://bing.ee123.net/img/rand?artid=146291274
img: https://bing.ee123.net/img/rand?artid=146291274
---

# 嵌入式八股硬件篇

## 前言

总结了最常见的外设的知识

### 1. MCU MPU CPU 与 SOC

1. CPU: 没有感情的执行命令机器 只做计算: 由运算器、控制器和寄存器构成
     
   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/95393e645b7f4d2995edc9d5bf65e31b.png)
2. MPU: 增强版CPU, 更强大的计算能力
3. MCU: MCU相较于前两个 继承了更多的东西已经可以运行代码了 MCU = CPU + 存储器 + 定时/计数器 + 各种控制器比如I2C控制器…
4. SOC: 更为复杂的集成 SOC = MCU / MPU + GPU + ISP巴拉巴拉的

### 2. RAM ROM 与 Flash,Cache

1. 什么是RAM
     
   RAM:Random Access Memory 其中Random体现在不必顺序查找和存储数据 比如我现在正访问RAM的0x800000位置 我突然想访问0x40000位置也没问题
   * RAM的特点
     + 掉电就丢失
     + 可读可写
   * 常见的RAM
     + SRAM
       - 上电就能用:STM32 内部的RAM就是SRAM,启动时SP指针的值一赋值就直接用了
       - CPU可以直接通过地址访问任意数据
       - 速度快但是成本高
     + DRAM: 需要实时刷新来保持数据稳定性
       - 这意味着DRAM不是上电就能用的,需要设置其对应的控制器
       - CPU不可直接访问:一般我们要访问DRAM的数据时 要通过其控制器才能访问
       - 速度慢但是便宜量大
     + SDRAM: 本质是DRAM
     + DDR : 更高级的SDRAM 但还是DRAM
2. 什么是ROM
     
   ROM是一种只读存储器，其中的数据
   **不能被常规方式**
   修改或写入
     
   ROM的特点:掉电后可以保存
   * MROM
   * PROM
       
     PROM适用于需要存储不可更改数据的应用，如设备固件等,写入就不能改
   * EPROM
       
     需要用紫外线才能擦除代码
   * EEPROM
       
     电可擦除可编程只读存储器,此时已经是可读/可写了,按照单个字节操作
   * FLASH
       
     FLASH是EEPROM的一个分支 特点是按块读/写,
     **不能按单个字节操作**
       
     擦除操作只能将位设置为“1”，而写入操作可以将位从“1”改为“0”。因此，为了更新数据，必须先擦除相应的块或页，然后才能写入新的数据
     + NOR FLASH: CPU可以通过地址直接访问对应数据从而运行代码,但是贵
         
       STM32 的内部FLASH 就是 NOR FLASH,我们在启动的时候就是直接通过地址访问对应的代码的
     + NAND FLASH: CPU需要通过控制器访问其中的数据 但是便宜
3. Cache
     
   Cache的本质 一块SRAM
     
   Cache的目的: 解决CPU快但是DRAM慢的问题
   * Cache命中
       
     当读数据的时候 先从Cache里读 如果读到了就称作Cache命中,否则就去把对应地址一块的内存都读进Cache
   * 脏页
       
     CPU写数据的时候是写入到Cache里就不管了 那么此时内存的数据和Cache的数据就不一致了,就会标记为dirty

### 3. 中断

这里中断只是一个通用的讲 关于什么上/下半部会放到Linux的中断系统里讲

* 什么是中断
    
  CPU暂停当前正在执行的任务，转而去处理更为紧急或重要的任务，并在处理完成后返回继续执行之前的任务
    
  发生中断后,就从线程模式变为handler模式了
* 中断的分类
  + 硬件中断/软件中断(系统调用)
  + 外部中断 / 内部中断(异常 比如缺页错误/除0了)
* 中断的应用
  + 实时响应:配置外部中断实时响应
  + 异步处理
  + 多任务切换: PendSV
* 中断处理流程
  + 保存现场：将当前程序状态（如寄存器内容）保存起来，以便稍后恢复。
  + 确定中断源：识别哪个设备或事件触发了中断。
  + 执行中断服务例程（ISR）：跳转到相应的中断处理程序执行必要的处理。(在执行前就设置了PC LR MSP等)
  + 恢复现场
* 中断与轮训
    
  中断：当特定事件发生时，系统自动调用中断服务程序来处理事件。
    
  轮询：CPU周期性地检查设备状态，以确定是否需要处理事件。
* 中断服务程序
  + 不能在中断服务程序里 阻塞/睡眠
  + 快速响应
  + 中断服务程序的传参: 无法传参 或者说你想传什么呢
  + 中断服务程序的返回值: 无返回值 你想返回什么? 返回给谁呢
  + 互斥访问: 对于全局变量的操作要谨慎
* 中断向量表
    
  用于管理和响应中断的数据结构。它是一个预先定义的表格，存储了每个中断类型对应的中断处理程序的入口地址。当发生一个中断时，硬件会通过中断控制器将中断信号发送给操作系统。操作系统根据中断类型，在中断向量表中查找相应的中断处理程序的入口地址，并跳转到该地址开始执行中断处理程

### 4. DMA

* 什么是DMA
    
  允许外部设备在不经过CPU的情况下直接与内存进行数据传输。这种技术能够显著提高数据传输的效率，减轻CPU的负担，从而提升系统的整体性能
* DMA的工作与配置
  + 配置DMA控制器
  + 确定传输方向
      
    是从哪里传输到哪里,地址到底自增还是不自增呢
  + 传输的模式: 单次还是循环传输
  + 配置相关的中断: 传输完成中断/一半中断之类的

### 5. GPIO

通用功能输入输出
  
芯片上大部分引脚都是 GPIO引脚，作为这类引脚，它的功能和特点是可以被编程控制它的工作模式，也可以编程控制它的电压高低等 GPIO = 引脚 + 功能寄存器

* GPIO的八种模式
  + 上拉输入 : 平时为高电平
  + 下拉输入 : 平时为低电平
  + 浮空输入 : 完全取决于外部电路
  + 模拟输入
  + 推挽输出 : 既能输出高 又能输出低
  + 开漏输出 : 只能输出低 或高阻态 想要输出高得外接上拉电阻
    - 相较于推挽的好处: 可以实现线与 多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平;推挽就不行,直接就烧毁了
    - 可以输出不同电压: 通过改变上拉电源的电压，便可以改变传输电平
  + 复用开漏输出
  + 复用推挽输出

### 6. 定时器

* sysTick
    
  自动重装载的定时器 既可以让它的频率等于程序运行的频率 也可以配置为其他;在后面的RTOS中有用
* RTC时钟
    
  掉电后通过后背隐藏能源运行
* 通用定时器
  + 定时器的应用场景
      
    假设我们的RTOS的调度是每10ms进行一次 但是我们想每间隔10us就对电机的数据进行采样 这时候怎么做呢? 肯定不能是把对电机采样这个作为一个普通的任务了
      
    此时 我们通过定时器中断实现,注意
    **设置定时器中断的优先级不受RTOS的中断管理**
* 软件定时器
    
  软件定时器的本质还是sysTick定时器 + 链表之类的数据结构来实现的
* 看门狗
  + 看门狗原理
      
    定期向系统发送一个计时器信号 如果系统正常运行就会在规定时间内定期重置或喂狗，如果没有及时喂狗就会触发看门狗超时,自动执行复位操作
  + 设置看门狗定时器
  + 系统正常运行期间 软件会定时喂狗 重置计数器计数值
  + 故障或者死机就无法定期喂狗 就会触发看门狗超时
  + 看门狗超时:向系统发送复位信号 强制复位

### 7. PWM

脉冲宽度调制技术,使用PWM波形，等效地实现一个模拟信号的输出
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/50b35cd3bc0a4ddeb54c4b48df2d2809.png)

根据这个IO高电平在一个周期的时间 就能算出输出了多少电压了

* PWM的占空比
    
  占空比 = (高电平信号持续时间 / 一个周期) \* 100%
    
  改变PWM的占空比 可以控制输出信号的平均电平值
* PWM应用
  + 电机控制
  + LED亮度调节
  + 数字控制系统

### 8. 低功耗模式

* 三种低功耗模式
    
  sleep / stop / standby
  + sleep
      
    CPU停止 外设保持活动 此时有中断就能恢复工作 接着之前状态运行
  + stop
      
    CPU和大部分外设都停止 只有部分必要外设(RTC 看门狗)保持运行
      
    外部中断唤醒 接着之前状态运行
  + Standby
      
    cpu + 外设 + 时钟全关
      
    只由外部事件或RTC警报才能唤醒 此时重置运行状态
* run模式怎么降低呢
  1. 关闭一些没必要的时钟来降低
  2. 降低时钟频率