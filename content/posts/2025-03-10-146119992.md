---
layout: post
title: "机器学习chp12半监督学习自我训练协同训练多视角学习生成模型半监督SVM基于图的半监督算法半监督聚类"
date: 2025-03-10 12:09:48 +0800
description: "半监督学习的定义和基本思想半监督学习（Semi-Supervised Learning，SSL）结合了监督学习和无监督学习的特点。它的基本思想是使用少量的标注数据和大量的无标注数据进行学习。标注数据相对较贵且稀缺，而无标注数据通常可以轻松获得，因此半监督学习能够在实际应用中发挥巨大作用。监督学习：依赖大量标注数据，通过标注数据训练模型进行分类或回归任务。无监督学习：使用未标注数据进行训练，主要用于聚类或数据表示学习，不依赖标签。"
keywords: "【机器学习chp12】半监督学习（自我训练+协同训练多视角学习+生成模型+半监督SVM+基于图的半监督算法+半监督聚类）"
categories: ['机器学习']
tags: ['算法', '机器学习', '半监督学习', '人工智能']
artid: "146119992"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146119992
    alt: "机器学习chp12半监督学习自我训练协同训练多视角学习生成模型半监督SVM基于图的半监督算法半监督聚类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146119992
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146119992
cover: https://bing.ee123.net/img/rand?artid=146119992
image: https://bing.ee123.net/img/rand?artid=146119992
img: https://bing.ee123.net/img/rand?artid=146119992
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【机器学习chp12】半监督学习（自我训练+协同训练多视角学习+生成模型+半监督SVM+基于图的半监督算法+半监督聚类）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B" name="%E4%B8%80%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B">
     一、半监督学习简介
    </h2>
    <h3 id="1%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" name="1%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">
     1、
     <strong>
      半监督学习的定义和基本思想
     </strong>
    </h3>
    <p>
     半监督学习（Semi-Supervised Learning，SSL）结合了监督学习和无监督学习的特点。它的基本思想是使用少量的标注数据和大量的无标注数据进行学习。标注数据相对较贵且稀缺，而无标注数据通常可以轻松获得，因此半监督学习能够在实际应用中发挥巨大作用。
    </p>
    <ul>
     <li>
      <strong>
       监督学习
      </strong>
      ：依赖大量标注数据，通过标注数据训练模型进行分类或回归任务。
     </li>
     <li>
      <strong>
       无监督学习
      </strong>
      ：使用未标注数据进行训练，主要用于聚类或数据表示学习，不依赖标签。
     </li>
    </ul>
    <p>
     半监督学习的核心优势是它能充分利用无标注数据的结构信息（例如数据分布、聚类结构等），同时又保持了监督学习对标注数据的依赖。
    </p>
    <h3 id="2%E3%80%81%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0%C2%A0%20%E5%92%8C%C2%A0%20%E7%9B%B4%E6%8E%A8%E5%AD%A6%E4%B9%A0" name="2%E3%80%81%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0%C2%A0%20%E5%92%8C%C2%A0%20%E7%9B%B4%E6%8E%A8%E5%AD%A6%E4%B9%A0">
     2、归纳学习  和  直推学习
    </h3>
    <p>
     在半监督学习中，
     <strong>
      归纳学习
     </strong>
     和
     <strong>
      直推学习
     </strong>
     是两种不同的学习方法，它们的主要区别在于模型的应用和预测的范围。
    </p>
    <h4 id="%EF%BC%881%EF%BC%89%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0" name="%EF%BC%881%EF%BC%89%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0">
     （1）
     <strong>
      归纳学习
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        定义
       </strong>
       ：归纳学习是指从已知的训练数据（包括标注数据和无标注数据）中学习一个泛化的学习函数（或模型），该函数可以用来对新的、未见过的测试数据进行预测。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：归纳学习的目标是学到一个
       <strong>
        泛化的函数
       </strong>
       ，这个函数不仅能够对训练集进行拟合，而且能够对未来的、未见过的数据进行准确的预测。归纳学习假设我们学到的模型是适用于整个数据空间的。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数学表示
       </strong>
       ：给定训练数据
       <img alt="D = \{(x_1, y_1), (x_2, y_2), \dots, (x_L, y_L)\}" class="mathcode" src="https://latex.csdn.net/eq?D%20%3D%20%5C%7B%28x_1%2C%20y_1%29%2C%20%28x_2%2C%20y_2%29%2C%20%5Cdots%2C%20%28x_L%2C%20y_L%29%5C%7D">
        ，其中
        <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i">
         ​ 为输入特征，
         <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i">
          ​ 为对应标签。无标注数据为
          <img alt="D_U = \{x_{L+1}, x_{L+2}, \dots, x_{L+U}\}" class="mathcode" src="https://latex.csdn.net/eq?D_U%20%3D%20%5C%7Bx_%7BL&amp;plus;1%7D%2C%20x_%7BL&amp;plus;2%7D%2C%20%5Cdots%2C%20x_%7BL&amp;plus;U%7D%5C%7D">
           。目标是学习一个分类器
           <img alt="f" class="mathcode" src="https://latex.csdn.net/eq?f">
            ，使其能够对未知的测试数据
            <img alt="x_{\text{test}}" class="mathcode" src="https://latex.csdn.net/eq?x_%7B%5Ctext%7Btest%7D%7D">
             ​ 进行预测。
            </img>
           </img>
          </img>
         </img>
        </img>
       </img>
      </p>
     </li>
     <li>
      <p>
       <strong>
        应用实例
       </strong>
       ：在图像分类任务中，归纳学习的目标是从训练数据（标注的图像和标签）学习到一个分类器，该分类器不仅能够对训练集中的图像进行分类，还能够对未来的未标注图像进行预测。
      </p>
     </li>
    </ul>
    <h4 id="%EF%BC%882%EF%BC%89%E7%9B%B4%E6%8E%A8%E5%AD%A6%E4%B9%A0" name="%EF%BC%882%EF%BC%89%E7%9B%B4%E6%8E%A8%E5%AD%A6%E4%B9%A0">
     （2）
     <strong>
      直推学习
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        定义
       </strong>
       ：直推学习与归纳学习不同，它不关注学到一个泛化的模型，而是直接关注如何利用训练数据（标注数据）来对测试数据进行预测。
       <strong>
        直推学习的目标是尽可能好地对测试数据进行预测，而不需要考虑如何将学习到的知识推广到其他未知数据
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：在直推学习中，模型是针对特定的测试集进行训练的，因此它在学习过程中并不假设模型能够泛化到所有数据。它专注于给定的测试数据集，在该数据集上进行准确的预测。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数学表示
       </strong>
       ：给定训练数据
       <img alt="D = \{(x_1, y_1), (x_2, y_2), \dots, (x_L, y_L)\}" class="mathcode" src="https://latex.csdn.net/eq?D%20%3D%20%5C%7B%28x_1%2C%20y_1%29%2C%20%28x_2%2C%20y_2%29%2C%20%5Cdots%2C%20%28x_L%2C%20y_L%29%5C%7D">
        ，无标注数据
        <img alt="D_U = \{x_{L+1}, x_{L+2}, \dots, x_{L+U}\}" class="mathcode" src="https://latex.csdn.net/eq?D_U%20%3D%20%5C%7Bx_%7BL&amp;plus;1%7D%2C%20x_%7BL&amp;plus;2%7D%2C%20%5Cdots%2C%20x_%7BL&amp;plus;U%7D%5C%7D">
         ，直推学习通过对
         <strong>
          测试集
         </strong>
         <img alt="x_{\text{test}}" class="mathcode" src="https://latex.csdn.net/eq?x_%7B%5Ctext%7Btest%7D%7D"/>
         ​ 进行预测，不要求学到的模型具有对其他数据的泛化能力。
        </img>
       </img>
      </p>
     </li>
     <li>
      <p>
       <strong>
        应用实例
       </strong>
       ：在网络链接预测中，直推学习可以根据现有的已知链接信息和无标注的数据推测新的链接，而不要求该模型能够广泛地应用于其他场景。
      </p>
     </li>
    </ul>
    <h3 id="3%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8A%BF" name="3%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8A%BF">
     3、
     <strong>
      半监督学习的作用与优势
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       少量标注数据与大量无标注数据结合
      </strong>
      ：这种数据组合可以让模型在保证标注数据的准确性的同时，借助无标注数据的结构信息来提高模型的泛化能力。
     </li>
     <li>
      <strong>
       有效利用无标注数据
      </strong>
      ：无标注数据虽然没有标签，但它们可以通过相似性或聚类结构帮助模型进行学习，例如基于数据的几何结构或类簇结构来推测未标注数据的标签。
     </li>
    </ul>
    <h3 id="4%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%85%B3%E9%94%AE%E5%81%87%E8%AE%BE" name="4%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%85%B3%E9%94%AE%E5%81%87%E8%AE%BE">
     4、
     <strong>
      半监督学习的关键假设
     </strong>
    </h3>
    <p>
     半监督学习的有效性依赖于一些关键的假设，例如：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        高密度平滑假设（Smoothness Assumption）
       </strong>
       ：如果两个点在特征空间中很接近，那么它们的标签应该相似。这种假设强调了数据点之间的相似性对预测标签的影响。例如，如果数据在某个区域内密集，那么该区域内的点可能属于同一个类。
      </p>
     </li>
     <li>
      <p>
       <strong>
        聚类假设（Cluster Assumption）
       </strong>
       ：在某些区域内，数据点可能会形成聚类，且属于同一类。聚类假设假定，数据点在同一簇内更可能属于同一类。等价形式：低密度分割：决策边界应该在低密度区域。
      </p>
     </li>
     <li>
      <p>
       <strong>
        流形假设（Manifold Assumption）
       </strong>
       ：高维数据常常分布在低维流形上，相邻的点通常具有相似的标签。在图像中提到的数据流形假设展示了如何利用流形结构来改进学习过程。
      </p>
     </li>
    </ul>
    <h3 id="5%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BA%94%E7%94%A8" name="5%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BA%94%E7%94%A8">
     5、
     <strong>
      半监督学习的应用
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       图像识别
      </strong>
      ：大量无标注的图像可以帮助模型学习图像的潜在结构，从而提高分类精度。
     </li>
     <li>
      <strong>
       文本分类
      </strong>
      ：对于有标注的少量文本数据和大量无标注的文本数据，半监督学习能够结合两者的优势，提高文本分类的准确性。
     </li>
    </ul>
    <h3 id="6%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95" name="6%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">
     6、
     <strong>
      半监督学习的常见方法
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        生成式模型
       </strong>
       ：这类方法通过建模数据的生成过程来处理无标注数据。在这种方法中，我们假设数据是从一个潜在的生成模型中生成的，标注数据和无标注数据共同参与模型的训练。
      </p>
     </li>
     <li>
      <p>
       <strong>
        图模型与图传播
       </strong>
       ：基于图模型的方法利用数据点之间的相似性来推断无标注数据的标签，通过图传递标签信息来提升分类或回归精度。
      </p>
     </li>
    </ul>
    <h3 id="7%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8C%91%E6%88%98%E4%B8%8E%E9%97%AE%E9%A2%98" name="7%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8C%91%E6%88%98%E4%B8%8E%E9%97%AE%E9%A2%98">
     7、
     <strong>
      半监督学习的挑战与问题
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       噪声问题
      </strong>
      ：无标注数据可能存在噪声，因此如何处理噪声成为半监督学习的一大挑战。
     </li>
     <li>
      <strong>
       模型选择问题
      </strong>
      ：如何选择合适的模型来利用标注数据和无标注数据的优势是一个值得深入研究的问题。
     </li>
    </ul>
    <p>
    </p>
    <p>
     <strong>
      <em>
       <span style="background-color:null">
       </span>
       <span style="background-color:#a2e043">
        半监督学习算法
       </span>
      </em>
     </strong>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E8%87%AA%E6%88%91%E8%AE%AD%E7%BB%83" name="%E4%BA%8C%E3%80%81%E8%87%AA%E6%88%91%E8%AE%AD%E7%BB%83">
     二、自我训练
    </h2>
    <h3 id="1%E3%80%81%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%81%87%E8%AE%BE%E5%92%8C%E6%AD%A5%E9%AA%A4" name="1%E3%80%81%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%81%87%E8%AE%BE%E5%92%8C%E6%AD%A5%E9%AA%A4">
     1、
     <strong>
      自我学习算法的假设和步骤
     </strong>
    </h3>
    <p id="%E5%81%87%E8%AE%BE%EF%BC%9A" name="%E5%81%87%E8%AE%BE%EF%BC%9A">
     <strong>
      假设：
     </strong>
    </p>
    <p>
     自我训练法假设输出的高度置信的预测是正确的。这意味着，对于无标注数据，我们会基于现有模型的预测信心来决定是否将其添加到标注数据集。模型会对那些被认为是最有可能正确的样本进行标注，并不断通过这些标注数据进行自我学习。
    </p>
    <p id="%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4%EF%BC%9A" name="%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4%EF%BC%9A">
     <strong>
      自我学习步骤：
     </strong>
    </p>
    <p>
     自我训练法的步骤如下：
    </p>
    <ul>
     <li>
      <strong>
       步骤 1：
      </strong>
      从少量的标注数据集
      <img alt="L_{\text{init}}" class="mathcode" src="https://latex.csdn.net/eq?L_%7B%5Ctext%7Binit%7D%7D"/>
      ​ 开始，使用这些数据训练一个初始分类器 fff。
     </li>
     <li>
      <strong>
       步骤 2：
      </strong>
      计算分类器对无标注数据
      <img alt="D_U" class="mathcode" src="https://latex.csdn.net/eq?D_U"/>
      ​ 的预测结果
      <img alt="f(x)" class="mathcode" src="https://latex.csdn.net/eq?f%28x%29"/>
      。
     </li>
     <li>
      <strong>
       步骤 3：
      </strong>
      选择预测信心最强的无标注数据样本，并将这些样本及其预测标签添加到标注数据集中，形成新的训练集。
     </li>
     <li>
      <strong>
       步骤 4：
      </strong>
      使用新的训练集更新分类器，并重复步骤 2 和 3。
     </li>
    </ul>
    <p>
     这种方法依赖于每次迭代中通过选择分类器预测最有信心的样本来扩大标注数据集。
    </p>
    <h3 id="2%E3%80%81%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8F%98%E4%BD%93" name="2%E3%80%81%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8F%98%E4%BD%93">
     2、
     <strong>
      自我学习的变体
     </strong>
    </h3>
    <p>
     自我训练法有几个变体，常见的有：
    </p>
    <ul>
     <li>
      <strong>
       添加高度置信的预测结果：
      </strong>
      每次训练后选择最有信心的无标注数据进行标注，添加到训练数据集。
     </li>
     <li>
      <strong>
       全量数据添加：
      </strong>
      每次都将所有无标注数据与其预测结果添加到训练集，而不进行置信度筛选。
     </li>
     <li>
      <strong>
       根据置信度赋予不同的权重：
      </strong>
      对于每个无标注数据的预测结果，可以根据预测的置信度给予不同的权重，来调整模型对不同数据点的关注程度。
     </li>
    </ul>
    <h3 id="4%E3%80%81%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" name="4%E3%80%81%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">
     4、
     <strong>
      自我学习的优缺点
     </strong>
    </h3>
    <p id="%E4%BC%98%E7%82%B9%EF%BC%9A" name="%E4%BC%98%E7%82%B9%EF%BC%9A">
     <strong>
      优点：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       最简单且易于实现：
      </strong>
      自我训练法是最简单的半监督学习方法之一，易于实现并且不需要复杂的计算或算法。
     </li>
     <li>
      <strong>
       适用性强：
      </strong>
      可以应用到已经存在的分类器上，甚至是复杂的分类器（如KNN等）。这种方法通过不断迭代，可以有效提高分类器的性能。
     </li>
     <li>
      <strong>
       提高模型的泛化能力：
      </strong>
      自我训练能够利用大量的无标注数据，逐步扩展训练集，增强模型的泛化能力。
     </li>
    </ul>
    <p id="%E7%BC%BA%E7%82%B9%EF%BC%9A" name="%E7%BC%BA%E7%82%B9%EF%BC%9A">
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       早期错误的放大：
      </strong>
      如果分类器在初期阶段做出了错误的预测，错误会被不断地放大。即使是少数的错误预测，也可能对模型的学习产生负面影响。
     </li>
     <li>
      <strong>
       依赖预测的准确性：
      </strong>
      自我训练法高度依赖分类器的预测信心。如果分类器在初期预测时不准确，可能会导致错误的标签进入训练集，从而影响模型的性能。
     </li>
     <li>
      <strong>
       缺乏对错误的保护：
      </strong>
      自我训练法本身没有针对预测错误的保护机制，这可能导致学习过程中的不稳定性。
     </li>
    </ul>
    <h3 id="5%E3%80%81%E6%80%BB%E7%BB%93" name="5%E3%80%81%E6%80%BB%E7%BB%93">
     5、总结
    </h3>
    <p>
     自我训练法是一种简单且有效的半监督学习方法，它能够通过不断扩大标注数据集来提高模型的性能。虽然它存在一些早期错误的放大问题，但在合适的场景下，它仍然是一种非常实用的半监督学习技术。
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0" name="%E4%B8%89%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0">
     三、协同训练——多视角学习
    </h2>
    <h3 id="1%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E4%BB%8B%E7%BB%8D" name="1%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E4%BB%8B%E7%BB%8D">
     1、
     <strong>
      协同训练介绍
     </strong>
    </h3>
    <p>
     协同训练是自训练到多个监督分类器的扩展。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        基本思想
       </strong>
       ：在标注数据上迭代训练多个分类器，多个分类器互相教对方：将各自最有信心的预测加到其他分类器的标注数据。
      </p>
     </li>
     <li>
      <p>
       协同训练中基础学习器的预测必须相关性不太强：多样性标准
      </p>
     </li>
     <li>
      <p>
       为了促进分类器的多样性
      </p>
      <ul>
       <li>
        <div>
        </div>
        数据的多个不同视图：多视图学习。
       </li>
       <li>
        学习算法本身的多样性：不同超参数的分类器、不同的基础分类器。
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="2%E3%80%81%E7%BD%91%E9%A1%B5%E5%88%86%E7%B1%BB%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%92%8C%E6%96%87%E6%9C%AC%E4%B8%A4%E4%B8%AA%E8%A7%86%E8%A7%92%E7%89%B9%E5%BE%81%E5%88%86%E8%A3%82" name="2%E3%80%81%E7%BD%91%E9%A1%B5%E5%88%86%E7%B1%BB%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%92%8C%E6%96%87%E6%9C%AC%E4%B8%A4%E4%B8%AA%E8%A7%86%E8%A7%92%E7%89%B9%E5%BE%81%E5%88%86%E8%A3%82">
     2、
     <strong>
      网页分类的例子：图像和文本两个视角特征分裂
     </strong>
    </h3>
    <p>
     在网页分类的任务中，我们可以将网页的特征分为两个视角（特征分裂）：图像特征和文本特征。这两个视角在协同训练中可以作为两个不同的分类器进行训练。
    </p>
    <ul>
     <li>
      <strong>
       图像特征
      </strong>
      ：包括网页中的图片内容。
     </li>
     <li>
      <strong>
       文本特征
      </strong>
      ：包括网页的HTML文本。
     </li>
    </ul>
    <p>
     这些视角相互补充，图像和文本分别代表了网页的不同部分。通过训练两个分类器（分别基于图像和文本），我们可以从这两个视角的预测中提取最有信心的预测结果，进一步扩展训练集。
    </p>
    <p>
     <img alt="" height="251" src="https://i-blog.csdnimg.cn/direct/adf3d9136f514c658b0929bcabec2171.png" width="389"/>
    </p>
    <h3 id="3%E3%80%81%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%81%87%E8%AE%BE" name="3%E3%80%81%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%81%87%E8%AE%BE">
     3、
     <strong>
      多视角学习的假设
     </strong>
    </h3>
    <p>
     多视角学习的基本假设包括：
    </p>
    <ul>
     <li>
      <strong>
       特征可分裂
      </strong>
      ：每个样本的特征可以分裂成多个部分。
     </li>
     <li>
      <strong>
       视角独立性
      </strong>
      ：两个视角（特征子集）在给定类别后是条件独立的。
     </li>
     <li>
      <strong>
       充分性
      </strong>
      ：特征子集单独对于训练一个好的分类器是充分的。
     </li>
    </ul>
    <h3 id="4%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E7%AE%97%E6%B3%95" name="4%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E7%AE%97%E6%B3%95">
     4、
     <strong>
      协同训练算法
     </strong>
    </h3>
    <p>
     协同训练的步骤如下：
    </p>
    <ol>
     <li>
      <strong>
       训练两个分类器
      </strong>
      ：从标注数据
      <img alt="(x_L, y_L)" class="mathcode" src="https://latex.csdn.net/eq?%28x_L%2C%20y_L%29"/>
      学习两个分类器
      <img alt="f^{(1)}" class="mathcode" src="https://latex.csdn.net/eq?f%5E%7B%281%29%7D"/>
      和
      <img alt="f^{(2)}" class="mathcode" src="https://latex.csdn.net/eq?f%5E%7B%282%29%7D"/>
      ，分别基于不同的特征视角（例如图像特征和文本特征）。
     </li>
     <li>
      <strong>
       扩展训练集
      </strong>
      ：使用两个分类器
      <img alt="f^{(1)}" class="mathcode" src="https://latex.csdn.net/eq?f%5E%7B%281%29%7D"/>
      和
      <img alt="f^{(2)}" class="mathcode" src="https://latex.csdn.net/eq?f%5E%7B%282%29%7D"/>
      分别对无标注数据
      <img alt="D_U" class="mathcode" src="https://latex.csdn.net/eq?D_U"/>
      ​ 进行预测，将每个分类器最有信心的
      <img alt="k" class="mathcode" src="https://latex.csdn.net/eq?k"/>
      个预测结果加入到标注数据集。
     </li>
     <li>
      <strong>
       重复上述步骤
      </strong>
      ：将新加入的预测样本作为标注数据，继续训练两个分类器，并迭代执行，直到达到预期的效果。
     </li>
    </ol>
    <h3 id="5%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" name="5%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">
     5、
     <strong>
      协同训练的优缺点
     </strong>
    </h3>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       简单且易实现
      </strong>
      ：协同训练是基于简单的 wrapper 方法，可以很容易地应用到已经存在的多个分类器中。
     </li>
     <li>
      <strong>
       鲁棒性较强
      </strong>
      ：相比自我训练，协同训练对错误的敏感性较低，因为它依赖于多个分类器的协同作用。
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       特征分裂的自然性问题
      </strong>
      ：并非所有问题都能自然地将特征分成多个独立的视角，这可能在某些任务中造成困难。
     </li>
     <li>
      <strong>
       全特征模型可能更好
      </strong>
      ：在一些情况下，使用所有特征的模型可能比单独使用每个视角的模型效果更好。
     </li>
    </ul>
    <h3 id="6%E3%80%81%E5%8D%8F%E5%90%8C%E6%AD%A3%E5%88%99%E5%8C%96" name="6%E3%80%81%E5%8D%8F%E5%90%8C%E6%AD%A3%E5%88%99%E5%8C%96">
     6、
     <strong>
      协同正则化
     </strong>
    </h3>
    <p>
     协同正则化是一种通过正则化不同分类器之间的行为一致性来提升模型性能的技术。在协同训练中，我们希望多个分类器在无标注数据上的预测尽可能一致。为了实现这一目标，引入了协同正则化作为一个策略，目的是将分类器之间的不一致性最小化。
    </p>
    <p>
     <strong>
      工作原理：
     </strong>
    </p>
    <ul>
     <li>
      协同正则化的核心思想是，训练的不同分类器应该在无标注数据上的输出保持一致。换句话说，两个分类器分别在各自的视角下对同一数据进行预测时，它们的预测结果应当相似。
     </li>
     <li>
      具体地，我们会在优化目标函数中引入一个正则化项，用来衡量不同分类器在无标注数据上的预测差异。通过最小化这个正则化项，可以促进分类器的预测一致性。
     </li>
    </ul>
    <p>
     <strong>
      目标函数:
     </strong>
    </p>
    <p>
     公式：
    </p>
    <p>
     <img alt="\min_f \left( \sum_{\nu=1}^{M} \left( \sum_{i=1}^{L} L(y_i, f_v(x_i)) + \lambda_1 R(f_v) \right) \right) +" class="mathcode" src="https://latex.csdn.net/eq?%5Cmin_f%20%5Cleft%28%20%5Csum_%7B%5Cnu%3D1%7D%5E%7BM%7D%20%5Cleft%28%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20L%28y_i%2C%20f_v%28x_i%29%29%20&amp;plus;%20%5Clambda_1%20R%28f_v%29%20%5Cright%29%20%5Cright%29%20&amp;plus;"/>
     <img alt="\lambda_2 \sum_{u=1}^{M} \sum_{i=L+1}^{N}(f_u(x_i) - f_v(x_i))^2" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda_2%20%5Csum_%7Bu%3D1%7D%5E%7BM%7D%20%5Csum_%7Bi%3DL&amp;plus;1%7D%5E%7BN%7D%28f_u%28x_i%29%20-%20f_v%28x_i%29%29%5E2"/>
     <img alt="" class="mathcode" src="https://latex.csdn.net/eq?"/>
    </p>
    <p>
     这个目标函数包括了两个部分：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        第一部分
       </strong>
       ：监督学习损失与正则化项
      </p>
      <img alt="\sum_{\nu=1}^{M} \left( \sum_{i=1}^{L} L(y_i, f_v(x_i)) + \lambda_1 R(f_v) \right)" class="mathcode" src="https://latex.csdn.net/eq?%5Csum_%7B%5Cnu%3D1%7D%5E%7BM%7D%20%5Cleft%28%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20L%28y_i%2C%20f_v%28x_i%29%29%20&amp;plus;%20%5Clambda_1%20R%28f_v%29%20%5Cright%29"/>
      <p>
       这里的
       <img alt="L(y_i, f_v(x_i))" class="mathcode" src="https://latex.csdn.net/eq?L%28y_i%2C%20f_v%28x_i%29%29"/>
       是监督学习中的损失函数，用于计算分类器对标注数据的预测误差，
       <img alt="f_v(x_i)" class="mathcode" src="https://latex.csdn.net/eq?f_v%28x_i%29"/>
       是分类器
       <img alt="v" class="mathcode" src="https://latex.csdn.net/eq?v"/>
       对样本
       <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
       ​ 的预测，
       <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i"/>
       ​ 是实际标签。
       <img alt="\lambda_1 R(f_v)" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda_1%20R%28f_v%29"/>
       是正则化项，用于约束分类器模型的复杂度，避免过拟合。
      </p>
     </li>
     <li>
      <p>
       <strong>
        第二部分
       </strong>
       ：协同正则化损失
      </p>
      <img alt="\lambda_2 \sum_{u=1}^{M} \sum_{i=L+1}^{N} (f_u(x_i) - f_v(x_i))^2" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda_2%20%5Csum_%7Bu%3D1%7D%5E%7BM%7D%20%5Csum_%7Bi%3DL&amp;plus;1%7D%5E%7BN%7D%20%28f_u%28x_i%29%20-%20f_v%28x_i%29%29%5E2"/>
      <p>
       这个部分衡量不同分类器之间对无标注数据的预测一致性。对于每一个无标注数据
       <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
       ​，
       <img alt="f_u(x_i)" class="mathcode" src="https://latex.csdn.net/eq?f_u%28x_i%29"/>
       和
       <img alt="f_v(x_i)" class="mathcode" src="https://latex.csdn.net/eq?f_v%28x_i%29"/>
       是不同分类器的预测结果，通过最小化它们之间的差异来增强它们的协同作用。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      作用
     </strong>
     ：
    </p>
    <p>
     通过协同正则化，两个分类器不仅会在标注数据上进行优化，同时也会通过最小化它们在无标注数据上的不一致性来共同学习。
    </p>
    <p>
    </p>
    <h3 id="7%E3%80%81%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90" name="7%E3%80%81%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90">
     7、
     <strong>
      多视角学习的本质分析
     </strong>
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%AD%A6%E5%BE%97%E6%9B%B4%E5%A5%BD%3F" name="%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%9A%E8%A7%86%E8%A7%92%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%AD%A6%E5%BE%97%E6%9B%B4%E5%A5%BD%3F">
     （1）为什么多视角学习能学得更好?
    </h4>
    <ul>
     <li>
      学习过程实质上是搜索最好的分类器
     </li>
     <li>
      通过强迫多个分类器的预测一致性， 缩小了搜索空间
     </li>
     <li>
      希望在较少的训练数据能够找到最好的分类器
     </li>
    </ul>
    <h4 id="%EF%BC%882%EF%BC%89%E5%AF%B9%E4%BA%8E%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%9E%8D%E5%90%88%E5%A4%9A%E4%B8%AA%E5%88%86%E7%B1%BB%E5%99%A8" name="%EF%BC%882%EF%BC%89%E5%AF%B9%E4%BA%8E%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%9E%8D%E5%90%88%E5%A4%9A%E4%B8%AA%E5%88%86%E7%B1%BB%E5%99%A8">
     （2）对于测试数据，融合多个分类器
    </h4>
    <ul>
     <li>
      例如：投票、共识等
     </li>
    </ul>
    <h4 id="%EF%BC%883%EF%BC%89%E7%90%86%E8%AE%BA%E6%94%AF%E6%8C%81%EF%BC%9A%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%87%AA%E7%84%B6%E8%BF%87%E6%B8%A1" name="%EF%BC%883%EF%BC%89%E7%90%86%E8%AE%BA%E6%94%AF%E6%8C%81%EF%BC%9A%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%87%AA%E7%84%B6%E8%BF%87%E6%B8%A1">
     （3）理论支持：半监督学习和集成学习的自然过渡
    </h4>
    <ul>
     <li>
      集成学习观点：使用多个学习器，可将弱学习器性提升
     </li>
     <li>
      半监督学习观点：使用未标记样本，可将弱学习器性能提升
     </li>
    </ul>
    <h3 id="8%E3%80%81%E5%A4%9A%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" name="8%E3%80%81%E5%A4%9A%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">
     8、
     <strong>
      多视图的构造方法
     </strong>
    </h3>
    <p>
     <strong>
      在标注数据上训练多个模型：
     </strong>
    </p>
    <ul>
     <li>
      相同数据，不同结构的神经网络或不同的学习算法
     </li>
     <li>
      对有标签数据进行Bootstrap采样，对每个Bootstrap训练一个模型
     </li>
     <li>
      对数据（标注数据和无标签数据）增加噪声/数据增广
     </li>
     <li>
      多个不同辅助任务训练的基础模型生成的嵌入表示（Meta Co-Training）
     </li>
    </ul>
    <p>
     <strong>
      多个模型分别对无标签数据进行预测，若多个模型的结果一致（如超过 一半模型）
     </strong>
    </p>
    <ul>
     <li>
      将该无标签的数据的标签标为模型的预测结果，视为有标签数据
     </li>
     <li>
      只将该数据加入到不一致的那些模型（view）中
     </li>
    </ul>
    <h3 id="9%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E4%BE%8B%E5%AD%90" name="9%E3%80%81%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E4%BE%8B%E5%AD%90">
     9、协同训练的例子
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89Meta%20Co-Training%20(%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83)" name="%EF%BC%881%EF%BC%89Meta%20Co-Training%20(%E5%8D%8F%E5%90%8C%E8%AE%AD%E7%BB%83)">
     （1）
     <strong>
      Meta Co-Training (协同训练)
     </strong>
    </h4>
    <p>
     这部分展示了
     <strong>
      Meta Co-Training
     </strong>
     方法，它是一种半监督学习的策略，主要用于处理带有少量标注数据和大量未标注数据的情况。图中展示了两个模型
     <code>
      Model 1
     </code>
     和
     <code>
      Model 2
     </code>
     ，分别对未标注数据进行预测，并通过相互交换标注来提升模型的性能。
    </p>
    <p>
     <img alt="" height="302" src="https://i-blog.csdnimg.cn/direct/38bb2438dc904cf691a1c31e3f291ce2.png" width="575"/>
    </p>
    <ul>
     <li>
      <strong>
       图的结构
      </strong>
      ：
      <code>
       U
      </code>
      表示未标注数据，
      <code>
       L
      </code>
      表示标注数据。在模型训练过程中，模型相互合作（通过交换信息），使得每个模型的预测能够进一步提高准确性。最终，合并了两者的学习结果。
     </li>
     <li>
      <strong>
       数据集的结果
      </strong>
      ：展示了不同模型在单视图和双视图上的 Top-1 准确率。双视图策略相较于单视图策略能够显著提升准确率，尤其在数据较少时更为明显。
     </li>
    </ul>
    <p>
    </p>
    <h4 id="%EF%BC%882%EF%BC%89Pseudo-Label%20(%E4%BC%AA%E6%A0%87%E7%AD%BE)" name="%EF%BC%882%EF%BC%89Pseudo-Label%20(%E4%BC%AA%E6%A0%87%E7%AD%BE)">
     （2）Pseudo-Label (伪标签)
    </h4>
    <p>
     主要思想：伪标签的方法通过结合已标注数据的损失（
     <code>
      Llabel
     </code>
     ）和未标注数据的伪标签损失（
     <code>
      Lunlabel
     </code>
     ）来计算总损失。
     <strong>
      对于未标注的样本，对样本进行扰动，扰动前后分别使用模型进行预测，将其中的一个预测结果强制变成伪标签（即将可能性大的视为1，可能性小的视为0）。另一个预测结果和伪标签的交叉熵即为未标注数据的伪标签损失（对于一个好的模型轻微扰动前后的预测应该是相近的）。
     </strong>
     未标注数据的损失通过权重系数
     <code>
      α_t
     </code>
     进行加权，从而决定伪标签在训练中的影响程度。随着训练的进行，伪标签的权重逐渐增加（图中的右侧曲线）。
    </p>
    <p>
     <img alt="" height="272" src="https://i-blog.csdnimg.cn/direct/363e9094cbf645789fa7b3aef25b33fe.png" width="655"/>
    </p>
    <p>
     <strong>
      训练过程
     </strong>
     ：最初，伪标签对损失函数的贡献较小（目的是首先要以有标注的样本为主），但随着训练进展，伪标签的影响逐渐加大，模型能够更加依赖伪标签来改进预测。
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%CF%80-Model%20(%CF%80-%E6%A8%A1%E5%9E%8B)" name="%EF%BC%883%EF%BC%89%CF%80-Model%20(%CF%80-%E6%A8%A1%E5%9E%8B)">
     （3）π-Model (π-模型)
    </h4>
    <p>
     为什么叫 π-模型：因为模型对样本进行两次增广长得像平躺的 π 。
    </p>
    <p>
     <strong>
      核心思想
     </strong>
     ：和伪标签类似。模型对有标签和无标签的样本都进行两次增广（扰动），分别让模型进行预测，对于有标签的样本，让其结果和真实值进计算交叉熵损失，对于无标签的样本，让其两个的输出尽可能相近，所以它的损失是他们之间的差异。最后加权有标签损失和无标签损失得到总的损失。
    </p>
    <p>
     <img alt="" height="257" src="https://i-blog.csdnimg.cn/direct/ed7b157d3379486e96544e4ae98473ec.png" width="610"/>
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%884%EF%BC%89Temporal%20Ensembling%20(%E6%97%B6%E5%BA%8F%E9%9B%86%E6%88%90)" name="%EF%BC%884%EF%BC%89Temporal%20Ensembling%20(%E6%97%B6%E5%BA%8F%E9%9B%86%E6%88%90)">
     （4）Temporal Ensembling (时序集成)
    </h4>
    <p>
     <strong>
      核心思想
     </strong>
     ：时序集成方法借鉴了 π-模型的思想，但它通过多个过去时刻的模型预测结果的加权组合进行集成，加权值通常是指数衰减，进一步提高模型的泛化能力。
    </p>
    <ul>
     <li>
      <strong>
       模型结构
      </strong>
      ：通过 EMA（Exponential Moving Average）存储过去时刻的模型参数或预测结果，并将这些结果进行加权平均，用于计算最终损失。
     </li>
     <li>
      <strong>
       优势
      </strong>
      ：通过考虑多个历史时刻的模型预测，可以减少过拟合，并提升在未标注数据上的表现。
     </li>
    </ul>
    <p>
     <img alt="" height="361" src="https://i-blog.csdnimg.cn/direct/fffc4d7e7e8f4e4db75f74c751d0c32a.png" width="625"/>
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%885%EF%BC%89Mean%20Teacher%20(%E5%B9%B3%E5%9D%87%E6%95%99%E5%B8%88%E6%A8%A1%E5%9E%8B)" name="%EF%BC%885%EF%BC%89Mean%20Teacher%20(%E5%B9%B3%E5%9D%87%E6%95%99%E5%B8%88%E6%A8%A1%E5%9E%8B)">
     （5）
     <strong>
      Mean Teacher (平均教师模型)
     </strong>
    </h4>
    <p>
     平均教师模型是半监督学习中的经典方法之一，类似于时序集成，但指数平均的不是预测值，而是模型参数，它的核心思想是通过一个“学生模型”和一个“教师模型”来协同训练。
    </p>
    <ul>
     <li>
      <strong>
       结构说明
      </strong>
      ：在该方法中，学生模型和教师模型共享参数。学生模型是普通的神经网络，而教师模型通过 EMA 更新。教师模型的预测结果用于指导学生模型的学习，从而使得学生模型逐步学习到更好的表示。
     </li>
     <li>
      <strong>
       优势
      </strong>
      ：教师模型的稳定性和一致性有助于提高学生模型的性能，尤其是在缺乏标注数据时。
     </li>
    </ul>
    <p>
     <img alt="" height="234" src="https://i-blog.csdnimg.cn/direct/6ce8d4ceef4341beb597eb4b2e647749.png" width="610"/>
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%886%EF%BC%89Adversarial%20Training%20(%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83)" name="%EF%BC%886%EF%BC%89Adversarial%20Training%20(%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83)">
     （6）Adversarial Training (对抗训练)
    </h4>
    <p>
     对抗训练通过生成具有挑战性的对抗样本来训练模型。该方法通过对图像生成两个不同的视角（或对抗样本），并确保模型在这两个视角下的预测一致。
    </p>
    <ul>
     <li>
      <strong>
       模型结构
      </strong>
      ：图中展示了如何利用两个不同的视角（first view 和 second view）生成对抗样本，并通过计算它们之间的预测差异来强化模型的鲁棒性。
     </li>
     <li>
      <strong>
       KL Divergence
      </strong>
      ：两种视角之间的预测差异通过 KL 散度来衡量，目标是减少这两个视角之间的差异，从而提升模型对未标注数据的适应能力。
     </li>
    </ul>
    <p>
     <img alt="" height="332" src="https://i-blog.csdnimg.cn/direct/242da6ad89fd464d970a28480719b123.png" width="592"/>
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%887%EF%BC%89MixUp" name="%EF%BC%887%EF%BC%89MixUp">
     （7）MixUp
    </h4>
    <p>
     <strong>
      MixUp
     </strong>
     是一种数据增强技术，主要通过对两张图像进行加权组合来生成新的图像，从而增强模型的鲁棒性。它通过生成新的样本和目标来改善模型的泛化能力，尤其是在缺乏标注数据的情况下。
    </p>
    <p>
     <img alt="" height="329" src="https://i-blog.csdnimg.cn/direct/cfcbfa09e9884fca82225355635db760.png" width="613"/>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        过程
       </strong>
       ：
      </p>
      <ul>
       <li>
        图中左侧的
        <code>
         Labeled Sample
        </code>
        表示标注数据，
        <code>
         (xi, yi)
        </code>
        是输入图像和标签。
       </li>
       <li>
        图中右侧的
        <code>
         Unlabeled Samples
        </code>
        表示未标注数据，
        <code>
         (uj)
        </code>
        是未标注数据。
       </li>
       <li>
        MixUp 在未标注数据上使用
        <code>
         Mixλ(uj, uk)
        </code>
        ，这是对两张未标注图像
        <code>
         uj
        </code>
        和
        <code>
         uk
        </code>
        的加权组合，生成新的样本
        <code>
         um
        </code>
        。
       </li>
       <li>
        然后通过模型对每个样本（标注和未标注样本）进行预测，生成预测结果
        <code>
         ŷi
        </code>
        ,
        <code>
         ŷj
        </code>
        , 和
        <code>
         ŷk
        </code>
        ，这些预测结果将被用于计算损失。
       </li>
       <li>
        最终的损失函数由两部分组成：
        <strong>
         监督损失
        </strong>
        （用于标注数据）和
        <strong>
         一致性损失
        </strong>
        （用于未标注数据）。一致性损失通过计算不同视角（增强过的数据）下的预测结果之间的差异来衡量。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        加权系数
       </strong>
       ：
      </p>
      <ul>
       <li>
        λ 值从 Beta 分布中抽取，控制混合比例。通过这个加权系数，可以控制两个样本在生成的新样本中的比例。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        公式
       </strong>
       ：
      </p>
      <ul>
       <li>
        <code>
         λ ∼ Beta(α, α)
        </code>
        ：表示从 Beta 分布中抽取一个值 λ。
       </li>
       <li>
        <code>
         λ' = max(λ, 1 - λ)
        </code>
        ：确保 λ 在 [0, 1] 范围内。
       </li>
       <li>
        生成的加权样本和标签：
        <code>
         x' = λ * x1 + (1 - λ) * x2
        </code>
        ，
        <code>
         p' = λ * p1 + (1 - λ) * p2
        </code>
        。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h4 id="%EF%BC%888%EF%BC%89MixMatch" name="%EF%BC%888%EF%BC%89MixMatch">
     （8）MixMatch
    </h4>
    <p>
     <strong>
      MixMatch
     </strong>
     是结合了多种技术的方法，它结合了 MixUp 和多种数据增强策略，目的是提高半监督学习的效果。MixMatch 通过对未标注数据进行多次数据增强，然后利用平均值和锐化操作来生成新的目标。
    </p>
    <p>
     <img alt="" height="188" src="https://i-blog.csdnimg.cn/direct/19fb9e9a8e2c4247821e359dae341889.png" width="651"/>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        过程
       </strong>
       ：
      </p>
      <ul>
       <li>
        图中展示了未标注图像的多次增强（
        <code>
         K augmentations
        </code>
        ），即对每个未标注图像进行多次不同的增强操作。
       </li>
       <li>
        经过增强的每个图像被送入分类器进行预测。
       </li>
       <li>
        MixMatch 通过对多次增强的结果进行平均（
        <code>
         Average
        </code>
        ），得到每个图像的最终预测结果。
       </li>
       <li>
        然后，通过对这些平均结果进行“锐化”操作（
        <code>
         Sharpen
        </code>
        ），从而得到最终的伪标签，这些伪标签被用于半监督学习中的训练。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        优势
       </strong>
       ：
      </p>
      <ul>
       <li>
        <strong>
         数据增强
        </strong>
        ：通过对同一未标注数据进行多次增强，MixMatch 通过多样化的视角来增加数据的多样性。
       </li>
       <li>
        <strong>
         平均化与锐化
        </strong>
        ：通过对预测结果的平均化和锐化，MixMatch 能够平滑预测，同时增加最终目标的可信度，提升模型的泛化能力。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B" name="%E5%9B%9B%E3%80%81%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B">
     四、生成模型
    </h2>
    <h3 id="1%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0" name="1%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0">
     1、生成式模型概述
    </h3>
    <p>
     假设所有数据（带标签&amp;不带标签）都由一个潜在的模型生成
    </p>
    <ul>
     <li>
      模型参数将无标记数据与学习目标联系起来
     </li>
     <li>
      无标记数据的标记可视为模型的缺失参数，通常可基于EM算 法进行极大似然估计求解
     </li>
    </ul>
    <h3 id="2%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0" name="2%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">
     2、生成式模型用于半监督学习
    </h3>
    <p>
     <strong>
      生成式模型假设：
     </strong>
    </p>
    <ul>
     <li>
      完全的生成式模型
      <img alt="p(X, y | \theta)" class="mathcode" src="https://latex.csdn.net/eq?p%28X%2C%20y%20%7C%20%5Ctheta%29"/>
     </li>
    </ul>
    <p>
     <strong>
      生成式模型用于半监督学习：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       我们所感兴趣的量：
      </p>
      <img alt="p(X_L, y_L, X_U | \theta) = \sum_{y_u} p(X_L, y_L, X_U, y_u | \theta)" class="mathcode" src="https://latex.csdn.net/eq?p%28X_L%2C%20y_L%2C%20X_U%20%7C%20%5Ctheta%29%20%3D%20%5Csum_%7By_u%7D%20p%28X_L%2C%20y_L%2C%20X_U%2C%20y_u%20%7C%20%5Ctheta%29"/>
      <p>
       其中，
       <img alt="X_L" class="mathcode" src="https://latex.csdn.net/eq?X_L"/>
       ​ 是带标签的数据，
       <img alt="X_U" class="mathcode" src="https://latex.csdn.net/eq?X_U"/>
       ​ 是未标注的数据，
       <img alt="y_L" class="mathcode" src="https://latex.csdn.net/eq?y_L"/>
       ​ 是带标签数据的标签，
       <img alt="y_u" class="mathcode" src="https://latex.csdn.net/eq?y_u"/>
       ​ 是未标注数据的标签，
       <img alt="\theta" class="mathcode" src="https://latex.csdn.net/eq?%5Ctheta"/>
       是模型参数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        寻找
       </strong>
       <img alt="\theta" class="mathcode" src="https://latex.csdn.net/eq?%5Ctheta"/>
       的极大似然估计，或最大后验估计（贝叶斯估计）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      生成式模型的例子：
     </strong>
    </p>
    <p>
     在半监督学习中经常使用:
    </p>
    <ul>
     <li>
      高斯混合模型(GMM)
     </li>
     <li>
      混合多项分布 (朴素贝叶斯)
     </li>
     <li>
      隐马尔科夫模型(HMM)
     </li>
    </ul>
    <p>
    </p>
    <h3 id="3%E3%80%81%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8BGMM" name="3%E3%80%81%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8BGMM">
     3、
     <strong>
      高斯混合模型
     </strong>
     GMM
    </h3>
    <p>
     生成式模型中的
     <strong>
      高斯混合模型 (GMM)
     </strong>
     是一种常用于半监督学习的概率模型。在此模型中，我们假设数据集来自于多个高斯分布的混合，每个高斯分布代表一个潜在的类别。这些类别的参数包括均值、协方差和类别的概率。
    </p>
    <h4 id="%EF%BC%881%EF%BC%89%E4%BB%85%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE%E7%9A%84%20GMM%EF%BC%88%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%89" name="%EF%BC%881%EF%BC%89%E4%BB%85%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE%E7%9A%84%20GMM%EF%BC%88%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%89">
     （1）
     <strong>
      仅使用带标签数据的 GMM（最大似然估计）
     </strong>
    </h4>
    <p>
     对于简单的二分类任务，GMM可以通过最大似然估计（MLE）来估计参数。具体来说，假设我们仅使用带标签的数据
     <img alt="X_L, y_L" class="mathcode" src="https://latex.csdn.net/eq?X_L%2C%20y_L"/>
     ，其目标是最大化似然函数。
    </p>
    <ul>
     <li>
      <p>
       计算对数似然函数：
      </p>
      <img alt="\ln p(X_L, y_L | \theta) = \sum_{i=1}^{L} \ln(p(y_i | \theta)p(x_i | y_i, \theta))" class="mathcode" src="https://latex.csdn.net/eq?%5Cln%20p%28X_L%2C%20y_L%20%7C%20%5Ctheta%29%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20%5Cln%28p%28y_i%20%7C%20%5Ctheta%29p%28x_i%20%7C%20y_i%2C%20%5Ctheta%29%29"/>
      <p>
       这里，
       <img alt="\theta" class="mathcode" src="https://latex.csdn.net/eq?%5Ctheta"/>
       是模型参数，包括高斯分布的均值和协方差矩阵。
      </p>
     </li>
     <li>
      <p>
       <strong>
        MLE 计算过程
       </strong>
       ：
       <br/>
       使用最大似然估计方法，模型会根据带标签数据来计算高斯分布的频率（即每个类别的比例），样本均值和样本协方差。GMM通过估计这些参数来拟合数据。
      </p>
     </li>
    </ul>
    <h4 id="%EF%BC%882%EF%BC%89%E8%80%83%E8%99%91%E5%B8%A6%E6%A0%87%E7%AD%BE%E5%92%8C%E6%9C%AA%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E7%9A%84%20GMM" name="%EF%BC%882%EF%BC%89%E8%80%83%E8%99%91%E5%B8%A6%E6%A0%87%E7%AD%BE%E5%92%8C%E6%9C%AA%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E7%9A%84%20GMM">
     （2）
     <strong>
      考虑带标签和未标注数据的 GMM
     </strong>
    </h4>
    <p>
     对于半监督学习，我们不仅使用带标签的数据，还会考虑未标注的数据
     <img alt="X_U" class="mathcode" src="https://latex.csdn.net/eq?X_U"/>
     ​，模型需要处理带标签和未标注数据的混合情况。这个过程通常涉及对未标注数据的“伪标注”，即通过估计类别概率来推断它们的标签。
    </p>
    <ul>
     <li>
      <p>
       计算包含未标注数据的对数似然函数：
      </p>
      <img alt="\ln p(X_L, y_L, X_U | \theta) = \sum_{i=1}^{L} \ln(p(y_i | \theta)p(x_i | y_i, \theta)) + \sum_{i=L+1}^{L+U} \ln(\sum_{y_i=1}^K p(y_i | \theta)p(x_i | y_i, \theta))" class="mathcode" src="https://latex.csdn.net/eq?%5Cln%20p%28X_L%2C%20y_L%2C%20X_U%20%7C%20%5Ctheta%29%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20%5Cln%28p%28y_i%20%7C%20%5Ctheta%29p%28x_i%20%7C%20y_i%2C%20%5Ctheta%29%29%20&amp;plus;%20%5Csum_%7Bi%3DL&amp;plus;1%7D%5E%7BL&amp;plus;U%7D%20%5Cln%28%5Csum_%7By_i%3D1%7D%5EK%20p%28y_i%20%7C%20%5Ctheta%29p%28x_i%20%7C%20y_i%2C%20%5Ctheta%29%29"/>
      <p>
       这个式子包括了两个部分：一部分是带标签数据的对数似然，另一部分是对未标注数据的对数似然，其中我们对每个未标注样本进行类别推断。
      </p>
     </li>
     <li>
      <p>
       <strong>
        EM算法
       </strong>
       ：由于MLE计算可能非常复杂，尤其是当涉及未标注数据时，常用
       <strong>
        EM（期望最大化）算法（迭代）
       </strong>
       来优化参数。
      </p>
      <ul>
       <li>
        <strong>
         E步
        </strong>
        ：根据当前的模型参数对未标注数据进行分类估计，计算每个数据点属于各类别的后验概率。
       </li>
       <li>
        <strong>
         M步
        </strong>
        ：更新模型参数（均值、协方差和类别概率），同时使用带标签数据和伪标签数据来估计模型参数。
       </li>
       <li>
        重复上面步骤（迭代）
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="%EF%BC%883%EF%BC%89EM%E7%AE%97%E6%B3%95%E5%9C%A8%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" name="%EF%BC%883%EF%BC%89EM%E7%AE%97%E6%B3%95%E5%9C%A8%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">
     （3）
     <strong>
      EM算法在高斯混合模型中的应用
     </strong>
    </h4>
    <p>
     <strong>
      EM算法
     </strong>
     在高斯混合模型中的应用包含了三个主要步骤：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        初始化
       </strong>
       ：在带标签数据
       <img alt="(X_L, y_L)" class="mathcode" src="https://latex.csdn.net/eq?%28X_L%2C%20y_L%29"/>
       上，使用最大似然估计（MLE）来估计参数
       <img alt="\theta = \{\pi, \mu, \Sigma\}" class="mathcode" src="https://latex.csdn.net/eq?%5Ctheta%20%3D%20%5C%7B%5Cpi%2C%20%5Cmu%2C%20%5CSigma%5C%7D"/>
       。
      </p>
      <ul>
       <li>
        类别的比例：
        <img alt="\pi_k = \frac{N_k}{L}" class="mathcode" src="https://latex.csdn.net/eq?%5Cpi_k%20%3D%20%5Cfrac%7BN_k%7D%7BL%7D"/>
       </li>
       <li>
        类别的均值：
        <img alt="\mu_k = \frac{1}{N_k} \sum_{y_i = k} x_i" class="mathcode" src="https://latex.csdn.net/eq?%5Cmu_k%20%3D%20%5Cfrac%7B1%7D%7BN_k%7D%20%5Csum_%7By_i%20%3D%20k%7D%20x_i"/>
       </li>
       <li>
        类别的协方差矩阵：
        <img alt="\Sigma_k = \frac{1}{N_k} \sum_{y_i = k} (x_i - \mu_k)(x_i - \mu_k)^T" class="mathcode" src="https://latex.csdn.net/eq?%5CSigma_k%20%3D%20%5Cfrac%7B1%7D%7BN_k%7D%20%5Csum_%7By_i%20%3D%20k%7D%20%28x_i%20-%20%5Cmu_k%29%28x_i%20-%20%5Cmu_k%29%5ET"/>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        E步
       </strong>
       ：计算每个未标注样本的类别概率，即估计未标注数据属于每个类别的后验概率：
      </p>
      <img alt="\gamma(z_{i,k}) = p(y = k | x_i, \theta) = \frac{\pi_k N(x_i | \mu_k, \Sigma_k)}{\sum_{k'=1}^K \pi_{k'} N(x_i | \mu_{k'}, \Sigma_{k'})}" class="mathcode" src="https://latex.csdn.net/eq?%5Cgamma%28z_%7Bi%2Ck%7D%29%20%3D%20p%28y%20%3D%20k%20%7C%20x_i%2C%20%5Ctheta%29%20%3D%20%5Cfrac%7B%5Cpi_k%20N%28x_i%20%7C%20%5Cmu_k%2C%20%5CSigma_k%29%7D%7B%5Csum_%7Bk%27%3D1%7D%5EK%20%5Cpi_%7Bk%27%7D%20N%28x_i%20%7C%20%5Cmu_%7Bk%27%7D%2C%20%5CSigma_%7Bk%27%7D%29%7D"/>
      <p>
       其中
       <img alt="\gamma(z_{i,k})" class="mathcode" src="https://latex.csdn.net/eq?%5Cgamma%28z_%7Bi%2Ck%7D%29"/>
       是类别
       <img alt="k" class="mathcode" src="https://latex.csdn.net/eq?k"/>
       的后验概率。
      </p>
     </li>
     <li>
      <p>
       <strong>
        M步
       </strong>
       ：使用带标签数据和未标注数据的伪标签来重新估计模型参数：
      </p>
      <ul>
       <li>
        更新类别的权重：
        <img alt="\pi_k = \frac{\sum_{x_i \in X_U} \gamma(z_{i,k}) + N_k}{N}" class="mathcode" src="https://latex.csdn.net/eq?%5Cpi_k%20%3D%20%5Cfrac%7B%5Csum_%7Bx_i%20%5Cin%20X_U%7D%20%5Cgamma%28z_%7Bi%2Ck%7D%29%20&amp;plus;%20N_k%7D%7BN%7D"/>
       </li>
       <li>
        更新均值：
        <img alt="\mu_k = \frac{\sum_{x_i \in X_U} \gamma(z_{i,k}) x_i + \sum_{x_i \in X_L, y_i = k} x_i}{\sum_{x_i \in X_U} \gamma(z_{i,k}) + N_k}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmu_k%20%3D%20%5Cfrac%7B%5Csum_%7Bx_i%20%5Cin%20X_U%7D%20%5Cgamma%28z_%7Bi%2Ck%7D%29%20x_i%20&amp;plus;%20%5Csum_%7Bx_i%20%5Cin%20X_L%2C%20y_i%20%3D%20k%7D%20x_i%7D%7B%5Csum_%7Bx_i%20%5Cin%20X_U%7D%20%5Cgamma%28z_%7Bi%2Ck%7D%29%20&amp;plus;%20N_k%7D"/>
       </li>
       <li>
        更新协方差矩阵：
        <img alt="\Sigma_k = \frac{\sum_{x_i \in X_U} \gamma(z_{i,k})(x_i - \mu_k)(x_i - \mu_k)^T + \sum_{x_i \in X_L, y_i = k} (x_i - \mu_k)(x_i - \mu_k)^T}{\sum_{x_i \in X_U} \gamma(z_{i,k}) + N_k}" class="mathcode" src="https://latex.csdn.net/eq?%5CSigma_k%20%3D%20%5Cfrac%7B%5Csum_%7Bx_i%20%5Cin%20X_U%7D%20%5Cgamma%28z_%7Bi%2Ck%7D%29%28x_i%20-%20%5Cmu_k%29%28x_i%20-%20%5Cmu_k%29%5ET%20&amp;plus;%20%5Csum_%7Bx_i%20%5Cin%20X_L%2C%20y_i%20%3D%20k%7D%20%28x_i%20-%20%5Cmu_k%29%28x_i%20-%20%5Cmu_k%29%5ET%7D%7B%5Csum_%7Bx_i%20%5Cin%20X_U%7D%20%5Cgamma%28z_%7Bi%2Ck%7D%29%20&amp;plus;%20N_k%7D"/>
       </li>
      </ul>
     </li>
    </ol>
    <h4 id="%EF%BC%884%EF%BC%89EM%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B" name="%EF%BC%884%EF%BC%89EM%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B">
     （4）
     <strong>
      EM算法的迭代过程
     </strong>
    </h4>
    <ul>
     <li>
      在图像中展示的过程，通过逐步迭代，模型不断调整其高斯分布参数，直到收敛。在每次迭代中，EM算法通过更新类别的均值和协方差，使得每个数据点在高斯混合模型中的概率分布逐渐变得更加准确。
     </li>
    </ul>
    <p>
     <strong>
      可视化迭代过程：
     </strong>
    </p>
    <p>
     <img alt="" height="297" src="https://i-blog.csdnimg.cn/direct/5d3ccf2b0efa40dab9352436afc70f38.png" width="518"/>
    </p>
    <p>
    </p>
    <h3 id="4%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%3A%20%E9%99%A4%E4%BA%86EM%E4%B9%8B%E5%A4%96" name="4%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%3A%20%E9%99%A4%E4%BA%86EM%E4%B9%8B%E5%A4%96">
     4、生成式模型用于半监督学习: 除了EM之外
    </h3>
    <p>
     核心是最大化：
     <img alt="p(X_L, y_L, X_U | \theta)" class="mathcode" src="https://latex.csdn.net/eq?p%28X_L%2C%20y_L%2C%20X_U%20%7C%20%5Ctheta%29"/>
    </p>
    <p>
     EM只是最大化该概率的一种方式
    </p>
    <p>
     其他能计算出使其最大化参数的方法也是可行的，如变分近似，或 直接优化
    </p>
    <p>
    </p>
    <h3 id="5%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" name="5%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">
     5、生成式模型用于半监督学习的优缺点
    </h3>
    <p>
     <strong>
      优势
     </strong>
    </p>
    <ul>
     <li>
      清晰，基于良好理论基础的概率框架
     </li>
     <li>
      如果模型接近真实的分布，将会非常有效
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      验证模型的正确性比较困难
     </li>
     <li>
      模型可辨识问题(Model identifiability)
     </li>
     <li>
      EM局部最优
     </li>
     <li>
      如果生成模型是错误，无监督数据会加重错误
     </li>
    </ul>
    <p>
    </p>
    <h3 id="6%E3%80%81%E5%87%8F%E5%B0%91%E9%A3%8E%E9%99%A9%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E6%96%B9%E6%B3%95" name="6%E3%80%81%E5%87%8F%E5%B0%91%E9%A3%8E%E9%99%A9%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E6%96%B9%E6%B3%95">
     6、减少风险的启发式方法
    </h3>
    <p>
     （1）需要更加仔细地构建生成模型，能正确建模目标任务
    </p>
    <p>
     例如：
     <strong>
      每个类别用多个高斯分布，而不是单个高斯分布
     </strong>
    </p>
    <p>
     （2）
     <strong>
      降低无标注数据的权重
     </strong>
    </p>
    <p>
     <img alt="\ln p(X_L, y_L | \theta) = \sum_{i=1}^{L} \ln(p(y_i | \theta)p(x_i | y_i, \theta)) + \lambda \sum_{i=L+1}^{L+U} \ln\left(\sum_{y_i=1}^2 p(y_i | \theta)p(x_i | y_i, \theta)\right)" class="mathcode" src="https://latex.csdn.net/eq?%5Cln%20p%28X_L%2C%20y_L%20%7C%20%5Ctheta%29%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20%5Cln%28p%28y_i%20%7C%20%5Ctheta%29p%28x_i%20%7C%20y_i%2C%20%5Ctheta%29%29%20&amp;plus;%20%5Clambda%20%5Csum_%7Bi%3DL&amp;plus;1%7D%5E%7BL&amp;plus;U%7D%20%5Cln%5Cleft%28%5Csum_%7By_i%3D1%7D%5E2%20p%28y_i%20%7C%20%5Ctheta%29p%28x_i%20%7C%20y_i%2C%20%5Ctheta%29%5Cright%29"/>
    </p>
    <p>
    </p>
    <h3 id="7%E3%80%81%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%3A%20%E8%81%9A%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%B3%95%EF%BC%88Cluster-and-label%EF%BC%89" name="7%E3%80%81%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%3A%20%E8%81%9A%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%B3%95%EF%BC%88Cluster-and-label%EF%BC%89">
     7、相关方法: 聚类标签法（Cluster-and-label）
    </h3>
    <p>
     除了使用概率生成模型，任何聚类算法都可以被用于半监督学习:
    </p>
    <ul>
     <li>
      在
      <img alt="x_1\cdot \cdot \cdot x_U" class="mathcode" src="https://latex.csdn.net/eq?x_1%5Ccdot%20%5Ccdot%20%5Ccdot%20x_U"/>
      运行某种你挑选的聚类算法.
     </li>
     <li>
      通过计算簇内占多数的类别，将簇内所有的点标记为该类别.
     </li>
     <li>
      优点: 利用现有算法的一种简单方法.
     </li>
     <li>
      缺点: 很难去分析它的好坏。如果簇假设不正确，结果会很差.
     </li>
    </ul>
    <p>
    </p>
    <h2 id="%E4%BA%94%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3SVM" name="%E4%BA%94%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3SVM">
     五、半监督SVM
    </h2>
    <h3 id="1%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8ES3VM%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%83%8C%E6%99%AF" name="1%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8ES3VM%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%83%8C%E6%99%AF">
     1、半监督学习与S3VM的基本背景
    </h3>
    <p>
     <strong>
      半监督学习
     </strong>
     介于监督学习和无监督学习之间，利用少量有标签数据和大量无标签数据进行训练。其基本假设是，无标签数据在某些方面能够帮助分类，特别是当数据在某种空间中呈现聚集趋势时。常见的半监督学习方法包括
     <strong>
      图模型
     </strong>
     、
     <strong>
      标签传播
     </strong>
     （Label Propagation）、
     <strong>
      半监督支持向量机 (S3VM)
     </strong>
     等。
    </p>
    <p>
     <strong>
      半监督SVM (S3VM)
     </strong>
     是一个结合了支持向量机（SVM）和无标签数据的半监督学习算法。它的目标是通过最小化有标签样本的分类误差，同时考虑无标签样本的影响，使得分类决策边界尽可能平滑。其核心思想是利用无标签数据帮助确定最优的分类超平面，同时尽量保持分类边界的最大间隔。
    </p>
    <h3 id="2%E3%80%81S3VM%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" name="2%E3%80%81S3VM%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">
     2、S3VM的核心思想
    </h3>
    <p>
     S3VM的基本假设是：
    </p>
    <ul>
     <li>
      <strong>
       对于所有可能的标签配置
      </strong>
      ，通过计算一个新的支持向量机来建立一个对应的模型，并选择使间隔最大化的那个模型。也就是说，S3VM不仅考虑有标签数据，还在优化过程中使用无标签数据的信息，从而更好地找到一个适合所有数据的分隔超平面。
     </li>
    </ul>
    <p>
     具体而言，S3VM目标是最小化以下目标函数：
    </p>
    <p>
     <img alt="\min_{f} \; \frac{1}{2} \| w \|^2 + C_1 \sum_{i=1}^{L} (1 - y_i f(x_i))_+ + C_2 \sum_{i=L+1}^{N} (1 - | f(x_i) |)_+" class="mathcode" src="https://latex.csdn.net/eq?%5Cmin_%7Bf%7D%20%5C%3B%20%5Cfrac%7B1%7D%7B2%7D%20%5C%7C%20w%20%5C%7C%5E2%20&amp;plus;%20C_1%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20%281%20-%20y_i%20f%28x_i%29%29_&amp;plus;%20&amp;plus;%20C_2%20%5Csum_%7Bi%3DL&amp;plus;1%7D%5E%7BN%7D%20%281%20-%20%7C%20f%28x_i%29%20%7C%29_&amp;plus;"/>
    </p>
    <p>
     其中：
    </p>
    <ul>
     <li>
      w 是SVM的权重，定义了分类超平面；
     </li>
     <li>
      <img alt="f(x_i)" class="mathcode" src="https://latex.csdn.net/eq?f%28x_i%29"/>
      是样本
      <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
      ​ 的预测输出；
     </li>
     <li>
      <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i"/>
      ​ 是样本
      <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
      ​ 的标签，L 是有标签数据的数量；
     </li>
     <li>
      <img alt="C_1" class="mathcode" src="https://latex.csdn.net/eq?C_1"/>
      ​ 和
      <img alt="C_2" class="mathcode" src="https://latex.csdn.net/eq?C_2"/>
      ​ 是正则化参数，控制有标签样本和无标签样本的影响；
     </li>
     <li>
      <img alt="(1 - y_i f(x_i))_+" class="mathcode" src="https://latex.csdn.net/eq?%281%20-%20y_i%20f%28x_i%29%29_&amp;plus;"/>
      ​ 是
      <strong>
       硬边距损失
      </strong>
      （对于有标签数据）；
     </li>
     <li>
      <img alt="(1 - |f(x_i)|)_+" class="mathcode" src="https://latex.csdn.net/eq?%281%20-%20%7Cf%28x_i%29%7C%29_&amp;plus;"/>
      ​ 是
      <strong>
       软边距损失
      </strong>
      （对于无标签数据）。
     </li>
    </ul>
    <h3 id="3%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3SVM%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98" name="3%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3SVM%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98">
     3、半监督SVM的优化问题
    </h3>
    <p>
     S3VM的优化目标是通过最大化所有数据点之间的间隔，构建一个最佳分类超平面，同时考虑无标签数据对分类决策边界的影响。具体来说，目标函数包含两部分：
    </p>
    <ol>
     <li>
      <strong>
       有标签数据的分类误差项
      </strong>
      ：用于最小化有标签数据点的分类误差；
     </li>
     <li>
      <strong>
       无标签数据的损失项
      </strong>
      ：用于调整无标签数据点对决策边界的影响。
     </li>
    </ol>
    <p>
     <strong>
      对比标准SVM：
     </strong>
    </p>
    <p>
     标准SVM只考虑有标签数据，目标是最大化“有标签数据的间隔”，并通过最小化有标签样本的分类误差来训练模型。
    </p>
    <p>
     而S3VM通过在目标函数中加入对无标签数据的控制，使得分类边界不仅符合有标签数据的约束，还考虑了无标签数据的分布情况，进而增强了分类模型的泛化能力。
    </p>
    <p>
     <strong>
      求解过程：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        目标函数：
       </strong>
       对于有标签样本，使用标准的SVM损失函数
       <img alt="\max(0, 1 - y_i f(x_i))" class="mathcode" src="https://latex.csdn.net/eq?%5Cmax%280%2C%201%20-%20y_i%20f%28x_i%29%29"/>
       ，对于无标签样本，使用类似的损失函数，但是对标签的“松弛”程度更大。无标签样本的目标是使它们的预测值
       <img alt="f(x_i)" class="mathcode" src="https://latex.csdn.net/eq?f%28x_i%29"/>
       尽可能接近0，即尽量不与已有标签发生冲突。
      </p>
     </li>
     <li>
      <p>
       <strong>
        优化过程：
       </strong>
       对上述目标函数求解权重参数 w 和偏置 b，即通过调整超平面来使损失最小化，平衡有标签数据的损失和无标签数据的损失。
      </p>
     </li>
    </ol>
    <h3 id="4%E3%80%81%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E4%B8%8E%E6%97%A0%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A9%E7%94%A8" name="4%E3%80%81%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E4%B8%8E%E6%97%A0%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A9%E7%94%A8">
     4、标签传播与无标签数据的利用
    </h3>
    <p>
     在S3VM中，无标签数据的利用方式类似于“标签传播”的思想。S3VM的关键是根据有标签数据确定模型，并根据无标签数据的分布来推断标签的潜在值。具体过程如下：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        标签传播 (Transductive SVM)
       </strong>
       ：
       <br/>
       无标签数据通过与有标签数据的关系被“推测”出标签。这种推测并不是直接预测类别，而是基于间隔的平滑性假设，即无标签数据应该位于有标签数据的附近或者边界附近。
      </p>
     </li>
     <li>
      <p>
       <strong>
        影响边界
       </strong>
       ：
       <br/>
       S3VM的目标是通过构造一个分类超平面，使得所有数据（包括有标签和无标签数据）之间的间隔最大化。无标签数据的作用是通过这些点的位置帮助“调整”超平面的位置，最大化整体数据集的分类间隔。
      </p>
     </li>
    </ol>
    <h3 id="5%E3%80%81S3VM%E7%9A%84%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0" name="5%E3%80%81S3VM%E7%9A%84%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">
     5、S3VM的目标函数和损失函数
    </h3>
    <p>
     目标函数的两个主要部分是：
    </p>
    <ul>
     <li>
      <strong>
       有标签数据的损失
      </strong>
      ：使有标签数据的分类误差最小，形式类似标准SVM。
     </li>
     <li>
      <strong>
       无标签数据的损失
      </strong>
      ：对于无标签样本，其损失函数为
      <img alt="(1 - |f(x_i)|)_+" class="mathcode" src="https://latex.csdn.net/eq?%281%20-%20%7Cf%28x_i%29%7C%29_&amp;plus;"/>
      ​，意图尽量减少其对分类边界的影响，且其对分类边界的影响逐渐减小，随着训练的进行，模型逐步修正对无标签数据的分类决策。
     </li>
    </ul>
    <p>
     通过最小化上述目标函数，S3VM模型能够在训练过程中平衡有标签数据和无标签数据之间的影响，从而找到一个适合整个数据集的分类边界。
    </p>
    <h3 id="6%E3%80%81%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%B1%82%E8%A7%A3%E9%9A%BE%E5%BA%A6" name="6%E3%80%81%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%B1%82%E8%A7%A3%E9%9A%BE%E5%BA%A6">
     6、训练过程与求解难度
    </h3>
    <p>
     S3VM的训练过程可以采用以下两种方法：
    </p>
    <ul>
     <li>
      <strong>
       精确方法：
       <strong>
        例如使用
       </strong>
       混合整数规划(Mixed Integer Programming)
      </strong>
      来准确求解最优模型，但是这种方法计算复杂度高，适合数据规模较小的情况。
     </li>
     <li>
      <strong>
       近似方法：
       <strong>
        例如使用
       </strong>
       梯度下降法(gradient descent)
      </strong>
      或
      <strong>
       自标记启发式方法
      </strong>
      （如S3VMlight），这些方法通过迭代优化逐步逼近最优解，适合大规模数据集。
     </li>
    </ul>
    <p>
     <strong>
      S3VMlight
     </strong>
     是针对S3VM的一个高效实现，能够在大规模数据集上进行训练。它通过局部组合搜索（Local Combinatorial Search）来逐步调整标签，并优化模型。
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       《S3VM light更详细的思想见附录1》
      </strong>
     </span>
    </p>
    <p>
    </p>
    <h3 id="7%E3%80%81S3VM%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98" name="7%E3%80%81S3VM%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98">
     7、S3VM的优势与挑战
    </h3>
    <p>
     <strong>
      优势：
     </strong>
    </p>
    <ul>
     <li>
      **适应性强：**S3VM可以在任何SVM的框架中应用，具有广泛的适用性。
     </li>
     <li>
      **数学框架清晰：**通过精确的数学公式，S3VM能够有效地解决多种半监督学习问题。
     </li>
    </ul>
    <p>
     <strong>
      挑战：
     </strong>
    </p>
    <ul>
     <li>
      **优化困难：**S3VM的优化过程比标准SVM复杂，需要处理标签的交互和无标签数据的影响。
     </li>
     <li>
      **局部最优问题：**类似于许多半监督学习方法，S3VM也可能面临局部最优解，难以找到全局最优解。
     </li>
    </ul>
    <h3 id="8%E3%80%81S3VM%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E9%99%85%E5%AE%9E%E7%8E%B0" name="8%E3%80%81S3VM%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E9%99%85%E5%AE%9E%E7%8E%B0">
     8、S3VM的应用与实际实现
    </h3>
    <ul>
     <li>
      **应用范围：**S3VM可以应用于任何需要处理标签稀缺或成本较高的情形，尤其在文本分类、图像识别等任务中表现良好。
     </li>
     <li>
      <strong>
       实际实现：
       <strong>
        常见的实现包括
        <strong>
         S3VMlight
        </strong>
        ，它是一个基于
       </strong>
       局部组合搜索
      </strong>
      的实现方法，能够通过迭代优化算法来逐步改进模型。
     </li>
    </ul>
    <h3 id="9%E3%80%81%E6%80%BB%E7%BB%93" name="9%E3%80%81%E6%80%BB%E7%BB%93">
     9、总结
    </h3>
    <p>
     半监督支持向量机 (S3VM) 结合了SVM的强大分类能力与无标签数据的潜在信息。通过构建一个优化问题，S3VM可以在有标签数据和无标签数据之间找到一个最佳的分类超平面，同时保持分类间隔的最大化。尽管它在理论和实际应用中都表现出了显著的优势，但其优化过程相对复杂，并且计算成本较高。
    </p>
    <p>
    </p>
    <h2 id="%E5%85%AD%E3%80%81%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95" name="%E5%85%AD%E3%80%81%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95">
     六、基于图的算法
    </h2>
    <h3 id="1%E3%80%81%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF" name="1%E3%80%81%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">
     1、问题背景与基本思路
    </h3>
    <p>
     在半监督学习场景中，我们通常只有一部分样本有标签(记为L)，而大部分样本没有标签(记为U)。基于图的半监督学习方法通过以下思路来利用无标签数据的结构信息：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        构建图：
       </strong>
       <br/>
       将所有样本（有标签与无标签）视为图中的节点，用边的权重表示样本之间的相似度（或距离的某种函数）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        平滑性假设（流形假设）：
       </strong>
       <br/>
       相似的样本（即在图上相邻或距离较近的节点）应当有“相似”的标签。
      </p>
      <ul>
       <li>
        在数学上，一种常见的“平滑性”约束可以表示为：若节点
        <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
        和节点
        <img alt="j" class="mathcode" src="https://latex.csdn.net/eq?j"/>
        在图上有较高权重
        <img alt="w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D"/>
        ​，则模型给出的函数值
        <img alt="f_i" class="mathcode" src="https://latex.csdn.net/eq?f_i"/>
        ​与
        <img alt="f_j" class="mathcode" src="https://latex.csdn.net/eq?f_j"/>
        ​应该相近。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        标签传播：
       </strong>
       <br/>
       根据已知的少量有标签样本，通过图结构将标签“扩散”或“传播”到无标签节点上。
      </p>
      <ul>
       <li>
        这通常可以通过最小化某种“平滑性”损失函数，或者通过随机游走的思想来实现。
       </li>
      </ul>
     </li>
    </ol>
    <h3 id="2%E3%80%81%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA" name="2%E3%80%81%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA">
     2、图的构建
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9" name="%EF%BC%881%EF%BC%89%E8%8A%82%E7%82%B9%E4%B8%8E%E8%BE%B9">
     （1）节点与边
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        节点(
        <img alt="\mathcal{V}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathcal%7BV%7D"/>
        )：
       </strong>
       <br/>
       包括所有训练样本，既包括有标签的样本集合
       <img alt="L" class="mathcode" src="https://latex.csdn.net/eq?L"/>
       ，也包括无标签的样本集合
       <img alt="U" class="mathcode" src="https://latex.csdn.net/eq?U"/>
       。记节点总数为
       <img alt="n" class="mathcode" src="https://latex.csdn.net/eq?n"/>
       。其中
       <img alt="|L| = l" class="mathcode" src="https://latex.csdn.net/eq?%7CL%7C%20%3D%20l"/>
       ，
       <img alt="|U| = u" class="mathcode" src="https://latex.csdn.net/eq?%7CU%7C%20%3D%20u"/>
       ，且
       <img alt="l + u = n" class="mathcode" src="https://latex.csdn.net/eq?l%20&amp;plus;%20u%20%3D%20n"/>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        边(
        <img alt="\mathcal{E}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathcal%7BE%7D"/>
        )及权重
        <img alt="w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D"/>
        ​：
       </strong>
       <br/>
       常见做法是基于样本特征向量之间的相似度来定义边的权重。例如，可以先根据欧式距离或核函数等得到相似度，再设定一个邻域（如k-近邻或 ε -半径球）来决定是否连接，以及连接边的权重大小。
       <br/>
       一种常见的相似度定义是：
      </p>
      <img alt="w_{ij} = \exp\left(-\frac{\|x_i - x_j\|^2}{\sigma^2}\right)" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D%20%3D%20%5Cexp%5Cleft%28-%5Cfrac%7B%5C%7Cx_i%20-%20x_j%5C%7C%5E2%7D%7B%5Csigma%5E2%7D%5Cright%29"/>
      <p>
       其中 σ 是一个平滑参数，用于控制相似度衰减的速度。若
       <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
       和
       <img alt="j" class="mathcode" src="https://latex.csdn.net/eq?j"/>
       不在彼此的k-近邻或距离超过 ε ，则可令
       <img alt="w_{ij} = 0" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D%20%3D%200"/>
       。
      </p>
     </li>
    </ul>
    <h4 id="%EF%BC%882%EF%BC%89%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5W%E4%B8%8E%E5%BA%A6%E7%9F%A9%E9%98%B5D" name="%EF%BC%882%EF%BC%89%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5W%E4%B8%8E%E5%BA%A6%E7%9F%A9%E9%98%B5D">
     （2）权重矩阵W与度矩阵D
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        权重矩阵
        <img alt="W\in \mathbb{R}^{n\times n}" class="mathcode" src="https://latex.csdn.net/eq?W%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%5Ctimes%20n%7D"/>
        ：
       </strong>
       <br/>
       由
       <img alt="w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D"/>
       ​组成的对称矩阵（若使用对称相似度），对角元素通常为0 (
       <img alt="w_{ii} = 0" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bii%7D%20%3D%200"/>
       )。
      </p>
     </li>
     <li>
      <p>
       <strong>
        度矩阵
        <img alt="D\in \mathbb{R}^{n\times n}" class="mathcode" src="https://latex.csdn.net/eq?D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%5Ctimes%20n%7D"/>
        ：
       </strong>
       <br/>
       对角矩阵，其对角元素
       <img alt="D_{ii} = \sum_{j} w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?D_%7Bii%7D%20%3D%20%5Csum_%7Bj%7D%20w_%7Bij%7D"/>
       ，即节点iii的度数（连接强度之和）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        图拉普拉斯矩阵
        <img alt="L\in \mathbb{R}^{n\times n}" class="mathcode" src="https://latex.csdn.net/eq?L%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%5Ctimes%20n%7D"/>
        ：
       </strong>
       <br/>
       一般定义为
      </p>
      <img alt="L = D - W" class="mathcode" src="https://latex.csdn.net/eq?L%20%3D%20D%20-%20W"/>
      <p>
       在图的平滑性中，L起到非常重要的作用。
      </p>
     </li>
    </ul>
    <p>
     在半监督学习中，我们通常把矩阵进行分块，按照有标签样本和无标签样本进行拆分。例如，将节点按照
     <img alt="\{1,\dots,l\}\cup\{l+1,\dots,l+u\}" class="mathcode" src="https://latex.csdn.net/eq?%5C%7B1%2C%5Cdots%2Cl%5C%7D%5Ccup%5C%7Bl&amp;plus;1%2C%5Cdots%2Cl&amp;plus;u%5C%7D"/>
     进行排序，则
    </p>
    <p>
     <img alt="W = \begin{pmatrix} W_{LL} &amp; W_{LU}\\ W_{UL} &amp; W_{UU} \end{pmatrix},\quad D = \begin{pmatrix} D_{LL} &amp; 0\\ 0 &amp; D_{UU} \end{pmatrix},\quad L = \begin{pmatrix} L_{LL} &amp; L_{LU}\\ L_{UL} &amp; L_{UU} \end{pmatrix}" class="mathcode" src="https://latex.csdn.net/eq?W%20%3D%20%5Cbegin%7Bpmatrix%7D%20W_%7BLL%7D%20%26%20W_%7BLU%7D%5C%5C%20W_%7BUL%7D%20%26%20W_%7BUU%7D%20%5Cend%7Bpmatrix%7D%2C%5Cquad%20D%20%3D%20%5Cbegin%7Bpmatrix%7D%20D_%7BLL%7D%20%26%200%5C%5C%200%20%26%20D_%7BUU%7D%20%5Cend%7Bpmatrix%7D%2C%5Cquad%20L%20%3D%20%5Cbegin%7Bpmatrix%7D%20L_%7BLL%7D%20%26%20L_%7BLU%7D%5C%5C%20L_%7BUL%7D%20%26%20L_%7BUU%7D%20%5Cend%7Bpmatrix%7D"/>
    </p>
    <p>
     这里下标L表示与有标签节点相关的行/列，下标U表示与无标签节点相关的行/列。
    </p>
    <h3 id="3%E3%80%81%E5%9B%BE%E7%9A%84%E5%B9%B3%E6%BB%91%E6%80%A7%E7%BA%A6%E6%9D%9F%E4%B8%8E%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0" name="3%E3%80%81%E5%9B%BE%E7%9A%84%E5%B9%B3%E6%BB%91%E6%80%A7%E7%BA%A6%E6%9D%9F%E4%B8%8E%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0">
     3、图的平滑性约束与目标函数
    </h3>
    <p>
     在图上，如果我们用向量
     <img alt="\mathbf{f} = (f_1, f_2, \dots, f_n)^T" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D%20%3D%20%28f_1%2C%20f_2%2C%20%5Cdots%2C%20f_n%29%5ET"/>
     表示对每个节点的“标签函数值”（若是分类，可用one-hot向量或实值打分表示），我们希望相连（相似度大）的节点函数值越相似越好。这常用下面的“平滑性”损失来度量：
    </p>
    <p>
     <img alt="S(\mathbf{f}) = \frac{1}{2}\sum_{i,j} w_{ij} \bigl(f_i - f_j\bigr)^2" class="mathcode" src="https://latex.csdn.net/eq?S%28%5Cmathbf%7Bf%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%2Cj%7D%20w_%7Bij%7D%20%5Cbigl%28f_i%20-%20f_j%5Cbigr%29%5E2"/>
    </p>
    <p>
     它可以写成矩阵形式(这里省略了
     <img alt="\frac12" class="mathcode" src="https://latex.csdn.net/eq?%5Cfrac12"/>
     ​常数因子不影响最终求解)：
    </p>
    <p>
     <img alt="S(\mathbf{f}) = \mathbf{f}^T L \,\mathbf{f}" class="mathcode" src="https://latex.csdn.net/eq?S%28%5Cmathbf%7Bf%7D%29%20%3D%20%5Cmathbf%7Bf%7D%5ET%20L%20%5C%2C%5Cmathbf%7Bf%7D"/>
    </p>
    <p>
     其中 L = D - W 就是图拉普拉斯矩阵。
    </p>
    <p>
     在半监督情形下，我们还要求在有标签的节点
     <img alt="i\in L" class="mathcode" src="https://latex.csdn.net/eq?i%5Cin%20L"/>
     上，
     <img alt="\mathbf{f}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D"/>
     必须“贴合”已有的标签
     <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i"/>
     ​ 。常见的做法有两种：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        硬约束(hard constraint)：
       </strong>
       <br/>
       有标签节点
       <img alt="i\in L" class="mathcode" src="https://latex.csdn.net/eq?i%5Cin%20L"/>
       的
       <img alt="f_i" class="mathcode" src="https://latex.csdn.net/eq?f_i"/>
       ​固定为
       <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i"/>
       ​，不参与自由优化，只在无标签节点U上优化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        软约束(soft constraint)：
       </strong>
       <br/>
       在有标签节点上加入一个与
       <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i"/>
       ​偏差的惩罚项，如
       <img alt="\sum_{i\in L}\lambda (f_i - y_i)^2" class="mathcode" src="https://latex.csdn.net/eq?%5Csum_%7Bi%5Cin%20L%7D%5Clambda%20%28f_i%20-%20y_i%29%5E2"/>
       。
       <br/>
       这种形式在后续“标签传播”(label spreading)等算法中会出现。
      </p>
     </li>
    </ol>
    <p>
     下文我们先以
     <strong>
      硬约束
     </strong>
     为例进行推导：即在
     <img alt="\mathbf{f}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D"/>
     中，前
     <img alt="l" class="mathcode" src="https://latex.csdn.net/eq?l"/>
     个有标签节点值固定，后u个无标签节点值需要通过最小化图的平滑性得到。
    </p>
    <p>
    </p>
    <h3 id="4%E3%80%81%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%9A%84%E8%A7%A3%E6%9E%90%E8%A7%A3%EF%BC%88%E7%A1%AC%E7%BA%A6%E6%9D%9F%E6%83%85%E5%86%B5%EF%BC%89" name="4%E3%80%81%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%9A%84%E8%A7%A3%E6%9E%90%E8%A7%A3%EF%BC%88%E7%A1%AC%E7%BA%A6%E6%9D%9F%E6%83%85%E5%86%B5%EF%BC%89">
     4、标签传播的解析解（硬约束情况）
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E5%88%86%E5%9D%97%E8%A1%A8%E7%A4%BA" name="%EF%BC%881%EF%BC%89%E5%88%86%E5%9D%97%E8%A1%A8%E7%A4%BA">
     （1）分块表示
    </h4>
    <p>
     令
     <img alt="\mathbf{f} = \begin{pmatrix}\mathbf{f}_L \\ \mathbf{f}_U\end{pmatrix}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%5Cmathbf%7Bf%7D_L%20%5C%5C%20%5Cmathbf%7Bf%7D_U%5Cend%7Bpmatrix%7D"/>
     ，其中：
    </p>
    <ul>
     <li>
      <img alt="\mathbf{f}_L\in \mathbb{R}^l" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_L%5Cin%20%5Cmathbb%7BR%7D%5El"/>
      ：已知标签(固定为
      <img alt="\mathbf{y}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7By%7D_L"/>
      ​)
     </li>
     <li>
      <img alt="\mathbf{f}_U\in \mathbb{R}^u" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_U%5Cin%20%5Cmathbb%7BR%7D%5Eu"/>
      ：未知标签，需要优化
     </li>
    </ul>
    <p>
     图拉普拉斯矩阵L相应地分块：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="L = \begin{pmatrix} L_{LL} &amp; L_{LU}\\ L_{UL} &amp; L_{UU} \end{pmatrix}" class="mathcode" src="https://latex.csdn.net/eq?L%20%3D%20%5Cbegin%7Bpmatrix%7D%20L_%7BLL%7D%20%26%20L_%7BLU%7D%5C%5C%20L_%7BUL%7D%20%26%20L_%7BUU%7D%20%5Cend%7Bpmatrix%7D"/>
    </p>
    <p>
     由于
     <img alt="\mathbf{f}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_L"/>
     ​固定，不作为优化变量，最小化目标函数
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="S(\mathbf{f}) = \mathbf{f}^T L \mathbf{f}" class="mathcode" src="https://latex.csdn.net/eq?S%28%5Cmathbf%7Bf%7D%29%20%3D%20%5Cmathbf%7Bf%7D%5ET%20L%20%5Cmathbf%7Bf%7D"/>
    </p>
    <p>
     等价于最小化
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="S(\mathbf{f}_U) = \begin{pmatrix}\mathbf{f}_L^T &amp; \mathbf{f}_U^T\end{pmatrix} \begin{pmatrix} L_{LL} &amp; L_{LU}\\ L_{UL} &amp; L_{UU} \end{pmatrix} \begin{pmatrix}\mathbf{f}_L \\ \mathbf{f}_U\end{pmatrix}" class="mathcode" src="https://latex.csdn.net/eq?S%28%5Cmathbf%7Bf%7D_U%29%20%3D%20%5Cbegin%7Bpmatrix%7D%5Cmathbf%7Bf%7D_L%5ET%20%26%20%5Cmathbf%7Bf%7D_U%5ET%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20L_%7BLL%7D%20%26%20L_%7BLU%7D%5C%5C%20L_%7BUL%7D%20%26%20L_%7BUU%7D%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%5Cmathbf%7Bf%7D_L%20%5C%5C%20%5Cmathbf%7Bf%7D_U%5Cend%7Bpmatrix%7D"/>
    </p>
    <p>
     展开后与
     <img alt="\mathbf{f}_U" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_U"/>
     ​相关的部分为：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="S(\mathbf{f}_U) = \mathbf{f}_U^T L_{UU} \mathbf{f}_U + 2 \mathbf{f}_U^T L_{UL} \mathbf{f}_L + \mathbf{f}_L^T L_{LL} \mathbf{f}_L" class="mathcode" src="https://latex.csdn.net/eq?S%28%5Cmathbf%7Bf%7D_U%29%20%3D%20%5Cmathbf%7Bf%7D_U%5ET%20L_%7BUU%7D%20%5Cmathbf%7Bf%7D_U%20&amp;plus;%202%20%5Cmathbf%7Bf%7D_U%5ET%20L_%7BUL%7D%20%5Cmathbf%7Bf%7D_L%20&amp;plus;%20%5Cmathbf%7Bf%7D_L%5ET%20L_%7BLL%7D%20%5Cmathbf%7Bf%7D_L"/>
    </p>
    <p>
     其中
     <img alt="\mathbf{f}_L^T L_{LL} \mathbf{f}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_L%5ET%20L_%7BLL%7D%20%5Cmathbf%7Bf%7D_L"/>
     ​是常数项，与
     <img alt="\mathbf{f}_U" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_U"/>
     ​无关，最小化时可以忽略。故可关注：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="S(\mathbf{f}_U) = \mathbf{f}_U^T L_{UU} \mathbf{f}_U + 2 \mathbf{f}_U^T L_{UL} \mathbf{f}_L" class="mathcode" src="https://latex.csdn.net/eq?S%28%5Cmathbf%7Bf%7D_U%29%20%3D%20%5Cmathbf%7Bf%7D_U%5ET%20L_%7BUU%7D%20%5Cmathbf%7Bf%7D_U%20&amp;plus;%202%20%5Cmathbf%7Bf%7D_U%5ET%20L_%7BUL%7D%20%5Cmathbf%7Bf%7D_L"/>
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E6%B1%82%E5%AF%BC%E5%B9%B6%E8%AE%BE%E4%B8%BA%E9%9B%B6" name="%EF%BC%882%EF%BC%89%E6%B1%82%E5%AF%BC%E5%B9%B6%E8%AE%BE%E4%B8%BA%E9%9B%B6">
     （2）求导并设为零
    </h4>
    <p>
     对
     <img alt="\mathbf{f}_U" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_U"/>
     ​求偏导并令其为零：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\frac{\partial S}{\partial \mathbf{f}_U} = 2 L_{UU} \mathbf{f}_U + 2 L_{UL} \mathbf{f}_L = 0" class="mathcode" src="https://latex.csdn.net/eq?%5Cfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20%5Cmathbf%7Bf%7D_U%7D%20%3D%202%20L_%7BUU%7D%20%5Cmathbf%7Bf%7D_U%20&amp;plus;%202%20L_%7BUL%7D%20%5Cmathbf%7Bf%7D_L%20%3D%200"/>
    </p>
    <p>
     因此得到
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="L_{UU}\,\mathbf{f}_U + L_{UL}\,\mathbf{f}_L = 0" class="mathcode" src="https://latex.csdn.net/eq?L_%7BUU%7D%5C%2C%5Cmathbf%7Bf%7D_U%20&amp;plus;%20L_%7BUL%7D%5C%2C%5Cmathbf%7Bf%7D_L%20%3D%200"/>
    </p>
    <p>
     假设
     <img alt="L_{UU}" class="mathcode" src="https://latex.csdn.net/eq?L_%7BUU%7D"/>
     ​可逆(在实际中，常需要对L进行某些正则化，或保证图是连通的并在无标签部分足够“非退化”以使
     <img alt="L_{UU}" class="mathcode" src="https://latex.csdn.net/eq?L_%7BUU%7D"/>
     ​可逆)，则
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\mathbf{f}_U = - L_{UU}^{-1} L_{UL}\,\mathbf{f}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_U%20%3D%20-%20L_%7BUU%7D%5E%7B-1%7D%20L_%7BUL%7D%5C%2C%5Cmathbf%7Bf%7D_L"/>
    </p>
    <p>
     这就是一个闭式解，表示无标签节点的函数值可由有标签节点的值通过图拉普拉斯矩阵的子块来计算。
    </p>
    <p>
     在实际实现时，为了数值稳定或满足一定正则化，通常会对 L 进行修改(例如加上一个小的对角项
     <img alt="\alpha I" class="mathcode" src="https://latex.csdn.net/eq?%5Calpha%20I"/>
     )，或者使用
     <strong>
      正规化拉普拉斯
      <img alt="L_{\text{sym}} = I - D^{-1/2} W D^{-1/2}" class="mathcode" src="https://latex.csdn.net/eq?L_%7B%5Ctext%7Bsym%7D%7D%20%3D%20I%20-%20D%5E%7B-1/2%7D%20W%20D%5E%7B-1/2%7D"/>
     </strong>
     等变体，但核心思想相同。
    </p>
    <p>
    </p>
    <h3 id="5%E3%80%81%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E8%A7%82%E7%82%B9%EF%BC%9A%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0" name="5%E3%80%81%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E8%A7%82%E7%82%B9%EF%BC%9A%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0">
     5、随机游走观点：标签传播的迭代实现
    </h3>
    <p>
     除了上面基于“最小化图平滑损失”并加上“已知标签硬约束”来求闭式解的思路，还有一条思路是**随机游走(RW, Random Walk)**或“传播矩阵” P 的迭代更新方法。常见的标签传播算法(如Zhu &amp; Ghahramani提出的Label Propagation)就是基于以下原理：
    </p>
    <ol>
     <li>
      <p>
       定义
       <strong>
        传播矩阵
        <img alt="P = D^{-1}W" class="mathcode" src="https://latex.csdn.net/eq?P%20%3D%20D%5E%7B-1%7DW"/>
       </strong>
       。
      </p>
      <ul>
       <li>
        其中
        <img alt="D^{-1}" class="mathcode" src="https://latex.csdn.net/eq?D%5E%7B-1%7D"/>
        是度矩阵的逆，对节点 i 做归一化，使得每一行的和为1。这样
        <img alt="P_{ij}" class="mathcode" src="https://latex.csdn.net/eq?P_%7Bij%7D"/>
        ​可以理解为“从节点
        <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
        随机跳到
        <img alt="j" class="mathcode" src="https://latex.csdn.net/eq?j"/>
        ”的转移概率。
       </li>
      </ul>
     </li>
     <li>
      <p>
       迭代更新公式
      </p>
      <ul>
       <li>
        记
        <img alt="\mathbf{F}^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t%29%7D"/>
        表示第
        <img alt="t" class="mathcode" src="https://latex.csdn.net/eq?t"/>
        次迭代时，每个节点的标签(或分布)打分。
       </li>
       <li>
        传播过程可以写作：
        <img alt="\mathbf{F}^{(t+1)} = P\,\mathbf{F}^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t&amp;plus;1%29%7D%20%3D%20P%5C%2C%5Cmathbf%7BF%7D%5E%7B%28t%29%7D"/>
        , 即每个节点的标签向邻居扩散或从邻居获取信息。
       </li>
       <li>
        若有标签节点在迭代过程中保持不变(硬约束)，则在每次迭代时，将有标签节点重新置为其真实标签，或使用“
        <img alt="\alpha" class="mathcode" src="https://latex.csdn.net/eq?%5Calpha"/>
        -重启”方式进行修正(见后述)。
       </li>
      </ul>
     </li>
     <li>
      <p>
       收敛分析
      </p>
      <ul>
       <li>
        在一定条件下，该迭代会收敛到一个平稳分布
        <img alt="\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*"/>
        ，此时满足
        <img alt="\mathbf{F}^* = P\,\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%20%3D%20P%5C%2C%5Cmathbf%7BF%7D%5E*"/>
        。
       </li>
       <li>
        如果再考虑“有标签节点保持固定”的操作，可以通过修改更新规则或在每次迭代后重置有标签节点为真值，最终无标签节点的值也会稳定。
       </li>
      </ul>
     </li>
    </ol>
    <h4 id="%EF%BC%881%EF%BC%89%E5%B8%A6%E6%9C%89%E2%80%9C%E4%BF%9D%E6%8C%81%E6%9C%89%E6%A0%87%E7%AD%BE%E8%8A%82%E7%82%B9%E4%B8%8D%E5%8F%98%E2%80%9D%E7%9A%84%E4%BF%AE%E6%AD%A3" name="%EF%BC%881%EF%BC%89%E5%B8%A6%E6%9C%89%E2%80%9C%E4%BF%9D%E6%8C%81%E6%9C%89%E6%A0%87%E7%AD%BE%E8%8A%82%E7%82%B9%E4%B8%8D%E5%8F%98%E2%80%9D%E7%9A%84%E4%BF%AE%E6%AD%A3">
     （1）带有“保持有标签节点不变”的修正
    </h4>
    <p>
     一个常见实现是：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\mathbf{F}^{(t+1)} = \alpha P\,\mathbf{F}^{(t)} + (1-\alpha)\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t&amp;plus;1%29%7D%20%3D%20%5Calpha%20P%5C%2C%5Cmathbf%7BF%7D%5E%7B%28t%29%7D%20&amp;plus;%20%281-%5Calpha%29%5Cmathbf%7BY%7D"/>
    </p>
    <p>
     其中
     <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
     是只在有标签节点上非零(为真实标签)，在无标签节点上为0的矩阵/向量。
    </p>
    <ul>
     <li>
      <img alt="\alpha\in(0,1)" class="mathcode" src="https://latex.csdn.net/eq?%5Calpha%5Cin%280%2C1%29"/>
      是平衡参数，控制每一步对邻居信息的采纳程度与对原始标签信息的保留程度。
     </li>
     <li>
      这种算法也称为
      <strong>
       标签传播Label Spreading
      </strong>
      ，因其在邻域中不断平滑 / 扩散的过程。
     </li>
    </ul>
    <p>
     在足够多次迭代后，
     <img alt="\mathbf{F}^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t%29%7D"/>
     会收敛到一组稳定解
     <img alt="\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*"/>
     ，并且有标签节点与无标签节点之间达成某种平滑一致性。
    </p>
    <p>
    </p>
    <h3 id="6.%20%E5%85%B6%E4%BB%96%E6%8E%A8%E5%AF%BC%E5%8F%8A%E5%8F%98%E4%BD%93" name="6.%20%E5%85%B6%E4%BB%96%E6%8E%A8%E5%AF%BC%E5%8F%8A%E5%8F%98%E4%BD%93">
     6. 其他推导及变体
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E8%A7%A3" name="%EF%BC%881%EF%BC%89%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E8%A7%A3">
     （1）矩阵形式的随机游走解
    </h4>
    <p>
     在随机游走框架中，若定义转移矩阵
     <img alt="P = D^{-1}W" class="mathcode" src="https://latex.csdn.net/eq?P%20%3D%20D%5E%7B-1%7DW"/>
     ，并将节点按有标签(L)和无标签(U)进行分块，可写成：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="P = \begin{pmatrix} P_{LL} &amp; P_{LU}\\ P_{UL} &amp; P_{UU} \end{pmatrix}" class="mathcode" src="https://latex.csdn.net/eq?P%20%3D%20%5Cbegin%7Bpmatrix%7D%20P_%7BLL%7D%20%26%20P_%7BLU%7D%5C%5C%20P_%7BUL%7D%20%26%20P_%7BUU%7D%20%5Cend%7Bpmatrix%7D"/>
    </p>
    <p>
     令
     <img alt="\mathbf{F}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_L"/>
     ​为已知标签(
     <img alt="l" class="mathcode" src="https://latex.csdn.net/eq?l"/>
     个)，
     <img alt="\mathbf{F}_U" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_U"/>
     ​为未知标签(
     <img alt="u" class="mathcode" src="https://latex.csdn.net/eq?u"/>
     个)，则迭代更新有时可写成：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\mathbf{F}_U^{(t+1)} = P_{UU}\,\mathbf{F}_U^{(t)} + P_{UL}\,\mathbf{F}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_U%5E%7B%28t&amp;plus;1%29%7D%20%3D%20P_%7BUU%7D%5C%2C%5Cmathbf%7BF%7D_U%5E%7B%28t%29%7D%20&amp;plus;%20P_%7BUL%7D%5C%2C%5Cmathbf%7BF%7D_L"/>
    </p>
    <p>
     若我们要求收敛到
     <img alt="\mathbf{F}_U^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_U%5E*"/>
     ，则在稳定状态有
    </p>
    <p>
     ​​​​​​​
     <img alt="\mathbf{F}_U^* = P_{UU}\,\mathbf{F}_U^* + P_{UL}\,\mathbf{F}_L \quad \Longrightarrow\quad \mathbf{F}_U^* = (I - P_{UU})^{-1} P_{UL}\,\mathbf{F}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_U%5E*%20%3D%20P_%7BUU%7D%5C%2C%5Cmathbf%7BF%7D_U%5E*%20&amp;plus;%20P_%7BUL%7D%5C%2C%5Cmathbf%7BF%7D_L%20%5Cquad%20%5CLongrightarrow%5Cquad%20%5Cmathbf%7BF%7D_U%5E*%20%3D%20%28I%20-%20P_%7BUU%7D%29%5E%7B-1%7D%20P_%7BUL%7D%5C%2C%5Cmathbf%7BF%7D_L"/>
    </p>
    <p>
     这与前面拉普拉斯方法得到的形式在本质上是一致的(只是使用了
     <img alt="P" class="mathcode" src="https://latex.csdn.net/eq?P"/>
     矩阵而非
     <img alt="L" class="mathcode" src="https://latex.csdn.net/eq?L"/>
     矩阵)。在实际中，为了确保
     <img alt="(I - P_{UU})" class="mathcode" src="https://latex.csdn.net/eq?%28I%20-%20P_%7BUU%7D%29"/>
     可逆，通常要求图是连通并且
     <img alt="P_{UU}" class="mathcode" src="https://latex.csdn.net/eq?P_%7BUU%7D"/>
     ​的谱半径&lt;1（或者进行适当的正则化）。
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E5%8A%A0%E6%AD%A3%E5%88%99%E7%9A%84%E5%B9%B3%E6%BB%91%E6%8D%9F%E5%A4%B1" name="%EF%BC%882%EF%BC%89%E5%8A%A0%E6%AD%A3%E5%88%99%E7%9A%84%E5%B9%B3%E6%BB%91%E6%8D%9F%E5%A4%B1">
     （2）加正则的平滑损失
    </h4>
    <p>
     如前所述，有些算法会将硬约束改为软约束，目标函数可写为：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\min_{\mathbf{f}} \;\mathbf{f}^T L \mathbf{f} + \mu \|\mathbf{f} - \mathbf{Y}\|^2" class="mathcode" src="https://latex.csdn.net/eq?%5Cmin_%7B%5Cmathbf%7Bf%7D%7D%20%5C%3B%5Cmathbf%7Bf%7D%5ET%20L%20%5Cmathbf%7Bf%7D%20&amp;plus;%20%5Cmu%20%5C%7C%5Cmathbf%7Bf%7D%20-%20%5Cmathbf%7BY%7D%5C%7C%5E2"/>
    </p>
    <p>
     其中
     <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
     在有标签位置给出
     <img alt="y_i" class="mathcode" src="https://latex.csdn.net/eq?y_i"/>
     ​，在无标签位置可为0，
     <img alt="\mu" class="mathcode" src="https://latex.csdn.net/eq?%5Cmu"/>
     为平衡系数。
     <br/>
     通过对
     <img alt="\mathbf{f}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D"/>
     求导，最终也能得到一个闭式解：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\mathbf{f}^* = \bigl(L + \mu I\bigr)^{-1}\,\mu \mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D%5E*%20%3D%20%5Cbigl%28L%20&amp;plus;%20%5Cmu%20I%5Cbigr%29%5E%7B-1%7D%5C%2C%5Cmu%20%5Cmathbf%7BY%7D"/>
    </p>
    <p>
     这就是
     <strong>
      Label Spreading
     </strong>
     算法的一个典型形式。
    </p>
    <p>
    </p>
    <h3 id="7%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E7%A4%BA%E4%BE%8B" name="7%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E7%A4%BA%E4%BE%8B">
     7、总结与示例
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        核心思想：图+平滑性
       </strong>
      </p>
      <ul>
       <li>
        基于相似度构建图，通过最小化
        <img alt="\sum_{i,j} w_{ij}(f_i - f_j)^2" class="mathcode" src="https://latex.csdn.net/eq?%5Csum_%7Bi%2Cj%7D%20w_%7Bij%7D%28f_i%20-%20f_j%29%5E2"/>
        来保证相似样本标签尽量相似。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        两种主要推导思路：
       </strong>
      </p>
      <ol>
       <li>
        <strong>
         最小化平滑损失并对有标签点做硬约束
        </strong>
        ：
        <ul>
         <li>
          得到闭式解
          <img alt="\mathbf{f}_U = - L_{UU}^{-1} L_{UL}\,\mathbf{f}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D_U%20%3D%20-%20L_%7BUU%7D%5E%7B-1%7D%20L_%7BUL%7D%5C%2C%5Cmathbf%7Bf%7D_L"/>
         </li>
         <li>
          或在软约束下得到
          <img alt="\mathbf{f}^* = (L + \mu I)^{-1}\,\mu \mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D%5E*%20%3D%20%28L%20&amp;plus;%20%5Cmu%20I%29%5E%7B-1%7D%5C%2C%5Cmu%20%5Cmathbf%7BY%7D"/>
         </li>
        </ul>
       </li>
       <li>
        <strong>
         随机游走(或传播矩阵)迭代
        </strong>
        ：
        <ul>
         <li>
          定义
          <img alt="P = D^{-1}W" class="mathcode" src="https://latex.csdn.net/eq?P%20%3D%20D%5E%7B-1%7DW"/>
          ，反复迭代
          <img alt="\mathbf{F}^{(t+1)} = P \mathbf{F}^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t&amp;plus;1%29%7D%20%3D%20P%20%5Cmathbf%7BF%7D%5E%7B%28t%29%7D"/>
          ，并在有标签节点固定/重置标签。
         </li>
         <li>
          最终收敛得到
          <img alt="\mathbf{F}^* = (I - P_{UU})^{-1}P_{UL}\mathbf{F}_L" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%20%3D%20%28I%20-%20P_%7BUU%7D%29%5E%7B-1%7DP_%7BUL%7D%5Cmathbf%7BF%7D_L"/>
         </li>
        </ul>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        实现注意点：
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         权重矩阵W的构建
        </strong>
        ：选择合适的相似度度量、k-近邻或 ε 邻域及 σ 等超参数。
       </li>
       <li>
        <strong>
         正则化
        </strong>
        ：图拉普拉斯 L 或传播矩阵 P 有时需要加对角项或进行对称正规化，以避免奇异或数值不稳定。
       </li>
       <li>
        <strong>
         迭代收敛
        </strong>
        ：若用迭代方式实现，需要在每步迭代后将有标签节点的值“锁定”或进行 α -重启(对比PageRank思想)。
       </li>
       <li>
        <strong>
         多分类情形
        </strong>
        ：
        <img alt="\mathbf{f}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7Bf%7D"/>
        可以是
        <img alt="n\times C" class="mathcode" src="https://latex.csdn.net/eq?n%5Ctimes%20C"/>
        矩阵，每个节点对 C 个类别的打分，通过同样的图传播公式对每一列(类别)做传播，最后选取最大打分的类别即可。
       </li>
      </ul>
     </li>
     <li>
      示例
     </li>
    </ol>
    <p>
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/d61a0cfaffea4887ba95e75f60f97718.png" width="596"/>
    </p>
    <p>
    </p>
    <h3 id="8%E3%80%81%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%A4%9A%E5%88%86%E7%B1%BB%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0(%E6%A0%87%E8%AE%B0%E6%89%A9%E6%95%A3)" name="8%E3%80%81%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%A4%9A%E5%88%86%E7%B1%BB%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0(%E6%A0%87%E8%AE%B0%E6%89%A9%E6%95%A3)">
     8、基于图的多分类半监督学习(标记扩散)
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E5%A4%9A%E5%88%86%E7%B1%BB%E7%9A%84%E6%A0%87%E7%AD%BE%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA" name="%EF%BC%881%EF%BC%89%E5%A4%9A%E5%88%86%E7%B1%BB%E7%9A%84%E6%A0%87%E7%AD%BE%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA">
     （1）多分类的标签矩阵表示
    </h4>
    <p>
     在多分类场景下，我们有C个类别，训练集中有L个带标签样本以及U个无标签样本，总样本数为
     <img alt="L+U" class="mathcode" src="https://latex.csdn.net/eq?L&amp;plus;U"/>
     。为了同时对所有类别进行打分，通常将每个样本
     <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
     ​的标签表示为一个**C-维向量**：
    </p>
    <ul>
     <li>
      <p>
       对于有标签样本(
       <img alt="1 \le i \le L" class="mathcode" src="https://latex.csdn.net/eq?1%20%5Cle%20i%20%5Cle%20L"/>
       )，令其真实类别为
       <img alt="y_i \in \{1,\dots,C\}" class="mathcode" src="https://latex.csdn.net/eq?y_i%20%5Cin%20%5C%7B1%2C%5Cdots%2CC%5C%7D"/>
       。可以用**独热编码(One-Hot)**方式初始化一个标签矩阵
       <img alt="\mathbf{Y}\in \mathbb{R}^{(L+U)\times C}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%28L&amp;plus;U%29%5Ctimes%20C%7D"/>
       ，其中
      </p>
      <img alt="Y_{i,c} \;=\; \begin{cases} 1, &amp; \text{if } i \le L \text{ and } y_i = c,\\ 0, &amp; \text{else} \end{cases}" class="mathcode" src="https://latex.csdn.net/eq?Y_%7Bi%2Cc%7D%20%5C%3B%3D%5C%3B%20%5Cbegin%7Bcases%7D%201%2C%20%26%20%5Ctext%7Bif%20%7D%20i%20%5Cle%20L%20%5Ctext%7B%20and%20%7D%20y_i%20%3D%20c%2C%5C%5C%200%2C%20%26%20%5Ctext%7Belse%7D%20%5Cend%7Bcases%7D"/>
      <p>
       这样，
       <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
       的第
       <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
       行就是样本
       <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
       ​在C个类别上的“初始标签分布”，带标签样本对应的行只有在真实类别处为1，其它位置为0；无标签样本对应的行全为0。
      </p>
     </li>
     <li>
      <p>
       在算法中，我们要学习一个标记矩阵
       <img alt="\mathbf{F}\in \mathbb{R}^{(L+U)\times C}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7B%28L&amp;plus;U%29%5Ctimes%20C%7D"/>
       ，其中
       <img alt="\mathbf{F}_{i,c}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_%7Bi%2Cc%7D"/>
       ​表示“模型对于样本
       <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
       ​属于类别
       <img alt="c" class="mathcode" src="https://latex.csdn.net/eq?c"/>
       的打分”或“后验概率近似”。最后的预测规则一般取
      </p>
      <img alt="\hat{y}_i \;=\;\arg\max_{1\le c \le C}\;F_{i,c}" class="mathcode" src="https://latex.csdn.net/eq?%5Chat%7By%7D_i%20%5C%3B%3D%5C%3B%5Carg%5Cmax_%7B1%5Cle%20c%20%5Cle%20C%7D%5C%3BF_%7Bi%2Cc%7D"/>
      <p>
       这样就能实现多分类预测。
      </p>
     </li>
    </ul>
    <h4 id="%EF%BC%882%EF%BC%89%E5%B8%A6%E6%AD%A3%E5%88%99%E9%A1%B9%E7%9A%84%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0" name="%EF%BC%882%EF%BC%89%E5%B8%A6%E6%AD%A3%E5%88%99%E9%A1%B9%E7%9A%84%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0">
     （2）带正则项的目标函数
    </h4>
    <p>
     典型的正则化目标函数，用来平衡
     <strong>
      图上的平滑性
     </strong>
     和
     <strong>
      对有标签样本的拟合
     </strong>
     。其形式为：
    </p>
    <p>
     <img alt="\min_{\mathbf{F}}\;\; \underbrace{\frac{1}{2}\sum_{i,j=1}^{L+U} w_{ij}\Bigl\|\tfrac{1}{\sqrt{d_i}}\,\mathbf{F}_i \;-\; \tfrac{1}{\sqrt{d_j}}\,\mathbf{F}_j\Bigr\|^2}_{\text{no1}} \;\;+\;\; \underbrace{\lambda \sum_{i=1}^{L} \|\mathbf{F}_i - \mathbf{Y}_i\|^2}_{\text{no2}}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmin_%7B%5Cmathbf%7BF%7D%7D%5C%3B%5C%3B%20%5Cunderbrace%7B%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%2Cj%3D1%7D%5E%7BL&amp;plus;U%7D%20w_%7Bij%7D%5CBigl%5C%7C%5Ctfrac%7B1%7D%7B%5Csqrt%7Bd_i%7D%7D%5C%2C%5Cmathbf%7BF%7D_i%20%5C%3B-%5C%3B%20%5Ctfrac%7B1%7D%7B%5Csqrt%7Bd_j%7D%7D%5C%2C%5Cmathbf%7BF%7D_j%5CBigr%5C%7C%5E2%7D_%7B%5Ctext%7Bno1%7D%7D%20%5C%3B%5C%3B&amp;plus;%5C%3B%5C%3B%20%5Cunderbrace%7B%5Clambda%20%5Csum_%7Bi%3D1%7D%5E%7BL%7D%20%5C%7C%5Cmathbf%7BF%7D_i%20-%20%5Cmathbf%7BY%7D_i%5C%7C%5E2%7D_%7B%5Ctext%7Bno2%7D%7D"/>
    </p>
    <p>
     其中：
    </p>
    <ol>
     <li>
      <strong>
       no1
      </strong>
      ：图平滑项
     </li>
     <li>
      <strong>
       no2
      </strong>
      ：正则项（对已标记样本的约束）
     </li>
     <li>
      <img alt="\mathbf{F}_i" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_i"/>
      ​表示第
      <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
      行（对应样本
      <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
      ​）的C-维打分向量；
     </li>
     <li>
      <img alt="w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D"/>
      ​是样本
      <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
      和
      <img alt="j" class="mathcode" src="https://latex.csdn.net/eq?j"/>
      之间的边权(通常基于相似度)；
     </li>
     <li>
      <img alt="d_i = \sum_{j} w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?d_i%20%3D%20%5Csum_%7Bj%7D%20w_%7Bij%7D"/>
      是节点
      <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
      的度；
     </li>
     <li>
      <img alt="\lambda &gt; 0" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda%20%3E%200"/>
      是平衡系数，控制“保持与初始标签一致”与“在图上尽量平滑”之间的权重。
     </li>
    </ol>
    <h6 id="2.1%20%E5%B9%B3%E6%BB%91%E9%A1%B9" name="2.1%20%E5%B9%B3%E6%BB%91%E9%A1%B9">
     2.1 平滑项
    </h6>
    <p>
     平滑项
     <img alt="\tfrac{1}{2}\sum_{i,j} w_{ij}\|\tfrac{1}{\sqrt{d_i}}\mathbf{F}_i - \tfrac{1}{\sqrt{d_j}}\mathbf{F}_j\|^2" class="mathcode" src="https://latex.csdn.net/eq?%5Ctfrac%7B1%7D%7B2%7D%5Csum_%7Bi%2Cj%7D%20w_%7Bij%7D%5C%7C%5Ctfrac%7B1%7D%7B%5Csqrt%7Bd_i%7D%7D%5Cmathbf%7BF%7D_i%20-%20%5Ctfrac%7B1%7D%7B%5Csqrt%7Bd_j%7D%7D%5Cmathbf%7BF%7D_j%5C%7C%5E2"/>
     可以视作“归一化图拉普拉斯”的刻画：若节点
     <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
     与
     <img alt="j" class="mathcode" src="https://latex.csdn.net/eq?j"/>
     相似度
     <img alt="w_{ij}" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bij%7D"/>
     ​大，则
     <img alt="\mathbf{F}_i" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_i"/>
     ​和
     <img alt="\mathbf{F}_j" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D_j"/>
     ​应当相近，从而减少该项的损失。
    </p>
    <h6 id="2.2%20%E6%AD%A3%E5%88%99%E9%A1%B9%EF%BC%88%E5%AF%B9%E5%B7%B2%E6%A0%87%E8%AE%B0%E6%A0%B7%E6%9C%AC%E7%9A%84%E7%BA%A6%E6%9D%9F%EF%BC%89" name="2.2%20%E6%AD%A3%E5%88%99%E9%A1%B9%EF%BC%88%E5%AF%B9%E5%B7%B2%E6%A0%87%E8%AE%B0%E6%A0%B7%E6%9C%AC%E7%9A%84%E7%BA%A6%E6%9D%9F%EF%BC%89">
     2.2 正则项（对已标记样本的约束）
    </h6>
    <p>
     <img alt="\lambda\sum_{i=1}^{L}\|\mathbf{F}_i - \mathbf{Y}_i\|^2" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda%5Csum_%7Bi%3D1%7D%5E%7BL%7D%5C%7C%5Cmathbf%7BF%7D_i%20-%20%5Cmathbf%7BY%7D_i%5C%7C%5E2"/>
     表示：
    </p>
    <ul>
     <li>
      当
      <img alt="\lambda" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda"/>
      很大时，算法更倾向于“严格贴合”初始标签
      <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
      ；
     </li>
     <li>
      当
      <img alt="\lambda" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda"/>
      较小时，算法可以“牺牲”一部分对
      <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
      的拟合，从而在图上进行更大范围的平滑，也允许“修正”可能有噪声的标签。
     </li>
    </ul>
    <p>
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%E8%A7%A3%E6%9E%90%E8%A7%A3%E5%8F%8A%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F" name="%EF%BC%883%EF%BC%89%E8%A7%A3%E6%9E%90%E8%A7%A3%E5%8F%8A%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F">
     （3）解析解及矩阵形式
    </h4>
    <p>
     在论文或教材中，通过对
     <img alt="\mathbf{F}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D"/>
     求导并令其为零，或者利用图拉普拉斯矩阵的性质，可以得到一个
     <strong>
      闭式解
     </strong>
     (即一次性求得
     <img alt="\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*"/>
     )。结果是：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\mathbf{F}^* = \bigl(1 \;+\;\lambda\bigl(I - D^{-\tfrac{1}{2}}\,W\,D^{-\tfrac{1}{2}}\bigr)\bigr)^{-1}\,\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%20%3D%20%5Cbigl%281%20%5C%3B&amp;plus;%5C%3B%5Clambda%5Cbigl%28I%20-%20D%5E%7B-%5Ctfrac%7B1%7D%7B2%7D%7D%5C%2CW%5C%2CD%5E%7B-%5Ctfrac%7B1%7D%7B2%7D%7D%5Cbigr%29%5Cbigr%29%5E%7B-1%7D%5C%2C%5Cmathbf%7BY%7D"/>
    </p>
    <p>
     或者常用的一种等价写法是先定义
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\alpha \;=\;\frac{\lambda}{1 + \lambda}, \quad S \;=\; D^{-\tfrac{1}{2}}\,W\,D^{-\tfrac{1}{2}}" class="mathcode" src="https://latex.csdn.net/eq?%5Calpha%20%5C%3B%3D%5C%3B%5Cfrac%7B%5Clambda%7D%7B1%20&amp;plus;%20%5Clambda%7D%2C%20%5Cquad%20S%20%5C%3B%3D%5C%3B%20D%5E%7B-%5Ctfrac%7B1%7D%7B2%7D%7D%5C%2CW%5C%2CD%5E%7B-%5Ctfrac%7B1%7D%7B2%7D%7D"/>
    </p>
    <p>
     则
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\mathbf{F}^* = (1-\alpha)\,\bigl(I \;-\;\alpha\,S\bigr)^{-1}\;\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%20%3D%20%281-%5Calpha%29%5C%2C%5Cbigl%28I%20%5C%3B-%5C%3B%5Calpha%5C%2CS%5Cbigr%29%5E%7B-1%7D%5C%3B%5Cmathbf%7BY%7D"/>
    </p>
    <p>
     这是因为
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="1 + \lambda \;=\; \frac{1}{1-\alpha}, \quad \lambda\bigl(I - S\bigr) \;=\; \frac{\alpha}{1-\alpha}\,\bigl(I - S\bigr)" class="mathcode" src="https://latex.csdn.net/eq?1%20&amp;plus;%20%5Clambda%20%5C%3B%3D%5C%3B%20%5Cfrac%7B1%7D%7B1-%5Calpha%7D%2C%20%5Cquad%20%5Clambda%5Cbigl%28I%20-%20S%5Cbigr%29%20%5C%3B%3D%5C%3B%20%5Cfrac%7B%5Calpha%7D%7B1-%5Calpha%7D%5C%2C%5Cbigl%28I%20-%20S%5Cbigr%29"/>
    </p>
    <p>
     经过代数变形即可得到如上形式。
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%884%EF%BC%89%E8%BF%AD%E4%BB%A3%E6%B1%82%E8%A7%A3%EF%BC%9A" name="%EF%BC%884%EF%BC%89%E8%BF%AD%E4%BB%A3%E6%B1%82%E8%A7%A3%EF%BC%9A">
     （4）迭代求解：
     <img alt="\mathbf{F}^{(t+1)} = \alpha\,S\,\mathbf{F}^{(t)} + (1-\alpha)\,\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t&amp;plus;1%29%7D%20%3D%20%5Calpha%5C%2CS%5C%2C%5Cmathbf%7BF%7D%5E%7B%28t%29%7D%20&amp;plus;%20%281-%5Calpha%29%5C%2C%5Cmathbf%7BY%7D"/>
    </h4>
    <p>
     在很多实际应用中，不直接用矩阵逆来求
     <img alt="\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*"/>
     ，而是用
     <strong>
      迭代更新
     </strong>
     的方式来求解，既能减少计算量，也能在大规模数据上更灵活地实现。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        初始化：
       </strong>
      </p>
      <img alt="\mathbf{F}^{(0)} \;=\; \mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%280%29%7D%20%5C%3B%3D%5C%3B%20%5Cmathbf%7BY%7D"/>
      <p>
       （即初始时刻，把有标签样本的行设为独热向量，无标签样本的行全为0）
      </p>
     </li>
     <li>
      <p>
       <strong>
        迭代公式：
       </strong>
      </p>
      <img alt="\mathbf{F}^{(t+1)} = \alpha\,S\,\mathbf{F}^{(t)} \;+\; (1-\alpha)\,\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t&amp;plus;1%29%7D%20%3D%20%5Calpha%5C%2CS%5C%2C%5Cmathbf%7BF%7D%5E%7B%28t%29%7D%20%5C%3B&amp;plus;%5C%3B%20%281-%5Calpha%29%5C%2C%5Cmathbf%7BY%7D"/>
      <p>
       其中
       <img alt="S = D^{-\tfrac12} W D^{-\tfrac12}" class="mathcode" src="https://latex.csdn.net/eq?S%20%3D%20D%5E%7B-%5Ctfrac12%7D%20W%20D%5E%7B-%5Ctfrac12%7D"/>
       ​，
       <img alt="\alpha \in (0,1)" class="mathcode" src="https://latex.csdn.net/eq?%5Calpha%20%5Cin%20%280%2C1%29"/>
       。
      </p>
      <ul>
       <li>
        可以理解为：每一步将当前
        <img alt="\mathbf{F}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D"/>
        在图上扩散(
        <img alt="\alpha\,S\,\mathbf{F}^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?%5Calpha%5C%2CS%5C%2C%5Cmathbf%7BF%7D%5E%7B%28t%29%7D"/>
        )，再部分回退到原始标签(
        <img alt="(1-\alpha)\,\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%281-%5Calpha%29%5C%2C%5Cmathbf%7BY%7D"/>
        )。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        收敛结果：
       </strong>
       <br/>
       当
       <img alt="t\to\infty" class="mathcode" src="https://latex.csdn.net/eq?t%5Cto%5Cinfty"/>
       ，
       <img alt="\mathbf{F}^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t%29%7D"/>
       将收敛到
      </p>
      <img alt="\mathbf{F}^* = (1-\alpha)\,(I - \alpha S)^{-1}\,\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%20%3D%20%281-%5Calpha%29%5C%2C%28I%20-%20%5Calpha%20S%29%5E%7B-1%7D%5C%2C%5Cmathbf%7BY%7D"/>
      <p>
       这与前述解析解完全一致。
      </p>
     </li>
    </ol>
    <h4 id="%EF%BC%885%EF%BC%89%E5%A4%9A%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E4%B8%8E%E2%80%9C%E6%A0%87%E8%AE%B0%E5%8F%AF%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%AD%A3%E2%80%9D%E7%9A%84%E7%8E%B0%E8%B1%A1" name="%EF%BC%885%EF%BC%89%E5%A4%9A%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E4%B8%8E%E2%80%9C%E6%A0%87%E8%AE%B0%E5%8F%AF%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%AD%A3%E2%80%9D%E7%9A%84%E7%8E%B0%E8%B1%A1">
     （5）多分类预测与“标记可能被修正”的现象
    </h4>
    <h6 id="5.1%20%E9%A2%84%E6%B5%8B%E8%A7%84%E5%88%99" name="5.1%20%E9%A2%84%E6%B5%8B%E8%A7%84%E5%88%99">
     5.1 预测规则
    </h6>
    <p>
     当算法收敛后，我们得到
     <img alt="\mathbf{F}^*\in\mathbb{R}^{(L+U)\times C}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%5Cin%5Cmathbb%7BR%7D%5E%7B%28L&amp;plus;U%29%5Ctimes%20C%7D"/>
     。对于任何样本
     <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
     ​，包括原先无标签的样本(
     <img alt="i&gt;L" class="mathcode" src="https://latex.csdn.net/eq?i%3EL"/>
     )，可按下式预测类别：
    </p>
    <p>
     ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​
     <img alt="\hat{y}_i = \arg\max_{1 \le c \le C} \; F^*_{i,c}" class="mathcode" src="https://latex.csdn.net/eq?%5Chat%7By%7D_i%20%3D%20%5Carg%5Cmax_%7B1%20%5Cle%20c%20%5Cle%20C%7D%20%5C%3B%20F%5E*_%7Bi%2Cc%7D"/>
    </p>
    <p>
     这样就完成了对无标签样本的多分类预测。
    </p>
    <h6 id="5.2%20%E6%A0%87%E8%AE%B0%E4%BF%AE%E6%AD%A3" name="5.2%20%E6%A0%87%E8%AE%B0%E4%BF%AE%E6%AD%A3">
     5.2 标记修正
    </h6>
    <p>
     在最终收敛结果中，
     <strong>
      原有的标记样本
     </strong>
     (即
     <img alt="1 \le i \le L" class="mathcode" src="https://latex.csdn.net/eq?1%20%5Cle%20i%20%5Cle%20L"/>
     )的标签向量
     <img alt="\mathbf{F}^*_{i}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*_%7Bi%7D"/>
     也可能和初始
     <img alt="\mathbf{Y}_i" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D_i"/>
     ​有所不同，甚至可能导致
     <img alt="arg\max" class="mathcode" src="https://latex.csdn.net/eq?arg%5Cmax"/>
     发生变化。这是因为我们在目标函数中并没有对有标签样本做“硬约束”，而是用
     <img alt="\lambda\|\mathbf{F}_i - \mathbf{Y}_i\|^2" class="mathcode" src="https://latex.csdn.net/eq?%5Clambda%5C%7C%5Cmathbf%7BF%7D_i%20-%20%5Cmathbf%7BY%7D_i%5C%7C%5E2"/>
     这种
     <strong>
      软约束
     </strong>
     。如果图的整体结构和其他样本的分布强烈“推翻”了某个标签，算法就会倾向于修正它，从而
     <strong>
      一定程度上对噪声标签具有鲁棒性
     </strong>
     。
    </p>
    <h4 id="%EF%BC%886%EF%BC%89%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A6%81%E7%82%B9" name="%EF%BC%886%EF%BC%89%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A6%81%E7%82%B9">
     （6）总结与要点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        多分类标签矩阵
        <img alt="\mathbf{F}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D"/>
       </strong>
      </p>
      <ul>
       <li>
        每一行对应一个样本，每一列对应一个类别。
       </li>
       <li>
        通过独热编码初始化
        <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
        ，再利用图结构进行扩散和修正。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        正则化目标
       </strong>
      </p>
      <ul>
       <li>
        第一项(平滑性)：鼓励在相似度高的节点之间
        <img alt="\mathbf{F}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D"/>
        接近；
       </li>
       <li>
        第二项(拟合有标签)：鼓励与初始标签
        <img alt="\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BY%7D"/>
        保持一致，但允许带噪声的标签被纠正。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        解析解 vs. 迭代解
       </strong>
      </p>
      <ul>
       <li>
        解析解：
        <img alt="\mathbf{F}^* = (1-\alpha)(I - \alpha S)^{-1}\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*%20%3D%20%281-%5Calpha%29%28I%20-%20%5Calpha%20S%29%5E%7B-1%7D%5Cmathbf%7BY%7D"/>
       </li>
       <li>
        迭代解：
        <img alt="\mathbf{F}^{(t+1)} = \alpha\,S\,\mathbf{F}^{(t)} + (1-\alpha)\,\mathbf{Y}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E%7B%28t&amp;plus;1%29%7D%20%3D%20%5Calpha%5C%2CS%5C%2C%5Cmathbf%7BF%7D%5E%7B%28t%29%7D%20&amp;plus;%20%281-%5Calpha%29%5C%2C%5Cmathbf%7BY%7D"/>
        ，
        <img alt="t\to\infty" class="mathcode" src="https://latex.csdn.net/eq?t%5Cto%5Cinfty"/>
        收敛到
        <img alt="\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*"/>
        。
       </li>
       <li>
        迭代方法在大规模数据中往往更实用，也可以更方便地与稀疏矩阵操作结合。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        最终预测
       </strong>
      </p>
      <ul>
       <li>
        对每个样本
        <img alt="x_i" class="mathcode" src="https://latex.csdn.net/eq?x_i"/>
        ​，取
        <img alt="\hat{y}_i = \arg\max_c F^*_{i,c}" class="mathcode" src="https://latex.csdn.net/eq?%5Chat%7By%7D_i%20%3D%20%5Carg%5Cmax_c%20F%5E*_%7Bi%2Cc%7D"/>
       </li>
       <li>
        如果
        <img alt="\mathbf{F}^*" class="mathcode" src="https://latex.csdn.net/eq?%5Cmathbf%7BF%7D%5E*"/>
        在已标记样本上也发生了“修正”，说明算法对疑似错误的标签进行了一定程度的纠正。
       </li>
      </ul>
     </li>
    </ol>
    <p>
    </p>
    <h3 id="9%E3%80%81%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93" name="9%E3%80%81%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93">
     9、基于图的算法的总结
    </h3>
    <p>
     <strong>
      优点:
     </strong>
    </p>
    <ul>
     <li>
      清晰的数学框架
     </li>
    </ul>
    <p>
     <strong>
      缺点:
     </strong>
    </p>
    <ul>
     <li>
      图质量差的时候性能差
     </li>
     <li>
      对图的结构和权重敏感
     </li>
     <li>
      存储需求大
     </li>
    </ul>
    <p>
    </p>
    <h2 id="%E4%B8%83%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB" name="%E4%B8%83%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB">
     七、半监督聚类
    </h2>
    <p>
     半监督聚类(semisupervised clustering)是一种结合有标签数据和无标签数据的聚类方法，旨在提升聚类算法的性能，尤其是在有少量标记数据时。这种方法的基本思想是：通过引入一些先验信息（如已知的相似关系、约束条件等），来改进聚类算法对无标签数据的处理方式。
    </p>
    <h3 id="1%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" name="1%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">
     1、半监督聚类的基本概念
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        聚类的定义：
       </strong>
       聚类是一种无监督学习方法，通过把样本划分成若干个子集（簇），使得同一簇内的样本之间相似度较高，而不同簇之间的样本相似度较低。常见的聚类算法包括K-means、层次聚类等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        半监督聚类：
       </strong>
       在传统的聚类方法中，我们没有标签信息，只有数据本身的相似性或者距离信息。而半监督聚类则通过结合部分已知标签信息来提高聚类的准确性。标记信息可以来自于先验知识（例如已知的某些样本属于同一类或者属于不同类）。
      </p>
     </li>
    </ul>
    <p>
     在半监督聚类中，通常有以下几种类型的知识可以引导聚类过程：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        簇之间的相似性：
       </strong>
       例如，通过用户提供的“必须连接(must-link)”或“不能连接(cannot-link)”关系，告诉算法哪些样本必须在同一簇内，哪些样本不能在同一簇内。
      </p>
     </li>
     <li>
      <p>
       <strong>
        标记点：
       </strong>
       用户可以提供一小部分带标签的样本，用来指导无标签样本的聚类过程。
      </p>
     </li>
    </ol>
    <h3 id="2%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86" name="2%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86">
     2、半监督聚类的应用和原理
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        基于已有标签的区域知识：
       </strong>
       <br/>
       通过引入标记数据，可以帮助算法确定数据点之间的关系。例如，已经标记的样本可以帮助划定数据集中的类别区域，进而帮助聚类算法推测无标签样本的类别。
      </p>
      <p>
       具体来说，半监督聚类算法通过在数据的特征空间中创建一系列不同的簇，进而利用已有标签的样本指导聚类过程。这些标签帮助算法“知道”哪些样本应当属于同一类别，并且能够在没有标签的样本上进行推理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        基于用户提供的标签进行初步分类：
       </strong>
       <br/>
       提供部分标记样本（例如，红色、蓝色样本），通过这些标记样本，可以帮助算法明确数据集中的分类区域，并逐步调整和优化数据点的聚类位置。这种方法可以通过一些聚类算法（如K-means或谱聚类）实现，其中初始簇的中心可以基于标签数据来选择。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据分配与更新：
       </strong>
       <br/>
       通过对已有标签数据点进行计算（例如计算均值或重心），将样本分配到相应的簇中，并更新簇中心。算法会在迭代过程中反复更新聚类结果，直到满足收敛条件。
      </p>
     </li>
    </ul>
    <h3 id="3%E3%80%81%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%BC%95%E5%85%A5" name="3%E3%80%81%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%BC%95%E5%85%A5">
     3、约束条件的引入
    </h3>
    <p>
     在半监督聚类中，
     <strong>
      约束条件
     </strong>
     是十分重要的，它们能够帮助算法从有标签样本中获取更多的信息，进而优化无标签样本的聚类效果。常见的约束包括：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        必须连接(must-link)：
       </strong>
       <br/>
       这种约束指定了两个样本必须属于同一簇。例如，用户可以提供这样的先验知识：“样本A和样本B应该在同一类中”。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不能连接(cannot-link)：
       </strong>
       <br/>
       这种约束则指定了两个样本不能属于同一簇。例如，用户可以提供这样的先验知识：“样本C和样本D不应该在同一类中”。
      </p>
     </li>
    </ol>
    <p>
     通过这些约束，半监督聚类算法能够在进行聚类时考虑到更多的先验知识，从而更好地将数据分配到合适的簇中。
    </p>
    <h3 id="4%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B" name="4%E3%80%81%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%81%9A%E7%B1%BB%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">
     4、半监督聚类的算法流程
    </h3>
    <p>
     半监督聚类算法流程。这里以K-means为例进行说明：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        初始化：
       </strong>
      </p>
      <ul>
       <li>
        随机选择数据点或基于标签数据选择簇的中心。
       </li>
       <li>
        如果有标签数据，选择标签数据点作为初始簇中心。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        计算距离并分配簇：
       </strong>
      </p>
      <ul>
       <li>
        对每个样本，计算其与各簇中心的距离，并将样本分配到距离最小的簇。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        更新簇中心：
       </strong>
      </p>
      <ul>
       <li>
        计算每个簇的均值或重心，更新簇的中心位置。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        考虑约束条件：
       </strong>
      </p>
      <ul>
       <li>
        如果样本之间有“必须连接”或“不能连接”的约束，更新簇的分配和簇中心位置，确保满足这些约束。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        迭代：
       </strong>
      </p>
      <ul>
       <li>
        重复步骤2至步骤4，直到聚类结果收敛（即簇中心不再变化）。
       </li>
      </ul>
     </li>
    </ol>
    <h3 id="5%E3%80%81%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%94%B6%E6%95%9B" name="5%E3%80%81%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%94%B6%E6%95%9B">
     5、迭代过程与收敛
    </h3>
    <p>
     在算法的实现中，收敛通常意味着簇中心不再发生变化，或者变化非常微小。当簇中心稳定时，表示聚类过程完成。在收敛过程中，约束条件（如must-link和cannot-link）帮助算法调整簇的划分，确保样本被正确地归类。
    </p>
    <p>
    </p>
    <h2 id="%E5%85%AB%E3%80%81%E6%9B%B4%E5%A4%9A%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%80%EF%BC%89" name="%E5%85%AB%E3%80%81%E6%9B%B4%E5%A4%9A%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%80%EF%BC%89">
     八、更多半监督学习算法（简）
    </h2>
    <h3 id="1%E3%80%81Transfer%20Learning%EF%BC%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%EF%BC%89" name="1%E3%80%81Transfer%20Learning%EF%BC%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%EF%BC%89">
     1、Transfer Learning（迁移学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     在一个源领域（source domain）已经训练好了模型，或积累了大量知识（包括预训练模型），将其迁移到另一个目标领域（target domain）或目标任务（target task）上，以提高目标任务的学习效率或性能。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      都是解决
      <strong>
       标注数据有限
      </strong>
      的问题，但着眼点不同：
      <ul>
       <li>
        半监督学习通常是
        <strong>
         在同一数据分布下
        </strong>
        ，用少量有标签数据 + 大量无标签数据进行学习；
       </li>
       <li>
        迁移学习通常是
        <strong>
         跨分布
        </strong>
        （源域和目标域可能分布不同），利用源域已有的模型或知识来帮助目标域。
       </li>
      </ul>
     </li>
     <li>
      实际中常常结合使用：在目标域仅有少量标签的情况下，可以先用迁移学习（从大规模源域数据中获得预训练模型），再用半监督学习（利用目标域的无标签数据进行微调）。
     </li>
    </ul>
    <hr/>
    <h3 id="2%E3%80%81One%2FFew-shot%20Learning%EF%BC%88%E5%8D%95%E6%A0%B7%E6%9C%AC%2F%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0%EF%BC%89" name="2%E3%80%81One%2FFew-shot%20Learning%EF%BC%88%E5%8D%95%E6%A0%B7%E6%9C%AC%2F%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0%EF%BC%89">
     2、One/Few-shot Learning（单样本/小样本学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     在极少量（甚至只有1个或很少几个）有标签样本的情况下，仍能有效地完成分类、识别等任务。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      同样面对
      <strong>
       标签极度匮乏
      </strong>
      的情形；
     </li>
     <li>
      One/Few-shot Learning 通常依赖
      <strong>
       度量学习（metric learning）
      </strong>
      、
      <strong>
       元学习（meta-learning）
      </strong>
      、
      <strong>
       预训练表征
      </strong>
      等方法，从而在仅有少量样本时也能泛化；
     </li>
     <li>
      半监督学习则更偏向于“充分利用大量无标签数据”来约束或丰富决策边界。
     </li>
     <li>
      两者可以结合，如在小样本场景下，还可以额外利用无标签数据帮助学习更好的特征或决策边界。
     </li>
    </ul>
    <hr/>
    <h3 id="3%E3%80%81Un%2FSelf-Supervised%20Learning%EF%BC%88%E6%97%A0%E7%9B%91%E7%9D%A3%2F%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%89" name="3%E3%80%81Un%2FSelf-Supervised%20Learning%EF%BC%88%E6%97%A0%E7%9B%91%E7%9D%A3%2F%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%89">
     3、Un/Self-Supervised Learning（无监督/自监督学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       无监督学习 (Unsupervised Learning)
      </strong>
      ：仅使用无标签数据进行聚类、降维、密度估计等。
     </li>
     <li>
      <strong>
       自监督学习 (Self-Supervised Learning)
      </strong>
      ：构造“预训练任务”或“伪标签”，在大量无标签数据上学习可泛化的特征表示，之后在下游任务上微调。
     </li>
    </ul>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      半监督学习介于监督与无监督之间；
     </li>
     <li>
      自监督学习是当前非常热门的表征学习手段，能与半监督学习相结合：先对无标签数据进行自监督预训练，得到通用特征，再用少量标签微调或半监督微调；
     </li>
     <li>
      二者的共同点是都希望
      <strong>
       最大化对无标签数据的利用
      </strong>
      ，但自监督更多是通过设计预训练任务（如对比学习、遮挡预测、旋转预测等）来学习表征，半监督则在同一个任务下直接利用有无标签数据进行训练。
     </li>
    </ul>
    <hr/>
    <h3 id="4%E3%80%81Domain%20Adaptation%EF%BC%88%E9%A2%86%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%89" name="4%E3%80%81Domain%20Adaptation%EF%BC%88%E9%A2%86%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%89">
     4、Domain Adaptation（领域自适应）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     在目标领域数据上几乎没有标签（或只有极少量标签）的情况下，通过源领域数据（有较多标签）来帮助目标领域的学习。与迁移学习类似，但更关注“分布差异”导致的模型失配问题，强调对分布差异进行校正或对齐（domain alignment）。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      二者都涉及“无标签数据”的使用，但 Domain Adaptation 更关注
      <strong>
       源域与目标域分布不同
      </strong>
      时如何对齐；
     </li>
     <li>
      半监督学习多在
      <strong>
       同一分布
      </strong>
      假设下，仅是标签缺乏；
     </li>
     <li>
      当目标域有少量或无标签数据时，往往结合半监督思路，对目标域无标签样本进行“自适应”或“伪标签”生成，从而改进分类器。
     </li>
    </ul>
    <hr/>
    <h3 id="5%E3%80%81Meta-Learning%EF%BC%88%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%89" name="5%E3%80%81Meta-Learning%EF%BC%88%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%89">
     5、Meta-Learning（元学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     “学习如何学习”（learn to learn），希望通过在多个任务上的训练，学到一种
     <strong>
      快速适应新任务
     </strong>
     的能力。常见思路是利用
     <strong>
      元任务集合
     </strong>
     训练一个元模型，使得它能在遇到新任务时仅需少量样本或少量训练就能获得较好性能。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      都可用于
      <strong>
       小数据场景
      </strong>
      ；
     </li>
     <li>
      元学习通常依赖在许多相关任务上进行“训练”，从而在新的任务中实现高效学习；
     </li>
     <li>
      半监督学习则更多是“同一个任务下，有标签样本少，但无标签样本多”。
     </li>
     <li>
      两者可以结合：先用元学习得到对小样本的快速适应能力，再利用新任务中大量无标签数据做半监督增强。
     </li>
    </ul>
    <hr/>
    <h3 id="6%E3%80%81Zero-shot%20Learning%EF%BC%88%E9%9B%B6%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0%EF%BC%89" name="6%E3%80%81Zero-shot%20Learning%EF%BC%88%E9%9B%B6%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0%EF%BC%89">
     6、Zero-shot Learning（零样本学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     模型在训练时
     <strong>
      从未见过
     </strong>
     某些类别的任何样本，但可以基于类别的语义描述（如词向量、属性、描述文本等）来识别这些全新类别的样本。常见于图像识别中的“零样本分类”。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      Zero-shot Learning 关注“
      <strong>
       完全没有
      </strong>
      目标类别的训练样本”，更多借助
      <strong>
       类别属性
      </strong>
      或
      <strong>
       辅助信息
      </strong>
      （如文本描述）来建立模型；
     </li>
     <li>
      半监督学习依赖“
      <strong>
       同分布
      </strong>
      的大量无标签样本”来帮助学习决策边界；
     </li>
     <li>
      二者的思路不同，但都面向“标签不足”问题，且都需要额外信息或假设（Zero-shot 需要类别语义信息，半监督需要无标签数据分布信息）。
     </li>
    </ul>
    <hr/>
    <h3 id="7%E3%80%81Continual%20%2F%20Lifelong-learning%EF%BC%88%E6%8C%81%E7%BB%AD%2F%E7%BB%88%E8%BA%AB%E5%AD%A6%E4%B9%A0%EF%BC%89" name="7%E3%80%81Continual%20%2F%20Lifelong-learning%EF%BC%88%E6%8C%81%E7%BB%AD%2F%E7%BB%88%E8%BA%AB%E5%AD%A6%E4%B9%A0%EF%BC%89">
     7、Continual / Lifelong-learning（持续/终身学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     模型持续不断地接收新任务或新数据流，需要在不忘记之前学到的知识（避免灾难性遗忘）的同时，逐渐累积、更新模型能力。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      半监督学习主要解决
      <strong>
       同一阶段
      </strong>
      有无标签数据混合的学习问题；
     </li>
     <li>
      持续/终身学习强调
      <strong>
       时间序列
      </strong>
      上的学习过程，模型要随着数据流不断学习新知识；
     </li>
     <li>
      在实际应用中，如果在新阶段拿到大量无标签数据，也可采用半监督思路；若在每个阶段只有少量标签，也可能结合半监督技术来利用无标签数据。
     </li>
    </ul>
    <hr/>
    <h3 id="8%E3%80%81Active%20Learning%EF%BC%88%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0%EF%BC%89" name="8%E3%80%81Active%20Learning%EF%BC%88%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0%EF%BC%89">
     8、Active Learning（主动学习）
    </h3>
    <p>
     <strong>
      核心思想：
     </strong>
     <br/>
     模型可以从未标注的数据池中“主动”挑选最有价值的样本请求人工标注，从而用最少的标注成本得到最佳模型性能。
    </p>
    <p>
     <strong>
      与半监督学习的关系：
     </strong>
    </p>
    <ul>
     <li>
      Active Learning 假设
      <strong>
       可以交互式
      </strong>
      地获取标签，但标注成本较高，需要“精挑细选”要标注的样本；
     </li>
     <li>
      半监督学习假设
      <strong>
       大部分数据是无标签且暂时无法标注
      </strong>
      ，只能在已有少量标签和大量无标签数据下被动训练；
     </li>
     <li>
      二者可结合成
      <strong>
       主动半监督学习
      </strong>
      ：先对最具价值的无标签样本进行标注，再利用半监督方法对剩余的无标签数据进行学习。
     </li>
    </ul>
    <hr/>
    <h3 id="9%E3%80%81%E5%B0%8F%E7%BB%93" name="9%E3%80%81%E5%B0%8F%E7%BB%93">
     9、小结
    </h3>
    <p>
     这张幻灯片中的各个学习范式都与“
     <strong>
      标签匮乏
     </strong>
     ”或“
     <strong>
      数据分布差异
     </strong>
     ”相关，但各自关注的角度、所做的假设和技术手段并不相同：
    </p>
    <ul>
     <li>
      <strong>
       半监督学习
      </strong>
      ：同一分布下，少量有标签 + 大量无标签，充分利用无标签数据的信息。
     </li>
     <li>
      <strong>
       迁移学习 / 领域自适应
      </strong>
      ：跨域、跨任务的知识迁移，强调分布差异下的模型复用或对齐。
     </li>
     <li>
      <strong>
       小样本学习 / 元学习
      </strong>
      ：极少量样本学习，通常借助元学习或度量学习在多任务上提炼“快速适应”能力。
     </li>
     <li>
      <strong>
       自监督学习 / 无监督学习
      </strong>
      ：不依赖外部人工标签，通过设计预训练任务或聚类等方式提取数据结构或特征表示。
     </li>
     <li>
      <strong>
       零样本学习
      </strong>
      ：对从未见过样本的类别进行识别，需要辅助信息（类别属性、描述等）。
     </li>
     <li>
      <strong>
       持续 / 终身学习
      </strong>
      ：随时间不断学习新知识，避免灾难性遗忘。
     </li>
     <li>
      <strong>
       主动学习
      </strong>
      ：主动选择最具价值的样本进行标注，以最少标注成本达成最好性能。
     </li>
    </ul>
    <p>
     在实际应用中，这些方法往往
     <strong>
      相互结合
     </strong>
     ，根据任务需求、数据特点、标注成本等因素来制定合适的学习策略。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2 id="%E9%99%84%E5%BD%95" name="%E9%99%84%E5%BD%95">
     附录
    </h2>
    <h3 id="1%E3%80%81S3VM%20light%20%E8%AF%A6%E8%A7%A3" name="1%E3%80%81S3VM%20light%20%E8%AF%A6%E8%A7%A3">
     1、S3VM light 详解
    </h3>
    <p>
     对
     <strong>
      S3VMlight
     </strong>
     （一种求解半监督支持向量机 S3VM 的近似方法）做详细分析与推导。
     <strong>
      S3VMlight
     </strong>
     最早由 T. Joachims 提出，用于在大规模数据集上以较快的速度迭代求解半监督 SVM，核心是一个“
     <strong>
      局部组合搜索
     </strong>
     (Local Combinatorial Search)”策略，避免了直接对所有无标签样本的标签配置进行穷举。
    </p>
    <h4 id="%EF%BC%881%EF%BC%89%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E5%8D%8A%E7%9B%91%E7%9D%A3%20SVM%20%E7%9A%84%E9%9A%BE%E7%82%B9" name="%EF%BC%881%EF%BC%89%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E5%8D%8A%E7%9B%91%E7%9D%A3%20SVM%20%E7%9A%84%E9%9A%BE%E7%82%B9">
     （1）问题背景：半监督 SVM 的难点
    </h4>
    <h6 id="1.1%20%E5%8D%8A%E7%9B%91%E7%9D%A3%20SVM%20(S3VM)%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F" name="1.1%20%E5%8D%8A%E7%9B%91%E7%9D%A3%20SVM%20(S3VM)%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F">
     1.1 半监督 SVM (S3VM) 的基本形式
    </h6>
    <p>
     在半监督场景下，我们有：
    </p>
    <ul>
     <li>
      <img alt="l" class="mathcode" src="https://latex.csdn.net/eq?l"/>
      个带标签样本
      <img alt="\{(x_i, y_i)\}_{i=1}^l" class="mathcode" src="https://latex.csdn.net/eq?%5C%7B%28x_i%2C%20y_i%29%5C%7D_%7Bi%3D1%7D%5El"/>
      ，其中
      <img alt="y_i \in \{-1,+1\}" class="mathcode" src="https://latex.csdn.net/eq?y_i%20%5Cin%20%5C%7B-1%2C&amp;plus;1%5C%7D"/>
      。
     </li>
     <li>
      <img alt="u" class="mathcode" src="https://latex.csdn.net/eq?u"/>
      个无标签样本
      <img alt="\{x_j\}_{j=l+1}^{l+u}" class="mathcode" src="https://latex.csdn.net/eq?%5C%7Bx_j%5C%7D_%7Bj%3Dl&amp;plus;1%7D%5E%7Bl&amp;plus;u%7D"/>
      ​，但我们并不知道其真实标签。
     </li>
    </ul>
    <p>
     <strong>
      S3VM
     </strong>
     的目标是同时学习到分类器
     <img alt="f(x) = \langle w, x \rangle + b" class="mathcode" src="https://latex.csdn.net/eq?f%28x%29%20%3D%20%5Clangle%20w%2C%20x%20%5Crangle%20&amp;plus;%20b"/>
     以及无标签样本的“最优”标签指派
     <img alt="\{y_j\}_{j=l+1}^{l+u}" class="mathcode" src="https://latex.csdn.net/eq?%5C%7By_j%5C%7D_%7Bj%3Dl&amp;plus;1%7D%5E%7Bl&amp;plus;u%7D"/>
     ，使得所有样本（带标签+无标签）的间隔最大化、分类错误（或离边界过近）的样本最少。一个常见的目标函数是：
    </p>
    <p>
     ​​​​​​​
     <img alt="\min_{\substack{w,b,\\ y_j \in \{-1,+1\}}} \;\; \frac12 \|w\|^2 \;+\; C_1 \sum_{i=1}^{l} \xi_i \;+\; C_2 \sum_{j=l+1}^{l+u} \xi_j \quad \text{(S3VM)}" class="mathcode" src="https://latex.csdn.net/eq?%5Cmin_%7B%5Csubstack%7Bw%2Cb%2C%5C%5C%20y_j%20%5Cin%20%5C%7B-1%2C&amp;plus;1%5C%7D%7D%7D%20%5C%3B%5C%3B%20%5Cfrac12%20%5C%7Cw%5C%7C%5E2%20%5C%3B&amp;plus;%5C%3B%20C_1%20%5Csum_%7Bi%3D1%7D%5E%7Bl%7D%20%5Cxi_i%20%5C%3B&amp;plus;%5C%3B%20C_2%20%5Csum_%7Bj%3Dl&amp;plus;1%7D%5E%7Bl&amp;plus;u%7D%20%5Cxi_j%20%5Cquad%20%5Ctext%7B%28S3VM%29%7D"/>
    </p>
    <p>
     配合如下的约束（或损失）：
    </p>
    <ul>
     <li>
      对于有标签数据
      <img alt="(x_i, y_i)" class="mathcode" src="https://latex.csdn.net/eq?%28x_i%2C%20y_i%29"/>
      ，使用与标准 SVM 相同的软间隔约束：
      <img alt="\xi_i \ge 0" class="mathcode" src="https://latex.csdn.net/eq?%5Cxi_i%20%5Cge%200"/>
      ，且
      <img alt="y_i\,(\langle w, x_i\rangle + b) \;\ge\; 1 - \xi_i,\quad i=1,\dots,l" class="mathcode" src="https://latex.csdn.net/eq?y_i%5C%2C%28%5Clangle%20w%2C%20x_i%5Crangle%20&amp;plus;%20b%29%20%5C%3B%5Cge%5C%3B%201%20-%20%5Cxi_i%2C%5Cquad%20i%3D1%2C%5Cdots%2Cl"/>
     </li>
     <li>
      对于无标签数据
      <img alt="x_j" class="mathcode" src="https://latex.csdn.net/eq?x_j"/>
      ​，令其“标签”也作为变量
      <img alt="y_j \in \{-1,+1\}" class="mathcode" src="https://latex.csdn.net/eq?y_j%20%5Cin%20%5C%7B-1%2C&amp;plus;1%5C%7D"/>
      。对应的软间隔
      <img alt="\xi_j" class="mathcode" src="https://latex.csdn.net/eq?%5Cxi_j"/>
      ​ 要满足：
      <img alt="y_j\,(\langle w, x_j\rangle + b) \;\ge\; 1 - \xi_j,\quad j=l+1,\dots,l+u" class="mathcode" src="https://latex.csdn.net/eq?y_j%5C%2C%28%5Clangle%20w%2C%20x_j%5Crangle%20&amp;plus;%20b%29%20%5C%3B%5Cge%5C%3B%201%20-%20%5Cxi_j%2C%5Cquad%20j%3Dl&amp;plus;1%2C%5Cdots%2Cl&amp;plus;u"/>
      .  换言之，我们同时要决定
      <img alt="y_j" class="mathcode" src="https://latex.csdn.net/eq?y_j"/>
      ​ 和
      <img alt="w,b" class="mathcode" src="https://latex.csdn.net/eq?w%2Cb"/>
      ，让所有样本尽量远离分界面。
     </li>
    </ul>
    <p>
     因为无标签样本的“标签”也是待优化变量，这会形成一个
     <strong>
      组合优化
     </strong>
     问题：无标签数据量为
     <img alt="u" class="mathcode" src="https://latex.csdn.net/eq?u"/>
     时，标签配置空间多达
     <img alt="2^u" class="mathcode" src="https://latex.csdn.net/eq?2%5Eu"/>
     ，直接穷举显然不可行。
     <strong>
      S3VMlight
     </strong>
     便是为解决此困难而提出的一种高效近似方法。
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%882%EF%BC%89S3VMlight%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF" name="%EF%BC%882%EF%BC%89S3VMlight%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF">
     （2）S3VMlight 的核心思路
    </h4>
    <p>
     <strong>
      S3VMlight
     </strong>
     的核心可以用“
     <strong>
      局部搜索 + SVM 子问题
     </strong>
     ”来概括：
    </p>
    <ol>
     <li>
      <strong>
       固定无标签数据的某个标签配置
      </strong>
      （如初始时将所有无标签样本设为 +1，或用简单启发式给定）；
     </li>
     <li>
      <strong>
       求解标准 SVM 子问题
      </strong>
      ：在上述固定标签配置下，问题退化为一个有标签数据集(包括真实有标签数据和“临时标注”的无标签数据)的标准 SVM，能用现成的 SVM 优化算法(如 SMO、QP 求解等)快速得到最优解
      <img alt="(w,b)" class="mathcode" src="https://latex.csdn.net/eq?%28w%2Cb%29"/>
      ；
     </li>
     <li>
      <strong>
       试探性地修改(翻转)部分无标签样本的标签
      </strong>
      ：例如将某个无标签样本从 +1 改为 -1，或者从 -1 改为 +1，然后再次训练 SVM，观察目标函数是否下降；若能改进，就接受这次翻转；
     </li>
     <li>
      <strong>
       不断重复
      </strong>
      ，直到无法通过翻转单个(或小批量)无标签样本标签而进一步降低目标函数。
     </li>
    </ol>
    <p>
     这种“
     <strong>
      翻转 + 重训练
     </strong>
     ”形成了一种局部组合搜索(“local combinatorial search”)，每次只在邻域内(翻转少数样本)寻找更优解，因而算法不会因无标签量大而彻底失控。虽然可能会陷入局部最优，但在大规模数据上往往效果可观。
    </p>
    <h6 id="2.1%20%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88" name="2.1%20%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88">
     2.1 算法结构概览
    </h6>
    <p>
     假设无标签样本索引为
     <img alt="U = \{l+1,\dots,l+u\}" class="mathcode" src="https://latex.csdn.net/eq?U%20%3D%20%5C%7Bl&amp;plus;1%2C%5Cdots%2Cl&amp;plus;u%5C%7D"/>
     ，初始为每个
     <img alt="j \in U" class="mathcode" src="https://latex.csdn.net/eq?j%20%5Cin%20U"/>
     赋予标签
     <img alt="y_j^{(0)} \in \{-1,+1\}" class="mathcode" src="https://latex.csdn.net/eq?y_j%5E%7B%280%29%7D%20%5Cin%20%5C%7B-1%2C&amp;plus;1%5C%7D"/>
     。然后迭代如下步骤：
    </p>
    <ol>
     <li>
      <strong>
       训练 SVM
      </strong>
      ：
      <br/>
      固定
      <img alt="\{y_j^{(t)}\}" class="mathcode" src="https://latex.csdn.net/eq?%5C%7By_j%5E%7B%28t%29%7D%5C%7D"/>
      (第
      <img alt="t" class="mathcode" src="https://latex.csdn.net/eq?t"/>
      次迭代的标签配置)，用标准 SVM 优化求解
      <img alt="\min \frac12 \|w\|^2 + C_1\sum \xi_i + C_2 \sum \xi_j" class="mathcode" src="https://latex.csdn.net/eq?%5Cmin%20%5Cfrac12%20%5C%7Cw%5C%7C%5E2%20&amp;plus;%20C_1%5Csum%20%5Cxi_i%20&amp;plus;%20C_2%20%5Csum%20%5Cxi_j"/>
      ​，得到
      <img alt="(w^{(t)}, b^{(t)})" class="mathcode" src="https://latex.csdn.net/eq?%28w%5E%7B%28t%29%7D%2C%20b%5E%7B%28t%29%7D%29"/>
      。
     </li>
     <li>
      <strong>
       尝试翻转
      </strong>
      ：
      <br/>
      在无标签集合
      <img alt="U" class="mathcode" src="https://latex.csdn.net/eq?U"/>
      中，依次试着翻转单个或小批量样本的标签：
      <img alt="y_j^{(t+1)} \;\leftarrow\; -\,y_j^{(t)}" class="mathcode" src="https://latex.csdn.net/eq?y_j%5E%7B%28t&amp;plus;1%29%7D%20%5C%3B%5Cleftarrow%5C%3B%20-%5C%2Cy_j%5E%7B%28t%29%7D"/>
      ​, 重新训练 SVM 并计算目标函数值(或近似目标值)，若下降则接受翻转，否则回退。
     </li>
     <li>
      <strong>
       重复
      </strong>
      ，直到所有样本都无法进一步通过翻转降低目标函数时，输出当前解。
     </li>
    </ol>
    <p>
     在实际实现中，
     <strong>
      S3VMlight
     </strong>
     还会用到
     <strong>
      启发式
     </strong>
     来加速翻转决策、减少反复完整训练的次数（例如：只挑“边缘附近”的无标签点尝试翻转，或一次性评估多个点的翻转对目标函数的影响等）。
    </p>
    <p>
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E7%BF%BB%E8%BD%AC%E5%88%A4%E6%96%AD" name="%EF%BC%883%EF%BC%89%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E7%BF%BB%E8%BD%AC%E5%88%A4%E6%96%AD">
     （3）目标函数的本质与翻转判断
    </h4>
    <h6 id="3.1%20%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0" name="3.1%20%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0">
     3.1 目标函数
    </h6>
    <p>
     从
     <strong>
      S3VM
     </strong>
     的角度看，完整目标函数可写为（带松弛变量）：
    </p>
    <p>
     <img alt="\begin{aligned} &amp;\min_{\substack{w,b,\,\{\xi_i\},\,\{\xi_j\},\\ y_j\in\{-1,+1\}}} &amp;&amp; \frac12 \|w\|^2 \;+\; C_1 \sum_{i=1}^l \xi_i \;+\; C_2 \sum_{j=l+1}^{l+u} \xi_j,\\ &amp;\text{s.t.} &amp;&amp; y_i \,\bigl(\langle w,x_i\rangle + b\bigr) \;\ge\; 1 - \xi_i,\quad \xi_i\ge 0,\quad i=1,\dots,l,\\ &amp;&amp;&amp; y_j \,\bigl(\langle w,x_j\rangle + b\bigr) \;\ge\; 1 - \xi_j,\quad \xi_j\ge 0,\quad j=l+1,\dots,l+u. \end{aligned}" class="mathcode" src="https://latex.csdn.net/eq?%5Cbegin%7Baligned%7D%20%26%5Cmin_%7B%5Csubstack%7Bw%2Cb%2C%5C%2C%5C%7B%5Cxi_i%5C%7D%2C%5C%2C%5C%7B%5Cxi_j%5C%7D%2C%5C%5C%20y_j%5Cin%5C%7B-1%2C&amp;plus;1%5C%7D%7D%7D%20%26%26%20%5Cfrac12%20%5C%7Cw%5C%7C%5E2%20%5C%3B&amp;plus;%5C%3B%20C_1%20%5Csum_%7Bi%3D1%7D%5El%20%5Cxi_i%20%5C%3B&amp;plus;%5C%3B%20C_2%20%5Csum_%7Bj%3Dl&amp;plus;1%7D%5E%7Bl&amp;plus;u%7D%20%5Cxi_j%2C%5C%5C%20%26%5Ctext%7Bs.t.%7D%20%26%26%20y_i%20%5C%2C%5Cbigl%28%5Clangle%20w%2Cx_i%5Crangle%20&amp;plus;%20b%5Cbigr%29%20%5C%3B%5Cge%5C%3B%201%20-%20%5Cxi_i%2C%5Cquad%20%5Cxi_i%5Cge%200%2C%5Cquad%20i%3D1%2C%5Cdots%2Cl%2C%5C%5C%20%26%26%26%20y_j%20%5C%2C%5Cbigl%28%5Clangle%20w%2Cx_j%5Crangle%20&amp;plus;%20b%5Cbigr%29%20%5C%3B%5Cge%5C%3B%201%20-%20%5Cxi_j%2C%5Cquad%20%5Cxi_j%5Cge%200%2C%5Cquad%20j%3Dl&amp;plus;1%2C%5Cdots%2Cl&amp;plus;u.%20%5Cend%7Baligned%7D"/>
    </p>
    <p>
     当我们固定了无标签数据的标签配置
     <img alt="\{y_j\}" class="mathcode" src="https://latex.csdn.net/eq?%5C%7By_j%5C%7D"/>
     ，该问题就变成了一个
     <strong>
      标准的有标签 SVM
     </strong>
     (只不过超参数和样本数量增加了)；而当我们尝试翻转某个样本
     <img alt="x_j" class="mathcode" src="https://latex.csdn.net/eq?x_j"/>
     ​ 的标签时，就相当于把它从正样本变成负样本（或反之），需要重新求解一遍 SVM 子问题并比较新的目标函数值是否更优。
    </p>
    <h6 id="3.2%20%E7%BF%BB%E8%BD%AC%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6" name="3.2%20%E7%BF%BB%E8%BD%AC%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6">
     3.2 翻转判断条件
    </h6>
    <p>
     <strong>
      S3VMlight
     </strong>
     中，翻转判断一般采用“若翻转标签能显著降低目标函数，则执行翻转”的规则。翻转后再解一次标准 SVM 子问题，若目标值(或者近似值)更小，就说明翻转是有利的。
     <br/>
     在实现层面，直接每次都完整训练 SVM 的计算开销较大，因此 S3VMlight 通常会用一些
     <strong>
      启发式近似
     </strong>
     来估计翻转对目标函数的影响，比如利用当前解
     <img alt="(w^{(t)}, b^{(t)})" class="mathcode" src="https://latex.csdn.net/eq?%28w%5E%7B%28t%29%7D%2C%20b%5E%7B%28t%29%7D%29"/>
     的梯度信息、松弛变量
     <img alt="\xi_j" class="mathcode" src="https://latex.csdn.net/eq?%5Cxi_j"/>
     ​ 的大小、或距离决策边界的远近等，做快速筛选，然后再对少数“翻转可行性高”的样本做精确重训练检验。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35363939373139322f:61727469636c652f64657461696c732f313436313139393932" class_="artid" style="display:none">
 </p>
</div>


