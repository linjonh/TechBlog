---
layout: post
title: "unity基础3D画线"
date: 2025-03-13 19:14:14 +0800
description: "主要属性：positions（坐标点集合）、width（线条粗细）、material（外观材质）相比数组，支持动态扩容和便捷操作（Add/Clear等）Unity的组件类，用于在3D空间绘制连续线段。依赖Collider组件，用于准确定位绘制位置。静态方法，计算两个三维点之间的欧几里得距离。物理检测方法，发射不可见射线检测碰撞体。：每帧检测鼠标移动，满足条件时添加新点。使用List管理坐标点，自动处理内存。：线端顶点数，影响端点圆滑度。：拐角顶点数，影响转角平滑度。：初始化新线条，记录起始点。"
keywords: "unity基础——3D画线"
categories: ['学习', 'Unity']
tags: ['游戏引擎', 'Unity', '3D']
artid: "146239865"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146239865
    alt: "unity基础3D画线"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146239865
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146239865
cover: https://bing.ee123.net/img/rand?artid=146239865
image: https://bing.ee123.net/img/rand?artid=146239865
img: https://bing.ee123.net/img/rand?artid=146239865
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     unity基础——3D画线
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" height="381" src="https://i-blog.csdnimg.cn/direct/683cf8b77b6e4a428aa3bd15248d48e0.png" width="900"/>
    </p>
    <h4>
     关键术语解释：
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        LineRenderer
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Unity的组件类，用于在3D空间绘制连续线段
        </p>
       </li>
       <li>
        <p>
         主要属性：positions（坐标点集合）、width（线条粗细）、material（外观材质）
        </p>
       </li>
       <li>
        <p>
         <code>
          numCapVertices
         </code>
         ：线端顶点数，影响端点圆滑度
        </p>
       </li>
       <li>
        <p>
         <code>
          numCornerVertices
         </code>
         ：拐角顶点数，影响转角平滑度
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Raycast
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         物理检测方法，发射不可见射线检测碰撞体
        </p>
       </li>
       <li>
        <p>
         <code>
          ScreenPointToRay
         </code>
         ：将
         <strong>
          屏幕坐标转换为3D空间射线
         </strong>
        </p>
       </li>
       <li>
        <p>
         依赖Collider组件，用于准确定位绘制位置
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        List&lt;Vector3&gt;
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         C#泛型集合，动态存储坐标序列
        </p>
       </li>
       <li>
        <p>
         相比数组，支持动态扩容和便捷操作（Add/Clear等）
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Vector3.Distance
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         静态方法，计算两个三维点之间的欧几里得距离
        </p>
       </li>
       <li>
        <p>
         用于判断鼠标移动量是否达到绘制阈值
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        UI Toggle
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Unity UI系统的开关组件
        </p>
       </li>
       <li>
        <p>
         通过OnValueChanged事件绑定颜色/尺寸切换方法
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     脚本设计思路：
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        输入处理流程
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          按下阶段
         </strong>
         ：初始化新线条，记录起始点
        </p>
       </li>
       <li>
        <p>
         <strong>
          持续阶段
         </strong>
         ：每帧检测鼠标移动，满足条件时添加新点
        </p>
       </li>
       <li>
        <p>
         <strong>
          释放阶段
         </strong>
         ：清理数据，准备下次绘制
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        坐标获取机制
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用主摄像机发射射线
        </p>
       </li>
       <li>
        <p>
         依赖场景中的Collider获取准确坐标
        </p>
       </li>
       <li>
        <p>
         Z轴偏移解决渲染重叠问题
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        渲染优化策略
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         动态更新LineRenderer的positions数组
        </p>
       </li>
       <li>
        <p>
         使用List管理坐标点，自动处理内存
        </p>
       </li>
       <li>
        <p>
         通过顶点数配置提升线条视觉质量
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        模块化设计
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         分离核心绘制逻辑（AddPosition）
        </p>
       </li>
       <li>
        <p>
         独立坐标获取方法（GetMousePoint）
        </p>
       </li>
       <li>
        <p>
         清晰的UI事件处理区域
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     实现代码：
    </h4>
    <pre><code class="language-cs">using System.Collections.Generic;
using UnityEngine;

public class Mapaint : MonoBehaviour
{
    // 画笔颜色属性 和 画笔大小属性
    public Color paintColor = Color.red;
    public float paintSize = 0.1f;
    // 当前画线
    public LineRenderer Currentline;
    // 画线的材质
    public Material lineMaterial;
    //存储线条点的坐标集合
    private List&lt;Vector3&gt; positions = new List&lt;Vector3&gt;();
    // 鼠标按下状态标志
    private bool isMouseDown = false;
    // 鼠标上一帧位置
    private Vector3 lastMousePosition = Vector3.zero;

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            // 创建新的游戏对象承载LineRenderer组件
            GameObject go = new GameObject();
            go.transform.SetParent(this.transform);  // 挂载到当前物体下
            Currentline = go.AddComponent&lt;LineRenderer&gt;();  // 添加LineRenderer组件

            // 设置材质
            Currentline.material = lineMaterial;
            // 设置宽度
            Currentline.startWidth = paintSize;
            Currentline.endWidth = paintSize;
            // 设置颜色
            Currentline.startColor = paintColor;
            Currentline.endColor = paintColor;

            Currentline.numCapVertices = 5;  // 设置顶点数
            Currentline.numCornerVertices = 5;  // 设置角点数

            // 初始化第一个点
            Vector3 position = GetMousePoint();
            position.z -= 1f;
            positions.Clear();
            AddPosition(position);  // 调用AddPosition方法
            lastMousePosition = position; // 记录初始位置

            // 标记鼠标按下状态
            isMouseDown = true;


        }
        // 持续按住鼠标时持续添加点
        if (isMouseDown)
        {
            Vector3 currentPos = GetMousePoint();
            currentPos.z -= 1f;
           
            // 鼠标移动时，距离大于0.01时才添加点
            if (Vector3.Distance(currentPos, lastMousePosition) &gt; 0.01f)
            {
                AddPosition(currentPos);
                lastMousePosition = currentPos;
                Debug.Log("加点");
            }
        }

        // 鼠标松开时结束绘制
        if (Input.GetMouseButtonUp(0))
        {
            Currentline = null;
            // 清空历史坐标点
            positions.Clear();
            isMouseDown = false;
        }

        // 添加坐标点到当前线条
        void AddPosition(Vector3 position)
        {
            positions.Add(position);

            // 更新LineRenderer数据
            Currentline.positionCount = positions.Count;
            Currentline.SetPositions(positions.ToArray());

        }
        // 通过射线检测获取鼠标在场景中的坐标（需要场景中存在碰撞体）
        Vector3 GetMousePoint()
        {
            // 创建从摄像机发射的射线
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;  // 存储射线碰撞信息的结构体

            // 进行物理射线检测（最大距离默认为无限）
            bool isCollider = Physics.Raycast(ray, out hit);
            if (isCollider)
            {
                return hit.point;  // 返回碰撞点的世界坐标
            }

            return Vector3.zero;  // 安全返回值

        }
    }

    #region
    public void OnRedColorChanged(bool isON)
    {
        if (isON)
        {
            paintColor = Color.red;
        }
    }
    public void OnGreenColorChanged(bool isON)
    {
        if (isON)
        {
            paintColor = Color.green;
        }
    }
    public void OnBlueColorChanged(bool isON)
    {
        if (isON)
        {
            paintColor = Color.blue;
        }
    }
    public void OnPaint1Changed(bool isON)
    {
        if (isON)
        {
            paintSize = 0.1f;
        }
    }
    public void OnPaint2Changed(bool isON)
    {
        if (isON)
        {
            paintSize = 0.2f;
        }
    }
    public void OnPaint3Changed(bool isON)
    {
        if (isON)
        {
            paintSize = 0.4f;
        }
    }
    #endregion
}
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f4c464a494e4e414e2f:61727469636c652f64657461696c732f313436323339383635" class_="artid" style="display:none">
 </p>
</div>


