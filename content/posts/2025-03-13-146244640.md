---
layout: post
title: "QT非模态使用WA_DeleteOnClose避免内存泄漏"
date: 2025-03-13 23:13:02 +0800
description: "创建了一个 `QDialog` 对象 `dlg`，并将其父对象设置为当前对象（`this`）。这意味着 `dlg` 的生命周期与父对象相关联，但父对象不会自动删除 `dlg`，除非显式设置。在对话框关闭后，程序才会继续执行 `exec()` 之后的代码。- 如果你使用 `exec()`，通常不需要手动设置 `Qt::WA_DeleteOnClose`，因为模态对话框通常在关闭后会立即被处理。- `show()` 是非模态对话框的显示方式。关于 `dlg->exec()` 和 `dlg->show()`"
keywords: "QT：非模态使用WA_DeleteOnClose避免内存泄漏"
categories: ['未分类']
tags: ['开发语言', 'Qt']
artid: "146244640"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146244640
    alt: "QT非模态使用WA_DeleteOnClose避免内存泄漏"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146244640
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146244640
cover: https://bing.ee123.net/img/rand?artid=146244640
image: https://bing.ee123.net/img/rand?artid=146244640
img: https://bing.ee123.net/img/rand?artid=146244640
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     QT：非模态使用WA_DeleteOnClose避免内存泄漏
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <pre><code class="language-cpp">connect(ui-&gt;actionnewFile,&amp;QAction::triggered,this,[=](){
      QDialog*dlg = new QDialog(this);
      //dlg.exec();
      dlg-&gt;show();
      dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);
      qDebug()&lt;&lt;"打开对话框";
    });</code></pre>
    <p>
     1. `QDialog* dlg = new QDialog(this);
     <br/>
     - 创建了一个 `QDialog` 对象 `dlg`，并将其父对象设置为当前对象（`this`）。这意味着 `dlg` 的生命周期与父对象相关联，但父对象不会自动删除 `dlg`，除非显式设置。
    </p>
    <p>
     2. dlg-&gt;show();
     <br/>
     - 调用 `show()` 方法将对话框显示出来。它是一个非模态对话框，用户可以在对话框显示的同时与主窗口交互。
    </p>
    <p>
     3. dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);
     <br/>
     - 为对话框设置 `Qt::WA_DeleteOnClose` 属性。这意味着当用户关闭对话框时（例如点击关闭按钮或调用 `close()` 方法），对话框对象会自动被删除，从而避免内存泄漏。
    </p>
    <p>
     关于 `dlg-&gt;exec()` 和 `dlg-&gt;show()`
     <br/>
     dlg-&gt;exec();`
     <br/>
     - `exec()` 是一个模态对话框的显示方式。它会阻塞调用它的线程，直到对话框关闭。在对话框关闭后，程序才会继续执行 `exec()` 之后的代码。
     <br/>
     - 如果你使用 `exec()`，通常不需要手动设置 `Qt::WA_DeleteOnClose`，因为模态对话框通常在关闭后会立即被处理。
    </p>
    <p>
     dlg-&gt;show();
     <br/>
     - `show()` 是非模态对话框的显示方式。它不会阻塞主线程，用户可以在对话框打开的同时与主窗口交互。
     <br/>
     - 在这种情况下，设置 `Qt::WA_DeleteOnClose` 是一个很好的实践，以确保对话框在关闭时被正确删除。
    </p>
    <p>
     总结
     <br/>
     <strong>
      - `dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);` 的作用是**声明**对话框在关闭时自动删除自己，避免内存泄漏。
      <br/>
      - 如果你使用 `show()` 显示对话框，建议设置 `Qt::WA_DeleteOnClose`。
      <br/>
      - 如果你使用 `exec()` 显示对话框，通常不需要设置 `Qt::WA_DeleteOnClose`，因为模态对话框的生命周期通常由代码逻辑控制。
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35373131323931332f:61727469636c652f64657461696c732f313436323434363430" class_="artid" style="display:none">
 </p>
</div>


