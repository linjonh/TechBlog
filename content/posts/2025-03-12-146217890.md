---
layout: post
title: "基于Redis实现限流"
date: 2025-03-12 23:47:41 +0800
description: "限流尽可能在满足需求的情况下越简单越好！"
keywords: "基于Redis实现限流"
categories: ['Redis', 'Java']
tags: ['缓存', '数据库', 'Redis']
artid: "146217890"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146217890
    alt: "基于Redis实现限流"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146217890
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146217890
cover: https://bing.ee123.net/img/rand?artid=146217890
image: https://bing.ee123.net/img/rand?artid=146217890
img: https://bing.ee123.net/img/rand?artid=146217890
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     基于Redis实现限流
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      限流尽可能在满足需求的情况下越简单越好！
     </p>
    </blockquote>
    <h2>
     1、基于Redsi的increment方法实现固定窗口限流
    </h2>
    <ul>
     <li>
      Redis的increment方法保证并发线程安全
     </li>
     <li>
      窗口尽可能越小越好(太大可能某一小段时间就打满请求剩下的都拿不到令牌了)
     </li>
     <li>
      这个原理其实就是用当前时间戳然后除窗口大小 在这个窗口大小的时间内 key都一样
     </li>
    </ul>
    <pre><code class="hljs">public class RedisRateLimiter {


    private final StringRedisTemplate redisTemplate;
    // 命令前缀
    private final String key;

    private final int rate;

    private final int window;

    public RedisRateLimiter(StringRedisTemplate redisTemplate, String key, int rate,int window) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        this.rate = rate;
        Assert.isTrue(window &gt; 0 &amp;&amp; window &lt;= 60,"窗口只支持分钟内");
        this.window = window;
    }

    // 检查并获取令牌
    public boolean acquire() {
        String currentKey = key + "_" + (DateUtil.currentSeconds() / window);

        Long currentCount = redisTemplate.opsForValue().increment(currentKey);

        redisTemplate.expire(currentKey, window, TimeUnit.SECONDS);

        if (currentCount &gt; rate){
            return false;
        }
        return true;
    }


    public void acquireSleep() {
        int count = 0;
        while (!acquire()){
            ThreadUtil.sleep(1,TimeUnit.SECONDS);
            count++;
            log.info("RedisRateLimiter[{}] try acquire sleep {}",key,count);
        }
    }

    public boolean acquireSleep(int waitSecond) {
        int count = 0;
        while (!acquire()){
            if (count &gt;= waitSecond){
                return false;
            }
            ThreadUtil.sleep(1,TimeUnit.SECONDS);
            count++;
            log.info("RedisRateLimiter[{}] try acquire sleep {}",key,count);
        }
        return true;
    }

}</code></pre>
    <p>
     使用案例：
    </p>
    <p>
     下面这个任务是实时请求评论和子评论接口，但是两个接口每分钟不能超过100，所以我们使用限流限制10秒不超过18即可也能满足需求。
    </p>
    <pre><code class="hljs">public class ScCommentRealTimeSyncTask  {
        private RedisRateLimiter rateLimiter;

        @PostConstruct
        public void init(){
            rateLimiter = new
                    RedisRateLimiter(stringRedisTemplate,KAOLA_COMMENT_RATE_KEY,16,10);
        }

        @Scheduled(fixedDelay = 3000)
        public void task(){
            // 请求接口1
            rateLimiter.acquireSleep();
            request1();
            
            //请求接口2
            rateLimiter.acquireSleep();
            request2();

        }


    }</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34333536363738322f:61727469636c652f64657461696c732f313436323137383930" class_="artid" style="display:none">
 </p>
</div>


