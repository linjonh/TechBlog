---
layout: post
title: "基于Redis实现限流"
date: 2025-03-12 23:47:41 +0800
description: "限流尽可能在满足需求的情况下越简单越好！"
keywords: "基于Redis实现限流"
categories: ['Redis', 'Java']
tags: ['缓存', '数据库', 'Redis']
artid: "146217890"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146217890
    alt: "基于Redis实现限流"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146217890
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146217890
cover: https://bing.ee123.net/img/rand?artid=146217890
image: https://bing.ee123.net/img/rand?artid=146217890
img: https://bing.ee123.net/img/rand?artid=146217890
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     基于Redis实现限流
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      限流尽可能在满足需求的情况下越简单越好！
     </p>
     <p>
      分布式限流是指在分布式系统中对请求进行限制，以防止系统过载或滥用资源。以下是常见的分布式限流策略及其实现方式：
     </p>
    </blockquote>
    <h2>
     1、基于 Redis 的固定窗口限流
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：
    </p>
    <ul>
     <li>
      设定一个时间窗口（如 1 秒）
     </li>
     <li>
      使用 Redis 维护一个计数器，存储当前窗口的请求数
     </li>
     <li>
      当请求到来时，
      <code>
       INCR
      </code>
      计数器，如果超过阈值则拒绝
     </li>
     <li>
      过期后自动删除键，进入下一个窗口
     </li>
    </ul>
    <p>
     <strong>
      优缺点
     </strong>
     ： ✅ 简单易实现
     <br/>
     ❌ 在窗口交界处可能会出现短时间的突发流量（"临界突增"）
    </p>
    <pre><code>public class RedisRateLimiter {


    private final StringRedisTemplate redisTemplate;
    // 命令前缀
    private final String key;

    private final int rate;

    private final int window;

    public RedisRateLimiter(StringRedisTemplate redisTemplate, String key, int rate,int window) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        this.rate = rate;
        Assert.isTrue(window &gt; 0 &amp;&amp; window &lt;= 60,"窗口只支持分钟内");
        this.window = window;
    }

    // 检查并获取令牌
    public boolean acquire() {
        String currentKey = key + "_" + (DateUtil.currentSeconds() / window);

        Long currentCount = redisTemplate.opsForValue().increment(currentKey);

        redisTemplate.expire(currentKey, window, TimeUnit.SECONDS);

        if (currentCount &gt; rate){
            return false;
        }
        return true;
    }


    public void acquireSleep() {
        int count = 0;
        while (!acquire()){
            ThreadUtil.sleep(1,TimeUnit.SECONDS);
            count++;
            log.info("RedisRateLimiter[{}] try acquire sleep {}",key,count);
        }
    }

    public boolean acquireSleep(int waitSecond) {
        int count = 0;
        while (!acquire()){
            if (count &gt;= waitSecond){
                return false;
            }
            ThreadUtil.sleep(1,TimeUnit.SECONDS);
            count++;
            log.info("RedisRateLimiter[{}] try acquire sleep {}",key,count);
        }
        return true;
    }

}</code></pre>
    <p>
     使用案例：
    </p>
    <p>
     下面这个任务是实时请求评论和子评论接口，但是两个接口每分钟不能超过100，所以我们使用限流限制10秒不超过18即可也能满足需求。
    </p>
    <pre><code>public class ScCommentRealTimeSyncTask  {
        private RedisRateLimiter rateLimiter;

        @PostConstruct
        public void init(){
            rateLimiter = new
                    RedisRateLimiter(stringRedisTemplate,KAOLA_COMMENT_RATE_KEY,16,10);
        }

        @Scheduled(fixedDelay = 3000)
        public void task(){
            // 请求接口1
            rateLimiter.acquireSleep();
            request1();
            
            //请求接口2
            rateLimiter.acquireSleep();
            request2();

        }


    }</code></pre>
    <h2>
     2.
     <strong>
      基于 Redis 的滑动窗口限流
     </strong>
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：
    </p>
    <ul>
     <li>
      维护一个基于时间的列表（ZSET，有序集合）
     </li>
     <li>
      每次请求时，记录当前时间戳到 ZSET
     </li>
     <li>
      删除超出窗口时间范围的请求
     </li>
     <li>
      统计 ZSET 中当前窗口内的请求数，超出阈值则拒绝
     </li>
    </ul>
    <p>
     <strong>
      优缺点
     </strong>
     ： ✅ 解决了固定窗口的临界突增问题
     <br/>
     ❌ 存储和计算成本比固定窗口稍高
    </p>
    <p>
     <strong>
      原理说明
     </strong>
    </p>
    <ul>
     <li>
      利用 Redis 的有序集合（ZSet），以请求的时间戳作为 score，每个请求入队一个唯一的 member（例如时间戳+UUID）。
     </li>
     <li>
      每次请求时，先移除时间窗口外的记录（score 小于当前时间减去窗口长度）。
     </li>
     <li>
      统计当前窗口内的请求数量，若数量超过设定阈值，则拒绝请求。
     </li>
    </ul>
    <pre><code class="hljs">@Slf4j
public class RedisSlidingWindowRateLimiter {

    private final StringRedisTemplate redisTemplate;
    private final String key;
    private final int rate;
    private final int window; // 窗口长度，单位秒

    public RedisSlidingWindowRateLimiter(StringRedisTemplate redisTemplate, String key, int rate, int window) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        this.rate = rate;
        // 限制窗口长度在 1 分钟以内
        Assert.isTrue(window &gt; 0 &amp;&amp; window &lt;= 60, "窗口只支持一分钟内");
        this.window = window;
    }

    // 检查并获取令牌
    public boolean acquire() {
        long now = System.currentTimeMillis();
        // 计算窗口起始时间（单位毫秒）
        long windowStart = now - window * 1000;
        // 移除过期的请求记录
        redisTemplate.opsForZSet().removeRangeByScore(key, 0, windowStart);
        // 添加当前请求记录，member 用当前时间戳加 UUID 保证唯一性，score 为当前时间
        String member = now + "_" + UUID.randomUUID().toString();
        redisTemplate.opsForZSet().add(key, member, now);
        // 统计当前窗口内的请求数量
        Long count = redisTemplate.opsForZSet().count(key, windowStart, now);
        // 为了避免 key 永不过期，设置一个过期时间（窗口长度）
        redisTemplate.expire(key, window, TimeUnit.SECONDS);
        if (count != null &amp;&amp; count &gt; rate) {
            return false;
        }
        return true;
    }

    // 采用轮询方式等待获取令牌
    public void acquireSleep() {
        int count = 0;
        while (!acquire()){
            ThreadUtil.sleep(1, TimeUnit.SECONDS);
            count++;
            log.info("RedisSlidingWindowRateLimiter[{}] try acquire sleep {}", key, count);
        }
    }

    public boolean acquireSleep(int waitSecond) {
        int count = 0;
        while (!acquire()){
            if (count &gt;= waitSecond){
                return false;
            }
            ThreadUtil.sleep(1, TimeUnit.SECONDS);
            count++;
            log.info("RedisSlidingWindowRateLimiter[{}] try acquire sleep {}", key, count);
        }
        return true;
    }
}
</code></pre>
    <p>
     <strong>
      代码说明
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       移除过期记录
      </strong>
      ：调用
      <code>
       removeRangeByScore
      </code>
      清理掉窗口外的请求数据。
     </li>
     <li>
      <strong>
       添加当前请求
      </strong>
      ：将当前请求的时间戳与 UUID 组合后添加到 ZSet 中，score 为当前时间，确保在滑动窗口内计数。
     </li>
     <li>
      <strong>
       统计计数
      </strong>
      ：通过
      <code>
       count
      </code>
      方法统计当前窗口内的请求数，如果超出限制则返回 false。
     </li>
    </ul>
    <h2>
     3.
     <strong>
      基于 Redis 的令牌桶限流
     </strong>
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：
    </p>
    <ul>
     <li>
      设定一个容量为
      <code>
       max_tokens
      </code>
      的令牌桶，初始装满
     </li>
     <li>
      以固定速率向桶中添加令牌（如每秒 10 个）
     </li>
     <li>
      每次请求需要消耗一个令牌，没有令牌时拒绝请求
     </li>
     <li>
      通常使用 Redis 的
      <code>
       Lua
      </code>
      脚本实现原子操作
     </li>
    </ul>
    <p>
     <strong>
      优缺点
     </strong>
     ： ✅ 更加平滑，支持突发流量
     <br/>
     ❌ 需要额外的定时任务或后台线程补充令牌
    </p>
    <p>
     <strong>
      原理说明
     </strong>
    </p>
    <ul>
     <li>
      令牌桶算法中，设定一个桶最大容量
      <code>
       capacity
      </code>
      ，同时以一定速率
      <code>
       refillRate
      </code>
      补充令牌。
     </li>
     <li>
      每次请求需要消耗一个令牌，若当前桶内令牌不足，则拒绝请求。
     </li>
     <li>
      为保证原子性，利用 Redis 的 Lua 脚本将令牌获取和补充过程封装为原子操作。
     </li>
    </ul>
    <pre><code class="hljs">@Slf4j
public class RedisTokenBucketRateLimiter {

    private final StringRedisTemplate redisTemplate;
    private final String key;
    // 桶的容量（最大令牌数）
    private final int capacity;
    // 令牌补充速率，单位：个/秒
    private final double refillRate;

    // Lua 脚本，用于原子化处理令牌桶逻辑
    private static final String LUA_SCRIPT = 
        "local tokens_key = KEYS[1] .. ':tokens' \n" +
        "local timestamp_key = KEYS[1] .. ':ts' \n" +
        "local capacity = tonumber(ARGV[1]) \n" +
        "local refill_rate = tonumber(ARGV[2]) \n" +
        "local current_time = tonumber(ARGV[3]) \n" +
        "local requested = tonumber(ARGV[4]) \n" +
        "local tokens = tonumber(redis.call('get', tokens_key) or capacity) \n" +
        "local last_refill = tonumber(redis.call('get', timestamp_key) or current_time) \n" +
        "local delta = current_time - last_refill \n" +
        "local tokens_to_add = delta * refill_rate \n" +
        "tokens = math.min(capacity, tokens + tokens_to_add) \n" +
        "if tokens &lt; requested then \n" +
        "   return 0 \n" +
        "else \n" +
        "   tokens = tokens - requested \n" +
        "   redis.call('set', tokens_key, tokens) \n" +
        "   redis.call('set', timestamp_key, current_time) \n" +
        "   return 1 \n" +
        "end";

    public RedisTokenBucketRateLimiter(StringRedisTemplate redisTemplate, String key, int capacity, double refillRate) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        this.capacity = capacity;
        this.refillRate = refillRate;
    }

    // 检查并获取令牌
    public boolean acquire() {
        // 当前时间（单位秒）
        long currentTime = System.currentTimeMillis() / 1000;
        // 请求消耗 1 个令牌
        Long result = redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; {
            List&lt;byte[]&gt; keys = Collections.singletonList(key.getBytes());
            List&lt;byte[]&gt; args = Arrays.asList(
                String.valueOf(capacity).getBytes(),
                String.valueOf(refillRate).getBytes(),
                String.valueOf(currentTime).getBytes(),
                "1".getBytes()
            );
            return connection.eval(LUA_SCRIPT.getBytes(), ReturnType.INTEGER, keys.size(), keys.toArray(new byte[0][]), args.toArray(new byte[0][]));
        });
        return result != null &amp;&amp; result == 1;
    }
}
</code></pre>
    <p>
     <strong>
      代码说明
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Lua 脚本逻辑
      </strong>
      ：
      <ul>
       <li>
        获取当前桶中剩余令牌数和上次补充时间，若不存在则默认初始化为满桶状态。
       </li>
       <li>
        根据当前时间与上次更新时间的差值计算应补充的令牌数，并更新桶内令牌。
       </li>
       <li>
        判断是否有足够令牌供本次请求（默认请求 1 个令牌），若不足返回 0，否则扣减令牌并更新上次补充时间，返回 1。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       原子执行
      </strong>
      ：通过 redisTemplate 的
      <code>
       eval
      </code>
      方法保证 Lua 脚本的原子性，避免并发问题。
     </li>
    </ul>
    <h2>
     4.
     <strong>
      基于 Redis 的漏桶限流
     </strong>
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：
    </p>
    <ul>
     <li>
      设定一个队列模拟漏桶
     </li>
     <li>
      按固定速率从队列取出请求执行
     </li>
     <li>
      请求过多时，超出队列长度的请求被丢弃
     </li>
    </ul>
    <p>
     <strong>
      优缺点
     </strong>
     ： ✅ 输出速率稳定，不受突发流量影响
     <br/>
     ❌ 可能会丢弃部分流量
    </p>
    <p>
     <strong>
      原理说明
     </strong>
    </p>
    <ul>
     <li>
      漏桶算法中，将请求看作向桶中注入的“水”，桶以固定速率漏水（处理请求）。
     </li>
     <li>
      当桶中水量超过预设容量时，则拒绝新请求。
     </li>
     <li>
      同样利用 Lua 脚本保证原子操作。
     </li>
    </ul>
    <pre><code class="hljs">@Slf4j
public class RedisLeakyBucketRateLimiter {

    private final StringRedisTemplate redisTemplate;
    private final String key;
    // 桶的容量（允许的最大突发请求数）
    private final int capacity;
    // 漏水速率，单位：个/秒，表示每秒可处理的请求数
    private final double leakRate;

    // Lua 脚本，用于原子化处理漏桶逻辑
    private static final String LUA_SCRIPT = 
        "local level_key = KEYS[1] .. ':level' \n" +
        "local timestamp_key = KEYS[1] .. ':ts' \n" +
        "local capacity = tonumber(ARGV[1]) \n" +
        "local leak_rate = tonumber(ARGV[2]) \n" +
        "local current_time = tonumber(ARGV[3]) \n" +
        "local level = tonumber(redis.call('get', level_key) or '0') \n" +
        "local last_time = tonumber(redis.call('get', timestamp_key) or current_time) \n" +
        "local delta = current_time - last_time \n" +
        "local leaked = delta * leak_rate \n" +
        // 计算漏水后桶内水量，不能低于 0
        "level = math.max(0, level - leaked) \n" +
        "if level + 1 &gt; capacity then \n" +
        "   return 0 \n" +
        "else \n" +
        "   level = level + 1 \n" +
        "   redis.call('set', level_key, level) \n" +
        "   redis.call('set', timestamp_key, current_time) \n" +
        "   return 1 \n" +
        "end";

    public RedisLeakyBucketRateLimiter(StringRedisTemplate redisTemplate, String key, int capacity, double leakRate) {
        this.redisTemplate = redisTemplate;
        this.key = key;
        this.capacity = capacity;
        this.leakRate = leakRate;
    }

    // 检查并获取请求处理资格
    public boolean acquire() {
        // 当前时间（单位秒）
        long currentTime = System.currentTimeMillis() / 1000;
        Long result = redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; {
            List&lt;byte[]&gt; keys = Collections.singletonList(key.getBytes());
            List&lt;byte[]&gt; args = Arrays.asList(
                String.valueOf(capacity).getBytes(),
                String.valueOf(leakRate).getBytes(),
                String.valueOf(currentTime).getBytes()
            );
            return connection.eval(LUA_SCRIPT.getBytes(), ReturnType.INTEGER, keys.size(), keys.toArray(new byte[0][]), args.toArray(new byte[0][]));
        });
        return result != null &amp;&amp; result == 1;
    }
}
</code></pre>
    <p>
     <strong>
      代码说明
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       Lua 脚本逻辑
      </strong>
      ：
      <ul>
       <li>
        从 Redis 中获取当前桶内水量（即请求数量）和上次更新的时间。
       </li>
       <li>
        根据当前时间与上次更新时间的差值和设定的漏水速率计算“漏掉”的水量，并更新桶内水量（不能低于 0）。
       </li>
       <li>
        判断加入当前请求后是否超过桶的容量，超过则返回 0（拒绝），否则将水量加 1 并更新记录，返回 1 表示允许。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       原子执行
      </strong>
      ：同样通过
      <code>
       eval
      </code>
      方法保证操作原子性，避免并发修改问题。
     </li>
    </ul>
    <h3>
     总结
    </h3>
    <ul>
     <li>
      <strong>
       滑动窗口
      </strong>
      ：使用 Redis ZSet 记录请求时间戳，动态统计窗口内请求数，平滑控制突发流量。
     </li>
     <li>
      <strong>
       令牌桶
      </strong>
      ：通过 Lua 脚本实现令牌的自动补充和扣减，支持一定的突发请求。
     </li>
     <li>
      <strong>
       漏桶
      </strong>
      ：用固定漏水速率保证请求以均匀的速率被处理，避免瞬间大量请求。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34333536363738322f:61727469636c652f64657461696c732f313436323137383930" class_="artid" style="display:none">
 </p>
</div>


