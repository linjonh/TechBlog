---
layout: post
title: "JVM垃圾收集器相关面试题1"
date: 2025-03-14 23:54:56 +0800
description: "Jvm 一.核心垃圾收集算法对比  二.分代收集核心机制、#三.永久代演进对比、 四.对象存活判定"
keywords: "JVM垃圾收集器相关面试题（1）"
categories: ['未分类']
tags: ['Jvm']
artid: "146269718"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146269718
    alt: "JVM垃圾收集器相关面试题1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146269718
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146269718
cover: https://bing.ee123.net/img/rand?artid=146269718
image: https://bing.ee123.net/img/rand?artid=146269718
img: https://bing.ee123.net/img/rand?artid=146269718
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM垃圾收集器相关面试题（1）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     垃圾收集与内存管理摘要
    </h2>
    <h3>
     <a id="_2">
     </a>
     一.核心垃圾收集算法对比
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        算法
       </th>
       <th>
        原理
       </th>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
       <th>
        适用场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        标记-清除
       </td>
       <td>
        两次遍历（标记存活对象→清除未标记对象）
       </td>
       <td>
        实现简单
       </td>
       <td>
        内存碎片化、双遍历效率低
       </td>
       <td>
        老年代（结合整理）
       </td>
      </tr>
      <tr>
       <td>
        标记-复制
       </td>
       <td>
        内存对半分，存活对象复制到空白区
       </td>
       <td>
        无碎片、效率高
       </td>
       <td>
        内存利用率50%
       </td>
       <td>
        新生代
       </td>
      </tr>
      <tr>
       <td>
        标记-整理
       </td>
       <td>
        标记后移动存活对象至内存端
       </td>
       <td>
        无碎片、内存利用率高
       </td>
       <td>
        对象移动开销大
       </td>
       <td>
        老年代
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_10">
     </a>
     二.分代收集核心机制
    </h3>
    <h4>
     <a id="_12">
     </a>
     内存分代结构
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        新生代
       </strong>
       （1/3堆）
      </p>
      <ul>
       <li>
        <em>
         Eden区
        </em>
        ：80%空间，新对象初始分配区，通过连续内存分配优化短命对象处理
       </li>
       <li>
        <em>
         Survivor区
        </em>
        ：From/To各10%，存放至少存活一次的对象，采用复制算法
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        老年代
       </strong>
       （2/3堆）：存放长周期对象，采用标记-清除/整理算法
      </p>
     </li>
     <li>
      <p>
       <strong>
        元空间
       </strong>
       （本地内存）：类元数据存储，GC条件更宽松
      </p>
     </li>
    </ul>
    <h4>
     <a id="_21">
     </a>
     回收流程关键点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        Minor GC
       </strong>
       （新生代）
      </p>
      <ul>
       <li>
        触发条件：Eden区满
       </li>
       <li>
        对象晋升：年龄阈值（15）或Survivor空间不足
       </li>
       <li>
        复制效率：仅处理存活对象，存活率&lt;10%时最优
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Full GC
       </strong>
       （全局）
      </p>
      <ul>
       <li>
        触发条件：老年代不足/显式调用
       </li>
       <li>
        性能影响：全堆扫描，停顿时间显著
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_33">
     </a>
     三.永久代演进对比
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        Java7永久代
       </th>
       <th>
        Java8+元空间
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        存储位置
       </td>
       <td>
        堆内存
       </td>
       <td>
        本地内存
       </td>
      </tr>
      <tr>
       <td>
        GC触发条件
       </td>
       <td>
        类+类加载器+反射引用全解除
       </td>
       <td>
        类加载器回收即释放
       </td>
      </tr>
      <tr>
       <td>
        内存管理
       </td>
       <td>
        固定大小易OOM
       </td>
       <td>
        动态扩展
       </td>
      </tr>
      <tr>
       <td>
        性能影响
       </td>
       <td>
        Full GC时扫描
       </td>
       <td>
        独立回收机制
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_42">
     </a>
     四.对象存活判定
    </h3>
    <ul>
     <li>
      <strong>
       可达性分析法
      </strong>
      ：通过GC Roots（栈变量、静态属性、JNI引用）遍历引用链
     </li>
     <li>
      <strong>
       死亡判定流程
      </strong>
      ：两次标记机制（可达性分析→finalize()自救机会→不可达回收）
     </li>
    </ul>
    <blockquote>
     <p>
      关键设计理念：基于对象生命周期特征（98%对象朝生夕死）进行分代优化，通过空间换时间（复制算法）和延迟处理（老年代整理）平衡吞吐量与停顿时间。
     </p>
    </blockquote>
    <h2>
     <a id="_49">
     </a>
     正文
    </h2>
    <h3>
     <a id="_51">
     </a>
     一.常见的垃圾收集算法
    </h3>
    <h4>
     <a id="_53">
     </a>
     标记-清楚
    </h4>
    <p>
     <strong>
      原理：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       标记：从GC Roots（例如栈中的变量，静态变量等）开始便利，标记出所有被引用的对象
      </p>
     </li>
     <li>
      <p>
       清除：遍历整个堆，清除没被标记的对象。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      标记和清除各遍历一次，效率低下
     </li>
     <li>
      可能产生大量不连续的空间，当程序需要分配较大内存时，可能会因为无法找到连续的内存空间导致内存不足，从而提前触发垃圾回收。
     </li>
    </ul>
    <h4>
     <a id="_66">
     </a>
     标记-复制
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：将内存空间化为等大的两块，一般称为（Form和To空间）。每次只是用其中的一块，当这一块用满后，就将存活的对象复制到另一块空间，然后把原来使用的空间直接清理掉。
    </p>
    <p>
     <strong>
      优点：
     </strong>
    </p>
    <ul>
     <li>
      只需要复制存活的对象效率很高
     </li>
     <li>
      清除后的空间是连续的
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      内存空间只占用一般，另一半用来存放复制后的内存，空间浪费严重
     </li>
    </ul>
    <h4>
     <a id="_79">
     </a>
     标记-整理
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：
    </p>
    <ul>
     <li>
      标记：与标记-清除算法相同，从GC Root开始遍历所有存活的对象
     </li>
     <li>
      整理：将存活对象向内存的一端移动，此过程不会清除垃圾对象，而是会把存活对象直接挪到垃圾对象，类似于赋值操作，然后直接清理掉边界以外的内存空间。
     </li>
    </ul>
    <p>
     <strong>
      优点
     </strong>
    </p>
    <ul>
     <li>
      解决了标记-清除算法需要遍历两次和会产生内存碎片的问题，同时也不会和标记-整理算法一样浪费一半的空间
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      整理过程需要移动对象，效率相对较低，尤其是对象过多的情况下
     </li>
    </ul>
    <h4>
     <a id="_94">
     </a>
     分代收集
    </h4>
    <p>
     <strong>
      原理
     </strong>
    </p>
    <ul>
     <li>
      <p>
       基于对象存活周期不同，讲内存化为不同的代
      </p>
     </li>
     <li>
      <p>
       新生代:对象通常“朝生夕死”存活率低。一般采用
       <strong>
        标记-复制算法
       </strong>
      </p>
     </li>
     <li>
      <p>
       老生代:对象通常存活率高，占用空间大。一般采用
       <strong>
        标记-清除
       </strong>
       或
       <strong>
        标记-整理
       </strong>
       算法
      </p>
     </li>
    </ul>
    <p>
     <strong>
      优点
     </strong>
    </p>
    <ul>
     <li>
      根据对象存活特点采用不同算法，提高垃圾回收效率，减少对应用程序性能的影响。
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <ul>
     <li>
      需要对堆内存进行分代管理，增加了垃圾回收器的实现复杂度。
     </li>
    </ul>
    <h3>
     <a id="_112">
     </a>
     二.分代垃圾回收器工作原理详解
    </h3>
    <p>
     分代垃圾回收器是基于一个假说：
     <strong>
      大部分对象生命周期极短，少数对象长期存活。
     </strong>
    </p>
    <h4>
     <a id="_116">
     </a>
     堆内存分代结构
    </h4>
    <ul>
     <li>
      <p>
       新生代
      </p>
      <ul>
       <li>
        <p>
         占堆内存的1/3
        </p>
       </li>
       <li>
        <p>
         分为Eden区（80%）和两个Survivor区（From+To 各10%）
        </p>
        <ul>
         <li>
          为什么要有Eden区？直接和正常的标记-复制算法一样不好吗？只要From和To两个分区
         </li>
         <li>
          因为大多数内存活不过一次GC，新对象直接在连续内存的 Eden 区分配，避免频繁内存整理。集中处理 “朝生暮死” 的对象，减少对 Survivor 区的频繁操作。
          <br/>
          如果只是用From和To两个Survivor区域，则无法隔离新对象和多次存活对象，导致每次 GC 需扫描全部区域，效率降低。
          <br/>
          所以我们再Survivor中存放的是至少存货过一次的对象，Eden区只存放新对象
         </li>
        </ul>
       </li>
       <li>
        <p>
         新对象优先在Eden区分配，若Eden区空间不足，则出发Minor GC
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       老生代
      </p>
      <ul>
       <li>
        占堆内存2/3，存放长期存活的对象
       </li>
       <li>
        当老生代空间不足时，则出发Full GC或Major GC，回收整个堆
       </li>
      </ul>
     </li>
     <li>
      <p>
       元空间
      </p>
      <ul>
       <li>
        取代永久代，存放类元数据，常量池等，GC主要针对不在使用的类的加载器和常量池
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="_137">
     </a>
     对象分配与回收流程
    </h4>
    <p>
     1.对象分配
    </p>
    <ul>
     <li>
      <p>
       新对象先分配到Eden区，若Eden区已满，则出发Minor GC
      </p>
     </li>
     <li>
      <p>
       大对象（如长数组）会直接进入老年代
      </p>
     </li>
    </ul>
    <p>
     2.Minor GC（新生代回收）
    </p>
    <p>
     前面我们总体到Minor GC，那么他到底是个什么呢？
    </p>
    <ul>
     <li>
      存活对象：从 Eden 和 Survivor 区复制到另一个 Survivor 区（复制算法）。
     </li>
     <li>
      对象年龄：每熬过一次 Minor GC，年龄 + 1。
     </li>
     <li>
      晋升老年代：年龄达到阈值（默认 15）或 Survivor 区空间不足时晋升
     </li>
    </ul>
    <p>
     3.Full GC（老年代回收）：
    </p>
    <ul>
     <li>
      <p>
       触发条件：老年代空间不足、显式调用System.gc()等。
      </p>
     </li>
     <li>
      <p>
       使用标记 - 清除或标记 - 整理算法，回收整个堆，耗时长
      </p>
     </li>
    </ul>
    <h3>
     <a id="JVM__160">
     </a>
     三.JVM 永久代中会发生垃圾回收吗
    </h3>
    <ul>
     <li>
      <p>
       Java8前 永久代
      </p>
      <ul>
       <li>
        存储位置：JVM堆内存
       </li>
       <li>
        GC 条件：类需满足：所有实例被回收 + 类加载器被回收 + 无反射引用。
       </li>
       <li>
        问题：容易因类加载过多引发` ‍```rustOutOfMemoryError: PermGen space‍````
       </li>
      </ul>
     </li>
     <li>
      <p>
       Java8+ 元空间
      </p>
      <ul>
       <li>
        <p>
         存储位置：本地内存，不再占用堆。
        </p>
       </li>
       <li>
        <p>
         GC 条件：仅需类加载器被回收，自动释放类元数据。
        </p>
       </li>
       <li>
        <p>
         改进：
        </p>
        <ul>
         <li>
          内存动态扩展，内存取决于物理内存大小
         </li>
         <li>
          减少 OOM 风险，GC 效率更高。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_177">
     </a>
     四.如何判断对象是否存活？
    </h3>
    <h4>
     <a id="_179">
     </a>
     可达性算法
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        原理：
       </strong>
       从CG Roots出发，遍历所有的引用链，无法到达的对象即为死亡
      </p>
     </li>
     <li>
      <p>
       GC Roots 包括：
      </p>
      <ul>
       <li>
        虚拟机栈中局部变量引用的对象。
       </li>
       <li>
        方法区中静态变量和常量引用的对象。
       </li>
       <li>
        本地方法栈中 JNI （Java Native Interface）引用的对象
       </li>
      </ul>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f496861766542422f:61727469636c652f64657461696c732f313436323639373138" class_="artid" style="display:none">
 </p>
</div>


