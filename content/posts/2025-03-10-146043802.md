---
layout: post
title: "Java多线程3单例模式与线程安全"
date: 2025-03-10 18:22:04 +0800
description: "哈喽大家好吖，今天继续给大家分享Java中多线程的学习，今天主要先给上文做个收尾以及讲解单例模式，那么废话不多说，让我们开始吧。"
keywords: "Java【多线程】（3）单例模式与线程安全"
categories: ['未分类']
tags: ['开发语言', '安全', '单例模式', 'Java', 'Intellij', 'Idea']
artid: "146043802"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146043802
    alt: "Java多线程3单例模式与线程安全"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146043802
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146043802
cover: https://bing.ee123.net/img/rand?artid=146043802
image: https://bing.ee123.net/img/rand?artid=146043802
img: https://bing.ee123.net/img/rand?artid=146043802
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java【多线程】（3）单例模式与线程安全
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/071aea4aa98a46b0b5072a96abb15190.jpeg" width="368"/>
    </p>
    <hr/>
    <p>
     <strong>
      目录
     </strong>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <h2>
     1.前言
    </h2>
    <p>
     哈喽大家好吖，今天继续给大家分享Java中多线程的学习，今天主要先给上文做个收尾以及讲解单例模式，那么废话不多说，让我们开始吧。
    </p>
    <h2 id="2.%E6%AD%A3%E6%96%87" name="2.%E6%AD%A3%E6%96%87">
     2.正文
    </h2>
    <h3 id="2.1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB" name="2.1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB">
     2.1线程安全类
    </h3>
    <p>
     先再重新回顾一个概念，到底如何判断会涉及线程安全问题，凡是该方法涉及到修改数据的操作，而且没有内部进行加锁操作，这样就会导致线程安全问题，那么接下来就来详细介绍线程安全类以及线程不安全类：
    </p>
    <blockquote>
     <p>
      <strong>
       常见的线程安全类
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         集合框架
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           Vector
          </code>
          （同步方法）
         </p>
        </li>
        <li>
         <p>
          <code>
           Hashtable
          </code>
          （同步方法）
         </p>
        </li>
        <li>
         <p>
          <code>
           CopyOnWriteArrayList
          </code>
          （写时复制）
         </p>
        </li>
        <li>
         <p>
          <code>
           BlockingQueue
          </code>
          实现类（如
          <code>
           ArrayBlockingQueue
          </code>
          ，用于生产者-消费者模式）
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         原子类
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           AtomicInteger
          </code>
          、
          <code>
           AtomicLong
          </code>
         </p>
        </li>
        <li>
         <p>
          <code>
           AtomicReference
          </code>
          、
          <code>
           AtomicBoolean
          </code>
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         工具类
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           String
          </code>
          （不涉及修改）
         </p>
        </li>
        <li>
         <p>
          <code>
           StringBuffer
          </code>
          （同步方法，线程安全版的
          <code>
           StringBuilder
          </code>
          ）
         </p>
        </li>
        <li>
         <p>
          <code>
           Collections.synchronizedList()
          </code>
          （包装非线程安全集合，如
          <code>
           ArrayList
          </code>
          ）
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <hr/>
    <blockquote>
     <p>
      <strong>
       常见的线程不安全类
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         集合框架（集合类本身没有进行任何加锁限制）
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           ArrayList
          </code>
          、
          <code>
           LinkedList
          </code>
         </p>
        </li>
        <li>
         <p>
          <code>
           HashMap
          </code>
          、
          <code>
           HashSet
          </code>
         </p>
        </li>
        <li>
         <p>
          <code>
           StringBuilder
          </code>
          （非同步的字符序列操作）
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         日期格式化类
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           SimpleDateFormat
          </code>
          （内部状态可变）
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         其他工具类
        </strong>
       </p>
       <ul>
        <li>
         <p>
          <code>
           Random
          </code>
          （共享种子可能导致竞争）
         </p>
        </li>
       </ul>
      </li>
     </ol>
     <p>
      上述集合中，有的虽然有synchronized，但不推荐使用，因为加锁这个事情，是有代价的，一旦在代码中使用了锁，意味着代码可能会因为锁的竞争，产生阻塞，这样程序执行的效率会大打折扣，一旦造成线程阻塞，从cpu中调度走，啥时候才能回来执行就未知了。
     </p>
    </blockquote>
    <h3 id="2.2%E6%9D%82%E8%B0%88%EF%BC%88%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%89" name="2.2%E6%9D%82%E8%B0%88%EF%BC%88%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%89">
     2.2杂谈（介绍几个概念）
    </h3>
    <h4 id="2.2.1%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7" name="2.2.1%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7">
     2.2.1内存可见性
    </h4>
    <p>
     内存可见性也是造成线程安全问题的原因之一，我们先附上一个代码：
    </p>
    <pre><code class="language-java">import java.util.Scanner;

public class test {
    public static int flag = 0;
    public static void main(String[] args) {
        Thread t1 = new Thread(()-&gt;{
            while(flag == 0){

            }
            System.out.println("t1线程结束");
        });

        Thread t2 = new Thread(()-&gt;{
            Scanner scanner = new Scanner(System.in);
            System.out.println("请输入flag值：");
            flag = scanner.nextInt();
        });
        t1.start();
        t2.start();
    }
}</code></pre>
    <p>
     我们尝试运行一下，结果发现：
    </p>
    <p>
     <img alt="" height="293" src="https://i-blog.csdnimg.cn/direct/b2081d8ae4e045ac82b3c6c6d4b79703.png" width="460"/>
    </p>
    <p>
     我们修改了flag值，结果发现t1线程没有像我们预期的会结束线程，一个线程读取，一个线程修改，修改线程的值，并没有被线程读到，这就是
     <strong>
      内存可见性
     </strong>
     问题。
    </p>
    <p>
     讲一下为什么：
    </p>
    <blockquote>
     <p>
      研究 JDK 的大佬们,就希望通过让编译器 &amp; JVM 对程序员写的代码,自动的进行优化
      <br/>
      本来写的代码是进行 xxxxx,编译器/VM 会在你原有逻辑不变的前提下, 对你的代码进行调整
      <br/>
      使程序效率更高。
     </p>
     <p>
     </p>
     <p>
      编译器,虽然声称优化操作,是能够保证逻辑不变,尤其是在多线程的程序中,编译器的判断可能出现失误.可能导致编译器的优化,使优化后的逻辑,和优化前的逻辑出现细节上的偏差。
     </p>
     <p>
     </p>
     <p>
      于是原因就显而易见了：
     </p>
     <ol>
      <li>
       <p>
        <strong>
         硬件架构影响
        </strong>
       </p>
       <ul>
        <li>
         <p>
          CPU缓存：每个线程可能在自己的CPU缓存中操作变量，而非直接读写主内存。
         </p>
        </li>
        <li>
         <p>
          指令重排序：编译器和处理器可能优化指令顺序以提高性能，导致代码执行顺序与预期不一致。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         Java内存模型（JMM）抽象
        </strong>
       </p>
       <ul>
        <li>
         <p>
          JMM规定所有变量存储在主内存，线程通过本地内存（缓存副本）操作变量。
         </p>
        </li>
        <li>
         <p>
          线程间通信需通过主内存完成，本地内存更新若未同步到主内存，其他线程无法感知变化。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <p>
     于是上述代码我们这样稍作修改就可以了：
    </p>
    <pre><code class="language-java">import java.util.Scanner;

public class test {
    public static int flag = 0;
    public static void main(String[] args) {
        Thread t1 = new Thread(()-&gt;{
            while(flag == 0){
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("t1线程结束");
        });

        Thread t2 = new Thread(()-&gt;{
            Scanner scanner = new Scanner(System.in);
            System.out.println("请输入flag值：");
            flag = scanner.nextInt();
        });
        t1.start();
        t2.start();
    }
}</code></pre>
    <p>
     <img alt="" height="273" src="https://i-blog.csdnimg.cn/direct/6b8aaad99ade484e92cd6843b18f0f4e.png" width="421"/>
    </p>
    <p>
     结果如我们所愿。
    </p>
    <p>
     那么我们不能一遇到内存可见性问题就选择sleep，那样会影响程序执行效率，所以说接下来我们引入一个关键字来解决这个问题：
    </p>
    <blockquote>
     <p>
      <code>
       volatile
      </code>
      是 Java 提供的一种轻量级的同步机制，主要解决
      <strong>
       内存可见性
      </strong>
      和
      <strong>
       指令重排序
      </strong>
      问题，但
      <strong>
       不保证原子性
      </strong>
      。确保一个线程对
      <code>
       volatile
      </code>
      变量的修改对其他线程立即可见。
     </p>
     <ul>
      <li>
       <p>
        <strong>
         问题根源
        </strong>
        ：线程操作变量时可能使用本地缓存（如 CPU 缓存），而非直接读写主内存。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          volatile
         </code>
         的解决
        </strong>
        ：强制所有读写操作直接操作主内存，绕过线程本地缓存。
       </p>
      </li>
     </ul>
    </blockquote>
    <pre><code class="language-java">import java.util.Scanner;

public class test {
    public volatile static int flag = 0;
    public static void main(String[] args) {
        Thread t1 = new Thread(()-&gt;{
            while(flag == 0){

            }
            System.out.println("t1线程结束");
        });

        Thread t2 = new Thread(()-&gt;{
            Scanner scanner = new Scanner(System.in);
            System.out.println("请输入flag值：");
            flag = scanner.nextInt();
        });
        t1.start();
        t2.start();
    }
}</code></pre>
    <p>
     <img alt="" height="758" src="https://i-blog.csdnimg.cn/direct/ab055e69fce34688b351b513a4732ba2.png" width="1476">
      结束！
     </img>
    </p>
    <h4 id="2.2.2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F" name="2.2.2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F">
     2.2.2指令重排序
    </h4>
    <p>
     还记得上文提到的volatile关键字吗，里面的讲解提到了一个指令重排序的问题，那么这个问题是什么意思呢？这里先简单提及下，讲到单例模式时会有详细讲解：
    </p>
    <blockquote>
     <p>
      指令重排序是指在不改变
      <strong>
       单线程程序执行结果
      </strong>
      的前提下，编译器或处理器通过调整指令的执行顺序来优化性能。
     </p>
     <hr/>
     <p>
      <strong>
       编译器进行指令重排序的原因：
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         提高CPU利用率
        </strong>
        ：减少流水线停顿，避免等待慢操作（如内存访问，上文提及）。
       </p>
      </li>
      <li>
       <p>
        <strong>
         优化缓存效率
        </strong>
        ：通过局部性原理提高缓存命中率。
       </p>
      </li>
      <li>
       <p>
        <strong>
         并行执行指令
        </strong>
        ：现代CPU的多级流水线和多核心架构需要指令级并行。
       </p>
      </li>
     </ul>
     <hr/>
     <p>
      我们为什么之前没有遇到这个问题呢，因为我们在Java初阶的学习过程中大部分都是单线程环境下，只有在多线程环境下才会受到指令重排序的影响。
     </p>
     <ul>
      <li>
       <p>
        <strong>
         可见性问题
        </strong>
        ：一个线程的修改对另一个线程不可见。
       </p>
      </li>
      <li>
       <p>
        <strong>
         有序性问题
        </strong>
        ：代码的实际执行顺序与预期不一致。
       </p>
      </li>
     </ul>
    </blockquote>
    <h4 id="2.2.3%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF" name="2.2.3%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF">
     2.2.3线程饥饿
    </h4>
    <p>
     什么是线程饥饿呢？
    </p>
    <blockquote>
     <p id="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF%EF%BC%9F" name="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF%EF%BC%9F" style="background-color:transparent">
      <strong>
       1. 什么是线程饥饿？
      </strong>
     </p>
     <p>
      <strong>
       线程饥饿
      </strong>
      指在多线程环境下，某个或某些线程
      <strong>
       长期无法获得所需的资源（如CPU时间片、锁、I/O等）
      </strong>
      ，导致其任务无法正常执行的现象。饥饿的线程可能
      <strong>
       永远等待
      </strong>
      ，或执行进度远慢于其他线程。
     </p>
     <p>
      <strong>
       关键特征
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        非全局阻塞（其他线程仍正常运行）。
       </p>
      </li>
      <li>
       <p>
        由资源分配策略或调度机制引起。
       </p>
      </li>
      <li>
       <p>
        可能伴随优先级反转、资源竞争等问题。
       </p>
      </li>
     </ul>
     <hr/>
     <p id="2.%20%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0" name="2.%20%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0">
      <strong>
       2. 线程饥饿的常见原因
      </strong>
     </p>
     <table>
      <thead>
       <tr>
        <th>
         <strong>
          原因
         </strong>
        </th>
        <th>
         <strong>
          说明
         </strong>
        </th>
        <th>
         <strong>
          示例
         </strong>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <strong>
          高优先级线程抢占
         </strong>
        </td>
        <td>
         高优先级线程始终优先获得CPU时间片，低优先级线程长期无法执行。
        </td>
        <td>
         线程优先级设置不合理（如Java中
         <code>
          setPriority(10)
         </code>
         抢占低优先级线程）。
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          非公平锁竞争
         </strong>
        </td>
        <td>
         锁的获取策略不公平，某些线程始终竞争失败。
        </td>
        <td>
         <code>
          synchronized
         </code>
         关键字导致某些线程饥饿。
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          资源独占
         </strong>
        </td>
        <td>
         某个线程长期持有共享资源（如数据库连接、文件句柄），其他线程无法获取。
        </td>
        <td>
         未合理释放资源（如忘记关闭锁或未用
         <code>
          try-finally
         </code>
         块）。
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          任务调度策略缺陷
         </strong>
        </td>
        <td>
         任务队列设计不合理（如固定顺序的任务分配）。
        </td>
        <td>
         线程池使用无界队列或固定顺序提交任务。
        </td>
       </tr>
      </tbody>
     </table>
     <span style="color:null">
      通过合理设计资源分配策略和使用同步工具，可有效减少线程饥饿的发生，保障多线程程序的稳定性和性能。
     </span>
    </blockquote>
    <h4 id="2.2.4%E5%8C%BA%E5%88%86wait%E5%92%8Csleep" name="2.2.4%E5%8C%BA%E5%88%86wait%E5%92%8Csleep">
     2.2.4区分wait和sleep
    </h4>
    <p>
     在讲解单例模式前，再最后区分一下wait和sleep：
    </p>
    <blockquote>
     <p>
      wait有等待时间，sleep也有等待时间，wait可以使用notify提前唤醒，sleep也可以使用Interrupt提前唤醒。
     </p>
     <hr/>
     <p>
      wait 和 sleep 最主要的区别,在于针对锁的操作.
     </p>
     <ol>
      <li>
       wait 必须要搭配锁.先加锁, 才能用 wait. sleep 不需要.
      </li>
      <li>
       2)如果都是在 synchronized 内部使用, wait 会释放锁.sleep 不会释放锁~
      </li>
     </ol>
    </blockquote>
    <h3 id="2.4%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" name="2.4%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">
     2.4单例模式
    </h3>
    <p>
     单例模式是一种常用的软件设计模式，用于确保某个类只有一个实例，并且提供一个全局访问点。其中饿汉模式和懒汉模式是其中最经典的两种单例模式。
    </p>
    <h4 id="2.4.1%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F" name="2.4.1%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F">
     2.4.1饿汉模式
    </h4>
    <p>
     饿汉式单例在类加载时就创建实例，这种方式可以保证线程安全，但是实例的创建是立即进行的，可能会浪费资源。
    </p>
    <hr/>
    <p>
    </p>
    <pre><code class="language-java">class Singleton {
    private static Singleton instance = new Singleton(100);

    public static Singleton getInstance() {
        return instance;
    }

    private Singleton() {

    }

    private Singleton(int n) {

    }
}

public class test2 {
    public static void main(String[] args) {
        Singleton t1 = Singleton.getInstance();
        Singleton t2 = Singleton.getInstance();
        System.out.println(t1 == t2);
        
    }
}</code></pre>
    <p>
     为了判断该代码仅创建了一个实例，我们创建t1和t2来判断是一个实例还是两个：
     <br/>
     <img alt="" height="330" src="https://i-blog.csdnimg.cn/direct/114a7c8e87d34c0eb71ce69b05d433e3.png" width="493"/>
    </p>
    <p>
     可以发现是一个实例。
    </p>
    <h4 id="2.4.2%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F" name="2.4.2%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F">
     2.4.2懒汉模式
    </h4>
    <p>
     懒和饿是相对的，一个是在程序一启动就创建好示例，另一个是尽可能晚的创建实例，以达到节省效率的目的。
    </p>
    <p>
     懒汉式单例的特点是在需要的时候才创建实例，这种实现方式可以延迟实例的创建，节省资源。但是，如果多个线程同时访问getInstance方法，可能会导致多个实例的创建，因此需要进行同步处理。
    </p>
    <hr/>
    <pre><code class="language-java">class SingletonLazy{
    public static SingletonLazy instance = null;

    public static SingletonLazy getInstance(){
        if(instance == null){
            instance = new SingletonLazy();
        }
        return instance;
    }

    private SingletonLazy(){

    }
}
public class test3 {
    public static void main(String[] args) {
        SingletonLazy s1 = SingletonLazy.getInstance();
        SingletonLazy s2 = SingletonLazy.getInstance();
        System.out.println(s1 == s2);
    
        // SingletonLazy s3 = new SingletonLazy();
    }
}</code></pre>
    <p>
     <img alt="" height="332" src="https://i-blog.csdnimg.cn/direct/5d964308c07d4b9da2aeb03304fc8957.png" width="458">
     </img>
    </p>
    <p>
     仿照着饿汉模式，我们仿佛就把正确的代码写出来了，但这里要抛出一个很重要的问题：这样的代码是否是
     <strong>
      线程安全
     </strong>
     的呢？
    </p>
    <h4 id="2.4.2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" name="2.4.2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">
     2.4.2指令重排序与线程安全
    </h4>
    <blockquote>
     <p>
      第一个饿汉模式，在getinstance方法中只涉及到return的读操作，不涉及到线程安全问题。然而懒汉模式的getinstance方法
     </p>
     <p>
      <img alt="" height="156" src="https://i-blog.csdnimg.cn/direct/74c4f5fa1ee44a469164bbf80cb4eeea.png" width="444"/>
     </p>
     <p>
      创建实例时可能涉及到多线程的修改操作，并且一个if语句加上与一个创建示例的语句，这样就违背了原子性的原则。
     </p>
     <p>
      在多线程环境下，如果有多个线程同时调用
      <code>
       getInstance()
      </code>
      方法，可能会在检查
      <code>
       instance == null
      </code>
      后，多个线程都进入
      <code>
       if
      </code>
      块并创建新的实例。这是因为多个线程可能在同一时间检查到
      <code>
       instance
      </code>
      为
      <code>
       null
      </code>
      ，从而都执行
      <code>
       new SingletonLazy()
      </code>
      ，导致创建多个实例。
     </p>
     <hr/>
     <p>
      所以我们就希望通过修改代码，使其避免上述问题。
     </p>
     <p>
      <img alt="" height="251" src="https://i-blog.csdnimg.cn/direct/d3862280ad654b51ae5d92de266f8247.png" width="431"/>
     </p>
     <hr/>
     <p>
      但又有新的问题出现了，在多线程情况下，加锁会互相阻塞，影响执行效率，所以我们再进行修改：
     </p>
     <p>
      <img alt="" height="259" src="https://i-blog.csdnimg.cn/direct/97359e2fd49243649b07e1684715ecbe.png" width="434"/>
     </p>
     <p>
      此处最外层的if语句即为判断该实例是否已被创建，如果该实例以及被创建，就不需要进行获得锁操作，提升程序执行效率。
     </p>
     <hr/>
     <p>
      这样总会没问题了吧，不其实还有，有没有可能出现内存重排序问题呢，稳妥起见我们加上volatile
     </p>
     <p>
      <img alt="" height="299" src="https://i-blog.csdnimg.cn/direct/62c26593279e4d82be2cc51950eee7bf.png" width="444"/>
     </p>
     <p>
      到这里就要呼应上文了，那指令重排序呢，现在就要讲了：
     </p>
     <p>
      在创建实例时，要经过下面几个步骤：
     </p>
     <ol>
      <li>
       申请内存空间
      </li>
      <li>
       在空间上构造对象(初始化)
      </li>
      <li>
       内存空间的首地址,赋值给引用变量
      </li>
     </ol>
     <p>
      正常来说，这三个步骤按照 123这样的顺序来执行的，但是在指令重排序下,可能成为132 这样的顺序单线程环境下,123 还是 132 其实无所谓~~如果是13 2 这样的顺序执行,多线程环境下,可能会出现 bug !!
     </p>
     <p>
      如果先进行1，3，那么很有可能出现尝试赋值时在对一个“未初始化的对象”进行操作，于是乎在这里，volatile也起到了解决指令重排序的问题。接下来就是正确的完整代码：
      <br/>
     </p>
     <pre><code class="language-java">class SingletonLazy{
    private static volatile SingletonLazy instance = null;
    private static Object locker = new Object();

    public static SingletonLazy getInstance() {
        if (instance == null) {
            synchronized (locker) {
                if (instance == null) {
                    instance = new SingletonLazy();
                }
            }
        }
        return instance;
    }
}
public class test3 {
    public static void main(String[] args) {
        SingletonLazy s1 = SingletonLazy.getInstance();
        SingletonLazy s2 = SingletonLazy.getInstance();
        System.out.println(s1 == s2);

        // SingletonLazy s3 = new SingletonLazy();
    }
}</code></pre>
     <p>
      大功告成！
     </p>
    </blockquote>
    <h2 id="3.%E5%B0%8F%E7%BB%93" name="3.%E5%B0%8F%E7%BB%93">
     3.小结
    </h2>
    <p>
     今天的分享到这里就结束了，喜欢的小伙伴点点赞点点关注，你的支持就是对我最大的鼓励，大家加油！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313037333331372f:61727469636c652f64657461696c732f313436303433383032" class_="artid" style="display:none">
 </p>
</div>


