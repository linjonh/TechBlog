---
layout: post
title: "力扣hot100二刷哈希双指针滑动窗口"
date: 2025-03-10 22:16:41 +0800
description: "第二次刷题不在idea写代码，而是直接在leetcode网站上写，“逼”自己掌握常用的函数。"
keywords: "力扣hot100二刷——哈希、双指针、滑动窗口"
categories: ['手撕算法']
tags: ['面试', '算法', '哈希算法', 'Leetcode']
artid: "146165514"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146165514
    alt: "力扣hot100二刷哈希双指针滑动窗口"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146165514
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146165514
cover: https://bing.ee123.net/img/rand?artid=146165514
image: https://bing.ee123.net/img/rand?artid=146165514
img: https://bing.ee123.net/img/rand?artid=146165514
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     力扣hot100二刷——哈希、双指针、滑动窗口
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     第二次刷题不在idea写代码，而是直接在leetcode网站上写，“逼”自己掌握常用的函数。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        标志
       </th>
       <th>
        掌握程度
       </th>
       <th>
        解释
       </th>
       <th>
        办法
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ⭐
       </td>
       <td>
        Fully 完全掌握
       </td>
       <td>
        看到题目就有思路，编程也很流利
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐
       </td>
       <td>
        Basically 基本掌握
       </td>
       <td>
        需要稍作思考，或者看到提示方法后能解答
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Slightly 稍微掌握
       </td>
       <td>
        需要看之前写过的代码才能想起怎么做
       </td>
       <td>
        多做
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        absolutely no 完全没有掌握
       </td>
       <td>
        需要看题解才知道怎么做
       </td>
       <td>
        背
       </td>
      </tr>
      <tr>
       <td>
        ⭐⭐⭐⭐⭐
       </td>
       <td>
        有难度的高频题
       </td>
       <td>
        需要看题解才知道怎么做，而且过几天就忘了这道题怎么做了
       </td>
       <td>
        背背
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th>
        序号
       </th>
       <th>
        掌握程度
       </th>
       <th>
        难度
       </th>
       <th>
        类型
       </th>
       <th>
        题号/题名
       </th>
       <th>
        思路/易错点
       </th>
       <th>
        新的函数
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1
       </td>
       <td>
        ⭐
       </td>
       <td>
        Easy
       </td>
       <td>
        哈希
       </td>
       <td>
        1/两数之和
       </td>
       <td>
        先把每个数保存进map再进行后续操作 的做法是错误的， 因为这样的话，后面map.ContainsKey()找到的数可能是数字本身，而不是另一个数字 所以应该边遍历数组，边查找map中是否只有匹配的元素，然后再添加元素到map， 一句总结：寻找当前元素之前是否有匹配的数
       </td>
       <td>
        if(map.containsKey(target - nums[i]))
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        ⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        哈希
       </td>
       <td>
        49/字母异位词分组
       </td>
       <td>
        遍历字符串数组 对数组中的每个字符串进行内部的字母排序 相同的字母排序作为同一个键，将排序前的字符串添加进键对应的值（是一个数组）
       </td>
       <td>
        char[] ch = str.toCharArray(); Arrays.sort(ch); List strList = map.getOrDefault(s, new ArrayList()); map.put(s, strList);
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        哈希
       </td>
       <td>
        128/最长连续序列
       </td>
       <td>
        先遍历一边数组，将数组中元素存进set集合 再次遍历数组 每次遍历中，如果没有当前数前面的那个数，说明可以从该数开始向后寻数（用一个temp记录临时长度），直到找不到连续的数，就结束这次循环 每次遍历，更新答案。
       </td>
       <td>
        while(set.contains(num++))
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        ⭐⭐
       </td>
       <td>
        Easy
       </td>
       <td>
        双指针
       </td>
       <td>
        283/移动零
       </td>
       <td>
        一个指针left维护为0的位置，指针right维护不为0的位置 right指针遍历整个数组（right++） 遇到位置left上的数为0，right上的数不为0时就交换位置，left++
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        ⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        双指针
       </td>
       <td>
        11/盛最多水的容器
       </td>
       <td>
        比较简单 一个指针从数组最左向右移动，一个指针从数组最右向左移动 哪个指针指向的数更小，就移动哪个指针。
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        双指针
       </td>
       <td>
        15/三数之和
       </td>
       <td>
        这道题的重点在于避免重复结果 先把数组排序，排序后的第一位数如果大于0，直接return 然后再遍历数组，对数组中的每个数去寻找另外两个数 遍历时，要跳过一样的数（从第二个数开始，和上一个数一样就跳过） 维护两个指针，分别指向当前数的下一个数和数组尾数 While(left &lt; right) 中遍历寻找另外两个数，使这三个数的和为0 在寻找的同时，也一定要注意避免重复的结果，使用while循环来跳过一样的数，且要注意left &lt; right
       </td>
       <td>
        ans.add(Arrays.asList(nums[i], nums[left], nums[right]));
       </td>
      </tr>
      <tr>
       <td>
        7
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        Hard
       </td>
       <td>
        双指针
       </td>
       <td>
        42/接雨水
       </td>
       <td>
        两种解法：一种是前后缀分解，知道思路后其实很简单，另一种是单调栈 前后缀分解需要三次遍历数组。 第一次遍历数组，来维护一个保存每个当前数左边最大的数的数组 第二次遍历数组，来维护一个保存每个当前右边最大的数的数组 第三次遍历数组，来累加每个位置上的积水
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        8
       </td>
       <td>
        ⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        滑动窗口
       </td>
       <td>
        3/无重复字符的最长字串
       </td>
       <td>
        维护一个哈希集合，保存当前子串中的字母 维护左右指针，left、right，分别指向子串头尾 右指针向右移动，同时判断新的字母是否和当前子串集合中的字母重复，如有重复，移动左指针，直到没有重复为止
       </td>
       <td>
        set.add(ch[right]); set.remove(ch[right]);
       </td>
      </tr>
      <tr>
       <td>
        9
       </td>
       <td>
        ⭐⭐
       </td>
       <td>
        Medium
       </td>
       <td>
        滑动窗口
       </td>
       <td>
        438/找到字符串中所有字母异位词
       </td>
       <td>
        维护两个大小为26的字母数组，用来保存当前遍历子串的字母数量，和目标子串的字母数量 维护left、right指针，分别指向当前遍历子串的头尾 判定完当前子串是否是目标字串的异位词后，再将左右指针右移
       </td>
       <td>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     图片版：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0fcf099d18ff45aaba9d64e06feb0894.png"/>
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34393432363131352f:61727469636c652f64657461696c732f313436313635353134" class_="artid" style="display:none">
 </p>
</div>


