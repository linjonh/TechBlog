---
layout: post
title: "使用-Prim-算法生成了最小生成树,-使用-Fleury-算法生成了欧拉回路,尝试找到了一个简单的哈密尔顿圈"
date: 2025-03-08 16:31:51 +0800
description: "使用 Prim 算法生成了最小生成树。使用 Fleury 算法生成了欧拉回路。尝试找到了一个简单的哈密尔顿圈。请注意，上述代码中的城市数据和距离是示例数据，你可以根据实际的全国各省会及主要城市的联通线路信息进行替换。同时，哈密尔顿圈的搜索方法是暴力搜索，对于大规模图可能效率较低。"
keywords: "使用 Prim 算法生成了最小生成树， 使用 Fleury 算法生成了欧拉回路，尝试找到了一个简单的哈密尔顿圈。"
categories: ['算法']
tags: ['算法']
artid: "146118321"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146118321
    alt: "使用-Prim-算法生成了最小生成树,-使用-Fleury-算法生成了欧拉回路,尝试找到了一个简单的哈密尔顿圈"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146118321
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146118321
cover: https://bing.ee123.net/img/rand?artid=146118321
image: https://bing.ee123.net/img/rand?artid=146118321
img: https://bing.ee123.net/img/rand?artid=146118321
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     使用 Prim 算法生成了最小生成树， 使用 Fleury 算法生成了欧拉回路，尝试找到了一个简单的哈密尔顿圈。
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     我们将分步骤完成建立全国各省会及一些主要城市的最简联通线路，利用 Prim 算法生成最小生成树，使用 Fleury 算法研究铁路线路回路方案，最后建立简单的哈密尔顿圈。
    </p>
    <h4>
     <a id="_1_2">
     </a>
     步骤 1：数据准备
    </h4>
    <p>
     首先，我们需要定义城市之间的连接信息和距离，这些信息将存储在邻接矩阵中。以下是一个简单的示例，假设我们有几个城市：
    </p>
    <pre><code class="prism language-python"><span class="token comment"># 城市名称列表</span>
cities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"广州"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">,</span> <span class="token string">"成都"</span><span class="token punctuation">]</span>

<span class="token comment"># 邻接矩阵表示城市之间的距离</span>
graph <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1800</span><span class="token punctuation">,</span> <span class="token number">1900</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token number">1300</span><span class="token punctuation">,</span> <span class="token number">1600</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">1800</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">1900</span><span class="token punctuation">,</span> <span class="token number">1300</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1300</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">1500</span><span class="token punctuation">,</span> <span class="token number">1600</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token number">1300</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>
</code></pre>
    <h4>
     <a id="_2Prim__19">
     </a>
     步骤 2：Prim 算法生成最小生成树
    </h4>
    <p>
     Prim 算法是一种贪心算法，用于在加权无向图中找到最小生成树。以下是实现代码：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> sys

<span class="token keyword">def</span> <span class="token function">prim</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    num_vertices <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
    <span class="token comment"># 用于记录顶点是否已被访问</span>
    visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> num_vertices
    <span class="token comment"># 存储最小生成树的边</span>
    mst <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 选择第一个顶点作为起始点</span>
    visited<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>mst<span class="token punctuation">)</span> <span class="token operator">&lt;</span> num_vertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
        min_dist <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize
        min_edge <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_vertices<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_vertices<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">and</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min_dist<span class="token punctuation">:</span>
                        min_dist <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                        min_edge <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>

        <span class="token keyword">if</span> min_edge<span class="token punctuation">:</span>
            mst<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min_edge<span class="token punctuation">)</span>
            visited<span class="token punctuation">[</span>min_edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">return</span> mst

<span class="token comment"># 生成最小生成树</span>
mst <span class="token operator">=</span> prim<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最小生成树的边："</span><span class="token punctuation">,</span> mst<span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="_3Fleury__56">
     </a>
     步骤 3：Fleury 算法生成欧拉回路
    </h4>
    <p>
     Fleury 算法用于在连通图中找到欧拉回路。以下是实现代码：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">is_bridge</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 检查边 (u, v) 是否为桥</span>
    temp_graph <span class="token operator">=</span> <span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> graph<span class="token punctuation">]</span>
    temp_graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    temp_graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>

    visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span>u<span class="token punctuation">]</span>
    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
        node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> temp_graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token keyword">not</span> visited<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>
                visited<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">return</span> <span class="token keyword">not</span> <span class="token builtin">all</span><span class="token punctuation">(</span>visited<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">fleury</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    num_vertices <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
    <span class="token comment"># 选择一个起始顶点</span>
    start_vertex <span class="token operator">=</span> <span class="token number">0</span>
    circuit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span>start_vertex<span class="token punctuation">]</span>

    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
        current_vertex <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        found_edge <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_vertices<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> graph<span class="token punctuation">[</span>current_vertex<span class="token punctuation">]</span><span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> <span class="token keyword">not</span> is_bridge<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> current_vertex<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>
                    graph<span class="token punctuation">[</span>current_vertex<span class="token punctuation">]</span><span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
                    graph<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">[</span>current_vertex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
                    found_edge <span class="token operator">=</span> <span class="token boolean">True</span>
                    <span class="token keyword">break</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> found_edge<span class="token punctuation">:</span>
            circuit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> circuit

<span class="token comment"># 复制最小生成树的图</span>
mst_graph <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> mst<span class="token punctuation">:</span>
    mst_graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span>
    mst_graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span>

<span class="token comment"># 生成欧拉回路</span>
euler_circuit <span class="token operator">=</span> fleury<span class="token punctuation">(</span>mst_graph<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欧拉回路："</span><span class="token punctuation">,</span> euler_circuit<span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="_4_113">
     </a>
     步骤 4：建立简单的哈密尔顿圈
    </h4>
    <p>
     哈密尔顿圈是一个遍历图中每个顶点恰好一次并回到起始顶点的回路。由于找到哈密尔顿圈是一个 NP 完全问题，我们可以使用简单的暴力搜索方法。以下是实现代码：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> itertools <span class="token keyword">import</span> permutations

<span class="token keyword">def</span> <span class="token function">is_hamiltonian_cycle</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    num_vertices <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">!=</span> num_vertices<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_vertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> graph<span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>path<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">if</span> graph<span class="token punctuation">[</span>path<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token keyword">def</span> <span class="token function">find_hamiltonian_cycle</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    num_vertices <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
    vertices <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>num_vertices<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> perm <span class="token keyword">in</span> permutations<span class="token punctuation">(</span>vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        path <span class="token operator">=</span> <span class="token punctuation">[</span>vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">list</span><span class="token punctuation">(</span>perm<span class="token punctuation">)</span>
        <span class="token keyword">if</span> is_hamiltonian_cycle<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> path
    <span class="token keyword">return</span> <span class="token boolean">None</span>

<span class="token comment"># 找到哈密尔顿圈</span>
hamiltonian_cycle <span class="token operator">=</span> find_hamiltonian_cycle<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"哈密尔顿圈："</span><span class="token punctuation">,</span> hamiltonian_cycle<span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="_145">
     </a>
     总结
    </h4>
    <p>
     通过以上代码，我们完成了以下任务：
    </p>
    <ol>
     <li>
      使用 Prim 算法生成了最小生成树。
     </li>
     <li>
      使用 Fleury 算法生成了欧拉回路。
     </li>
     <li>
      尝试找到了一个简单的哈密尔顿圈。
     </li>
    </ol>
    <p>
     请注意，上述代码中的城市数据和距离是示例数据，你可以根据实际的全国各省会及主要城市的联通线路信息进行替换。同时，哈密尔顿圈的搜索方法是暴力搜索，对于大规模图可能效率较低。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f676f353436333135383436352f:61727469636c652f64657461696c732f313436313138333231" class_="artid" style="display:none">
 </p>
</div>


