---
layout: post
title: "写时拷贝技术"
date: 2025-03-15 20:31:16 +0800
description: "写时拷贝"
keywords: "写时拷贝技术"
categories: ['Linux']
tags: ['服务器', '数据库', '开发语言', 'Linux', 'Java']
artid: "146276627"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146276627
    alt: "写时拷贝技术"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146276627
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146276627
cover: https://bing.ee123.net/img/rand?artid=146276627
image: https://bing.ee123.net/img/rand?artid=146276627
img: https://bing.ee123.net/img/rand?artid=146276627
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     写时拷贝技术
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p style="text-align:center">
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2269d535401c4eafad83755163f33a76.png"/>
    </p>
    <p>
     在操作系统中，写时拷贝（Copy-On-Write，COW）是一种
     <strong>
      优化内存使用
     </strong>
     的策略，它延迟了数据的复制操作，直到
     <strong>
      实际需要写入数据时才进行复制
     </strong>
     。常用于需要
     <u>
      大量数据拷贝
     </u>
     的场景，以提高程序效率和降低资源消耗。
    </p>
    <h2 id="%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D" name="%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D">
     写时拷贝
    </h2>
    <h3 id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" name="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     核心思想
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     在多个调用者请求
     <strong>
      相同资源
     </strong>
     时，它们会共同获取
     <strong>
      相同的指针
     </strong>
     指向相同的资源。直到某个调用者试图
     <strong>
      修改资源的内容
     </strong>
     时，系统才会真正
     <strong>
      复制一份专用副本
     </strong>
     给该调用者，而其他
     <strong>
      调用者所见到的资源
     </strong>
     仍然
     <strong>
      保持不变
     </strong>
     。这个过程对其他调用者是透明的。
    </p>
    <h3 id="%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" name="%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     基本原理
    </h3>
    <h5 id="%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B" name="%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">
     基本过程
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      <strong>
       内存管理单元
      </strong>
      （MMU）是实现写时拷贝的关键。当两个或多个进程
      <strong>
       共享同一块内存区域
      </strong>
      时，MMU 会记录该区域的
      <strong>
       引用计数
      </strong>
      ，并将其标记为
      <strong>
       只读
      </strong>
      。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      只要没有进程对共享内存区域进行
      <strong>
       写入操作
      </strong>
      ，就可以一直共享这块内存，避免了不必要的数据拷贝，从而节省内存空间和数据复制的时间成本。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      一旦有进程试图对共享内存区域进行
      <strong>
       写入操作
      </strong>
      ，MMU 会发现该区域被标记为只读，从而触发一个
      <strong>
       页面错误异常
      </strong>
      （page fault）。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      操作系统内核会捕获这个异常，并根据
      <strong>
       写时拷贝
      </strong>
      策略进行处理。内核会为进行写入操作的进程分配新的
      <strong>
       物理内存页
      </strong>
      ，并
      <u>
       将原有共享内存页的内容复制到新的内存页
      </u>
      中。这样，进行写入操作的进程就可以在
      <strong>
       新的内存页
      </strong>
      上安全地进行
      <strong>
       修改
      </strong>
      ，而
      <u>
       不会影响其他共享该内存区域的进程
      </u>
      。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      <img alt="" height="602" src="https://i-blog.csdnimg.cn/direct/f1147b02fb4d420fa16c609d0593173f.png" width="1148"/>
     </p>
    </blockquote>
    <h5 id="%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3" name="%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     一个例子深入理解
    </h5>
    <p>
     fork创建子进程后，父子进程在内存层面是如何运转的呢？？？
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     当父进程调用fork()创建子进程时,内核会将父进程的所有内存页都标记为只读(即共享页面)，并
     <strong>
      增加每个页面的引用计数
     </strong>
     。在这个过程中,父子进程共享同一份内存页面,可以大幅减少内存占用。
    </p>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      一旦其中一个进程(父进程或子进程)尝试写入某个内存页，就会触发一个保护故障(缺页异常)，此时会陷入内核，内核将拦截这个写入操作，检查该页面的引用数：如果引用数
      <span style="color:#0d0016">
       <strong>
        大于 1
       </strong>
      </span>
      ，则会
      <strong>
       创建该页面的副本
      </strong>
      ，并将引用数减 1，同时恢复这个页面的
      <strong>
       可写权限
      </strong>
      ，然后重新执行这个
      <strong>
       写操作
      </strong>
      ；如果页面的引用数只有 1，也就是说该页面只被当前进程引用,那么内核就可以跳过分配新页面的步骤，
      <strong>
       直接修改该页面
      </strong>
      ，将其标记为
      <strong>
       可写
      </strong>
      。
     </p>
    </blockquote>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     在一般情况下,当子进程通过写时复制机制创建了自己的内存页面副本后,这个副本
     <u>
      会一直与父进程的页面保持不一致,直到该子进程退出或被杀死
     </u>
     。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <img alt="" height="407" src="https://i-blog.csdnimg.cn/direct/78b72a17d2d5493ab374905b9865b034.png" width="646"/>
    </p>
    <h3 id="%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" name="%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     补充知识--引用计数
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <strong>
      引用计数
     </strong>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     在开辟的空间中
     <strong>
      多维护四个字节
     </strong>
     来存储引用计数。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     两种方法：
    </p>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      ①：多开辟四个字节(pCount)的空间，用来
      <strong>
       记录有多少个指针指向这片空间
      </strong>
      。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      ②：在开辟空间的头部
      <strong>
       预留四个字节的空间
      </strong>
      来记录有多少个指针指向这片空间。
     </p>
    </blockquote>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <u>
      当我们多开辟一份空间时，让引用计数+1，如果有释放空间，那就让计数-1
     </u>
     ，但是此时不是真正的释放，是
     <strong>
      假释放
     </strong>
     ，等到引用计数变为 0 时，才会真正的释放空间。如果有修改或写的操作，那么也让原空间的引用计数-1，并且真正开辟新的空间。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
    </p>
    <h3 id="%E5%B0%8F%E6%80%BB%E7%BB%93" name="%E5%B0%8F%E6%80%BB%E7%BB%93" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     小总结
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     写实拷贝本质就是
     <span style="color:#fe2c24">
      <strong>
       等到修改数据时才真正分配内存空间
      </strong>
     </span>
     。这是对程序性能的优化，可以延迟甚至是避免内存拷贝，目的就是避免不必要的内存拷贝。
    </p>
    <h2 id="%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0" name="%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     写时拷贝实现
    </h2>
    <h3 id="%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3%EF%BC%88%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E8%A7%92%E5%BA%A6%EF%BC%89" name="%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3%EF%BC%88%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E8%A7%92%E5%BA%A6%EF%BC%89">
     宏观理解（进程、线程角度）
    </h3>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      <strong>
       流程：资源共享-&gt;只读访问-&gt;写操作触发拷贝-&gt;独立修改
      </strong>
     </p>
    </blockquote>
    <h5 id="%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB" name="%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     资源共享
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      当多个
      <strong>
       进程或线程
      </strong>
      需要
      <strong>
       访问相同的数据
      </strong>
      时，操作系统会将数据的
      <strong>
       内存页标记为只读
      </strong>
      ，并让这些进程或线程
      <strong>
       共享同一块内存
      </strong>
      。
     </p>
    </blockquote>
    <h5 id="%E5%8F%AA%E8%AF%BB%E8%AE%BF%E9%97%AE" name="%E5%8F%AA%E8%AF%BB%E8%AE%BF%E9%97%AE" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     只读访问
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      在没有进程或线程修改数据的情况下，
      <u>
       只有一份数据存储在内存中
      </u>
      ，所有共享者都只能进行
      <strong>
       只读访问
      </strong>
      。
     </p>
    </blockquote>
    <h5 id="%E5%86%99%E6%93%8D%E4%BD%9C%E8%A7%A6%E5%8F%91%E6%8B%B7%E8%B4%9D" name="%E5%86%99%E6%93%8D%E4%BD%9C%E8%A7%A6%E5%8F%91%E6%8B%B7%E8%B4%9D" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     写操作触发拷贝
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      当某个进程或线程尝试修改这块
      <strong>
       共享数据
      </strong>
      时，会触发一个
      <strong>
       页面错误
      </strong>
      （Page Fault），因为内存页被标记为只读。操作系统捕捉到这个错误后，会为该进程或线程
      <u>
       分配一块新的内存
      </u>
      ，并将原始数据拷贝到这块新内存中。
     </p>
    </blockquote>
    <h5 id="%E7%8B%AC%E7%AB%8B%E4%BF%AE%E6%94%B9" name="%E7%8B%AC%E7%AB%8B%E4%BF%AE%E6%94%B9" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     独立修改
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      经过拷贝操作后，修改数据的进程或线程拥有了数据的
      <strong>
       独立副本
      </strong>
      ，可以自由地对其进行修改，而
      <strong>
       不会影响到其他共享者
      </strong>
      。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      拷贝过程如图所示：
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      <img alt="" height="443" src="https://i-blog.csdnimg.cn/direct/9e742ed4e2dd481180d8ce2714246bb7.png" width="548"/>
     </p>
    </blockquote>
    <h3 id="%E5%BE%AE%E8%A7%82%E7%90%86%E8%A7%A3%EF%BC%88fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A7%92%E5%BA%A6%EF%BC%89" name="%E5%BE%AE%E8%A7%82%E7%90%86%E8%A7%A3%EF%BC%88fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A7%92%E5%BA%A6%EF%BC%89" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     微观理解（fork系统调用角度）
    </h3>
    <h5 id="%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%EF%BC%88fork%EF%BC%89%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84" name="%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%EF%BC%88fork%EF%BC%89%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     进程创建（fork）时的内存映射
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      虚拟内存映射：在 Linux 中，fork 系统调用创建子进程时，内核为子进程创建与父进程相同的
      <strong>
       虚拟内存映射
      </strong>
      。
      <u>
       虚拟内存是进程对内存的一种逻辑视图
      </u>
      ，
      <u>
       每个进程都有自己独立的虚拟地址空间
      </u>
      。父子进程的虚拟地址空间布局相似，但并不直接对应到
      <u>
       相同的物理内存
      </u>
      。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      页表设置：内核为子进程
      <strong>
       构建页表
      </strong>
      ，这些页表最初指向与父进程相同的
      <strong>
       物理内存页面
      </strong>
      。页表是一种数据结构，用于将
      <strong>
       虚拟地址映射到物理地址
      </strong>
      。此时，父子进程
      <strong>
       共享
      </strong>
      这些物理内存页面，但这些页面被标记为
      <strong>
       只读
      </strong>
      （read - only）。
     </p>
    </blockquote>
    <h6 id="%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86--%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98" name="%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86--%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     补充知识--虚拟内存与物理内存
    </h6>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <img alt="" height="617" src="https://i-blog.csdnimg.cn/direct/72ad66579a7b4c839f5e8f2b1fae0a18.png" width="650"/>
    </p>
    <h5 id="%E5%86%99%E6%93%8D%E4%BD%9C%E8%A7%A6%E5%8F%91%E6%8B%B7%E8%B4%9D" name="%E5%86%99%E6%93%8D%E4%BD%9C%E8%A7%A6%E5%8F%91%E6%8B%B7%E8%B4%9D" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     写操作触发拷贝
    </h5>
    <blockquote>
     <p style="margin-left:0.0001pt; margin-right:0px">
      写保护异常：当父子进程中的任何一个试图对共享的只读物理内存页面进行
      <strong>
       写操作
      </strong>
      时，CPU 会检测到写保护异常（因为页面被标记为只读），将控制权交给操作系统内核。
     </p>
     <p style="margin-left:0.0001pt; margin-right:0px">
      内核处理：内核
      <strong>
       捕获
      </strong>
      到写保护异常后，识别出该页面是由于写时拷贝机制而被共享的。内核会为执行写操作的进程分配一个新的
      <strong>
       物理内存页面
      </strong>
      。这个新页面是原共享页面的
      <strong>
       副本
      </strong>
      。
     </p>
     <p style="margin-left:0.0001pt; margin-right:0px">
      更新页表：
      <strong>
       内核更新执行写操作进程的页表
      </strong>
      ，使其指向
      <u>
       新分配的物理内存页面
      </u>
      ，并将该页面标记为
      <strong>
       可读写
      </strong>
      （read - write）。这样，该进程就可以在新的页面上进行
      <strong>
       写操作
      </strong>
      ，而不会影响其他进程（如父子进程中的另一方）对原共享页面的访问。
     </p>
    </blockquote>
    <h5 id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96" name="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     内存管理优化
    </h5>
    <blockquote>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      减少内存占用：通过写时拷贝技术，在 fork后多个进程可以
      <u>
       共享大量的物理内存页面
      </u>
      ，只有在真正需要
      <strong>
       修改
      </strong>
      数据时才会为进程分配额外的
      <strong>
       物理内存
      </strong>
      。这大大减少了内存占用，提高了内存利用率。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
      提高性能：由于减少了 fork时的内存复制操作，fork的执行效率得到提高。同时，写时拷贝技术也减少了
      <strong>
       内存碎片
      </strong>
      的产生，因为只有在必要时才分配新的物理内存页面，而不是在进程创建时就分配大量内存。
     </p>
     <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     </p>
    </blockquote>
    <h3 id="%E5%B0%8F%E6%80%BB%E7%BB%93" name="%E5%B0%8F%E6%80%BB%E7%BB%93" style="margin-left:0px; margin-right:0px; text-align:justify">
     小总结
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     1、
     <strong>
      在Linux系统中，调用fork()系统调用创建子进程时，并不会把父进程所有占用的内存页复制一份，而是与父进程共享相同的内存页，但当子进程或父进程对内存页进行修改时才会进行复制。（换而言是只有进程空间的某页内存的内容发生修改时，才会将父进程的该页内存复制一份给子进程）
     </strong>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     2、
     <strong>
      <span style="color:#fe2c24">
       fork之后，子进程的页表也指向父进程所指向的物理内存页面，并标记为只读！！！
      </span>
     </strong>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <strong>
      这些共享页标记为写时拷贝，这意味着如果任何一个进程写入共享页面，那么就创建共享页面的副本。
     </strong>
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     原理如图所示：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <img alt="" height="648" src="https://i-blog.csdnimg.cn/direct/722d9868f00a4152850ff5092c4b7b54.png" width="680"/>
    </p>
    <h2 id="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D" name="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D" style="margin-left:0px; margin-right:0px; text-align:justify">
     虚拟内存管理中的写时拷贝
    </h2>
    <h5 id="%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6" name="%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6" style="margin-left:0px; margin-right:0px; text-align:justify">
     内存映射文件
    </h5>
    <p style="margin-left:0; margin-right:0; text-align:justify">
     当多个进程需要访问同一个文件时，可以通过内存映射技术将文件映射到
     <strong>
      进程的地址空间
     </strong>
     ，这些进程在
     <strong>
      没有修改文件
     </strong>
     的情况下
     <strong>
      共享
     </strong>
     相同的内存区域。例如，当进程A和进程B都映射同一个文件到它们的地址空间时，它们共享同一物理内存页面。如果进程A修改该文件的某个页面，操作系统会
     <strong>
      触发页错误
     </strong>
     ，将
     <strong>
      该页面拷贝给进程A
     </strong>
     ，而进程B继续使用原始的共享内存页。
    </p>
    <h5 id="%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%B0%83%E5%BA%A6" name="%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%B0%83%E5%BA%A6" style="margin-left:0px; margin-right:0px; text-align:justify">
     <strong>
      页面交换和调度
     </strong>
    </h5>
    <blockquote>
     <p style="margin-left:0; margin-right:0; text-align:justify">
      在虚拟内存管理中，COW可以用于
      <strong>
       优化页面的交换和调度
      </strong>
      。当多个进程共享相同的页面时，操作系统可以
      <strong>
       推迟复制
      </strong>
      ，直到有进程修改页面为止。比如
      <u>
       当进程需要访问的页面不在物理内存中时，操作系统会触发
       <strong>
        缺页中断
       </strong>
      </u>
      ，此时如果该页面是共享的且未被修改过，操作系统可以从磁盘交换区/文件系统中重新加载该页面，而不会触发复制操作。
     </p>
    </blockquote>
    <h5 id="%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D" name="%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     对象拷贝
    </h5>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     当需要拷贝一个较大的对象时，如果直接进行深拷贝，可能会导致性能下降和内存占用增加。使用写时拷贝策略，可以在对象拷贝时，只是简单地
     <strong>
      将指针指向相同的内存区域，并增加引用计数
     </strong>
     。只有当对对象进行修改时，才会触发拷贝操作，真正分配新的内存并复制数据。
    </p>
    <h5 id="%E5%AE%B9%E5%99%A8%E5%85%B1%E4%BA%AB" name="%E5%AE%B9%E5%99%A8%E5%85%B1%E4%BA%AB" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     容器共享
    </h5>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     多个容器（如 vector）可能共享同一块数据内存。在未进行写入操作之前，它们只是
     <u>
      共享同一数据，不产生实际的拷贝
     </u>
     。一旦对数据进行修改，则会触发拷贝，确保每个容器拥有自己的数据副本。
    </p>
    <h2 id="%C2%A0%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E4%BC%98%E7%82%B9" name="%C2%A0%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E4%BC%98%E7%82%B9" style="margin-left:0.0001pt; margin-right:0px; text-align:justify">
     写时拷贝优点
    </h2>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <strong>
      节省内存
     </strong>
     ：在不需要对共享数据进行修改的情况下，多个进程或对象可以共享同一内存区域，大大减少了内存的使用量。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     <strong>
      提高效率
     </strong>
     ：避免了在不需要修改数据时的不必要的数据拷贝操作，提高了程序的运行效率，尤其在涉及大量数据拷贝的场景中，效果更为明显。
    </p>
    <h2 id="%E6%80%BB%E7%BB%93" name="%E6%80%BB%E7%BB%93" style="background-color:transparent; margin-left:0.0001pt; margin-right:0px; text-align:justify">
     总结
    </h2>
    <p>
     实际上写时拷贝技术十分应用广泛，Linux下fork()系统调用，string数据结构，智能指针shared_ptr都使用写时拷贝技术解决拷贝问题。
    </p>
    <p>
     写时拷贝拷贝机制如图所示
    </p>
    <p>
     <img alt="" height="502" src="https://i-blog.csdnimg.cn/direct/35b02c3c2358483db68fcd90544a1b88.png" width="484"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303334353338352f:61727469636c652f64657461696c732f313436323736363237" class_="artid" style="display:none">
 </p>
</div>


