---
layout: post
title: "c介绍锁-一"
date: 2025-03-10 20:20:09 +0800
description: "可以使用一次性分配所有资源方法，即线程一次申请它所需要的所有资源，只有在所有资源都满足情况下才开始执行，否则就释放已经获得的资源重新申请。3.破坏不剥夺条件：如果一个线程申请新的资源时已持有的资源被占用，可以强制释放它已占有的资源。4.使用死锁检测和恢复：系统可以定期检测是否存在死锁，如果检测到死锁，即采取恢复措施，例如，终止某些线程并且释放它们占有资源。： 已获得的资源在未使用完之前，不能被强行剥夺，只能使用完毕后由线程自己释放。：线程已经持有至少一个资源，同时又申请新的资源，而新资源被其他线程占有。"
keywords: "c++介绍锁 一"
categories: ['C']
tags: ['开发语言', 'C']
artid: "146157746"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146157746
    alt: "c介绍锁-一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146157746
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146157746
cover: https://bing.ee123.net/img/rand?artid=146157746
image: https://bing.ee123.net/img/rand?artid=146157746
img: https://bing.ee123.net/img/rand?artid=146157746
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     c++介绍锁 一
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     死锁如何产生的：两个或者多个线程，互相等待对方释放资源，从而导致进程或者线程无法继续执行的现象。
    </p>
    <p>
     造成死锁的条件：
    </p>
    <p>
     1.
     <strong>
      互斥条件（Mutual Exclusion）：
     </strong>
     资源一次只能被一个线程占用。
    </p>
    <p>
     2.
     <strong>
      请求保持条件(Hold and Wait)
     </strong>
     ：线程已经持有至少一个资源，同时又申请新的资源，而新资源被其他线程占有。
    </p>
    <p>
     3.
     <strong>
      不剥夺条件（No Preemption）
     </strong>
     ： 已获得的资源在未使用完之前，不能被强行剥夺，只能使用完毕后由线程自己释放。
    </p>
    <p>
     4.
     <strong>
      循环等待条件：
     </strong>
     存在一个线程循环等待链，链中的每个线程持有下一个线程所需资源。
    </p>
    <p>
    </p>
    <p>
     如何解决死锁
    </p>
    <p>
     1：避免循环等待条件：避免形成资源循环等待=链。例如，可以对所有资源进行排序，并按照顺序申请资源，确保不会形成循环等待。
    </p>
    <p>
     2.破坏请求保持条件：在一个线程申请资源时，不允许它同时持有其他资源。可以使用一次性分配所有资源方法，即线程一次申请它所需要的所有资源，只有在所有资源都满足情况下才开始执行，否则就释放已经获得的资源重新申请。
    </p>
    <p>
     3.破坏不剥夺条件：如果一个线程申请新的资源时已持有的资源被占用，可以强制释放它已占有的资源。尽管这种方法在实际系统很难实现，但某些情况下是可行的。
    </p>
    <p>
     4.使用死锁检测和恢复：系统可以定期检测是否存在死锁，如果检测到死锁，即采取恢复措施，例如，终止某些线程并且释放它们占有资源。
    </p>
    <p>
     5。使用高级同步工具：使用lock和unique_lock等高级同步工具来避免死锁。lock可以同时锁定多个互斥锁。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f73756e74696e677368656e673132332f:61727469636c652f64657461696c732f313436313537373436" class_="artid" style="display:none">
 </p>
</div>


