---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f73756e74696e677368656e673132332f:61727469636c652f64657461696c732f313436313537373436"
layout: post
title: "c介绍锁-一"
date: 2025-03-10 20:20:09 +08:00
description: "可以使用一次性分配所有资源方法，即线程一次申请它所需要的所有资源，只有在所有资源都满足情况下才开始执行，否则就释放已经获得的资源重新申请。3.破坏不剥夺条件：如果一个线程申请新的资源时已持有的资源被占用，可以强制释放它已占有的资源。4.使用死锁检测和恢复：系统可以定期检测是否存在死锁，如果检测到死锁，即采取恢复措施，例如，终止某些线程并且释放它们占有资源。： 已获得的资源在未使用完之前，不能被强行剥夺，只能使用完毕后由线程自己释放。：线程已经持有至少一个资源，同时又申请新的资源，而新资源被其他线程占有。"
keywords: "c++介绍锁 一"
categories: ['C']
tags: ['开发语言', 'C']
artid: "146157746"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146157746
    alt: "c介绍锁-一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146157746
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146157746
cover: https://bing.ee123.net/img/rand?artid=146157746
image: https://bing.ee123.net/img/rand?artid=146157746
img: https://bing.ee123.net/img/rand?artid=146157746
---

# c++介绍锁 一

死锁如何产生的：两个或者多个线程，互相等待对方释放资源，从而导致进程或者线程无法继续执行的现象。

造成死锁的条件：

1.
**互斥条件（Mutual Exclusion）：**
资源一次只能被一个线程占用。

2.
**请求保持条件(Hold and Wait)**
：线程已经持有至少一个资源，同时又申请新的资源，而新资源被其他线程占有。

3.
**不剥夺条件（No Preemption）**
： 已获得的资源在未使用完之前，不能被强行剥夺，只能使用完毕后由线程自己释放。

4.
**循环等待条件：**
存在一个线程循环等待链，链中的每个线程持有下一个线程所需资源。

如何解决死锁

1：避免循环等待条件：避免形成资源循环等待=链。例如，可以对所有资源进行排序，并按照顺序申请资源，确保不会形成循环等待。

2.破坏请求保持条件：在一个线程申请资源时，不允许它同时持有其他资源。可以使用一次性分配所有资源方法，即线程一次申请它所需要的所有资源，只有在所有资源都满足情况下才开始执行，否则就释放已经获得的资源重新申请。

3.破坏不剥夺条件：如果一个线程申请新的资源时已持有的资源被占用，可以强制释放它已占有的资源。尽管这种方法在实际系统很难实现，但某些情况下是可行的。

4.使用死锁检测和恢复：系统可以定期检测是否存在死锁，如果检测到死锁，即采取恢复措施，例如，终止某些线程并且释放它们占有资源。

5。使用高级同步工具：使用lock和unique\_lock等高级同步工具来避免死锁。lock可以同时锁定多个互斥锁。