---
layout: post
title: "算法-两数之和simple"
date: 2025-03-11 19:59:18 +0800
description: "两数之和(simple)题解"
keywords: "[算法] 两数之和(simple)"
categories: ['未分类']
tags: ['算法', '散列表', '哈希算法']
artid: "146187274"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146187274
    alt: "算法-两数之和simple"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146187274
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146187274
cover: https://bing.ee123.net/img/rand?artid=146187274
image: https://bing.ee123.net/img/rand?artid=146187274
img: https://bing.ee123.net/img/rand?artid=146187274
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [算法] 两数之和(simple)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-kimbie-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <p>
     接下来, 我们分享一道十分简单的题目 -&gt;
     <a href="https://leetcode.cn/problems/two-sum/description/" rel="nofollow">
      两数之和(simple)
     </a>
    </p>
    <h3>
     <a id="1__4">
     </a>
     1. 题意
    </h3>
    <blockquote>
     <p>
      给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
      <br/>
      <br/>
      你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
      <br/>
      <br/>
      你可以按任意顺序返回答案。
     </p>
    </blockquote>
    <p>
     示例 1：
     <br/>
     输入：nums = [2,7,11,15], target = 9
     <br/>
     输出：[0,1]
     <br/>
     解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
    </p>
    <p>
     示例 2：
     <br/>
     输入：nums = [3,2,4], target = 6
     <br/>
     输出：[1,2]
    </p>
    <p>
     示例 3：
     <br/>
     输入：nums = [3,3], target = 6
     <br/>
     输出：[0,1]
    </p>
    <p>
     提示：
    </p>
    <ul>
     <li>
      2 &lt;= nums.length &lt;= 104
     </li>
     <li>
      109 &lt;= nums[i] &lt;= 109
     </li>
     <li>
      109 &lt;= target &lt;= 109
     </li>
    </ul>
    <p>
     注: 只会存在一个有效答案
    </p>
    <pre><code>说白了, 就是给你一个数组, 然后让你挑出俩数来使之和 = target. 
</code></pre>
    <h3>
     <a id="2__35">
     </a>
     2. 思路
    </h3>
    <p>
     我们正常想到的是暴力求解, 挨个枚举即可.
     <br/>
     在策略上, 有两种方式:
    </p>
    <ul>
     <li>
      固定前面的数
      <code>
       nums[i]
      </code>
      , 来寻找后面有没有
      <code>
       target-nums[i]
      </code>
      .
     </li>
     <li>
      固定后面的数
      <code>
       nums[i]
      </code>
      , 来寻找前面有没有
      <code>
       target-nums[i]
      </code>
      .
      <br/>
      好的, 这两种思路都可以. 缺点就是时间复杂度是
      <strong>
       O(N*N)
      </strong>
      .
     </li>
    </ul>
    <p>
     我们还可以用 [哈希表] 来优化这道题的时间复杂度.
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5528afefe4d04496b00b4e44eb75d3de.png">
      <br/>
      前面暴力求解的思路之所以慢, 是因为当我们固定一个数
      <code>
       nums[i]
      </code>
      的时候, 来寻找另一个
      <code>
       target - nums[i]
      </code>
      的时间复杂度是
      <strong>
       O(N)
      </strong>
      .
      <br/>
      而如果我们哈希表提前把数组存储起来, 那么当我们固定一个数
      <code>
       nums[i]
      </code>
      的时候, 来寻找另一个
      <code>
       target - nums[i]
      </code>
      的时间复杂度接近
      <strong>
       O(1)
      </strong>
      .
      <br/>
      因为暴力求解有两种策略, 那么加上哈希表也有两种不同的策略.
     </img>
    </p>
    <ul>
     <li>
      <font color="ff00">
       策略1: 固定前面的数选后面的数 + 哈希表
      </font>
     </li>
     <li>
      <font color="ff00">
       策略2: 固定后面的数选前面的数 + 哈希表
      </font>
     </li>
    </ul>
    <p>
     这两种思路都是可以的, 时间复杂度都一样, 都是O(N), 但是编码难易程度不同.
    </p>
    <p>
     如果采用策略1:
     <br/>
     我们可以先把数组全部入哈希表, 然后遍历数组寻找哈希表中是否存在
     <code>
      target - nums[i]
     </code>
     .
     <font color="ff00">
      但是需要特判, 因为可能会找到自己!
     </font>
     <br/>
     如果采用策略2:
     <br/>
     我们可以一边将数组的值
     <code>
      nums[i]
     </code>
     入哈希表, 然后一边寻找
     <code>
      target-nums[i]
     </code>
     .
    </p>
    <h3>
     <a id="3__57">
     </a>
     3. 编码
    </h3>
    <p>
     // 策略1编码:
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            hash<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> hash<span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
                <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>i<span class="token punctuation">,</span> hash<span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 为了迎合编译器过编. </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <font color="ff00">
      [注意]: 策略1需要特殊判断找到的
      <code>
       target - nums[i]是否是nums[i]
      </code>
      !!!
     </font>
    </p>
    <p>
     // 策略2编码:
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
                <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>i<span class="token punctuation">,</span> hash<span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            hash<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 为了迎合编译器过编. </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     思路1: 暴力求解
     <br/>
     时间复杂度: O(N*N)
     <br/>
     空间复杂度: O(1)
    </p>
    <p>
     思路2: 暴力求解 + 哈希表
     <br/>
     时间复杂度: O(N)
     <br/>
     空间复杂度: O(N)
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8baff74c4eed4c10a5195f05345860e8.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e02aa594d8b745f491c6636f445e260a.png"/>
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37393033313634362f:61727469636c652f64657461696c732f313436313837323734" class_="artid" style="display:none">
 </p>
</div>


