---
layout: post
title: "数据结构栈"
date: 2025-03-14 19:37:44 +0800
description: "逻辑结构：在数据结构中栈只能在一段进行进栈和出栈操作的线性结构—所以满足后进先出的原则物理结构：在存储结构上分为顺序栈和链栈。"
keywords: "数据结构——栈"
categories: ['未分类']
tags: ['数据结构']
artid: "146265428"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146265428
    alt: "数据结构栈"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146265428
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146265428
cover: https://bing.ee123.net/img/rand?artid=146265428
image: https://bing.ee123.net/img/rand?artid=146265428
img: https://bing.ee123.net/img/rand?artid=146265428
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——栈
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     逻辑结构：在数据结构中栈只能在一段进行进栈和出栈操作的线性结构—所以满足后进先出的原则
    </p>
    <p>
     物理结构：在存储结构上分为顺序栈和链栈
    </p>
    <p>
    </p>
    <h2>
     1.顺序栈
    </h2>
    <p>
     <img alt="" height="668" src="https://i-blog.csdnimg.cn/direct/d2e915176e734a238801fed44382ce3e.png" width="861"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h3>
     1.1顺序栈的结构体
    </h3>
    <pre><code class="language-cs">#define MaxSize 10
typedef struct Stack
{
	int data[MaxSize];//数组用于存放栈中的元素
	int top;//栈顶指针
}SqStack;
</code></pre>
    <h3>
     1.2初始化顺序栈
    </h3>
    <pre><code class="language-cs">//初始化栈
void InitStack(SqStack* S)
{
	S-&gt;top = -1;//栈顶指针为-1表示为空栈
}
</code></pre>
    <h3>
     1.3栈的判空
    </h3>
    <pre><code class="language-cs"> //栈的判空
bool Empty(SqStack* S)
{
	if (S-&gt;top == -1)
	{
		printf(" 这个栈是空栈\n");
		return true;
	}
	else
	{
		return false;
	}
}
</code></pre>
    <h3>
     1.4进栈操作
    </h3>
    <pre><code class="language-cs">//进栈操作

bool Push(SqStack* S)
{
	//进栈要先保证栈没有满
	if (S-&gt;top &gt;= MaxSize)
	{
		return false;
	}
	int x = 0;
	printf("请输入要进栈的元素：");
	scanf("%d", &amp;x);
	S-&gt;data[++S-&gt;top] = x;
	//S-&gt;top=S-&gt;top+1;
	// S-&gt;data[S-&gt;top]=x;
	//先对指针加一，再进行赋值操作
	return true;
}
</code></pre>
    <h3>
     1.5出栈操作
    </h3>
    <pre><code class="language-cs">//出栈操作
bool Pop(SqStack* S,int* x)
{
	//出栈要保证栈不空
	if (S-&gt;top == -1)
	{
		return false;
	}
	//出栈操作只能取出栈顶元素
	*x = S-&gt;data[S-&gt;top--];
	//x=S-&gt;data[S-&gt;top];
	//s-&gt;top--;
	//这里的数据x依旧在内存当中并没有删除，只是在逻辑上删除了
	return true;
}

</code></pre>
    <h3>
     1.6读出栈顶元素
    </h3>
    <pre><code class="language-cs">//读栈顶元素与出栈操作区别不大
bool GetTop(SqStack* S,int* x)
{
    //读栈顶元素要保证栈不空
    if (S-&gt;top == -1)
    {
        return false;
    }
     *x = S-&gt;data[S-&gt;top];
    return true;
}</code></pre>
    <h3>
     1.7完整的顺序栈代码
    </h3>
    <pre><code class="language-cs">//顺序栈的基本操作

typedef struct Stack
{
	int data[MaxSize];//数组用于存放栈中的元素
	int top;//栈顶指针
}SqStack;


//初始化栈
void InitStack(SqStack* S)
{
	S-&gt;top = -1;//栈顶指针为-1表示为空栈
}

 //栈的判空
bool Empty(SqStack* S)
{
	if (S-&gt;top == -1)
	{
		printf(" 这个栈是空栈\n");
		return true;
	}
	else
	{
		return false;
	}
}

//进栈操作

bool Push(SqStack* S)
{
	//进栈要先保证栈没有满
	if (S-&gt;top &gt;= MaxSize)
	{
		return false;
	}
	int x = 0;
	printf("请输入要进栈的元素：");
	scanf("%d", &amp;x);
	S-&gt;data[++S-&gt;top] = x;
	//S-&gt;top=S-&gt;top+1;
	// S-&gt;data[S-&gt;top]=x;
	//先对指针加一，再进行赋值操作
	return true;
}

//出栈操作
bool Pop(SqStack* S,int* x)
{
	//出栈要保证栈不空
	if (S-&gt;top == -1)
	{
		return false;
	}
	//出栈操作只能取出栈顶元素
	*x = S-&gt;data[S-&gt;top--];
	//x=S-&gt;data[S-&gt;top];
	//s-&gt;top--;
	//这里的数据x依旧在内存当中并没有删除，只是在逻辑上删除了
	return true;
}


//读栈顶元素与出栈操作区别不大
bool GetTop(SqStack* S,int* x)
{
	//读栈顶元素要保证栈不空
	if (S-&gt;top == -1)
	{
		return false;
	}
	 *x = S-&gt;data[S-&gt;top];
	return true;
}


int main()
{
	SqStack S;
	int x = 0;//用于记录栈顶元素，或者读出栈顶元素
	InitStack(&amp;S);
	//先进栈5个元素
	int i = 0;
	for (i = 0; i &lt; 5; i++)
	{
		Push(&amp;S);
	}
	//出栈一个元素
	Pop(&amp;S,&amp;x);
	printf("出栈元素是%d\n", x);

	//读出此时的栈顶元素
	GetTop(&amp;S,&amp;x);
	printf("此时的栈顶元素是%d\n", x);
	return 0;
}
</code></pre>
    <h2>
     <br/>
     2.链栈
    </h2>
    <p>
     下面主要介绍不带头结点的链栈，并且把链表的表头当作链栈的栈顶。
    </p>
    <p>
    </p>
    <h3>
     2.1链栈的结构体和初始化
    </h3>
    <pre><code class="language-cs">typedef struct LinkNode
{
	int data;
	struct LinkNode* next;
}LiStack;


//初始化链栈
void InitLiStack(LiStack** L)
{
	(*L) = NULL;
}



int main()
{
	LiStack* S=NULL;
	int x = 0;
	InitLiStack(&amp;S);//这里涉及到二级指针
	//进栈操作,先进栈五个元素
	int i = 0;
	for (i = 0; i &lt; 5; i++)
	{
		Push(&amp;S);
	}
	//出栈一个元素
	Pop(&amp;S,&amp;x);
	printf("出栈的元素是%d\n", x);

	//获取栈顶元素
	GetTop(S,&amp;x);
	printf("当前栈顶元素是%d\n", x);
}

</code></pre>
    <p>
     <img alt="" height="360" src="https://i-blog.csdnimg.cn/direct/e567bc773fe14f6ca61940a332ffba04.png" width="900"/>
    </p>
    <h3>
     2.2入栈操作
    </h3>
    <p>
     <img alt="" height="708" src="https://i-blog.csdnimg.cn/direct/4d509af103d04498b293fc7aec9f66d9.png" width="1777"/>
    </p>
    <pre><code class="language-cs">//入栈
bool Push(LiStack** L)
{
	//对于链栈不存在栈满
	int x = 0;
	printf("请输入要进栈的整数:");
	scanf("%d", &amp;x);

	LiStack* s = (LiStack*)calloc(1, sizeof(LiStack));
	if (s == NULL)
	{
		return false;
	}
	s-&gt;data = x;
	s-&gt;next = (*L);
	(*L) = s;
	return true;
}
</code></pre>
    <h3>
     2.3出栈操作
    </h3>
    <p>
     <img alt="" height="527" src="https://i-blog.csdnimg.cn/direct/2bd581ad7760408dba8b080391f0ca1e.png" width="1590"/>
    </p>
    <pre><code class="language-cs">//出栈
bool Pop(LiStack** L, int* x)
{
	//先判断栈是否为空 
	if (L == NULL)
	{
		return false;
	}
	(*x) = (*L)-&gt;data;
	LiStack* p = (*L);
	(*L) = p-&gt;next;
	free(p);
	return true;
}</code></pre>
    <h3>
     2.4读出栈顶元素
    </h3>
    <pre><code class="language-cs">//获取栈顶元素
bool GetTop(LiStack* L,int* x)
{
	//先判断栈是否为空 
	if (L == NULL)
	{
		return false;
	}
	(*x) = L-&gt;data;
	return true;
}</code></pre>
    <h3>
     2.5链栈的整体代码
    </h3>
    <pre><code class="language-cs">//不带头结点的链栈

typedef struct LinkNode
{
	int data;
	struct LinkNode* next;
}LiStack;


//初始化链栈
void InitLiStack(LiStack** L)
//这里涉及到二级指针
{
	(*L) = NULL;
}

//入栈
bool Push(LiStack** L)
{
	//对于链栈不存在栈满
	int x = 0;
	printf("请输入要进栈的整数:");
	scanf("%d", &amp;x);

	LiStack* s = (LiStack*)calloc(1, sizeof(LiStack));
	if (s == NULL)
	{
		return false;
	}
	s-&gt;data = x;
	s-&gt;next = (*L);
	(*L) = s;
	return true;
}

//出栈
bool Pop(LiStack** L, int* x)
{
	//先判断栈是否为空 
	if (L == NULL)
	{
		return false;
	}
	(*x) = (*L)-&gt;data;
	LiStack* p = (*L);
	(*L) = p-&gt;next;
	free(p);
	return true;
}

//获取栈顶元素
bool GetTop(LiStack* L,int* x)
{
	//先判断栈是否为空 
	if (L == NULL)
	{
		return false;
	}
	(*x) = L-&gt;data;
	return true;
}

int main()
{
	LiStack* S=NULL;
	int x = 0;
	InitLiStack(&amp;S);//这里涉及到二级指针，传递的是栈顶指针的地址
	//进栈操作,先进栈五个元素
	int i = 0;
	for (i = 0; i &lt; 5; i++)
	{
		Push(&amp;S);
	}
	//出栈一个元素
	Pop(&amp;S,&amp;x);
	printf("出栈的元素是%d\n", x);

	//获取栈顶元素
	GetTop(S,&amp;x);
	printf("当前栈顶元素是%d\n", x);
}


</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f68776230302f:61727469636c652f64657461696c732f313436323635343238" class_="artid" style="display:none">
 </p>
</div>


