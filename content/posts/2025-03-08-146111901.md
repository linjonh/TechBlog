---
layout: post
title: "力扣热题-100二叉树专题经典题解析前8道"
date: 2025-03-08 10:59:04 +0800
description: "二叉搜索树的性质是：左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值。我们可以使用递归的方法，同时传递当前节点的合法取值范围。我们可以使用递归的方法，在计算深度的同时更新最大直径。我们可以使用递归的方法，分别计算左右子树的深度，然后取最大值加 1（根节点）。我们可以使用递归的方法，选择数组的中间元素作为根节点，然后递归构建左右子树。最大深度是指从根节点到最远叶子节点的最长路径上的节点数。我们可以使用递归的方法，对每个节点交换其左右子树。给定一个升序排列的数组，将其转换为高度平衡的二叉搜索树。"
keywords: "力扣热题 100：二叉树专题经典题解析（前8道）"
categories: ['未分类']
tags: ['算法', 'Leetcode', 'Java']
artid: "146111901"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146111901
    alt: "力扣热题-100二叉树专题经典题解析前8道"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146111901
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146111901
cover: https://bing.ee123.net/img/rand?artid=146111901
image: https://bing.ee123.net/img/rand?artid=146111901
img: https://bing.ee123.net/img/rand?artid=146111901
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     力扣热题 100：二叉树专题经典题解析（前8道）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <p>
     在力扣（LeetCode）平台上，二叉树相关的题目是算法面试和练习中的重要部分。今天，我们就来详细解析二叉树专题中的几道经典题目，帮助大家更好地理解解题思路和技巧。
    </p>
    <h3>
     <a id="_94_4">
     </a>
     一、二叉树的中序遍历（题目 94）
    </h3>
    <h4>
     <a id="1__6">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个二叉树，返回其节点值的中序遍历。
    </p>
    <h4>
     <a id="2__10">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [1, null, 2, 3]
     </code>
    </p>
    <p>
     输出：
     <code>
      [1, 3, 2]
     </code>
    </p>
    <h4>
     <a id="3__18">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉树的中序遍历。中序遍历的顺序是左子树、根节点、右子树。我们可以使用递归或迭代的方法来实现。这里使用递归方法，因为它更简洁易懂。
    </p>
    <h4>
     <a id="4_Java_22">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorderHelper</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">inorderHelper</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderHelper</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__43">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，其中 n 是二叉树的节点数。每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，递归调用栈的深度在最坏情况下为 O(n)（如退化为链表的二叉树）。
     </li>
    </ul>
    <h3>
     <a id="_104_48">
     </a>
     二、二叉树的最大深度（题目 104）
    </h3>
    <h4>
     <a id="1__50">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个二叉树，求其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点数。
    </p>
    <h4>
     <a id="2__54">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [3, 9, 20, null, null, 15, 7]
     </code>
    </p>
    <p>
     输出：
     <code>
      3
     </code>
    </p>
    <h4>
     <a id="3__62">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉树的深度计算。我们可以使用递归的方法，分别计算左右子树的深度，然后取最大值加 1（根节点）。
    </p>
    <h4>
     <a id="4_Java_66">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__81">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，递归调用栈的深度在最坏情况下为 O(n)。
     </li>
    </ul>
    <h3>
     <a id="_226_86">
     </a>
     三、翻转二叉树（题目 226）
    </h3>
    <h4>
     <a id="1__88">
     </a>
     1. 题目描述
    </h4>
    <p>
     翻转一棵二叉树，即将左子树和右子树交换。
    </p>
    <h4>
     <a id="2__92">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [4, 2, 7, 1, 3, 6, 9]
     </code>
    </p>
    <p>
     输出：
     <code>
      [4, 7, 2, 9, 6, 3, 1]
     </code>
    </p>
    <h4>
     <a id="3__100">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉树的翻转操作。我们可以使用递归的方法，对每个节点交换其左右子树。
    </p>
    <h4>
     <a id="4_Java_104">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__120">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，递归调用栈的深度在最坏情况下为 O(n)。
     </li>
    </ul>
    <h3>
     <a id="_101_125">
     </a>
     四、对称二叉树（题目 101）
    </h3>
    <h4>
     <a id="1__127">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个二叉树，判断它是否是镜像对称的。
    </p>
    <h4>
     <a id="2__131">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [1, 2, 2, 3, 4, 4, 3]
     </code>
    </p>
    <p>
     输出：
     <code>
      true
     </code>
    </p>
    <h4>
     <a id="3__139">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉树的对称性判断。我们可以使用递归的方法，判断左子树和右子树是否镜像对称。
    </p>
    <h4>
     <a id="4_Java_143">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isMirror</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> t1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> t1<span class="token punctuation">.</span>val <span class="token operator">==</span> t2<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__163">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，递归调用栈的深度在最坏情况下为 O(n)。
     </li>
    </ul>
    <h3>
     <a id="_543_168">
     </a>
     五、二叉树的直径（题目 543）
    </h3>
    <h4>
     <a id="1__170">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个二叉树，求其直径。直径是指任意两个节点之间的最长路径的长度。
    </p>
    <h4>
     <a id="2__174">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [1, 2, 3, 4, 5]
     </code>
    </p>
    <p>
     输出：
     <code>
      3
     </code>
    </p>
    <p>
     解释：最长路径是 4 → 2 → 1 → 3，长度为 3。
    </p>
    <h4>
     <a id="3__184">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉树直径的计算。直径等于左右子树深度之和的最大值。我们可以使用递归的方法，在计算深度的同时更新最大直径。
    </p>
    <h4>
     <a id="4_Java_188">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> maxDiameter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> maxDiameter<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        maxDiameter <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxDiameter<span class="token punctuation">,</span> leftDepth <span class="token operator">+</span> rightDepth<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__211">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，递归调用栈的深度在最坏情况下为 O(n)。
     </li>
    </ul>
    <h3>
     <a id="_102_216">
     </a>
     六、二叉树的层序遍历（题目 102）
    </h3>
    <h4>
     <a id="1__218">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个二叉树，返回其层序遍历的结果。
    </p>
    <h4>
     <a id="2__222">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [3, 9, 20, null, null, 15, 7]
     </code>
    </p>
    <p>
     输出：
     <code>
      [[3], [9, 20], [15, 7]]
     </code>
    </p>
    <h4>
     <a id="3__230">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉树的层序遍历。我们可以使用广度优先搜索（BFS）的方法，使用队列来实现。具体步骤如下：
    </p>
    <ol>
     <li>
      初始化一个队列，将根节点加入队列。
     </li>
     <li>
      遍历队列中的节点，按层处理。
     </li>
     <li>
      对于每一层，记录节点值，并将子节点加入队列。
     </li>
     <li>
      重复直到队列为空。
     </li>
    </ol>
    <h4>
     <a id="4_Java_239">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Queue</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> level <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                level<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__275">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，队列在最坏情况下存储一层的所有节点。
     </li>
    </ul>
    <h3>
     <a id="_108_280">
     </a>
     七、将有序数组转换为二叉搜索树（题目 108）
    </h3>
    <h4>
     <a id="1__282">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个升序排列的数组，将其转换为高度平衡的二叉搜索树。
    </p>
    <h4>
     <a id="2__286">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      nums = [-10, -3, 0, 5, 9]
     </code>
    </p>
    <p>
     输出：
     <code>
      [0, -3, 9, -10, null, 5]
     </code>
    </p>
    <p>
     解释：一种可能的平衡二叉搜索树如下：
    </p>
    <pre><code>    0
   / \
 -3   9
 /   /
-10  5
</code></pre>
    <h4>
     <a id="3__304">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉搜索树的构建。我们可以使用递归的方法，选择数组的中间元素作为根节点，然后递归构建左右子树。
    </p>
    <h4>
     <a id="4_Java_308">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__329">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个元素访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(log n)，递归调用栈的深度在平衡情况下为 O(log n)。
     </li>
    </ul>
    <h3>
     <a id="_98_334">
     </a>
     八、验证二叉搜索树（题目 98）
    </h3>
    <h4>
     <a id="1__336">
     </a>
     1. 题目描述
    </h4>
    <p>
     给定一个二叉树，判断它是否是有效的二叉搜索树。
    </p>
    <h4>
     <a id="2__340">
     </a>
     2. 示例
    </h4>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [2, 1, 3]
     </code>
    </p>
    <p>
     输出：
     <code>
      true
     </code>
    </p>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     输入：
     <code>
      root = [5, 1, 4, null, null, 3, 6]
     </code>
    </p>
    <p>
     输出：
     <code>
      false
     </code>
    </p>
    <p>
     解释：右子树的根节点 4 小于根节点 5。
    </p>
    <h4>
     <a id="3__356">
     </a>
     3. 解题思路
    </h4>
    <p>
     这道题主要考察二叉搜索树的验证。二叉搜索树的性质是：左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值。我们可以使用递归的方法，同时传递当前节点的合法取值范围。
    </p>
    <h4>
     <a id="4_Java_360">
     </a>
     4. 代码实现（Java）
    </h4>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">Integer</span> min<span class="token punctuation">,</span> <span class="token class-name">Integer</span> max<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>min <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>val <span class="token operator">&gt;=</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="5__380">
     </a>
     5. 复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个节点访问一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：O(n)，递归调用栈的深度在最坏情况下为 O(n)。
     </li>
    </ul>
    <p>
     以上就是力扣热题 100 中与二叉树相关的经典题目的详细解析，希望对大家有所帮助。在实际刷题过程中，建议大家多动手实践，理解解题思路的本质，这样才能更好地应对各种算法问题。
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b69eb415448f41c4ae90e62a21ccfa87.png#pic_center"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323638363139362f:61727469636c652f64657461696c732f313436313131393031" class_="artid" style="display:none">
 </p>
</div>


