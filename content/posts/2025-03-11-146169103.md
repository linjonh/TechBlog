---
layout: post
title: "Python正则表达式"
date: 2025-03-11 09:09:29 +0800
description: "正则表达式在python中的基础和应用"
keywords: "Python：正则表达式"
categories: ['Python']
tags: ['正则表达式', '数据库', 'Python']
artid: "146169103"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146169103
    alt: "Python正则表达式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146169103
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146169103
cover: https://bing.ee123.net/img/rand?artid=146169103
image: https://bing.ee123.net/img/rand?artid=146169103
img: https://bing.ee123.net/img/rand?artid=146169103
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python：正则表达式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     正则表达式的基础和应用
    </p>
    <h4>
     一、正则表达式核心语法（四大基石）
    </h4>
    <h5>
     1. ​
     <strong>
      元字符（特殊符号）​
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       定位符
      </strong>
      <br/>
      <code>
       ^
      </code>
      ：匹配字符串
      <strong>
       开始位置
      </strong>
      <br/>
      <code>
       $
      </code>
      ：匹配字符串
      <strong>
       结束位置
      </strong>
      <br/>
      <code>
       \b
      </code>
      ：匹配
      <strong>
       单词边界
      </strong>
      ​（如
      <code>
       \bword\b
      </code>
      匹配独立单词）
     </li>
     <li>
      ​
      <strong>
       字符类
      </strong>
      <br/>
      <code>
       .
      </code>
      ：任意单个字符（默认不包括换行符）
      <br/>
      <code>
       \d
      </code>
      ：数字（等价
      <code>
       [0-9]
      </code>
      ）
      <br/>
      <code>
       \w
      </code>
      ：字母、数字、下划线（等价
      <code>
       [a-zA-Z0-9_]
      </code>
      ）
      <br/>
      <code>
       \s
      </code>
      ：空白符（空格、Tab、换行等）
     </li>
     <li>
      ​
      <strong>
       转义符
      </strong>
      <br/>
      <code>
       \
      </code>
      ：将特殊字符转为普通字符（如
      <code>
       \.
      </code>
      匹配真正的点号）
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      量词（重复次数）​
     </strong>
    </h5>
    <ul>
     <li>
      <code>
       *
      </code>
      ：0次或多次
     </li>
     <li>
      <code>
       +
      </code>
      ：1次或多次
     </li>
     <li>
      <code>
       ?
      </code>
      ：0次或1次
     </li>
     <li>
      <code>
       {n}
      </code>
      ：精确n次
     </li>
     <li>
      <code>
       {n,}
      </code>
      ：至少n次
     </li>
     <li>
      <code>
       {n,m}
      </code>
      ：n到m次
     </li>
    </ul>
    <h5>
     3. ​
     <strong>
      字符集合与逻辑
     </strong>
    </h5>
    <ul>
     <li>
      <code>
       [abc]
      </code>
      ：匹配a、b、c中的任意一个
     </li>
     <li>
      <code>
       [a-z]
      </code>
      ：匹配小写字母a到z
     </li>
     <li>
      <code>
       [^abc]
      </code>
      ：否定集合（匹配不在abc中的字符）
     </li>
     <li>
      <code>
       |
      </code>
      ：逻辑或（如
      <code>
       cat|dog
      </code>
      匹配"cat"或"dog"）
     </li>
    </ul>
    <h5>
     4. ​
     <strong>
      分组与引用
     </strong>
    </h5>
    <ul>
     <li>
      <code>
       ( )
      </code>
      ：捕获分组（可通过
      <code>
       \1
      </code>
      或
      <code>
       $1
      </code>
      反向引用）
     </li>
     <li>
      <code>
       (?: )
      </code>
      ：非捕获分组（仅用于逻辑分组）
     </li>
     <li>
      <code>
       (?P&lt;name&gt;)
      </code>
      ：命名分组（Python中可通过名称引用）
     </li>
    </ul>
    <hr/>
    <h4>
     二、正则引擎工作原理（NFA vs DFA）
    </h4>
    <h5>
     1. ​
     <strong>
      NFA引擎（主流实现）​
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       特点
      </strong>
      ：支持回溯、捕获组、零宽断言等高级功能，但存在性能风险
     </li>
     <li>
      ​
      <strong>
       匹配流程
      </strong>
      ：
      <ol>
       <li>
        从起始位置尝试匹配
       </li>
       <li>
        记录所有可能的分支（回溯点）
       </li>
       <li>
        失败时退回最近回溯点继续尝试
       </li>
       <li>
        直到匹配成功或完全失败
       </li>
      </ol>
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      DFA引擎
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       特点
      </strong>
      ：无回溯，线性时间复杂度，但功能受限（不支持分组引用）
     </li>
     <li>
      ​
      <strong>
       流程
      </strong>
      ：一次性扫描文本，无状态回退
     </li>
    </ul>
    <hr/>
    <h4>
     三、关键应用场景与解决方案
    </h4>
    <h5>
     1. ​
     <strong>
      数据验证（精准匹配）​
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       ​
       <strong>
        邮箱验证
       </strong>
      </p>
      <pre><code class="language-python">^[\w\.-]+@([\w-]+\.)+[\w-]{2,4}$  </code></pre>
      <ul>
       <li>
        <code>
         ^
        </code>
        和
        <code>
         $
        </code>
        确保整行匹配
       </li>
       <li>
        <code>
         [\w\.-]+
        </code>
        允许用户名包含字母、数字、点、减号
       </li>
       <li>
        <code>
         ([\w-]+\.)+
        </code>
        匹配多级域名（如 "mail." 或 "google.com."）
       </li>
       <li>
        <code>
         [\w-]{2,4}
        </code>
        匹配顶级域名（如 com、org）
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        强密码规则
       </strong>
      </p>
      <pre><code class="language-python">^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$  </code></pre>
      <ul>
       <li>
        <code>
         (?=.*\d)
        </code>
        ：正向预查确保包含数字
       </li>
       <li>
        <code>
         (?=.*[a-z])
        </code>
        ：必须有小写字母
       </li>
       <li>
        <code>
         (?=.*[A-Z])
        </code>
        ：必须有大写字母
       </li>
       <li>
        <code>
         .{8,}
        </code>
        ：总长度至少8位
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      数据提取（捕获关键信息）​
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       ​
       <strong>
        从URL提取域名和路径
       </strong>
      </p>
      <pre><code>^https?://([^/?#]+)([^?#]*)  </code></pre>
      <ul>
       <li>
        分组1
        <code>
         ([^/?#]+)
        </code>
        捕获域名（如
        <code>
         www.example.com
        </code>
        ）
       </li>
       <li>
        分组2
        <code>
         ([^?#]*)
        </code>
        捕获路径（如
        <code>
         /path/to/page
        </code>
        ）
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        日志时间戳提取
       </strong>
      </p>
      <pre><code>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}</code></pre>
      <ul>
       <li>
        精确匹配
        <code>
         YYYY-MM-DD HH:MM:SS
        </code>
        格式
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     3. ​
     <strong>
      文本清洗与替换
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       ​
       <strong>
        删除HTML标签
       </strong>
      </p>
      <pre><code>&lt;[^&gt;]+&gt;  </code></pre>
      <ul>
       <li>
        匹配所有以
        <code>
         &lt;
        </code>
        开头、
        <code>
         &gt;
        </code>
        结尾的内容
       </li>
       <li>
        使用
        <code>
         re.sub(r'&lt;[^&gt;]+&gt;', '', html)
        </code>
        替换为空
       </li>
      </ul>
     </li>
     <li>
      <p>
       ​
       <strong>
        格式化电话号码
       </strong>
       <br/>
       输入：
       <code>
        1234567890
       </code>
       → 输出：
       <code>
        (123) 456-7890
       </code>
      </p>
      <pre><code>re.sub(r'(\d{3})(\d{3})(\d{4})', r'(\1) \2-\3', phone)</code></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     四、性能优化与避坑指南
    </h4>
    <h5>
     1. ​
     <strong>
      避免灾难性回溯
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       危险模式
      </strong>
      ：
      <code>
       (a+)+
      </code>
      或
      <code>
       .*.*
      </code>
      （嵌套量词导致指数级复杂度）
     </li>
     <li>
      ​
      <strong>
       优化方法
      </strong>
      ：
      <ul>
       <li>
        用具体字符代替
        <code>
         .*
        </code>
        （如
        <code>
         \d+
        </code>
        代替
        <code>
         .*
        </code>
        ）
       </li>
       <li>
        使用原子分组
        <code>
         (?&gt;...)
        </code>
        （部分引擎支持）
       </li>
       <li>
        添加锚点限制范围（如
        <code>
         ^...$
        </code>
        ）
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      贪婪与非贪婪选择
     </strong>
    </h5>
    <ul>
     <li>
      ​
      <strong>
       贪婪模式
      </strong>
      ​（默认）：
      <code>
       .*
      </code>
      匹配尽可能多内容
      <pre><code>&lt;div&gt;.*&lt;/div&gt; → 可能跨多个标签错误匹配</code></pre>
     </li>
     <li>
      ​
      <strong>
       非贪婪模式
      </strong>
      ：
      <code>
       .*?
      </code>
      匹配最短结果
      <pre><code>&lt;div&gt;.*?&lt;/div&gt; → 精确匹配单个标签内容</code></pre>
     </li>
    </ul>
    <h5>
     3. ​
     <strong>
      预编译与复用
     </strong>
    </h5>
    <pre><code># 预编译提升性能（适用于频繁调用场景）
pattern = re.compile(r'\d{3}-\d{4}')
pattern.findall('Tel: 123-4567')</code></pre>
    <hr/>
    <h4>
     五、进阶技巧
    </h4>
    <h5>
     1. ​
     <strong>
      零宽断言（Lookaround）​
     </strong>
    </h5>
    <ul>
     <li>
      <code>
       (?=...)
      </code>
      ：正向先行断言（右侧必须满足条件）
      <pre><code>\d+(?=px) → 匹配 "100px" 中的 "100"</code></pre>
     </li>
     <li>
      <code>
       (?&lt;=...)
      </code>
      ：正向后行断言（左侧必须满足条件）
      <pre><code>(?&lt;=\$)\d+ → 匹配 "$200" 中的 "200"</code></pre>
     </li>
    </ul>
    <h5>
     2. ​
     <strong>
      条件匹配
     </strong>
    </h5>
    <pre><code>(?(id)yes|no) → 根据分组是否存在选择分支</code></pre>
    <ul>
     <li>
      示例：匹配带区号的电话号码
      <pre><code>($)? \d{3} (?(1)$|) → 匹配 "(123)" 或 "123"</code></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     六、好用的工具
    </h4>
    <ol>
     <li>
      ​
      <strong>
       调试工具
      </strong>
      <ul>
       <li>
        RegExr：实时高亮匹配结果，显示分组与回溯
       </li>
       <li>
        Regex101：支持多语言引擎，提供错误解释
       </li>
      </ul>
     </li>
     <li>
      ​
      <strong>
       可视化工具
      </strong>
      <br/>
      Regexper：图形化展示正则逻辑
     </li>
    </ol>
    <hr/>
    <h4>
     七、总结
    </h4>
    <p>
     正则表达式的核心在于 ​
     <strong>
      模式定义
     </strong>
     与 ​
     <strong>
      引擎匹配机制
     </strong>
     的结合。掌握以下要点即可应对90%的场景：
    </p>
    <ol>
     <li>
      ​
      <strong>
       精准定位
      </strong>
      ：用
      <code>
       ^
      </code>
      、
      <code>
       $
      </code>
      、
      <code>
       \b
      </code>
      约束边界
     </li>
     <li>
      ​
      <strong>
       明确范围
      </strong>
      ：用字符集合
      <code>
       [...]
      </code>
      和量词
      <code>
       {n,m}
      </code>
      减少模糊匹配
     </li>
     <li>
      ​
      <strong>
       合理分组
      </strong>
      ：通过
      <code>
       ( )
      </code>
      提取关键数据
     </li>
     <li>
      ​
      <strong>
       性能优先
      </strong>
      ：避免嵌套量词，优先使用具体字符
     </li>
    </ol>
    <blockquote>
     <h3>
      以下是Python中正则表达式的用法
     </h3>
     <hr/>
     <p>
      一、环境准备
     </p>
     <p>
      1. 导入re模块
     </p>
     <pre><code class="language-python">import re  # Python内置正则库</code></pre>
     <p>
      2. 原始字符串（Raw String）
     </p>
     <p>
      正则表达式推荐使用原始字符串（前缀
      <code>
       r
      </code>
      ），避免Python字符串转义冲突：
     </p>
     <pre><code class="language-python">pattern = r'\d+'  # 正确：匹配数字
pattern = '\\d+'   # 错误：需双重转义，可读性差</code></pre>
     <hr/>
     <p>
      二、四大核心方法
     </p>
     <p>
      1. re.match() - ​
      <strong>
       从开头匹配
      </strong>
     </p>
     <ul>
      <li>
       <p>
        只匹配字符串
        <strong>
         开头
        </strong>
        ，成功返回
        <code>
         Match对象
        </code>
        ，否则返回
        <code>
         None
        </code>
       </p>
      </li>
     </ul>
     <pre><code class="language-python">text = "123abc"
result = re.match(r'\d+', text)
if result:
    print("匹配成功:", result.group())  # 输出: 123</code></pre>
     <p>
      2. re.search() - ​
      <strong>
       全局搜索
      </strong>
     </p>
     <ul>
      <li>
       <p>
        扫描整个字符串，找到
        <strong>
         第一个
        </strong>
        匹配项
       </p>
      </li>
     </ul>
     <pre><code class="language-python">text = "abc456def"
result = re.search(r'\d+', text)
print(result.group())  # 输出: 456</code></pre>
     <p>
      3. re.findall() - ​
      <strong>
       查找所有匹配
      </strong>
     </p>
     <ul>
      <li>
       <p>
        返回所有匹配结果的
        <strong>
         列表
        </strong>
        ​（无分组时返回字符串列表）
       </p>
      </li>
     </ul>
     <pre><code class="language-python">text = "1a2b3c"
numbers = re.findall(r'\d', text)
print(numbers)  # 输出: ['1', '2', '3']</code></pre>
     <p>
      4. re.sub() - ​
      <strong>
       替换匹配内容
      </strong>
     </p>
     <ul>
      <li>
       <p>
        将匹配内容替换为指定字符串
       </p>
      </li>
     </ul>
     <pre><code class="language-python">text = "2023-01-01"
new_text = re.sub(r'-', '/', text)
print(new_text)  # 输出: 2023/01/01</code></pre>
     <hr/>
     <p>
      三、分组与捕获
     </p>
     <p>
      1. 基本分组
      <code>
       ( )
      </code>
     </p>
     <ul>
      <li>
       <p>
        用括号分组，通过
        <code>
         group(index)
        </code>
        提取
       </p>
      </li>
     </ul>
     <pre><code class="language-python">text = "John:30"
pattern = r'(\w+):(\d+)'
match = re.search(pattern, text)
print(match.group(1))  # John
print(match.group(2))  # 30</code></pre>
     <p>
      2. 非捕获分组
      <code>
       (?: )
      </code>
     </p>
     <ul>
      <li>
       <p>
        分组但不捕获，节省内存
       </p>
      </li>
     </ul>
     <pre><code>text = "apple orange"
pattern = r'(?:a|an|the) (\w+)'  # 匹配冠词后的单词但不捕获冠词
match = re.search(pattern, text)
print(match.group(1))  # apple</code></pre>
     <p>
      3. 命名分组
      <code>
       (?P&lt;name&gt;)
      </code>
     </p>
     <ul>
      <li>
       <p>
        为分组命名，提升可读性
       </p>
      </li>
     </ul>
     <pre><code>text = "Date: 2023-08-15"
pattern = r'Date: (?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})'
match = re.search(pattern, text)
print(match.group('year'))   # 2023
print(match.groupdict())     # {'year': '2023', 'month': '08', 'day': '15'}</code></pre>
     <hr/>
     <p>
      四、高级功能
     </p>
     <p>
      1. 正则标志（Flags）
     </p>
     <ul>
      <li>
       <p>
        控制匹配模式的全局行为
       </p>
      </li>
     </ul>
     <pre><code>text = "Hello\nWorld"
# 多行模式（^和$匹配每行开头结尾）
re.findall(r'^\w+', text, flags=re.MULTILINE)  # 输出: ['Hello', 'World']
# 忽略大小写
re.findall(r'hello', text, flags=re.IGNORECASE)  # 输出: ['Hello']</code></pre>
     <p>
      2. 预编译正则表达式
     </p>
     <ul>
      <li>
       <p>
        提升重复使用时的性能
       </p>
      </li>
     </ul>
     <pre><code>pattern = re.compile(r'\d{3}-\d{4}')  # 编译为RegexObject
result = pattern.findall("Tel: 123-4567")  # ['123-4567']</code></pre>
     <p>
      3. 替换时使用函数
     </p>
     <ul>
      <li>
       <p>
        动态生成替换内容
       </p>
      </li>
     </ul>
     <pre><code>def to_upper(match):
    return match.group().upper()

text = "hello world"
new_text = re.sub(r'\b\w', to_upper, text)
print(new_text)  # 输出: Hello World</code></pre>
     <hr/>
     <p>
      五、经典实战案例
     </p>
     <p>
      1. 验证邮箱格式
     </p>
     <pre><code class="language-python">def validate_email(email):
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    return re.match(pattern, email) is not None

print(validate_email("user@example.com"))  # True
print(validate_email("invalid.email@"))     # False</code></pre>
     <p>
      2. 提取HTML链接
     </p>
     <pre><code class="language-python">html = '&lt;a href="https://example.com"&gt;Link&lt;/a&gt;'
pattern = r'href="(https?://[^"]+)"'
match = re.search(pattern, html)
print(match.group(1))  # https://example.com</code></pre>
     <p>
      3. 转换日期格式
     </p>
     <pre><code class="language-python">date = "2023-08-15"
new_date = re.sub(r'(\d{4})-(\d{2})-(\d{2})', r'\2/\3/\1', date)
print(new_date)  # 08/15/2023</code></pre>
     <hr/>
     <p>
      六、避坑指南
     </p>
     <ol>
      <li>
       <p>
        ​
        <strong>
         贪婪匹配陷阱
        </strong>
        <br/>
        使用
        <code>
         .*?
        </code>
        非贪婪模式避免过度匹配：
       </p>
       <pre><code class="language-python">text = "&lt;div&gt;Hello&lt;/div&gt;&lt;div&gt;World&lt;/div&gt;"
re.findall(r'&lt;div&gt;(.*?)&lt;/div&gt;', text)  # ['Hello', 'World']</code></pre>
      </li>
      <li>
       <p>
        ​
        <strong>
         特殊字符转义
        </strong>
        <br/>
        匹配
        <code>
         .
        </code>
        、
        <code>
         *
        </code>
        等符号需转义：
       </p>
       <pre><code class="language-python">re.findall(r'3\.14', "pi=3.14")  # ['3.14']</code></pre>
      </li>
      <li>
       <p>
        ​
        <strong>
         性能优化
        </strong>
        <br/>
        避免在循环中重复编译正则，优先使用预编译。
       </p>
      </li>
     </ol>
     <hr/>
     <p>
      七、调试工具
     </p>
     <ol>
      <li>
       <p>
        ​
        <strong>
         在线测试
        </strong>
        <br/>
        RegExr：实时高亮匹配结果，显示分组信息
       </p>
      </li>
      <li>
       ​
       <strong>
        代码调试
       </strong>
       <br/>
       使用
       <code>
        re.DEBUG
       </code>
       标志查看正则解析过程：
       <pre><code class="language-python">re.compile(r'\d+', re.DEBUG)</code></pre>
      </li>
     </ol>
     <p>
     </p>
     <p>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323733373438362f:61727469636c652f64657461696c732f313436313639313033" class_="artid" style="display:none">
 </p>
</div>


