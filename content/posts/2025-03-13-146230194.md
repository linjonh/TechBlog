---
layout: post
title: "草堂笔记ARM5到ARM6-分散文件加载错误问题"
date: 2025-03-13 14:42:00 +08:00
description: "在最近的一次项目中，使用的是ciu32L系列的单片机，因为初始化时，需要对flash进行一些数据写入，发现其使用的是ARM5编译用官方的历程编译一切正常，但我项目使用的是ARM6编译器，所以我也试了下，直接将编译器改为ARM6，此时编译报了各警告。"
keywords: "【草堂笔记】ARM5到ARM6 分散文件加载错误问题"
categories: ['好记性不如烂笔头系列随笔']
tags: ['经验分享', '笔记', '单片机', 'C']
artid: "146230194"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146230194
    alt: "草堂笔记ARM5到ARM6-分散文件加载错误问题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146230194
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146230194
cover: https://bing.ee123.net/img/rand?artid=146230194
image: https://bing.ee123.net/img/rand?artid=146230194
img: https://bing.ee123.net/img/rand?artid=146230194
---

# 【草堂笔记】ARM5到ARM6 分散文件加载错误问题
## 一 、 背景
在最近的一次项目中，使用的是ciu32L系列的单片机，因为初始化时，需要对flash进行一些数据写入，发现其使用的是ARM5编译
用官方的历程编译一切正常，但我项目使用的是ARM6编译器，所以我也试了下，直接将编译器改为ARM6，此时编译报了各警告
如下：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/460c86444b234975a63c8c107c5056d6.png#pic\_center)
## 二、解决方案
### 2.1、 官方例程如下：
#if defined ( \_\_CC\_ARM )
#pragma arm section code = "FAST\_PROGRAM"
#elif defined ( \_\_ICCARM\_\_ )
\_\_ramfunc
#elif defined ( \_\_GNUC\_\_ )
\_\_attribute\_\_ ((section (".RamFunc")))
#endif
/\*\*
\* @brief Flash快速编程，往目标地址快速编程半页数据
\* @param address 编程地址
\* @param data\_buf 编程数据
\* @retval std\_status\_t 本函数执行结果
\*/
std\_status\_t bsp\_flash\_fast\_write(uint32\_t address, uint32\_t \*data\_buf)
{
std\_status\_t status = STD\_OK;
uint32\_t prog\_count = 0;
/\* 启动快速编程模式 \*/
FLASH->CR |= FLASH\_CR\_FSTPG\_MODE;
/\* 向目标地址写入数据 \*/
for (prog\_count=0; prog\_count < FSTPG\_WORD\_COUNT; prog\_count++)
{
((uint32\_t \*)address)[prog\_count] = data\_buf[prog\_count];
/\* 查询等待BSY标志被清除 \*/
while ((FLASH->SR & FLASH\_FLAG\_BSY) == FLASH\_FLAG\_BSY);
/\* 若出现错误，则退出编程循环 \*/
if (FLASH->SR & FLASH\_FLAG\_ALL\_ERR)
{
status = STD\_ERR;
break;
}
}
/\* 查询等待FSTPG\_MODE状态被自动清零 \*/
while ((FLASH->CR & FLASH\_CR\_FSTPG\_MODE) == FLASH\_CR\_FSTPG\_MODE);
/\* 清除Flash标志 \*/
FLASH->SR = (FLASH\_FLAG\_ALL\_ERR | FLASH\_SR\_EOP);
return (status);
}
#if defined ( \_\_CC\_ARM )
#pragma arm section
#endif
分散加载文件如下：
LR\_IROM1 0x08000000 0x00040000 { ; load region size\_region
ER\_IROM1 0x08000000 0x00040000 { ; load address = execution address
\*.o (RESET, +First)
\*(InRoot$$Sections)
.ANY (+RO)
}
RW\_IRAM1 0x20000000 0x00001000 { ; RW data
\*.o(FAST\_PROGRAM)
.ANY (+RW +ZI)
}
}
注意：
> 在ARM6（即AC6编译器，基于LLVM/Clang）环境下，\_\_CC\_ARM 这个宏已被废弃，\*\*GNUC\*\*
> 也被Keil的ARM编译器6支持。但你遇到的问题的根本原因是，没有正确地在链接脚本和代码中统一声明和使用 .FAST\_PROGRAM
> 段，导致编译时找不到匹配的 .o(FAST\_PROGRAM) 段。
### 2.2、解决方案：
1. 确保正确的编译器宏判断
ARM6 编译器在 Keil 中的宏是 \_\_ARMCC\_VERSION
#if defined(\_\_CC\_ARM) // ARM Compiler 5
#pragma arm section code="FAST\_PROGRAM"
#elif defined(\_\_ARMCC\_VERSION) && (\_\_ARMCC\_VERSION >= 6000000) // ARM Compiler 6
\_\_attribute\_\_((section(".FAST\_PROGRAM"), used))
#elif defined(\_\_ICCARM\_\_) // IAR
\_\_ramfunc
#elif defined(\_\_GNUC\_\_) // GCC
\_\_attribute\_\_((section(".FAST\_PROGRAM"), used))
#endif
分散加载文件如下：
LR\_IROM1 0x08000000 0x00040000 { ; load region size\_region
ER\_IROM1 0x08000000 0x00040000 { ; load address = execution address
\*.o (RESET, +First)
\*(InRoot$$Sections)
.ANY (+RO)
}
RW\_IRAM1 0x20000000 0x00002000 { ; RW data
\*(FAST\_PROGRAM) ; 让 .FAST\_PROGRAM 段放入 RAM
.ANY (+RW +ZI)
}
}
此时编译通过，程序运行正常。
写笔记的目的其实就是当再次遇到同一个问题，时间久了可能会忘记处理方法，同时也可以解决大家在项目中碰到此类问题，给以快速解决方案。赠人玫瑰，手有余香。养成做笔记的习惯。