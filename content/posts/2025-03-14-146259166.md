---
layout: post
title: "LinkedList底层结构和源码分析JDK1.8"
date: 2025-03-14 15:45:31 +0800
description: "参考视频：韩顺平Java集合创建几个节点，并为其建立链表链接：简单的应用：从头到尾遍历、从尾到头遍历：简单的应用：在 node1 和 node2 之间插入 node 1.5遍历一下验证插入结果（但是注意，这里所展示的遍历的例子是依靠 first 和 last 指针的移动来实现的，所以如果我们要遍历一遍插入新元素后的链表，则需要将 first 和 last 进行一个重新指向。）LinkedList 增删改查——源码示例源码：构造器创建 linkedList 的细节和流程"
keywords: "LinkedList底层结构和源码分析（JDK1.8）"
categories: ['未分类']
tags: ['笔记', '学习', 'Java']
artid: "146259166"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146259166
    alt: "LinkedList底层结构和源码分析JDK1.8"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146259166
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146259166
cover: https://bing.ee123.net/img/rand?artid=146259166
image: https://bing.ee123.net/img/rand?artid=146259166
img: https://bing.ee123.net/img/rand?artid=146259166
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LinkedList底层结构和源码分析（JDK1.8）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     参考视频：
     <a href="https://www.bilibili.com/video/BV1YA411T76k?spm_id_from=333.788.player.switch&amp;vd_source=4dfc8cb4522320b273b785a2db6e20b3&amp;p=18" rel="nofollow">
      韩顺平Java集合
     </a>
    </p>
    <h3>
     <a id="_3">
     </a>
     特点
    </h3>
    <ul>
     <li>
      LinkedList 底层实现了
      <code>
       双向链表
      </code>
      和
      <code>
       双端队列
      </code>
      的特点。
     </li>
     <li>
      可以添加任意元素（元素可以重复），包括 null。
     </li>
     <li>
      线程不安全，没有实现同步。
     </li>
    </ul>
    <h3>
     <a id="LinkedList__8">
     </a>
     LinkedList 底层结构
    </h3>
    <p>
     <img alt="image.png|425" src="https://i-blog.csdnimg.cn/img_convert/2e1f5664943eff131fc5e13be3578b5f.png"/>
    </p>
    <ul>
     <li>
      LinkedList 底层维护了一个双向链表
     </li>
     <li>
      LinkedList 中维护了两个属性
      <code>
       first
      </code>
      和
      <code>
       last
      </code>
      分别指向首节点和尾节点。
     </li>
     <li>
      每个节点（Node 对象）里面有维护了
      <code>
       prev
      </code>
      、
      <code>
       next
      </code>
      、
      <code>
       item
      </code>
      三个属性，其中通过
      <code>
       prev
      </code>
      指向前一个，通过
      <code>
       next
      </code>
      指向后一个节点。最终实现双向链表。
     </li>
     <li>
      所以 LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高。
     </li>
    </ul>
    <h3>
     <a id="_16">
     </a>
     模拟一个简单的双向链表
    </h3>
    <ul>
     <li>
      定义一个Node类，表示一个双向链表的节点：
      <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">public</span> <span class="token class-name">Object</span> item<span class="token punctuation">;</span>  
    <span class="token keyword">public</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span><span class="token comment">//指向后一个节点  </span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span><span class="token comment">//指向后一个节点  </span>
  
    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Object</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> name<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">return</span> <span class="token string">"Node name="</span><span class="token operator">+</span>item<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      创建几个节点，并为其建立链表链接：
      <pre><code class="prism language-java"><span class="token comment">//模拟一个简单的双向链表  </span>
<span class="token annotation punctuation">@Test</span>  
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token class-name">LinkedList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token class-name">Node</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"Node1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token class-name">Node</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"Node2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token class-name">Node</span> node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"Node3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token comment">//链接三个节点，形成双向链表  </span>
    <span class="token comment">//1-&gt;2-&gt;3  </span>
    node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>  
    node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node3<span class="token punctuation">;</span>  
    <span class="token comment">//3-&gt;2-&gt;1  </span>
    node3<span class="token punctuation">.</span>prev <span class="token operator">=</span> node2<span class="token punctuation">;</span>  
    node2<span class="token punctuation">.</span>prev <span class="token operator">=</span> node1<span class="token punctuation">;</span>  
  
    <span class="token comment">//头节点  </span>
    <span class="token class-name">Node</span> first <span class="token operator">=</span> node1<span class="token punctuation">;</span>  
    <span class="token comment">//尾节点  </span>
    <span class="token class-name">Node</span> last <span class="token operator">=</span> node3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      简单的应用：从头到尾遍历、从尾到头遍历：
      <pre><code class="prism language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=======从头到尾进行遍历======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//演示：从头到尾进行遍历  </span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//头节点移动至下一个  </span>
<span class="token punctuation">}</span>  
  
<span class="token comment">//演示：从尾到头进行遍历  </span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=======从尾到头进行遍历======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    last <span class="token operator">=</span> last<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      简单的应用：在 node1 和 node2 之间插入 node 1.5
      <pre><code class="prism language-java"><span class="token class-name">Node</span> node15 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"node1.5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
node15<span class="token punctuation">.</span>prev <span class="token operator">=</span> node1<span class="token punctuation">;</span>  
node15<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>  
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node15<span class="token punctuation">;</span>  
node2<span class="token punctuation">.</span>prev <span class="token operator">=</span> node15<span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      遍历一下验证插入结果
      <ul>
       <li>
        （但是注意，这里所展示的遍历的例子是依靠 first 和 last 指针的移动来实现的，所以如果我们要遍历一遍插入新元素后的链表，则需要将 first 和 last 进行一个重新指向。）
       </li>
      </ul>
      <pre><code class="prism language-java"><span class="token comment">//头和尾要重新进行指向  </span>
first <span class="token operator">=</span> node1<span class="token punctuation">;</span>  
last <span class="token operator">=</span> node3<span class="token punctuation">;</span>  
  
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=======从头到尾进行遍历======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//演示：从头到尾进行遍历  </span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//头节点移动至下一个  </span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ul>
    <h3>
     <a id="LinkedList__100">
     </a>
     LinkedList 增删改查——源码示例
    </h3>
    <ul>
     <li>
      源码：
      <ul>
       <li>
        构造器创建 linkedList 的细节和流程
       </li>
       <li>
        第一次添加元素（节点 1）
       </li>
       <li>
        第二次添加元素（节点 2）
       </li>
       <li>
        删除第一个节点
       </li>
       <li>
        删除下标为 2 的节点
       </li>
      </ul>
      <pre><code class="prism language-java"><span class="token annotation punctuation">@Test</span>  
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token class-name">LinkedList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"linkedList = "</span><span class="token operator">+</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ul>
    <p>
     在 JDK 1.8 中，Node 的类是这样设计的：
     <br/>
     <img alt="image.png|425" src="https://i-blog.csdnimg.cn/img_convert/3680df4aa69edf26adb59b92a37e739c.png">
      <br/>
      与前面我们的简单实现相比，这里的 Node 中存放数据的
      <code>
       item
      </code>
      是使用泛型来约束的，这样在使用时可以定义其存储数据的类型。更加严谨一些。
     </img>
    </p>
    <blockquote>
     <p>
      构造器创建 LinkedList
     </p>
    </blockquote>
    <ul>
     <li>
      调用空参构造器创建了一个 size=0 的 linkedList。
     </li>
     <li>
      此时头和尾都为空，
      <code>
       modCount
      </code>
      为修改次数
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/3a14f02b86ef8bbab21070144bf25911.png"/>
     </li>
    </ul>
    <blockquote>
     <p>
      第一次添加元素（节点 1）
     </p>
    </blockquote>
    <ul>
     <li>
      进入
      <code>
       add()
      </code>
      方法，将所添加的数据传递给
      <code>
       linkedLast()
      </code>
      中
      <br/>
      <img alt="image.png|75" src="https://i-blog.csdnimg.cn/img_convert/c1603d49386b73f06e3d293283bbf28c.png"/>
     </li>
     <li>
      注意此时链表为空，所以头节点和尾节点都为 null
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/cf921c7da436bbb9ed22977956e7db66.png"/>
     </li>
     <li>
      <code>
       LinkedLast()
      </code>
      作用是将所添加的元素插在最后：
      <br/>
      <img alt="image.png|450" src="https://i-blog.csdnimg.cn/img_convert/053c614823836ef071944a62290fd66f.png"/>
     </li>
     <li>
      var2=链表当前最后的元素。
      <mark>
       （因为此时链表为空，所以 var2=null）
      </mark>
     </li>
     <li>
      新建一个 Node，将其中的 item 值设置为 var1，并设置前节点（var2）和后节点（null）。这就是 var3。
      <mark>
       （此时 var2【null】➡var3【item=var1】➡null）
      </mark>
     </li>
     <li>
      让当前的尾节点指向 var3。
      <mark>
       (此时last➡var3)
      </mark>
     </li>
     <li>
      判断前一个节点（ var2） 是否为空？
      <ul>
       <li>
        如果 var2=null，也就代表原本是一个空链表，那么我们就需要将头结点指向新添加的节点 var3。
        <mark>
         （此时first➡var3⬅️last）
        </mark>
       </li>
       <li>
        如果 var2 不为空，就将 var2 的下一个节点指向 var3。
       </li>
      </ul>
     </li>
     <li>
      链表长度+1
      <mark>
       （此时size=1）
      </mark>
     </li>
     <li>
      修改次数+1
      <mark>
       （此时monCount=1）
      </mark>
     </li>
     <li>
      至此，添加操作完成，回到添加的主逻辑：返回 true，添加完成。
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/9fae989cbdc2e4aad8218071c4b58574.png"/>
     </li>
     <li>
      可以看到数据已经放在了链表中，并且头节点和尾节点都指向该节点
      <mark>
       （@861）
      </mark>
      。
      <br/>
      <img alt="image.png|425" src="https://i-blog.csdnimg.cn/img_convert/521465e6a77dd2782c8267e737f6e7a2.png"/>
     </li>
    </ul>
    <blockquote>
     <p>
      第二次添加元素（节点 2）
     </p>
    </blockquote>
    <ul>
     <li>
      进入
      <code>
       add()
      </code>
      方法，将所添加的数据传递给
      <code>
       linkedLast()
      </code>
      中：
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/a29e5dc6d78db70dd7027de4bc1f9660.png"/>
     </li>
     <li>
      <code>
       LinkedLast()
      </code>
      作用是将所添加的元素插在最后：
      <br/>
      <img alt="image.png|475" src="https://i-blog.csdnimg.cn/img_convert/abec1730da4eae57535ac9ae72797e3b.png"/>
     </li>
     <li>
      var2=链表当前最后的元素。
      <mark>
       （此时 var2=节点 1）
      </mark>
     </li>
     <li>
      新建一个 Node，将其中的 item 值设置为 var1，并设置前节点（var2）和后节点（null）。这就是 var3。
      <mark>
       （此时 var2【节点 1】➡var3【item=var1】➡null）
      </mark>
     </li>
     <li>
      让当前的尾节点指向 var3。
      <mark>
       (此时last➡var3)
      </mark>
     </li>
     <li>
      判断前一个节点（ var2） 是否为空？
      <ul>
       <li>
        如果 var2=null，也就代表原本是一个空链表，那么我们就需要将头结点指向新添加的节点 var3。
       </li>
       <li>
        如果 var2 不为空，就将 var2 的下一个节点指向 var3。
        <mark>
         （此时 var2【节点 1】➡var3）
        </mark>
       </li>
      </ul>
     </li>
     <li>
      链表长度+1
      <mark>
       （此时size=2）
      </mark>
     </li>
     <li>
      修改次数+1
      <mark>
       （此时monCount=2）
      </mark>
     </li>
     <li>
      至此，添加操作完成，回到添加的主逻辑：返回 true，添加完成。
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/d3317867da5a32e7af544af98728ebaa.png"/>
     </li>
     <li>
      可以看到数据已经放在了链表中，并且头节点指向节点 1（@861），尾节点指向节点 2
      <mark>
       （@867）
      </mark>
      。
      <br/>
      <img alt="image.png|400" src="https://i-blog.csdnimg.cn/img_convert/d2a3b53409a18980b23f8e2ae6531e2a.png"/>
     </li>
    </ul>
    <blockquote>
     <p>
      删除第一个节点（无参，默认删除第一个）
     </p>
    </blockquote>
    <ul>
     <li>
      进入
      <code>
       remove()
      </code>
      方法中，可以发现其中调用了
      <code>
       removeFirst()
      </code>
      方法：
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/3017103b4bbfb7ba15d3cb231772ea7e.png"/>
     </li>
     <li>
      <code>
       removeFirst()
      </code>
      的作用就是删除链表的第一个元素。
     </li>
     <li>
      var1=当前链表的头结点==（节点 1）==
     </li>
     <li>
      判断头结点是否为空，也就是判断链表是否为空
     </li>
     <li>
      为空则抛出异常；不为空则调用
      <code>
       unlinkFirst()
      </code>
      方法，将头节点传入：
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/726430498ace1e9672af96bc35d7e7eb.png"/>
     </li>
     <li>
      unlinkFirst() 的作用是删除链表的第一个节点：
     </li>
     <li>
      var2=头节点中的数据
      <mark>
       （本例中是 “1”）
      </mark>
     </li>
     <li>
      var3=头节点的下一个节点
      <mark>
       （本例中是节点 2）
      </mark>
     </li>
     <li>
      将头节点的数据清空
     </li>
     <li>
      将头节点的 next 置为 null；
     </li>
     <li>
      将头节点设置为下一个节点（var3）
     </li>
     <li>
      判断下一个节点是否为空（也就是判断该链表是否只有 var1 这一个节点）
      <ul>
       <li>
        为空，则代表尾指针 last 也在 var1 这个要删除的节点上，所以需要将 last 也置为 null；
       </li>
       <li>
        不为空，则表示后续还有节点，把后节点的 prev 设置为 null。
        <mark>
         （本例）
        </mark>
       </li>
      </ul>
     </li>
     <li>
      链表的长度-1
      <mark>
       （size=9-1=8）
      </mark>
     </li>
     <li>
      修改次数+1
      <mark>
       （modCount=9+1=10）
      </mark>
      <br/>
      <img alt="image.png|500" src="https://i-blog.csdnimg.cn/img_convert/9348afa8491eaf4d9943b8c40239a661.png"/>
     </li>
     <li>
      可以看到第一个节点已被删除。
      <br/>
      <img alt="image.png|425" src="https://i-blog.csdnimg.cn/img_convert/ae01019823d3a98400dd595e31d0cf65.png"/>
     </li>
    </ul>
    <blockquote>
     <p>
      删除索引为 2 的节点
     </p>
    </blockquote>
    <p>
     此时链表中的元素有【2，3，4，5，6，7，8，9】，我们要删除的是 “4”。
    </p>
    <ul>
     <li>
      进入
      <code>
       remove()
      </code>
      方法，先进入
      <code>
       checkElementIndex()
      </code>
      方法检查一下索引是否合法
      <br/>
      <img alt="image.png|425" src="https://i-blog.csdnimg.cn/img_convert/3fc7c509af93b56f37b51006dea9913c.png"/>
     </li>
     <li>
      <code>
       checkElementIndex()
      </code>
      ：检查索引是否合法
      <mark>
       （目前链表 size=8，索引2 合法）
      </mark>
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/1411ba508e4125543a8ba956ac1a1731.png"/>
      <img alt="image.png|500" src="https://i-blog.csdnimg.cn/img_convert/d96b5f90b1e79f9617de652f26e13960.png"/>
     </li>
     <li>
      回到 remove() 中，调用 unlink(node) 方法，其作用是删除一个节点 node。
      <br/>
      <img alt="image.png|500" src="https://i-blog.csdnimg.cn/img_convert/6cf078634721415dfc85f4b0e451825d.png"/>
     </li>
     <li>
      但由于我们传入的是索引，而不是节点本身，所以需要调用
      <code>
       node (index)
      </code>
      方法来查找并返回节点。
     </li>
     <li>
      观察 node 方法：它的查找方式是检查要查找的节点索引在前半部分还是后半部分。
      <mark>
       （本例中我们查找索引 2，在前半部分，所以从头开始查找）
      </mark>
      <ul>
       <li>
        如果是前半部分则从头开始查找；
       </li>
       <li>
        如果是后半部分，则从尾开始查找。
       </li>
       <li>
        var2 是遍历用的节点
       </li>
       <li>
        var3 遍历用的索引
        <br/>
        <img alt="image.png|475" src="https://i-blog.csdnimg.cn/img_convert/4d6e444884fa219eab17a26c1bdc0da8.png"/>
       </li>
      </ul>
     </li>
     <li>
      最后将找到的节点返回给
      <code>
       unlink(node)
      </code>
      方法中。
      <br/>
      <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/7646b192d33c6cc62f6f8d06dc679819.png"/>
     </li>
     <li>
      找到的节点作为参数 var1 传入该方法。
     </li>
     <li>
      var2=该节点的数据
      <mark>
       （本例中是 “4”）
      </mark>
     </li>
     <li>
      var3=该节点的后节点
     </li>
     <li>
      var4=该节点的前节点
     </li>
     <li>
      判断前节点（var4）是否为 null
      <ul>
       <li>
        如果 var4 为 null，则表示该节点为头节点，需要将 first 指针指向其下一个节点（var3）；
       </li>
       <li>
        如果不为 null，说明其前面还有节点，就要将前节点（var4）的 next 指向其后节点（var3），并且将该节点的 prev 解除。
        <mark>
         （本例）
        </mark>
       </li>
      </ul>
     </li>
     <li>
      判断后节点（var3）是否为 null
      <ul>
       <li>
        如果 var3 为 null，则表示该节点为尾节点，需要将 last 指针指向其上一个节点（var3）；
       </li>
       <li>
        如果不为 null，说明其后面还有节点，就要将后节点（var3）的 prev 指向其前节点（var4），并且将该节点的 next 解除。
        <mark>
         （本例）
        </mark>
       </li>
      </ul>
     </li>
     <li>
      这样一来就将要删除的元素 var1 彻底与链表解除了关系，成为了一个孤立的节点。最后要做的就是将其中的数据（item）也进行清空
     </li>
     <li>
      链表长度-1
      <mark>
       （size=8-1=7）
      </mark>
     </li>
     <li>
      修改次数+1
      <mark>
       （modCount=10+1=11）
      </mark>
      <br/>
      <img alt="image.png|425" src="https://i-blog.csdnimg.cn/img_convert/ff7508229af0cf18db022bf002d63123.png"/>
     </li>
     <li>
      至此，删除下标为 2 的节点完成。
     </li>
    </ul>
    <blockquote>
     <p>
      改：set (int, Object) 和查：get(i) 的源码都比较简单，可以自己分析一下。
     </p>
    </blockquote>
    <h3>
     <a id="LinkedList__229">
     </a>
     LinkedList 遍历
    </h3>
    <p>
     由于 LinkedList 实现了 List 接口，而 List 接口可以使用三种方式遍历：迭代器、增强 for 循环、普通 for 循环。所以 LinkedList 也是支持的。
    </p>
    <pre><code class="prism language-java"><span class="token comment">//增强for遍历  </span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======增强遍历"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span>list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token comment">//迭代器遍历  </span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======迭代器遍历"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token class-name">Object</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token comment">//普通for遍历  </span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======普通for遍历"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f616263313135323032383933362f:61727469636c652f64657461696c732f313436323539313636" class_="artid" style="display:none">
 </p>
</div>


