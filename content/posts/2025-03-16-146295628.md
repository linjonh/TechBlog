---
layout: post
title: "接上一篇,C中,如何设计等价于Qt的信号与槽机制"
date: 2025-03-16 15:31:56 +0800
description: "看下面例子：所有连接类FileManage中的信号，在changeFileName函数中被调用。输出：输出：是不是一样，是不是很酷。：）"
keywords: "接上一篇，C++中，如何设计等价于Qt的信号与槽机制。"
categories: ['未分类']
tags: ['开发语言', 'Qt', 'C']
artid: "146295628"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146295628
    alt: "接上一篇,C中,如何设计等价于Qt的信号与槽机制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146295628
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146295628
cover: https://bing.ee123.net/img/rand?artid=146295628
image: https://bing.ee123.net/img/rand?artid=146295628
img: https://bing.ee123.net/img/rand?artid=146295628
---

# 接上一篇，C++中，如何设计等价于Qt的信号与槽机制。
## 看下面例子：
class FileManager : public QObject {
Q\_OBJECT
public:
FileManager(QObject\* parent = nullptr) : QObject(parent) {}
void changeFileName(const QString& newName) {
fileName = newName;
emit fileNameChanged(fileName);
}
signals:
void fileNameChanged(const QString& newName);
private:
QString fileName;
};
## 所有连接类FileManage中的信号，在changeFileName函数中被调用。例如：
int main(int argc, char\* argv[])
{
QApplication a(argc, argv); //注意，这里是QApplication
FileManager fm;
QObject::connect(&fm, &FileManager::fileNameChanged, [](const QString& newName) {
std::cout << "函数1收到：文件名改变了。\n";
});
QObject::connect(&fm, &FileManager::fileNameChanged, [](const QString& newName) {
std::cout << "函数2收到：文件名改变2。\n";
});
fm.changeFileName("abc");
return a.exec();
}
输出：
![](https://i-blog.csdnimg.cn/direct/5e84da91990f429fb8eb1fd583be8b88.png)
## 下面我们也来设计相同功能的FileManager2:
class FileManager2 {
public:
using fileNameChanged = std::function;
public:
std::list< fileNameChanged> fileNameChanged\_list;
public:
FileManager2(QObject\* parent = nullptr) {}
void changeFileName(const QString& newName) {
fileName = newName;
for (fileNameChanged& f: fileNameChanged\_list) {
if (f != 0)
f(newName);
}
}
void connect(fileNameChanged f) {
fileNameChanged\_list.push\_back(f);
}
private:
QString fileName;
};
int main(int argc, char\* argv[])
{
QApplication a(argc, argv); //注意，这里是QApplication
FileManager2 fm;
fm.connect([](const QString& newName) {
std::cout << "函数1收到：文件名改变了。\n";
});
fm.connect([](const QString& newName) {
std::cout << "函数2收到：文件名改变。\n";
});
fm.changeFileName("abc");
return a.exec();
}
输出：
![](https://i-blog.csdnimg.cn/direct/68d0f793f8e643d1aaefc84775f4a4f3.png)
## 是不是一样，是不是很酷。：）
关键地方：
![](https://i-blog.csdnimg.cn/direct/e034a41a7ba3472b8a349f4ab35c5c3b.png)
##
![](https://i-blog.csdnimg.cn/direct/2b81ea7b5be5467a9dbd64e6c098a4e5.png)这里相当于Qt中的emit
![](https://i-blog.csdnimg.cn/direct/937334d57b7149ca9bf1318bed19f685.png)
这里添加一个函数指针，上篇说过：
![](https://i-blog.csdnimg.cn/direct/93b192ddcdd149fc8b6ffebaa3548067.png)
这里可连接N个Lambda
[表达式](https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F/7655228?fromModule=lemma\_inlink
"表达式")，与Qt一样：
![](https://i-blog.csdnimg.cn/direct/87a6c4b0935d4a22a5e438f819b7c9aa.png)
## 连接函数：
![](https://i-blog.csdnimg.cn/direct/ac2102a55b1345578adc8cc093acd4ca.png)
## 最终也一样：
![](https://i-blog.csdnimg.cn/direct/ed55440db9fc45f8a850bbe7e4666f91.png)
## 由于临时灵感来了，用了几分钟写的，难免有问题, 如果使用
std::list::remove 会编译不了，现在用新版方案替代，以后再完善：
template
class \_callback {
public:
friend bool operator==(const \_callback& l, const \_callback& r) {
return l.m\_id == r.m\_id;
}
\_callback(const T& pf) {
m\_pf = pf;
m\_id = \_DateTime::g\_timeStamp();
}
public:
\_\_int64 m\_id;
T m\_pf;
};
class \_FileManager {
public:
using pf\_fileNameChanged = std::function;
/// 
/// 更改文件名或路径并通知所有订阅者
/// 
/// 
/// 
/// 创建时间：2025-03-16 最后一次修改时间：2025-03-16
void changeFileName(const \_string& oldPathName, const \_string& newPathName);
/// 
/// 更改文件夹名或路径
/// 
/// 
/// 
/// 创建时间：2025-03-16 最后一次修改时间：2025-03-16
void changeFolderName(const \_string& oldPathName, const \_string& newPathName);
/// 
/// 删除文件
/// 
/// 
void deleteFile(const \_string& fileName);
/// 
/// 删除文件夹
/// 
/// 
void deleteFolder(const \_string& folderName);
// 订阅文件名更改事件
void subscribe(const pf\_fileNameChanged& callback) {
std::lock\_guard lock(m\_mutex); // 线程安全
m\_fileNameChanged.push\_back(callback);
}
// 取消订阅文件名更改事件
void unsubscribe(const pf\_fileNameChanged& callback) {
std::lock\_guard lock(m\_mutex); // 线程安全
m\_fileNameChanged.remove(callback);
}
private:
\_string m\_dirPathName; // 当前文件名
std::list<\_callback> m\_fileNameChanged; // 订阅者列表
mutable std::mutex m\_mutex; // 用于线程安全
};
![](https://i-blog.csdnimg.cn/direct/957002e1773b4afda53844f6ea2b71bf.png)
![](https://i-blog.csdnimg.cn/direct/8e0d067fb4a345cf96a474647fd782c5.png)