---
layout: post
title: "MySQL事务及索引复习笔记"
date: 2025-03-12 17:08:34 +0800
description: "本文参考小林coding，地址。"
keywords: "MySQL事务及索引复习笔记"
categories: ['小林启动']
tags: ['数据库', 'Mysql']
artid: "146141070"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146141070
    alt: "MySQL事务及索引复习笔记"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146141070
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146141070
cover: https://bing.ee123.net/img/rand?artid=146141070
image: https://bing.ee123.net/img/rand?artid=146141070
img: https://bing.ee123.net/img/rand?artid=146141070
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL事务及索引复习笔记
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     本文参考小林coding，地址
     <a href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" rel="nofollow" title="事务隔离级别是怎么实现的？ | 小林coding">
      事务隔离级别是怎么实现的？ | 小林coding
     </a>
    </p>
    <h3>
     事务
    </h3>
    <h4>
     <br/>
     <strong>
      一、事务是什么？
     </strong>
    </h4>
    <p>
     比如一个程序是转账，你要扣减a的余额，增加b的余额，但是如果程序执行扣减成功然后挂了，就会出现a的余额扣减了但是b的余额没增加的情况。因此我们要引入事务，也就是
     <strong>
      要么全部成功，要么全部失败
     </strong>
    </p>
    <h4>
     <strong>
      二、事务四大特性
     </strong>
    </h4>
    <p>
     <strong>
      原子性、一致性、隔离性、持久性
     </strong>
     <br/>
     原子性 就是 一个事务中的业务要么都成功要么都失败，不能扣除了a余额却不增加b的余额
     <br/>
     一致性 就是 事务开始前和结束后，数据库要保持一致状态，比如转账前后a和b的总余额不能少
     <br/>
     隔离性 就是 多个事务并发执行时它们互不影响
     <br/>
     持久性 就是 事务一旦提交就会持久化到数据库
    </p>
    <h4>
     <strong>
      三、事务隔离性
     </strong>
    </h4>
    <p>
     同时处理多个事务时会出现的问题
     <strong>
      ：脏读、不可重复读、幻读
      <br/>
      （1）脏读是什么？
     </strong>
     <br/>
     当a事务对数据做出修改但未提交，此时b事务进来查询 查到数据，然后a事务回滚撤销修改，那b事务读到的数据就是脏数据，也就是脏读
     <br/>
     <strong>
      （2）不可重复读是什么？
     </strong>
     <br/>
     a事务进来读取一次数据，然后此时b事务进来修改数据并提交，然后a事务再次读取数据就会发现数据前后不一致，也就是不可重复读
     <br/>
     <strong>
      （3）幻读是什么？
     </strong>
     <br/>
     a事务进来查询一次数据，查到有3条，此时b事务进来新增一条并提交，然后a事务再次查询数据就会发现有4条，记录数不一致，也就是幻读
    </p>
    <p>
     简单说一下不可重复读和幻读的区别：走的流程差不多，主要区别在不可重复读是a前后两次读到的
     <strong>
      数据不一致
     </strong>
     ，而幻读是
     <strong>
      读到的记录条数不一致
     </strong>
    </p>
    <h4>
     <strong>
      四、解决方法：事务隔离级别
     </strong>
    </h4>
    <p>
     sql提出四种事务隔离级别去解决这几种问题
     <br/>
     分别是：
     <strong>
      读未提交、读已提交、可重复读、串行执行
     </strong>
    </p>
    <p>
     <strong>
      读未提交
     </strong>
     ：最捞的版本，放飞自我，三种问题都可能会出现
    </p>
    <p>
     <strong>
      读已提交
     </strong>
     ：只允许读已提交的数据，可以避免脏读
    </p>
    <p>
     <strong>
      可重复读
     </strong>
     （默认的隔离级别）：一个事务中多次读取到的数据必须相同，可以避免不可重复读
    </p>
    <p>
     <strong>
      串行化
     </strong>
     ：多个事务串行执行，一个事务提交之后才能执行另一个事务，最安全，性能最差
    </p>
    <p>
     简单说一下可重复读：可重复读就是假如事务a会多次读取某条记录，就以他一开始看到的数据为准，直到事务提交
    </p>
    <h4>
     <strong>
      五、ReadView快照
     </strong>
    </h4>
    <p>
     读未提交就是不设限，数据一直保持最新，但是最容易出错；而串行化就是加锁
    </p>
    <p>
     而【读已提交】和【可重复读】都会用到 ReadView 快照，区别在于读已提交是每次语句执行前都要更新一次快照，而可重复读是在事务开始时生成一次快照
     <br/>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/74bd53af8d5a4f038feebc25155fa59d.png" width="682"/>
    </p>
    <p>
     然后对于InnoDB引擎存储的数据库表，他的一条数据会包含两个隐藏列：
     <br/>
     第一个 trx_id，也就是最近修改这条数据的事务id
     <br/>
     第二个 roll_pointer，指向旧版本记录
     <br/>
     然后我们拿当前记录的trx_id去和快照中的id进行比对：
     <img alt="" height="346" src="https://i-blog.csdnimg.cn/direct/f15913406dd24fe08d8ff96b2e495463.png" width="676"/>
    </p>
    <p>
     当
     <strong>
      记录的 id &lt; 快照的最小事务id
     </strong>
     时，说明这条记录在快照创建前已提交，
     <strong>
      可以读取
     </strong>
     <br/>
     当
     <strong>
      快照的最小事务id &lt; 记录的id &lt; 下一个事务的id
     </strong>
     时，需要进行判断：
     <br/>
     ①如果在活跃事务列表中，说明记录还在活跃状态，
     <strong>
      不可读取
     </strong>
     <br/>
     ②如果不在活跃事务列表中，说明已经被提交，可以读取
     <br/>
     当
     <strong>
      记录的id &gt;下一个事务的id
     </strong>
     时，说明这条记录是快照创建后才修改的，不可读取
    </p>
    <p>
    </p>
    <h3>
     索引
    </h3>
    <h4>
     一、索引是什么
    </h4>
    <p>
     索引是基于数据库字段建立的一种数据结构，可以提升查询速率
     <br/>
     在不建立索引前，我们查找一个数据需要全表扫描，遍历整个表，在建立索引后，我们根据索引即可快速找到需要的数据，而不需要遍历表，索引就类似一个目录一样
    </p>
    <h4>
     二、索引优缺点
    </h4>
    <p>
     优点：快速找到数据，提升查询速率，减少磁盘IO次数
     <br/>
     缺点：索引是一种数据结构，建立索引需要消耗一定的空间，同时由于索引的结构，会降低增删改的速率
    </p>
    <h4>
     三、索引有哪几种
    </h4>
    <p>
     按最简单的来划分：
     <strong>
      主键索引、唯一索引、普通索引、联合索引、前缀索引、全文索引
     </strong>
     <br/>
     主键索引：伟大无需多言，非空，通常在建表时就已创建
     <br/>
     唯一索引：字段值必须唯一，可以为空
     <br/>
     普通索引：平平无奇
     <br/>
     联合索引：
     <strong>
      重点
     </strong>
     <br/>
     前缀索引：用于 like"a%"的匹配
     <br/>
     全文索引：将文本拆分成词条进行匹配
    </p>
    <h4>
     四、索引结构是什么样的
    </h4>
    <p>
     是B+树，结构如下图所示：
     <br/>
     <img alt="" height="418" src="https://i-blog.csdnimg.cn/direct/4a8c5272502c439991f82391326c1f4c.png" width="675">
      <br/>
      首先B+树和二叉树不同，二叉树每个节点最多只有两个分支，B+树可以有n个；他和B树也不同，不像B树中间的非叶子节点也会放数据，而且底层的叶子节点是双向链表实现
     </img>
    </p>
    <p>
     B+树的非叶子节点存放索引键值和指针，指向对应的下一级，而叶子节点存放数据
    </p>
    <p>
     对于这个图中的树来说，它是怎么样走的呢？
     <br/>
     当我获得一个索引键值，首先我会看到有1、10和19，然后我会拿这个键和这三个数进行比较：
     <br/>
     1 ≤ key＜10时，走第一个
     <br/>
     10 ≤ key＜19时，走第二个
     <br/>
     19 ≤ key 时，走第三个
     <br/>
     然后继续往下走直到走到叶子节点就可以找到数据了
    </p>
    <p>
     如图，这种叶子节点放完整数据的属于主键索引，而叶子节点只放主键值的是二级索引
     <br/>
     一般我们建的普通索引就是二级索引
     <br/>
     它们的区别在于：
     <br/>
     我用主键索引去找可以直接找到完整数据
     <br/>
     我用二级索引去找只能找到主键，然后必须回表，根据主键再去主键索引找完整数据
    </p>
    <h4>
     五、联合索引
    </h4>
    <p>
     就是用两个或者以上属性的值作为B+树的key值
     <br/>
     但他的实际效果往往是第一个属性是全局有序的，后面的属性往往是全局无序的，只在第一个属性相同的情况下是有序的
     <br/>
     举例：
    </p>
    <p>
     <br/>
     比如我建立了一个a和b的联合索引
     <br/>
     <br/>
     <strong>
      "where a=1 and b=2"
     </strong>
     对a、b都有用
     <br/>
     <strong>
      "where a&gt;1 and b=2"
     </strong>
     对a有用，对b没用，因为B+树找到a&gt;1的数据后，它们对应的属性b往往是无序的
     <br/>
     <strong>
      "where a≥1 and b=2"
     </strong>
     对a有用，对b部分有用，按a&gt;1查出来的对b没用，按a=1查出来的对b有用
    </p>
    <p>
     能看懂吧？就是&gt;、&lt;索引会失效，但是=不会
    </p>
    <p>
     继续
    </p>
    <p>
     <strong>
      "where key between x and y"
     </strong>
     相当于 x ≤ key ≤ y ，只在＝部分有用
     <br/>
     <strong>
      "where name like 'a%' "
     </strong>
     对匹配到的a....无用，只在当 name=a的时候有用
    </p>
    <p>
    </p>
    <p>
     还有一个是经典问题：我建立了一个a，b，c的联合索引，我查a，b这个索引有没有用
     <br/>
     答：有用
     <br/>
     但是必须按顺序，我建立一个a，b，c的联合索引，我要用这个索引，查询条件必须依次包含a，b，c
     <br/>
     比如（a,b)有用 （a,c）没用  (b,c)也没用
    </p>
    <h4>
     六、索引优化
    </h4>
    <p>
     ①减少回表次数，建立优秀的覆盖索引
     <br/>
     比如有一个 users 表，包含 id、name、age 和 email 列。如果经常执行查询 SELECT name, age FROM users WHERE email = 'example@example.com'，可以创建一个 (email, name, age) 覆盖索引
    </p>
    <p>
     ②设置自增主键，在B+树后面追加，而不是再走一次B+树
     <br/>
     ③用区分度大的属性作为索引，比如id，而不是性别这种
     <br/>
     ④索引最好是not null
    </p>
    <h4>
     七、常见索引命令
    </h4>
    <p>
     普通索引
    </p>
    <pre><code class="hljs">CREATE INDEX idx_age ON users (age)</code></pre>
    <p>
     唯一索引
    </p>
    <pre><code class="hljs">CREATE UNIQUE INDEX idx_email ON users (email)</code></pre>
    <p>
     联合索引
    </p>
    <pre><code class="hljs">CREATE INDEX idx_name_age ON users (name, age)</code></pre>
    <p>
     主键索引（添加主键约束）
    </p>
    <pre><code class="hljs">ALTER TABLE students ADD PRIMARY KEY (id)</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36323531393237382f:61727469636c652f64657461696c732f313436313431303730" class_="artid" style="display:none">
 </p>
</div>


