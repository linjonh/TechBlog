---
layout: post
title: "C学习十标准,C11-和-C14,C17,C20"
date: 2025-03-06 18:54:30 +0800
description: "这段代码像**“智能厨房点单”**——主线程下单后继续干活，协程默默计时处理，最后交付结果，高效利用等待时间！🕒👨🍳和 关键字。"
keywords: "c++ 目前最新标准"
categories: ['未分类']
tags: ['学习', 'C', 'C']
artid: "146077277"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077277
    alt: "C学习十标准,C11-和-C14,C17,C20"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077277
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077277
cover: https://bing.ee123.net/img/rand?artid=146077277
image: https://bing.ee123.net/img/rand?artid=146077277
img: https://bing.ee123.net/img/rand?artid=146077277
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++学习(十)(标准,C++11 和 C++14,C++17,C++20)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="c-standards" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        C++ 标准
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       C++ 标准是一组定义语言功能、语法和语义的规则和准则。国际标准化组织 （ISO） 负责维护和更新 C++ 标准。这些标准的主要目的是确保跨多个平台和编译器的一致性、效率和可维护性。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       以下是迄今为止发布的不同 C++ 标准的简要摘要：
      </span>
     </span>
    </p>
    <ul style="margin-left:0; margin-right:0">
     <li>
      <p style="margin-left:.5rem; margin-right:0">
       <strong>
        C++98/C++03
       </strong>
       ：C++ 的第一个标准化版本，引入了许多功能，如模板、异常和标准模板库 （STL）。C++03 是对 C++98 的次要更新，修复了一些错误并改进了性能。
      </p>
     </li>
     <li>
      <p style="margin-left:.5rem; margin-right:0">
       <strong>
        C++11
       </strong>
       ：对语言的重大升级，引入了以下功能：
      </p>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        Lambda 表达式：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">auto sum = [](int a, int b) -&gt; int { return a + b; };</code></pre>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        基于范围的 for 循环：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">std::vector&lt;int&gt; numbers = {1, 2, 3, 4};
for (int num : numbers) {
    std::cout &lt;&lt; num &lt;&lt; std::endl;
}</code></pre>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        智能指针（如 和 ）。
        <code>
         std::shared_ptr
        </code>
        <code>
         std::unique_ptr
        </code>
       </li>
      </ul>
     </li>
     <li>
      <p style="margin-left:.5rem; margin-right:0">
       <strong>
        C++14
       </strong>
       ：对 C++11 进行了一次次要更新，其中添加了如下功能：
      </p>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        通用 lambda 表达式：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">auto generic_sum = [](auto a, auto b) { return a + b; };</code></pre>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        二进制文本：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">int binary_number = 0b1010;</code></pre>
     </li>
     <li>
      <p style="margin-left:.5rem; margin-right:0">
       <strong>
        C++17
       </strong>
       ：另一个重大更新，引入了如下功能：
      </p>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        <code>
         if
        </code>
        和初始值设定项：
        <code>
         switch
        </code>
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">if (auto it = my_map.find(key); it != my_map.end()) {
    // use 'it' here
}
</code></pre>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        结构化绑定：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">std::map&lt;std::string, int&gt; my_map = {<!-- -->{"A", 1}, {"B", 2}};
for (const auto&amp; [key, value] : my_map) {
    // use 'key' and 'value' here
}</code></pre>
     </li>
     <li>
      <p style="margin-left:.5rem; margin-right:0">
       <strong>
        C++20
       </strong>
       ：该语言的最新重大更新，具有以下功能：
      </p>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        概念：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">template&lt;typename T&gt;
concept Addable = requires(T a, T b) {
    { a + b } -&gt; std::same_as&lt;T&gt;;
};</code></pre>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        范围：
       </li>
      </ul>
      <pre class="has" style="margin-left:0; margin-right:0"><code class="language-astro-code">std::vector&lt;int&gt; numbers = {1, 2, 3, 4};
auto doubled = numbers | std::views::transform([](int n) { return n * 2; });</code></pre>
      <ul style="margin-left:.75em; margin-right:.75em">
       <li>
        协程等。
       </li>
      </ul>
     </li>
    </ul>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       请记住，要使用这些语言功能，您可能需要将编译器配置为使用特定的 C++ 标准版本。例如，对于 GCC 或 Clang，您可以使用 、 、 或 标志。
       <code>
        -std=c++11
       </code>
       <code>
        -std=c++14
       </code>
       <code>
        -std=c++17
       </code>
       <code>
        -std=c++20
       </code>
      </span>
     </span>
    </p>
    <h2 id="c11-and-c14">
     C++11 和 C++14
    </h2>
    <p>
     <strong>
      C++11
     </strong>
     C++11 标准，也称为 C++0x，于 2011 年 9 月正式发布。它引入了几项新的语言功能和改进，包括：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        Auto
       </strong>
       ：允许编译器根据变量的初始化表达式推断变量类型。
      </p>
      <pre><code>auto integer = 42; // integer is of int type
auto floating = 3.14; // floating is of double type
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        基于范围的 for 循环
       </strong>
       ：提供类似于 foreach 的语义，用于迭代容器或数组。
      </p>
      <pre><code>std::vector&lt;int&gt; numbers {1, 2, 3, 4};
for (int number : numbers) {
    std::cout &lt;&lt; number &lt;&lt; std::endl;
}
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        Lambda 函数
       </strong>
       ：允许更轻松地创建函数对象的匿名函数。
      </p>
      <pre><code>auto add = [](int a, int b) -&gt; int { return a + b; };
int sum = add(42, 13); // sum is equal to 55
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        nullptr
       </strong>
       ：一个表示 null 指针的新关键字，比使用文本 '0' 或 “NULL” 更类型安全。
      </p>
      <pre><code>int *ptr = nullptr;
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        线程支持库
       </strong>
       ：提供一种使用线程和跨线程同步数据访问的标准方法。
      </p>
      <pre><code>std::thread t([]() { std::cout &lt;&lt; "Hello from another thread\n"; });
t.join();
</code></pre>
     </li>
    </ul>
    <p>
     <strong>
      C++14
     </strong>
     C++14 标准于 2014 年 12 月正式发布，作为 C++11 的小型扩展，更侧重于微调语言功能和修复问题。引入的一些新功能：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        通用 Lambda：
       </strong>
       允许使用 'auto' 类型占位符声明 lambda 函数参数。
      </p>
      <pre><code>auto add = [](auto a, auto b) { return a + b; };
auto sum_i = add(42, 13); // Still works with integers
auto sum_f = add(3.14, 2.72); // Now works with doubles too
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        Binary Literals（二进制文本）：
       </strong>
       允许您将整数作为二进制文本输入，以提高可读性。
      </p>
      <pre><code>int b = 0b110101; // Decimal value is 53
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        decltype（auto）：
       </strong>
       推导变量的类型以匹配初始化变量时使用的表达式的类型。
      </p>
      <pre><code>auto func = [](auto a, auto b) { return a * b; };
decltype(auto) result = func(5, 3.14); // decltype(auto) deduces to "double"
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        变量模板
       </strong>
       ：允许您使用模板参数定义变量。
      </p>
      <pre><code>template &lt;typename T&gt;
constexpr T pi = T(3.1415926535897932385);
float r = pi&lt;float&gt;; // Instantiated as a float
double d = pi&lt;double&gt;; // Instantiated as a double</code></pre>
     </li>
    </ul>
    <p>
    </p>
    <h2 id="c20">
     C++20
    </h2>
    <p>
     C++20 是 C++ 编程语言的最新标准，它为语言带来了重大改进和新功能。此版本旨在促进更好的软件开发实践，并使开发人员能够编写更高效、可读和可维护的代码。
    </p>
    <p>
     以下是 C++20 中引入的一些关键功能：
    </p>
    <h3 id="concepts">
     概念
    </h3>
    <p>
     概念是一种对模板参数强制实施特定要求的方法，允许您编写更具表现力和可理解性的代码。它们改进了使用模板时的错误消息，并确保模板参数满足特定条件。
    </p>
    <pre><code>template &lt;typename T&gt;
concept Addable = requires (T a, T b) {
    { a + b } -&gt; std::same_as&lt;T&gt;;
};

template &lt;Addable T&gt;
T add(T a, T b) {
    return a + b;
}
</code></pre>
    <h3 id="ranges">
     范围
    </h3>
    <p>
     范围提供了一种处理值序列的新方法，增强了标准库算法的功能和表现力。基于范围的算法使使用序列变得更加容易和方便。
    </p>
    <pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = { 1, 2, 3, 4, 5 };

    auto even_numbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });

    for (int n : even_numbers) {
        std::cout &lt;&lt; n &lt;&lt; ' ';
    }
}
</code></pre>
    <h3 id="coroutines">
     协程
    </h3>
    <p>
     协程是一种编写异步和并发代码的新方法，具有更高的可读性。它们允许暂停和恢复函数，使您能够编写更高效、无阻塞的代码。
    </p>
    <pre><code>#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;future&gt;

std::future&lt;int&gt; async_value(int value) {
    co_await std::chrono::seconds(1);
    co_return value * 2;
}

int main() {
    auto result = async_value(42);
    std::cout &lt;&lt; "Result: " &lt;&lt; result.get() &lt;&lt; std::endl;
}</code></pre>
    <p>
     我们可以用**“定时烹饪任务”**的比喻来理解这段代码的异步协程机制：
    </p>
    <hr/>
    <h4>
     <strong>
      代码拆解
     </strong>
    </h4>
    <h5>
     1.
     <strong>
      创建定时烹饪任务（协程函数）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code class="hljs">std::future&lt;int&gt; async_value(int value) {
    co_await std::chrono::seconds(1); // 暂停1秒（定时器）
    co_return value * 2;              // 返回结果（完成烹饪）
}</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         co_await
        </code>
       </strong>
       ：
       <br/>
       像给厨房设定一个
       <strong>
        定时器
       </strong>
       ，在等待的1秒钟里，厨师（主线程）可以去做其他事情（不阻塞）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         co_return
        </code>
       </strong>
       ：
       <br/>
       定时器响后，自动继续执行，返回加工后的结果（把原料
       <code>
        value
       </code>
       翻倍）。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     2.
     <strong>
      启动任务并获取结果
     </strong>
    </h5>
    <p>
    </p>
    <pre><code class="hljs">int main() {
    auto result = async_value(42);       // 开始烹饪（启动协程）
    std::cout &lt;&lt; "Result: " &lt;&lt; result.get() &lt;&lt; std::endl; // 等待结果
}</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         result.get()
        </code>
       </strong>
       ：
       <br/>
       相当于
       <strong>
        等待厨师完成烹饪
       </strong>
       ，如果结果还没准备好（定时未到），主线程会在这里暂停等待。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      类比场景
     </strong>
    </h4>
    <p>
     想象你让智能厨房做菜：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        下达指令
       </strong>
       ：
       <br/>
       <code>
        async_value(42)
       </code>
       相当于说：“把42克食材处理一下，1小时后给我结果”。
      </p>
     </li>
     <li>
      <p>
       <strong>
        异步等待
       </strong>
       ：
       <br/>
       厨房定时器开始倒计时，你可以去刷手机（主线程不阻塞）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        获取结果
       </strong>
       ：
       <br/>
       1小时后，你调用
       <code>
        result.get()
       </code>
       取回加工好的84克成品。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      关键知识点
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        代码部分
       </th>
       <th>
        作用
       </th>
       <th>
        类比
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         std::future&lt;int&gt;
        </code>
       </td>
       <td>
        表示未来将获得一个整数结果
       </td>
       <td>
        烹饪订单凭据
       </td>
      </tr>
      <tr>
       <td>
        <code>
         co_await
        </code>
       </td>
       <td>
        暂停协程，让出线程资源
       </td>
       <td>
        设定厨房定时器
       </td>
      </tr>
      <tr>
       <td>
        <code>
         co_return
        </code>
       </td>
       <td>
        协程完成时返回结果
       </td>
       <td>
        厨师交付成品
       </td>
      </tr>
      <tr>
       <td>
        <code>
         result.get()
        </code>
       </td>
       <td>
        阻塞等待结果
       </td>
       <td>
        等待厨师完成
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      实际执行流程
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       调用
       <code>
        async_value(42)
       </code>
       启动协程：
      </p>
      <ul>
       <li>
        <p>
         遇到
         <code>
          co_await
         </code>
         → 暂停协程，启动1秒定时器。
        </p>
       </li>
       <li>
        <p>
         <strong>
          立刻返回
         </strong>
         <code>
          future
         </code>
         对象（此时结果尚未准备好）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       主线程执行
       <code>
        result.get()
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果1秒未到 → 主线程
         <strong>
          阻塞等待
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         1秒后定时器触发 → 协程恢复，计算
         <code>
          42*2=84
         </code>
         并存入
         <code>
          future
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         主线程获得结果，输出
         <code>
          Result: 84
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        协程依赖
       </strong>
       ：需要 C++20 或更高标准，且编译器支持协程（如 GCC11+/Clang14+）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不完全是多线程
       </strong>
       ：协程的暂停/恢复在单线程内也可实现（本例通过定时器演示异步，实际可能涉及线程池）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        错误处理
       </strong>
       ：真实场景需处理协程中可能的异常（本例未展示）。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <p>
     这段代码像**“智能厨房点单”**——主线程下单后继续干活，协程默默计时处理，最后交付结果，高效利用等待时间！ 🕒👨🍳
    </p>
    <h3 id="the-constexpr-and-consteval-keywords" style="margin-left:.75rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        和 关键字
        <code>
         constexpr
        </code>
        <code>
         consteval
        </code>
       </span>
      </span>
     </strong>
    </h3>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       和 都与编译时评估有关。标记为 的函数可以在编译时或运行时执行，而标记为 的函数只能在编译时执行。
       <code>
        constexpr
       </code>
       <code>
        consteval
       </code>
       <code>
        constexpr
       </code>
       <code>
        consteval
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">constexpr int add(int a, int b) {
    return a + b;
}

consteval int square(int x) {
    return x * x;
}

int main() {
    constexpr int result1 = add(3, 4);   // evaluated at compile-time
    int result2 = add(5, 6);             // evaluated at runtime
    constexpr int result3 = square(7);   // evaluated at compile-time
}</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       这些只是 C++20 标准的一些亮点。它还包括许多其他功能和改进，例如结构化绑定、改进的 lambda 和新的标准库组件。总体而言，C++20 使开发人员能够更轻松地编写干净、高效且富有表现力的代码。
      </span>
     </span>
     <br/>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
    <p>
     我们可以用**“建筑设计”
     <strong>
      和
     </strong>
     “施工阶段”**的比喻来理解这两个关键字：
    </p>
    <hr/>
    <h4>
     <strong>
      核心区别
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        关键字
       </th>
       <th>
        作用阶段
       </th>
       <th>
        比喻
       </th>
       <th>
        灵活性
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         <code>
          constexpr
         </code>
        </strong>
       </td>
       <td>
        <strong>
         编译时 或 运行时
        </strong>
       </td>
       <td>
        设计蓝图（可调整）
       </td>
       <td>
        灵活，能适应不同阶段
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          consteval
         </code>
        </strong>
       </td>
       <td>
        <strong>
         仅编译时
        </strong>
       </td>
       <td>
        设计规范（必须确定）
       </td>
       <td>
        严格，仅设计阶段
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      详细解释
     </strong>
    </h4>
    <h5>
     1.
     <strong>
      <code>
       constexpr
      </code>
      （灵活的双面手）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：可以用于编译时计算，也可以在运行时当普通函数调用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         编译时：比如计算数组长度、模板参数等需要提前确定的值。
        </p>
       </li>
       <li>
        <p>
         运行时：当输入参数只能在运行时确定时，自动降级为普通函数。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="hljs">constexpr int 平方(int x) {
    return x * x;
}

int main() {
    constexpr int a = 平方(5);  // 编译时计算（设计阶段确定）
    int b = 平方(10);           // 运行时计算（施工阶段执行）
}</code></pre>
    <pre></pre>
    <hr/>
    <h5>
     2.
     <strong>
      <code>
       consteval
      </code>
      （严格的编译时警察）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        功能
       </strong>
       ：强制函数
       <strong>
        必须在编译时执行
       </strong>
       ，否则直接报错。
      </p>
     </li>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         必须确保某个值在编译时确定（如模板元编程中的常量）。
        </p>
       </li>
       <li>
        <p>
         避免运行时开销，确保优化。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      代码示例
     </strong>
     ：
    </p>
    <pre><code class="hljs">consteval int 立方(int x) {
    return x * x * x;
}

int main() {
    constexpr int a = 立方(3); // 合法（编译时计算）
    int b = 立方(5);           // ❌ 编译错误（不能在运行时调用！）
}</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      对比场景
     </strong>
    </h4>
    <p>
     假设你是一个建筑师：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         constexpr
        </code>
       </strong>
       像可调节的
       <strong>
        蓝图工具
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         可以在设计阶段（编译时）计算房间面积。
        </p>
       </li>
       <li>
        <p>
         也可以在施工时（运行时）根据现场测量临时计算。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         consteval
        </code>
       </strong>
       像严格的
       <strong>
        设计规范检查器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         必须在设计阶段确定所有参数（如承重墙位置）。
        </p>
       </li>
       <li>
        <p>
         施工阶段不允许临时修改，否则直接停工！
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      为什么需要
      <code>
       consteval
      </code>
      ？
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        安全强制
       </strong>
       ：确保某些关键计算（如加密密钥生成）不会泄露到运行时。
      </p>
     </li>
     <li>
      <p>
       <strong>
        优化保证
       </strong>
       ：编译时计算的结果可直接内联，提升性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        错误前置
       </strong>
       ：在编译阶段发现问题，避免运行时崩溃。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <code>
        constexpr
       </code>
       ：
       <strong>
        灵活多面手
       </strong>
       ，编译时和运行时都能干活。
      </p>
     </li>
     <li>
      <p>
       <code>
        consteval
       </code>
       ：
       <strong>
        严格检查员
       </strong>
       ，只允许编译时干活！ 🔧⚡
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f736f6c6f6d6f6e7a772f:61727469636c652f64657461696c732f313436303737323737" class_="artid" style="display:none">
 </p>
</div>


