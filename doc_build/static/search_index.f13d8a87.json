[{"id":0,"title":"安卓学习之路","content":"> 1、视频是怎么创建的\n\n> 2、视频怎么播放的\n\n> 3、数据库升级策略\n\n> 4、APP路线图\n\n\n\n> Java路线图\n\n","routePath":"/blog/2018-07-14-Android学习之路","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"安卓学习之路","date":"2018-07-14 20:20","categories":"jekyll update"},"version":""},{"id":1,"title":"Android APPs 反编译工具","content":"反编译工具有哪些？#\n\n * dex2jar\n * jd-gui\n * jadx\n * enjarify\n * Apktool\n\n上面的5种反编译相关的工具都是开源的。\n\n> 最开始反编译工具是dex2jar可以将dex转化成jar包，然后可以将jar通过jd-gui来转换。\n\n发现这个过程需要两步才能完成，后来直接使用jadx将apk\n\n使用jd-gui/jadx查看代码的时候，跳转以及查找都比较的慢。就使用enjarify(号称可以反编译出来的类最多)将apk反编译成dex,然后使用jadx将\ndex反编译成java代码，使用Android Studio查看代码。 使用apktool可以反编译出资源文件。\n所以现在我的习惯，对于直接给的jar(其它部门的SDK)使用jd-gui。对于不需要去具体看代码的apk使用jadx直接查看。对于可能需要研究的代码，使用enj\narify + jadx + Andorid Studio。需要查看资源文件就使用apktool。\n\n> 一个小的tips，使用adb命令快速的找到当前在那个界面。\n\n\n\n> 更多的adb命令还可以查考awesome-adb\n\n最后反编译不是我们学习的全部，但是了解一点还是对开发有帮助的。","routePath":"/blog/2018-07-20-AnroidApp反编译工具","lang":"","toc":[{"text":"反编译工具有哪些？","id":"反编译工具有哪些","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"Android APPs 反编译工具","date":"2018-07-20T15:57:34.000Z","categories":"Android 反编译工具 工具","tags":"Android"},"version":""},{"id":2,"title":"Android的进程和线程.","content":"Android中包括5种进程#\n\n> 1、前台进程：\n\n用户交互的Activity，绑定到service的用户正在交互Activity， startForground()的service，\n托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()，\nbroadcast的正在执行onReceive（）\n\n> 2、可见进程\n\n托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一\nActivity，则有可能会发生这种情况。 托管绑定到可见（或前台）Activity 的 Service。\n\nclik topic to see more...\n\n> 3、服务进程\n\n正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。\n\n> 4、后台进程\n\n包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）\n这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU\n（最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity\n正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity\n会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。\n\n> 5、空进程\n\n不含任何活动应用组件的进程。 保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。\n为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\n\n\nAndroid线程类#\n\n> HanlderThread这个类可以看看源码，看到","routePath":"/blog/2018-07-21-Android的进程和线程","lang":"","toc":[{"text":"Android中包括5种进程","id":"android中包括5种进程","depth":2,"charIndex":-1},{"text":"Android线程类","id":"android线程类","depth":2,"charIndex":831}],"domain":"","frontmatter":{"layout":"post","title":"Android的进程和线程.","date":"2018-07-20T18:05:05.000Z","categories":"Android","tags":"Android 线程 进程"},"version":""},{"id":3,"title":"Flutter new mobil app sdk","content":"What is Flutter ?#\n\nA new mobile app SDK to help developers and designers build modern mobile apps\nfor iOS and Android. Flutter is an open-source project currently in beta.\n\n\nThe Link of project#\n\n> The project is host on github: Flutter","routePath":"/blog/2018-07-21-Flutter-newMobilAppSDK","lang":"","toc":[{"text":"What is Flutter ?","id":"what-is-flutter-","depth":2,"charIndex":-1},{"text":"The Link of project","id":"the-link-of-project","depth":2,"charIndex":174}],"domain":"","frontmatter":{"layout":"post","title":"Flutter new mobil app sdk","date":"2018-07-20T18:19:34.000Z","categories":"Android Flutter","tags":"Android Flutter SDK"},"version":""},{"id":4,"title":"Github自定义域名和域名解析设置","content":" * content {:toc}\n\n--------------------------------------------------------------------------------\n\n\n域名注册#\n\n可以从网上搜索域名注册 关键词，进入域名注册提供商网站去注册自己想要的域名，看自己的情况选择购买合适价格的域名进行注册。\n\n本人是在阿里云注册的域名，现在注册需要实名认证之后才能成功解析域名。否则在网站上输入自己的域名无法访问到ip地址，即打不开网站。\n\n\n域名解析#\n\n> 本人注册的域名解析的是解析至GitHub主机上。\n\nGitHub pages 是一个静态网页托管平台，你可以把你制作的HTML静态网页通过git工具上传至GitHub代码仓库。\n\n在你GitHub上的某个项目上设置你的自定义域名#\n\n 1. 在GitHub上 , 导航至你的某个网页项目仓库 （GitHub Pages site's repository）。\n 2. 在你的项目仓库下, 点击 **Settings **设置标签进入设置界面\n 3. 在 \"Custom domain,\"下输入框中添加你的自定义域名（你之前购买的域名想要指向该项目作为网站，如：jaylin.top），之后点击\n    Save.按钮保存。 To check if your custom domain is supported, see \"About supported\n    custom domains.\"\n 4. 如果你设置了自定义域名之后可以强制为你的网站设置为 HTTPS 协议. For more information, see \"Securing your\n    GitHub Pages site with HTTPS.\"\n\n在DNS提供商网站上设置DNS解析记录#\n\n如图，在阿里云上，我的DNS解析记录包括Apex记录，subdomain记录：\n\n\n\n> Apex记录是指A记录是顶级域名解析设置，解析到的记录值是IP地址。eg:\n> \n> 记录类型   记录值\n> A      185.199.110.153 (这是github pages的IP地址)\n\n> subdomain记录是指CNAME子级域名记录解析设置，解析到github的网站域名。eg:\n> \n> 记录类型    记录值\n> CNAME   username.github.io（你的gitbug pages的域名）\n\n 1. A记录是为了能够通过你注册的Apex顶级域名eg:jaylin.top在浏览器上输入访问时能解析指定访问到GitHub pages主机上。\n\n 2. subdomain子级域名就是在顶级域名前加上前缀的域名eg: **shop.**jaylin.top。想要让某个子级域名也指向GitHub\n    pages主机上需要设置的类型是CNAME类型，在GitHub上的对应代码仓库下，按照上述设置自定义域名的方法设置主机怎么显示这个子级域名代表的网页内容\n    。\n\n> GitHub支持的域名类型\n\nSUPPORTED CUSTOM DOMAIN TYPE          EXAMPLE DOMAIN\nwww subdomain                         www.example.com\none apex domain & one www subdomain   example.com & www.example.com\napex domain                           example.com\ncustom subdomain                      blog.example.com\n\n\n补充说明如何申请你的github pages域名#\n\n 1. 在github.com 上注册一个你的账号如：jaylin\n\n 2. 创建一个代码仓库项目，名称是有要求的，前缀必须和你的注册的账号名称一样如：jaylin.gihub.io\n\n 3. 然后这个代码仓库的项目名称：jaylin.gihub.io 就是你的GitHub pages的域名\n\n 4. 通过git工具将你的网页代码上传这个项目仓库下，就可以通过http:// jaylin.gihub.io访问了。\n\n 5. 如果你不满意这个仓库的域名，就可以自己注册一个自定义域名，步骤如上域名解析。\n\n\n自定义域名重定向至GitHub Pages site#\n\nThe type of pages site you're using determines how your site redirects custom\ndomains.\n\n> Warning: If the URL for your GitHub Pages site contains a username or\n> organization name that begins or ends in a dash, or contains consecutive\n> dashes, then people browsing with Linux will receive a server error when they\n> visit the site. To fix this, change your GitHub username to remove\n> non-alphanumeric characters. For instructions on how to do this, see \"Changing\n> your GitHub username.\"\n\nTYPE OF GITHUB PAGES SITE   PAGES DEFAULT DOMAIN & HOST LOCATION ON GITHUB   HOW THE PAGE IS REDIRECTED                                    EXAMPLE CUSTOM DOMAIN\n个人网站                        username.github.io                               Automatically redirected to the custom domain that has been   user.example.com\n                                                                             set for it\n企业                          orgname.github.io                                Automatically redirected to the custom domain that has been   org.example.com\n                                                                             set for it\n个人网站项目                      username.github.io/projectname                   Automatically redirected to a subdirectory of a User Pages    project.example.com\n                                                                             site custom domain (user.example.com/projectname)\n企业网站项目                      orgname.github.io/projectname                    Automatically redirected to a subdirectory of an              project.example.com\n                                                                             Organization Pages site custom domain\n                                                                             (org.example.com/projectname)\n\n> To learn more about the different GitHub Pages site types, including whether\n> to use master or gh-pages as a publishing branch, see this User, Organization,\n> and Project pages chart.","routePath":"/blog/2018-07-21-GitHub自定义域名解析方法","lang":"","toc":[{"text":"域名注册","id":"域名注册","depth":2,"charIndex":101},{"text":"域名解析","id":"域名解析","depth":2,"charIndex":237},{"text":"在你`GitHub`上的某个项目上设置你的自定义域名","id":"在你github上的某个项目上设置你的自定义域名","depth":4,"charIndex":-1},{"text":"在DNS提供商网站上设置DNS解析记录","id":"在dns提供商网站上设置dns解析记录","depth":4,"charIndex":762},{"text":"补充说明如何申请你的github pages域名","id":"补充说明如何申请你的github-pages域名","depth":2,"charIndex":1584},{"text":"自定义域名重定向至GitHub Pages site","id":"自定义域名重定向至github-pages-site","depth":2,"charIndex":1866}],"domain":"","frontmatter":{"layout":"post","date":"2018-07-21T06:26:00.000Z","title":"Github自定义域名和域名解析设置","categories":"域名 domain Github","tags":"域名 Github"},"version":""},{"id":5,"title":"bundle-install-for-jekyll","content":"Problems on linux when using gem bundle install#\n\n> As following:\n\n\n\n> All we need is to install \"nokogiri-1.8.4\" extenstions first, so we just\n> install it at shell:\n\n\n\n> As log discription, we lost zlib (zlib1g-dev), ok, let's get is install:\n\n\n\nThat's all right, we could continue install \"nokogirl-1.8.4\" and next run\n\"bundle install\"","routePath":"/blog/2018-07-27-bundler-install-for-jekyll-problems","lang":"","toc":[{"text":"Problems on linux when using gem bundle install","id":"problems-on-linux-when-using-gem-bundle-install","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"bundle-install-for-jekyll","date":"2018-07-27T08:03:18.000Z","categories":"gem jekyll gem-bundle","tags":"gem jekyll gem-bundle"},"version":""},{"id":6,"title":"Android Gradle build 构建脚本语法用法","content":"Android 构建脚本简介#\n\nAndroid APP\n构建脚本采用的是Gradle框架。Gradle是一种构建builde编译框架，采用的是groovy语言。谷歌官方有使用自己的一套builde 插件依赖\n配置在project.gradle文件里：\n\n\n\n\n项目build.gradle配置#\n\n\n\n\n设置本地查找引用.aar的gradle依赖用法是#\n\n\n\n\n设置NDK生成lib.so对应的ArmABI平台代码：#\n\n\n\n\n强制使用依赖版本#\n\n\n\n这里有使用到字符串模板变量是定义在project.gradle里的ext{}代码块里的。\n\n\n定义ext变量#\n\nlocation at file project.gradle\n\n\n\n\n构建变体选项#\n\n","routePath":"/blog/2018-08-15-Android-Gradle-build-构建脚本语法用法","lang":"","toc":[{"text":"Android 构建脚本简介","id":"android-构建脚本简介","depth":2,"charIndex":-1},{"text":"项目build.gradle配置","id":"项目buildgradle配置","depth":2,"charIndex":130},{"text":"设置本地查找引用.aar的gradle依赖用法是","id":"设置本地查找引用aar的gradle依赖用法是","depth":3,"charIndex":152},{"text":"设置NDK生成lib.so对应的ArmABI平台代码：","id":"设置ndk生成libso对应的armabi平台代码","depth":3,"charIndex":182},{"text":"强制使用依赖版本","id":"强制使用依赖版本","depth":3,"charIndex":215},{"text":"定义ext变量","id":"定义ext变量","depth":3,"charIndex":275},{"text":"构建变体选项","id":"构建变体选项","depth":3,"charIndex":321}],"domain":"","frontmatter":{"layout":"post","title":"Android Gradle build 构建脚本语法用法","date":"2018-08-15 11:32","categories":"Android Gradle","tags":"Android Gradle groovy"},"version":""},{"id":7,"title":"Android 接入firebase","content":"注册firebase账号#\n\n在firebse 上注册登陆账号，之后注册应用，填写包名等信息，下载配置文件。\n\n\n下载配置文件#\n\ngoogle-services.json\n\n\n添加 Firebase SDK#\n\n适用于 Gradle 的说明|UnityC++Gradle 的 Google\n服务插件会加载您刚刚下载的 google-services.json 文件。请修改您的 build.gradle 文件以使用该插件。\n\n项目级 build.gradle（<项目>/build.gradle）：\n\n\n\n应用级 build.gradle（<项目>/<应用模块>/build.gradle）：\n\n\n\n默认情况下包含 Analytics\n\n最后，按 IDE 中显示的栏中的“立即同步”：","routePath":"/blog/2018-08-18-Android接入firebase","lang":"","toc":[{"text":"注册firebase账号","id":"注册firebase账号","depth":3,"charIndex":-1},{"text":"下载配置文件","id":"下载配置文件","depth":3,"charIndex":56},{"text":"添加 Firebase SDK","id":"添加-firebase-sdk","depth":3,"charIndex":88}],"domain":"","frontmatter":{"layout":"post","title":"Android 接入firebase","date":"2018-08-15T16:04+08:00","categories":"Android firebase gradle","tags":"Android Firebase"},"version":""},{"id":8,"title":"Public An aar library to JCenter and MavenCenter","content":"#\n\n\nJcenter And Maven Center#\n\nJcenter and MavenCenter are moden time standar maven center. they maintained by\nBintray and sonatype respectively.\n\nAs the artical , we just talk abut Bintray's JCenter. Cause Android Studio now\nsupport Jcenter as default maven center.\n\n> First of all , you need create an accunt of Binray at Bintray.com and generate\n> an API Key at Edit menu of account profile\n\n\nExample Project#\n\n\n\nMvpArch\n\n\nAndroid Gradle automated publish an aar library#\n\nAdd buildScript to dependencies#\n\n\n\napply plugin at library module#\n\n\n\n> The bintray plugin supports three methods to create groups of artifacts:\n> Configurations, Publications and Copying specific files using filesSpec. For\n> more read, reference gradle-bintray-plugin.\n\nFor maven ,we need sources.Jar and javadoc.Jar artifacts#\n\ncreate task as below for android gradle:\n\n\n\nBintray configuration:#\n\n\n\nMaven publish mathod configuration:#\n\n\n\n\nReferences#\n\n * https://github.com/bintray/gradle-bintray-plugin\n * https://github.com/bintray/bintray-examples\n * https://www.jfrog.com/confluence/display/BT/Uploading+Using+APIs (Set Me Up )","routePath":"/blog/2018-09-23-Publish An aar library to Jcenter and maven center","lang":"","toc":[{"text":"Jcenter And Maven Center","id":"jcenter-and-maven-center","depth":2,"charIndex":3},{"text":"Example Project","id":"example-project","depth":2,"charIndex":395},{"text":"Android Gradle automated publish an aar library","id":"android-gradle-automated-publish-an-aar-library","depth":2,"charIndex":425},{"text":"References","id":"references","depth":2,"charIndex":918}],"domain":"","frontmatter":{"layout":"post","date":"2018-09-23 23:21","title":"Public An aar library to JCenter and MavenCenter","categories":"Android Jcenter Maven","tags":"JCenter Maven Gradle"},"version":""},{"id":9,"title":"Android Storage Access Framework(SAF)","content":"SAF存储访问框架介绍#\n\nSAF介绍链接\n\nAndroid 4.4（API 级别 19）引入了存储访问框架 (SAF)。SAF\n让用户能够在其所有首选文档存储提供程序中方便地浏览并打开文档、图像以及其他文件。 用户可以通过易用的标准\nUI，以统一方式在所有应用和提供程序中浏览文件和访问最近使用的文件。\n\n\n针对SD Card文件访问读写受限制的问题。#\n\n自API 19引入SAF后，应用程序无法直接通过java 的File API进行写操作了。需要用到Android 的DocumentFile API\n进行间接处理文件。\n\n * 首先需要获取SD Card的读写权限\n * 在获取的URI权限基础上创建DocumentFile.fromTreeUri(context,uri)\n * 根据获取到的权限目录树进行子文件或子文件夹操作，类似于JAVA的File操作。\n\n\nSD card权限获取方法#\n\n 1. 通过注册Receiver监听Intent.ACTION_MEDIA_MOUNTED,接收有新存储设备挂载，在Intent.getParcelableEx\n    tra（StorageVolume.EXTRA_STORAGE_VOLUME）里可以获取到分区的名称标识（uuid），在获取的分区实例后，直接请求权限：\n    \n    \n\n 2. 通过系统服务框架（System Service Framework）获取存储设置管理服务StorageManager\n    \n    \n    \n    再而查询获取存储设备列表storageManager.getStorageVolumes();该API 需要 level\n    24才能调用。也可以用反射的方法去获取。不过将来Android 9.0 以后，谷歌收紧了非SDK\n    API的访问限制，9.0以后将会抛出classNotFountException 异常。\n    \n    \n    \n    有了StorageVolume分区列表对象，就可以调用上述的方法创建请求权限的intent了。\n\n 3. 通过系统提供的UI选取器，让用户选择预期想要授权的存储设备根目录，在onActivityResult()方法里处理返回的URI路径。\n    \n    \n\n> Caution:\n> \n> 为了下次不用反复请求权限的问题，使用ContentProvider.takePersistableUriPermission(uri,Intent.FLAG\n> _GRANT_WRITE_URI_PERMISSION |\n> Intent.FLAG_GRANT_READ_URI_PERMISSION);保存在系统了，即使reboot了也依然存在，除非clear APP data.\n> \n> 获取已授权的URI 列表：List<UriPermission> persistedUriPermissions =\n> getActivity().getContentResolver().getPersistedUriPermissions();\n> \n> 取消授权：getActivity().getContentResolver().releasePersistableUriPermission(uri,mo\n> deFlags);\n> \n> 或者getActivity().revokeUriPermission(permissionUri,\n> Intent.FLAG_GRANT_READ_URI_PERMISSION |\n> Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n\n\n对文件进行处理操作#\n\n对受限的文件写操作，如Rename,delete, edit\n,需要得到权限URI的DocumentFile才能起作用。（这个也是当初很困惑的一个问题，研究许久，这个URI没有直接像查询MediaStore那样查询数据库的\n方法获取URI）\n\n通过getContentResolver().getPersistedUriPermissions();获取已授权的tree URI,\n使用DocmentFile API 一路解析下去到file名称那一级，即是对应的权限的DocumentFile对象，就可以对文件进行写操作了。\n\n解析方式：\n\n\n\n获取到了已授权的标准DocumentFile对象之后，就可以为所欲为了，哈哈，开个玩笑......\n\n检测是不是标准URI的DocumentFile,使用DocumentsContract.isDocumentUri(context,tdocumentFile.\ngetUri()) 返回布尔值。","routePath":"/blog/2018-11-26-Android-Storage-Access-Framework","lang":"","toc":[{"text":"SAF存储访问框架介绍","id":"saf存储访问框架介绍","depth":2,"charIndex":-1},{"text":"针对SD Card文件访问读写受限制的问题。","id":"针对sd-card文件访问读写受限制的问题","depth":2,"charIndex":154},{"text":"SD card权限获取方法","id":"sd-card权限获取方法","depth":3,"charIndex":387},{"text":"对文件进行处理操作","id":"对文件进行处理操作","depth":2,"charIndex":1549}],"domain":"","frontmatter":{"layout":"post","title":"Android Storage Access Framework(SAF)","date":"2018-11-26T06:54:34.000Z","categories":"Android SAF","tags":"Android  SAF"},"version":""},{"id":10,"title":"Android TargetSDK28 升级SDK版本后适配修改点","content":"Upgrade to TagertSDK 28#\n\n\n前台服务需要添加 ForgroundService权限 否则系统会引发 SecurityException。#\n\n\n\n打开前台服务，需要有通知栏体现：\n\n\n\n要请求让服务运行于前台，在ForegroundService.class里需要调用如下方法启动通知栏:\n\n\n\n\n非SDK API的限制#\n\n对非Android SDK API的调用做了限制，通常会出现类似NoSuchClassException或NoSuchFieldException异常。\n\n非SDK API包括Android未公开的底层内部实现细节的API反射调用。还有NDK里未公开的方法调用等。\n\n> 需要排查有哪些非SDK API可以使用如下方法\n\n\n\n\n网络请求方面#\n\n * 框架安全性变更\n   \n   在Android 9.0(28)以上，默认情况下启用网络传输层安全协议 (TLS），在此情况下不支持http明文协议了，网路请求数据将返回无数据。\n   \n   要改变该行为，可以AndroidManifest.xml做配置：\n   \n   \n   \n   若要支持安全的密文传输，可按照Google的 网络安全配置 去实现\n\n * 在 Android 6.0 中，我们取消了对 Apache HTTP 客户端的支持\n   \n   如果还需要继续能够使用Apache HTTP的类库，按如下配置：\n   \n   要继续使用 Apache HTTP 客户端，以 Android 9 及更高版本为目标的应用可以向其 AndroidManifest.xml添加以下内容：\n   \n   \n   \n   \n\n\n使用了透明主题的Activity不可设置orientation配置，否则会崩溃。#\n\n解决办法是不设置orientation。或设置值为android:screenOrientation=\"unspecified\"\n\n\n现在强制执行 FLAG_ACTIVITY_NEW_TASK 要求#\n\n在 Android 9 中，您不能从非 Activity 环境中启动 Activity，除非您传递 Intent 标志\nFLAG_ACTIVITY_NEW_TASK。 如果您尝试在不传递此标志的情况下启动 Activity，则该 Activity\n不会启动，系统会在日志中输出一则消息。\n\n注：在 Android 7.0（API 级别 24）之前，标志要求一直是期望的行为并被强制执行。 Android 7.0 中的一个错误会临时阻止实施标志要求。","routePath":"/blog/2019-07-03-Android-TargetSDK28升级SDK版本后适配修改点","lang":"","toc":[{"text":"Upgrade to TagertSDK 28","id":"upgrade-to-tagertsdk-28","depth":2,"charIndex":-1},{"text":"前台服务需要添加 ForgroundService权限  否则系统会引发 。","id":"前台服务需要添加-forgroundservice权限--否则系统会引发-","depth":3,"charIndex":-1},{"text":"非SDK API的限制","id":"非sdk-api的限制","depth":3,"charIndex":161},{"text":"网络请求方面","id":"网络请求方面","depth":3,"charIndex":339},{"text":"使用了透明主题的Activity不可设置orientation配置，否则会崩溃。","id":"使用了透明主题的activity不可设置orientation配置否则会崩溃","depth":3,"charIndex":717},{"text":"现在强制执行 FLAG_ACTIVITY_NEW_TASK 要求","id":"现在强制执行-flag_activity_new_task-要求","depth":3,"charIndex":827}],"domain":"","frontmatter":{"layout":"post","title":"Android TargetSDK28 升级SDK版本后适配修改点","date":"2019-07-03T09:49:00.000Z","categories":"Android TargetSDK28","tags":"Android  TargetSDK28"},"version":""},{"id":11,"title":"Android-微信支付-支付宝SDK集成指南","content":"项目文件结构#\n\n\n\n\n微信#\n\n\n支付流程#\n\n> 请求服务器接口下订单--->调用本地SDK支付--->SDK返回支付结果--->服务器验证查询订单支付结果\n\n\n微信支付服务器接口文档#\n\n\n支付宝#\n\n\n支付流程#\n\n> 请求服务器接口下订单--->调用本地SDK支付--->SDK返回支付结果--->服务器验证查询订单支付结果\n\n\n支付宝服务器接口文档#\n\n\n恢复购买#\n\n * 支付宝恢复购买流程:\n\n> 请求服务器接口获得授权信息--->调用支付宝SDK对授权信息进行授权--->获得openID再请求服务器接口获取所有订单购买情况\n\n * 微信恢复购买流程：\n\n> 微信SDK发起授权获取code--->通过请求微信官网的链接接口进行验证授权返回openID--->请求服务接口获取所有订单购买情况\n\n\n注意事项#\n\n\n微信支付注意事项#\n\n对SDK回调响应的类名和包名是有要求的，必须是注册的{包名.wxapi}.WXEntryActivity.java\n\n对于支付回调的类名和包名是{包名.wxapi}.WXPayEntryActivity.java\n\n在类里面实现IWXAPIEventHandler接口，SDK会调用onReq(BaseReq baseReq)和onResp(BaseResp\nbaseResp)方法\n\n如果类名和包名不一致会导致无法回调SDK接口。\n\n\n恢复购买注意事项#\n\n每次APP启动都会访问网络查询VIP信息接口，获取当前APP是否已购买状态，同恢复购买接口一样只查询最后购买的支付方式的openID去查询VIP信息接口。两种支\n付方式的购买单项特权不叠加，即支付宝购买的特权在微信支付方式下未购买的情况下，用微信支付方式恢复购买则不会恢复支付宝已购买的特权。\n\n\n接入指南#\n\n\n支付模块引用接入#\n\n现已经将支付功能模块化成类库了，模块名称为cnpay。在需要用到支付功能的工程项目里在setting.gradle引用模块：\n\n\n\n在build.gradle里添加依赖支付类库：\n\n\n\n\n主要入口#\n\n跳转到VIP界面#\n\nVIP购买页：VipPayActivity.java\n\nVIP购买结果页：BuyVipResultActivity.java\n\nVIP状态页：VipStatusActivity.java\n\n\n\nVIP 购买状态#\n\n购买情况本地存储的类VipSharePreference.java\n\nVIP入口类型:#\n\n购买项目跳转VIP入口类型常量VipConstant.java\n\n订单ID#\n\n订单ID常量ProductIdConstant.java\n\n更新UI状态方式#\n\n当购买成功够更新VIP UI状态的接收方法是通过EventBus收发的：\n\n\n\n\n代码混淆#\n\n对gson的entity类做keep\n\n\n\n\n支付模块框架介绍#\n\n * 网络架构：OKHttp3+Retrofit2+RxJava2\n   \n   \n\n * 设计模式：MVP模式\n   \n   \n\n * 引用模块：\n   \n   \n\n * CN\n   VRecorder代码地址：http://192.168.0.233/svn/EnergyAVEditor/Branch/VRecorder/CN_VRe\n   corder/CN_VRecorder_v3.2.1_re(100)","routePath":"/blog/2019-07-22-Android-微信支付宝支付SDK集成指南","lang":"","toc":[{"text":"支付流程","id":"支付流程","depth":3,"charIndex":17},{"text":"微信支付服务器接口文档","id":"微信支付服务器接口文档","depth":3,"charIndex":82},{"text":"支付流程","id":"支付流程-1","depth":3,"charIndex":104},{"text":"支付宝服务器接口文档","id":"支付宝服务器接口文档","depth":3,"charIndex":169},{"text":"微信支付注意事项","id":"微信支付注意事项","depth":3,"charIndex":366},{"text":"恢复购买注意事项","id":"恢复购买注意事项","depth":3,"charIndex":596},{"text":"支付模块引用接入","id":"支付模块引用接入","depth":3,"charIndex":764},{"text":"主要入口","id":"主要入口","depth":3,"charIndex":869},{"text":"跳转到VIP界面","id":"跳转到vip界面","depth":4,"charIndex":876},{"text":"VIP 购买状态","id":"vip-购买状态","depth":4,"charIndex":984},{"text":"VIP入口类型:","id":"vip入口类型","depth":4,"charIndex":1030},{"text":"订单ID","id":"订单id","depth":4,"charIndex":1074},{"text":"更新UI状态方式","id":"更新ui状态方式","depth":4,"charIndex":1111},{"text":"代码混淆","id":"代码混淆","depth":3,"charIndex":1163}],"domain":"","frontmatter":{"layout":"post","title":"Android-微信支付-支付宝SDK集成指南","date":"2019-07-22T02:25:00.000Z","categories":"Android Pay WeiXinPay AliPay 微信支付 支付宝","tags":"Android  Pay WeiXinPay AliPay"},"version":""},{"id":12,"title":"Android-自定义水印+OpenGL画水印图片","content":"自定义编辑水印篇#\n\n自定义编辑水印涉及到控件的自定义，控件位置的移动，图片大小和文字大小缩放，文字的颜色改变，还有水印的透明度。\n\n> 水印元素包括了\n\n * 图片水印\n\n * 文字水印\n\n> 涉及到的控件\n\n\n\n> 水印需要保存的信息：数据库信息\n\n * 水印透明度alpha\n\n * 水印宽度widthRatio比例（涉及到横竖屏）\n\n * 水印高度heightRatio比例（涉及到横竖屏）\n\n * 水印位置centerX比例（涉及到横竖屏）\n\n * 水印位置centerY比例（涉及到横竖屏）\n\n * 文字水印颜色color\n\n * 文字水印文案信息\n\n * 文字缩放大小值textSize\n\n * 图片水印文件路径\n\n * 水印元素ID（数据库ID自动生成）\n\n\n控件手势移动#\n\n\n\n\n控件位置计算#\n\n\n\n\n控件大小计算#\n\nView.onMeasure()调用周期\n\n\n\n通过View.requestLayout()来刷新计算控件大小，控件重写了View.onMeasure()计算控件的大小，重写View.layout()来布局当\n前控件的位置和宽高。\n\n> TextView的水印自定义控件使用到了android.text.StaticLayout.java来自动计算字体的大小宽高\n\n\n控件放大缩小算法和进度条计算算法#\n\n * 图片水印控件放大缩小算法\n   \n   \n\n * 文字水印控件放大缩小算法\n   \n   \n\n * 文字水印颜色的选择和进度条的转换算法\n   \n   \n\n\nOpenGL 画图篇#\n\n\nOpenGL API V2#\n\n\n定义定点脚本和片段着色脚本#\n\n\n\n\n创建OpenGL脚本画图程序编译，然后链接程序#\n\n\n\n\n创建水印纹理#\n\n\n\n\n计算水印坐标转换成openGL的坐标矩阵#\n\n\n\n\n引用创建的OpenGL水印渲染脚本程序开始画图#\n\n\n\n\nOpen GL Android 知识#\n\n\nOpenGL ES#\n\n此链接的文档详细介绍了Android 如何使用OpenGL版本和如何转换坐标映射到屏幕，还有投影和相机视图矩阵变换来使得在手机屏幕上不会失真变形。\n\n\n\nFigure 1. Default OpenGL coordinate system (left) mapped to a typical Android\ndevice screen (right).\n\n\nDisplaying graphics with OpenGL ES#\n\n * Build an OpenGL ES environment\n   \n   Learn how to set up an Android application to be able to draw OpenGL\n   graphics.\n\n * Define shapes\n   \n   Learn how to define shapes and why you need to know about faces and winding.\n\n * Draw shapes\n   \n   Learn how to draw OpenGL shapes in your application.\n\n * Apply projection and camera views\n   \n   Learn how to use projection and camera views to get a new perspective on your\n   drawn objects.\n\n * Add motion\n   \n   Learn how to do basic movement and animation of drawn objects with OpenGL.\n\n * Respond to touch events\n   \n   Learn how to do basic interaction with OpenGL graphics.\n\nAdditional sample code\n\nTo download NDK samples, see NDK Samples.","routePath":"/blog/2019-08-21-Android-自定义水印+OpenGL画水印图片","lang":"","toc":[{"text":"控件手势移动","id":"控件手势移动","depth":2,"charIndex":337},{"text":"控件位置计算","id":"控件位置计算","depth":2,"charIndex":349},{"text":"控件大小计算","id":"控件大小计算","depth":2,"charIndex":361},{"text":"控件放大缩小算法和进度条计算算法","id":"控件放大缩小算法和进度条计算算法","depth":2,"charIndex":554},{"text":"OpenGL API V2","id":"opengl-api-v2","depth":3,"charIndex":669},{"text":"定义定点脚本和片段着色脚本","id":"定义定点脚本和片段着色脚本","depth":3,"charIndex":686},{"text":"创建OpenGL脚本画图程序编译，然后链接程序","id":"创建opengl脚本画图程序编译然后链接程序","depth":3,"charIndex":705},{"text":"创建水印纹理","id":"创建水印纹理","depth":3,"charIndex":734},{"text":"计算水印坐标转换成openGL的坐标矩阵","id":"计算水印坐标转换成opengl的坐标矩阵","depth":3,"charIndex":746},{"text":"引用创建的OpenGL水印渲染脚本程序开始画图","id":"引用创建的opengl水印渲染脚本程序开始画图","depth":3,"charIndex":772},{"text":"OpenGL ES","id":"opengl-es","depth":3,"charIndex":823},{"text":"Displaying graphics with OpenGL ES","id":"displaying-graphics-with-opengl-es","depth":3,"charIndex":1015}],"domain":"","frontmatter":{"layout":"post","title":"Android-自定义水印+OpenGL画水印图片","date":"2019-08-21T07:46:00.000Z","categories":"Android 水印 自定义水印 OpenGL","tags":"Android OpenGL DrawImage"},"version":""},{"id":13,"title":"Target 28遇到的问题","content":"#\n\n\n1. unescaped apostrophe in string array （string.xml文件里）#\n\n这是修改了buildTools版本为28.0.3导致单引号字符串定位行数不准确的问题\n\n解决办法：升级gradle为最新的。\n\n\n2. 升级gradle为最新之后出现，SVNRevision revision = status.getRevision();脚本出现空指针问题。#\n\n解决办法：修改方法\n\n\n\n\n3. classpath 'io.fabric.tools:gradle:1.25.1升级到classpath\n'io.fabric.tools:gradle:1.25.4#\n\n否则和classpath 'com.android.tools.build:gradle:3.5.1‘不匹配，（gradle-5.4.1-all.zip）\n\n\n4. canvas.save(Canvas.ALL_SAVE_FLAG); 方法target28API已经没有参数#\n\n解决办法：删除参数\n\n\n5.target 28 透明activity设置#\n\nRecorderSplashActivity.java的manifest的orientation配置为unspacifed\n\nGoogleVipKeepDialog的orientation去除\n\n\n6.网络使用到的Apache库修改#\n\n参见target28升级SDK版本修改点的md文档\n\n\n7. 修复MaterialStickerFragment贴图素材下载使用了apache的HTTPClient导致release版本没法请求到服务器的问题#\n\n\n8.【升级到到target28】base64 API不使用Apache的API改为Android 的API#\n\n","routePath":"/blog/2019-10-18-Android-Target 28遇到的问题","lang":"","toc":[{"text":"1. unescaped apostrophe in string  array  （string.xml文件里）","id":"1-unescaped-apostrophe-in-string--array--stringxml文件里","depth":2,"charIndex":-1},{"text":"2. 升级gradle为最新之后出现，SVNRevision revision = status.getRevision();脚本出现空指针问题。","id":"2-升级gradle为最新之后出现svnrevision-revision--statusgetrevision脚本出现空指针问题","depth":2,"charIndex":126},{"text":"3.  classpath 'io.fabric.tools:gradle:1.25.1升级到classpath 'io.fabric.tools:gradle:1.25.4","id":"3--classpath-iofabrictoolsgradle1251升级到classpath-iofabrictoolsgradle1254","depth":2,"charIndex":-1},{"text":"4. canvas.save(Canvas.ALL_SAVE_FLAG); 方法target28API已经没有参数","id":"4-canvassavecanvasall_save_flag-方法target28api已经没有参数","depth":2,"charIndex":385},{"text":"5.target 28 透明activity设置","id":"5target-28-透明activity设置","depth":2,"charIndex":457},{"text":"6.网络使用到的Apache库修改","id":"6网络使用到的apache库修改","depth":2,"charIndex":583},{"text":"7. 修复MaterialStickerFragment贴图素材下载使用了apache的HTTPClient导致release版本没法请求到服务器的问题","id":"7-修复materialstickerfragment贴图素材下载使用了apache的httpclient导致release版本没法请求到服务器的问题","depth":2,"charIndex":631},{"text":"8.【升级到到target28】base64 API不使用Apache的API改为Android 的API","id":"8升级到到target28base64-api不使用apache的api改为android-的api","depth":2,"charIndex":711}],"domain":"","frontmatter":{"title":"Target 28遇到的问题","date":"2019-10-18T09:15:26.000Z","categories":["Android"],"tags":["Android","TargetSDK28"]},"version":""},{"id":14,"title":"涂鸦功能","content":"#\n\n\n创建图形#\n\n由各个事项定义好的图形对象实现draw方法来画出对应图形。\n\n如下圆形对象的定义：\n\n\n\n其中x1,x2,x2,y2的含义是手势触摸移动的坐标\n\n\n\n其他图示类似方法来定义。\n\n五角星需要数学知识计算如何画图形。\n\n通过Canvas对象来画对应的形状：\n\n\n\n\n画笔类型#\n\n画笔类型分为：\n\n * 普通\n * 模糊\n * 浮雕\n * 橡皮擦\n\n\n画笔实现方式#\n\n画笔对象：android.graphics.Paint\n\n> 普通画笔\n\nPlainPen：设置Paint.Style.STROKE\n\n> 模糊\n\nBlurPen: 设置Paint.Style.STROKE，设置maskFilter\n\n\n\n> 浮雕\n\nEmbossPen ：设置Paint.Style.STROKE，设置maskFilter\n\n\n\n> 橡皮擦\n\nEraser：设置PorterDuffXfermode为PorterDuff.Mode.DST_OUT\n\n\n\n结合手势move坐标创建Path然后画贝塞尔曲线\n\n\n\n之后画橡皮曲线\n\n\n\n\n代码位置#\n\n","routePath":"/blog/2020-03-10-涂鸦功能","lang":"","toc":[{"text":"创建图形","id":"创建图形","depth":2,"charIndex":3},{"text":"画笔类型","id":"画笔类型","depth":2,"charIndex":141},{"text":"画笔实现方式","id":"画笔实现方式","depth":3,"charIndex":184},{"text":"代码位置","id":"代码位置","depth":2,"charIndex":469}],"domain":"","frontmatter":{"layout":"post","title":"涂鸦功能","date":"2020-03-10T03:44:00.000Z","categories":"paint 涂鸦 截屏","tags":"paint 涂鸦 截屏","author":"林建有"},"version":""},{"id":15,"title":"Target29修改点","content":"Android 10 引入了大量变更\n\n\n重大隐私权变更#\n\n    隐私权变更                                           受影响的应用                    缓解策略\n√   分区存储 针对外部存储的过滤视图，可提供对特定于应用的文件和媒体集合的访问权限         访问和共享外部存储中的文件的应用          使用特定于应用的目录和媒体集合目录 了解详情\n√   增强了用户对位置权限的控制力 仅限前台权限，可让用户更好地控制应用对设备位置信息的访问权限   在后台时请求访问用户位置信息的应用         确保在没有后台位置信息更新的情况下优雅降级 使用 Android 10 中引入的权限在后台获取位置信息 了解详情\n√   系统执行后台 Activity 针对从后台启动 Activity 实施了限制          不需要用户互动就启动 Activity 的应用   使用通知触发的 Activity 了解详情\n√   不可重置的硬件标识符 针对访问设备序列号和 IMEI 实施了限制                访问设备序列号或 IMEI 的应用         使用用户可以重置的标识符 了解详情\n√   无线扫描权限 访问某些 WLAN、WLAN 感知和蓝牙扫描方法需要获得精确位置权限       使用 WLAN API 和蓝牙 API 的应用   针对相关使用场景请求 ACCESS_FINE_LOCATION 权限 了解详情\n\n\n外部存储访问权限范围限定为应用文件和媒体#\n\n为了让用户更好地管理自己的文件并减少混乱，以 Android 10（API 级别\n29）及更高版本为目标平台的应用在默认情况下被赋予了对外部存储设备的分区访问权限（即分区存储）。此类应用只能看到本应用专有的目录（通过\nContext.getExternalFilesDir() 访问）以及特定类型的媒体。除非您的应用需要访问存放在应用的专有目录以及 MediaStore\n之外的文件，否则最好使用分区存储。\n\n下表总结了分区存储如何影响文件访问：\n\n文件位置              所需权限                                    访问方法 (*)                卸载应用时是否移除文件？\n特定于应用的目录          无                                       getExternalFilesDir()   是\n媒体集合 （照片、视频、音频）   READ_EXTERNAL_STORAGE （仅当 访问其他应用的文件时）   MediaStore              否\n下载内容 （文档和 电子书籍）   无                                       存储访问框架 （加载系统的文件选择器）     否\n\n*您可以使用存储访问框架访问上表中显示的每一个位置，而无需请求任何权限。\n\n\n存储的数据库读些和视频文件读写受到影响#\n\n解决办法:\n\n> 数据库存储目录:\n\n修改数据库存储目录变为应用专有的目录（卸载应用，数据库将会被删除）。\n\n\n\n> 录制保存视频目录\n\n录制保存视频文件放置在应用专有的目录的movie下\n\n\n\n\n\n> 素材目录：\n\n\n\n> 图片缓存目录\n\n\n\n> 更多路径修改：请查看FileManager.java文件代码，和SettingFragment的保存视频路径的改动代码\n\n\nAndroid 10 录制视频创建视频方式#\n\n> 通过MediaStore API\n> 存储文件：获得保存文件URI，然后获得parcelFileDescriptor传递给录制MediaMuxer，注意ParcelFileDescriptor可\n> 能在录制开始之前被close回收导致录制失败，所以不要先获取内部的ParcelFileDescriptor.getFileDescriptor()，先做参数\n> 传递下去，最后在创建MediaMuxer是获取FileDescriptor\n\n\n\n\n\n\n从 Android 10 开始，将弃用 android.preference 库#\n\n开发者应该改为使用 AndroidX preference 库，这是 Android Jetpack\n的一部分。如需获取其他有助于迁移和开发的资源，请查看经过更新的设置指南以及我们的公开示例应用和参考文档。\n\n解决方案：\n\n修改preference类库\n\n\n非 SDK 接口 限制#\n\nStickyGridHeadersGridView类使用了反射机制调用了AndroidSDK里非公开的代码，导致崩溃：\n\n> 反射调用地方\n\n\n\n> 奔溃日志：\n\n\n\n> 解决方法使用了RecycleView的方式替换，引入了新框架库：\n\n\n\n使用其LayoutManager方式达到相同的显示效果。[项目地址链接](https://github.com/TonicArtos/SuperSLiM/wik\ni/Getting started with version 0.4)\n\n\n加载图片预览#\n\n> 图片预览\n\n在Android 10 以上无法直接使用file\npath创建视频预览图了，需要使用mediaStoreAPI的**getContentResolver().loadThumbnail（）**去生成bitmap\n\n\n\n\n测试存储变更：选择停用分区存储#\n\n> 警告：明年，主要平台版本将要求所有应用都使用分区存储，无论应用的目标 SDK 级别是多少。因此，您应该提前确保您的应用能够使用分区存储。为此，请确保针对搭载\n> Android 10（API 级别 29）及更高版本的设备启用了该行为。\n\n在您的应用完全兼容分区存储之前，您可以根据应用的目标 SDK 级别或 requestLegacyExternalStorage 清单属性，暂时选择停用分区存储：\n\n * 以 Android 9（API 级别 28）或更低版本为目标平台。\n * 如果以 Android 10 或更高版本为目标平台，请在应用的清单文件中将 requestLegacyExternalStorage 的值设为 true：\n\n\n\n要测试以 Android 9 或更低版本为目标平台的应用在使用分区存储时的行为，您可以通过将 requestLegacyExternalStorage 的值设为\nfalse 来选择启用该行为。\n\n\nAndroid 10 录制视频前台服务权限需要改动#\n\n> Android 10在录制视频的前台服务里必须要调用startForeground(int id, @NonNull Notification\n> notification, @ForegroundServiceType int foregroundServiceType)\n> \n> 即：service中开启通知时增加ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION参数\n\n\n\n> 或者在服务里头添加 android:foregroundServiceType=\"mediaProjection\"标记，\n> 否则未添加该参数针对target29会崩溃。\n\n\n\n> 获取MediaProjection方式也要改动：不能再Activity里获取了，需要在有android:foregroundServiceType=\"med\n> iaProjection\"标记的服务里头获取mediaProjection对象\n\n\n\n> 截屏涂鸦功能也类似的需要在xml的FloatService\n> 添加android:foregroundServiceType=\"mediaProjection\"标记，并且要有通知栏标记\n> startForeground(int id, @NonNull Notification notification,\n> @ForegroundServiceType int foregroundServiceType)","routePath":"/blog/2020-03-31日-安卓Target29API升级修改点","lang":"","toc":[{"text":"存储的数据库读些和视频文件读写受到影响","id":"存储的数据库读些和视频文件读写受到影响","depth":2,"charIndex":1300}],"domain":"","frontmatter":{"layout":"post","title":"Target29修改点","date":"2020-03-31T08:16:00.000Z","categories":"应用Android10升级 target29","tags":"Android API target29","author":"林建有"},"version":""},{"id":16,"title":"Firebase 云消息传递","content":"Firebase消息推送配置#\n\n\n配置接入firebase SDK#\n\n> 增加Google gradle插件：在根级（项目级）Gradle 文件 (build.gradle)\n\n\n\n> 在app module的grdle下添加\n\n\n\n> 添加firebase SDK到应用依赖\n\n\n\n\n下载google-services.json文件#\n\n从firebase 控制台创建firebase项目，然后获取google-services.json文件配置，放置到app项目变体目录里\n\n\n代码接入#\n\n\n修改应用清单#\n\n> 在Manifest 添加一项继承 FirebaseMessagingService 的服务 ，该服务用于接收消息自自定义处理\n> \n> 除接收应用通知外，如果您还希望在后台进行更多的消息处理工作，则必须添加此服务。要接收前台应用中的通知、接收数据负载以及发送上行消息等，您必须继承此服务。\n\n\n\n> 可选配置meta-data 通知的icon和文字颜色，还有通知渠道配置\n\n\n\n\n测试所需令牌代码#\n\n> 添加便于测试发送消息时需要的令牌：获取令牌代码\n\n\n\n\n消息处理#\n\n\nAPP未启动或在后台运行情况，消息处理#\n\n该种情况下firebase会自动生成一个notification\n到通知栏，并把数据负载在点击了通知后传递给app启动器的activity的intent的extras里面。\n\n所以需要在启动器activity里接收firebase的extras字段获取消息数据，都是字符型。\n\n\n\n\nAPP已启动且在前台运行情况，消息处理#\n\n该种情况下firebase会把消息传递给自定义继承的FirebaseMessagingService 的服务里的onMessageReceived方法里\n\n\n\n\n为客户端订阅主题（用于firebase后台定向推送）#\n\n> 若要订阅某个主题，客户端应用需使用 FCM 主题名称调用 Firebase 云消息传递的 subscribeToTopic() 方法。此方法会返回一个\n> Task，完成监听器可以使用它来确定订阅是否成功, 若要退订，客户端应用需使用主题名称调用 Firebase 云消息传递的\n> unsubscribeFromTopic() 方法。\n\n","routePath":"/blog/2020-08-06-Android-Firebase-云消息传递","lang":"","toc":[{"text":"配置接入firebase SDK","id":"配置接入firebase-sdk","depth":2,"charIndex":17},{"text":"下载google-services.json文件","id":"下载google-servicesjson文件","depth":2,"charIndex":144},{"text":"修改应用清单","id":"修改应用清单","depth":2,"charIndex":250},{"text":"测试所需令牌代码","id":"测试所需令牌代码","depth":2,"charIndex":451},{"text":"APP未启动或在后台运行情况，消息处理","id":"app未启动或在后台运行情况消息处理","depth":2,"charIndex":500},{"text":"APP已启动且在前台运行情况，消息处理","id":"app已启动且在前台运行情况消息处理","depth":2,"charIndex":664}],"domain":"","frontmatter":{"layout":"post","title":"Firebase 云消息传递","date":"2020-08-06T08:48:00.000Z","categories":"Firebase massage 云消息传递","tags":"Firebase massage 云消息传递","author":"林建有"},"version":""},{"id":17,"title":"Android手机间传输共享文件","content":"#\n\n * 蓝牙\n * WLAN（wifi）\n   * 1、Wifi-直连（p2p）\n   * 2、手机wifi热点\n   * 3、通过连接到同一WIFI路由器\n     * 1、socket直接传输（启用Android网络发现服务获取IP地址和端口）\n     * 2、http协议搭建网站服务）","routePath":"/blog/2020-09-27-Android手机间传输共享文件","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"Android手机间传输共享文件","date":"2020-09-27T07:33:00.000Z","categories":"Android share-file p2p-share wifi WLAN hotspot","tags":"Android share p2p-share wifi WLAN hotspot"},"version":""},{"id":18,"title":"Android 前台服务和通知相关排查","content":"前台服务和通知相关排查#\n\n\nVRecorder涉及到的前台服务#\n\n主版本VRecorder targetSDK已经是28（Android P，API 9）#\n\n * FloatWindowService.java\n   \n   应用打开后，创建悬浮球依赖的前台服务，同时会在通知栏创建前台服务通知。\n   \n   \n   \n   因为是target 28，所有Manifest里配置了权限前台服务权限\n   \n   \n\n * StartRecorderService.java\n   \n   该服务是录制时打开的后台服务，在Android P以下没有独立打开通知，不属于前台服务。\n\n\n退出APP主动关闭服务和通知#\n\n\n\n\n通知栏的创建涉及到的channel ID和channel Name#\n\n * StartRecordNotifications.java 录制通知栏专属类\n\n创建该类的时候就一并创建通知渠道id和渠道名称\n\n\n\n创建渠道id和名称\n\n\n\n\nTarget 29（Android 10 ）前台服务的升级#\n\n前台服务在Manifest里的升级增加android:foregroundServiceType属性#\n\n依然需要前台服务权限声明\n\n\n\n代码里的打开前台服务升级#\n\n开启前台服务时需要添加参数foregroundServiceType使用如下方法\n\nstartForeground(int id,Notification notification,int foregroundServiceType)\n\nVRecorder使用案例：在FloatWindowService.java和StartRecorderService.java里都需要调用\n\n\n\n代码里关闭服务升级#\n\n在FloatWindowService.java里退出APP时：\n\n","routePath":"/blog/2020-6-4-前台服务和通知相关排查","lang":"","toc":[{"text":"`VRecorder`涉及到的前台服务","id":"vrecorder涉及到的前台服务","depth":2,"charIndex":-1},{"text":"主版本`VRecorder` `targetSDK`已经是28（Android P，API 9）","id":"主版本vrecorder-targetsdk已经是28android-papi-9","depth":4,"charIndex":-1},{"text":"退出APP主动关闭服务和通知","id":"退出app主动关闭服务和通知","depth":2,"charIndex":294},{"text":"通知栏的创建涉及到的channel ID和channel Name","id":"通知栏的创建涉及到的channel-id和channel-name","depth":2,"charIndex":314},{"text":"前台服务在Manifest里的升级增加`android:foregroundServiceType`属性","id":"前台服务在manifest里的升级增加androidforegroundservicetype属性","depth":4,"charIndex":-1},{"text":"代码里的打开前台服务升级","id":"代码里的打开前台服务升级","depth":4,"charIndex":535},{"text":"代码里关闭服务升级","id":"代码里关闭服务升级","depth":4,"charIndex":743}],"domain":"","frontmatter":{"layout":"post","title":"Android 前台服务和通知相关排查","date":"2020-06-04T03:40:00.000Z","categories":"Android ForegroundService 前台服务 通知","tags":"Android  ForegroundService 前台服务 通知","author":"林建有"},"version":""},{"id":19,"title":"build.gradle里APK重命名方法","content":"#\n\n在APP的build.gradle文件里增加setArchivesBaseName属性方法代码\n\n\n\n定义getOutputBaseName方法：\n\n\n\n不再使用就的setOutput（）的android.productFlavors.all { flavor ->\n...}遍历方案，因为生成的APK没有实时的更新APK名称，还会导致编译生成APK时容易第一次出错，需要clear项目再编译才行的问题。","routePath":"/blog/2021-04-25-APK-Rename","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"build.gradle里APK重命名方法","date":"2021-04-25T07:18:00.000Z","categories":"APK rename","tags":"APK rename","author":"林建有"},"version":""},{"id":20,"title":"广告模块详解mopub广告等","content":"#\n\n模块名称：Adslibrary\n\n\n广告平台和广告类型#\n\n * 广告平台包含：Admob，Facebook ，Vungle，Mopub中介\n\n * 广告类型：\n   \n   * Admob的接入的广告类型有：\n     \n     插屏广告InterstitialAd，开屏广告（AppOpenAd），\n     \n     激励广告RewardedAd，原生广告UnifiedNativeAd\n   \n   * Facebook接入的广告类型有：\n     \n     原生广告NativeAd，激励广告RewardedVideoAd\n   \n   * Vungle接入广告类型有：插屏广告\n   \n   * Mopub接入的广告类型有：原生广告NativeAd，激励广告MoPubReward，插屏广告MoPubInterstitial\n\n\n广告模块架构#\n\n基础的广告类型加载和展示#\n\n类是放在basexxx目录下的，如下图。当钥匙用某个平台的广告是，就集成该类，然后实现对应的广告ID即可。\n\n\n\n广告渠道配比#\n\n渠道配比的控制基类是AdManagerBase.kt，具体继承实现可参考NativeForExportingHandler.kt类。\n\n实现了某个渠道配比控制类后需要在AdTrafficControl.onInitAd里设置获取到的服务器渠道变量给控制类。然后可以开始加载广告。\n\n\n\nAdTrafficControl.java是广告渠道配比请求和解析的类，需要传入预设的渠道参数配比传入请求参数里，才会返回渠道配比字段。\n\n\nMopub#\n\n\nmopub接入SDK依赖#\n\n\n\n\nmopub广告初始化#\n\n * mopub 的激励广告需要传递Activity类型的context进行初始化，否则不会加载激励广告。\n\n\n\n\nMopub加载广告和展示#\n\nmopub原生广告加载#\n\n\n\nmopub 原生广告展示#\n\n * 使用默认加载广告时定义的布局layoutIDViewBinder绑定的id时使用加载时的layoutID传入方法fun showAds(parent:\n   ViewGroup, layoutId: Int)\n\n * 如果是使用了自定义的新布局的视图id绑定，则新建一个ViewBinder类指定id然后调用如下方法展示广告\n   \n   fun showAds(parent: ViewGroup, viewBinder: ViewBinder, isBigAdMaterial:\n   Boolean)\n\n\n\nmopub 插屏广告加载#\n\n详细代码看MopubInterstitialBase.kt\n\n创建 MoPubInterstitial构造器时需要传入activity类型的context，所以需要在展示广告的界面临时加载\n\n\n\nmopub插屏展示#\n\n调用如下方法展示\n\n\n\nmopub激励广告#\n\n详情看RewardAdDialogFragment.java类型，该类集成了Admob，Facebook，mopub三家平台的激励广告逻辑","routePath":"/blog/2021-06-04-广告模块详解mopub广告等","lang":"","toc":[{"text":"广告平台和广告类型","id":"广告平台和广告类型","depth":2,"charIndex":20},{"text":"广告模块架构","id":"广告模块架构","depth":2,"charIndex":376},{"text":"基础的广告类型加载和展示","id":"基础的广告类型加载和展示","depth":4,"charIndex":385},{"text":"广告渠道配比","id":"广告渠道配比","depth":4,"charIndex":457},{"text":"Mopub","id":"mopub","depth":2,"charIndex":680},{"text":"mopub接入`SDK`依赖","id":"mopub接入sdk依赖","depth":3,"charIndex":-1},{"text":"mopub广告初始化","id":"mopub广告初始化","depth":3,"charIndex":707},{"text":"Mopub加载广告和展示","id":"mopub加载广告和展示","depth":3,"charIndex":778},{"text":"mopub原生广告加载","id":"mopub原生广告加载","depth":4,"charIndex":793},{"text":"mopub 原生广告展示","id":"mopub-原生广告展示","depth":4,"charIndex":809},{"text":"mopub 插屏广告加载","id":"mopub-插屏广告加载","depth":4,"charIndex":1084},{"text":"mopub插屏展示","id":"mopub插屏展示","depth":4,"charIndex":1197},{"text":"mopub激励广告","id":"mopub激励广告","depth":4,"charIndex":1221}],"domain":"","frontmatter":{"layout":"post","title":"广告模块详解mopub广告等","date":"2021-06-04T07:18:00.000Z","categories":"广告模块 mopub","tags":"mopub 广告模块","author":"林建有"},"version":""},{"id":21,"title":"MyLog 库的的使用","content":"#\n\nSDK简介#\n\n\n\n引入arr库#\n\n注：库里还包含了MVP架构\n\n\n\n源码地址：https://github.com/linjonh/MvpArch.git#\n\n举列#\n\n1、MyLog.e(sku);会打印如下格式\n\n![image-20210701162746215][image1]\n\n2、例如：MyLog.printCallerStackTrace()方法可以打印java 方法调用堆栈\n\n![image2][image2]\n\n3、MyLog.e()还可以直接传入Exception对象，内部实现了打印输出错误堆栈的的信息。\n\n\n\n维护#\n\n最后如果这些方法不足以满足需要，若有新的需求，也可以修改源码在gitbub提交 pull request。","routePath":"/blog/MyLog 库的的使用","lang":"","toc":[{"text":"SDK简介","id":"sdk简介","depth":4,"charIndex":2},{"text":"引入arr库","id":"引入arr库","depth":4,"charIndex":12},{"text":"源码地址：https://github.com/linjonh/MvpArch.git","id":"源码地址httpsgithubcomlinjonhmvparchgit","depth":4,"charIndex":38},{"text":"举列","id":"举列","depth":4,"charIndex":84},{"text":"维护","id":"维护","depth":4,"charIndex":273}],"domain":"","frontmatter":{"title":"MyLog 库的的使用","author":"林建有","date":"2021-07-01T09:10:53.000Z","categories":["Android","utils"],"tags":["Android","utils"],"image":"https://api.vvhan.com/api/bing?rand=sj&t=mylog"},"version":""},{"id":22,"title":"如何创建Docusaurus网站","content":"#\n\n\n首先了解下什么是Docusaurus？#\n\nDocusaurus是指一个开源的构建文档项目，由Meta公司（旧名Facebook）开源维护。是一个静态网页生成器，类似于jekyll，hugo，Docsif\ny，VitePress等的静态生成器工具。\n\n\nDocusaurus有哪些特点#\n\n * 由 MDX 驱动\n   \n   节约时间并专注于文档本身。只需要以 Markdown/MDX 格式撰写文档/博客，Docusaurus 就能自动构建生成静态 HTML 文件。用 JSX\n   和 React 撰写交互组件，并将其嵌入 Markdown。\n\n * 使用 React 构建\n   \n   通过编写 React 组件来扩展和自定义你的网页布局。利用插件架构，你可以在设计自己的网站的同时，复用 Docusaurus 插件所创建的数据。\n\n * 可翻译\n   \n   开箱即用的本地化。使用 git、Crowdin 或任何其他翻译管理器来翻译你的文档并单独部署。\n\n * 文档版本化\n   \n   为你的用户提供所有版本的项目文档。版本化文档可让你的文档发布与项目发行时间保持一致。\n\n * 内容搜索\n   \n   让你的社区在文档中轻松找到他们需要的内容。我们支持 Algolia 文档搜索。\n\n\n开始上手#\n\n\n安装构建工具#\n\nDocusaurus由一组npm包组成，因而需要安装Node.js工具集。安装Node.js推荐使用nvm安装，nvm可以方便选择不同版本的Node.js，但版\n本要求在18.0 或以上。\n\n\n创建脚手架项目网站#\n\n安装 Docusaurus 最简单的方法是使用create-docusaurus命令行工具，它可以帮助你快速搭建一个 Docusaurus 网站的基础框架。\n你可以在空仓库或现有仓库的任何地方运行这个命令，它会创建一个包含模板文件的新目录。\n\n\n\n也可以增加--typescript参数来支持 TypeScript\n\n\n\nclassic参数是表示使用经典脚手架模版，classic template包含了\n@docusaurus/preset-classic模块，它具有标准文档，博客，自定义页面，和CSS框架（支持黑夜主题模式）的功能。\n\n除了上述方式创建模版项目外，也可以使用如下命令初始化项目：\n\n * npm\n\n\n\n * yarn\n\n\n\n * pnpm\n\n\n\n * bunx\n\n\n\n\n项目目录结构#\n\n假如使用脚手架工具创建了my-website项目后，会自动生成如下文件和目录结构：\n\n\n\n目录结构介绍：#\n\n * /blog/ :\n   包括了博客Markdown文件。你可以删除该目录以禁止使用博客插件功能，或者你可以当设置了path选项后，更改其名称，可以在博客指南中发掘更多详情。\n * /docs/\n   :包含了Markdown格式的文档文件.可以在sidebars.js自定义修改文档在侧边栏的顺序。你可以删除该目录以禁止使用文档插件功能，或者你可以当设置\n   了path选项后，更改其名称，可以在文档指南中发掘更多详情。\n * /src/ : 可以放置类似pages或自定义的React\n   components的非文档类文件。严格来说，你不一定要把非文档类文件放在这里。不过把它们放在一个集中的目录，可以让代码检查或者处理更为简便。\n * /src/pages : 在该目录的任何JSX/TSX/MDX文件都将被转化为网页页面。更多详情查看页面指南\n * /static/ : 静态目录。 在该目录里的任何内容都将会被拷贝到最终构建的根目录里。\n * /docusaurus.config.js : 一个包含了网站配置的配置文件。这相当于Docusaurus v1的siteConfig.js\n * /package.json : 一个Docusaurus 站点是一个React app. 你可以安装并使用任何 npm 包。\n * /sidebars.js : 用于指定文档的在侧边栏的顺序。\n\n在已有项目中创建Docusaurus网站（monorepos）#\n\n如果你打算用 Docusaurus 来给一个现有的项目搭建文档，单仓模式可能是一种解决方案。 单仓允许你在类似项目间共享依赖项。\n例如，您的网站可以使用本地软件包来展示最新功能，而不是依赖已发布的版本。 然后，您的贡献者可以在实现功能的同时更新文档。 下面是单仓模式文件夹结构的一个例子：\n\n\n\n在此样例中，你应该在./my-monorepo目录下运行npx create-docusaurus\n\n如果使用Netlify或Vercel托管网站的提供商时，需要修改指定网站的基础根目录，在该样例中根目录是./。 请在部署文档里查询更多配置。\n\n更多真实样例：Docusaurus 和 Jest\n\n更多关于monorepos：Yarn documentation (Yarn不是唯一的设置一个monorepo方式, 但却是一个常见的解决方案)。\n\n\n运行开发调试服务#\n\n要实时预览你的编辑，你可以运行本地开发服务器。它会部署你的网站，并反映最新更改。\n\n\n\n默认会在浏览器中打开地址 http://localhost:3000.\n\n恭喜！ 你刚刚成功创建了你的首个 Docusaurus 网站！ 四处逛逛，看看有什么功能吧。\n\n\nbuild构建#\n\nDocusaurus 是一款现代化的静态网页生成器。因此，我们需要将网站生成为静态内容，并上传到网络服务器，才能被其他人访问。 要构建站点，请使用以下命令：\n\n * npm:\n\n\n\n * yarm\n\n\n\n * pnpm\n\n\n\n * bun\n\n\n\n内容将被构建生成在/build目录，该目录下的文件就可以托管到静态文件托管服务的提供上网站上了，如：GitHub pages, Vercel 或\nNetlify，详情看deployment\n\n\n配置搜索#\n\nDocusaurus 已官方支持Algolia DocSearch。该服务是免费的，是针对于任何开发者文档和技术博客的，请确保符合Algolia\nDocSearch的要求：checklist，然后申请应用 apply to the DocSearch program\n\nDocsearch 每周一次爬取你的网站（可以在网页界面上配置具体时间），并将所有内容汇总到一个 Algolia 索引中。 随后，你的前端会调用 Algolia\nAPI 来直接查询这些内容。 如果你的网站不符合免费版托管DocSearch资质，或者你的网站是有防火墙且不是公开的，那么你可以运行你自己的爬虫程序 run\nyour own DocSearch crawler。\n\n如果是应用了预设的经典主题classic就会包含@docusaurus/preset-classic插件，会默认集成了Algolia\nDocSearch，就不需要额外安装任何东西。\n\n * npm\n\n\n\n * yarn, pnmp, bun\n\n\n\n2、docusaurus.config.js配置文件里注册主题\n\n\n\n> 首先你得在Apply for DocSearch 获取你的配置Algolia index and API key，之后会收到邮件告诉你如何将\n> DocSearch 添加到你的项目，可以编辑和管理你自己的爬虫配置：the web\n> interface。部署完毕后，索引就立即可用了，所以一般不需要手动配置。\n\n> 然后在项目配置里algolia字段增加搜索配置连接到Algolia：\n\n\n\n更多详细配置可查看搜索配置","routePath":"/blog/create-docusaurus-site","lang":"","toc":[{"text":"首先了解下什么是Docusaurus？","id":"首先了解下什么是docusaurus","depth":2,"charIndex":3},{"text":"Docusaurus有哪些特点","id":"docusaurus有哪些特点","depth":2,"charIndex":130},{"text":"开始上手","id":"开始上手","depth":2,"charIndex":555},{"text":"安装构建工具","id":"安装构建工具","depth":3,"charIndex":563},{"text":"创建脚手架项目网站","id":"创建脚手架项目网站","depth":3,"charIndex":669},{"text":"项目目录结构","id":"项目目录结构","depth":3,"charIndex":1027},{"text":"目录结构介绍：","id":"目录结构介绍","depth":4,"charIndex":1081},{"text":"在已有项目中创建Docusaurus网站（monorepos）","id":"在已有项目中创建docusaurus网站monorepos","depth":4,"charIndex":1695},{"text":"运行开发调试服务","id":"运行开发调试服务","depth":2,"charIndex":2102},{"text":"build构建","id":"build构建","depth":2,"charIndex":2243},{"text":"配置搜索","id":"配置搜索","depth":2,"charIndex":2473}],"domain":"","frontmatter":{"title":"如何创建Docusaurus网站","date":"2025-04-16T03:29:29.000Z","categories":["docs","website"],"tags":["docusaurus","website","文档构建"],"image":"https://api.vvhan.com/api/bing?rand=sj&t=1744977029292"},"version":""},{"id":23,"title":"如何使用hugo框架生成静态网页","content":"#\n\n\nhugo介绍#\n\nhugo是一个静态网页生成器工具，官方声称是世界上最快的构建网页的框架。也是一个最流行的开源静态网站生成器。凭借器惊人的速度和灵活性，让构建网站变得再次有趣。它\n的底层实现使用go语言开发，相比jekyll框架，hugo更适合构建拥有大量文章的大型网站。因为正如官方所说的，是世界上最快的构建框架。得益于go语言的运行效率\n。\n\n\n开始使用#\n\n\n安装hugo工具#\n\nhugo的版本分三种： 标准，扩展，扩展与部署（standard, extended, and extended/deploy.） 区别如下：\n\n功能                                                   EXTENDED 版本   EXTENDED/DEPLOY 版本\n当处理图片时，会把图片编码为WebP格式。你可以用任何版本都能解码WebP图片。             ✔️            ✔️\n使用内嵌的LibSass转义器将Sass转义为CSS，你可以使用任何版本的Dart Sass转义器。   ✔️            ✔️\n你可以直接部署你的网站至Google Cloud Storage bucket，一个AWS S3     ❌             ✔️\nbucket，或者是一个Azure Storage container。\n\n如果你已经有其他工具的部署方案而不需要hugo的extended/deploy版本，那么推荐使用extended版本。\n\n * 安装Windows平台\n   \n   * 1、使用包管理器安装\n     \n     * Chocolatey\n       \n       Chocolatey 是一个免费开源的windows包管理器，安装hugo的extended命令如下：\n       \n       \n       \n       注意\n       \n       \n     \n     * Scoop Scoop 也是一个免费开源的windows包管理器，安装hugo的extended命令如下：\n       \n       \n     \n     * Winget Winget 是微软官方的免费开源windows包管理，安装hugo的extended命令如下：\n       \n       \n       \n       卸载hugo的extended版本：\n       \n       \n   \n   * 2、使用已经编译好的二进制程序安装 预编译好的版本支持各个平台和系统架构，访问latest\n     release网页，滑动到底部资源部分，选择下载适合的版本包文件，解压后安装到你希望的目录下，安装完成后，将安装目录添加到PATH系统环境变量中。新启\n     动一个终端，运行hugo version验证安装版本。\n   \n   * 3、从源码自行编译安装\n     \n     首先需要满足如下条件：\n     \n     * 安装Git版本管理工具\n     * 安装Go语言版本 1.23.0或更高版本\n     * 安装一个C语言编译器，如GCC或者Clang\n     * 更新Go文档里提到的PATH环境变量\n     \n     标准版编译：\n     \n     \n     \n     扩展版本编译：\n     \n     \n     \n     扩展/部署版本编译：\n     \n     \n   \n   安装方式比较：\n   \n             PREBUILT BINARIES   PACKAGE MANAGERS   BUILD FROM SOURCE\n   容易安装?     ✔️                  ✔️                 ✔️\n   容易升级?     ✔️                  ✔️                 ✔️\n   容易降级?     ✔️                  ✔️                 ✔️\n   自动升级?     ❌                   ❌                  ❌\n   可用最新版本?   ✔️                  ✔️                 ✔️\n\n * Linux平台\n   \n   * 1、使用包管理器安装\n     \n     * Snap\n       \n       Snap是一个免费开源的Linux包管理器，snap包是很容易安装的，而且是会自动升级的。\n       \n       Hugo Snap 软件包受到严格限制。严格限制的 Snap\n       软件包在完全隔离的环境中运行，并保持最低访问级别，以确保始终安全。您创建和构建的网站必须位于您的主目录中，或位于可移动介质上。\n       \n       安装extended版本：\n       \n       \n       \n       启用或回收可移动介质访问权限：\n       \n       \n       \n       启用或回收SSH keys访问权限：\n       \n       \n     \n     * Homebrew\n       \n       Homebrew是一个免费开源的macOS和Linux包管理器， 安装hugo extended版本：\n       \n       \n   \n   * 2、不同Linux系统的仓库包方式安装\n     \n     Linux也分为各种发行版本的系统，选择适合你的Linux版本方式安装：(以安装extended版本为例)\n     \n     * Alpine Linux\n       \n       \n     \n     * Arch Linux\n       \n       分发系统包括EndeavourOS, Garuda Linux, Manjaro, and others.系统\n       \n       \n     \n     * Debian\n       \n       分发系统包括elementary OS, KDE neon, Linux Lite, Linux Mint, MX Linux, Pop!_OS,\n       Ubuntu, Zorin OS, and others.\n       \n       \n     \n     * Exherbo\n       \n       1、Add this line to /etc/paludis/options.conf:\n       \n       \n       \n       2、Install using the Paludis package manager:\n       \n       \n     \n     * Fedora\n       \n       分发系统包括 CentOS, Red Hat Enterprise Linux, and others.\n       \n       \n     \n     * Gentoo\n       \n       分发系统包括 Calculate Linux, Funtoo, and others.\n       \n       1、指定扩展USE标记 到/etc/portage/package.use/hugo里面:\n       \n       \n       \n       2、Build using the Portage package manager:\n       \n       \n     \n     * NixOS\n       \n       \n     \n     * openSUSE\n       \n       分发系统包括 GeckoLinux, Linux Karmada, and others.\n       \n       \n     \n     * Solus\n       \n       \n     \n     * Void Linux\n       \n       \n   \n   * 3、从源码编译安装hugo\n     \n     先决条件类似windows：\n     \n     * 安装Git版本管理工具\n     * 安装Go语言版本 1.23.0或更高版本\n     * 安装一个C语言编译器，如GCC或者Clang\n     * 更新Go文档里提到的PATH环境变量\n     \n     但是环境变量需要注意：\n     \n     注意\n     \n     安装目录是由GOPATH and GOBIN环境变量控制. 如果设置了GOBIN，二进制文件是安装在该目录下。 如果设置了 GOPATH ,\n     二进制文件会安装在GOPATH列表里的第一个目录的bin子目录下。 否则二进制文件会安装在默认的GOPATH ($HOME/go or\n     %USERPROFILE%\\go)的bin子目录下。\n     \n     标准版编译：\n     \n     \n     \n     扩展版本编译：\n     \n     \n     \n     扩展/部署版本编译：\n     \n     \n   \n   * 安装方式比较\n     \n               预编译二进制   包管理器安装   仓库包安装   从源码安装\n     容易安装?     ✔️       ✔️       ✔️      ✔️\n     容易升级?     ✔️       ✔️       各种各样    ✔️\n     容易降级?     ✔️       ✔️       各种各样    ✔️\n     自动升级?     ❌        各种各样     ❌       ✔️\n     可用最新版本?   ✔️       ✔️       各种各样    ✔️\n\n\nhugo项目目录结构#\n\n每个 Hugo 项目都是一个目录，其中包含有助于您网站的内容、结构、行为和呈现的子目录。\n\n网站骨架#\n\n使用hugo命令创建一个站点，会自动生成项目目录结构骨架：\n\n\n\n生成的目录结构：\n\n\n\n取决于需要，你可能希望组织你的网站配置到子目录\n\n\n\n当编译你的网站时，hugo会生成一个Public目录，通常还会创建一个特别的resource目录：\n\n\n\n骨架目录介绍#\n\narchetypes（原型模板）\n\n * archetypes 目录包含新建内容时使用的模板。\n\nassets（资源）\n\n * assets 目录包含全局资源，通常通过资源管道进行处理。这些资源包括图片、CSS、Sass、JavaScript 和 TypeScript 文件。\n\nconfig（配置）\n\n * config 目录包含你的网站配置，可能分为多个子目录和文件。如果是配置简单或者不需要根据不同环境变化的项目，可以在项目根目录只用一个名为\n   hugo.toml 的配置文件即可。\n\ncontent（内容）\n\n * content 目录包含组成你网站内容的标记文件（通常是 Markdown）和页面资源。\n\ndata（数据）\n\n * data 目录包含数据文件（支持 JSON、TOML、YAML 或 XML 格式），用于扩展内容、配置、本地化和导航。\n\ni18n（国际化）\n\n * i18n 目录包含多语言网站使用的翻译表。\n\nlayouts（布局模板）\n\n * layouts 目录包含将内容、数据和资源转化为完整网站所需的模板。\n\npublic（发布目录）\n\n * public 目录包含生成的网站内容，当你运行 hugo 或 hugo server 命令时生成。Hugo 会根据需要重建该目录及其内容。\n\nresources（资源缓存）\n\n * resources 目录包含 Hugo 资源管道处理后生成的缓存输出，如 CSS 和图片。每次运行 hugo 或 hugo server\n   命令时会根据需要重建此目录及其内容。\n\nstatic（静态文件）\n\n * static 目录中的文件会在构建网站时直接复制到 public 目录。例如：favicon.ico、robots.txt\n   以及验证站点所有权所需的文件。在引入页面包（Page Bundles）和资源管道之前，static 目录也常用于存放图片、CSS 和\n   JavaScript。\n\nthemes（主题）\n\n * themes 目录包含一个或多个主题，每个主题在自己的子目录中。\n\n联合文件系统#\n\nhugo创建一个联合文件系统，运行你去挂载两个或更多目录到相同的目录下。例如，假设你的Home主目录中包含了一个hugo项目目录，在另一个目录下包含共享目录：\n\n\n\n当你用挂着方式构建你的网站时，你可以包含这个共享目录。在你的网站配置中如下配置即可：(选择toml，yaml，json三种方式配置其一)\n\n * hugo.toml\n\n\n\n * hugo.yaml\n\n\n\n * hugo.json\n\n\n\n注意\n\n当您将一个目录覆盖在另一个目录之上时，必须同时挂载这两个目录。 Hugo 不遵循符号链接。如果您需要符号链接提供的功能，请使用 Hugo 的联合文件系统。\n\n挂载后，联合文件系统就有如下目录结构：\n\n\n\n你可以挂载目录到 archetypes, assets, content, data, i18n, layouts, and static。\n\n也可以使用hugo modules从git仓库挂载目录。\n\n主题骨架#\n\n创建主题命令：\n\n\n\n创建的目录结构如下（子目录未展示）：\n\n\n\nHugo\n使用上述联合文件系统，将每个目录挂载到项目中的相应位置。当两个文件具有相同路径时，项目目录中的文件优先。例如，这允许您通过将副本放置在项目目录中的相同位置来覆盖\n主题的模板。\n\n如果您同时使用来自两个或多个主题或模块的组件，并且发生路径冲突，则第一个挂载的文件优先。\n\n\nhugo构建web#\n\n构建命令：\n\n\n\n开发调试命令：(包含热加载)\n\n\n\n开发调试，自动定位到最后修改处\n\n\n\n构建网页时，front matter里指定的时间是未来文章，草稿标记的文章，过期时间文章，发布时间文章不会被构建（draft, date,\npublishDate, and expiryDate ）。如果需要覆盖默认构建行为，加上参数：\n\n\n\n\n发布部署web#\n\n编译生产环境：\n\n * Linux下：\n\n\n\n或\n\n\n\n * windows\n\npowershell\n\n\n\ncmd\n\n\n\n或\n\n\n\n最终会生成编译后的内容到public目录下，将该目录下的文件发布到网站托管平台，如 AWS Amplify, CloudCannon, Cloudflare\nPages, GitHub Pages, GitLab Pages, Netlify, firebase hosting等。","routePath":"/blog/create-hugo-website","lang":"","toc":[{"text":"hugo介绍","id":"hugo介绍","depth":2,"charIndex":3},{"text":"开始使用","id":"开始使用","depth":2,"charIndex":178},{"text":"安装hugo工具","id":"安装hugo工具","depth":3,"charIndex":186},{"text":"hugo项目目录结构","id":"hugo项目目录结构","depth":3,"charIndex":4208},{"text":"网站骨架","id":"网站骨架","depth":4,"charIndex":4267},{"text":"骨架目录介绍","id":"骨架目录介绍","depth":4,"charIndex":4399},{"text":"联合文件系统","id":"联合文件系统","depth":4,"charIndex":5297},{"text":"主题骨架","id":"主题骨架","depth":4,"charIndex":5715},{"text":"hugo构建web","id":"hugo构建web","depth":3,"charIndex":5896},{"text":"发布部署web","id":"发布部署web","depth":3,"charIndex":6077}],"domain":"","frontmatter":{"title":"如何使用hugo框架生成静态网页","date":"2025-04-18T02:07:54.000Z","categories":["docs","website"],"tags":["hugo","website","文档构建"],"image":"https://api.vvhan.com/api/bing?rand=sj&t=1744977000331"},"version":""},{"id":24,"title":"如何使用jekyll框架生成静态网页","content":"","routePath":"/blog/create-jekyll-website","lang":"","toc":[],"domain":"","frontmatter":{"title":"如何使用jekyll框架生成静态网页","date":"2025-04-18T03:18:42.000Z","categories":["docs","website"],"tags":["jekyll","website","文档构建"],"image":"https://api.vvhan.com/api/bing?rand=sj&t=1744977040682"},"version":""},{"id":25,"title":"Firebase hosting托管网页","content":"#\n\n\n\n\n介绍#\n\nFirebase Hosting 可为您的 Web 应用提供快速、安全的托管服务。\n\nFirebase Hosting 是面向开发者的生产级 Web 内容托管服务。您只需运行一个命令，便可轻松快捷地将 Web 应用部署到全球级\nCDN（内容分发网络）中。\n\n虽然 Firebase Hosting 针对静态和单页 Web 应用进行了优化，不过，您还可以将 Firebase Hosting 与 Cloud\nFunctions 或 Cloud Run 搭配使用，在 Firebase 上构建和托管动态内容和微服务。\n\n无论您是在部署一个简单的应用着陆页，还是部署复杂的渐进式 Web 应用 (PWA)，Hosting\n均为您提供了专为部署和管理网站和应用而特别开发的基础架构、功能和工具。\n\n使用 Firebase CLI，您可以从计算机上的本地目录将文件部署到我们的 Hosting 服务器。除了提供静态内容之外，您还可以使用 Cloud\nFunctions for Firebase 或 Cloud Run 在您的网站上提供动态内容和托管微服务。所有内容都可从我们的全球级 CDN\n上最近的边缘服务器通过 SSL 连接提供。\n\n您还可以在上线前查看和测试更改。 使用 Firebase Local Emulator\nSuite，您可以通过本地托管的网址模拟您的应用和后端资源。您还可以使用临时预览网址共享更改，并设置 GitHub 集成，以便在开发期间轻松迭代。\n\nFirebase Hosting 具有轻量级托管配置选项，支持您构建精密的\nPWA。您可以轻松为客户端路由重新编写网址、设置自定义标头，甚至可以提供本地化的内容。\n\n为了分发您的内容，Firebase 提供了多个网域和子网域选项：\n\n默认情况下，每个 Firebase 项目在 web.app 和 firebaseapp.com 网域上都有免费的子网域。这两个网站提供相同的已部署内容和配置。\n\n如果您拥有提供不同内容但仍共享相同 Firebase 项目资源的相关网站和应用（例如，如果您有博客、管理面板和公开应用），则可以创建多个网站。\n\n您可以将自己的域名关联到 Firebase 托管的网站。\n\nFirebase 会自动为您的所有网域预配 SSL 证书，确保安全提供您的所有内容。\n\n\n创建一个firebase hosting#\n\n\n1、准备工作#\n\n首先您必须在谷歌的firebase后台先创建一个 Firebase 项目，然后才能设置 Firebase Hosting。\n\n\n2、安装 Firebase CLI 命令行工具#\n\nFirebase CLI (GitHub) 提供了各种用于管理、查看 Firebase 项目并在其中进行部署的工具。 以Linux为例的npm安装方式：\n\n\n\n之后登录firebase：\n\n\n\n查看登录账号下的项目\n\n\n\n更多详情参阅 Firebase CLI 文档，了解如何安装 CLI 或将其更新为最新版本。\n\n\n3、初始化你的本地项目#\n\n如需将本地项目文件与 Firebase 项目关联，请从本地项目目录的根目录下运行以下命令：\n\n\n\n在项目初始化期间，请按照 Firebase CLI 提示执行以下操作：\n\n * 选择一个 Firebase 项目以与您的本地项目目录关联。\n   \n   选定的 Firebase 项目是本地项目目录的“默认”Firebase 项目。要将其他 Firebase 项目关联到本地项目目录，请设置项目别名。\n\n * 指定用作公共根目录的目录。\n   \n   此目录包含您公开提供的所有静态文件，包括 index.html 文件以及要部署到 Firebase Hosting 的所有其他资产。\n   \n   * 公共根目录的默认名称为 public。\n     \n     * 您可以立即指定公共根目录，也可以稍后指定（在您的 firebase.json 配置文件中）。\n     \n     * 如果您选择默认值并且还没有名为 public 的目录，Firebase 会为您创建该目录。\n   \n   * 如果您的公共根目录中不存在有效的 index.html 文件或 404.html 文件，Firebase 会为您创建一个。\n\n * 为您的网站选择配置。\n   \n   如果您选择制作一个单页应用，Firebase 会自动为您添加重写配置。\n\n在初始化结束时，Firebase 会自动创建两个文件，并将其添加到本地应用目录的根目录下：\n\n * firebase.json 配置文件，其中列出了您的项目配置。如需详细了解此文件，请参阅配置托管行为页面。\n\n * .firebaserc 文件，其中存储有项目别名。\n\n\n4、部署到您的网站#\n\n要部署到您的网站，请从本地项目目录的根目录下运行以下命令：\n\n\n\n> 注意：如果运行带有 --only hosting 标志的此命令，您部署的只是您的 Hosting\n> 内容和配置。如果您还希望部署其他项目资源或配置（例如函数或数据库规则），请运行此命令，并在标志中使用逗号分隔列表（例如 --only\n> hosting,functions）。\n\n此命令会将您的 Hosting 内容和配置部署到以下 Firebase 预配的子网域：\n\n * PROJECT_ID.web.app\n * PROJECT_ID.firebaseapp.com\n\n详细了解如何部署并在本地测试您的网站。","routePath":"/blog/firebase-web-hosting","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":5},{"text":"创建一个firebase hosting","id":"创建一个firebase-hosting","depth":2,"charIndex":990},{"text":"1、准备工作","id":"1准备工作","depth":3,"charIndex":1014},{"text":"2、安装 Firebase CLI 命令行工具","id":"2安装-firebase-cli-命令行工具","depth":3,"charIndex":1087},{"text":"3、初始化你的本地项目","id":"3初始化你的本地项目","depth":3,"charIndex":1272},{"text":"4、部署到您的网站","id":"4部署到您的网站","depth":3,"charIndex":1992}],"domain":"","frontmatter":{"title":"Firebase hosting托管网页","date":"2025-04-17T02:34:34.000Z","categories":["docs","website"],"tags":["firebase","hosting","web"],"image":"https://api.vvhan.com/api/bing?rand=sj&t=1744977051515"},"version":""},{"id":26,"title":"Github pages托管网页","content":"#\n\n\n介绍#\n\nGithub\npages默认支持Jekyll静态网页生成器，也就是说你的github上的某个仓库如果包含了docs或public网页内容或markdown文件内容，会以Jek\nyll方式编译网站自动托管到Github pages上。域名将会是\nusername.gihub.io/repo/，username替换成你的github账号名,repo替换成你的仓库名。\n\n如果仓库名为username.gihub.io，这也正式你的github pages的首页域名，也是创建github pages必需创建的公开仓库！\n\n\n开始#\n\n\n1、启用github pages#\n\n * 创建站点仓库\n   \n   创建一个.github.io或.gihub.io仓库。在项目settings设置里的pages配置里，设置分发pages分支和目录作为pages托管目录。\n\n\n2、使用jekyll框架#\n\n如果目录是直接可以托管而不需要编译的内容，需要增加.nojekyll文件标记。然后github就不会自动jekyll编译该目录了。直接会分发到pages托管服务\n上。\n\n如果需要编译，则按照jekyll框架目录来创建docs文档项目。或者可以使用其他构建框架构建项目，然后提交到settings设置里pages设置的分支和目录下，\n就可以托管了。\n\n\n发布#\n\nGithub pages会寻找index.html、index.md 或 README.md 文件作为站点的入口文件。\n\n * 默认分支和目录发布\n   \n   把需要托管的文件提交到项目的settings/pages里设置的相应分支和目录下，github会自动发布该目录下的内容。\n\n * 使用自定义工作流github workflow自动构建和发布\n   \n   1、首先需要在默认分支下的根目录下创建一个.github/workflow目录，然后在该目录下创建一个.yml后缀名格式的文件。\n   \n   \n   \n   2、编写build-deploy.yml actions脚本\n   \n   \n   \n   该脚本会在git\n   push后，在github的actions选项页里触发自动编译和部署，可以在actions页里查看编译和发布历史。检查编译和发布是否成功。","routePath":"/blog/github-pages-hosting","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"开始","id":"开始","depth":2,"charIndex":269},{"text":"1、启用github pages","id":"1启用github-pages","depth":3,"charIndex":275},{"text":"2、使用jekyll框架","id":"2使用jekyll框架","depth":3,"charIndex":391},{"text":"发布","id":"发布","depth":2,"charIndex":582}],"domain":"","frontmatter":{"title":"Github pages托管网页","date":"2025-04-18T03:20:33.000Z","categories":["docs","website"],"tags":["github pages","hosting","web"],"image":"https://api.vvhan.com/api/bing?rand=sj&t=1744977060652"},"version":""},{"id":27,"title":"","content":"Rhino的名字来源于O'Reilly关于JavaScript的书封面上的动物。\n\nRhino项目于1997年秋天在Netscape启动。当时，Netscape计划生产一个完全用Java编写的Navigator版本，因此它需要一个用Java编写\n的JavaScript的实现。当Netscape停止开发所谓的“Javagator”时，Rhino不知何故逃脱了斧头（有传言称高管们“忘记”了它的存在）。有一段\n时间，几家大公司（包括Sun）授权Rhino在他们的产品中使用，并向Netscape支付费用，允许Rhino的工作继续进行。现在Rhino是Mozilla开源存\n储库的一部分。\n\n最初，Rhino编译所有JavaScript代码以在生成的类文件中Java字节码。这产生了最好的性能（当在JIT上运行时，通常会击败JavaScript的C实现\n），但有两个错误。首先，编译时间很长，因为生成Java字节码和加载生成的类是一个重量级的过程。此外，由于大多数JVM并没有真正收集未使用的类或由于加载类文件而被\n插入的字符串，因此实现实际上泄露了内存。\n\n因此在1998年秋天，Rhino添加了一种解释模式。类文件生成代码被移动到一个可选的、动态加载的包中。编译速度更快，当脚本不再使用时，它们可以像任何其他Java\n对象一样被收集。\n\nRhino于1998年4月发布到mozilla.org。最初Rhino类文件生成被推迟发布。然而，Rhino的被许可人现在同意将所有Rhino发布到开源，包括类\n文件生成。自开源发布以来，Rhino发现了多种用途，并且越来越多的人为代码做出了贡献。","routePath":"/blog/rhino","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode block#\n\n\nBasic usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow line numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use component","id":"use-component","depth":2,"charIndex":198},{"text":"Front matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show line numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1712}],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""}]